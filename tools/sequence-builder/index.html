<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Celli Sequence Builder - Unified</title>
  
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #1a1a1a;
      color: #e0e0e0;
      overflow: hidden;
    }

    /* Overlay Mode */
    .builder-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.95);
      z-index: 10000;
      display: none;
      animation: fadeIn 0.3s ease-out;
    }

    .builder-overlay.active {
      display: flex;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    /* Main Container - Resizable Grid */
    .builder-container {
      display: grid;
      grid-template-columns: 280px 1fr 360px minmax(400px, 1fr);
      grid-template-rows: 60px 1fr 180px;
      height: 100vh;
      width: 100vw;
      gap: 0;
      position: relative;
      overflow: hidden;
      --builder-header-height: 60px;
      --builder-bottom-height: 180px;
    }

    /* Resizer Handles */
    .resize-handle {
      position: absolute;
      background: #3498db;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 1000;
      cursor: col-resize;
      pointer-events: auto;
      top: var(--builder-header-height);
      bottom: var(--builder-bottom-height);
      box-shadow: 0 0 12px rgba(52, 152, 219, 0.45);
    }

    .resize-handle:hover,
    .resize-handle.active,
    .builder-container:hover .resize-handle {
      opacity: 0.3;
    }
    
    .resize-handle.active {
      opacity: 0.6 !important;
    }

    .resize-handle-1,
    .resize-handle-2,
    .resize-handle-3 {
      width: 4px;
      margin-left: -2px;
    }

    .resize-handle-vertical {
      left: 0;
      right: 0;
      height: 4px;
      cursor: row-resize;
      background: linear-gradient(90deg, rgba(52, 152, 219, 0.15) 0%, rgba(52, 152, 219, 0.7) 50%, rgba(52, 152, 219, 0.15) 100%);
      box-shadow: 0 0 14px rgba(52, 152, 219, 0.35);
    }

    .resize-handle-bottom {
      bottom: var(--builder-bottom-height);
      margin-bottom: -2px;
    }

    /* ===== HEADER ===== */
    .builder-header {
      grid-column: 1 / -1;
      background: linear-gradient(135deg, #2c3e50 0%, #1a252f 100%);
      border-bottom: 2px solid #34495e;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 20px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
      width: 100%;
      box-sizing: border-box;
    }

    .builder-title {
      font-size: 20px;
      font-weight: 600;
      color: #ecf0f1;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .scene-badge {
      background: #3498db;
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 0.5px;
    }

    .builder-controls {
      display: flex;
      gap: 8px;
    }

    .btn {
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .btn-primary { background: #3498db; color: white; }
    .btn-primary:hover { background: #2980b9; transform: translateY(-1px); }
    .btn-success { background: #27ae60; color: white; }
    .btn-success:hover { background: #229954; }
    .btn-danger { background: #e74c3c; color: white; }
    .btn-danger:hover { background: #c0392b; }
    .btn-secondary { background: #7f8c8d; color: white; }
    .btn-secondary:hover { background: #5d6d6e; }

    /* ===== LEFT PANEL - ASSET MANAGER ===== */
    .panel-left {
      background: #2c2c2c;
      border-right: 1px solid #444;
      overflow-y: auto;
      padding: 15px;
      grid-column: 1;
      grid-row: 2;
      width: 100%;
      height: 100%;
      box-sizing: border-box;
    }

    .asset-manager-header {
      background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
      padding: 12px;
      border-radius: 8px;
      margin-bottom: 15px;
      border: 1px solid #445566;
    }

    .asset-manager-title {
      font-size: 14px;
      font-weight: 700;
      color: #3498db;
      margin-bottom: 8px;
    }

    .asset-stats {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      font-size: 10px;
      color: #bdc3c7;
    }

    .stat-item {
      background: rgba(52, 152, 219, 0.1);
      padding: 6px;
      border-radius: 4px;
      text-align: center;
    }

    .stat-value {
      font-size: 16px;
      font-weight: 700;
      color: #3498db;
      display: block;
    }

    /* Expandable Asset Groups */
    .asset-group {
      margin-bottom: 12px;
      background: #353535;
      border-radius: 6px;
      overflow: hidden;
      border: 1px solid #444;
    }

    .asset-group-header {
      padding: 10px 12px;
      background: #2a2a2a;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      transition: background 0.2s;
      user-select: none;
    }

    .asset-group-header:hover {
      background: #333;
    }

    .asset-group-header.active {
      background: #2c3e50;
    }

    .asset-group-title {
      font-size: 12px;
      font-weight: 700;
      color: #e0e0e0;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .asset-count {
      background: #3498db;
      color: white;
      padding: 2px 8px;
      border-radius: 10px;
      font-size: 10px;
      font-weight: 700;
    }

    .expand-icon {
      font-size: 12px;
      transition: transform 0.2s;
      color: #999;
    }

    .asset-group-header.active .expand-icon {
      transform: rotate(90deg);
    }

    .asset-group-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease-out;
    }

    .asset-group-content.expanded {
      max-height: 600px;
      overflow-y: auto;
    }

    .asset-item {
      padding: 8px 12px;
      margin: 4px 8px;
      background: #2a2a2a;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 11px;
      border-left: 3px solid transparent;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .asset-item:hover {
      background: #404040;
      border-left-color: #3498db;
      transform: translateX(4px);
    }

    .asset-item.selected {
      background: #2c3e50;
      border-left-color: #3498db;
    }

    .asset-name {
      font-weight: 600;
      color: #e0e0e0;
    }

    .asset-type {
      font-size: 9px;
      padding: 2px 6px;
      border-radius: 3px;
      font-weight: 700;
      text-transform: uppercase;
    }

    .type-component { background: #9b59b6; color: white; }
    .type-style { background: #e74c3c; color: white; }
    .type-function { background: #f39c12; color: white; }
    .type-variable { background: #16a085; color: white; }
    .type-import { background: #34495e; color: white; }

    /* ===== CENTER LEFT - SCENE VIEWPORT ===== */
    .panel-viewport {
      background: #1e1e1e;
      display: flex;
      flex-direction: column;
      grid-column: 2;
      grid-row: 2;
      border-right: 1px solid #444;
      position: relative;
      overflow: hidden;
      width: 100%;
      height: 100%;
      box-sizing: border-box;
    }

    .viewport-header {
      background: #252525;
      padding: 10px 15px;
      border-bottom: 1px solid #333;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .viewport-title {
      font-size: 13px;
      font-weight: 600;
      color: #3498db;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .viewport-controls {
      display: flex;
      gap: 6px;
      align-items: center;
      flex-wrap: wrap;
    }

    .viewport-btn {
      padding: 4px 10px;
      background: #353535;
      border: 1px solid #555;
      border-radius: 4px;
      color: #e0e0e0;
      cursor: pointer;
      font-size: 11px;
      transition: all 0.2s;
    }

    .viewport-btn:hover {
      background: #404040;
      border-color: #3498db;
    }

    .viewport-btn.active {
      background: #3498db;
      border-color: #5dade2;
      color: white;
    }
    
    .camera-select {
      padding: 4px 8px;
      background: #353535;
      border: 1px solid #555;
      border-radius: 4px;
      color: #e0e0e0;
      cursor: pointer;
      font-size: 11px;
      min-width: 100px;
    }
    
    .camera-select:focus {
      outline: none;
      border-color: #3498db;
    }
    
    .playback-controls {
      display: flex;
      gap: 4px;
      margin-left: 8px;
      padding-left: 8px;
      border-left: 1px solid #555;
    }
    
    .play-btn {
      padding: 4px 8px;
      background: #27ae60;
      border: 1px solid #2ecc71;
      border-radius: 4px;
      color: white;
      cursor: pointer;
      font-size: 11px;
      font-weight: 600;
      transition: all 0.2s;
    }
    
    .play-btn:hover {
      background: #229954;
    }
    
    .play-btn.paused {
      background: #3498db;
      border-color: #5dade2;
    }
    
    .pause-btn {
      padding: 4px 8px;
      background: #e74c3c;
      border: 1px solid #ec7063;
      border-radius: 4px;
      color: white;
      cursor: pointer;
      font-size: 11px;
      font-weight: 600;
      transition: all 0.2s;
    }
    
    .pause-btn:hover {
      background: #c0392b;
    }

    #sceneViewport {
      flex: 1;
      position: relative;
      background: #0a0a0a;
    }

    #sceneCanvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .viewport-overlay {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.8);
      padding: 10px;
      border-radius: 6px;
      font-size: 11px;
      font-family: 'Consolas', monospace;
      color: #3498db;
      pointer-events: none;
    }

    /* ===== CENTER RIGHT - TIMELINE/DIALOGUE ===== */
    .panel-center {
      background: #1e1e1e;
      display: flex;
      flex-direction: column;
      grid-column: 3;
      grid-row: 2;
      border-right: 1px solid #444;
      width: 100%;
      height: 100%;
      box-sizing: border-box;
    }

    .center-tabs {
      background: #252525;
      border-bottom: 1px solid #333;
      display: flex;
      gap: 2px;
      padding: 0 10px;
    }

    .tab-btn {
      padding: 10px 20px;
      background: transparent;
      border: none;
      color: #999;
      cursor: pointer;
      font-size: 12px;
      font-weight: 600;
      border-bottom: 3px solid transparent;
      transition: all 0.2s;
    }

    .tab-btn:hover {
      color: #e0e0e0;
      background: rgba(255,255,255,0.05);
    }

    .tab-btn.active {
      color: #3498db;
      border-bottom-color: #3498db;
    }

    .tab-content {
      flex: 1;
      overflow: hidden;
      display: none;
    }

    .tab-content.active {
      display: flex;
      flex-direction: column;
    }

    /* Timeline - Node Canvas */
    .timeline-container {
      flex: 1;
      position: relative;
      overflow: auto;
      padding: 0;
      background: #1e1e1e;
    }
    
    #nodeCanvas {
      position: relative;
      min-width: 3000px;
      min-height: 2000px;
      background-image: 
        linear-gradient(rgba(255,255,255,0.03) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255,255,255,0.03) 1px, transparent 1px);
      background-size: 20px 20px;
      cursor: grab;
    }
    
    #nodeCanvas.dragging {
      cursor: grabbing;
    }
    
    #connectionsSvg {
      position: absolute;
      top: 0;
      left: 0;
      width: 3000px;
      height: 2000px;
      pointer-events: none;
      z-index: 1;
      overflow: visible;
    }

    .graph-node {
      position: absolute;
      background: #252526;
      border: 2px solid #3e3e42;
      border-radius: 6px;
      min-width: 180px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
      cursor: move;
      user-select: none;
      z-index: 2;
    }

    .graph-node.selected {
      border-color: #3498db;
      box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.3);
    }

    .graph-node-header {
      padding: 8px 12px;
      background: #2d2d30;
      border-bottom: 1px solid #3e3e42;
      font-size: 12px;
      font-weight: 600;
      border-radius: 4px 4px 0 0;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .graph-node-title {
      display: flex;
      align-items: center;
      gap: 6px;
      flex: 1;
      color: #e0e0e0;
    }

    .node-type-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .graph-node-actions {
      display: flex;
      gap: 4px;
    }

    .node-action-btn {
      width: 16px;
      height: 16px;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      font-size: 10px;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0.7;
      transition: opacity 0.2s;
      padding: 0;
    }

    .node-action-btn:hover {
      opacity: 1;
    }

    .node-copy-btn {
      background: #27ae60;
    }

    .node-delete-btn {
      background: #e74c3c;
    }

    .graph-node-body {
      padding: 10px 12px;
      font-size: 11px;
      color: #ccc;
    }

    .node-socket {
      position: absolute;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 2px solid #3e3e42;
      cursor: pointer;
      transition: all 0.2s;
      z-index: 10;
    }

    .node-socket:hover {
      transform: scale(1.4);
      border-color: #fff;
    }

    .node-socket.input {
      left: -6px;
      background: #4a9eff;
    }

    .node-socket.output {
      right: -6px;
      background: #ff6b6b;
    }

    .socket-label {
      position: absolute;
      font-size: 10px;
      color: #999;
      white-space: nowrap;
      top: 50%;
      transform: translateY(-50%);
      pointer-events: none;
      font-weight: 500;
    }

    .node-socket.input .socket-label {
      left: 18px;
    }

    .node-socket.output .socket-label {
      right: 18px;
    }

    .node-connection {
      stroke-width: 2;
      fill: none;
      stroke: #4a9eff;
      opacity: 0.7;
      pointer-events: stroke;
      cursor: pointer;
    }

    .node-connection:hover {
      opacity: 1;
      stroke-width: 3;
    }

    .temp-connection {
      stroke: #4a9eff;
      stroke-width: 2;
      fill: none;
      stroke-dasharray: 5, 5;
      opacity: 0.5;
      pointer-events: none;
    }
    
    /* Node type colors - organized by category */
    
    /* Dialogue nodes - Red/Magenta */
    .graph-node.type-dialogue {
      background: linear-gradient(135deg, #6d1138 0%, #1a1a1a 100%);
      border-color: #c2185b;
    }
    .graph-node.type-dialogue .graph-node-header {
      background: #4a0d28;
      border-bottom-color: #6d1138;
    }
    .graph-node.type-dialogue .node-type-indicator {
      background: #e91e63;
      box-shadow: 0 0 8px rgba(233, 30, 99, 0.6);
    }
    .graph-node.type-dialogue.selected {
      border-color: #e91e63;
      box-shadow: 0 0 0 2px rgba(233, 30, 99, 0.4);
    }
    
    /* Object nodes - Blue */
    .graph-node.type-object {
      background: linear-gradient(135deg, #0d3a5c 0%, #1a1a1a 100%);
      border-color: #1565c0;
    }
    .graph-node.type-object .graph-node-header {
      background: #082540;
      border-bottom-color: #0d3a5c;
    }
    .graph-node.type-object .node-type-indicator {
      background: #2196f3;
      box-shadow: 0 0 8px rgba(33, 150, 243, 0.6);
    }
    .graph-node.type-object.selected {
      border-color: #2196f3;
      box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.4);
    }
    
    /* Parameter nodes - Cyan */
    .graph-node.type-parameter {
      background: linear-gradient(135deg, #0d4d4d 0%, #1a1a1a 100%);
      border-color: #00bcd4;
    }
    .graph-node.type-parameter .graph-node-header {
      background: #083838;
      border-bottom-color: #0d4d4d;
    }
    .graph-node.type-parameter .node-type-indicator {
      background: #00e5ff;
      box-shadow: 0 0 8px rgba(0, 229, 255, 0.6);
    }
    .graph-node.type-parameter.selected {
      border-color: #00e5ff;
      box-shadow: 0 0 0 2px rgba(0, 229, 255, 0.4);
    }
    
    /* Animation/Transition nodes - Yellow */
    .graph-node.type-transition,
    .graph-node.type-animation {
      background: linear-gradient(135deg, #7d4a0b 0%, #1a1a1a 100%);
      border-color: #f57f17;
    }
    .graph-node.type-transition .graph-node-header,
    .graph-node.type-animation .graph-node-header {
      background: #5c3508;
      border-bottom-color: #7d4a0b;
    }
    .graph-node.type-transition .node-type-indicator,
    .graph-node.type-animation .node-type-indicator {
      background: #ffc107;
      box-shadow: 0 0 8px rgba(255, 193, 7, 0.6);
    }
    .graph-node.type-transition.selected,
    .graph-node.type-animation.selected {
      border-color: #ffc107;
      box-shadow: 0 0 0 2px rgba(255, 193, 7, 0.4);
    }
    
    /* Event nodes - Orange */
    .graph-node.type-event {
      background: linear-gradient(135deg, #7d3a0b 0%, #1a1a1a 100%);
      border-color: #ff6f00;
    }
    .graph-node.type-event .graph-node-header {
      background: #5c2a08;
      border-bottom-color: #7d3a0b;
    }
    .graph-node.type-event .node-type-indicator {
      background: #ff9800;
      box-shadow: 0 0 8px rgba(255, 152, 0, 0.6);
    }
    .graph-node.type-event.selected {
      border-color: #ff9800;
      box-shadow: 0 0 0 2px rgba(255, 152, 0, 0.4);
    }
    
    /* Delay nodes - Yellow */
    .graph-node.type-delay {
      background: linear-gradient(135deg, #7d4a0b 0%, #1a1a1a 100%);
      border-color: #f57f17;
    }
    .graph-node.type-delay .graph-node-header {
      background: #5c3508;
      border-bottom-color: #7d4a0b;
    }
    .graph-node.type-delay .graph-node-title {
      color: #e0e0e0;
    }
    .graph-node.type-delay .graph-node-body {
      color: #e0e0e0;
    }
    .graph-node.type-delay .node-type-indicator {
      background: #ffc107;
      box-shadow: 0 0 8px rgba(255, 193, 7, 0.6);
    }
    .graph-node.type-delay.selected {
      border-color: #ffc107;
      box-shadow: 0 0 0 2px rgba(255, 193, 7, 0.4);
    }
    
    /* Snapshot/Parallel nodes - Purple */
    .graph-node.type-snapshot,
    .graph-node.type-parallel {
      background: linear-gradient(135deg, #4a0d5c 0%, #1a1a1a 100%);
      border-color: #9c27b0;
    }
    .graph-node.type-snapshot .graph-node-header,
    .graph-node.type-parallel .graph-node-header {
      background: #380840;
      border-bottom-color: #4a0d5c;
    }
    .graph-node.type-snapshot .graph-node-title,
    .graph-node.type-parallel .graph-node-title {
      color: #e0e0e0;
    }
    .graph-node.type-snapshot .graph-node-body,
    .graph-node.type-parallel .graph-node-body {
      color: #e0e0e0;
    }
    .graph-node.type-snapshot .node-type-indicator,
    .graph-node.type-parallel .node-type-indicator {
      background: #ba68c8;
      box-shadow: 0 0 8px rgba(186, 104, 200, 0.6);
    }
    .graph-node.type-snapshot.selected,
    .graph-node.type-parallel.selected {
      border-color: #ba68c8;
      box-shadow: 0 0 0 2px rgba(186, 104, 200, 0.4);
    }
    
    /* Parallel output management */
    .parallel-outputs {
      margin-top: 8px;
      padding: 8px;
      background: rgba(156, 39, 176, 0.1);
      border-radius: 4px;
    }
    
    .parallel-output-btn {
      padding: 4px 8px;
      margin: 2px;
      background: #9c27b0;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      font-size: 10px;
    }
    
    .parallel-output-btn:hover {
      background: #7b1fa2;
    }
    
    /* Execute After Panel */
    .execute-after-panel {
      margin-top: 16px;
      padding: 12px;
      background: #2a2a2f;
      border-radius: 6px;
      border: 1px solid #444;
    }
    
    .execute-after-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      cursor: pointer;
      user-select: none;
    }
    
    .execute-after-title {
      font-size: 12px;
      font-weight: 600;
      color: #3498db;
    }
    
    .execute-after-toggle {
      font-size: 10px;
      color: #999;
    }
    
    .execute-after-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease-out;
    }
    
    .execute-after-content.expanded {
      max-height: 400px;
      overflow-y: auto;
    }
    
    .execute-after-controls {
      display: flex;
      gap: 6px;
      margin-bottom: 8px;
    }
    
    .execute-after-btn {
      padding: 4px 10px;
      background: #3498db;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 10px;
      font-weight: 600;
    }
    
    .execute-after-btn:hover {
      background: #2980b9;
    }
    
    .execute-after-btn.secondary {
      background: #7f8c8d;
    }
    
    .execute-after-btn.secondary:hover {
      background: #5d6d6e;
    }
    
    .execute-after-hierarchy {
      margin-top: 8px;
    }
    
    .execute-after-node {
      padding: 6px 8px;
      margin: 3px 0;
      background: #353535;
      border-radius: 4px;
      border-left: 3px solid #3498db;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 11px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .execute-after-node:hover {
      background: #404040;
      transform: translateX(2px);
    }
    
    .execute-after-node.checked {
      background: #2c3e50;
      border-left-color: #27ae60;
    }
    
    .execute-after-checkbox {
      width: 14px;
      height: 14px;
      cursor: pointer;
    }
    
    .execute-after-node-title {
      flex: 1;
      color: #e0e0e0;
    }
    
    .execute-after-node-type {
      font-size: 9px;
      padding: 2px 6px;
      background: rgba(52, 152, 219, 0.2);
      border-radius: 3px;
      color: #3498db;
    }
    
    .execute-after-node.depth-1 { padding-left: 20px; }
    .execute-after-node.depth-2 { padding-left: 36px; }
    .execute-after-node.depth-3 { padding-left: 52px; }

    /* Dialogue System */
    .dialogue-workspace {
      flex: 1;
      padding: 15px;
      overflow-y: auto;
    }

    .dialogue-controls {
      background: #252525;
      padding: 12px;
      border-bottom: 1px solid #333;
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    .dialogue-cards-container {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
      gap: 12px;
    }

    .dialogue-card {
      background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
      border: 1px solid #445566;
      border-radius: 8px;
      padding: 12px;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }

    .dialogue-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 20px rgba(52, 152, 219, 0.3);
      border-color: #3498db;
    }

    .dialogue-card.selected {
      border-color: #3498db;
      box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.4);
    }

    .dialogue-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .dialogue-speaker {
      font-size: 12px;
      font-weight: 700;
      color: #3498db;
    }

    .dialogue-actions {
      display: flex;
      gap: 4px;
    }

    .icon-btn {
      padding: 3px 6px;
      background: rgba(255,255,255,0.1);
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
      transition: all 0.2s;
    }

    .icon-btn:hover {
      background: rgba(255,255,255,0.2);
    }

    .dialogue-text {
      font-size: 11px;
      line-height: 1.5;
      color: #e0e0e0;
      min-height: 50px;
      max-height: 80px;
      overflow-y: auto;
    }

    .dialogue-meta {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid rgba(255,255,255,0.1);
      font-size: 9px;
      color: #999;
      display: flex;
      justify-content: space-between;
    }

    .dialogue-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-top: 6px;
    }

    .dialogue-tag {
      background: rgba(52, 152, 219, 0.18);
      border: 1px solid rgba(52, 152, 219, 0.35);
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 9px;
      letter-spacing: 0.3px;
      color: #d0e8ff;
      text-transform: uppercase;
    }

    .display-target {
      padding: 2px 6px;
      background: #27ae60;
      color: white;
      border-radius: 10px;
      font-size: 8px;
      font-weight: 700;
    }

    /* Node Tools Panel */
    .node-tool-btn {
      width: 100%;
      padding: 8px 12px;
      margin-bottom: 6px;
      background: #37373d;
      border: 1px solid #555;
      border-radius: 4px;
      color: #e0e0e0;
      cursor: pointer;
      font-size: 11px;
      text-align: left;
      transition: all 0.2s;
      display: block;
    }

    .node-tool-btn:hover {
      background: #404045;
      border-color: #3498db;
      transform: translateX(4px);
    }

    .node-tool-btn:active {
      transform: scale(0.98);
    }

    /* Enhanced Scene Entity Styles */
    .scene-entity {
      padding: 8px 10px;
      margin: 4px 8px;
      background: #2a2a2a;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 11px;
      border-left: 3px solid #555;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .scene-entity:hover {
      background: #404040;
      border-left-color: #3498db;
      transform: translateX(4px);
    }

    .entity-name {
      display: flex;
      align-items: center;
      gap: 6px;
      color: #e0e0e0;
      font-weight: 600;
    }

    .entity-icon {
      font-size: 14px;
    }

    .entity-actions {
      display: flex;
      gap: 4px;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .scene-entity:hover .entity-actions {
      opacity: 1;
    }

    .entity-btn {
      padding: 2px 6px;
      background: #3498db;
      border: none;
      border-radius: 2px;
      color: white;
      font-size: 9px;
      cursor: pointer;
      transition: background 0.2s;
      font-weight: 600;
    }

    .entity-btn:hover {
      background: #2980b9;
    }

    .entity-btn.ingest-all {
      background: #27ae60;
    }

    .entity-btn.ingest-all:hover {
      background: #229954;
    }

    .entity-part {
      padding: 6px 10px;
      margin: 2px 8px 2px 24px;
      background: #252526;
      border-radius: 3px;
      font-size: 10px;
      color: #999;
      border-left: 2px solid #666;
      cursor: pointer;
      transition: all 0.2s;
    }

    .entity-part:hover {
      background: #2d2d30;
      color: #e0e0e0;
      border-left-color: #3498db;
    }

    /* Dialogue Display Mode Controls */
    .dialogue-display-mode {
      margin-top: 10px;
      padding: 10px;
      background: #252526;
      border-radius: 4px;
      border-top: 1px solid #3e3e42;
    }

    .mode-label {
      font-size: 10px;
      color: #999;
      margin-bottom: 6px;
      display: block;
      font-weight: 600;
    }

    .mode-options {
      display: flex;
      gap: 4px;
      margin-bottom: 8px;
    }

    .mode-option-btn {
      flex: 1;
      padding: 6px;
      background: #37373d;
      border: 1px solid #555;
      border-radius: 3px;
      color: #ccc;
      font-size: 10px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .mode-option-btn:hover {
      background: #404045;
    }

    .mode-option-btn.active {
      background: #3498db;
      border-color: #3498db;
      color: white;
      font-weight: 600;
    }

    /* ===== RIGHT PANEL - INSPECTOR ===== */
    .panel-right {
      background: #2c2c2c;
      overflow-y: auto;
      padding: 15px;
      grid-column: 4;
      grid-row: 2;
      width: 100%;
      height: 100%;
    }

    .inspector-section {
      background: #353535;
      padding: 12px;
      margin-bottom: 12px;
      border-radius: 6px;
      border: 1px solid #444;
    }

    .inspector-section-title {
      font-size: 13px;
      font-weight: 600;
      color: #3498db;
      margin-bottom: 10px;
      padding-bottom: 6px;
      border-bottom: 1px solid #444;
    }

    .prop-preview-wrapper {
      display: flex;
      flex-direction: column;
      gap: 10px;
      position: relative;
    }

    .prop-preview-canvas {
      width: 100%;
      height: 220px;
      background: radial-gradient(circle at 30% 30%, rgba(80, 80, 80, 0.6), rgba(10, 10, 10, 0.9));
      border-radius: 8px;
      border: 1px solid #3e3e3e;
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.6);
      cursor: grab;
    }

    .prop-preview-resizer {
      height: 6px;
      border-radius: 3px;
      background: rgba(52, 152, 219, 0.25);
      border: 1px solid rgba(52, 152, 219, 0.45);
      cursor: ns-resize;
      transition: background 0.2s;
      position: relative;
    }

    .prop-preview-resizer::after {
      content: '';
      position: absolute;
      left: 50%;
      top: 50%;
      width: 30px;
      height: 2px;
      border-radius: 2px;
      background: rgba(255, 255, 255, 0.35);
      transform: translate(-50%, -50%);
      box-shadow: 0 0 8px rgba(52, 152, 219, 0.4);
    }

    .prop-preview-resizer:hover {
      background: rgba(52, 152, 219, 0.45);
    }

    .prop-preview-meta {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 11px;
      color: #d0d0d0;
    }

    .prop-preview-meta strong {
      font-size: 12px;
      letter-spacing: 0.4px;
      color: #ffffff;
    }

    .prop-preview-description {
      line-height: 1.4;
      color: #b5c2cf;
    }

    .prop-preview-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }

    .prop-tag {
      background: rgba(52, 152, 219, 0.15);
      border: 1px solid rgba(52, 152, 219, 0.35);
      color: #8cd3ff;
      padding: 2px 6px;
      border-radius: 10px;
      font-size: 10px;
      letter-spacing: 0.4px;
      text-transform: uppercase;
    }

    .property-group {
      margin-bottom: 12px;
    }

    .property-label {
      font-size: 11px;
      font-weight: 600;
      color: #999;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 6px;
    }

    .property-input {
      width: 100%;
      padding: 8px 10px;
      background: #2a2a2a;
      border: 1px solid #555;
      border-radius: 4px;
      color: #e0e0e0;
      font-size: 12px;
      font-family: 'Consolas', 'Monaco', monospace;
    }

    .property-input:focus {
      outline: none;
      border-color: #3498db;
      background: #333;
    }

    textarea.property-input {
      resize: vertical;
      min-height: 80px;
      font-family: 'Segoe UI', sans-serif;
    }

    /* ===== BOTTOM PANEL - CODE PREVIEW ===== */
    .panel-bottom {
      grid-column: 1 / -1;
      background: #1a1a1a;
      border-top: 2px solid #444;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      width: 100%;
      box-sizing: border-box;
    }

    .code-preview-header {
      background: #252525;
      padding: 8px 15px;
      border-bottom: 1px solid #333;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .code-preview-title {
      font-size: 12px;
      font-weight: 600;
      color: #999;
    }

    .code-preview-content {
      flex: 1;
      overflow: auto;
      padding: 15px;
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 11px;
      line-height: 1.6;
      background: #1a1a1a;
      color: #d4d4d4;
    }

    .code-keyword { color: #569cd6; }
    .code-string { color: #ce9178; }
    .code-number { color: #b5cea8; }
    .code-comment { color: #6a9955; font-style: italic; }
    .code-function { color: #dcdcaa; }

    /* Loading Overlay */
    .loading-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
    }

    .loading-content {
      text-align: center;
      color: #3498db;
    }

    .loading-spinner {
      width: 50px;
      height: 50px;
      border: 4px solid #444;
      border-top-color: #3498db;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .loading-text {
      font-size: 16px;
      font-weight: 600;
    }

    .loading-detail {
      font-size: 12px;
      color: #999;
      margin-top: 8px;
    }

    /* Video Player Overlay */
    .video-player-overlay {
      position: fixed;
      inset: 0;
      background: #000;
      z-index: 20000;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .video-player-overlay.active {
      display: flex;
    }

    .video-container {
      position: relative;
      width: 90vw;
      height: 90vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .video-canvas {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }

    .video-controls {
      position: absolute;
      bottom: 20px;
      right: 20px;
      display: flex;
      gap: 10px;
    }

    .video-close-btn {
      padding: 10px 20px;
      background: #e74c3c;
      border: none;
      border-radius: 6px;
      color: white;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.2s;
    }

    .video-close-btn:hover {
      background: #c0392b;
    }

    /* Scrollbar Styling */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: #1a1a1a;
    }

    ::-webkit-scrollbar-thumb {
      background: #555;
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #666;
    }
  </style>
</head>
<body>
  <!-- Overlay Mode Container -->
  <div class="builder-overlay" id="builderOverlay">
    <div class="builder-container" id="builderContainer">
      
      <!-- Resize Handles -->
      <div class="resize-handle resize-handle-1" data-handle="1"></div>
      <div class="resize-handle resize-handle-2" data-handle="2"></div>
      <div class="resize-handle resize-handle-3" data-handle="3"></div>
      <div class="resize-handle resize-handle-vertical resize-handle-bottom" data-handle="bottom"></div>
      
      <!-- Header -->
      <div class="builder-header">
        <div class="builder-title">
          <span>🎬</span>
          <span>Sequence Builder</span>
          <span class="scene-badge" id="sceneName">Loading...</span>
        </div>
        <div class="builder-controls">
          <select id="sceneDropdown" class="property-input" style="width: 180px; padding: 8px; font-size: 12px; margin-right: 8px;">
            <option value="">Current Scene</option>
            <option value="IntroSceneComplete">Intro Scene</option>
            <option value="VisiCalcScene">VisiCalc</option>
            <option value="CelliRealScene">Celli Real</option>
            <option value="FullhandScene">Fullhand</option>
            <option value="End3Scene">End3</option>
            <option value="CityScene">City</option>
            <option value="LeaveScene">Leave</option>
          </select>
          <button class="btn btn-primary" id="switchSceneBtn">🔄 Switch</button>
          <button class="btn btn-success" id="autoIngestBtn">📥 Ingest</button>
          <button class="btn btn-primary" id="playIntroBtn">🎬 Intro</button>
          <button class="btn btn-primary" id="analyzeBtn">🔍 Analyze</button>
          <button class="btn btn-success" id="exportBtn">💾 Export</button>
          <button class="btn btn-secondary" id="importBtn">📂 Import</button>
          <button class="btn btn-danger" id="closeBtn">✕ Close</button>
        </div>
      </div>

      <!-- Left Panel - Scene Manager & Node Tools -->
      <div class="panel-left">
        <div class="asset-manager-header">
          <div class="asset-manager-title">🎬 Scene Manager</div>
          <div class="asset-stats">
            <div class="stat-item">
              <span class="stat-value" id="totalEntities">0</span>
              <span>Entities</span>
            </div>
            <div class="stat-item">
              <span class="stat-value" id="totalComponents">0</span>
              <span>Components</span>
            </div>
          </div>
        </div>
        <div id="sceneManagerContainer"></div>
        
        <div class="asset-manager-header" style="margin-top: 15px;">
          <div class="asset-manager-title">🛠️ Node Tools Panel</div>
        </div>
        <div id="nodeToolsPanel" style="padding: 10px;">
          <button class="node-tool-btn" data-node-type="dialogue">💬 Dialogue</button>
          <button class="node-tool-btn" data-node-type="animation">🎬 Animation</button>
          <button class="node-tool-btn" data-node-type="delay">⏱️ Delay</button>
          <button class="node-tool-btn" data-node-type="transition">🔄 Transition</button>
          <button class="node-tool-btn" data-node-type="parameter">📊 Parameter</button>
          <button class="node-tool-btn" data-node-type="event">⚡ Event</button>
          <button class="node-tool-btn" data-node-type="object">🎯 Object</button>
          <button class="node-tool-btn" data-node-type="snapshot">📸 Snapshot</button>
          <button class="node-tool-btn" data-node-type="parallel">⚡ Parallel</button>
        </div>
      </div>

      <!-- Center Left - Scene Viewport -->
      <div class="panel-viewport">
        <div class="viewport-header">
          <div class="viewport-title">
            <span>🎥</span>
            <span>Scene Viewport</span>
          </div>
          <div class="viewport-controls">
            <button class="viewport-btn active" id="viewRenderBtn" data-mode="render">Render</button>
            <button class="viewport-btn" id="viewWireframeBtn" data-mode="wireframe">Wireframe</button>
            <button class="viewport-btn" id="viewUnlitBtn" data-mode="unlit">Unlit</button>
            <button class="viewport-btn" id="viewFlatBtn" data-mode="flat">Flat Light</button>
            <button class="viewport-btn" id="viewResetBtn">Reset</button>
            <select class="camera-select" id="cameraSelect">
              <option value="viewport">Viewport Camera</option>
            </select>
            <div class="playback-controls">
              <button class="play-btn" id="playSceneBtn">▶ Play</button>
              <button class="pause-btn" id="pauseSceneBtn">⏸ Pause</button>
            </div>
          </div>
        </div>
        <div id="sceneViewport">
          <canvas id="sceneCanvas"></canvas>
          <div class="viewport-overlay" id="viewportOverlay">
            <div>FPS: <span id="fpsCounter">60</span></div>
            <div>Objects: <span id="objectCount">0</span></div>
            <div>Tris: <span id="triCount">0</span></div>
          </div>
        </div>
      </div>

      <!-- Center Right - Timeline & Dialogue -->
      <div class="panel-center">
        <div class="center-tabs">
          <button class="tab-btn active" data-tab="timeline">⏱️ Timeline</button>
          <button class="tab-btn" data-tab="dialogue">💬 Dialogue</button>
        </div>

        <!-- Timeline Tab -->
        <div class="tab-content active" id="timeline-tab">
          <div class="timeline-container" id="timelineContainer">
            <div id="nodeCanvas">
              <svg id="connectionsSvg"></svg>
              <div id="nodesContainer"></div>
            </div>
          </div>
        </div>

        <!-- Dialogue Tab -->
        <div class="tab-content" id="dialogue-tab">
          <div class="dialogue-controls">
            <button class="btn btn-primary" id="addDialogueBtn" style="padding: 6px 12px; font-size: 11px;">➕ Add</button>
            <button class="btn btn-secondary" id="castToDisplayBtn" style="padding: 6px 12px; font-size: 11px;">📺 Cast</button>
            <select class="property-input" id="displaySelect" style="width: auto; padding: 4px 8px; font-size: 11px;">
              <option value="terminal">Terminal</option>
              <option value="notepad">Notepad</option>
              <option value="subtitle">Subtitle</option>
              <option value="popup">Popup</option>
            </select>
          </div>
          <div class="dialogue-workspace">
            <div class="dialogue-cards-container" id="dialogueCardsContainer">
            </div>
          </div>
        </div>
      </div>

      <!-- Right Panel - Inspector -->
      <div class="panel-right">
        <div class="inspector-section">
          <div class="inspector-section-title">🎭 Prop Preview</div>
          <div class="prop-preview-wrapper">
            <canvas id="propPreviewCanvas" class="prop-preview-canvas"></canvas>
            <div class="prop-preview-resizer" id="propPreviewResizer"></div>
            <div class="prop-preview-meta">
              <strong id="propPreviewTitle">Select a prop to preview</strong>
              <div class="prop-preview-description" id="propPreviewDescription">
                Choose a prop from the Props category to see a live Three.js preview.
              </div>
              <div class="prop-preview-tags" id="propPreviewTags"></div>
            </div>
          </div>
        </div>
        <div class="inspector-section">
          <div class="inspector-section-title">🔍 Inspector</div>
          <div id="inspector">
            <div style="text-align: center; color: #666; padding: 40px 20px; font-size: 12px;">
              Select an asset or dialogue to inspect
            </div>
          </div>
        </div>
      </div>

      <!-- Bottom Panel - Code Preview -->
      <div class="panel-bottom">
        <div class="code-preview-header">
          <div class="code-preview-title">📄 Generated Code / Analysis</div>
          <button class="btn btn-secondary" id="copyCodeBtn" style="padding: 4px 10px; font-size: 11px;">📋 Copy</button>
        </div>
        <div class="code-preview-content" id="codePreview">
          <span class="code-comment">// Scene analysis and generated code will appear here...</span>
        </div>
      </div>

    </div>
  </div>

  <!-- Loading Overlay -->
  <div class="loading-overlay" id="loadingOverlay">
    <div class="loading-content">
      <div class="loading-spinner"></div>
      <div class="loading-text">Loading Sequence Builder</div>
      <div class="loading-detail" id="loadingDetail">Initializing...</div>
    </div>
  </div>

  <!-- Video Player Overlay -->
  <div class="video-player-overlay" id="videoPlayerOverlay">
    <div class="video-container">
      <video id="introVideo" style="display: none;" crossorigin="anonymous"></video>
      <canvas id="videoCanvas" class="video-canvas"></canvas>
      <div class="video-controls">
        <button class="video-close-btn" id="videoCloseBtn">✕ Close</button>
      </div>
    </div>
  </div>

  <!-- Import Map for THREE.js -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';
    
    // Import sequence builder core for auto-ingest
    let sequenceBuilder = null;
    try {
      const module = await import('../../src/tools/SequenceBuilderCore.js');
      sequenceBuilder = module.sequenceBuilder;
      console.log('✅ SequenceBuilderCore loaded');
    } catch (e) {
      console.warn('⚠️ Could not load SequenceBuilderCore (may not be on web server):', e);
      // Create a minimal fallback
      sequenceBuilder = {
        transitionToScene: async (sceneName) => {
          console.warn('Fallback: transitionToScene called for', sceneName);
          return false;
        }
      };
    }

    console.log('🎬 Unified Sequence Builder Starting...');

    let propLibrary = null;
    try {
      propLibrary = await import('../../src/assets/js/props/index.js');
      const totalProps = propLibrary?.listProps?.()?.length ?? 0;
      console.log(`✅ Prop library loaded (${totalProps} asset${totalProps === 1 ? '' : 's'})`);
    } catch (error) {
      console.warn('⚠️ Could not load prop library for builder viewport:', error);
    }

    let avatarFactory = null;
    try {
      const avatarModule = await import('../../src/scripts/systems/AvatarFactory.js');
      avatarFactory = avatarModule?.AvatarFactory || avatarModule?.default || null;
      if (avatarFactory) {
        console.log('✅ AvatarFactory loaded');
      }
    } catch (error) {
      console.warn('⚠️ Could not load AvatarFactory:', error);
    }

    let arrayaFactory = null;
    try {
      const arrayaModule = await import('../../src/scripts/systems/ArrayaAvatarFactory.js');
      arrayaFactory = arrayaModule?.ArrayaAvatarFactory || arrayaModule?.default || null;
      if (arrayaFactory?.create) {
        console.log('✅ ArrayaAvatarFactory loaded');
      }
    } catch (error) {
      console.warn('⚠️ Could not load ArrayaAvatarFactory:', error);
    }

    let landingPageLibrary = [];
    try {
      const landingModule = await import('../../src/scripts/scenes/components/ReferrerLandingPages.js');
      landingPageLibrary = landingModule?.REFERRER_LANDING_PAGES || [];
      console.log(`✅ Loaded ${landingPageLibrary.length} landing page component(s)`);
    } catch (error) {
      console.warn('⚠️ Could not load referrer landing pages library:', error);
    }

    // Scene Manager Data - Hierarchical scene entities
    const sceneData = {
      "Scene Objects": [
        {
          id: "avatar.celli",
          name: "celli",
          icon: "🔷",
          previewId: "avatar:celli",
          components: [
            { name: "position", type: "vector3", path: "celli.transform.position" },
            { name: "rotation", type: "vector3", path: "celli.transform.rotation" },
            { name: "scale", type: "vector3", path: "celli.transform.scale" },
            { name: "visible", type: "boolean", path: "celli.renderer.visible" },
            { name: "opacity", type: "number", path: "celli.renderer.opacity" }
          ],
          parts: [
            { 
              name: "head", 
              components: [
                { name: "position", type: "vector3", path: "celli.head.position" },
                { name: "rotation", type: "vector3", path: "celli.head.rotation" },
                { name: "color", type: "color", path: "celli.head.color" },
                { name: "visible", type: "boolean", path: "celli.head.visible" }
              ]
            },
            {
              name: "body",
              components: [
                { name: "position", type: "vector3", path: "celli.body.position" },
                { name: "color", type: "color", path: "celli.body.color" }
              ]
            }
          ]
        },
        {
          name: "player",
          icon: "👤",
          components: [
            { name: "position", type: "vector3", path: "player.position" },
            { name: "velocity", type: "vector3", path: "player.velocity" },
            { name: "health", type: "number", path: "player.health" },
            { name: "energy", type: "number", path: "player.energy" }
          ]
        },
        {
          id: "avatar.arraya",
          name: "Arraya Avatar",
          icon: "🪱",
          previewId: "avatar:arraya",
          components: [
            { name: "position", type: "vector3", path: "arraya.transform.position" },
            { name: "rotation", type: "vector3", path: "arraya.transform.rotation" },
            { name: "scale", type: "vector3", path: "arraya.transform.scale" },
            { name: "segments", type: "number", path: "arraya.userData.segmentCount" }
          ]
        },
        {
          id: "avatar.bob",
          name: "Bob Avatar",
          icon: "🟦",
          previewId: "avatar:bob",
          components: [
            { name: "position", type: "vector3", path: "bob.transform.position" },
            { name: "rotation", type: "vector3", path: "bob.transform.rotation" },
            { name: "scale", type: "vector3", path: "bob.transform.scale" },
            { name: "glow", type: "number", path: "bob.userData.glowAmount" }
          ]
        },
        {
          id: "avatar.palette",
          name: "Pal-ette Avatar",
          icon: "🟩",
          previewId: "avatar:palette",
          components: [
            { name: "position", type: "vector3", path: "palette.transform.position" },
            { name: "rotation", type: "vector3", path: "palette.transform.rotation" },
            { name: "scale", type: "vector3", path: "palette.transform.scale" },
            { name: "cellPulse", type: "number", path: "palette.userData.pulseStrength" }
          ]
        }
      ],
      "Environment": [
        {
          name: "camera",
          icon: "📷",
          components: [
            { name: "position", type: "vector3", path: "camera.position" },
            { name: "target", type: "vector3", path: "camera.target" },
            { name: "fov", type: "number", path: "camera.fov" },
            { name: "near", type: "number", path: "camera.near" },
            { name: "far", type: "number", path: "camera.far" }
          ]
        },
        {
          name: "lights",
          icon: "💡",
          components: [
            { name: "ambient.intensity", type: "number", path: "lights.ambient.intensity" },
            { name: "ambient.color", type: "color", path: "lights.ambient.color" },
            { name: "directional.intensity", type: "number", path: "lights.directional.intensity" },
            { name: "directional.color", type: "color", path: "lights.directional.color" },
            { name: "directional.position", type: "vector3", path: "lights.directional.position" }
          ]
        },
        {
          name: "skybox",
          icon: "🌌",
          components: [
            { name: "color", type: "color", path: "skybox.color" },
            { name: "rotation", type: "number", path: "skybox.rotation" },
            { name: "intensity", type: "number", path: "skybox.intensity" }
          ]
        }
      ],
      "Effects": [
        {
          name: "postprocessing",
          icon: "✨",
          components: [
            { name: "bloom.intensity", type: "number", path: "fx.bloom.intensity" },
            { name: "bloom.threshold", type: "number", path: "fx.bloom.threshold" },
            { name: "vignette.intensity", type: "number", path: "fx.vignette.intensity" },
            { name: "chromatic.offset", type: "number", path: "fx.chromatic.offset" }
          ]
        },
        {
          name: "particles",
          icon: "✨",
          components: [
            { name: "emissionRate", type: "number", path: "particles.emissionRate" },
            { name: "lifetime", type: "number", path: "particles.lifetime" },
            { name: "size", type: "number", path: "particles.size" },
            { name: "color", type: "color", path: "particles.color" }
          ]
        }
      ],
      "Props": [
        {
          name: "Film Camera",
          icon: "🎥",
          previewId: "filmCamera",
          description: "Dual-reel film camera with glowing lens and tripod stand.",
          tags: ["camera", "cinema", "hardware"],
          components: [
            { name: "position", type: "vector3", path: "props.filmCamera.position" },
            { name: "rotation", type: "vector3", path: "props.filmCamera.rotation" },
            { name: "scale", type: "vector3", path: "props.filmCamera.scale" },
            { name: "visible", type: "boolean", path: "props.filmCamera.visible" }
          ]
        },
        {
          name: "Film Reel",
          icon: "📽️",
          previewId: "filmReel",
          description: "Layered cinema reel with reflective plates and wound ribbon.",
          tags: ["reel", "cinema", "prop"],
          components: [
            { name: "position", type: "vector3", path: "props.filmReel.position" },
            { name: "rotation", type: "vector3", path: "props.filmReel.rotation" },
            { name: "scale", type: "vector3", path: "props.filmReel.scale" },
            { name: "visible", type: "boolean", path: "props.filmReel.visible" }
          ]
        },
        {
          name: "Film Strip",
          icon: "🎞️",
          previewId: "filmStrip",
          description: "Translucent connected frames with perforated guide bars.",
          tags: ["ui", "cinema", "graphic"],
          components: [
            { name: "position", type: "vector3", path: "props.filmStrip.position" },
            { name: "rotation", type: "vector3", path: "props.filmStrip.rotation" },
            { name: "scale", type: "vector3", path: "props.filmStrip.scale" },
            { name: "opacity", type: "number", path: "props.filmStrip.opacity" }
          ]
        },
        {
          id: "chessPawn",
          name: "Chess Pawn",
          icon: "♟️",
          previewId: "chessPawn",
          description: "Storybook pawn token with a glowing collar and warm lacquer finish.",
          tags: ["tabletop", "pawn", "board"],
          components: [
            { name: "position", type: "vector3", path: "props.chessPawn.position" },
            { name: "rotation", type: "vector3", path: "props.chessPawn.rotation" },
            { name: "scale", type: "vector3", path: "props.chessPawn.scale" },
            { name: "visible", type: "boolean", path: "props.chessPawn.visible" }
          ]
        },
        {
          id: "dice",
          name: "Dice",
          icon: "🎲",
          previewId: "dice",
          description: "Beveled six-sided die with inset pips and specular rim highlight.",
          tags: ["tabletop", "dice", "game"],
          components: [
            { name: "position", type: "vector3", path: "props.dice.position" },
            { name: "rotation", type: "vector3", path: "props.dice.rotation" },
            { name: "scale", type: "vector3", path: "props.dice.scale" },
            { name: "visible", type: "boolean", path: "props.dice.visible" }
          ]
        },
        {
          id: "playingCard",
          name: "Playing Card",
          icon: "🂡",
          previewId: "playingCard",
          description: "Rounded card with diamond pip detailing and contrasting backer.",
          tags: ["tabletop", "card", "deck"],
          components: [
            { name: "position", type: "vector3", path: "props.playingCard.position" },
            { name: "rotation", type: "vector3", path: "props.playingCard.rotation" },
            { name: "scale", type: "vector3", path: "props.playingCard.scale" },
            { name: "visible", type: "boolean", path: "props.playingCard.visible" }
          ]
        }
      ],
      "Landing Pages": landingPageLibrary.map(page => ({
        name: page.name,
        icon: page.icon || "📰",
        previewId: page.previewId || null,
        description: page.description,
        tags: page.tags || [],
        components: page.components || []
      })),
      "Audio": [
        {
          name: "bgMusic",
          icon: "🎵",
          components: [
            { name: "volume", type: "number", path: "audio.bgMusic.volume" },
            { name: "pitch", type: "number", path: "audio.bgMusic.pitch" },
            { name: "loop", type: "boolean", path: "audio.bgMusic.loop" }
          ]
        },
        {
          name: "sfx",
          icon: "🔊",
          components: [
            { name: "volume", type: "number", path: "audio.sfx.volume" },
            { name: "spatialBlend", type: "number", path: "audio.sfx.spatialBlend" }
          ]
        }
      ]
    };

    // ===== SCENE VIEWPORT MANAGER =====
    class SceneViewportManager {
      constructor(canvas, options = {}) {
        this.canvas = canvas;
        this.options = options;
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.controls = null;
        this.animationId = null;
        this.stats = { fps: 0, objects: 0, tris: 0 };
        this.nodeMarkers = new Map();
        this.dynamicHelpers = [];
        this.previewGridIndex = 0;
        this.originalMaterials = new Map();
        this.unlitMaterialCache = new Map();
        this.flatMaterialCache = new Map();
        this.lightingMode = 'default';
        this.flatLightingRig = null;
        this.library = options.propLibrary || propLibrary || null;
        this.avatarFactory = options.avatarFactory || avatarFactory || null;
        this.arrayaFactory = options.arrayaFactory || arrayaFactory || null;
        this.roundedBoxGeometry = options.roundedBoxGeometry || RoundedBoxGeometry;
        this.sceneData = options.sceneData || sceneData;
        this.previewRotation = options.previewRotation ?? Math.PI / 6;
        this.previewSpacing = options.previewSpacing || { x: 1.2, z: 1.05 };
      }

      init() {
        this.library = this.library || propLibrary || null;
        this.avatarFactory = this.avatarFactory || avatarFactory || null;
        this.arrayaFactory = this.arrayaFactory || arrayaFactory || null;

        // Try to get live scene from parent window
        const liveScene = this.getLiveScene();

        this.sceneCameras = [];
        this.currentCameraIndex = 0;
        this.selectedObject = null;
        this.nodeMarkers.clear();
        this.dynamicHelpers = [];
        this.previewGridIndex = 0;
        this.originalMaterials.clear();
        this.unlitMaterialCache.clear();
        this.flatMaterialCache.clear();
        this.lightingMode = 'default';
        this.flatLightingRig = null;

        if (liveScene) {
          console.log('🎥 Using live scene from parent window');
          this.scene = liveScene.scene;
          this.camera = liveScene.camera;
          this.renderer = liveScene.renderer;
          this.sceneObject = liveScene.sceneObject;
          this.usingLiveScene = true;
          
          // Collect all cameras from scene
          this.scene.traverse((obj) => {
            if (obj.isCamera) {
              this.sceneCameras.push({
                camera: obj,
                name: obj.name || `Camera ${this.sceneCameras.length + 1}`
              });
            }
          });
          console.log(`Found ${this.sceneCameras.length} cameras in scene`);
          
          // Setup our own renderer for viewport
          this.viewportRenderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true });
          this.viewportRenderer.setSize(this.canvas.clientWidth, this.canvas.clientHeight);
          this.viewportRenderer.setPixelRatio(window.devicePixelRatio);
          
          // Clone camera for independent viewport
          this.viewportCamera = this.camera.clone();
          this.viewportCamera.aspect = this.canvas.clientWidth / this.canvas.clientHeight;
          this.viewportCamera.updateProjectionMatrix();
          this.viewportCamera.name = 'Viewport Camera';
          
          // Controls for viewport camera
          this.controls = new OrbitControls(this.viewportCamera, this.canvas);
          this.controls.enableDamping = true;
          this.controls.dampingFactor = 0.05;
          
          // Setup raycaster for object selection
          this.raycaster = new THREE.Raycaster();
          this.mouse = new THREE.Vector2();
          this.setupObjectSelection();
          
        } else {
          console.log('🎥 Creating standalone scene');
          this.usingLiveScene = false;
          
          // Scene
          this.scene = new THREE.Scene();
          this.scene.background = new THREE.Color(0x0a0a0a);

          // Camera
          const aspect = this.canvas.clientWidth / this.canvas.clientHeight;
          this.camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
          this.camera.position.set(5, 3, 5);
          this.viewportCamera = this.camera;

          // Renderer
          this.viewportRenderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true });
          this.viewportRenderer.setSize(this.canvas.clientWidth, this.canvas.clientHeight);
          this.viewportRenderer.setPixelRatio(window.devicePixelRatio);

          // Controls
          this.controls = new OrbitControls(this.viewportCamera, this.canvas);
          this.controls.enableDamping = true;
          this.controls.dampingFactor = 0.05;

          // Lights
          const ambientLight = new THREE.AmbientLight(0x404040, 2);
          this.scene.add(ambientLight);

          const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
          directionalLight.position.set(5, 10, 5);
          this.scene.add(directionalLight);

          // Grid
          const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
          this.scene.add(gridHelper);

          // Sample object
          const geometry = new THREE.BoxGeometry(1, 1, 1);
          const material = new THREE.MeshStandardMaterial({ color: 0x3498db });
          const cube = new THREE.Mesh(geometry, material);
          cube.position.y = 0.5;
          this.scene.add(cube);
        }

        // Start animation
        this.animate();

        // Handle resize
        window.addEventListener('resize', () => this.handleResize());
        
        // Populate camera picker
        this.populateCameraPicker();
        
        console.log('✅ Scene viewport initialized');
      }
      
      setupObjectSelection() {
        this.canvas.addEventListener('click', (event) => {
          const rect = this.canvas.getBoundingClientRect();
          this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
          
          this.raycaster.setFromCamera(this.mouse, this.viewportCamera);
          const intersects = this.raycaster.intersectObjects(this.scene.children, true);
          
          if (intersects.length > 0) {
            const object = intersects[0].object;
            this.selectObject(object);
          }
        });
      }
      
      selectObject(object) {
        console.log('Selected object:', object.name || object.type, object);
        this.selectedObject = object;
        
        // Notify main app
        if (window.builderApp) {
          window.builderApp._showObjectInspector(object);
        }
        
        // Highlight object (optional visual feedback)
        if (this.highlightedObject) {
          // Remove previous highlight
          if (this.highlightedObject.material && this.highlightedObject.material.emissive) {
            this.highlightedObject.material.emissive.setHex(this.originalEmissive || 0x000000);
          }
        }
        
        if (object.material && object.material.emissive) {
          this.originalEmissive = object.material.emissive.getHex();
          object.material.emissive.setHex(0x3498db);
          this.highlightedObject = object;
        }
      }
      
      populateCameraPicker() {
        const select = document.getElementById('cameraSelect');
        if (!select) return;
        
        // Clear existing options except viewport
        select.innerHTML = '<option value="viewport">Viewport Camera</option>';
        
        // Add scene cameras
        this.sceneCameras.forEach((cam, index) => {
          const option = document.createElement('option');
          option.value = `scene_${index}`;
          option.textContent = cam.name;
          select.appendChild(option);
        });
      }
      
      switchCamera(value) {
        if (value === 'viewport') {
          this.currentCameraIndex = -1;
          this.controls.enabled = true;
          console.log('Switched to viewport camera');
        } else {
          const index = parseInt(value.split('_')[1]);
          if (index >= 0 && index < this.sceneCameras.length) {
            this.currentCameraIndex = index;
            this.viewportCamera = this.sceneCameras[index].camera;
            this.controls.enabled = false; // Disable controls when using scene camera
            console.log(`Switched to ${this.sceneCameras[index].name}`);
          }
        }
      }
      
      getLiveScene() {
        // Try to access parent window's scene
        try {
          if (window.parent && window.parent !== window) {
            const parentScene = window.parent.currentScene || window.parent.introScene;
            if (parentScene && parentScene.scene && parentScene.camera && parentScene.renderer) {
              return {
                scene: parentScene.scene,
                camera: parentScene.camera,
                renderer: parentScene.renderer,
                sceneObject: parentScene
              };
            }
          }
          
          // Try opener window
          if (window.opener) {
            const openerScene = window.opener.currentScene || window.opener.introScene;
            if (openerScene && openerScene.scene && openerScene.camera && openerScene.renderer) {
              return {
                scene: openerScene.scene,
                camera: openerScene.camera,
                renderer: openerScene.renderer,
                sceneObject: openerScene
              };
            }
          }
        } catch (e) {
          console.warn('Could not access parent scene:', e);
        }
        
        return null;
      }

      animate() {
        if (!this.isPaused) {
          this.animationId = requestAnimationFrame(() => this.animate());
        }
        
        if (this.controls && this.controls.enabled) {
          this.controls.update();
        }

        if (this.dynamicHelpers.length) {
          this.dynamicHelpers = this.dynamicHelpers.filter(entry => entry.helper && entry.target);
          this.dynamicHelpers.forEach(entry => {
            if (entry.helper && entry.target) {
              entry.helper.update();
            }
          });
        }

        // Render with viewport camera and renderer
        if (this.viewportRenderer && this.viewportCamera) {
          this.viewportRenderer.render(this.scene, this.viewportCamera);
        }
        
        // Update stats
        this.updateStats();
      }
      
      play() {
        if (this.isPaused) {
          this.isPaused = false;
          this.animate();
          console.log('▶ Scene playback resumed');
        }
      }
      
      pause() {
        this.isPaused = true;
        console.log('⏸ Scene playback paused');
      }

      updateStats() {
        this.stats.objects = this.scene.children.length;
        this.stats.tris = this.viewportRenderer ? this.viewportRenderer.info.render.triangles : 0;
      }

      handleResize() {
        const width = this.canvas.clientWidth;
        const height = this.canvas.clientHeight;
        
        if (this.viewportCamera) {
          this.viewportCamera.aspect = width / height;
          this.viewportCamera.updateProjectionMatrix();
        }
        if (this.viewportRenderer) {
          this.viewportRenderer.setSize(width, height);
        }
      }

      setWireframe(enabled) {
        this.scene.traverse((object) => {
          if (object.isMesh && object.material) {
            if (Array.isArray(object.material)) {
              object.material.forEach(mat => mat.wireframe = enabled);
            } else {
              object.material.wireframe = enabled;
            }
          }
        });
      }

      resetCamera() {
        if (this.viewportCamera) {
          this.viewportCamera.position.set(5, 3, 5);
          this.controls.target.set(0, 0, 0);
          this.controls.update();
        }
      }

      dispose() {
        if (this.animationId) {
          cancelAnimationFrame(this.animationId);
        }
        if (this.viewportRenderer) {
          this.viewportRenderer.dispose();
        }
        if (this.controls) {
          this.controls.dispose();
        }
      }
    }

    // ===== PROP PREVIEW MANAGER =====
    class PropPreviewer {
      constructor(canvas, meta = {}) {
        this.canvas = canvas;
        this.meta = meta;
        this.renderer = null;
        this.scene = null;
        this.camera = null;
        this.controls = null;
        this.currentProp = null;
        this.animationId = null;
        this.library = null;
        this.lights = [];
        this.canvasHeight = (canvas ? canvas.clientHeight : 220) || 220;
        this.minHeight = 160;
        this.maxHeight = 420;
        this.nodeMarkers = new Map();
        this.dynamicHelpers = [];
        this.previewGridIndex = 0;
        this.originalMaterials = new Map();
        this.unlitMaterialCache = new Map();
        this.flatMaterialCache = new Map();
        this.lightingMode = 'default';
        this.flatLightingRig = null;
        this.sceneData = meta.sceneData || sceneData;
        this.library = meta.assetLibrary || propLibrary || null;
        this.avatarFactory = meta.avatarFactory || avatarFactory || null;
        this.arrayaFactory = meta.arrayaFactory || arrayaFactory || null;
        this.roundedBoxGeometry = meta.roundedBoxGeometry || RoundedBoxGeometry;
        this.previewRotation = meta.previewRotation ?? Math.PI / 6;
        this.previewSpacing = meta.previewSpacing || { x: 1.2, z: 1.05 };
      }

      async init() {
        if (!this.canvas) {
          console.warn('PropPreviewer: canvas not found');
          return;
        }

        try {
          if (!this.library) {
            this.library = await import('../../src/assets/js/props/index.js');
            console.log('🎨 Prop library loaded');
          } else {
            console.log('🎨 Prop library injected');
          }
        } catch (error) {
          console.warn('⚠️ Prop library could not be loaded:', error);
          this._updateMeta({
            title: 'Prop library unavailable',
            description: 'Ensure the assets/js/props bundle is accessible when serving the builder.',
            tags: ['error'],
          });
          return;
        }

        const width = this.canvas.clientWidth || 320;
        const height = this.canvas.clientHeight || this.canvasHeight || 200;
        this.canvasHeight = height;

        this.canvas.style.height = `${this.canvasHeight}px`;

        this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true, alpha: true });
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.setSize(width, height);
        this.renderer.shadowMap.enabled = true;

        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x050607);

        this.camera = new THREE.PerspectiveCamera(45, width / height, 0.05, 200);
        this.camera.position.set(3, 2.2, 3.4);

        this.controls = new OrbitControls(this.camera, this.canvas);
        this.controls.enableDamping = true;
        this.controls.enablePan = false;
        this.controls.dampingFactor = 0.08;
        this.controls.target.set(0, 1, 0);

        // Lighting setup
        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        this.scene.add(ambient);
        this.lights.push(ambient);

        const keyLight = new THREE.DirectionalLight(0xffffff, 0.85);
        keyLight.position.set(4, 6, 5);
        keyLight.castShadow = true;
        this.scene.add(keyLight);
        this.lights.push(keyLight);

        const rimLight = new THREE.PointLight(0x4cc0ff, 0.8, 12, 2);
        rimLight.position.set(-3, 2, -4);
        this.scene.add(rimLight);
        this.lights.push(rimLight);

        const ground = new THREE.Mesh(
          new THREE.CircleGeometry(4.5, 48),
          new THREE.MeshStandardMaterial({
            color: 0x111216,
            metalness: 0.2,
            roughness: 0.8,
            transparent: true,
            opacity: 0.95,
          })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        ground.position.y = 0.01;
        this.scene.add(ground);

        this._updateMeta({
          title: 'Select a prop to preview',
          description: 'Browse the Props category to see new Three.js ready assets in action.',
          tags: ['props', 'preview', 'three.js'],
        });

        this.handleResize();
        this._animate();
      }

      _animate() {
        this.animationId = requestAnimationFrame(() => this._animate());
        if (this.controls) {
          this.controls.update();
        }
        if (this.renderer && this.scene && this.camera) {
          this.renderer.render(this.scene, this.camera);
        }
      }

      showProp(id, metaOverrides = {}) {
        if (!this.scene) return;

        const stubNode = {
          id: `preview-${id}`,
          data: {
            previewId: id,
            previewSize: metaOverrides.previewSize || 2.4,
            previewRotation: metaOverrides.rotationY ?? this.previewRotation,
          }
        };

        const propDefinition = this.library?.getPropDefinition?.(id) || this._findSceneEntityMeta(id);
        let instance = this.library?.createProp?.(id);

        if (!instance) {
          instance = this._buildAssetInstance(id, stubNode);
        }

        if (!instance) {
          this._updateMeta({
            title: 'Preview unavailable',
            description: 'This asset has not been implemented yet.',
            tags: ['todo'],
          });
          return;
        }

        if (this.currentProp) {
          this._disposeCurrentProp();
        }

        const container = this._wrapAssetForPreview(instance, stubNode, {
          targetSize: stubNode.data.previewSize,
          rotationY: stubNode.data.previewRotation,
          baseOffsetY: 0,
          maxScale: 3.2,
        });

        container.position.set(0, 0, 0);
        container.rotation.y = stubNode.data.previewRotation ?? this.previewRotation;

        this.currentProp = container;
        this.scene.add(container);

        this._focusOnProp(container);

        this._updateMeta({
          title: metaOverrides.title || propDefinition?.name || 'Asset Preview',
          description: metaOverrides.description || propDefinition?.description || '',
          tags: metaOverrides.tags || propDefinition?.tags || [],
        });
      }

      handleResize() {
        if (!this.renderer || !this.camera || !this.canvas) return;
        const width = this.canvas.clientWidth || 320;
        const height = this.canvas.clientHeight || this.canvasHeight || 200;
        this.canvasHeight = height;
        this.renderer.setSize(width, height);
        this.camera.aspect = width / Math.max(1, height);
        this.camera.updateProjectionMatrix();
      }

      setHeight(height) {
        if (!this.canvas) return;
        const clamped = Math.max(this.minHeight, Math.min(this.maxHeight, height));
        this.canvasHeight = clamped;
        this.canvas.style.height = `${clamped}px`;
        if (this.renderer) {
          const width = this.canvas.clientWidth || 320;
          this.renderer.setSize(width, clamped);
        }
        this.handleResize();
      }

      getHeight() {
        return this.canvasHeight;
      }

      setLightingMode(mode = 'default') {
        if (!this.scene) return;
        if (mode === this.lightingMode) return;

        this._restoreOriginalMaterials();

        switch (mode) {
          case 'unlit':
            this._applyUnlitMaterials();
            this._removeFlatLighting();
            break;
          case 'flat':
            this._applyFlatMaterials();
            this._ensureFlatLighting();
            break;
          default:
            this._removeFlatLighting();
            break;
        }

        this.lightingMode = mode;
      }

      addNodePreview(node) {
        if (!node || !this.scene) return;
        if (this.nodeMarkers.has(node.id)) return;

        const color = this._getNodeColor(node.type);
        let marker = null;

        if (node.type === 'object' && node.data?.entityName) {
          marker = this._highlightSceneObject(node.data.entityName, node.id, color);
        }

        if (!marker) {
          marker = this._createPreviewMesh(node, color);
        }

        if (marker) {
          this.nodeMarkers.set(node.id, marker);
        }
      }

      removeNodePreview(nodeId) {
        const marker = this.nodeMarkers.get(nodeId);
        if (!marker) return;

        if (marker.type === 'mesh' && marker.mesh) {
          this.scene.remove(marker.mesh);
          marker.mesh.traverse((child) => {
            if (!child.isMesh) return;
            child.geometry?.dispose?.();
            if (Array.isArray(child.material)) {
              child.material.forEach((mat) => mat?.dispose?.());
            } else {
              child.material?.dispose?.();
            }
          });
        }

        if (marker.type === 'highlight') {
          if (marker.helper) {
            this.scene.remove(marker.helper);
            this.dynamicHelpers = this.dynamicHelpers.filter(entry => entry.helper !== marker.helper);
          }

          if (marker.target && marker.emissiveBackup) {
            const applyRestore = (mat, backup) => {
              if (mat && mat.emissive && backup !== undefined) {
                mat.emissive.setHex(backup);
              }
            };

            if (Array.isArray(marker.target.material)) {
              marker.target.material.forEach((mat, index) => applyRestore(mat, marker.emissiveBackup[index]));
            } else {
              applyRestore(marker.target.material, marker.emissiveBackup[0]);
            }
          }
        }

        this.nodeMarkers.delete(nodeId);
      }

      clearNodePreviews() {
        Array.from(this.nodeMarkers.keys()).forEach(id => this.removeNodePreview(id));
        this.previewGridIndex = 0;
      }

      _getNodeColor(type) {
        const colors = {
          object: 0x3498db,
          parameter: 0x2ecc71,
          animation: 0xff6b6b,
          transition: 0xf39c12,
          event: 0xf1c40f,
          dialogue: 0x9b59b6,
          snapshot: 0x95a5a6
        };
        return colors[type] || 0xffffff;
      }

      _createPreviewMesh(node, color) {
        const marker = this._createAssetPreview(node?.data?.previewId, node, { color });
        if (marker) {
          return marker;
        }

        const geometry = new THREE.BoxGeometry(0.35, 0.35, 0.35);
        const emissiveColor = new THREE.Color(color).multiplyScalar(0.35);
        const material = new THREE.MeshStandardMaterial({
          color,
          emissive: emissiveColor,
          transparent: true,
          opacity: 0.85
        });

        const mesh = new THREE.Mesh(geometry, material);
        const row = Math.floor(this.previewGridIndex / 5);
        const col = this.previewGridIndex % 5;
        mesh.position.set(-2 + col * 0.9, 0.25 + row * 0.55, -1.8 - row * 0.8);
        mesh.userData.nodeId = node.id;
        this.previewGridIndex += 1;

        this.scene.add(mesh);
        return { type: 'mesh', mesh };
      }

      _createAssetPreview(previewId, node, options = {}) {
        if (!this.scene) return null;

        let id = previewId;
        if (!id && node?.data?.entityName) {
          const meta = this._findSceneEntityMeta(node.data.entityName);
          id = meta?.previewId || meta?.id || id;
        }

        if (!id) return null;

        const asset = this._buildAssetInstance(id, node);
        if (!asset) return null;

        const container = this._wrapAssetForPreview(asset, node, {
          rotationY: options.rotationY ?? node?.data?.previewRotation ?? this.previewRotation,
          targetSize: node?.data?.previewSize ?? 1.1,
          baseOffsetY: 0,
        });

        const spacingX = this.previewSpacing?.x ?? 1.2;
        const spacingZ = this.previewSpacing?.z ?? 1.0;
        const row = Math.floor(this.previewGridIndex / 5);
        const col = this.previewGridIndex % 5;
        container.position.set(-2 + col * spacingX, 0, -1.8 - row * spacingZ);
        container.userData.nodeId = node?.id;
        container.userData.previewId = id;

        this.previewGridIndex += 1;
        this.scene.add(container);

        return { type: 'mesh', mesh: container, previewId: id };
      }

      _buildAssetInstance(previewId, node) {
        if (!previewId && node?.data?.entityName) {
          const meta = this._findSceneEntityMeta(node.data.entityName);
          previewId = meta?.previewId || meta?.id || previewId;
        }

        if (!previewId) return null;

        if (previewId.startsWith('avatar:')) {
          return this._createAvatarPreview(previewId, node);
        }

        const options = node?.data?.propOptions || {};
        if (this.library?.createProp) {
          const instance = this.library.createProp(previewId, options);
          if (instance) {
            return instance;
          }
        }

        return null;
      }

      _wrapAssetForPreview(asset, node, options = {}) {
        const container = new THREE.Group();
        container.name = `PreviewContainer_${node?.id ?? 'asset'}`;
        container.add(asset);

        const box = new THREE.Box3().setFromObject(asset);
        if (!isFinite(box.min.x) || !isFinite(box.max.x)) {
          return container;
        }

        const size = new THREE.Vector3();
        const center = new THREE.Vector3();
        box.getSize(size);
        box.getCenter(center);

        asset.position.x -= center.x;
        asset.position.z -= center.z;
        asset.position.y -= box.min.y;

        const targetSize = options.targetSize ?? node?.data?.previewSize ?? 1.1;
        const maxDim = Math.max(size.x, size.y, size.z) || 1;
        const maxScale = options.maxScale ?? 2.2;
        const scale = Math.min(targetSize / maxDim, maxScale);
        container.scale.setScalar(scale);

        container.rotation.y = options.rotationY ?? node?.data?.previewRotation ?? this.previewRotation;
        container.position.y = options.baseOffsetY ?? 0;
        container.userData.nodeId = node?.id;

        return container;
      }

      _findSceneEntityMeta(name) {
        if (!name || !this.sceneData) return null;
        const lower = name.toLowerCase();
        for (const category of Object.keys(this.sceneData)) {
          const entities = this.sceneData[category];
          if (!Array.isArray(entities)) continue;
          const match = entities.find((entity) => {
            const entityName = entity.name?.toLowerCase();
            const entityId = entity.id?.toLowerCase();
            return entityName === lower || entityId === lower;
          });
          if (match) return match;
        }
        return null;
      }

      _createAvatarPreview(previewId) {
        if (previewId === 'avatar:celli' && this.avatarFactory?.createCelli) {
          const avatar = this.avatarFactory.createCelli(THREE, this.roundedBoxGeometry);
          avatar.name = avatar.name || 'CelliAvatar';
          return avatar;
        }

        if (previewId === 'avatar:bob' && this.avatarFactory?.createBob) {
          const avatar = this.avatarFactory.createBob(THREE);
          avatar.name = avatar.name || 'BobAvatar';
          return avatar;
        }

        if (previewId === 'avatar:palette' && this.avatarFactory?.createPalette) {
          const avatar = this.avatarFactory.createPalette(THREE);
          avatar.name = avatar.name || 'PaletteAvatar';
          return avatar;
        }

        if (previewId === 'avatar:arraya' && this.arrayaFactory?.create) {
          const avatar = this.arrayaFactory.create(THREE);
          avatar.name = avatar.name || 'ArrayaAvatar';
          return avatar;
        }

        return null;
      }

      _highlightSceneObject(name, nodeId, color) {
        if (!name) return null;
        let target = null;
        this.scene.traverse(obj => {
          if (target) return;
          if (obj.name && obj.name.toLowerCase() === name.toLowerCase()) {
            target = obj;
          }
        });

        if (!target) return null;

        const helper = new THREE.BoxHelper(target, color);
        helper.userData.nodeId = nodeId;
        this.scene.add(helper);
        this.dynamicHelpers.push({ helper, target });

        const emissiveBackup = [];
        const applyHighlight = (material) => {
          if (material && material.emissive) {
            emissiveBackup.push(material.emissive.getHex());
            material.emissive.setHex(color);
          }
        };

        if (Array.isArray(target.material)) {
          target.material.forEach(applyHighlight);
        } else {
          applyHighlight(target.material);
        }

        return { type: 'highlight', helper, target, emissiveBackup };
      }

      _cacheOriginalMaterial(mesh) {
        if (this.originalMaterials.has(mesh.uuid)) return;
        const material = mesh.material;
        if (Array.isArray(material)) {
          this.originalMaterials.set(mesh.uuid, material.map(mat => mat));
        } else {
          this.originalMaterials.set(mesh.uuid, material);
        }
      }

      _restoreOriginalMaterials() {
        if (!this.scene) return;
        this.scene.traverse(obj => {
          if (!obj.isMesh) return;
          if (!this.originalMaterials.has(obj.uuid)) return;

          const original = this.originalMaterials.get(obj.uuid);
          if (Array.isArray(original)) {
            obj.material = original.map(mat => mat);
          } else {
            obj.material = original;
          }

          const resetFlat = (material) => {
            if (material && material.flatShading !== undefined) {
              material.flatShading = false;
              material.needsUpdate = true;
            }
          };

          if (Array.isArray(obj.material)) {
            obj.material.forEach(resetFlat);
          } else {
            resetFlat(obj.material);
          }
        });
      }

      _applyUnlitMaterials() {
        if (!this.scene) return;
        this.scene.traverse(obj => {
          if (!obj.isMesh) return;
          this._cacheOriginalMaterial(obj);
          const original = this.originalMaterials.get(obj.uuid);
          if (!original) return;

          if (Array.isArray(original)) {
            const overrides = original.map(mat => this._createUnlitMaterial(mat));
            this.unlitMaterialCache.set(obj.uuid, overrides);
            obj.material = overrides;
          } else {
            let override = this.unlitMaterialCache.get(obj.uuid);
            if (!override) {
              override = this._createUnlitMaterial(original);
              this.unlitMaterialCache.set(obj.uuid, override);
            }
            obj.material = override;
          }
        });
      }

      _applyFlatMaterials() {
        if (!this.scene) return;
        this.scene.traverse(obj => {
          if (!obj.isMesh) return;
          this._cacheOriginalMaterial(obj);
          const original = this.originalMaterials.get(obj.uuid);
          if (!original) return;

          if (Array.isArray(original)) {
            let overrides = this.flatMaterialCache.get(obj.uuid);
            if (!overrides) {
              overrides = original.map(mat => this._cloneFlatMaterial(mat));
              this.flatMaterialCache.set(obj.uuid, overrides);
            }
            obj.material = overrides;
          } else {
            let override = this.flatMaterialCache.get(obj.uuid);
            if (!override) {
              override = this._cloneFlatMaterial(original);
              this.flatMaterialCache.set(obj.uuid, override);
            }
            obj.material = override;
          }
        });
      }

      _createUnlitMaterial(material) {
        if (!material) {
          return new THREE.MeshBasicMaterial({ color: 0xffffff });
        }

        const color = material.color ? material.color.clone() : new THREE.Color(0xffffff);
        return new THREE.MeshBasicMaterial({
          color,
          transparent: material.transparent === true,
          opacity: material.opacity !== undefined ? material.opacity : 1,
          wireframe: material.wireframe === true
        });
      }

      _cloneFlatMaterial(material) {
        if (!material) return new THREE.MeshStandardMaterial({ flatShading: true });
        const clone = material.clone ? material.clone() : material;
        if (clone && clone.flatShading !== undefined) {
          clone.flatShading = true;
          clone.needsUpdate = true;
        }
        return clone;
      }

      _ensureFlatLighting() {
        if (!this.scene) return;
        if (this.flatLightingRig) return;
        this.flatLightingRig = new THREE.HemisphereLight(0xffffff, 0x111111, 0.85);
        this.flatLightingRig.position.set(0, 6, 0);
        this.scene.add(this.flatLightingRig);
      }

      _removeFlatLighting() {
        if (this.flatLightingRig && this.scene) {
          this.scene.remove(this.flatLightingRig);
          this.flatLightingRig = null;
        }
      }

      _focusOnProp(object) {
        const box = new THREE.Box3().setFromObject(object);
        const size = box.getSize(new THREE.Vector3());
        const center = box.getCenter(new THREE.Vector3());

        const maxDim = Math.max(size.x, size.y, size.z);
        const distance = maxDim * 2.4 + 0.5;

        const offset = new THREE.Vector3(1.6, 1.1, 1.8).normalize().multiplyScalar(distance);
        this.camera.position.copy(center.clone().add(offset));
        this.controls.target.copy(center);
        this.controls.update();

        this.camera.near = Math.max(0.01, distance / 20);
        this.camera.far = Math.max(50, distance * 6);
        this.camera.updateProjectionMatrix();
      }

      _disposeCurrentProp() {
        if (!this.currentProp) return;
        this.scene.remove(this.currentProp);
        this.currentProp.traverse((child) => {
          if (child.isMesh) {
            if (child.geometry) child.geometry.dispose();
            if (Array.isArray(child.material)) {
              child.material.forEach((mat) => mat.dispose?.());
            } else if (child.material) {
              child.material.dispose?.();
            }
          }
        });
        this.currentProp = null;
      }

      _updateMeta({ title, description, tags }) {
        if (this.meta.titleEl) {
          this.meta.titleEl.textContent = title || 'Prop Preview';
        }
        if (this.meta.descriptionEl) {
          this.meta.descriptionEl.textContent = description || '';
        }
        if (this.meta.tagsEl) {
          this.meta.tagsEl.innerHTML = '';
          if (tags && tags.length) {
            tags.forEach((tag) => {
              const span = document.createElement('span');
              span.className = 'prop-tag';
              span.textContent = tag;
              this.meta.tagsEl.appendChild(span);
            });
          }
        }
      }
    }

    const sharedPreviewMethods = [
      'setLightingMode',
      'addNodePreview',
      'removeNodePreview',
      'clearNodePreviews',
      '_getNodeColor',
      '_createPreviewMesh',
      '_createAssetPreview',
      '_buildAssetInstance',
      '_wrapAssetForPreview',
      '_findSceneEntityMeta',
      '_createAvatarPreview',
      '_highlightSceneObject',
      '_cacheOriginalMaterial',
      '_restoreOriginalMaterials',
      '_applyUnlitMaterials',
      '_applyFlatMaterials',
      '_createUnlitMaterial',
      '_cloneFlatMaterial',
      '_ensureFlatLighting',
      '_removeFlatLighting'
    ];

    sharedPreviewMethods.forEach((method) => {
      if (!SceneViewportManager.prototype[method] && PropPreviewer.prototype[method]) {
        SceneViewportManager.prototype[method] = PropPreviewer.prototype[method];
      }
    });

    // ===== RESIZABLE PANELS MANAGER =====
    class ResizableManager {
      constructor(container) {
        this.container = container;
        this.handles = document.querySelectorAll('.resize-handle');
        this.isResizing = false;
        this.currentHandle = null;
        this.startX = 0;
        this.startY = 0;
        this.startColumns = [];
        this.startBottomHeight = 180;
        this.startHeaderHeight = 60;
        this.minColumnWidths = [220, 320, 280, 320];
      }

      init() {
        this.handles.forEach(handle => {
          handle.addEventListener('mousedown', (e) => this.startResize(e, handle));
        });

        document.addEventListener('mousemove', (e) => this.resize(e));
        document.addEventListener('mouseup', () => this.stopResize());

        this._syncHandlePositions();
        window.addEventListener('resize', () => this._syncHandlePositions());
      }

      startResize(e, handle) {
        this.isResizing = true;
        this.currentHandle = handle;
        this.startX = e.clientX;
        this.startY = e.clientY;
        handle.classList.add('active');

        this.startColumns = this._captureColumnWidths();
        const { header, bottom } = this._captureRowHeights();
        this.startHeaderHeight = header;
        this.startBottomHeight = bottom;

        // Convert grid to fixed pixels for smooth dragging
        this._applyColumnWidths(this.startColumns);
        this.container.style.gridTemplateRows = `${this.startHeaderHeight}px 1fr ${this.startBottomHeight}px`;
        e.preventDefault();
      }

      resize(e) {
        if (!this.isResizing) return;

        const handleNum = this.currentHandle.dataset.handle;

        if (handleNum === 'bottom') {
          // Vertical resize
          const deltaY = e.clientY - this.startY;
          const desiredHeight = this.startBottomHeight - deltaY;
          const newHeight = Math.max(140, Math.min(420, desiredHeight));

          this.container.style.gridTemplateRows = `${this.startHeaderHeight}px 1fr ${newHeight}px`;
          this.container.style.setProperty('--builder-bottom-height', `${newHeight}px`);
          this._syncHandlePositions();
        } else {
          // Horizontal resize
          const deltaX = e.clientX - this.startX;
          const handleIndex = parseInt(handleNum) - 1;
          const nextIndex = handleIndex + 1;

          if (nextIndex >= this.startColumns.length) return;

          const delta = this._computeColumnDelta(handleIndex, nextIndex, deltaX);
          const newWidths = [...this.startColumns];
          newWidths[handleIndex] = this.startColumns[handleIndex] + delta;
          newWidths[nextIndex] = this.startColumns[nextIndex] - delta;

          this._applyColumnWidths(newWidths);
          this._syncHandlePositions();
        }
      }

      stopResize() {
        if (!this.isResizing) return;
        
        this.isResizing = false;
        if (this.currentHandle) {
          this.currentHandle.classList.remove('active');
        }
        this.currentHandle = null;
        
        // Notify viewport to resize
        if (window.viewportManager) {
          setTimeout(() => window.viewportManager.handleResize(), 100);
        }
        if (window.propPreviewer) {
          setTimeout(() => window.propPreviewer.handleResize(), 150);
        }

        this._syncHandlePositions();
      }

      _computeColumnDelta(index, nextIndex, deltaX) {
        const currentWidth = this.startColumns[index];
        const nextWidth = this.startColumns[nextIndex];
        let delta = deltaX;

        const minCurrent = this.minColumnWidths[index] || 200;
        const minNext = this.minColumnWidths[nextIndex] || 240;

        if (currentWidth + delta < minCurrent) {
          delta = minCurrent - currentWidth;
        }
        if (nextWidth - delta < minNext) {
          delta = nextWidth - minNext;
        }

        return delta;
      }

      _captureColumnWidths() {
        const left = this.container.querySelector('.panel-left');
        const viewport = this.container.querySelector('.panel-viewport');
        const center = this.container.querySelector('.panel-center');
        const right = this.container.querySelector('.panel-right');
        return [left, viewport, center, right]
          .map(panel => (panel ? panel.offsetWidth : 0));
      }

      _captureRowHeights() {
        const header = this.container.querySelector('.builder-header');
        const bottom = this.container.querySelector('.panel-bottom');
        return {
          header: header ? header.offsetHeight : 60,
          bottom: bottom ? bottom.offsetHeight : 180
        };
      }

      _applyColumnWidths(widths) {
        this.container.style.gridTemplateColumns = widths.map(w => `${Math.max(120, Math.round(w))}px`).join(' ');
      }

      _syncHandlePositions() {
        const widths = this._captureColumnWidths();
        if (widths.some(w => !w)) return;

        const positions = [widths[0], widths[0] + widths[1], widths[0] + widths[1] + widths[2]];
        const headerBottom = this._captureRowHeights();

        this.container.style.setProperty('--builder-header-height', `${headerBottom.header}px`);
        this.container.style.setProperty('--builder-bottom-height', `${headerBottom.bottom}px`);

        const handles = {
          first: this.container.querySelector('.resize-handle-1'),
          second: this.container.querySelector('.resize-handle-2'),
          third: this.container.querySelector('.resize-handle-3'),
          bottom: this.container.querySelector('.resize-handle-bottom')
        };

        if (handles.first) {
          handles.first.style.left = `${positions[0]}px`;
          handles.first.style.right = '';
        }
        if (handles.second) {
          handles.second.style.left = `${positions[1]}px`;
          handles.second.style.right = '';
        }
        if (handles.third) {
          handles.third.style.left = `${positions[2]}px`;
          handles.third.style.right = '';
        }
        if (handles.bottom) {
          handles.bottom.style.bottom = `${headerBottom.bottom}px`;
        }
      }
    }

    // ===== DIALOGUE MANAGER =====
    class DialogueManager {
      constructor() {
        this.dialogues = [];
        this.selectedDialogue = null;
      }

      createDialogue(data = {}) {
        const baseDialogue = {
          id: Date.now(),
          speaker: data.speaker || 'Unknown',
          text: data.text || '',
          display: data.display || 'subtitle',
          timestamp: data.timestamp ?? 0,
          duration: data.duration ?? 3.0,
          nodeType: data.nodeType || 'dialogue',
          ...data
        };

        baseDialogue.tags = this._deriveDialogueTags(baseDialogue);
        this.dialogues.push(baseDialogue);
        return baseDialogue;
      }

      updateDialogue(id, updates) {
        const dialogue = this.dialogues.find(d => d.id === id);
        if (dialogue) {
          Object.assign(dialogue, updates);
          dialogue.tags = this._deriveDialogueTags(dialogue);
        }
        return dialogue;
      }

      deleteDialogue(id) {
        const index = this.dialogues.findIndex(d => d.id === id);
        if (index > -1) {
          this.dialogues.splice(index, 1);
        }
      }

      exportDialogues() {
        return {
          dialogues: this.dialogues,
          count: this.dialogues.length
        };
      }

      importDialogues(data) {
        if (data.dialogues) {
          this.dialogues = data.dialogues.map(dialogue => ({
            ...dialogue,
            tags: this._deriveDialogueTags(dialogue)
          }));
        }
      }

      _deriveDialogueTags(dialogue) {
        const tags = new Set();
        const add = (value) => {
          if (value === undefined || value === null) return;
          const str = String(value)
            .replace(/[_-]/g, ' ')
            .replace(/([a-z])([A-Z])/g, '$1 $2')
            .trim()
            .toLowerCase();
          if (str) tags.add(str);
        };

        add('dialogue');
        add(dialogue.display || 'subtitle');
        add(dialogue.nodeType || 'card');
        if (dialogue.category) add(dialogue.category);
        if (dialogue.entityName) add(dialogue.entityName);

        if (Array.isArray(dialogue.tags)) {
          dialogue.tags.forEach(add);
        }

        return Array.from(tags);
      }
    }

    // ===== NODE GRAPH MANAGER =====
    class NodeGraphManager {
      constructor(canvasEl, svgEl, nodesContainerEl, options = {}) {
        this.canvas = canvasEl;
        this.svg = svgEl;
        this.nodesContainer = nodesContainerEl;
        this.nodes = [];
        this.connections = [];
        this.nodeIdCounter = 1;
        this.connectionIdCounter = 1;
        this.selectedNode = null;
        this.dragState = null;
        this.connectionDrag = null;
        this.canvasOffset = { x: 0, y: 0 };
        this.options = options || {};

        this._setupCanvasInteraction();
      }
      
      _setupCanvasInteraction() {
        // Canvas panning
        let isPanning = false;
        let panStart = { x: 0, y: 0 };
        
        this.canvas.addEventListener('mousedown', (e) => {
          if (e.target === this.canvas || e.target === this.nodesContainer) {
            isPanning = true;
            panStart = { x: e.clientX, y: e.clientY };
            this.canvas.classList.add('dragging');
          }
        });
        
        document.addEventListener('mousemove', (e) => {
          if (isPanning) {
            const dx = e.clientX - panStart.x;
            const dy = e.clientY - panStart.y;
            
            const container = this.canvas.parentElement;
            container.scrollLeft -= dx;
            container.scrollTop -= dy;
            
            panStart = { x: e.clientX, y: e.clientY };
          }
          
          // Handle connection dragging
          if (this.connectionDrag) {
            this._updateTempConnection(e);
          }
        });
        
        document.addEventListener('mouseup', () => {
          if (isPanning) {
            isPanning = false;
            this.canvas.classList.remove('dragging');
          }
          
          if (this.connectionDrag) {
            this._endConnectionDrag();
          }
        });
      }
      
      createNode(type, x, y, data = {}) {
        const node = {
          id: this.nodeIdCounter++,
          type,
          x,
          y,
          data: {
            speaker: data.speaker || 'Node',
            text: data.text || '',
            ...data
          }
        };
        
        console.log(`Creating node: ${type} at (${x}, ${y})`, node);
        
        this.nodes.push(node);
        console.log(`Total nodes: ${this.nodes.length}`);
        
        if (!this.nodesContainer) {
          console.error('❌ nodesContainer is null! Cannot render node.');
          return node;
        }
        
        this._renderNode(node);
        this._expandCanvasIfNeeded(x + 250, y + 150);
        
        console.log(`✅ Node created and rendered: ${node.id}`);
        if (this.options.onNodeCreated) {
          try {
            this.options.onNodeCreated(node);
          } catch (err) {
            console.warn('onNodeCreated callback failed', err);
          }
        }
        return node;
      }
      
      _expandCanvasIfNeeded(x, y) {
        const currentWidth = parseInt(this.canvas.style.minWidth) || 3000;
        const currentHeight = parseInt(this.canvas.style.minHeight) || 2000;
        
        let newWidth = currentWidth;
        let newHeight = currentHeight;
        let needsUpdate = false;
        
        if (x > currentWidth - 500) {
          newWidth = Math.max(currentWidth, x + 1000);
          needsUpdate = true;
        }
        
        if (y > currentHeight - 500) {
          newHeight = Math.max(currentHeight, y + 1000);
          needsUpdate = true;
        }
        
        if (needsUpdate) {
          this.canvas.style.minWidth = newWidth + 'px';
          this.canvas.style.minHeight = newHeight + 'px';
          this.svg.style.width = newWidth + 'px';
          this.svg.style.height = newHeight + 'px';
        }
      }
      
      _renderNode(node) {
        console.log(`Rendering node ${node.id} of type ${node.type}`);
        
        const nodeEl = document.createElement('div');
        nodeEl.className = `graph-node type-${node.type}`;
        nodeEl.dataset.nodeId = node.id;
        nodeEl.style.left = node.x + 'px';
        nodeEl.style.top = node.y + 'px';
        
        console.log(`Node element created, position: ${node.x}, ${node.y}`);
        
        nodeEl.innerHTML = `
          <div class="graph-node-header">
            <div class="graph-node-title">
              <div class="node-type-indicator"></div>
              <span>${node.data.speaker || node.type}</span>
            </div>
            <div class="graph-node-actions">
              <button class="node-action-btn node-copy-btn" title="Copy Node">📋</button>
              <button class="node-action-btn node-delete-btn" title="Delete Node">×</button>
            </div>
          </div>
          <div class="graph-node-body">
            ${node.data.text || 'No content'}
          </div>
        `;
        
        console.log(`Node HTML set for node ${node.id}`);
        
        // Add sockets
        const hasInput = node.type !== 'parameter';
        const hasOutput = true;
        
        if (hasInput) {
          const inputSocket = this._createSocket('input', node.id);
          nodeEl.appendChild(inputSocket);
        }
        
        if (hasOutput) {
          // Handle multiple outputs for parallel nodes
          if (node.type === 'parallel') {
            const numOutputs = node.data.outputs || 3;
            for (let i = 0; i < numOutputs; i++) {
              const outputSocket = this._createSocket('output', node.id, i);
              outputSocket.style.top = `${20 + (i * 25)}%`;
              nodeEl.appendChild(outputSocket);
            }
            
            // Add output management controls
            const controlsDiv = document.createElement('div');
            controlsDiv.className = 'parallel-outputs';
            controlsDiv.innerHTML = `
              <button class="parallel-output-btn" onclick="window.nodeGraphManager._addParallelOutput('${node.id}')">+ Add Output</button>
              ${numOutputs > 1 ? `<button class="parallel-output-btn" onclick="window.nodeGraphManager._removeParallelOutput('${node.id}')">- Remove Output</button>` : ''}
            `;
            nodeEl.querySelector('.graph-node-body').appendChild(controlsDiv);
          } else {
            const outputSocket = this._createSocket('output', node.id);
            nodeEl.appendChild(outputSocket);
          }
        }
        
        // Node dragging
        const header = nodeEl.querySelector('.graph-node-header');
        header.addEventListener('mousedown', (e) => {
          if (e.target.closest('.node-action-btn')) return;
          
          this.selectedNode = node;
          this.dragState = {
            node,
            startX: e.clientX,
            startY: e.clientY,
            nodeStartX: node.x,
            nodeStartY: node.y
          };
          
          document.querySelectorAll('.graph-node').forEach(n => n.classList.remove('selected'));
          nodeEl.classList.add('selected');
          
          const onMouseMove = (e) => {
            if (!this.dragState) return;
            
            const dx = e.clientX - this.dragState.startX;
            const dy = e.clientY - this.dragState.startY;
            
            // Calculate new position with bounds checking
            let newX = this.dragState.nodeStartX + dx;
            let newY = this.dragState.nodeStartY + dy;
            
            // Get node dimensions
            const nodeWidth = nodeEl.offsetWidth || 180;
            const nodeHeight = nodeEl.offsetHeight || 100;
            
            // Get canvas dimensions
            const canvasWidth = this.canvas.offsetWidth;
            const canvasHeight = this.canvas.offsetHeight;
            
            // Constrain within bounds (with some padding)
            const padding = 20;
            newX = Math.max(padding, Math.min(newX, canvasWidth - nodeWidth - padding));
            newY = Math.max(padding, Math.min(newY, canvasHeight - nodeHeight - padding));
            
            node.x = newX;
            node.y = newY;
            
            nodeEl.style.left = node.x + 'px';
            nodeEl.style.top = node.y + 'px';
            
            // Expand canvas if getting close to edge
            this._expandCanvasIfNeeded(node.x + nodeWidth, node.y + nodeHeight);
            
            this._updateConnections();
          };
          
          const onMouseUp = () => {
            this.dragState = null;
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
          };
          
          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseup', onMouseUp);
          
          e.stopPropagation();
        });
        
        // Copy button
        nodeEl.querySelector('.node-copy-btn').addEventListener('click', (e) => {
          e.stopPropagation();
          this.copyNode(node.id);
        });
        
        // Delete button
        nodeEl.querySelector('.node-delete-btn').addEventListener('click', (e) => {
          e.stopPropagation();
          this.deleteNode(node.id);
        });
        
        console.log(`Appending node ${node.id} to nodesContainer`);
        this.nodesContainer.appendChild(nodeEl);
        console.log(`✅ Node ${node.id} appended. Container children count: ${this.nodesContainer.children.length}`);
      }
      
      _createSocket(type, nodeId, index = 0) {
        const socket = document.createElement('div');
        socket.className = `node-socket ${type}`;
        socket.dataset.nodeId = nodeId;
        socket.dataset.socketType = type;
        socket.dataset.socketIndex = index;
        
        const label = document.createElement('span');
        label.className = 'socket-label';
        label.textContent = type === 'input' ? 'In' : (index > 0 ? `Out${index + 1}` : 'Out');
        socket.appendChild(label);
        
        socket.style.top = '50%';
        socket.style.transform = 'translateY(-50%)';
        
        // Socket interaction
        socket.addEventListener('mousedown', (e) => {
          e.stopPropagation();
          
          if (type === 'output') {
            this.connectionDrag = {
              fromNode: nodeId,
              fromType: type,
              fromIndex: index,
              startX: e.clientX,
              startY: e.clientY
            };
          }
        });
        
        socket.addEventListener('mouseup', (e) => {
          if (this.connectionDrag && type === 'input' && this.connectionDrag.fromNode !== nodeId) {
            this.createConnection(this.connectionDrag.fromNode, nodeId, this.connectionDrag.fromIndex);
          }
        });
        
        return socket;
      }
      
      _addParallelOutput(nodeId) {
        const node = this.nodes.find(n => n.id === nodeId);
        if (!node || node.type !== 'parallel') return;
        
        node.data.outputs = (node.data.outputs || 3) + 1;
        node.data.text = `${node.data.outputs} parallel outputs`;
        
        // Re-render node
        const nodeEl = document.querySelector(`.graph-node[data-node-id="${nodeId}"]`);
        if (nodeEl) {
          nodeEl.remove();
          this._renderNode(node);
        }
        
        console.log(`Added output to parallel node. Total outputs: ${node.data.outputs}`);
      }
      
      _removeParallelOutput(nodeId) {
        const node = this.nodes.find(n => n.id === nodeId);
        if (!node || node.type !== 'parallel') return;
        
        if (node.data.outputs <= 1) return;
        
        node.data.outputs = node.data.outputs - 1;
        node.data.text = `${node.data.outputs} parallel outputs`;
        
        // Re-render node
        const nodeEl = document.querySelector(`.graph-node[data-node-id="${nodeId}"]`);
        if (nodeEl) {
          nodeEl.remove();
          this._renderNode(node);
        }
        
        console.log(`Removed output from parallel node. Total outputs: ${node.data.outputs}`);
      }
      
      createConnection(fromNodeId, toNodeId) {
        // Check if connection already exists
        const exists = this.connections.some(c => 
          c.from === fromNodeId && c.to === toNodeId
        );
        
        if (exists) return;
        
        const connection = {
          id: this.connectionIdCounter++,
          from: fromNodeId,
          to: toNodeId
        };
        
        this.connections.push(connection);
        this._updateConnections();
        
        console.log('✅ Connection created:', connection);
      }
      
      _updateConnections() {
        this.svg.innerHTML = '';
        
        this.connections.forEach(conn => {
          const fromNode = this.nodes.find(n => n.id === conn.from);
          const toNode = this.nodes.find(n => n.id === conn.to);
          
          if (!fromNode || !toNode) return;
          
          const fromEl = document.querySelector(`[data-node-id="${conn.from}"].graph-node .node-socket.output`);
          const toEl = document.querySelector(`[data-node-id="${conn.to}"].graph-node .node-socket.input`);
          
          if (!fromEl || !toEl) return;
          
          // Get positions relative to the canvas
          const x1 = fromNode.x + fromEl.offsetParent.offsetWidth - 6;
          const y1 = fromNode.y + (fromEl.offsetTop || 30);
          const x2 = toNode.x - 6;
          const y2 = toNode.y + (toEl.offsetTop || 30);
          
          const path = this._createBezierPath(x1, y1, x2, y2);
          const pathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          pathEl.setAttribute('d', path);
          pathEl.setAttribute('class', 'node-connection');
          pathEl.setAttribute('data-connection-id', conn.id);
          
          pathEl.addEventListener('click', () => {
            if (confirm('Delete this connection?')) {
              this.deleteConnection(conn.id);
            }
          });
          
          this.svg.appendChild(pathEl);
        });
      }
      
      _createBezierPath(x1, y1, x2, y2) {
        const dx = Math.abs(x2 - x1);
        const offset = Math.min(dx * 0.5, 100);
        return `M ${x1} ${y1} C ${x1 + offset} ${y1}, ${x2 - offset} ${y2}, ${x2} ${y2}`;
      }
      
      _updateTempConnection(e) {
        if (!this.connectionDrag) return;
        
        const fromNode = this.nodes.find(n => n.id === this.connectionDrag.fromNode);
        if (!fromNode) return;
        
        const fromSocket = document.querySelector(
          `[data-node-id="${this.connectionDrag.fromNode}"].graph-node .node-socket.output`
        );
        
        if (!fromSocket) return;
        
        const container = this.canvas.parentElement;
        const canvasRect = this.canvas.getBoundingClientRect();
        const containerRect = container.getBoundingClientRect();
        
        // Get socket position relative to canvas
        const x1 = fromNode.x + fromSocket.offsetParent.offsetWidth - 6;
        const y1 = fromNode.y + (fromSocket.offsetTop || 30);
        
        // Get mouse position relative to canvas accounting for scroll
        const x2 = e.clientX - containerRect.left + container.scrollLeft;
        const y2 = e.clientY - containerRect.top + container.scrollTop;
        
        let tempPath = this.svg.querySelector('.temp-connection');
        if (!tempPath) {
          tempPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          tempPath.setAttribute('class', 'temp-connection');
          this.svg.appendChild(tempPath);
        }
        
        const path = this._createBezierPath(x1, y1, x2, y2);
        tempPath.setAttribute('d', path);
      }
      
      _endConnectionDrag() {
        const tempPath = this.svg.querySelector('.temp-connection');
        if (tempPath) {
          tempPath.remove();
        }
        this.connectionDrag = null;
      }
      
      copyNode(nodeId) {
        const node = this.nodes.find(n => n.id === nodeId);
        if (!node) return;
        
        const copy = this.createNode(
          node.type,
          node.x + 30,
          node.y + 30,
          { ...node.data, speaker: node.data.speaker + ' (Copy)' }
        );
        
        console.log('✅ Node copied:', copy);
        return copy;
      }
      
      deleteNode(nodeId) {
        const index = this.nodes.findIndex(n => n.id === nodeId);
        if (index === -1) return;

        this.nodes.splice(index, 1);
        this.connections = this.connections.filter(c => c.from !== nodeId && c.to !== nodeId);

        const nodeEl = document.querySelector(`[data-node-id="${nodeId}"].graph-node`);
        if (nodeEl) nodeEl.remove();

        this._updateConnections();

        console.log('✅ Node deleted:', nodeId);
        if (this.options.onNodeDeleted) {
          try {
            this.options.onNodeDeleted(nodeId);
          } catch (err) {
            console.warn('onNodeDeleted callback failed', err);
          }
        }
      }

      deleteConnection(connectionId) {
        const index = this.connections.findIndex(c => c.id === connectionId);
        if (index === -1) return;
        
        this.connections.splice(index, 1);
        this._updateConnections();
        
        console.log('✅ Connection deleted:', connectionId);
      }
      
      clear() {
        this.nodes = [];
        this.connections = [];
        this.nodesContainer.innerHTML = '';
        this.svg.innerHTML = '';
        if (this.options.onCleared) {
          try {
            this.options.onCleared();
          } catch (err) {
            console.warn('onCleared callback failed', err);
          }
        }
      }
    }

    // ===== MAIN APPLICATION =====
    class UnifiedSequenceBuilder {
      constructor() {
        this.dialogueManager = new DialogueManager();
        this.nodeGraphManager = null;
        this.viewportManager = null;
        this.resizableManager = null;
        this.propPreviewer = null;
        this.isOverlayMode = false;
        this.state = {
          currentScene: null,
          assets: null,
          selectedAsset: null,
          currentTab: 'timeline'
        };

        this.ui = {
          overlay: document.getElementById('builderOverlay'),
          container: document.getElementById('builderContainer'),
          sceneName: document.getElementById('sceneName'),
          sceneManagerContainer: document.getElementById('sceneManagerContainer'),
          totalEntities: document.getElementById('totalEntities'),
          totalComponents: document.getElementById('totalComponents'),
          inspector: document.getElementById('inspector'),
          codePreview: document.getElementById('codePreview'),
          dialogueCardsContainer: document.getElementById('dialogueCardsContainer'),
          loadingOverlay: document.getElementById('loadingOverlay'),
          loadingDetail: document.getElementById('loadingDetail'),
          fpsCounter: document.getElementById('fpsCounter'),
          objectCount: document.getElementById('objectCount'),
          triCount: document.getElementById('triCount'),
          propPreviewCanvas: document.getElementById('propPreviewCanvas'),
          propPreviewTitle: document.getElementById('propPreviewTitle'),
          propPreviewDescription: document.getElementById('propPreviewDescription'),
          propPreviewTags: document.getElementById('propPreviewTags')
        };

        this.nodeTagIndex = new Map();
        this.keyframeRegistry = new Map();
        this.dialogueTagIndex = new Map();
      }

      async init(overlayMode = false) {
        try {
        console.log('🎬 Initializing Unified Sequence Builder...');
        
        this.isOverlayMode = overlayMode;
        
        if (overlayMode) {
          this.ui.overlay.classList.add('active');
        } else {
          // Standalone mode - show container directly
          document.body.appendChild(this.ui.container);
        }
        
        this.ui.loadingDetail.textContent = 'Initializing scene viewport...';
          console.log('Step 1: Scene viewport...');

        // Initialize scene viewport
        const canvas = document.getElementById('sceneCanvas');
        this.viewportManager = new SceneViewportManager(canvas, {
          propLibrary,
          avatarFactory,
          arrayaFactory,
          roundedBoxGeometry: RoundedBoxGeometry,
          sceneData,
          previewRotation: Math.PI / 6,
          previewSpacing: { x: 1.2, z: 1.05 }
        });
        this.viewportManager.init();
        window.viewportManager = this.viewportManager;
          console.log('✅ Scene viewport initialized');

        // Initialize resizable panels
          this.ui.loadingDetail.textContent = 'Initializing panels...';
          console.log('Step 2: Resizable panels...');
        this.resizableManager = new ResizableManager(this.ui.container);
        this.resizableManager.init();
          console.log('✅ Resizable panels initialized');

          this.ui.loadingDetail.textContent = 'Initializing prop preview...';
          console.log('Step 3: Prop preview...');
        this.propPreviewer = new PropPreviewer(this.ui.propPreviewCanvas, {
          titleEl: this.ui.propPreviewTitle,
          descriptionEl: this.ui.propPreviewDescription,
          tagsEl: this.ui.propPreviewTags,
          assetLibrary: propLibrary,
          avatarFactory,
          arrayaFactory,
          roundedBoxGeometry: RoundedBoxGeometry,
          sceneData,
          previewSpacing: { x: 1.2, z: 1.05 }
        });
        await this.propPreviewer.init();
        window.propPreviewer = this.propPreviewer;
          console.log('✅ Prop preview initialized');

        this._bindPropPreviewResizer();

          // Initialize node graph
          this.ui.loadingDetail.textContent = 'Initializing node graph...';
          console.log('Step 4: Node graph...');
          const nodeCanvas = document.getElementById('nodeCanvas');
          const connectionsSvg = document.getElementById('connectionsSvg');
          const nodesContainer = document.getElementById('nodesContainer');
          this.nodeGraphManager = new NodeGraphManager(nodeCanvas, connectionsSvg, nodesContainer, {
            onNodeCreated: (node) => this._handleNodeCreated(node),
            onNodeDeleted: (nodeId) => this._handleNodeDeleted(nodeId),
            onCleared: () => this._handleGraphCleared()
          });
          window.nodeGraphManager = this.nodeGraphManager;
          window.sequenceBuilder = sequenceBuilder;
          console.log('✅ Node graph initialized');

          // Update connections on scroll and resize
          const timelineContainer = document.getElementById('timelineContainer');
          if (timelineContainer) {
            timelineContainer.addEventListener('scroll', () => {
              if (this.nodeGraphManager) {
                requestAnimationFrame(() => {
                  this.nodeGraphManager._updateConnections();
                });
              }
            });
          }
          
          // Update connections on window resize
          window.addEventListener('resize', () => {
            if (this.nodeGraphManager) {
              requestAnimationFrame(() => {
                this.nodeGraphManager._updateConnections();
              });
            }
            if (this.propPreviewer) {
              this.propPreviewer.handleResize();
            }
          });
          
          // Periodic connection update to handle panel resizing (less frequent now that we have scroll listeners)
          setInterval(() => {
            if (this.nodeGraphManager && this.nodeGraphManager.connections.length > 0) {
              this.nodeGraphManager._updateConnections();
            }
          }, 500);
        
        this.ui.loadingDetail.textContent = 'Detecting scene...';
          console.log('Step 5: Detecting scene...');

        const sceneName = this._detectCurrentScene();
        this.state.currentScene = sceneName;
        this.ui.sceneName.textContent = sceneName;
          console.log(`✅ Scene detected: ${sceneName}`);

          this.ui.loadingDetail.textContent = 'Generating assets...';
          console.log('Step 6: Generating assets...');
        this._generateMockAssets();
          console.log('✅ Assets generated');

          this.ui.loadingDetail.textContent = 'Rendering UI...';
          console.log('Step 7: Rendering UI...');
        this._renderAssetGroups();
          console.log('✅ Asset groups rendered');

          this.ui.loadingDetail.textContent = 'Setting up event listeners...';
          console.log('Step 8: Event listeners...');
        this._setupEventListeners();
          console.log('✅ Event listeners set up');

          this.ui.loadingDetail.textContent = 'Loading dialogues...';
          console.log('Step 9: Dialogues...');
        this._renderInitialDialogues();
          console.log('✅ Dialogues rendered');

          this.ui.loadingDetail.textContent = 'Extracting sequence nodes...';
          console.log('Step 10: Sequence nodes...');
        this._extractSequenceNodes();
          console.log('✅ Sequence nodes extracted');

          this.ui.loadingDetail.textContent = 'Updating code preview...';
          console.log('Step 11: Code preview...');
        this._updateCodePreview();
          console.log('✅ Code preview updated');

          this.ui.loadingDetail.textContent = 'Starting stats update...';
          console.log('Step 12: Stats...');
        this._startStatsUpdate();
          console.log('✅ Stats update started');
          
          this.ui.loadingDetail.textContent = 'Ready!';
        
        setTimeout(() => {
          this.ui.loadingOverlay.style.display = 'none';
          console.log('✅ Unified Sequence Builder Ready');
          }, 300);
          
        } catch (error) {
          console.error('❌ Error during initialization:', error);
          console.error('Stack trace:', error.stack);
          
          this.ui.loadingDetail.textContent = `Error: ${error.message}`;
          this.ui.loadingDetail.style.color = '#e74c3c';
          
          setTimeout(() => {
            this.ui.loadingOverlay.style.display = 'none';
            alert(`Initialization error:\n\n${error.message}\n\nSome features may not work. Check console for details.`);
          }, 1000);
        }
      }

      _detectCurrentScene() {
        if (window.opener && window.opener.introScene) {
          return 'IntroSceneComplete';
        }
        if (window.opener && window.opener.currentScene) {
          return window.opener.currentScene.constructor.name;
        }
        return 'IntroSceneComplete';
      }

      _generateMockAssets() {
        // Count scene data
        this.sceneManagerState = { collapsedCategories: new Set() };
        let totalEntities = 0;
        let totalComponents = 0;
        
        Object.keys(sceneData).forEach(category => {
          sceneData[category].forEach(entity => {
            totalEntities++;
            totalComponents += entity.components.length;
            if (entity.parts) {
              entity.parts.forEach(part => {
                totalComponents += part.components.length;
              });
            }
          });
        });
        
        // Update UI counts
        if (this.ui.totalEntities) this.ui.totalEntities.textContent = totalEntities;
        if (this.ui.totalComponents) this.ui.totalComponents.textContent = totalComponents;
      }

      _renderAssetGroups() {
        const container = document.getElementById('sceneManagerContainer');
        if (!container) return;
        
        container.innerHTML = '';
        
        Object.keys(sceneData).forEach(category => {
          const categoryDiv = document.createElement('div');
          categoryDiv.className = 'asset-group';
          
          const isCollapsed = this.sceneManagerState.collapsedCategories.has(category);
          const entities = sceneData[category];
          
          categoryDiv.innerHTML = `
            <div class="asset-group-header ${isCollapsed ? '' : 'active'}">
              <div class="asset-group-title">
                <span>${category}</span>
                <span class="asset-count">${entities.length}</span>
              </div>
              <span class="expand-icon">${isCollapsed ? '▶' : '▼'}</span>
            </div>
            <div class="asset-group-content ${isCollapsed ? '' : 'expanded'}">
              ${this._renderSceneEntities(category, entities)}
            </div>
          `;
          
          container.appendChild(categoryDiv);
          
          // Add toggle handler
          const header = categoryDiv.querySelector('.asset-group-header');
          const content = categoryDiv.querySelector('.asset-group-content');
          
          header.addEventListener('click', () => {
            const isExpanded = content.classList.contains('expanded');
            if (isExpanded) {
              content.classList.remove('expanded');
              header.classList.remove('active');
              this.sceneManagerState.collapsedCategories.add(category);
            } else {
              content.classList.add('expanded');
              header.classList.add('active');
              this.sceneManagerState.collapsedCategories.delete(category);
            }
          });
        });
      }
      
      _renderSceneEntities(category, entities) {
        return entities.map(entity => {
          const previewButton = entity.previewId
            ? `<button class="entity-btn" onclick='window.builderApp._previewAsset(${JSON.stringify(entity.previewId)}, ${JSON.stringify(entity.name)}, ${JSON.stringify(category)})'>Preview</button>`
            : '';

          let html = `
            <div class="scene-entity" data-entity="${entity.name}" data-category="${category}">
              <div class="entity-name">
                <span class="entity-icon">${entity.icon || '📦'}</span>
                <span>${entity.name}</span>
              </div>
              <div class="entity-actions">
                ${previewButton}
                <button class="entity-btn" onclick="window.builderApp._addObjectNode('${entity.name}', '${category}')">Add Node</button>
                <button class="entity-btn ingest-all" onclick="window.builderApp._ingestAllParameters('${entity.name}', '${category}')">Ingest All</button>
              </div>
            </div>
          `;
          
          // Add parts if any
          if (entity.parts && entity.parts.length > 0) {
            entity.parts.forEach(part => {
              html += `
                <div class="entity-part" onclick="window.builderApp._ingestEntityPart('${entity.name}', '${part.name}', '${category}')">
                  ↳ ${part.name}
                </div>
              `;
            });
          }
          
          return html;
        }).join('');
      }

      _previewAsset(previewId, entityName, category) {
        const entities = sceneData[category] || [];
        const entity = entities.find(e => e.name === entityName);

        if (category === 'Props' && this.propPreviewer) {
          this.state.selectedAsset = { id: previewId, name: entityName, category };
          this.propPreviewer.showProp(previewId, {
            title: entity?.name || entityName,
            description: entity?.description,
            tags: entity?.tags || [],
          });
        } else {
          console.log('ℹ️ Preview not available for', entityName, 'in category', category);
        }
      }
      
      _addObjectNode(entityName, category) {
        console.log(`Adding object node for: ${entityName} (${category})`);
        const entities = sceneData[category] || [];
        const entityMeta = entities.find(e => e.name === entityName);
        const previewId = entityMeta?.previewId || entityMeta?.id || null;
        const baseData = {
          speaker: entityName,
          text: `Object node for ${entityName}`,
          display: 'terminal',
          timestamp: this.nodeGraphManager ? this.nodeGraphManager.nodes.length * 0.5 : 0,
          duration: 1.5,
          nodeType: 'object',
          entityName,
          category,
          previewId,
          entityId: entityMeta?.id || entityName,
          icon: entityMeta?.icon,
          description: entityMeta?.description,
          propOptions: entityMeta?.defaultOptions || {}
        };

        if (this.nodeGraphManager) {
          const x = 200 + Math.random() * 320;
          const y = 160 + Math.random() * 260;
          this.nodeGraphManager.createNode('object', x, y, baseData);
        }

        const categoryTag = this._formatTagValue ? this._formatTagValue(category) : category?.toLowerCase();
        this.dialogueManager.createDialogue({
          ...baseData,
          tags: ['object', categoryTag, 'scene'].filter(Boolean)
        });

        this._renderDialogueCards();
      }
      
      _ingestAllParameters(entityName, category) {
        const entity = sceneData[category].find(e => e.name === entityName);
        if (!entity) return;
        
        console.log(`Ingesting all parameters for: ${entityName}`);
        
        const categoryTag = this._formatTagValue ? this._formatTagValue(category) : category?.toLowerCase();

        // Add main entity components
        entity.components.forEach(comp => {
          this.dialogueManager.createDialogue({
            speaker: `${entityName}.${comp.name}`,
            text: `Parameter: ${comp.path} (${comp.type})`,
            display: 'terminal',
            timestamp: 0,
            nodeType: 'parameter',
            path: comp.path,
            paramType: comp.type,
            tags: ['parameter', categoryTag, comp.type].filter(Boolean)
          });
        });
        
        // Add parts components
        if (entity.parts) {
          entity.parts.forEach(part => {
            part.components.forEach(comp => {
              this.dialogueManager.createDialogue({
                speaker: `${entityName}.${part.name}.${comp.name}`,
                text: `Parameter: ${comp.path} (${comp.type})`,
                display: 'terminal',
                timestamp: 0,
                nodeType: 'parameter',
                path: comp.path,
                paramType: comp.type,
                tags: ['parameter', categoryTag, part.name, comp.type].filter(Boolean)
              });
            });
          });
        }
        
        this._renderDialogueCards();
      }
      
      _ingestEntityPart(entityName, partName, category) {
        const entity = sceneData[category].find(e => e.name === entityName);
        if (!entity || !entity.parts) return;
        
        const part = entity.parts.find(p => p.name === partName);
        if (!part) return;
        
        console.log(`Ingesting part: ${entityName}.${partName}`);
        
        const xStart = 400;
        const yStart = 100;
        const spacing = 120;

        part.components.forEach((comp, i) => {
          this.nodeGraphManager.createNode('parameter', xStart, yStart + i * spacing, {
            speaker: `${entityName}.${partName}.${comp.name}`,
            text: `${comp.path} (${comp.type})`,
            path: comp.path,
            paramType: comp.type,
            duration: 0,
            tags: ['parameter', this._formatTagValue ? this._formatTagValue(partName) : partName, comp.type].filter(Boolean)
          });
        });
      }


      _renderInitialDialogues() {
        this.dialogueManager.createDialogue({
          speaker: 'System',
          text: 'Welcome to the unified sequence builder with scene viewport.',
          display: 'terminal',
          timestamp: 0
        });

        this._renderDialogueCards();
      }

      _renderDialogueCards() {
        this.ui.dialogueCardsContainer.innerHTML = this.dialogueManager.dialogues.map(dialogue => {
          const tags = Array.isArray(dialogue.tags) ? dialogue.tags.filter(Boolean) : [];
          const tagsHtml = tags.length
            ? `<div class="dialogue-tags">${tags.map(tag => `<span class=\"dialogue-tag\">${tag}</span>`).join('')}</div>`
            : '';

          return `
          <div class="dialogue-card" data-id="${dialogue.id}">
            <div class="dialogue-header">
              <div class="dialogue-speaker">${dialogue.speaker}</div>
              <div class="dialogue-actions">
                <button class="icon-btn" onclick="window.builderApp._editDialogue(${dialogue.id})">✏️</button>
                <button class="icon-btn" onclick="window.builderApp._deleteDialogue(${dialogue.id})">🗑️</button>
              </div>
            </div>
            <div class="dialogue-text">${dialogue.text}</div>
            <div class="dialogue-meta">
              <span>@${dialogue.timestamp.toFixed(1)}s</span>
              <span class="display-target">${dialogue.display}</span>
            </div>
            ${tagsHtml}
          </div>
        `;
        }).join('');

        this._rebuildDialogueTagIndex();

        document.querySelectorAll('.dialogue-card').forEach(card => {
          card.addEventListener('click', (e) => {
            if (!e.target.closest('.icon-btn')) {
              this._selectDialogue(parseInt(card.dataset.id));
            }
          });
        });
      }

      _rebuildDialogueTagIndex() {
        this.dialogueTagIndex.clear();
        this.dialogueManager.dialogues.forEach(dialogue => {
          if (!dialogue || !Array.isArray(dialogue.tags)) return;
          dialogue.tags.forEach(tag => {
            if (!tag) return;
            if (!this.dialogueTagIndex.has(tag)) {
              this.dialogueTagIndex.set(tag, new Set());
            }
            this.dialogueTagIndex.get(tag).add(dialogue.id);
          });
        });
      }

      _handleNodeCreated(node) {
        if (!node) return;
        node.data = node.data || {};

        const initialTags = Array.isArray(node.data?.tags) ? node.data.tags : [];
        const tags = this._generateTagsForNode(node);
        node.data.tags = tags;
        if (initialTags.length) {
          node.data.sourceTags = initialTags;
        }
        this._indexNodeTags(node, tags);

        const keyframes = this._generateKeyframesForNode(node);
        if (keyframes.length) {
          node.data.keyframes = keyframes;
          this.keyframeRegistry.set(node.id, keyframes);
        } else {
          this.keyframeRegistry.delete(node.id);
        }

        if (this.viewportManager && typeof this.viewportManager.addNodePreview === 'function') {
          this.viewportManager.addNodePreview(node);
        }

        this._updateCodePreview();
      }

      _handleNodeDeleted(nodeId) {
        this._removeNodeFromTagIndex(nodeId);
        this.keyframeRegistry.delete(nodeId);
        if (this.viewportManager && typeof this.viewportManager.removeNodePreview === 'function') {
          this.viewportManager.removeNodePreview(nodeId);
        }
        this._updateCodePreview();
      }

      _handleGraphCleared() {
        this.nodeTagIndex.clear();
        this.keyframeRegistry.clear();
        if (this.viewportManager && typeof this.viewportManager.clearNodePreviews === 'function') {
          this.viewportManager.clearNodePreviews();
        }
        this._updateCodePreview();
      }

      _generateTagsForNode(node) {
        const tags = [
          'sequence',
          node.type,
          node.data?.nodeType,
          node.data?.display,
          node.data?.category,
          node.data?.entityName
        ];

        if (Array.isArray(node.data?.tags)) {
          node.data.tags.forEach(tag => tags.push(tag));
        }

        if (node.data?.path) {
          node.data.path.split('.').slice(0, 3).forEach(segment => tags.push(segment));
        }

        if (node.data?.timestamp !== undefined) tags.push('timed');
        if (node.type === 'animation' || node.type === 'transition') tags.push('animation');
        if (node.type === 'parameter') tags.push('parameter');
        if (node.type === 'dialogue') tags.push('card');
        if (node.type === 'event') tags.push('event');

        return this._normalizeTagSet(tags);
      }

      _generateKeyframesForNode(node) {
        const keyframes = [];
        const start = parseFloat(node.data?.timestamp);
        const duration = parseFloat(node.data?.duration);

        if (!Number.isNaN(start)) {
          keyframes.push({ time: start, action: 'start' });

          if (!Number.isNaN(duration)) {
            keyframes.push({ time: start + duration, action: 'end' });
          }
        }

        if (node.data?.path) {
          keyframes.push({ time: Number.isNaN(start) ? 0 : start, action: node.data.path });
        }

        return keyframes;
      }

      _indexNodeTags(node, tags) {
        if (!Array.isArray(tags)) return;
        tags.forEach(tag => {
          if (!tag) return;
          if (!this.nodeTagIndex.has(tag)) {
            this.nodeTagIndex.set(tag, new Set());
          }
          this.nodeTagIndex.get(tag).add(node.id);
        });
      }

      _removeNodeFromTagIndex(nodeId) {
        this.nodeTagIndex.forEach((set, tag) => {
          if (set.has(nodeId)) {
            set.delete(nodeId);
            if (set.size === 0) {
              this.nodeTagIndex.delete(tag);
            }
          }
        });
      }

      _normalizeTagSet(rawTags = []) {
        const normalized = new Set();
        rawTags.forEach(tag => {
          const formatted = this._formatTagValue(tag);
          if (formatted) normalized.add(formatted);
        });
        return Array.from(normalized);
      }

      _formatTagValue(value) {
        if (value === undefined || value === null) return null;
        return String(value)
          .replace(/[_-]/g, ' ')
          .replace(/([a-z])([A-Z])/g, '$1 $2')
          .trim()
          .toLowerCase();
      }

      _formatLabel(value) {
        const normalized = this._formatTagValue(value);
        if (!normalized) return '';
        return normalized.replace(/\b\w/g, char => char.toUpperCase());
      }

      _ingestUniversalCollections(sceneObject, startX, startY, xSpacing, ySpacing) {
        if (!this.nodeGraphManager) {
          return { nodes: [], nextX: startX, nextY: startY };
        }

        const keys = ['cards', 'cardDeck', 'dialogues', 'panels', 'overlays', 'cssLayers', 'css', 'styles', 'screens', 'landingPages', 'referrerPages'];
        const nodes = [];
        let currentX = startX;
        let currentY = startY;

        keys.forEach((key, index) => {
          const collection = sceneObject[key];
          if (!collection) return;

          const items = Array.isArray(collection)
            ? collection
            : typeof collection === 'object'
              ? Object.values(collection)
              : [];

          if (!items || items.length === 0) return;

          items.forEach((item, itemIndex) => {
            const label = item?.name || item?.title || `Item ${itemIndex + 1}`;
            const description = typeof item === 'string'
              ? item
              : item?.description || item?.text || `${this._formatLabel(key)} entry`;
            const slug = this._formatTagValue(label)?.replace(/\s+/g, '_') || `item_${itemIndex + 1}`;
            const node = this.nodeGraphManager.createNode('parameter', currentX, currentY, {
              speaker: `${this._formatLabel(key)}: ${label}`,
              text: description.length > 140 ? `${description.slice(0, 137)}...` : description,
              path: `${key}.${slug}`,
              duration: item?.duration || 0,
              nodeType: 'parameter',
              tags: [key, item?.type, item?.category, item?.layer]
                .map(value => this._formatTagValue(value))
                .filter(Boolean)
            });

            if (node) {
              if (item?.timeline) {
                node.data.timeline = item.timeline;
              }
              if (item?.events) {
                node.data.events = item.events;
              }
              nodes.push(node);
              currentY += ySpacing;
            }
          });

          currentX += xSpacing * 0.7;
          currentY = startY;
        });

        return { nodes, nextX: currentX, nextY: currentY };
      }

      _selectDialogue(id) {
        document.querySelectorAll('.dialogue-card').forEach(el => el.classList.remove('selected'));
        const card = document.querySelector(`.dialogue-card[data-id="${id}"]`);
        if (card) card.classList.add('selected');

        const dialogue = this.dialogueManager.dialogues.find(d => d.id === id);
        if (dialogue) {
          this._showDialogueInspector(dialogue);
        }
      }

      _showDialogueInspector(dialogue) {
        const displayMode = dialogue.displayMode || 'card';
        const screenTarget = dialogue.screenTarget || 'screen1';
        
        this.ui.inspector.innerHTML = `
          <div class="property-group">
            <div class="property-label">Speaker</div>
            <input type="text" class="property-input" id="dialogueSpeaker" value="${dialogue.speaker}">
          </div>
          
          <div class="property-group">
            <div class="property-label">Text</div>
            <textarea class="property-input" id="dialogueText">${dialogue.text}</textarea>
          </div>
          
          <div class="property-group">
            <div class="property-label">Display Target</div>
            <select class="property-input" id="dialogueDisplay">
              <option value="terminal" ${dialogue.display === 'terminal' ? 'selected' : ''}>Terminal</option>
              <option value="notepad" ${dialogue.display === 'notepad' ? 'selected' : ''}>Notepad</option>
              <option value="subtitle" ${dialogue.display === 'subtitle' ? 'selected' : ''}>Subtitle</option>
              <option value="popup" ${dialogue.display === 'popup' ? 'selected' : ''}>Popup</option>
            </select>
          </div>
          
          <div class="dialogue-display-mode">
            <label class="mode-label">Display Mode</label>
            <div class="mode-options">
              <button class="mode-option-btn ${displayMode === 'card' ? 'active' : ''}" data-mode="card">Card/Terminal</button>
              <button class="mode-option-btn ${displayMode === 'screen' ? 'active' : ''}" data-mode="screen">On Screen</button>
            </div>
            
            <div id="screenTargetGroup" style="${displayMode === 'screen' ? 'display: block;' : 'display: none;'}">
              <label class="mode-label">Screen Target</label>
              <select class="property-input" id="dialogueScreenTarget">
                <option value="screen1" ${screenTarget === 'screen1' ? 'selected' : ''}>Screen 1</option>
                <option value="screen2" ${screenTarget === 'screen2' ? 'selected' : ''}>Screen 2</option>
                <option value="screen3" ${screenTarget === 'screen3' ? 'selected' : ''}>Screen 3</option>
                <option value="mainDisplay" ${screenTarget === 'mainDisplay' ? 'selected' : ''}>Main Display</option>
                <option value="hudOverlay" ${screenTarget === 'hudOverlay' ? 'selected' : ''}>HUD Overlay</option>
              </select>
            </div>
          </div>
          
          <div class="property-group">
            <div class="property-label">Timestamp (s)</div>
            <input type="number" class="property-input" id="dialogueTimestamp" value="${dialogue.timestamp}" step="0.1" min="0">
          </div>
          
          <button class="btn btn-primary" onclick="window.builderApp._saveDialogueChanges(${dialogue.id})" style="width: 100%; margin-top: 10px; padding: 8px;">
            💾 Save Changes
          </button>
          
          <button class="btn btn-secondary" onclick="window.builderApp._copyDialogue(${dialogue.id})" style="width: 100%; margin-top: 8px; padding: 8px;">
            📋 Copy Node
          </button>
          
          <!-- Execute After Panel -->
          <div class="execute-after-panel">
            <div class="execute-after-header" onclick="window.builderApp._toggleExecuteAfter(${dialogue.id})">
              <div class="execute-after-title">▶ Execute After</div>
              <div class="execute-after-toggle" id="executeAfterToggle-${dialogue.id}">Click to expand</div>
            </div>
            <div class="execute-after-content" id="executeAfterContent-${dialogue.id}">
              <div class="execute-after-controls">
                <button class="execute-after-btn" onclick="window.builderApp._selectAllExecuteAfter(${dialogue.id})">All</button>
                <button class="execute-after-btn secondary" onclick="window.builderApp._selectNoneExecuteAfter(${dialogue.id})">None</button>
              </div>
              <div class="execute-after-hierarchy" id="executeAfterHierarchy-${dialogue.id}">
                Loading...
              </div>
            </div>
          </div>
        `;
        
        // Add event listeners for mode buttons
        document.querySelectorAll('.mode-option-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            document.querySelectorAll('.mode-option-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            
            const screenTargetGroup = document.getElementById('screenTargetGroup');
            if (btn.dataset.mode === 'screen') {
              screenTargetGroup.style.display = 'block';
            } else {
              screenTargetGroup.style.display = 'none';
            }
          });
        });
      }

      _saveDialogueChanges(id) {
        const activeMode = document.querySelector('.mode-option-btn.active');
        const displayMode = activeMode ? activeMode.dataset.mode : 'card';
        
        const updates = {
          speaker: document.getElementById('dialogueSpeaker').value,
          text: document.getElementById('dialogueText').value,
          display: document.getElementById('dialogueDisplay').value,
          timestamp: parseFloat(document.getElementById('dialogueTimestamp').value),
          displayMode: displayMode
        };
        
        // Only save screen target if in screen mode
        if (displayMode === 'screen') {
          const screenTargetEl = document.getElementById('dialogueScreenTarget');
          if (screenTargetEl) {
            updates.screenTarget = screenTargetEl.value;
          }
        }
        
        this.dialogueManager.updateDialogue(id, updates);
        this._renderDialogueCards();
        this._updateCodePreview();
        
        console.log('✅ Dialogue saved:', updates);
      }

      _copyDialogue(id) {
        const dialogue = this.dialogueManager.dialogues.find(d => d.id === id);
        if (!dialogue) return;
        
        // Create a copy with new ID
        const copy = this.dialogueManager.createDialogue({
          ...dialogue,
          id: undefined, // Will be generated
          speaker: dialogue.speaker + ' (Copy)',
          timestamp: dialogue.timestamp + 0.5
        });
        
        this._renderDialogueCards();
        this._selectDialogue(copy.id);
        
        console.log('✅ Dialogue copied:', copy);
      }

      _editDialogue(id) {
        this._selectDialogue(id);
      }

      _deleteDialogue(id) {
        if (confirm('Delete this dialogue?')) {
          this.dialogueManager.deleteDialogue(id);
          this._renderDialogueCards();
          this._updateCodePreview();
        }
      }

      _updateCodePreview() {
        const dialogues = this.dialogueManager.exportDialogues();
        const nodes = this.nodeGraphManager ? this.nodeGraphManager.nodes : [];

        let code = `<span class="code-comment">// Scene: ${this.state.currentScene || 'Unknown'}</span>\n`;
        code += `<span class="code-keyword">const</span> sequence = {\n`;
        code += `  <span class="code-string">dialogues</span>: [\n`;

        dialogues.dialogues.forEach((d, i) => {
          const tags = Array.isArray(d.tags) && d.tags.length
            ? `, <span class="code-string">tags</span>: [${d.tags.map(tag => `<span class=\"code-string\">\"${tag}\"</span>`).join(', ')}]`
            : '';

          code += `    {\n`;
          code += `      <span class="code-string">speaker</span>: <span class="code-string">"${d.speaker}"</span>,\n`;
          code += `      <span class="code-string">text</span>: <span class="code-string">"${d.text}"</span>,\n`;
          code += `      <span class="code-string">display</span>: <span class="code-string">"${d.display}"</span>,\n`;
          code += `      <span class="code-string">timestamp</span>: <span class="code-number">${d.timestamp}</span>${tags}\n`;
          code += `    }${i < dialogues.count - 1 ? ',' : ''}\n`;
        });

        code += `  ]`;

        if (nodes.length) {
          code += `,\n  <span class="code-string">nodes</span>: [\n`;
          nodes.forEach((node, index) => {
            const tagList = Array.isArray(node.data?.tags) && node.data.tags.length
              ? `[${node.data.tags.map(tag => `<span class=\"code-string\">\"${tag}\"</span>`).join(', ')}]`
              : '[]';
            const keyframes = Array.isArray(node.data?.keyframes) && node.data.keyframes.length
              ? `[${node.data.keyframes.map(kf => `{ <span class="code-string">time</span>: <span class="code-number">${Number(kf.time).toFixed ? Number(kf.time).toFixed(2) : kf.time}</span>, <span class="code-string">action</span>: <span class="code-string">"${kf.action}"</span> }`).join(', ')}]`
              : '[]';

            code += `    {\n`;
            code += `      <span class="code-string">id</span>: <span class="code-number">${node.id}</span>,\n`;
            code += `      <span class="code-string">type</span>: <span class="code-string">"${node.type}"</span>,\n`;
            code += `      <span class="code-string">label</span>: <span class="code-string">"${node.data?.speaker || node.type}"</span>,\n`;
            code += `      <span class="code-string">timestamp</span>: <span class="code-number">${Number(node.data?.timestamp ?? 0)}</span>,\n`;
            code += `      <span class="code-string">duration</span>: <span class="code-number">${Number(node.data?.duration ?? 0)}</span>,\n`;
            code += `      <span class="code-string">tags</span>: ${tagList},\n`;
            code += `      <span class="code-string">keyframes</span>: ${keyframes}\n`;
            code += `    }${index < nodes.length - 1 ? ',' : ''}\n`;
          });
          code += `  ]`;
        }

        const tagSummaries = [];
        this.nodeTagIndex.forEach((nodeSet, tag) => {
          tagSummaries.push({
            tag,
            nodes: nodeSet.size,
            dialogues: this.dialogueTagIndex.get(tag)?.size || 0
          });
        });
        this.dialogueTagIndex.forEach((dialogueSet, tag) => {
          if (!this.nodeTagIndex.has(tag)) {
            tagSummaries.push({ tag, nodes: 0, dialogues: dialogueSet.size });
          }
        });

        if (tagSummaries.length) {
          tagSummaries.sort((a, b) => a.tag.localeCompare(b.tag));
          code += `,\n  <span class="code-string">tags</span>: {\n`;
          tagSummaries.forEach((entry, index) => {
            code += `    <span class="code-string">"${entry.tag}"</span>: { <span class="code-string">nodes</span>: <span class="code-number">${entry.nodes}</span>, <span class="code-string">dialogues</span>: <span class="code-number">${entry.dialogues}</span> }${index < tagSummaries.length - 1 ? ',' : ''}\n`;
          });
          code += `  }`;
        }

        code += `\n};\n\n`;
        code += `<span class="code-keyword">export</span> <span class="code-keyword">default</span> sequence;`;

        this.ui.codePreview.innerHTML = code;
      }

      _startStatsUpdate() {
        setInterval(() => {
          if (this.viewportManager) {
            this.ui.objectCount.textContent = this.viewportManager.stats.objects;
            this.ui.triCount.textContent = this.viewportManager.stats.tris;
          }
        }, 100);
      }
      
      _extractSequenceNodes() {
        const nodes = [];
        
        try {
          // Try to get sequence data from live scene
          const liveScene = this.viewportManager?.getLiveScene?.();
          if (liveScene && liveScene.sceneObject) {
            const sceneObj = liveScene.sceneObject;
            
            // Extract timing data from scene
            if (sceneObj.introCfg) {
              const cfg = sceneObj.introCfg;
              
              // Create nodes from intro config
              if (cfg.rollEnd) nodes.push({ name: 'Roll Phase', time: 0, duration: cfg.rollEnd, type: 'animation' });
              if (cfg.bounceEnd) nodes.push({ name: 'Bounce Phase', time: cfg.rollEnd || 0, duration: (cfg.bounceEnd - (cfg.rollEnd || 0)), type: 'animation' });
              if (cfg.triangleEnd) nodes.push({ name: 'Triangle Form', time: cfg.bounceEnd || 0, duration: (cfg.triangleEnd - (cfg.bounceEnd || 0)), type: 'animation' });
              if (cfg.transitionEnd) nodes.push({ name: 'Orbit Transition', time: cfg.triangleEnd || 0, duration: (cfg.transitionEnd - (cfg.triangleEnd || 0)), type: 'animation' });
              if (cfg.normalEnd) nodes.push({ name: 'Normal Mode', time: cfg.transitionEnd || 0, duration: (cfg.normalEnd - (cfg.transitionEnd || 0)), type: 'animation' });
              if (cfg.vennEnd) nodes.push({ name: 'Venn Diagram', time: cfg.normalEnd || 0, duration: (cfg.vennEnd - (cfg.normalEnd || 0)), type: 'effect' });
              if (cfg.collapseEnd) nodes.push({ name: 'Collapse', time: cfg.vennEnd || 0, duration: (cfg.collapseEnd - (cfg.vennEnd || 0)), type: 'transition' });
              if (cfg.glitchEnd) nodes.push({ name: 'Glitch Effect', time: cfg.collapseEnd || 0, duration: (cfg.glitchEnd - (cfg.collapseEnd || 0)), type: 'effect' });
              if (cfg.blackoutEnd) nodes.push({ name: 'Blackout', time: cfg.glitchEnd || 0, duration: (cfg.blackoutEnd - (cfg.glitchEnd || 0)), type: 'transition' });
              if (cfg.loomworksEnd) nodes.push({ name: 'Loomworks Text', time: cfg.blackoutEnd || 0, duration: (cfg.loomworksEnd - (cfg.blackoutEnd || 0)), type: 'text' });
              if (cfg.celliEnd) nodes.push({ name: 'CELLI Voxel', time: cfg.loomworksEnd || 0, duration: (cfg.celliEnd - (cfg.loomworksEnd || 0)), type: 'animation' });
              if (cfg.doorwayEnd) nodes.push({ name: 'Doorway Portal', time: cfg.celliEnd || 0, duration: (cfg.doorwayEnd - (cfg.celliEnd || 0)), type: 'transition' });
            }
            
            // Extract from motionCfg
            if (sceneObj.motionCfg) {
              console.log('Found motion config:', sceneObj.motionCfg);
            }
            
            // Check for sequence property
            if (sceneObj.sequence && Array.isArray(sceneObj.sequence)) {
              sceneObj.sequence.forEach((seq, i) => {
                nodes.push({
                  name: seq.name || `Sequence ${i + 1}`,
                  time: seq.startTime || seq.time || 0,
                  duration: seq.duration || 1.0,
                  type: seq.type || 'animation'
                });
              });
            }
          }
        } catch (e) {
          console.warn('Could not extract sequence nodes:', e);
        }
        
        // If no nodes found, create sample
        if (nodes.length === 0) {
          nodes.push({ name: 'Sample Node', time: 0, duration: 2.0, type: 'animation' });
          nodes.push({ name: 'Effect', time: 2.5, duration: 1.5, type: 'effect' });
          nodes.push({ name: 'Transition', time: 4.5, duration: 1.0, type: 'transition' });
        }
        
        this._renderTimelineNodes(nodes);
      }
      
      _renderTimelineNodes(nodes) {
        const container = document.getElementById('timelineNodes');
        if (!container) return;
        
        container.innerHTML = '';
        
        const pixelsPerSecond = 50;
        const trackHeight = 60;
        
        nodes.forEach((node, index) => {
          const nodeEl = document.createElement('div');
          nodeEl.className = 'sequence-node-item';
          nodeEl.dataset.index = index;
          
          const left = 20 + (node.time * pixelsPerSecond);
          const width = node.duration * pixelsPerSecond;
          const top = 20 + (index % 5) * (trackHeight + 10);
          
          nodeEl.style.left = `${left}px`;
          nodeEl.style.top = `${top}px`;
          nodeEl.style.width = `${Math.max(width, 100)}px`;
          
          // Color by type
          const typeColors = {
            animation: 'linear-gradient(135deg, #3498db 0%, #2980b9 100%)',
            effect: 'linear-gradient(135deg, #e74c3c 0%, #c0392b 100%)',
            transition: 'linear-gradient(135deg, #f39c12 0%, #d68910 100%)',
            text: 'linear-gradient(135deg, #16a085 0%, #138d75 100%)',
            sound: 'linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%)'
          };
          
          nodeEl.style.background = typeColors[node.type] || typeColors.animation;
          
          nodeEl.innerHTML = `
            <div>${node.name}</div>
            <div class="node-time">@${node.time.toFixed(1)}s (${node.duration.toFixed(1)}s)</div>
          `;
          
          nodeEl.addEventListener('click', () => {
            document.querySelectorAll('.sequence-node-item').forEach(n => n.classList.remove('selected'));
            nodeEl.classList.add('selected');
            this._showNodeInspector(node);
          });
          
          container.appendChild(nodeEl);
        });
        
        console.log(`✅ Rendered ${nodes.length} sequence nodes`);
      }
      
      _showNodeInspector(node) {
        this.ui.inspector.innerHTML = `
          <div class="inspector-section">
            <div class="inspector-section-title">📦 Sequence Node</div>
            
            <div class="property-group">
              <div class="property-label">Name</div>
              <input type="text" class="property-input" value="${node.name}" readonly>
            </div>
            
            <div class="property-group">
              <div class="property-label">Type</div>
              <input type="text" class="property-input" value="${node.type}" readonly>
            </div>
            
            <div class="property-group">
              <div class="property-label">Start Time (s)</div>
              <input type="number" class="property-input" value="${node.time}" readonly>
            </div>
            
            <div class="property-group">
              <div class="property-label">Duration (s)</div>
              <input type="number" class="property-input" value="${node.duration}" readonly>
            </div>
          </div>
        `;
      }
      
      _showObjectInspector(object) {
        const position = object.position ? `(${object.position.x.toFixed(2)}, ${object.position.y.toFixed(2)}, ${object.position.z.toFixed(2)})` : 'N/A';
        const rotation = object.rotation ? `(${(object.rotation.x * 180 / Math.PI).toFixed(1)}°, ${(object.rotation.y * 180 / Math.PI).toFixed(1)}°, ${(object.rotation.z * 180 / Math.PI).toFixed(1)}°)` : 'N/A';
        const scale = object.scale ? `(${object.scale.x.toFixed(2)}, ${object.scale.y.toFixed(2)}, ${object.scale.z.toFixed(2)})` : 'N/A';
        
        this.ui.inspector.innerHTML = `
          <div class="inspector-section">
            <div class="inspector-section-title">🎯 Selected Object</div>
            
            <div class="property-group">
              <div class="property-label">Name</div>
              <input type="text" class="property-input" value="${object.name || '(unnamed)'}" readonly>
            </div>
            
            <div class="property-group">
              <div class="property-label">Type</div>
              <input type="text" class="property-input" value="${object.type}" readonly>
            </div>
            
            <div class="property-group">
              <div class="property-label">Position</div>
              <input type="text" class="property-input" value="${position}" readonly>
            </div>
            
            <div class="property-group">
              <div class="property-label">Rotation</div>
              <input type="text" class="property-input" value="${rotation}" readonly>
            </div>
            
            <div class="property-group">
              <div class="property-label">Scale</div>
              <input type="text" class="property-input" value="${scale}" readonly>
            </div>
            
            ${object.material ? `
              <div class="property-group">
                <div class="property-label">Material</div>
                <input type="text" class="property-input" value="${object.material.type}" readonly>
              </div>
            ` : ''}
            
            ${object.geometry ? `
              <div class="property-group">
                <div class="property-label">Geometry</div>
                <input type="text" class="property-input" value="${object.geometry.type || 'BufferGeometry'}" readonly>
              </div>
            ` : ''}
            
            <div class="property-group">
              <div class="property-label">Visible</div>
              <input type="text" class="property-input" value="${object.visible ? 'Yes' : 'No'}" readonly>
            </div>
          </div>
        `;
      }

      _setupEventListeners() {
        // Tab switching
        document.querySelectorAll('.tab-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            const tab = btn.dataset.tab;
            
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            
            btn.classList.add('active');
            const tabEl = document.getElementById(`${tab}-tab`);
            if (tabEl) tabEl.classList.add('active');
            
            this.state.currentTab = tab;
          });
        });

        // Viewport controls
        const viewportModeButtons = document.querySelectorAll('.viewport-btn[data-mode]');
        viewportModeButtons.forEach(btn => {
          btn.addEventListener('click', () => {
            viewportModeButtons.forEach(b => b.classList.toggle('active', b === btn));
            const mode = btn.dataset.mode;

            switch (mode) {
              case 'render':
                this.viewportManager.setWireframe(false);
                this.viewportManager.setLightingMode('default');
                break;
              case 'wireframe':
                this.viewportManager.setLightingMode('default');
                this.viewportManager.setWireframe(true);
                break;
              case 'unlit':
                this.viewportManager.setWireframe(false);
                this.viewportManager.setLightingMode('unlit');
                break;
              case 'flat':
                this.viewportManager.setWireframe(false);
                this.viewportManager.setLightingMode('flat');
                break;
              default:
                this.viewportManager.setWireframe(false);
                this.viewportManager.setLightingMode('default');
                break;
            }
          });
        });

        const viewResetBtn = document.getElementById('viewResetBtn');
        if (viewResetBtn) {
          viewResetBtn.addEventListener('click', () => {
            this.viewportManager.resetCamera();
            this.viewportManager.setWireframe(false);
            this.viewportManager.setLightingMode('default');
            viewportModeButtons.forEach(btn => btn.classList.toggle('active', btn.dataset.mode === 'render'));
          });
        }
        
        // Camera picker
        const cameraSelect = document.getElementById('cameraSelect');
        if (cameraSelect) {
          cameraSelect.addEventListener('change', (e) => {
          this.viewportManager.switchCamera(e.target.value);
        });
        }
        
        // Play button
        const playSceneBtn = document.getElementById('playSceneBtn');
        if (playSceneBtn) {
          playSceneBtn.addEventListener('click', () => {
          this.viewportManager.play();
        });
        }
        
        // Pause button
        const pauseSceneBtn = document.getElementById('pauseSceneBtn');
        if (pauseSceneBtn) {
          pauseSceneBtn.addEventListener('click', () => {
          this.viewportManager.pause();
        });
        }

        // Add dialogue
        const addDialogueBtn = document.getElementById('addDialogueBtn');
        if (addDialogueBtn) {
          addDialogueBtn.addEventListener('click', () => {
          const dialogue = this.dialogueManager.createDialogue({
            speaker: 'New Speaker',
            text: 'Enter dialogue text here...',
            display: 'subtitle',
            timestamp: 0
          });
          this._renderDialogueCards();
          this._selectDialogue(dialogue.id);
        });
        }

        // Cast to display
        const castToDisplayBtn = document.getElementById('castToDisplayBtn');
        if (castToDisplayBtn) {
          castToDisplayBtn.addEventListener('click', () => {
          const selected = document.querySelector('.dialogue-card.selected');
          if (!selected) {
            alert('Please select a dialogue first');
            return;
          }
          
          const display = document.getElementById('displaySelect').value;
          const id = parseInt(selected.dataset.id);
          this.dialogueManager.updateDialogue(id, { display });
          this._renderDialogueCards();
        });
        }

        // Analyze button
        const analyzeBtn = document.getElementById('analyzeBtn');
        if (analyzeBtn) {
          analyzeBtn.addEventListener('click', () => {
          console.log('🔍 Re-analyzing scene...');
          this._generateMockAssets();
          this._renderAssetGroups();
          this._updateCodePreview();
        });
        }
        
        // Refresh Nodes button
        const refreshNodesBtn = document.getElementById('refreshNodesBtn');
        if (refreshNodesBtn) {
          refreshNodesBtn.addEventListener('click', () => {
          console.log('🔄 Refreshing sequence nodes...');
          this._extractSequenceNodes();
        });
        }

        // Export
        const exportBtn = document.getElementById('exportBtn');
        if (exportBtn) {
          exportBtn.addEventListener('click', () => {
          const data = {
            scene: this.state.currentScene,
            dialogues: this.dialogueManager.exportDialogues(),
            timestamp: Date.now()
          };
          
          const json = JSON.stringify(data, null, 2);
          const blob = new Blob([json], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `sequence_${this.state.currentScene}_${Date.now()}.json`;
          a.click();
          URL.revokeObjectURL(url);
          
          navigator.clipboard.writeText(json);
          alert('✅ Exported and copied to clipboard!');
        });
        }

        // Copy code
        const copyCodeBtn = document.getElementById('copyCodeBtn');
        if (copyCodeBtn) {
          copyCodeBtn.addEventListener('click', () => {
          const code = this.ui.codePreview.innerText;
          navigator.clipboard.writeText(code);
          alert('✅ Copied to clipboard!');
        });
        }

        // Close
        const closeBtn = document.getElementById('closeBtn');
        if (closeBtn) {
          closeBtn.addEventListener('click', () => {
          if (this.isOverlayMode) {
            this.close();
            // Notify parent window
            if (window.parent && window.parent !== window) {
              window.parent.postMessage({ type: 'closeSequenceBuilder' }, '*');
            }
          } else {
            if (confirm('Close Sequence Builder?')) {
              window.close();
            }
          }
        });
        }
        
        // Node Tools Panel
        document.querySelectorAll('.node-tool-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            const nodeType = btn.dataset.nodeType;
            console.log(`Creating ${nodeType} node from tools panel`);
            
            const nodeDefaults = {
              dialogue: {
                speaker: 'New Speaker',
                text: 'Enter dialogue text here...'
              },
              animation: {
                speaker: 'Animation',
                text: 'Configure animation properties'
              },
              delay: {
                speaker: 'Delay',
                text: 'Duration: 1.0s'
              },
              transition: {
                speaker: 'Transition',
                text: 'Configure transition'
              },
              parameter: {
                speaker: 'Parameter',
                text: 'Select from Scene Manager'
              },
              event: {
                speaker: 'Event Trigger',
                text: 'Event: custom_event'
              },
              object: {
                speaker: 'Object',
                text: 'Select from Scene Manager'
              },
              snapshot: {
                speaker: 'Snapshot',
                text: 'Capture object state'
              },
              parallel: {
                speaker: 'Parallel',
                text: '3 parallel outputs',
                outputs: 3
              }
            };
            
            const defaults = nodeDefaults[nodeType] || nodeDefaults.dialogue;
            
            // Create node on canvas
            const x = 150 + Math.random() * 300;
            const y = 150 + Math.random() * 300;
            
            this.nodeGraphManager.createNode(nodeType, x, y, defaults);
          });
        });
        
        // Auto-Ingest Scene button
        const autoIngestBtn = document.getElementById('autoIngestBtn');
        if (autoIngestBtn) {
          autoIngestBtn.addEventListener('click', async () => {
            console.log('🔄 Auto-ingesting scene...');
            
            const sceneDropdown = document.getElementById('sceneDropdown');
            const selectedScene = sceneDropdown ? sceneDropdown.value : '';
            
            console.log(`Selected scene from dropdown: "${selectedScene}"`);
          
          let sceneObject = null;
          
          // Get scene object from parent or opener window
          try {
            // Try parent window first
            if (window.parent && window.parent !== window) {
              console.log('Checking parent window for scene...');
              
              // PRIORITY 1: Check for running scene instances FIRST (before selectedScene filtering)
              if (window.parent.introScene) {
                const introSceneName = window.parent.introScene.constructor.name;
                console.log(`Found introScene: ${introSceneName}`);
                
                // If no selection or selection matches intro
                if (!selectedScene || selectedScene === '' || introSceneName === selectedScene || selectedScene === 'IntroSceneComplete') {
                  sceneObject = window.parent.introScene;
                  console.log(`✅ Using intro scene: ${introSceneName}`);
                }
              }
              
              // PRIORITY 2: Check currentScene
              if (!sceneObject && window.parent.currentScene) {
                const currentSceneName = window.parent.currentScene.constructor.name;
                console.log(`Found currentScene: ${currentSceneName}`);
                
                // If no selection or selection matches current
                if (!selectedScene || selectedScene === '' || currentSceneName === selectedScene) {
                  sceneObject = window.parent.currentScene;
                  console.log(`✅ Using current scene: ${currentSceneName}`);
                }
              }
              
              // PRIORITY 3: Try direct property lookup (for scene classes)
              if (!sceneObject && selectedScene) {
                sceneObject = window.parent[selectedScene] || 
                             window.parent[selectedScene.toLowerCase()] ||
                             window.parent[selectedScene.charAt(0).toLowerCase() + selectedScene.slice(1)];
                
                if (sceneObject) {
                  console.log(`✅ Found scene via property: ${selectedScene}`);
                }
              }
            }
            
            // Try opener window if not found in parent
            if (!sceneObject && window.opener) {
              console.log('Checking opener window for scene...');
              
              // PRIORITY 1: Check for running scene instances FIRST
              if (window.opener.introScene) {
                const introSceneName = window.opener.introScene.constructor.name;
                console.log(`Found opener introScene: ${introSceneName}`);
                
                if (!selectedScene || selectedScene === '' || introSceneName === selectedScene || selectedScene === 'IntroSceneComplete') {
                  sceneObject = window.opener.introScene;
                  console.log(`✅ Using opener intro scene: ${introSceneName}`);
                }
              }
              
              // PRIORITY 2: Check currentScene
              if (!sceneObject && window.opener.currentScene) {
                const currentSceneName = window.opener.currentScene.constructor.name;
                console.log(`Found opener currentScene: ${currentSceneName}`);
                
                if (!selectedScene || selectedScene === '' || currentSceneName === selectedScene) {
                  sceneObject = window.opener.currentScene;
                  console.log(`✅ Using opener current scene: ${currentSceneName}`);
                }
              }
              
              // PRIORITY 3: Try direct property lookup
              if (!sceneObject && selectedScene) {
                sceneObject = window.opener[selectedScene] || 
                             window.opener[selectedScene.toLowerCase()] ||
                             window.opener[selectedScene.charAt(0).toLowerCase() + selectedScene.slice(1)];
                
                if (sceneObject) {
                  console.log(`✅ Found scene via opener property: ${selectedScene}`);
                }
              }
            }
          } catch (e) {
            console.error('❌ Error accessing scene object:', e);
          }
          
          console.log(`Scene object result:`, sceneObject ? sceneObject.constructor.name : 'NULL');
          
          if (!sceneObject) {
            const sceneName = selectedScene || 'current scene';
            console.error(`❌ Scene object is null for "${sceneName}"`);
            
            // Offer to switch to the scene
            if (selectedScene && confirm(`Scene "${sceneName}" is not currently running.\n\nWould you like to switch to this scene first?`)) {
              const transitioned = await window.sequenceBuilder.transitionToScene(selectedScene);
              
              if (transitioned) {
                alert(`Switched to ${selectedScene}. Please wait for the scene to load, then try auto-ingest again.`);
              } else {
                alert(`Could not switch to scene "${selectedScene}".\n\nMake sure:\n1. The main app is running in parent/opener window\n2. The scene is available in the scene registry\n3. The transitionToScene function is available`);
              }
            } else {
              alert(`Could not find scene object for "${sceneName}".\n\nOptions:\n1. Use the "Switch" button to switch to the scene first\n2. Make sure a scene is running in the parent window\n3. Open this builder from within a running scene`);
            }
            return;
          }
          
          console.log(`Found scene object:`, sceneObject.constructor ? sceneObject.constructor.name : 'unknown');
          
          // Check if it's a class constructor (not instantiated)
          const isClass = typeof sceneObject === 'function';
          
          if (isClass) {
            alert(`Found scene class "${sceneObject.name}" but it's not instantiated.\n\nPlease switch to this scene first, then try auto-ingest.`);
            
            if (confirm(`Would you like to switch to ${sceneObject.name} now?`)) {
              const transitioned = await window.sequenceBuilder.transitionToScene(selectedScene);
              if (transitioned) {
                alert(`Switched to ${sceneObject.name}. Please wait for scene to load, then try auto-ingest again.`);
              }
            }
            return;
          }
          
          // Clear existing nodes (skip confirm if graph is empty)
          const hasExistingNodes = this.nodeGraphManager.nodes.length > 0;
          const shouldProceed = !hasExistingNodes || confirm(`Clear ${this.nodeGraphManager.nodes.length} existing node(s) and auto-ingest data from ${sceneObject.constructor ? sceneObject.constructor.name : 'scene'}?`);
          
          if (shouldProceed) {
            if (hasExistingNodes) {
              console.log('Clearing existing nodes and connections...');
              this.nodeGraphManager.nodes = [];
              this.nodeGraphManager.connections = [];
              this.nodeGraphManager.nodesContainer.innerHTML = '';
              
              // Clear SVG connections
              const svgConnections = this.nodeGraphManager.svg.querySelectorAll('.node-connection');
              svgConnections.forEach(conn => conn.remove());
              console.log('✅ Cleared all existing nodes and connections');
            } else {
              console.log('No existing nodes to clear, proceeding with ingest...');
            }
            
            // Auto-ingest scene
            console.log('Starting auto-ingest...');
            console.log('Scene object to ingest:', sceneObject);
            const ingestedNodes = await this.autoIngestScene(sceneObject);
            
            console.log(`✅ Scene auto-ingested successfully - ${ingestedNodes ? ingestedNodes.length : 0} nodes created`);
            console.log(`Total nodes in graph: ${this.nodeGraphManager.nodes.length}`);
            console.log(`Nodes in DOM: ${this.nodeGraphManager.nodesContainer.children.length}`);
            
            alert(`Scene ingested!\n\n${ingestedNodes ? ingestedNodes.length : 0} nodes created.\n\nCheck the "Node Graph" tab to see them.`);
          } else {
            console.log('User cancelled auto-ingest');
          }
          });
        }
        
        // Scene dropdown change
        const sceneDropdown2 = document.getElementById('sceneDropdown');
        if (sceneDropdown2) {
          sceneDropdown2.addEventListener('change', (e) => {
            console.log('Scene selection changed:', e.target.value);
            this.ui.sceneName.textContent = e.target.value || 'Current Scene';
          });
        }
        
        // Switch to Scene button
        const switchSceneBtn = document.getElementById('switchSceneBtn');
        if (switchSceneBtn) {
          switchSceneBtn.addEventListener('click', async () => {
            const sceneDropdown = document.getElementById('sceneDropdown');
            const selectedScene = sceneDropdown ? sceneDropdown.value : '';
            
            if (!selectedScene) {
              alert('Please select a scene from the dropdown first.');
              return;
            }
            
            console.log(`🔄 Switching to scene: ${selectedScene}`);
            
            if (confirm(`Switch to ${selectedScene}?`)) {
              const transitioned = await window.sequenceBuilder.transitionToScene(selectedScene);
              
              if (transitioned) {
                alert(`✅ Switched to ${selectedScene}!\n\nYou can now auto-ingest this scene's data.`);
                // Update the scene badge
                this.ui.sceneName.textContent = selectedScene;
              } else {
                alert(`❌ Could not switch to ${selectedScene}.\n\nMake sure:\n1. The main app is running in parent/opener window\n2. The scene is available\n3. The transitionToScene function is available`);
              }
            }
          });
        }
        
        console.log('✅ All event listeners attached');
      }

      _bindPropPreviewResizer() {
        const resizer = document.getElementById('propPreviewResizer');
        if (!resizer || !this.propPreviewer) return;

        let isDragging = false;
        let startY = 0;
        let startHeight = this.propPreviewer.getHeight ? this.propPreviewer.getHeight() : (this.ui.propPreviewCanvas?.clientHeight || 220);

        const onMouseMove = (event) => {
          if (!isDragging) return;
          const delta = startY - event.clientY;
          const desiredHeight = startHeight + delta;
          this.propPreviewer.setHeight(desiredHeight);
        };

        const onMouseUp = () => {
          if (!isDragging) return;
          isDragging = false;
          document.removeEventListener('mousemove', onMouseMove);
          document.removeEventListener('mouseup', onMouseUp);
        };

        resizer.addEventListener('mousedown', (event) => {
          event.preventDefault();
          isDragging = true;
          startY = event.clientY;
          startHeight = this.propPreviewer.getHeight ? this.propPreviewer.getHeight() : (this.ui.propPreviewCanvas?.clientHeight || 220);
          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseup', onMouseUp);
        });
      }

      async autoIngestScene(sceneObject) {
        console.log('🔍 Inspecting scene object for data...');
        console.log('Scene object:', sceneObject);
        console.log('Scene properties:', Object.keys(sceneObject));
        
        const nodes = [];
        let xPos = 100;
        let yPos = 100;
        const xSpacing = 300;
        const ySpacing = 150;

        // NEW: Extract from timing.phases (BaseScene compatible)
        if (sceneObject.timing && sceneObject.timing.phases && sceneObject.timing.phases.length > 0) {
          console.log('✅ Found timing.phases:', sceneObject.timing.phases);
          
          sceneObject.timing.phases.forEach((phase, index) => {
            const node = this.nodeGraphManager.createNode(
              phase.type || 'animation',
              xPos,
              yPos,
              {
                speaker: phase.name,
                text: `Duration: ${phase.duration.toFixed(2)}s | Start: ${phase.start.toFixed(2)}s`,
                timestamp: phase.start,
                duration: phase.duration.toFixed(2) + 's'
              }
            );
            nodes.push(node);
            
            // Connect to previous node
            if (index > 0 && nodes[index - 1]) {
              this.nodeGraphManager.connections.push({
                from: nodes[index - 1].id,
                to: node.id,
                fromSocket: 'output-0',
                toSocket: 'input-0'
              });
            }
            
            yPos += ySpacing;
            if (index % 5 === 0 && index > 0) {
              xPos += xSpacing;
              yPos = 100;
            }
          });
        }
        // OLD: Extract timing configuration from introCfg (backward compatibility)
        else if (sceneObject.introCfg) {
          console.log('✅ Found introCfg:', sceneObject.introCfg);
          const cfg = sceneObject.introCfg;
          const phases = [
            { name: 'Roll Phase', start: 0, end: cfg.rollEnd, type: 'animation' },
            { name: 'Bounce Phase', start: cfg.rollEnd, end: cfg.bounceEnd, type: 'animation' },
            { name: 'Triangle Form', start: cfg.bounceEnd, end: cfg.triangleEnd, type: 'animation' },
            { name: 'Orbit Transition', start: cfg.triangleEnd, end: cfg.transitionEnd, type: 'transition' },
            { name: 'Normal Mode', start: cfg.transitionEnd, end: cfg.normalEnd, type: 'animation' },
            { name: 'Venn Diagram', start: cfg.normalEnd, end: cfg.vennEnd, type: 'animation' },
            { name: 'Collapse', start: cfg.vennEnd, end: cfg.collapseEnd, type: 'transition' },
            { name: 'Glitch Effect', start: cfg.collapseEnd, end: cfg.glitchEnd, type: 'event' },
            { name: 'Blackout', start: cfg.glitchEnd, end: cfg.blackoutEnd, type: 'transition' },
            { name: 'Loomworks Text', start: cfg.blackoutEnd, end: cfg.loomworksEnd, type: 'dialogue' },
            { name: 'CELLI Voxel', start: cfg.loomworksEnd, end: cfg.celliEnd, type: 'animation' },
            { name: 'Doorway Portal', start: cfg.celliEnd, end: cfg.doorwayEnd, type: 'transition' }
          ];

          phases.forEach((phase, index) => {
            if (phase.end && phase.end > (phase.start || 0)) {
              const duration = phase.end - (phase.start || 0);
              const node = this.nodeGraphManager.createNode(
                phase.type,
                xPos,
                yPos,
                {
                  speaker: phase.name,
                  text: `Duration: ${duration.toFixed(2)}s | Start: ${(phase.start || 0).toFixed(2)}s`,
                  timestamp: phase.start || 0,
                  duration: duration.toFixed(2) + 's'
                }
              );
              nodes.push(node);
              
              // Connect to previous node
              if (index > 0 && nodes[index - 1]) {
                this.nodeGraphManager.connections.push({
                  from: nodes[index - 1].id,
                  to: node.id,
                  fromSocket: 'output-0',
                  toSocket: 'input-0'
                });
              }
              
              yPos += ySpacing;
              if (index % 5 === 0 && index > 0) {
                xPos += xSpacing;
                yPos = 100;
              }
            }
          });
        } else {
          console.log('⚠️ No introCfg found');
        }
        
        // Extract from motionCfg
        if (sceneObject.motionCfg) {
          console.log('✅ Found motionCfg:', sceneObject.motionCfg);
          const cfg = sceneObject.motionCfg;
          Object.keys(cfg).forEach((key) => {
            const motion = cfg[key];
            if (motion && typeof motion === 'object') {
              const node = this.nodeGraphManager.createNode(
                'parameter',
                xPos + xSpacing,
                yPos,
                {
                  speaker: `Motion: ${key}`,
                  text: JSON.stringify(motion).substring(0, 80) + '...',
                  path: `motionCfg.${key}`
                }
              );
              nodes.push(node);
              yPos += ySpacing;
            }
          });
        } else {
          console.log('⚠️ No motionCfg found');
        }
        
        // Extract from sequence array
        if (sceneObject.sequence && Array.isArray(sceneObject.sequence)) {
          console.log('✅ Found sequence array:', sceneObject.sequence);
          sceneObject.sequence.forEach((seq, index) => {
            const node = this.nodeGraphManager.createNode(
              seq.type || 'animation',
              xPos + xSpacing * 2,
              yPos,
              {
                speaker: seq.name || `Sequence ${index + 1}`,
                text: `Duration: ${seq.duration || 1.0}s | Start: ${seq.startTime || seq.time || 0}s`,
                timestamp: seq.startTime || seq.time || 0,
                duration: seq.duration || 1.0
              }
            );
            nodes.push(node);
            yPos += ySpacing;
          });
        } else {
          console.log('⚠️ No sequence array found');
        }

        const universalResults = this._ingestUniversalCollections(
          sceneObject,
          xPos + xSpacing * 3,
          yPos,
          xSpacing,
          ySpacing
        );

        if (universalResults.nodes.length) {
          nodes.push(...universalResults.nodes);
          xPos = Math.max(xPos, universalResults.nextX);
          yPos = Math.max(yPos, universalResults.nextY);
        }

        // If still no nodes, try to inspect all properties and create generic nodes
        if (nodes.length === 0) {
          console.log('⚠️ No standard properties found, scanning all properties...');
          
          const sceneProps = Object.keys(sceneObject);
          console.log(`Scene has ${sceneProps.length} properties:`, sceneProps);
          
          // Look for config-like objects
          sceneProps.forEach(prop => {
            const value = sceneObject[prop];
            if (value && typeof value === 'object' && !value.constructor || value.constructor.name === 'Object') {
              // This looks like a config object
              const configKeys = Object.keys(value);
              if (configKeys.length > 0 && configKeys.length < 50) {
                console.log(`Found potential config object: ${prop}`, value);
                
                const node = this.nodeGraphManager.createNode(
                  'parameter',
                  xPos,
                  yPos,
                  {
                    speaker: prop,
                    text: `Config with ${configKeys.length} properties: ${configKeys.slice(0, 3).join(', ')}...`
                  }
                );
                nodes.push(node);
                yPos += ySpacing;
              }
            }
          });
        }
        
        // Absolute fallback - create a sample node to show it's working
        if (nodes.length === 0) {
          console.log('⚠️ No data could be extracted. Creating sample node...');
          const sceneName = sceneObject.constructor ? sceneObject.constructor.name : 'Unknown Scene';
          
          const node = this.nodeGraphManager.createNode(
            'object',
            xPos,
            yPos,
            {
              speaker: sceneName,
              text: `Scene object found but no extractable sequence data.\n\nTry adding introCfg, motionCfg, or sequence properties to the scene.`
            }
          );
          nodes.push(node);
        }

        this.nodeGraphManager._updateConnections();
        console.log(`✅ Auto-ingested ${nodes.length} nodes from scene`);
        
        // Switch to graph tab to show nodes
        const graphTab = document.querySelector('.tab-btn[data-tab="graph"]');
        if (graphTab) {
          graphTab.click();
          console.log('✅ Switched to Node Graph tab');
        }
        
        return nodes;
      }
      
      _toggleExecuteAfter(dialogueId) {
        const content = document.getElementById(`executeAfterContent-${dialogueId}`);
        const toggle = document.getElementById(`executeAfterToggle-${dialogueId}`);
        const hierarchy = document.getElementById(`executeAfterHierarchy-${dialogueId}`);
        
        if (!content) return;
        
        if (content.classList.contains('expanded')) {
          content.classList.remove('expanded');
          toggle.textContent = 'Click to expand';
        } else {
          content.classList.add('expanded');
          toggle.textContent = 'Click to collapse';
          
          // Generate and render hierarchy
          this._renderExecuteAfterHierarchy(dialogueId, hierarchy);
        }
      }
      
      _renderExecuteAfterHierarchy(dialogueId, container) {
        if (!this.nodeGraphManager) return;
        
        const hierarchy = this._generateExecuteAfterHierarchy(dialogueId);
        
        if (hierarchy.length === 0) {
          container.innerHTML = '<div style="padding: 8px; color: #999; font-size: 11px;">No connected nodes</div>';
          return;
        }
        
        container.innerHTML = hierarchy.map(node => `
          <div class="execute-after-node depth-${node.depth}" data-node-id="${node.id}">
            <input type="checkbox" class="execute-after-checkbox" ${node.checked ? 'checked' : ''} 
                   onchange="window.builderApp._toggleNodeCheck(${node.id})">
            <span class="execute-after-node-title">${node.title}</span>
            <span class="execute-after-node-type">${node.type}</span>
          </div>
        `).join('');
      }
      
      _generateExecuteAfterHierarchy(nodeId) {
        if (!this.nodeGraphManager) return [];
        
        const hierarchy = [];
        const visited = new Set();

        const traverse = (id, depth = 0) => {
          if (visited.has(id) || depth > 3) return;
          visited.add(id);

          const connections = this.nodeGraphManager.connections.filter(c => c.from === id);
          
          connections.forEach(conn => {
            const targetNode = this.nodeGraphManager.nodes.find(n => n.id === conn.to);
            if (targetNode) {
              hierarchy.push({
                id: targetNode.id,
                title: targetNode.data.speaker || 'Untitled',
                type: targetNode.type,
                depth: depth,
                checked: false
              });
              traverse(targetNode.id, depth + 1);
            }
          });
        };

        traverse(nodeId);
        return hierarchy;
      }
      
      _toggleNodeCheck(nodeId) {
        console.log(`Toggled node ${nodeId}`);
        const nodeEl = document.querySelector(`.execute-after-node[data-node-id="${nodeId}"]`);
        if (nodeEl) {
          const isChecked = nodeEl.querySelector('input').checked;
          if (isChecked) {
            nodeEl.classList.add('checked');
          } else {
            nodeEl.classList.remove('checked');
          }
        }
      }
      
      _selectAllExecuteAfter(dialogueId) {
        const container = document.getElementById(`executeAfterHierarchy-${dialogueId}`);
        if (!container) return;
        
        container.querySelectorAll('.execute-after-checkbox').forEach(checkbox => {
          checkbox.checked = true;
          checkbox.closest('.execute-after-node').classList.add('checked');
        });
      }
      
      _selectNoneExecuteAfter(dialogueId) {
        const container = document.getElementById(`executeAfterHierarchy-${dialogueId}`);
        if (!container) return;
        
        container.querySelectorAll('.execute-after-checkbox').forEach(checkbox => {
          checkbox.checked = false;
          checkbox.closest('.execute-after-node').classList.remove('checked');
        });
      }

      open() {
        if (this.isOverlayMode) {
          this.ui.overlay.classList.add('active');
        }
      }

      close() {
        if (this.isOverlayMode) {
          this.ui.overlay.classList.remove('active');
        }
      }

      toggle() {
        if (this.ui.overlay.classList.contains('active')) {
          this.close();
        } else {
          this.open();
        }
      }
    }

    // ===== VIDEO PLAYER WITH EFFECTS =====
    class GlitchVideoPlayer {
      constructor() {
        this.overlay = document.getElementById('videoPlayerOverlay');
        this.video = document.getElementById('introVideo');
        this.canvas = document.getElementById('videoCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.closeBtn = document.getElementById('videoCloseBtn');
        
        this.isPlaying = false;
        this.animationId = null;
        
        // Audio context for effects
        this.audioContext = null;
        this.sourceNode = null;
        this.gainNode = null;
        this.filterNode = null;
        this.distortionNode = null;
        
        this.setupEventListeners();
      }
      
      setupEventListeners() {
        this.closeBtn.addEventListener('click', () => this.close());
        
        this.video.addEventListener('ended', () => this.close());
        
        // Escape key to close
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && this.isPlaying) {
            this.close();
          }
        });
      }
      
      async play(videoPath) {
        try {
          // Show overlay
          this.overlay.classList.add('active');
          
          // Setup audio context
          if (!this.audioContext) {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          }
          
          // Load video
          this.video.src = videoPath;
          this.video.load();
          
          // Wait for video metadata
          await new Promise((resolve, reject) => {
            this.video.onloadedmetadata = resolve;
            this.video.onerror = reject;
          });
          
          // Setup canvas size
          this.canvas.width = this.video.videoWidth;
          this.canvas.height = this.video.videoHeight;
          
          // Setup audio effects
          this.setupAudioEffects();
          
          // Play video
          await this.video.play();
          this.isPlaying = true;
          
          // Start rendering with effects
          this.renderWithEffects();
          
          console.log('🎬 Playing intro video with effects');
        } catch (error) {
          console.error('Error playing video:', error);
          alert('Failed to load intro.mp4. Make sure the file exists in the root folder.');
          this.close();
        }
      }
      
      setupAudioEffects() {
        // Create audio nodes
        if (!this.sourceNode) {
          this.sourceNode = this.audioContext.createMediaElementSource(this.video);
        }
        
        // Gain node for volume control
        this.gainNode = this.audioContext.createGain();
        this.gainNode.gain.value = 0.7;
        
        // Low-pass filter for muffled effect
        this.filterNode = this.audioContext.createBiquadFilter();
        this.filterNode.type = 'lowpass';
        this.filterNode.frequency.value = 22000; // Start clear
        this.filterNode.Q.value = 1;
        
        // Distortion (subtle)
        this.distortionNode = this.audioContext.createWaveShaper();
        this.distortionNode.curve = this.makeDistortionCurve(10);
        this.distortionNode.oversample = '4x';
        
        // Connect nodes
        this.sourceNode.connect(this.filterNode);
        this.filterNode.connect(this.distortionNode);
        this.distortionNode.connect(this.gainNode);
        this.gainNode.connect(this.audioContext.destination);
        
        // Randomly apply muffle effect
        this.applyRandomAudioEffects();
      }
      
      makeDistortionCurve(amount) {
        const samples = 44100;
        const curve = new Float32Array(samples);
        const deg = Math.PI / 180;
        
        for (let i = 0; i < samples; i++) {
          const x = (i * 2) / samples - 1;
          curve[i] = ((3 + amount) * x * 20 * deg) / (Math.PI + amount * Math.abs(x));
        }
        
        return curve;
      }
      
      applyRandomAudioEffects() {
        if (!this.isPlaying) return;
        
        // Random interval between 100-500ms
        const interval = 100 + Math.random() * 400;
        
        setTimeout(() => {
          if (!this.isPlaying) return;
          
          const now = this.audioContext.currentTime;
          
          // 30% chance to apply muffle
          if (Math.random() < 0.3) {
            const muffleFreq = 300 + Math.random() * 1500;
            this.filterNode.frequency.setValueAtTime(muffleFreq, now);
            this.filterNode.frequency.linearRampToValueAtTime(22000, now + 0.2);
          }
          
          // 20% chance to apply distortion spike
          if (Math.random() < 0.2) {
            this.distortionNode.curve = this.makeDistortionCurve(50 + Math.random() * 100);
            setTimeout(() => {
              this.distortionNode.curve = this.makeDistortionCurve(10);
            }, 50 + Math.random() * 100);
          }
          
          // 15% chance to apply volume dip
          if (Math.random() < 0.15) {
            this.gainNode.gain.setValueAtTime(0.3, now);
            this.gainNode.gain.linearRampToValueAtTime(0.7, now + 0.15);
          }
          
          // Continue applying effects
          this.applyRandomAudioEffects();
        }, interval);
      }
      
      renderWithEffects() {
        if (!this.isPlaying) return;
        
        // Draw video to canvas
        this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);
        
        // Apply glitch effects randomly
        if (Math.random() < 0.15) { // 15% chance per frame
          this.applyGlitchEffect();
        }
        
        // Apply distortion occasionally
        if (Math.random() < 0.08) { // 8% chance per frame
          this.applyDistortionEffect();
        }
        
        // Apply RGB shift occasionally
        if (Math.random() < 0.1) { // 10% chance per frame
          this.applyRGBShift();
        }
        
        this.animationId = requestAnimationFrame(() => this.renderWithEffects());
      }
      
      applyGlitchEffect() {
        const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
        const data = imageData.data;
        
        // Horizontal line displacement
        const numGlitches = 3 + Math.floor(Math.random() * 5);
        
        for (let i = 0; i < numGlitches; i++) {
          const y = Math.floor(Math.random() * this.canvas.height);
          const height = 5 + Math.floor(Math.random() * 30);
          const offset = -20 + Math.floor(Math.random() * 40);
          
          const sliceData = this.ctx.getImageData(0, y, this.canvas.width, height);
          this.ctx.putImageData(sliceData, offset, y);
        }
        
        // Random pixel corruption
        for (let i = 0; i < data.length; i += 4 * Math.floor(Math.random() * 1000)) {
          if (Math.random() < 0.5) {
            data[i] = Math.random() * 255;
            data[i + 1] = Math.random() * 255;
            data[i + 2] = Math.random() * 255;
          }
        }
        
        this.ctx.putImageData(imageData, 0, 0);
      }
      
      applyDistortionEffect() {
        // Block displacement
        const blockSize = 50 + Math.floor(Math.random() * 100);
        const numBlocks = 5 + Math.floor(Math.random() * 10);
        
        for (let i = 0; i < numBlocks; i++) {
          const srcX = Math.floor(Math.random() * (this.canvas.width - blockSize));
          const srcY = Math.floor(Math.random() * (this.canvas.height - blockSize));
          const destX = Math.floor(Math.random() * (this.canvas.width - blockSize));
          const destY = Math.floor(Math.random() * (this.canvas.height - blockSize));
          
          const blockData = this.ctx.getImageData(srcX, srcY, blockSize, blockSize);
          this.ctx.putImageData(blockData, destX, destY);
        }
      }
      
      applyRGBShift() {
        const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
        const shiftAmount = 2 + Math.floor(Math.random() * 8);
        
        const shiftedR = this.ctx.getImageData(shiftAmount, 0, this.canvas.width - shiftAmount, this.canvas.height);
        const shiftedB = this.ctx.getImageData(-shiftAmount, 0, this.canvas.width + shiftAmount, this.canvas.height);
        
        const data = imageData.data;
        
        for (let i = 0; i < data.length; i += 4) {
          const pixelIndex = i / 4;
          const x = pixelIndex % this.canvas.width;
          
          if (x < shiftAmount) continue;
          if (x >= this.canvas.width - shiftAmount) continue;
          
          const shiftedIndex = i;
          data[shiftedIndex] = shiftedR.data[shiftedIndex]; // R channel shifted
          data[shiftedIndex + 2] = shiftedB.data[shiftedIndex + 2]; // B channel shifted
        }
        
        this.ctx.putImageData(imageData, 0, 0);
      }
      
      close() {
        this.isPlaying = false;
        
        if (this.animationId) {
          cancelAnimationFrame(this.animationId);
          this.animationId = null;
        }
        
        this.video.pause();
        this.video.currentTime = 0;
        
        this.overlay.classList.remove('active');
        
        console.log('🛑 Video player closed');
      }
    }

    // Detect mode and initialize
    const isStandalone = !window.opener || window.location.search.includes('standalone');
    console.log(`🎯 Initializing in ${isStandalone ? 'Standalone' : 'Overlay'} mode...`);
    
    const app = new UnifiedSequenceBuilder();
    
    // Store globally
    window.builderApp = app;
    window.sequenceBuilder = sequenceBuilder;
    window.openSequenceBuilder = () => app.open();
    window.closeSequenceBuilder = () => app.close();
    window.toggleSequenceBuilder = () => app.toggle();
    
    // Initialize app
    try {
      await app.init(!isStandalone);
    } catch (error) {
      console.error('❌ App initialization failed:', error);
      alert(`Failed to initialize Sequence Builder:\n\n${error.message}`);
    }
    
    // Initialize video player
    const videoPlayer = new GlitchVideoPlayer();
    
    // Add Play Intro button handler
    document.getElementById('playIntroBtn').addEventListener('click', () => {
      videoPlayer.play('../../intro.mp4');
    });
    
    console.log('✅ Unified Sequence Builder Ready');
    console.log(`Mode: ${isStandalone ? 'Standalone' : 'Overlay'}`);
    
    // Console helper for debugging integration
    window.checkIntegration = function() {
      const w = window.parent && window.parent !== window ? window.parent : window.opener;
      if (!w) {
        console.error('❌ No parent or opener window');
        return;
      }
      
      console.log('🔍 Checking integration with main app...\n');
      console.log('transitionToScene:', typeof w.transitionToScene);
      console.log('getSceneByName:', typeof w.getSceneByName);
      console.log('scenes:', w.scenes ? Object.keys(w.scenes) : 'not found');
      console.log('currentScene:', w.currentScene?.constructor?.name || 'not running');
      console.log('introScene:', w.introScene?.constructor?.name || 'not running');
      
      if (typeof w.transitionToScene === 'function') {
        console.log('\n✅ Integration is working!');
        console.log('You can now use Auto-Ingest and Switch Scene features.');
      } else {
        console.log('\n❌ Integration incomplete - transitionToScene not found');
        console.log('Make sure you opened this builder from the main app (press \\ key)');
      }
    };
    
    console.log('💡 Run checkIntegration() in console to verify setup');
  </script>
</body>
</html>

