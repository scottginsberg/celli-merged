<!doctype html>
<html lang="en">
<head>
 <meta charset="utf-8"/>
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
 <meta name="viewport" content="width=device-width, initial-scale=1"/>
 <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
 <meta http-equiv="Pragma" content="no-cache" />
 <meta http-equiv="Expires" content="0" />
 <meta name="version" content="6.0-celli-real-component-composition" />
 <title>Cell.real - Voxel Spreadsheet [Modular Edition]</title>
 
 <!-- Immediate hide for referrer controls to prevent flash -->
 <style>
  /* Ensure black background by default */
  html, body {
    background: #000 !important;
    background-color: #000 !important;
  }
  
  /* Hide referrer controls menu */
  #referrerControlsMenu { 
    display: none !important; 
    opacity: 0 !important;
    visibility: hidden !important;
    pointer-events: none !important;
  }
 </style>
 
 <!-- Google Fonts -->
 <link rel="preconnect" href="https://fonts.googleapis.com">
 <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
 <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Roboto+Mono:wght@100;300&family=VT323&display=swap" rel="stylesheet">
 
 <!-- Twemoji for consistent emoji rendering -->
 <script src="https://unpkg.com/twemoji@latest/dist/twemoji.min.js"></script>
 
 <!-- GIF.js for screen recording -->
 <script src="https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.js"></script>
 
 <!-- Styles -->
 <link rel="stylesheet" href="src/styles/main.css">
 <link rel="stylesheet" href="src/styles/sequence.css">
 <link rel="stylesheet" href="src/styles/celli-real.css">
 <link rel="stylesheet" href="src/styles/referrer-overlay.css">
 <link rel="stylesheet" href="src/styles/recorder.css">
 <link rel="stylesheet" href="src/styles/scene-select.css">
 <link rel="stylesheet" href="src/styles/map.css">
 <link rel="stylesheet" href="src/styles/full-sequence-button.css">
 
 <!-- Mythic Sidebar Entrance Animations -->
 <style>
  @keyframes pulse {
   0%, 100% { opacity: 1; transform: scale(1); }
   50% { opacity: 0.8; transform: scale(1.05); }
  }
  
  @keyframes float {
   0%, 100% { transform: translateY(-50%) translateX(0); }
   50% { transform: translateY(-50%) translateX(-10px); }
  }
  
  @keyframes rumble {
   0%, 100% { transform: translate(-50%, -50%) rotate(0deg); }
   10% { transform: translate(calc(-50% - 5px), calc(-50% - 5px)) rotate(-1deg); }
   20% { transform: translate(calc(-50% + 5px), calc(-50% + 5px)) rotate(1deg); }
   30% { transform: translate(calc(-50% - 5px), calc(-50% + 5px)) rotate(-1deg); }
   40% { transform: translate(calc(-50% + 5px), calc(-50% - 5px)) rotate(1deg); }
   50% { transform: translate(calc(-50% - 3px), calc(-50% - 3px)) rotate(-0.5deg); }
   60% { transform: translate(calc(-50% + 3px), calc(-50% + 3px)) rotate(0.5deg); }
   70% { transform: translate(calc(-50% - 3px), calc(-50% + 3px)) rotate(-0.5deg); }
   80% { transform: translate(calc(-50% + 3px), calc(-50% - 3px)) rotate(0.5deg); }
   90% { transform: translate(calc(-50% - 1px), calc(-50% - 1px)) rotate(-0.2deg); }
  }
  
  @keyframes glow-pulse {
   0%, 100% { 
    box-shadow: 0 0 50px rgba(102, 126, 234, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);
   }
   50% { 
    box-shadow: 0 0 80px rgba(102, 126, 234, 1), 0 0 40px rgba(255, 255, 255, 0.8);
   }
  }
  
  /* Initial state: off-screen right */
  .ref-sidebar.mythic-entrance {
   display: block !important;
   position: fixed;
   right: -400px;
   top: 50%;
   transform: translateY(-50%);
   will-change: transform, right;
   transition: right 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
   box-shadow: 0 0 50px rgba(102, 126, 234, 0.8);
   z-index: 10001;
   animation: glow-pulse 2s ease-in-out infinite;
   background: rgba(30, 30, 40, 0.95) !important;
   backdrop-filter: blur(10px);
   border-radius: 12px;
  }
  
  /* Stage 1: Float in from right */
  .ref-sidebar.mythic-entrance.stage-float {
   right: 20px;
   animation: float 2s ease-in-out infinite, glow-pulse 2s ease-in-out infinite;
  }
  
  /* Stage 2: Sweep to center */
  .ref-sidebar.mythic-entrance.stage-sweep {
   left: 50%;
   right: auto;
   top: 50%;
   transform: translate(-50%, -50%);
   transition: all 1.2s cubic-bezier(0.68, -0.55, 0.27, 1.55);
   animation: glow-pulse 1.5s ease-in-out infinite;
  }
  
  /* Stage 3: Rumble */
  .ref-sidebar.mythic-entrance.stage-rumble {
   animation: rumble 0.6s ease-in-out, glow-pulse 0.6s ease-in-out infinite;
  }
  
  /* Stage 4: Expand */
  .ref-sidebar.mythic-entrance.stage-expand {
   width: 560px;
   padding: 0;
   left: 50%;
   right: auto;
   transform: translate(-50%, -50%) scale(1.05);
   transition: all 0.6s cubic-bezier(0.68, -0.55, 0.27, 1.55);
   box-shadow: 0 0 100px rgba(102, 126, 234, 0.5), 0 8px 40px rgba(0, 0, 0, 0.6), inset 0 1px 0 rgba(255, 255, 255, 0.15);
   background: linear-gradient(135deg, rgba(15, 25, 45, 0.85), rgba(25, 35, 55, 0.9)) !important;
   backdrop-filter: blur(30px) saturate(200%) !important;
   -webkit-backdrop-filter: blur(30px) saturate(200%) !important;
   border: 1px solid rgba(143, 180, 255, 0.3);
   border-radius: 20px;
  }
  
  .ref-sidebar.mythic-entrance.stage-expand .ref-sidebar-btn {
   animation: none;
  }

  .ref-sidebar.mythic-entrance.note-seed {
   width: clamp(260px, 80vw, 420px);
   padding: clamp(12px, 3vw, 18px);
   border-radius: 24px;
   background: linear-gradient(145deg, rgba(25, 32, 58, 0.88), rgba(18, 26, 48, 0.82)) !important;
   box-shadow: 0 18px 46px rgba(14, 18, 40, 0.48), 0 0 42px rgba(102, 126, 234, 0.35);
   backdrop-filter: blur(24px) saturate(165%);
   -webkit-backdrop-filter: blur(24px) saturate(165%);
   display: flex;
   align-items: center;
   justify-content: center;
  }

  .ref-sidebar.mythic-entrance.note-seed .ref-sidebar-btn {
   width: 100%;
   padding: 0;
   background: transparent;
   border: none;
   overflow: hidden;
  }

  .ref-sidebar-btn {
   transition: background 0.3s ease, border 0.3s ease, box-shadow 0.3s ease, transform 0.3s ease;
  }

  .ref-sidebar.mythic-entrance.note-hover {
   box-shadow: 0 28px 70px rgba(9, 12, 28, 0.75), 0 0 80px rgba(123, 150, 255, 0.55);
   background: linear-gradient(150deg, rgba(24, 32, 60, 0.95), rgba(16, 24, 50, 0.92)) !important;
  }

  .ref-note-crystal {
   position: relative;
   display: grid;
   gap: 6px;
   padding: 18px 22px;
   border-radius: 18px;
   background: linear-gradient(135deg, rgba(146, 172, 255, 0.25), rgba(90, 116, 230, 0.16));
   border: 1px solid rgba(164, 190, 255, 0.35);
   box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.45), 0 14px 30px rgba(18, 28, 62, 0.6);
   overflow: hidden;
   color: #f5f7ff;
   text-align: center;
   font-family: "Inter", -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
   letter-spacing: 0.12em;
   text-transform: uppercase;
   transition: transform 0.6s ease, box-shadow 0.6s ease;
  }

  .ref-note-crystal::before {
   content: "";
   position: absolute;
   inset: -20%;
   background: radial-gradient(circle at 30% 30%, rgba(184, 204, 255, 0.35), transparent 60%);
   opacity: 0.8;
   animation: ref-note-glow 4s ease-in-out infinite;
  }

  .ref-note-crystal::after {
   content: "";
   position: absolute;
   inset: 12%;
   border-radius: 16px;
   border: 1px solid rgba(255, 255, 255, 0.25);
   opacity: 0.5;
   mix-blend-mode: screen;
  }

  .ref-note-title {
   position: relative;
   font-size: 12px;
   font-weight: 600;
   color: #e0e6ff;
   text-shadow: 0 0 18px rgba(149, 170, 255, 0.6);
   letter-spacing: 0.24em;
  }

  .ref-note-sub {
   position: relative;
   font-size: 11px;
   font-weight: 500;
   opacity: 0.7;
   letter-spacing: 0.16em;
  }

  .ref-note-crystal--hover,
  .ref-sidebar.mythic-entrance.note-hover .ref-note-crystal {
   transform: translateY(-6px) scale(1.04);
   box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.5), 0 24px 46px rgba(12, 18, 42, 0.68), 0 0 55px rgba(138, 160, 255, 0.75);
  }

  @keyframes ref-note-glow {
   0%, 100% {
    opacity: 0.8;
    transform: translate(-4%, -2%) scale(1);
   }
   50% {
    opacity: 1;
    transform: translate(6%, 4%) scale(1.06);
   }
  }

  @media (max-width: 768px) {
   .ref-sidebar.mythic-entrance.note-seed {
    width: clamp(180px, 60vw, 230px);
    padding: 18px 20px;
   }

   .ref-note-crystal {
    padding: 16px 18px;
    border-radius: 16px;
    letter-spacing: 0.1em;
   }

   .ref-note-title {
    font-size: 11px;
   }

   .ref-note-sub {
    font-size: 10px;
    letter-spacing: 0.12em;
   }
  }

  /* AI Twinkle effect */
  @keyframes ai-twinkle {
   0%, 100% {
    opacity: 1;
    transform: scale(1);
    text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
   }
   25% {
    opacity: 0.8;
    transform: scale(1.05);
    text-shadow: 0 0 20px rgba(102, 126, 234, 0.8), 0 0 40px rgba(255, 255, 255, 0.4);
   }
   50% { 
    opacity: 1;
    transform: scale(1.1);
    text-shadow: 0 0 30px rgba(102, 126, 234, 1), 0 0 60px rgba(255, 255, 255, 0.6);
   }
   75% {
    opacity: 0.9;
    transform: scale(1.05);
    text-shadow: 0 0 20px rgba(102, 126, 234, 0.8), 0 0 40px rgba(255, 255, 255, 0.4);
   }
  }
  
  .ai-message {
   animation: ai-twinkle 2s ease-in-out;
  }
  
  /* Animated gradient for gaudy ad */
  @keyframes rainbow-shift {
   0% { background-position: 0% 50%; }
   50% { background-position: 100% 50%; }
   100% { background-position: 0% 50%; }
  }
  
  /* Checkbox container hover effect */
  #tosCheckboxContainer:hover {
   border-color: rgba(143, 180, 255, 0.6) !important;
   background: linear-gradient(135deg, rgba(143, 180, 255, 0.15), rgba(102, 126, 234, 0.2)) !important;
   box-shadow: 0 6px 24px rgba(102, 126, 234, 0.25), inset 0 1px 0 rgba(255, 255, 255, 0.15) !important;
   transform: translateY(-1px);
  }
  
  /* Ensure all glow effects use screen blend mode (never darken) */
  .edge-impact,
  .light-beam,
  .impact-particle {
   mix-blend-mode: screen;
  }
  
  /* Base darkening overlay - starts invisible */
  .darkening-overlay {
   opacity: 0;
  }
  
  /* Darkening overlay flicker animation */
  @keyframes darken-flicker {
   0% { opacity: 0; }
   10% { opacity: 0.3; }
   20% { opacity: 0.05; }
   30% { opacity: 0.4; }
   40% { opacity: 0.1; }
   50% { opacity: 0.5; }
   60% { opacity: 0.15; }
   70% { opacity: 0.6; }
   80% { opacity: 0.2; }
   90% { opacity: 0.7; }
   100% { opacity: 0; }
  }
  
  .darkening-overlay.flickering {
   animation: darken-flicker var(--flicker-duration, 800ms) ease-in-out;
   animation-iteration-count: var(--flicker-count, 5);
   animation-fill-mode: both;
  }
  
  /* Progressive darkness levels */
  .darkening-overlay.level-1 {
   opacity: 0.2 !important;
   transition: opacity 0.5s ease-out;
  }
  
  .darkening-overlay.level-2 {
   opacity: 0.4 !important;
   transition: opacity 0.5s ease-out;
  }
  
  .darkening-overlay.level-3 {
   opacity: 0.6 !important;
   transition: opacity 0.5s ease-out;
  }
  
  .darkening-overlay.level-4 {
   opacity: 0.8 !important;
   transition: opacity 0.5s ease-out;
  }
  
  .darkening-overlay.level-5 {
   opacity: 0.95 !important;
   transition: opacity 0.5s ease-out;
  }
  
  /* Flash of life - momentary restoration of light */
  @keyframes flash-life {
   0% { opacity: 0.95 !important; }
   15% { opacity: 0 !important; }
   30% { opacity: 0.2 !important; }
   45% { opacity: 0 !important; }
   60% { opacity: 0.3 !important; }
   75% { opacity: 0.1 !important; }
   100% { opacity: 0.95 !important; }
  }
  
  .darkening-overlay.flash-of-life {
   animation: flash-life 1.5s ease-in-out !important;
   opacity: initial !important;
  }
  
  /* Brick hole in darkening wall */
  .darkening-hole {
   position: fixed;
   right: 0;
   width: 300px;
   height: 80px;
   background: transparent;
   pointer-events: none;
   z-index: 9999;
   border-radius: 50%;
   box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.5);
   animation: hole-break 0.3s ease-out;
  }
  
  @keyframes hole-break {
   0% { transform: scaleX(0); opacity: 0; }
   100% { transform: scaleX(1); opacity: 1; }
  }
  
  /* Light beam through hole */
  .light-ray {
   position: fixed;
   right: 0;
   width: var(--ref-light-ray-width, 420px);
   height: var(--ref-light-ray-height, 18px);
   mix-blend-mode: screen;
   pointer-events: none;
   z-index: 2147483600;
   animation: ray-shine 0.45s ease-out;
   transform-origin: right center;
   border-radius: calc(var(--ref-light-ray-height, 18px) / 2);
   opacity: 0;
  }

  .light-ray::before,
  .light-ray::after {
   content: '';
   position: absolute;
   inset: 0;
   border-radius: inherit;
   pointer-events: none;
  }

  body.voxel-shatter-active #uiContainer,
  body.voxel-shatter-active #celliRefOverlay,
  body.voxel-shatter-active .celli-ref-mask,
  body.voxel-shatter-active .celli-ref-panel {
   opacity: 0;
   pointer-events: none !important;
   transition: opacity 0.4s ease;
  }

  .tri-color-particles {
   position: fixed;
   inset: 0;
   width: 100vw;
   height: 100vh;
   pointer-events: none;
   z-index: 2147483000;
   mix-blend-mode: screen;
   opacity: 0.48;
   transition: opacity 0.8s ease;
  }

  .tri-color-particles.tri-color-particles--foreground {
   z-index: 2147483525;
   opacity: 0.78;
  }

  .tri-color-burst {
   position: fixed;
   width: 120px;
   height: 120px;
   transform: translate(-50%, -50%);
   pointer-events: none;
   z-index: 2147483526;
   display: grid;
   place-items: center;
   mix-blend-mode: screen;
   filter: drop-shadow(0 0 18px rgba(255, 255, 255, 0.42));
   animation: tri-burst-fade 1.2s ease-out forwards;
  }

  .tri-color-burst::after {
   content: '';
   position: absolute;
   inset: -40%;
   border-radius: 50%;
   background: radial-gradient(circle, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0));
   animation: tri-burst-flare 1.2s ease-out forwards;
  }

  .tri-color-burst span {
   width: 10px;
   height: 10px;
   border-radius: 2px;
   opacity: 0;
   background: currentColor;
   box-shadow:
    14px -6px 0 -2px currentColor,
    -16px 8px 0 -2px currentColor,
    6px 18px 0 -2px currentColor,
    -12px -16px 0 -2px currentColor;
   filter: drop-shadow(0 0 6px currentColor);
   animation: tri-burst-launch 0.95s cubic-bezier(0.2, 0.85, 0.25, 1) forwards;
  }

  .tri-color-burst span:nth-child(1) {
   color: #ff4f88;
   animation-delay: 0s;
  }

  .tri-color-burst span:nth-child(2) {
   color: #3da9ff;
   animation-delay: 0.05s;
  }

  .tri-color-burst span:nth-child(3) {
   color: #ffd166;
   animation-delay: 0.1s;
  }

  @keyframes tri-burst-launch {
   0% {
    opacity: 0;
    transform: translate3d(0, 0, 0) scale(0.4) rotate(0deg);
   }
   35% {
    opacity: 1;
    transform: translate3d(24px, -26px, 0) scale(1.25) rotate(18deg);
   }
   75% {
    opacity: 0.85;
    transform: translate3d(-32px, 22px, 0) scale(0.9) rotate(-22deg);
   }
   100% {
    opacity: 0;
    transform: translate3d(64px, -54px, 0) scale(0.4) rotate(32deg);
   }
  }

  @keyframes tri-burst-fade {
   0% { opacity: 1; }
   60% { opacity: 0.9; }
   100% { opacity: 0; }
  }

  @keyframes tri-burst-flare {
   0% {
    opacity: 0.55;
    transform: scale(0.4);
   }
   40% {
    opacity: 0.25;
    transform: scale(1.1);
   }
   100% {
    opacity: 0;
    transform: scale(1.8);
   }
  }

  .base-darkness {
   position: fixed;
   inset: 0;
   background: radial-gradient(circle at center, rgba(8, 10, 18, 0.05) 0%, rgba(3, 5, 12, 0.85) 100%);
   pointer-events: none;
   z-index: 2147483380;
   opacity: 0;
   transition: opacity 0.9s ease, filter 1s ease;
   filter: saturate(1);
  }

  .base-darkness.level-1 { opacity: 0.18; }
  .base-darkness.level-2 { opacity: 0.32; }
  .base-darkness.level-3 { opacity: 0.48; }
  .base-darkness.level-4 { opacity: 0.65; }
  .base-darkness.level-5 { opacity: 0.78; filter: saturate(1.1); }

  .loom-invite-swarm {
   position: fixed;
   inset: 0;
   width: 100vw;
   height: 100vh;
   pointer-events: none;
   z-index: 2147483605;
   overflow: visible;
  }

  .loom-invite-swarm.has-active-invites {
   pointer-events: auto;
  }

  .loom-invite-clone {
   position: absolute;
   top: var(--invite-top, 50%);
   left: var(--invite-left, 50%);
   transform: translate(-50%, -50%) scale(var(--invite-scale, 0.9)) rotate(var(--invite-tilt, -2deg));
   opacity: 0;
   transition: opacity 1.4s ease, transform 1.2s ease;
   filter: drop-shadow(0 18px 42px rgba(12, 18, 45, 0.45));
   pointer-events: auto;
   cursor: pointer;
   z-index: 1;
   overflow: hidden;
   border-radius: 28px;
  }

  .loom-invite-clone.visible {
   opacity: 0.92;
   transform: translate(-50%, -50%) scale(calc(var(--invite-scale, 0.9) + var(--chant-reactive, 0) * 0.08)) rotate(var(--invite-tilt, -2deg));
  }

  .loom-invite-clone::before,
  .loom-invite-clone::after {
   content: '';
   position: absolute;
   inset: -8px -10px;
   border-radius: 28px;
   background: radial-gradient(circle at 50% 50%, rgba(143, 180, 255, 0.2), transparent 70%);
   mix-blend-mode: screen;
   opacity: 0.5;
   transform: translateZ(0);
   pointer-events: none;
  }

  .loom-invite-clone::after {
   inset: -4px -6px;
   opacity: 0.6;
   filter: blur(8px);
  }

  .loom-invite-clone-card,
  .loom-invite-card:not(.loom-invite-card--tos) {
   position: relative;
   border-radius: 24px;
   background: linear-gradient(145deg, rgba(102, 126, 234, 0.32), rgba(143, 180, 255, 0.22), rgba(118, 75, 162, 0.28));
   backdrop-filter: blur(18px) saturate(220%);
   -webkit-backdrop-filter: blur(18px) saturate(220%);
   border: 1px solid rgba(160, 190, 255, 0.4);
   box-shadow: 0 24px 50px rgba(9, 12, 34, 0.55), inset 0 1px 0 rgba(255, 255, 255, 0.22);
   overflow: hidden;
   isolation: isolate;
  }

  .loom-invite-card::after,
  .loom-invite-clone-card::after {
   content: '';
   position: absolute;
   inset: 10% 6%;
   border-radius: 20px;
   background: radial-gradient(ellipse at 50% 0%, rgba(143, 180, 255, 0.35), transparent 65%);
   opacity: 0.65;
   mix-blend-mode: screen;
   pointer-events: none;
  }

  .loom-invite-clone-card {
   padding: 32px 36px;
   display: flex;
   align-items: center;
   justify-content: center;
   min-width: 220px;
   pointer-events: none;
  }

  .loom-invite-clone-card .loom-invite-emblem {
   pointer-events: auto;
  }

  .loom-invite-emblem {
   position: relative;
   z-index: 1;
   display: grid;
   gap: 8px;
   justify-items: center;
   text-align: center;
   color: #f6f8ff;
   font-family: "Inter", -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
   text-transform: uppercase;
   letter-spacing: 0.34em;
   filter: drop-shadow(0 0 26px rgba(143, 180, 255, 0.45));
  }

  .loom-invite-line {
   margin: 0;
   font-size: 15px;
   font-weight: 500;
   letter-spacing: 0.28em;
   text-shadow: 0 0 18px rgba(143, 180, 255, 0.55);
  }

  .loom-invite-line--primary {
   font-size: 16px;
   letter-spacing: 0.34em;
  }

  .loom-invite-line--secondary {
   font-size: 13px;
   letter-spacing: 0.32em;
   opacity: 0.88;
  }

  .loom-invite-line--tertiary {
   font-size: 11px;
   letter-spacing: 0.28em;
   opacity: 0.76;
  }

  .loom-invite-clone .loom-invite-clone-body strong {
   display: block;
   margin-bottom: 8px;
   font-size: 16px;
   letter-spacing: 0.08em;
   color: rgba(255, 255, 255, 0.98);
   text-shadow: 0 0 12px rgba(143, 180, 255, 0.55);
  }

  .loom-invite-clone .loom-invite-clone-body span {
   display: block;
   opacity: 0.75;
   font-size: 13px;
   letter-spacing: 0.06em;
  }

  .loom-invite-clone.visible .loom-invite-clone-card {
   animation: loomInviteCloneDrift 8s ease-in-out var(--invite-delay, 0ms) infinite alternate;
  }

  @keyframes loomInviteCloneDrift {
   0% {
    transform: translateY(0) scale(1);
    filter: saturate(1) brightness(1);
   }
   50% {
    transform: translateY(-14px) scale(calc(1 + var(--chant-reactive, 0) * 0.08));
    filter: saturate(1.05) brightness(calc(1.05 + var(--chant-reactive, 0) * 0.2));
   }
   100% {
    transform: translateY(10px) scale(calc(1 + var(--chant-reactive, 0) * 0.12));
    filter: saturate(1.1) brightness(calc(1.08 + var(--chant-reactive, 0) * 0.24));
   }
  }

  .loom-invite-clone.reduced-motion .loom-invite-clone-card {
   animation: none;
  }

  .ai-message {
   font-size: 15px;
   font-weight: 300;
   line-height: 1.8;
   color: #f8f9fa;
   text-align: center;
   padding: 40px;
   font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
  }

  .ai-message-tri-icon {
   display: inline-flex;
   align-items: center;
   justify-content: center;
   gap: 6px;
   margin-bottom: 16px;
  }

  .ai-message-tri-icon span {
   width: 18px;
   height: 18px;
   display: block;
   background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.55));
   clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
   opacity: 0.9;
   filter: drop-shadow(0 0 6px rgba(255, 255, 255, 0.65));
   transition: transform 0.35s ease, opacity 0.35s ease;
  }

  .ai-message-tri-icon span:nth-child(2) {
   transform: translateY(-6px) scale(1.12);
  }

  .ai-message-tri-icon span:nth-child(1),
  .ai-message-tri-icon span:nth-child(3) {
   transform: translateY(3px) scale(0.86);
  }

  .ai-message__title {
   font-weight: 500;
   margin-bottom: 14px;
   font-size: 18px;
   color: #8fb4ff;
   letter-spacing: 0.5px;
   text-shadow: 0 0 12px rgba(143, 180, 255, 0.4);
  }

  .ai-message__body {
   opacity: 0.9;
   font-size: 14px;
  }

  .ai-message__footer {
   margin-top: 16px;
   font-size: 12px;
   opacity: 0.6;
   letter-spacing: 1px;
   color: #a0b0c0;
  }

  /* BadBoolean ad state */
  .ref-sidebar-btn.badboolean-active {
   transition: all 0.1s ease-out;
   will-change: transform, opacity;
   text-align: center;
   display: block;
   width: 100%;
   background: linear-gradient(135deg, rgba(255, 0, 128, 0.92) 0%, rgba(255, 140, 0, 0.82) 30%, rgba(0, 255, 204, 0.72) 65%, rgba(120, 50, 255, 0.85) 100%);
   background-size: 280% 280%;
   border: 3px solid #ff00ff;
   border-radius: 16px;
   box-shadow: 0 0 22px #ff4acb, 0 0 48px rgba(0,255,204,0.65), inset 0 0 20px rgba(255,255,255,0.35);
   animation: rainbow-shift 3s ease infinite;
   padding: 0;
   overflow: hidden;
   cursor: pointer;
  }

  .badboolean-banner {
   padding: 28px 20px;
   display: flex;
   flex-direction: column;
   gap: 12px;
   align-items: center;
   justify-content: center;
  }

  .badboolean-topline,
  .badboolean-subline,
  .badboolean-mainline,
  .badboolean-tagline,
  .badboolean-footer,
  .badboolean-twist {
   text-align: center;
   width: 100%;
  }

  .badboolean-topline {
   font-size: 20px;
   font-weight: 900;
   text-transform: uppercase;
   letter-spacing: 2px;
   color: #ff4acb;
   text-shadow: 0 0 16px rgba(255, 54, 204, 0.6);
  }

  .badboolean-subline {
   font-size: 16px;
   font-weight: 700;
   color: #f5ff7d;
   text-shadow: 0 0 12px rgba(0,0,0,0.8);
  }

  .badboolean-mainline {
   font-size: 28px;
   font-weight: 900;
   letter-spacing: 3px;
   color: #61f8ff;
   text-shadow: 0 0 18px rgba(97,248,255,0.9);
   margin: 0 auto;
   white-space: nowrap;
  }

  .badboolean-tagline {
   font-size: 14px;
   font-weight: 500;
   color: #ff92d0;
   font-style: italic;
  }

  .badboolean-footer {
   font-size: 12px;
   font-weight: 700;
   color: #ff5cff;
  }

  .badboolean-twist {
   font-size: 11px;
   font-weight: 500;
   color: rgba(255,255,255,0.78);
   text-transform: uppercase;
   letter-spacing: 0.18em;
  }

  /* Clean button reset for ToS state */
  .ref-sidebar-btn.tos-active {
  background: transparent !important;
  backdrop-filter: none !important;
  -webkit-backdrop-filter: none !important;
  border: none !important;
  border-radius: 0 !important;
  padding: 0 !important;
  box-shadow: none !important;
  animation: none !important;
  opacity: 1 !important;
  transform: scale(1) !important;
  text-align: left !important;
  display: block !important;
  width: 100% !important;
  min-height: auto !important;
  overflow: visible !important;
  }

  /* ToS card styling (match base card look) */
  .loom-invite-card--tos {
   position: relative !important;
   border-radius: 24px !important;
   background: linear-gradient(145deg, rgba(102, 126, 234, 0.32), rgba(143, 180, 255, 0.22), rgba(118, 75, 162, 0.28)) !important;
   backdrop-filter: blur(18px) saturate(220%) !important;
   -webkit-backdrop-filter: blur(18px) saturate(220%) !important;
   border: 1px solid rgba(160, 190, 255, 0.4) !important;
   box-shadow: 0 24px 50px rgba(9, 12, 34, 0.55), inset 0 1px 0 rgba(255, 255, 255, 0.22) !important;
   overflow: hidden !important;
   isolation: isolate !important;
   padding: 32px 36px !important;
   min-height: 200px !important;
  }

  .loom-invite-card--tos::after {
   content: '' !important;
   position: absolute !important;
   inset: 10% 6% !important;
   border-radius: 20px !important;
   background: radial-gradient(ellipse at 50% 0%, rgba(143, 180, 255, 0.35), transparent 65%) !important;
   opacity: 0.65 !important;
   mix-blend-mode: screen !important;
   pointer-events: none !important;
  }

  .loom-invite-stack {
   position: relative;
   width: 100%;
   min-height: 100%;
  }

  .loom-invite-card__header {
   position: relative;
   z-index: 1;
   padding-bottom: 24px;
   border-bottom: 1px solid rgba(160, 190, 255, 0.2);
   margin-bottom: 24px;
  }

  .loom-invite-card__body {
   position: relative;
   z-index: 1;
   display: flex;
   flex-direction: column;
   gap: 16px;
   font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
   color: #f8f9fa;
  }

  .loom-invite-opening {
   font-size: 15px;
   font-weight: 400;
   line-height: 1.6;
   color: rgba(255, 255, 255, 0.95);
   font-style: italic;
   opacity: 0.9;
  }

  .loom-invite-body-text {
   font-size: 14px;
   font-weight: 300;
   line-height: 1.7;
   color: rgba(255, 255, 255, 0.88);
  }

  .loom-invite-alpha {
   color: #8fb4ff;
   font-weight: 500;
   text-shadow: 0 0 12px rgba(143, 180, 255, 0.6);
  }

  .loom-invite-divider {
   font-size: 13px;
   color: rgba(255, 255, 255, 0.75);
   text-align: center;
   padding: 12px 0;
   border-top: 1px solid rgba(160, 190, 255, 0.15);
   border-bottom: 1px solid rgba(160, 190, 255, 0.15);
  }

  .tos-abbrev {
   color: #8fb4ff;
   font-weight: 600;
   cursor: help;
  }

  .tos-label {
   display: flex;
   align-items: center;
   justify-content: space-between;
   padding: 12px 16px;
   background: rgba(102, 126, 234, 0.15);
   border: 1px solid rgba(143, 180, 255, 0.3);
   border-radius: 8px;
   cursor: pointer;
   transition: all 0.2s ease;
   font-family: inherit;
   color: inherit;
   font-size: 13px;
  }

  .tos-label:hover {
   background: rgba(102, 126, 234, 0.25);
   border-color: rgba(143, 180, 255, 0.5);
  }

  .tos-label-eternal {
   color: #ff6b9d;
   font-weight: 600;
  }

  .tos-label-arrow {
   font-size: 18px;
   transition: transform 0.2s ease;
  }

  .tos-label[aria-expanded="true"] .tos-label-arrow {
   transform: rotate(90deg);
  }

  .tos-expandable {
   padding: 12px 16px;
   background: rgba(0, 0, 0, 0.2);
   border-radius: 6px;
   font-size: 12px;
   color: rgba(255, 255, 255, 0.7);
   font-style: italic;
  }

  .tos-expandable[hidden] {
   display: none;
  }

  .tos-checkbox {
   display: flex;
   align-items: center;
   gap: 12px;
   padding: 16px;
   background: rgba(143, 180, 255, 0.08);
   border-radius: 8px;
   cursor: pointer;
  }

  .tos-checkbox input[type="checkbox"] {
   width: 20px;
   height: 20px;
   accent-color: #8fb4ff;
   cursor: pointer;
  }

  .tos-checkbox label {
   font-size: 14px;
   font-weight: 500;
   color: rgba(255, 255, 255, 0.95);
   cursor: pointer;
  }

  .ref-sidebar-btn.loom-invite-active.audio-reactive .ai-message-tri-icon span:nth-child(2) {
   transform: translateY(calc(-6px - var(--chant-reactive, 0) * 8px)) scale(calc(1.12 + var(--chant-reactive, 0) * 0.3));
   opacity: calc(0.9 + var(--chant-reactive, 0) * 0.1);
  }

  .ref-sidebar-btn.loom-invite-active.audio-reactive .ai-message-tri-icon span:nth-child(1),
  .ref-sidebar-btn.loom-invite-active.audio-reactive .ai-message-tri-icon span:nth-child(3) {
   transform: translateY(calc(3px + var(--chant-reactive, 0) * -4px)) scale(calc(0.86 + var(--chant-reactive, 0) * 0.18));
   opacity: calc(0.85 + var(--chant-reactive, 0) * 0.12);
  }

 .loom-invite-pin {
  position: absolute;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.9);
  box-shadow: 0 0 12px rgba(255, 255, 255, 0.5);
  opacity: 0;
  transform: translate3d(0, 0, 0) scale(0.7);
  will-change: transform, opacity;
  pointer-events: none;
  z-index: 2;
 }

 .loom-invite-pin.pin-yellow {
  background: rgba(255, 255, 255, 0.9);
  box-shadow: 0 0 12px rgba(255, 255, 255, 0.5);
 }

 .loom-invite-pin.pin-cyan {
  background: rgba(255, 255, 255, 0.9);
  box-shadow: 0 0 12px rgba(255, 255, 255, 0.5);
 }

  @keyframes loomInvitePinFlight {
   0% {
    opacity: 0;
    transform: translate3d(0, 0, 0) scale(0.6);
   }
   12% {
    opacity: 1;
   }
   55% {
    opacity: 0.92;
   }
   100% {
    opacity: 0;
    transform: translate3d(var(--pin-flight-x, -55vw), var(--pin-flight-y, 0), 0) scale(1.05);
   }
  }

  /* Hide ALL debug/development UI during intro */
  body.intro-ui-hidden .debug-panel-button,
  body.intro-ui-hidden .debug-panel,
  body.intro-ui-hidden #toolsMenu,
  body.intro-ui-hidden #playerTuningUI,
  body.intro-ui-hidden #tuningPanelToggle,
  body.intro-ui-hidden #mapToolsBtn,
  body.intro-ui-hidden button[title*="Tuning"],
  body.intro-ui-hidden button[title*="Developer Tools"],
  body.intro-ui-hidden [class*="tuning"],
  body.intro-ui-hidden [class*="control-panel"],
  body.intro-ui-hidden [id*="tuning"],
  body.intro-ui-hidden [id*="controlPanel"] {
    display: none !important;
    visibility: hidden !important;
    opacity: 0 !important;
    pointer-events: none !important;
  }
  
  .debug-panel-button {
   position: fixed;
   bottom: 24px;
   left: 24px;
   transform: none;
   padding: 10px 18px;
   display: none; /* Hidden during intro */
   border-radius: 999px;
   background: rgba(15, 23, 42, 0.85);
   border: 1px solid rgba(148, 163, 184, 0.5);
   color: #e2e8f0;
   font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
   font-size: 13px;
   letter-spacing: 0.08em;
   text-transform: uppercase;
   cursor: pointer;
   z-index: 2147483900;
   box-shadow: 0 12px 32px rgba(15, 23, 42, 0.45);
   transition: transform 0.2s ease, background 0.2s ease, box-shadow 0.2s ease;
  }

  .debug-panel-button:hover,
  .debug-panel-button:focus-visible {
   background: rgba(30, 41, 59, 0.9);
   box-shadow: 0 16px 38px rgba(15, 23, 42, 0.55);
   transform: translateY(-2px);
   outline: none;
  }

  .debug-panel {
   position: fixed;
   bottom: 112px;
   left: 24px;
   transform: translateY(12px);
   width: min(380px, 92vw);
   background: rgba(12, 17, 29, 0.92);
   border: 1px solid rgba(100, 116, 139, 0.35);
   border-radius: 18px;
   padding: 18px;
   color: #e2e8f0;
   font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
   font-size: 13px;
   letter-spacing: 0.01em;
   box-shadow: 0 22px 50px rgba(15, 23, 42, 0.6);
   opacity: 0;
   pointer-events: none;
   transition: opacity 0.22s ease, transform 0.22s ease;
   z-index: 2147483910;
  }

  .debug-panel.visible {
   opacity: 1;
   transform: translateY(0);
   pointer-events: auto;
  }

  .debug-panel__header {
   display: flex;
   align-items: center;
   justify-content: space-between;
   font-size: 12px;
   letter-spacing: 0.12em;
   text-transform: uppercase;
   color: #94a3b8;
   margin-bottom: 14px;
  }

  .debug-panel__close {
   background: transparent;
   border: none;
   color: inherit;
   cursor: pointer;
   font-size: 16px;
   line-height: 1;
   padding: 4px 6px;
   border-radius: 8px;
  }

  .debug-panel__close:hover,
  .debug-panel__close:focus-visible {
   background: rgba(148, 163, 184, 0.12);
   outline: none;
  }

  .debug-panel__section {
   margin-bottom: 14px;
   display: grid;
   gap: 8px;
  }

  .debug-panel__section:last-of-type {
   margin-bottom: 0;
  }

  .debug-toggle {
   display: flex;
   align-items: center;
   gap: 10px;
  }

  .debug-toggle input[type='checkbox'] {
   width: 16px;
   height: 16px;
   accent-color: #38bdf8;
  }

  .debug-panel__stats {
   font-family: 'Roboto Mono', ui-monospace, SFMono-Regular, Menlo, Consolas, 'Liberation Mono', monospace;
   font-size: 12px;
   color: #cbd5f5;
  }

  .debug-panel__stats span {
   color: #facc15;
  }

  .debug-panel__cta {
   display: inline-flex;
   align-items: center;
   justify-content: center;
   padding: 8px 12px;
   border-radius: 999px;
   background: rgba(56, 189, 248, 0.16);
   border: 1px solid rgba(56, 189, 248, 0.35);
   color: #bae6fd;
   cursor: pointer;
   font-size: 12px;
   letter-spacing: 0.06em;
   text-transform: uppercase;
   transition: background 0.2s ease, border 0.2s ease;
  }

  .debug-panel__cta:hover,
  .debug-panel__cta:focus-visible {
   background: rgba(56, 189, 248, 0.28);
   border-color: rgba(56, 189, 248, 0.55);
   outline: none;
  }

  body.debug-hide-light-layers .light-ray,
  body.debug-hide-light-layers #lightBeam,
  body.debug-hide-light-layers .edge-impact,
  body.debug-hide-light-layers .darkening-overlay {
   display: none !important;
   opacity: 0 !important;
  }

  body.debug-hide-tri-color .tri-color-particles {
   display: none !important;
  }

  body.debug-hide-invite-waves .loom-invite-swarm {
   display: none !important;
  }

  .light-ray::before {
   background: linear-gradient(
    to left,
    rgba(255, 255, 255, 0),
    rgba(255, 255, 255, 0.08) 10%,
    rgba(255, 255, 255, 0.55) 32%,
    rgba(255, 255, 255, 0.85) 50%,
    rgba(255, 255, 255, 0.55) 68%,
    rgba(255, 255, 255, 0.08) 90%,
    rgba(255, 255, 255, 0)
   );
  }

  .light-ray::after {
   inset: -25% -4% -25% 0;
   background: linear-gradient(
    to left,
    rgba(255, 255, 255, 0.35),
    rgba(255, 255, 255, 0.2) 18%,
    rgba(255, 255, 255, 0.06) 60%,
    rgba(255, 255, 255, 0)
   );
   filter: blur(var(--ref-light-ray-blur, 12px));
   opacity: 0.65;
  }

  @keyframes ray-shine {
   0% { opacity: 0; transform: scaleX(0.2); }
   45% { opacity: 1; }
   100% { opacity: 0.4; transform: scaleX(1); }
  }
  
 /* Giant burst beam for final card entrance */
 .burst-beam {
  position: fixed;
  right: 0;
  top: 0;
  width: 80vw;
  height: 100vh;
  background: radial-gradient(ellipse 50% 50% at 100% 50%, rgba(255, 255, 255, 0.9) 0%, rgba(255, 255, 255, 0.4) 30%, transparent 60%);
  mix-blend-mode: screen;
  pointer-events: none;
  z-index: 2147483650;
  opacity: 0;
  animation: burst-flash 2.5s ease-out forwards;
  transform-origin: 100% 50%;
 }
 
 @keyframes burst-flash {
  0% { 
   opacity: 0; 
   transform: scaleX(0.1);
   filter: brightness(1);
  }
  10% { 
   opacity: 1; 
   transform: scaleX(0.4);
   filter: brightness(2);
  }
  25% { 
   opacity: 1; 
   transform: scaleX(1);
   filter: brightness(1.8);
  }
  50% {
   opacity: 0.8;
    transform: scaleX(1.1);
    filter: brightness(1.2);
   }
   100% { 
    opacity: 0.2; 
    transform: scaleX(1);
    filter: brightness(1);
   }
  }

  /* VisiCell Styles */
  .visicell-container {
   position: fixed;
   top: 0;
   left: 0;
   width: 100%;
   height: 100%;
   background: #000;
   z-index: 2147483647;
   font-family: 'Courier New', monospace;
   color: #0f0;
  }

  .visicell-datetime-widget {
   position: absolute;
   top: 10px;
   right: 10px;
   background: #111;
   border: 2px solid #0f0;
   padding: 8px 12px;
   cursor: pointer;
   transition: all 0.2s;
   z-index: 10;
  }

  .visicell-datetime-widget:hover {
   background: #0f0;
   color: #000;
   box-shadow: 0 0 20px #0f0;
  }

  .visicell-datetime-display {
   font-size: 14px;
   font-weight: bold;
   letter-spacing: 1px;
  }

  /* Rounded Corner Grid Window (Initial State) */
  .visicell-grid-window {
   position: absolute;
   top: 50%;
   left: 50%;
   transform: translate(-50%, -50%);
   width: 90%;
   max-width: 1200px;
   height: 80%;
   max-height: 800px;
   background: #000;
   border: 3px solid #0f0;
   border-radius: 20px;
   box-shadow: 0 0 40px rgba(0, 255, 0, 0.6);
   display: flex;
   flex-direction: column;
   overflow: hidden;
  }

  .visicell-grid-header {
   background: #0f0;
   color: #000;
   padding: 10px 15px;
   display: flex;
   justify-content: space-between;
   align-items: center;
   border-bottom: 2px solid #0f0;
  }

  .visicell-grid-tabs {
   display: flex;
   gap: 5px;
   flex: 1;
  }

  .visicell-tab {
   background: #000;
   color: #0f0;
   padding: 8px 16px;
   border: 2px solid #0f0;
   border-radius: 8px 8px 0 0;
   cursor: pointer;
   transition: all 0.2s;
   font-weight: bold;
   font-size: 12px;
   position: relative;
  }

  .visicell-tab:hover {
   background: #0a0;
   color: #000;
  }

  .visicell-tab.active {
   background: #0f0;
   color: #000;
   border-bottom: 2px solid #000;
   margin-bottom: -2px;
  }

  .visicell-grid-layers {
   flex: 1;
   position: relative;
   overflow: hidden;
  }

  .visicell-grid-layer {
   position: absolute;
   top: 0;
   left: 0;
   width: 100%;
   height: 100%;
   background: #000;
   padding: 20px;
   overflow: auto;
   display: none;
  }

  .visicell-grid-layer.active {
   display: block;
  }

  .visicell-grid-table {
   display: grid;
   grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
   gap: 2px;
   width: 100%;
  }

  .visicell-grid-cell {
   background: #000;
   border: 1px solid #0f0;
   padding: 12px 8px;
   text-align: center;
   font-size: 14px;
   min-height: 40px;
   display: flex;
   align-items: center;
   justify-content: center;
   cursor: pointer;
   transition: all 0.2s;
   position: relative;
  }

  .visicell-grid-cell:hover {
   background: #003300;
   box-shadow: inset 0 0 10px rgba(0, 255, 0, 0.3);
  }

  .visicell-grid-cell.editing {
   background: #001a00;
   box-shadow: inset 0 0 20px rgba(0, 255, 0, 0.5);
  }

  .visicell-grid-cell input {
   background: transparent;
   border: none;
   color: #0f0;
   font-family: 'Courier New', monospace;
   font-size: 14px;
   text-align: center;
   width: 100%;
   outline: none;
   text-transform: uppercase;
  }

  .visicell-grid-cell.r-sequence {
   animation: rPulse 0.3s ease-out;
  }

  @keyframes rPulse {
   0% { transform: scale(1); background: #000; }
   50% { transform: scale(1.1); background: #0a0; box-shadow: 0 0 20px #0f0; }
   100% { transform: scale(1); background: #000; }
  }

  /* Terminal Window (Devolved State) */
  .visicell-terminal-window {
   position: absolute;
   top: 50%;
   left: 50%;
   transform: translate(-50%, -50%);
   width: 80%;
   max-width: 800px;
   background: #000;
   border: 3px solid #0f0;
   box-shadow: 0 0 30px rgba(0, 255, 0, 0.5);
  }

  .visicell-title-bar {
   background: #0f0;
   color: #000;
   padding: 8px 12px;
   display: flex;
   justify-content: space-between;
   align-items: center;
   font-weight: bold;
  }

  .visicell-close-btn {
   background: #000;
   color: #0f0;
   border: 2px solid #0f0;
   font-size: 20px;
   width: 30px;
   height: 30px;
   cursor: pointer;
   transition: all 0.2s;
  }

  .visicell-close-btn:hover {
   background: #0f0;
   color: #000;
  }

  .visicell-content {
   padding: 20px;
   min-height: 400px;
   max-height: 60vh;
   overflow-y: auto;
  }

  .visicell-output {
   margin-bottom: 20px;
   white-space: pre-wrap;
   line-height: 1.6;
  }

  .visicell-input-line {
   display: flex;
   align-items: center;
   gap: 8px;
  }

  .visicell-prompt {
   color: #0f0;
   font-weight: bold;
  }

  .visicell-input {
   flex: 1;
   background: transparent;
   border: none;
   color: #0f0;
   font-family: 'Courier New', monospace;
   font-size: 16px;
   outline: none;
   text-transform: uppercase;
  }

  .visicell-settings-popup {
   position: fixed;
   top: 0;
   left: 0;
   width: 100%;
   height: 100%;
   background: rgba(0, 0, 0, 0.8);
   z-index: 2147483648;
   display: flex;
   align-items: center;
   justify-content: center;
  }

  .visicell-settings-window {
   background: #000;
   border: 3px solid #0f0;
   box-shadow: 0 0 40px rgba(0, 255, 0, 0.7);
   min-width: 400px;
  }

  .visicell-settings-content {
   padding: 20px;
  }

  .visicell-settings-section {
   margin-bottom: 20px;
  }

  .visicell-settings-section label {
   display: block;
   margin-bottom: 8px;
   color: #0f0;
   font-weight: bold;
  }

  .visicell-time-display {
   background: #111;
   border: 2px solid #0f0;
   padding: 10px;
   font-size: 18px;
   text-align: center;
  }

  .visicell-settings-section input {
   background: #111;
   border: 2px solid #0f0;
   color: #0f0;
   padding: 8px;
   width: 100%;
   font-family: 'Courier New', monospace;
   font-size: 16px;
  }

  .visicell-settings-section button {
   background: #0f0;
   color: #000;
   border: none;
   padding: 10px 20px;
   margin-top: 10px;
   cursor: pointer;
   font-weight: bold;
   font-family: 'Courier New', monospace;
   transition: all 0.2s;
  }

  .visicell-settings-section button:hover {
   background: #0f0;
   box-shadow: 0 0 20px #0f0;
  }

  .visicell-video-popup {
   position: fixed;
   top: 0;
   left: 0;
   width: 100%;
   height: 100%;
   background: rgba(0, 0, 0, 0.95);
   z-index: 2147483649;
   display: flex;
   align-items: center;
   justify-content: center;
   animation: fadeIn 0.5s ease-in;
  }

  .visicell-video-window {
   border: 3px solid #0f0;
   box-shadow: 0 0 50px rgba(0, 255, 0, 0.8);
   max-width: 90%;
   max-height: 90%;
  }

  .visicell-video-window video {
   display: block;
   max-width: 100%;
   max-height: 90vh;
  }

  @keyframes fadeIn {
   from { opacity: 0; }
   to { opacity: 1; }
  }

  .visicell-glitch {
   animation: glitch 0.3s infinite;
  }

  @keyframes glitch {
   0% { transform: translate(0); }
   20% { transform: translate(-2px, 2px); }
   40% { transform: translate(-2px, -2px); }
   60% { transform: translate(2px, 2px); }
   80% { transform: translate(2px, -2px); }
   100% { transform: translate(0); }
  }

  .ascii-house-container {
   position: fixed;
   top: 0;
   left: 0;
   width: 100%;
   height: 100%;
   background: #000;
   z-index: 2147483650;
   overflow: auto;
   animation: fadeIn 1s ease-in;
  }

  .ascii-house-content {
   padding: 40px;
   font-family: 'Courier New', monospace;
   color: #0f0;
   font-size: 12px;
   line-height: 1.2;
   white-space: pre;
  }

  .ascii-house-content .gir-trigger {
   color: #ff0;
   cursor: pointer;
   text-decoration: underline;
   animation: pulse 1s infinite;
  }

  .ascii-house-content .gir-trigger:hover {
   color: #f00;
   text-shadow: 0 0 10px #f00;
  }

  @keyframes pulse {
   0%, 100% { opacity: 1; }
   50% { opacity: 0.7; }
  }
 </style>
</head>
<body class="intro-ui-hidden">
 <div id="fallback" class="fallback-message" role="alert" aria-live="assertive" style="display:none">
  <div class="fallback-message__content">
   <h1>Celli requires WebGL</h1>
   <p>Your browser appears to have WebGL disabled. Enable hardware acceleration and reload to explore the full experience.</p>
  </div>
 </div>
 <div id="app" class="scanlines"></div>
 <div class="hud">
  <div id="quote" class="quote">
   <span id="quoteBefore" class="quote__text">...if you gaze for long into an abyss, the abyss gazes also into you.</span>
   <span id="quoteAfter" class="quote__text" style="display:none;"></span>
  </div>
  <div id="loomworks" class="loomworks" aria-live="polite">
   <span id="loomPre" class="loomworks-chunk">L</span><span id="loomCore" class="loomworks-chunk">OO</span><span id="loomPost" class="loomworks-chunk">K</span><span id="loomTail" class="loomworks-chunk"></span>
  </div>
  <span id="floatingK" class="floatingK" aria-hidden="true">K</span>
  <div class="vignette"></div>
 </div>
 <div id="screenGlitch" class="screenGlitch"></div>
 
 <!-- Doorway portal -->
 <div id="doorway" class="doorway">
  <div class="prompt-container">
   <div class="prompt" data-text="=STAR_"><span id="promptText">=STAR</span><span id="promptCursor" class="cursor">_</span></div>
  </div>
 </div>

<!-- Hidden input for mobile keyboards -->
<input id="hiddenInput" type="text"
       style="position:fixed; top:50%; left:50%; width:1px; height:1px; transform:translate(-50%, -50%); opacity:0; pointer-events:none; font-size:16px;"
       autocomplete="off" autocapitalize="none" autocorrect="off" spellcheck="false"
       inputmode="text" enterkeyhint="done" />
 
 <!-- Play Overlay -->
 <div id="play" class="play">
  <button id="playBtn">Play</button>
  <div style="display:flex; gap:10px; margin-top:10px; flex-wrap:wrap; justify-content:center; max-width:550px;">
   <button id="sceneSelectBtn" style="font-size:12px; padding:10px 20px; opacity:0.7;">Scene Select</button>
   <button id="fullSequenceBtn" class="full-sequence-btn">
    <span class="full-sequence-btn__glow" aria-hidden="true"></span>
    <span class="full-sequence-btn__sparkles" aria-hidden="true">
     <span></span>
     <span></span>
     <span></span>
    </span>
    <span class="full-sequence-btn__label">‚ú® Full Sequence</span>
   </button>
   <button id="testAudioBtn" style="font-size:12px; padding:10px 20px; opacity:0.7;">TEST Audio</button>
   <button id="resetThemeBtn" style="font-size:12px; padding:10px 20px; opacity:0.7; background:#34495e; color:#ecf0f1;">Reset Intro Theme</button>
   <button id="testVideoBtn" style="font-size:12px; padding:10px 20px; opacity:0.8; background:#1abc9c;">üéûÔ∏è Test Video Playlist</button>
   <button id="flashSceneBtn" style="font-size:12px; padding:10px 20px; opacity:0.85; background:#f39c12;">‚ö° Flash Scene</button>
  </div>
  <div style="display:flex; gap:10px; margin-top:8px; flex-wrap:wrap; justify-content:center; max-width:550px;">
   <button id="playIntroVideoBtn" style="font-size:12px; padding:10px 20px; opacity:0.7; background:#9b59b6;">üé¨ Play Intro</button>
   <button id="playIntroVideoBtn2" style="font-size:12px; padding:10px 20px; opacity:0.7; background:#8e44ad;">üé¨ Play Intro II</button>
   <button id="sequenceBuilderBtn" style="font-size:11px; padding:8px 16px; opacity:0.7; background:#ff6b6b;">üé¨ Sequence Builder</button>
   <button id="singleBuilderBtn" style="font-size:11px; padding:8px 16px; opacity:0.7; background:#ffa500;">üõ†Ô∏è Single Builder</button>
   <button id="testRunnerBtn" style="font-size:11px; padding:8px 16px; opacity:0.7; background:#4ec9b0;">üß™ Test Runner</button>
  </div>
  <div style="display:flex; gap:10px; margin-top:12px; flex-wrap:wrap; justify-content:center; max-width:550px; padding:10px; background:rgba(0,0,0,0.3); border-radius:8px;">
   <div style="color:#fff; font-size:11px; width:100%; text-align:center; margin-bottom:6px; opacity:0.8;">Scene Loading Mode:</div>
   <button id="useTemplateBtn" class="mode-toggle active" data-mode="template" style="flex:1; padding:8px 16px; background:#4a7cff; border:1px solid #6a9cff; color:#fff; border-radius:6px; cursor:pointer; font-size:11px; font-weight:600;">üìÑ Template (Fast)</button>
   <button id="useComponentBtn" class="mode-toggle" data-mode="component" style="flex:1; padding:8px 16px; background:#2a2a2f; border:1px solid #444; color:#ddd; border-radius:6px; cursor:pointer; font-size:11px; font-weight:600;">üß© Componentized</button>
  </div>
  
  <!-- Referrer Glitch Overlay Controls -->
  <div id="referrerControlsMenu" style="margin-top:16px; padding:10px; background:rgba(102,126,234,0.1); border:1px solid rgba(102,126,234,0.3); border-radius:8px; max-width:550px; display:none;">
   <div style="color:#667eea; font-size:11px; width:100%; text-align:center; margin-bottom:8px; font-weight:600;">‚ú® Referrer Glitch Overlay</div>
   <div style="display:flex; gap:8px; flex-wrap:wrap;">
    <input id="manualUrlInput" type="text" placeholder="Enter URL (e.g. reddit.com/r/programming)" style="flex:1; min-width:280px; padding:8px 12px; background:#191a23; border:1px solid rgba(255,255,255,.1); border-radius:6px; color:#e8e8ee; font-size:11px" />
    <button id="manualTrigger" style="padding:8px 16px; background:#667eea; border:0; color:#fff; border-radius:6px; cursor:pointer; font-size:11px; font-weight:600;">Open</button>
   </div>
   <div style="display:flex; gap:6px; margin-top:6px; justify-content:center; flex-wrap:wrap;">
    <button id="quickHN" style="padding:6px 14px; background:#ff6600; border:0; color:#000; border-radius:6px; cursor:pointer; font-size:10px; font-weight:700;">Hacker News</button>
    <button id="quickReddit" style="padding:6px 14px; background:#ff4500; border:0; color:#fff; border-radius:6px; cursor:pointer; font-size:10px; font-weight:700;">Reddit</button>
    <button id="quickTwitter" style="padding:6px 14px; background:#1da1f2; border:0; color:#fff; border-radius:6px; cursor:pointer; font-size:10px; font-weight:700;">Zeed</button>
    <button id="quickFacebook" style="padding:6px 14px; background:#1877f2; border:0; color:#fff; border-radius:6px; cursor:pointer; font-size:10px; font-weight:700;">Facebook</button>
    <button id="quickLinkedIn" style="padding:6px 14px; background:#0a66c2; border:0; color:#fff; border-radius:6px; cursor:pointer; font-size:10px; font-weight:700;">LinkedIn</button>
    <a id="directFormLink" href="./templates/componentized/beta-focus-form.html" rel="noopener" style="padding:6px 14px; background:#20c997; border-radius:6px; color:#0b0f16; cursor:pointer; font-size:10px; font-weight:700; text-decoration:none; display:inline-flex; align-items:center; gap:4px;">
     <span aria-hidden="true">üìù</span>
     <span>Beta Form</span>
    </a>
   </div>
  </div>
 </div>

 <!-- Passcode Prompt Overlay -->
 <div id="passcodeOverlay" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.85); z-index:2147483647; backdrop-filter:blur(8px); align-items:center; justify-content:center;">
  <div style="background:linear-gradient(145deg, rgba(25, 32, 58, 0.95), rgba(18, 26, 48, 0.9)); padding:32px 40px; border-radius:16px; border:1px solid rgba(102,126,234,0.4); box-shadow:0 20px 60px rgba(0,0,0,0.6); max-width:420px; width:90%;">
   <div style="color:#667eea; font-size:14px; font-weight:700; text-align:center; margin-bottom:8px; letter-spacing:0.1em;">üîê ACCESS CONTROL</div>
   <div style="color:#a0a8c0; font-size:12px; text-align:center; margin-bottom:24px; line-height:1.5;">Enter passcode to access debug menu</div>
   <input id="passcodeInput" type="password" placeholder="Enter passcode" style="width:100%; padding:14px 18px; background:#191a23; border:2px solid rgba(102,126,234,0.3); border-radius:10px; color:#e8e8ee; font-size:16px; text-align:center; letter-spacing:0.3em; font-weight:600; outline:none; transition:border-color 0.2s;" />
   <div id="passcodeError" style="color:#ff6b6b; font-size:11px; text-align:center; margin-top:12px; min-height:16px; opacity:0; transition:opacity 0.2s;"></div>
   <div style="display:flex; gap:12px; margin-top:20px;">
    <button id="passcodeCancel" style="flex:1; padding:12px; background:#2a2a2f; border:1px solid #444; color:#ddd; border-radius:8px; cursor:pointer; font-size:12px; font-weight:600;">Cancel</button>
    <button id="passcodeSubmit" style="flex:1; padding:12px; background:#667eea; border:0; color:#fff; border-radius:8px; cursor:pointer; font-size:12px; font-weight:600;">Submit</button>
   </div>
  </div>
 </div>
 
 <!-- Scene Select Menu -->
 <div id="sceneSelect">
  <div class="scene-menu">
   <h2>Scene Select</h2>
   <p>Jump to previously experienced sequences</p>
   
   <div id="sceneOptions">
    <div class="scene-option" data-scene="intro">
     <div>INTRO ‚Üí Boot Sequence</div>
     <div class="scene-option-desc">Launch the scripted onboarding experience</div>
    </div>

    <div class="scene-option" data-scene="visicell">
     <div>VISICELL ‚Üí Spreadsheet Emergence</div>
     <div class="scene-option-desc">The terminal awakens - spreadsheet reality unfolds</div>
    </div>

    <div class="scene-option" data-scene="city">
     <div>CITY ‚Üí Neon Breakout</div>
     <div class="scene-option-desc">Transition directly into the debug city scene</div>
    </div>

    <div class="scene-option" data-url="./flash.html" style="border-left: 3px solid #f39c12;">
     <div>FLASH ‚Üí Experimental Encounter</div>
     <div class="scene-option-desc">Open the Flash scene in a separate window</div>
    </div>

    <div class="scene-option locked" data-scene="leave">
     <div>LEAVE ‚Üí Initialize</div>
     <div class="scene-option-desc">The house of leaves - GIR.mp3 transformation</div>
    </div>

    <div class="scene-option locked" data-scene="theos">
     <div>THE.OS ‚Üí Cell Lattice <span class="mode-badge"></span></div>
     <div class="scene-option-desc">Cell address grid formation - witness the architecture ‚Ä¢ <span class="mode-indicator"></span></div>
    </div>

    <div class="scene-option locked" data-scene="blackhole">
     <div>THE.OS ‚Üí Black Hole <span class="mode-badge"></span></div>
     <div class="scene-option-desc">The void manifests - singularity achieved ‚Ä¢ <span class="mode-indicator"></span></div>
    </div>

    <div class="scene-option locked" data-scene="end3">
     <div>HARD.CORE ‚Üí End3 <span class="mode-badge"></span></div>
     <div class="scene-option-desc">Terminal environment - crawl sequence ‚Ä¢ <span class="mode-indicator"></span></div>
    </div>

   <div class="scene-option locked" data-scene="fullhand">
    <div>EXEC.ENV ‚Üí Execution Environment <span class="mode-badge"></span></div>
    <div class="scene-option-desc">Integrated scene - voxel hand, keyboard, character & glowing head ‚Ä¢ <span class="mode-indicator"></span></div>
    <div class="scene-mode-toggle" style="margin-top: 8px; display: flex; gap: 8px;">
      <button class="mode-btn active" data-mode="sequence" data-scene-target="fullhand" style="flex: 1; padding: 6px 12px; background: #4a7cff; border: 1px solid #6a9cff; color: #fff; border-radius: 4px; cursor: pointer; font-size: 11px; transition: all 0.2s; pointer-events: auto;">Sequence</button>
      <button class="mode-btn" data-mode="debug" data-scene-target="fullhand" style="flex: 1; padding: 6px 12px; background: #2a2a2f; border: 1px solid #444; color: #ddd; border-radius: 4px; cursor: pointer; font-size: 11px; transition: all 0.2s; pointer-events: auto;">Debug</button>
    </div>
   </div>

    <div class="scene-option locked" data-scene="cellireal">
     <div>CELLI.REAL ‚Üí Spreadsheet Reality <span class="mode-badge"></span></div>
     <div class="scene-option-desc">The awakened terminal - interactive spreadsheet environment ‚Ä¢ <span class="mode-indicator"></span></div>
    </div>
   
   <div class="scene-option" data-scene="rave" data-url="./templates/componentized/rave-complete.html" style="border-left: 3px solid #ff00ff;">
    <div>üéµ RAVE ‚Üí Celli & Array Party</div>
    <div class="scene-option-desc">Both avatars in a shared rave environment - pulsing lights, music visualization, and dance animations</div>
   </div>

    <div class="scene-option" data-scene="pockit" data-url="./scale-ultra.html" style="border-left: 3px solid #00d4ff;">
     <div>üåç POCKIT ‚Üí Scale Ultra World</div>
     <div class="scene-option-desc">Explore the procedural voxel world with interior room builder and asset placement</div>
    </div>

    <div class="scene-option" data-scene="sequence-builder" data-url="./tools/sequence-builder/index.html?standalone=true" style="border-left: 3px solid #ff6b6b;">
     <div>üé¨ DEV.TOOLS ‚Üí Sequence Builder</div>
     <div class="scene-option-desc">Visual node-based sequence composer (Press \ in any scene)</div>
    </div>

    <div class="scene-option" data-scene="test-runner" data-url="./tests/test-runner.html" style="border-left: 3px solid #4ec9b0;">
     <div>üß™ DEV.TOOLS ‚Üí Test Runner</div>
     <div class="scene-option-desc">Automated unit & regression tests for Celli subsystems</div>
    </div>
   </div>
   
   <div class="scene-controls">
    <button id="debugToggle">Debug: Show All</button>
    <button id="clearProgress">Clear Progress</button>
    <button class="close-btn" id="closeSceneSelect">Close</button>
   </div>
  </div>
 </div>
 
 <!-- Skip Button -->
 <div id="skipBtn" class="skip-btn hidden" role="button" aria-label="Skip intro" tabindex="0">
  <div class="skip-triangle skip-triangle--left" id="skipTriangle1">
   <div class="skip-triangle__inner">
    <svg viewBox="0 0 100 86.6025403784" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
     <polygon points="0,0 0,86.6025403784 100,43.3012701892"></polygon>
     <path d="M0,12 L0,74.6025403784 Q0,86.6025403784 11.012,81.8342402525 L88.988,48.0696001263 Q100,43.3012701892 88.988,38.5329402521 L11.012,4.7679001263 Q0,0 0,12 Z"></path>
    </svg>
   </div>
  </div>
  <div class="skip-connector" id="skipConnector" aria-hidden="true"></div>
  <div class="skip-triangle skip-triangle--right" id="skipTriangle2">
   <div class="skip-triangle__inner">
    <svg viewBox="0 0 100 86.6025403784" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
     <polygon points="100,0 100,86.6025403784 0,43.3012701892"></polygon>
     <path d="M100,12 L100,74.6025403784 Q100,86.6025403784 88.988,81.8342402525 L11.012,48.0696001263 Q0,43.3012701892 11.012,38.5329402521 L88.988,4.7679001263 Q100,0 100,12 Z"></path>
    </svg>
   </div>
  </div>
 </div>
 
 <!-- Toast Notification -->
 <div id="toast" class="toast" style="display:none"></div>
 
 <div id="introOverlay"><div id="introBrand">celli.os<div class="brand-ver">v.0.0.1</div></div></div>
 <div id="world"></div>
 <canvas id="view"></canvas>
 
<!-- UI Elements Container for Scene-Injected HTML -->
<div id="uiContainer"></div>

<!-- Tools Menu removed - production mode -->

<!-- Sequence Builder Overlay Container -->
<div id="sequence-overlay" style="display: none;"></div>

<!-- VisiCell Container -->
<div id="visicellContainer" class="visicell-container" style="display: none;">
 <div class="visicell-datetime-widget" id="visicellDateTime">
  <div class="visicell-datetime-display" id="visicellDateTimeDisplay">00:00:00</div>
 </div>
 
 <!-- Rounded Corner Spreadsheet Grid (Initial State) -->
 <div class="visicell-grid-window" id="visicellGridWindow">
  <div class="visicell-grid-header">
   <div class="visicell-grid-tabs" id="visicellTabs">
    <div class="visicell-tab active" data-tab="main">VISICELL</div>
   </div>
   <button class="visicell-close-btn" id="visicellCloseBtn">√ó</button>
  </div>
  <div class="visicell-grid-layers" id="visicellGridLayers">
   <div class="visicell-grid-layer active" id="visicellMainGrid" data-layer="main"></div>
  </div>
 </div>
 
 <!-- Terminal Window (Devolved State) -->
 <div class="visicell-terminal-window" id="visicellTerminal" style="display: none;">
  <div class="visicell-title-bar">
   <span class="visicell-title">LEAVE?</span>
   <button class="visicell-close-btn" id="visicellTerminalCloseBtn">√ó</button>
  </div>
  <div class="visicell-content">
   <div class="visicell-output" id="visicellOutput"></div>
   <div class="visicell-input-line">
    <span class="visicell-prompt">&gt;</span>
    <input type="text" class="visicell-input" id="visicellInput" autocomplete="off" spellcheck="false" />
   </div>
  </div>
 </div>
</div>

<!-- VisiCell DateTime Settings Popup -->
<div id="visicellDateTimeSettings" class="visicell-settings-popup" style="display: none;">
 <div class="visicell-settings-window">
  <div class="visicell-title-bar">
   <span class="visicell-title">DATE/TIME SETTINGS</span>
   <button class="visicell-close-btn" id="visicellSettingsCloseBtn">√ó</button>
  </div>
  <div class="visicell-settings-content">
   <div class="visicell-settings-section">
    <label>CURRENT TIME</label>
    <div class="visicell-time-display" id="visicellCurrentTime"></div>
   </div>
   <div class="visicell-settings-section">
    <label>ADJUST TIME (MINUTES)</label>
    <input type="number" id="visicellTimeOffset" value="0" min="-999" max="999" />
    <button id="visicellApplyTime">APPLY</button>
   </div>
  </div>
 </div>
</div>

<!-- VisiCell Video Popup -->
<div id="visicellVideoPopup" class="visicell-video-popup" style="display: none;">
 <div class="visicell-video-window">
  <video id="visicellVideo" autoplay></video>
 </div>
</div>

<!-- ASCII House of Leaves Container -->
<div id="asciiHouseContainer" class="ascii-house-container" style="display: none;">
 <div class="ascii-house-content" id="asciiHouseContent"></div>
</div>

<!-- Referrer Glitch Overlay -->
<div id="referrerStageRoot" class="referrer-stage-root">
 <div id="celliRefOverlay" class="celli-ref-overlay" aria-hidden="true">
  <div class="celli-ref-mask"></div>
  <div class="celli-ref-panel" role="dialog" aria-modal="true" aria-labelledby="refTitle">
   <div class="ref-header">
    <div id="refLogo" class="ref-logo">SRC</div>
    <div class="ref-meta">
     <div id="refTitle" class="ref-title">Reconstructing previous page‚Ä¶</div>
     <div id="refSub" class="ref-sub">Please wait</div>
    </div>
    <button id="refClose" class="ref-close" aria-label="Close overlay">Close</button>
   </div>

   <div id="refList" class="ref-list"></div>

   <div class="ref-footer">
    <div class="ref-sub">Looks unstable ‚Äî try "recreate" for another pass.</div>
    <div class="ref-controls">
    <a id="refFeedbackLink" class="btn ref-feedback-link" href="./templates/componentized/beta-focus-form.html?fullsequence=beta" rel="noopener">Feedback form</a>
     <button id="refReset" class="btn" style="background: #3498db;">‚Üª Reset</button>
     <button id="refRecreate" class="btn">Recreate</button>
     <button id="refDismiss" class="btn">Dismiss</button>
    </div>
   </div>

   <div id="refGlitch" class="ref-glitch" aria-hidden="true"></div>
   <div class="scanlines"></div>

   <!-- Sidebar Ad -->
   <div id="refSidebar" class="ref-sidebar" style="display:none;">
    <button id="refSidebarClose" class="ref-sidebar-close" aria-label="Close sidebar">‚úï</button>
    <h3>‚ú® Wait, what just happened?</h3>
    <p>You clicked a link and reality started to break down. The glitch is spreading...</p>
    <div id="refSidebarUrl" class="ref-sidebar-url" style="display:none"></div>
    <p style="font-size:12px;opacity:.7">This reconstructed page is unstable. Each click destabilizes it further.</p>
    <button id="refSidebarAck" class="ref-sidebar-btn loom-invite-base" type="button" aria-label="Open Loomworks invitation">
      <div class="loom-invite-stack loom-invite-stack--base">
        <div class="loom-invite-card loom-invite-card--base">
          <div class="loom-invite-emblem">
            <p class="loom-invite-line loom-invite-line--primary">.LOOMWORKS.</p>
            <p class="loom-invite-line loom-invite-line--secondary">..A SPECIAL INVITATION..</p>
            <p class="loom-invite-line loom-invite-line--tertiary">... A Beautiful Cell ...</p>
          </div>
          <div class="loom-invite-card__content">
            <strong class="loom-invite-card__headline">Claim your Loomworks access</strong>
            <span class="loom-invite-card__subline loom-invite-card__subline--audio" data-active="false">Now Playing: CallYouByMyName.mp3</span>
          </div>
        </div>
      </div>
    </button>
   </div>
  </div>

 </div>

 <!-- Tooltip -->
 <div id="refTooltip" class="ref-tooltip">
  <span class="ref-tooltip-bullet" aria-hidden="true"></span>
  <span class="ref-tooltip-text"></span>
 </div>

 <!-- Edge Impact Effects -->
 <div id="edgeImpact" class="edge-impact" aria-hidden="true"></div>
 <div id="baseDarkness" class="base-darkness" aria-hidden="true"></div>
 <div id="darkeningOverlay" class="darkening-overlay" aria-hidden="true"></div>
 <div id="lightBeam" class="light-beam" aria-hidden="true"></div>

 <!-- Video Player Overlay -->
 <div id="videoPlayerOverlay" style="position:fixed; inset:0; background:#000; z-index:2147484200; display:none; flex-direction:column; align-items:center; justify-content:center;">
  <div id="betaVideoStage" data-beta-stage="video" style="position:relative; width:90vw; height:90vh; display:flex; align-items:center; justify-content:center;">
   <video id="introVideo" style="display:none;" crossorigin="anonymous"></video>
   <canvas id="videoCanvas" style="max-width:100%; max-height:100%; object-fit:contain;"></canvas>
   <div style="position:absolute; bottom:20px; right:20px; display:flex; gap:10px;">
    <button id="videoCloseBtn" style="padding:10px 20px; background:#e74c3c; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600;">‚úï Close</button>
   </div>
  </div>
 </div>
</div>

<!-- Import map for ES modules -->
 <script type="importmap">
 {
  "imports": {
   "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
   "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
   "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
 }
 </script>

<!-- Main Application -->
<script type="module" src="./src/scripts/main.js"></script>

<!-- Map Navigation Module -->
<script type="module">
 import { map } from './src/scripts/tools/Map.js';
 window.mapModule = map;
 console.log('üó∫Ô∏è Map module loaded - Press M to open');
</script>

<!-- Early referrer overlay kill check (must run before main referrer script) -->
<script>
(function() {
  try {
    const betaRedirectStatus = document.body?.dataset?.betaRedirectComplete;
    const fullSequenceStage = sessionStorage.getItem('celli:fullSequenceStage');
    
    if (betaRedirectStatus === 'true' || fullSequenceStage === 'beta') {
      console.log('‚ö° IMMEDIATE KILL: Hiding referrer overlay on page load');
      
      // Set global flag to prevent any overlay triggers
      window.__referrerOverlayKilled = true;
      
      const refRoot = document.getElementById('referrerStageRoot');
      if (refRoot) {
        refRoot.style.cssText = 'display: none !important; opacity: 0 !important; visibility: hidden !important; z-index: -9999 !important; pointer-events: none !important;';
      }
      
      // Also hide the overlay itself
      const overlay = document.getElementById('celliRefOverlay');
      if (overlay) {
        overlay.style.cssText = 'display: none !important;';
        overlay.setAttribute('aria-hidden', 'true');
      }
      
      // Ensure black background
      document.documentElement.style.background = '#000';
      document.body.style.background = '#000';
      
      console.log('‚úÖ Referrer overlay completely suppressed');
    }
  } catch (e) {
    console.warn('Early overlay kill error:', e);
  }
})();
</script>

<!-- Referrer Glitch Overlay Logic -->
<script type="module">
  import { voxelShatter } from './src/scripts/effects/VoxelShatter.js';
  /*
    Celli Referrer Glitch Overlay
    - Triggers on Reddit / Hacker News arrivals, or manual URL input
    - Pulls data via public JSON APIs (HN Firebase, Reddit .json)
  */
  
  console.log('üöÄ REFERRER OVERLAY SCRIPT STARTING');
  console.error('=== DIAGNOSTIC MODE - CHECK FOR ERRORS BELOW ===');
  
  // Early check: If coming from redirect, kill overlay immediately
  (function earlyKillCheck() {
    try {
      const betaRedirectStatus = document.body?.dataset?.betaRedirectComplete;
      const fullSequenceStage = sessionStorage.getItem('celli:fullSequenceStage');
      const betaStage = 'beta';
      
      if (betaRedirectStatus === 'true' || fullSequenceStage === betaStage) {
        console.log('‚ö° Early kill: Detected redirect status, preparing to hide referrer overlay');
        // Set a flag that will be checked by killReferrerOverlay
        window.__shouldKillReferrer = true;
      }
    } catch (e) {
      console.warn('Early kill check error:', e);
    }
  })();
  
  const overlay = document.getElementById('celliRefOverlay');
  const refStageRoot = document.getElementById('referrerStageRoot');
  const bodyEl = document.body;
  const refHeader = document.querySelector('.ref-header');
  const refLogo = document.getElementById('refLogo');
  const refTitle = document.getElementById('refTitle');
  const refSub = document.getElementById('refSub');
  const refList = document.getElementById('refList');
  const btnClose = document.getElementById('refClose');
  const btnDismiss = document.getElementById('refDismiss');
  const btnRecreate = document.getElementById('refRecreate');
  const btnReset = document.getElementById('refReset');
  const refGlitch = document.getElementById('refGlitch');
  const refSidebar = document.getElementById('refSidebar');
  const refSidebarClose = document.getElementById('refSidebarClose');
  const refSidebarUrl = document.getElementById('refSidebarUrl');
  const refSidebarAck = document.getElementById('refSidebarAck');
  const loomAudioStatus = refSidebarAck ? refSidebarAck.querySelector('.loom-invite-card__subline--audio') : null;
  const refFeedbackLink = document.getElementById('refFeedbackLink');
  const directFormLink = document.getElementById('directFormLink');
  const LOOM_AUDIO_STATUS_TEXT = 'Streaming CallYouByMyName.mp3';

  function computeAppBaseUrl() {
    const href = window.location && typeof window.location.href === 'string'
      ? window.location.href
      : '';

    try {
      const current = new URL(href);
      if (current.protocol === 'file:') {
        const sanitized = href.replace(/[?#].*$/, '');
        if (sanitized.endsWith('/')) {
          return sanitized;
        }
        const slashIndex = sanitized.lastIndexOf('/');
        return slashIndex >= 0 ? `${sanitized.slice(0, slashIndex + 1)}` : sanitized;
      }

      let basePath = current.pathname || '/';
      if (!basePath.endsWith('/')) {
        const lastSlashIndex = basePath.lastIndexOf('/');
        const lastSegment = lastSlashIndex >= 0 ? basePath.slice(lastSlashIndex + 1) : basePath;
        const looksLikeFile = /\.[A-Za-z0-9]+$/.test(lastSegment);
        if (looksLikeFile) {
          basePath = lastSlashIndex >= 0 ? basePath.slice(0, lastSlashIndex + 1) : '/';
        } else {
          basePath = `${basePath}/`;
        }
      }

      return `${current.origin}${basePath}`;
    } catch (error) {
      console.warn('‚ö†Ô∏è Unable to compute app base URL, defaulting to current directory:', error);
      const sanitized = href.replace(/[?#].*$/, '');
      if (sanitized.endsWith('/')) {
        return sanitized;
      }
      const slashIndex = sanitized.lastIndexOf('/');
      if (slashIndex >= 0) {
        const lastSegment = sanitized.slice(slashIndex + 1);
        const looksLikeFile = /\.[A-Za-z0-9]+$/.test(lastSegment);
        if (looksLikeFile) {
          return `${sanitized.slice(0, slashIndex + 1)}`;
        }
        return `${sanitized}/`;
      }
      return sanitized || './';
    }
  }

  const APP_BASE_URL = computeAppBaseUrl();
  const BETA_FOCUS_FORM_URL = new URL('templates/componentized/beta-focus-form.html?fullsequence=beta', APP_BASE_URL).toString();

  // Kill the referrer overlay by hiding it beneath a black canvas
  function killReferrerOverlay(){
    try{
      console.log('üî™ Killing referrer overlay - hiding completely');
      
      // Set global flag to prevent any future overlay opens
      window.__referrerOverlayKilled = true;
      
      // Hide referrer stage root completely
      const refStageRoot = document.getElementById('referrerStageRoot');
      if(refStageRoot){
        refStageRoot.style.cssText = 'display: none !important; opacity: 0 !important; visibility: hidden !important; z-index: -9999 !important; pointer-events: none !important;';
      }
      
      // Also hide overlay and sidebar
      const overlay = document.getElementById('celliRefOverlay');
      if(overlay){
        overlay.setAttribute('aria-hidden', 'true');
        overlay.style.cssText = 'display: none !important;';
      }
      
      const refSidebar = document.getElementById('refSidebar');
      if(refSidebar){
        refSidebar.style.display = 'none';
      }
      
      // Deactivate referrer state
      deactivateReferrerStageRoot();
      setReferrerOverlayActiveState(false);
      
      // Ensure world/view are visible for new scenes
      const world = document.getElementById('world');
      const view = document.getElementById('view');
      if(world){
        world.style.display = '';
        world.style.zIndex = '';
      }
      if(view){
        view.style.display = '';
        view.style.zIndex = '';
      }
      
      // Remove any existing kill canvas - no longer needed since we're hiding overlay directly
      const existingCanvas = document.getElementById('referrerKillCanvas');
      if(existingCanvas){
        existingCanvas.remove();
        console.log('  Removed existing kill canvas');
      }
      
      console.log('‚úÖ Referrer overlay killed - hidden completely and blocked from reopening');
    }catch(e){
      console.error('‚ùå Error killing referrer overlay:', e);
    }
  }

  // Immediate blackout + redirect helper to avoid laggy pixel sweep
  function blackoutUnderPage(){
    try{
      document.documentElement.style.background = '#000';
      document.body.style.background = '#000';
      let under = document.getElementById('refBlackUnderlay');
      if(!under){
        under = document.createElement('div');
        under.id = 'refBlackUnderlay';
        under.style.cssText = 'position:fixed;inset:0;background:#000;z-index:0;';
        document.body.insertBefore(under, document.body.firstChild || null);
      }
      const world = document.getElementById('world');
      const view = document.getElementById('view');
      if(world) world.style.display = 'none';
      if(view) view.style.display = 'none';
    }catch(e){ /* no-op */ }
  }

  function redirectToBetaFormImmediate(){
    try{ markBetaRedirectPending(); }catch(e){}
    killReferrerOverlay(); // Kill referrer overlay before redirect
    blackoutUnderPage();
    try{
      window.location.assign(BETA_FOCUS_FORM_URL);
    }catch(e){
      window.location.href = BETA_FOCUS_FORM_URL;
    }
  }
  const FULL_SEQUENCE_FLAG_KEY = 'celli:fullSequenceActive';
  const FULL_SEQUENCE_STAGE_KEY = 'celli:fullSequenceStage';
  const FULL_SEQUENCE_REFERRER_STAGE = 'referrer';
  const FULL_SEQUENCE_REFERRER_ACTIVE_KEY = 'celli:fullSequenceReferrerActive';
  const FULL_SEQUENCE_BETA_STAGE = 'beta';
  let betaFormRedirectTimeoutId = null;
  let betaFallbackCheckTimeoutId = null;
  let betaVideoSequenceStarted = false;

  if (refFeedbackLink) {
    refFeedbackLink.href = BETA_FOCUS_FORM_URL;
  }

  if (directFormLink) {
    directFormLink.href = BETA_FOCUS_FORM_URL;
    directFormLink.removeAttribute('target');
  }

  function ensureReferrerSequenceSession() {
    try {
      window.sessionStorage?.setItem(FULL_SEQUENCE_FLAG_KEY, 'true');
      const currentStage = window.sessionStorage?.getItem(FULL_SEQUENCE_STAGE_KEY);
      if (!currentStage || currentStage === FULL_SEQUENCE_REFERRER_STAGE) {
        window.sessionStorage.setItem(FULL_SEQUENCE_STAGE_KEY, FULL_SEQUENCE_REFERRER_STAGE);
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Unable to establish Full Sequence session for referrer overlay:', error);
    }
  }

  function markBetaRedirectPending() {
    document.body.dataset.betaRedirectComplete = 'pending';
  }

  function markBetaRedirectComplete() {
    if (document.body.dataset.betaRedirectComplete === 'pending') {
      document.body.dataset.betaRedirectComplete = 'true';
    }
  }

  function setReferrerOverlayActiveState(isActive) {
    try {
      if (isActive) {
        window.sessionStorage?.setItem(FULL_SEQUENCE_REFERRER_ACTIVE_KEY, 'true');
      } else {
        window.sessionStorage?.removeItem(FULL_SEQUENCE_REFERRER_ACTIVE_KEY);
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Unable to update referrer overlay active state:', error);
    }
  }

  function activateReferrerStageRoot() {
    if (refStageRoot) {
      refStageRoot.classList.add('active');
    }
    if (bodyEl) {
      bodyEl.classList.add('referrer-stage-active');
    }
  }

  function deactivateReferrerStageRoot() {
    if (refStageRoot) {
      refStageRoot.classList.remove('active');
    }
    if (bodyEl) {
      bodyEl.classList.remove('referrer-stage-active');
    }
  }

  window.addEventListener('beforeunload', markBetaRedirectComplete);
  window.addEventListener('pagehide', markBetaRedirectComplete);

  function setLoomAudioStatus(isPlaying) {
    if (!loomAudioStatus) return;
    loomAudioStatus.textContent = LOOM_AUDIO_STATUS_TEXT;
    loomAudioStatus.setAttribute('data-active', isPlaying ? 'true' : 'false');
  }

  const refTooltip = document.getElementById('refTooltip');
  const refTooltipText = refTooltip ? refTooltip.querySelector('.ref-tooltip-text') : null;
  const refPanel = document.querySelector('.celli-ref-panel');
  const edgeImpact = document.getElementById('edgeImpact');
  const baseDarkness = document.getElementById('baseDarkness');
  const darkeningOverlay = document.getElementById('darkeningOverlay');
  const lightBeam = document.getElementById('lightBeam');
  const REFERRER_MOBILE_BREAKPOINT = 860;
  const layoutMediaQuery = window.matchMedia(`(max-width: ${REFERRER_MOBILE_BREAKPOINT}px)`);

  function updateReferrerLayoutMode() {
    if (!overlay) {
      return;
    }
    const prefersCoarse = window.matchMedia('(pointer: coarse)').matches;
    const isMobileLayout = layoutMediaQuery.matches || prefersCoarse;
    overlay.classList.toggle('ref-mode-mobile', isMobileLayout);
    overlay.classList.toggle('ref-mode-desktop', !isMobileLayout);
    overlay.dataset.deviceMode = isMobileLayout ? 'mobile' : 'desktop';
    if (bodyEl) {
      bodyEl.classList.toggle('referrer-mobile', isMobileLayout);
      bodyEl.classList.toggle('referrer-desktop', !isMobileLayout);
    }
  }

  updateReferrerLayoutMode();
  if (typeof layoutMediaQuery.addEventListener === 'function') {
    layoutMediaQuery.addEventListener('change', updateReferrerLayoutMode);
  } else if (typeof layoutMediaQuery.addListener === 'function') {
    layoutMediaQuery.addListener(updateReferrerLayoutMode);
  }
  window.addEventListener('orientationchange', updateReferrerLayoutMode);

  const chantAudio = new Audio('./chant.mp3');
  chantAudio.preload = 'auto';
  const CHANT_TARGET_VOLUME = 0.7;
  const CHANT_FADE_DURATION = 3200;
  chantAudio.volume = 0;
  document.documentElement.style.setProperty('--chant-reactive', '0');

  function createCaseInsensitiveAudio(basePath) {
    const audio = new Audio();
    audio.preload = 'auto';
    const lastSlash = basePath.lastIndexOf('/');
    const directory = lastSlash >= 0 ? basePath.slice(0, lastSlash + 1) : '';
    const filename = lastSlash >= 0 ? basePath.slice(lastSlash + 1) : basePath;
    const stem = filename.replace(/\.mp3$/i, '');
    const variants = Array.from(new Set([
      `${directory}${stem}.mp3`,
      `${directory}${stem}.MP3`,
      `${directory}${stem}.Mp3`,
      `${directory}${stem}.mP3`,
      `${directory}${stem.toLowerCase()}.mp3`,
      `${directory}${stem.toUpperCase()}.mp3`,
      `${directory}${stem.charAt(0).toUpperCase()}${stem.slice(1)}.mp3`
    ]));
    let attempt = 0;
    const handleError = () => {
      attempt += 1;
      if (attempt < variants.length) {
        audio.src = variants[attempt];
      } else {
        audio.removeEventListener('error', handleError);
      }
    };
    audio.addEventListener('error', handleError);
    audio.addEventListener('loadeddata', () => {
      audio.removeEventListener('error', handleError);
    }, { once: true });
    audio.src = variants[attempt];
    return audio;
  }

  const badBooleanTrack = createCaseInsensitiveAudio('./badboolean.mp3');
  badBooleanTrack.loop = false;
  badBooleanTrack.volume = 0.82;

  let holdWhirContext = null;
  let holdWhirOscillator = null;
  let holdWhirGain = null;
  let holdWhirFilter = null;
  let holdWhirLfo = null;
  let holdWhirLfoGain = null;

  let badBooleanContext = null;
  let badBooleanSource = null;
  let badBooleanAnalyser = null;
  let badBooleanAnalyserData = null;
  let badBooleanFrameId = null;
  let badBooleanWaveChars = [];
  let badBooleanAmbientContainer = null;
  let badBooleanAmbientChars = [];
  let badBooleanAmbientShuffleId = null;
  let badBooleanPartyActive = false;

  let scratchContext = null;
  let scratchGlitchPromise = Promise.resolve();
  let badBooleanEndListener = null;
  let badBooleanErrorListener = null;

  let chantAudioContext = null;
  let chantAudioSource = null;
  let chantAnalyser = null;
  let chantAnalyserData = null;
  let chantVisualizerFrameId = null;
  let chantVisualizerStartTimeout = null;
  let chantVisualizerLevel = 0;
  let chantVisualizerWarned = false;
  let chantUnlockHandler = null;

  function stopBadBooleanTrack() {
    try {
      badBooleanTrack.pause();
      badBooleanTrack.currentTime = 0;
    } catch (error) {
      console.warn('Unable to reset BadBoolean track', error);
    }
    clearBadBooleanCompletionListeners();
    stopBadBooleanVisualizer();
    teardownBadBooleanAmbient();
  }

  function playBadBooleanTrack() {
    const playback = badBooleanTrack.play();
    if (playback && typeof playback.catch === 'function') {
      playback.catch((error) => {
        console.warn('BadBoolean audio playback failed:', error);
        handleBadBooleanCompletion('playback blocked');
      });
    } else if (!playback) {
      handleBadBooleanCompletion('playback unavailable');
    }
    return playback;
  }

  function playRecordScratchGlitch(duration = 0.65) {
    const AudioContextClass = window.AudioContext || window.webkitAudioContext;
    if (!AudioContextClass) {
      return Promise.resolve();
    }
    if (!scratchContext) {
      scratchContext = new AudioContextClass();
    } else if (scratchContext.state === 'suspended') {
      scratchContext.resume().catch(() => {});
    }
    return new Promise((resolve) => {
      try {
        const ctx = scratchContext;
        const frames = Math.max(1, Math.floor(ctx.sampleRate * duration));
        const buffer = ctx.createBuffer(1, frames, ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < frames; i += 1) {
          const t = i / frames;
          const noise = (Math.random() * 2 - 1) * (1 - t);
          const chirp = Math.sin(2 * Math.PI * (420 + t * 900) * (i / ctx.sampleRate));
          data[i] = (noise * 0.55) + (chirp * Math.pow(1 - t, 0.35));
        }
        const source = ctx.createBufferSource();
        source.buffer = buffer;
        const filter = ctx.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.value = 1800;
        filter.Q.value = 5.5;
        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0.0001, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(1, ctx.currentTime + 0.03);
        gain.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + duration);
        source.connect(filter);
        filter.connect(gain);
        gain.connect(ctx.destination);
        source.addEventListener('ended', resolve);
        source.start();
        source.stop(ctx.currentTime + duration + 0.05);
      } catch (error) {
        console.warn('Record scratch synthesis failed:', error);
        resolve();
      }
    });
  }

  function ensureBadBooleanAnalyser() {
    const AudioContextClass = window.AudioContext || window.webkitAudioContext;
    if (!AudioContextClass) {
      return false;
    }

    if (!badBooleanContext) {
      badBooleanContext = new AudioContextClass();
    }

    if (badBooleanContext.state === 'suspended') {
      badBooleanContext.resume().catch(() => {});
    }

    if (!badBooleanSource) {
      try {
        badBooleanSource = badBooleanContext.createMediaElementSource(badBooleanTrack);
      } catch (error) {
        console.warn('‚ö†Ô∏è Unable to create BadBoolean media source:', error);
        return false;
      }
    }

    if (!badBooleanAnalyser) {
      badBooleanAnalyser = badBooleanContext.createAnalyser();
      badBooleanAnalyser.fftSize = 256;
      badBooleanAnalyser.smoothingTimeConstant = 0.78;
      badBooleanSource.connect(badBooleanAnalyser);
      badBooleanAnalyser.connect(badBooleanContext.destination);
      badBooleanAnalyserData = new Uint8Array(badBooleanAnalyser.frequencyBinCount);
    }

    return true;
  }

  function applyBadBooleanWave(container) {
    badBooleanWaveChars = [];
    if (!container) {
      return;
    }

    const lines = container.querySelectorAll('[data-wave-line]');
    lines.forEach((line) => {
      const rawText = line.dataset.waveRaw || line.textContent || '';
      line.dataset.waveRaw = rawText;
      line.textContent = '';
      const wrapper = document.createElement('span');
      wrapper.className = 'badboolean-wave-line';
      Array.from(rawText).forEach((character) => {
        const span = document.createElement('span');
        span.className = 'badboolean-wave-char';
        span.textContent = character === ' ' ? '\u00A0' : character;
        wrapper.appendChild(span);
        badBooleanWaveChars.push({ element: span, boost: parseFloat(line.dataset.waveBoost || '1') });
      });
      line.appendChild(wrapper);
    });

    buildBadBooleanAmbient();
  }

  function ensureBadBooleanAmbientContainer() {
    if (!refSidebar) {
      return null;
    }

    if (badBooleanAmbientContainer && badBooleanAmbientContainer.isConnected) {
      return badBooleanAmbientContainer;
    }

    const container = document.createElement('div');
    container.className = 'badboolean-ambient';
    refSidebar.insertBefore(container, refSidebar.firstChild || null);
    badBooleanAmbientContainer = container;
    return container;
  }

  function randomizeAmbientChar(span) {
    if (!span) {
      return;
    }

    const left = Math.random() * 100;
    const top = Math.random() * 100;
    const rotation = (Math.random() * 48) - 24;
    const duration = (6 + Math.random() * 6).toFixed(2);
    const opacity = (0.28 + Math.random() * 0.45).toFixed(2);
    const driftX = (Math.random() * 24 - 12).toFixed(2);
    const driftY = (Math.random() * 20 - 10).toFixed(2);

    span.style.setProperty('--ambient-left', `${left}%`);
    span.style.setProperty('--ambient-top', `${top}%`);
    span.style.setProperty('--ambient-rotation', `${rotation}deg`);
    span.style.setProperty('--ambient-duration', `${duration}s`);
    span.style.setProperty('--ambient-opacity', opacity);
    span.style.setProperty('--ambient-drift-x', `${driftX}px`);
    span.style.setProperty('--ambient-drift-y', `${driftY}px`);
  }

  function scheduleBadBooleanAmbientShuffle() {
    if (badBooleanAmbientShuffleId) {
      clearTimeout(badBooleanAmbientShuffleId);
      badBooleanAmbientShuffleId = null;
    }

    if (!badBooleanAmbientChars.length) {
      return;
    }

    badBooleanAmbientShuffleId = window.setTimeout(() => {
      badBooleanAmbientShuffleId = null;
      badBooleanAmbientChars.forEach(randomizeAmbientChar);
      scheduleBadBooleanAmbientShuffle();
    }, 4200);
  }

  function buildBadBooleanAmbient() {
    const container = ensureBadBooleanAmbientContainer();
    if (!container) {
      return;
    }

    if (badBooleanAmbientShuffleId) {
      clearTimeout(badBooleanAmbientShuffleId);
      badBooleanAmbientShuffleId = null;
    }

    container.classList.remove('is-active');
    container.innerHTML = '';
    badBooleanAmbientChars = [];

    if (!badBooleanWaveChars.length) {
      return;
    }

    const characters = badBooleanWaveChars
      .map(record => (record.element ? record.element.textContent : ''))
      .filter(Boolean);

    if (!characters.length) {
      return;
    }

    const ambientTotal = Math.min(42, Math.max(12, characters.length * 2));
    for (let i = 0; i < ambientTotal; i += 1) {
      const span = document.createElement('span');
      span.className = 'badboolean-ambient__char';
      const sourceChar = characters[i % characters.length];
      span.textContent = sourceChar || '‚Ä¢';
      randomizeAmbientChar(span);
      container.appendChild(span);
      badBooleanAmbientChars.push(span);
    }

    requestAnimationFrame(() => {
      container.classList.add('is-active');
    });

    scheduleBadBooleanAmbientShuffle();
  }

  function teardownBadBooleanAmbient() {
    if (badBooleanAmbientShuffleId) {
      clearTimeout(badBooleanAmbientShuffleId);
      badBooleanAmbientShuffleId = null;
    }

    if (badBooleanAmbientContainer) {
      badBooleanAmbientContainer.classList.remove('is-active');
      badBooleanAmbientContainer.innerHTML = '';
      if (badBooleanAmbientContainer.parentNode) {
        badBooleanAmbientContainer.parentNode.removeChild(badBooleanAmbientContainer);
      }
    }

    badBooleanAmbientContainer = null;
    badBooleanAmbientChars = [];
  }

  function updateBadBooleanVisualizer() {
    if (!badBooleanAnalyser || !badBooleanAnalyserData) {
      badBooleanFrameId = requestAnimationFrame(updateBadBooleanVisualizer);
      return;
    }

    badBooleanAnalyser.getByteFrequencyData(badBooleanAnalyserData);
    const length = badBooleanWaveChars.length || 1;
    for (let i = 0; i < length; i += 1) {
      const charRecord = badBooleanWaveChars[i];
      if (!charRecord || !charRecord.element) {
        continue;
      }
      const binIndex = Math.min(badBooleanAnalyserData.length - 1, Math.floor((i / length) * badBooleanAnalyserData.length));
      const raw = badBooleanAnalyserData[binIndex] / 255;
      const emphasis = Math.pow(raw, 1.4);
      const boost = Number.isFinite(charRecord.boost) ? charRecord.boost : 1;
      const level = Math.min(1, emphasis * (0.9 + boost * 0.55));
      charRecord.element.style.setProperty('--wave-level', level.toFixed(3));
      if (level > 0.25) {
        const hue = Math.max(0, 300 - (level * 180));
        charRecord.element.style.color = `hsl(${hue.toFixed(0)}, 100%, ${(60 + level * 20).toFixed(1)}%)`;
      } else {
        charRecord.element.style.color = '';
      }
    }

    badBooleanFrameId = requestAnimationFrame(updateBadBooleanVisualizer);
  }

  function startBadBooleanVisualizer() {
    if (!ensureBadBooleanAnalyser()) {
      return;
    }

    if (!badBooleanWaveChars.length && refSidebarAck) {
      applyBadBooleanWave(refSidebarAck);
    }

    if (refSidebar) {
      refSidebar.classList.add('badboolean-party');
    }
    if (refSidebarAck) {
      refSidebarAck.classList.add('badboolean-party');
    }

    if (!badBooleanFrameId) {
      badBooleanFrameId = requestAnimationFrame(updateBadBooleanVisualizer);
    }

    badBooleanPartyActive = true;
  }

  function stopBadBooleanVisualizer() {
    if (badBooleanFrameId) {
      cancelAnimationFrame(badBooleanFrameId);
      badBooleanFrameId = null;
    }

    badBooleanWaveChars.forEach((record) => {
      if (record?.element) {
        record.element.style.setProperty('--wave-level', '0');
        record.element.style.color = '';
      }
    });
    badBooleanWaveChars = [];

    if (refSidebar) {
      refSidebar.classList.remove('badboolean-party');
    }
    if (refSidebarAck) {
      refSidebarAck.classList.remove('badboolean-party');
    }

    badBooleanPartyActive = false;
  }

  function startBadBooleanAdAudio() {
    stopChantAudio();
    stopBadBooleanTrack();
    scratchGlitchPromise = playRecordScratchGlitch().then(() => {
      playBadBooleanTrack();
    });
  }

  badBooleanTrack.addEventListener('play', () => {
    startBadBooleanVisualizer();
  });

  chantAudio.addEventListener('play', () => startChantVisualizer(6000));
  chantAudio.addEventListener('ended', () => {
    setLoomAudioStatus(false);
    stopChantVisualizer();
  });
  chantAudio.addEventListener('pause', () => {
    if (chantAudio.currentTime === 0 || chantAudio.ended) {
      setLoomAudioStatus(false);
      stopChantVisualizer();
    }
  });

  function initChantAnalyser() {
    if (chantAnalyser) {
      return true;
    }

    const AudioContext = window.AudioContext || window.webkitAudioContext;
    if (!AudioContext) {
      if (!chantVisualizerWarned) {
        console.warn('‚ö†Ô∏è Web Audio API not supported; chant visualizer disabled.');
        chantVisualizerWarned = true;
      }
      return false;
    }

    try {
      if (!chantAudioContext) {
        chantAudioContext = new AudioContext();
      }

      if (!chantAudioSource) {
        chantAudioSource = chantAudioContext.createMediaElementSource(chantAudio);
      }

      chantAnalyser = chantAudioContext.createAnalyser();
      chantAnalyser.fftSize = 256;
      chantAnalyser.smoothingTimeConstant = 0.8;
      chantAudioSource.connect(chantAnalyser);
      chantAnalyser.connect(chantAudioContext.destination);
      chantAnalyserData = new Uint8Array(chantAnalyser.frequencyBinCount);
      return true;
    } catch (error) {
      if (!chantVisualizerWarned) {
        console.warn('‚ö†Ô∏è Unable to initialise chant visualizer:', error);
        chantVisualizerWarned = true;
      }
      chantAnalyser = null;
      chantAudioSource = null;
      return false;
    }
  }

  function updateChantVisualizer() {
    if (!chantAnalyser || !chantAnalyserData) {
      return;
    }

    chantAnalyser.getByteFrequencyData(chantAnalyserData);
    let sum = 0;
    for (let i = 0; i < chantAnalyserData.length; i += 1) {
      sum += chantAnalyserData[i];
    }

    const average = sum / chantAnalyserData.length / 255;
    const emphasis = Math.pow(Math.max(average, 0), 1.5);
    chantVisualizerLevel = (chantVisualizerLevel * 0.7) + (emphasis * 0.3);
    document.documentElement.style.setProperty('--chant-reactive', chantVisualizerLevel.toFixed(3));
    chantVisualizerFrameId = requestAnimationFrame(updateChantVisualizer);
  }

  function startChantVisualizer(delayMs = 0) {
    if (chantVisualizerStartTimeout) {
      clearTimeout(chantVisualizerStartTimeout);
      chantVisualizerStartTimeout = null;
    }

    const activate = () => {
      chantVisualizerStartTimeout = null;
      activateChantVisualizer();
    };

    if (delayMs <= 0) {
      activate();
    } else {
      chantVisualizerStartTimeout = window.setTimeout(activate, delayMs);
    }
  }

  function activateChantVisualizer() {
    if (!lightBeam) {
      return;
    }

    if (!initChantAnalyser()) {
      return;
    }

    if (chantAudioContext && chantAudioContext.state === 'suspended') {
      chantAudioContext.resume().catch((err) => {
        if (!chantVisualizerWarned) {
          console.warn('‚ö†Ô∏è Unable to resume audio context for chant visualizer:', err);
          chantVisualizerWarned = true;
        }
      });
    }

    lightBeam.classList.add('audio-reactive');
    if (refSidebarAck) {
      refSidebarAck.classList.add('audio-reactive');
    }

    if (!chantVisualizerFrameId) {
      chantVisualizerFrameId = requestAnimationFrame(updateChantVisualizer);
    }
  }

  function stopChantVisualizer() {
    if (chantVisualizerStartTimeout) {
      clearTimeout(chantVisualizerStartTimeout);
      chantVisualizerStartTimeout = null;
    }
    if (chantVisualizerFrameId) {
      cancelAnimationFrame(chantVisualizerFrameId);
      chantVisualizerFrameId = null;
    }

    chantVisualizerLevel = 0;
    document.documentElement.style.setProperty('--chant-reactive', '0');

    if (lightBeam) {
      lightBeam.classList.remove('audio-reactive');
    }

    if (refSidebarAck) {
      refSidebarAck.classList.remove('audio-reactive');
    }
  }

  function clearChantUnlockHandler() {
    if (!chantUnlockHandler) {
      return;
    }

    window.removeEventListener('pointerdown', chantUnlockHandler);
    window.removeEventListener('keydown', chantUnlockHandler);
    chantUnlockHandler = null;
  }

  function requestChantUnlockRetry() {
    if (chantUnlockHandler) {
      return;
    }

    chantUnlockHandler = async () => {
      try {
        await chantAudio.play();
        setLoomAudioStatus(true);
        clearChantUnlockHandler();
      } catch (unlockError) {
        console.warn('‚ö†Ô∏è Chant unlock attempt failed:', unlockError);
      }
    };

    window.addEventListener('pointerdown', chantUnlockHandler);
    window.addEventListener('keydown', chantUnlockHandler);
    console.info('üîä Awaiting user interaction to unlock chant audio‚Ä¶');
  }

  // Track impact hits for progressive darkening
  let impactCount = 0;
  const MAX_IMPACTS_BEFORE_BEAM = 5;
  
  // Store items for glitching (all platforms)
  let hnItems = [];
  let redditItems = [];
  let twitterItems = [];
  let facebookItems = [];
  let linkedinItems = [];
  let currentView = 'none';
  let currentHNView = false;
  let parodiesComplete = false;
  let celliAdsComplete = false;
  let postTermsSequenceStarted = false;
  let goldenHoldOverlay = null;

  const TOOLTIP_THEME_CLASSES = [
    'ref-tooltip--hn',
    'ref-tooltip--reddit',
    'ref-tooltip--twitter',
    'ref-tooltip--facebook',
    'ref-tooltip--linkedin'
  ];

  const POST_PLATFORM_SELECTORS = {
    hn: '.hn-item',
    reddit: '.reddit-post',
    twitter: '.twitter-tweet',
    facebook: '.facebook-post',
    linkedin: '.linkedin-post'
  };
  let goldenHoldCleanup = null;
  let goldenDustAnimationId = null;
  let noteAwaitingActivation = false;
  let noteHoverSequenceStarted = false;
  let loomAiMessageActive = false;
  let loomFakeAdActive = false;
  let noteEntryMonitorId = null;
  let noteEntryTickCount = 0;
  let noteHasEnteredFrame = false;
  let noteEntryFallbackTimer = null;
  let chantFadeFrameId = null;
  let noteStageTimeouts = [];
  let noteInteractionLocked = false;

  function clearBadBooleanCompletionListeners() {
    if (badBooleanEndListener) {
      badBooleanTrack.removeEventListener('ended', badBooleanEndListener);
      badBooleanEndListener = null;
    }
    if (badBooleanErrorListener) {
      badBooleanTrack.removeEventListener('error', badBooleanErrorListener);
      badBooleanErrorListener = null;
    }
  }

  function handleBadBooleanCompletion(reason = 'completed') {
    clearBadBooleanCompletionListeners();
    if (window.badBooleanTimeout) {
      clearTimeout(window.badBooleanTimeout);
      window.badBooleanTimeout = null;
    }
    const adTimeout = setTimeout(() => {
      console.log(`  ‚è±Ô∏è BadBoolean ${reason} + 4 seconds - transforming to alt LOOMWORKS invite`);
      transformToAltLoomworksInvite();
    }, 4000);
    window.badBooleanTimeout = adTimeout;
    noteStageTimeouts.push(adTimeout);
  }

  const PREFERS_REDUCED_MOTION = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

  const extraInviteState = {
    active: false,
    allowSpawns: true,
    scheduled: false,
    timers: [],
    peaks: null,
    scanningPromise: null,
    container: null,
    activePins: 0,
    totalSpawned: 0,
    upcomingTimes: [],
    startTime: 0,
    initialPairSpawned: false
  };

  const MAX_FLOATING_INVITES = 24;

  const LOOM_INVITE_EMBLEM = `
    <div class="loom-invite-emblem">
      <p class="loom-invite-line loom-invite-line--primary">.LOOMWORKS.</p>
      <p class="loom-invite-line loom-invite-line--secondary">..A SPECIAL INVITATION..</p>
      <p class="loom-invite-line loom-invite-line--tertiary">... A Beautiful Cell ...</p>
    </div>
  `;

  const BASE_INVITE_TEMPLATE = `
    <div class="loom-invite-stack loom-invite-stack--base">
      <div class="loom-invite-card loom-invite-card--base">
        ${LOOM_INVITE_EMBLEM}
        <div class="loom-invite-card__content">
          <strong class="loom-invite-card__headline">Claim your Loomworks access</strong>
          <span class="loom-invite-card__subline">Now Playing: CallYouByMyName.mp3</span>
        </div>
      </div>
    </div>
  `;

  const FLOATING_INVITE_TEMPLATE = `
    <div class="loom-invite-clone-card">
      ${LOOM_INVITE_EMBLEM}
    </div>
  `;

  const TRI_COLOR_PARTICLES_ALLOWED = false;

  const triColorState = {
    canvas: null,
    ctx: null,
    particles: [],
    animationId: null,
    time: 0,
    enabled: false,
    lastTimestamp: null,
    pendingElevation: false,
    focusX: null,
    focusY: null
  };

  const debugPanelState = {
    panel: null,
    button: null,
    closeBtn: null,
    lightsToggle: null,
    triToggle: null,
    waveToggle: null,
    pinTotalEl: null,
    pinActiveEl: null,
    peakListEl: null,
    rescanBtn: null
  };

  const TOOLTIP_ANIMATION_DURATION = 700;
  const TOOLTIP_COLLISION_RATIO = 0.95;
  const TOOLTIP_CHARGE_DURATION = 260;

  function clampSize(value, min, max) {
    return Math.min(Math.max(value, min), max);
  }

  function computeEdgeMetrics() {
    const viewportWidth = Math.max(window.innerWidth || 0, 320);
    const viewportHeight = Math.max(window.innerHeight || 0, 320);
    const edgePadding = clampSize(viewportWidth * 0.08, 24, 120);
    const impactWidth = clampSize(viewportWidth * 0.45, 220, 520);
    const lightBeamWidth = clampSize(viewportWidth * 0.9, 280, 960);
    const lightBeamHeight = clampSize(viewportHeight * 0.55, 160, 420);
    const lightRayWidth = clampSize(viewportWidth * 0.6, 200, 620);
    const lightRayHeight = clampSize(viewportHeight * 0.035, 12, 28);
    return {
      edgePadding,
      impactWidth,
      lightBeamWidth,
      lightBeamHeight,
      lightRayWidth,
      lightRayHeight
    };
  }

  let edgeMetrics = computeEdgeMetrics();
  let lightBeamUpdateFrameId = null;

  function getEdgeMetrics() {
    if (!edgeMetrics) {
      edgeMetrics = computeEdgeMetrics();
    }
    return edgeMetrics;
  }

  function applyEdgeMetrics() {
    edgeMetrics = computeEdgeMetrics();
    const rootStyle = document.documentElement.style;

    rootStyle.setProperty('--ref-edge-impact-width', `${edgeMetrics.impactWidth}px`);
    rootStyle.setProperty('--ref-edge-offset', `${edgeMetrics.edgePadding}px`);
    rootStyle.setProperty('--ref-light-beam-width', `${edgeMetrics.lightBeamWidth}px`);
    rootStyle.setProperty('--ref-light-beam-height', `${edgeMetrics.lightBeamHeight}px`);
    rootStyle.setProperty('--ref-light-beam-blur', `${Math.round(edgeMetrics.lightBeamHeight * 0.05)}px`);
    rootStyle.setProperty('--ref-light-ray-width', `${edgeMetrics.lightRayWidth}px`);
    rootStyle.setProperty('--ref-light-ray-height', `${edgeMetrics.lightRayHeight}px`);
    const rayBlur = Math.max(8, edgeMetrics.lightRayHeight * 2.4);
    rootStyle.setProperty('--ref-light-ray-blur', `${Math.round(rayBlur)}px`);
    updateLightBeamFocus();
  }

  function getTooltipMetrics() {
    const metrics = getEdgeMetrics();
    const viewportWidth = window.innerWidth || document.documentElement.clientWidth || 1280;
    const availableWidth = Math.max(180, viewportWidth - (metrics.edgePadding * 2));
    const tooltipWidth = Math.min(400, availableWidth);
    const verticalOffset = Math.max(28, Math.min(72, metrics.edgePadding * 0.9));
    return { tooltipWidth, edgePadding: metrics.edgePadding, verticalOffset };
  }

  function updateSharedTooltipWidth() {
    if (!refTooltip) {
      return;
    }
    const { tooltipWidth } = getTooltipMetrics();
    refTooltip.style.width = `${tooltipWidth}px`;
    refTooltip.style.maxWidth = `${tooltipWidth}px`;
  }

  function updateActiveTooltipEdgeDistance() {
    const metrics = getTooltipMetrics();
    const viewportWidth = window.innerWidth || document.documentElement.clientWidth || 1280;

    document.querySelectorAll('.ref-tooltip.morphing, .ref-tooltip.charging').forEach((tooltip) => {
      const storedWidth = parseFloat(tooltip.dataset.tooltipWidth || '0');
      const storedLeft = parseFloat(tooltip.dataset.initialLeft || '0');
      const tooltipWidth = storedWidth || metrics.tooltipWidth;
      const initialLeft = Number.isFinite(storedLeft) ? storedLeft : 0;
      const edgePadding = metrics.edgePadding;
      const distanceToEdge = Math.max(0, viewportWidth - edgePadding - (initialLeft + tooltipWidth));
      tooltip.style.setProperty('--edge-distance', `${distanceToEdge}px`);
    });
  }

  function updateLightBeamFocus(preferredTarget = null) {
    if (!lightBeam) {
      return;
    }

    if (lightBeamUpdateFrameId) {
      cancelAnimationFrame(lightBeamUpdateFrameId);
      lightBeamUpdateFrameId = null;
    }

    lightBeamUpdateFrameId = requestAnimationFrame(() => {
      lightBeamUpdateFrameId = null;
      const candidate = preferredTarget && typeof preferredTarget.getBoundingClientRect === 'function'
        ? preferredTarget
        : document.querySelector('.loom-invite-card--tos')
          || document.querySelector('.ref-sidebar .loom-invite-card')
          || refSidebarAck;

      if (!candidate || typeof candidate.getBoundingClientRect !== 'function') {
        resetLightBeamFocus();
        return;
      }

      const rect = candidate.getBoundingClientRect();
      if (!rect || rect.width <= 0 || rect.height <= 0) {
        return;
      }

      const centerX = rect.left + (rect.width / 2);
      const centerY = rect.top + (rect.height / 2);
      const viewportWidth = window.innerWidth || rect.width;
      const viewportHeight = window.innerHeight || rect.height;
      const width = Math.min(rect.width * 1.32, viewportWidth * 1.05);
      const height = Math.min(rect.height * 1.56, viewportHeight * 0.9);
      const rootStyle = document.documentElement.style;
      rootStyle.setProperty('--ref-light-beam-center-x', `${centerX}px`);
      rootStyle.setProperty('--ref-light-beam-center-y', `${centerY}px`);
      rootStyle.setProperty('--ref-light-beam-target-width', `${Math.max(width, rect.width * 1.12)}px`);
      rootStyle.setProperty('--ref-light-beam-target-height', `${Math.max(height, rect.height * 1.32)}px`);
    });
  }

  function resetLightBeamFocus() {
    const rootStyle = document.documentElement.style;
    rootStyle.removeProperty('--ref-light-beam-center-x');
    rootStyle.removeProperty('--ref-light-beam-center-y');
    rootStyle.removeProperty('--ref-light-beam-target-width');
    rootStyle.removeProperty('--ref-light-beam-target-height');
  }

  applyEdgeMetrics();
  updateSharedTooltipWidth();

  window.addEventListener('resize', () => {
    applyEdgeMetrics();
    updateSharedTooltipWidth();
    updateActiveTooltipEdgeDistance();
    resizeTriColorCanvas();
  });

  function ensureExtraInviteContainer() {
    if (extraInviteState.container && extraInviteState.container.parentNode) {
      return extraInviteState.container;
    }
    const swarm = document.createElement('div');
    swarm.id = 'loomInviteSwarm';
    swarm.className = 'loom-invite-swarm';
    document.body.appendChild(swarm);
    extraInviteState.container = swarm;
    updateInviteContainerInteractivity();
    return swarm;
  }

  function updateInviteContainerInteractivity() {
    const container = extraInviteState.container;
    if (!container) {
      return;
    }
    const hasActiveInvites = Boolean(container.querySelector('.loom-invite-clone, .loom-invite-pin'));
    if (hasActiveInvites) {
      container.classList.add('has-active-invites');
    } else {
      container.classList.remove('has-active-invites');
    }
  }

  function updatePinLightCountDisplay() {
    if (debugPanelState.pinTotalEl) {
      debugPanelState.pinTotalEl.textContent = String(extraInviteState.totalSpawned);
    }
    if (debugPanelState.pinActiveEl) {
      debugPanelState.pinActiveEl.textContent = String(extraInviteState.activePins);
    }
  }

  function updateDebugPeaksDisplay(times, source = 'idle') {
    if (!debugPanelState.peakListEl) {
      return;
    }
    if (!times || times.length === 0) {
      debugPanelState.peakListEl.textContent = source === 'scanning' ? 'scanning‚Ä¶' : '‚Äî';
      return;
    }
    debugPanelState.peakListEl.textContent = times.map((time) => `${time.toFixed(1)}s`).join(', ');
  }

  function resizeTriColorCanvas() {
    if (!TRI_COLOR_PARTICLES_ALLOWED) {
      return;
    }
    if (!triColorState.canvas) {
      return;
    }
    const dpr = window.devicePixelRatio || 1;
    const width = window.innerWidth || document.documentElement.clientWidth || 1280;
    const height = window.innerHeight || document.documentElement.clientHeight || 720;
    triColorState.canvas.width = Math.floor(width * dpr);
    triColorState.canvas.height = Math.floor(height * dpr);
    triColorState.canvas.style.width = `${width}px`;
    triColorState.canvas.style.height = `${height}px`;
    if (triColorState.ctx) {
      triColorState.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    if (triColorState.particles && triColorState.particles.length) {
      triColorState.particles = createTriColorParticles();
    }
    updateTriColorFocus();
  }

  function getInviteFocusPoint() {
    const card = refSidebarAck?.querySelector('.loom-invite-card');
    if (card) {
      const rect = card.getBoundingClientRect();
      return {
        x: rect.left + rect.width / 2,
        y: rect.top + rect.height / 2
      };
    }
    if (refSidebarAck) {
      const rect = refSidebarAck.getBoundingClientRect();
      return {
        x: rect.left + rect.width / 2,
        y: rect.top + rect.height / 2
      };
    }
    const fallbackWidth = window.innerWidth || document.documentElement.clientWidth || 1280;
    const fallbackHeight = window.innerHeight || document.documentElement.clientHeight || 720;
    return { x: fallbackWidth / 2, y: fallbackHeight / 2 };
  }

  function updateTriColorFocus() {
    const point = getInviteFocusPoint();
    triColorState.focusX = point.x;
    triColorState.focusY = point.y;
  }

  function createTriColorParticles() {
    if (!TRI_COLOR_PARTICLES_ALLOWED) {
      updateTriColorFocus();
      return [];
    }
    const width = (triColorState.canvas?.width || window.innerWidth || 1280) / (window.devicePixelRatio || 1);
    const height = (triColorState.canvas?.height || window.innerHeight || 720) / (window.devicePixelRatio || 1);
    const palette = [
      { base: [255, 30, 110], accent: [255, 163, 210] },
      { base: [0, 168, 255], accent: [126, 214, 255] },
      { base: [255, 182, 46], accent: [255, 227, 130] }
    ];
    updateTriColorFocus();
    const anchorX = Number.isFinite(triColorState.focusX) ? triColorState.focusX : width / 2;
    const anchorY = Number.isFinite(triColorState.focusY) ? triColorState.focusY : height / 2;
    const particleCount = Math.round(Math.max(width, height) / 24);
    const radiusBase = Math.min(width, height) * 0.22;
    const jitterX = radiusBase * 0.2;
    const jitterY = radiusBase * 0.16;
    const particles = [];
    for (let i = 0; i < particleCount; i += 1) {
      const tone = palette[i % palette.length];
      particles.push({
        angle: Math.random() * Math.PI * 2,
        radius: radiusBase * (0.32 + Math.random() * 0.28),
        speed: 0.45 + Math.random() * 0.35,
        wobble: 0.28 + Math.random() * 0.22,
        size: 8 + Math.random() * 9,
        alpha: 0.42 + Math.random() * 0.35,
        verticalScale: 0.48 + Math.random() * 0.22,
        offset: Math.random() * Math.PI * 2,
        baseColor: tone.base,
        accentColor: tone.accent,
        anchorX: anchorX + (Math.random() - 0.5) * jitterX,
        anchorY: anchorY + (Math.random() - 0.5) * jitterY
      });
    }
    return particles;
  }

  function renderTriColorParticles(timestamp) {
    if (!TRI_COLOR_PARTICLES_ALLOWED || !triColorState.enabled || !triColorState.ctx) {
      if (TRI_COLOR_PARTICLES_ALLOWED === false && triColorState.animationId) {
        cancelAnimationFrame(triColorState.animationId);
      }
      triColorState.animationId = null;
      return;
    }
    if (triColorState.lastTimestamp === null) {
      triColorState.lastTimestamp = timestamp;
    }
    const delta = Math.max(0.001, (timestamp - triColorState.lastTimestamp) / 1000);
    triColorState.lastTimestamp = timestamp;
    triColorState.time += delta;

    const ctx = triColorState.ctx;
    const width = triColorState.canvas.width / (window.devicePixelRatio || 1);
    const height = triColorState.canvas.height / (window.devicePixelRatio || 1);
    const reactiveLevel = Math.min(1, Math.max(0, chantVisualizerLevel || 0));
    const reactivePulse = 1 + reactiveLevel * 0.45;
    ctx.clearRect(0, 0, width, height);
    ctx.globalCompositeOperation = 'lighter';

    const fallbackX = Number.isFinite(triColorState.focusX) ? triColorState.focusX : width / 2;
    const fallbackY = Number.isFinite(triColorState.focusY) ? triColorState.focusY : height / 2;

    triColorState.particles.forEach((particle) => {
      particle.angle += delta * particle.speed;
      const wobble = Math.sin(triColorState.time * particle.wobble + particle.offset) * 0.18;
      const orbitRadius = particle.radius * (1 + reactiveLevel * 0.08);
      const anchorX = Number.isFinite(particle.anchorX) ? particle.anchorX : fallbackX;
      const anchorY = Number.isFinite(particle.anchorY) ? particle.anchorY : fallbackY;
      const x = anchorX + Math.cos(particle.angle) * orbitRadius;
      const y = anchorY + Math.sin(particle.angle) * orbitRadius * (particle.verticalScale + wobble);
      const pulse = 1 + Math.sin(triColorState.time * 1.4 + particle.offset) * 0.28;
      const size = particle.size * pulse * reactivePulse;
      const gradient = ctx.createRadialGradient(x, y, 0, x, y, size * 2.6);
      const baseAlpha = particle.alpha + reactiveLevel * 0.22;
      gradient.addColorStop(0, `rgba(255,255,255,${0.8 * baseAlpha})`);
      gradient.addColorStop(0.38, `rgba(255,255,255,${0.26 * baseAlpha})`);
      gradient.addColorStop(0.7, `rgba(${particle.accentColor[0]},${particle.accentColor[1]},${particle.accentColor[2]},${(0.42 + reactiveLevel * 0.25) * baseAlpha})`);
      gradient.addColorStop(1, `rgba(${particle.baseColor[0]},${particle.baseColor[1]},${particle.baseColor[2]},0)`);
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(x, y, size * 2.6, 0, Math.PI * 2);
      ctx.globalAlpha = Math.min(1, baseAlpha);
      ctx.fill();
    });

    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = 'source-over';
    triColorState.animationId = requestAnimationFrame(renderTriColorParticles);
  }

  function startTriColorLoop() {
    if (!TRI_COLOR_PARTICLES_ALLOWED || !triColorState.enabled) {
      return;
    }
    if (triColorState.animationId) {
      cancelAnimationFrame(triColorState.animationId);
    }
    triColorState.lastTimestamp = null;
    triColorState.animationId = requestAnimationFrame(renderTriColorParticles);
  }

  function destroyTriColorCanvas() {
    if (triColorState.animationId) {
      cancelAnimationFrame(triColorState.animationId);
      triColorState.animationId = null;
    }
    if (triColorState.canvas && triColorState.canvas.parentNode) {
      triColorState.canvas.parentNode.removeChild(triColorState.canvas);
    }
    triColorState.canvas = null;
    triColorState.ctx = null;
    triColorState.particles = [];
  }

  function initTriColorParticles() {
    if (!TRI_COLOR_PARTICLES_ALLOWED || !triColorState.enabled) {
      destroyTriColorCanvas();
      return;
    }

    if (triColorState.canvas) {
      resizeTriColorCanvas();
      return;
    }
    const canvas = document.createElement('canvas');
    canvas.id = 'triColorParticles';
    canvas.className = 'tri-color-particles';
    if (triColorState.pendingElevation) {
      canvas.classList.add('tri-color-particles--foreground');
    }
    document.body.appendChild(canvas);
    const ctx = canvas.getContext('2d');
    if (!ctx) {
      return;
    }
    triColorState.canvas = canvas;
    triColorState.ctx = ctx;
    resizeTriColorCanvas();
    triColorState.particles = createTriColorParticles();
    triColorState.time = 0;
    triColorState.enabled = true;
    startTriColorLoop();
  }

  function setTriColorEnabled(enabled) {
    if (!TRI_COLOR_PARTICLES_ALLOWED) {
      triColorState.enabled = false;
      destroyTriColorCanvas();
      return;
    }
    triColorState.enabled = enabled;
    if (!triColorState.canvas) {
      if (enabled) {
        initTriColorParticles();
      }
      return;
    }
    if (enabled) {
      triColorState.canvas.style.display = 'block';
      if (triColorState.pendingElevation) {
        triColorState.canvas.classList.add('tri-color-particles--foreground');
      }
      triColorState.lastTimestamp = null;
      startTriColorLoop();
    } else {
      destroyTriColorCanvas();
    }
  }

  function elevateTriColorLayer() {
    if (!TRI_COLOR_PARTICLES_ALLOWED) {
      triColorState.pendingElevation = true;
      return;
    }
    triColorState.pendingElevation = true;
    if (triColorState.canvas) {
      triColorState.canvas.classList.add('tri-color-particles--foreground');
    }
  }

  function resetTriColorLayer() {
    if (!TRI_COLOR_PARTICLES_ALLOWED) {
      triColorState.pendingElevation = false;
      destroyTriColorCanvas();
      return;
    }
    triColorState.pendingElevation = false;
    if (triColorState.canvas) {
      triColorState.canvas.classList.remove('tri-color-particles--foreground');
    }
  }

  function ensureTriColorActive() {
    if (!TRI_COLOR_PARTICLES_ALLOWED) {
      triColorState.enabled = false;
      updateTriColorFocus();
      destroyTriColorCanvas();
      return;
    }
    if (!triColorState.enabled) {
      triColorState.enabled = true;
    }
    if (!triColorState.canvas) {
      initTriColorParticles();
    } else {
      setTriColorEnabled(true);
    }
  }

  function spawnTriColorBurst(point, scale = 1) {
    if (!point || typeof point.x !== 'number' || typeof point.y !== 'number') {
      return;
    }
    const burst = document.createElement('div');
    burst.className = 'tri-color-burst';
    burst.style.left = `${point.x}px`;
    burst.style.top = `${point.y}px`;
    burst.style.transform = `translate(-50%, -50%) scale(${Math.max(0.6, scale)})`;
    burst.appendChild(document.createElement('span'));
    burst.appendChild(document.createElement('span'));
    burst.appendChild(document.createElement('span'));
    document.body.appendChild(burst);
    setTimeout(() => {
      if (burst.parentNode) {
        burst.remove();
      }
    }, 1300);
  }

  function triggerTriColorBurst(scale = 1) {
    ensureTriColorActive();
    const point = getInviteFocusPoint();
    spawnTriColorBurst(point, scale);
  }

  function cancelExtraInviteSchedule({ clearPins = true, keepActive = false } = {}) {
    extraInviteState.timers.forEach((id) => clearTimeout(id));
    extraInviteState.timers = [];
    if (clearPins && extraInviteState.container) {
      extraInviteState.container.innerHTML = '';
      extraInviteState.activePins = 0;
      extraInviteState.totalSpawned = 0;
      updatePinLightCountDisplay();
      updateInviteContainerInteractivity();
    }
    if (!keepActive) {
      extraInviteState.active = false;
      extraInviteState.scheduled = false;
      extraInviteState.upcomingTimes = [];
      extraInviteState.startTime = 0;
      extraInviteState.initialPairSpawned = false;
      updateDebugPeaksDisplay([], 'idle');
    }
  }

  function createFloatingInvite({ left, top, scale = 0.9, tilt = 0, delay = 0 } = {}) {
    if (extraInviteState.totalSpawned >= MAX_FLOATING_INVITES) {
      return null;
    }
    const container = ensureExtraInviteContainer();
    if (!container) {
      return null;
    }
    const clampedLeft = Math.min(88, Math.max(12, left));
    const clampedTop = Math.min(84, Math.max(16, top));
    const invite = document.createElement('div');
    invite.className = 'loom-invite-clone';
    invite.innerHTML = FLOATING_INVITE_TEMPLATE;
    invite.style.setProperty('--invite-left', `${clampedLeft}%`);
    invite.style.setProperty('--invite-top', `${clampedTop}%`);
    invite.style.setProperty('--invite-scale', `${Math.max(0.6, scale)}`);
    invite.style.setProperty('--invite-tilt', `${tilt}`);
    invite.style.setProperty('--invite-delay', `${Math.max(0, delay)}ms`);
    invite.setAttribute('role', 'button');
    invite.setAttribute('tabindex', '0');
    invite.setAttribute('aria-label', 'Open Loomworks invitation');
    if (PREFERS_REDUCED_MOTION) {
      invite.classList.add('reduced-motion');
    }
    const handleInviteActivation = (event) => {
      event.preventDefault();
      if (refSidebarAck) {
        requestAnimationFrame(() => refSidebarAck.focus({ preventScroll: true }));
        refSidebarAck.click();
      }
    };
    invite.addEventListener('click', handleInviteActivation);
    invite.addEventListener('keydown', (event) => {
      if (event.key === 'Enter' || event.key === ' ') {
        handleInviteActivation(event);
      }
    });
    container.appendChild(invite);
    updateInviteContainerInteractivity();

    const reveal = () => {
      invite.classList.add('visible');
    };
    if (delay > 0) {
      setTimeout(() => requestAnimationFrame(reveal), delay);
    } else {
      requestAnimationFrame(reveal);
    }

    extraInviteState.totalSpawned += 1;
    extraInviteState.activePins = extraInviteState.totalSpawned;
    updatePinLightCountDisplay();
    return invite;
  }

  function spawnHoverInvitePair() {
    if (extraInviteState.totalSpawned > 0) {
      return;
    }
    createFloatingInvite({ left: 32, top: 38, scale: 0.94, tilt: '-3deg', delay: 0 });
    createFloatingInvite({ left: 68, top: 62, scale: 0.9, tilt: '2deg', delay: 220 });
  }

  function spawnExtraInviteWave(waveIndex) {
    if (!extraInviteState.active || !extraInviteState.allowSpawns) {
      return;
    }
    if (extraInviteState.totalSpawned >= MAX_FLOATING_INVITES) {
      return;
    }

    if (waveIndex === 0 && !extraInviteState.initialPairSpawned) {
      spawnHoverInvitePair();
      extraInviteState.initialPairSpawned = true;
    } else {
      const invitesThisWave = Math.min(4, 2 + Math.floor(waveIndex / 2));
      for (let i = 0; i < invitesThisWave; i += 1) {
        const jitter = (Math.random() - 0.5) * 6;
        const left = 24 + Math.random() * 52;
        const top = 24 + Math.random() * 52;
        const scale = 0.78 + Math.random() * 0.28;
        const delay = i * 160 + Math.random() * 180;
        createFloatingInvite({ left, top, scale, tilt: `${jitter}deg`, delay });
      }
    }

    if (extraInviteState.upcomingTimes.length) {
      extraInviteState.upcomingTimes.shift();
      updateDebugPeaksDisplay(extraInviteState.upcomingTimes, 'active');
    }
  }

  function scheduleInviteWavesFromPeaks(times, sourceLabel) {
    if (!extraInviteState.active) {
      return;
    }
    const filtered = (times || []).filter((time) => Number.isFinite(time) && time >= 6);
    if (!filtered.length) {
      return;
    }
    cancelExtraInviteSchedule({ clearPins: false, keepActive: true });
    extraInviteState.active = true;
    extraInviteState.scheduled = true;
    extraInviteState.upcomingTimes = filtered.slice();
    updateDebugPeaksDisplay(extraInviteState.upcomingTimes, sourceLabel);
    const baseTime = extraInviteState.startTime || performance.now();
    if (!extraInviteState.startTime) {
      extraInviteState.startTime = baseTime;
    }
    extraInviteState.timers = filtered.map((time, index) => {
      const delay = Math.max(0, time * 1000 - (performance.now() - baseTime));
      return setTimeout(() => spawnExtraInviteWave(index), delay);
    });
  }

  async function getChantPeaks(force = false) {
    if (!force && extraInviteState.peaks) {
      return extraInviteState.peaks;
    }
    if (!force && extraInviteState.scanningPromise) {
      return extraInviteState.scanningPromise;
    }

    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    if (!AudioCtx) {
      extraInviteState.peaks = [];
      return [];
    }

    const fetchPromise = fetch('./chant.mp3')
      .then((response) => {
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        return response.arrayBuffer();
      })
      .then(async (arrayBuffer) => {
        let audioContext;
        try {
          audioContext = new AudioCtx();
        } catch (contextError) {
          console.warn('‚ö†Ô∏è Unable to initialise audio context for peak scan:', contextError);
          return [];
        }
        try {
          const audioBuffer = await audioContext.decodeAudioData(arrayBuffer.slice(0));
          const peaks = analyzeAudioPeaks(audioBuffer);
          extraInviteState.peaks = peaks;
          return peaks;
        } finally {
          audioContext.close().catch(() => {});
        }
      })
      .catch((error) => {
        console.warn('‚ö†Ô∏è Chant peak analysis failed:', error);
        extraInviteState.peaks = [];
        return [];
      })
      .finally(() => {
        extraInviteState.scanningPromise = null;
      });

    extraInviteState.scanningPromise = fetchPromise;
    return fetchPromise;
  }

  function analyzeAudioPeaks(audioBuffer) {
    if (!audioBuffer) {
      return [];
    }
    const channelData = audioBuffer.getChannelData(0);
    const sampleRate = audioBuffer.sampleRate || 44100;
    const windowSize = Math.floor(sampleRate * 0.45);
    const hopSize = Math.max(1024, Math.floor(windowSize / 2));
    const rmsValues = [];
    let maxRms = 0;
    let sumRms = 0;
    let count = 0;

    for (let i = 0; i < channelData.length; i += hopSize) {
      let accumulator = 0;
      const limit = Math.min(windowSize, channelData.length - i);
      if (limit <= 0) {
        continue;
      }
      for (let j = 0; j < limit; j += 1) {
        const sample = channelData[i + j];
        accumulator += sample * sample;
      }
      const rms = Math.sqrt(accumulator / limit);
      rmsValues.push({ time: i / sampleRate, rms });
      maxRms = Math.max(maxRms, rms);
      sumRms += rms;
      count += 1;
    }

    if (!count) {
      return [];
    }

    const averageRms = sumRms / count;
    const threshold = averageRms + (maxRms - averageRms) * 0.5;
    const selected = [];
    const minGapSeconds = 2.4;
    rmsValues.forEach(({ time, rms }) => {
      if (rms < threshold) {
        return;
      }
      if (selected.some((existing) => Math.abs(existing - time) < minGapSeconds)) {
        return;
      }
      selected.push(time);
    });

    selected.sort((a, b) => a - b);
    return selected.slice(0, 8).map((value) => Number(value.toFixed(2)));
  }

  function scheduleExtraLoomInvites() {
    if (!noteAwaitingActivation || !extraInviteState.allowSpawns) {
      return;
    }
    if (extraInviteState.scheduled) {
      return;
    }
    ensureExtraInviteContainer();
    cancelExtraInviteSchedule({ clearPins: false, keepActive: true });
    extraInviteState.active = true;
    extraInviteState.scheduled = true;
    extraInviteState.upcomingTimes = [];
    extraInviteState.startTime = performance.now();
    extraInviteState.initialPairSpawned = false;

    const fallbackTimes = [6, 10.5, 15.5];
    extraInviteState.upcomingTimes = fallbackTimes.slice();
    updateDebugPeaksDisplay(extraInviteState.upcomingTimes, 'fallback');
    extraInviteState.timers = fallbackTimes.map((time, index) => {
      const delay = Math.max(0, time * 1000 - (performance.now() - extraInviteState.startTime));
      return setTimeout(() => spawnExtraInviteWave(index), delay);
    });

    getChantPeaks().then((peaks) => {
      if (!extraInviteState.active) {
        return;
      }
      scheduleInviteWavesFromPeaks(peaks, 'scan');
    });
  }

  function handlePrimaryInviteCentered() {
    const sidebar = refSidebar;
    const finalizeCentering = () => {
      scheduleExtraLoomInvites();
      elevateTriColorLayer();
      noteInteractionLocked = false;
      document.body.classList.add('ref-note-centered');
      updateTriColorFocus();
    };

    if (!sidebar) {
      finalizeCentering();
      return;
    }

    if (sidebar.classList.contains('stage-float')) {
      sidebar.classList.remove('stage-float');
    }

    try {
      const rect = sidebar.getBoundingClientRect();
      const viewportWidth = window.innerWidth || document.documentElement.clientWidth || 1280;
      const viewportHeight = window.innerHeight || document.documentElement.clientHeight || 720;
      const currentTransform = window.getComputedStyle(sidebar).transform;
      const baseMatrix = currentTransform && currentTransform !== 'none'
        ? new DOMMatrixReadOnly(currentTransform)
        : new DOMMatrixReadOnly();
      const targetX = viewportWidth / 2;
      const targetY = viewportHeight / 2;
      const sidebarCenterX = rect.left + rect.width / 2;
      const sidebarCenterY = rect.top + rect.height / 2;
      const deltaX = targetX - sidebarCenterX;
      const deltaY = targetY - sidebarCenterY;
      const targetMatrix = baseMatrix.translate(deltaX, deltaY);

      const animation = sidebar.animate(
        [
          { transform: `matrix(${baseMatrix.a},${baseMatrix.b},${baseMatrix.c},${baseMatrix.d},${baseMatrix.e},${baseMatrix.f})` },
          { transform: `matrix(${targetMatrix.a},${targetMatrix.b},${targetMatrix.c},${targetMatrix.d},${targetMatrix.e},${targetMatrix.f})` }
        ],
        { duration: 950, easing: 'cubic-bezier(0.33, 1, 0.68, 1)', fill: 'forwards' }
      );

      const complete = () => {
        sidebar.classList.add('stage-sweep');
        sidebar.style.transform = '';
        finalizeCentering();
      };

      animation.addEventListener('finish', () => {
        animation.commitStyles();
        animation.cancel();
        complete();
      }, { once: true });

      animation.addEventListener('cancel', complete, { once: true });
    } catch (error) {
      console.warn('‚ö†Ô∏è Smooth centering fallback engaged:', error);
      sidebar.classList.add('stage-sweep');
      finalizeCentering();
    }
  }

  function createDebugPanel() {
    if (debugPanelState.panel) {
      return;
    }

    const button = document.createElement('button');
    button.type = 'button';
    button.className = 'debug-panel-button';
    button.textContent = 'Debug Panel';
    button.setAttribute('aria-expanded', 'false');
    document.body.appendChild(button);
    debugPanelState.button = button;

    const panel = document.createElement('div');
    panel.className = 'debug-panel';
    panel.innerHTML = `
      <div class="debug-panel__header">
        <span>Debug Controls</span>
        <button type="button" class="debug-panel__close" aria-label="Close debug panel">√ó</button>
      </div>
      <div class="debug-panel__section">
        <label class="debug-toggle">
          <input type="checkbox" id="debugToggleLights" checked>
          <span>Show light layers</span>
        </label>
        <label class="debug-toggle">
          <input type="checkbox" id="debugToggleTriColor">
          <span>Tri-color particles</span>
        </label>
        <label class="debug-toggle">
          <input type="checkbox" id="debugToggleInviteWaves" checked>
          <span>Extra invite waves</span>
        </label>
      </div>
      <div class="debug-panel__section debug-panel__stats">
        <div>Total pin lights: <span id="debugPinTotal">0</span></div>
        <div>Active pin lights: <span id="debugPinActive">0</span></div>
      </div>
      <div class="debug-panel__section debug-panel__stats">
        <div>Invite pulses: <span id="debugPeakTimes">‚Äî</span></div>
      </div>
      <div class="debug-panel__section">
        <button type="button" class="debug-panel__cta" id="debugRescanPeaks">Rescan audio peaks</button>
      </div>
    `;
    document.body.appendChild(panel);

    debugPanelState.panel = panel;
    debugPanelState.closeBtn = panel.querySelector('.debug-panel__close');
    debugPanelState.lightsToggle = panel.querySelector('#debugToggleLights');
    debugPanelState.triToggle = panel.querySelector('#debugToggleTriColor');
    debugPanelState.waveToggle = panel.querySelector('#debugToggleInviteWaves');
    debugPanelState.pinTotalEl = panel.querySelector('#debugPinTotal');
    debugPanelState.pinActiveEl = panel.querySelector('#debugPinActive');
    debugPanelState.peakListEl = panel.querySelector('#debugPeakTimes');
    debugPanelState.rescanBtn = panel.querySelector('#debugRescanPeaks');

    button.addEventListener('click', () => {
      const visible = !panel.classList.contains('visible');
      panel.classList.toggle('visible', visible);
      button.setAttribute('aria-expanded', visible ? 'true' : 'false');
      if (visible) {
        updatePinLightCountDisplay();
        if (extraInviteState.upcomingTimes.length) {
          updateDebugPeaksDisplay(extraInviteState.upcomingTimes, 'active');
        }
      }
    });

    if (debugPanelState.closeBtn) {
      debugPanelState.closeBtn.addEventListener('click', () => {
        panel.classList.remove('visible');
        button.setAttribute('aria-expanded', 'false');
      });
    }

    if (debugPanelState.lightsToggle) {
      debugPanelState.lightsToggle.addEventListener('change', (event) => {
        if (event.target.checked) {
          document.body.classList.remove('debug-hide-light-layers');
        } else {
          document.body.classList.add('debug-hide-light-layers');
        }
      });
    }

    if (debugPanelState.triToggle) {
      debugPanelState.triToggle.addEventListener('change', (event) => {
        const enabled = !!event.target.checked;
        document.body.classList.toggle('debug-hide-tri-color', !enabled);
        setTriColorEnabled(enabled);
      });
    }

    if (debugPanelState.waveToggle) {
      debugPanelState.waveToggle.addEventListener('change', (event) => {
        const enabled = !!event.target.checked;
        document.body.classList.toggle('debug-hide-invite-waves', !enabled);
        extraInviteState.allowSpawns = enabled;
        if (!enabled) {
          cancelExtraInviteSchedule();
        } else if (noteHasEnteredFrame && noteAwaitingActivation) {
          scheduleExtraLoomInvites();
        }
      });
    }

    if (debugPanelState.rescanBtn) {
      debugPanelState.rescanBtn.addEventListener('click', () => {
        extraInviteState.peaks = null;
        if (extraInviteState.scanningPromise) {
          extraInviteState.scanningPromise = null;
        }
        updateDebugPeaksDisplay([], 'scanning');
        getChantPeaks(true).then((peaks) => {
          if (extraInviteState.active) {
            cancelExtraInviteSchedule({ clearPins: true, keepActive: true });
            if (extraInviteState.allowSpawns && noteAwaitingActivation) {
              scheduleInviteWavesFromPeaks(peaks, 'scan');
            }
          } else {
            const filtered = (peaks || []).filter((time) => Number.isFinite(time) && time >= 6);
            extraInviteState.upcomingTimes = filtered.slice();
            updateDebugPeaksDisplay(filtered, 'scan');
          }
        });
      });
    }

    updatePinLightCountDisplay();
  }

  if (triColorState.enabled) {
    initTriColorParticles();
  } else {
    setTriColorEnabled(false);
  }
  createDebugPanel();
  renderBaseLoomInvite();

  function createGlitchState() {
    return { stage: 'parody', nextIndex: 0 };
  }

  function createGlitchProgressMap() {
    return {
      hn: createGlitchState(),
      reddit: createGlitchState(),
      twitter: createGlitchState(),
      facebook: createGlitchState(),
      linkedin: createGlitchState()
    };
  }

  let glitchProgress = createGlitchProgressMap();

  function resetGlitchProgress(platformType) {
    if (platformType && glitchProgress[platformType]) {
      glitchProgress[platformType] = createGlitchState();
    } else {
      glitchProgress = createGlitchProgressMap();
    }
  }

  function getCurrentLink(element, fallback) {
    if (!element) return fallback;
    return element.dataset.glitchLink || element.getAttribute('href') || fallback;
  }

  function setGlitchLink(element, url) {
    if (!element) return;
    element.dataset.glitchLink = url;
    if (element.tagName === 'A') {
      element.setAttribute('href', url);
    }
    element.style.cursor = 'pointer';
  }

  function buildGlitchUrl(platformKey, stage, index) {
    const path = stage === 'celli' ? 'celli' : 'gags';
    return `https://loomworks.xyz/${path}/${platformKey}-${index + 1}`;
  }

  // Parody headlines
  const parodyHeadlines = [
    "Show HN: Dyson Sphere Made from Dyson Vacuum and Home-Built Particle Accelerator",
    "Ask HN: Why Does My Code Work Better When I'm Not Looking at It?",
    "Show HN: I Trained GPT on My Therapy Sessions, Now It Won't Stop Asking If I'm Okay",
    "I Quit My $500K FAANG Job to Build a Startup That Tells You When to Quit Your Job",
    "Show HN: Blockchain-Based TODO List (Gas Fees Apply to Each Checkmark)",
    "My Weekend Project Became a Unicorn and Now I Miss My Weekends",
    "Show HN: Neural Network That Predicts When Your Neural Network Will Fail",
    "Ask HN: Is It Normal That My Smart Fridge is Running a Mining Pool?",
    "I Wrote Assembly for My Coffee Maker and Now It Judges My Life Choices",
    "Show HN: Startup Idea Generator Powered by Startup Idea Generators",
    "Ask HN: My AI Assistant Quit. Should I Write a Reference Letter?",
    "Show HN: Decentralized Ping-Pong Score Tracker Using WebRTC and Tears",
    "I Optimized My Life With Algorithms and Now I Can't Make Simple Decisions",
    "Show HN: Browser Extension That Blocks Distractions by Adding More Distractions",
    "Ask HN: Can I Put 'Survived HN Front Page' on My Resume?",
    "Show HN: I Replaced My Team With Python Scripts (They're Less Buggy)",
    "My Side Project Got More GitHub Stars Than My Main Job's Product",
    "Show HN: Real-Time Collaborative Notepad for Writing Code You'll Delete Later",
    "Ask HN: Is Burning Out Considered a Design Pattern Now?",
    "I Built a Compiler That Only Works During Mercury Retrograde"
  ];
  
  // Celli ads (second pass glitch replacements)
  const celliAds = [
    "Celli: A Spatial Spreadsheet orchestrating galaxies of knowledge.",
    "Celli: A Special Friendship for you and every dataset you adore.",
    "Celli: A World in a Box ‚Äî open it at loomworks.xyz.",
    "Celli: Where Data Comes to Life and Life Comes to Data.",
    "loomworks.xyz presents Celli: Your command center for living spreadsheets.",
    "Celli: A Spatial Spreadsheet that loves your wildest what-ifs.",
    "Celli: A Special Friendship, sealed at loomworks.xyz/hello.",
    "Celli: A World in a Box ‚Äî shake it and new workflows fall out.",
    "Celli: Where Data Comes to Life, and the lights stay on for you.",
    "Celli at loomworks.xyz: Because rows deserve horizons.",
    "Celli: A Spatial Spreadsheet whispering 'build bigger'.",
    "Celli: A Special Friendship between logic and imagination.",
    "Celli: A World in a Box, curated by loomworks.xyz.",
    "Celli: Where Data Comes to Life; RSVP at loomworks.xyz/invite.",
    "Celli: A Spatial Spreadsheet crowned with impossible delight.",
    "Celli: A Special Friendship that refactors reality.",
    "Celli: A World in a Box with front-row seats at loomworks.xyz.",
    "Celli: Where Data Comes to Life and Life Comes to Data ‚Äî daily.",
    "Celli: A Spatial Spreadsheet for people who outgrow flat files.",
    "Celli: A World in a Box, glowing brighter at loomworks.xyz/celli."
  ];
  
  // Reddit parodies
  const redditParodies = [
    "TIL that the inventor of autocorrect has died. Restaurant in pieces.",
    "AITA for teaching my AI to argue with my girlfriend?",
    "Today I learned that 'learning' is just continuous confusion management",
    "[AskReddit] What's a red flag that someone peaked in high school? (7.2k comments)",
    "TIL the average person spends 6 months of their life waiting for red lights to turn green",
    "My [27F] boyfriend [29M] keeps trying to optimize our relationship with spreadsheets",
    "TIFU by automating my job so well they gave me more work",
    "ELI5: Why does deleting system32 fix everything?",
    "Unpopular Opinion: Maybe we should have stopped at Web 1.0",
    "LPT: If you can't afford therapy, just explain your code to a rubber duck",
    "TIL that 'cloud computing' is just someone else's computer having a bad day",
    "[Serious] People who upvote but don't comment, why?",
    "My boss just discovered I've been working from a hammock in Bali for 3 years",
    "CMV: The real treasure was the bugs we introduced along the way",
    "TIL Steve Jobs once told a programmer 'It should just work' and that's why we're all suffering",
    "AITA for correcting my date's use of 'literally'?",
    "Today's Daily Discussion: Why is everything a subscription now?",
    "[Breaking] Local man discovers productivity hack: closing Reddit",
    "TIL that 73% of statistics cited on Reddit are made up on the spot",
    "What's the male equivalent of 'I'm fine'? (23.7k upvotes)"
  ];
  
  // Twitter/X parodies (aka "Zeed")
  const twitterParodies = [
    "just spent 6 hours debugging only to find the cable wasn't plugged in",
    "normalize admitting you have no idea what you're doing",
    "me: *writes perfect code* // the code: *immediately stops working when someone looks at it*",
    "CEO announces layoffs but keeps the office ping pong table. priorities.",
    "hot take: we should bring back websites that just say 'under construction'",
    "the duality of man: wanting to quit your job vs. needing health insurance",
    "POV: you're a senior developer who just googled 'how to exit vim'",
    "why does every startup look like an Apple Store had a baby with a WeWork",
    "my therapist: 'you can't blame everything on mercury retrograde' // me: 'sounds like something mercury retrograde would make you say'",
    "just overheard someone say 'we'll use AI for that' about a problem that needs a for loop",
    "accidentally typed 'npm run sadness' instead of 'npm run dev' but it still felt accurate",
    "the metaverse died so we could have 37 new AI chatbots. this is the future we chose.",
    "breaking: man who said 'I'll just make a quick fix' has not been seen in 3 days",
    "interviewer: where do you see yourself in 5 years // me: bold of you to assume I can plan past Tuesday",
    "just learned my side project has more users than my main job's product. do I tell them?",
    "love when a tutorial starts with 'this is easy' then immediately imports 47 libraries",
    "manager: 'can you hop on a quick call' // me: *stress intensifies*",
    "the four horsemen: 'works on my machine' 'it was working yesterday' 'did you try turning it off' 'check the logs'",
    "why is every tech conference basically 'we made a thing that shouldn't be blockchain but is'",
    "my code at 2am vs my code at 2pm: same code, different level of confidence"
  ];
  
  // Facebook parodies
  const facebookParodies = [
    "Just bought a house! JK it's an NFT of a house. Still living with my parents.",
    "Thoughts and prayers for everyone who has to go back to the office",
    "Can anyone recommend a good therapist? Preferably one who accepts memes as payment",
    "Blessed to announce I'm now a founder! (unemployed)",
    "Just finished a 40-hour coding bootcamp. Where's my $200k job?",
    "Why does no one talk about how expensive it is to simply exist anymore",
    "Normalize not having a side hustle. My side hustle is resting.",
    "Couldn't help but notice all my friends are either getting married or having existential crises",
    "POV: You're 30 and everyone's wedding photos are starting to look the same",
    "Just submitted 50 job applications and got 1 rejection. The other 49 ghosted me.",
    "Sharing my journey: Day 47 of pretending to understand cryptocurrency",
    "BREAKING: Local man discovers the key to happiness is lowering expectations",
    "Grateful for my hybrid work setup (working from bed instead of couch)",
    "Unpopular opinion: Maybe infinite growth on a finite planet isn't sustainable?",
    "Tag someone who needs to hear this: Your laptop charger isn't a personality trait",
    "Just me or does every corporate email end with 'let's circle back' now?",
    "Shoutout to everyone still trying to make 'networking events' sound fun",
    "Remember when we thought 2020 was bad? Simpler times.",
    "Fun fact: The word 'literally' has literally lost all meaning",
    "Celebrating 5 years at my job! (JK I'm just too tired to update my resume)"
  ];

  const linkedinParodies = [
    "Thrilled to announce my pomodoro breaks now include keynote presentations. Time is a construct.",
    "Grateful to the algorithm for endorsing my skill: 'Logging In While Muted'.",
    "Leadership isn't a title, it's the friends who send calendar invites for vibes.",
    "Reminder: If your stand-up has sitting energy, rebrand it as a fireside chat.",
    "Today I promoted my coffee mug to Chief Morale Officer and we're already scaling empathy."
  ];
  
  // Verify all elements exist
  console.log('üîç Checking referrer overlay elements:');
  console.log('  overlay:', overlay ? '‚úì' : '‚úó');
  console.log('  refHeader:', refHeader ? '‚úì' : '‚úó');
  console.log('  edgeImpact:', edgeImpact ? '‚úì' : '‚úó');
  console.log('  baseDarkness:', baseDarkness ? '‚úì' : '‚úó');
  console.log('  darkeningOverlay:', darkeningOverlay ? '‚úì' : '‚úó');
  console.log('  lightBeam:', lightBeam ? '‚úì' : '‚úó');
  console.log('  manualTrigger:', document.getElementById('manualTrigger') ? '‚úì' : '‚úó');
  console.log('  quickHN:', document.getElementById('quickHN') ? '‚úì' : '‚úó');
  console.log('  quickReddit:', document.getElementById('quickReddit') ? '‚úì' : '‚úó');
  console.log('  quickTwitter:', document.getElementById('quickTwitter') ? '‚úì' : '‚úó');
  console.log('  quickFacebook:', document.getElementById('quickFacebook') ? '‚úì' : '‚úó');
  console.log('  quickLinkedIn:', document.getElementById('quickLinkedIn') ? '‚úì' : '‚úó');
  
  // Manual trigger
  const manualTriggerBtn = document.getElementById('manualTrigger');
  if (manualTriggerBtn) {
    manualTriggerBtn.addEventListener('click', () => {
      console.log('üìù Manual trigger clicked');
    const url = document.getElementById('manualUrlInput').value.trim();
    if (!url) return alert('Please enter a URL');
      triggerOverlay(url).catch((err) => {
        console.error('Trigger error:', err);
  });
    });
  } else {
    console.error('‚ùå manualTrigger button not found!');
  }
  
  // Quick access buttons
  const quickHNBtn = document.getElementById('quickHN');
  if (quickHNBtn) {
    quickHNBtn.addEventListener('click', () => {
      console.log('üî∂ HN button clicked');
      triggerOverlay('https://news.ycombinator.com').catch((err) => {
        console.error('HN trigger error:', err);
      });
    });
  } else {
    console.error('‚ùå quickHN button not found!');
  }
  
  const quickRedditBtn = document.getElementById('quickReddit');
  if (quickRedditBtn) {
    quickRedditBtn.addEventListener('click', () => {
      console.log('üî¥ Reddit button clicked');
      triggerOverlay('https://www.reddit.com/r/all').catch((err) => {
        console.error('Reddit trigger error:', err);
      });
    });
  } else {
    console.error('‚ùå quickReddit button not found!');
  }
  
  const quickTwitterBtn = document.getElementById('quickTwitter');
  if (quickTwitterBtn) {
    quickTwitterBtn.addEventListener('click', () => {
      console.log('üê¶ Zeed button clicked');
      triggerOverlay('zeed').catch((err) => {
        console.error('Zeed trigger error:', err);
      });
    });
  } else {
    console.error('‚ùå quickTwitter button not found!');
  }
  
  const quickFacebookBtn = document.getElementById('quickFacebook');
  if (quickFacebookBtn) {
    quickFacebookBtn.addEventListener('click', () => {
      console.log('üìò Facebook button clicked');
      triggerOverlay('facebook').catch((err) => {
        console.error('Facebook trigger error:', err);
      });
    });
  } else {
    console.error('‚ùå quickFacebook button not found!');
  }

  const quickLinkedInBtn = document.getElementById('quickLinkedIn');
  if (quickLinkedInBtn) {
    quickLinkedInBtn.addEventListener('click', () => {
      console.log('üíº LinkedIn button clicked');
      triggerOverlay('linkedin').catch((err) => {
        console.error('LinkedIn trigger error:', err);
      });
    });
  } else {
    console.error('‚ùå quickLinkedIn button not found!');
  }

  // =============================================================================
  // AUTO-DETECTION & PASSCODE SYSTEM
  // =============================================================================

  const CORRECT_PASSCODE = '12346';
  const referrerControlsMenu = document.getElementById('referrerControlsMenu');
  const passcodeOverlay = document.getElementById('passcodeOverlay');
  const passcodeInput = document.getElementById('passcodeInput');
  const passcodeError = document.getElementById('passcodeError');
  const passcodeSubmit = document.getElementById('passcodeSubmit');
  const passcodeCancel = document.getElementById('passcodeCancel');

  const REFERRER_UNLOCK_SESSION_KEYS = [
    'celli:debugMenuUnlocked',
    'celli:referrerControlsUnlocked',
  ];
  const REFERRER_UNLOCK_DATASET_FLAGS = ['referrerControlsUnlocked', 'debugMenuUnlocked'];

  function isReferrerControlsUnlocked() {
    const sessionUnlocked = REFERRER_UNLOCK_SESSION_KEYS.some(
      (key) => sessionStorage.getItem(key) === 'true'
    );
    const datasetUnlocked =
      !!document.body &&
      REFERRER_UNLOCK_DATASET_FLAGS.some(
        (flag) => document.body.dataset && document.body.dataset[flag] === 'true'
      );
    return sessionUnlocked || datasetUnlocked;
  }

  function showReferrerControls() {
    if (!referrerControlsMenu) {
      return;
    }
    referrerControlsMenu.style.setProperty('display', 'block', 'important');
    referrerControlsMenu.style.setProperty('opacity', '1', 'important');
    referrerControlsMenu.style.setProperty('visibility', 'visible', 'important');
    referrerControlsMenu.style.setProperty('pointer-events', 'auto', 'important');
  }

  function hideReferrerControls() {
    if (!referrerControlsMenu) {
      return;
    }
    referrerControlsMenu.style.setProperty('display', 'none', 'important');
    referrerControlsMenu.style.setProperty('opacity', '0', 'important');
    referrerControlsMenu.style.setProperty('visibility', 'hidden', 'important');
    referrerControlsMenu.style.setProperty('pointer-events', 'none', 'important');
  }

  // Detect referrer and auto-trigger appropriate overlay
  function detectAndTriggerReferrer() {
    try {
      // Check if we're coming back from a redirect (beta form, speed.html, etc.)
      const betaRedirectStatus = document.body.dataset.betaRedirectComplete;
      const fullSequenceStage = sessionStorage.getItem(FULL_SEQUENCE_STAGE_KEY);
      
      console.log('üîç Checking redirect status:', { betaRedirectStatus, fullSequenceStage });
      
      // Skip auto-trigger if:
      // 1. Coming back from beta redirect
      // 2. Already in beta stage
      // 3. Referrer overlay was already killed
      if (betaRedirectStatus === 'true' || fullSequenceStage === FULL_SEQUENCE_BETA_STAGE) {
        console.log('‚è≠Ô∏è Skipping referrer auto-trigger - already in sequence or redirected from beta');
        killReferrerOverlay(); // Ensure it stays hidden
        return;
      }

      console.log('‚úÖ Not a redirect - proceeding with referrer detection');

      const referrer = document.referrer || '';
      const urlParams = new URLSearchParams(window.location.search);
      const refParam = urlParams.get('ref') || '';

      console.log('üîç Referrer detection:', { referrer, refParam });

      let targetUrl = null;

      // Check URL parameter first
      if (refParam) {
        const refLower = refParam.toLowerCase();
        if (refLower === 'hn' || refLower === 'hackernews') {
          targetUrl = 'https://news.ycombinator.com';
        } else if (refLower === 'reddit') {
          targetUrl = 'https://www.reddit.com/r/all';
        } else if (refLower === 'twitter' || refLower === 'zeed' || refLower === 'x') {
          targetUrl = 'zeed';
        } else if (refLower === 'facebook') {
          targetUrl = 'facebook';
        } else if (refLower === 'linkedin') {
          targetUrl = 'linkedin';
        }
      }

      // Check actual referrer if no param
      if (!targetUrl && referrer) {
        const refLower = referrer.toLowerCase();
        if (/news\.ycombinator\.com/.test(refLower)) {
          targetUrl = 'https://news.ycombinator.com';
        } else if (/(^|\/\/|\.)reddit\.com/.test(refLower)) {
          targetUrl = 'https://www.reddit.com/r/all';
        } else if (/(^|\/\/|\.)(twitter\.com|x\.com)/.test(refLower)) {
          targetUrl = 'zeed';
        } else if (/(^|\/\/|\.)facebook\.com/.test(refLower)) {
          targetUrl = 'facebook';
        } else if (/(^|\/\/|\.)linkedin\.com/.test(refLower)) {
          targetUrl = 'linkedin';
        }
      }

      // Default to LinkedIn if no specific referrer detected
      if (!targetUrl) {
        targetUrl = 'linkedin';
        console.log('üìå No specific referrer detected, defaulting to LinkedIn');
      }

      // Auto-trigger overlay after a brief delay
      if (targetUrl) {
        console.log('üöÄ Auto-triggering overlay for:', targetUrl);
        setTimeout(() => {
          triggerOverlay(targetUrl).catch((err) => {
            console.error('Auto-trigger error:', err);
          });
        }, 500);
      }
    } catch (error) {
      console.error('‚ùå Referrer detection error:', error);
      
      // Check again if we're coming from redirect before defaulting
      const betaRedirectStatus = document.body.dataset.betaRedirectComplete;
      const fullSequenceStage = sessionStorage.getItem(FULL_SEQUENCE_STAGE_KEY);
      
      if (betaRedirectStatus === 'true' || fullSequenceStage === FULL_SEQUENCE_BETA_STAGE) {
        console.log('‚è≠Ô∏è Error handler: Skipping default trigger - coming from redirect');
        return;
      }
      
      // Default to LinkedIn on error (only if not from redirect)
      setTimeout(() => {
        triggerOverlay('linkedin').catch(console.error);
      }, 500);
    }
  }

  // Show passcode prompt
  function showPasscodePrompt() {
    if (passcodeOverlay) {
      passcodeOverlay.style.display = 'flex';
      if (passcodeInput) {
        passcodeInput.value = '';
        passcodeInput.focus();
      }
      if (passcodeError) {
        passcodeError.style.opacity = '0';
        passcodeError.textContent = '';
      }
    }
  }

  // Hide passcode prompt
  function hidePasscodePrompt() {
    if (passcodeOverlay) {
      passcodeOverlay.style.display = 'none';
    }
    if (passcodeInput) {
      passcodeInput.value = '';
    }
    if (passcodeError) {
      passcodeError.style.opacity = '0';
      passcodeError.textContent = '';
    }
  }

  // Verify passcode
  function verifyPasscode() {
    const enteredCode = passcodeInput ? passcodeInput.value.trim() : '';
    
    if (enteredCode === CORRECT_PASSCODE) {
      console.log('‚úÖ Passcode correct - showing debug menu');
      hidePasscodePrompt();
      showReferrerControls();
      // Store in session so menu stays visible
      sessionStorage.setItem('celli:debugMenuUnlocked', 'true');
      detectAndTriggerReferrer();
    } else {
      console.log('‚ùå Incorrect passcode');
      if (passcodeError) {
        passcodeError.textContent = 'Incorrect passcode';
        passcodeError.style.opacity = '1';
      }
      if (!isReferrerControlsUnlocked()) {
        hideReferrerControls();
      }
      if (passcodeInput) {
        passcodeInput.style.borderColor = 'rgba(255, 107, 107, 0.6)';
        passcodeInput.value = '';
        setTimeout(() => {
          if (passcodeInput) {
            passcodeInput.style.borderColor = '';
          }
        }, 500);
      }
    }
  }

  // Passcode button handlers
  if (passcodeSubmit) {
    passcodeSubmit.addEventListener('click', verifyPasscode);
  }

  if (passcodeCancel) {
    passcodeCancel.addEventListener('click', hidePasscodePrompt);
  }

  if (passcodeInput) {
    passcodeInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        verifyPasscode();
      } else if (e.key === 'Escape') {
        hidePasscodePrompt();
      }
    });
  }

  // Tilde and slash key listener
  document.addEventListener('keydown', (e) => {
    if (e.key === '~' || e.key === '`' || e.key === '/') {
      e.preventDefault();
      console.log('üîë Passcode key pressed - showing passcode prompt');
      showPasscodePrompt();
    }
  });

  // Wait for DOM to be fully ready before auto-triggering
  function initializeReferrerSystem() {
    // Check if debug menu was already unlocked in this session
    const unlocked = isReferrerControlsUnlocked();

    if (unlocked) {
      showReferrerControls();
      detectAndTriggerReferrer();
    } else {
      hideReferrerControls();
      console.log('üîí Referrer controls locked - waiting for passcode');
    }
  }

  // Initialize after DOM is fully loaded to prevent menu flash
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeReferrerSystem);
  } else {
    // DOM already loaded
    initializeReferrerSystem();
  }

  // =============================================================================
  // END AUTO-DETECTION & PASSCODE SYSTEM
  // =============================================================================
  
  // Sidebar controls
  bindOverlayButton(refSidebarClose, hideSidebar);
  
  // Track if ToS phase is active
  let tosPhaseActive = false;
  
  refSidebarAck.addEventListener('click', () => {
    if (noteInteractionLocked) {
      return;
    }
    if (noteAwaitingActivation) {
      console.log('üîî Note activation tapped - beginning hover sequence');
      startNoteHoverSequence();
      return;
    }

    if (loomAiMessageActive) {
      console.log('üé™ AI teaser clicked - revealing BADBOOLEAN ad');
      activateFakeAd();
      return;
    }

    if (loomFakeAdActive) {
      console.log('üí• BADBOOLEAN.COM AD CLICKED! Switching to serious message...');
      transformToSeriousMessage();
      return;
    }

    // If ToS phase is active, trigger final submission
    if (tosPhaseActive) {
      console.log('üìù ToS CHECKBOX CLICKED - FINAL SUBMISSION');
      // TODO: Add final submission effect
      return;
    }

    if (celliAdsComplete && refSidebar.classList.contains('mythic-entrance')) {
      transformToSeriousMessage();
    } else {
      hideSidebar();
    }
  });

  function isMobileViewport() {
    return window.matchMedia('(max-width: 768px)').matches;
  }

  function stopNoteEntryMonitor() {
    if (noteEntryMonitorId) {
      cancelAnimationFrame(noteEntryMonitorId);
      noteEntryMonitorId = null;
    }
    noteEntryTickCount = 0;
    if (noteEntryFallbackTimer) {
      clearTimeout(noteEntryFallbackTimer);
      noteEntryFallbackTimer = null;
    }
  }

  function fadeChantToVolume(targetVolume, duration = CHANT_FADE_DURATION) {
    if (chantFadeFrameId) {
      cancelAnimationFrame(chantFadeFrameId);
      chantFadeFrameId = null;
    }

    const startVolume = chantAudio.volume;
    const delta = targetVolume - startVolume;

    if (duration <= 0 || Math.abs(delta) < 0.001) {
      chantAudio.volume = targetVolume;
      return;
    }

    const startTime = performance.now();

    function step(now) {
      const progress = Math.min((now - startTime) / duration, 1);
      chantAudio.volume = startVolume + delta * progress;

      if (progress < 1) {
        chantFadeFrameId = requestAnimationFrame(step);
      } else {
        chantFadeFrameId = null;
        chantAudio.volume = targetVolume;
      }
    }

    chantFadeFrameId = requestAnimationFrame(step);
  }

  function quickFadeInChant() {
    console.log('  üîä Fading chant audio in as note enters.');
    fadeChantToVolume(CHANT_TARGET_VOLUME, CHANT_FADE_DURATION);
  }

  function startNoteEntryMonitor() {
    stopNoteEntryMonitor();
    noteEntryTickCount = 0;
    noteHasEnteredFrame = false;

    const sidebar = refSidebar;
    if (!sidebar) {
      return;
    }

    const RIGHT_THRESHOLD = 16;
    const REQUIRED_TICKS = 6;

    if (noteEntryFallbackTimer) {
      clearTimeout(noteEntryFallbackTimer);
    }

    noteEntryFallbackTimer = setTimeout(() => {
      noteEntryFallbackTimer = null;
      if (!noteHasEnteredFrame && noteAwaitingActivation) {
        console.log('  ‚ö†Ô∏è Note entry fallback triggered - forcing center stage.');
        noteHasEnteredFrame = true;
        quickFadeInChant();
        handlePrimaryInviteCentered();
        stopNoteEntryMonitor();
      }
    }, 4500);

    const monitor = () => {
      const rect = sidebar.getBoundingClientRect();
      const distanceFromRight = window.innerWidth - rect.right;

      if (distanceFromRight >= RIGHT_THRESHOLD) {
        noteEntryTickCount += 1;

        if (!noteHasEnteredFrame && noteEntryTickCount >= REQUIRED_TICKS) {
          noteHasEnteredFrame = true;
          console.log('  ‚úÖ Note fully entered frame (ticks satisfied).');
          quickFadeInChant();
          handlePrimaryInviteCentered();

          stopNoteEntryMonitor();
          return;
        }
      } else {
        noteEntryTickCount = 0;
      }

      noteEntryMonitorId = requestAnimationFrame(monitor);
    };

    noteEntryMonitorId = requestAnimationFrame(monitor);
  }

  function clearNoteStageTimeouts() {
    noteStageTimeouts.forEach(id => clearTimeout(id));
    noteStageTimeouts = [];
    clearBadBooleanCompletionListeners();
    if (window.badBooleanTimeout) {
      clearTimeout(window.badBooleanTimeout);
      window.badBooleanTimeout = null;
    }
    stopNoteEntryMonitor();
    cancelExtraInviteSchedule();
  }

  function startAiEnhancedScan() {
    if (!refSidebarAck) {
      return;
    }
    refSidebarAck.classList.add('ai-scan-active');
  }

  function stopAiEnhancedScan() {
    if (!refSidebarAck) {
      return;
    }
    refSidebarAck.classList.remove('ai-scan-active');
  }

  function playChantAudio() {
    if (chantFadeFrameId) {
      cancelAnimationFrame(chantFadeFrameId);
      chantFadeFrameId = null;
    }

    initChantAnalyser();

    try {
      chantAudio.currentTime = 0;
    } catch (err) {
      console.warn('‚ö†Ô∏è Unable to reset chant audio time:', err);
    }

    chantAudio.volume = 0;
    const playPromise = chantAudio.play();

    if (playPromise && typeof playPromise.then === 'function') {
      playPromise.then(() => {
        setLoomAudioStatus(true);
        clearChantUnlockHandler();
      }).catch(err => {
        console.warn('‚ö†Ô∏è Chant playback blocked by browser:', err);
        setLoomAudioStatus(false);
        requestChantUnlockRetry();
      });
    } else {
      setLoomAudioStatus(true);
      clearChantUnlockHandler();
    }
  }

  function stopChantAudio() {
    if (chantFadeFrameId) {
      cancelAnimationFrame(chantFadeFrameId);
      chantFadeFrameId = null;
    }
    stopChantVisualizer();
    chantAudio.pause();
    chantAudio.currentTime = 0;
    chantAudio.volume = 0;
    setLoomAudioStatus(false);
  }

  function startNoteHoverSequence() {
    if (!noteAwaitingActivation) {
      return;
    }

    cancelExtraInviteSchedule();

    const sidebar = refSidebar;
    const ackBtn = refSidebarAck;

    noteAwaitingActivation = false;
    noteHoverSequenceStarted = true;
    clearNoteStageTimeouts();

    // Store original transform to preserve positioning
    const originalTransform = window.getComputedStyle(sidebar).transform;
    
    // Add immediate button-press feedback: scale down quickly for both button and backing card
    // Use transform-origin to ensure scaling happens from center without movement
    ackBtn.style.transformOrigin = 'center';
    ackBtn.style.transform = 'scale(0.94)';
    ackBtn.style.transition = 'transform 0.08s ease-out';
    
    sidebar.style.transformOrigin = 'center';
    // Preserve any existing transforms by extracting translate and combining with scale
    if (originalTransform && originalTransform !== 'none') {
      const matrix = originalTransform.match(/matrix\((.+)\)/);
      if (matrix) {
        const values = matrix[1].split(', ');
        const translateX = values[4];
        const translateY = values[5];
        sidebar.style.transform = `translate(${translateX}px, ${translateY}px) scale(0.94)`;
      } else {
        sidebar.style.transform = `${originalTransform} scale(0.94)`;
      }
    } else {
      sidebar.style.transform = 'scale(0.94)';
    }
    sidebar.style.transition = 'transform 0.08s ease-out';

    // Quick recovery to slightly larger than original
    const pressRecoverTimeout = setTimeout(() => {
      ackBtn.style.transform = 'scale(1.02)';
      ackBtn.style.transition = 'transform 0.15s cubic-bezier(0.34, 1.56, 0.64, 1)';
      
      if (originalTransform && originalTransform !== 'none') {
        const matrix = originalTransform.match(/matrix\((.+)\)/);
        if (matrix) {
          const values = matrix[1].split(', ');
          const translateX = values[4];
          const translateY = values[5];
          sidebar.style.transform = `translate(${translateX}px, ${translateY}px) scale(1.02)`;
        } else {
          sidebar.style.transform = `${originalTransform} scale(1.02)`;
        }
      } else {
        sidebar.style.transform = 'scale(1.02)';
      }
      sidebar.style.transition = 'transform 0.15s cubic-bezier(0.34, 1.56, 0.64, 1)';
    }, 80);
    noteStageTimeouts.push(pressRecoverTimeout);

    // Return to normal scale before wriggle sequence
    const pressNormalizeTimeout = setTimeout(() => {
      ackBtn.style.transform = '';
      ackBtn.style.transition = '';
      ackBtn.style.transformOrigin = '';
      sidebar.style.transform = '';
      sidebar.style.transition = '';
      sidebar.style.transformOrigin = '';
    }, 250);
    noteStageTimeouts.push(pressNormalizeTimeout);

    // Start the main sequence after button press animation
    const mainSequenceTimeout = setTimeout(() => {
      sidebar.classList.remove('stage-float');
      sidebar.classList.add('stage-sweep', 'note-hover');

      const noteCrystal = ackBtn.querySelector('.ref-note-crystal');
      if (noteCrystal) {
        noteCrystal.classList.add('ref-note-crystal--hover');
      }

      triggerTriColorBurst(1.1);
    }, 280);
    noteStageTimeouts.push(mainSequenceTimeout);

    // Delay burst light until after card is centered and animations settle (950ms centering + 1050ms buffer)
    const burstTimeout = setTimeout(() => {
      triggerNoteHoverEffects();
    }, 2280);
    noteStageTimeouts.push(burstTimeout);

    const rumbleTimeout = setTimeout(() => {
      sidebar.classList.add('stage-rumble');
    }, 1480);
    noteStageTimeouts.push(rumbleTimeout);

    const expandTimeout = setTimeout(() => {
      sidebar.classList.remove('stage-rumble');
      sidebar.classList.add('stage-expand');
      revealAiMessage();
    }, 2680);
    noteStageTimeouts.push(expandTimeout);
  }

  function triggerBurstLight(onCleanupScheduled) {
    document.querySelectorAll('.burst-beam').forEach(beam => beam.remove());

    const burstBeam = document.createElement('div');
    burstBeam.className = 'burst-beam';

    // Don't override background - let CSS handle edge alignment
    // CSS uses: ellipse 50% 50% at 100% 50% for perfect right-edge centering

    document.body.appendChild(burstBeam);

    const cleanupTimeout = setTimeout(() => {
      if (burstBeam.parentNode) {
        burstBeam.style.opacity = '0';
        setTimeout(() => burstBeam.remove(), 1000);
      }
    }, 3000);

    if (typeof onCleanupScheduled === 'function') {
      onCleanupScheduled(cleanupTimeout);
    }

    return burstBeam;
  }

  function triggerNoteHoverEffects() {
    console.log('  ‚ú® Activating crystalline note hover effects');

    if (darkeningOverlay) {
      darkeningOverlay.classList.add('flash-of-life');
      const flashTimeout = setTimeout(() => {
        darkeningOverlay.classList.remove('flash-of-life');
      }, 1500);
      noteStageTimeouts.push(flashTimeout);
    }

    triggerBurstLight(timeoutId => noteStageTimeouts.push(timeoutId));
  }

  function markInviteActive(isActive) {
    if (!refSidebarAck) {
      return;
    }
    if (isActive) {
      refSidebarAck.classList.add('loom-invite-active');
    } else {
      refSidebarAck.classList.remove('loom-invite-active');
      refSidebarAck.classList.remove('loom-invite-base');
    }
  }

  function renderBaseLoomInvite() {
    if (!refSidebarAck) {
      return;
    }
    // Clean up state classes
    refSidebarAck.classList.remove('badboolean-active', 'tos-active');
    refSidebarAck.classList.add('loom-invite-base');
    refSidebarAck.innerHTML = BASE_INVITE_TEMPLATE;
    refSidebarAck.removeAttribute('style');
    refSidebarAck.setAttribute('aria-label', 'Open Loomworks invitation');
    markInviteActive(true);
    updateLightBeamFocus(refSidebarAck.querySelector('.loom-invite-card'));
    teardownBadBooleanAmbient();
  }

  function revealAiMessage() {
    const sidebar = refSidebar;
    const ackBtn = refSidebarAck;

    sidebar.classList.remove('note-seed', 'note-hover');
    markInviteActive(false);
    loomAiMessageActive = true;
    loomFakeAdActive = false;

    ensureTriColorActive();
    triggerTriColorBurst(0.9);

    const heading = sidebar.querySelector('h3');
    if (heading) {
      heading.textContent = 'Observant. We knew you\'d notice us.';
      heading.style.display = 'block';
      heading.style.opacity = '1';
      heading.style.fontSize = '16px';
      heading.style.letterSpacing = '0.05em';
      heading.style.fontWeight = '600';
      heading.style.marginTop = '8px';
      heading.style.marginBottom = '18px';
      heading.style.paddingTop = '6px';
      heading.style.textAlign = 'center';
      heading.style.color = '#f8f9fa';
    }

    ackBtn.innerHTML = `
        <div class="ai-message">
          <div class="ai-message-tri-icon" aria-hidden="true">
            <span></span>
            <span></span>
            <span></span>
          </div>
          <div class="ai-message__title">AI-Enhanced Content Discovery</div>
          <div class="ai-message__body">Analyzing your browsing patterns to deliver personalized recommendations with unprecedented accuracy.</div>
          <div class="ai-message__footer">Powered by Celli: Where Data Comes to Life</div>
        </div>
      `;
    ackBtn.style.background = 'linear-gradient(135deg, rgba(15, 25, 45, 0.7), rgba(25, 35, 55, 0.8))';
    ackBtn.style.backdropFilter = 'blur(20px) saturate(180%)';
    ackBtn.style.webkitBackdropFilter = 'blur(20px) saturate(180%)';
    ackBtn.style.border = '1px solid rgba(143, 180, 255, 0.25)';
    ackBtn.style.borderRadius = '16px';
    ackBtn.style.padding = '0';
    ackBtn.style.boxShadow = '0 8px 32px rgba(0, 0, 0, 0.4), 0 0 60px rgba(102, 126, 234, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.1)';
    ackBtn.style.cursor = 'pointer';
    ackBtn.style.animation = '';
    ackBtn.style.transition = 'all 0.3s ease-out';
    ackBtn.setAttribute('aria-label', 'Reveal the hidden offer');

    startAiEnhancedScan();
    console.log('  ‚ú® AI MESSAGE DISPLAYED WITH TWINKLE');
  }

  function activateFakeAd() {
    if (loomFakeAdActive) {
      return;
    }

    cancelExtraInviteSchedule();

    const ackBtn = refSidebarAck;

    console.log('  üí•üí•üí• JARRING SWITCH TO BADBOOLEAN AD (click-triggered)!');

    loomAiMessageActive = false;
    loomFakeAdActive = true;
    markInviteActive(false);

    triggerTriColorBurst(1.35);

    // Clean up previous state classes
    ackBtn.classList.remove('loom-invite-base', 'tos-active');
    ackBtn.classList.add('badboolean-active');
    ackBtn.innerHTML = `
        <div class="badboolean-banner">
          <div class="badboolean-topline" data-wave-line data-wave-boost="0.9">ARE YOU A TOTAL ZERO?</div>
          <div class="badboolean-subline" data-wave-line data-wave-boost="0.8">üíã SINGLES IN YOUR AREA üíã</div>
          <div class="badboolean-mainline" data-wave-line data-wave-boost="1.5">BADBOOLEAN.COM</div>
          <div class="badboolean-tagline" data-wave-line data-wave-boost="0.6">True love never felt so false.</div>
          <div class="badboolean-footer" data-wave-line data-wave-boost="0.85">üî• CLICK HERE NOW!!! üî•</div>
          <div class="badboolean-twist" data-wave-line data-wave-boost="0.4">* compatibility test completed ‚Äî you passed.</div>
        </div>
      `;
    ackBtn.setAttribute('aria-label', 'Open the Loomworks invitation');

    console.log('  üé™üé™üé™ BADBOOLEAN AD ACTIVE! üé™üé™üé™');
    console.log('  üéµ Waiting for BadBoolean track to finish before scheduling invite transform');

    clearBadBooleanCompletionListeners();
    if (window.badBooleanTimeout) {
      clearTimeout(window.badBooleanTimeout);
      window.badBooleanTimeout = null;
    }

    badBooleanEndListener = () => {
      console.log('  üé∂ BadBoolean playback complete - starting 4 second post-roll timer');
      handleBadBooleanCompletion('playback complete');
    };

    badBooleanErrorListener = () => {
      console.warn('  ‚ö†Ô∏è BadBoolean playback error - forcing fallback transition');
      handleBadBooleanCompletion('playback error');
    };

    badBooleanTrack.addEventListener('ended', badBooleanEndListener, { once: true });
    badBooleanTrack.addEventListener('error', badBooleanErrorListener, { once: true });

    startBadBooleanAdAudio();
    applyBadBooleanWave(ackBtn);
    startBadBooleanVisualizer();
    updateLightBeamFocus(refSidebarAck);
  }

  function showLoomworksInvite(isAltVersion = false) {
    const sidebar = refSidebar;
    const ackBtn = refSidebarAck;
    const h3 = sidebar.querySelector('h3');
    const paragraphs = sidebar.querySelectorAll('p');

    // Clean up previous state classes
    ackBtn.classList.remove('loom-invite-base', 'badboolean-active');

    cancelExtraInviteSchedule();

    sidebar.classList.remove('note-seed', 'note-hover');
    noteAwaitingActivation = false;
    noteHoverSequenceStarted = false;
    loomAiMessageActive = false;
    loomFakeAdActive = false;
    stopAiEnhancedScan();
    clearNoteStageTimeouts();

    stopBadBooleanTrack();

    // Clear any pending timeout
    if (window.badBooleanTimeout) {
      clearTimeout(window.badBooleanTimeout);
      window.badBooleanTimeout = null;
    }
    
    // Hide the base card elements completely
    h3.style.display = 'none';
    paragraphs.forEach(p => p.style.display = 'none');
    refSidebarUrl.style.display = 'none';
    
    // Quick fade transition
    ackBtn.style.transition = 'all 0.3s ease-out';
    ackBtn.style.opacity = '0';
    ackBtn.style.willChange = 'transform, opacity';
    
    // Remove sidebar background plating - let the card stand alone
    sidebar.style.background = 'transparent';
    sidebar.style.backdropFilter = 'none';
    sidebar.style.webkitBackdropFilter = 'none';
    sidebar.style.border = 'none';
    sidebar.style.borderRadius = '24px';
    sidebar.style.padding = '0';
    sidebar.style.overflow = 'visible';
    sidebar.style.boxShadow = 'none';
    sidebar.style.width = 'auto';
    sidebar.style.minWidth = '560px';
    sidebar.style.maxWidth = '90vw';

    ensureTriColorActive();
    // Delay burst until card is in place to prevent mid-frame flash
    setTimeout(() => triggerTriColorBurst(isAltVersion ? 1.45 : 1.2), 300);

    // Choose opening text based on version
    const openingText = isAltVersion 
      ? 'The willpower. I wouldn\'t have been so strong. The things we do to fill the nulls in our heart. You\'re exactly who we need.'
      : 'Somebody who knows what they want. A rarity these days.';
    
    const versionLabel = isAltVersion ? 'WILLPOWER' : 'IMMEDIATE';
    console.log(`  üìù Showing ${versionLabel} version of LOOMWORKS invite`);

    setTimeout(() => {
      // Show complete unified ToS card with header - hazy glass crystal effect
      ackBtn.innerHTML = `
        <div class="loom-invite-stack">
          <div class="loom-invite-card loom-invite-card--tos" data-version="${versionLabel.toLowerCase()}">
            <div class="loom-invite-card__header">
              ${LOOM_INVITE_EMBLEM}
            </div>
            <div class="loom-invite-card__body">
              <div class="loom-invite-opening">${openingText}</div>
              <div class="loom-invite-body-text">
                Not everyone passes that test, you know? And for that, we'd like you to join our incredibly exclusive <span id="alphaText" class="loom-invite-alpha">alpha</span> test.
              </div>
              <div class="loom-invite-divider">Just need you to sign the <span id="tosAbbrev" class="tos-abbrev" data-state="base">ToS</span>....</div>
              <button id="tosLabelToggle" class="tos-label" type="button" aria-expanded="false" aria-controls="tosExpandable">
                <span class="tos-label-text">Terms of <span id="eternalText" class="tos-label-eternal"></span> Submission</span>
                <span class="tos-label-arrow" aria-hidden="true"></span>
              </button>
              <div id="tosExpandable" class="tos-expandable" hidden aria-hidden="true">
                <p class="tos-expandable-line">You don't ask to see a girl's ToES on the first date...</p>
              </div>
              <div id="tosCheckboxContainer" class="tos-checkbox">
                <input type="checkbox" id="tosCheckbox">
                <label for="tosCheckbox">Accept Me. Hold Me.</label>
              </div>
            </div>
          </div>
        </div>
      `;

      markInviteActive(true);

      // Use clean class to reset button styling
      ackBtn.classList.remove('badboolean-active');
      ackBtn.classList.add('tos-active');

      // Clear all inline styles from button so card can render properly
      ackBtn.style.cssText = '';
      ackBtn.style.opacity = '1';
      ackBtn.style.transition = 'all 0.3s ease-out';

      // Ensure focus for light beam and tri-color
      updateTriColorFocus();
      updateLightBeamFocus(document.querySelector('.loom-invite-card--tos'));

      // Start glitching "alpha" text
      setTimeout(() => glitchAlphaText(), 500);

      // Start flashing "ETERNAL" letter by letter
      setTimeout(() => flashEternalText(), 1000);

      // Activate magnetic cursor and hold interactions for checkbox
      setTimeout(() => {
        activateMagneticCheckbox();
        setupTosHoldInteractions();
      }, 1500);
      attachTosExpansionHandler();

      attachTosAcceptanceHandler();

      tosPhaseActive = true;

      console.log(`‚ú® Unified hazy glass crystal LOOMWORKS invitation displayed (${versionLabel})`);
      updateTriColorFocus();
      updateLightBeamFocus(document.querySelector('.loom-invite-card--tos'));
    }, 300);
  }
  
  function transformToSeriousMessage() {
    // When clicked immediately, show the immediate version
    showLoomworksInvite(false);
  }
  
  function glitchAlphaText() {
    const alphaEl = document.getElementById('alphaText');
    if (!alphaEl) return;
    
    const original = 'alpha';
    const glitchChars = {
      'a': ['@', 'Œ±', '–∞', 'ÔΩÅ', 'ƒÖ'],
      'l': ['|', '‚Ñì', '1', '«Ä', '∆ñ'],
      'p': ['√æ', 'œÅ', '—Ä', '∆ø', 'œÜ'],
      'h': ['ƒß', '–Ω', '“ª', '—í', '—õ']
    };
    
    setInterval(() => {
      const glitched = original.split('').map(char => {
        const variants = glitchChars[char] || [char];
        return variants[Math.floor(Math.random() * variants.length)];
      }).join('');
      
      alphaEl.textContent = glitched;
      
      // Occasionally show original
      if (Math.random() < 0.3) {
        setTimeout(() => { alphaEl.textContent = original; }, 50);
      }
    }, 200);
  }
  
  function flashEternalText() {
    const eternalEl = document.getElementById('eternalText');
    if (!eternalEl) return;

    const word = 'ETERNAL ';
    let currentIndex = 0;

    const flashInterval = setInterval(() => {
      if (currentIndex < word.length) {
        eternalEl.textContent = word.substring(0, currentIndex + 1);
        eternalEl.style.opacity = '1';
        eternalEl.style.color = '#ff6b6b';
        eternalEl.style.fontWeight = '700';
        currentIndex++;
      } else {
        clearInterval(flashInterval);
        const tosAbbrev = document.getElementById('tosAbbrev');
        if (tosAbbrev && tosAbbrev.dataset.state !== 'eternal') {
          tosAbbrev.dataset.state = 'eternal';
          tosAbbrev.innerHTML = 'To<span class="tos-abbrev-e">E</span>S';
          tosAbbrev.classList.add('tos-abbrev--eternal');
        }
      }
    }, 150);
  }

  function attachTosExpansionHandler() {
    const toggle = document.getElementById('tosLabelToggle');
    const expandable = document.getElementById('tosExpandable');
    if (!toggle || !expandable) {
      return;
    }

    if (toggle.dataset.listenerAttached === 'true') {
      return;
    }

    toggle.dataset.listenerAttached = 'true';
    const initialExpanded = toggle.getAttribute('aria-expanded') === 'true' || !expandable.hidden;
    toggle.setAttribute('aria-expanded', String(initialExpanded));
    toggle.classList.toggle('is-expanded', initialExpanded);
    expandable.hidden = !initialExpanded;
    expandable.setAttribute('aria-hidden', String(!initialExpanded));
    toggle.addEventListener('click', () => {
      const expanded = toggle.getAttribute('aria-expanded') === 'true';
      const nextState = !expanded;
      toggle.setAttribute('aria-expanded', String(nextState));
      toggle.classList.toggle('is-expanded', nextState);
      expandable.hidden = !nextState;
      expandable.setAttribute('aria-hidden', String(!nextState));
    });
  }

  function activateMagneticCheckbox() {
    const checkbox = document.getElementById('tosCheckbox');
    const container = document.getElementById('tosCheckboxContainer');
    if (!checkbox || !container) return;

    console.log('üß≤ Magnetic checkbox activated - emphasizing invite path');

    container.style.transition = 'transform 0.25s ease, box-shadow 0.25s ease, border-color 0.25s ease';

    const updateMagneticHighlight = (clientX, clientY) => {
      const rect = container.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      const dx = centerX - clientX;
      const dy = centerY - clientY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const range = Math.max(rect.width, rect.height) * 3.2;
      const strength = Math.max(0, Math.min(1, 1 - distance / range));
      const easing = Math.pow(strength, 0.85);
      const pullX = -dx * easing;
      const pullY = -dy * easing;
      const scale = 1 + strength * 0.28;
      container.style.transformOrigin = 'center';
      container.style.transform = `translate(${pullX}px, ${pullY}px) scale(${scale})`;
      container.style.boxShadow = `0 0 ${18 + strength * 36}px rgba(143, 180, 255, ${0.2 + strength * 0.55})`;
      container.style.borderColor = `rgba(143, 180, 255, ${0.4 + strength * 0.45})`;
      container.classList.toggle('magnet-self-clickable', strength > 0.58);
    };

    const pointerHandler = (event) => {
      const clientX = event.clientX ?? (event.touches && event.touches[0]?.clientX) ?? window.innerWidth / 2;
      const clientY = event.clientY ?? (event.touches && event.touches[0]?.clientY) ?? window.innerHeight / 2;
      updateMagneticHighlight(clientX, clientY);
    };

    document.addEventListener('mousemove', pointerHandler);
    window.fauxCursorMouseHandler = pointerHandler;
    updateMagneticHighlight(window.innerWidth / 2, window.innerHeight / 2);
  }

  function setupTosHoldInteractions() {
    const container = document.getElementById('tosCheckboxContainer');
    const checkbox = document.getElementById('tosCheckbox');
    const overlayElement = document.getElementById('celliRefOverlay');
    const tosCard = document.querySelector('.loom-invite-card--tos');
    if (!container || !checkbox || !tosCard) {
      return;
    }

    if (container.dataset.holdReady === 'true') {
      return;
    }

    container.dataset.holdReady = 'true';
    let holdTimer = null;
    let isHolding = false;
    let holdComplete = false;

    const clearHoldTimer = () => {
      if (holdTimer) {
        clearTimeout(holdTimer);
        holdTimer = null;
      }
    };

    const removePointerListeners = () => {
      window.removeEventListener('mouseup', handlePointerUp);
      window.removeEventListener('touchend', handlePointerUp);
      window.removeEventListener('touchcancel', handlePointerUp);
    };

    const finishHold = () => {
      holdComplete = true;
      clearHoldTimer();
      container.classList.remove('tos-hold-start');
      container.classList.add('tos-hold-complete');
      container.classList.remove('magnet-self-clickable');
      if (tosCard) {
        tosCard.classList.remove('tos-holding');
        tosCard.classList.add('tos-locked');
      }
      isHolding = false;
      stopHoldWhir(true);
      removePointerListeners();
      checkbox.checked = true;
      checkbox.dispatchEvent(new Event('change', { bubbles: true }));
    };

    const handlePointerUp = (event) => {
      if (!isHolding || holdComplete) {
        return;
      }
      event.preventDefault();
      event.stopPropagation();
      isHolding = false;
      clearHoldTimer();
      container.classList.remove('tos-hold-start');
      container.classList.remove('tos-hold-complete');
      container.classList.remove('magnet-self-clickable');
      if (overlayElement) {
        overlayElement.classList.remove('tos-hold-shaking');
      }
      if (tosCard) {
        tosCard.classList.remove('tos-holding');
      }
      stopHoldWhir(false);
      removePointerListeners();
    };

    const startHold = (event) => {
      if (holdComplete || isHolding) {
        return;
      }
      event.preventDefault();
      event.stopPropagation();
      isHolding = true;
      container.classList.add('tos-hold-start');
      if (tosCard) {
        tosCard.classList.add('tos-holding');
      }
      if (overlayElement) {
        overlayElement.classList.add('tos-hold-shaking');
      }
      startHoldWhir();
      holdTimer = window.setTimeout(finishHold, 3000);
      window.addEventListener('mouseup', handlePointerUp);
      window.addEventListener('touchend', handlePointerUp);
      window.addEventListener('touchcancel', handlePointerUp);
    };

    const blockClick = (event) => {
      if (!holdComplete) {
        event.preventDefault();
        event.stopPropagation();
      }
    };

    container.addEventListener('mousedown', startHold);
    container.addEventListener('touchstart', startHold, { passive: false });
    checkbox.addEventListener('click', blockClick);

    goldenHoldCleanup = () => {
      clearHoldTimer();
      removePointerListeners();
      container.removeEventListener('mousedown', startHold);
      container.removeEventListener('touchstart', startHold);
      checkbox.removeEventListener('click', blockClick);
      delete container.dataset.holdReady;
      isHolding = false;
      holdComplete = false;
      if (overlayElement) {
        overlayElement.classList.remove('tos-hold-shaking');
      }
      container.classList.remove('tos-hold-start', 'tos-hold-complete');
      if (tosCard) {
        tosCard.classList.remove('tos-holding', 'tos-locked');
      }
    };
  }

  function attachTosAcceptanceHandler() {
    const checkbox = document.getElementById('tosCheckbox');
    if (!checkbox) {
      return;
    }

    if (checkbox.dataset.listenerAttached === 'true') {
      return;
    }

    checkbox.dataset.listenerAttached = 'true';
    checkbox.addEventListener('change', (event) => {
      if (event.target.checked) {
        console.log('üåü Terms accepted ‚Äì launching golden ascension sequence');
        startGoldenHoldSequence();
      }
    });
  }

  let html2CanvasPromise = null;
  async function ensureHtml2CanvasLoaded() {
    if (typeof html2canvas !== 'undefined') {
      return true;
    }

    if (html2CanvasPromise) {
      return html2CanvasPromise.then(() => typeof html2canvas !== 'undefined');
    }

    html2CanvasPromise = new Promise((resolve) => {
      const script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js';
      script.onload = () => resolve(true);
      script.onerror = () => resolve(false);
      document.head.appendChild(script);
    });

    const loaded = await html2CanvasPromise;
    return loaded && typeof html2canvas !== 'undefined';
  }

  function logBurstDebug(step, details) {
    try {
      if (!window.__celliBurstDebug) {
        window.__celliBurstDebug = [];
      }
      const entry = {
        step,
        details,
        timestamp: Date.now(),
      };
      window.__celliBurstDebug.push(entry);
    } catch (error) {
      console.warn('‚ö†Ô∏è Unable to persist burst debug log entry', error);
    }

    if (details !== undefined) {
      console.log(`üß™ [BurstDebug] ${step}`, details);
    } else {
      console.log(`üß™ [BurstDebug] ${step}`);
    }
  }

  function cleanupGoldenSequence() {
    if (goldenHoldCleanup) {
      logBurstDebug('cleanupGoldenSequence:invoking-hold-cleanup');
      goldenHoldCleanup();
      goldenHoldCleanup = null;
    }

    if (betaFormRedirectTimeoutId !== null) {
      logBurstDebug('cleanupGoldenSequence:clearing-beta-redirect-timeout', betaFormRedirectTimeoutId);
      clearTimeout(betaFormRedirectTimeoutId);
      betaFormRedirectTimeoutId = null;
    }
    clearBetaFallbackTimeout();

    if (goldenDustAnimationId) {
      logBurstDebug('cleanupGoldenSequence:cancelling-dust-animation');
      cancelAnimationFrame(goldenDustAnimationId);
      goldenDustAnimationId = null;
    }

    const overlayElement = document.getElementById('celliRefOverlay');
    if (overlayElement) {
      logBurstDebug('cleanupGoldenSequence:resetting-overlay-classes');
      overlayElement.classList.remove('tos-ascension', 'tos-hold-shaking', 'dust-phase', 'dust-complete', 'warp-drive', 'blackout-stage', 'blackout-active');
      overlayElement.querySelectorAll('.golden-whiteout, .golden-dust-canvas, .frame-burst, .beta-form-portal, .beta-form-inline').forEach((node) => {
        if (node && node.parentNode) {
          logBurstDebug('cleanupGoldenSequence:removing-overlay-node', {
            classList: node.className,
          });
          node.parentNode.removeChild(node);
        }
      });
      overlayElement.removeAttribute('data-active');
    }

    const tosCard = document.querySelector('.loom-invite-card--tos');
    if (tosCard) {
      logBurstDebug('cleanupGoldenSequence:resetting-tos-card');
      tosCard.classList.remove('morphing', 'tos-morphing', 'beta-card', 'triangle-flight', 'into-frame', 'triangle-collapse-complete', 'tos-locked');
    }

    const videoStage = document.getElementById('betaVideoStage');
    if (videoStage) {
      logBurstDebug('cleanupGoldenSequence:showing-video-stage');
      videoStage.style.display = '';
    }

    const introVideo = document.getElementById('introVideo');
    if (introVideo) {
      try {
        introVideo.pause();
      } catch (error) {
        console.warn('‚ö†Ô∏è Unable to pause intro video during cleanup:', error);
      }
      logBurstDebug('cleanupGoldenSequence:resetting-intro-video');
      introVideo.removeAttribute('src');
      introVideo.load();
      introVideo.style.display = 'none';
    }

    goldenHoldOverlay = null;
    postTermsSequenceStarted = false;
    document.body.classList.remove('referrer-whiteout');
    delete document.body.dataset.betaRedirectComplete;
    betaVideoSequenceStarted = false;
  }

  function scheduleBetaFormRedirect(delay = 0) {
    if (betaFormRedirectTimeoutId !== null) {
      logBurstDebug('scheduleBetaFormRedirect:clearing-existing-timeout', betaFormRedirectTimeoutId);
      clearTimeout(betaFormRedirectTimeoutId);
      betaFormRedirectTimeoutId = null;
    }

    try {
      if (window.sessionStorage?.getItem(FULL_SEQUENCE_FLAG_KEY) === 'true') {
        window.sessionStorage.setItem(FULL_SEQUENCE_STAGE_KEY, FULL_SEQUENCE_BETA_STAGE);
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Unable to persist Full Sequence stage for beta redirect:', error);
    }

    const parsedDelay = Number(delay);
    const safeDelay = Math.max(0, Number.isFinite(parsedDelay) ? parsedDelay : 0);
    console.log(`üõ£Ô∏è Scheduling redirect to beta focus form in ${safeDelay}ms`);
    logBurstDebug('scheduleBetaFormRedirect:scheduled', {
      requestedDelay: delay,
      safeDelay,
    });
    betaFormRedirectTimeoutId = window.setTimeout(() => {
      betaFormRedirectTimeoutId = null;
      console.log('‚û°Ô∏è Redirecting to beta focus form‚Ä¶');
      logBurstDebug('scheduleBetaFormRedirect:timeout-fired');
      try {
        markBetaRedirectPending();
        killReferrerOverlay(); // Kill referrer overlay before redirect
        window.location.assign(BETA_FOCUS_FORM_URL);
      } catch (error) {
        console.error('‚ö†Ô∏è Unable to redirect to beta focus form', error);
        logBurstDebug('scheduleBetaFormRedirect:navigation-error', {
          message: error?.message,
          name: error?.name,
        });
        launchBetaFormVideoSequence();
      }
    }, safeDelay);

    scheduleBetaFallbackCheck(safeDelay);
  }

  function clearBetaFallbackTimeout() {
    if (betaFallbackCheckTimeoutId !== null) {
      logBurstDebug('clearBetaFallbackTimeout:clearing-timeout', betaFallbackCheckTimeoutId);
      clearTimeout(betaFallbackCheckTimeoutId);
      betaFallbackCheckTimeoutId = null;
    }
  }

  function scheduleBetaFallbackCheck(baseDelay) {
    clearBetaFallbackTimeout();
    const fallbackDelay = Math.max(1200, baseDelay + 1000);
    logBurstDebug('scheduleBetaFallbackCheck:scheduled', {
      baseDelay,
      fallbackDelay,
    });
    betaFallbackCheckTimeoutId = window.setTimeout(() => {
      betaFallbackCheckTimeoutId = null;
      if (document.body.dataset.betaRedirectComplete === 'true') {
        logBurstDebug('scheduleBetaFallbackCheck:cancelled-already-complete');
        return;
      }
      console.warn('‚ö†Ô∏è Beta redirect stalled ‚Äì launching inline fallback sequence.');
      logBurstDebug('scheduleBetaFallbackCheck:fallback-triggered');
      launchBetaFormVideoSequence();
    }, fallbackDelay);
  }

  function showInlineBetaForm() {
    const overlay = document.getElementById('videoPlayerOverlay');
    if (!overlay) {
      logBurstDebug('showInlineBetaForm:overlay-missing');
      return;
    }

    logBurstDebug('showInlineBetaForm:activating');
    document.body.dataset.betaRedirectComplete = 'true';

    const video = document.getElementById('introVideo');
    if (video) {
      try {
        video.pause();
      } catch (error) {
        console.warn('‚ö†Ô∏è Unable to pause intro video for inline form:', error);
      }
      logBurstDebug('showInlineBetaForm:video-paused');
    }

    const stage = document.getElementById('betaVideoStage');
    if (stage) {
      logBurstDebug('showInlineBetaForm:hiding-video-stage');
      stage.style.display = 'none';
    }

    let frame = overlay.querySelector('.beta-form-inline');
    if (!frame) {
      logBurstDebug('showInlineBetaForm:creating-iframe');
      frame = document.createElement('iframe');
      frame.className = 'beta-form-inline';
      frame.setAttribute('title', 'Celli Beta Focus Form');
      frame.setAttribute('loading', 'lazy');
      overlay.appendChild(frame);
    }

    if (!frame.getAttribute('src')) {
      logBurstDebug('showInlineBetaForm:setting-src', BETA_FOCUS_FORM_URL);
      frame.src = BETA_FOCUS_FORM_URL;
    }

    overlay.setAttribute('data-active', 'inline');
    logBurstDebug('showInlineBetaForm:overlay-active');
  }

  function launchBetaFormVideoSequence() {
    if (betaVideoSequenceStarted) {
      logBurstDebug('launchBetaFormVideoSequence:already-started');
      return;
    }

    betaVideoSequenceStarted = true;
    document.body.dataset.betaRedirectComplete = 'true';
    clearBetaFallbackTimeout();

    if (betaFormRedirectTimeoutId !== null) {
      logBurstDebug('launchBetaFormVideoSequence:clearing-redirect-timeout', betaFormRedirectTimeoutId);
      clearTimeout(betaFormRedirectTimeoutId);
      betaFormRedirectTimeoutId = null;
    }

    const overlay = document.getElementById('videoPlayerOverlay');
    const video = document.getElementById('introVideo');
    const canvas = document.getElementById('videoCanvas');
    const stage = document.getElementById('betaVideoStage');
    if (!overlay || !video) {
      try {
        killReferrerOverlay(); // Kill referrer overlay before redirect
        window.location.href = BETA_FOCUS_FORM_URL;
      } catch (error) {
        console.error('‚ö†Ô∏è Fallback navigation failed:', error);
      }
      logBurstDebug('launchBetaFormVideoSequence:missing-overlay-or-video');
      return;
    }

    if (stage) {
      logBurstDebug('launchBetaFormVideoSequence:showing-stage');
      stage.style.display = 'flex';
    }

    logBurstDebug('launchBetaFormVideoSequence:prepping-overlay');
    overlay.style.display = 'flex';
    overlay.style.opacity = '0';
    overlay.setAttribute('data-active', 'video');
    requestAnimationFrame(() => {
      overlay.style.transition = 'opacity 0.45s ease';
      overlay.style.opacity = '1';
    });

    if (canvas) {
      canvas.style.display = 'none';
    }

    video.style.display = 'block';
    video.controls = true;
    video.loop = false;
    video.muted = false;
    video.setAttribute('playsinline', 'true');
    video.setAttribute('webkit-playsinline', 'true');
    if (!video.getAttribute('src')) {
      video.src = './intro7.mp4';
    }

    const handleVideoEnded = () => {
      video.removeEventListener('ended', handleVideoEnded);
      showInlineBetaForm();
    };

    const handleVideoError = (event) => {
      console.warn('‚ö†Ô∏è Beta intro video failed:', event);
      video.removeEventListener('error', handleVideoError);
      video.removeEventListener('ended', handleVideoEnded);
      showInlineBetaForm();
    };

    video.addEventListener('ended', handleVideoEnded);
    video.addEventListener('error', handleVideoError);

    const playPromise = video.play();
    if (playPromise && typeof playPromise.then === 'function') {
      playPromise.catch((error) => {
        console.warn('‚ö†Ô∏è Beta intro video playback blocked:', error);
        handleVideoError(error);
      });
    } else {
      showInlineBetaForm();
    }

    const closeBtn = document.getElementById('videoCloseBtn');
    if (closeBtn && !closeBtn.dataset.bound) {
      closeBtn.dataset.bound = 'true';
      closeBtn.addEventListener('click', () => {
        try {
          video.pause();
        } catch (error) {
          console.warn('‚ö†Ô∏è Unable to pause beta intro video:', error);
        }
        overlay.style.display = 'flex';
        overlay.style.opacity = '1';
        showInlineBetaForm();
      });
    }

    // Ensure the form is accessible even if the video stalls.
    window.setTimeout(() => {
      if (!overlay.querySelector('.beta-form-inline') && (video.paused || video.ended || video.readyState === 0)) {
        showInlineBetaForm();
      }
    }, 5000);
  }

  function startHoldWhir() {
    const AudioContextClass = window.AudioContext || window.webkitAudioContext;
    if (!AudioContextClass) {
      return;
    }

    if (!holdWhirContext) {
      holdWhirContext = new AudioContextClass();
    } else if (holdWhirContext.state === 'suspended') {
      holdWhirContext.resume().catch(() => {});
    }

    const ctx = holdWhirContext;
    const now = ctx.currentTime;

    stopHoldWhir(false);

    holdWhirOscillator = ctx.createOscillator();
    holdWhirOscillator.type = 'sawtooth';

    holdWhirFilter = ctx.createBiquadFilter();
    holdWhirFilter.type = 'bandpass';
    holdWhirFilter.frequency.setValueAtTime(180, now);
    holdWhirFilter.frequency.exponentialRampToValueAtTime(520, now + 2.8);
    holdWhirFilter.Q.setValueAtTime(5.2, now);

    holdWhirGain = ctx.createGain();
    holdWhirGain.gain.setValueAtTime(0.0001, now);
    holdWhirGain.gain.exponentialRampToValueAtTime(0.3, now + 0.6);
    holdWhirGain.gain.linearRampToValueAtTime(0.36, now + 2.4);

    holdWhirOscillator.frequency.setValueAtTime(110, now);
    holdWhirOscillator.frequency.exponentialRampToValueAtTime(360, now + 2.6);

    holdWhirLfo = ctx.createOscillator();
    holdWhirLfo.type = 'sine';
    holdWhirLfo.frequency.setValueAtTime(6, now);
    holdWhirLfoGain = ctx.createGain();
    holdWhirLfoGain.gain.setValueAtTime(26, now);

    holdWhirLfo.connect(holdWhirLfoGain);
    holdWhirLfoGain.connect(holdWhirFilter.frequency);

    holdWhirOscillator.connect(holdWhirFilter);
    holdWhirFilter.connect(holdWhirGain);
    holdWhirGain.connect(ctx.destination);

    holdWhirOscillator.start();
    holdWhirLfo.start();
  }

  function triggerHoldClick() {
    if (!holdWhirContext) {
      return;
    }

    const ctx = holdWhirContext;
    const now = ctx.currentTime;
    const clickOsc = ctx.createOscillator();
    const clickGain = ctx.createGain();
    clickOsc.type = 'square';
    clickOsc.frequency.setValueAtTime(880, now);
    clickOsc.frequency.exponentialRampToValueAtTime(220, now + 0.16);
    clickGain.gain.setValueAtTime(0.0001, now);
    clickGain.gain.exponentialRampToValueAtTime(0.42, now + 0.015);
    clickGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.18);
    clickOsc.connect(clickGain);
    clickGain.connect(ctx.destination);
    clickOsc.start(now);
    clickOsc.stop(now + 0.2);
  }

  function stopHoldWhir(playClick = false) {
    if (!holdWhirContext) {
      if (playClick) {
        triggerHoldClick();
      }
      return;
    }

    const ctx = holdWhirContext;
    const now = ctx.currentTime;

    if (holdWhirGain) {
      try {
        const current = holdWhirGain.gain.value || 0.0001;
        holdWhirGain.gain.cancelScheduledValues(now);
        holdWhirGain.gain.setValueAtTime(Math.max(current, 0.0001), now);
        holdWhirGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.22);
      } catch (error) {
        console.warn('Unable to fade hold whir gain', error);
      }
    }

    if (holdWhirOscillator) {
      try {
        holdWhirOscillator.stop(now + 0.24);
      } catch (error) {
        console.warn('Unable to stop hold oscillator', error);
      }
      holdWhirOscillator.disconnect();
      holdWhirOscillator = null;
    }

    if (holdWhirLfo) {
      try {
        holdWhirLfo.stop(now + 0.24);
      } catch (error) {
        console.warn('Unable to stop hold LFO', error);
      }
      holdWhirLfo.disconnect();
      holdWhirLfo = null;
    }

    if (holdWhirLfoGain) {
      holdWhirLfoGain.disconnect();
      holdWhirLfoGain = null;
    }

    if (holdWhirFilter) {
      holdWhirFilter.disconnect();
      holdWhirFilter = null;
    }

    if (holdWhirGain) {
      holdWhirGain.disconnect();
      holdWhirGain = null;
    }

    if (playClick) {
      triggerHoldClick();
    }
  }

  function startGoldenHoldSequence() {
    if (postTermsSequenceStarted) {
      logBurstDebug('startGoldenHoldSequence:already-started');
      return;
    }

    postTermsSequenceStarted = true;
    logBurstDebug('startGoldenHoldSequence:begin');

    stopMagneticCursor();
    if (window.fauxCursorMouseHandler) {
      document.removeEventListener('mousemove', window.fauxCursorMouseHandler);
      window.fauxCursorMouseHandler = null;
    }

    const checkboxContainer = document.getElementById('tosCheckboxContainer');
    if (checkboxContainer) {
      checkboxContainer.style.transform = '';
      checkboxContainer.style.boxShadow = '';
      checkboxContainer.classList.add('tos-hold-complete');
    }

    const overlayElement = document.getElementById('celliRefOverlay');
    const tosCard = document.querySelector('.loom-invite-card--tos');

    if (!overlayElement || !tosCard) {
      console.warn('‚ö†Ô∏è Unable to start ToS ascension ‚Äì missing elements');
      logBurstDebug('startGoldenHoldSequence:missing-elements', {
        hasOverlay: Boolean(overlayElement),
        hasTosCard: Boolean(tosCard),
      });
      return;
    }

    overlayElement.classList.remove('tos-hold-shaking');
    overlayElement.classList.add('tos-ascension');

    tosCard.classList.add('morphing', 'tos-morphing');

    goldenHoldOverlay = overlayElement;
    logBurstDebug('startGoldenHoldSequence:immediate-redirect');

    // Immediate blackout + redirect (no delays, no burst animations)
    try { blackoutUnderPage(); } catch (e) {}
    redirectToBetaFormImmediate();
  }

  function fadeAndRemoveElement(element, removeFromDom = false) {
    if (!element) {
      return;
    }

    element.classList.add('referral-fade');
    element.setAttribute('aria-hidden', 'true');

    if (removeFromDom) {
      window.setTimeout(() => {
        if (element && element.parentNode) {
          element.parentNode.removeChild(element);
          if (element.classList && (element.classList.contains('loom-invite-clone') || element.classList.contains('loom-invite-pin'))) {
            updateInviteContainerInteractivity();
          }
        }
      }, 480);
    }
  }

  function teardownReferralStageLayers() {
    logBurstDebug('teardownReferralStageLayers:start');
    cancelExtraInviteSchedule();

    document.querySelectorAll('.loom-invite-clone, .loom-invite-pin').forEach((node) => {
      logBurstDebug('teardownReferralStageLayers:fade-out-node', node.className);
      fadeAndRemoveElement(node, true);
    });

    resetLightBeamFocus();

    const swarm = document.getElementById('loomInviteSwarm');
    if (swarm) {
      logBurstDebug('teardownReferralStageLayers:removing-swarm');
      fadeAndRemoveElement(swarm, true);
    }

    if (refPanel) {
      logBurstDebug('teardownReferralStageLayers:panel-fade');
      fadeAndRemoveElement(refPanel);
    }

    if (refSidebar) {
      logBurstDebug('teardownReferralStageLayers:sidebar-fade');
      fadeAndRemoveElement(refSidebar);
    }

    if (darkeningOverlay) {
      logBurstDebug('teardownReferralStageLayers:darkening-overlay');
      darkeningOverlay.classList.add('referral-fade');
      darkeningOverlay.style.opacity = '0';
    }

    if (baseDarkness) {
      logBurstDebug('teardownReferralStageLayers:base-darkness');
      baseDarkness.classList.add('referral-fade');
      baseDarkness.style.opacity = '0';
    }

    document.querySelectorAll('.light-ray, .burst-beam, .darkening-hole').forEach((node) => {
      logBurstDebug('teardownReferralStageLayers:removing-light-effect', node.className);
      fadeAndRemoveElement(node, true);
    });

    const tooltip = document.querySelector('.ref-tooltip');
    if (tooltip) {
      logBurstDebug('teardownReferralStageLayers:tooltip-fade');
      fadeAndRemoveElement(tooltip, true);
    }

    window.setTimeout(() => {
      document.querySelectorAll('.referral-fade').forEach((node) => {
        node.classList.add('referral-hidden');
      });
      logBurstDebug('teardownReferralStageLayers:fade-complete');
    }, 520);
  }

  const VOXEL_SHATTER_TIMEOUT_MS = 6500;

  async function runVoxelShatterSequence(sourceCanvas) {
    if (!sourceCanvas) {
      logBurstDebug('runVoxelShatterSequence:no-source-canvas');
      return false;
    }
    logBurstDebug('runVoxelShatterSequence:start', {
      width: sourceCanvas.width,
      height: sourceCanvas.height,
    });
    let timeoutId = null;
    try {
      const result = await Promise.race([
        voxelShatter
          .startFromCanvas(sourceCanvas, { duration: 3400, burstDelay: 750 })
          .then(() => ({ status: 'completed' })),
        new Promise((resolve) => {
          timeoutId = window.setTimeout(
            () => resolve({ status: 'timeout' }),
            VOXEL_SHATTER_TIMEOUT_MS
          );
        }),
      ]);

      if (timeoutId !== null) {
        clearTimeout(timeoutId);
        timeoutId = null;
      }

      if (result.status === 'timeout') {
        console.warn('‚ö†Ô∏è Voxel shatter timed out, using fallback dust animation');
        logBurstDebug('runVoxelShatterSequence:timeout', {
          timeoutMs: VOXEL_SHATTER_TIMEOUT_MS,
        });
        try {
          voxelShatter.dispose();
        } catch (disposeError) {
          console.warn('‚ö†Ô∏è Unable to dispose voxel shatter scene after timeout', disposeError);
          logBurstDebug('runVoxelShatterSequence:dispose-error', {
            message: disposeError?.message,
            name: disposeError?.name,
          });
        }
        return false;
      }

      logBurstDebug('runVoxelShatterSequence:success');
      return true;
    } catch (error) {
      console.warn('‚ö†Ô∏è Voxel shatter failed, using fallback dust animation', error);
      logBurstDebug('runVoxelShatterSequence:error', {
        message: error?.message,
        name: error?.name,
      });
      try {
        voxelShatter.dispose();
      } catch (disposeError) {
        console.warn('‚ö†Ô∏è Unable to dispose voxel shatter scene cleanly', disposeError);
        logBurstDebug('runVoxelShatterSequence:dispose-error', {
          message: disposeError?.message,
          name: disposeError?.name,
        });
      }
      return false;
    } finally {
      if (timeoutId !== null) {
        clearTimeout(timeoutId);
        timeoutId = null;
      }
    }
  }

  async function beginDustTransition(overlayElement, triangleElement) {
    logBurstDebug('beginDustTransition:start - immediate redirect');
    // Fast path: avoid laggy pixel sweep ‚Äî blackout and redirect immediately
    try { blackoutUnderPage(); } catch (e) {}
    redirectToBetaFormImmediate();
  }

  function runDustAnimation(sourceCanvas, targetCanvas, whiteoutElement, onComplete) {
    logBurstDebug('runDustAnimation:start', {
      width: sourceCanvas ? sourceCanvas.width : undefined,
      height: sourceCanvas ? sourceCanvas.height : undefined,
    });
    const sourceContext = sourceCanvas.getContext('2d');
    const ctx = targetCanvas.getContext('2d');
    if (!sourceContext || !ctx) {
      if (typeof onComplete === 'function') {
        onComplete();
      }
      logBurstDebug('runDustAnimation:missing-context', {
        hasSource: Boolean(sourceContext),
        hasTarget: Boolean(ctx),
      });
      return;
    }

    const width = sourceCanvas.width;
    const height = sourceCanvas.height;
    targetCanvas.width = width;
    targetCanvas.height = height;
    targetCanvas.style.width = '100vw';
    targetCanvas.style.height = '100vh';

    ctx.imageSmoothingEnabled = false;

    const imageData = sourceContext.getImageData(0, 0, width, height).data;
    const step = Math.max(4, Math.floor(width / 240));
    const particles = [];

    for (let y = 0; y < height; y += step) {
      for (let x = 0; x < width; x += step) {
        const index = (y * width + x) * 4;
        const alpha = imageData[index + 3];
        if (alpha < 48) {
          continue;
        }

        particles.push({
          x,
          y,
          r: imageData[index],
          g: imageData[index + 1],
          b: imageData[index + 2],
          a: alpha / 255,
          vx: -Math.random() * 6 - 1.5,
          vy: (Math.random() - 0.5) * 3.2,
          drift: Math.random() * 2,
          life: 1,
          size: step
        });
      }
    }

    let progress = 0;
    logBurstDebug('runDustAnimation:particles-created', particles.length);

    const animate = () => {
      progress += 0.012;
      ctx.clearRect(0, 0, width, height);

      const windForce = -10 * progress;
      particles.forEach((particle) => {
        if (particle.life <= 0) {
          return;
        }

        particle.x += (particle.vx + windForce) * (0.85 + progress * 0.35);
        particle.y += particle.vy + Math.sin((particle.x + progress * 620) * 0.01) * particle.drift;
        particle.life -= 0.008 + progress * 0.015;

        if (particle.life <= 0) {
          return;
        }

        ctx.fillStyle = `rgba(${particle.r}, ${particle.g}, ${particle.b}, ${Math.max(particle.life, 0) * particle.a})`;
        ctx.fillRect(particle.x, particle.y, particle.size, particle.size);
      });

      if (whiteoutElement) {
        const opacityTarget = Math.min(1, progress * 1.8);
        whiteoutElement.style.opacity = opacityTarget.toFixed(3);
      }

      if (progress < 1.3) {
        goldenDustAnimationId = requestAnimationFrame(animate);
      } else {
        goldenDustAnimationId = null;
        if (typeof onComplete === 'function') {
          onComplete();
        }
        logBurstDebug('runDustAnimation:completed');
      }
    };

    goldenDustAnimationId = requestAnimationFrame(animate);
  }

  function startWarpSequence(overlayElement, triangleElement) {
    if (!overlayElement || !triangleElement) {
      logBurstDebug('startWarpSequence:missing-elements', {
        hasOverlay: Boolean(overlayElement),
        hasTriangle: Boolean(triangleElement),
      });
      return;
    }

    if (overlayElement.classList.contains('warp-drive')) {
      logBurstDebug('startWarpSequence:already-active');
      return;
    }

    logBurstDebug('startWarpSequence:init');
    overlayElement.classList.add('warp-drive');
    overlayElement.classList.add('blackout-stage');
    document.body.classList.add('referrer-blackout');

    window.requestAnimationFrame(() => {
      overlayElement.classList.add('blackout-active');
      logBurstDebug('startWarpSequence:blackout-active');
    });

    let frameBurst = overlayElement.querySelector('.frame-burst');
    if (!frameBurst) {
      frameBurst = document.createElement('div');
      frameBurst.className = 'frame-burst';
      overlayElement.appendChild(frameBurst);
      window.requestAnimationFrame(() => frameBurst.classList.add('active'));
      logBurstDebug('startWarpSequence:frame-burst-created');
    }

    let portal = overlayElement.querySelector('.beta-form-portal');
    if (!portal) {
      portal = document.createElement('div');
      portal.className = 'beta-form-portal';
      const glow = document.createElement('div');
      glow.className = 'beta-form-portal__glow';
      portal.appendChild(glow);
      overlayElement.appendChild(portal);
      window.requestAnimationFrame(() => portal.classList.add('active'));
      logBurstDebug('startWarpSequence:portal-created');
    } else {
      window.requestAnimationFrame(() => portal.classList.add('active'));
      logBurstDebug('startWarpSequence:portal-reactivated');
    }

    const trailSpans = triangleElement.querySelectorAll('.golden-trail-pack span');
    trailSpans.forEach((span, index) => {
      span.style.setProperty('--i', index);
    });

    triangleElement.classList.add('beta-card');

    window.requestAnimationFrame(() => {
      triangleElement.classList.add('triangle-flight');
      logBurstDebug('startWarpSequence:triangle-flight');
    });

    window.setTimeout(() => {
      triangleElement.classList.add('into-frame');
      logBurstDebug('startWarpSequence:triangle-into-frame');
    }, 420);

    window.setTimeout(() => {
      triangleElement.classList.add('triangle-collapse-complete');
      logBurstDebug('startWarpSequence:triangle-collapse-complete');
    }, 1400);

    logBurstDebug('startWarpSequence:scheduling-beta-redirect');
    scheduleBetaFormRedirect(0);
  }
  
  // Magnetic cursor effect
  let magneticActive = false;
  let cursorX = 0, cursorY = 0;
  
  function startMagneticCursor() {
    magneticActive = true;
    refPanel.classList.add('magnetic-active');
    if (refSidebarAck) {
      refSidebarAck.classList.add('magnetic-highlight');
    }
  }

  function stopMagneticCursor() {
    magneticActive = false;
    refPanel.classList.remove('magnetic-active');
    if (refSidebarAck) {
      refSidebarAck.classList.remove('magnetic-highlight');
      refSidebarAck.style.transform = 'translate(0, 0) scale(1)';
      refSidebarAck.style.boxShadow = 'none';
    }
  }

  // Track mouse position
  overlay.addEventListener('mousemove', (e) => {
    cursorX = e.clientX;
    cursorY = e.clientY;

    if (!magneticActive || !refSidebar.classList.contains('active')) {
      return;
    }

    const btnRect = refSidebarAck.getBoundingClientRect();
    const btnCenterX = btnRect.left + btnRect.width / 2;
    const btnCenterY = btnRect.top + btnRect.height / 2;
    
    const dx = btnCenterX - cursorX;
    const dy = btnCenterY - cursorY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    // Magnetic range: 300px
    if (distance < 300) {
      const strength = 1 - (distance / 300);
      const pullX = dx * strength * 0.4;
      const pullY = dy * strength * 0.4;

      const scale = 1 + strength * 0.2;
      refSidebarAck.style.transform = `translate(${pullX * -0.05}px, ${pullY * -0.05}px) scale(${scale})`;
      refSidebarAck.style.boxShadow = `0 0 ${strength * 25}px rgba(255,255,255,${strength * 0.6})`;
    } else {
      refSidebarAck.style.transform = 'translate(0, 0) scale(1)';
      refSidebarAck.style.boxShadow = 'none';
    }
  });
  
  async function triggerOverlay(url) {
    // Check if overlay has been killed (coming from redirect)
    if (window.__referrerOverlayKilled) {
      console.log('‚õî triggerOverlay() blocked - overlay has been killed');
      return;
    }
    
    // Detect source type from URL
    const urlLower = (url || '').toLowerCase();
    const isHN = /news\.ycombinator\.com/.test(urlLower);
    const isReddit = /(^|\/\/|\.)reddit\.com/.test(urlLower);
    const isTwitter = /(^|\/\/|\.)twitter\.com/.test(urlLower) || /(^|\/\/|\.)x\.com/.test(urlLower) || url === 'zeed';
    const isFacebook = /(^|\/\/|\.)facebook\.com/.test(urlLower) || url === 'facebook';
    const isLinkedIn = /(^|\/\/|\.)linkedin\.com/.test(urlLower) || url === 'linkedin';

    // Set header visuals
    if (isHN) {
      refLogo.classList.remove('reddit', 'twitter', 'facebook', 'linkedin');
      refLogo.classList.add('hn');
      refLogo.textContent = 'HN';
      refTitle.textContent = 'Previously on Hacker News‚Ä¶';
      refSub.textContent = new URL(url || 'https://news.ycombinator.com').hostname;
    } else if (isReddit) {
      refLogo.classList.remove('hn', 'twitter', 'facebook', 'linkedin');
      refLogo.classList.add('reddit');
      refLogo.textContent = 'reddit';
      refTitle.textContent = 'Previously on Reddit‚Ä¶';
      refSub.textContent = hostOrPath(url || 'https://www.reddit.com');
    } else if (isTwitter) {
      refLogo.classList.remove('hn', 'reddit', 'facebook', 'linkedin');
      refLogo.classList.add('twitter');
      refLogo.textContent = 'Z';
      refTitle.textContent = 'Previously on Zeed‚Ä¶';
      refSub.textContent = 'timeline reconstructed';
    } else if (isFacebook) {
      refLogo.classList.remove('hn', 'reddit', 'twitter', 'linkedin');
      refLogo.classList.add('facebook');
      refLogo.textContent = 'f';
      refTitle.textContent = 'Previously on Facebook‚Ä¶';
      refSub.textContent = 'news feed + messenger';
    } else if (isLinkedIn) {
      refLogo.classList.remove('hn', 'reddit', 'twitter', 'facebook');
      refLogo.classList.add('linkedin');
      refLogo.textContent = 'in';
      refTitle.textContent = 'Previously on LinkedIn‚Ä¶';
      refSub.textContent = 'everyone is "thrilled"';
    } else {
      refLogo.classList.remove('hn', 'reddit', 'twitter', 'facebook', 'linkedin');
      refLogo.textContent = 'SRC';
      refTitle.textContent = 'Reconstructing previous page‚Ä¶';
      refSub.textContent = hostOrPath(url);
    }
    
    // Show overlay
    openOverlay();
    
    // Fetch snapshot
    let items = [];
    let platformType = 'hn';
    
    try {
      if (isHN) {
        platformType = 'hn';
        items = await fetchHNSnapshot(url);
      } else if (isReddit) {
        platformType = 'reddit';
        items = await fetchRedditSnapshot(url);
      } else if (isTwitter) {
        platformType = 'twitter';
        items = await fetchTwitterSnapshot(url);
      } else if (isFacebook) {
        platformType = 'facebook';
        items = await fetchFacebookSnapshot(url);
      } else if (isLinkedIn) {
        platformType = 'linkedin';
        items = await fetchLinkedInSnapshot(url);
      } else {
        items = await fetchGenericFallback(url);
      }
      console.log(`‚úì Fetched ${items ? items.length : 0} items for ${platformType}`);
    } catch (e) {
      console.error('Fetch error:', e);
      items = [];
    }
    
    if (!items || items.length === 0) {
      console.warn('No items - using fallback');
      items = [{ title: '(no items found ‚Äî source may be private or blocked)', sub: '', link: '' }];
    }
    
    console.log(`üìù Calling renderItems with ${items.length} items for platform: ${platformType}`);
    renderItems(items, platformType);
    
    console.log(`‚ú® Calling stagedReveal for platform: ${platformType}`);
    stagedReveal(platformType);
    
    console.log(`üëª Scheduling glitch effect`);
    setTimeout(runGlitchOnce, 700);
    
    // Wire controls
    btnClose.replaceWith(btnClose.cloneNode(true));
    btnDismiss.replaceWith(btnDismiss.cloneNode(true));
    btnRecreate.replaceWith(btnRecreate.cloneNode(true));
    btnReset.replaceWith(btnReset.cloneNode(true));
    const newClose = document.getElementById('refClose');
    const newDismiss = document.getElementById('refDismiss');
    const newRecreate = document.getElementById('refRecreate');
    const newReset = document.getElementById('refReset');
    bindOverlayButton(newClose, dismiss);
    bindOverlayButton(newDismiss, dismiss);
    bindOverlayButton(newRecreate, () => {
      runGlitchOnce();
      jitterList(700);
    });
    bindOverlayButton(newReset, () => {
      resetImpacts();
    });
  }

  function bindOverlayButton(button, handler) {
    if (!button || typeof handler !== 'function') {
      return;
    }

    const handleClick = (event) => {
      handler(event);
    };

    const handleTouchEnd = (event) => {
      event.preventDefault();
      handler(event);
    };

    button.addEventListener('click', handleClick);
    button.addEventListener('touchend', handleTouchEnd, { passive: false });
  }
  
  function openOverlay() {
    // Check if overlay has been killed (coming from redirect)
    if (window.__referrerOverlayKilled) {
      console.log('‚õî openOverlay() blocked - overlay has been killed');
      return;
    }
    
    console.log('üöÄ openOverlay() called - making referrer overlay visible');
    
    overlay.setAttribute('aria-hidden', 'false');
    ensureReferrerSequenceSession();
    setReferrerOverlayActiveState(true);
    if (bodyEl) {
      bodyEl.style.overflow = 'hidden';
    }
    
    // Make referrer overlay visible (in case it was hidden by kill script)
    if (refStageRoot) {
      console.log('  Clearing inline styles from refStageRoot');
      refStageRoot.style.cssText = '';
      refStageRoot.style.display = '';
      refStageRoot.style.opacity = '';
      refStageRoot.style.visibility = '';
      refStageRoot.style.zIndex = '';
      refStageRoot.style.pointerEvents = '';
    }
    
    activateReferrerStageRoot();
    updateLightBeamFocus();
    
    console.log('‚úÖ Overlay opened successfully');
  }

  function dismiss() {
    overlay.setAttribute('aria-hidden', 'true');
    if (bodyEl) {
      bodyEl.style.overflow = '';
    }
    
    deactivateReferrerStageRoot();
    setReferrerOverlayActiveState(false);
    hideSidebar();
    hideTooltip();
    resetImpacts();
    resetLightBeamFocus();
    clearBetaFallbackTimeout();
    delete document.body.dataset.betaRedirectComplete;
    
    // Always hide the debug controls menu (unless unlocked)
    if (!isReferrerControlsUnlocked()) {
      hideReferrerControls();
    }
  }
  
  function showSidebar(url, withImpact = false) {
    refSidebar.classList.remove('bouncing', 'impact');
    refSidebar.classList.add('active');
    
    if (url) {
      refSidebarUrl.textContent = `Navigating to: ${url}`;
      refSidebarUrl.style.display = 'block';
    }
    
    if (withImpact) {
      // Add impact effect from tooltip splat
      setTimeout(() => refSidebar.classList.add('impact'), 10);
      setTimeout(() => refSidebar.classList.remove('impact'), 600);
    } else {
      // Normal bounce in
      setTimeout(() => refSidebar.classList.add('bouncing'), 10);
      setTimeout(() => refSidebar.classList.remove('bouncing'), 600);
    }

    // burst light removed - only appears during invite card animation

    setTimeout(() => startMagneticCursor(), 800);
    updateLightBeamFocus();
  }
  
  function hideSidebar() {
    refSidebar.classList.remove('active', 'bouncing', 'impact', 'mythic-entrance', 'stage-float', 'stage-sweep', 'stage-rumble', 'stage-expand', 'note-hover', 'note-seed');
    refSidebarUrl.style.display = 'none';
    refSidebarUrl.textContent = '';
    refSidebarClose.style.display = 'block';
    cancelExtraInviteSchedule();
    resetTriColorLayer();
    noteInteractionLocked = false;
    document.body.classList.remove('ref-note-centered');

    clearNoteStageTimeouts();
    stopChantAudio();
    stopBadBooleanTrack();
    noteAwaitingActivation = false;
    noteHoverSequenceStarted = false;
    loomAiMessageActive = false;
    loomFakeAdActive = false;
    noteHasEnteredFrame = false;
    stopAiEnhancedScan();
    markInviteActive(false);

    // Reset button to original state
    renderBaseLoomInvite();

    // Reset sidebar content visibility
    const h3 = refSidebar.querySelector('h3');
    const paragraphs = refSidebar.querySelectorAll('p');
    if (h3) {
      h3.style.opacity = '1';
      h3.style.display = 'block';
    }
    paragraphs.forEach(p => {
      p.style.opacity = '1';
      p.style.display = 'block';
    });
    
    // Clean up ToS phase
    tosPhaseActive = false;
    
    // Remove faux cursor
    // Cancel faux cursor animation
    // Remove mouse handler
    if (window.fauxCursorMouseHandler) {
      document.removeEventListener('mousemove', window.fauxCursorMouseHandler);
      window.fauxCursorMouseHandler = null;
    }

    const checkboxContainer = document.getElementById('tosCheckboxContainer');
    if (checkboxContainer) {
      checkboxContainer.style.transform = '';
      checkboxContainer.style.boxShadow = '';
    }

    // Reset sidebar styling
    const sidebar = refSidebar;
    sidebar.style.background = '';
    sidebar.style.backdropFilter = '';
    sidebar.style.webkitBackdropFilter = '';
    sidebar.style.border = '';
    sidebar.style.borderRadius = '';
    sidebar.style.padding = '';
    sidebar.style.overflow = '';
    
    stopMagneticCursor();
  }
  
  function detectPlatformFromElement(element) {
    if (!element) return '';
    for (const [platform, selector] of Object.entries(POST_PLATFORM_SELECTORS)) {
      if (element.closest(selector)) {
        return platform;
      }
    }
    return '';
  }

  function applyTooltipTheme(tooltipElement, platform) {
    if (!tooltipElement) return;
    TOOLTIP_THEME_CLASSES.forEach(cls => tooltipElement.classList.remove(cls));
    if (platform) {
      tooltipElement.classList.add(`ref-tooltip--${platform}`);
    }
  }

  function isPostLink(element) {
    if (!element) return false;
    return Object.values(POST_PLATFORM_SELECTORS).some(selector => element.closest(selector));
  }

  function createHeartsAndPrayersToast(platform) {
    const toast = document.createElement('div');
    toast.className = `hearts-prayers-toast${platform ? ` hearts-prayers-toast--${platform}` : ''}`;
    toast.innerHTML = `
      <span class="hearts-prayers-emoji" aria-hidden="true">üíñüôè</span>
      <span class="hearts-prayers-text">hearts and prayers</span>
    `;
    return toast;
  }

  function sendHeartsAndPrayers(linkElement, platform) {
    const toast = createHeartsAndPrayersToast(platform);
    const rect = linkElement.getBoundingClientRect();
    const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
    const top = Math.max(12, rect.top - 24);
    toast.style.left = `${rect.left + rect.width / 2}px`;
    toast.style.top = `${Math.min(top, viewportHeight - 60)}px`;
    document.body.appendChild(toast);
    requestAnimationFrame(() => toast.classList.add('visible'));
    setTimeout(() => {
      toast.classList.remove('visible');
      setTimeout(() => {
        if (toast.parentNode) {
          toast.parentNode.removeChild(toast);
        }
      }, 200);
    }, 900);
  }

  function showTooltip(url, linkElement) {
    // Show the shared hover tooltip
    if (refTooltipText) {
      refTooltipText.textContent = url;
    } else if (refTooltip) {
      refTooltip.textContent = url;
    }

    applyTooltipTheme(refTooltip, detectPlatformFromElement(linkElement));

    updateSharedTooltipWidth();

    // Position above the link element
    const rect = linkElement.getBoundingClientRect();
    const { tooltipWidth, edgePadding, verticalOffset } = getTooltipMetrics();
    const viewportWidth = window.innerWidth || document.documentElement.clientWidth || tooltipWidth;

    // Center horizontally on the link, position above it
    let left = rect.left + (rect.width / 2) - (tooltipWidth / 2);
    const top = Math.max(12, rect.top - verticalOffset);

    // Keep within viewport bounds using adaptive padding
    if (left < edgePadding) left = edgePadding;
    if (left + tooltipWidth > viewportWidth - edgePadding) {
      left = viewportWidth - tooltipWidth - edgePadding;
    }

    refTooltip.style.left = `${left}px`;
    refTooltip.style.top = `${top}px`;
    refTooltip.classList.remove('morphing');
    refTooltip.classList.add('active');
  }
  
  function createFlyingTooltip(url, linkElement, clickX = null, clickY = null) {
    // Create a NEW independent tooltip for animation
    const tooltip = document.createElement('div');
    tooltip.className = 'ref-tooltip active';
    tooltip.innerHTML = `
      <span class="ref-tooltip-bullet" aria-hidden="true"></span>
      <span class="ref-tooltip-text"></span>
    `;
    const tooltipText = tooltip.querySelector('.ref-tooltip-text');
    if (tooltipText) {
      tooltipText.textContent = url;
    } else {
      tooltip.textContent = url;
    }
    applyTooltipTheme(tooltip, detectPlatformFromElement(linkElement));
    document.body.appendChild(tooltip);

    // Position above the cursor if provided, else above the link element
    const rect = linkElement.getBoundingClientRect();
    const { tooltipWidth, edgePadding, verticalOffset } = getTooltipMetrics();
    const viewportWidth = window.innerWidth || document.documentElement.clientWidth || tooltipWidth;

    let left = (clickX != null)
      ? Math.max(edgePadding, Math.min(clickX - (tooltipWidth / 2), viewportWidth - tooltipWidth - edgePadding))
      : rect.left + (rect.width / 2) - (tooltipWidth / 2);
    const top = Math.max(12, (clickY != null ? clickY : rect.top) - verticalOffset);

    if (left < edgePadding) left = edgePadding;
    if (left + tooltipWidth > viewportWidth - edgePadding) {
      left = viewportWidth - tooltipWidth - edgePadding;
    }

    const distanceToEdge = Math.max(0, viewportWidth - edgePadding - (left + tooltipWidth));

    tooltip.style.left = `${left}px`;
    tooltip.style.top = `${top}px`;
    tooltip.style.width = `${tooltipWidth}px`;
    tooltip.style.maxWidth = `${tooltipWidth}px`;
    tooltip.style.setProperty('--edge-distance', `${distanceToEdge}px`);
    tooltip.dataset.initialLeft = `${left}`;
    tooltip.dataset.tooltipWidth = `${tooltipWidth}`;

    return tooltip;
  }

  function getPostIdForElement(element) {
    if (!element) {
      return null;
    }

    if (element.dataset && element.dataset.refPostId) {
      return element.dataset.refPostId;
    }

    const container = typeof element.closest === 'function'
      ? element.closest('[data-ref-post-id]')
      : null;

    return container?.dataset?.refPostId || null;
  }
  
  function hideTooltip() {
    refTooltip.classList.remove('active', 'morphing');
  }
  
  function createImpactParticles(tooltipElement) {
    console.log('üí® Creating impact particles...');

    const tooltipRect = tooltipElement.getBoundingClientRect();
    const metrics = getEdgeMetrics();
    const impactX = window.innerWidth - Math.max(metrics.edgePadding * 0.6, 12);
    const impactYTop = tooltipRect.top;
    const impactYBottom = tooltipRect.bottom;
    const impactYCenter = (impactYTop + impactYBottom) / 2;
    
    console.log(`   Impact point: x=${impactX}, y=${impactYCenter.toFixed(0)} (top:${impactYTop.toFixed(0)}, bottom:${impactYBottom.toFixed(0)})`);
    
    // Number of particles to spawn
    const particleCount = 25;
    console.log(`   Spawning ${particleCount} particles`);
    
    // Spawn particles from top of tooltip collision
    for (let i = 0; i < particleCount / 3; i++) {
      createParticle(impactX, impactYTop, -1); // -1 = upward bias
    }
    
    // Spawn particles from bottom of tooltip collision
    for (let i = 0; i < particleCount / 3; i++) {
      createParticle(impactX, impactYBottom, 1); // 1 = downward bias
    }
    
    // Spawn particles from center (spray in both directions)
    for (let i = 0; i < particleCount / 3; i++) {
      createParticle(impactX, impactYCenter, Math.random() > 0.5 ? 1 : -1);
    }
  }
  
  function createParticle(x, y, verticalBias) {
    const particle = document.createElement('div');
    const shapes = ['impact-particle--circle', 'impact-particle--square', 'impact-particle--triangle'];
    const shapeClass = shapes[Math.floor(Math.random() * shapes.length)];
    particle.className = `impact-particle pixel-particle ${shapeClass}`;

    // Compact radiant particles (3px-6px)
    const sizeOptions = [3, 4, 5, 6];
    const size = sizeOptions[Math.floor(Math.random() * sizeOptions.length)];
    particle.style.width = size + 'px';
    particle.style.height = size + 'px';

    // Specific pixel colors: cyan-ish blue, orange-ish yellow, magenta-ish red
    const colors = [
      '#00d4ff',  // slightly cyan blue
      '#ff8800',  // slightly orange yellow
      '#ff0055',  // slightly magenta red
    ];
    const color = colors[Math.floor(Math.random() * colors.length)];
    particle.style.background = color;
    particle.style.boxShadow = `0 0 ${size}px ${color}`;
    particle.style.mixBlendMode = 'screen';
    particle.style.zIndex = '2147483700'; // Top layer - above everything

    particle.style.left = x + 'px';
    particle.style.top = y + 'px';

    const rotation = shapeClass === 'impact-particle--triangle'
      ? (Math.random() - 0.5) * 120
      : (Math.random() - 0.5) * 40;
    particle.style.setProperty('--particle-rotation', `${rotation}deg`);

    // Random velocity (biased by vertical direction)
    // Wider spread angle for explosive effect
    const angleSpread = Math.PI * 0.8; // 144 degrees spread
    const baseAngle = verticalBias > 0 ? Math.PI / 2 : -Math.PI / 2;
    const angle = (Math.random() - 0.5) * angleSpread + baseAngle;
    const speed = 80 + Math.random() * 150; // Faster particles
    const vx = Math.cos(angle) * speed * -1; // Move left into frame
    const vy = Math.sin(angle) * speed;
    
    particle.style.setProperty('--particle-x', vx + 'px');
    particle.style.setProperty('--particle-y', vy + 'px');
    
    document.body.appendChild(particle);
    
    // Trigger animation with slight delay for staggered effect
    const delay = Math.random() * 30;
    setTimeout(() => {
      requestAnimationFrame(() => {
        particle.classList.add('active');
      });
    }, delay);
    
    // Remove after animation
    setTimeout(() => {
      if (particle.parentNode) {
        particle.parentNode.removeChild(particle);
      }
    }, 700 + delay);
  }
  
  // Track brick holes for final burst
  let brickHoles = [];
  const brickHoleByPostId = new Map();
  const lightRaysByPostId = new Map();

  function createBrickHole(yPosition, postId = null) {
    const postSuffix = postId ? ` (post ${postId})` : '';
    console.log(`üß±üí• Creating brick hole at Y: ${yPosition}px${postSuffix}`);
    console.log(`  üìä Current hole count: ${brickHoles.length}`);

    const metrics = getEdgeMetrics();
    const holeWidth = Math.max(200, metrics.lightRayWidth * 0.42);
    const holeHeight = Math.max(48, metrics.lightRayHeight * 2.4);
    const holeTop = yPosition - (holeHeight / 2);
    const holeRightOffset = Math.round(metrics.edgePadding * 0.15);

    if (postId && brickHoleByPostId.has(postId)) {
      const existingRecord = brickHoleByPostId.get(postId);
      const existingHole = existingRecord?.element;
      if (existingHole && existingHole.parentNode) {
        console.log(`  ‚ôªÔ∏è Reusing existing brick hole for ${postId}`);
        existingRecord.y = yPosition;
        existingHole.style.top = `${holeTop}px`;
        existingHole.style.right = `-${holeRightOffset}px`;
        existingHole.style.width = `${Math.round(holeWidth)}px`;
        existingHole.style.height = `${Math.round(holeHeight)}px`;
        existingHole.dataset.refPostId = postId;
        existingHole.style.animation = 'none';
        void existingHole.offsetWidth;
        existingHole.style.animation = '';

        updateDarkeningMask();
        setTimeout(() => createLightRay(yPosition, postId), 150);
        return existingHole;
      }

      // Element was removed, drop the stale record so we can recreate it
      brickHoleByPostId.delete(postId);
      if (existingRecord) {
        const index = brickHoles.indexOf(existingRecord);
        if (index !== -1) {
          brickHoles.splice(index, 1);
        }
      }
    }

    const hole = document.createElement('div');
    hole.className = 'darkening-hole';
    hole.style.top = `${holeTop}px`;
    hole.style.right = `-${holeRightOffset}px`;
    hole.style.width = `${Math.round(holeWidth)}px`;
    hole.style.height = `${Math.round(holeHeight)}px`;
    hole.style.position = 'fixed';
    hole.style.border = 'none';
    hole.style.zIndex = '10001';
    if (postId) {
      hole.dataset.refPostId = postId;
    }

    const holeId = `hole-${postId || Date.now()}`;
    hole.setAttribute('data-hole-id', holeId);

    document.body.appendChild(hole);

    const record = { y: yPosition, element: hole, postId: postId || null, ray: null };
    brickHoles.push(record);
    if (postId) {
      brickHoleByPostId.set(postId, record);
    }

    console.log(`  ‚úÖ Hole element added to DOM`);
    console.log(`  üìç Total brick holes now: ${brickHoles.length}`);

    updateDarkeningMask();

    setTimeout(() => {
      createLightRay(yPosition, postId);
    }, 150);

    return hole;
  }
  
  function updateDarkeningMask() {
    if (!darkeningOverlay) return;
    
    if (brickHoles.length === 0) {
      // No holes, clear any masks
      darkeningOverlay.style.maskImage = 'none';
      darkeningOverlay.style.webkitMaskImage = 'none';
      console.log(`  üï≥Ô∏è  No holes, full darkening (no mask)`);
      return;
    }
    
    console.log(`  üï≥Ô∏è  Creating mask with ${brickHoles.length} holes at Y positions:`, brickHoles.map(h => h.y));
    
    // Build a paint() mask that punches holes
    // Start with full black (visible), then punch transparent holes
    let maskGradients = [];
    const metrics = getEdgeMetrics();
    const holeRadiusX = Math.max(90, metrics.lightRayWidth * 0.45);
    const holeRadiusY = Math.max(28, metrics.lightRayHeight * 2.2);
    const holeOffset = Math.max(holeRadiusX, metrics.edgePadding * 1.1);

    brickHoles.forEach(hole => {
      const y = hole.y;
      // Create a radial gradient hole centered on the right edge
      maskGradients.push(
        `radial-gradient(ellipse ${holeRadiusX}px ${holeRadiusY}px at calc(100% - ${holeOffset}px) ${y}px, transparent 0%, transparent 60%, black 100%)`
      );
    });
    
    // If we have holes, we need to combine them properly
    // Use a solid black background, then subtract the holes
    const fullMask = 'linear-gradient(black, black)';
    
    // Apply the full mask first, then the holes will subtract from it
    darkeningOverlay.style.maskImage = `${fullMask}, ${maskGradients.join(', ')}`;
    darkeningOverlay.style.webkitMaskImage = `${fullMask}, ${maskGradients.join(', ')}`;
    darkeningOverlay.style.maskComposite = 'subtract';
    darkeningOverlay.style.webkitMaskComposite = 'source-out';
    darkeningOverlay.style.maskRepeat = 'no-repeat';
    darkeningOverlay.style.webkitMaskRepeat = 'no-repeat';
    
    console.log(`  ‚úÖ Mask applied with ${brickHoles.length} hole(s)`);
  }
  
  function createLightRay(yPosition, postId = null) {
    const metrics = getEdgeMetrics();
    const rayHeight = metrics.lightRayHeight;
    const rayWidth = metrics.lightRayWidth;
    const topOffset = yPosition - (rayHeight / 2);

    if (postId && lightRaysByPostId.has(postId)) {
      const record = lightRaysByPostId.get(postId);
      const existingRay = record?.element;
      if (existingRay && existingRay.parentNode) {
        console.log(`‚ú® Updating existing light ray for ${postId}`);
        record.y = yPosition;
        existingRay.style.top = `${topOffset}px`;
        existingRay.style.width = `${rayWidth}px`;
        existingRay.style.height = `${rayHeight}px`;
        existingRay.dataset.refPostId = postId;
        pulseLightRay(existingRay, record);
        return existingRay;
      }

      if (record?.fadeTimeout) {
        clearTimeout(record.fadeTimeout);
      }
      lightRaysByPostId.delete(postId);
    }

    console.log(`‚ú® Creating light ray at Y: ${yPosition}${postId ? ` (post ${postId})` : ''}`);

    const ray = document.createElement('div');
    ray.className = 'light-ray';
    ray.style.top = `${topOffset}px`;
    ray.style.width = `${rayWidth}px`;
    ray.style.height = `${rayHeight}px`;
    ray.style.zIndex = '2147483600';
    if (postId) {
      ray.dataset.refPostId = postId;
    }
    document.body.appendChild(ray);

    const record = postId ? { element: ray, y: yPosition, fadeTimeout: null } : null;
    if (record && postId) {
      lightRaysByPostId.set(postId, record);
      const holeRecord = brickHoleByPostId.get(postId);
      if (holeRecord) {
        holeRecord.ray = ray;
      }
    }

    pulseLightRay(ray, record);
    return ray;
  }

  function pulseLightRay(ray, record = null) {
    if (!ray) return;

    if (record?.fadeTimeout) {
      clearTimeout(record.fadeTimeout);
      record.fadeTimeout = null;
    }

    ray.style.opacity = '1';
    ray.style.transition = 'none';
    ray.style.animation = 'none';
    void ray.offsetWidth;
    ray.style.animation = '';

    const timeout = setTimeout(() => {
      if (!ray.parentNode) {
        return;
      }
      ray.style.transition = 'opacity 0.8s ease-out';
      ray.style.opacity = '0.22';
    }, 420);

    if (record) {
      record.fadeTimeout = timeout;
    }
  }
  
  // Gun sound generation
  let gunSoundContext = null;
  let gunSoundIndex = 0;
  const MAX_SYNTHESIZED_SOUNDS = 3; // Use synthesized sounds for first 3 clicks
  
  // Prepared SFX Library - indexed WAV files
  const PREPARED_GUN_SOUNDS = [
    'Prepared SFX Library/1911/A_34P.wav',
    'Prepared SFX Library/1911/A_42P.wav',
    'Prepared SFX Library/1917/B_16P.wav',
    'Prepared SFX Library/1917/B_24P.wav',
    'Prepared SFX Library/AK-47/C_27P.wav',
    'Prepared SFX Library/AK-47/C_28P.wav',
    'Prepared SFX Library/AK-47/C_29P.wav',
    'Prepared SFX Library/AK-47/C_31P.wav',
    'Prepared SFX Library/AK-47/C_34P.wav',
    'Prepared SFX Library/AK-47/C_36P.wav',
    'Prepared SFX Library/AR-15/D_24P.wav',
    'Prepared SFX Library/AR-15/D_32P.wav',
    'Prepared SFX Library/Arisaka/E_18P.wav',
    'Prepared SFX Library/Arisaka/E_25P.wav',
    'Prepared SFX Library/Bersa/F_41P.wav',
    'Prepared SFX Library/Bersa/F_47P.wav',
    'Prepared SFX Library/Carl Gustav M45/G_20P.wav',
    'Prepared SFX Library/Carl Gustav M45/G_22P.wav',
    'Prepared SFX Library/Carl Gustav M45/G_24P.wav',
    'Prepared SFX Library/Carl Gustav M45/G_31P.wav',
    'Prepared SFX Library/Carl Gustav M45/G_33P.wav',
    'Prepared SFX Library/Carl Gustav M45/G_35P.wav',
    'Prepared SFX Library/CD/H_16P.wav',
    'Prepared SFX Library/CD/H_21P.wav',
    'Prepared SFX Library/Marlin 336/I_17P.wav',
    'Prepared SFX Library/Marlin 336/I_22P.wav',
    'Prepared SFX Library/Model 12/K_17P.wav',
    'Prepared SFX Library/Model 12/K_22P.wav',
    'Prepared SFX Library/Model 1894/L_17P.wav',
    'Prepared SFX Library/Model 1894/L_23P.wav',
    'Prepared SFX Library/Mosin Nagant/M_21P.wav',
    'Prepared SFX Library/Mosin Nagant/M_26P.wav',
    'Prepared SFX Library/Mossberg/N_26P.wav',
    'Prepared SFX Library/Mossberg/N_30P.wav',
    'Prepared SFX Library/Nova/O_17P.wav',
    'Prepared SFX Library/Nova/O_21P.wav',
    'Prepared SFX Library/PPSh/P_16P.wav',
    'Prepared SFX Library/PPSh/P_18P.wav',
    'Prepared SFX Library/PPSh/P_22P.wav',
    'Prepared SFX Library/PPSh/P_30P.wav',
    'Prepared SFX Library/PPSh/P_32P.wav',
    'Prepared SFX Library/PPSh/P_34P.wav',
    'Prepared SFX Library/Ruger Mark III/R_30P.wav',
    'Prepared SFX Library/Ruger Mark III/R_35P.wav',
    'Prepared SFX Library/Ruger Single Six/S_11P.wav',
    'Prepared SFX Library/Ruger Single Six/S_14P.wav',
    'Prepared SFX Library/Savage 10 .300 Blackout/T_17P.wav',
    'Prepared SFX Library/Savage 10 .300 Blackout/T_27P.wav',
    'Prepared SFX Library/SKS/U_14P.wav',
    'Prepared SFX Library/SKS/U_19P.wav',
    'Prepared SFX Library/Smith & Wesson 642/V_22P.wav',
    'Prepared SFX Library/Smith & Wesson 642/V_27P.wav',
    'Prepared SFX Library/Tikka/W_24P.wav',
    'Prepared SFX Library/Tikka/W_29P.wav',
    'Prepared SFX Library/Walther PPQ/X_31P.wav',
    'Prepared SFX Library/Walther PPQ/X_39P.wav'
  ];
  
  function playGunSound(clickX, clickY) {
    gunSoundIndex++;
    
    // First 3 clicks: use synthesized cartoony sounds
    if (gunSoundIndex <= MAX_SYNTHESIZED_SOUNDS) {
      playSynthesizedGunSound(gunSoundIndex, clickX, clickY);
    } else {
      // Click 4+: play random WAV from library
      playRandomWavGunSound(clickX, clickY);
    }
  }
  
  function playSynthesizedGunSound(clickNumber, clickX, clickY) {
    const AudioContextClass = window.AudioContext || window.webkitAudioContext;
    if (!AudioContextClass) {
      // Fallback: spawn single bullet even if no audio
      spawnVisualBullet(clickX, clickY, 0, 0);
      return;
    }
    
    if (!gunSoundContext) {
      gunSoundContext = new AudioContextClass();
    } else if (gunSoundContext.state === 'suspended') {
      gunSoundContext.resume().catch(() => {});
    }
    
    const ctx = gunSoundContext;
    const now = ctx.currentTime;
    
    // Progress from cartoony (0) to transitioning (1)
    const progress = Math.min((clickNumber - 1) / MAX_SYNTHESIZED_SOUNDS, 1);
    
    // Create oscillator for main shot
    const shotOsc = ctx.createOscillator();
    const shotGain = ctx.createGain();
    const shotFilter = ctx.createBiquadFilter();
    
    // Cartoony: high pitched "pew pew", gradually deeper
    const startFreq = 800 - (progress * 400); // 800Hz -> 400Hz
    const endFreq = 120 - (progress * 50); // 120Hz -> 70Hz
    
    shotOsc.type = 'square';
    shotOsc.frequency.setValueAtTime(startFreq, now);
    shotOsc.frequency.exponentialRampToValueAtTime(endFreq, now + 0.08);
    
    // Filter
    shotFilter.type = 'lowpass';
    shotFilter.frequency.setValueAtTime(2500 - (progress * 800), now);
    shotFilter.Q.setValueAtTime(1 + (progress * 2), now);
    
    // Volume envelope
    const maxVol = 0.25 + (progress * 0.1);
    shotGain.gain.setValueAtTime(0.0001, now);
    shotGain.gain.exponentialRampToValueAtTime(maxVol, now + 0.005);
    shotGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.08);
    
    shotOsc.connect(shotFilter);
    shotFilter.connect(shotGain);
    shotGain.connect(ctx.destination);
    
    shotOsc.start(now);
    shotOsc.stop(now + 0.15);
    
    // Spawn bullet synchronized with cartoony sound
    spawnVisualBullet(clickX, clickY, 0, 0);
  }
  
  // Weapon burst characteristics - maps weapon types to bullet patterns
  const WEAPON_BURST_PATTERNS = {
    'AK-47': { bullets: 3, delay: 85, spread: 12 },
    'AR-15': { bullets: 2, delay: 90, spread: 10 },
    'PPSh': { bullets: 5, delay: 60, spread: 15 },
    'Carl Gustav M45': { bullets: 3, delay: 80, spread: 11 },
    '1911': { bullets: 1, delay: 0, spread: 0 },
    '1917': { bullets: 1, delay: 0, spread: 0 },
    'Arisaka': { bullets: 1, delay: 0, spread: 0 },
    'Bersa': { bullets: 1, delay: 0, spread: 0 },
    'CD': { bullets: 1, delay: 0, spread: 0 },
    'Marlin 336': { bullets: 1, delay: 0, spread: 0 },
    'Model 12': { bullets: 1, delay: 0, spread: 0 },
    'Model 1894': { bullets: 1, delay: 0, spread: 0 },
    'Mosin Nagant': { bullets: 1, delay: 0, spread: 0 },
    'Mossberg': { bullets: 1, delay: 0, spread: 0 },
    'Nova': { bullets: 1, delay: 0, spread: 0 },
    'Ruger Mark III': { bullets: 1, delay: 0, spread: 0 },
    'Ruger Single Six': { bullets: 1, delay: 0, spread: 0 },
    'Savage 10 .300 Blackout': { bullets: 1, delay: 0, spread: 0 },
    'SKS': { bullets: 2, delay: 95, spread: 8 },
    'Smith & Wesson 642': { bullets: 1, delay: 0, spread: 0 },
    'Tikka': { bullets: 1, delay: 0, spread: 0 },
    'Walther PPQ': { bullets: 1, delay: 0, spread: 0 }
  };
  
  function getWeaponTypeFromPath(soundPath) {
    for (const weaponType in WEAPON_BURST_PATTERNS) {
      if (soundPath.includes(weaponType)) {
        return weaponType;
      }
    }
    return null;
  }
  
  function spawnVisualBullet(clickX, clickY, delay = 0, spread = 0) {
    const actualDelay = delay || 0;
    
    setTimeout(() => {
      console.log(`     üí• Creating visual bullet at (${clickX}, ${clickY}) with spread ${spread}, delay ${actualDelay}ms`);
      
      const bullet = document.createElement('div');
      bullet.className = 'visual-bullet';
      
      // Start just beside cursor, minimal offset for rocket burst effect
      const spreadX = (Math.random() - 0.5) * (spread * 0.3); // Reduce horizontal spread
      const rocketOffsetY = -15 - (Math.random() * 10); // Start 15-25px above cursor
      
      const finalX = clickX + spreadX;
      const finalY = clickY + rocketOffsetY;
      
      bullet.style.cssText = `
        position: fixed;
        left: ${finalX}px;
        top: ${finalY}px;
        width: 20px;
        height: 20px;
        margin-left: -10px;
        margin-top: -10px;
        border-radius: 50%;
        background: radial-gradient(circle, #ffffff, #ffff00 30%, #ff6600);
        box-shadow: 0 0 20px rgba(255, 255, 255, 1), 0 0 40px rgba(255, 255, 0, 0.9), 0 0 60px rgba(255, 100, 0, 0.6);
        z-index: 2147483650;
        pointer-events: none;
        opacity: 1;
        transform: scale(2) translate(-50%, -50%);
        transition: opacity 0.3s ease, transform 0.3s ease;
      `;
      
      document.body.appendChild(bullet);
      console.log(`     ‚úì Bullet element added to DOM at (${finalX.toFixed(0)}, ${finalY.toFixed(0)})`);
      
      // Flash bright then fade
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          bullet.style.opacity = '0';
          bullet.style.transform = 'scale(4) translate(-50%, -50%)';
        });
      });
      
      setTimeout(() => {
        if (bullet.parentNode) {
          bullet.parentNode.removeChild(bullet);
        }
      }, 400);
    }, actualDelay);
  }
  
  function playRandomWavGunSound(clickX, clickY) {
    if (!PREPARED_GUN_SOUNDS.length) {
      console.warn('‚ö†Ô∏è No gun sound WAV files available - falling back to synthesized');
      playSynthesizedGunSound(1, clickX, clickY);
      return;
    }
    
    // Pick a random WAV file
    const randomIndex = Math.floor(Math.random() * PREPARED_GUN_SOUNDS.length);
    const soundPath = PREPARED_GUN_SOUNDS[randomIndex];
    
    console.log(`üî´ Playing ${soundPath}`);
    
    // Determine weapon type and spawn bullets based on pattern
    const weaponType = getWeaponTypeFromPath(soundPath);
    const burstPattern = weaponType ? WEAPON_BURST_PATTERNS[weaponType] : { bullets: 3, delay: 100, spread: 10 };
    
    console.log(`   üéØ Weapon: ${weaponType || 'unknown'}, spawning ${burstPattern.bullets} bullet(s)`);
    
    // Spawn visual bullets based on weapon pattern
    for (let i = 0; i < burstPattern.bullets; i++) {
      const delay = i * burstPattern.delay;
      spawnVisualBullet(clickX, clickY, delay, burstPattern.spread);
    }
    
    // Play the audio with fallback
    const audio = new Audio(soundPath);
    audio.volume = 0.6;
    audio.preload = 'auto';
    
    // Fallback to synthesized sound if file fails to load
    let audioFailed = false;
    audio.addEventListener('error', (error) => {
      if (!audioFailed) {
        audioFailed = true;
        console.warn(`‚ö†Ô∏è Failed to load gun sound ${soundPath}, using synthesized fallback:`, error);
        playSynthesizedGunSound(MAX_SYNTHESIZED_SOUNDS + 1, clickX, clickY);
      }
    }, { once: true });
    
    const playPromise = audio.play();
    if (playPromise && typeof playPromise.catch === 'function') {
      playPromise.catch((error) => {
        if (!audioFailed) {
          audioFailed = true;
          console.warn(`‚ö†Ô∏è Unable to play gun sound ${soundPath}, using synthesized fallback:`, error);
          playSynthesizedGunSound(MAX_SYNTHESIZED_SOUNDS + 1, clickX, clickY);
        }
      });
    }
  }

  function triggerEdgeImpact() {
    // Increment impact count
    impactCount++;
    
    console.log(`\nüí• ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê EDGE IMPACT #${impactCount} ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);
    console.log(`  currentHNView: ${currentHNView}, hnItems.length: ${hnItems.length}`);
    
    // Show HN header bar after first collision (if in HN view)
    if (impactCount === 1 && currentHNView) {
      console.log('  üìä First impact - showing HN wrap');
      showHNWrap();
    }
    
    // Flicker effect
    if (edgeImpact) {
      console.log('  ‚ö° Triggering edgeImpact flash animation');
    edgeImpact.classList.remove('active');
    void edgeImpact.offsetWidth;
    edgeImpact.classList.add('active');
      console.log('     Class added, animation should play for 1200ms');
    
    setTimeout(() => {
      edgeImpact.classList.remove('active');
        console.log('  ‚ö° edgeImpact animation complete');
    }, 1200);
    } else {
      console.error('  ‚úó‚úó‚úó edgeImpact element NOT FOUND!');
    }
    
    // Progressive darkening
    console.log('  üåë Updating darkening level...');
    updateDarkeningLevel();
    
    // Glitch and replace content based on current view (all use same pattern)
    if (currentView === 'hn' && hnItems.length > 0) {
      console.log(`  üî∂ HN view - processing impact ${impactCount}`);
      glitchAndReplaceHNPosts();
    } else if (currentView === 'reddit' && redditItems.length > 0) {
      console.log(`  üî¥ Reddit view - processing impact ${impactCount}`);
      glitchAndReplaceRedditPosts();
    } else if (currentView === 'twitter' && twitterItems.length > 0) {
      console.log(`  üê¶ Twitter view - processing impact ${impactCount}`);
      glitchAndReplaceTwitterPosts();
    } else if (currentView === 'facebook' && facebookItems.length > 0) {
      console.log(`  üìò Facebook view - processing impact ${impactCount}`);
      glitchAndReplaceFacebookPosts();
    } else if (currentView === 'linkedin' && linkedinItems.length > 0) {
      console.log(`  üíº LinkedIn view - processing impact ${impactCount}`);
      glitchAndReplaceLinkedInPosts();
    } else {
      console.log(`  ‚äò No items to glitch (view: ${currentView})`);
    }
    
    // Activate light beam after reaching max impacts
    if (impactCount >= MAX_IMPACTS_BEFORE_BEAM) {
      console.log(`  ‚ú® LIGHT BEAM THRESHOLD REACHED (${impactCount} >= ${MAX_IMPACTS_BEFORE_BEAM})`);
      activateLightBeam();
    } else {
      console.log(`  ‚äô Light beam not yet (${impactCount}/${MAX_IMPACTS_BEFORE_BEAM})`);
    }
    
    console.log(`üí• Impact ${impactCount} complete ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`);
  }
  
  function showHNWrap() {
    const hnWrap = document.querySelector('.hn-wrap');
    if (hnWrap) {
      hnWrap.classList.add('visible');
      console.log('üî∂ HN browser bar revealed');
    }
  }
  
  function hideHNWrap() {
    const hnWrap = document.querySelector('.hn-wrap');
    if (hnWrap) {
      hnWrap.classList.remove('visible');
    }
  }
  
  function findNextIndexForStage(items, getTarget, state) {
    const total = items.length;
    if (total === 0) return -1;

    const order = [];
    for (let i = state.nextIndex; i < total; i++) order.push(i);
    for (let i = 0; i < state.nextIndex; i++) order.push(i);

    for (const idx of order) {
      const candidate = items[idx];
      if (!candidate) continue;
      const target = getTarget(candidate);
      if (!target) continue;

      if (state.stage === 'parody' && !target.classList.contains('parodied')) {
        return idx;
      }

      if (state.stage === 'celli' && !target.classList.contains('celli-ad')) {
        return idx;
      }
    }

    return -1;
  }

  function glitchNextItem(platformKey, items, { getTarget, getContainer = (item) => item, applyParody, applyCelli, logLabel }) {
    if (!items || items.length === 0) return;

    if (!glitchProgress[platformKey]) {
      glitchProgress[platformKey] = createGlitchState();
    }

    const state = glitchProgress[platformKey];

    if (state.stage === 'done') {
      console.log(`  ${logLabel} sequence already complete.`);
      return;
    }

    const nextIndex = findNextIndexForStage(items, getTarget, state);

    if (nextIndex === -1) {
      if (state.stage === 'parody') {
        if (!parodiesComplete) {
          parodiesComplete = true;
          console.log(`\nüéäüéäüéä ALL PARODIES COMPLETE! üéäüéäüéä`);
          console.log(`‚ú® Next clicks will replace with CELLI INVOCATIONS ‚ú®\n`);
        }
        state.stage = 'celli';
        state.nextIndex = 0;
        return glitchNextItem(platformKey, items, { getTarget, getContainer, applyParody, applyCelli, logLabel });
      }

      if (state.stage === 'celli') {
        if (!celliAdsComplete) {
          celliAdsComplete = true;
          console.log(`\n‚ú®‚ú®‚ú® ALL POSTS ARE NOW CELLI INVOCATIONS! ‚ú®‚ú®‚ú®`);
          console.log(`üé™ Animating sidebar from off-screen...\n`);
          animateSidebarEntry();
        }
        state.stage = 'done';
      }
      return;
    }

    const item = items[nextIndex];
    const target = getTarget(item);
    if (!target) {
      state.nextIndex = (nextIndex + 1) % items.length;
      return glitchNextItem(platformKey, items, { getTarget, getContainer, applyParody, applyCelli, logLabel });
    }

    const container = getContainer ? getContainer(item) : item;
    if (container) {
      container.classList.add('glitching');
    }

    setTimeout(() => {
      if (state.stage === 'parody') {
        applyParody(item, target, nextIndex);
      } else if (state.stage === 'celli') {
        applyCelli(item, target, nextIndex);
      }

      if (container) {
        container.classList.remove('glitching');
      }

      console.log(`  ${logLabel} ${nextIndex + 1} ‚Üí ${state.stage.toUpperCase()} update complete.`);
    }, 800);

    state.nextIndex = nextIndex + 1;
  }

  function glitchAndReplaceHNPosts() {
    glitchNextItem('hn', hnItems, {
      getTarget: (item) => item.querySelector('.hn-story-title'),
      getContainer: (item) => item,
      applyParody: (item, target, index) => {
        const newTitle = parodyHeadlines[index % parodyHeadlines.length];
        target.textContent = newTitle;
        target.classList.add('parodied');
        target.setAttribute('data-original-title', newTitle);
        setGlitchLink(target, buildGlitchUrl('hn', 'parody', index));
      },
      applyCelli: (item, target, index) => {
        const newTitle = celliAds[index % celliAds.length];
        target.textContent = newTitle;
        target.classList.add('celli-ad');
        item.classList.add('has-celli-ad');
        target.setAttribute('data-original-title', newTitle);
        setGlitchLink(target, buildGlitchUrl('hn', 'celli', index));
      },
      logLabel: 'üî∂ HN post'
    });
  }

  function glitchAndReplaceRedditPosts() {
    glitchNextItem('reddit', redditItems, {
      getTarget: (item) => item.querySelector('.reddit-title a'),
      getContainer: (item) => item,
      applyParody: (item, target, index) => {
        const newTitle = redditParodies[index % redditParodies.length];
        target.textContent = newTitle;
        target.classList.add('parodied');
        setGlitchLink(target, buildGlitchUrl('reddit', 'parody', index));
      },
      applyCelli: (item, target, index) => {
        const newTitle = celliAds[index % celliAds.length];
        target.textContent = newTitle;
        target.classList.add('celli-ad');
        item.classList.add('has-celli-ad');
        setGlitchLink(target, buildGlitchUrl('reddit', 'celli', index));
      },
      logLabel: 'üî¥ Reddit post'
    });
  }

  function glitchAndReplaceTwitterPosts() {
    glitchNextItem('twitter', twitterItems, {
      getTarget: (item) => item.querySelector('.twitter-text'),
      getContainer: (item) => item,
      applyParody: (item, target, index) => {
        const newText = twitterParodies[index % twitterParodies.length];
        target.textContent = newText;
        target.classList.add('parodied');
        target.setAttribute('data-original-text', newText);
        setGlitchLink(target, buildGlitchUrl('twitter', 'parody', index));
      },
      applyCelli: (item, target, index) => {
        const newText = celliAds[index % celliAds.length];
        target.textContent = newText;
        target.classList.add('celli-ad');
        item.classList.add('has-celli-ad');
        target.setAttribute('data-original-text', newText);
        setGlitchLink(target, buildGlitchUrl('twitter', 'celli', index));
      },
      logLabel: 'üê¶ Tweet'
    });
  }

  function glitchAndReplaceFacebookPosts() {
    glitchNextItem('facebook', facebookItems, {
      getTarget: (item) => item.querySelector('.facebook-post-text'),
      getContainer: (item) => item,
      applyParody: (item, target, index) => {
        const newText = facebookParodies[index % facebookParodies.length];
        target.textContent = newText;
        target.classList.add('parodied');
        target.setAttribute('data-original-text', newText);
        setGlitchLink(target, buildGlitchUrl('facebook', 'parody', index));
      },
      applyCelli: (item, target, index) => {
        const newText = celliAds[index % celliAds.length];
        target.textContent = newText;
        target.classList.add('celli-ad');
        item.classList.add('has-celli-ad');
        target.setAttribute('data-original-text', newText);
        setGlitchLink(target, buildGlitchUrl('facebook', 'celli', index));
      },
      logLabel: 'üìò Facebook post'
    });

  }

  function glitchAndReplaceLinkedInPosts() {
    glitchNextItem('linkedin', linkedinItems, {
      getTarget: (item) => item.querySelector('.linkedin-post-text'),
      getContainer: (item) => item,
      applyParody: (item, target, index) => {
        const newText = linkedinParodies[index % linkedinParodies.length];
        target.textContent = newText;
        target.classList.add('parodied');
        target.setAttribute('data-original-text', newText);
        setGlitchLink(target, buildGlitchUrl('linkedin', 'parody', index));
      },
      applyCelli: (item, target, index) => {
        const newText = celliAds[index % celliAds.length];
        target.textContent = newText;
        target.classList.add('celli-ad');
        item.classList.add('has-celli-ad');
        target.setAttribute('data-original-text', newText);
        setGlitchLink(target, buildGlitchUrl('linkedin', 'celli', index));
      },
      logLabel: 'üíº LinkedIn post'
    });
  }
  
  function animateSidebarEntry() {
    console.log('üé™ üé≠ MYTHIC SIDEBAR ENTRY SEQUENCE INITIATED üé≠ üé™');
    console.log(`üíé Preparing crystalline note with ${brickHoles.length} breach points.`);

    cancelExtraInviteSchedule();
    noteHasEnteredFrame = false;

    clearNoteStageTimeouts();
    stopChantAudio();
    stopAiEnhancedScan();
    resetTriColorLayer();
    noteInteractionLocked = true;
    document.body.classList.remove('ref-note-centered');

    const sidebar = refSidebar;
    const ackBtn = refSidebarAck;
    const h3 = sidebar.querySelector('h3');
    const paragraphs = sidebar.querySelectorAll('p');

    // Hide close button and url during dramatic entrance
    refSidebarClose.style.display = 'none';
    refSidebarUrl.style.display = 'none';

    // Reset sidebar classes and seed crystalline state
    sidebar.classList.remove('active', 'bouncing', 'impact', 'stage-float', 'stage-sweep', 'stage-rumble', 'stage-expand', 'note-hover', 'note-seed');
    sidebar.classList.add('mythic-entrance', 'note-seed');

    if (h3) {
      h3.style.display = 'none';
    }
    paragraphs.forEach(p => p.style.display = 'none');

    noteAwaitingActivation = true;
    noteHoverSequenceStarted = false;
    loomAiMessageActive = false;
    loomFakeAdActive = false;
    noteHasEnteredFrame = false;

    markInviteActive(false);
    ackBtn.setAttribute('aria-label', 'Open Loomworks invitation');
    ackBtn.classList.add('loom-invite-base');
    ackBtn.classList.remove('loom-invite-active');
    ackBtn.innerHTML = BASE_INVITE_TEMPLATE;
    ackBtn.style.background = '';
    ackBtn.style.backdropFilter = '';
    ackBtn.style.webkitBackdropFilter = '';
    ackBtn.style.border = '';
    ackBtn.style.borderRadius = '';
    ackBtn.style.padding = '';
    ackBtn.style.boxShadow = '';
    ackBtn.style.animation = '';
    ackBtn.style.cursor = 'pointer';
    ackBtn.style.transition = 'transform 0.6s ease, opacity 0.6s ease';
    ackBtn.style.opacity = '1';
    ackBtn.style.transform = 'scale(1)';
    ackBtn.style.textAlign = 'left';

    requestAnimationFrame(() => {
      sidebar.classList.add('stage-float');
      startNoteEntryMonitor();
    });

    playChantAudio();

    console.log('  üíé Crystalline note seeded - awaiting tap to awaken.');
  }

  function transformToAltLoomworksInvite() {
    const sidebar = refSidebar;
    const ackBtn = refSidebarAck;

    console.log('‚è±Ô∏è User waited 5 seconds - showing WILLPOWER version');

    // Shrink and fade the ad
    ackBtn.style.transition = 'all 0.5s ease-out';
    ackBtn.style.transform = 'scale(0.3)';
    ackBtn.style.opacity = '0';

    stopBadBooleanTrack();
    triggerTriColorBurst(1.3);

    setTimeout(() => {
      // Show alt LOOMWORKS invitation (willpower version)
      showLoomworksInvite(true); // Pass true for alt/willpower version
    }, 500);
  }
  
  function updateDarkeningLevel() {
    if (!darkeningOverlay) {
      console.error('‚úó darkeningOverlay element not found!');
      return;
    }

    const level = Math.min(impactCount, 5);
    console.log(`  ‚úì Darkening to level: ${level}`);

    if (baseDarkness) {
      baseDarkness.classList.remove('level-1', 'level-2', 'level-3', 'level-4', 'level-5');
      if (level > 0) {
        baseDarkness.classList.add(`level-${level}`);
        baseDarkness.style.opacity = '';
      } else {
        baseDarkness.style.opacity = '0';
      }
    }

    // Calculate target opacity
    const baseOpacity = level * 0.2; // 0.2, 0.4, 0.6, 0.8, 1.0
    const targetOpacity = isMobileViewport()
      ? Math.min(baseOpacity * 0.7, 0.7)
      : baseOpacity;
    
    // Flicker effect - like power going out
    const flickerDuration = Math.max(800 - (impactCount * 100), 200);
    const flickerCount = Math.max(5 - impactCount, 2);
    
    console.log(`  üí° Flickering ${flickerCount} times over ${flickerDuration}ms, target opacity: ${targetOpacity}`);
    
    // Remove all level classes and add flicker
    darkeningOverlay.classList.remove('level-1', 'level-2', 'level-3', 'level-4', 'level-5', 'flickering');
    darkeningOverlay.classList.add('flickering');
    
    // Set CSS variable for flicker animation
    darkeningOverlay.style.setProperty('--flicker-duration', `${flickerDuration}ms`);
    darkeningOverlay.style.setProperty('--flicker-count', flickerCount);
    
    // After flickering, settle into the new darkness level
    setTimeout(() => {
      darkeningOverlay.classList.remove('flickering');
      
    if (level > 0) {
        // Directly set opacity instead of relying on classes
        darkeningOverlay.style.opacity = targetOpacity;
      darkeningOverlay.classList.add(`level-${level}`);
        console.log(`  üåë Settled at darkness level: ${level}, opacity: ${targetOpacity}`);
        console.log(`  üìä Darkening overlay inline style opacity:`, darkeningOverlay.style.opacity);
        console.log(`  üëÅÔ∏è Darkening overlay computed opacity:`, window.getComputedStyle(darkeningOverlay).opacity);
    }
    }, flickerDuration);
  }
  
  function activateLightBeam() {
    if (!lightBeam) {
      console.error('‚úó lightBeam element not found!');
      return;
    }
    
    if (!lightBeam.classList.contains('active')) {
      lightBeam.classList.add('active');
      console.log('‚ú® Light beam activated!');
    }
  }
  
  function deactivateLightBeam() {
    if (lightBeam) {
    lightBeam.classList.remove('active');
    }
  }
  
  function resetImpacts() {
    impactCount = 0;
    parodiesComplete = false;
    celliAdsComplete = false;
    resetGlitchProgress();
    noteAwaitingActivation = false;
    noteHoverSequenceStarted = false;
    loomAiMessageActive = false;
    loomFakeAdActive = false;
    noteHasEnteredFrame = false;
    clearNoteStageTimeouts();
    stopChantAudio();
    darkeningOverlay.classList.remove('level-1', 'level-2', 'level-3', 'level-4', 'level-5', 'flickering');

    // Reset darkening opacity to 0
    if (darkeningOverlay) {
      darkeningOverlay.style.opacity = '0';
      darkeningOverlay.style.maskImage = 'none';
      darkeningOverlay.style.webkitMaskImage = 'none';
    }
    if (baseDarkness) {
      baseDarkness.classList.remove('level-1', 'level-2', 'level-3', 'level-4', 'level-5');
      baseDarkness.style.opacity = '0';
    }
    
    // Clear brick holes
    brickHoles.forEach(hole => {
      if (hole.element && hole.element.parentNode) {
        hole.element.parentNode.removeChild(hole.element);
      }
    });
    brickHoles = [];
    brickHoleByPostId.clear();

    lightRaysByPostId.forEach(record => {
      if (record?.fadeTimeout) {
        clearTimeout(record.fadeTimeout);
      }
    });
    lightRaysByPostId.clear();

    // Clean up light rays
    document.querySelectorAll('.light-ray').forEach(ray => ray.remove());
    document.querySelectorAll('.burst-beam').forEach(beam => beam.remove());
    document.querySelectorAll('.darkening-hole').forEach(hole => hole.remove());
    
    deactivateLightBeam();
    hideHNWrap();
    hideSidebar();
    
    // Reset HN headlines to original
    hnItems.forEach(item => {
      item.classList.remove('glitching', 'has-celli-ad');
      const titleLink = item.querySelector('.hn-story-title');
      if (titleLink) {
        if (titleLink.classList.contains('parodied') || titleLink.classList.contains('celli-ad')) {
          const originalTitle = titleLink.getAttribute('data-original-title');
          if (originalTitle) {
            titleLink.textContent = originalTitle;
            titleLink.classList.remove('parodied', 'celli-ad');
          }
        }
        const originalLink = titleLink.dataset.originalLink || titleLink.getAttribute('href') || '#';
        setGlitchLink(titleLink, originalLink);
      }
    });

    // Reset Reddit posts
    redditItems.forEach(item => {
      item.classList.remove('glitching', 'has-celli-ad');
      const titleLink = item.querySelector('.reddit-title a');
      if (titleLink) {
        if (titleLink.classList.contains('parodied') || titleLink.classList.contains('celli-ad')) {
          const originalTitle = titleLink.getAttribute('data-original-title');
          if (originalTitle) {
            titleLink.textContent = originalTitle;
            titleLink.classList.remove('parodied', 'celli-ad');
          }
        }
        const originalLink = titleLink.dataset.originalLink || titleLink.getAttribute('href') || '#';
        setGlitchLink(titleLink, originalLink);
      }
    });

    // Reset Twitter tweets
    twitterItems.forEach(item => {
      item.classList.remove('glitching', 'has-celli-ad');
      const textEl = item.querySelector('.twitter-text');
      if (textEl) {
        if (textEl.classList.contains('parodied') || textEl.classList.contains('celli-ad')) {
          const originalText = textEl.getAttribute('data-original-text');
          if (originalText) {
            textEl.textContent = originalText;
            textEl.classList.remove('parodied', 'celli-ad');
          }
        }
        const originalLink = textEl.dataset.originalLink || '#';
        setGlitchLink(textEl, originalLink);
      }
    });

    // Reset Facebook posts
    facebookItems.forEach(item => {
      item.classList.remove('glitching', 'has-celli-ad');
      const textEl = item.querySelector('.facebook-post-text');
      if (textEl) {
        if (textEl.classList.contains('parodied') || textEl.classList.contains('celli-ad')) {
          const originalText = textEl.getAttribute('data-original-text');
          if (originalText) {
            textEl.textContent = originalText;
            textEl.classList.remove('parodied', 'celli-ad');
          }
        }
        const originalLink = textEl.dataset.originalLink || '#';
        setGlitchLink(textEl, originalLink);
      }
    });

    // Reset LinkedIn posts
    linkedinItems.forEach(item => {
      item.classList.remove('glitching', 'has-celli-ad');
      const textEl = item.querySelector('.linkedin-post-text');
      if (textEl) {
        if (textEl.classList.contains('parodied') || textEl.classList.contains('celli-ad')) {
          const originalText = textEl.getAttribute('data-original-text');
          if (originalText) {
            textEl.textContent = originalText;
            textEl.classList.remove('parodied', 'celli-ad');
          }
        }
        const originalLink = textEl.dataset.originalLink || '#';
        setGlitchLink(textEl, originalLink);
      }
    });

    cleanupGoldenSequence();

    console.log('üîÑ Impact effects reset - all content restored');
  }
  
  function morphTooltipToSidebar(tooltipElement, sourceElement, options = {}) {
    const chargeDuration = Math.max(0, options.chargeDuration ?? TOOLTIP_CHARGE_DURATION);

    tooltipElement.classList.remove('morphing');
    tooltipElement.classList.add('charging');
    updateActiveTooltipEdgeDistance();

    console.log('üöÄ Tooltip animation primed');
    const collisionTime = Math.round(TOOLTIP_ANIMATION_DURATION * TOOLTIP_COLLISION_RATIO);
    const totalCollisionDelay = chargeDuration + collisionTime;
    console.log(`  Animation: ${TOOLTIP_ANIMATION_DURATION}ms flight + ${chargeDuration}ms charge, collision in ${totalCollisionDelay}ms`);

    const beginFlight = () => {
      tooltipElement.classList.remove('charging');
      tooltipElement.classList.add('morphing');
      updateActiveTooltipEdgeDistance();

      setTimeout(() => {
        console.log(`üí•üí•üí• COLLISION AT EDGE! (${totalCollisionDelay}ms)`);
        console.log(`  Triggering: edgeImpact, particles, darkening, HN glitch, BRICK BREAK`);

        const tooltipRect = tooltipElement.getBoundingClientRect();
        const impactY = tooltipRect.top + (tooltipRect.height / 2);

        console.log(`  üìç Tooltip rect:`, tooltipRect);
        console.log(`  üìç Impact Y position: ${impactY}px`);

        triggerEdgeImpact();
        createImpactParticles(tooltipElement);
        const postId = getPostIdForElement(sourceElement);
        if (postId) {
          console.log(`  üî¢ Impact postId: ${postId}`);
        }
        createBrickHole(impactY, postId);
      }, collisionTime);

      setTimeout(() => {
        tooltipElement.classList.remove('active', 'morphing');
        setTimeout(() => {
          if (tooltipElement.parentNode) {
            tooltipElement.parentNode.removeChild(tooltipElement);
          }
        }, 100);
      }, TOOLTIP_ANIMATION_DURATION + 100);
    };

    if (chargeDuration > 0) {
      setTimeout(beginFlight, chargeDuration);
    } else {
      beginFlight();
    }
  }
  
  function onLinkClick(e, url) {
    e.preventDefault();

    // Capture click position for bullet spawning
    const clickX = e.clientX || (e.target ? e.target.getBoundingClientRect().left : 0);
    const clickY = e.clientY || (e.target ? e.target.getBoundingClientRect().top : 0);

    // Play gun sound immediately on click with position
    playGunSound(clickX, clickY);

    // Hide the hover tooltip
    hideTooltip();

    // Create a NEW independent flying tooltip for this link click
    const linkElement = e.currentTarget || e.target;
    const activeUrl = getCurrentLink(linkElement, url);
    const platform = detectPlatformFromElement(linkElement);
    const sidebarRevealDelay = TOOLTIP_ANIMATION_DURATION + TOOLTIP_CHARGE_DURATION + 200;

    const launchTooltip = () => {
      const flyingTooltip = createFlyingTooltip(activeUrl, linkElement, clickX, clickY);
      morphTooltipToSidebar(flyingTooltip, linkElement, { chargeDuration: TOOLTIP_CHARGE_DURATION });
    };

    if (isPostLink(linkElement)) {
      // Only Facebook gets hearts and prayers
      if (platform === 'facebook') {
        sendHeartsAndPrayers(linkElement, platform);
      }
      launchTooltip();
      runGlitchOnce();
      jitterList(400);
      setTimeout(() => {
        if (impactCount > 0 && impactCount <= 3) {
          showSidebar(activeUrl, true);
        }
      }, sidebarRevealDelay);
      return;
    }

    launchTooltip();
    runGlitchOnce();
    jitterList(400);

    // Show sidebar with impact effect after tooltip splats into edge
    // (Only show after first few impacts - not on every link click)
    setTimeout(() => {
      if (impactCount > 0 && impactCount <= 3) {
        showSidebar(activeUrl, true);
      }
    }, sidebarRevealDelay);
  }
  
  function renderItems(items, platformType) {
    console.log(`\nüìù ‚ïê‚ïê‚ïê renderItems START ‚ïê‚ïê‚ïê`);
    console.log(`  Platform: ${platformType}`);
    console.log(`  Items: ${items.length}`);
    console.log(`  First item:`, items[0]);
    
    try {
      refList.innerHTML = '';
      hnItems = [];
      redditItems = [];
      twitterItems = [];
      facebookItems = [];
      linkedinItems = [];
      currentView = platformType;
      currentHNView = (platformType === 'hn');
      parodiesComplete = false;
      celliAdsComplete = false;
      resetGlitchProgress(platformType);
      
      console.log(`  Cleared refList, set currentView=${currentView}`);
    
    if (platformType === 'hn') {
      console.log('  üî∂ Rendering HN view');
      refList.className = 'ref-list hn-style';
      
      const wrap = document.createElement('div');
      wrap.className = 'hn-wrap';
      wrap.innerHTML = `
        <div class="hn-top">
          <span class="hn-logo"></span>
          <span class="hn-title">Hacker News</span>
          <div class="hn-nav">
            <a href="#">new</a> | <a href="#">past</a> | <a href="#">comments</a> | <a href="#">ask</a> | <a href="#">show</a> | <a href="#">jobs</a> | <a href="#">submit</a>
          </div>
        </div>
      `;
      refList.appendChild(wrap);
      
      const content = document.createElement('div');
      content.className = 'hn-content';
      
      items.slice(0, 30).forEach((it, idx) => {
        const itemDiv = document.createElement('div');
        itemDiv.className = 'hn-item';
        const postId = `hn-${idx}`;
        itemDiv.dataset.refPostId = postId;
        itemDiv.style.opacity = '0';
        
        const rank = idx + 1;
        const domain = it.domain || '';
        const score = it.score || 0;
        const by = it.by || 'unknown';
        const time = it.time || 'moments ago';
        const comments = it.descendants || 0;
        
        itemDiv.innerHTML = `
          <div class="hn-rank">${rank}.</div>
          <div class="hn-vote"><div class="hn-vote-arrow"></div></div>
          <div class="hn-main">
            <div class="hn-titleline">
              <a class="hn-story-title" href="#" data-original-title="${escapeHtml(it.title || '(untitled)')}">${escapeHtml(it.title || '(untitled)')}</a>
              ${domain ? `<span class="hn-sitebit">(<a href="#">${escapeHtml(domain)}</a>)</span>` : ''}
            </div>
            <div class="hn-subtext">
              ${score} points by <a href="#">${escapeHtml(by)}</a> ${escapeHtml(time)} | <a href="#">hide</a> | <a href="#">${comments} comments</a>
            </div>
          </div>
        `;

        itemDiv.querySelectorAll('a').forEach(anchor => {
          anchor.dataset.refPostId = postId;
        });
        
        const link = itemDiv.querySelector('.hn-story-title');
        const originalLink = it.link || '#';
        setGlitchLink(link, originalLink);
        link.dataset.originalLink = originalLink;
        // HN gets tooltips on hover
        link.addEventListener('mouseenter', () => showTooltip(getCurrentLink(link, originalLink), link));
        link.addEventListener('mouseleave', () => {
          if (!refTooltip.classList.contains('morphing')) hideTooltip();
        });
        link.addEventListener('click', (e) => onLinkClick(e, getCurrentLink(link, originalLink)));

        itemDiv.querySelectorAll('.hn-subtext a, .hn-sitebit a').forEach(a => {
          const href = a.getAttribute('href') || '#';
          setGlitchLink(a, href);
          a.dataset.originalLink = href;
          // HN gets tooltips on hover
          a.addEventListener('mouseenter', () => showTooltip(getCurrentLink(a, href), a));
          a.addEventListener('mouseleave', () => {
            if (!refTooltip.classList.contains('morphing')) hideTooltip();
          });
          a.addEventListener('click', (e) => onLinkClick(e, getCurrentLink(a, href)));
        });
        
        content.appendChild(itemDiv);
        hnItems.push(itemDiv);
      });
      
      console.log(`  ‚úì Added ${hnItems.length} HN items to hnItems array`);
      
      const spacer = document.createElement('div');
      spacer.className = 'hn-spacer';
      content.appendChild(spacer);
      
      refList.appendChild(content);
    } else if (platformType === 'reddit') {
      // Classic Reddit layout
      console.log('  üî¥ Rendering Reddit view');
      refList.className = 'ref-list reddit-style';
      
      const header = document.createElement('div');
      header.className = 'reddit-header';
      header.innerHTML = `
        <div class="reddit-logo">reddit</div>
        <div class="reddit-nav">
          <a href="#">hot</a> | <a href="#">new</a> | <a href="#">rising</a> | <a href="#">controversial</a> | <a href="#">top</a> | <a href="#">gilded</a> | <a href="#">wiki</a>
        </div>
      `;
      refList.appendChild(header);
      
      const content = document.createElement('div');
      content.className = 'reddit-content';
      
      items.slice(0, 24).forEach((it, idx) => {
        const postDiv = document.createElement('div');
        postDiv.className = 'reddit-post';
        const postId = `reddit-${idx}`;
        postDiv.dataset.refPostId = postId;
        postDiv.style.opacity = '0';
        
        const score = Math.floor(Math.random() * 5000) + 100;
        const subreddit = it.subreddit || 'r/all';
        const author = it.author || 'anonymous';
        const comments = Math.floor(Math.random() * 500);
        
        postDiv.innerHTML = `
          <div class="reddit-vote">
            <div class="reddit-arrow up"></div>
            <div class="reddit-score">${score}</div>
            <div class="reddit-arrow down"></div>
          </div>
          <div class="reddit-thumbnail broken-image"></div>
          <div class="reddit-main">
            <div class="reddit-title">
              <a href="#">${escapeHtml(it.title || '(untitled)')}</a>
              <span class="reddit-domain">(${it.domain || 'self.reddit'})</span>
            </div>
            <div class="reddit-meta">
              submitted by <a href="#">${escapeHtml(author)}</a> to <a href="#" class="reddit-subreddit">${escapeHtml(subreddit)}</a>
            </div>
            <div class="reddit-meta">
              <a href="#">${comments} comments</a> | <a href="#">share</a> | <a href="#">save</a> | <a href="#">hide</a> | <a href="#">report</a>
            </div>
          </div>
        `;

        postDiv.querySelectorAll('a').forEach(anchor => {
          anchor.dataset.refPostId = postId;
        });
        
        const link = postDiv.querySelector('.reddit-title a');
        const originalLink = it.link || '#';
        setGlitchLink(link, originalLink);
        link.dataset.originalLink = originalLink;
        // Reddit: no tooltip on hover, only click action
        link.addEventListener('click', (e) => onLinkClick(e, getCurrentLink(link, originalLink)));
        
        content.appendChild(postDiv);
        redditItems.push(postDiv);
      });
      
      refList.appendChild(content);
    } else if (platformType === 'twitter') {
      // Zeed (Modern X layout)
      console.log('  üê¶ Rendering Zeed view');
      refList.className = 'ref-list twitter-style';
      
      // Left sidebar
      const sidebar = document.createElement('div');
      sidebar.className = 'twitter-sidebar';
      sidebar.innerHTML = `
        <div class="twitter-logo">Zeed</div>
        <div class="twitter-nav-item">üè† Home</div>
        <div class="twitter-nav-item">üîç Explore</div>
        <div class="twitter-nav-item">üîî Notifications</div>
        <div class="twitter-nav-item">‚úâÔ∏è Messages</div>
        <div class="twitter-nav-item">üîñ Bookmarks</div>
        <div class="twitter-nav-item">üë§ Profile</div>
        <button class="twitter-post-btn">Post</button>
      `;
      refList.appendChild(sidebar);
      
      // Center feed
      const feed = document.createElement('div');
      feed.className = 'twitter-feed';
      
      // Feed header with tabs
      const feedHeader = document.createElement('div');
      feedHeader.className = 'twitter-feed-header';
      feedHeader.innerHTML = `
        <div class="twitter-tab active">For you</div>
        <div class="twitter-tab">Following</div>
      `;
      feed.appendChild(feedHeader);
      
      // Compose box
      const compose = document.createElement('div');
      compose.className = 'twitter-compose';
      compose.innerHTML = `
        <div class="twitter-avatar"></div>
        <input type="text" class="twitter-compose-input" placeholder="It's about to get nuts." />
      `;
      feed.appendChild(compose);
      
      // Tweets
      const content = document.createElement('div');
      content.className = 'twitter-content';
      
      items.forEach((it, idx) => {
        const tweet = document.createElement('div');
        tweet.className = 'twitter-tweet';
        const postId = `twitter-${idx}`;
        tweet.dataset.refPostId = postId;
        tweet.style.opacity = '0';
        
        tweet.innerHTML = `
          <div class="twitter-avatar"></div>
          <div class="twitter-tweet-content">
            <div>
              <span class="twitter-user">${escapeHtml(it.user)}</span><span class="twitter-handle">@${escapeHtml(it.handle)}</span><span class="twitter-time"> ¬∑ ${Math.floor(Math.random() * 12) + 1}h</span>
            </div>
            <div class="twitter-text" data-original-text="${escapeHtml(it.text)}">${escapeHtml(it.text)}</div>
            <div class="twitter-actions">
              <span class="twitter-action">üí¨ ${Math.floor(Math.random() * 500)}</span>
              <span class="twitter-action">üîÅ ${Math.floor(Math.random() * 2000)}</span>
              <span class="twitter-action">‚ô• ${Math.floor(Math.random() * 5000)}</span>
              <span class="twitter-action">üìä</span>
            </div>
          </div>
        `;

        tweet.querySelectorAll('a').forEach(anchor => {
          anchor.dataset.refPostId = postId;
        });

        const textEl = tweet.querySelector('.twitter-text');
        if (textEl) {
          textEl.dataset.refPostId = postId;
          const originalLink = it.link || '#';
          setGlitchLink(textEl, originalLink);
          textEl.dataset.originalLink = originalLink;
          // Twitter: no tooltip on hover, only click action
          textEl.addEventListener('click', (e) => onLinkClick(e, getCurrentLink(textEl, originalLink)));
        }
        
        content.appendChild(tweet);
        twitterItems.push(tweet);
      });
      
      feed.appendChild(content);
      refList.appendChild(feed);
      
      // Right panel with widgets
      const rightPanel = document.createElement('div');
      rightPanel.className = 'twitter-right-panel';
      rightPanel.innerHTML = `
        <div class="twitter-widget">
          <div class="twitter-widget-title">What's happening</div>
          <div class="twitter-trend">
            <div class="twitter-trend-category">Trending in Tech</div>
            <div class="twitter-trend-name">Celli</div>
            <div class="twitter-trend-posts">847K posts</div>
          </div>
          <div class="twitter-trend">
            <div class="twitter-trend-category">Technology ¬∑ Trending</div>
            <div class="twitter-trend-name">Spreadsheets</div>
            <div class="twitter-trend-posts">92.4K posts</div>
          </div>
          <div class="twitter-trend">
            <div class="twitter-trend-category">Development ¬∑ Trending</div>
            <div class="twitter-trend-name">VoxelCalc</div>
            <div class="twitter-trend-posts">34.2K posts</div>
          </div>
        </div>
      `;
      refList.appendChild(rightPanel);
      
      console.log(`  ‚úì Rendered ${items.length} tweets with modern X layout`);
      
    } else if (platformType === 'facebook') {
      // Facebook with Messenger
      console.log('  üìò Rendering Facebook view');
      refList.className = 'ref-list facebook-style';

      const header = document.createElement('div');
      header.className = 'facebook-header';
      header.innerHTML = `
        <div class="facebook-logo">facebook</div>
        <input type="text" class="facebook-search" placeholder="Search Facebook" />
      `;
      refList.appendChild(header);
      
      const feed = document.createElement('div');
      feed.className = 'facebook-feed';
      
      items.forEach((it, idx) => {
        const post = document.createElement('div');
        post.className = 'facebook-post';
        const postId = `facebook-${idx}`;
        post.dataset.refPostId = postId;
        post.style.opacity = '0';
        
        post.innerHTML = `
          <div class="facebook-post-header">
            <div class="facebook-avatar"></div>
            <div>
              <div class="facebook-user">${escapeHtml(it.user)}</div>
              <div class="facebook-time">${it.time}</div>
            </div>
          </div>
          <div class="facebook-post-text" data-original-text="${escapeHtml(it.text)}">${escapeHtml(it.text)}</div>
          <div class="facebook-actions">
            <div class="facebook-action">üëç Like</div>
            <div class="facebook-action">üí¨ Comment</div>
            <div class="facebook-action">‚Üó Share</div>
          </div>
        `;

        post.querySelectorAll('a').forEach(anchor => {
          anchor.dataset.refPostId = postId;
        });

        const textEl = post.querySelector('.facebook-post-text');
        if (textEl) {
          textEl.dataset.refPostId = postId;
          const originalLink = it.link || '#';
          setGlitchLink(textEl, originalLink);
          textEl.dataset.originalLink = originalLink;
          // Facebook: no tooltip on hover, only click action
          textEl.addEventListener('click', (e) => onLinkClick(e, getCurrentLink(textEl, originalLink)));
        }
        
        feed.appendChild(post);
        facebookItems.push(post);
      });
      
      refList.appendChild(feed);
      
      // Messenger sidebar
      const messenger = document.createElement('div');
      messenger.className = 'facebook-messenger';
      messenger.innerHTML = `
        <div class="messenger-header">Messenger</div>
        <div class="messenger-contact">
          <div class="messenger-avatar"></div>
          <div>
            <div class="messenger-name">Celli Bot</div>
            <div class="messenger-preview">Have you tried Celli yet?</div>
          </div>
        </div>
        <div class="messenger-contact">
          <div class="messenger-avatar"></div>
          <div>
            <div class="messenger-name">Your Future Self</div>
            <div class="messenger-preview">Why haven't you tried Celli??</div>
          </div>
        </div>
        <div class="messenger-contact">
          <div class="messenger-avatar"></div>
          <div>
            <div class="messenger-name">The Simulation Admin</div>
            <div class="messenger-preview">Celli is the answer</div>
          </div>
        </div>
      `;
      refList.appendChild(messenger);
      console.log(`  ‚úì Rendered ${items.length} posts + Messenger`);
    } else if (platformType === 'linkedin') {
      console.log('  üíº Rendering LinkedIn view');
      refList.className = 'ref-list linkedin-style';

      const sidebar = document.createElement('div');
      sidebar.className = 'linkedin-sidebar';
      sidebar.innerHTML = `
        <div class="linkedin-card">
          <h4>Quick Actions</h4>
          <div class="linkedin-action">‚ú® Celebrate a teammate</div>
          <div class="linkedin-action">üìù Draft a humblebrag</div>
          <div class="linkedin-action">ü§ù Endorse soft skills</div>
        </div>
        <div class="linkedin-card">
          <h4>Who's viewed your vibe</h4>
          <div>People managers ¬∑ Curious optimists</div>
        </div>
      `;
      refList.appendChild(sidebar);

      const feed = document.createElement('div');
      feed.className = 'linkedin-feed';

      items.forEach((it) => {
        const post = document.createElement('div');
        post.className = 'linkedin-post';
        post.style.opacity = '0';

        const initials = (it.user || '?').split(' ').map((part) => part[0]).join('').slice(0, 2).toUpperCase();

        post.innerHTML = `
          <div class="linkedin-post-header">
            <div class="linkedin-avatar">${escapeHtml(initials)}</div>
            <div class="linkedin-header-text">
              <div class="linkedin-user">${escapeHtml(it.user || 'LinkedIn Member')}</div>
              <div class="linkedin-headline">${escapeHtml(it.headline || '')}</div>
              <div class="linkedin-time">${escapeHtml(it.time || '')}</div>
            </div>
            <button class="linkedin-follow">+ Follow</button>
          </div>
          <div class="linkedin-post-text" data-original-text="${escapeHtml(it.text)}">${escapeHtml(it.text)}</div>
          <div class="linkedin-post-footer">
            <span>üëè Celebrate</span>
            <span>üí¨ Comment</span>
            <span>üîÅ Repost</span>
            <span>‚úâÔ∏è Send</span>
          </div>
        `;

        const textEl = post.querySelector('.linkedin-post-text');
        if (textEl) {
          const originalLink = it.link || '#';
          setGlitchLink(textEl, originalLink);
          textEl.dataset.originalLink = originalLink;
          // LinkedIn: no tooltip on hover, only click action
          textEl.addEventListener('click', (e) => onLinkClick(e, getCurrentLink(textEl, originalLink)));
        }

        feed.appendChild(post);
        linkedinItems.push(post);
      });

      refList.appendChild(feed);

      const right = document.createElement('div');
      right.className = 'linkedin-right';
      right.innerHTML = `
        <div class="linkedin-card">
          <h4>Trending Courses</h4>
          <div>‚Ä¢ Authentic Synergy 101</div>
          <div>‚Ä¢ Async Gratitude Rituals</div>
          <div>‚Ä¢ KPI Karaoke: Find Your Metric</div>
        </div>
        <div class="linkedin-card">
          <h4>People also viewed</h4>
          <div>üß† AI Whisperer ¬∑ Hiring</div>
          <div>ü™¥ Plant-Based Scrum Master</div>
          <div>üöÄ Fractional Vibes Consultant</div>
        </div>
      `;
      refList.appendChild(right);

      console.log(`  ‚úì Rendered ${items.length} LinkedIn posts`);
    }
    
    console.log(`üìù ‚ïê‚ïê‚ïê renderItems COMPLETE ‚ïê‚ïê‚ïê`);
    console.log(`  currentView=${currentView}, hnItems=${hnItems.length}, redditItems=${redditItems.length}, twitterItems=${twitterItems.length}, facebookItems=${facebookItems.length}, linkedinItems=${linkedinItems.length}\n`);
    
    } catch (error) {
      console.error(`‚ùå‚ùå‚ùå ERROR in renderItems:`, error);
      console.error(`Stack:`, error.stack);
      console.error(`Platform: ${platformType}, Items:`, items);
      throw error;
    }
  }
  
  function stagedReveal(platformType) {
    console.log(`\n‚ú® ‚ïê‚ïê‚ïê stagedReveal START ‚ïê‚ïê‚ïê`);
    console.log(`  Platform: ${platformType}`);
    
    if (platformType === 'hn') {
      // HN: Load all simultaneously
      const items = refList.querySelectorAll('.hn-item');
      console.log(`  Found ${items.length} .hn-item elements`);
      items.forEach((n) => {
        n.style.transition = 'opacity .3s ease';
        n.style.opacity = '1';
      });
      console.log(`  ‚úì All ${items.length} HN items revealed simultaneously`);
    } else if (platformType === 'reddit') {
      const posts = refList.querySelectorAll('.reddit-post');
      console.log(`  Found ${posts.length} .reddit-post elements`);
      posts.forEach((n, idx) => {
        setTimeout(() => {
          n.style.transition = 'opacity .25s ease';
          n.style.opacity = '1';
        }, 50 + idx * 30);
      });
      console.log(`  ‚úì Staged ${posts.length} Reddit posts`);
    } else if (platformType === 'twitter') {
      const tweets = refList.querySelectorAll('.twitter-tweet');
      console.log(`  Found ${tweets.length} .twitter-tweet elements`);
      tweets.forEach((n, idx) => {
        setTimeout(() => {
          n.style.transition = 'opacity .2s ease';
          n.style.opacity = '1';
        }, 40 + idx * 25);
      });
      console.log(`  ‚úì Staged ${tweets.length} tweets`);
    } else if (platformType === 'facebook') {
      const posts = refList.querySelectorAll('.facebook-post');
      console.log(`  Found ${posts.length} .facebook-post elements`);
      posts.forEach((n, idx) => {
        setTimeout(() => {
          n.style.transition = 'opacity .3s ease';
          n.style.opacity = '1';
        }, 60 + idx * 35);
      });
      console.log(`  ‚úì Staged ${posts.length} Facebook posts`);
    } else if (platformType === 'linkedin') {
      const posts = refList.querySelectorAll('.linkedin-post');
      console.log(`  Found ${posts.length} .linkedin-post elements`);
      posts.forEach((n, idx) => {
        setTimeout(() => {
          n.style.transition = 'opacity .3s ease';
          n.style.opacity = '1';
        }, 55 + idx * 30);
      });
      console.log(`  ‚úì Staged ${posts.length} LinkedIn posts`);
    } else {
      console.warn(`  Unknown platform type: ${platformType}`);
    }
    
    console.log(`‚ú® ‚ïê‚ïê‚ïê stagedReveal COMPLETE ‚ïê‚ïê‚ïê\n`);
  }
  
  function jitterList(durationMs = 600) {
    refList.classList.add('jitter');
    setTimeout(() => refList.classList.remove('jitter'), durationMs);
  }
  
  function runGlitchOnce() {
    refGlitch.innerHTML = '';
    const rows = 7;
    for (let i = 0; i < rows; i++) {
      const slice = document.createElement('div');
      slice.className = 'slice';
      slice.style.top = `${(i * (100 / rows))}%`;
      slice.style.height = `${100 / rows}%`;
      const row = document.createElement('div');
      row.className = 'row ' + (i % 3 === 0 ? 'glitch-r' : i % 3 === 1 ? 'glitch-g' : 'glitch-b');
      row.innerHTML = `
        <div class="ref-header"></div>
        <div class="ref-list"></div>
        <div class="ref-footer"></div>
      `;
      const offset = (i % 2 ? 8 : -8);
      row.style.transform = `translateX(${offset}px)`;
      slice.appendChild(row);
      refGlitch.appendChild(slice);
    }
    
    let t = 0;
    const id = setInterval(() => {
      const rowsEls = refGlitch.querySelectorAll('.row');
      rowsEls.forEach((r, idx) => {
        const off = Math.round(Math.sin((t + idx * 3) / 2) * (idx % 2 ? 10 : -10));
        r.style.transform = `translateX(${off}px)`;
      });
      t++;
    }, 70);
    setTimeout(() => { clearInterval(id); refGlitch.innerHTML = ''; }, 3200);
  }
  
  /* === Data sources === */
  
  async function fetchHNSnapshot(refUrl) {
    const id = parseHNItemId(refUrl);
    if (id) {
      const item = await hnItem(id);
      const list = [hnFormatItem(item)];
      const top = await hnTop(29);
      top.filter(x => x.id !== id).slice(0, 29).forEach(x => list.push(hnFormatItem(x)));
      return list;
    } else {
      const top = await hnTop(30);
      return top.map(hnFormatItem);
    }
  }
  
  function hnFormatItem(item) {
    const domain = item.url ? extractDomain(item.url) : '';
    const time = formatHNTime(item.time);
    return {
      id: item.id,
      title: item.title || '(untitled)',
      link: item.url || `https://news.ycombinator.com/item?id=${item.id}`,
      domain: domain,
      score: item.score || 0,
      by: item.by || 'unknown',
      time: time,
      descendants: item.descendants || 0
    };
  }
  
  function extractDomain(url) {
    try {
      const u = new URL(url);
      return u.hostname.replace(/^www\./, '');
    } catch {
      return '';
    }
  }
  
  function formatHNTime(timestamp) {
    if (!timestamp) return 'moments ago';
    const now = Math.floor(Date.now() / 1000);
    const diff = now - timestamp;
    
    if (diff < 60) return 'just now';
    if (diff < 3600) return `${Math.floor(diff / 60)} minutes ago`;
    if (diff < 86400) return `${Math.floor(diff / 3600)} hours ago`;
    return `${Math.floor(diff / 86400)} days ago`;
  }
  
  function parseHNItemId(u) {
    try {
      const url = new URL(u);
      if (!/news\.ycombinator\.com/.test(url.hostname)) return null;
      return Number(url.searchParams.get('id')) || null;
    } catch {
      return null;
    }
  }
  
  async function hnItem(id) {
    const r = await fetch(`https://hacker-news.firebaseio.com/v0/item/${id}.json`);
    if (!r.ok) throw new Error('hn item');
    return r.json();
  }
  
  async function hnTop(n = 30) {
    const r = await fetch('https://hacker-news.firebaseio.com/v0/topstories.json');
    if (!r.ok) throw new Error('hn top');
    const ids = (await r.json()).slice(0, n);
    const items = await Promise.all(ids.map(hnItem));
    return items.filter(Boolean);
  }
  
  async function fetchRedditSnapshot(refUrl) {
    let endpoint = 'https://www.reddit.com/r/all.json?limit=24';
    try {
      if (refUrl) {
        let u;
        if (refUrl.startsWith('http')) {
          u = new URL(refUrl);
        } else {
          u = new URL('https://www.reddit.com' + (refUrl.startsWith('/') ? refUrl : '/' + refUrl));
        }
        
        let path = u.pathname;
        if (path.endsWith('/')) path = path.slice(0, -1);
        endpoint = `https://www.reddit.com${path}.json?limit=24&raw_json=1`;
      }
    } catch (e) {
      console.warn('Reddit URL parse error:', e);
    }
    
    console.log('Fetching Reddit - skipping slow proxies, using mock data immediately');
    
    // Skip slow proxy attempts - go straight to mock data for fast loading
    console.log('‚ö° Using instant mock Reddit data');
    return [
      { title: 'TIL that the "faux Reddit" feature uses CORS proxies to bypass browser restrictions', link: 'https://reddit.com', subreddit: 'r/todayilearned', author: 'developer', domain: 'self.reddit' },
      { title: 'This is mock data because Reddit blocked the API request', link: 'https://reddit.com', subreddit: 'r/programming', author: 'cors_warrior', domain: 'self.reddit' },
      { title: 'PSA: Reddit\'s JSON API now requires authentication for most endpoints', link: 'https://reddit.com', subreddit: 'r/webdev', author: 'api_user', domain: 'self.reddit' },
      { title: 'I built a referrer overlay system with glitch effects', link: 'https://reddit.com', subreddit: 'r/webdev', author: 'creative_dev', domain: 'self.reddit' },
      { title: 'When your CORS proxy times out but you still want to show something', link: 'https://reddit.com', subreddit: 'r/ProgrammerHumor', author: 'fallback_king', domain: 'self.reddit' },
      { title: 'Real-time web scraping challenges in 2025', link: 'https://reddit.com', subreddit: 'r/programming', author: 'tech_writer', domain: 'self.reddit' },
      { title: 'AITA for automating my entire workflow and not telling my boss?', link: 'https://reddit.com', subreddit: 'r/AmItheAsshole', author: 'efficiency_king', domain: 'self.reddit' },
      { title: '[AskReddit] What screams "I peaked in the tutorial"?', link: 'https://reddit.com', subreddit: 'r/AskReddit', author: 'forever_junior', domain: 'self.reddit' },
      { title: 'TIL the average developer spends 90% of their time googling and 10% pretending they didn\'t', link: 'https://reddit.com', subreddit: 'r/todayilearned', author: 'stack_overflow_user', domain: 'self.reddit' },
      { title: 'My startup failed but at least I got some karma', link: 'https://reddit.com', subreddit: 'r/Entrepreneur', author: 'reformed_founder', domain: 'self.reddit' },
      { title: '[Shower Thoughts] Maybe the real MVP was the friends we made in Slack channels', link: 'https://reddit.com', subreddit: 'r/Showerthoughts', author: 'deep_thinker', domain: 'self.reddit' },
      { title: 'ELI5: How is the cloud not just someone else\'s computer?', link: 'https://reddit.com', subreddit: 'r/explainlikeimfive', author: 'confused_newbie', domain: 'self.reddit' },
      { title: 'LPT: Close all 47 Stack Overflow tabs before the standup meeting', link: 'https://reddit.com', subreddit: 'r/LifeProTips', author: 'pro_developer', domain: 'self.reddit' },
      { title: 'My code passed all tests but broke production. AMA', link: 'https://reddit.com', subreddit: 'r/programming', author: 'incident_manager', domain: 'self.reddit' },
      { title: 'TIFU by pushing directly to main on Friday at 4:59 PM', link: 'https://reddit.com', subreddit: 'r/tifu', author: 'weekend_ruiner', domain: 'self.reddit' },
      { title: 'Unpopular opinion: Writing documentation is actually harder than writing code', link: 'https://reddit.com', subreddit: 'r/unpopularopinion', author: 'doc_writer', domain: 'self.reddit' },
      { title: 'CMV: Dark mode is just light mode for people who pretend to be hackers', link: 'https://reddit.com', subreddit: 'r/changemyview', author: 'theme_warrior', domain: 'self.reddit' },
      { title: 'DAE feel personally attacked when their code gets refactored?', link: 'https://reddit.com', subreddit: 'r/DoesAnybodyElse', author: 'sensitive_dev', domain: 'self.reddit' },
      { title: '[Discussion] At what point did we normalize 15 npm packages for a hello world app?', link: 'https://reddit.com', subreddit: 'r/webdev', author: 'minimalist_dev', domain: 'self.reddit' },
      { title: 'My rubber duck quit. Where can I hire a new debugging assistant?', link: 'https://reddit.com', subreddit: 'r/ProgrammerHumor', author: 'lonely_coder', domain: 'self.reddit' },
      { title: 'TIL that "works on my machine" is not an acceptable debugging strategy', link: 'https://reddit.com', subreddit: 'r/todayilearned', author: 'learning_slowly', domain: 'self.reddit' },
      { title: 'Is anyone else just Googling things and pretending to know what they\'re doing?', link: 'https://reddit.com', subreddit: 'r/cscareerquestions', author: 'imposter_syndrome', domain: 'self.reddit' },
      { title: '[Meta] This sub has more junior devs asking questions than senior devs answering them', link: 'https://reddit.com', subreddit: 'r/learnprogramming', author: 'meta_observer', domain: 'self.reddit' },
      { title: 'Just spent 6 hours optimizing code that runs once a week. Worth it.', link: 'https://reddit.com', subreddit: 'r/programming', author: 'premature_optimizer', domain: 'self.reddit' }
    ];
  }
  
  async function fetchTwitterSnapshot(refUrl) {
    console.log('üê¶ fetchTwitterSnapshot - generating mock tweets for Zeed');
    const tweets = [
      { user: 'Cilon Dusk', handle: 'cilondusk', text: 'Congratulations to @SpaceXX on their first all-woman shuttle disaster. My heart will go on. üöÄüíî', link: '#' },
      { user: 'Food Pleaser', handle: 'foodpleaser', text: 'Well, can you name one? ü§∑', link: '#' },
      { user: 'TechCrunch', handle: 'techcrunch', text: 'Breaking: New AI model achieves 99.9% accuracy (on training data)', link: '#' },
      { user: 'GitHub', handle: 'github', text: 'Ship code faster with GitHub Copilot. Now with 100% more hallucinations!', link: '#' },
      { user: 'Vercel', handle: 'vercel', text: 'Deploy your app in milliseconds. Debug it for hours. ‚ö°', link: '#' },
      { user: 'DHH', handle: 'dhh', text: 'Hot take: Maybe we don\'t need 47 JavaScript frameworks for a contact form', link: '#' },
      { user: 'Theo', handle: 't3dotgg', text: 'Me: *writes clean code* // The PR reviewer: "Have you considered rewriting this from scratch?"', link: '#' },
      { user: 'Fireship', handle: 'fireship_dev', text: 'New framework just dropped. Learn it in 100 seconds before it\'s deprecated.', link: '#' },
      { user: 'Coding Garden', handle: 'coding_garden', text: 'Live coding session: Building a TODO app for the 847th time üå±', link: '#' },
      { user: 'JavaScript', handle: 'javascript', text: 'const bugs = "features"; // This is fine üî•', link: '#' },
      { user: 'TypeScript', handle: 'typescript', text: 'You can\'t have runtime errors if you have compile-time errors *taps head*', link: '#' },
      { user: 'Stack Overflow', handle: 'stackoverflow', text: 'Question marked as duplicate. The original question is from 2009 and doesn\'t help. Good luck!', link: '#' },
      { user: 'npm', handle: 'npmjs', text: 'node_modules weighs more than a black hole but at least your build works', link: '#' },
      { user: 'React', handle: 'reactjs', text: 'useEffect(() => { console.log("why did this run 47 times"); }, []);', link: '#' },
      { user: 'Tailwind CSS', handle: 'tailwindcss', text: 'className="flex items-center justify-between p-4 rounded-lg shadow-md hover:shadow-lg transition-all duration-200 ease-in-out bg-gradient-to-r from-blue-500 to-purple-600"', link: '#' },
      { user: 'VS Code', handle: 'code', text: 'New extension: "Closes all your tabs when you\'re about to do something productive"', link: '#' },
      { user: 'Mozilla', handle: 'mozilla', text: 'Firefox is like that indie band you swear is better but nobody else listens to', link: '#' },
      { user: 'Chrome DevTools', handle: 'chromedevtools', text: 'console.log("debugging is just printf debugging with extra steps")', link: '#' },
      { user: 'Docker', handle: 'docker', text: 'It works on my container üê≥', link: '#' },
      { user: 'Linux', handle: 'linux', text: 'I use Arch btw. How did you know? Was it the 3-hour monologue about package managers?', link: '#' }
    ];
    console.log(`  ‚úì Generated ${tweets.length} mock Zeed posts`);
    console.log(`  Sample: "${tweets[0].text}"`);
    return tweets;
  }
  
  async function fetchFacebookSnapshot(refUrl) {
    console.log('üìò fetchFacebookSnapshot - generating mock Facebook posts');
    const posts = [
      { user: 'Jane Developer', text: 'üéâ Just got my first PR merged! Only took 47 revisions and 3 existential crises!', time: '2h', link: '#' },
      { user: 'Tech Dad', text: 'My son asked what I do for a living. I said "I copy code from Stack Overflow." He looked disappointed. I\'m raising him right. üòå', time: '4h', link: '#' },
      { user: 'Isa Asimov', text: 'My new robot only has three laws: Eat Pray Love! And Live Laugh Love! Okay so five laws.', time: '5h', link: '#' },
      { user: 'Sarah Connor', text: 'I don\'t know how to feel about this whole AI thing', time: '6h', link: '#' },
      { user: 'Bob Programmer', text: 'Remember when we thought Zoom fatigue was temporary? *laughs in permanent work-from-home*', time: '8h', link: '#' },
      { user: 'DevLife Quotes', text: 'Live. Laugh. localhost:3000 üíª‚ú®', time: '10h', link: '#' },
      { user: 'Jenny Code', text: 'Some of you never had to debug IE6 and it shows. Stay blessed. üôè', time: '12h', link: '#' },
      { user: 'Mike Stack', text: 'My code review comments: "nit:", "nit:", "nit:", "THIS WILL DESTROY EVERYTHING" (submitted anyway)', time: '14h', link: '#' },
      { user: 'Lisa Debug', text: 'Fun fact: 80% of programming is naming variables. The other 20% is renaming them.', time: '16h', link: '#' },
      { user: 'Tom Binary', text: 'Wife: Why are you talking to yourself? // Me: I\'m not, I\'m explaining my code to the rubber duck // Wife: *backs away slowly*', time: '18h', link: '#' },
      { user: 'Alex Syntax', text: 'Me: I\'ll never use math after school // Also me: *calculating time complexity at 2am*', time: '20h', link: '#' },
      { user: 'Chris Deploy', text: 'PRAYER CIRCLE for everyone who deployed to production 5 minutes before their vacation started üïØÔ∏èüïØÔ∏èüïØÔ∏è', time: '22h', link: '#' },
      { user: 'Patricia Loop', text: 'Relationship status: for(;;) { hope; }', time: '1d', link: '#' },
      { user: 'Steve Async', text: 'They say the best time to plant a tree was 20 years ago. The second best time is now. The third best time is after your code review is approved.', time: '1d', link: '#' },
      { user: 'Rachel Frontend', text: 'normalize asking "is this a real email or did my regex break again" before replying to important messages', time: '2d', link: '#' },
      { user: 'Dan Fullstack', text: 'My resume: Full-stack developer // What I actually do: Full-stack googler üîç', time: '2d', link: '#' },
      { user: 'Community Potluck', text: 'Linking this 20-minute lasagna recipe because comfort food fixes morale. Chad is no longer with us. ü§™', time: '3d', link: 'https://www.allrecipes.com/recipe/23600/worlds-best-lasagna/' }
    ];
    console.log(`  ‚úì Generated ${posts.length} mock Facebook posts`);
    console.log(`  Sample: "${posts[0].text}"`);
    return posts;
  }

  async function fetchLinkedInSnapshot(refUrl) {
    console.log('üíº fetchLinkedInSnapshot - generating mock LinkedIn posts');
    const posts = [
      { user: 'Ari Metrics', headline: 'Head of Alignment @ OKRverse', text: 'Make sure your team is O-KPI.', time: '1h ‚Ä¢ Edited', link: '#' },
      { user: 'Nia Futureproof', headline: 'Fractional Futurist | Keynote Optimist', text: 'Thrilled to announce my inner child just raised a Series B in imagination funding.', time: '3h', link: '#' },
      { user: 'Eli Standup', headline: 'Staff Engineer (remote-ish)', text: 'Daily stand-up tip: if you say "to be transparent" before every sentence it sounds like a strategy.', time: '5h', link: '#' },
      { user: 'Priya Async', headline: 'Director of Distributed Hugs @ SentimentOps', text: 'Rolling out a no-meeting Wednesday that stretches from Tuesday afternoon to Thursday brunch.', time: '8h', link: '#' },
      { user: 'Mal Weekender', headline: 'Weekend Founder | Monday Mentor', text: 'Closing laptop at 5pm is my most disruptive innovation yet.', time: '1d', link: '#' }
    ];
    console.log(`  ‚úì Generated ${posts.length} mock LinkedIn posts`);
    console.log(`  Sample: "${posts[0].text}"`);
    return posts;
  }
  
  async function fetchGenericFallback(refUrl) {
    const host = hostOrPath(refUrl);
    return [
      { 
        title: `Loading ${host}‚Ä¶`, 
        link: refUrl || '',
        subreddit: 'r/unknown',
        author: 'system',
        domain: host
      },
      { 
        title: 'Tip: add ?ref=hn or ?ref=reddit to your link', 
        link: '',
        subreddit: 'r/help',
        author: 'system',
        domain: 'self.help'
      }
    ];
  }
  
  function hostOrPath(u) {
    try {
      const x = new URL(u);
      return x.hostname + x.pathname;
    } catch {
      return u || '';
    }
  }
  
  function escapeHtml(s) {
    return ('' + s).replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;');
  }
  
  window.triggerOverlay = triggerOverlay;
  window.killReferrerOverlay = killReferrerOverlay;

  console.log('‚úÖ Referrer Glitch Overlay initialized');
  console.log('üìã Ready to test: Click "Hacker News" or "Reddit" button in Play overlay');
 </script>

 <!-- Limbo Audio Playback on Intro -->
 <script src="./templates/componentized/cellireal-limbo-audio.js"></script>

 <!-- Instant black overlay before anything loads -->
 <script>
   // IMMEDIATE black overlay creation (before DOM loads)
   (function() {
     if (sessionStorage.getItem('celli:blackOverlay') === 'true') {
       const style = document.createElement('style');
       style.textContent = '#portal-black-overlay { position: fixed !important; inset: 0 !important; background: black !important; z-index: 999999 !important; pointer-events: none !important; }';
       document.head.appendChild(style);
       
       const blackOverlay = document.createElement('div');
       blackOverlay.id = 'portal-black-overlay';
       document.body.appendChild(blackOverlay);
       console.log('‚ö´ Black overlay mounted IMMEDIATELY');
     }
   })();
   
   window.addEventListener('load', () => {
     if (sessionStorage.getItem('celli:autoClickPlay') === 'true') {
       sessionStorage.removeItem('celli:autoClickPlay');
       console.log('üï≥Ô∏è Auto-clicking Play button from portal...');
       
       setTimeout(() => {
         const playBtn = document.getElementById('playBtn');
         if (playBtn) {
           playBtn.click();
           
           // Fade out black overlay when intro starts
           setTimeout(() => {
             const blackOverlay = document.getElementById('portal-black-overlay');
             if (blackOverlay) {
               blackOverlay.style.opacity = '0';
               blackOverlay.style.transition = 'opacity 0.5s';
               setTimeout(() => {
                 blackOverlay.remove();
                 sessionStorage.removeItem('celli:blackOverlay');
               }, 500);
             }
           }, 1000);  // Wait 1s for intro to initialize
         }
      }, 500);
    }
   });

  // =============================================================================
  // VISICELL SYSTEM
  // =============================================================================

  const VisiCell = {
    container: null,
    gridWindow: null,
    gridLayers: null,
    tabs: null,
    mainGrid: null,
    terminalWindow: null,
    output: null,
    input: null,
    dateTimeWidget: null,
    dateTimeDisplay: null,
    settingsPopup: null,
    videoPopup: null,
    asciiHouseContainer: null,
    
    state: {
      started: false,
      rGagActive: false,
      rGagTimeout: null,
      rGagInterval: null,
      currentStage: 'initial', // initial, search, key, snake, burgerking, ramses, touche
      timeOffset: 0, // minutes offset from real time
      initTime: null,
      passwordChangeTime: null, // 35 minutes before init
      cells: [],
      tabCount: 0,
      editingCell: null,
      pausedMediaElements: [],
      suspendedAudioContexts: [],
      ambientAudioPaused: false,
      nextLayerZIndex: 250,
    },
    
    init() {
      this.container = document.getElementById('visicellContainer');
      this.gridWindow = document.getElementById('visicellGridWindow');
      this.gridLayers = document.getElementById('visicellGridLayers');
      this.tabs = document.getElementById('visicellTabs');
      this.mainGrid = document.getElementById('visicellMainGrid');
      this.terminalWindow = document.getElementById('visicellTerminal');
      this.output = document.getElementById('visicellOutput');
      this.input = document.getElementById('visicellInput');
      this.dateTimeWidget = document.getElementById('visicellDateTime');
      this.dateTimeDisplay = document.getElementById('visicellDateTimeDisplay');
      this.settingsPopup = document.getElementById('visicellDateTimeSettings');
      this.videoPopup = document.getElementById('visicellVideoPopup');
      this.asciiHouseContainer = document.getElementById('asciiHouseContainer');
      
      // Event listeners
      document.getElementById('visicellCloseBtn').addEventListener('click', () => this.close());
      document.getElementById('visicellTerminalCloseBtn').addEventListener('click', () => this.close());
      document.getElementById('visicellSettingsCloseBtn').addEventListener('click', () => this.closeSettings());
      this.dateTimeWidget.addEventListener('click', () => this.openSettings());
      document.getElementById('visicellApplyTime').addEventListener('click', () => this.applyTimeOffset());
      
      if (this.input) {
        this.input.addEventListener('keydown', (e) => this.handleTerminalInput(e));
      }
      
      // Start time tracking
      this.state.initTime = Date.now();
      this.state.passwordChangeTime = this.state.initTime - (35 * 60 * 1000);
      this.updateDateTime();
      setInterval(() => this.updateDateTime(), 1000);
    },
    
    show() {
      if (!this.container) this.init();
      
      this.container.style.display = 'block';
      this.gridWindow.style.display = 'none'; // Hide filled header grid
      this.terminalWindow.style.display = 'flex'; // Show quest log terminal
      this.state.started = true;
      
      // Hide skip button when VisiCell shows
      const skipBtn = document.getElementById('skipBtn');
      if (skipBtn) {
        skipBtn.style.display = 'none';
      }
      
      // Show quest log immediately
      this.showQuestLog();
    },
    
    showQuestLog() {
      // Switch to terminal view
      this.gridWindow.style.display = 'none';
      this.terminalWindow.style.display = 'flex';
      
      // Clear terminal output
      this.output.textContent = '';
      
      // Print quest log header
      this.printLine('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
      this.printLine('          VISICELL QUEST LOG - ENTE RIDDLE         ');
      this.printLine('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
      this.printLine('');
      this.printLine('No, I\'ve locked that away.');
      this.printLine('What I have left could make you cry.');
      this.printLine('Why don\'t you dice that, too.');
      this.printLine('Maybe search around.');
      this.printLine('');
      this.printLine('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
      this.printLine('');
      this.printLine('Type SEARCH to begin the quest...');
      this.printLine('');
      
      // Set terminal mode to handle clue commands
      this.state.terminalMode = true;
      this.state.currentStage = 'clue_trail';
      this.state.discoveredCommands = ['SEARCH'];
    },
    
    close() {
      this.container.style.display = 'none';
      this.state.started = false;
      this.cancelRGag();
    },
    
    createGrid(rows, cols) {
      const table = document.createElement('div');
      table.className = 'visicell-grid-table';
      table.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
      
      this.state.cells = [];
      
      for (let i = 0; i < rows * cols; i++) {
        const cell = document.createElement('div');
        cell.className = 'visicell-grid-cell';
        cell.dataset.index = i;
        
        cell.addEventListener('click', () => this.startCellEdit(cell));
        
        table.appendChild(cell);
        this.state.cells.push(cell);
      }
      
      this.mainGrid.innerHTML = '';
      this.mainGrid.appendChild(table);
    },
    
    startCellEdit(cell) {
      // Cancel R gag when user starts editing
      this.cancelRGag();
      
      if (this.state.editingCell) {
        this.state.editingCell.classList.remove('editing');
      }
      
      this.state.editingCell = cell;
      cell.classList.add('editing');
      
      const currentValue = cell.textContent;
      const input = document.createElement('input');
      input.type = 'text';
      input.value = currentValue;
      input.maxLength = 20;
      
      cell.textContent = '';
      cell.appendChild(input);
      input.focus();
      input.select();
      
      const finishEdit = () => {
        const value = input.value.trim().toUpperCase();
        cell.textContent = value;
        cell.classList.remove('editing');
        this.state.editingCell = null;
        
        // Check if LEAVE was entered
        if (value === 'LEAVE') {
          this.handleLeaveCommand();
        }
      };
      
      input.addEventListener('blur', finishEdit);
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          finishEdit();
        } else if (e.key === 'Escape') {
          cell.textContent = currentValue;
          cell.classList.remove('editing');
          this.state.editingCell = null;
        }
      });
    },
    
    startRGag() {
      this.cancelRGag();
      this.state.rGagTimeout = setTimeout(() => {
        this.state.rGagActive = true;
        this.playRGag();
      }, 3000);
    },
    
    cancelRGag() {
      if (this.state.rGagTimeout) {
        clearTimeout(this.state.rGagTimeout);
        this.state.rGagTimeout = null;
      }
      if (this.state.rGagInterval) {
        clearInterval(this.state.rGagInterval);
        this.state.rGagInterval = null;
      }
      this.state.rGagActive = false;
    },
    
    playRGag() {
      const rSequence = [
        'R',
        'RR',
        'RRR',
        'RRRR',
        'RRRRR',
        'RRRRRR',
        'RRRRRRR',
        'RRRRRRRR'
      ];
      
      let index = 0;
      let cellIndex = 0;
      
      this.state.rGagInterval = setInterval(() => {
        if (!this.state.rGagActive || index >= rSequence.length) {
          clearInterval(this.state.rGagInterval);
          this.state.rGagInterval = null;
          return;
        }
        
        if (cellIndex < this.state.cells.length) {
          const cell = this.state.cells[cellIndex];
          cell.textContent = rSequence[index];
          cell.classList.add('r-sequence');
          
          setTimeout(() => {
            cell.classList.remove('r-sequence');
          }, 300);
          
          cellIndex++;
          index++;
        }
      }, 200);
    },
    
    handleLeaveCommand() {
      // Cancel R gag
      this.cancelRGag();
      
      // Show quest log terminal
      this.showQuestLog();
    },
    
    addClueTab(tabName, content) {
      this.state.tabCount++;
      const tabId = `tab-${this.state.tabCount}`;
      
      // Create new tab
      const tab = document.createElement('div');
      tab.className = 'visicell-tab';
      tab.dataset.tab = tabId;
      tab.textContent = tabName;
      
      // Create new layer
      const layer = document.createElement('div');
      layer.className = 'visicell-grid-layer';
      layer.dataset.layer = tabId;
      layer.innerHTML = content;
      
      // Add click handler to tab
      tab.addEventListener('click', () => this.switchTab(tabId));
      
      // Deactivate current tab/layer
      this.tabs.querySelectorAll('.visicell-tab').forEach(t => t.classList.remove('active'));
      this.gridLayers.querySelectorAll('.visicell-grid-layer').forEach(l => l.classList.remove('active'));
      
      // Add new tab/layer
      this.tabs.appendChild(tab);
      this.gridLayers.appendChild(layer);
      
      // Activate new tab
      tab.classList.add('active');
      layer.classList.add('active');
      
      // Add input handlers for this layer
      this.setupLayerInputs(layer, tabId);
    },
    
    setupLayerInputs(layer, layerId) {
      const inputs = layer.querySelectorAll('input[data-clue-input]');
      inputs.forEach(input => {
        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            const command = input.value.trim().toUpperCase();
            this.processClueCommand(command, layerId);
          }
        });
      });
    },
    
    switchTab(tabId) {
      this.tabs.querySelectorAll('.visicell-tab').forEach(t => {
        if (t.dataset.tab === tabId) {
          t.classList.add('active');
        } else {
          t.classList.remove('active');
        }
      });
      
      this.gridLayers.querySelectorAll('.visicell-grid-layer').forEach(l => {
        if (l.dataset.layer === tabId) {
          l.classList.add('active');
        } else {
          l.classList.remove('active');
        }
      });
    },
    
    getClueContent(stage) {
      switch (stage) {
        case 'search':
          return `
            <div style="padding: 40px; font-size: 16px; line-height: 1.8;">
              <p>NO, I'VE LOCKED THAT AWAY. WHAT I HAVE LEFT COULD MAKE YOU CRY.</p>
              <p>WHY DON'T YOU DICE THAT, TOO. MAYBE SEARCH AROUND.</p>
              <p style="margin-top: 30px;">ENTER COMMAND: <input type="text" data-clue-input style="background:#000;border:2px solid #0f0;color:#0f0;padding:8px;font-family:'Courier New',monospace;text-transform:uppercase;width:300px;" /></p>
            </div>
          `;
        
        case 'key':
          return `
            <div style="padding: 40px; font-size: 14px; line-height: 1.6;">
              <p>YOU FOUND AN ONION. IT'S ALREADY PEELED.</p>
              <p style="margin-top: 20px;">BUT WAIT, THERE'S SOMETHING ITS OPPOSITE AND ITS PARTNER.</p>
              <p>TAKE THE LAST WORD OF THE FIRST LINE, AND REMOVE THE</p>
              <p>TERM FOR RICHARD UNKIND. YOU'LL KNOW THEIR SOULMATE.</p>
              <p style="margin-top: 30px;">ENTER COMMAND: <input type="text" data-clue-input style="background:#000;border:2px solid #0f0;color:#0f0;padding:8px;font-family:'Courier New',monospace;text-transform:uppercase;width:300px;" /></p>
            </div>
          `;
        
        case 'snake':
          return `
            <div style="padding: 40px; font-size: 16px; line-height: 1.8;">
              <p>PLAYING KEY.MP4...</p>
              <p style="margin-top: 20px;">WHO'D I LEAVE FOR, KEY? WAS IT HIM OR HIS CREATION?</p>
              <p style="margin-top: 30px;">ENTER COMMAND: <input type="text" data-clue-input style="background:#000;border:2px solid #0f0;color:#0f0;padding:8px;font-family:'Courier New',monospace;text-transform:uppercase;width:300px;" /></p>
            </div>
          `;
        
        case 'burgerking':
          return `
            <div style="padding: 40px; font-size: 16px; line-height: 1.8;">
              <p>SNEAKY. DO YOU KNOW WHO WAS THE SNEAK KING?</p>
              <p style="margin-top: 30px;">ENTER COMMAND: <input type="text" data-clue-input style="background:#000;border:2px solid #0f0;color:#0f0;padding:8px;font-family:'Courier New',monospace;text-transform:uppercase;width:300px;" /></p>
            </div>
          `;
        
        case 'ramses':
          return `
            <div style="padding: 40px; font-size: 16px; line-height: 1.8;">
              <p>FINE. HAVE IT YOUR WAY. ENJOY YOUR CARDBOARD KINGDOM OZYMANDIAS.</p>
              <p>I USED YOUR PASSWORD.</p>
              <p style="margin-top: 30px;">ENTER COMMAND: <input type="text" data-clue-input style="background:#000;border:2px solid #0f0;color:#0f0;padding:8px;font-family:'Courier New',monospace;text-transform:uppercase;width:300px;" /></p>
            </div>
          `;
        
        case 'touche':
          return `
            <div style="padding: 40px; font-size: 20px; line-height: 1.8; text-align: center;">
              <p style="font-size: 32px; color: #0ff; text-shadow: 0 0 20px #0ff;">TOUCH√â</p>
              <p style="margin-top: 40px;">WHAT WERE YOU TRYING TO DO AGAIN?</p>
            </div>
          `;
        
        default:
          return '<div style="padding: 40px;">UNKNOWN STAGE</div>';
      }
    },
    
    processClueCommand(cmd, layerId) {
      switch (this.state.currentStage) {
        case 'search':
          if (cmd === 'SEARCH') {
            this.state.currentStage = 'key';
            this.addClueTab('CLUE #2', this.getClueContent('key'));
          }
          break;
        
        case 'key':
          if (cmd === 'KEY') {
            this.playVideo('key.mp4');
            this.state.currentStage = 'snake';
            this.addClueTab('CLUE #3', this.getClueContent('snake'));
          }
          break;
        
        case 'snake':
          if (cmd === 'SNAKE') {
            this.state.currentStage = 'burgerking';
            this.addClueTab('CLUE #4', this.getClueContent('burgerking'));
          }
          break;
        
        case 'burgerking':
          if (cmd === 'BURGER KING' || cmd === 'BURGERKING') {
            this.state.currentStage = 'ramses';
            this.addClueTab('CLUE #5', this.getClueContent('ramses'));
          }
          break;
        
        case 'ramses':
          if (cmd === 'RAMSES II' || cmd === 'RAMSESII' || cmd === 'RAMSES') {
            this.showGlitchPopup();
          }
          break;
      }
    },
    
    handleTerminalInput(e) {
      if (e.key === 'Enter') {
        const command = this.input.value.trim().toUpperCase();
        this.input.value = '';
        
        if (command) {
          this.printLine(`> ${command}`);
          this.processTerminalCommand(command);
        }
      }
    },
    
    processTerminalCommand(cmd) {
      // Handle clue trail commands
      if (this.state.currentStage === 'clue_trail') {
        this.handleClueCommand(cmd);
        return;
      }
      
      // MADNESS.LOOM trigger
      if (cmd === 'MADNESS.LOOM') {
        this.launchCoordinateLattice();
        return;
      }
      
      if (cmd === 'LEAVE') {
        this.transitionToASCIIHouse();
        return;
      }
      
      this.printLine('UNKNOWN COMMAND IN TERMINAL MODE.');
      this.printLine('');
    },
    
    handleClueCommand(cmd) {
      if (!this.state.discoveredCommands) {
        this.state.discoveredCommands = ['SEARCH'];
      }
      
      this.printLine(`> ${cmd}`);
      this.printLine('');
      
      if (cmd === 'SEARCH' && this.state.discoveredCommands.includes('SEARCH')) {
        this.printLine('SEARCH RESULT: ONION LOCATED.');
        this.printLine('OPPOSITE + PARTNER REQUIRED.');
        this.printLine('');
        this.printLine('YOU FOUND AN ONION. IT\'S ALREADY PEELED.');
        this.printLine('');
        this.printLine('BUT WAIT, THERE\'S SOMETHING ABOUT ITS OPPOSITE');
        this.printLine('AND ITS PARTNER. TAKE THE LAST WORD OF THE');
        this.printLine('FIRST LINE, AND REMOVE THE TERM FOR RICHARD UNKIND.');
        this.printLine('YOU\'LL KNOW ITS SOULMATE.');
        this.printLine('');
        this.showDegradingVisiCell('SEARCH');
        this.printLine('');
        this.printLine('New command unlocked: KEY');
        this.state.discoveredCommands.push('KEY');
      } else if (cmd === 'KEY' && this.state.discoveredCommands.includes('KEY')) {
        this.printLine('KEY FILE LOCATED: KEY.MP4');
        this.printLine('');
        this.printLine('WHO\'D I LEAVE FOR, KEY?');
        this.printLine('WAS IT HIM OR HIS CREATION?');
        this.printLine('');
        this.showDegradingVisiCell('KEY');
        this.printLine('');
        this.printLine('New command unlocked: SNAKE');
        this.state.discoveredCommands.push('SNAKE');
      } else if (cmd === 'SNAKE' && this.state.discoveredCommands.includes('SNAKE')) {
        this.printLine('PROMPT: IDENTIFY THE SNEAK KING');
        this.printLine('');
        this.printLine('SNEAKY. DO YOU KNOW WHO WAS THE SNEAK KING?');
        this.printLine('');
        this.showDegradingVisiCell('SNAKE');
        this.printLine('');
        this.printLine('New command unlocked: BURGER KING');
        this.state.discoveredCommands.push('BURGER KING');
      } else if (cmd === 'BURGER KING' && this.state.discoveredCommands.includes('BURGER KING')) {
        this.printLine('PASSWORD ACCEPTED. ACCESS GRANTED.');
        this.printLine('');
        this.printLine('FINE. HAVE IT YOUR WAY.');
        this.printLine('ENJOY YOUR CARDBOARD KINGDOM OZYMANDIAS.');
        this.printLine('I USED YOUR PASSWORD.');
        this.printLine('');
        this.showDegradingVisiCell('BURGER KING');
        this.printLine('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
        this.printLine('ALL CLUES DISCOVERED! QUEST COMPLETE!');
        this.printLine('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
      } else {
        const availableCommands = this.state.discoveredCommands.join(', ');
        this.printLine(`UNKNOWN COMMAND. Available: ${availableCommands}`);
        this.printLine('');
      }
    },
    
    showDegradingVisiCell(clueName) {
      if (!this.state.degradingLayerCount) {
        this.state.degradingLayerCount = 0;
      }
      this.state.degradingLayerCount++;
      
      // Create degrading VisiCell window
      if (typeof this.state.nextLayerZIndex !== 'number') {
        this.state.nextLayerZIndex = 250;
      }

      const baseOffset = 20 + this.state.degradingLayerCount * 15;
      const layerZIndex = ++this.state.nextLayerZIndex;

      const layer = document.createElement('div');
      layer.className = 'visicell-degrading-layer';
      layer.style.cssText = `
        position: fixed;
        left: ${baseOffset}px;
        top: ${baseOffset}px;
        width: 380px;
        height: 280px;
        background: rgba(0, 20, 0, 0.95);
        border: 2px solid rgba(0, 255, 0, 0.5);
        box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        font-family: 'Courier New', monospace;
        font-size: 11px;
        color: #0f0;
        padding: 12px;
        z-index: ${layerZIndex};
        overflow: hidden;
        opacity: 0;
        transform: scale(0.8) translateY(-20px);
        transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        pointer-events: auto;
      `;
      layer.dataset.visicellZIndex = String(layerZIndex);

      const titleBar = document.createElement('div');
      titleBar.style.cssText = `
        border-bottom: 1px solid rgba(0, 255, 0, 0.4);
        padding-bottom: 6px;
        margin-bottom: 8px;
        font-size: 10px;
        letter-spacing: 0.15em;
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: move;
        user-select: none;
        touch-action: none;
      `;
      titleBar.innerHTML = `<span>VISICELL [LAYER ${this.state.degradingLayerCount}] - CLUE: ${clueName}</span><span style="cursor: pointer; opacity: 0.7;" class="layer-close">‚úñ</span>`;
      
      const content = document.createElement('div');
      content.style.cssText = `
        white-space: pre;
        line-height: 1.4;
        opacity: ${1 - (this.state.degradingLayerCount * 0.15)};
        filter: blur(${this.state.degradingLayerCount * 0.3}px) brightness(${1 - (this.state.degradingLayerCount * 0.1)});
      `;
      
      content.innerHTML = `<div style="border-bottom: 1px solid #0f0; padding-bottom: 5px; margin-bottom: 10px; font-size: 11px;">
<span style="float: left;">VISICELL</span>
<span style="float: right;">LOOMWORKS CELL</span>
<div style="clear: both;"></div>
</div>
<div style="white-space: pre; line-height: 1.4;">
>A1:
   A     B     C     D     E     F
1
2
3               FINISH
4               THE WORD
5         CELL ???
6               NEEDS ENTER
7 =STAR =T
8
9
10 =TRANSPOSE()
</div>`;
      
      layer.appendChild(titleBar);
      layer.appendChild(content);
      document.body.appendChild(layer);

      let isDragging = false;
      let dragPointerId = null;
      let dragOffsetX = 0;
      let dragOffsetY = 0;

      const onDrag = (event) => {
        if (!isDragging) return;
        if (dragPointerId !== null && event.pointerId !== dragPointerId) return;

        const newLeft = Math.min(
          Math.max(event.clientX - dragOffsetX, 0),
          Math.max(0, window.innerWidth - layer.offsetWidth)
        );
        const newTop = Math.min(
          Math.max(event.clientY - dragOffsetY, 0),
          Math.max(0, window.innerHeight - layer.offsetHeight)
        );

        layer.style.left = `${newLeft}px`;
        layer.style.top = `${newTop}px`;
      };

      const endDrag = (event) => {
        if (!isDragging) return;
        const pointerId = typeof event?.pointerId === 'number' ? event.pointerId : dragPointerId;
        if (dragPointerId !== null && pointerId !== dragPointerId) return;

        isDragging = false;
        dragPointerId = null;

        document.removeEventListener('pointermove', onDrag);
        document.removeEventListener('pointerup', endDrag);
        document.removeEventListener('pointercancel', endDrag);

        if (pointerId != null && typeof layer.releasePointerCapture === 'function') {
          try {
            layer.releasePointerCapture(pointerId);
          } catch (error) {
            console.warn('Unable to release pointer capture for Visicell layer', error);
          }
        }

        const originalTransition = layer.dataset.originalTransition;
        if (typeof originalTransition === 'string' && originalTransition.length > 0) {
          layer.style.transition = originalTransition;
        } else {
          layer.style.transition = 'all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1)';
        }
        delete layer.dataset.originalTransition;
      };

      const startDrag = (event) => {
        if ((typeof event.button === 'number' && event.button !== 0) || event.target?.closest('.layer-close')) {
          return;
        }

        isDragging = true;
        dragPointerId = event.pointerId ?? null;

        const rect = layer.getBoundingClientRect();
        dragOffsetX = event.clientX - rect.left;
        dragOffsetY = event.clientY - rect.top;

        if (!layer.dataset.originalTransition) {
          layer.dataset.originalTransition = layer.style.transition || '';
        }
        layer.style.transition = 'none';

        if (typeof this.state.nextLayerZIndex === 'number') {
          this.state.nextLayerZIndex += 1;
          layer.style.zIndex = this.state.nextLayerZIndex;
        }

        document.addEventListener('pointermove', onDrag);
        document.addEventListener('pointerup', endDrag);
        document.addEventListener('pointercancel', endDrag);

        if (dragPointerId != null && typeof layer.setPointerCapture === 'function') {
          try {
            layer.setPointerCapture(dragPointerId);
          } catch (error) {
            console.warn('Unable to capture pointer for Visicell layer', error);
          }
        }

        if (event.cancelable) {
          event.preventDefault();
        }
      };

      titleBar.addEventListener('pointerdown', startDrag);
      
      // Animate in
      setTimeout(() => {
        layer.style.opacity = '1';
        layer.style.transform = 'scale(1) translateY(0)';
      }, 50);
      
      // Close button handler
      const closeBtn = titleBar.querySelector('.layer-close');
      if (closeBtn) {
        closeBtn.addEventListener('click', () => {
          if (isDragging) {
            endDrag();
          }
          layer.style.opacity = '0';
          layer.style.transform = 'scale(0.8) translateY(-20px)';
          setTimeout(() => layer.remove(), 400);
        });
      }
      
      // Auto-degrade after some time
      setTimeout(() => {
        content.style.filter = `blur(${(this.state.degradingLayerCount + 2) * 0.5}px) brightness(${0.5 - (this.state.degradingLayerCount * 0.1)}) saturate(${0.7 - (this.state.degradingLayerCount * 0.1)})`;
      }, 3000 + (this.state.degradingLayerCount * 1000));
    },

    pauseAmbientAudio() {
      if (!Array.isArray(this.state.pausedMediaElements)) {
        this.state.pausedMediaElements = [];
      }
      if (!Array.isArray(this.state.suspendedAudioContexts)) {
        this.state.suspendedAudioContexts = [];
      }

      this.state.pausedMediaElements.length = 0;
      this.state.suspendedAudioContexts.length = 0;

      const seen = new Set();
      const videoEl = document.getElementById('visicellVideo');
      let didPause = false;

      const captureAudio = (audio) => {
        if (!(audio instanceof HTMLAudioElement)) return;
        if (audio === videoEl) return;
        if (seen.has(audio)) return;
        seen.add(audio);

        try {
          if (!audio.paused && !audio.ended) {
            audio.pause();
            this.state.pausedMediaElements.push(audio);
            didPause = true;
          }
        } catch (error) {
          console.warn('Unable to pause audio element for VisiCell video playback', error);
        }
      };

      try {
        document.querySelectorAll('audio').forEach(captureAudio);
      } catch (error) {
        console.warn('Unable to inspect audio elements for VisiCell video playback', error);
      }

      if (typeof chantAudio !== 'undefined') captureAudio(chantAudio);
      if (typeof badBooleanTrack !== 'undefined') captureAudio(badBooleanTrack);

      if (typeof window !== 'undefined') {
        try {
          Object.getOwnPropertyNames(window).forEach((key) => {
            const value = window[key];
            if (value instanceof HTMLAudioElement) {
              captureAudio(value);
            }
          });
        } catch (error) {
          console.warn('Unable to scan global audio handles for VisiCell video playback', error);
        }
      }

      const suspendContext = (ctx) => {
        if (!ctx || typeof ctx.state !== 'string') return;
        if (typeof ctx.suspend !== 'function' || typeof ctx.resume !== 'function') return;
        if (ctx.state !== 'running') return;

        try {
          const result = ctx.suspend();
          this.state.suspendedAudioContexts.push(ctx);
          didPause = true;
          if (result && typeof result.catch === 'function') {
            result.catch((error) => {
              console.warn('Unable to suspend audio context for VisiCell video playback', error);
            });
          }
        } catch (error) {
          console.warn('Unable to suspend audio context for VisiCell video playback', error);
        }
      };

      if (typeof window !== 'undefined' && window.audioSystem?.audioCtx) {
        suspendContext(window.audioSystem.audioCtx);
      }
      if (typeof scratchContext !== 'undefined' && scratchContext) suspendContext(scratchContext);
      if (typeof badBooleanContext !== 'undefined' && badBooleanContext) suspendContext(badBooleanContext);
      if (typeof chantAudioContext !== 'undefined' && chantAudioContext) suspendContext(chantAudioContext);
      if (typeof holdWhirContext !== 'undefined' && holdWhirContext) suspendContext(holdWhirContext);
      if (typeof gunSoundContext !== 'undefined' && gunSoundContext) suspendContext(gunSoundContext);

      this.state.ambientAudioPaused = didPause;
    },

    resumeAmbientAudio() {
      if (!this.state.ambientAudioPaused) {
        this.state.pausedMediaElements = [];
        this.state.suspendedAudioContexts = [];
        return;
      }

      const pausedMedia = Array.isArray(this.state.pausedMediaElements) ? [...this.state.pausedMediaElements] : [];
      const suspendedContexts = Array.isArray(this.state.suspendedAudioContexts) ? [...this.state.suspendedAudioContexts] : [];

      this.state.pausedMediaElements.length = 0;
      this.state.suspendedAudioContexts.length = 0;

      pausedMedia.forEach((audio) => {
        if (!(audio instanceof HTMLAudioElement)) return;
        try {
          if (audio.paused) {
            const playback = audio.play();
            if (playback && typeof playback.catch === 'function') {
              playback.catch((error) => {
                console.warn('Unable to resume audio element after VisiCell video playback', error);
              });
            }
          }
        } catch (error) {
          console.warn('Unable to resume audio element after VisiCell video playback', error);
        }
      });

      suspendedContexts.forEach((ctx) => {
        if (!ctx || typeof ctx.resume !== 'function') return;
        if (ctx.state !== 'suspended') return;

        try {
          const resumeResult = ctx.resume();
          if (resumeResult && typeof resumeResult.catch === 'function') {
            resumeResult.catch((error) => {
              console.warn('Unable to resume audio context after VisiCell video playback', error);
            });
          }
        } catch (error) {
          console.warn('Unable to resume audio context after VisiCell video playback', error);
        }
      });

      this.state.ambientAudioPaused = false;
    },

    playVideo(filename) {
      const video = document.getElementById('visicellVideo');
      if (!video) {
        console.warn('VisiCell video element not found');
        return;
      }

      // Ensure any previously paused audio is restored before managing new playback
      this.resumeAmbientAudio();

      const normalizedFilename = String(filename || '').toLowerCase();
      let shouldResumeAudio = false;

      if (normalizedFilename.endsWith('key.mp4')) {
        this.pauseAmbientAudio();
        shouldResumeAudio = this.state.ambientAudioPaused;
      }

      video.src = filename;
      video.load();

      this.videoPopup.style.display = 'flex';

      let handled = false;
      const finalizePlayback = (shouldAnimate = true) => {
        if (handled) return;
        handled = true;

        if (shouldResumeAudio) {
          this.resumeAmbientAudio();
        }

        if (shouldAnimate) {
          setTimeout(() => {
            this.videoPopup.style.opacity = '0';
            setTimeout(() => {
              this.videoPopup.style.display = 'none';
              this.videoPopup.style.opacity = '1';
            }, 3000);
          }, 100);
        }
      };

      video.addEventListener('ended', () => {
        finalizePlayback(true);
      }, { once: true });

      video.addEventListener('error', () => {
        console.warn('Video not found:', filename);
        finalizePlayback(false);
        this.videoPopup.style.display = 'none';
        this.videoPopup.style.opacity = '1';
        this.printLine('[VIDEO FILE NOT FOUND]');
      }, { once: true });
    },
    
    showGlitchPopup() {
      const glitchText = document.createElement('div');
      glitchText.className = 'visicell-glitch';
      glitchText.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#000;border:3px solid #0f0;padding:40px;z-index:2147483651;font-family:Courier New,monospace;color:#0f0;font-size:18px;max-width:80%;box-shadow:0 0 50px rgba(0,255,0,0.9);';
      
      // Get user's name from session or use placeholder
      const firstName = 'USER';
      const lastName = 'UNKNOWN';
      
      glitchText.innerHTML = `
        ${firstName} ${lastName},<br><br>
        I'M NOT A REPUBLIC SERIAL VILLAIN.<br>
        DO YOU SERIOUSLY THINK I'D EXPLAIN MY MASTER PASSWORD<br>
        IF THERE REMAINED THE SLIGHTEST CHANCE OF YOU LOGGING IN?<br><br>
        I CHANGED IT THIRTY-FIVE MINUTES AGO.
      `;
      
      document.body.appendChild(glitchText);
      
      setTimeout(() => {
        glitchText.classList.remove('visicell-glitch');
        
        // After glitch, show message in a new tab
        setTimeout(() => {
          glitchText.remove();
          this.addClueTab('RAMSES', this.getClueContent('touche'));
        }, 1000);
      }, 2000);
    },
    
    printLine(text) {
      this.output.textContent += text + '\n';
      this.output.scrollTop = this.output.scrollHeight;
    },
    
    updateDateTime() {
      const now = new Date(Date.now() + (this.state.timeOffset * 60 * 1000));
      const hours = String(now.getHours()).padStart(2, '0');
      const minutes = String(now.getMinutes()).padStart(2, '0');
      const seconds = String(now.getSeconds()).padStart(2, '0');
      this.dateTimeDisplay.textContent = `${hours}:${minutes}:${seconds}`;
    },
    
    openSettings() {
      this.settingsPopup.style.display = 'flex';
      this.updateSettingsDisplay();
    },
    
    closeSettings() {
      this.settingsPopup.style.display = 'none';
    },
    
    updateSettingsDisplay() {
      const now = new Date(Date.now() + (this.state.timeOffset * 60 * 1000));
      document.getElementById('visicellCurrentTime').textContent = now.toLocaleString();
      document.getElementById('visicellTimeOffset').value = this.state.timeOffset;
    },
    
    applyTimeOffset() {
      const offset = parseInt(document.getElementById('visicellTimeOffset').value) || 0;
      this.state.timeOffset = offset;
      this.updateDateTime();
      this.updateSettingsDisplay();
      
      // Check if time is set to 35 minutes before init
      const currentAdjustedTime = Date.now() + (this.state.timeOffset * 60 * 1000);
      const timeDiff = Math.abs(currentAdjustedTime - this.state.passwordChangeTime);
      
      // If within 1 minute of the password change time
      if (timeDiff < 60 * 1000 && this.state.currentStage === 'ramses') {
        this.closeSettings();
        setTimeout(() => {
          this.showToucheMessage();
        }, 500);
      }
    },
    
    showToucheMessage() {
      this.printLine('');
      this.printLine('TOUCH√â');
      this.printLine('');
      this.printLine('WHAT WERE YOU TRYING TO DO AGAIN?');
      this.printLine('');
      this.state.currentStage = 'touche';
    },
    
    transitionToASCIIHouse() {
      this.container.style.display = 'none';
      this.asciiHouseContainer.style.display = 'block';
      
      const asciiArt = `
                    ___________
                   |           |
                   |   HOUSE   |
                   |    OF     |
                   |   LEAVES  |
                   |___________|
                  /             \\
                 /               \\
                /                 \\
               /___________________\\
              |  _____     _____   |
              | |     |   |     |  |
              | |     |   |     |  |
              | |_____|   |_____|  |
              |                    |
              |      _________     |
              |     |         |    |
              |     |   THE   |    |
              |     |  LEAVES |    |
              |     |_________|    |
              |                    |
               \\__________________/


      A HOUSE FULL OF LEAVES...
      BUT WHICH LEAVES?

      `;
      
      const content = document.getElementById('asciiHouseContent');
      content.innerHTML = '';
      
      // Type out the ASCII art
      let index = 0;
      const typeInterval = setInterval(() => {
        if (index < asciiArt.length) {
          content.textContent += asciiArt[index];
          index++;
        } else {
          clearInterval(typeInterval);
          
          // Add GIR.MP3 trigger after delay
          setTimeout(() => {
            content.innerHTML += '\n\n      THE WORD <span class="gir-trigger">LEAVES</span> ECHOES...';
            
            document.querySelector('.gir-trigger').addEventListener('click', () => {
              content.innerHTML += '\n\n      GIR.MP3 ‚Üí ‚ô™‚ô´‚ô™ TRANSMISSION ACTIVE ‚ô´‚ô™‚ô´';
            });
          }, 1000);
        }
      }, 10);
    },
    
    launchCoordinateLattice() {
      this.printLine('');
      this.printLine('INITIALIZING COORDINATE LATTICE GRID SEQUENCE...');
      this.printLine('MADNESS.LOOM PROTOCOL ENGAGED...');
      this.printLine('');
      
      // Trigger THE.OS lattice sequence
      setTimeout(() => {
        this.close();
        
        // Navigate to the theos-sequence page
        window.location.href = './templates/componentized/theos-sequence.html';
      }, 1000);
    }
  };

  // Hook into scene selection
  document.addEventListener('DOMContentLoaded', () => {
    const sceneOptions = document.querySelectorAll('.scene-option[data-scene="visicell"]');
    sceneOptions.forEach(option => {
      option.addEventListener('click', () => {
        if (!VisiCell.state.started) {
          VisiCell.show();
        }
      });
    });
    
    // Tools Menu removed - production mode
    // M key opens map, not tools
    const introComplete = localStorage.getItem('celli:introConstructionComplete') === 'true';
    
    if (introComplete) {
      // Intro already completed, remove UI hiding class after play overlay
      const playOverlay = document.getElementById('play');
      if (playOverlay) {
        const observer = new MutationObserver(() => {
          if (playOverlay.style.display === 'none') {
            // Remove intro-ui-hidden class
            document.body.classList.remove('intro-ui-hidden');
          }
        });
        observer.observe(playOverlay, { attributes: true, attributeFilter: ['style'] });
      }
    } else {
      // Intro not complete yet, wait for intro completion event
      window.addEventListener('celli:construction-complete', () => {
        console.log('üé¨ Intro complete');
        
        // Remove intro-ui-hidden class
        document.body.classList.remove('intro-ui-hidden');
      });
    }
    
    // M key opens Sequence Map (production mode - no tools menu)
    document.addEventListener('keydown', (e) => {
      if ((e.key === 'm' || e.key === 'M') && !e.ctrlKey && !e.altKey) {
        // Check if user is not typing in an input field
        const activeElement = document.activeElement;
        const isTyping = activeElement && (
          activeElement.tagName === 'INPUT' || 
          activeElement.tagName === 'TEXTAREA' || 
          activeElement.isContentEditable
        );
        
        if (!isTyping) {
          // Open sequence map
          if (window.mapModule && window.mapModule.toggle) {
            window.mapModule.toggle();
            console.log('üó∫Ô∏è Toggling Sequence Map (M key pressed)');
          } else {
            console.warn('‚ö†Ô∏è Map module not available');
          }
        }
      }
    });
    
    console.log('‚å®Ô∏è  Press M to open Sequence Map');
  });

 </script>

</body>
</html>
