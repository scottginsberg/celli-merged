// --- Play button wiring & scene selection -------------------------------
const sceneSelect = document.getElementById('sceneSelect');
const sceneSelectBtn = document.getElementById('sceneSelectBtn');
const closeSceneSelectBtn = document.getElementById('closeSceneSelect');
const debugToggle = document.getElementById('debugToggle');
const clearProgress = document.getElementById('clearProgress');
const sceneOptions = Array.from(document.querySelectorAll('.scene-option'));
 idleTimeoutStart = Date.now();
 idleBloomIncreaseTriggered = false;
 idleGlitchingTriggered = false;
 if (skipBtn) {
  skipBtn.classList.remove('idle-bloom-increase');
  skipBtn.classList.remove('idle-glitching');
 }
 if (!running || !idleTimeoutStart) return;
 const idleTime = Date.now() - idleTimeoutStart;

 // Start bloom increase after 5 seconds
 if (idleTime >= IDLE_BLOOM_START && !idleBloomIncreaseTriggered) {
  idleBloomIncreaseTriggered = true;
  if (skipBtn) {
   skipBtn.classList.add('idle-bloom-increase');
   console.log('[Idle] Bloom increase started');
  }
 }
 // Start glitching after bloom reaches max (3 more seconds)
 if (idleTime >= IDLE_GLITCH_START && !idleGlitchingTriggered) {
  idleGlitchingTriggered = true;
  if (skipBtn) {
   skipBtn.classList.add('idle-glitching');
   console.log('[Idle] Glitching started');
  }
 }
if (playBtn && playOverlay && skipBtn) {
 playBtn.addEventListener('click', () => {
  running = true;
  window.running = running;
  clock.getDelta();

  playOverlay.classList.add('hidden');
  skipBtn.classList.remove('hidden'); // Show skip button (it will be hidden when transitioning to fullhand)
  clearToast();

  // Start idle timeout detection
  resetIdleTimer();

  frame();
 });
}

if (skipBtn) {
 skipBtn.addEventListener('click', () => {
  if (!running) return;

  // Jump to CELLI phase
  totalTime = introCfg.celliEnd - 6.0; // Start 6 seconds before celli ends (during trickle/chime)

  // Hide all prior elements
  quoteEl.style.visibility = 'hidden';
  quoteEl.style.opacity = '0';
  loomworksEl.style.display = 'none';
  triMesh.visible = false;
  blackHole.visible = false;
  spheres.forEach(s => s.visible = false);

  // Setup CELLI
  if (!celliStarted) {
   celliStarted = true;
   celliStartTime = totalTime;
  }

  // Play startup bass note after skip
  setTimeout(() => {
   playStartupBass();
  }, 500);
 });

 skipBtn.addEventListener('keydown', (event) => {
  if (event.key === 'Enter' || event.key === ' ') {
   event.preventDefault();
   skipBtn.click();
  }
 });
}

let debugMode = false;

function updateSceneSelect() {
 if (!sceneSelect) return;

 const hasSeenVisicell = localStorage.getItem('megred_seen_visicell') === 'true';
 const hasSeenLeave = localStorage.getItem('megred_seen_leave') === 'true';
 const hasSeenTheos = localStorage.getItem('megred_seen_theos') === 'true';
 const hasSeenBlackhole = localStorage.getItem('megred_seen_blackhole') === 'true';
 const hasSeenEnd3 = localStorage.getItem('megred_seen_end3') === 'true';
 const hasSeenFullhand = localStorage.getItem('megred_seen_fullhand') === 'true';
 const hasSeenCelliReal = localStorage.getItem('megred_seen_cellireal') === 'true';

 sceneOptions.forEach(opt => {
  const scene = opt.dataset.scene;
  let unlocked = debugMode;

  if (!unlocked) {
   if (scene === 'visicell' && hasSeenVisicell) unlocked = true;
   if (scene === 'leave' && hasSeenLeave) unlocked = true;
   if (scene === 'theos' && hasSeenTheos) unlocked = true;
   if (scene === 'blackhole' && hasSeenBlackhole) unlocked = true;
   if (scene === 'end3' && hasSeenEnd3) unlocked = true;
   if (scene === 'fullhand' && hasSeenFullhand) unlocked = true;
   if (scene === 'cellireal' && hasSeenCelliReal) unlocked = true;
  }

  if (unlocked) {
   opt.classList.remove('locked');
  } else {
   opt.classList.add('locked');
  }
 });

 if (debugToggle) {
  debugToggle.textContent = debugMode ? 'Debug: ON ?' : 'Debug: Show All';
 }
}

if (sceneSelectBtn && sceneSelect) {
 sceneSelectBtn.addEventListener('click', () => {
  updateSceneSelect();
  sceneSelect.classList.add('visible');
 });
}

if (closeSceneSelectBtn && sceneSelect) {
 closeSceneSelectBtn.addEventListener('click', () => {
  sceneSelect.classList.remove('visible');
 });
}

if (debugToggle) {
 debugToggle.addEventListener('click', () => {
  debugMode = !debugMode;
  updateSceneSelect();
 });
}

if (clearProgress) {
 clearProgress.addEventListener('click', () => {
  if (confirm('Clear all progress? This will lock all scenes.')) {
   localStorage.removeItem('megred_seen_visicell');
   localStorage.removeItem('megred_seen_leave');
   localStorage.removeItem('megred_seen_theos');
   localStorage.removeItem('megred_seen_blackhole');
   localStorage.removeItem('megred_seen_end3');
   localStorage.removeItem('megred_seen_fullhand');
   localStorage.removeItem('megred_seen_cellireal');
   updateSceneSelect();
   console.log('? Progress cleared');
  }
 });
}

sceneOptions.forEach(opt => {
 opt.addEventListener('click', () => {
  if (opt.classList.contains('locked')) return;
  const scene = opt.dataset.scene;
  if (sceneSelect) {
   sceneSelect.classList.remove('visible');
  }
  // Start the experience if not running
  if (!running) {
   running = true;
   window.running = running;
   clock.getDelta();
   if (playOverlay) playOverlay.classList.add('hidden');
   if (skipBtn) skipBtn.classList.remove('hidden');
   clearToast();
   frame();
  }
  const suspendAudio = () => {
   if (audioCtx && audioCtx.state === 'running') {
    audioCtx.suspend().catch(e => console.warn('Audio suspend failed:', e));
   }
  };
  // Jump to scene
  if (scene === 'visicell') {
   console.log('?? Jumping to VisiCell');
   totalTime = introCfg.celliEnd + 10;
   showVisiCalc();
   localStorage.setItem('megred_seen_visicell', 'true');
  } else if (scene === 'leave') {
   console.log('?? Jumping to VisiCell terminal (MADNESS.LOOM)');
   totalTime = introCfg.celliEnd + 8;
   showVisiCalc();
   localStorage.setItem('megred_seen_leave', 'true');
  } else if (scene === 'theos') {
   console.log('?? Jumping to THE.OS grid scene (cell lattice start)');
   totalTime = introCfg.celliEnd + 8;
   showVisiCalc();
   setTimeout(() => {
    const frameEl = document.getElementById('visicalc-frame');
    const visiCalc = document.getElementById('visicalc');
    if (frameEl) {
     startCellAddressSequence(frameEl, visiCalc);
     console.log('?? THE.OS cell address sequence started from beginning');
    }
   }, 500);
   localStorage.setItem('megred_seen_theos', 'true');
  } else if (scene === 'blackhole') {
   console.log('?? Jumping to Black Hole formed scene');
   totalTime = introCfg.celliEnd + 8;
   showVisiCalc();
   window.addressSequenceTime = 56;
   console.log('? Pre-setting sequence time to 56s for black hole visibility');
   setTimeout(() => {
    const frameEl = document.getElementById('visicalc-frame');
    const visiCalc = document.getElementById('visicalc');
    if (frameEl) {
     startCellAddressSequence(frameEl, visiCalc);
     console.log('?? Cell address sequence started at t=56s (black hole visible)');
    }
   }, 500);
   localStorage.setItem('megred_seen_blackhole', 'true');
  } else if (scene === 'end3') {
   console.log('?? Jumping to END3 terminal crawl scene');
   running = false;
   window.running = running;
   suspendAudio();
   transitionToEnd3Scene();
   localStorage.setItem('megred_seen_end3', 'true');
  } else if (scene === 'fullhand') {
   console.log('?? Jumping to Execution Environment scene');
   running = false;
   window.running = running;
   suspendAudio();
   transitionToFullhandScene();
   localStorage.setItem('megred_seen_fullhand', 'true');
  } else if (scene === 'cellireal') {
   console.log('?? Jumping to CELLI.REAL scene');
   running = false;
   window.running = running;
   suspendAudio();
   transitionToCelliRealScene();
   localStorage.setItem('megred_seen_cellireal', 'true');
  }
 });
});
// Restore saved mode on load
document.querySelectorAll('.mode-btn').forEach(btn => {
 const sceneTarget = btn.getAttribute('data-scene-target');
 const mode = btn.getAttribute('data-mode');
 const savedMode = localStorage.getItem(`${sceneTarget}_mode`) || 'sequence';
 if (mode === savedMode) {
  btn.classList.add('active');
  btn.style.background = '#4a7cff';
  btn.style.borderColor = '#6a9cff';
  btn.style.color = '#fff';
 } else {
  btn.classList.remove('active');
  btn.style.background = '#2a2a2f';
  btn.style.borderColor = '#444';
  btn.style.color = '#ddd';
 }
});
document.querySelectorAll('.mode-btn').forEach(btn => {
 btn.addEventListener('click', (event) => {
  event.stopPropagation();
  const sceneTarget = btn.getAttribute('data-scene-target');
  const mode = btn.getAttribute('data-mode');

  document.querySelectorAll(`.mode-btn[data-scene-target="${sceneTarget}"]`).forEach(otherBtn => {
   otherBtn.classList.remove('active');
   otherBtn.style.background = '#2a2a2f';
   otherBtn.style.borderColor = '#444';
   otherBtn.style.color = '#ddd';
  });

  btn.classList.add('active');
  btn.style.background = '#4a7cff';
  btn.style.borderColor = '#6a9cff';
  btn.style.color = '#fff';

  localStorage.setItem(`${sceneTarget}_mode`, mode);
  console.log(`? ${sceneTarget} mode set to: ${mode}`);
 });
updateSceneSelect();

