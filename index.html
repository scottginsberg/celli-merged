<!doctype html>
<html lang="en">
<head>
 <meta charset="utf-8"/>
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
 <meta name="viewport" content="width=device-width, initial-scale=1"/>
 <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
 <meta http-equiv="Pragma" content="no-cache" />
 <meta http-equiv="Expires" content="0" />
 <meta name="version" content="6.0-celli-real-component-composition" />
 <title>Cell.real - Voxel Spreadsheet [Modular Edition]</title>
 
 <!-- Google Fonts -->
 <link rel="preconnect" href="https://fonts.googleapis.com">
 <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
 <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Roboto+Mono:wght@100;300&family=VT323&display=swap" rel="stylesheet">
 
 <!-- Twemoji for consistent emoji rendering -->
 <script src="https://unpkg.com/twemoji@latest/dist/twemoji.min.js"></script>
 
 <!-- GIF.js for screen recording -->
 <script src="https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.js"></script>
 
 <!-- Styles -->
 <link rel="stylesheet" href="src/styles/main.css">
 <link rel="stylesheet" href="src/styles/sequence.css">
 <link rel="stylesheet" href="src/styles/celli-real.css">
 <link rel="stylesheet" href="src/styles/referrer-overlay.css">
 <link rel="stylesheet" href="src/styles/recorder.css">
 
 <!-- Mythic Sidebar Entrance Animations -->
 <style>
  @keyframes pulse {
   0%, 100% { opacity: 1; transform: scale(1); }
   50% { opacity: 0.8; transform: scale(1.05); }
  }
  
  @keyframes float {
   0%, 100% { transform: translateY(-50%) translateX(0); }
   50% { transform: translateY(-50%) translateX(-10px); }
  }
  
  @keyframes rumble {
   0%, 100% { transform: translate(-50%, -50%) rotate(0deg); }
   10% { transform: translate(calc(-50% - 5px), calc(-50% - 5px)) rotate(-1deg); }
   20% { transform: translate(calc(-50% + 5px), calc(-50% + 5px)) rotate(1deg); }
   30% { transform: translate(calc(-50% - 5px), calc(-50% + 5px)) rotate(-1deg); }
   40% { transform: translate(calc(-50% + 5px), calc(-50% - 5px)) rotate(1deg); }
   50% { transform: translate(calc(-50% - 3px), calc(-50% - 3px)) rotate(-0.5deg); }
   60% { transform: translate(calc(-50% + 3px), calc(-50% + 3px)) rotate(0.5deg); }
   70% { transform: translate(calc(-50% - 3px), calc(-50% + 3px)) rotate(-0.5deg); }
   80% { transform: translate(calc(-50% + 3px), calc(-50% - 3px)) rotate(0.5deg); }
   90% { transform: translate(calc(-50% - 1px), calc(-50% - 1px)) rotate(-0.2deg); }
  }
  
  @keyframes glow-pulse {
   0%, 100% { 
    box-shadow: 0 0 50px rgba(102, 126, 234, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);
   }
   50% { 
    box-shadow: 0 0 80px rgba(102, 126, 234, 1), 0 0 40px rgba(255, 255, 255, 0.8);
   }
  }
  
  /* Initial state: off-screen right */
  .ref-sidebar.mythic-entrance {
   display: block !important;
   position: fixed;
   right: -400px;
   top: 50%;
   transform: translateY(-50%);
   transition: right 0.8s cubic-bezier(0.34, 1.56, 0.64, 1), transform 0.8s ease-out;
   box-shadow: 0 0 50px rgba(102, 126, 234, 0.8);
   z-index: 10001;
   animation: glow-pulse 2s ease-in-out infinite;
   background: rgba(30, 30, 40, 0.95) !important;
   backdrop-filter: blur(10px);
   border-radius: 12px;
  }
  
  /* Stage 1: Float in from right */
  .ref-sidebar.mythic-entrance.stage-float {
   right: 20px;
   animation: float 2s ease-in-out infinite, glow-pulse 2s ease-in-out infinite;
  }
  
  /* Stage 2: Sweep to center */
  .ref-sidebar.mythic-entrance.stage-sweep {
   left: 50%;
   right: auto;
   top: 50%;
   transform: translate(-50%, -50%);
   transition: all 1.2s cubic-bezier(0.68, -0.55, 0.27, 1.55);
   animation: glow-pulse 1.5s ease-in-out infinite;
  }
  
  /* Stage 3: Rumble */
  .ref-sidebar.mythic-entrance.stage-rumble {
   animation: rumble 0.6s ease-in-out, glow-pulse 0.6s ease-in-out infinite;
  }
  
  /* Stage 4: Expand */
  .ref-sidebar.mythic-entrance.stage-expand {
   width: 560px;
   padding: 0;
   left: 50%;
   right: auto;
   transform: translate(-50%, -50%) scale(1.05);
   transition: all 0.6s cubic-bezier(0.68, -0.55, 0.27, 1.55);
   box-shadow: 0 0 100px rgba(102, 126, 234, 0.5), 0 8px 40px rgba(0, 0, 0, 0.6), inset 0 1px 0 rgba(255, 255, 255, 0.15);
   background: linear-gradient(135deg, rgba(15, 25, 45, 0.85), rgba(25, 35, 55, 0.9)) !important;
   backdrop-filter: blur(30px) saturate(200%) !important;
   -webkit-backdrop-filter: blur(30px) saturate(200%) !important;
   border: 1px solid rgba(143, 180, 255, 0.3);
   border-radius: 20px;
  }
  
  .ref-sidebar.mythic-entrance.stage-expand .ref-sidebar-btn {
   animation: none;
  }

  .ref-sidebar.mythic-entrance.note-seed {
   width: clamp(210px, 65vw, 260px);
   padding: 20px 24px;
   border-radius: 22px;
   background: linear-gradient(145deg, rgba(25, 32, 58, 0.92), rgba(18, 26, 48, 0.88)) !important;
   box-shadow: 0 18px 46px rgba(14, 18, 40, 0.58), 0 0 42px rgba(102, 126, 234, 0.45);
   backdrop-filter: blur(24px) saturate(185%);
   -webkit-backdrop-filter: blur(24px) saturate(185%);
   display: flex;
   align-items: center;
   justify-content: center;
  }

  .ref-sidebar.mythic-entrance.note-seed .ref-sidebar-btn {
   width: 100%;
   padding: 0;
   background: transparent;
   border: none;
  }

  .ref-sidebar.mythic-entrance.note-hover {
   box-shadow: 0 28px 70px rgba(9, 12, 28, 0.75), 0 0 80px rgba(123, 150, 255, 0.55);
   background: linear-gradient(150deg, rgba(24, 32, 60, 0.95), rgba(16, 24, 50, 0.92)) !important;
  }

  .ref-note-crystal {
   position: relative;
   display: grid;
   gap: 6px;
   padding: 18px 22px;
   border-radius: 18px;
   background: linear-gradient(135deg, rgba(146, 172, 255, 0.25), rgba(90, 116, 230, 0.16));
   border: 1px solid rgba(164, 190, 255, 0.35);
   box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.45), 0 14px 30px rgba(18, 28, 62, 0.6);
   overflow: hidden;
   color: #f5f7ff;
   text-align: center;
   font-family: "Inter", -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
   letter-spacing: 0.12em;
   text-transform: uppercase;
   transition: transform 0.6s ease, box-shadow 0.6s ease;
  }

  .ref-note-crystal::before {
   content: "";
   position: absolute;
   inset: -20%;
   background: radial-gradient(circle at 30% 30%, rgba(184, 204, 255, 0.35), transparent 60%);
   opacity: 0.8;
   animation: ref-note-glow 4s ease-in-out infinite;
  }

  .ref-note-crystal::after {
   content: "";
   position: absolute;
   inset: 12%;
   border-radius: 16px;
   border: 1px solid rgba(255, 255, 255, 0.25);
   opacity: 0.5;
   mix-blend-mode: screen;
  }

  .ref-note-title {
   position: relative;
   font-size: 12px;
   font-weight: 600;
   color: #e0e6ff;
   text-shadow: 0 0 18px rgba(149, 170, 255, 0.6);
   letter-spacing: 0.24em;
  }

  .ref-note-sub {
   position: relative;
   font-size: 11px;
   font-weight: 500;
   opacity: 0.7;
   letter-spacing: 0.16em;
  }

  .ref-note-crystal--hover,
  .ref-sidebar.mythic-entrance.note-hover .ref-note-crystal {
   transform: translateY(-6px) scale(1.04);
   box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.5), 0 24px 46px rgba(12, 18, 42, 0.68), 0 0 55px rgba(138, 160, 255, 0.75);
  }

  @keyframes ref-note-glow {
   0%, 100% {
    opacity: 0.8;
    transform: translate(-4%, -2%) scale(1);
   }
   50% {
    opacity: 1;
    transform: translate(6%, 4%) scale(1.06);
   }
  }

  @media (max-width: 768px) {
   .ref-sidebar.mythic-entrance.note-seed {
    width: clamp(180px, 60vw, 230px);
    padding: 18px 20px;
   }

   .ref-note-crystal {
    padding: 16px 18px;
    border-radius: 16px;
    letter-spacing: 0.1em;
   }

   .ref-note-title {
    font-size: 11px;
   }

   .ref-note-sub {
    font-size: 10px;
    letter-spacing: 0.12em;
   }
  }

  /* AI Twinkle effect */
  @keyframes ai-twinkle {
   0%, 100% {
    opacity: 1;
    transform: scale(1);
    text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
   }
   25% {
    opacity: 0.8;
    transform: scale(1.05);
    text-shadow: 0 0 20px rgba(102, 126, 234, 0.8), 0 0 40px rgba(255, 255, 255, 0.4);
   }
   50% { 
    opacity: 1;
    transform: scale(1.1);
    text-shadow: 0 0 30px rgba(102, 126, 234, 1), 0 0 60px rgba(255, 255, 255, 0.6);
   }
   75% {
    opacity: 0.9;
    transform: scale(1.05);
    text-shadow: 0 0 20px rgba(102, 126, 234, 0.8), 0 0 40px rgba(255, 255, 255, 0.4);
   }
  }
  
  .ai-message {
   animation: ai-twinkle 2s ease-in-out;
  }
  
  /* Animated gradient for gaudy ad */
  @keyframes rainbow-shift {
   0% { background-position: 0% 50%; }
   50% { background-position: 100% 50%; }
   100% { background-position: 0% 50%; }
  }
  
  /* Hide real cursor when faux cursor is active */
  body.faux-cursor-active {
   cursor: none !important;
  }
  
  body.faux-cursor-active * {
   cursor: none !important;
  }
  
  /* Checkbox container hover effect */
  #tosCheckboxContainer:hover {
   border-color: rgba(143, 180, 255, 0.6) !important;
   background: linear-gradient(135deg, rgba(143, 180, 255, 0.15), rgba(102, 126, 234, 0.2)) !important;
   box-shadow: 0 6px 24px rgba(102, 126, 234, 0.25), inset 0 1px 0 rgba(255, 255, 255, 0.15) !important;
   transform: translateY(-1px);
  }
  
  /* Ensure all glow effects use screen blend mode (never darken) */
  .edge-impact,
  .light-beam,
  .impact-particle {
   mix-blend-mode: screen;
  }
  
  /* Base darkening overlay - starts invisible */
  .darkening-overlay {
   opacity: 0;
  }
  
  /* Darkening overlay flicker animation */
  @keyframes darken-flicker {
   0% { opacity: 0; }
   10% { opacity: 0.3; }
   20% { opacity: 0.05; }
   30% { opacity: 0.4; }
   40% { opacity: 0.1; }
   50% { opacity: 0.5; }
   60% { opacity: 0.15; }
   70% { opacity: 0.6; }
   80% { opacity: 0.2; }
   90% { opacity: 0.7; }
   100% { opacity: 0; }
  }
  
  .darkening-overlay.flickering {
   animation: darken-flicker var(--flicker-duration, 800ms) ease-in-out;
   animation-iteration-count: var(--flicker-count, 5);
   animation-fill-mode: both;
  }
  
  /* Progressive darkness levels */
  .darkening-overlay.level-1 {
   opacity: 0.2 !important;
   transition: opacity 0.5s ease-out;
  }
  
  .darkening-overlay.level-2 {
   opacity: 0.4 !important;
   transition: opacity 0.5s ease-out;
  }
  
  .darkening-overlay.level-3 {
   opacity: 0.6 !important;
   transition: opacity 0.5s ease-out;
  }
  
  .darkening-overlay.level-4 {
   opacity: 0.8 !important;
   transition: opacity 0.5s ease-out;
  }
  
  .darkening-overlay.level-5 {
   opacity: 0.95 !important;
   transition: opacity 0.5s ease-out;
  }
  
  /* Flash of life - momentary restoration of light */
  @keyframes flash-life {
   0% { opacity: 0.95 !important; }
   15% { opacity: 0 !important; }
   30% { opacity: 0.2 !important; }
   45% { opacity: 0 !important; }
   60% { opacity: 0.3 !important; }
   75% { opacity: 0.1 !important; }
   100% { opacity: 0.95 !important; }
  }
  
  .darkening-overlay.flash-of-life {
   animation: flash-life 1.5s ease-in-out !important;
   opacity: initial !important;
  }
  
  /* Brick hole in darkening wall */
  .darkening-hole {
   position: fixed;
   right: 0;
   width: 300px;
   height: 80px;
   background: transparent;
   pointer-events: none;
   z-index: 9999;
   border-radius: 50%;
   box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.5);
   animation: hole-break 0.3s ease-out;
  }
  
  @keyframes hole-break {
   0% { transform: scaleX(0); opacity: 0; }
   100% { transform: scaleX(1); opacity: 1; }
  }
  
  /* Light beam through hole */
  .light-ray {
   position: fixed;
   right: 0;
   width: var(--ref-light-ray-width, 420px);
   height: var(--ref-light-ray-height, 18px);
   mix-blend-mode: screen;
   pointer-events: none;
   z-index: 2147483600;
   animation: ray-shine 0.45s ease-out;
   transform-origin: right center;
   border-radius: calc(var(--ref-light-ray-height, 18px) / 2);
   opacity: 0;
  }

  .light-ray::before,
  .light-ray::after {
   content: '';
   position: absolute;
   inset: 0;
   border-radius: inherit;
   pointer-events: none;
  }

  body.voxel-shatter-active #uiContainer,
  body.voxel-shatter-active #celliRefOverlay,
  body.voxel-shatter-active .celli-ref-mask,
  body.voxel-shatter-active .celli-ref-panel {
   opacity: 0;
   pointer-events: none !important;
   transition: opacity 0.4s ease;
  }

  .tri-color-particles {
   position: fixed;
   inset: 0;
   width: 100vw;
   height: 100vh;
   pointer-events: none;
   z-index: 2147483000;
   mix-blend-mode: screen;
   opacity: 0.48;
   transition: opacity 0.8s ease;
  }

  .tri-color-particles.tri-color-particles--foreground {
   z-index: 2147483525;
   opacity: 0.78;
  }

  .base-darkness {
   position: fixed;
   inset: 0;
   background: radial-gradient(circle at center, rgba(8, 10, 18, 0.05) 0%, rgba(3, 5, 12, 0.85) 100%);
   pointer-events: none;
   z-index: 2147483380;
   opacity: 0;
   transition: opacity 0.9s ease, filter 1s ease;
   filter: saturate(1);
  }

  .base-darkness.level-1 { opacity: 0.18; }
  .base-darkness.level-2 { opacity: 0.32; }
  .base-darkness.level-3 { opacity: 0.48; }
  .base-darkness.level-4 { opacity: 0.65; }
  .base-darkness.level-5 { opacity: 0.78; filter: saturate(1.1); }

  .loom-invite-swarm {
   position: fixed;
   inset: 0;
   width: 100vw;
   height: 100vh;
   pointer-events: none;
   z-index: 2147483580;
   overflow: visible;
  }

  .loom-invite-clone {
   position: absolute;
   top: var(--invite-top, 50%);
   left: var(--invite-left, 50%);
   transform: translate(-50%, -50%) scale(var(--invite-scale, 0.9)) rotate(var(--invite-tilt, -2deg));
   opacity: 0;
   transition: opacity 1.4s ease, transform 1.2s ease;
   filter: drop-shadow(0 18px 42px rgba(12, 18, 45, 0.45));
   pointer-events: auto;
   cursor: pointer;
  }

  .loom-invite-clone.visible {
   opacity: 0.92;
   transform: translate(-50%, -50%) scale(calc(var(--invite-scale, 0.9) + var(--chant-reactive, 0) * 0.08)) rotate(var(--invite-tilt, -2deg));
  }

  .loom-invite-clone::before,
  .loom-invite-clone::after {
   content: '';
   position: absolute;
   inset: -22px -28px;
   border-radius: 28px;
   background: radial-gradient(circle at 50% 18%, rgba(143, 180, 255, 0.16), transparent 60%);
   mix-blend-mode: screen;
   opacity: 0.65;
   transform: translateZ(0);
   pointer-events: none;
  }

  .loom-invite-clone::after {
   inset: -12px -16px;
   opacity: 0.85;
   filter: blur(18px);
  }

  .loom-invite-clone-card,
  .loom-invite-card {
   position: relative;
   border-radius: 24px;
   background: linear-gradient(145deg, rgba(102, 126, 234, 0.32), rgba(143, 180, 255, 0.22), rgba(118, 75, 162, 0.28));
   backdrop-filter: blur(18px) saturate(220%);
   -webkit-backdrop-filter: blur(18px) saturate(220%);
   border: 1px solid rgba(160, 190, 255, 0.4);
   box-shadow: 0 24px 50px rgba(9, 12, 34, 0.55), inset 0 1px 0 rgba(255, 255, 255, 0.22);
   overflow: hidden;
  }

  .loom-invite-card::after,
  .loom-invite-clone-card::after {
   content: '';
   position: absolute;
   inset: 10% 6%;
   border-radius: 20px;
   background: radial-gradient(ellipse at 50% 0%, rgba(143, 180, 255, 0.35), transparent 65%);
   opacity: 0.65;
   mix-blend-mode: screen;
   pointer-events: none;
  }

  .loom-invite-clone-card {
   padding: 32px 36px;
   display: flex;
   align-items: center;
   justify-content: center;
   min-width: 220px;
   pointer-events: none;
  }

  .loom-invite-clone-card .loom-invite-emblem {
   pointer-events: auto;
  }

  .loom-invite-emblem {
   position: relative;
   z-index: 1;
   display: grid;
   gap: 8px;
   justify-items: center;
   text-align: center;
   color: #f6f8ff;
   font-family: "Inter", -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
   text-transform: uppercase;
   letter-spacing: 0.34em;
   filter: drop-shadow(0 0 26px rgba(143, 180, 255, 0.45));
  }

  .loom-invite-line {
   margin: 0;
   font-size: 15px;
   font-weight: 500;
   letter-spacing: 0.28em;
   text-shadow: 0 0 18px rgba(143, 180, 255, 0.55);
  }

  .loom-invite-line--primary {
   font-size: 16px;
   letter-spacing: 0.34em;
  }

  .loom-invite-line--secondary {
   font-size: 13px;
   letter-spacing: 0.32em;
   opacity: 0.88;
  }

  .loom-invite-line--tertiary {
   font-size: 11px;
   letter-spacing: 0.28em;
   opacity: 0.76;
  }

  .loom-invite-clone .loom-invite-clone-body strong {
   display: block;
   margin-bottom: 8px;
   font-size: 16px;
   letter-spacing: 0.08em;
   color: rgba(255, 255, 255, 0.98);
   text-shadow: 0 0 12px rgba(143, 180, 255, 0.55);
  }

  .loom-invite-clone .loom-invite-clone-body span {
   display: block;
   opacity: 0.75;
   font-size: 13px;
   letter-spacing: 0.06em;
  }

  .loom-invite-clone.visible .loom-invite-clone-card {
   animation: loomInviteCloneDrift 8s ease-in-out var(--invite-delay, 0ms) infinite alternate;
  }

  @keyframes loomInviteCloneDrift {
   0% {
    transform: translateY(0) scale(1);
    filter: saturate(1) brightness(1);
   }
   50% {
    transform: translateY(-14px) scale(calc(1 + var(--chant-reactive, 0) * 0.08));
    filter: saturate(1.05) brightness(calc(1.05 + var(--chant-reactive, 0) * 0.2));
   }
   100% {
    transform: translateY(10px) scale(calc(1 + var(--chant-reactive, 0) * 0.12));
    filter: saturate(1.1) brightness(calc(1.08 + var(--chant-reactive, 0) * 0.24));
   }
  }

  .loom-invite-clone.reduced-motion .loom-invite-clone-card {
   animation: none;
  }

  .ai-message-tri-icon {
   display: inline-flex;
   align-items: center;
   justify-content: center;
   gap: 6px;
   margin-bottom: 16px;
  }

  .ai-message-tri-icon span {
   width: 18px;
   height: 18px;
   display: block;
   background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.55));
   clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
   opacity: 0.9;
   filter: drop-shadow(0 0 6px rgba(255, 255, 255, 0.65));
   transition: transform 0.35s ease, opacity 0.35s ease;
  }

  .ai-message-tri-icon span:nth-child(2) {
   transform: translateY(-6px) scale(1.12);
  }

  .ai-message-tri-icon span:nth-child(1),
  .ai-message-tri-icon span:nth-child(3) {
   transform: translateY(3px) scale(0.86);
  }

  .ref-sidebar-btn.loom-invite-active.audio-reactive .ai-message-tri-icon span:nth-child(2) {
   transform: translateY(calc(-6px - var(--chant-reactive, 0) * 8px)) scale(calc(1.12 + var(--chant-reactive, 0) * 0.3));
   opacity: calc(0.9 + var(--chant-reactive, 0) * 0.1);
  }

  .ref-sidebar-btn.loom-invite-active.audio-reactive .ai-message-tri-icon span:nth-child(1),
  .ref-sidebar-btn.loom-invite-active.audio-reactive .ai-message-tri-icon span:nth-child(3) {
   transform: translateY(calc(3px + var(--chant-reactive, 0) * -4px)) scale(calc(0.86 + var(--chant-reactive, 0) * 0.18));
   opacity: calc(0.85 + var(--chant-reactive, 0) * 0.12);
  }

  .loom-invite-pin {
   position: absolute;
   width: 18px;
   height: 18px;
   border-radius: 50%;
   background: radial-gradient(circle, rgba(255,255,255,0.95) 0%, rgba(255,255,255,0.5) 40%, rgba(255,30,110,0.25) 100%);
   box-shadow: 0 0 24px rgba(255, 30, 110, 0.65), 0 0 48px rgba(0, 168, 255, 0.4);
   opacity: 0;
   transform: translate3d(0, 0, 0) scale(0.7);
   will-change: transform, opacity;
   pointer-events: none;
  }

  .loom-invite-pin.pin-yellow {
   background: radial-gradient(circle, rgba(255,255,255,0.95) 0%, rgba(255,255,255,0.5) 40%, rgba(255,182,46,0.3) 100%);
   box-shadow: 0 0 24px rgba(255, 182, 46, 0.7), 0 0 48px rgba(0, 168, 255, 0.35);
  }

  .loom-invite-pin.pin-cyan {
   background: radial-gradient(circle, rgba(255,255,255,0.95) 0%, rgba(255,255,255,0.5) 40%, rgba(0,168,255,0.3) 100%);
   box-shadow: 0 0 24px rgba(0, 168, 255, 0.7), 0 0 48px rgba(255, 30, 110, 0.35);
  }

  @keyframes loomInvitePinFlight {
   0% {
    opacity: 0;
    transform: translate3d(0, 0, 0) scale(0.6);
   }
   12% {
    opacity: 1;
   }
   55% {
    opacity: 0.92;
   }
   100% {
    opacity: 0;
    transform: translate3d(var(--pin-flight-x, -55vw), var(--pin-flight-y, 0), 0) scale(1.05);
   }
  }

  .debug-panel-button {
   position: fixed;
   bottom: 24px;
   left: 24px;
   transform: none;
   padding: 10px 18px;
   border-radius: 999px;
   background: rgba(15, 23, 42, 0.85);
   border: 1px solid rgba(148, 163, 184, 0.5);
   color: #e2e8f0;
   font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
   font-size: 13px;
   letter-spacing: 0.08em;
   text-transform: uppercase;
   cursor: pointer;
   z-index: 2147483900;
   box-shadow: 0 12px 32px rgba(15, 23, 42, 0.45);
   transition: transform 0.2s ease, background 0.2s ease, box-shadow 0.2s ease;
  }

  .debug-panel-button:hover,
  .debug-panel-button:focus-visible {
   background: rgba(30, 41, 59, 0.9);
   box-shadow: 0 16px 38px rgba(15, 23, 42, 0.55);
   transform: translateY(-2px);
   outline: none;
  }

  .debug-panel {
   position: fixed;
   bottom: 112px;
   left: 24px;
   transform: translateY(12px);
   width: min(380px, 92vw);
   background: rgba(12, 17, 29, 0.92);
   border: 1px solid rgba(100, 116, 139, 0.35);
   border-radius: 18px;
   padding: 18px;
   color: #e2e8f0;
   font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
   font-size: 13px;
   letter-spacing: 0.01em;
   box-shadow: 0 22px 50px rgba(15, 23, 42, 0.6);
   opacity: 0;
   pointer-events: none;
   transition: opacity 0.22s ease, transform 0.22s ease;
   z-index: 2147483910;
  }

  .debug-panel.visible {
   opacity: 1;
   transform: translateY(0);
   pointer-events: auto;
  }

  .debug-panel__header {
   display: flex;
   align-items: center;
   justify-content: space-between;
   font-size: 12px;
   letter-spacing: 0.12em;
   text-transform: uppercase;
   color: #94a3b8;
   margin-bottom: 14px;
  }

  .debug-panel__close {
   background: transparent;
   border: none;
   color: inherit;
   cursor: pointer;
   font-size: 16px;
   line-height: 1;
   padding: 4px 6px;
   border-radius: 8px;
  }

  .debug-panel__close:hover,
  .debug-panel__close:focus-visible {
   background: rgba(148, 163, 184, 0.12);
   outline: none;
  }

  .debug-panel__section {
   margin-bottom: 14px;
   display: grid;
   gap: 8px;
  }

  .debug-panel__section:last-of-type {
   margin-bottom: 0;
  }

  .debug-toggle {
   display: flex;
   align-items: center;
   gap: 10px;
  }

  .debug-toggle input[type='checkbox'] {
   width: 16px;
   height: 16px;
   accent-color: #38bdf8;
  }

  .debug-panel__stats {
   font-family: 'Roboto Mono', ui-monospace, SFMono-Regular, Menlo, Consolas, 'Liberation Mono', monospace;
   font-size: 12px;
   color: #cbd5f5;
  }

  .debug-panel__stats span {
   color: #facc15;
  }

  .debug-panel__cta {
   display: inline-flex;
   align-items: center;
   justify-content: center;
   padding: 8px 12px;
   border-radius: 999px;
   background: rgba(56, 189, 248, 0.16);
   border: 1px solid rgba(56, 189, 248, 0.35);
   color: #bae6fd;
   cursor: pointer;
   font-size: 12px;
   letter-spacing: 0.06em;
   text-transform: uppercase;
   transition: background 0.2s ease, border 0.2s ease;
  }

  .debug-panel__cta:hover,
  .debug-panel__cta:focus-visible {
   background: rgba(56, 189, 248, 0.28);
   border-color: rgba(56, 189, 248, 0.55);
   outline: none;
  }

  body.debug-hide-light-layers .light-ray,
  body.debug-hide-light-layers #lightBeam,
  body.debug-hide-light-layers .edge-impact,
  body.debug-hide-light-layers .darkening-overlay {
   display: none !important;
   opacity: 0 !important;
  }

  body.debug-hide-tri-color .tri-color-particles {
   display: none !important;
  }

  body.debug-hide-invite-waves .loom-invite-swarm {
   display: none !important;
  }

  .light-ray::before {
   background: linear-gradient(
    to left,
    rgba(255, 255, 255, 0),
    rgba(255, 255, 255, 0.08) 10%,
    rgba(255, 255, 255, 0.55) 32%,
    rgba(255, 255, 255, 0.85) 50%,
    rgba(255, 255, 255, 0.55) 68%,
    rgba(255, 255, 255, 0.08) 90%,
    rgba(255, 255, 255, 0)
   );
  }

  .light-ray::after {
   inset: -25% -4% -25% 0;
   background: linear-gradient(
    to left,
    rgba(255, 255, 255, 0.35),
    rgba(255, 255, 255, 0.2) 18%,
    rgba(255, 255, 255, 0.06) 60%,
    rgba(255, 255, 255, 0)
   );
   filter: blur(var(--ref-light-ray-blur, 12px));
   opacity: 0.65;
  }

  @keyframes ray-shine {
   0% { opacity: 0; transform: scaleX(0.2); }
   45% { opacity: 1; }
   100% { opacity: 0.4; transform: scaleX(1); }
  }
  
  /* Giant burst beam for final card entrance */
  .burst-beam {
   position: fixed;
   right: 0;
   top: 0;
   width: 100vw;
   height: 100vh;
   background: radial-gradient(ellipse at right center, rgba(255, 255, 255, 0.9) 0%, rgba(255, 255, 255, 0.4) 30%, transparent 60%);
   mix-blend-mode: screen;
   pointer-events: none;
   z-index: 2147483650;
   opacity: 0;
   animation: burst-flash 2.5s ease-out forwards;
  }
  
  @keyframes burst-flash {
   0% { 
    opacity: 0; 
    transform: scaleX(0);
    filter: brightness(1);
   }
   10% { 
    opacity: 1; 
    transform: scaleX(0.5);
    filter: brightness(2);
   }
   25% { 
    opacity: 1; 
    transform: scaleX(1.3);
    filter: brightness(1.8);
   }
   50% {
    opacity: 0.8;
    transform: scaleX(1.1);
    filter: brightness(1.2);
   }
   100% { 
    opacity: 0.2; 
    transform: scaleX(1);
    filter: brightness(1);
   }
  }
 </style>
</head>
<body>
 <div id="app" class="scanlines"></div>
 <div class="hud">
  <div id="quote" class="quote">
   <span id="quoteBefore" class="quote__text">...if you gaze for long into an abyss, the abyss gazes also into you.</span>
   <span id="quoteAfter" class="quote__text" style="display:none;"></span>
  </div>
  <div id="loomworks" class="loomworks" aria-live="polite">
   <span id="loomPre" class="loomworks-chunk">L</span><span id="loomCore" class="loomworks-chunk">OO</span><span id="loomPost" class="loomworks-chunk">K</span><span id="loomTail" class="loomworks-chunk"></span>
  </div>
  <span id="floatingK" class="floatingK" aria-hidden="true">K</span>
  <div class="vignette"></div>
 </div>
 <div id="screenGlitch" class="screenGlitch"></div>
 
 <!-- Doorway portal -->
 <div id="doorway" class="doorway">
  <div class="prompt-container">
   <div class="prompt" data-text="=STAR_"><span id="promptText">=STAR</span><span id="promptCursor" class="cursor">_</span></div>
  </div>
 </div>
 
 <!-- Play Overlay -->
 <div id="play" class="play">
  <button id="playBtn">Play</button>
  <div style="display:flex; gap:10px; margin-top:10px; flex-wrap:wrap; justify-content:center; max-width:550px;">
   <button id="sceneSelectBtn" style="font-size:12px; padding:10px 20px; opacity:0.7;">Scene Select</button>
   <button id="testAudioBtn" style="font-size:12px; padding:10px 20px; opacity:0.7;">TEST Audio</button>
   <button id="testVideoBtn" style="font-size:12px; padding:10px 20px; opacity:0.8; background:#1abc9c;">🎞️ Test Video Playlist</button>
   <button id="flashSceneBtn" style="font-size:12px; padding:10px 20px; opacity:0.85; background:#f39c12;">⚡ Flash Scene</button>
  </div>
  <div style="display:flex; gap:10px; margin-top:8px; flex-wrap:wrap; justify-content:center; max-width:550px;">
   <button id="playIntroVideoBtn" style="font-size:12px; padding:10px 20px; opacity:0.7; background:#9b59b6;">🎬 Play Intro</button>
   <button id="playIntroVideoBtn2" style="font-size:12px; padding:10px 20px; opacity:0.7; background:#8e44ad;">🎬 Play Intro II</button>
   <button id="sequenceBuilderBtn" style="font-size:11px; padding:8px 16px; opacity:0.7; background:#ff6b6b;">🎬 Sequence Builder</button>
   <button id="singleBuilderBtn" style="font-size:11px; padding:8px 16px; opacity:0.7; background:#ffa500;">🛠️ Single Builder</button>
   <button id="testRunnerBtn" style="font-size:11px; padding:8px 16px; opacity:0.7; background:#4ec9b0;">🧪 Test Runner</button>
  </div>
  <div style="display:flex; gap:10px; margin-top:12px; flex-wrap:wrap; justify-content:center; max-width:550px; padding:10px; background:rgba(0,0,0,0.3); border-radius:8px;">
   <div style="color:#fff; font-size:11px; width:100%; text-align:center; margin-bottom:6px; opacity:0.8;">Scene Loading Mode:</div>
   <button id="useTemplateBtn" class="mode-toggle active" data-mode="template" style="flex:1; padding:8px 16px; background:#4a7cff; border:1px solid #6a9cff; color:#fff; border-radius:6px; cursor:pointer; font-size:11px; font-weight:600;">📄 Template (Fast)</button>
   <button id="useComponentBtn" class="mode-toggle" data-mode="component" style="flex:1; padding:8px 16px; background:#2a2a2f; border:1px solid #444; color:#ddd; border-radius:6px; cursor:pointer; font-size:11px; font-weight:600;">🧩 Componentized</button>
  </div>
  
  <!-- Referrer Glitch Overlay Controls -->
  <div style="margin-top:16px; padding:10px; background:rgba(102,126,234,0.1); border:1px solid rgba(102,126,234,0.3); border-radius:8px; max-width:550px;">
   <div style="color:#667eea; font-size:11px; width:100%; text-align:center; margin-bottom:8px; font-weight:600;">✨ Referrer Glitch Overlay</div>
   <div style="display:flex; gap:8px; flex-wrap:wrap;">
    <input id="manualUrlInput" type="text" placeholder="Enter URL (e.g. reddit.com/r/programming)" style="flex:1; min-width:280px; padding:8px 12px; background:#191a23; border:1px solid rgba(255,255,255,.1); border-radius:6px; color:#e8e8ee; font-size:11px" />
    <button id="manualTrigger" style="padding:8px 16px; background:#667eea; border:0; color:#fff; border-radius:6px; cursor:pointer; font-size:11px; font-weight:600;">Open</button>
   </div>
   <div style="display:flex; gap:6px; margin-top:6px; justify-content:center; flex-wrap:wrap;">
    <button id="quickHN" style="padding:6px 14px; background:#ff6600; border:0; color:#000; border-radius:6px; cursor:pointer; font-size:10px; font-weight:700;">Hacker News</button>
    <button id="quickReddit" style="padding:6px 14px; background:#ff4500; border:0; color:#fff; border-radius:6px; cursor:pointer; font-size:10px; font-weight:700;">Reddit</button>
    <button id="quickTwitter" style="padding:6px 14px; background:#1da1f2; border:0; color:#fff; border-radius:6px; cursor:pointer; font-size:10px; font-weight:700;">Zeed</button>
    <button id="quickFacebook" style="padding:6px 14px; background:#1877f2; border:0; color:#fff; border-radius:6px; cursor:pointer; font-size:10px; font-weight:700;">Facebook</button>
    <button id="quickLinkedIn" style="padding:6px 14px; background:#0a66c2; border:0; color:#fff; border-radius:6px; cursor:pointer; font-size:10px; font-weight:700;">LinkedIn</button>
    <a id="directFormLink" href="./templates/componentized/beta-focus-form.html" target="_blank" rel="noopener" style="padding:6px 14px; background:#20c997; border-radius:6px; color:#0b0f16; cursor:pointer; font-size:10px; font-weight:700; text-decoration:none; display:inline-flex; align-items:center; gap:4px;">
     <span aria-hidden="true">📝</span>
     <span>Beta Form</span>
    </a>
   </div>
  </div>
 </div>
 
 <!-- Scene Select Menu -->
 <div id="sceneSelect">
  <div class="scene-menu">
   <h2>Scene Select</h2>
   <p>Jump to previously experienced sequences</p>
   
   <div id="sceneOptions">
    <div class="scene-option" data-scene="intro">
     <div>INTRO → Boot Sequence</div>
     <div class="scene-option-desc">Launch the scripted onboarding experience</div>
    </div>

    <div class="scene-option" data-scene="visicalc">
     <div>VISICALC → Spreadsheet Emergence</div>
     <div class="scene-option-desc">The terminal awakens - spreadsheet reality unfolds</div>
    </div>

    <div class="scene-option" data-scene="city">
     <div>CITY → Neon Breakout</div>
     <div class="scene-option-desc">Transition directly into the debug city scene</div>
    </div>

    <div class="scene-option" data-url="./flash.html" style="border-left: 3px solid #f39c12;">
     <div>FLASH → Experimental Encounter</div>
     <div class="scene-option-desc">Open the Flash scene in a separate window</div>
    </div>

    <div class="scene-option locked" data-scene="leave">
     <div>LEAVE → Initialize</div>
     <div class="scene-option-desc">The house of leaves - GIR.mp3 transformation</div>
    </div>

    <div class="scene-option locked" data-scene="theos">
     <div>THE.OS → Cell Lattice</div>
     <div class="scene-option-desc">Cell address grid formation - witness the architecture</div>
    </div>

    <div class="scene-option locked" data-scene="blackhole">
     <div>THE.OS → Black Hole</div>
     <div class="scene-option-desc">The void manifests - singularity achieved</div>
    </div>

    <div class="scene-option locked" data-scene="end3">
     <div>HARD.CORE → End3 <span class="mode-badge"></span></div>
     <div class="scene-option-desc">Terminal environment - crawl sequence • <span class="mode-indicator"></span></div>
    </div>

   <div class="scene-option locked" data-scene="fullhand">
    <div>EXEC.ENV → Execution Environment <span class="mode-badge"></span></div>
    <div class="scene-option-desc">Integrated scene - voxel hand, keyboard, character & glowing head • <span class="mode-indicator"></span></div>
    <div class="scene-mode-toggle" style="margin-top: 8px; display: flex; gap: 8px;">
      <button class="mode-btn active" data-mode="sequence" data-scene-target="fullhand" style="flex: 1; padding: 6px 12px; background: #4a7cff; border: 1px solid #6a9cff; color: #fff; border-radius: 4px; cursor: pointer; font-size: 11px; transition: all 0.2s; pointer-events: auto;">Sequence</button>
      <button class="mode-btn" data-mode="debug" data-scene-target="fullhand" style="flex: 1; padding: 6px 12px; background: #2a2a2f; border: 1px solid #444; color: #ddd; border-radius: 4px; cursor: pointer; font-size: 11px; transition: all 0.2s; pointer-events: auto;">Debug</button>
    </div>
   </div>

    <div class="scene-option locked" data-scene="cellireal">
     <div>CELLI.REAL → Spreadsheet Reality <span class="mode-badge"></span></div>
     <div class="scene-option-desc">The awakened terminal - interactive spreadsheet environment • <span class="mode-indicator"></span></div>
    </div>
   
   <div class="scene-option" data-scene="rave" data-url="./templates/componentized/rave-complete.html" style="border-left: 3px solid #ff00ff;">
    <div>🎵 RAVE → Celli & Array Party</div>
    <div class="scene-option-desc">Both avatars in a shared rave environment - pulsing lights, music visualization, and dance animations</div>
   </div>

    <div class="scene-option" data-scene="sequence-builder" data-url="./tools/sequence-builder/index.html?standalone=true" style="border-left: 3px solid #ff6b6b;">
     <div>🎬 DEV.TOOLS → Sequence Builder</div>
     <div class="scene-option-desc">Visual node-based sequence composer (Press \ in any scene)</div>
    </div>

    <div class="scene-option" data-scene="test-runner" data-url="./tests/test-runner.html" style="border-left: 3px solid #4ec9b0;">
     <div>🧪 DEV.TOOLS → Test Runner</div>
     <div class="scene-option-desc">Automated unit & regression tests for Celli subsystems</div>
    </div>
   </div>
   
   <div class="scene-controls">
    <button id="debugToggle">Debug: Show All</button>
    <button id="clearProgress">Clear Progress</button>
    <button class="close-btn" id="closeSceneSelect">Close</button>
   </div>
  </div>
 </div>
 
 <!-- Skip Button -->
 <div id="skipBtn" class="skip-btn hidden" role="button" aria-label="Skip intro" tabindex="0">
  <div class="skip-triangle skip-triangle--left" id="skipTriangle1">
   <div class="skip-triangle__inner">
    <svg viewBox="0 0 100 86.6025403784" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
     <polygon points="0,0 0,86.6025403784 100,43.3012701892"></polygon>
     <path d="M0,12 L0,74.6025403784 Q0,86.6025403784 11.012,81.8342402525 L88.988,48.0696001263 Q100,43.3012701892 88.988,38.5329402521 L11.012,4.7679001263 Q0,0 0,12 Z"></path>
    </svg>
   </div>
  </div>
  <div class="skip-connector" id="skipConnector" aria-hidden="true"></div>
  <div class="skip-triangle skip-triangle--right" id="skipTriangle2">
   <div class="skip-triangle__inner">
    <svg viewBox="0 0 100 86.6025403784" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
     <polygon points="100,0 100,86.6025403784 0,43.3012701892"></polygon>
     <path d="M100,12 L100,74.6025403784 Q100,86.6025403784 88.988,81.8342402525 L11.012,48.0696001263 Q0,43.3012701892 11.012,38.5329402521 L88.988,4.7679001263 Q100,0 100,12 Z"></path>
    </svg>
   </div>
  </div>
 </div>
 
 <!-- Toast Notification -->
 <div id="toast" class="toast" style="display:none"></div>
 
 <div id="introOverlay"><div id="introBrand">celli.os<div class="brand-ver">v.0.0.1</div></div></div>
 <div id="world"></div>
 <canvas id="view"></canvas>
 
 <!-- UI Elements Container for Scene-Injected HTML -->
 <div id="uiContainer"></div>
 
 <!-- Sequence Builder Overlay Container -->
 <div id="sequence-overlay" style="display: none;"></div>
 
 <!-- Referrer Glitch Overlay -->
 <div id="celliRefOverlay" class="celli-ref-overlay" aria-hidden="true">
  <div class="celli-ref-mask"></div>
  <div class="celli-ref-panel" role="dialog" aria-modal="true" aria-labelledby="refTitle">
   <div class="ref-header">
    <div id="refLogo" class="ref-logo">SRC</div>
    <div class="ref-meta">
     <div id="refTitle" class="ref-title">Reconstructing previous page…</div>
     <div id="refSub" class="ref-sub">Please wait</div>
    </div>
    <button id="refClose" class="ref-close" aria-label="Close overlay">Close</button>
   </div>
   
   <div id="refList" class="ref-list"></div>
   
   <div class="ref-footer">
    <div class="ref-sub">Looks unstable — try "recreate" for another pass.</div>
    <div class="ref-controls">
     <a id="refFeedbackLink" class="btn ref-feedback-link" href="./templates/componentized/beta-focus-form.html" target="_blank" rel="noopener">Feedback form</a>
     <button id="refReset" class="btn" style="background: #3498db;">↻ Reset</button>
     <button id="refRecreate" class="btn">Recreate</button>
     <button id="refDismiss" class="btn">Dismiss</button>
    </div>
   </div>
   
   <div id="refGlitch" class="ref-glitch" aria-hidden="true"></div>
   <div class="scanlines"></div>
   
   <!-- Sidebar Ad -->
   <div id="refSidebar" class="ref-sidebar" style="display:none;">
    <button id="refSidebarClose" class="ref-sidebar-close" aria-label="Close sidebar">✕</button>
    <h3>✨ Wait, what just happened?</h3>
    <p>You clicked a link and reality started to break down. The glitch is spreading...</p>
    <div id="refSidebarUrl" class="ref-sidebar-url" style="display:none"></div>
    <p style="font-size:12px;opacity:.7">This reconstructed page is unstable. Each click destabilizes it further.</p>
    <button id="refSidebarAck" class="ref-sidebar-btn">Acknowledge Glitch</button>
    <div id="loomAudioStatus" class="loom-audio-status" aria-hidden="true">Streaming CallYouByMyName.mp3</div>
   </div>
  </div>
  
  <!-- Custom Cursor -->
  <div id="customCursor" class="custom-cursor"></div>
 </div>
 
 <!-- Tooltip -->
 <div id="refTooltip" class="ref-tooltip">
  <span class="ref-tooltip-bullet" aria-hidden="true"></span>
  <span class="ref-tooltip-text"></span>
 </div>
 
<!-- Edge Impact Effects -->
<div id="edgeImpact" class="edge-impact" aria-hidden="true"></div>
<div id="baseDarkness" class="base-darkness" aria-hidden="true"></div>
<div id="darkeningOverlay" class="darkening-overlay" aria-hidden="true"></div>
<div id="lightBeam" class="light-beam" aria-hidden="true"></div>

<!-- Video Player Overlay -->
<div id="videoPlayerOverlay" style="position:fixed; inset:0; background:#000; z-index:30000; display:none; flex-direction:column; align-items:center; justify-content:center;">
 <div style="position:relative; width:90vw; height:90vh; display:flex; align-items:center; justify-content:center;">
  <video id="introVideo" style="display:none;" crossorigin="anonymous"></video>
  <canvas id="videoCanvas" style="max-width:100%; max-height:100%; object-fit:contain;"></canvas>
  <div style="position:absolute; bottom:20px; right:20px; display:flex; gap:10px;">
   <button id="videoCloseBtn" style="padding:10px 20px; background:#e74c3c; border:none; border-radius:6px; color:white; cursor:pointer; font-weight:600;">✕ Close</button>
  </div>
 </div>
</div>

<!-- Import map for ES modules -->
 <script type="importmap">
 {
  "imports": {
   "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
   "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
 }
 </script>

 <!-- Main Application -->
 <script type="module" src="./src/scripts/main.js"></script>

 <!-- Referrer Glitch Overlay Logic -->
 <script type="module">
  import { voxelShatter } from './src/scripts/effects/VoxelShatter.js';
  /*
    Celli Referrer Glitch Overlay
    - Triggers on Reddit / Hacker News arrivals, or manual URL input
    - Pulls data via public JSON APIs (HN Firebase, Reddit .json)
  */
  
  console.log('🚀 REFERRER OVERLAY SCRIPT STARTING');
  console.error('=== DIAGNOSTIC MODE - CHECK FOR ERRORS BELOW ===');
  
  const overlay = document.getElementById('celliRefOverlay');
  const refHeader = document.querySelector('.ref-header');
  const refLogo = document.getElementById('refLogo');
  const refTitle = document.getElementById('refTitle');
  const refSub = document.getElementById('refSub');
  const refList = document.getElementById('refList');
  const btnClose = document.getElementById('refClose');
  const btnDismiss = document.getElementById('refDismiss');
  const btnRecreate = document.getElementById('refRecreate');
  const btnReset = document.getElementById('refReset');
  const refGlitch = document.getElementById('refGlitch');
  const refSidebar = document.getElementById('refSidebar');
  const refSidebarClose = document.getElementById('refSidebarClose');
  const refSidebarUrl = document.getElementById('refSidebarUrl');
  const refSidebarAck = document.getElementById('refSidebarAck');
  const loomAudioStatus = document.getElementById('loomAudioStatus');
  const refFeedbackLink = document.getElementById('refFeedbackLink');
  const LOOM_AUDIO_STATUS_TEXT = 'Streaming CallYouByMyName.mp3';
  const BETA_FOCUS_FORM_URL = './templates/componentized/beta-focus-form.html';
  let betaFormRedirectListenerAttached = false;
  let betaFormRedirectTimeoutId = null;

  if (refFeedbackLink) {
    refFeedbackLink.href = BETA_FOCUS_FORM_URL;
  }

  function setLoomAudioStatus(isPlaying) {
    if (!loomAudioStatus) return;
    if (isPlaying) {
      loomAudioStatus.style.display = 'block';
      loomAudioStatus.textContent = LOOM_AUDIO_STATUS_TEXT;
      loomAudioStatus.setAttribute('aria-hidden', 'false');
    } else {
      loomAudioStatus.style.display = 'none';
      loomAudioStatus.setAttribute('aria-hidden', 'true');
    }
  }

  const refTooltip = document.getElementById('refTooltip');
  const refTooltipText = refTooltip ? refTooltip.querySelector('.ref-tooltip-text') : null;
  const customCursor = document.getElementById('customCursor');
  const refPanel = document.querySelector('.celli-ref-panel');
  const edgeImpact = document.getElementById('edgeImpact');
  const baseDarkness = document.getElementById('baseDarkness');
  const darkeningOverlay = document.getElementById('darkeningOverlay');
  const lightBeam = document.getElementById('lightBeam');
  const chantAudio = new Audio('./chant.mp3');
  chantAudio.preload = 'auto';
  const CHANT_TARGET_VOLUME = 0.7;
  const CHANT_FADE_DURATION = 3200;
  chantAudio.volume = 0;
  document.documentElement.style.setProperty('--chant-reactive', '0');

  let chantAudioContext = null;
  let chantAudioSource = null;
  let chantAnalyser = null;
  let chantAnalyserData = null;
  let chantVisualizerFrameId = null;
  let chantVisualizerStartTimeout = null;
  let chantVisualizerLevel = 0;
  let chantVisualizerWarned = false;
  let chantUnlockHandler = null;

  chantAudio.addEventListener('play', () => startChantVisualizer(6000));
  chantAudio.addEventListener('ended', () => {
    setLoomAudioStatus(false);
    stopChantVisualizer();
  });
  chantAudio.addEventListener('pause', () => {
    if (chantAudio.currentTime === 0 || chantAudio.ended) {
      setLoomAudioStatus(false);
      stopChantVisualizer();
    }
  });

  function initChantAnalyser() {
    if (chantAnalyser) {
      return true;
    }

    const AudioContext = window.AudioContext || window.webkitAudioContext;
    if (!AudioContext) {
      if (!chantVisualizerWarned) {
        console.warn('⚠️ Web Audio API not supported; chant visualizer disabled.');
        chantVisualizerWarned = true;
      }
      return false;
    }

    try {
      if (!chantAudioContext) {
        chantAudioContext = new AudioContext();
      }

      if (!chantAudioSource) {
        chantAudioSource = chantAudioContext.createMediaElementSource(chantAudio);
      }

      chantAnalyser = chantAudioContext.createAnalyser();
      chantAnalyser.fftSize = 256;
      chantAnalyser.smoothingTimeConstant = 0.8;
      chantAudioSource.connect(chantAnalyser);
      chantAnalyser.connect(chantAudioContext.destination);
      chantAnalyserData = new Uint8Array(chantAnalyser.frequencyBinCount);
      return true;
    } catch (error) {
      if (!chantVisualizerWarned) {
        console.warn('⚠️ Unable to initialise chant visualizer:', error);
        chantVisualizerWarned = true;
      }
      chantAnalyser = null;
      chantAudioSource = null;
      return false;
    }
  }

  function updateChantVisualizer() {
    if (!chantAnalyser || !chantAnalyserData) {
      return;
    }

    chantAnalyser.getByteFrequencyData(chantAnalyserData);
    let sum = 0;
    for (let i = 0; i < chantAnalyserData.length; i += 1) {
      sum += chantAnalyserData[i];
    }

    const average = sum / chantAnalyserData.length / 255;
    const emphasis = Math.pow(Math.max(average, 0), 1.5);
    chantVisualizerLevel = (chantVisualizerLevel * 0.7) + (emphasis * 0.3);
    document.documentElement.style.setProperty('--chant-reactive', chantVisualizerLevel.toFixed(3));
    chantVisualizerFrameId = requestAnimationFrame(updateChantVisualizer);
  }

  function startChantVisualizer(delayMs = 0) {
    if (chantVisualizerStartTimeout) {
      clearTimeout(chantVisualizerStartTimeout);
      chantVisualizerStartTimeout = null;
    }

    const activate = () => {
      chantVisualizerStartTimeout = null;
      activateChantVisualizer();
    };

    if (delayMs <= 0) {
      activate();
    } else {
      chantVisualizerStartTimeout = window.setTimeout(activate, delayMs);
    }
  }

  function activateChantVisualizer() {
    if (!lightBeam) {
      return;
    }

    if (!initChantAnalyser()) {
      return;
    }

    if (chantAudioContext && chantAudioContext.state === 'suspended') {
      chantAudioContext.resume().catch((err) => {
        if (!chantVisualizerWarned) {
          console.warn('⚠️ Unable to resume audio context for chant visualizer:', err);
          chantVisualizerWarned = true;
        }
      });
    }

    lightBeam.classList.add('audio-reactive');
    if (refSidebarAck) {
      refSidebarAck.classList.add('audio-reactive');
    }

    if (!chantVisualizerFrameId) {
      chantVisualizerFrameId = requestAnimationFrame(updateChantVisualizer);
    }
  }

  function stopChantVisualizer() {
    if (chantVisualizerStartTimeout) {
      clearTimeout(chantVisualizerStartTimeout);
      chantVisualizerStartTimeout = null;
    }
    if (chantVisualizerFrameId) {
      cancelAnimationFrame(chantVisualizerFrameId);
      chantVisualizerFrameId = null;
    }

    chantVisualizerLevel = 0;
    document.documentElement.style.setProperty('--chant-reactive', '0');

    if (lightBeam) {
      lightBeam.classList.remove('audio-reactive');
    }

    if (refSidebarAck) {
      refSidebarAck.classList.remove('audio-reactive');
    }
  }

  function clearChantUnlockHandler() {
    if (!chantUnlockHandler) {
      return;
    }

    window.removeEventListener('pointerdown', chantUnlockHandler);
    window.removeEventListener('keydown', chantUnlockHandler);
    chantUnlockHandler = null;
  }

  function requestChantUnlockRetry() {
    if (chantUnlockHandler) {
      return;
    }

    chantUnlockHandler = async () => {
      try {
        await chantAudio.play();
        setLoomAudioStatus(true);
        clearChantUnlockHandler();
      } catch (unlockError) {
        console.warn('⚠️ Chant unlock attempt failed:', unlockError);
      }
    };

    window.addEventListener('pointerdown', chantUnlockHandler);
    window.addEventListener('keydown', chantUnlockHandler);
    console.info('🔊 Awaiting user interaction to unlock chant audio…');
  }

  // Track impact hits for progressive darkening
  let impactCount = 0;
  const MAX_IMPACTS_BEFORE_BEAM = 5;
  
  // Store items for glitching (all platforms)
  let hnItems = [];
  let redditItems = [];
  let twitterItems = [];
  let facebookItems = [];
  let linkedinItems = [];
  let currentView = 'none';
  let currentHNView = false;
  let parodiesComplete = false;
  let celliAdsComplete = false;
  let postTermsSequenceStarted = false;
  let goldenHoldOverlay = null;

  const TOOLTIP_THEME_CLASSES = [
    'ref-tooltip--hn',
    'ref-tooltip--reddit',
    'ref-tooltip--twitter',
    'ref-tooltip--facebook',
    'ref-tooltip--linkedin'
  ];

  const POST_PLATFORM_SELECTORS = {
    hn: '.hn-item',
    reddit: '.reddit-post',
    twitter: '.twitter-tweet',
    facebook: '.facebook-post',
    linkedin: '.linkedin-post'
  };
  let goldenHoldCleanup = null;
  let goldenHoldTimer = null;
  let goldenDustAnimationId = null;
  let noteAwaitingActivation = false;
  let noteHoverSequenceStarted = false;
  let loomAiMessageActive = false;
  let loomFakeAdActive = false;
  let noteEntryMonitorId = null;
  let noteEntryTickCount = 0;
  let noteHasEnteredFrame = false;
  let noteEntryFallbackTimer = null;
  let chantFadeFrameId = null;
  let noteStageTimeouts = [];
  let noteInteractionLocked = false;

  const PREFERS_REDUCED_MOTION = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

  const extraInviteState = {
    active: false,
    allowSpawns: true,
    scheduled: false,
    timers: [],
    peaks: null,
    scanningPromise: null,
    container: null,
    activePins: 0,
    totalSpawned: 0,
    upcomingTimes: [],
    startTime: 0,
    initialPairSpawned: false
  };

  const MAX_FLOATING_INVITES = 24;

  const LOOM_INVITE_EMBLEM = `
    <div class="loom-invite-emblem">
      <p class="loom-invite-line loom-invite-line--primary">.LOOMWORKS.</p>
      <p class="loom-invite-line loom-invite-line--secondary">..A SPECIAL INVITATION..</p>
      <p class="loom-invite-line loom-invite-line--tertiary">... A Beautiful Cell ...</p>
    </div>
  `;

  const FLOATING_INVITE_TEMPLATE = `
    <div class="loom-invite-clone-card">
      ${LOOM_INVITE_EMBLEM}
    </div>
  `;

  const triColorState = {
    canvas: null,
    ctx: null,
    particles: [],
    animationId: null,
    time: 0,
    enabled: true,
    lastTimestamp: null,
    pendingElevation: false,
    focusX: null,
    focusY: null
  };

  const debugPanelState = {
    panel: null,
    button: null,
    closeBtn: null,
    lightsToggle: null,
    triToggle: null,
    waveToggle: null,
    pinTotalEl: null,
    pinActiveEl: null,
    peakListEl: null,
    rescanBtn: null
  };

  const TOOLTIP_ANIMATION_DURATION = 700;
  const TOOLTIP_COLLISION_RATIO = 0.95;

  function clampSize(value, min, max) {
    return Math.min(Math.max(value, min), max);
  }

  function computeEdgeMetrics() {
    const viewportWidth = Math.max(window.innerWidth || 0, 320);
    const viewportHeight = Math.max(window.innerHeight || 0, 320);
    const edgePadding = clampSize(viewportWidth * 0.08, 24, 120);
    const impactWidth = clampSize(viewportWidth * 0.45, 220, 520);
    const lightBeamWidth = clampSize(viewportWidth * 0.9, 280, 960);
    const lightBeamHeight = clampSize(viewportHeight * 0.55, 160, 420);
    const lightRayWidth = clampSize(viewportWidth * 0.6, 200, 620);
    const lightRayHeight = clampSize(viewportHeight * 0.035, 12, 28);
    return {
      edgePadding,
      impactWidth,
      lightBeamWidth,
      lightBeamHeight,
      lightRayWidth,
      lightRayHeight
    };
  }

  let edgeMetrics = computeEdgeMetrics();

  function getEdgeMetrics() {
    if (!edgeMetrics) {
      edgeMetrics = computeEdgeMetrics();
    }
    return edgeMetrics;
  }

  function applyEdgeMetrics() {
    edgeMetrics = computeEdgeMetrics();
    const rootStyle = document.documentElement.style;

    rootStyle.setProperty('--ref-edge-impact-width', `${edgeMetrics.impactWidth}px`);
    rootStyle.setProperty('--ref-edge-offset', `${edgeMetrics.edgePadding}px`);
    rootStyle.setProperty('--ref-light-beam-width', `${edgeMetrics.lightBeamWidth}px`);
    rootStyle.setProperty('--ref-light-beam-height', `${edgeMetrics.lightBeamHeight}px`);
    rootStyle.setProperty('--ref-light-beam-blur', `${Math.round(edgeMetrics.lightBeamHeight * 0.05)}px`);
    rootStyle.setProperty('--ref-light-ray-width', `${edgeMetrics.lightRayWidth}px`);
    rootStyle.setProperty('--ref-light-ray-height', `${edgeMetrics.lightRayHeight}px`);
    const rayBlur = Math.max(8, edgeMetrics.lightRayHeight * 2.4);
    rootStyle.setProperty('--ref-light-ray-blur', `${Math.round(rayBlur)}px`);
  }

  function getTooltipMetrics() {
    const metrics = getEdgeMetrics();
    const viewportWidth = window.innerWidth || document.documentElement.clientWidth || 1280;
    const availableWidth = Math.max(180, viewportWidth - (metrics.edgePadding * 2));
    const tooltipWidth = Math.min(400, availableWidth);
    const verticalOffset = Math.max(28, Math.min(72, metrics.edgePadding * 0.9));
    return { tooltipWidth, edgePadding: metrics.edgePadding, verticalOffset };
  }

  function updateSharedTooltipWidth() {
    if (!refTooltip) {
      return;
    }
    const { tooltipWidth } = getTooltipMetrics();
    refTooltip.style.width = `${tooltipWidth}px`;
    refTooltip.style.maxWidth = `${tooltipWidth}px`;
  }

  function updateActiveTooltipEdgeDistance() {
    const metrics = getTooltipMetrics();
    const viewportWidth = window.innerWidth || document.documentElement.clientWidth || 1280;

    document.querySelectorAll('.ref-tooltip.morphing').forEach((tooltip) => {
      const storedWidth = parseFloat(tooltip.dataset.tooltipWidth || '0');
      const storedLeft = parseFloat(tooltip.dataset.initialLeft || '0');
      const tooltipWidth = storedWidth || metrics.tooltipWidth;
      const initialLeft = Number.isFinite(storedLeft) ? storedLeft : 0;
      const edgePadding = metrics.edgePadding;
      const distanceToEdge = Math.max(0, viewportWidth - edgePadding - (initialLeft + tooltipWidth));
      tooltip.style.setProperty('--edge-distance', `${distanceToEdge}px`);
    });
  }

  applyEdgeMetrics();
  updateSharedTooltipWidth();

  window.addEventListener('resize', () => {
    applyEdgeMetrics();
    updateSharedTooltipWidth();
    updateActiveTooltipEdgeDistance();
    resizeTriColorCanvas();
  });

  function ensureExtraInviteContainer() {
    if (extraInviteState.container && extraInviteState.container.parentNode) {
      return extraInviteState.container;
    }
    const swarm = document.createElement('div');
    swarm.id = 'loomInviteSwarm';
    swarm.className = 'loom-invite-swarm';
    document.body.appendChild(swarm);
    extraInviteState.container = swarm;
    return swarm;
  }

  function updatePinLightCountDisplay() {
    if (debugPanelState.pinTotalEl) {
      debugPanelState.pinTotalEl.textContent = String(extraInviteState.totalSpawned);
    }
    if (debugPanelState.pinActiveEl) {
      debugPanelState.pinActiveEl.textContent = String(extraInviteState.activePins);
    }
  }

  function updateDebugPeaksDisplay(times, source = 'idle') {
    if (!debugPanelState.peakListEl) {
      return;
    }
    if (!times || times.length === 0) {
      debugPanelState.peakListEl.textContent = source === 'scanning' ? 'scanning…' : '—';
      return;
    }
    debugPanelState.peakListEl.textContent = times.map((time) => `${time.toFixed(1)}s`).join(', ');
  }

  function resizeTriColorCanvas() {
    if (!triColorState.canvas) {
      return;
    }
    const dpr = window.devicePixelRatio || 1;
    const width = window.innerWidth || document.documentElement.clientWidth || 1280;
    const height = window.innerHeight || document.documentElement.clientHeight || 720;
    triColorState.canvas.width = Math.floor(width * dpr);
    triColorState.canvas.height = Math.floor(height * dpr);
    triColorState.canvas.style.width = `${width}px`;
    triColorState.canvas.style.height = `${height}px`;
    if (triColorState.ctx) {
      triColorState.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    if (triColorState.particles && triColorState.particles.length) {
      triColorState.particles = createTriColorParticles();
    }
    updateTriColorFocus();
  }

  function getInviteFocusPoint() {
    const card = refSidebarAck?.querySelector('.loom-invite-card');
    if (card) {
      const rect = card.getBoundingClientRect();
      return {
        x: rect.left + rect.width / 2,
        y: rect.top + rect.height / 2
      };
    }
    if (refSidebarAck) {
      const rect = refSidebarAck.getBoundingClientRect();
      return {
        x: rect.left + rect.width / 2,
        y: rect.top + rect.height / 2
      };
    }
    const fallbackWidth = window.innerWidth || document.documentElement.clientWidth || 1280;
    const fallbackHeight = window.innerHeight || document.documentElement.clientHeight || 720;
    return { x: fallbackWidth / 2, y: fallbackHeight / 2 };
  }

  function updateTriColorFocus() {
    const point = getInviteFocusPoint();
    triColorState.focusX = point.x;
    triColorState.focusY = point.y;
  }

  function createTriColorParticles() {
    const width = (triColorState.canvas?.width || window.innerWidth || 1280) / (window.devicePixelRatio || 1);
    const height = (triColorState.canvas?.height || window.innerHeight || 720) / (window.devicePixelRatio || 1);
    const palette = [
      { base: [255, 30, 110], accent: [255, 163, 210] },
      { base: [0, 168, 255], accent: [126, 214, 255] },
      { base: [255, 182, 46], accent: [255, 227, 130] }
    ];
    updateTriColorFocus();
    const anchorX = Number.isFinite(triColorState.focusX) ? triColorState.focusX : width / 2;
    const anchorY = Number.isFinite(triColorState.focusY) ? triColorState.focusY : height / 2;
    const particleCount = Math.round(Math.max(width, height) / 24);
    const radiusBase = Math.min(width, height) * 0.22;
    const jitterX = radiusBase * 0.2;
    const jitterY = radiusBase * 0.16;
    const particles = [];
    for (let i = 0; i < particleCount; i += 1) {
      const tone = palette[i % palette.length];
      particles.push({
        angle: Math.random() * Math.PI * 2,
        radius: radiusBase * (0.32 + Math.random() * 0.28),
        speed: 0.45 + Math.random() * 0.35,
        wobble: 0.28 + Math.random() * 0.22,
        size: 8 + Math.random() * 9,
        alpha: 0.42 + Math.random() * 0.35,
        verticalScale: 0.48 + Math.random() * 0.22,
        offset: Math.random() * Math.PI * 2,
        baseColor: tone.base,
        accentColor: tone.accent,
        anchorX: anchorX + (Math.random() - 0.5) * jitterX,
        anchorY: anchorY + (Math.random() - 0.5) * jitterY
      });
    }
    return particles;
  }

  function renderTriColorParticles(timestamp) {
    if (!triColorState.enabled || !triColorState.ctx) {
      triColorState.animationId = null;
      return;
    }
    if (triColorState.lastTimestamp === null) {
      triColorState.lastTimestamp = timestamp;
    }
    const delta = Math.max(0.001, (timestamp - triColorState.lastTimestamp) / 1000);
    triColorState.lastTimestamp = timestamp;
    triColorState.time += delta;

    const ctx = triColorState.ctx;
    const width = triColorState.canvas.width / (window.devicePixelRatio || 1);
    const height = triColorState.canvas.height / (window.devicePixelRatio || 1);
    const reactiveLevel = Math.min(1, Math.max(0, chantVisualizerLevel || 0));
    const reactivePulse = 1 + reactiveLevel * 0.45;
    ctx.clearRect(0, 0, width, height);
    ctx.globalCompositeOperation = 'lighter';

    const fallbackX = Number.isFinite(triColorState.focusX) ? triColorState.focusX : width / 2;
    const fallbackY = Number.isFinite(triColorState.focusY) ? triColorState.focusY : height / 2;

    triColorState.particles.forEach((particle) => {
      particle.angle += delta * particle.speed;
      const wobble = Math.sin(triColorState.time * particle.wobble + particle.offset) * 0.18;
      const orbitRadius = particle.radius * (1 + reactiveLevel * 0.08);
      const anchorX = Number.isFinite(particle.anchorX) ? particle.anchorX : fallbackX;
      const anchorY = Number.isFinite(particle.anchorY) ? particle.anchorY : fallbackY;
      const x = anchorX + Math.cos(particle.angle) * orbitRadius;
      const y = anchorY + Math.sin(particle.angle) * orbitRadius * (particle.verticalScale + wobble);
      const pulse = 1 + Math.sin(triColorState.time * 1.4 + particle.offset) * 0.28;
      const size = particle.size * pulse * reactivePulse;
      const gradient = ctx.createRadialGradient(x, y, 0, x, y, size * 2.6);
      const baseAlpha = particle.alpha + reactiveLevel * 0.22;
      gradient.addColorStop(0, `rgba(255,255,255,${0.8 * baseAlpha})`);
      gradient.addColorStop(0.38, `rgba(255,255,255,${0.26 * baseAlpha})`);
      gradient.addColorStop(0.7, `rgba(${particle.accentColor[0]},${particle.accentColor[1]},${particle.accentColor[2]},${(0.42 + reactiveLevel * 0.25) * baseAlpha})`);
      gradient.addColorStop(1, `rgba(${particle.baseColor[0]},${particle.baseColor[1]},${particle.baseColor[2]},0)`);
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(x, y, size * 2.6, 0, Math.PI * 2);
      ctx.globalAlpha = Math.min(1, baseAlpha);
      ctx.fill();
    });

    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = 'source-over';
    triColorState.animationId = requestAnimationFrame(renderTriColorParticles);
  }

  function startTriColorLoop() {
    if (!triColorState.enabled) {
      return;
    }
    if (triColorState.animationId) {
      cancelAnimationFrame(triColorState.animationId);
    }
    triColorState.lastTimestamp = null;
    triColorState.animationId = requestAnimationFrame(renderTriColorParticles);
  }

  function initTriColorParticles() {
    if (triColorState.canvas) {
      resizeTriColorCanvas();
      return;
    }
    const canvas = document.createElement('canvas');
    canvas.id = 'triColorParticles';
    canvas.className = 'tri-color-particles';
    if (triColorState.pendingElevation) {
      canvas.classList.add('tri-color-particles--foreground');
    }
    document.body.appendChild(canvas);
    const ctx = canvas.getContext('2d');
    if (!ctx) {
      return;
    }
    triColorState.canvas = canvas;
    triColorState.ctx = ctx;
    resizeTriColorCanvas();
    triColorState.particles = createTriColorParticles();
    triColorState.time = 0;
    triColorState.enabled = true;
    startTriColorLoop();
  }

  function setTriColorEnabled(enabled) {
    triColorState.enabled = enabled;
    if (!triColorState.canvas) {
      if (enabled) {
        initTriColorParticles();
      }
      return;
    }
    if (enabled) {
      triColorState.canvas.style.display = 'block';
      if (triColorState.pendingElevation) {
        triColorState.canvas.classList.add('tri-color-particles--foreground');
      }
      triColorState.lastTimestamp = null;
      startTriColorLoop();
    } else {
      if (triColorState.animationId) {
        cancelAnimationFrame(triColorState.animationId);
        triColorState.animationId = null;
      }
      triColorState.canvas.style.display = 'none';
      triColorState.lastTimestamp = null;
    }
  }

  function elevateTriColorLayer() {
    triColorState.pendingElevation = true;
    if (triColorState.canvas) {
      triColorState.canvas.classList.add('tri-color-particles--foreground');
    }
  }

  function resetTriColorLayer() {
    triColorState.pendingElevation = false;
    if (triColorState.canvas) {
      triColorState.canvas.classList.remove('tri-color-particles--foreground');
    }
  }

  function cancelExtraInviteSchedule({ clearPins = true, keepActive = false } = {}) {
    extraInviteState.timers.forEach((id) => clearTimeout(id));
    extraInviteState.timers = [];
    if (clearPins && extraInviteState.container) {
      extraInviteState.container.innerHTML = '';
      extraInviteState.activePins = 0;
      extraInviteState.totalSpawned = 0;
      updatePinLightCountDisplay();
    }
    if (!keepActive) {
      extraInviteState.active = false;
      extraInviteState.scheduled = false;
      extraInviteState.upcomingTimes = [];
      extraInviteState.startTime = 0;
      extraInviteState.initialPairSpawned = false;
      updateDebugPeaksDisplay([], 'idle');
    }
  }

  function createFloatingInvite({ left, top, scale = 0.9, tilt = 0, delay = 0 } = {}) {
    if (extraInviteState.totalSpawned >= MAX_FLOATING_INVITES) {
      return null;
    }
    const container = ensureExtraInviteContainer();
    if (!container) {
      return null;
    }
    const clampedLeft = Math.min(88, Math.max(12, left));
    const clampedTop = Math.min(84, Math.max(16, top));
    const invite = document.createElement('div');
    invite.className = 'loom-invite-clone';
    invite.innerHTML = FLOATING_INVITE_TEMPLATE;
    invite.style.setProperty('--invite-left', `${clampedLeft}%`);
    invite.style.setProperty('--invite-top', `${clampedTop}%`);
    invite.style.setProperty('--invite-scale', `${Math.max(0.6, scale)}`);
    invite.style.setProperty('--invite-tilt', `${tilt}`);
    invite.style.setProperty('--invite-delay', `${Math.max(0, delay)}ms`);
    invite.setAttribute('role', 'button');
    invite.setAttribute('tabindex', '0');
    invite.setAttribute('aria-label', 'Open Loomworks invitation');
    if (PREFERS_REDUCED_MOTION) {
      invite.classList.add('reduced-motion');
    }
    const handleInviteActivation = (event) => {
      event.preventDefault();
      if (refSidebarAck) {
        requestAnimationFrame(() => refSidebarAck.focus({ preventScroll: true }));
        refSidebarAck.click();
      }
    };
    invite.addEventListener('click', handleInviteActivation);
    invite.addEventListener('keydown', (event) => {
      if (event.key === 'Enter' || event.key === ' ') {
        handleInviteActivation(event);
      }
    });
    container.appendChild(invite);

    const reveal = () => {
      invite.classList.add('visible');
    };
    if (delay > 0) {
      setTimeout(() => requestAnimationFrame(reveal), delay);
    } else {
      requestAnimationFrame(reveal);
    }

    extraInviteState.totalSpawned += 1;
    extraInviteState.activePins = extraInviteState.totalSpawned;
    updatePinLightCountDisplay();
    return invite;
  }

  function spawnHoverInvitePair() {
    if (extraInviteState.totalSpawned > 0) {
      return;
    }
    createFloatingInvite({ left: 32, top: 38, scale: 0.94, tilt: '-3deg', delay: 0 });
    createFloatingInvite({ left: 68, top: 62, scale: 0.9, tilt: '2deg', delay: 220 });
  }

  function spawnExtraInviteWave(waveIndex) {
    if (!extraInviteState.active || !extraInviteState.allowSpawns) {
      return;
    }
    if (extraInviteState.totalSpawned >= MAX_FLOATING_INVITES) {
      return;
    }

    if (waveIndex === 0 && !extraInviteState.initialPairSpawned) {
      spawnHoverInvitePair();
      extraInviteState.initialPairSpawned = true;
    } else {
      const invitesThisWave = Math.min(4, 2 + Math.floor(waveIndex / 2));
      for (let i = 0; i < invitesThisWave; i += 1) {
        const jitter = (Math.random() - 0.5) * 6;
        const left = 24 + Math.random() * 52;
        const top = 24 + Math.random() * 52;
        const scale = 0.78 + Math.random() * 0.28;
        const delay = i * 160 + Math.random() * 180;
        createFloatingInvite({ left, top, scale, tilt: `${jitter}deg`, delay });
      }
    }

    if (extraInviteState.upcomingTimes.length) {
      extraInviteState.upcomingTimes.shift();
      updateDebugPeaksDisplay(extraInviteState.upcomingTimes, 'active');
    }
  }

  function scheduleInviteWavesFromPeaks(times, sourceLabel) {
    if (!extraInviteState.active) {
      return;
    }
    const filtered = (times || []).filter((time) => Number.isFinite(time) && time >= 6);
    if (!filtered.length) {
      return;
    }
    cancelExtraInviteSchedule({ clearPins: false, keepActive: true });
    extraInviteState.active = true;
    extraInviteState.scheduled = true;
    extraInviteState.upcomingTimes = filtered.slice();
    updateDebugPeaksDisplay(extraInviteState.upcomingTimes, sourceLabel);
    const baseTime = extraInviteState.startTime || performance.now();
    if (!extraInviteState.startTime) {
      extraInviteState.startTime = baseTime;
    }
    extraInviteState.timers = filtered.map((time, index) => {
      const delay = Math.max(0, time * 1000 - (performance.now() - baseTime));
      return setTimeout(() => spawnExtraInviteWave(index), delay);
    });
  }

  async function getChantPeaks(force = false) {
    if (!force && extraInviteState.peaks) {
      return extraInviteState.peaks;
    }
    if (!force && extraInviteState.scanningPromise) {
      return extraInviteState.scanningPromise;
    }

    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    if (!AudioCtx) {
      extraInviteState.peaks = [];
      return [];
    }

    const fetchPromise = fetch('./chant.mp3')
      .then((response) => {
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        return response.arrayBuffer();
      })
      .then(async (arrayBuffer) => {
        let audioContext;
        try {
          audioContext = new AudioCtx();
        } catch (contextError) {
          console.warn('⚠️ Unable to initialise audio context for peak scan:', contextError);
          return [];
        }
        try {
          const audioBuffer = await audioContext.decodeAudioData(arrayBuffer.slice(0));
          const peaks = analyzeAudioPeaks(audioBuffer);
          extraInviteState.peaks = peaks;
          return peaks;
        } finally {
          audioContext.close().catch(() => {});
        }
      })
      .catch((error) => {
        console.warn('⚠️ Chant peak analysis failed:', error);
        extraInviteState.peaks = [];
        return [];
      })
      .finally(() => {
        extraInviteState.scanningPromise = null;
      });

    extraInviteState.scanningPromise = fetchPromise;
    return fetchPromise;
  }

  function analyzeAudioPeaks(audioBuffer) {
    if (!audioBuffer) {
      return [];
    }
    const channelData = audioBuffer.getChannelData(0);
    const sampleRate = audioBuffer.sampleRate || 44100;
    const windowSize = Math.floor(sampleRate * 0.45);
    const hopSize = Math.max(1024, Math.floor(windowSize / 2));
    const rmsValues = [];
    let maxRms = 0;
    let sumRms = 0;
    let count = 0;

    for (let i = 0; i < channelData.length; i += hopSize) {
      let accumulator = 0;
      const limit = Math.min(windowSize, channelData.length - i);
      if (limit <= 0) {
        continue;
      }
      for (let j = 0; j < limit; j += 1) {
        const sample = channelData[i + j];
        accumulator += sample * sample;
      }
      const rms = Math.sqrt(accumulator / limit);
      rmsValues.push({ time: i / sampleRate, rms });
      maxRms = Math.max(maxRms, rms);
      sumRms += rms;
      count += 1;
    }

    if (!count) {
      return [];
    }

    const averageRms = sumRms / count;
    const threshold = averageRms + (maxRms - averageRms) * 0.5;
    const selected = [];
    const minGapSeconds = 2.4;
    rmsValues.forEach(({ time, rms }) => {
      if (rms < threshold) {
        return;
      }
      if (selected.some((existing) => Math.abs(existing - time) < minGapSeconds)) {
        return;
      }
      selected.push(time);
    });

    selected.sort((a, b) => a - b);
    return selected.slice(0, 8).map((value) => Number(value.toFixed(2)));
  }

  function scheduleExtraLoomInvites() {
    if (!noteAwaitingActivation || !extraInviteState.allowSpawns) {
      return;
    }
    if (extraInviteState.scheduled) {
      return;
    }
    ensureExtraInviteContainer();
    cancelExtraInviteSchedule({ clearPins: false, keepActive: true });
    extraInviteState.active = true;
    extraInviteState.scheduled = true;
    extraInviteState.upcomingTimes = [];
    extraInviteState.startTime = performance.now();
    extraInviteState.initialPairSpawned = false;

    const fallbackTimes = [6, 10.5, 15.5];
    extraInviteState.upcomingTimes = fallbackTimes.slice();
    updateDebugPeaksDisplay(extraInviteState.upcomingTimes, 'fallback');
    extraInviteState.timers = fallbackTimes.map((time, index) => {
      const delay = Math.max(0, time * 1000 - (performance.now() - extraInviteState.startTime));
      return setTimeout(() => spawnExtraInviteWave(index), delay);
    });

    getChantPeaks().then((peaks) => {
      if (!extraInviteState.active) {
        return;
      }
      scheduleInviteWavesFromPeaks(peaks, 'scan');
    });
  }

  function handlePrimaryInviteCentered() {
    const sidebar = refSidebar;
    const finalizeCentering = () => {
      scheduleExtraLoomInvites();
      elevateTriColorLayer();
      noteInteractionLocked = false;
      document.body.classList.add('ref-note-centered');
      updateTriColorFocus();
    };

    if (!sidebar) {
      finalizeCentering();
      return;
    }

    if (sidebar.classList.contains('stage-float')) {
      sidebar.classList.remove('stage-float');
    }

    try {
      const rect = sidebar.getBoundingClientRect();
      const viewportWidth = window.innerWidth || document.documentElement.clientWidth || 1280;
      const viewportHeight = window.innerHeight || document.documentElement.clientHeight || 720;
      const currentTransform = window.getComputedStyle(sidebar).transform;
      const baseMatrix = currentTransform && currentTransform !== 'none'
        ? new DOMMatrixReadOnly(currentTransform)
        : new DOMMatrixReadOnly();
      const targetX = viewportWidth / 2;
      const targetY = viewportHeight / 2;
      const sidebarCenterX = rect.left + rect.width / 2;
      const sidebarCenterY = rect.top + rect.height / 2;
      const deltaX = targetX - sidebarCenterX;
      const deltaY = targetY - sidebarCenterY;
      const targetMatrix = baseMatrix.translate(deltaX, deltaY);

      const animation = sidebar.animate(
        [
          { transform: `matrix(${baseMatrix.a},${baseMatrix.b},${baseMatrix.c},${baseMatrix.d},${baseMatrix.e},${baseMatrix.f})` },
          { transform: `matrix(${targetMatrix.a},${targetMatrix.b},${targetMatrix.c},${targetMatrix.d},${targetMatrix.e},${targetMatrix.f})` }
        ],
        { duration: 950, easing: 'cubic-bezier(0.33, 1, 0.68, 1)', fill: 'forwards' }
      );

      const complete = () => {
        sidebar.classList.add('stage-sweep');
        sidebar.style.transform = '';
        finalizeCentering();
      };

      animation.addEventListener('finish', () => {
        animation.commitStyles();
        animation.cancel();
        complete();
      }, { once: true });

      animation.addEventListener('cancel', complete, { once: true });
    } catch (error) {
      console.warn('⚠️ Smooth centering fallback engaged:', error);
      sidebar.classList.add('stage-sweep');
      finalizeCentering();
    }
  }

  function createDebugPanel() {
    if (debugPanelState.panel) {
      return;
    }

    const button = document.createElement('button');
    button.type = 'button';
    button.className = 'debug-panel-button';
    button.textContent = 'Debug Panel';
    button.setAttribute('aria-expanded', 'false');
    document.body.appendChild(button);
    debugPanelState.button = button;

    const panel = document.createElement('div');
    panel.className = 'debug-panel';
    panel.innerHTML = `
      <div class="debug-panel__header">
        <span>Debug Controls</span>
        <button type="button" class="debug-panel__close" aria-label="Close debug panel">×</button>
      </div>
      <div class="debug-panel__section">
        <label class="debug-toggle">
          <input type="checkbox" id="debugToggleLights" checked>
          <span>Show light layers</span>
        </label>
        <label class="debug-toggle">
          <input type="checkbox" id="debugToggleTriColor" checked>
          <span>Tri-color particles</span>
        </label>
        <label class="debug-toggle">
          <input type="checkbox" id="debugToggleInviteWaves" checked>
          <span>Extra invite waves</span>
        </label>
      </div>
      <div class="debug-panel__section debug-panel__stats">
        <div>Total pin lights: <span id="debugPinTotal">0</span></div>
        <div>Active pin lights: <span id="debugPinActive">0</span></div>
      </div>
      <div class="debug-panel__section debug-panel__stats">
        <div>Invite pulses: <span id="debugPeakTimes">—</span></div>
      </div>
      <div class="debug-panel__section">
        <button type="button" class="debug-panel__cta" id="debugRescanPeaks">Rescan audio peaks</button>
      </div>
    `;
    document.body.appendChild(panel);

    debugPanelState.panel = panel;
    debugPanelState.closeBtn = panel.querySelector('.debug-panel__close');
    debugPanelState.lightsToggle = panel.querySelector('#debugToggleLights');
    debugPanelState.triToggle = panel.querySelector('#debugToggleTriColor');
    debugPanelState.waveToggle = panel.querySelector('#debugToggleInviteWaves');
    debugPanelState.pinTotalEl = panel.querySelector('#debugPinTotal');
    debugPanelState.pinActiveEl = panel.querySelector('#debugPinActive');
    debugPanelState.peakListEl = panel.querySelector('#debugPeakTimes');
    debugPanelState.rescanBtn = panel.querySelector('#debugRescanPeaks');

    button.addEventListener('click', () => {
      const visible = !panel.classList.contains('visible');
      panel.classList.toggle('visible', visible);
      button.setAttribute('aria-expanded', visible ? 'true' : 'false');
      if (visible) {
        updatePinLightCountDisplay();
        if (extraInviteState.upcomingTimes.length) {
          updateDebugPeaksDisplay(extraInviteState.upcomingTimes, 'active');
        }
      }
    });

    if (debugPanelState.closeBtn) {
      debugPanelState.closeBtn.addEventListener('click', () => {
        panel.classList.remove('visible');
        button.setAttribute('aria-expanded', 'false');
      });
    }

    if (debugPanelState.lightsToggle) {
      debugPanelState.lightsToggle.addEventListener('change', (event) => {
        if (event.target.checked) {
          document.body.classList.remove('debug-hide-light-layers');
        } else {
          document.body.classList.add('debug-hide-light-layers');
        }
      });
    }

    if (debugPanelState.triToggle) {
      debugPanelState.triToggle.addEventListener('change', (event) => {
        const enabled = !!event.target.checked;
        document.body.classList.toggle('debug-hide-tri-color', !enabled);
        setTriColorEnabled(enabled);
      });
    }

    if (debugPanelState.waveToggle) {
      debugPanelState.waveToggle.addEventListener('change', (event) => {
        const enabled = !!event.target.checked;
        document.body.classList.toggle('debug-hide-invite-waves', !enabled);
        extraInviteState.allowSpawns = enabled;
        if (!enabled) {
          cancelExtraInviteSchedule();
        } else if (noteHasEnteredFrame && noteAwaitingActivation) {
          scheduleExtraLoomInvites();
        }
      });
    }

    if (debugPanelState.rescanBtn) {
      debugPanelState.rescanBtn.addEventListener('click', () => {
        extraInviteState.peaks = null;
        if (extraInviteState.scanningPromise) {
          extraInviteState.scanningPromise = null;
        }
        updateDebugPeaksDisplay([], 'scanning');
        getChantPeaks(true).then((peaks) => {
          if (extraInviteState.active) {
            cancelExtraInviteSchedule({ clearPins: true, keepActive: true });
            if (extraInviteState.allowSpawns && noteAwaitingActivation) {
              scheduleInviteWavesFromPeaks(peaks, 'scan');
            }
          } else {
            const filtered = (peaks || []).filter((time) => Number.isFinite(time) && time >= 6);
            extraInviteState.upcomingTimes = filtered.slice();
            updateDebugPeaksDisplay(filtered, 'scan');
          }
        });
      });
    }

    updatePinLightCountDisplay();
  }

  initTriColorParticles();
  createDebugPanel();

  function createGlitchState() {
    return { stage: 'parody', nextIndex: 0 };
  }

  function createGlitchProgressMap() {
    return {
      hn: createGlitchState(),
      reddit: createGlitchState(),
      twitter: createGlitchState(),
      facebook: createGlitchState(),
      linkedin: createGlitchState()
    };
  }

  let glitchProgress = createGlitchProgressMap();

  function resetGlitchProgress(platformType) {
    if (platformType && glitchProgress[platformType]) {
      glitchProgress[platformType] = createGlitchState();
    } else {
      glitchProgress = createGlitchProgressMap();
    }
  }

  function getCurrentLink(element, fallback) {
    if (!element) return fallback;
    return element.dataset.glitchLink || element.getAttribute('href') || fallback;
  }

  function setGlitchLink(element, url) {
    if (!element) return;
    element.dataset.glitchLink = url;
    if (element.tagName === 'A') {
      element.setAttribute('href', url);
    }
  }

  function buildGlitchUrl(platformKey, stage, index) {
    const path = stage === 'celli' ? 'celli' : 'gags';
    return `https://loomworks.xyz/${path}/${platformKey}-${index + 1}`;
  }

  // Parody headlines
  const parodyHeadlines = [
    "Show HN: Dyson Sphere Made from Dyson Vacuum and Home-Built Particle Accelerator",
    "Ask HN: Why Does My Code Work Better When I'm Not Looking at It?",
    "Show HN: I Trained GPT on My Therapy Sessions, Now It Won't Stop Asking If I'm Okay",
    "I Quit My $500K FAANG Job to Build a Startup That Tells You When to Quit Your Job",
    "Show HN: Blockchain-Based TODO List (Gas Fees Apply to Each Checkmark)",
    "My Weekend Project Became a Unicorn and Now I Miss My Weekends",
    "Show HN: Neural Network That Predicts When Your Neural Network Will Fail",
    "Ask HN: Is It Normal That My Smart Fridge is Running a Mining Pool?",
    "I Wrote Assembly for My Coffee Maker and Now It Judges My Life Choices",
    "Show HN: Startup Idea Generator Powered by Startup Idea Generators",
    "Ask HN: My AI Assistant Quit. Should I Write a Reference Letter?",
    "Show HN: Decentralized Ping-Pong Score Tracker Using WebRTC and Tears",
    "I Optimized My Life With Algorithms and Now I Can't Make Simple Decisions",
    "Show HN: Browser Extension That Blocks Distractions by Adding More Distractions",
    "Ask HN: Can I Put 'Survived HN Front Page' on My Resume?",
    "Show HN: I Replaced My Team With Python Scripts (They're Less Buggy)",
    "My Side Project Got More GitHub Stars Than My Main Job's Product",
    "Show HN: Real-Time Collaborative Notepad for Writing Code You'll Delete Later",
    "Ask HN: Is Burning Out Considered a Design Pattern Now?",
    "I Built a Compiler That Only Works During Mercury Retrograde"
  ];
  
  // Celli ads (second pass glitch replacements)
  const celliAds = [
    "Celli: A Spatial Spreadsheet orchestrating galaxies of knowledge.",
    "Celli: A Special Friendship for you and every dataset you adore.",
    "Celli: A World in a Box — open it at loomworks.xyz.",
    "Celli: Where Data Comes to Life and Life Comes to Data.",
    "loomworks.xyz presents Celli: Your command center for living spreadsheets.",
    "Celli: A Spatial Spreadsheet that loves your wildest what-ifs.",
    "Celli: A Special Friendship, sealed at loomworks.xyz/hello.",
    "Celli: A World in a Box — shake it and new workflows fall out.",
    "Celli: Where Data Comes to Life, and the lights stay on for you.",
    "Celli at loomworks.xyz: Because rows deserve horizons.",
    "Celli: A Spatial Spreadsheet whispering 'build bigger'.",
    "Celli: A Special Friendship between logic and imagination.",
    "Celli: A World in a Box, curated by loomworks.xyz.",
    "Celli: Where Data Comes to Life; RSVP at loomworks.xyz/invite.",
    "Celli: A Spatial Spreadsheet crowned with impossible delight.",
    "Celli: A Special Friendship that refactors reality.",
    "Celli: A World in a Box with front-row seats at loomworks.xyz.",
    "Celli: Where Data Comes to Life and Life Comes to Data — daily.",
    "Celli: A Spatial Spreadsheet for people who outgrow flat files.",
    "Celli: A World in a Box, glowing brighter at loomworks.xyz/celli."
  ];
  
  // Reddit parodies
  const redditParodies = [
    "TIL that the inventor of autocorrect has died. Restaurant in pieces.",
    "AITA for teaching my AI to argue with my girlfriend?",
    "Today I learned that 'learning' is just continuous confusion management",
    "[AskReddit] What's a red flag that someone peaked in high school? (7.2k comments)",
    "TIL the average person spends 6 months of their life waiting for red lights to turn green",
    "My [27F] boyfriend [29M] keeps trying to optimize our relationship with spreadsheets",
    "TIFU by automating my job so well they gave me more work",
    "ELI5: Why does deleting system32 fix everything?",
    "Unpopular Opinion: Maybe we should have stopped at Web 1.0",
    "LPT: If you can't afford therapy, just explain your code to a rubber duck",
    "TIL that 'cloud computing' is just someone else's computer having a bad day",
    "[Serious] People who upvote but don't comment, why?",
    "My boss just discovered I've been working from a hammock in Bali for 3 years",
    "CMV: The real treasure was the bugs we introduced along the way",
    "TIL Steve Jobs once told a programmer 'It should just work' and that's why we're all suffering",
    "AITA for correcting my date's use of 'literally'?",
    "Today's Daily Discussion: Why is everything a subscription now?",
    "[Breaking] Local man discovers productivity hack: closing Reddit",
    "TIL that 73% of statistics cited on Reddit are made up on the spot",
    "What's the male equivalent of 'I'm fine'? (23.7k upvotes)"
  ];
  
  // Twitter/X parodies (aka "Zeed")
  const twitterParodies = [
    "just spent 6 hours debugging only to find the cable wasn't plugged in",
    "normalize admitting you have no idea what you're doing",
    "me: *writes perfect code* // the code: *immediately stops working when someone looks at it*",
    "CEO announces layoffs but keeps the office ping pong table. priorities.",
    "hot take: we should bring back websites that just say 'under construction'",
    "the duality of man: wanting to quit your job vs. needing health insurance",
    "POV: you're a senior developer who just googled 'how to exit vim'",
    "why does every startup look like an Apple Store had a baby with a WeWork",
    "my therapist: 'you can't blame everything on mercury retrograde' // me: 'sounds like something mercury retrograde would make you say'",
    "just overheard someone say 'we'll use AI for that' about a problem that needs a for loop",
    "accidentally typed 'npm run sadness' instead of 'npm run dev' but it still felt accurate",
    "the metaverse died so we could have 37 new AI chatbots. this is the future we chose.",
    "breaking: man who said 'I'll just make a quick fix' has not been seen in 3 days",
    "interviewer: where do you see yourself in 5 years // me: bold of you to assume I can plan past Tuesday",
    "just learned my side project has more users than my main job's product. do I tell them?",
    "love when a tutorial starts with 'this is easy' then immediately imports 47 libraries",
    "manager: 'can you hop on a quick call' // me: *stress intensifies*",
    "the four horsemen: 'works on my machine' 'it was working yesterday' 'did you try turning it off' 'check the logs'",
    "why is every tech conference basically 'we made a thing that shouldn't be blockchain but is'",
    "my code at 2am vs my code at 2pm: same code, different level of confidence"
  ];
  
  // Facebook parodies
  const facebookParodies = [
    "Just bought a house! JK it's an NFT of a house. Still living with my parents.",
    "Thoughts and prayers for everyone who has to go back to the office",
    "Can anyone recommend a good therapist? Preferably one who accepts memes as payment",
    "Blessed to announce I'm now a founder! (unemployed)",
    "Just finished a 40-hour coding bootcamp. Where's my $200k job?",
    "Why does no one talk about how expensive it is to simply exist anymore",
    "Normalize not having a side hustle. My side hustle is resting.",
    "Couldn't help but notice all my friends are either getting married or having existential crises",
    "POV: You're 30 and everyone's wedding photos are starting to look the same",
    "Just submitted 50 job applications and got 1 rejection. The other 49 ghosted me.",
    "Sharing my journey: Day 47 of pretending to understand cryptocurrency",
    "BREAKING: Local man discovers the key to happiness is lowering expectations",
    "Grateful for my hybrid work setup (working from bed instead of couch)",
    "Unpopular opinion: Maybe infinite growth on a finite planet isn't sustainable?",
    "Tag someone who needs to hear this: Your laptop charger isn't a personality trait",
    "Just me or does every corporate email end with 'let's circle back' now?",
    "Shoutout to everyone still trying to make 'networking events' sound fun",
    "Remember when we thought 2020 was bad? Simpler times.",
    "Fun fact: The word 'literally' has literally lost all meaning",
    "Celebrating 5 years at my job! (JK I'm just too tired to update my resume)"
  ];

  const linkedinParodies = [
    "Thrilled to announce my pomodoro breaks now include keynote presentations. Time is a construct.",
    "Grateful to the algorithm for endorsing my skill: 'Logging In While Muted'.",
    "Leadership isn't a title, it's the friends who send calendar invites for vibes.",
    "Reminder: If your stand-up has sitting energy, rebrand it as a fireside chat.",
    "Today I promoted my coffee mug to Chief Morale Officer and we're already scaling empathy."
  ];
  
  // Verify all elements exist
  console.log('🔍 Checking referrer overlay elements:');
  console.log('  overlay:', overlay ? '✓' : '✗');
  console.log('  refHeader:', refHeader ? '✓' : '✗');
  console.log('  edgeImpact:', edgeImpact ? '✓' : '✗');
  console.log('  baseDarkness:', baseDarkness ? '✓' : '✗');
  console.log('  darkeningOverlay:', darkeningOverlay ? '✓' : '✗');
  console.log('  lightBeam:', lightBeam ? '✓' : '✗');
  console.log('  manualTrigger:', document.getElementById('manualTrigger') ? '✓' : '✗');
  console.log('  quickHN:', document.getElementById('quickHN') ? '✓' : '✗');
  console.log('  quickReddit:', document.getElementById('quickReddit') ? '✓' : '✗');
  console.log('  quickTwitter:', document.getElementById('quickTwitter') ? '✓' : '✗');
  console.log('  quickFacebook:', document.getElementById('quickFacebook') ? '✓' : '✗');
  console.log('  quickLinkedIn:', document.getElementById('quickLinkedIn') ? '✓' : '✗');
  
  // Manual trigger
  const manualTriggerBtn = document.getElementById('manualTrigger');
  if (manualTriggerBtn) {
    manualTriggerBtn.addEventListener('click', () => {
      console.log('📝 Manual trigger clicked');
    const url = document.getElementById('manualUrlInput').value.trim();
    if (!url) return alert('Please enter a URL');
      triggerOverlay(url).catch((err) => {
        console.error('Trigger error:', err);
  });
    });
  } else {
    console.error('❌ manualTrigger button not found!');
  }
  
  // Quick access buttons
  const quickHNBtn = document.getElementById('quickHN');
  if (quickHNBtn) {
    quickHNBtn.addEventListener('click', () => {
      console.log('🔶 HN button clicked');
      triggerOverlay('https://news.ycombinator.com').catch((err) => {
        console.error('HN trigger error:', err);
      });
    });
  } else {
    console.error('❌ quickHN button not found!');
  }
  
  const quickRedditBtn = document.getElementById('quickReddit');
  if (quickRedditBtn) {
    quickRedditBtn.addEventListener('click', () => {
      console.log('🔴 Reddit button clicked');
      triggerOverlay('https://www.reddit.com/r/all').catch((err) => {
        console.error('Reddit trigger error:', err);
      });
    });
  } else {
    console.error('❌ quickReddit button not found!');
  }
  
  const quickTwitterBtn = document.getElementById('quickTwitter');
  if (quickTwitterBtn) {
    quickTwitterBtn.addEventListener('click', () => {
      console.log('🐦 Zeed button clicked');
      triggerOverlay('zeed').catch((err) => {
        console.error('Zeed trigger error:', err);
      });
    });
  } else {
    console.error('❌ quickTwitter button not found!');
  }
  
  const quickFacebookBtn = document.getElementById('quickFacebook');
  if (quickFacebookBtn) {
    quickFacebookBtn.addEventListener('click', () => {
      console.log('📘 Facebook button clicked');
      triggerOverlay('facebook').catch((err) => {
        console.error('Facebook trigger error:', err);
      });
    });
  } else {
    console.error('❌ quickFacebook button not found!');
  }

  const quickLinkedInBtn = document.getElementById('quickLinkedIn');
  if (quickLinkedInBtn) {
    quickLinkedInBtn.addEventListener('click', () => {
      console.log('💼 LinkedIn button clicked');
      triggerOverlay('linkedin').catch((err) => {
        console.error('LinkedIn trigger error:', err);
      });
    });
  } else {
    console.error('❌ quickLinkedIn button not found!');
  }
  
  // Sidebar controls
  refSidebarClose.addEventListener('click', hideSidebar);
  
  // Track if ToS phase is active
  let tosPhaseActive = false;
  
  refSidebarAck.addEventListener('click', () => {
    if (noteInteractionLocked) {
      return;
    }
    if (noteAwaitingActivation) {
      console.log('🔔 Note activation tapped - beginning hover sequence');
      startNoteHoverSequence();
      return;
    }

    if (loomAiMessageActive) {
      console.log('🎪 AI teaser clicked - revealing BADBOOLEAN ad');
      activateFakeAd();
      return;
    }

    if (loomFakeAdActive) {
      console.log('💥 BADBOOLEAN.COM AD CLICKED! Switching to serious message...');
      transformToSeriousMessage();
      return;
    }

    // If ToS phase is active, trigger final submission
    if (tosPhaseActive) {
      console.log('📝 ToS CHECKBOX CLICKED - FINAL SUBMISSION');
      // TODO: Add final submission effect
      return;
    }

    if (celliAdsComplete && refSidebar.classList.contains('mythic-entrance')) {
      transformToSeriousMessage();
    } else {
      hideSidebar();
    }
  });

  function isMobileViewport() {
    return window.matchMedia('(max-width: 768px)').matches;
  }

  function stopNoteEntryMonitor() {
    if (noteEntryMonitorId) {
      cancelAnimationFrame(noteEntryMonitorId);
      noteEntryMonitorId = null;
    }
    noteEntryTickCount = 0;
    if (noteEntryFallbackTimer) {
      clearTimeout(noteEntryFallbackTimer);
      noteEntryFallbackTimer = null;
    }
  }

  function fadeChantToVolume(targetVolume, duration = CHANT_FADE_DURATION) {
    if (chantFadeFrameId) {
      cancelAnimationFrame(chantFadeFrameId);
      chantFadeFrameId = null;
    }

    const startVolume = chantAudio.volume;
    const delta = targetVolume - startVolume;

    if (duration <= 0 || Math.abs(delta) < 0.001) {
      chantAudio.volume = targetVolume;
      return;
    }

    const startTime = performance.now();

    function step(now) {
      const progress = Math.min((now - startTime) / duration, 1);
      chantAudio.volume = startVolume + delta * progress;

      if (progress < 1) {
        chantFadeFrameId = requestAnimationFrame(step);
      } else {
        chantFadeFrameId = null;
        chantAudio.volume = targetVolume;
      }
    }

    chantFadeFrameId = requestAnimationFrame(step);
  }

  function quickFadeInChant() {
    console.log('  🔊 Fading chant audio in as note enters.');
    fadeChantToVolume(CHANT_TARGET_VOLUME, CHANT_FADE_DURATION);
  }

  function startNoteEntryMonitor() {
    stopNoteEntryMonitor();
    noteEntryTickCount = 0;
    noteHasEnteredFrame = false;

    const sidebar = refSidebar;
    if (!sidebar) {
      return;
    }

    const RIGHT_THRESHOLD = 16;
    const REQUIRED_TICKS = 6;

    if (noteEntryFallbackTimer) {
      clearTimeout(noteEntryFallbackTimer);
    }

    noteEntryFallbackTimer = setTimeout(() => {
      noteEntryFallbackTimer = null;
      if (!noteHasEnteredFrame && noteAwaitingActivation) {
        console.log('  ⚠️ Note entry fallback triggered - forcing center stage.');
        noteHasEnteredFrame = true;
        quickFadeInChant();
        handlePrimaryInviteCentered();
        stopNoteEntryMonitor();
      }
    }, 4500);

    const monitor = () => {
      const rect = sidebar.getBoundingClientRect();
      const distanceFromRight = window.innerWidth - rect.right;

      if (distanceFromRight >= RIGHT_THRESHOLD) {
        noteEntryTickCount += 1;

        if (!noteHasEnteredFrame && noteEntryTickCount >= REQUIRED_TICKS) {
          noteHasEnteredFrame = true;
          console.log('  ✅ Note fully entered frame (ticks satisfied).');
          quickFadeInChant();
          handlePrimaryInviteCentered();

          stopNoteEntryMonitor();
          return;
        }
      } else {
        noteEntryTickCount = 0;
      }

      noteEntryMonitorId = requestAnimationFrame(monitor);
    };

    noteEntryMonitorId = requestAnimationFrame(monitor);
  }

  function clearNoteStageTimeouts() {
    noteStageTimeouts.forEach(id => clearTimeout(id));
    noteStageTimeouts = [];
    if (window.badBooleanTimeout) {
      clearTimeout(window.badBooleanTimeout);
      window.badBooleanTimeout = null;
    }
    stopNoteEntryMonitor();
    cancelExtraInviteSchedule();
  }

  function startAiEnhancedScan() {
    if (!refSidebarAck) {
      return;
    }
    refSidebarAck.classList.add('ai-scan-active');
  }

  function stopAiEnhancedScan() {
    if (!refSidebarAck) {
      return;
    }
    refSidebarAck.classList.remove('ai-scan-active');
  }

  function playChantAudio() {
    if (chantFadeFrameId) {
      cancelAnimationFrame(chantFadeFrameId);
      chantFadeFrameId = null;
    }

    initChantAnalyser();

    try {
      chantAudio.currentTime = 0;
    } catch (err) {
      console.warn('⚠️ Unable to reset chant audio time:', err);
    }

    chantAudio.volume = 0;
    const playPromise = chantAudio.play();

    if (playPromise && typeof playPromise.then === 'function') {
      playPromise.then(() => {
        setLoomAudioStatus(true);
        clearChantUnlockHandler();
      }).catch(err => {
        console.warn('⚠️ Chant playback blocked by browser:', err);
        setLoomAudioStatus(false);
        requestChantUnlockRetry();
      });
    } else {
      setLoomAudioStatus(true);
      clearChantUnlockHandler();
    }
  }

  function stopChantAudio() {
    if (chantFadeFrameId) {
      cancelAnimationFrame(chantFadeFrameId);
      chantFadeFrameId = null;
    }
    stopChantVisualizer();
    chantAudio.pause();
    chantAudio.currentTime = 0;
    chantAudio.volume = 0;
    setLoomAudioStatus(false);
  }

  function startNoteHoverSequence() {
    if (!noteAwaitingActivation) {
      return;
    }

    cancelExtraInviteSchedule();

    const sidebar = refSidebar;
    const ackBtn = refSidebarAck;

    noteAwaitingActivation = false;
    noteHoverSequenceStarted = true;
    clearNoteStageTimeouts();

    sidebar.classList.remove('stage-float');
    sidebar.classList.add('stage-sweep', 'note-hover');

    const noteCrystal = ackBtn.querySelector('.ref-note-crystal');
    if (noteCrystal) {
      noteCrystal.classList.add('ref-note-crystal--hover');
    }

    triggerNoteHoverEffects();

    const rumbleTimeout = setTimeout(() => {
      sidebar.classList.add('stage-rumble');
    }, 1200);
    noteStageTimeouts.push(rumbleTimeout);

    const expandTimeout = setTimeout(() => {
      sidebar.classList.remove('stage-rumble');
      sidebar.classList.add('stage-expand');
      revealAiMessage();
    }, 2400);
    noteStageTimeouts.push(expandTimeout);
  }

  function triggerBurstLight(onCleanupScheduled) {
    document.querySelectorAll('.burst-beam').forEach(beam => beam.remove());

    const burstBeam = document.createElement('div');
    burstBeam.className = 'burst-beam';

    if (brickHoles.length > 0) {
      const avgY = brickHoles.reduce((sum, h) => sum + h.y, 0) / brickHoles.length;
      burstBeam.style.background = `radial-gradient(ellipse at right ${avgY}px, rgba(255, 255, 255, 0.8) 0%, rgba(255, 255, 255, 0.35) 30%, transparent 60%)`;
    }

    document.body.appendChild(burstBeam);

    const cleanupTimeout = setTimeout(() => {
      if (burstBeam.parentNode) {
        burstBeam.style.opacity = '0';
        setTimeout(() => burstBeam.remove(), 1000);
      }
    }, 3000);

    if (typeof onCleanupScheduled === 'function') {
      onCleanupScheduled(cleanupTimeout);
    }

    return burstBeam;
  }

  function triggerNoteHoverEffects() {
    console.log('  ✨ Activating crystalline note hover effects');

    if (darkeningOverlay) {
      darkeningOverlay.classList.add('flash-of-life');
      const flashTimeout = setTimeout(() => {
        darkeningOverlay.classList.remove('flash-of-life');
      }, 1500);
      noteStageTimeouts.push(flashTimeout);
    }

    triggerBurstLight(timeoutId => noteStageTimeouts.push(timeoutId));
  }

  function markInviteActive(isActive) {
    if (!refSidebarAck) {
      return;
    }
    if (isActive) {
      refSidebarAck.classList.add('loom-invite-active');
    } else {
      refSidebarAck.classList.remove('loom-invite-active');
    }
  }

  function revealAiMessage() {
    const sidebar = refSidebar;
    const ackBtn = refSidebarAck;

    sidebar.classList.remove('note-seed', 'note-hover');
    markInviteActive(false);
    loomAiMessageActive = true;
    loomFakeAdActive = false;

    const heading = sidebar.querySelector('h3');
    if (heading) {
      heading.textContent = 'Observant. We knew you\'d notice us.';
      heading.style.display = 'block';
      heading.style.opacity = '1';
      heading.style.fontSize = '16px';
      heading.style.letterSpacing = '0.05em';
      heading.style.fontWeight = '600';
      heading.style.marginBottom = '18px';
      heading.style.textAlign = 'center';
      heading.style.color = '#f8f9fa';
    }

    ackBtn.innerHTML = `
        <div class="ai-message" style="font-size: 15px; font-weight: 300; line-height: 1.8; color: #f8f9fa; text-align: center;padding: 40px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;">
          <div class="ai-message-tri-icon" aria-hidden="true">
            <span></span>
            <span></span>
            <span></span>
          </div>
          <div style="font-weight: 500; margin-bottom: 14px; font-size: 18px; color: #8fb4ff; letter-spacing: 0.5px; text-shadow: 0 0 12px rgba(143, 180, 255, 0.4);">AI-Enhanced Content Discovery</div>
          <div style="opacity: 0.9; font-size: 14px;">Analyzing your browsing patterns to deliver personalized recommendations with unprecedented accuracy.</div>
          <div style="margin-top: 16px; font-size: 12px; opacity: 0.6; letter-spacing: 1px; color: #a0b0c0;">Powered by Celli: Where Data Comes to Life</div>
        </div>
      `;
    ackBtn.style.background = 'linear-gradient(135deg, rgba(15, 25, 45, 0.7), rgba(25, 35, 55, 0.8))';
    ackBtn.style.backdropFilter = 'blur(20px) saturate(180%)';
    ackBtn.style.webkitBackdropFilter = 'blur(20px) saturate(180%)';
    ackBtn.style.border = '1px solid rgba(143, 180, 255, 0.25)';
    ackBtn.style.borderRadius = '16px';
    ackBtn.style.padding = '0';
    ackBtn.style.boxShadow = '0 8px 32px rgba(0, 0, 0, 0.4), 0 0 60px rgba(102, 126, 234, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.1)';
    ackBtn.style.cursor = 'pointer';
    ackBtn.style.animation = '';
    ackBtn.style.transition = 'all 0.3s ease-out';
    ackBtn.setAttribute('aria-label', 'Reveal the hidden offer');

    startAiEnhancedScan();
    console.log('  ✨ AI MESSAGE DISPLAYED WITH TWINKLE');
  }

  function activateFakeAd() {
    if (loomFakeAdActive) {
      return;
    }

    cancelExtraInviteSchedule();

    const ackBtn = refSidebarAck;

    console.log('  💥💥💥 JARRING SWITCH TO BADBOOLEAN AD (click-triggered)!');

    loomAiMessageActive = false;
    loomFakeAdActive = true;
    markInviteActive(false);

    ackBtn.style.transition = 'all 0.1s ease-out';

    ackBtn.innerHTML = `
        <div style="font-size: 20px; font-weight: 900; margin-bottom: 12px; text-transform: uppercase; letter-spacing: 2px; color: #ff0080; animation: pulse 0.5s infinite;">
          ARE YOU A TOTAL ZERO?
        </div>
        <div style="font-size: 16px; margin-bottom: 10px; color: #ffff00; font-weight: 700; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);">
          💋 SINGLES IN YOUR AREA 💋
        </div>
        <div style="font-size: 26px; font-weight: 900; color: #00ff00; text-shadow: 0 0 15px #00ff00, 0 0 30px #00ff00; letter-spacing: 3px; animation: pulse 0.8s infinite;">
          BADBOOLEAN.COM
        </div>
        <div style="font-size: 14px; margin-top: 10px; color: #ff69b4; font-style: italic; font-weight: 500; opacity: 0.9;">
          True love never felt so false.
        </div>
        <div style="font-size: 12px; margin-top: 8px; color: #ff00ff; font-weight: 600;">🔥 CLICK HERE NOW!!! 🔥</div>
      `;
    ackBtn.style.background = 'linear-gradient(135deg, #ff0080 0%, #ff8c00 25%, #ffff00 50%, #00ff00 75%, #ff0080 100%)';
    ackBtn.style.backgroundSize = '200% 200%';
    ackBtn.style.border = '3px solid #ff00ff';
    ackBtn.style.boxShadow = '0 0 20px #ff0080, 0 0 40px #00ff00, inset 0 0 20px rgba(255,255,255,0.3)';
    ackBtn.style.animation = 'pulse 0.5s infinite, rainbow-shift 3s ease infinite';
    ackBtn.style.padding = '30px 20px';
    ackBtn.setAttribute('aria-label', 'Open the Loomworks invitation');

    console.log('  🎪🎪🎪 BADBOOLEAN AD ACTIVE! 🎪🎪🎪');
    console.log('  ⏰ Starting 5-second timeout for alt LOOMWORKS invite');

    if (window.badBooleanTimeout) {
      clearTimeout(window.badBooleanTimeout);
    }

    const adTimeout = setTimeout(() => {
      console.log('  ⏱️ 5 seconds elapsed - transforming to alt LOOMWORKS invite');
      transformToAltLoomworksInvite();
    }, 5000);

    window.badBooleanTimeout = adTimeout;
    noteStageTimeouts.push(adTimeout);
  }

  function showLoomworksInvite(isAltVersion = false) {
    const sidebar = refSidebar;
    const ackBtn = refSidebarAck;
    const h3 = sidebar.querySelector('h3');
    const paragraphs = sidebar.querySelectorAll('p');

    cancelExtraInviteSchedule();

    sidebar.classList.remove('note-seed', 'note-hover');
    noteAwaitingActivation = false;
    noteHoverSequenceStarted = false;
    loomAiMessageActive = false;
    loomFakeAdActive = false;
    stopAiEnhancedScan();
    clearNoteStageTimeouts();

    // Clear any pending timeout
    if (window.badBooleanTimeout) {
      clearTimeout(window.badBooleanTimeout);
      window.badBooleanTimeout = null;
    }
    
    // Hide the base card elements completely
    h3.style.display = 'none';
    paragraphs.forEach(p => p.style.display = 'none');
    refSidebarUrl.style.display = 'none';
    
    // Quick fade transition
    ackBtn.style.transition = 'all 0.3s ease-out';
    ackBtn.style.opacity = '0';
    
    // Transform entire sidebar into unified hazy glass crystal
    sidebar.style.background = 'linear-gradient(135deg, rgba(15, 25, 45, 0.65), rgba(25, 35, 55, 0.75), rgba(20, 30, 50, 0.7))';
    sidebar.style.backdropFilter = 'blur(40px) saturate(200%) brightness(1.1)';
    sidebar.style.webkitBackdropFilter = 'blur(40px) saturate(200%) brightness(1.1)';
    sidebar.style.border = '1px solid rgba(143, 180, 255, 0.4)';
    sidebar.style.borderRadius = '24px';
    sidebar.style.padding = '0';
    sidebar.style.overflow = 'hidden';
    sidebar.style.boxShadow = '0 8px 40px rgba(0, 0, 0, 0.5), 0 0 80px rgba(102, 126, 234, 0.25), inset 0 2px 0 rgba(255, 255, 255, 0.15), inset 0 -2px 20px rgba(102, 126, 234, 0.1)';
    
    // Choose opening text based on version
    const openingText = isAltVersion 
      ? 'The willpower. I wouldn\'t have been so strong. The things we do to fill the nulls in our heart. You\'re exactly who we need.'
      : 'Somebody who knows what they want. A rarity these days.';
    
    const versionLabel = isAltVersion ? 'WILLPOWER' : 'IMMEDIATE';
    console.log(`  📝 Showing ${versionLabel} version of LOOMWORKS invite`);

    setTimeout(() => {
      // Show complete unified ToS card with header - hazy glass crystal effect
      ackBtn.innerHTML = `
        <div class="loom-invite-stack">
          <div class="loom-invite-card" style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;">
          <!-- Header with crystal haze effect -->
          <div style="padding: 32px 36px; display:flex; justify-content:center; background: linear-gradient(140deg, rgba(118, 75, 162, 0.28), rgba(102, 126, 234, 0.24), rgba(143, 180, 255, 0.22)); border-bottom: 1px solid rgba(143, 180, 255, 0.28); backdrop-filter: blur(14px);">
            ${LOOM_INVITE_EMBLEM}
          </div>

          <!-- Content -->
          <div style="padding: 36px; font-size: 15px; font-weight: 300; line-height: 1.9; color: #f8f9fa;">
            <div style="margin-bottom: 24px; font-weight: 400; font-size: 16px; color: #ffffff; letter-spacing: 0.4px; line-height: 1.6;">
              ${openingText}
            </div>
            <div style="margin-bottom: 28px; opacity: 0.95; font-size: 14px; line-height: 1.7;">
              Not everyone passes that test, you know? And for that, we'd like you to join our incredibly exclusive <span id="alphaText" style="font-weight: 600; color: #8fb4ff; text-shadow: 0 0 8px rgba(143, 180, 255, 0.5);">alpha</span> test.
            </div>
            <div style="margin-top: 32px; padding-top: 24px; border-top: 1px solid rgba(143, 180, 255, 0.2); font-size: 13px; opacity: 0.85; font-weight: 300;">
              Just need you to sign the ToS....
            </div>
            <div id="tosLabel" style="margin-top: 16px; font-size: 11px; color: #a0b0c0; letter-spacing: 2px; font-weight: 500;">
              TERMS OF <span id="eternalText" style="opacity: 0;"></span> SUBMISSION
            </div>
            <div id="tosCheckboxContainer" style="margin-top: 22px; display: flex; align-items: center; gap: 14px; cursor: pointer; padding: 18px 24px; border: 1px solid rgba(143, 180, 255, 0.4); border-radius: 14px; background: linear-gradient(135deg, rgba(143, 180, 255, 0.12), rgba(102, 126, 234, 0.15)); backdrop-filter: blur(15px) saturate(180%); box-shadow: 0 4px 24px rgba(102, 126, 234, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.15), inset 0 -1px 10px rgba(102, 126, 234, 0.1); transition: all 0.3s ease;">
              <input type="checkbox" id="tosCheckbox" style="width: 22px; height: 22px; cursor: pointer; accent-color: #667eea; border-radius: 4px;">
              <label for="tosCheckbox" style="cursor: pointer; user-select: none; font-size: 13px; font-weight: 400; color: #e8ecf0; letter-spacing: 0.4px;">I accept the terms</label>
            </div>
          </div>
          </div>
        </div>
      `;

      markInviteActive(true);

      // Reset button to transparent (content defines styling now)
      ackBtn.style.background = 'transparent';
      ackBtn.style.backdropFilter = 'none';
      ackBtn.style.webkitBackdropFilter = 'none';
      ackBtn.style.border = 'none';
      ackBtn.style.borderRadius = '0';
      ackBtn.style.padding = '0';
      ackBtn.style.boxShadow = 'none';
      ackBtn.style.animation = '';
      ackBtn.style.opacity = '1';
      ackBtn.style.transform = 'scale(1)';
      
      // Start glitching "alpha" text
      setTimeout(() => glitchAlphaText(), 500);
      
      // Start flashing "ETERNAL" letter by letter
      setTimeout(() => flashEternalText(), 1000);
      
      // Activate magnetic cursor for checkbox
      setTimeout(() => activateMagneticCheckbox(), 1500);

      attachTosAcceptanceHandler();

      tosPhaseActive = true;

      console.log(`✨ Unified hazy glass crystal LOOMWORKS invitation displayed (${versionLabel})`);
      updateTriColorFocus();
    }, 300);
  }
  
  function transformToSeriousMessage() {
    // When clicked immediately, show the immediate version
    showLoomworksInvite(false);
  }
  
  function glitchAlphaText() {
    const alphaEl = document.getElementById('alphaText');
    if (!alphaEl) return;
    
    const original = 'alpha';
    const glitchChars = {
      'a': ['@', 'α', 'а', 'ａ', 'ą'],
      'l': ['|', 'ℓ', '1', 'ǀ', 'Ɩ'],
      'p': ['þ', 'ρ', 'р', 'ƿ', 'φ'],
      'h': ['ħ', 'н', 'һ', 'ђ', 'ћ']
    };
    
    setInterval(() => {
      const glitched = original.split('').map(char => {
        const variants = glitchChars[char] || [char];
        return variants[Math.floor(Math.random() * variants.length)];
      }).join('');
      
      alphaEl.textContent = glitched;
      
      // Occasionally show original
      if (Math.random() < 0.3) {
        setTimeout(() => { alphaEl.textContent = original; }, 50);
      }
    }, 200);
  }
  
  function flashEternalText() {
    const eternalEl = document.getElementById('eternalText');
    if (!eternalEl) return;
    
    const word = 'ETERNAL ';
    let currentIndex = 0;
    
    const flashInterval = setInterval(() => {
      if (currentIndex < word.length) {
        eternalEl.textContent = word.substring(0, currentIndex + 1);
        eternalEl.style.opacity = '1';
        eternalEl.style.color = '#ff6b6b';
        eternalEl.style.fontWeight = '700';
        currentIndex++;
      } else {
        clearInterval(flashInterval);
      }
    }, 150);
  }
  
  function activateMagneticCheckbox() {
    const checkbox = document.getElementById('tosCheckbox');
    const container = document.getElementById('tosCheckboxContainer');
    if (!checkbox || !container) return;
    
    console.log('🧲 Magnetic checkbox activated - hiding real cursor');
    
    // Hide real cursor
    document.body.classList.add('faux-cursor-active');
    
    // Create faux cursor
    let fauxCursor = document.getElementById('fauxCursor');
    if (!fauxCursor) {
      fauxCursor = document.createElement('div');
      fauxCursor.id = 'fauxCursor';
      fauxCursor.style.cssText = `
        position: fixed;
        width: 24px;
        height: 24px;
        border: 3px solid rgba(255, 255, 255, 0.9);
        border-radius: 50%;
        pointer-events: none;
        z-index: 100000;
        background: radial-gradient(circle, rgba(102, 126, 234, 0.6), transparent);
        box-shadow: 0 0 20px rgba(102, 126, 234, 0.8), inset 0 0 10px rgba(255, 255, 255, 0.3);
        transform-origin: center center;
        transform: translate(-50%, -50%);
      `;
      document.body.appendChild(fauxCursor);
      console.log('  🎯 Faux cursor element created');
    }
    
    fauxCursor.style.display = 'block';
    console.log('  👁️ Faux cursor visible, real cursor hidden');
    
    // Track real mouse position - initialize with current position
    let mouseX = window.innerWidth / 2;
    let mouseY = window.innerHeight / 2;
    
    const mouseMoveHandler = (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
    };
    
    // Add event listener and store reference for cleanup
    document.addEventListener('mousemove', mouseMoveHandler);
    window.fauxCursorMouseHandler = mouseMoveHandler;
    
    console.log(`  📍 Initial mouse position: (${mouseX}, ${mouseY})`);
    
    // Animate faux cursor toward checkbox with smooth interpolation
    let currentFauxX = mouseX;
    let currentFauxY = mouseY;
    let animationId;
    let frameCount = 0;
    
    const animateFauxCursor = () => {
      frameCount++;
      
      // Get checkbox position
      const checkboxRect = checkbox.getBoundingClientRect();
      if (!checkboxRect || checkboxRect.width === 0) {
        // Checkbox not visible yet, retry
        animationId = requestAnimationFrame(animateFauxCursor);
        return;
      }
      
      const targetX = checkboxRect.left + checkboxRect.width / 2;
      const targetY = checkboxRect.top + checkboxRect.height / 2;
      
      // Calculate gravitational pull from real mouse to checkbox
      const dx = targetX - mouseX;
      const dy = targetY - mouseY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      // Strong magnetic effect within 600px
      let desiredFauxX = mouseX;
      let desiredFauxY = mouseY;
      
      if (distance < 600) {
        const strength = 1 - (distance / 600);
        const pullStrength = 0.85; // Very strong pull (85% toward checkbox)
        desiredFauxX = mouseX + (dx * strength * pullStrength);
        desiredFauxY = mouseY + (dy * strength * pullStrength);
        
        // Scale and glow faux cursor based on proximity
        const scale = 1 + (strength * 0.8);
        const glow = 20 + (strength * 40);
        fauxCursor.style.transform = `translate(-50%, -50%) scale(${scale})`;
        fauxCursor.style.boxShadow = `0 0 ${glow}px rgba(102, 126, 234, ${0.8 + strength * 0.2}), inset 0 0 10px rgba(255, 255, 255, ${0.3 + strength * 0.4})`;
        
        // Log every 60 frames for debugging
        if (frameCount % 60 === 0) {
          console.log(`  🧲 Mouse:(${mouseX.toFixed(0)},${mouseY.toFixed(0)}) Checkbox:(${targetX.toFixed(0)},${targetY.toFixed(0)}) Distance:${distance.toFixed(0)}px Strength:${(strength * 100).toFixed(0)}%`);
          console.log(`  🎯 Faux:(${currentFauxX.toFixed(0)},${currentFauxY.toFixed(0)}) Desired:(${desiredFauxX.toFixed(0)},${desiredFauxY.toFixed(0)})`);
        }
      } else {
        fauxCursor.style.transform = 'translate(-50%, -50%) scale(1)';
        fauxCursor.style.boxShadow = '0 0 20px rgba(102, 126, 234, 0.8), inset 0 0 10px rgba(255, 255, 255, 0.3)';
      }
      
      // Smooth interpolation for cursor position
      currentFauxX += (desiredFauxX - currentFauxX) * 0.15;
      currentFauxY += (desiredFauxY - currentFauxY) * 0.15;
      
      fauxCursor.style.left = currentFauxX + 'px';
      fauxCursor.style.top = currentFauxY + 'px';
      
      animationId = requestAnimationFrame(animateFauxCursor);
    };
    
    console.log('  🚀 Starting faux cursor animation loop');
    animateFauxCursor();

    // Store animation ID for cleanup
    window.fauxCursorAnimationId = animationId;
  }

  function attachTosAcceptanceHandler() {
    const checkbox = document.getElementById('tosCheckbox');
    if (!checkbox) {
      return;
    }

    if (checkbox.dataset.listenerAttached === 'true') {
      return;
    }

    checkbox.dataset.listenerAttached = 'true';
    checkbox.addEventListener('change', (event) => {
      if (event.target.checked) {
        console.log('🌟 Terms accepted – launching golden ascension sequence');
        startGoldenHoldSequence();
      }
    });
  }

  let html2CanvasPromise = null;
  async function ensureHtml2CanvasLoaded() {
    if (typeof html2canvas !== 'undefined') {
      return true;
    }

    if (html2CanvasPromise) {
      return html2CanvasPromise.then(() => typeof html2canvas !== 'undefined');
    }

    html2CanvasPromise = new Promise((resolve) => {
      const script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js';
      script.onload = () => resolve(true);
      script.onerror = () => resolve(false);
      document.head.appendChild(script);
    });

    const loaded = await html2CanvasPromise;
    return loaded && typeof html2canvas !== 'undefined';
  }

  function cleanupGoldenSequence() {
    if (goldenHoldCleanup) {
      goldenHoldCleanup();
      goldenHoldCleanup = null;
    }

    if (goldenHoldTimer) {
      clearTimeout(goldenHoldTimer);
      goldenHoldTimer = null;
    }

    if (goldenDustAnimationId) {
      cancelAnimationFrame(goldenDustAnimationId);
      goldenDustAnimationId = null;
    }

    if (goldenHoldOverlay && goldenHoldOverlay.parentNode) {
      goldenHoldOverlay.parentNode.removeChild(goldenHoldOverlay);
    }

    goldenHoldOverlay = null;
    postTermsSequenceStarted = false;
    document.body.classList.remove('referrer-whiteout');
  }

  function scheduleBetaFormRedirect(delay = 0) {
    if (betaFormRedirectTimeoutId !== null) {
      return;
    }

    const parsedDelay = Number(delay);
    const safeDelay = Math.max(0, Number.isFinite(parsedDelay) ? parsedDelay : 0);
    console.log(`🛣️ Scheduling redirect to beta focus form in ${safeDelay}ms`);
    betaFormRedirectTimeoutId = window.setTimeout(() => {
      console.log('➡️ Redirecting to beta focus form…');
      try {
        window.location.href = BETA_FOCUS_FORM_URL;
      } catch (error) {
        console.error('⚠️ Unable to redirect to beta focus form', error);
      }
    }, safeDelay);
  }

  function attachBetaFormRedirectListener(triangleElement) {
    if (!triangleElement || betaFormRedirectListenerAttached) {
      return;
    }

    betaFormRedirectListenerAttached = true;
    const handleTriangleFlightEnd = (event) => {
      if (event && event.animationName && event.animationName !== 'triangle-flight') {
        return;
      }

      triangleElement.removeEventListener('animationend', handleTriangleFlightEnd);
      scheduleBetaFormRedirect(350);
    };

    triangleElement.addEventListener('animationend', handleTriangleFlightEnd);

    window.setTimeout(() => {
      scheduleBetaFormRedirect(0);
    }, 4200);
  }

  function startGoldenHoldSequence() {
    if (postTermsSequenceStarted) {
      return;
    }

    postTermsSequenceStarted = true;

    stopMagneticCursor();
    document.body.classList.remove('faux-cursor-active');

    const fauxCursor = document.getElementById('fauxCursor');
    if (fauxCursor) {
      fauxCursor.style.display = 'none';
    }

    if (window.fauxCursorAnimationId) {
      cancelAnimationFrame(window.fauxCursorAnimationId);
      window.fauxCursorAnimationId = null;
    }

    if (window.fauxCursorMouseHandler) {
      document.removeEventListener('mousemove', window.fauxCursorMouseHandler);
      window.fauxCursorMouseHandler = null;
    }

    const overlayElement = document.createElement('div');
    overlayElement.className = 'golden-ascension-overlay';
    overlayElement.innerHTML = `
      <div class="golden-content">
        <div class="golden-instruction">Click &amp; hold to finalize acceptance</div>
        <div class="golden-hold-wrapper">
          <div class="golden-hold-button">
            <span class="golden-label">CLICK + HOLD</span>
            <div class="golden-trail-pack">
              <span style="--i:0"></span>
              <span style="--i:1"></span>
              <span style="--i:2"></span>
              <span style="--i:3"></span>
              <span style="--i:4"></span>
            </div>
          </div>
        </div>
      </div>
    `;

    document.body.appendChild(overlayElement);
    goldenHoldOverlay = overlayElement;

    setupGoldenHoldInteraction(overlayElement);
  }

  function setupGoldenHoldInteraction(overlayElement) {
    const holdButton = overlayElement.querySelector('.golden-hold-button');
    if (!holdButton) {
      return;
    }

    const holdInstruction = overlayElement.querySelector('.golden-instruction');
    const defaultInstructionText = holdInstruction ? holdInstruction.textContent : '';
    const holdDuration = 1600;
    let holdComplete = false;
    let snapListener = null;

    const getPointerPosition = (event) => {
      if (event.touches && event.touches.length) {
        return { x: event.touches[0].clientX, y: event.touches[0].clientY };
      }
      return { x: event.clientX, y: event.clientY };
    };

    const startHold = (event) => {
      event.preventDefault();
      if (holdComplete) {
        return;
      }

      overlayElement.classList.add('holding');
      holdButton.classList.add('holding');

      const { x, y } = getPointerPosition(event);
      const rect = holdButton.getBoundingClientRect();
      const dx = x - (rect.left + rect.width / 2);
      const dy = y - (rect.top + rect.height / 2);
      holdButton.style.setProperty('--cursor-dx', `${dx}px`);
      holdButton.style.setProperty('--cursor-dy', `${dy}px`);
      holdButton.classList.add('snapping-to-cursor');

      if (!snapListener) {
        snapListener = (evt) => {
          if (evt.propertyName === 'transform' && holdButton.classList.contains('snapping-to-cursor')) {
            holdButton.classList.add('cursor-synced');
          }
        };
        holdButton.addEventListener('transitionend', snapListener);
      }

      if (holdInstruction) {
        holdInstruction.textContent = 'Hold steady…';
      }

      if (goldenHoldTimer) {
        clearTimeout(goldenHoldTimer);
      }

      goldenHoldTimer = setTimeout(() => {
        holdComplete = true;
        finalizeHold();
      }, holdDuration);
    };

    const cancelHold = () => {
      if (holdComplete) {
        return;
      }

      overlayElement.classList.remove('holding');
      holdButton.classList.remove('holding');
      holdButton.classList.remove('snapping-to-cursor', 'cursor-synced');
      holdButton.style.removeProperty('--cursor-dx');
      holdButton.style.removeProperty('--cursor-dy');

      if (goldenHoldTimer) {
        clearTimeout(goldenHoldTimer);
        goldenHoldTimer = null;
      }

      if (holdInstruction) {
        holdInstruction.textContent = defaultInstructionText;
      }
    };

    const finalizeHold = () => {
      overlayElement.classList.remove('holding');
      holdButton.classList.remove('holding');
      holdButton.classList.remove('snapping-to-cursor');
      holdButton.classList.add('cursor-synced');

      if (goldenHoldTimer) {
        clearTimeout(goldenHoldTimer);
        goldenHoldTimer = null;
      }

      if (goldenHoldCleanup) {
        goldenHoldCleanup();
        goldenHoldCleanup = null;
      }

      overlayElement.classList.add('hold-complete');
      holdButton.classList.add('morphing');

      if (holdInstruction) {
        holdInstruction.textContent = 'Acceptance locked in';
      }

      setTimeout(() => {
        beginDustTransition(overlayElement, holdButton);
      }, 1100);
    };

    holdButton.addEventListener('mousedown', startHold);
    holdButton.addEventListener('touchstart', startHold, { passive: false });
    window.addEventListener('mouseup', cancelHold);
    window.addEventListener('touchend', cancelHold);

    goldenHoldCleanup = () => {
      holdButton.removeEventListener('mousedown', startHold);
      holdButton.removeEventListener('touchstart', startHold);
      window.removeEventListener('mouseup', cancelHold);
      window.removeEventListener('touchend', cancelHold);
      if (snapListener) {
        holdButton.removeEventListener('transitionend', snapListener);
        snapListener = null;
      }
      holdButton.classList.remove('snapping-to-cursor', 'cursor-synced');
      holdButton.style.removeProperty('--cursor-dx');
      holdButton.style.removeProperty('--cursor-dy');
    };
  }

  async function runVoxelShatterSequence(sourceCanvas) {
    if (!sourceCanvas) {
      return false;
    }
    try {
      await voxelShatter.startFromCanvas(sourceCanvas, { duration: 3400, burstDelay: 750 });
      return true;
    } catch (error) {
      console.warn('⚠️ Voxel shatter failed, using fallback dust animation', error);
      try {
        voxelShatter.dispose();
      } catch (disposeError) {
        console.warn('⚠️ Unable to dispose voxel shatter scene cleanly', disposeError);
      }
      return false;
    }
  }

  async function beginDustTransition(overlayElement, triangleElement) {
    const label = triangleElement.querySelector('.golden-label');
    if (label) {
      setTimeout(() => label.remove(), 320);
    }

    const trailSpans = triangleElement.querySelectorAll('.golden-trail-pack span');
    trailSpans.forEach((span, index) => {
      span.style.setProperty('--i', index);
    });

    document.body.classList.add('referrer-whiteout');
    overlayElement.classList.add('dust-phase');

    let captureCanvas = null;
    const html2CanvasReady = await ensureHtml2CanvasLoaded();

    if (html2CanvasReady && typeof html2canvas !== 'undefined') {
      const previousVisibility = overlayElement.style.visibility;
      overlayElement.style.visibility = 'hidden';
      await new Promise((resolve) => requestAnimationFrame(resolve));
      try {
        captureCanvas = await html2canvas(document.body, {
          useCORS: true,
          logging: false,
          scale: window.devicePixelRatio || 1,
          backgroundColor: getComputedStyle(document.body).backgroundColor || '#0b0b10'
        });
        console.log('🖼️ DOM captured for raster dust sequence');
      } catch (err) {
        console.warn('⚠️ html2canvas capture failed', err);
      }
      overlayElement.style.visibility = previousVisibility || '';
    }

    const voxelSuccess = captureCanvas ? await runVoxelShatterSequence(captureCanvas) : false;

    if (!voxelSuccess) {
      const whiteout = document.createElement('div');
      whiteout.className = 'golden-whiteout';
      overlayElement.appendChild(whiteout);

      if (captureCanvas) {
        const dustCanvas = document.createElement('canvas');
        dustCanvas.className = 'golden-dust-canvas';
        overlayElement.appendChild(dustCanvas);

        runDustAnimation(captureCanvas, dustCanvas, whiteout, () => {
          dustCanvas.classList.add('fade-out');
          setTimeout(() => {
            if (dustCanvas.parentNode) {
              dustCanvas.parentNode.removeChild(dustCanvas);
            }
          }, 1600);
          overlayElement.classList.add('dust-complete');
          triangleElement.classList.add('into-white');
          startWarpSequence(overlayElement, triangleElement);
        });
      } else {
        overlayElement.classList.add('dust-complete');
        triangleElement.classList.add('into-white');
        setTimeout(() => startWarpSequence(overlayElement, triangleElement), 600);
      }
    } else {
      overlayElement.classList.add('dust-complete');
      triangleElement.classList.add('into-white');
      startWarpSequence(overlayElement, triangleElement);
    }

    triangleElement.classList.add('triangle-flight');
    attachBetaFormRedirectListener(triangleElement);
    setTimeout(() => {
      triangleElement.classList.add('into-white');
    }, 900);
  }

  function runDustAnimation(sourceCanvas, targetCanvas, whiteoutElement, onComplete) {
    const sourceContext = sourceCanvas.getContext('2d');
    const ctx = targetCanvas.getContext('2d');
    if (!sourceContext || !ctx) {
      if (typeof onComplete === 'function') {
        onComplete();
      }
      return;
    }

    const width = sourceCanvas.width;
    const height = sourceCanvas.height;
    targetCanvas.width = width;
    targetCanvas.height = height;
    targetCanvas.style.width = '100vw';
    targetCanvas.style.height = '100vh';

    ctx.imageSmoothingEnabled = false;

    const imageData = sourceContext.getImageData(0, 0, width, height).data;
    const step = Math.max(4, Math.floor(width / 240));
    const particles = [];

    for (let y = 0; y < height; y += step) {
      for (let x = 0; x < width; x += step) {
        const index = (y * width + x) * 4;
        const alpha = imageData[index + 3];
        if (alpha < 48) {
          continue;
        }

        particles.push({
          x,
          y,
          r: imageData[index],
          g: imageData[index + 1],
          b: imageData[index + 2],
          a: alpha / 255,
          vx: -Math.random() * 6 - 1.5,
          vy: (Math.random() - 0.5) * 3.2,
          drift: Math.random() * 2,
          life: 1,
          size: step
        });
      }
    }

    let progress = 0;

    const animate = () => {
      progress += 0.012;
      ctx.clearRect(0, 0, width, height);

      const windForce = -10 * progress;
      particles.forEach((particle) => {
        if (particle.life <= 0) {
          return;
        }

        particle.x += (particle.vx + windForce) * (0.85 + progress * 0.35);
        particle.y += particle.vy + Math.sin((particle.x + progress * 620) * 0.01) * particle.drift;
        particle.life -= 0.008 + progress * 0.015;

        if (particle.life <= 0) {
          return;
        }

        ctx.fillStyle = `rgba(${particle.r}, ${particle.g}, ${particle.b}, ${Math.max(particle.life, 0) * particle.a})`;
        ctx.fillRect(particle.x, particle.y, particle.size, particle.size);
      });

      if (whiteoutElement) {
        const opacityTarget = Math.min(1, progress * 1.8);
        whiteoutElement.style.opacity = opacityTarget.toFixed(3);
      }

      if (progress < 1.3) {
        goldenDustAnimationId = requestAnimationFrame(animate);
      } else {
        goldenDustAnimationId = null;
        if (typeof onComplete === 'function') {
          onComplete();
        }
      }
    };

    goldenDustAnimationId = requestAnimationFrame(animate);
  }

  function startWarpSequence(overlayElement, triangleElement) {
    if (!overlayElement || !triangleElement) {
      return;
    }

    if (overlayElement.classList.contains('warp-drive')) {
      return;
    }

    overlayElement.classList.add('warp-drive');

    const existingTunnel = overlayElement.querySelector('.warp-tunnel');
    if (!existingTunnel) {
      const warpTunnel = document.createElement('div');
      warpTunnel.className = 'warp-tunnel';
      overlayElement.appendChild(warpTunnel);
      requestAnimationFrame(() => warpTunnel.classList.add('active'));
    }

    const warpStars = document.createElement('div');
    warpStars.className = 'warp-stars';
    overlayElement.appendChild(warpStars);
    requestAnimationFrame(() => warpStars.classList.add('active'));

    const depthLines = document.createElement('div');
    depthLines.className = 'warp-depth-lines';
    for (let i = 0; i < 7; i++) {
      const span = document.createElement('span');
      span.style.setProperty('--depth-index', i);
      depthLines.appendChild(span);
    }
    overlayElement.appendChild(depthLines);
    requestAnimationFrame(() => depthLines.classList.add('active'));

    const trailSpans = triangleElement.querySelectorAll('.golden-trail-pack span');
    trailSpans.forEach((span, index) => {
      span.style.setProperty('--i', index);
    });

    setTimeout(() => {
      triangleElement.classList.add('warp-orientation');
    }, 350);
  }
  
  // Magnetic cursor effect
  let magneticActive = false;
  let cursorX = 0, cursorY = 0;
  let targetX = 0, targetY = 0;
  
  function startMagneticCursor() {
    magneticActive = true;
    refPanel.classList.add('magnetic-active');
    customCursor.classList.add('active');
  }
  
  function stopMagneticCursor() {
    magneticActive = false;
    refPanel.classList.remove('magnetic-active');
    customCursor.classList.remove('active');
    refSidebarAck.style.transform = 'scale(1)';
    refSidebarAck.style.boxShadow = 'none';
  }
  
  // Track mouse position
  overlay.addEventListener('mousemove', (e) => {
    cursorX = e.clientX;
    cursorY = e.clientY;
    
    if (!magneticActive || !refSidebar.classList.contains('active')) {
      customCursor.style.left = cursorX + 'px';
      customCursor.style.top = cursorY + 'px';
      return;
    }
    
    const btnRect = refSidebarAck.getBoundingClientRect();
    const btnCenterX = btnRect.left + btnRect.width / 2;
    const btnCenterY = btnRect.top + btnRect.height / 2;
    
    const dx = btnCenterX - cursorX;
    const dy = btnCenterY - cursorY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    // Magnetic range: 300px
    if (distance < 300) {
      const strength = 1 - (distance / 300);
      const pullX = dx * strength * 0.4;
      const pullY = dy * strength * 0.4;
      
      targetX = cursorX + pullX;
      targetY = cursorY + pullY;
      
      const scale = 1 + strength * 0.2;
      refSidebarAck.style.transform = `scale(${scale})`;
      refSidebarAck.style.boxShadow = `0 0 ${strength * 25}px rgba(255,255,255,${strength * 0.6})`;
    } else {
      targetX = cursorX;
      targetY = cursorY;
      refSidebarAck.style.transform = 'scale(1)';
      refSidebarAck.style.boxShadow = 'none';
    }
    
    customCursor.style.left = targetX + 'px';
    customCursor.style.top = targetY + 'px';
  });
  
  async function triggerOverlay(url) {
    // Detect source type from URL
    const urlLower = (url || '').toLowerCase();
    const isHN = /news\.ycombinator\.com/.test(urlLower);
    const isReddit = /(^|\/\/|\.)reddit\.com/.test(urlLower);
    const isTwitter = /(^|\/\/|\.)twitter\.com/.test(urlLower) || /(^|\/\/|\.)x\.com/.test(urlLower) || url === 'zeed';
    const isFacebook = /(^|\/\/|\.)facebook\.com/.test(urlLower) || url === 'facebook';
    const isLinkedIn = /(^|\/\/|\.)linkedin\.com/.test(urlLower) || url === 'linkedin';

    // Set header visuals
    if (isHN) {
      refLogo.classList.remove('reddit', 'twitter', 'facebook', 'linkedin');
      refLogo.classList.add('hn');
      refLogo.textContent = 'HN';
      refTitle.textContent = 'Previously on Hacker News…';
      refSub.textContent = new URL(url || 'https://news.ycombinator.com').hostname;
    } else if (isReddit) {
      refLogo.classList.remove('hn', 'twitter', 'facebook', 'linkedin');
      refLogo.classList.add('reddit');
      refLogo.textContent = 'reddit';
      refTitle.textContent = 'Previously on Reddit…';
      refSub.textContent = hostOrPath(url || 'https://www.reddit.com');
    } else if (isTwitter) {
      refLogo.classList.remove('hn', 'reddit', 'facebook', 'linkedin');
      refLogo.classList.add('twitter');
      refLogo.textContent = 'Z';
      refTitle.textContent = 'Previously on Zeed…';
      refSub.textContent = 'timeline reconstructed';
    } else if (isFacebook) {
      refLogo.classList.remove('hn', 'reddit', 'twitter', 'linkedin');
      refLogo.classList.add('facebook');
      refLogo.textContent = 'f';
      refTitle.textContent = 'Previously on Facebook…';
      refSub.textContent = 'news feed + messenger';
    } else if (isLinkedIn) {
      refLogo.classList.remove('hn', 'reddit', 'twitter', 'facebook');
      refLogo.classList.add('linkedin');
      refLogo.textContent = 'in';
      refTitle.textContent = 'Previously on LinkedIn…';
      refSub.textContent = 'everyone is "thrilled"';
    } else {
      refLogo.classList.remove('hn', 'reddit', 'twitter', 'facebook', 'linkedin');
      refLogo.textContent = 'SRC';
      refTitle.textContent = 'Reconstructing previous page…';
      refSub.textContent = hostOrPath(url);
    }
    
    // Show overlay
    openOverlay();
    
    // Fetch snapshot
    let items = [];
    let platformType = 'hn';
    
    try {
      if (isHN) {
        platformType = 'hn';
        items = await fetchHNSnapshot(url);
      } else if (isReddit) {
        platformType = 'reddit';
        items = await fetchRedditSnapshot(url);
      } else if (isTwitter) {
        platformType = 'twitter';
        items = await fetchTwitterSnapshot(url);
      } else if (isFacebook) {
        platformType = 'facebook';
        items = await fetchFacebookSnapshot(url);
      } else if (isLinkedIn) {
        platformType = 'linkedin';
        items = await fetchLinkedInSnapshot(url);
      } else {
        items = await fetchGenericFallback(url);
      }
      console.log(`✓ Fetched ${items ? items.length : 0} items for ${platformType}`);
    } catch (e) {
      console.error('Fetch error:', e);
      items = [];
    }
    
    if (!items || items.length === 0) {
      console.warn('No items - using fallback');
      items = [{ title: '(no items found — source may be private or blocked)', sub: '', link: '' }];
    }
    
    console.log(`📝 Calling renderItems with ${items.length} items for platform: ${platformType}`);
    renderItems(items, platformType);
    
    console.log(`✨ Calling stagedReveal for platform: ${platformType}`);
    stagedReveal(platformType);
    
    console.log(`👻 Scheduling glitch effect`);
    setTimeout(runGlitchOnce, 700);
    
    // Wire controls
    btnClose.replaceWith(btnClose.cloneNode(true));
    btnDismiss.replaceWith(btnDismiss.cloneNode(true));
    btnRecreate.replaceWith(btnRecreate.cloneNode(true));
    btnReset.replaceWith(btnReset.cloneNode(true));
    const newClose = document.getElementById('refClose');
    const newDismiss = document.getElementById('refDismiss');
    const newRecreate = document.getElementById('refRecreate');
    const newReset = document.getElementById('refReset');
    newClose.addEventListener('click', dismiss);
    newDismiss.addEventListener('click', dismiss);
    newRecreate.addEventListener('click', () => {
      runGlitchOnce();
      jitterList(700);
    });
    newReset.addEventListener('click', () => {
      resetImpacts();
    });
  }
  
  function openOverlay() {
    overlay.setAttribute('aria-hidden', 'false');
    document.body.style.overflow = 'hidden';
  }
  
  function dismiss() {
    overlay.setAttribute('aria-hidden', 'true');
    document.body.style.overflow = '';
    hideSidebar();
    hideTooltip();
    resetImpacts();
  }
  
  function showSidebar(url, withImpact = false) {
    refSidebar.classList.remove('bouncing', 'impact');
    refSidebar.classList.add('active');
    
    if (url) {
      refSidebarUrl.textContent = `Navigating to: ${url}`;
      refSidebarUrl.style.display = 'block';
    }
    
    if (withImpact) {
      // Add impact effect from tooltip splat
      setTimeout(() => refSidebar.classList.add('impact'), 10);
      setTimeout(() => refSidebar.classList.remove('impact'), 600);
    } else {
      // Normal bounce in
      setTimeout(() => refSidebar.classList.add('bouncing'), 10);
      setTimeout(() => refSidebar.classList.remove('bouncing'), 600);
    }

    triggerBurstLight();

    setTimeout(() => startMagneticCursor(), 800);
  }
  
  function hideSidebar() {
    refSidebar.classList.remove('active', 'bouncing', 'impact', 'mythic-entrance', 'stage-float', 'stage-sweep', 'stage-rumble', 'stage-expand', 'note-hover', 'note-seed');
    refSidebarUrl.style.display = 'none';
    refSidebarUrl.textContent = '';
    refSidebarClose.style.display = 'block';
    cancelExtraInviteSchedule();
    resetTriColorLayer();
    noteInteractionLocked = false;
    document.body.classList.remove('ref-note-centered');

    clearNoteStageTimeouts();
    stopChantAudio();
    noteAwaitingActivation = false;
    noteHoverSequenceStarted = false;
    loomAiMessageActive = false;
    loomFakeAdActive = false;
    noteHasEnteredFrame = false;
    stopAiEnhancedScan();
    markInviteActive(false);

    // Reset button to original state
    const ackBtn = refSidebarAck;
    ackBtn.innerHTML = 'Acknowledge Glitch';
    ackBtn.style.background = '';
    ackBtn.style.backdropFilter = '';
    ackBtn.style.webkitBackdropFilter = '';
    ackBtn.style.padding = '';
    ackBtn.style.fontSize = '';
    ackBtn.style.animation = '';
    ackBtn.style.border = '';
    ackBtn.style.boxShadow = '';
    ackBtn.style.opacity = '1';
    ackBtn.style.transition = '';
    ackBtn.style.borderRadius = '';
    ackBtn.style.transform = '';
    ackBtn.style.cursor = '';
    ackBtn.style.backgroundSize = '';
    ackBtn.setAttribute('aria-label', 'Acknowledge glitch');

    // Reset sidebar content visibility
    const h3 = refSidebar.querySelector('h3');
    const paragraphs = refSidebar.querySelectorAll('p');
    if (h3) {
      h3.style.opacity = '1';
      h3.style.display = 'block';
    }
    paragraphs.forEach(p => {
      p.style.opacity = '1';
      p.style.display = 'block';
    });
    
    // Clean up ToS phase
    tosPhaseActive = false;
    
    // Remove faux cursor
    const fauxCursor = document.getElementById('fauxCursor');
    if (fauxCursor) {
      fauxCursor.style.display = 'none';
    }
    
    // Restore real cursor
    document.body.classList.remove('faux-cursor-active');
    
    // Cancel faux cursor animation
    if (window.fauxCursorAnimationId) {
      cancelAnimationFrame(window.fauxCursorAnimationId);
      window.fauxCursorAnimationId = null;
    }
    
    // Remove mouse handler
    if (window.fauxCursorMouseHandler) {
      document.removeEventListener('mousemove', window.fauxCursorMouseHandler);
      window.fauxCursorMouseHandler = null;
    }
    
    // Reset sidebar styling
    const sidebar = refSidebar;
    sidebar.style.background = '';
    sidebar.style.backdropFilter = '';
    sidebar.style.webkitBackdropFilter = '';
    sidebar.style.border = '';
    sidebar.style.borderRadius = '';
    sidebar.style.padding = '';
    sidebar.style.overflow = '';
    
    stopMagneticCursor();
  }
  
  function detectPlatformFromElement(element) {
    if (!element) return '';
    for (const [platform, selector] of Object.entries(POST_PLATFORM_SELECTORS)) {
      if (element.closest(selector)) {
        return platform;
      }
    }
    return '';
  }

  function applyTooltipTheme(tooltipElement, platform) {
    if (!tooltipElement) return;
    TOOLTIP_THEME_CLASSES.forEach(cls => tooltipElement.classList.remove(cls));
    if (platform) {
      tooltipElement.classList.add(`ref-tooltip--${platform}`);
    }
  }

  function isPostLink(element) {
    if (!element) return false;
    return Object.values(POST_PLATFORM_SELECTORS).some(selector => element.closest(selector));
  }

  function createHeartsAndPrayersToast(platform) {
    const toast = document.createElement('div');
    toast.className = `hearts-prayers-toast${platform ? ` hearts-prayers-toast--${platform}` : ''}`;
    toast.innerHTML = `
      <span class="hearts-prayers-emoji" aria-hidden="true">💖🙏</span>
      <span class="hearts-prayers-text">hearts and prayers</span>
    `;
    return toast;
  }

  function sendHeartsAndPrayers(linkElement, platform) {
    const toast = createHeartsAndPrayersToast(platform);
    const rect = linkElement.getBoundingClientRect();
    const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
    const top = Math.max(12, rect.top - 24);
    toast.style.left = `${rect.left + rect.width / 2}px`;
    toast.style.top = `${Math.min(top, viewportHeight - 60)}px`;
    document.body.appendChild(toast);
    requestAnimationFrame(() => toast.classList.add('visible'));
    setTimeout(() => {
      toast.classList.remove('visible');
      setTimeout(() => {
        if (toast.parentNode) {
          toast.parentNode.removeChild(toast);
        }
      }, 200);
    }, 900);
  }

  function showTooltip(url, linkElement) {
    // Show the shared hover tooltip
    if (refTooltipText) {
      refTooltipText.textContent = url;
    } else if (refTooltip) {
      refTooltip.textContent = url;
    }

    applyTooltipTheme(refTooltip, detectPlatformFromElement(linkElement));

    updateSharedTooltipWidth();

    // Position above the link element
    const rect = linkElement.getBoundingClientRect();
    const { tooltipWidth, edgePadding, verticalOffset } = getTooltipMetrics();
    const viewportWidth = window.innerWidth || document.documentElement.clientWidth || tooltipWidth;

    // Center horizontally on the link, position above it
    let left = rect.left + (rect.width / 2) - (tooltipWidth / 2);
    const top = Math.max(12, rect.top - verticalOffset);

    // Keep within viewport bounds using adaptive padding
    if (left < edgePadding) left = edgePadding;
    if (left + tooltipWidth > viewportWidth - edgePadding) {
      left = viewportWidth - tooltipWidth - edgePadding;
    }

    refTooltip.style.left = `${left}px`;
    refTooltip.style.top = `${top}px`;
    refTooltip.classList.remove('morphing');
    refTooltip.classList.add('active');
  }
  
  function createFlyingTooltip(url, linkElement) {
    // Create a NEW independent tooltip for animation
    const tooltip = document.createElement('div');
    tooltip.className = 'ref-tooltip active';
    tooltip.innerHTML = `
      <span class="ref-tooltip-bullet" aria-hidden="true"></span>
      <span class="ref-tooltip-text"></span>
    `;
    const tooltipText = tooltip.querySelector('.ref-tooltip-text');
    if (tooltipText) {
      tooltipText.textContent = url;
    } else {
      tooltip.textContent = url;
    }
    applyTooltipTheme(tooltip, detectPlatformFromElement(linkElement));
    document.body.appendChild(tooltip);

    // Position above the link element
    const rect = linkElement.getBoundingClientRect();
    const { tooltipWidth, edgePadding, verticalOffset } = getTooltipMetrics();
    const viewportWidth = window.innerWidth || document.documentElement.clientWidth || tooltipWidth;

    let left = rect.left + (rect.width / 2) - (tooltipWidth / 2);
    const top = Math.max(12, rect.top - verticalOffset);

    if (left < edgePadding) left = edgePadding;
    if (left + tooltipWidth > viewportWidth - edgePadding) {
      left = viewportWidth - tooltipWidth - edgePadding;
    }

    const distanceToEdge = Math.max(0, viewportWidth - edgePadding - (left + tooltipWidth));

    tooltip.style.left = `${left}px`;
    tooltip.style.top = `${top}px`;
    tooltip.style.width = `${tooltipWidth}px`;
    tooltip.style.maxWidth = `${tooltipWidth}px`;
    tooltip.style.setProperty('--edge-distance', `${distanceToEdge}px`);
    tooltip.dataset.initialLeft = `${left}`;
    tooltip.dataset.tooltipWidth = `${tooltipWidth}`;

    return tooltip;
  }

  function getPostIdForElement(element) {
    if (!element) {
      return null;
    }

    if (element.dataset && element.dataset.refPostId) {
      return element.dataset.refPostId;
    }

    const container = typeof element.closest === 'function'
      ? element.closest('[data-ref-post-id]')
      : null;

    return container?.dataset?.refPostId || null;
  }
  
  function hideTooltip() {
    refTooltip.classList.remove('active', 'morphing');
  }
  
  function createImpactParticles(tooltipElement) {
    console.log('💨 Creating impact particles...');

    const tooltipRect = tooltipElement.getBoundingClientRect();
    const metrics = getEdgeMetrics();
    const impactX = window.innerWidth - Math.max(metrics.edgePadding * 0.6, 12);
    const impactYTop = tooltipRect.top;
    const impactYBottom = tooltipRect.bottom;
    const impactYCenter = (impactYTop + impactYBottom) / 2;
    
    console.log(`   Impact point: x=${impactX}, y=${impactYCenter.toFixed(0)} (top:${impactYTop.toFixed(0)}, bottom:${impactYBottom.toFixed(0)})`);
    
    // Number of particles to spawn
    const particleCount = 25;
    console.log(`   Spawning ${particleCount} particles`);
    
    // Spawn particles from top of tooltip collision
    for (let i = 0; i < particleCount / 3; i++) {
      createParticle(impactX, impactYTop, -1); // -1 = upward bias
    }
    
    // Spawn particles from bottom of tooltip collision
    for (let i = 0; i < particleCount / 3; i++) {
      createParticle(impactX, impactYBottom, 1); // 1 = downward bias
    }
    
    // Spawn particles from center (spray in both directions)
    for (let i = 0; i < particleCount / 3; i++) {
      createParticle(impactX, impactYCenter, Math.random() > 0.5 ? 1 : -1);
    }
  }
  
  function createParticle(x, y, verticalBias) {
    const particle = document.createElement('div');
    const shapes = ['impact-particle--circle', 'impact-particle--square', 'impact-particle--triangle'];
    const shapeClass = shapes[Math.floor(Math.random() * shapes.length)];
    particle.className = `impact-particle pixel-particle ${shapeClass}`;

    // Compact radiant particles (3px-6px)
    const sizeOptions = [3, 4, 5, 6];
    const size = sizeOptions[Math.floor(Math.random() * sizeOptions.length)];
    particle.style.width = size + 'px';
    particle.style.height = size + 'px';

    // Specific pixel colors: cyan-ish blue, orange-ish yellow, magenta-ish red
    const colors = [
      '#00d4ff',  // slightly cyan blue
      '#ff8800',  // slightly orange yellow
      '#ff0055',  // slightly magenta red
    ];
    const color = colors[Math.floor(Math.random() * colors.length)];
    particle.style.background = color;
    particle.style.boxShadow = `0 0 ${size}px ${color}`;
    particle.style.mixBlendMode = 'screen';

    particle.style.left = x + 'px';
    particle.style.top = y + 'px';

    const rotation = shapeClass === 'impact-particle--triangle'
      ? (Math.random() - 0.5) * 120
      : (Math.random() - 0.5) * 40;
    particle.style.setProperty('--particle-rotation', `${rotation}deg`);

    // Random velocity (biased by vertical direction)
    // Wider spread angle for explosive effect
    const angleSpread = Math.PI * 0.8; // 144 degrees spread
    const baseAngle = verticalBias > 0 ? Math.PI / 2 : -Math.PI / 2;
    const angle = (Math.random() - 0.5) * angleSpread + baseAngle;
    const speed = 80 + Math.random() * 150; // Faster particles
    const vx = Math.cos(angle) * speed * -1; // Move left into frame
    const vy = Math.sin(angle) * speed;
    
    particle.style.setProperty('--particle-x', vx + 'px');
    particle.style.setProperty('--particle-y', vy + 'px');
    
    document.body.appendChild(particle);
    
    // Trigger animation with slight delay for staggered effect
    const delay = Math.random() * 30;
    setTimeout(() => {
      requestAnimationFrame(() => {
        particle.classList.add('active');
      });
    }, delay);
    
    // Remove after animation
    setTimeout(() => {
      if (particle.parentNode) {
        particle.parentNode.removeChild(particle);
      }
    }, 700 + delay);
  }
  
  // Track brick holes for final burst
  let brickHoles = [];
  const brickHoleByPostId = new Map();
  const lightRaysByPostId = new Map();

  function createBrickHole(yPosition, postId = null) {
    const postSuffix = postId ? ` (post ${postId})` : '';
    console.log(`🧱💥 Creating brick hole at Y: ${yPosition}px${postSuffix}`);
    console.log(`  📊 Current hole count: ${brickHoles.length}`);

    const metrics = getEdgeMetrics();
    const holeWidth = Math.max(200, metrics.lightRayWidth * 0.42);
    const holeHeight = Math.max(48, metrics.lightRayHeight * 2.4);
    const holeTop = yPosition - (holeHeight / 2);
    const holeRightOffset = Math.round(metrics.edgePadding * 0.15);

    if (postId && brickHoleByPostId.has(postId)) {
      const existingRecord = brickHoleByPostId.get(postId);
      const existingHole = existingRecord?.element;
      if (existingHole && existingHole.parentNode) {
        console.log(`  ♻️ Reusing existing brick hole for ${postId}`);
        existingRecord.y = yPosition;
        existingHole.style.top = `${holeTop}px`;
        existingHole.style.right = `-${holeRightOffset}px`;
        existingHole.style.width = `${Math.round(holeWidth)}px`;
        existingHole.style.height = `${Math.round(holeHeight)}px`;
        existingHole.dataset.refPostId = postId;
        existingHole.style.animation = 'none';
        void existingHole.offsetWidth;
        existingHole.style.animation = '';

        updateDarkeningMask();
        setTimeout(() => createLightRay(yPosition, postId), 150);
        return existingHole;
      }

      // Element was removed, drop the stale record so we can recreate it
      brickHoleByPostId.delete(postId);
      if (existingRecord) {
        const index = brickHoles.indexOf(existingRecord);
        if (index !== -1) {
          brickHoles.splice(index, 1);
        }
      }
    }

    const hole = document.createElement('div');
    hole.className = 'darkening-hole';
    hole.style.top = `${holeTop}px`;
    hole.style.right = `-${holeRightOffset}px`;
    hole.style.width = `${Math.round(holeWidth)}px`;
    hole.style.height = `${Math.round(holeHeight)}px`;
    hole.style.position = 'fixed';
    hole.style.border = 'none';
    hole.style.zIndex = '10001';
    if (postId) {
      hole.dataset.refPostId = postId;
    }

    const holeId = `hole-${postId || Date.now()}`;
    hole.setAttribute('data-hole-id', holeId);

    document.body.appendChild(hole);

    const record = { y: yPosition, element: hole, postId: postId || null, ray: null };
    brickHoles.push(record);
    if (postId) {
      brickHoleByPostId.set(postId, record);
    }

    console.log(`  ✅ Hole element added to DOM`);
    console.log(`  📍 Total brick holes now: ${brickHoles.length}`);

    updateDarkeningMask();

    setTimeout(() => {
      createLightRay(yPosition, postId);
    }, 150);

    return hole;
  }
  
  function updateDarkeningMask() {
    if (!darkeningOverlay) return;
    
    if (brickHoles.length === 0) {
      // No holes, clear any masks
      darkeningOverlay.style.maskImage = 'none';
      darkeningOverlay.style.webkitMaskImage = 'none';
      console.log(`  🕳️  No holes, full darkening (no mask)`);
      return;
    }
    
    console.log(`  🕳️  Creating mask with ${brickHoles.length} holes at Y positions:`, brickHoles.map(h => h.y));
    
    // Build a paint() mask that punches holes
    // Start with full black (visible), then punch transparent holes
    let maskGradients = [];
    const metrics = getEdgeMetrics();
    const holeRadiusX = Math.max(90, metrics.lightRayWidth * 0.45);
    const holeRadiusY = Math.max(28, metrics.lightRayHeight * 2.2);
    const holeOffset = Math.max(holeRadiusX, metrics.edgePadding * 1.1);

    brickHoles.forEach(hole => {
      const y = hole.y;
      // Create a radial gradient hole centered on the right edge
      maskGradients.push(
        `radial-gradient(ellipse ${holeRadiusX}px ${holeRadiusY}px at calc(100% - ${holeOffset}px) ${y}px, transparent 0%, transparent 60%, black 100%)`
      );
    });
    
    // If we have holes, we need to combine them properly
    // Use a solid black background, then subtract the holes
    const fullMask = 'linear-gradient(black, black)';
    
    // Apply the full mask first, then the holes will subtract from it
    darkeningOverlay.style.maskImage = `${fullMask}, ${maskGradients.join(', ')}`;
    darkeningOverlay.style.webkitMaskImage = `${fullMask}, ${maskGradients.join(', ')}`;
    darkeningOverlay.style.maskComposite = 'subtract';
    darkeningOverlay.style.webkitMaskComposite = 'source-out';
    darkeningOverlay.style.maskRepeat = 'no-repeat';
    darkeningOverlay.style.webkitMaskRepeat = 'no-repeat';
    
    console.log(`  ✅ Mask applied with ${brickHoles.length} hole(s)`);
  }
  
  function createLightRay(yPosition, postId = null) {
    const metrics = getEdgeMetrics();
    const rayHeight = metrics.lightRayHeight;
    const rayWidth = metrics.lightRayWidth;
    const topOffset = yPosition - (rayHeight / 2);

    if (postId && lightRaysByPostId.has(postId)) {
      const record = lightRaysByPostId.get(postId);
      const existingRay = record?.element;
      if (existingRay && existingRay.parentNode) {
        console.log(`✨ Updating existing light ray for ${postId}`);
        record.y = yPosition;
        existingRay.style.top = `${topOffset}px`;
        existingRay.style.width = `${rayWidth}px`;
        existingRay.style.height = `${rayHeight}px`;
        existingRay.dataset.refPostId = postId;
        pulseLightRay(existingRay, record);
        return existingRay;
      }

      if (record?.fadeTimeout) {
        clearTimeout(record.fadeTimeout);
      }
      lightRaysByPostId.delete(postId);
    }

    console.log(`✨ Creating light ray at Y: ${yPosition}${postId ? ` (post ${postId})` : ''}`);

    const ray = document.createElement('div');
    ray.className = 'light-ray';
    ray.style.top = `${topOffset}px`;
    ray.style.width = `${rayWidth}px`;
    ray.style.height = `${rayHeight}px`;
    ray.style.zIndex = '2147483600';
    if (postId) {
      ray.dataset.refPostId = postId;
    }
    document.body.appendChild(ray);

    const record = postId ? { element: ray, y: yPosition, fadeTimeout: null } : null;
    if (record && postId) {
      lightRaysByPostId.set(postId, record);
      const holeRecord = brickHoleByPostId.get(postId);
      if (holeRecord) {
        holeRecord.ray = ray;
      }
    }

    pulseLightRay(ray, record);
    return ray;
  }

  function pulseLightRay(ray, record = null) {
    if (!ray) return;

    if (record?.fadeTimeout) {
      clearTimeout(record.fadeTimeout);
      record.fadeTimeout = null;
    }

    ray.style.opacity = '1';
    ray.style.transition = 'none';
    ray.style.animation = 'none';
    void ray.offsetWidth;
    ray.style.animation = '';

    const timeout = setTimeout(() => {
      if (!ray.parentNode) {
        return;
      }
      ray.style.transition = 'opacity 0.8s ease-out';
      ray.style.opacity = '0.22';
    }, 420);

    if (record) {
      record.fadeTimeout = timeout;
    }
  }
  
  function triggerEdgeImpact() {
    // Increment impact count
    impactCount++;
    
    console.log(`\n💥 ═══════════ EDGE IMPACT #${impactCount} ═══════════`);
    console.log(`  currentHNView: ${currentHNView}, hnItems.length: ${hnItems.length}`);
    
    // Show HN header bar after first collision (if in HN view)
    if (impactCount === 1 && currentHNView) {
      console.log('  📊 First impact - showing HN wrap');
      showHNWrap();
    }
    
    // Flicker effect
    if (edgeImpact) {
      console.log('  ⚡ Triggering edgeImpact flash animation');
    edgeImpact.classList.remove('active');
    void edgeImpact.offsetWidth;
    edgeImpact.classList.add('active');
      console.log('     Class added, animation should play for 1200ms');
    
    setTimeout(() => {
      edgeImpact.classList.remove('active');
        console.log('  ⚡ edgeImpact animation complete');
    }, 1200);
    } else {
      console.error('  ✗✗✗ edgeImpact element NOT FOUND!');
    }
    
    // Progressive darkening
    console.log('  🌑 Updating darkening level...');
    updateDarkeningLevel();
    
    // Glitch and replace content based on current view (all use same pattern)
    if (currentView === 'hn' && hnItems.length > 0) {
      console.log(`  🔶 HN view - processing impact ${impactCount}`);
      glitchAndReplaceHNPosts();
    } else if (currentView === 'reddit' && redditItems.length > 0) {
      console.log(`  🔴 Reddit view - processing impact ${impactCount}`);
      glitchAndReplaceRedditPosts();
    } else if (currentView === 'twitter' && twitterItems.length > 0) {
      console.log(`  🐦 Twitter view - processing impact ${impactCount}`);
      glitchAndReplaceTwitterPosts();
    } else if (currentView === 'facebook' && facebookItems.length > 0) {
      console.log(`  📘 Facebook view - processing impact ${impactCount}`);
      glitchAndReplaceFacebookPosts();
    } else if (currentView === 'linkedin' && linkedinItems.length > 0) {
      console.log(`  💼 LinkedIn view - processing impact ${impactCount}`);
      glitchAndReplaceLinkedInPosts();
    } else {
      console.log(`  ⊘ No items to glitch (view: ${currentView})`);
    }
    
    // Activate light beam after reaching max impacts
    if (impactCount >= MAX_IMPACTS_BEFORE_BEAM) {
      console.log(`  ✨ LIGHT BEAM THRESHOLD REACHED (${impactCount} >= ${MAX_IMPACTS_BEFORE_BEAM})`);
      activateLightBeam();
    } else {
      console.log(`  ⊙ Light beam not yet (${impactCount}/${MAX_IMPACTS_BEFORE_BEAM})`);
    }
    
    console.log(`💥 Impact ${impactCount} complete ═══════════\n`);
  }
  
  function showHNWrap() {
    const hnWrap = document.querySelector('.hn-wrap');
    if (hnWrap) {
      hnWrap.classList.add('visible');
      console.log('🔶 HN browser bar revealed');
    }
  }
  
  function hideHNWrap() {
    const hnWrap = document.querySelector('.hn-wrap');
    if (hnWrap) {
      hnWrap.classList.remove('visible');
    }
  }
  
  function findNextIndexForStage(items, getTarget, state) {
    const total = items.length;
    if (total === 0) return -1;

    const order = [];
    for (let i = state.nextIndex; i < total; i++) order.push(i);
    for (let i = 0; i < state.nextIndex; i++) order.push(i);

    for (const idx of order) {
      const candidate = items[idx];
      if (!candidate) continue;
      const target = getTarget(candidate);
      if (!target) continue;

      if (state.stage === 'parody' && !target.classList.contains('parodied')) {
        return idx;
      }

      if (state.stage === 'celli' && !target.classList.contains('celli-ad')) {
        return idx;
      }
    }

    return -1;
  }

  function glitchNextItem(platformKey, items, { getTarget, getContainer = (item) => item, applyParody, applyCelli, logLabel }) {
    if (!items || items.length === 0) return;

    if (!glitchProgress[platformKey]) {
      glitchProgress[platformKey] = createGlitchState();
    }

    const state = glitchProgress[platformKey];

    if (state.stage === 'done') {
      console.log(`  ${logLabel} sequence already complete.`);
      return;
    }

    const nextIndex = findNextIndexForStage(items, getTarget, state);

    if (nextIndex === -1) {
      if (state.stage === 'parody') {
        if (!parodiesComplete) {
          parodiesComplete = true;
          console.log(`\n🎊🎊🎊 ALL PARODIES COMPLETE! 🎊🎊🎊`);
          console.log(`✨ Next clicks will replace with CELLI INVOCATIONS ✨\n`);
        }
        state.stage = 'celli';
        state.nextIndex = 0;
        return glitchNextItem(platformKey, items, { getTarget, getContainer, applyParody, applyCelli, logLabel });
      }

      if (state.stage === 'celli') {
        if (!celliAdsComplete) {
          celliAdsComplete = true;
          console.log(`\n✨✨✨ ALL POSTS ARE NOW CELLI INVOCATIONS! ✨✨✨`);
          console.log(`🎪 Animating sidebar from off-screen...\n`);
          animateSidebarEntry();
        }
        state.stage = 'done';
      }
      return;
    }

    const item = items[nextIndex];
    const target = getTarget(item);
    if (!target) {
      state.nextIndex = (nextIndex + 1) % items.length;
      return glitchNextItem(platformKey, items, { getTarget, getContainer, applyParody, applyCelli, logLabel });
    }

    const container = getContainer ? getContainer(item) : item;
    if (container) {
      container.classList.add('glitching');
    }

    setTimeout(() => {
      if (state.stage === 'parody') {
        applyParody(item, target, nextIndex);
      } else if (state.stage === 'celli') {
        applyCelli(item, target, nextIndex);
      }

      if (container) {
        container.classList.remove('glitching');
      }

      console.log(`  ${logLabel} ${nextIndex + 1} → ${state.stage.toUpperCase()} update complete.`);
    }, 800);

    state.nextIndex = nextIndex + 1;
  }

  function glitchAndReplaceHNPosts() {
    glitchNextItem('hn', hnItems, {
      getTarget: (item) => item.querySelector('.hn-story-title'),
      getContainer: (item) => item,
      applyParody: (item, target, index) => {
        const newTitle = parodyHeadlines[index % parodyHeadlines.length];
        target.textContent = newTitle;
        target.classList.add('parodied');
        target.setAttribute('data-original-title', newTitle);
        setGlitchLink(target, buildGlitchUrl('hn', 'parody', index));
      },
      applyCelli: (item, target, index) => {
        const newTitle = celliAds[index % celliAds.length];
        target.textContent = newTitle;
        target.classList.add('celli-ad');
        item.classList.add('has-celli-ad');
        target.setAttribute('data-original-title', newTitle);
        setGlitchLink(target, buildGlitchUrl('hn', 'celli', index));
      },
      logLabel: '🔶 HN post'
    });
  }

  function glitchAndReplaceRedditPosts() {
    glitchNextItem('reddit', redditItems, {
      getTarget: (item) => item.querySelector('.reddit-title a'),
      getContainer: (item) => item,
      applyParody: (item, target, index) => {
        const newTitle = redditParodies[index % redditParodies.length];
        target.textContent = newTitle;
        target.classList.add('parodied');
        setGlitchLink(target, buildGlitchUrl('reddit', 'parody', index));
      },
      applyCelli: (item, target, index) => {
        const newTitle = celliAds[index % celliAds.length];
        target.textContent = newTitle;
        target.classList.add('celli-ad');
        item.classList.add('has-celli-ad');
        setGlitchLink(target, buildGlitchUrl('reddit', 'celli', index));
      },
      logLabel: '🔴 Reddit post'
    });
  }

  function glitchAndReplaceTwitterPosts() {
    glitchNextItem('twitter', twitterItems, {
      getTarget: (item) => item.querySelector('.twitter-text'),
      getContainer: (item) => item,
      applyParody: (item, target, index) => {
        const newText = twitterParodies[index % twitterParodies.length];
        target.textContent = newText;
        target.classList.add('parodied');
        target.setAttribute('data-original-text', newText);
        setGlitchLink(target, buildGlitchUrl('twitter', 'parody', index));
      },
      applyCelli: (item, target, index) => {
        const newText = celliAds[index % celliAds.length];
        target.textContent = newText;
        target.classList.add('celli-ad');
        item.classList.add('has-celli-ad');
        target.setAttribute('data-original-text', newText);
        setGlitchLink(target, buildGlitchUrl('twitter', 'celli', index));
      },
      logLabel: '🐦 Tweet'
    });
  }

  function glitchAndReplaceFacebookPosts() {
    glitchNextItem('facebook', facebookItems, {
      getTarget: (item) => item.querySelector('.facebook-post-text'),
      getContainer: (item) => item,
      applyParody: (item, target, index) => {
        const newText = facebookParodies[index % facebookParodies.length];
        target.textContent = newText;
        target.classList.add('parodied');
        target.setAttribute('data-original-text', newText);
        setGlitchLink(target, buildGlitchUrl('facebook', 'parody', index));
      },
      applyCelli: (item, target, index) => {
        const newText = celliAds[index % celliAds.length];
        target.textContent = newText;
        target.classList.add('celli-ad');
        item.classList.add('has-celli-ad');
        target.setAttribute('data-original-text', newText);
        setGlitchLink(target, buildGlitchUrl('facebook', 'celli', index));
      },
      logLabel: '📘 Facebook post'
    });

  }

  function glitchAndReplaceLinkedInPosts() {
    glitchNextItem('linkedin', linkedinItems, {
      getTarget: (item) => item.querySelector('.linkedin-post-text'),
      getContainer: (item) => item,
      applyParody: (item, target, index) => {
        const newText = linkedinParodies[index % linkedinParodies.length];
        target.textContent = newText;
        target.classList.add('parodied');
        target.setAttribute('data-original-text', newText);
        setGlitchLink(target, buildGlitchUrl('linkedin', 'parody', index));
      },
      applyCelli: (item, target, index) => {
        const newText = celliAds[index % celliAds.length];
        target.textContent = newText;
        target.classList.add('celli-ad');
        item.classList.add('has-celli-ad');
        target.setAttribute('data-original-text', newText);
        setGlitchLink(target, buildGlitchUrl('linkedin', 'celli', index));
      },
      logLabel: '💼 LinkedIn post'
    });
  }
  
  function animateSidebarEntry() {
    console.log('🎪 🎭 MYTHIC SIDEBAR ENTRY SEQUENCE INITIATED 🎭 🎪');
    console.log(`💎 Preparing crystalline note with ${brickHoles.length} breach points.`);

    cancelExtraInviteSchedule();
    noteHasEnteredFrame = false;

    clearNoteStageTimeouts();
    stopChantAudio();
    stopAiEnhancedScan();
    resetTriColorLayer();
    noteInteractionLocked = true;
    document.body.classList.remove('ref-note-centered');

    const sidebar = refSidebar;
    const ackBtn = refSidebarAck;
    const h3 = sidebar.querySelector('h3');
    const paragraphs = sidebar.querySelectorAll('p');

    // Hide close button and url during dramatic entrance
    refSidebarClose.style.display = 'none';
    refSidebarUrl.style.display = 'none';

    // Reset sidebar classes and seed crystalline state
    sidebar.classList.remove('active', 'bouncing', 'impact', 'stage-float', 'stage-sweep', 'stage-rumble', 'stage-expand', 'note-hover', 'note-seed');
    sidebar.classList.add('mythic-entrance', 'note-seed');

    if (h3) {
      h3.style.display = 'none';
    }
    paragraphs.forEach(p => p.style.display = 'none');

    noteAwaitingActivation = true;
    noteHoverSequenceStarted = false;
    loomAiMessageActive = false;
    loomFakeAdActive = false;
    noteHasEnteredFrame = false;

    markInviteActive(false);
    ackBtn.setAttribute('aria-label', 'Open Loomworks invitation note');
    ackBtn.innerHTML = `
      <div class="ref-note-crystal">
        <div class="ref-note-title">Loom Note</div>
        <div class="ref-note-sub">tap to continue</div>
      </div>
    `;
    ackBtn.style.background = 'transparent';
    ackBtn.style.backdropFilter = 'none';
    ackBtn.style.webkitBackdropFilter = 'none';
    ackBtn.style.border = 'none';
    ackBtn.style.borderRadius = '0';
    ackBtn.style.padding = '0';
    ackBtn.style.boxShadow = 'none';
    ackBtn.style.animation = '';
    ackBtn.style.cursor = 'pointer';
    ackBtn.style.transition = 'transform 0.6s ease, opacity 0.6s ease';
    ackBtn.style.opacity = '1';
    ackBtn.style.transform = 'scale(1)';

    requestAnimationFrame(() => {
      sidebar.classList.add('stage-float');
      startNoteEntryMonitor();
    });

    playChantAudio();

    console.log('  💎 Crystalline note seeded - awaiting tap to awaken.');
  }

  function transformToAltLoomworksInvite() {
    const sidebar = refSidebar;
    const ackBtn = refSidebarAck;
    
    console.log('⏱️ User waited 5 seconds - showing WILLPOWER version');
    
    // Shrink and fade the ad
    ackBtn.style.transition = 'all 0.5s ease-out';
    ackBtn.style.transform = 'scale(0.3)';
    ackBtn.style.opacity = '0';
    
    setTimeout(() => {
      // Show alt LOOMWORKS invitation (willpower version)
      showLoomworksInvite(true); // Pass true for alt/willpower version
    }, 500);
  }
  
  function updateDarkeningLevel() {
    if (!darkeningOverlay) {
      console.error('✗ darkeningOverlay element not found!');
      return;
    }

    const level = Math.min(impactCount, 5);
    console.log(`  ✓ Darkening to level: ${level}`);

    if (baseDarkness) {
      baseDarkness.classList.remove('level-1', 'level-2', 'level-3', 'level-4', 'level-5');
      if (level > 0) {
        baseDarkness.classList.add(`level-${level}`);
        baseDarkness.style.opacity = '';
      } else {
        baseDarkness.style.opacity = '0';
      }
    }

    // Calculate target opacity
    const baseOpacity = level * 0.2; // 0.2, 0.4, 0.6, 0.8, 1.0
    const targetOpacity = isMobileViewport()
      ? Math.min(baseOpacity * 0.7, 0.7)
      : baseOpacity;
    
    // Flicker effect - like power going out
    const flickerDuration = Math.max(800 - (impactCount * 100), 200);
    const flickerCount = Math.max(5 - impactCount, 2);
    
    console.log(`  💡 Flickering ${flickerCount} times over ${flickerDuration}ms, target opacity: ${targetOpacity}`);
    
    // Remove all level classes and add flicker
    darkeningOverlay.classList.remove('level-1', 'level-2', 'level-3', 'level-4', 'level-5', 'flickering');
    darkeningOverlay.classList.add('flickering');
    
    // Set CSS variable for flicker animation
    darkeningOverlay.style.setProperty('--flicker-duration', `${flickerDuration}ms`);
    darkeningOverlay.style.setProperty('--flicker-count', flickerCount);
    
    // After flickering, settle into the new darkness level
    setTimeout(() => {
      darkeningOverlay.classList.remove('flickering');
      
    if (level > 0) {
        // Directly set opacity instead of relying on classes
        darkeningOverlay.style.opacity = targetOpacity;
      darkeningOverlay.classList.add(`level-${level}`);
        console.log(`  🌑 Settled at darkness level: ${level}, opacity: ${targetOpacity}`);
        console.log(`  📊 Darkening overlay inline style opacity:`, darkeningOverlay.style.opacity);
        console.log(`  👁️ Darkening overlay computed opacity:`, window.getComputedStyle(darkeningOverlay).opacity);
    }
    }, flickerDuration);
  }
  
  function activateLightBeam() {
    if (!lightBeam) {
      console.error('✗ lightBeam element not found!');
      return;
    }
    
    if (!lightBeam.classList.contains('active')) {
      lightBeam.classList.add('active');
      console.log('✨ Light beam activated!');
    }
  }
  
  function deactivateLightBeam() {
    if (lightBeam) {
    lightBeam.classList.remove('active');
    }
  }
  
  function resetImpacts() {
    impactCount = 0;
    parodiesComplete = false;
    celliAdsComplete = false;
    resetGlitchProgress();
    noteAwaitingActivation = false;
    noteHoverSequenceStarted = false;
    loomAiMessageActive = false;
    loomFakeAdActive = false;
    noteHasEnteredFrame = false;
    clearNoteStageTimeouts();
    stopChantAudio();
    darkeningOverlay.classList.remove('level-1', 'level-2', 'level-3', 'level-4', 'level-5', 'flickering');

    // Reset darkening opacity to 0
    if (darkeningOverlay) {
      darkeningOverlay.style.opacity = '0';
      darkeningOverlay.style.maskImage = 'none';
      darkeningOverlay.style.webkitMaskImage = 'none';
    }
    if (baseDarkness) {
      baseDarkness.classList.remove('level-1', 'level-2', 'level-3', 'level-4', 'level-5');
      baseDarkness.style.opacity = '0';
    }
    
    // Clear brick holes
    brickHoles.forEach(hole => {
      if (hole.element && hole.element.parentNode) {
        hole.element.parentNode.removeChild(hole.element);
      }
    });
    brickHoles = [];
    brickHoleByPostId.clear();

    lightRaysByPostId.forEach(record => {
      if (record?.fadeTimeout) {
        clearTimeout(record.fadeTimeout);
      }
    });
    lightRaysByPostId.clear();

    // Clean up light rays
    document.querySelectorAll('.light-ray').forEach(ray => ray.remove());
    document.querySelectorAll('.burst-beam').forEach(beam => beam.remove());
    document.querySelectorAll('.darkening-hole').forEach(hole => hole.remove());
    
    deactivateLightBeam();
    hideHNWrap();
    hideSidebar();
    
    // Reset HN headlines to original
    hnItems.forEach(item => {
      item.classList.remove('glitching', 'has-celli-ad');
      const titleLink = item.querySelector('.hn-story-title');
      if (titleLink) {
        if (titleLink.classList.contains('parodied') || titleLink.classList.contains('celli-ad')) {
          const originalTitle = titleLink.getAttribute('data-original-title');
          if (originalTitle) {
            titleLink.textContent = originalTitle;
            titleLink.classList.remove('parodied', 'celli-ad');
          }
        }
        const originalLink = titleLink.dataset.originalLink || titleLink.getAttribute('href') || '#';
        setGlitchLink(titleLink, originalLink);
      }
    });

    // Reset Reddit posts
    redditItems.forEach(item => {
      item.classList.remove('glitching', 'has-celli-ad');
      const titleLink = item.querySelector('.reddit-title a');
      if (titleLink) {
        if (titleLink.classList.contains('parodied') || titleLink.classList.contains('celli-ad')) {
          const originalTitle = titleLink.getAttribute('data-original-title');
          if (originalTitle) {
            titleLink.textContent = originalTitle;
            titleLink.classList.remove('parodied', 'celli-ad');
          }
        }
        const originalLink = titleLink.dataset.originalLink || titleLink.getAttribute('href') || '#';
        setGlitchLink(titleLink, originalLink);
      }
    });

    // Reset Twitter tweets
    twitterItems.forEach(item => {
      item.classList.remove('glitching', 'has-celli-ad');
      const textEl = item.querySelector('.twitter-text');
      if (textEl) {
        if (textEl.classList.contains('parodied') || textEl.classList.contains('celli-ad')) {
          const originalText = textEl.getAttribute('data-original-text');
          if (originalText) {
            textEl.textContent = originalText;
            textEl.classList.remove('parodied', 'celli-ad');
          }
        }
        const originalLink = textEl.dataset.originalLink || '#';
        setGlitchLink(textEl, originalLink);
      }
    });

    // Reset Facebook posts
    facebookItems.forEach(item => {
      item.classList.remove('glitching', 'has-celli-ad');
      const textEl = item.querySelector('.facebook-post-text');
      if (textEl) {
        if (textEl.classList.contains('parodied') || textEl.classList.contains('celli-ad')) {
          const originalText = textEl.getAttribute('data-original-text');
          if (originalText) {
            textEl.textContent = originalText;
            textEl.classList.remove('parodied', 'celli-ad');
          }
        }
        const originalLink = textEl.dataset.originalLink || '#';
        setGlitchLink(textEl, originalLink);
      }
    });

    // Reset LinkedIn posts
    linkedinItems.forEach(item => {
      item.classList.remove('glitching', 'has-celli-ad');
      const textEl = item.querySelector('.linkedin-post-text');
      if (textEl) {
        if (textEl.classList.contains('parodied') || textEl.classList.contains('celli-ad')) {
          const originalText = textEl.getAttribute('data-original-text');
          if (originalText) {
            textEl.textContent = originalText;
            textEl.classList.remove('parodied', 'celli-ad');
          }
        }
        const originalLink = textEl.dataset.originalLink || '#';
        setGlitchLink(textEl, originalLink);
      }
    });

    cleanupGoldenSequence();

    console.log('🔄 Impact effects reset - all content restored');
  }
  
  function morphTooltipToSidebar(tooltipElement, sourceElement) {
    // Animate towards the sidebar (right edge of screen)
    tooltipElement.classList.add('morphing');
    
    console.log('🚀 Tooltip animation started');
    const COLLISION_TIME = Math.round(TOOLTIP_ANIMATION_DURATION * TOOLTIP_COLLISION_RATIO);
    console.log(`  Animation: ${TOOLTIP_ANIMATION_DURATION}ms total, collision at ~${Math.round(TOOLTIP_COLLISION_RATIO * 100)}% keyframe = ${COLLISION_TIME}ms`);

    // CSS transform animations don't update getBoundingClientRect().
    // Timing is based on the animation duration; collision happens near 95%.
    
    // Trigger effects at exact collision moment
          setTimeout(() => {
      console.log(`💥💥💥 COLLISION AT EDGE! (${COLLISION_TIME}ms)`);
      console.log(`  Triggering: edgeImpact, particles, darkening, HN glitch, BRICK BREAK`);
      
      // Get tooltip Y position for brick breaking
      const tooltipRect = tooltipElement.getBoundingClientRect();
      const impactY = tooltipRect.top + (tooltipRect.height / 2);
      
      console.log(`  📍 Tooltip rect:`, tooltipRect);
      console.log(`  📍 Impact Y position: ${impactY}px`);
      
      triggerEdgeImpact();
      createImpactParticles(tooltipElement);
      const postId = getPostIdForElement(sourceElement);
      if (postId) {
        console.log(`  🔢 Impact postId: ${postId}`);
      }
      createBrickHole(impactY, postId); // Create hole in darkening wall
    }, COLLISION_TIME);
    
    // Cleanup and remove this specific tooltip after animation completes
    setTimeout(() => {
      tooltipElement.classList.remove('active', 'morphing');
      setTimeout(() => {
        if (tooltipElement.parentNode) {
          tooltipElement.parentNode.removeChild(tooltipElement);
        }
      }, 100);
    }, 750);
  }
  
  function onLinkClick(e, url) {
    e.preventDefault();

    // Hide the hover tooltip
    hideTooltip();

    // Create a NEW independent flying tooltip for this link click
    const linkElement = e.currentTarget || e.target;
    const activeUrl = getCurrentLink(linkElement, url);
    const platform = detectPlatformFromElement(linkElement);

    if (isPostLink(linkElement)) {
      sendHeartsAndPrayers(linkElement, platform);
      runGlitchOnce();
      jitterList(400);
      triggerEdgeImpact();
      if (impactCount > 0 && impactCount <= 3) {
        setTimeout(() => showSidebar(activeUrl, true), 500);
      }
      return;
    }

    const flyingTooltip = createFlyingTooltip(activeUrl, linkElement);

    // Animate this specific tooltip independently
    morphTooltipToSidebar(flyingTooltip, linkElement);
    runGlitchOnce();
    jitterList(400);

    // Show sidebar with impact effect after tooltip splats into edge
    // (Only show after first few impacts - not on every link click)
    if (impactCount > 0 && impactCount <= 3) {
      setTimeout(() => showSidebar(activeUrl, true), 500);
    }
  }
  
  function renderItems(items, platformType) {
    console.log(`\n📝 ═══ renderItems START ═══`);
    console.log(`  Platform: ${platformType}`);
    console.log(`  Items: ${items.length}`);
    console.log(`  First item:`, items[0]);
    
    try {
      refList.innerHTML = '';
      hnItems = [];
      redditItems = [];
      twitterItems = [];
      facebookItems = [];
      linkedinItems = [];
      currentView = platformType;
      currentHNView = (platformType === 'hn');
      parodiesComplete = false;
      celliAdsComplete = false;
      resetGlitchProgress(platformType);
      
      console.log(`  Cleared refList, set currentView=${currentView}`);
    
    if (platformType === 'hn') {
      console.log('  🔶 Rendering HN view');
      refList.className = 'ref-list hn-style';
      
      const wrap = document.createElement('div');
      wrap.className = 'hn-wrap';
      wrap.innerHTML = `
        <div class="hn-top">
          <span class="hn-logo"></span>
          <span class="hn-title">Hacker News</span>
          <div class="hn-nav">
            <a href="#">new</a> | <a href="#">past</a> | <a href="#">comments</a> | <a href="#">ask</a> | <a href="#">show</a> | <a href="#">jobs</a> | <a href="#">submit</a>
          </div>
        </div>
      `;
      refList.appendChild(wrap);
      
      const content = document.createElement('div');
      content.className = 'hn-content';
      
      items.slice(0, 30).forEach((it, idx) => {
        const itemDiv = document.createElement('div');
        itemDiv.className = 'hn-item';
        const postId = `hn-${idx}`;
        itemDiv.dataset.refPostId = postId;
        itemDiv.style.opacity = '0';
        
        const rank = idx + 1;
        const domain = it.domain || '';
        const score = it.score || 0;
        const by = it.by || 'unknown';
        const time = it.time || 'moments ago';
        const comments = it.descendants || 0;
        
        itemDiv.innerHTML = `
          <div class="hn-rank">${rank}.</div>
          <div class="hn-vote"><div class="hn-vote-arrow"></div></div>
          <div class="hn-main">
            <div class="hn-titleline">
              <a class="hn-story-title" href="#" data-original-title="${escapeHtml(it.title || '(untitled)')}">${escapeHtml(it.title || '(untitled)')}</a>
              ${domain ? `<span class="hn-sitebit">(<a href="#">${escapeHtml(domain)}</a>)</span>` : ''}
            </div>
            <div class="hn-subtext">
              ${score} points by <a href="#">${escapeHtml(by)}</a> ${escapeHtml(time)} | <a href="#">hide</a> | <a href="#">${comments} comments</a>
            </div>
          </div>
        `;

        itemDiv.querySelectorAll('a').forEach(anchor => {
          anchor.dataset.refPostId = postId;
        });
        
        const link = itemDiv.querySelector('.hn-story-title');
        const originalLink = it.link || '#';
        setGlitchLink(link, originalLink);
        link.dataset.originalLink = originalLink;
        link.addEventListener('mouseenter', () => showTooltip(getCurrentLink(link, originalLink), link));
        link.addEventListener('mouseleave', () => {
          if (!refTooltip.classList.contains('morphing')) hideTooltip();
        });
        link.addEventListener('click', (e) => onLinkClick(e, getCurrentLink(link, originalLink)));

        itemDiv.querySelectorAll('.hn-subtext a, .hn-sitebit a').forEach(a => {
          const href = a.getAttribute('href') || '#';
          setGlitchLink(a, href);
          a.dataset.originalLink = href;
          a.addEventListener('mouseenter', () => showTooltip(getCurrentLink(a, href), a));
          a.addEventListener('mouseleave', () => {
            if (!refTooltip.classList.contains('morphing')) hideTooltip();
          });
          a.addEventListener('click', (e) => onLinkClick(e, getCurrentLink(a, href)));
        });
        
        content.appendChild(itemDiv);
        hnItems.push(itemDiv);
      });
      
      console.log(`  ✓ Added ${hnItems.length} HN items to hnItems array`);
      
      const spacer = document.createElement('div');
      spacer.className = 'hn-spacer';
      content.appendChild(spacer);
      
      refList.appendChild(content);
    } else if (platformType === 'reddit') {
      // Classic Reddit layout
      console.log('  🔴 Rendering Reddit view');
      refList.className = 'ref-list reddit-style';
      
      const header = document.createElement('div');
      header.className = 'reddit-header';
      header.innerHTML = `
        <div class="reddit-logo">reddit</div>
        <div class="reddit-nav">
          <a href="#">hot</a> | <a href="#">new</a> | <a href="#">rising</a> | <a href="#">controversial</a> | <a href="#">top</a> | <a href="#">gilded</a> | <a href="#">wiki</a>
        </div>
      `;
      refList.appendChild(header);
      
      const content = document.createElement('div');
      content.className = 'reddit-content';
      
      items.slice(0, 24).forEach((it, idx) => {
        const postDiv = document.createElement('div');
        postDiv.className = 'reddit-post';
        const postId = `reddit-${idx}`;
        postDiv.dataset.refPostId = postId;
        postDiv.style.opacity = '0';
        
        const score = Math.floor(Math.random() * 5000) + 100;
        const subreddit = it.subreddit || 'r/all';
        const author = it.author || 'anonymous';
        const comments = Math.floor(Math.random() * 500);
        
        postDiv.innerHTML = `
          <div class="reddit-vote">
            <div class="reddit-arrow up"></div>
            <div class="reddit-score">${score}</div>
            <div class="reddit-arrow down"></div>
          </div>
          <div class="reddit-thumbnail broken-image"></div>
          <div class="reddit-main">
            <div class="reddit-title">
              <a href="#">${escapeHtml(it.title || '(untitled)')}</a>
              <span class="reddit-domain">(${it.domain || 'self.reddit'})</span>
            </div>
            <div class="reddit-meta">
              submitted by <a href="#">${escapeHtml(author)}</a> to <a href="#" class="reddit-subreddit">${escapeHtml(subreddit)}</a>
            </div>
            <div class="reddit-meta">
              <a href="#">${comments} comments</a> | <a href="#">share</a> | <a href="#">save</a> | <a href="#">hide</a> | <a href="#">report</a>
            </div>
          </div>
        `;

        postDiv.querySelectorAll('a').forEach(anchor => {
          anchor.dataset.refPostId = postId;
        });
        
        const link = postDiv.querySelector('.reddit-title a');
        const originalLink = it.link || '#';
        setGlitchLink(link, originalLink);
        link.dataset.originalLink = originalLink;
        link.addEventListener('mouseenter', () => showTooltip(getCurrentLink(link, originalLink), link));
        link.addEventListener('mouseleave', () => {
          if (!refTooltip.classList.contains('morphing')) hideTooltip();
        });
        link.addEventListener('click', (e) => onLinkClick(e, getCurrentLink(link, originalLink)));
        
        content.appendChild(postDiv);
        redditItems.push(postDiv);
      });
      
      refList.appendChild(content);
    } else if (platformType === 'twitter') {
      // Zeed (Modern X layout)
      console.log('  🐦 Rendering Zeed view');
      refList.className = 'ref-list twitter-style';
      
      // Left sidebar
      const sidebar = document.createElement('div');
      sidebar.className = 'twitter-sidebar';
      sidebar.innerHTML = `
        <div class="twitter-logo">Zeed</div>
        <div class="twitter-nav-item">🏠 Home</div>
        <div class="twitter-nav-item">🔍 Explore</div>
        <div class="twitter-nav-item">🔔 Notifications</div>
        <div class="twitter-nav-item">✉️ Messages</div>
        <div class="twitter-nav-item">🔖 Bookmarks</div>
        <div class="twitter-nav-item">👤 Profile</div>
        <button class="twitter-post-btn">Post</button>
      `;
      refList.appendChild(sidebar);
      
      // Center feed
      const feed = document.createElement('div');
      feed.className = 'twitter-feed';
      
      // Feed header with tabs
      const feedHeader = document.createElement('div');
      feedHeader.className = 'twitter-feed-header';
      feedHeader.innerHTML = `
        <div class="twitter-tab active">For you</div>
        <div class="twitter-tab">Following</div>
      `;
      feed.appendChild(feedHeader);
      
      // Compose box
      const compose = document.createElement('div');
      compose.className = 'twitter-compose';
      compose.innerHTML = `
        <div class="twitter-avatar"></div>
        <input type="text" class="twitter-compose-input" placeholder="It's about to get nuts." />
      `;
      feed.appendChild(compose);
      
      // Tweets
      const content = document.createElement('div');
      content.className = 'twitter-content';
      
      items.forEach((it, idx) => {
        const tweet = document.createElement('div');
        tweet.className = 'twitter-tweet';
        const postId = `twitter-${idx}`;
        tweet.dataset.refPostId = postId;
        tweet.style.opacity = '0';
        
        tweet.innerHTML = `
          <div class="twitter-avatar"></div>
          <div class="twitter-tweet-content">
            <div>
              <span class="twitter-user">${escapeHtml(it.user)}</span><span class="twitter-handle">@${escapeHtml(it.handle)}</span><span class="twitter-time"> · ${Math.floor(Math.random() * 12) + 1}h</span>
            </div>
            <div class="twitter-text" data-original-text="${escapeHtml(it.text)}">${escapeHtml(it.text)}</div>
            <div class="twitter-actions">
              <span class="twitter-action">💬 ${Math.floor(Math.random() * 500)}</span>
              <span class="twitter-action">🔁 ${Math.floor(Math.random() * 2000)}</span>
              <span class="twitter-action">♥ ${Math.floor(Math.random() * 5000)}</span>
              <span class="twitter-action">📊</span>
            </div>
          </div>
        `;

        tweet.querySelectorAll('a').forEach(anchor => {
          anchor.dataset.refPostId = postId;
        });

        const textEl = tweet.querySelector('.twitter-text');
        if (textEl) {
          textEl.dataset.refPostId = postId;
          const originalLink = it.link || '#';
          setGlitchLink(textEl, originalLink);
          textEl.dataset.originalLink = originalLink;
          textEl.addEventListener('mouseenter', () => showTooltip(getCurrentLink(textEl, originalLink), textEl));
          textEl.addEventListener('mouseleave', () => {
            if (!refTooltip.classList.contains('morphing')) hideTooltip();
          });
          textEl.addEventListener('click', (e) => onLinkClick(e, getCurrentLink(textEl, originalLink)));
        }
        
        content.appendChild(tweet);
        twitterItems.push(tweet);
      });
      
      feed.appendChild(content);
      refList.appendChild(feed);
      
      // Right panel with widgets
      const rightPanel = document.createElement('div');
      rightPanel.className = 'twitter-right-panel';
      rightPanel.innerHTML = `
        <div class="twitter-widget">
          <div class="twitter-widget-title">What's happening</div>
          <div class="twitter-trend">
            <div class="twitter-trend-category">Trending in Tech</div>
            <div class="twitter-trend-name">Celli</div>
            <div class="twitter-trend-posts">847K posts</div>
          </div>
          <div class="twitter-trend">
            <div class="twitter-trend-category">Technology · Trending</div>
            <div class="twitter-trend-name">Spreadsheets</div>
            <div class="twitter-trend-posts">92.4K posts</div>
          </div>
          <div class="twitter-trend">
            <div class="twitter-trend-category">Development · Trending</div>
            <div class="twitter-trend-name">VoxelCalc</div>
            <div class="twitter-trend-posts">34.2K posts</div>
          </div>
        </div>
      `;
      refList.appendChild(rightPanel);
      
      console.log(`  ✓ Rendered ${items.length} tweets with modern X layout`);
      
    } else if (platformType === 'facebook') {
      // Facebook with Messenger
      console.log('  📘 Rendering Facebook view');
      refList.className = 'ref-list facebook-style';

      const header = document.createElement('div');
      header.className = 'facebook-header';
      header.innerHTML = `
        <div class="facebook-logo">facebook</div>
        <input type="text" class="facebook-search" placeholder="Search Facebook" />
      `;
      refList.appendChild(header);
      
      const feed = document.createElement('div');
      feed.className = 'facebook-feed';
      
      items.forEach((it, idx) => {
        const post = document.createElement('div');
        post.className = 'facebook-post';
        const postId = `facebook-${idx}`;
        post.dataset.refPostId = postId;
        post.style.opacity = '0';
        
        post.innerHTML = `
          <div class="facebook-post-header">
            <div class="facebook-avatar"></div>
            <div>
              <div class="facebook-user">${escapeHtml(it.user)}</div>
              <div class="facebook-time">${it.time}</div>
            </div>
          </div>
          <div class="facebook-post-text" data-original-text="${escapeHtml(it.text)}">${escapeHtml(it.text)}</div>
          <div class="facebook-actions">
            <div class="facebook-action">👍 Like</div>
            <div class="facebook-action">💬 Comment</div>
            <div class="facebook-action">↗ Share</div>
          </div>
        `;

        post.querySelectorAll('a').forEach(anchor => {
          anchor.dataset.refPostId = postId;
        });

        const textEl = post.querySelector('.facebook-post-text');
        if (textEl) {
          textEl.dataset.refPostId = postId;
          const originalLink = it.link || '#';
          setGlitchLink(textEl, originalLink);
          textEl.dataset.originalLink = originalLink;
          textEl.addEventListener('mouseenter', () => showTooltip(getCurrentLink(textEl, originalLink), textEl));
          textEl.addEventListener('mouseleave', () => {
            if (!refTooltip.classList.contains('morphing')) hideTooltip();
          });
          textEl.addEventListener('click', (e) => onLinkClick(e, getCurrentLink(textEl, originalLink)));
        }
        
        feed.appendChild(post);
        facebookItems.push(post);
      });
      
      refList.appendChild(feed);
      
      // Messenger sidebar
      const messenger = document.createElement('div');
      messenger.className = 'facebook-messenger';
      messenger.innerHTML = `
        <div class="messenger-header">Messenger</div>
        <div class="messenger-contact">
          <div class="messenger-avatar"></div>
          <div>
            <div class="messenger-name">Celli Bot</div>
            <div class="messenger-preview">Have you tried Celli yet?</div>
          </div>
        </div>
        <div class="messenger-contact">
          <div class="messenger-avatar"></div>
          <div>
            <div class="messenger-name">Your Future Self</div>
            <div class="messenger-preview">Why haven't you tried Celli??</div>
          </div>
        </div>
        <div class="messenger-contact">
          <div class="messenger-avatar"></div>
          <div>
            <div class="messenger-name">The Simulation Admin</div>
            <div class="messenger-preview">Celli is the answer</div>
          </div>
        </div>
      `;
      refList.appendChild(messenger);
      console.log(`  ✓ Rendered ${items.length} posts + Messenger`);
    } else if (platformType === 'linkedin') {
      console.log('  💼 Rendering LinkedIn view');
      refList.className = 'ref-list linkedin-style';

      const sidebar = document.createElement('div');
      sidebar.className = 'linkedin-sidebar';
      sidebar.innerHTML = `
        <div class="linkedin-card">
          <h4>Quick Actions</h4>
          <div class="linkedin-action">✨ Celebrate a teammate</div>
          <div class="linkedin-action">📝 Draft a humblebrag</div>
          <div class="linkedin-action">🤝 Endorse soft skills</div>
        </div>
        <div class="linkedin-card">
          <h4>Who's viewed your vibe</h4>
          <div>People managers · Curious optimists</div>
        </div>
      `;
      refList.appendChild(sidebar);

      const feed = document.createElement('div');
      feed.className = 'linkedin-feed';

      items.forEach((it) => {
        const post = document.createElement('div');
        post.className = 'linkedin-post';
        post.style.opacity = '0';

        const initials = (it.user || '?').split(' ').map((part) => part[0]).join('').slice(0, 2).toUpperCase();

        post.innerHTML = `
          <div class="linkedin-post-header">
            <div class="linkedin-avatar">${escapeHtml(initials)}</div>
            <div class="linkedin-header-text">
              <div class="linkedin-user">${escapeHtml(it.user || 'LinkedIn Member')}</div>
              <div class="linkedin-headline">${escapeHtml(it.headline || '')}</div>
              <div class="linkedin-time">${escapeHtml(it.time || '')}</div>
            </div>
            <button class="linkedin-follow">+ Follow</button>
          </div>
          <div class="linkedin-post-text" data-original-text="${escapeHtml(it.text)}">${escapeHtml(it.text)}</div>
          <div class="linkedin-post-footer">
            <span>👏 Celebrate</span>
            <span>💬 Comment</span>
            <span>🔁 Repost</span>
            <span>✉️ Send</span>
          </div>
        `;

        const textEl = post.querySelector('.linkedin-post-text');
        if (textEl) {
          const originalLink = it.link || '#';
          setGlitchLink(textEl, originalLink);
          textEl.dataset.originalLink = originalLink;
          textEl.addEventListener('mouseenter', () => showTooltip(getCurrentLink(textEl, originalLink), textEl));
          textEl.addEventListener('mouseleave', () => {
            if (!refTooltip.classList.contains('morphing')) hideTooltip();
          });
          textEl.addEventListener('click', (e) => onLinkClick(e, getCurrentLink(textEl, originalLink)));
        }

        feed.appendChild(post);
        linkedinItems.push(post);
      });

      refList.appendChild(feed);

      const right = document.createElement('div');
      right.className = 'linkedin-right';
      right.innerHTML = `
        <div class="linkedin-card">
          <h4>Trending Courses</h4>
          <div>• Authentic Synergy 101</div>
          <div>• Async Gratitude Rituals</div>
          <div>• KPI Karaoke: Find Your Metric</div>
        </div>
        <div class="linkedin-card">
          <h4>People also viewed</h4>
          <div>🧠 AI Whisperer · Hiring</div>
          <div>🪴 Plant-Based Scrum Master</div>
          <div>🚀 Fractional Vibes Consultant</div>
        </div>
      `;
      refList.appendChild(right);

      console.log(`  ✓ Rendered ${items.length} LinkedIn posts`);
    }
    
    console.log(`📝 ═══ renderItems COMPLETE ═══`);
    console.log(`  currentView=${currentView}, hnItems=${hnItems.length}, redditItems=${redditItems.length}, twitterItems=${twitterItems.length}, facebookItems=${facebookItems.length}, linkedinItems=${linkedinItems.length}\n`);
    
    } catch (error) {
      console.error(`❌❌❌ ERROR in renderItems:`, error);
      console.error(`Stack:`, error.stack);
      console.error(`Platform: ${platformType}, Items:`, items);
      throw error;
    }
  }
  
  function stagedReveal(platformType) {
    console.log(`\n✨ ═══ stagedReveal START ═══`);
    console.log(`  Platform: ${platformType}`);
    
    if (platformType === 'hn') {
      // HN: Load all simultaneously
      const items = refList.querySelectorAll('.hn-item');
      console.log(`  Found ${items.length} .hn-item elements`);
      items.forEach((n) => {
        n.style.transition = 'opacity .3s ease';
        n.style.opacity = '1';
      });
      console.log(`  ✓ All ${items.length} HN items revealed simultaneously`);
    } else if (platformType === 'reddit') {
      const posts = refList.querySelectorAll('.reddit-post');
      console.log(`  Found ${posts.length} .reddit-post elements`);
      posts.forEach((n, idx) => {
        setTimeout(() => {
          n.style.transition = 'opacity .25s ease';
          n.style.opacity = '1';
        }, 50 + idx * 30);
      });
      console.log(`  ✓ Staged ${posts.length} Reddit posts`);
    } else if (platformType === 'twitter') {
      const tweets = refList.querySelectorAll('.twitter-tweet');
      console.log(`  Found ${tweets.length} .twitter-tweet elements`);
      tweets.forEach((n, idx) => {
        setTimeout(() => {
          n.style.transition = 'opacity .2s ease';
          n.style.opacity = '1';
        }, 40 + idx * 25);
      });
      console.log(`  ✓ Staged ${tweets.length} tweets`);
    } else if (platformType === 'facebook') {
      const posts = refList.querySelectorAll('.facebook-post');
      console.log(`  Found ${posts.length} .facebook-post elements`);
      posts.forEach((n, idx) => {
        setTimeout(() => {
          n.style.transition = 'opacity .3s ease';
          n.style.opacity = '1';
        }, 60 + idx * 35);
      });
      console.log(`  ✓ Staged ${posts.length} Facebook posts`);
    } else if (platformType === 'linkedin') {
      const posts = refList.querySelectorAll('.linkedin-post');
      console.log(`  Found ${posts.length} .linkedin-post elements`);
      posts.forEach((n, idx) => {
        setTimeout(() => {
          n.style.transition = 'opacity .3s ease';
          n.style.opacity = '1';
        }, 55 + idx * 30);
      });
      console.log(`  ✓ Staged ${posts.length} LinkedIn posts`);
    } else {
      console.warn(`  Unknown platform type: ${platformType}`);
    }
    
    console.log(`✨ ═══ stagedReveal COMPLETE ═══\n`);
  }
  
  function jitterList(durationMs = 600) {
    refList.classList.add('jitter');
    setTimeout(() => refList.classList.remove('jitter'), durationMs);
  }
  
  function runGlitchOnce() {
    refGlitch.innerHTML = '';
    const rows = 7;
    for (let i = 0; i < rows; i++) {
      const slice = document.createElement('div');
      slice.className = 'slice';
      slice.style.top = `${(i * (100 / rows))}%`;
      slice.style.height = `${100 / rows}%`;
      const row = document.createElement('div');
      row.className = 'row ' + (i % 3 === 0 ? 'glitch-r' : i % 3 === 1 ? 'glitch-g' : 'glitch-b');
      row.innerHTML = `
        <div class="ref-header"></div>
        <div class="ref-list"></div>
        <div class="ref-footer"></div>
      `;
      const offset = (i % 2 ? 8 : -8);
      row.style.transform = `translateX(${offset}px)`;
      slice.appendChild(row);
      refGlitch.appendChild(slice);
    }
    
    let t = 0;
    const id = setInterval(() => {
      const rowsEls = refGlitch.querySelectorAll('.row');
      rowsEls.forEach((r, idx) => {
        const off = Math.round(Math.sin((t + idx * 3) / 2) * (idx % 2 ? 10 : -10));
        r.style.transform = `translateX(${off}px)`;
      });
      t++;
    }, 70);
    setTimeout(() => { clearInterval(id); refGlitch.innerHTML = ''; }, 3200);
  }
  
  /* === Data sources === */
  
  async function fetchHNSnapshot(refUrl) {
    const id = parseHNItemId(refUrl);
    if (id) {
      const item = await hnItem(id);
      const list = [hnFormatItem(item)];
      const top = await hnTop(29);
      top.filter(x => x.id !== id).slice(0, 29).forEach(x => list.push(hnFormatItem(x)));
      return list;
    } else {
      const top = await hnTop(30);
      return top.map(hnFormatItem);
    }
  }
  
  function hnFormatItem(item) {
    const domain = item.url ? extractDomain(item.url) : '';
    const time = formatHNTime(item.time);
    return {
      id: item.id,
      title: item.title || '(untitled)',
      link: item.url || `https://news.ycombinator.com/item?id=${item.id}`,
      domain: domain,
      score: item.score || 0,
      by: item.by || 'unknown',
      time: time,
      descendants: item.descendants || 0
    };
  }
  
  function extractDomain(url) {
    try {
      const u = new URL(url);
      return u.hostname.replace(/^www\./, '');
    } catch {
      return '';
    }
  }
  
  function formatHNTime(timestamp) {
    if (!timestamp) return 'moments ago';
    const now = Math.floor(Date.now() / 1000);
    const diff = now - timestamp;
    
    if (diff < 60) return 'just now';
    if (diff < 3600) return `${Math.floor(diff / 60)} minutes ago`;
    if (diff < 86400) return `${Math.floor(diff / 3600)} hours ago`;
    return `${Math.floor(diff / 86400)} days ago`;
  }
  
  function parseHNItemId(u) {
    try {
      const url = new URL(u);
      if (!/news\.ycombinator\.com/.test(url.hostname)) return null;
      return Number(url.searchParams.get('id')) || null;
    } catch {
      return null;
    }
  }
  
  async function hnItem(id) {
    const r = await fetch(`https://hacker-news.firebaseio.com/v0/item/${id}.json`);
    if (!r.ok) throw new Error('hn item');
    return r.json();
  }
  
  async function hnTop(n = 30) {
    const r = await fetch('https://hacker-news.firebaseio.com/v0/topstories.json');
    if (!r.ok) throw new Error('hn top');
    const ids = (await r.json()).slice(0, n);
    const items = await Promise.all(ids.map(hnItem));
    return items.filter(Boolean);
  }
  
  async function fetchRedditSnapshot(refUrl) {
    let endpoint = 'https://www.reddit.com/r/all.json?limit=24';
    try {
      if (refUrl) {
        let u;
        if (refUrl.startsWith('http')) {
          u = new URL(refUrl);
        } else {
          u = new URL('https://www.reddit.com' + (refUrl.startsWith('/') ? refUrl : '/' + refUrl));
        }
        
        let path = u.pathname;
        if (path.endsWith('/')) path = path.slice(0, -1);
        endpoint = `https://www.reddit.com${path}.json?limit=24&raw_json=1`;
      }
    } catch (e) {
      console.warn('Reddit URL parse error:', e);
    }
    
    console.log('Fetching Reddit - skipping slow proxies, using mock data immediately');
    
    // Skip slow proxy attempts - go straight to mock data for fast loading
    console.log('⚡ Using instant mock Reddit data');
    return [
      { title: 'TIL that the "faux Reddit" feature uses CORS proxies to bypass browser restrictions', link: 'https://reddit.com', subreddit: 'r/todayilearned', author: 'developer', domain: 'self.reddit' },
      { title: 'This is mock data because Reddit blocked the API request', link: 'https://reddit.com', subreddit: 'r/programming', author: 'cors_warrior', domain: 'self.reddit' },
      { title: 'PSA: Reddit\'s JSON API now requires authentication for most endpoints', link: 'https://reddit.com', subreddit: 'r/webdev', author: 'api_user', domain: 'self.reddit' },
      { title: 'I built a referrer overlay system with glitch effects', link: 'https://reddit.com', subreddit: 'r/webdev', author: 'creative_dev', domain: 'self.reddit' },
      { title: 'When your CORS proxy times out but you still want to show something', link: 'https://reddit.com', subreddit: 'r/ProgrammerHumor', author: 'fallback_king', domain: 'self.reddit' },
      { title: 'Real-time web scraping challenges in 2025', link: 'https://reddit.com', subreddit: 'r/programming', author: 'tech_writer', domain: 'self.reddit' },
      { title: 'AITA for automating my entire workflow and not telling my boss?', link: 'https://reddit.com', subreddit: 'r/AmItheAsshole', author: 'efficiency_king', domain: 'self.reddit' },
      { title: '[AskReddit] What screams "I peaked in the tutorial"?', link: 'https://reddit.com', subreddit: 'r/AskReddit', author: 'forever_junior', domain: 'self.reddit' },
      { title: 'TIL the average developer spends 90% of their time googling and 10% pretending they didn\'t', link: 'https://reddit.com', subreddit: 'r/todayilearned', author: 'stack_overflow_user', domain: 'self.reddit' },
      { title: 'My startup failed but at least I got some karma', link: 'https://reddit.com', subreddit: 'r/Entrepreneur', author: 'reformed_founder', domain: 'self.reddit' },
      { title: '[Shower Thoughts] Maybe the real MVP was the friends we made in Slack channels', link: 'https://reddit.com', subreddit: 'r/Showerthoughts', author: 'deep_thinker', domain: 'self.reddit' },
      { title: 'ELI5: How is the cloud not just someone else\'s computer?', link: 'https://reddit.com', subreddit: 'r/explainlikeimfive', author: 'confused_newbie', domain: 'self.reddit' },
      { title: 'LPT: Close all 47 Stack Overflow tabs before the standup meeting', link: 'https://reddit.com', subreddit: 'r/LifeProTips', author: 'pro_developer', domain: 'self.reddit' },
      { title: 'My code passed all tests but broke production. AMA', link: 'https://reddit.com', subreddit: 'r/programming', author: 'incident_manager', domain: 'self.reddit' },
      { title: 'TIFU by pushing directly to main on Friday at 4:59 PM', link: 'https://reddit.com', subreddit: 'r/tifu', author: 'weekend_ruiner', domain: 'self.reddit' },
      { title: 'Unpopular opinion: Writing documentation is actually harder than writing code', link: 'https://reddit.com', subreddit: 'r/unpopularopinion', author: 'doc_writer', domain: 'self.reddit' },
      { title: 'CMV: Dark mode is just light mode for people who pretend to be hackers', link: 'https://reddit.com', subreddit: 'r/changemyview', author: 'theme_warrior', domain: 'self.reddit' },
      { title: 'DAE feel personally attacked when their code gets refactored?', link: 'https://reddit.com', subreddit: 'r/DoesAnybodyElse', author: 'sensitive_dev', domain: 'self.reddit' },
      { title: '[Discussion] At what point did we normalize 15 npm packages for a hello world app?', link: 'https://reddit.com', subreddit: 'r/webdev', author: 'minimalist_dev', domain: 'self.reddit' },
      { title: 'My rubber duck quit. Where can I hire a new debugging assistant?', link: 'https://reddit.com', subreddit: 'r/ProgrammerHumor', author: 'lonely_coder', domain: 'self.reddit' },
      { title: 'TIL that "works on my machine" is not an acceptable debugging strategy', link: 'https://reddit.com', subreddit: 'r/todayilearned', author: 'learning_slowly', domain: 'self.reddit' },
      { title: 'Is anyone else just Googling things and pretending to know what they\'re doing?', link: 'https://reddit.com', subreddit: 'r/cscareerquestions', author: 'imposter_syndrome', domain: 'self.reddit' },
      { title: '[Meta] This sub has more junior devs asking questions than senior devs answering them', link: 'https://reddit.com', subreddit: 'r/learnprogramming', author: 'meta_observer', domain: 'self.reddit' },
      { title: 'Just spent 6 hours optimizing code that runs once a week. Worth it.', link: 'https://reddit.com', subreddit: 'r/programming', author: 'premature_optimizer', domain: 'self.reddit' }
    ];
  }
  
  async function fetchTwitterSnapshot(refUrl) {
    console.log('🐦 fetchTwitterSnapshot - generating mock tweets for Zeed');
    const tweets = [
      { user: 'Cilon Dusk', handle: 'cilondusk', text: 'Congratulations to @SpaceXX on their first all-woman shuttle disaster. My heart will go on. 🚀💔', link: '#' },
      { user: 'Food Pleaser', handle: 'foodpleaser', text: 'Well, can you name one? 🤷', link: '#' },
      { user: 'TechCrunch', handle: 'techcrunch', text: 'Breaking: New AI model achieves 99.9% accuracy (on training data)', link: '#' },
      { user: 'GitHub', handle: 'github', text: 'Ship code faster with GitHub Copilot. Now with 100% more hallucinations!', link: '#' },
      { user: 'Vercel', handle: 'vercel', text: 'Deploy your app in milliseconds. Debug it for hours. ⚡', link: '#' },
      { user: 'DHH', handle: 'dhh', text: 'Hot take: Maybe we don\'t need 47 JavaScript frameworks for a contact form', link: '#' },
      { user: 'Theo', handle: 't3dotgg', text: 'Me: *writes clean code* // The PR reviewer: "Have you considered rewriting this from scratch?"', link: '#' },
      { user: 'Fireship', handle: 'fireship_dev', text: 'New framework just dropped. Learn it in 100 seconds before it\'s deprecated.', link: '#' },
      { user: 'Coding Garden', handle: 'coding_garden', text: 'Live coding session: Building a TODO app for the 847th time 🌱', link: '#' },
      { user: 'JavaScript', handle: 'javascript', text: 'const bugs = "features"; // This is fine 🔥', link: '#' },
      { user: 'TypeScript', handle: 'typescript', text: 'You can\'t have runtime errors if you have compile-time errors *taps head*', link: '#' },
      { user: 'Stack Overflow', handle: 'stackoverflow', text: 'Question marked as duplicate. The original question is from 2009 and doesn\'t help. Good luck!', link: '#' },
      { user: 'npm', handle: 'npmjs', text: 'node_modules weighs more than a black hole but at least your build works', link: '#' },
      { user: 'React', handle: 'reactjs', text: 'useEffect(() => { console.log("why did this run 47 times"); }, []);', link: '#' },
      { user: 'Tailwind CSS', handle: 'tailwindcss', text: 'className="flex items-center justify-between p-4 rounded-lg shadow-md hover:shadow-lg transition-all duration-200 ease-in-out bg-gradient-to-r from-blue-500 to-purple-600"', link: '#' },
      { user: 'VS Code', handle: 'code', text: 'New extension: "Closes all your tabs when you\'re about to do something productive"', link: '#' },
      { user: 'Mozilla', handle: 'mozilla', text: 'Firefox is like that indie band you swear is better but nobody else listens to', link: '#' },
      { user: 'Chrome DevTools', handle: 'chromedevtools', text: 'console.log("debugging is just printf debugging with extra steps")', link: '#' },
      { user: 'Docker', handle: 'docker', text: 'It works on my container 🐳', link: '#' },
      { user: 'Linux', handle: 'linux', text: 'I use Arch btw. How did you know? Was it the 3-hour monologue about package managers?', link: '#' }
    ];
    console.log(`  ✓ Generated ${tweets.length} mock Zeed posts`);
    console.log(`  Sample: "${tweets[0].text}"`);
    return tweets;
  }
  
  async function fetchFacebookSnapshot(refUrl) {
    console.log('📘 fetchFacebookSnapshot - generating mock Facebook posts');
    const posts = [
      { user: 'Jane Developer', text: '🎉 Just got my first PR merged! Only took 47 revisions and 3 existential crises!', time: '2h', link: '#' },
      { user: 'Tech Dad', text: 'My son asked what I do for a living. I said "I copy code from Stack Overflow." He looked disappointed. I\'m raising him right. 😌', time: '4h', link: '#' },
      { user: 'Isa Asimov', text: 'My new robot only has three laws: Eat Pray Love! And Live Laugh Love! Okay so five laws.', time: '5h', link: '#' },
      { user: 'Sarah Connor', text: 'I don\'t know how to feel about this whole AI thing', time: '6h', link: '#' },
      { user: 'Bob Programmer', text: 'Remember when we thought Zoom fatigue was temporary? *laughs in permanent work-from-home*', time: '8h', link: '#' },
      { user: 'DevLife Quotes', text: 'Live. Laugh. localhost:3000 💻✨', time: '10h', link: '#' },
      { user: 'Jenny Code', text: 'Some of you never had to debug IE6 and it shows. Stay blessed. 🙏', time: '12h', link: '#' },
      { user: 'Mike Stack', text: 'My code review comments: "nit:", "nit:", "nit:", "THIS WILL DESTROY EVERYTHING" (submitted anyway)', time: '14h', link: '#' },
      { user: 'Lisa Debug', text: 'Fun fact: 80% of programming is naming variables. The other 20% is renaming them.', time: '16h', link: '#' },
      { user: 'Tom Binary', text: 'Wife: Why are you talking to yourself? // Me: I\'m not, I\'m explaining my code to the rubber duck // Wife: *backs away slowly*', time: '18h', link: '#' },
      { user: 'Alex Syntax', text: 'Me: I\'ll never use math after school // Also me: *calculating time complexity at 2am*', time: '20h', link: '#' },
      { user: 'Chris Deploy', text: 'PRAYER CIRCLE for everyone who deployed to production 5 minutes before their vacation started 🕯️🕯️🕯️', time: '22h', link: '#' },
      { user: 'Patricia Loop', text: 'Relationship status: for(;;) { hope; }', time: '1d', link: '#' },
      { user: 'Steve Async', text: 'They say the best time to plant a tree was 20 years ago. The second best time is now. The third best time is after your code review is approved.', time: '1d', link: '#' },
      { user: 'Rachel Frontend', text: 'normalize asking "is this a real email or did my regex break again" before replying to important messages', time: '2d', link: '#' },
      { user: 'Dan Fullstack', text: 'My resume: Full-stack developer // What I actually do: Full-stack googler 🔍', time: '2d', link: '#' },
      { user: 'Community Potluck', text: 'Linking this 20-minute lasagna recipe because comfort food fixes morale. Chad is no longer with us. 🤪', time: '3d', link: 'https://www.allrecipes.com/recipe/23600/worlds-best-lasagna/' }
    ];
    console.log(`  ✓ Generated ${posts.length} mock Facebook posts`);
    console.log(`  Sample: "${posts[0].text}"`);
    return posts;
  }

  async function fetchLinkedInSnapshot(refUrl) {
    console.log('💼 fetchLinkedInSnapshot - generating mock LinkedIn posts');
    const posts = [
      { user: 'Ari Metrics', headline: 'Head of Alignment @ OKRverse', text: 'Make sure your team is O-KPI.', time: '1h • Edited', link: '#' },
      { user: 'Nia Futureproof', headline: 'Fractional Futurist | Keynote Optimist', text: 'Thrilled to announce my inner child just raised a Series B in imagination funding.', time: '3h', link: '#' },
      { user: 'Eli Standup', headline: 'Staff Engineer (remote-ish)', text: 'Daily stand-up tip: if you say "to be transparent" before every sentence it sounds like a strategy.', time: '5h', link: '#' },
      { user: 'Priya Async', headline: 'Director of Distributed Hugs @ SentimentOps', text: 'Rolling out a no-meeting Wednesday that stretches from Tuesday afternoon to Thursday brunch.', time: '8h', link: '#' },
      { user: 'Mal Weekender', headline: 'Weekend Founder | Monday Mentor', text: 'Closing laptop at 5pm is my most disruptive innovation yet.', time: '1d', link: '#' }
    ];
    console.log(`  ✓ Generated ${posts.length} mock LinkedIn posts`);
    console.log(`  Sample: "${posts[0].text}"`);
    return posts;
  }
  
  async function fetchGenericFallback(refUrl) {
    const host = hostOrPath(refUrl);
    return [
      { 
        title: `Loading ${host}…`, 
        link: refUrl || '',
        subreddit: 'r/unknown',
        author: 'system',
        domain: host
      },
      { 
        title: 'Tip: add ?ref=hn or ?ref=reddit to your link', 
        link: '',
        subreddit: 'r/help',
        author: 'system',
        domain: 'self.help'
      }
    ];
  }
  
  function hostOrPath(u) {
    try {
      const x = new URL(u);
      return x.hostname + x.pathname;
    } catch {
      return u || '';
    }
  }
  
  function escapeHtml(s) {
    return ('' + s).replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;');
  }
  
  console.log('✅ Referrer Glitch Overlay initialized');
  console.log('📋 Ready to test: Click "Hacker News" or "Reddit" button in Play overlay');
 </script>
</body>
</html>
