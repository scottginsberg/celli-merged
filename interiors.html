<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Interiors System - Room Builder</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { height: 100%; overflow: hidden; background: #0a0d12; 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif; }
    
    #info {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(15,20,28,.96);
      backdrop-filter: blur(16px);
      border: 1px solid rgba(74,124,255,.3);
      border-radius: 12px;
      padding: 18px;
      color: #e8edf7;
      font-size: 13px;
      line-height: 1.6;
      box-shadow: 0 8px 32px rgba(0,0,0,.5);
      z-index: 100;
      max-width: 320px;
    }
    
    .panel-title {
      font-size: 15px;
      font-weight: 700;
      color: #6a9cff;
      margin-bottom: 14px;
      text-transform: uppercase;
      letter-spacing: 1px;
      border-bottom: 2px solid rgba(74,124,255,.2);
      padding-bottom: 8px;
    }
    
    kbd {
      background: linear-gradient(180deg, #2a3440 0%, #1a2130 100%);
      border: 1px solid rgba(106,156,255,.4);
      border-radius: 4px;
      padding: 3px 7px;
      font-family: 'Monaco', 'Consolas', monospace;
      font-size: 11px;
      color: #8ab4ff;
      display: inline-block;
      min-width: 22px;
      text-align: center;
    }
    
    button {
      background: linear-gradient(180deg, #4a7cff 0%, #3a6cef 100%);
      border: 1px solid rgba(106,156,255,.6);
      border-radius: 6px;
      padding: 8px 16px;
      color: white;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      margin: 4px;
      transition: all 0.2s;
    }
    
    button:hover {
      background: linear-gradient(180deg, #5a8cff 0%, #4a7cff 100%);
      transform: translateY(-1px);
    }
    
    button:active {
      transform: translateY(0);
    }
  </style>
</head>
<body>
  <div id="info">
    <div class="panel-title">üè† Interiors System</div>
    <div style="margin: 8px 0;">
      <kbd>1</kbd> Studio <kbd>2</kbd> 1BR <kbd>3</kbd> 2BR<br>
      <kbd>WASD</kbd> Move <kbd>Mouse</kbd> Look<br>
      <kbd>Space</kbd> Jump <kbd>Shift</kbd> Sprint<br>
      <kbd>B</kbd> Asset Library <kbd>Click</kbd> Interact
    </div>
    <div style="margin-top: 12px;">
      <button onclick="loadRoom('studio')">Studio</button>
      <button onclick="loadRoom('1br')">1BR</button>
      <button onclick="loadRoom('2br')">2BR</button>
      <br>
      <button onclick="loadRoom('classroom')">Classroom</button>
      <button onclick="loadRoom('gymnasium')">Gymnasium</button>
      <br>
      <button onclick="randomizeRoom()" style="background: linear-gradient(180deg, #ff8c4a 0%, #ef6c3a 100%);">üé≤ Randomize Current</button>
      <br>
      <button onclick="trulyRandom()" style="background: linear-gradient(180deg, #4aff8c 0%, #3aef6c 100%);">‚ú® Truly Random</button>
    </div>
    <div id="room-info" style="margin-top: 12px; font-size: 11px; color: #8ab4ff;">
      Current: None
    </div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
    import { FloorPatterns } from './js/floor-patterns.js';
    import { 
      SURFACE_METADATA, 
      FURNITURE_ZONES, 
      PLACEMENT_POLICIES, 
      WALL_DECOR_POLICIES,
      FLOOR_PATTERNS_BY_ROOM,
      getSurfaceGrid,
      isPlacementValid,
      selectSurfaceProps
    } from './js/interiors-metadata.js';

    // ==================== CONFIGURATION ====================
    
    const GRID_SIZE = 0.6; // Larger grid cell size (was 0.5)
    const WALL_HEIGHT = 2.5; // meters
    const WALL_THICKNESS = 0.1;
    
    // ==================== WALL PLACEMENT SYSTEM ====================
    // Walls are defined by grid line segments
    // Format: { x: grid_x, z: grid_z, dir: 'h'|'v', length: grid_units, hasDoor: bool }
    
    const ROOM_CONFIGS = {
      studio: {
        name: 'Studio Apartment',
        mainRoom: 'studio',
        floorBounds: { minX: -6, maxX: 6, minZ: -6, maxZ: 6 },
        walls: [
          // Outer perimeter with EXIT DOOR
          { x: -6, z: -6, dir: 'h', length: 4 },
          { x: -2, z: -6, dir: 'h', length: 6, hasDoor: true },  // EXIT DOOR on front wall
          { x: 4, z: -6, dir: 'h', length: 2 },
          { x: -6, z: 6, dir: 'h', length: 12 },   // Back wall
          { x: -6, z: -6, dir: 'v', length: 12 },  // Left wall
          { x: 6, z: -6, dir: 'v', length: 12 },   // Right wall
          
          // Bathroom partition walls with DOOR TO MAIN ROOM
          { x: 3, z: -6, dir: 'v', length: 5 },      // Bathroom left wall
          { x: 3, z: -1, dir: 'h', length: 3, hasDoor: true },  // Bathroom door to main
          { x: 6, z: -1, dir: 'v', length: 3 }       // Bathroom front corner
        ],
        windows: [
          { x: -4, z: -6, dir: 'h', length: 2 }   // Window on front wall
        ],
        furniture: [
          // Entrance door and hallway
          { type: 'entrancedoor', x: 0, z: -6.2, rotation: 0 },
          
          // Living area
          { type: 'couch', x: -2, z: 0, rotation: Math.PI },
          { type: 'coffeetable', shape: 'rectangle', x: -2, z: -1.5, rotation: 0 },
          { type: 'tv', x: -2, z: -4.5, rotation: 0 },
          
          // Games on coffee table
          { type: 'gameboard', x: -2.2, z: -1.5, y: 0.42, rotation: 0.2, variant: 'checkers' },
          { type: 'dice', x: -1.6, z: -1.7, y: 0.41, rotation: 0 },
          { type: 'pokerchip', x: -1.8, z: -1.3, y: 0.41, color: 0xff3333 },
          { type: 'pokerchip', x: -1.85, z: -1.35, y: 0.41, color: 0x3333ff },
          
          // Bedroom area
          { type: 'bed', x: -3, z: 3, rotation: Math.PI / 2 },
          { type: 'sidetable', x: -4.8, z: 3, rotation: 0 },
          { type: 'alarmclock', x: -4.8, z: 3, y: 0.55, rotation: 0 },
          { type: 'floorlamp', x: -1, z: 5, rotation: 0, lit: true },
          
          // Kitchen area
          { type: 'counter', x: 1, z: -2, rotation: Math.PI },
          { type: 'fruitbowl', x: 1, z: -2, y: 0.95, rotation: 0 },
          { type: 'plate', x: 0.5, z: -2, y: 0.91, rotation: 0 },
          { type: 'bowl', x: 1.5, z: -2, y: 0.91, rotation: 0 },
          
          // Decorations
          { type: 'plant', x: -4, z: 2, rotation: 0 },
          { type: 'plant', x: 2, z: 4, rotation: 0 },
          { type: 'artframe', size: 'medium', x: -5.9, z: 0, y: 1.5, rotation: Math.PI / 2, wallMount: true },
          { type: 'artframe', size: 'small', x: 5.9, z: 2, y: 1.4, rotation: -Math.PI / 2, wallMount: true },
          { type: 'clock', x: -5.9, z: 4, y: 2.0, rotation: Math.PI / 2 },
          
          // Bathroom
          { type: 'toilet', x: 4.5, z: -4.5, rotation: 0 },
          { type: 'shower', x: 4.5, z: 1, rotation: 0 }
        ]
      },
      
      '1br': {
        name: '1 Bedroom',
        mainRoom: 'living',
        floorBounds: { minX: -7, maxX: 7, minZ: -6, maxZ: 8 },
        walls: [
          // Outer perimeter with EXIT DOOR
          { x: -7, z: -6, dir: 'h', length: 5 },
          { x: -2, z: -6, dir: 'h', length: 7, hasDoor: true }, // EXIT DOOR to outside
          { x: 5, z: -6, dir: 'h', length: 2 },
          { x: -7, z: 8, dir: 'h', length: 14 },  // Back
          { x: -7, z: -6, dir: 'v', length: 14 }, // Left
          { x: 7, z: -6, dir: 'v', length: 14 },  // Right
          
          // Living/Bedroom divider with DOOR TO MAIN ROOM
          { x: -7, z: 2, dir: 'h', length: 5 },
          { x: -2, z: 2, dir: 'h', length: 7, hasDoor: true },  // Bedroom door to living
          { x: 5, z: 2, dir: 'h', length: 2 },
          
          // Bathroom walls with DOOR TO MAIN ROOM
          { x: 4, z: -6, dir: 'v', length: 4 },
          { x: 4, z: -2, dir: 'h', length: 3, hasDoor: true }  // Bathroom door to living
        ],
        windows: [
          { x: -3, z: -6, dir: 'h', length: 2 },  // Living room window
          { x: -1.5, z: 8, dir: 'h', length: 3 }    // Bedroom window
        ],
        furniture: [
          // Entrance door
          { type: 'entrancedoor', x: 1, z: -6.2, rotation: 0 },
          
          // Living room (main)
          { type: 'couch', x: -2, z: -1, rotation: Math.PI },
          { type: 'coffeetable', shape: 'rectangle', x: -2, z: -2.5, rotation: 0 },
          { type: 'tv', x: -2, z: -5, rotation: 0 },
          
          // Games on coffee table
          { type: 'gameboard', x: -2.3, z: -2.5, y: 0.42, rotation: 0.4, variant: 'chess' },
          { type: 'chesspawn', x: -2, z: -2.3, y: 0.42, color: 0xffffff },
          { type: 'chesspawn', x: -1.8, z: -2.6, y: 0.42, color: 0x1a1a1a },
          
          // Kitchen area
          { type: 'counter', x: -4, z: -1, rotation: 0 },
          { type: 'fruitbowl', x: -4, z: -1, y: 0.95, rotation: 0 },
          { type: 'plate', x: -3.5, z: -1, y: 0.91, rotation: 0 },
          
          // Living room decorations
          { type: 'plant', x: -6, z: 0, rotation: 0 },
          { type: 'floorlamp', x: -5, z: -4, rotation: 0, lit: true },
          { type: 'artframe', size: 'large', x: -6.9, z: -2, y: 1.6, rotation: Math.PI / 2, wallMount: true },
          
          // Bedroom (3 decorations required)
          { type: 'bed', x: 0, z: 5, rotation: 0 },
          { type: 'sidetable', x: -1.8, z: 5, rotation: 0 },
          { type: 'alarmclock', x: -1.8, z: 5, y: 0.55, rotation: 0, color: 0x4444ff },
          { type: 'closet', x: -6, z: 7, rotation: 0 },
          { type: 'computerdesk', x: 4, z: 6, rotation: -Math.PI / 2 },
          { type: 'plant', x: -3, z: 6, rotation: 0 },
          { type: 'artframe', size: 'medium', x: -6.9, z: 5, y: 1.5, rotation: Math.PI / 2, wallMount: true },
          { type: 'artframe', size: 'small', x: 2, z: 7.9, y: 1.4, rotation: Math.PI, wallMount: true },
          { type: 'clock', x: 5, z: 7.9, y: 2.0, rotation: Math.PI },
          
          // Bathroom
          { type: 'toilet', x: 5.5, z: -4.5, rotation: 0 },
          { type: 'shower', x: 5.5, z: -0.8, rotation: 0 }
        ]
      },
      
      '2br': {
        name: '2 Bedroom',
        mainRoom: 'living',
        floorBounds: { minX: -9, maxX: 9, minZ: -6, maxZ: 8 },
        walls: [
          // Outer perimeter with EXIT DOOR
          { x: -9, z: -6, dir: 'h', length: 6 },
          { x: -3, z: -6, dir: 'h', length: 9, hasDoor: true },  // EXIT DOOR to outside
          { x: 6, z: -6, dir: 'h', length: 3 },
          { x: -9, z: 8, dir: 'h', length: 18 },
          { x: -9, z: -6, dir: 'v', length: 14 },
          { x: 9, z: -6, dir: 'v', length: 14 },
          
          // Living/Hallway divider (hallway connects to main)
          { x: -9, z: 2, dir: 'h', length: 6 },
          { x: -3, z: 2, dir: 'h', length: 10, hasDoor: true },  // Hallway door to living
          { x: 7, z: 2, dir: 'h', length: 2 },
          
          // Bedroom divider (middle wall)
          { x: 0, z: 2, dir: 'v', length: 6 },
          
          // Bedroom 1 door TO MAIN (hallway)
          { x: -9, z: 4.5, dir: 'h', length: 3.5, hasDoor: true },
          
          // Bedroom 2 door TO MAIN (hallway)
          { x: 1, z: 4.5, dir: 'h', length: 3.5, hasDoor: true },
          
          // Bathroom walls with DOOR TO MAIN
          { x: 6, z: -6, dir: 'v', length: 4 },
          { x: 6, z: -2, dir: 'h', length: 3, hasDoor: true }  // Bathroom door to living
        ],
        windows: [
          { x: -4, z: -6, dir: 'h', length: 2 },  // Living
          { x: -5, z: 8, dir: 'h', length: 3 },   // Bedroom 1
          { x: 3, z: 8, dir: 'h', length: 3 }     // Bedroom 2
        ],
        furniture: [
          // Entrance door
          { type: 'entrancedoor', x: 1, z: -6.2, rotation: 0 },
          
          // Living room (main)
          { type: 'couch', x: 0, z: -1, rotation: Math.PI },
          { type: 'coffeetable', shape: 'square', x: 0, z: -2.5, rotation: 0 },
          { type: 'tv', x: 0, z: -5, rotation: 0 },
          
          // Games on coffee table
          { type: 'gameboard', x: -0.2, z: -2.5, y: 0.42, rotation: 0.1, variant: 'checkers' },
          { type: 'dice', x: 0.3, z: -2.3, y: 0.41, rotation: 0 },
          { type: 'pokerchip', x: 0.2, z: -2.7, y: 0.41, color: 0x1a1a1a },
          
          // Kitchen area
          { type: 'counter', x: -5, z: -2, rotation: 0 },
          { type: 'fruitbowl', x: -5, z: -2, y: 0.95, rotation: 0 },
          { type: 'plate', x: -4.5, z: -2, y: 0.91, rotation: 0 },
          { type: 'bowl', x: -5.5, z: -2, y: 0.91, rotation: 0 },
          
          // Living room decorations
          { type: 'plant', x: 3, z: -1, rotation: 0 },
          { type: 'plant', x: -7, z: 0, rotation: 0 },
          { type: 'floorlamp', x: 4, z: -4, rotation: 0, lit: true },
          { type: 'artframe', size: 'large', x: -8.9, z: -2, y: 1.6, rotation: Math.PI / 2, wallMount: true },
          { type: 'artframe', size: 'medium', x: 8.9, z: -2, y: 1.5, rotation: -Math.PI / 2, wallMount: true },
          
          // Bedroom 1 (3 decorations required + closet) - LEFT side
          { type: 'bed', x: -4.5, z: 5, rotation: 0 },
          { type: 'sidetable', x: -6.5, z: 5, rotation: 0 },
          { type: 'alarmclock', x: -6.5, z: 5, y: 0.55, rotation: 0, color: 0xff4444 },
          { type: 'closet', x: -7.5, z: 3.5, rotation: 0 },
          { type: 'plant', x: -2.5, z: 6.5, rotation: 0 },
          { type: 'artframe', size: 'medium', x: -8.9, z: 4.5, y: 1.5, rotation: Math.PI / 2, wallMount: true },
          { type: 'artframe', size: 'small', x: -4.5, z: 7.9, y: 1.4, rotation: Math.PI, wallMount: true },
          { type: 'clock', x: -6.5, z: 7.9, y: 2.0, rotation: Math.PI },
          
          // Bedroom 2 (3 decorations required + closet + computer desk) - RIGHT side
          { type: 'bed', x: 4.5, z: 5, rotation: Math.PI },
          { type: 'sidetable', x: 6.5, z: 5, rotation: 0 },
          { type: 'alarmclock', x: 6.5, z: 5, y: 0.55, rotation: 0, color: 0x44ff44 },
          { type: 'closet', x: 7.5, z: 3.5, rotation: Math.PI },
          { type: 'computerdesk', x: 2, z: 6, rotation: Math.PI / 2 },
          { type: 'plant', x: 2.5, z: 6.5, rotation: 0 },
          { type: 'artframe', size: 'medium', x: 8.9, z: 4.5, y: 1.5, rotation: -Math.PI / 2, wallMount: true },
          { type: 'artframe', size: 'small', x: 4.5, z: 7.9, y: 1.4, rotation: Math.PI, wallMount: true },
          { type: 'clock', x: 6.5, z: 7.9, y: 2.0, rotation: Math.PI },
          
          // Bathroom
          { type: 'toilet', x: 7.5, z: -4.5, rotation: 0 },
          { type: 'shower', x: 7.5, z: -0.8, rotation: 0 }
        ]
      }
    };
    
    // ==================== ASSET CATALOG (50+ Assets) ====================
    /*
      KITCHEN & DINING:
      - Plates, Bowls, Cups, Mugs, Wine Glass
      - Fork, Knife, Spoon, Chopsticks
      - Cutting Board, Pot, Pan, Kettle
      - Toaster, Microwave, Coffee Maker
      - Kitchen Counter with Sink
      
      FRUIT & FOOD:
      - Apple, Pear, Banana, Orange, Grapes
      - Bread Loaf, Cheese Block, Egg
      - Fruit Bowl (compound asset)
      
      FURNITURE:
      - Desks (Square, Rectangle, Circle)
      - Bed, Nightstand, Dresser, Wardrobe
      - Chair, Stool, Armchair, Sofa
      - Bookshelf, Coffee Table, TV Stand
      - Kitchen Counter
      
      DECORATIONS:
      - Potted Plant (various types)
      - Picture Frame (with abstract art)
      - Wall Clock, Desk Clock
      - Vase (empty or with flowers)
      - Lamp (Table, Floor, Desk)
      - Mirror, Rug, Curtains
      - Books (stack), Magazine
      
      BATHROOM:
      - Toilet, Shower, Bathtub
      - Sink, Towel Rack, Toilet Paper
      - Mirror, Medicine Cabinet
      
      ELECTRONICS:
      - TV, Monitor, Laptop, Phone
      - Speaker, Radio, Alarm Clock
      
      LIGHTING:
      - Ceiling Light, Pendant, Chandelier
      - Table Lamp, Floor Lamp, Desk Lamp
      
      STORAGE:
      - Cardboard Box, Basket, Bin
      - Shelf, Cabinet, Drawer
      
      OFFICE:
      - Pen Holder, Stapler, Tape Dispenser
      - Filing Cabinet, Whiteboard
      
      BEDROOM:
      - Pillow, Blanket, Sheet
      - Hanger, Laundry Basket
    */
    
    const ASSETS = {
      desk: {
        square: { width: 1, depth: 1, height: 0.75, legRadius: 0.04, legHeight: 0.7 },
        rectangle: { width: 1.5, depth: 0.75, height: 0.75, legRadius: 0.04, legHeight: 0.7 },
        circle: { radius: 0.5, height: 0.75, legRadius: 0.04, legHeight: 0.7 }
      },
      bed: { width: 1.5, depth: 2, height: 0.5, legHeight: 0.3 },
      toilet: { 
        bowlRadius: 0.22, 
        bowlHeight: 0.35,
        seatRadius: 0.24,
        tankWidth: 0.4,
        tankDepth: 0.15,
        tankHeight: 0.35
      },
      shower: { width: 1, depth: 1, height: 2 },
      counter: {
        width: 2.0,
        depth: 0.6,
        height: 0.9,
        thickness: 0.05,
        sinkWidth: 0.5,
        sinkDepth: 0.4,
        sinkHeight: 0.15
      }
    };
    
    // Interactive objects registry
    const interactiveObjects = [];
    let selectedObject = null;
    
    // ==================== SCENE SETUP ====================
    
    let scene, camera, renderer, controls;
    let currentRoom = null;
    let roomObjects = [];
    
    function init() {
      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);
      scene.fog = new THREE.Fog(0x87ceeb, 5, 15);
      
      // Camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
      camera.position.set(0, 1.6, 0);
      
      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);
      
      // Controls
      controls = new PointerLockControls(camera, renderer.domElement);
      
      renderer.domElement.addEventListener('click', () => {
        controls.lock();
      });
      
      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      
      const sunLight = new THREE.DirectionalLight(0xfff5e6, 0.8);
      sunLight.position.set(5, 10, 5);
      sunLight.castShadow = true;
      sunLight.shadow.camera.left = -10;
      sunLight.shadow.camera.right = 10;
      sunLight.shadow.camera.top = 10;
      sunLight.shadow.camera.bottom = -10;
      sunLight.shadow.mapSize.width = 2048;
      sunLight.shadow.mapSize.height = 2048;
      scene.add(sunLight);
      
      // Keyboard controls
      setupMovement();
      
      // Mouse interaction
      document.addEventListener('click', onMouseClick);
      
      // Window resize
      window.addEventListener('resize', onWindowResize);
      
      // Asset library UI
      setupAssetLibrary();
      
      // Load default room
      loadRoom('studio');
      
      // Start animation
      animate();
    }
    
    // ==================== MOVEMENT SYSTEM ====================
    
    const keys = new Set();
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    let moveSpeed = 3.0;
    let sprintMultiplier = 1.0;
    
    function setupMovement() {
      document.addEventListener('keydown', (e) => {
        keys.add(e.code);
        
        // Room switching
        if (e.code === 'Digit1') loadRoom('studio');
        if (e.code === 'Digit2') loadRoom('1br');
        if (e.code === 'Digit3') loadRoom('2br');
      });
      
      document.addEventListener('keyup', (e) => {
        keys.delete(e.code);
      });
    }
    
    function updateMovement(delta) {
      if (!controls.isLocked) return;
      
      velocity.x = 0;
      velocity.z = 0;
      
      direction.z = Number(keys.has('KeyW')) - Number(keys.has('KeyS'));
      direction.x = Number(keys.has('KeyD')) - Number(keys.has('KeyA'));
      direction.normalize();
      
      sprintMultiplier = keys.has('ShiftLeft') || keys.has('ShiftRight') ? 2.0 : 1.0;
      
      if (direction.z !== 0) {
        velocity.z = direction.z * moveSpeed * sprintMultiplier * delta;
      }
      if (direction.x !== 0) {
        velocity.x = direction.x * moveSpeed * sprintMultiplier * delta;
      }
      
      controls.moveRight(velocity.x);
      controls.moveForward(velocity.z);
      
      // Simple jump
      if (keys.has('Space') && camera.position.y <= 1.6) {
        camera.position.y += 0.05;
      } else if (camera.position.y > 1.6) {
        camera.position.y = Math.max(1.6, camera.position.y - 0.02);
      }
    }
    
    // ==================== DYNAMIC RULES ENGINE ====================
    
    const PLACEMENT_RULES = {
      // TVs must be on TV stands
      tv: (config) => {
        const tvStands = config.furniture.filter(f => f.type === 'tvstand');
        return tvStands.length > 0 ? tvStands[0] : null;
      },
      
      // Cleaning supplies in bathroom
      cleaningSupplies: ['broom', 'dustpan', 'vacuum', 'handheldvacuum', 'bucket', 'sponge', 'toiletpaperroll'],
      
      // Flexible items
      rag: ['coffeetable', 'sidetable', 'counter'],
      papertowelroll: ['coffeetable', 'sidetable', 'counter'],
      
      // Kitchen items
      refrigeratorItems: ['milkcarton', 'orangejuice', 'cheese', 'eggs'],
      counterItems: ['microwave', 'cerealbox', 'crackerbox', 'fruitbowl', 'plate'],
      
      // Shelves need wall placement with objects
      shelfObjects: ['plant', 'clock', 'artframe', 'book']
    };
    
    function applyRulesEngine(config) {
      // Rule 1: TVs on TV stands
      const tvItems = config.furniture.filter(f => f.type === 'tv');
      const tvStandItems = config.furniture.filter(f => f.type === 'tvstand');
      
      tvItems.forEach((tv, idx) => {
        if (tvStandItems[idx]) {
          tv.x = tvStandItems[idx].x;
          tv.z = tvStandItems[idx].z;
          tv.y = 0.5; // On stand height
          tv.rotation = tvStandItems[idx].rotation;
        }
      });
      
      // Rule 2: Beds against wall opposite door
      const beds = config.furniture.filter(f => f.type === 'bed');
      beds.forEach(bed => {
        // Rotate bed so headboard faces away from door
        const doorZ = config.walls.find(w => w.hasDoor)?.z || 0;
        if (bed.z < doorZ) {
          bed.rotation = 0; // Headboard north
        } else {
          bed.rotation = Math.PI; // Headboard south
        }
      });
      
      // Rule 3: Kitchen counters - detect wall-backed vs island
      const counters = config.furniture.filter(f => f.type === 'counter');
      counters.forEach(counter => {
        const isNearWall = config.walls.some(w => {
          const wallZ = w.z;
          const counterZ = counter.z;
          return Math.abs(wallZ - counterZ) < 1.5;
        });
        counter.wallBacked = isNearWall;
        counter.isIsland = !isNearWall;
      });
      
      // Rule 4: Add shelves to walls with objects
      const bounds = config.floorBounds;
      const wallPositions = [
        { x: (bounds.minX + bounds.maxX) / 2, z: bounds.minZ + 1, rotation: 0 },
        { x: (bounds.minX + bounds.maxX) / 2, z: bounds.maxZ - 1, rotation: Math.PI },
        { x: bounds.minX + 1, z: (bounds.minZ + bounds.maxZ) / 2, rotation: -Math.PI / 2 },
        { x: bounds.maxX - 1, z: (bounds.minZ + bounds.maxZ) / 2, rotation: Math.PI / 2 }
      ];
      
      // Add 2 shelves per room
      for (let i = 0; i < Math.min(2, wallPositions.length); i++) {
        const pos = wallPositions[i];
        config.furniture.push({
          type: 'shelf',
          x: pos.x,
          z: pos.z,
          rotation: pos.rotation,
          shelves: 3
        });
        
        // Add 1-2 objects on shelf
        const objectCount = 1 + Math.floor(Math.random() * 2);
        for (let j = 0; j < objectCount; j++) {
          const objectTypes = ['plant', 'clock'];
          config.furniture.push({
            type: objectTypes[Math.floor(Math.random() * objectTypes.length)],
            x: pos.x + (Math.random() - 0.5) * 0.5,
            y: 0.45 + j * 0.45, // Stack on shelves
            z: pos.z,
            rotation: pos.rotation
          });
        }
      }
      
      // Rule 5: Cleaning supplies in bathroom
      const bathroomBounds = { minX: bounds.minX, maxX: bounds.minX + 2, minZ: bounds.minZ, maxZ: bounds.minZ + 2 };
      PLACEMENT_RULES.cleaningSupplies.forEach((item, idx) => {
        config.furniture.push({
          type: item,
          x: bathroomBounds.minX + 0.5 + (idx % 2) * 0.5,
          z: bathroomBounds.minZ + 0.5 + Math.floor(idx / 2) * 0.5,
          rotation: 0
        });
      });
      
      // Rule 6: Ceiling lights in each room
      config.furniture.push({
        type: 'ceilinglight',
        x: (bounds.minX + bounds.maxX) / 2,
        z: (bounds.minZ + bounds.maxZ) / 2,
        style: ['modern', 'classic'][Math.floor(Math.random() * 2)]
      });
      
      // Rule 7: Rugs in living areas
      config.furniture.push({
        type: 'rug',
        x: (bounds.minX + bounds.maxX) / 2,
        z: (bounds.minZ + bounds.maxZ) / 2 + 1,
        color: [0x8b4513, 0xcc3333, 0x4444aa][Math.floor(Math.random() * 3)],
        width: 1.5,
        depth: 2.0
      });
      
      return config;
    }
    
    // ==================== ROOM GENERATION ====================
    
    function loadRoom(roomId) {
      // Clear existing room
      clearRoom();
      
      let config = ROOM_CONFIGS[roomId];
      if (!config) {
        console.error('Room config not found:', roomId);
        return;
      }
      
      // Apply rules engine
      config = applyRulesEngine(JSON.parse(JSON.stringify(config)));
      
      currentRoom = roomId;
      document.getElementById('room-info').textContent = `Current: ${config.name}`;
      
      // Generate single floor
      generateFloor(config.floorBounds);
      
      // Generate ceiling
      generateCeiling(config.floorBounds);
      
      // Place walls along grid lines
      generateWallsFromConfig(config.walls);
      
      // Place windows
      if (config.windows) {
        generateWindows(config.windows);
      }
      
      // Generate furniture
      generateFurniture(config);
      
      // Position camera in center of floor
      const centerX = (config.floorBounds.minX + config.floorBounds.maxX) / 2 * GRID_SIZE;
      const centerZ = (config.floorBounds.minZ + config.floorBounds.maxZ) / 2 * GRID_SIZE;
      camera.position.set(centerX, 1.6, centerZ);
    }
    
    function randomizeRoom() {
      const roomTypes = ['studio', '1br', '2br'];
      const randomRoom = roomTypes[Math.floor(Math.random() * roomTypes.length)];
      
      // Clear and load random room
      clearRoom();
      
      let config = JSON.parse(JSON.stringify(ROOM_CONFIGS[randomRoom]));
      
      // Randomize furniture positions slightly
      config.furniture = config.furniture.map(item => ({
        ...item,
        x: item.x + (Math.random() - 0.5) * 0.3,
        z: item.z + (Math.random() - 0.5) * 0.3,
        rotation: (item.rotation || 0) + (Math.random() - 0.5) * 0.2
      }));
      
      // Apply rules
      config = applyRulesEngine(config);
      
      // Randomize floor style
      const floorStyles = ['hardwood', 'tile', 'carpet'];
      const randomFloor = floorStyles[Math.floor(Math.random() * floorStyles.length)];
      
      currentRoom = randomRoom;
      document.getElementById('room-info').textContent = `Current: ${config.name} (Randomized)`;
      
      // Generate
      generateFloor(config.floorBounds, randomFloor);
      generateCeiling(config.floorBounds);
      generateWallsFromConfig(config.walls);
      if (config.windows) generateWindows(config.windows);
      generateFurniture(config);
      
      const centerX = (config.floorBounds.minX + config.floorBounds.maxX) / 2 * GRID_SIZE;
      const centerZ = (config.floorBounds.minZ + config.floorBounds.maxZ) / 2 * GRID_SIZE;
      camera.position.set(centerX, 1.6, centerZ);
    }
    
    function clearRoom() {
      roomObjects.forEach(obj => {
        scene.remove(obj);
        if (obj.geometry) obj.geometry.dispose();
        if (obj.material) {
          if (Array.isArray(obj.material)) {
            obj.material.forEach(m => m.dispose());
          } else {
            obj.material.dispose();
          }
        }
      });
      roomObjects = [];
      interactiveObjects.length = 0; // Clear interactive objects
    }
    
    function generateFloor(bounds, style) {
      const width = (bounds.maxX - bounds.minX) * GRID_SIZE;
      const depth = (bounds.maxZ - bounds.minZ) * GRID_SIZE;
      const centerX = (bounds.minX + bounds.maxX) / 2 * GRID_SIZE;
      const centerZ = (bounds.minZ + bounds.maxZ) / 2 * GRID_SIZE;
      
      // Base floor (solid color fallback)
      const floorGeo = new THREE.PlaneGeometry(width, depth);
        const floorMat = new THREE.MeshStandardMaterial({
        color: 0xd4a574,
          roughness: 0.8,
          metalness: 0.2
        });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
      floor.position.set(centerX, 0, centerZ);
        floor.receiveShadow = true;
        scene.add(floor);
        roomObjects.push(floor);
        
      // Add styled floor using advanced floor patterns
      createFloorStyling(bounds, style);

      // Grid helper REMOVED for clean professional look
      // No grid visualization needed
    }
    
    function generateCeiling(bounds) {
      const width = (bounds.maxX - bounds.minX) * GRID_SIZE;
      const depth = (bounds.maxZ - bounds.minZ) * GRID_SIZE;
      const centerX = (bounds.minX + bounds.maxX) / 2 * GRID_SIZE;
      const centerZ = (bounds.minZ + bounds.maxZ) / 2 * GRID_SIZE;
      
      const ceilingGeo = new THREE.PlaneGeometry(width, depth);
        const ceilingMat = new THREE.MeshStandardMaterial({
          color: 0xf5f5f5,
          roughness: 0.9
        });
      const ceiling = new THREE.Mesh(ceilingGeo, ceilingMat);
        ceiling.rotation.x = Math.PI / 2;
      ceiling.position.set(centerX, WALL_HEIGHT, centerZ);
        ceiling.receiveShadow = true;
        scene.add(ceiling);
        roomObjects.push(ceiling);
    }
    
    function generateWallsFromConfig(walls) {
      const wallMat = new THREE.MeshStandardMaterial({
        color: 0xf0e6d2,
        roughness: 0.9
      });
      
      walls.forEach(wallSpec => {
        createWallSegment(wallSpec, wallMat);
      });
    }
    
    function createWallSegment(spec, material) {
      const wallLength = spec.length * GRID_SIZE;
      
      // If has door, create wall with opening
      if (spec.hasDoor) {
        createWallWithDoor(spec, material);
        return;
      }
      
      let wallGeo, posX, posZ;
      
      if (spec.dir === 'h') {
        // Horizontal wall (runs along X axis)
        wallGeo = new THREE.BoxGeometry(wallLength, WALL_HEIGHT, WALL_THICKNESS);
        posX = spec.x * GRID_SIZE + wallLength / 2;
        posZ = spec.z * GRID_SIZE;
      } else {
        // Vertical wall (runs along Z axis)
        wallGeo = new THREE.BoxGeometry(WALL_THICKNESS, WALL_HEIGHT, wallLength);
        posX = spec.x * GRID_SIZE;
        posZ = spec.z * GRID_SIZE + wallLength / 2;
      }
      
      const wall = new THREE.Mesh(wallGeo, material);
      wall.position.set(posX, WALL_HEIGHT / 2, posZ);
      wall.castShadow = true;
      wall.receiveShadow = true;
      scene.add(wall);
      roomObjects.push(wall);
    }
    
    function createWallWithDoor(spec, material) {
      const doorWidth = 1.0;
      const doorHeight = 2.0;
      const wallLength = spec.length * GRID_SIZE;
      
      // Create two wall segments on either side of door
      const segment1Length = (wallLength - doorWidth) / 2;
      const segment2Length = segment1Length;
      
      if (spec.dir === 'h') {
        // Left segment
        if (segment1Length > 0.1) {
          const leftGeo = new THREE.BoxGeometry(segment1Length, WALL_HEIGHT, WALL_THICKNESS);
          const leftWall = new THREE.Mesh(leftGeo, material);
          leftWall.position.set(
            spec.x * GRID_SIZE + segment1Length / 2,
            WALL_HEIGHT / 2,
            spec.z * GRID_SIZE
          );
          leftWall.castShadow = true;
          leftWall.receiveShadow = true;
      scene.add(leftWall);
      roomObjects.push(leftWall);
        }
        
        // Right segment
        if (segment2Length > 0.1) {
          const rightGeo = new THREE.BoxGeometry(segment2Length, WALL_HEIGHT, WALL_THICKNESS);
          const rightWall = new THREE.Mesh(rightGeo, material);
          rightWall.position.set(
            spec.x * GRID_SIZE + wallLength - segment2Length / 2,
            WALL_HEIGHT / 2,
            spec.z * GRID_SIZE
          );
          rightWall.castShadow = true;
          rightWall.receiveShadow = true;
      scene.add(rightWall);
      roomObjects.push(rightWall);
    }
    
        // Top section above door
        const topHeight = WALL_HEIGHT - doorHeight;
        if (topHeight > 0.1) {
          const topGeo = new THREE.BoxGeometry(doorWidth, topHeight, WALL_THICKNESS);
          const topWall = new THREE.Mesh(topGeo, material);
          topWall.position.set(
            spec.x * GRID_SIZE + wallLength / 2,
            doorHeight + topHeight / 2,
            spec.z * GRID_SIZE
          );
          topWall.castShadow = true;
          topWall.receiveShadow = true;
          scene.add(topWall);
          roomObjects.push(topWall);
        }
      } else {
        // Vertical wall
        if (segment1Length > 0.1) {
          const frontGeo = new THREE.BoxGeometry(WALL_THICKNESS, WALL_HEIGHT, segment1Length);
          const frontWall = new THREE.Mesh(frontGeo, material);
          frontWall.position.set(
            spec.x * GRID_SIZE,
            WALL_HEIGHT / 2,
            spec.z * GRID_SIZE + segment1Length / 2
          );
          frontWall.castShadow = true;
          frontWall.receiveShadow = true;
          scene.add(frontWall);
          roomObjects.push(frontWall);
        }
        
        if (segment2Length > 0.1) {
          const backGeo = new THREE.BoxGeometry(WALL_THICKNESS, WALL_HEIGHT, segment2Length);
          const backWall = new THREE.Mesh(backGeo, material);
          backWall.position.set(
            spec.x * GRID_SIZE,
            WALL_HEIGHT / 2,
            spec.z * GRID_SIZE + wallLength - segment2Length / 2
          );
          backWall.castShadow = true;
          backWall.receiveShadow = true;
          scene.add(backWall);
          roomObjects.push(backWall);
        }
        
        const topHeight = WALL_HEIGHT - doorHeight;
        if (topHeight > 0.1) {
          const topGeo = new THREE.BoxGeometry(WALL_THICKNESS, topHeight, doorWidth);
          const topWall = new THREE.Mesh(topGeo, material);
          topWall.position.set(
            spec.x * GRID_SIZE,
            doorHeight + topHeight / 2,
            spec.z * GRID_SIZE + wallLength / 2
          );
          topWall.castShadow = true;
          topWall.receiveShadow = true;
      scene.add(topWall);
      roomObjects.push(topWall);
        }
      }
    }
    
    function generateWindows(windows) {
      windows.forEach(windowSpec => {
        createWindowSegment(windowSpec);
      });
    }
    
    function createWindowSegment(spec) {
      const windowHeight = 1.2;
      const windowSillHeight = 0.9;
      const windowLength = spec.length * GRID_SIZE;
      
      const wallMat = new THREE.MeshStandardMaterial({
        color: 0xf0e6d2,
        roughness: 0.9
      });
      
      if (spec.dir === 'h') {
        // Bottom sill
        const sillGeo = new THREE.BoxGeometry(windowLength, windowSillHeight, WALL_THICKNESS);
        const sill = new THREE.Mesh(sillGeo, wallMat);
        sill.position.set(
          spec.x * GRID_SIZE + windowLength / 2,
          windowSillHeight / 2,
          spec.z * GRID_SIZE
        );
        sill.castShadow = true;
        sill.receiveShadow = true;
        scene.add(sill);
        roomObjects.push(sill);
        
        // Top section
        const topHeight = WALL_HEIGHT - windowSillHeight - windowHeight;
        const topGeo = new THREE.BoxGeometry(windowLength, topHeight, WALL_THICKNESS);
        const top = new THREE.Mesh(topGeo, wallMat);
        top.position.set(
          spec.x * GRID_SIZE + windowLength / 2,
          windowSillHeight + windowHeight + topHeight / 2,
          spec.z * GRID_SIZE
        );
        top.castShadow = true;
        top.receiveShadow = true;
        scene.add(top);
        roomObjects.push(top);
        
        // Glass
        const glassGeo = new THREE.PlaneGeometry(windowLength, windowHeight);
        const glassMat = new THREE.MeshStandardMaterial({
        color: 0x87ceeb,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide
      });
        const glass = new THREE.Mesh(glassGeo, glassMat);
        glass.position.set(
          spec.x * GRID_SIZE + windowLength / 2,
          windowSillHeight + windowHeight / 2,
          spec.z * GRID_SIZE
        );
        scene.add(glass);
        roomObjects.push(glass);
      } else {
        // Vertical window
        const sillGeo = new THREE.BoxGeometry(WALL_THICKNESS, windowSillHeight, windowLength);
        const sill = new THREE.Mesh(sillGeo, wallMat);
        sill.position.set(
          spec.x * GRID_SIZE,
          windowSillHeight / 2,
          spec.z * GRID_SIZE + windowLength / 2
        );
        sill.castShadow = true;
        sill.receiveShadow = true;
        scene.add(sill);
        roomObjects.push(sill);
        
        const topHeight = WALL_HEIGHT - windowSillHeight - windowHeight;
        const topGeo = new THREE.BoxGeometry(WALL_THICKNESS, topHeight, windowLength);
        const top = new THREE.Mesh(topGeo, wallMat);
        top.position.set(
          spec.x * GRID_SIZE,
          windowSillHeight + windowHeight / 2,
          spec.z * GRID_SIZE + windowLength / 2
        );
        top.castShadow = true;
        top.receiveShadow = true;
        scene.add(top);
        roomObjects.push(top);
        
        const glassGeo = new THREE.PlaneGeometry(windowLength, windowHeight);
        const glassMat = new THREE.MeshStandardMaterial({
          color: 0x87ceeb,
          transparent: true,
          opacity: 0.3,
          side: THREE.DoubleSide
        });
        const glass = new THREE.Mesh(glassGeo, glassMat);
        glass.rotation.y = Math.PI / 2;
        glass.position.set(
          spec.x * GRID_SIZE,
          windowSillHeight + windowHeight / 2,
          spec.z * GRID_SIZE + windowLength / 2
        );
        scene.add(glass);
        roomObjects.push(glass);
      }
    }
    
    // ==================== FURNITURE GENERATION ====================
    
    function generateFurniture(config) {
      config.furniture.forEach(item => {
        const handlers = {
          desk: createDesk,
          bed: createBed,
          toilet: createToilet,
          shower: createShower,
          bathroomsink: createBathroomSink,
          bathroomfloor: createBathroomFloor,
          counter: createKitchenCounter,
          plate: createPlate,
          plant: createPottedPlant,
          apple: createApple,
          pear: createPear,
          banana: createBanana,
          grapes: createGrapes,
          bowl: createBowl,
          fruitbowl: createFruitBowl,
          microwave: createMicrowave,
          sodacan: createSodaCan,
          cerealbox: createCerealBox,
          crackerbox: createCrackerBox,
          computertower: createComputerTower,
          artframe: createArtFrame,
          clock: createWallClock,
          closet: createCloset,
          entrancedoor: createEntranceDoor,
          couch: createCouch,
          tv: createTV,
          tvstand: createTVStand,
          gameconsole: createGameConsole,
          dvd: createDVD,
          dvdcase: createDVDCase,
          remote: createRemote,
          coffeetable: createCoffeeTable,
          playingcard: createPlayingCard,
          dice: createDice,
          pokerchip: createPokerChip,
          gameboard: createGameBoard,
          computerdesk: createComputerDesk,
          chesspawn: createChessPawn,
          sidetable: createSideTable,
          floorlamp: createFloorLamp,
          alarmclock: createAlarmClock,
          broom: createBroom,
          dustpan: createDustpan,
          vacuum: createVacuum,
          handheldvacuum: createHandheldVacuum,
          bucket: createBucket,
          sponge: createSponge,
          rag: createRag,
          papertowelroll: createPaperTowelRoll,
          toiletpaperroll: createToiletPaperRoll,
          jengatower: createJengaTower,
          desklamp: createDeskLamp,
          pixarball: createPixarBall,
          basketball: createBasketball,
          baseball: createBaseball,
          rug: createRug,
          shelf: createShelf,
          ceilinglight: createCeilingLight,
          fork: createFork,
          knife: createKnife,
          spoon: createSpoon,
          refrigerator: createRefrigerator,
          milkcarton: createMilkCarton,
          orangejuice: createOrangeJuice,
          cheese: createCheese,
          eggs: createEggs,
          wallcabinets: createWallCabinets
        };
        
        const handler = handlers[item.type];
        if (handler) {
          handler(item);
        }
      });
    }
    
    function createDesk(spec) {
      const shape = spec.shape || 'rectangle';
      const deskSpec = ASSETS.desk[shape];
      
      const group = new THREE.Group();
      
      // Desktop
      let desktopGeo;
      if (shape === 'circle') {
        desktopGeo = new THREE.CylinderGeometry(
          deskSpec.radius,
          deskSpec.radius,
          0.05,
          32
        );
      } else {
        desktopGeo = new THREE.BoxGeometry(
          deskSpec.width,
          0.05,
          deskSpec.depth
        );
      }
      
      const desktopMat = new THREE.MeshStandardMaterial({
        color: 0x8b4513,
        roughness: 0.7,
        metalness: 0.1
      });
      const desktop = new THREE.Mesh(desktopGeo, desktopMat);
      desktop.position.y = deskSpec.height;
      desktop.castShadow = true;
      desktop.receiveShadow = true;
      group.add(desktop);
      
      // Legs (4 legs positioned at corners)
      const legGeo = new THREE.CylinderGeometry(
        deskSpec.legRadius,
        deskSpec.legRadius,
        deskSpec.legHeight,
        16
      );
      const legMat = new THREE.MeshStandardMaterial({
        color: 0x654321,
        roughness: 0.8
      });
      
      let legPositions;
      if (shape === 'circle') {
        const r = deskSpec.radius * 0.7;
        legPositions = [
          [r, 0, r],
          [-r, 0, r],
          [r, 0, -r],
          [-r, 0, -r]
        ];
      } else {
        const w = deskSpec.width / 2 - deskSpec.legRadius * 2;
        const d = deskSpec.depth / 2 - deskSpec.legRadius * 2;
        legPositions = [
          [w, 0, d],
          [-w, 0, d],
          [w, 0, -d],
          [-w, 0, -d]
        ];
      }
      
      legPositions.forEach(([x, y, z]) => {
        const leg = new THREE.Mesh(legGeo, legMat);
        leg.position.set(x, deskSpec.legHeight / 2, z);
        leg.castShadow = true;
        group.add(leg);
      });
      
      // Position and rotate group
      group.position.set(spec.x * GRID_SIZE, 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createBed(spec) {
      const bedSpec = ASSETS.bed;
      const group = new THREE.Group();
      
      // Mattress with rounded corners
      const mattressGeo = new THREE.BoxGeometry(
        bedSpec.width,
        bedSpec.height,
        bedSpec.depth,
        6, 2, 6
      );
      
      // Round the corners by moving vertices
      const positions = mattressGeo.attributes.position;
      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const y = positions.getY(i);
        const z = positions.getZ(i);
        
        // Edge softening for corners
        const edgeThreshold = 0.8;
        const xEdge = Math.abs(x) / (bedSpec.width / 2);
        const zEdge = Math.abs(z) / (bedSpec.depth / 2);
        const yEdge = Math.abs(y) / (bedSpec.height / 2);
        
        if (xEdge > edgeThreshold && zEdge > edgeThreshold && yEdge > 0.9) {
          const softness = 0.92;
          positions.setX(i, x * softness);
          positions.setZ(i, z * softness);
        }
      }
      mattressGeo.computeVertexNormals();
      
      const mattressMat = new THREE.MeshStandardMaterial({
        color: 0x4a5a6a,
        roughness: 0.9
      });
      const mattress = new THREE.Mesh(mattressGeo, mattressMat);
      mattress.position.y = bedSpec.legHeight + bedSpec.height / 2;
      mattress.castShadow = true;
      mattress.receiveShadow = true;
      group.add(mattress);
      
      // Pillows
      const pillowWidth = 0.5;
      const pillowHeight = 0.12;
      const pillowDepth = 0.35;
      const pillowGeo = new THREE.BoxGeometry(pillowWidth, pillowHeight, pillowDepth, 4, 2, 4);
      
      // Round pillow corners
      const pillowPos = pillowGeo.attributes.position;
      for (let i = 0; i < pillowPos.count; i++) {
        const x = pillowPos.getX(i);
        const y = pillowPos.getY(i);
        const z = pillowPos.getZ(i);
        
        const xEdge = Math.abs(x) / (pillowWidth / 2);
        const zEdge = Math.abs(z) / (pillowDepth / 2);
        const yEdge = Math.abs(y) / (pillowHeight / 2);
        
        if (yEdge > 0.8) {
          const puff = 1.05;
          pillowPos.setY(i, y * puff);
        }
        if (xEdge > 0.7 && zEdge > 0.7) {
          pillowPos.setX(i, x * 0.95);
          pillowPos.setZ(i, z * 0.95);
        }
      }
      pillowGeo.computeVertexNormals();
      
      const pillowMat = new THREE.MeshStandardMaterial({
        color: 0xf0f0f0,
        roughness: 0.8
      });
      
      // Two pillows side by side
      for (let i = 0; i < 2; i++) {
        const pillow = new THREE.Mesh(pillowGeo, pillowMat);
        pillow.position.set(
          (i - 0.5) * (pillowWidth + 0.1),
          bedSpec.legHeight + bedSpec.height + pillowHeight / 2 - 0.02,
          -bedSpec.depth / 2 + pillowDepth / 2 + 0.1
        );
        pillow.castShadow = true;
        pillow.receiveShadow = true;
        group.add(pillow);
      }
      
      // Bed frame (simple box)
      const frameGeo = new THREE.BoxGeometry(
        bedSpec.width + 0.1,
        bedSpec.legHeight,
        bedSpec.depth + 0.1
      );
      const frameMat = new THREE.MeshStandardMaterial({
        color: 0x654321,
        roughness: 0.8
      });
      const frame = new THREE.Mesh(frameGeo, frameMat);
      frame.position.y = bedSpec.legHeight / 2;
      frame.castShadow = true;
      group.add(frame);
      
      // Headboard (tall back panel)
      const headboardHeight = 1.0;
      const headboardGeo = new THREE.BoxGeometry(bedSpec.width + 0.15, headboardHeight, 0.1);
      const headboard = new THREE.Mesh(headboardGeo, frameMat);
      headboard.position.set(0, headboardHeight / 2, -bedSpec.depth / 2 - 0.05);
      headboard.castShadow = true;
      headboard.receiveShadow = true;
      group.add(headboard);
      
      // Position and rotate
      group.position.set(spec.x * GRID_SIZE, 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createToilet(spec) {
      const t = ASSETS.toilet;
      const group = new THREE.Group();
      
      const porcelainMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.2,
        metalness: 0.1
      });
      
      // === BOWL (stretched back hemisphere) ===
      const bowlGeo = new THREE.SphereGeometry(t.bowlRadius, 32, 16, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2);
      const bowl = new THREE.Mesh(bowlGeo, porcelainMat);
      bowl.scale.set(1, 1, 1.3); // Stretch back
      bowl.position.set(0, t.bowlHeight, 0);
      bowl.castShadow = true;
      bowl.receiveShadow = true;
      group.add(bowl);
      
      // === INNER BOWL (smaller nested hemisphere) ===
      const innerBowlGeo = new THREE.SphereGeometry(t.bowlRadius * 0.75, 32, 16, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2);
      const innerBowl = new THREE.Mesh(innerBowlGeo, porcelainMat);
      innerBowl.scale.set(1, 0.8, 1.3);
      innerBowl.position.set(0, t.bowlHeight + 0.02, 0);
      group.add(innerBowl);
      
      // === RIM (torus scaled to oval) ===
      const rimGeo = new THREE.TorusGeometry(t.bowlRadius * 0.9, 0.02, 16, 32);
      const rim = new THREE.Mesh(rimGeo, porcelainMat);
      rim.rotation.x = Math.PI / 2;
      rim.scale.set(1, 1.3, 1); // Oval shape
      rim.position.set(0, t.bowlHeight, 0);
      rim.castShadow = true;
      group.add(rim);
      
      // === SEAT (torus, thicker, oval) ===
      const seatGeo = new THREE.TorusGeometry(t.seatRadius, 0.03, 16, 32);
      const seatMat = new THREE.MeshStandardMaterial({
        color: 0xf5f5dc,
        roughness: 0.6
      });
      const seat = new THREE.Mesh(seatGeo, seatMat);
      seat.rotation.x = Math.PI / 2;
      seat.scale.set(1, 1.3, 1);
      seat.position.set(0, t.bowlHeight + 0.02, 0);
      seat.castShadow = true;
      group.add(seat);
      
      // === LID (interactive, hinged at back edge) ===
      const lidGroup = new THREE.Group();
      
      // Hinge point will be at back edge of seat
      const lidGeo = new THREE.TorusGeometry(t.seatRadius, 0.025, 16, 32);
      const lid = new THREE.Mesh(lidGeo, seatMat);
      lid.rotation.x = Math.PI / 2;
      lid.scale.set(1, 1.3, 1);
      lid.position.z = t.seatRadius * 1.3; // Move forward so back edge is at hinge (origin)
      lid.castShadow = true;
      lidGroup.add(lid);
      
      // Lid cover disc
      const lidCoverGeo = new THREE.CircleGeometry(t.seatRadius, 32);
      const lidCover = new THREE.Mesh(lidCoverGeo, seatMat);
      lidCover.rotation.x = -Math.PI / 2;
      lidCover.scale.set(1, 1.3, 1);
      lidCover.position.z = t.seatRadius * 1.3; // Move forward to match lid
      lidCover.castShadow = true;
      lidGroup.add(lidCover);
      
      // Position group at back edge of seat (hinge point)
      lidGroup.position.set(0, t.bowlHeight + 0.02, -t.seatRadius * 1.3);
      lidGroup.userData.isLid = true;
      lidGroup.userData.isOpen = false;
      lidGroup.userData.hingeAxis = new THREE.Vector3(1, 0, 0);
      group.add(lidGroup);
      
      // Register as interactive
      interactiveObjects.push(lidGroup);
      
      // === TANK (back) ===
      const tankGeo = new THREE.BoxGeometry(t.tankWidth, t.tankHeight, t.tankDepth);
      const tank = new THREE.Mesh(tankGeo, porcelainMat);
      tank.position.set(0, t.bowlHeight + t.tankHeight / 2, -t.bowlRadius * 1.3);
      tank.castShadow = true;
      tank.receiveShadow = true;
      group.add(tank);
      
      // === FLUSH LEVER (cylinder + platform) ===
      const leverGroup = new THREE.Group();
      const leverHandleGeo = new THREE.CylinderGeometry(0.008, 0.008, 0.1, 8);
      const leverMat = new THREE.MeshStandardMaterial({
        color: 0xc0c0c0,
        roughness: 0.4,
        metalness: 0.8
      });
      const leverHandle = new THREE.Mesh(leverHandleGeo, leverMat);
      leverHandle.rotation.z = Math.PI / 2;
      leverGroup.add(leverHandle);
      
      const leverPlatformGeo = new THREE.BoxGeometry(0.06, 0.03, 0.02);
      const leverPlatform = new THREE.Mesh(leverPlatformGeo, leverMat);
      leverPlatform.position.set(0.05, 0, 0);
      leverGroup.add(leverPlatform);
      
      leverGroup.position.set(-t.tankWidth / 2 + 0.05, t.bowlHeight + t.tankHeight * 0.7, -t.bowlRadius * 1.3 + t.tankDepth / 2);
      leverGroup.castShadow = true;
      group.add(leverGroup);
      
      // Position entire toilet
      group.position.set(spec.x * GRID_SIZE, 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createShower(spec) {
      const showerSpec = ASSETS.shower;
      const showerGroup = new THREE.Group();
      
      // Micro tiled floor (grid of small tiles)
      const tileSize = 0.05;
      const tilesX = Math.floor(showerSpec.width / tileSize);
      const tilesZ = Math.floor(showerSpec.depth / tileSize);
      
      for (let x = 0; x < tilesX; x++) {
        for (let z = 0; z < tilesZ; z++) {
          const tileGeo = new THREE.BoxGeometry(tileSize - 0.002, 0.01, tileSize - 0.002);
          const tileMat = new THREE.MeshStandardMaterial({
            color: 0xffffff, // All white tiles for shower
            roughness: 0.4
          });
          const tile = new THREE.Mesh(tileGeo, tileMat);
          tile.position.set(
            -showerSpec.width / 2 + x * tileSize + tileSize / 2,
            0.005,
            -showerSpec.depth / 2 + z * tileSize + tileSize / 2
          );
          tile.receiveShadow = true;
          showerGroup.add(tile);
        }
      }
      
      // Raised base border
      const baseGeo = new THREE.BoxGeometry(showerSpec.width, 0.08, showerSpec.depth);
      const baseMat = new THREE.MeshStandardMaterial({ 
        color: 0xaaaaaa,
        roughness: 0.7
      });
      const base = new THREE.Mesh(baseGeo, baseMat);
      base.position.y = 0.04;
      base.castShadow = true;
      base.receiveShadow = true;
      showerGroup.add(base);
      
      // Shower walls (3 sides, open front)
      const wallMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.4,
        side: THREE.DoubleSide
      });
      
      const backWallGeo = new THREE.PlaneGeometry(showerSpec.width, showerSpec.height);
      const backWall = new THREE.Mesh(backWallGeo, wallMat);
      backWall.position.set(0, showerSpec.height / 2, -showerSpec.depth / 2);
      showerGroup.add(backWall);
      
      const leftWallGeo = new THREE.PlaneGeometry(showerSpec.depth, showerSpec.height);
      const leftWall = new THREE.Mesh(leftWallGeo, wallMat);
      leftWall.rotation.y = Math.PI / 2;
      leftWall.position.set(-showerSpec.width / 2, showerSpec.height / 2, 0);
      showerGroup.add(leftWall);
      
      const rightWall = new THREE.Mesh(leftWallGeo, wallMat);
      rightWall.rotation.y = -Math.PI / 2;
      rightWall.position.set(showerSpec.width / 2, showerSpec.height / 2, 0);
      showerGroup.add(rightWall);
      
      // Position and rotate
      showerGroup.position.set(spec.x * GRID_SIZE, 0, spec.z * GRID_SIZE);
      showerGroup.rotation.y = spec.rotation || 0;
      
      scene.add(showerGroup);
      roomObjects.push(showerGroup);
    }
    
    function createBathroomSink(spec) {
      const group = new THREE.Group();
      
      // Pedestal base
      const pedestalGeo = new THREE.CylinderGeometry(0.15, 0.18, 0.7, 24);
      const porcelainMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.2,
        metalness: 0.1
      });
      const pedestal = new THREE.Mesh(pedestalGeo, porcelainMat);
      pedestal.position.y = 0.35;
      pedestal.castShadow = true;
      pedestal.receiveShadow = true;
      group.add(pedestal);
      
      // Basin (round)
      const basinRadius = 0.22;
      const basinDepth = 0.15;
      
      const basinGeo = new THREE.CylinderGeometry(basinRadius, basinRadius * 0.7, basinDepth, 32);
      const basin = new THREE.Mesh(basinGeo, porcelainMat);
      basin.position.y = 0.7 + basinDepth / 2;
      basin.castShadow = true;
      basin.receiveShadow = true;
      group.add(basin);
      
      // Inner basin
      const innerBasinGeo = new THREE.CylinderGeometry(basinRadius - 0.03, basinRadius * 0.65, basinDepth - 0.02, 32);
      const innerBasin = new THREE.Mesh(innerBasinGeo, porcelainMat);
      innerBasin.position.y = 0.7 + basinDepth / 2 + 0.01;
      innerBasin.receiveShadow = true;
      group.add(innerBasin);
      
      // Faucet
      const faucetMat = new THREE.MeshStandardMaterial({
        color: 0xd0d0d0,
        roughness: 0.2,
        metalness: 0.95
      });
      
      const faucetBaseGeo = new THREE.CylinderGeometry(0.015, 0.02, 0.15, 16);
      const faucetBase = new THREE.Mesh(faucetBaseGeo, faucetMat);
      faucetBase.position.y = 0.85 + 0.075;
      faucetBase.position.z = -0.18;
      faucetBase.castShadow = true;
      group.add(faucetBase);
      
      // Spout
      const spoutGeo = new THREE.TorusGeometry(0.06, 0.01, 8, 16, Math.PI);
      const spout = new THREE.Mesh(spoutGeo, faucetMat);
      spout.rotation.z = Math.PI / 2;
      spout.position.set(0, 0.85 + 0.15, -0.12);
      spout.castShadow = true;
      group.add(spout);
      
      group.position.set(spec.x * GRID_SIZE, 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createBathroomFloor(spec) {
      const group = new THREE.Group();
      
      const width = spec.width || 3;
      const depth = spec.depth || 3;
      const tileSize = 0.15; // Larger tiles for bathroom
      
      const tilesX = Math.floor(width / tileSize);
      const tilesZ = Math.floor(depth / tileSize);
      
      for (let x = 0; x < tilesX; x++) {
        for (let z = 0; z < tilesZ; z++) {
          const isWhite = (x + z) % 2 === 0;
          const tileGeo = new THREE.BoxGeometry(tileSize - 0.003, 0.008, tileSize - 0.003);
          const tileMat = new THREE.MeshStandardMaterial({
            color: isWhite ? 0xffffff : 0x4a90e2, // White and blue
            roughness: 0.4
          });
          const tile = new THREE.Mesh(tileGeo, tileMat);
          tile.position.set(
            spec.x * GRID_SIZE - width / 2 + x * tileSize + tileSize / 2,
            0.004,
            spec.z * GRID_SIZE - depth / 2 + z * tileSize + tileSize / 2
          );
          tile.receiveShadow = true;
          scene.add(tile);
          roomObjects.push(tile);
        }
      }
    }
    
    function createKitchenCounter(spec) {
      const c = ASSETS.counter;
      const group = new THREE.Group();
      const isIsland = spec.isIsland || false;
      const hasWallCabinets = spec.hasWallCabinets !== false; // Default true if wall-backed
      
      const counterMat = new THREE.MeshStandardMaterial({
        color: 0x8b7355,
        roughness: 0.7
      });
      
      // === COUNTER BASE (cabinets) ===
      const baseGeo = new THREE.BoxGeometry(c.width, c.height - c.thickness, c.depth);
      const baseMat = new THREE.MeshStandardMaterial({
        color: 0x654321,
        roughness: 0.8
      });
      const base = new THREE.Mesh(baseGeo, baseMat);
      base.position.set(0, (c.height - c.thickness) / 2, 0);
      base.castShadow = true;
      base.receiveShadow = true;
      group.add(base);
      
      // === DRAWERS (3 drawers with handles) ===
      const drawerCount = 3;
      const drawerHeight = (c.height - c.thickness) / drawerCount;
      const handleMat = new THREE.MeshStandardMaterial({
        color: 0xc0c0c0,
        roughness: 0.4,
        metalness: 0.8
      });
      
      for (let i = 0; i < drawerCount; i++) {
        // Drawer face panel (slightly inset)
        const drawerFaceGeo = new THREE.BoxGeometry(c.width - 0.08, drawerHeight - 0.04, 0.02);
        const drawerFace = new THREE.Mesh(drawerFaceGeo, baseMat);
        drawerFace.position.set(
          0,
          i * drawerHeight + drawerHeight / 2,
          c.depth / 2 + 0.01
        );
        drawerFace.castShadow = true;
        group.add(drawerFace);
        
        // Drawer handle
        const handleGeo = new THREE.CylinderGeometry(0.008, 0.008, c.width * 0.15, 12);
        const handle = new THREE.Mesh(handleGeo, handleMat);
        handle.rotation.z = Math.PI / 2;
        handle.position.set(
          0,
          i * drawerHeight + drawerHeight / 2,
          c.depth / 2 + 0.025
        );
        handle.castShadow = true;
        group.add(handle);
      }
      
      // === COUNTER TOP ===
      const topGeo = new THREE.BoxGeometry(c.width, c.thickness, c.depth);
      const top = new THREE.Mesh(topGeo, counterMat);
      top.position.set(0, c.height - c.thickness / 2, 0);
      top.castShadow = true;
      top.receiveShadow = true;
      group.add(top);
      
      // === SINK BASIN (high-quality metal with rounded corners) ===
      const sinkMat = new THREE.MeshStandardMaterial({
        color: 0xe0e0e0,
        roughness: 0.15,
        metalness: 0.9
      });
      
      // Create rounded basin using cylinder (looks more realistic)
      const basinRadius = Math.min(c.sinkWidth, c.sinkDepth) / 2.5;
      const basinDepth = c.sinkHeight;
      
      // Outer basin rim (torus for rounded edge)
      const rimGeo = new THREE.TorusGeometry(basinRadius, 0.015, 16, 32);
      const rim = new THREE.Mesh(rimGeo, sinkMat);
      rim.rotation.x = Math.PI / 2;
      rim.position.set(0, c.height - c.thickness - 0.01, 0);
      rim.castShadow = true;
      group.add(rim);
      
      // Main basin bowl (cylinder for smooth sides)
      const basinGeo = new THREE.CylinderGeometry(basinRadius - 0.02, basinRadius * 0.7, basinDepth, 32);
      const basin = new THREE.Mesh(basinGeo, sinkMat);
      basin.position.set(0, c.height - c.thickness - basinDepth / 2, 0);
      basin.castShadow = true;
      basin.receiveShadow = true;
      group.add(basin);
      
      // Inner basin bowl (darker, smaller for depth)
      const innerBasinGeo = new THREE.CylinderGeometry(basinRadius - 0.04, basinRadius * 0.65, basinDepth - 0.02, 32);
      const innerBasinMat = new THREE.MeshStandardMaterial({
        color: 0xc0c0c0,
        roughness: 0.25,
        metalness: 0.85
      });
      const innerBasin = new THREE.Mesh(innerBasinGeo, innerBasinMat);
      innerBasin.position.set(0, c.height - c.thickness - basinDepth / 2 + 0.01, 0);
      innerBasin.receiveShadow = true;
      group.add(innerBasin);
      
      // Basin bottom (sphere for rounded bottom)
      const bottomGeo = new THREE.SphereGeometry(basinRadius * 0.65, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
      const bottom = new THREE.Mesh(bottomGeo, innerBasinMat);
      bottom.position.set(0, c.height - c.thickness - basinDepth, 0);
      bottom.receiveShadow = true;
      group.add(bottom);
      
      // Drain (high detail)
      const drainGeo = new THREE.CylinderGeometry(0.035, 0.03, 0.025, 24);
      const drainMat = new THREE.MeshStandardMaterial({
        color: 0x2a2a2a,
        roughness: 0.5,
        metalness: 0.6
      });
      const drain = new THREE.Mesh(drainGeo, drainMat);
      drain.position.set(0, c.height - c.thickness - basinDepth + 0.01, 0);
      drain.receiveShadow = true;
      group.add(drain);
      
      // Drain holes (ring of small cylinders with more detail)
      const holeGeo = new THREE.CylinderGeometry(0.004, 0.004, 0.025, 8);
      for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const hole = new THREE.Mesh(holeGeo, drainMat);
        hole.position.set(
          Math.cos(angle) * 0.022,
          c.height - c.thickness - basinDepth + 0.01,
          Math.sin(angle) * 0.022
        );
        group.add(hole);
      }
      
      // === FAUCET (high-detail, pointing down into basin) ===
      const faucetGroup = new THREE.Group();
      
      // Base cylinder (more detailed)
      const faucetBaseGeo = new THREE.CylinderGeometry(0.025, 0.03, 0.08, 24);
      const faucetMat = new THREE.MeshStandardMaterial({
        color: 0xd0d0d0,
        roughness: 0.2,
        metalness: 0.95
      });
      const faucetBase = new THREE.Mesh(faucetBaseGeo, faucetMat);
      faucetGroup.add(faucetBase);
      
      // Neck (curved with torus, higher arc)
      const neckGeo = new THREE.TorusGeometry(0.1, 0.015, 12, 24, Math.PI);
      const neck = new THREE.Mesh(neckGeo, faucetMat);
      neck.rotation.z = Math.PI / 2;
      neck.position.set(0, 0.08, 0);
      neck.castShadow = true;
      faucetGroup.add(neck);
      
      // Downward spout (angled down into basin)
      const spoutGeo = new THREE.CylinderGeometry(0.01, 0.012, 0.08, 16);
      const spout = new THREE.Mesh(spoutGeo, faucetMat);
      spout.rotation.x = Math.PI * 0.15; // Angle slightly forward
      spout.position.set(0, 0.12, 0.1);
      spout.castShadow = true;
      faucetGroup.add(spout);
      
      // Spout tip/aerator (small detail at end)
      const tipGeo = new THREE.CylinderGeometry(0.012, 0.008, 0.015, 16);
      const tip = new THREE.Mesh(tipGeo, faucetMat);
      tip.rotation.x = Math.PI * 0.15;
      tip.position.set(0, 0.08, 0.15);
      faucetGroup.add(tip);
      
      // Handle (lever style)
      const handleGeo = new THREE.BoxGeometry(0.06, 0.01, 0.02);
      const handle = new THREE.Mesh(handleGeo, faucetMat);
      handle.position.set(0.04, 0.1, -0.03);
      handle.rotation.z = -Math.PI * 0.1;
      handle.castShadow = true;
      faucetGroup.add(handle);
      
      faucetGroup.position.set(0, c.height, -basinRadius + 0.05);
      faucetGroup.castShadow = true;
      group.add(faucetGroup);
      
      // Position counter
      group.position.set(spec.x * GRID_SIZE, 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
      
      // === WALL CABINETS (if backed by wall and long edge is wall-adjacent) ===
      if (!isIsland && hasWallCabinets && spec.wallBacked) {
        createWallCabinets({
          x: spec.x,
          z: spec.z - (c.depth / 2 + 0.15) / GRID_SIZE, // Closer to wall
          width: c.width,
          rotation: spec.rotation
        });
      }
    }
    
    function createWallCabinets(spec) {
      const group = new THREE.Group();
      const lod = spec.lod || 'high';
      
      const width = spec.width || 1.2;
      const height = 0.7;
      const depth = 0.35;
      
      const cabinetMat = new THREE.MeshStandardMaterial({
        color: 0x654321,
        roughness: 0.8
      });
      
      // Cabinet box
      const boxGeo = new THREE.BoxGeometry(width, height, depth);
      const box = new THREE.Mesh(boxGeo, cabinetMat);
      box.position.y = 1.5 + height / 2; // Above counter height
      box.castShadow = true;
      box.receiveShadow = true;
      group.add(box);
      
      // Doors (2 doors)
      const doorWidth = width / 2 - 0.04;
      const doorGeo = new THREE.BoxGeometry(doorWidth, height - 0.04, 0.02);
      
      for (let i = 0; i < 2; i++) {
        const door = new THREE.Mesh(doorGeo, cabinetMat);
        door.position.set(
          (i - 0.5) * (doorWidth + 0.02),
          1.5 + height / 2,
          depth / 2 + 0.01
        );
        door.castShadow = true;
        group.add(door);
        
        // Door handle
        if (lod === 'high') {
          const handleMat = new THREE.MeshStandardMaterial({
            color: 0xc0c0c0,
            roughness: 0.4,
            metalness: 0.8
          });
          const handleGeo = new THREE.CylinderGeometry(0.006, 0.006, 0.08, 8);
          const handle = new THREE.Mesh(handleGeo, handleMat);
          handle.position.set(
            (i - 0.5) * (doorWidth + 0.02) + (i === 0 ? doorWidth * 0.35 : -doorWidth * 0.35),
            1.5 + height / 2,
            depth / 2 + 0.02
          );
          handle.castShadow = true;
          group.add(handle);
        }
      }
      
      group.position.set(spec.x * GRID_SIZE, 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createPlate(spec) {
      const group = new THREE.Group();
      
      const plateMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xffffff,
        roughness: 0.4,
        metalness: 0.1
      });
      
      // === MAIN DISC ===
      const plateGeo = new THREE.CylinderGeometry(0.12, 0.12, 0.015, 32);
      const plate = new THREE.Mesh(plateGeo, plateMat);
      plate.castShadow = true;
      plate.receiveShadow = true;
      group.add(plate);
      
      // === RIM (slightly raised) ===
      const rimGeo = new THREE.TorusGeometry(0.11, 0.01, 16, 32);
      const rim = new THREE.Mesh(rimGeo, plateMat);
      rim.rotation.x = Math.PI / 2;
      rim.position.y = 0.01;
      group.add(rim);
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0.008, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createPottedPlant(spec) {
      const group = new THREE.Group();
      
      // === POT (tapered cylinder) ===
      const potGeo = new THREE.CylinderGeometry(0.08, 0.06, 0.15, 16);
      const potMat = new THREE.MeshStandardMaterial({
        color: 0x8b4513,
        roughness: 0.9
      });
      const pot = new THREE.Mesh(potGeo, potMat);
      pot.position.y = 0.075;
      pot.castShadow = true;
      pot.receiveShadow = true;
      group.add(pot);
      
      // === SOIL ===
      const soilGeo = new THREE.CylinderGeometry(0.075, 0.075, 0.02, 16);
      const soilMat = new THREE.MeshStandardMaterial({
        color: 0x3d2817,
        roughness: 1.0
      });
      const soil = new THREE.Mesh(soilGeo, soilMat);
      soil.position.y = 0.15;
      soil.receiveShadow = true;
      group.add(soil);
      
      // === STEM ===
      const stemGeo = new THREE.CylinderGeometry(0.005, 0.008, 0.25, 8);
      const stemMat = new THREE.MeshStandardMaterial({
        color: 0x228b22,
        roughness: 0.8
      });
      const stem = new THREE.Mesh(stemGeo, stemMat);
      stem.position.y = 0.275;
      stem.castShadow = true;
      group.add(stem);
      
      // === LEAVES (simple planes) ===
      const leafMat = new THREE.MeshStandardMaterial({
        color: 0x32cd32,
        roughness: 0.7,
        side: THREE.DoubleSide
      });
      
      for (let i = 0; i < 5; i++) {
        const leafGeo = new THREE.CircleGeometry(0.06, 8);
        const leaf = new THREE.Mesh(leafGeo, leafMat);
        const angle = (i / 5) * Math.PI * 2;
        const height = 0.2 + i * 0.05;
        leaf.position.set(
          Math.cos(angle) * 0.04,
          height,
          Math.sin(angle) * 0.04
        );
        leaf.rotation.y = angle;
        leaf.rotation.x = Math.PI / 4;
        leaf.scale.set(1, 1.5, 1);
        leaf.castShadow = true;
        group.add(leaf);
      }
      
      group.position.set(spec.x * GRID_SIZE, 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    // ==================== FRUIT ASSETS ====================
    
    function createApple(spec) {
      const group = new THREE.Group();
      
      // Body (squashed sphere)
      const bodyGeo = new THREE.SphereGeometry(0.04, 16, 16);
      const bodyMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xff3333,
        roughness: 0.6
      });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.scale.set(1, 0.9, 1);
      body.position.y = 0.04;
      body.castShadow = true;
      group.add(body);
      
      // Stem (tiny cylinder)
      const stemGeo = new THREE.CylinderGeometry(0.002, 0.003, 0.015, 6);
      const stemMat = new THREE.MeshStandardMaterial({ color: 0x4a3520 });
      const stem = new THREE.Mesh(stemGeo, stemMat);
      stem.position.y = 0.08;
      group.add(stem);
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createPear(spec) {
      const group = new THREE.Group();
      
      // Bottom (sphere)
      const bottomGeo = new THREE.SphereGeometry(0.035, 16, 16);
      const bodyMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xb8d62e,
        roughness: 0.6
      });
      const bottom = new THREE.Mesh(bottomGeo, bodyMat);
      bottom.position.y = 0.035;
      bottom.castShadow = true;
      group.add(bottom);
      
      // Top (smaller sphere, stretched)
      const topGeo = new THREE.SphereGeometry(0.02, 16, 16);
      const top = new THREE.Mesh(topGeo, bodyMat);
      top.scale.set(1, 1.3, 1);
      top.position.y = 0.065;
      group.add(top);
      
      // Stem
      const stemGeo = new THREE.CylinderGeometry(0.002, 0.003, 0.02, 6);
      const stemMat = new THREE.MeshStandardMaterial({ color: 0x4a3520 });
      const stem = new THREE.Mesh(stemGeo, stemMat);
      stem.position.y = 0.095;
      group.add(stem);
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createBanana(spec) {
      const group = new THREE.Group();
      
      // Banana body (curved cylinder using torus segment)
      const curve = new THREE.TorusGeometry(0.08, 0.02, 8, 16, Math.PI * 0.8);
      const bananaMat = new THREE.MeshStandardMaterial({
        color: 0xffeb3b,
        roughness: 0.7
      });
      const body = new THREE.Mesh(curve, bananaMat);
      body.rotation.x = Math.PI / 2;
      body.rotation.z = -Math.PI / 4;
      body.position.y = 0.05;
      body.castShadow = true;
      group.add(body);
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createGrapes(spec) {
      const group = new THREE.Group();
      
      const grapeMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x6a0dad,
        roughness: 0.3
      });
      
      // Cluster of spheres
      const positions = [
        [0, 0.06, 0], [0.015, 0.055, 0.01], [-0.015, 0.055, -0.01],
        [0.01, 0.045, -0.015], [-0.01, 0.045, 0.015],
        [0, 0.035, 0], [0.02, 0.03, 0], [-0.02, 0.03, 0],
        [0.01, 0.02, 0.015], [-0.01, 0.02, -0.015],
        [0, 0.01, 0]
      ];
      
      positions.forEach(([x, y, z]) => {
        const grapeGeo = new THREE.SphereGeometry(0.01, 8, 8);
        const grape = new THREE.Mesh(grapeGeo, grapeMat);
        grape.position.set(x, y, z);
        grape.castShadow = true;
        group.add(grape);
      });
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createBowl(spec) {
      const group = new THREE.Group();
      
      // Bowl (hemisphere scaled)
      const bowlGeo = new THREE.SphereGeometry(0.12, 32, 16, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2);
      const bowlMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xf5f5dc,
        roughness: 0.5
      });
      const bowl = new THREE.Mesh(bowlGeo, bowlMat);
      bowl.position.y = 0.05;
      bowl.castShadow = true;
      bowl.receiveShadow = true;
      group.add(bowl);
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      scene.add(group);
      roomObjects.push(group);
      return group;
    }
    
    function createFruitBowl(spec) {
      const group = new THREE.Group();
      
      // Bowl base
      const bowlGeo = new THREE.SphereGeometry(0.15, 32, 16, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2);
      const bowlMat = new THREE.MeshStandardMaterial({
        color: 0xe8dcc0,
        roughness: 0.6
      });
      const bowl = new THREE.Mesh(bowlGeo, bowlMat);
      bowl.position.y = 0.05;
      bowl.castShadow = true;
      bowl.receiveShadow = true;
      group.add(bowl);
      
      // Add fruits inside (parented)
      const fruitPositions = [
        { type: 'apple', x: 0, y: 0.08, z: 0, color: 0xff3333 },
        { type: 'apple', x: 0.06, y: 0.09, z: 0.04, color: 0x66ff66 },
        { type: 'banana', x: -0.05, y: 0.1, z: 0.02 },
        { type: 'grapes', x: 0.03, y: 0.08, z: -0.05, color: 0x6a0dad },
        { type: 'pear', x: -0.04, y: 0.08, z: -0.03, color: 0xffeb3b }
      ];
      
      fruitPositions.forEach(fruit => {
        if (fruit.type === 'apple') {
          const bodyGeo = new THREE.SphereGeometry(0.035, 12, 12);
          const bodyMat = new THREE.MeshStandardMaterial({ color: fruit.color, roughness: 0.6 });
          const apple = new THREE.Mesh(bodyGeo, bodyMat);
          apple.scale.set(1, 0.9, 1);
          apple.position.set(fruit.x, fruit.y, fruit.z);
          apple.castShadow = true;
          group.add(apple);
        } else if (fruit.type === 'banana') {
          const curve = new THREE.TorusGeometry(0.06, 0.015, 6, 12, Math.PI * 0.7);
          const bananaMat = new THREE.MeshStandardMaterial({ color: 0xffeb3b, roughness: 0.7 });
          const banana = new THREE.Mesh(curve, bananaMat);
          banana.rotation.x = Math.PI / 2;
          banana.rotation.z = -Math.PI / 6;
          banana.position.set(fruit.x, fruit.y, fruit.z);
          banana.castShadow = true;
          group.add(banana);
        } else if (fruit.type === 'grapes') {
          for (let i = 0; i < 6; i++) {
            const grapeGeo = new THREE.SphereGeometry(0.008, 6, 6);
            const grapeMat = new THREE.MeshStandardMaterial({ color: fruit.color, roughness: 0.3 });
            const grape = new THREE.Mesh(grapeGeo, grapeMat);
            grape.position.set(
              fruit.x + (Math.random() - 0.5) * 0.025,
              fruit.y + i * 0.012,
              fruit.z + (Math.random() - 0.5) * 0.025
            );
            grape.castShadow = true;
            group.add(grape);
          }
        } else if (fruit.type === 'pear') {
          const pearGeo = new THREE.SphereGeometry(0.03, 12, 12);
          const pearMat = new THREE.MeshStandardMaterial({ color: fruit.color, roughness: 0.6 });
          const pear = new THREE.Mesh(pearGeo, pearMat);
          pear.scale.set(0.9, 1.2, 0.9);
          pear.position.set(fruit.x, fruit.y, fruit.z);
          pear.castShadow = true;
          group.add(pear);
        }
      });
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      scene.add(group);
      roomObjects.push(group);
    }
    
    // ==================== CUTLERY ====================
    
    function createFork(spec) {
      const group = new THREE.Group();
      const lod = spec.lod || 'high';
      
      const metalMat = new THREE.MeshStandardMaterial({
        color: 0xc0c0c0,
        roughness: 0.3,
        metalness: 0.9
      });
      
      // Handle
      const handleGeo = lod === 'high' 
        ? new THREE.CylinderGeometry(0.003, 0.004, 0.12, 12)
        : new THREE.CylinderGeometry(0.003, 0.004, 0.12, 6);
      const handle = new THREE.Mesh(handleGeo, metalMat);
      handle.position.y = 0.06;
      handle.castShadow = true;
      group.add(handle);
      
      // Prongs
      const prongCount = lod === 'high' ? 4 : 3;
      for (let i = 0; i < prongCount; i++) {
        const prongGeo = new THREE.CylinderGeometry(0.001, 0.0008, 0.025, 6);
        const prong = new THREE.Mesh(prongGeo, metalMat);
        prong.position.set(
          (i - (prongCount - 1) / 2) * 0.004,
          0.1325,
          0
        );
        prong.castShadow = true;
        group.add(prong);
      }
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createKnife(spec) {
      const group = new THREE.Group();
      const lod = spec.lod || 'high';
      
      const handleMat = new THREE.MeshStandardMaterial({
        color: 0x2a2a2a,
        roughness: 0.6
      });
      
      const bladeMat = new THREE.MeshStandardMaterial({
        color: 0xe0e0e0,
        roughness: 0.1,
        metalness: 0.95
      });
      
      // Handle
      const handleGeo = lod === 'high'
        ? new THREE.CylinderGeometry(0.004, 0.004, 0.08, 12)
        : new THREE.CylinderGeometry(0.004, 0.004, 0.08, 6);
      const handle = new THREE.Mesh(handleGeo, handleMat);
      handle.position.y = 0.04;
      handle.castShadow = true;
      group.add(handle);
      
      // Blade
      const bladeGeo = lod === 'high'
        ? new THREE.BoxGeometry(0.015, 0.06, 0.001)
        : new THREE.BoxGeometry(0.012, 0.06, 0.001);
      const blade = new THREE.Mesh(bladeGeo, bladeMat);
      blade.position.y = 0.11;
      blade.castShadow = true;
      group.add(blade);
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createSpoon(spec) {
      const group = new THREE.Group();
      const lod = spec.lod || 'high';
      
      const metalMat = new THREE.MeshStandardMaterial({
        color: 0xc0c0c0,
        roughness: 0.3,
        metalness: 0.9
      });
      
      // Handle
      const handleGeo = lod === 'high'
        ? new THREE.CylinderGeometry(0.003, 0.004, 0.12, 12)
        : new THREE.CylinderGeometry(0.003, 0.004, 0.12, 6);
      const handle = new THREE.Mesh(handleGeo, metalMat);
      handle.position.y = 0.06;
      handle.castShadow = true;
      group.add(handle);
      
      // Bowl
      const bowlGeo = lod === 'high'
        ? new THREE.SphereGeometry(0.012, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2)
        : new THREE.SphereGeometry(0.012, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2);
      const bowl = new THREE.Mesh(bowlGeo, metalMat);
      bowl.rotation.x = Math.PI;
      bowl.position.y = 0.135;
      bowl.castShadow = true;
      group.add(bowl);
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    // ==================== REFRIGERATOR ====================
    
    function createRefrigerator(spec) {
      const group = new THREE.Group();
      const lod = spec.lod || 'high';
      
      const width = 0.9;
      const height = 1.8;
      const depth = 0.7;
      
      const fridgeMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xf0f0f0,
        roughness: 0.3,
        metalness: 0.6
      });
      
      // Main body
      const bodyGeo = new THREE.BoxGeometry(width, height, depth);
      const body = new THREE.Mesh(bodyGeo, fridgeMat);
      body.position.y = height / 2;
      body.castShadow = true;
      body.receiveShadow = true;
      group.add(body);
      
      // Freezer door (top section)
      const freezerHeight = height * 0.35;
      const freezerGeo = new THREE.BoxGeometry(width - 0.02, freezerHeight - 0.02, 0.04);
      const freezerDoor = new THREE.Mesh(freezerGeo, fridgeMat);
      freezerDoor.position.set(0, height - freezerHeight / 2, depth / 2 + 0.02);
      freezerDoor.castShadow = true;
      group.add(freezerDoor);
      
      // Main fridge door (bottom section)
      const mainDoorHeight = height * 0.65;
      const mainDoorGeo = new THREE.BoxGeometry(width - 0.02, mainDoorHeight - 0.02, 0.04);
      const mainDoor = new THREE.Mesh(mainDoorGeo, fridgeMat);
      mainDoor.position.set(0, mainDoorHeight / 2, depth / 2 + 0.02);
      mainDoor.castShadow = true;
      group.add(mainDoor);
      
      // Handles
      const handleMat = new THREE.MeshStandardMaterial({
        color: 0x4a4a4a,
        roughness: 0.4,
        metalness: 0.8
      });
      
      const handleGeo = lod === 'high'
        ? new THREE.CylinderGeometry(0.015, 0.015, 0.3, 16)
        : new THREE.CylinderGeometry(0.015, 0.015, 0.3, 8);
      
      // Freezer handle
      const freezerHandle = new THREE.Mesh(handleGeo, handleMat);
      freezerHandle.rotation.z = Math.PI / 2;
      freezerHandle.position.set(width * 0.35, height - freezerHeight / 2, depth / 2 + 0.045);
      freezerHandle.castShadow = true;
      group.add(freezerHandle);
      
      // Main door handle
      const mainHandle = new THREE.Mesh(handleGeo, handleMat);
      mainHandle.rotation.z = Math.PI / 2;
      mainHandle.position.set(width * 0.35, mainDoorHeight / 2, depth / 2 + 0.045);
      mainHandle.castShadow = true;
      group.add(mainHandle);
      
      group.position.set(spec.x * GRID_SIZE, 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    // Food items for refrigerator
    function createMilkCarton(spec) {
      const group = new THREE.Group();
      const lod = spec.lod || 'high';
      
      const cartonGeo = new THREE.BoxGeometry(0.07, 0.15, 0.07);
      const cartonMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.8
      });
      const carton = new THREE.Mesh(cartonGeo, cartonMat);
      carton.position.y = 0.075;
      carton.castShadow = true;
      group.add(carton);
      
      // Top spout
      if (lod === 'high') {
        const spoutGeo = new THREE.BoxGeometry(0.03, 0.02, 0.03);
        const spout = new THREE.Mesh(spoutGeo, cartonMat);
        spout.position.y = 0.16;
        spout.castShadow = true;
        group.add(spout);
      }
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createOrangeJuice(spec) {
      const group = new THREE.Group();
      const lod = spec.lod || 'high';
      
      const bottleGeo = new THREE.CylinderGeometry(0.035, 0.035, 0.15, lod === 'high' ? 16 : 8);
      const bottleMat = new THREE.MeshStandardMaterial({
        color: 0xff8800,
        transparent: true,
        opacity: 0.7,
        roughness: 0.2
      });
      const bottle = new THREE.Mesh(bottleGeo, bottleMat);
      bottle.position.y = 0.075;
      bottle.castShadow = true;
      group.add(bottle);
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createCheese(spec) {
      const group = new THREE.Group();
      
      const cheeseGeo = new THREE.BoxGeometry(0.08, 0.03, 0.08);
      const cheeseMat = new THREE.MeshStandardMaterial({
        color: 0xffd700,
        roughness: 0.7
      });
      const cheese = new THREE.Mesh(cheeseGeo, cheeseMat);
      cheese.position.y = 0.015;
      cheese.castShadow = true;
      group.add(cheese);
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createEggs(spec) {
      const group = new THREE.Group();
      const lod = spec.lod || 'high';
      
      // Egg carton base
      const cartonGeo = new THREE.BoxGeometry(0.12, 0.02, 0.08);
      const cartonMat = new THREE.MeshStandardMaterial({
        color: 0xcccccc,
        roughness: 0.9
      });
      const carton = new THREE.Mesh(cartonGeo, cartonMat);
      carton.position.y = 0.01;
      carton.castShadow = true;
      group.add(carton);
      
      // Eggs
      const eggCount = lod === 'high' ? 6 : 4;
      const eggMat = new THREE.MeshStandardMaterial({
        color: 0xffeedd,
        roughness: 0.6
      });
      
      for (let i = 0; i < eggCount; i++) {
        const eggGeo = new THREE.SphereGeometry(0.015, lod === 'high' ? 12 : 6, lod === 'high' ? 12 : 6);
        const egg = new THREE.Mesh(eggGeo, eggMat);
        egg.scale.set(1, 1.3, 1);
        egg.position.set(
          -0.04 + (i % 3) * 0.04,
          0.035,
          -0.02 + Math.floor(i / 3) * 0.04
        );
        egg.castShadow = true;
        group.add(egg);
      }
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      scene.add(group);
      roomObjects.push(group);
    }
    
    // ==================== CACTI & PLANTS ====================
    
    function createCactus(spec) {
      const group = new THREE.Group();
      const lod = spec.lod || 'high';
      const variant = spec.variant || 'rounded'; // 'rounded', 'forked', 'flower', 'tall'
      
      const cactusMat = new THREE.MeshStandardMaterial({
        color: 0x4a7c4a,
        roughness: 0.9
      });
      
      if (variant === 'rounded') {
        // Round barrel cactus
        const bodyGeo = new THREE.SphereGeometry(0.08, lod === 'high' ? 16 : 8, lod === 'high' ? 16 : 8);
        const body = new THREE.Mesh(bodyGeo, cactusMat);
        body.scale.set(1, 1.2, 1);
        body.position.y = 0.1;
        body.castShadow = true;
        group.add(body);
        
        // Spines (small protrusions)
        if (lod === 'high') {
          for (let i = 0; i < 12; i++) {
            const angle = (i / 12) * Math.PI * 2;
            const spineGeo = new THREE.ConeGeometry(0.002, 0.01, 4);
            const spineMat = new THREE.MeshStandardMaterial({ color: 0xddddaa });
            const spine = new THREE.Mesh(spineGeo, spineMat);
            spine.position.set(
              Math.cos(angle) * 0.08,
              0.1 + (Math.random() - 0.5) * 0.04,
              Math.sin(angle) * 0.08
            );
            spine.lookAt(0, 0.1, 0);
            group.add(spine);
          }
        }
        
      } else if (variant === 'forked') {
        // Forked saguaro-style cactus
        const mainGeo = new THREE.CylinderGeometry(0.04, 0.05, 0.3, lod === 'high' ? 12 : 6);
        const main = new THREE.Mesh(mainGeo, cactusMat);
        main.position.y = 0.15;
        main.castShadow = true;
        group.add(main);
        
        // Arms
        for (let i = 0; i < 2; i++) {
          const armGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.15, lod === 'high' ? 12 : 6);
          const arm = new THREE.Mesh(armGeo, cactusMat);
          arm.position.set((i - 0.5) * 0.1, 0.2, 0);
          arm.rotation.z = (i - 0.5) * Math.PI / 6;
          arm.castShadow = true;
          group.add(arm);
        }
        
      } else if (variant === 'flower') {
        // Cactus with flower on top
        const bodyGeo = new THREE.CylinderGeometry(0.05, 0.06, 0.2, lod === 'high' ? 12 : 6);
        const body = new THREE.Mesh(bodyGeo, cactusMat);
        body.position.y = 0.1;
        body.castShadow = true;
        group.add(body);
        
        // Flower
        const flowerGeo = new THREE.SphereGeometry(0.025, lod === 'high' ? 12 : 6, lod === 'high' ? 12 : 6);
        const flowerMat = new THREE.MeshStandardMaterial({
          color: 0xff6b9d,
          roughness: 0.6
        });
        const flower = new THREE.Mesh(flowerGeo, flowerMat);
        flower.position.y = 0.225;
        flower.castShadow = true;
        group.add(flower);
        
        // Petals
        if (lod === 'high') {
          for (let i = 0; i < 6; i++) {
            const angle = (i / 6) * Math.PI * 2;
            const petalGeo = new THREE.SphereGeometry(0.015, 8, 8);
            const petal = new THREE.Mesh(petalGeo, flowerMat);
            petal.position.set(
              Math.cos(angle) * 0.025,
              0.225,
              Math.sin(angle) * 0.025
            );
            petal.scale.set(0.6, 1, 1);
            group.add(petal);
          }
        }
        
      } else if (variant === 'tall') {
        // Tall columnar cactus
        const bodyGeo = new THREE.CylinderGeometry(0.04, 0.045, 0.4, lod === 'high' ? 12 : 6);
        const body = new THREE.Mesh(bodyGeo, cactusMat);
        body.position.y = 0.2;
        body.castShadow = true;
        group.add(body);
      }
      
      // Pot
      const potGeo = new THREE.CylinderGeometry(0.06, 0.05, 0.08, lod === 'high' ? 16 : 8);
      const potMat = new THREE.MeshStandardMaterial({
        color: 0x8b4513,
        roughness: 0.8
      });
      const pot = new THREE.Mesh(potGeo, potMat);
      pot.position.y = 0.04;
      pot.castShadow = true;
      pot.receiveShadow = true;
      group.add(pot);
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    // ==================== DRINKWARE ====================
    
    function createCup(spec) {
      const group = new THREE.Group();
      const lod = spec.lod || 'high';
      
      const cupGeo = new THREE.CylinderGeometry(0.035, 0.03, 0.08, lod === 'high' ? 16 : 8);
      const cupMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xffffff,
        roughness: 0.3,
        metalness: 0.1
      });
      const cup = new THREE.Mesh(cupGeo, cupMat);
      cup.position.y = 0.04;
      cup.castShadow = true;
      cup.receiveShadow = true;
      group.add(cup);
      
      // Handle
      if (lod === 'high') {
        const handleGeo = new THREE.TorusGeometry(0.02, 0.005, 8, 12, Math.PI);
        const handle = new THREE.Mesh(handleGeo, cupMat);
        handle.rotation.y = Math.PI / 2;
        handle.position.set(0.04, 0.05, 0);
        handle.castShadow = true;
        group.add(handle);
      }
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createMug(spec) {
      const group = new THREE.Group();
      const lod = spec.lod || 'high';
      
      const mugGeo = new THREE.CylinderGeometry(0.04, 0.035, 0.1, lod === 'high' ? 16 : 8);
      const mugMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x4a4a8a,
        roughness: 0.6
      });
      const mug = new THREE.Mesh(mugGeo, mugMat);
      mug.position.y = 0.05;
      mug.castShadow = true;
      mug.receiveShadow = true;
      group.add(mug);
      
      // Handle (C-shaped)
      const handleGeo = new THREE.TorusGeometry(0.025, 0.008, lod === 'high' ? 12 : 6, lod === 'high' ? 16 : 8, Math.PI * 1.2);
      const handle = new THREE.Mesh(handleGeo, mugMat);
      handle.rotation.y = -Math.PI / 2;
      handle.rotation.z = Math.PI / 2;
      handle.position.set(0.045, 0.05, 0);
      handle.castShadow = true;
      group.add(handle);
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createJar(spec) {
      const group = new THREE.Group();
      const lod = spec.lod || 'high';
      
      // Jar body
      const jarGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.12, lod === 'high' ? 16 : 8);
      const jarMat = new THREE.MeshStandardMaterial({
        color: 0xddddff,
        transparent: true,
        opacity: 0.7,
        roughness: 0.1
      });
      const jar = new THREE.Mesh(jarGeo, jarMat);
      jar.position.y = 0.06;
      jar.castShadow = true;
      jar.receiveShadow = true;
      group.add(jar);
      
      // Lid
      const lidGeo = new THREE.CylinderGeometry(0.042, 0.042, 0.015, lod === 'high' ? 16 : 8);
      const lidMat = new THREE.MeshStandardMaterial({
        color: 0x8a8a8a,
        roughness: 0.4,
        metalness: 0.6
      });
      const lid = new THREE.Mesh(lidGeo, lidMat);
      lid.position.y = 0.1275;
      lid.castShadow = true;
      group.add(lid);
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    // ==================== OFFICE SUPPLIES ====================
    
    function createPencil(spec) {
      const group = new THREE.Group();
      const lod = spec.lod || 'high';
      
      // Pencil body (hexagonal)
      const bodyGeo = new THREE.CylinderGeometry(0.003, 0.003, 0.15, lod === 'high' ? 6 : 4);
      const bodyMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xffcc00,
        roughness: 0.7
      });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = 0.075;
      body.castShadow = true;
      group.add(body);
      
      // Tip (graphite)
      const tipGeo = new THREE.ConeGeometry(0.003, 0.01, lod === 'high' ? 6 : 4);
      const tipMat = new THREE.MeshStandardMaterial({
        color: 0x2a2a2a,
        roughness: 0.3
      });
      const tip = new THREE.Mesh(tipGeo, tipMat);
      tip.position.y = 0.155;
      tip.castShadow = true;
      group.add(tip);
      
      // Eraser
      if (lod === 'high') {
        const eraserGeo = new THREE.CylinderGeometry(0.004, 0.004, 0.015, 6);
        const eraserMat = new THREE.MeshStandardMaterial({
          color: 0xffb6c1,
          roughness: 0.9
        });
        const eraser = new THREE.Mesh(eraserGeo, eraserMat);
        eraser.position.y = 0.0075;
        eraser.castShadow = true;
        group.add(eraser);
        
        // Metal band
        const bandGeo = new THREE.CylinderGeometry(0.0035, 0.0035, 0.005, 6);
        const bandMat = new THREE.MeshStandardMaterial({
          color: 0xc0c0c0,
          roughness: 0.2,
          metalness: 0.9
        });
        const band = new THREE.Mesh(bandGeo, bandMat);
        band.position.y = 0.0125;
        group.add(band);
      }
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      group.rotation.z = Math.PI / 2; // Lay flat
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createNotepad(spec) {
      const group = new THREE.Group();
      const lod = spec.lod || 'high';
      
      // Pad body
      const padGeo = new THREE.BoxGeometry(0.1, 0.015, 0.15);
      const padMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xffffdd,
        roughness: 0.9
      });
      const pad = new THREE.Mesh(padGeo, padMat);
      pad.position.y = 0.0075;
      pad.castShadow = true;
      pad.receiveShadow = true;
      group.add(pad);
      
      // Binding (top edge)
      if (lod === 'high') {
        const bindingGeo = new THREE.BoxGeometry(0.1, 0.02, 0.01);
        const bindingMat = new THREE.MeshStandardMaterial({
          color: 0x4a4a4a,
          roughness: 0.6
        });
        const binding = new THREE.Mesh(bindingGeo, bindingMat);
        binding.position.set(0, 0.0075, -0.075);
        binding.castShadow = true;
        group.add(binding);
      }
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createNotebook(spec) {
      const group = new THREE.Group();
      const lod = spec.lod || 'high';
      
      // Cover
      const coverGeo = new THREE.BoxGeometry(0.15, 0.025, 0.2);
      const coverMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x4a4a8a,
        roughness: 0.7
      });
      const cover = new THREE.Mesh(coverGeo, coverMat);
      cover.position.y = 0.0125;
      cover.castShadow = true;
      cover.receiveShadow = true;
      group.add(cover);
      
      // Spiral binding
      if (lod === 'high') {
        for (let i = 0; i < 8; i++) {
          const spiralGeo = new THREE.TorusGeometry(0.005, 0.002, 6, 8);
          const spiralMat = new THREE.MeshStandardMaterial({
            color: 0xc0c0c0,
            roughness: 0.3,
            metalness: 0.8
          });
          const spiral = new THREE.Mesh(spiralGeo, spiralMat);
          spiral.rotation.x = Math.PI / 2;
          spiral.position.set(-0.07, 0.0125, -0.08 + i * 0.023);
          group.add(spiral);
        }
      }
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createStickyNotes(spec) {
      const group = new THREE.Group();
      
      // Stack of sticky notes
      const stackGeo = new THREE.BoxGeometry(0.075, 0.02, 0.075);
      const stackMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xffff66,
        roughness: 0.9
      });
      const stack = new THREE.Mesh(stackGeo, stackMat);
      stack.position.y = 0.01;
      stack.castShadow = true;
      stack.receiveShadow = true;
      group.add(stack);
      
      // Individual note on top (slightly pulled)
      const noteGeo = new THREE.BoxGeometry(0.075, 0.001, 0.075);
      const note = new THREE.Mesh(noteGeo, stackMat);
      note.position.set(0.01, 0.022, -0.01);
      note.rotation.y = 0.1;
      note.castShadow = true;
      group.add(note);
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    // ==================== KITCHEN APPLIANCES & FOOD ====================
    
    function createMicrowave(spec) {
      const group = new THREE.Group();
      
      const width = 0.5;
      const height = 0.3;
      const depth = 0.35;
      
      // Main body
      const bodyGeo = new THREE.BoxGeometry(width, height, depth);
      const bodyMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x2a2a2a,
        roughness: 0.6,
        metalness: 0.3
      });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = height / 2;
      body.castShadow = true;
      body.receiveShadow = true;
      group.add(body);
      
      // Door (glass front)
      const doorGeo = new THREE.PlaneGeometry(width * 0.85, height * 0.75);
      const doorMat = new THREE.MeshStandardMaterial({
        color: 0x1a1a1a,
        transparent: true,
        opacity: 0.7,
        metalness: 0.5
      });
      const door = new THREE.Mesh(doorGeo, doorMat);
      door.position.set(0, height / 2, depth / 2 + 0.001);
      group.add(door);
      
      // Control panel
      const panelGeo = new THREE.PlaneGeometry(width * 0.3, height * 0.2);
      const panelMat = new THREE.MeshStandardMaterial({
        color: 0x333333,
        roughness: 0.4
      });
      const panel = new THREE.Mesh(panelGeo, panelMat);
      panel.position.set(width * 0.25, height * 0.7, depth / 2 + 0.002);
      group.add(panel);
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createSodaCan(spec) {
      const group = new THREE.Group();
      
      const radius = 0.03;
      const height = 0.12;
      
      // Can body
      const canGeo = new THREE.CylinderGeometry(radius, radius, height, 24);
      const canMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xff0000,
        roughness: 0.3,
        metalness: 0.8
      });
      const can = new THREE.Mesh(canGeo, canMat);
      can.position.y = height / 2;
      can.castShadow = true;
      can.receiveShadow = true;
      group.add(can);
      
      // Top rim
      const topGeo = new THREE.CylinderGeometry(radius + 0.002, radius, 0.008, 24);
      const topMat = new THREE.MeshStandardMaterial({
        color: 0xcccccc,
        roughness: 0.2,
        metalness: 0.9
      });
      const top = new THREE.Mesh(topGeo, topMat);
      top.position.y = height;
      group.add(top);
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createCerealBox(spec) {
      const group = new THREE.Group();
      
      const width = 0.2;
      const height = 0.3;
      const depth = 0.08;
      
      const boxGeo = new THREE.BoxGeometry(width, height, depth);
      const boxMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xffaa00,
        roughness: 0.8
      });
      const box = new THREE.Mesh(boxGeo, boxMat);
      box.position.y = height / 2;
      box.castShadow = true;
      box.receiveShadow = true;
      group.add(box);
      
      // Label
      const labelGeo = new THREE.PlaneGeometry(width * 0.8, height * 0.6);
      const labelMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.9
      });
      const label = new THREE.Mesh(labelGeo, labelMat);
      label.position.set(0, height * 0.6, depth / 2 + 0.001);
      group.add(label);
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createCrackerBox(spec) {
      const group = new THREE.Group();
      
      const width = 0.18;
      const height = 0.22;
      const depth = 0.06;
      
      const boxGeo = new THREE.BoxGeometry(width, height, depth);
      const boxMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xd4af37,
        roughness: 0.8
      });
      const box = new THREE.Mesh(boxGeo, boxMat);
      box.position.y = height / 2;
      box.castShadow = true;
      box.receiveShadow = true;
      group.add(box);
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createComputerTower(spec) {
      const group = new THREE.Group();
      
      const width = 0.2;
      const height = 0.45;
      const depth = 0.45;
      
      // Tower case
      const caseGeo = new THREE.BoxGeometry(width, height, depth);
      const caseMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x1a1a1a,
        roughness: 0.5,
        metalness: 0.6
      });
      const towerCase = new THREE.Mesh(caseGeo, caseMat);
      towerCase.position.y = height / 2;
      towerCase.castShadow = true;
      towerCase.receiveShadow = true;
      group.add(towerCase);
      
      // Front panel
      const panelGeo = new THREE.PlaneGeometry(width * 0.9, height * 0.3);
      const panelMat = new THREE.MeshStandardMaterial({
        color: 0x2a2a2a,
        roughness: 0.6
      });
      const panel = new THREE.Mesh(panelGeo, panelMat);
      panel.position.set(0, height * 0.7, depth / 2 + 0.001);
      group.add(panel);
      
      // Power button (small LED)
      const ledGeo = new THREE.CircleGeometry(0.008, 12);
      const ledMat = new THREE.MeshStandardMaterial({
        color: 0x00ff00,
        emissive: 0x00ff00,
        emissiveIntensity: 0.5
      });
      const led = new THREE.Mesh(ledGeo, ledMat);
      led.position.set(0, height * 0.85, depth / 2 + 0.002);
      group.add(led);
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    // ==================== CLEANING SUPPLIES ====================
    
    function createBroom(spec) {
      const group = new THREE.Group();
      
      // Handle (long cylinder)
      const handleGeo = new THREE.CylinderGeometry(0.012, 0.012, 1.2, 12);
      const handleMat = new THREE.MeshStandardMaterial({
        color: 0x8b7355,
        roughness: 0.8
      });
      const handle = new THREE.Mesh(handleGeo, handleMat);
      handle.position.y = 0.6;
      handle.castShadow = true;
      group.add(handle);
      
      // Bristles (flat box at bottom)
      const bristleGeo = new THREE.BoxGeometry(0.2, 0.08, 0.06);
      const bristleMat = new THREE.MeshStandardMaterial({
        color: 0xffcc66,
        roughness: 0.9
      });
      const bristles = new THREE.Mesh(bristleGeo, bristleMat);
      bristles.position.y = 0.04;
      bristles.castShadow = true;
      group.add(bristles);
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      if (spec.lean) group.rotation.z = Math.PI / 6;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createDustpan(spec) {
      const group = new THREE.Group();
      
      // Pan (angled box)
      const panGeo = new THREE.BoxGeometry(0.25, 0.02, 0.3);
      const panMat = new THREE.MeshStandardMaterial({
        color: 0xff4444,
        roughness: 0.6,
        metalness: 0.2
      });
      const pan = new THREE.Mesh(panGeo, panMat);
      pan.position.y = 0.02;
      pan.rotation.x = -Math.PI / 12;
      pan.castShadow = true;
      group.add(pan);
      
      // Handle
      const handleGeo = new THREE.CylinderGeometry(0.008, 0.008, 0.15, 8);
      const handle = new THREE.Mesh(handleGeo, panMat);
      handle.position.set(0, 0.08, -0.17);
      handle.rotation.x = Math.PI / 3;
      group.add(handle);
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createVacuum(spec) {
      const group = new THREE.Group();
      
      // Body (cylinder)
      const bodyGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.45, 24);
      const bodyMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x6a4c93,
        roughness: 0.6,
        metalness: 0.2
      });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = 0.225;
      body.castShadow = true;
      body.receiveShadow = true;
      group.add(body);
      
      // Hose
      const hoseGeo = new THREE.TorusGeometry(0.15, 0.015, 8, 16, Math.PI);
      const hoseMat = new THREE.MeshStandardMaterial({
        color: 0x333333,
        roughness: 0.7
      });
      const hose = new THREE.Mesh(hoseGeo, hoseMat);
      hose.rotation.x = -Math.PI / 4;
      hose.position.set(0, 0.4, 0);
      group.add(hose);
      
      // Nozzle
      const nozzleGeo = new THREE.CylinderGeometry(0.02, 0.03, 0.25, 12);
      const nozzle = new THREE.Mesh(nozzleGeo, hoseMat);
      nozzle.rotation.x = Math.PI / 2;
      nozzle.position.set(0, 0.35, 0.2);
      group.add(nozzle);
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createHandheldVacuum(spec) {
      const group = new THREE.Group();
      
      // Body (tapered cylinder)
      const bodyGeo = new THREE.CylinderGeometry(0.04, 0.06, 0.25, 16);
      const bodyMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x2a2a2a,
        roughness: 0.5,
        metalness: 0.3
      });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.rotation.z = Math.PI / 2;
      body.position.set(0.125, 0.05, 0);
      body.castShadow = true;
      group.add(body);
      
      // Handle
      const handleGeo = new THREE.TorusGeometry(0.035, 0.01, 8, 16, Math.PI);
      const handle = new THREE.Mesh(handleGeo, bodyMat);
      handle.rotation.z = Math.PI / 2;
      handle.position.set(-0.02, 0.08, 0);
      group.add(handle);
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createBucket(spec) {
      const group = new THREE.Group();
      
      // Bucket body (tapered cylinder)
      const bucketGeo = new THREE.CylinderGeometry(0.15, 0.12, 0.25, 24);
      const bucketMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xff6666,
        roughness: 0.6,
        metalness: 0.2
      });
      const bucket = new THREE.Mesh(bucketGeo, bucketMat);
      bucket.position.y = 0.125;
      bucket.castShadow = true;
      bucket.receiveShadow = true;
      group.add(bucket);
      
      // Handle
      const handleGeo = new THREE.TorusGeometry(0.12, 0.008, 8, 16, Math.PI);
      const handleMat = new THREE.MeshStandardMaterial({
        color: 0x666666,
        roughness: 0.4,
        metalness: 0.6
      });
      const handle = new THREE.Mesh(handleGeo, handleMat);
      handle.rotation.x = Math.PI / 2;
      handle.position.y = 0.28;
      group.add(handle);
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createSponge(spec) {
      const group = new THREE.Group();
      
      const spongeGeo = new THREE.BoxGeometry(0.08, 0.04, 0.12);
      const spongeMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xffff66,
        roughness: 0.95
      });
      const sponge = new THREE.Mesh(spongeGeo, spongeMat);
      sponge.position.y = 0.02;
      sponge.castShadow = true;
      group.add(sponge);
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createRag(spec) {
      const group = new THREE.Group();
      
      const ragGeo = new THREE.PlaneGeometry(0.25, 0.25, 4, 4);
      const positions = ragGeo.attributes.position;
      for (let i = 0; i < positions.count; i++) {
        positions.setY(i, positions.getY(i) + (Math.random() - 0.5) * 0.02);
      }
      ragGeo.computeVertexNormals();
      
      const ragMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x8888ff,
        roughness: 0.9,
        side: THREE.DoubleSide
      });
      const rag = new THREE.Mesh(ragGeo, ragMat);
      rag.rotation.x = -Math.PI / 2 + Math.random() * 0.3;
      rag.position.y = 0.01;
      rag.receiveShadow = true;
      group.add(rag);
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createPaperTowelRoll(spec) {
      const group = new THREE.Group();
      
      // Roll (cylinder)
      const rollGeo = new THREE.CylinderGeometry(0.06, 0.06, 0.28, 24);
      const rollMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.8
      });
      const roll = new THREE.Mesh(rollGeo, rollMat);
      roll.rotation.z = Math.PI / 2;
      roll.castShadow = true;
      roll.receiveShadow = true;
      group.add(roll);
      
      // Cardboard tube (inner)
      const tubeGeo = new THREE.CylinderGeometry(0.025, 0.025, 0.29, 16);
      const tubeMat = new THREE.MeshStandardMaterial({
        color: 0xd4a574,
        roughness: 0.9
      });
      const tube = new THREE.Mesh(tubeGeo, tubeMat);
      tube.rotation.z = Math.PI / 2;
      group.add(tube);
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0.06, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createToiletPaperRoll(spec) {
      const group = new THREE.Group();
      
      // Roll (cylinder)
      const rollGeo = new THREE.CylinderGeometry(0.055, 0.055, 0.11, 24);
      const rollMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.85
      });
      const roll = new THREE.Mesh(rollGeo, rollMat);
      roll.rotation.z = Math.PI / 2;
      roll.castShadow = true;
      roll.receiveShadow = true;
      group.add(roll);
      
      // Cardboard tube
      const tubeGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.12, 16);
      const tubeMat = new THREE.MeshStandardMaterial({
        color: 0xd4a574,
        roughness: 0.9
      });
      const tube = new THREE.Mesh(tubeGeo, tubeMat);
      tube.rotation.z = Math.PI / 2;
      group.add(tube);
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0.055, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    // ==================== TOYS & GAMES ====================
    
    function createJengaTower(spec) {
      const group = new THREE.Group();
      
      const blockWidth = 0.015;
      const blockHeight = 0.005;
      const blockDepth = 0.045;
      const levels = spec.levels || 18;
      const config = spec.config || 'clean'; // 'clean' or 'random'
      
      const woodMat = new THREE.MeshStandardMaterial({
        color: 0xd4a574,
        roughness: 0.7
      });
      
      for (let level = 0; level < levels; level++) {
        const isVertical = level % 2 === 0;
        const blocksPerLevel = 3;
        
        for (let i = 0; i < blocksPerLevel; i++) {
          const blockGeo = new THREE.BoxGeometry(
            isVertical ? blockWidth : blockDepth,
            blockHeight,
            isVertical ? blockDepth : blockWidth
          );
          const block = new THREE.Mesh(blockGeo, woodMat);
          
          if (config === 'random' && Math.random() > 0.7) {
            // Random placement for messy tower
            block.position.set(
              (i - 1) * (blockWidth + 0.001) + (Math.random() - 0.5) * 0.008,
              level * blockHeight + blockHeight / 2 + (Math.random() - 0.5) * 0.002,
              (Math.random() - 0.5) * 0.008
            );
            block.rotation.y = (Math.random() - 0.5) * 0.15;
          } else {
            // Clean placement
            if (isVertical) {
              block.position.set(
                (i - 1) * (blockWidth + 0.001),
                level * blockHeight + blockHeight / 2,
                0
              );
            } else {
              block.position.set(
                0,
                level * blockHeight + blockHeight / 2,
                (i - 1) * (blockWidth + 0.001)
              );
            }
          }
          
          block.castShadow = true;
          block.receiveShadow = true;
          group.add(block);
        }
      }
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createDeskLamp(spec) {
      const group = new THREE.Group();
      
      const metalMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xcccccc,
        roughness: 0.4,
        metalness: 0.8
      });
      
      // Base (heavy disk)
      const baseGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.02, 24);
      const base = new THREE.Mesh(baseGeo, metalMat);
      base.position.y = 0.01;
      base.castShadow = true;
      base.receiveShadow = true;
      group.add(base);
      
      // Lower arm (angled cylinder)
      const lowerArmGeo = new THREE.CylinderGeometry(0.008, 0.008, 0.25, 12);
      const lowerArm = new THREE.Mesh(lowerArmGeo, metalMat);
      lowerArm.position.set(0, 0.15, 0);
      lowerArm.rotation.z = -Math.PI / 6;
      lowerArm.castShadow = true;
      group.add(lowerArm);
      
      // Elbow joint (sphere)
      const elbowGeo = new THREE.SphereGeometry(0.015, 16, 16);
      const elbow = new THREE.Mesh(elbowGeo, metalMat);
      elbow.position.set(0.11, 0.27, 0);
      elbow.castShadow = true;
      group.add(elbow);
      
      // Upper arm (angled cylinder)
      const upperArmGeo = new THREE.CylinderGeometry(0.006, 0.006, 0.2, 12);
      const upperArm = new THREE.Mesh(upperArmGeo, metalMat);
      upperArm.position.set(0.19, 0.37, 0);
      upperArm.rotation.z = Math.PI / 4;
      upperArm.castShadow = true;
      group.add(upperArm);
      
      // Lampshade (cone)
      const shadeGeo = new THREE.ConeGeometry(0.08, 0.12, 24);
      const shadeMat = new THREE.MeshStandardMaterial({
        color: spec.shadeColor || 0x333333,
        roughness: 0.6,
        emissive: spec.lit ? 0xffcc66 : 0x000000,
        emissiveIntensity: spec.lit ? 0.3 : 0
      });
      const shade = new THREE.Mesh(shadeGeo, shadeMat);
      shade.rotation.z = Math.PI;
      shade.position.set(0.26, 0.48, 0);
      shade.castShadow = true;
      group.add(shade);
      
      // Bulb
      const bulbGeo = new THREE.SphereGeometry(0.02, 16, 16);
      const bulbMat = new THREE.MeshStandardMaterial({
        color: 0xffff99,
        emissive: spec.lit ? 0xffcc66 : 0xffff99,
        emissiveIntensity: spec.lit ? 1.0 : 0.2
      });
      const bulb = new THREE.Mesh(bulbGeo, bulbMat);
      bulb.position.set(0.26, 0.42, 0);
      group.add(bulb);
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createPixarBall(spec) {
      const group = new THREE.Group();
      
      const radius = spec.radius || 0.055;
      
      // Ball (yellow base)
      const ballGeo = new THREE.SphereGeometry(radius, 32, 32);
      const ballMat = new THREE.MeshStandardMaterial({
        color: 0xffdd00,
        roughness: 0.4,
        metalness: 0.1
      });
      const ball = new THREE.Mesh(ballGeo, ballMat);
      ball.position.y = radius;
      ball.castShadow = true;
      ball.receiveShadow = true;
      group.add(ball);
      
      // Red stripe
      const stripeGeo = new THREE.TorusGeometry(radius * 0.9, radius * 0.15, 12, 32);
      const stripeMat = new THREE.MeshStandardMaterial({
        color: 0xff0000,
        roughness: 0.4
      });
      const stripe = new THREE.Mesh(stripeGeo, stripeMat);
      stripe.rotation.x = Math.PI / 2;
      stripe.position.y = radius;
      stripe.castShadow = true;
      group.add(stripe);
      
      // Blue star (simple circle on top)
      const starGeo = new THREE.CircleGeometry(radius * 0.3, 5);
      const starMat = new THREE.MeshStandardMaterial({
        color: 0x0066ff,
        roughness: 0.5
      });
      const star = new THREE.Mesh(starGeo, starMat);
      star.position.y = radius + 0.001;
      star.rotation.x = -Math.PI / 2;
      group.add(star);
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createBasketball(spec) {
      const group = new THREE.Group();
      
      const radius = 0.12;
      
      const ballGeo = new THREE.SphereGeometry(radius, 32, 32);
      const ballMat = new THREE.MeshStandardMaterial({
        color: 0xff8833,
        roughness: 0.8
      });
      const ball = new THREE.Mesh(ballGeo, ballMat);
      ball.position.y = radius;
      ball.castShadow = true;
      ball.receiveShadow = true;
      group.add(ball);
      
      // Black lines (simplified)
      const lineMat = new THREE.MeshStandardMaterial({
        color: 0x000000,
        roughness: 0.9
      });
      
      // Horizontal line
      const hLineGeo = new THREE.TorusGeometry(radius, 0.003, 8, 32);
      const hLine = new THREE.Mesh(hLineGeo, lineMat);
      hLine.rotation.x = Math.PI / 2;
      hLine.position.y = radius;
      group.add(hLine);
      
      // Vertical lines
      for (let i = 0; i < 2; i++) {
        const vLine = new THREE.Mesh(hLineGeo, lineMat);
        vLine.rotation.z = (i * Math.PI / 2) + Math.PI / 4;
        vLine.position.y = radius;
        group.add(vLine);
      }
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createBaseball(spec) {
      const group = new THREE.Group();
      
      const radius = 0.037;
      
      const ballGeo = new THREE.SphereGeometry(radius, 32, 32);
      const ballMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.7
      });
      const ball = new THREE.Mesh(ballGeo, ballMat);
      ball.position.y = radius;
      ball.castShadow = true;
      ball.receiveShadow = true;
      group.add(ball);
      
      // Stitching (red curves)
      const stitchMat = new THREE.MeshStandardMaterial({
        color: 0xcc0000,
        roughness: 0.8
      });
      
      // Simplified stitching as small tori
      for (let i = 0; i < 2; i++) {
        const stitchGeo = new THREE.TorusGeometry(radius * 0.5, 0.002, 6, 16, Math.PI);
        const stitch = new THREE.Mesh(stitchGeo, stitchMat);
        stitch.rotation.y = i * Math.PI;
        stitch.rotation.x = Math.PI / 4;
        stitch.position.y = radius;
        group.add(stitch);
      }
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    // ==================== RUGS ====================
    
    function createRug(spec) {
      const group = new THREE.Group();
      
      const width = spec.width || 1.5;
      const depth = spec.depth || 2.0;
      const thickness = 0.015;
      
      // Main rug body with raised edges
      const rugGeo = new THREE.PlaneGeometry(width, depth, 16, 16);
      const positions = rugGeo.attributes.position;
      
      // Create bumped/raised edges
      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const y = positions.getY(i);
        
        const xEdge = Math.abs(x) / (width / 2);
        const yEdge = Math.abs(y) / (depth / 2);
        
        let height = 0;
        
        // Tasseled edge effect - raised bumps at the edges
        if (xEdge > 0.9 || yEdge > 0.9) {
          height = 0.008 + Math.random() * 0.004;
        } else if (xEdge > 0.85 || yEdge > 0.85) {
          height = 0.003;
        }
        
        positions.setZ(i, height);
      }
      rugGeo.computeVertexNormals();
      
      const rugMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x8b4513,
        roughness: 0.95,
        side: THREE.DoubleSide
      });
      const rug = new THREE.Mesh(rugGeo, rugMat);
      rug.rotation.x = -Math.PI / 2;
      rug.position.y = 0.002;
      rug.receiveShadow = true;
      group.add(rug);
      
      // Tassels at the short edges
      const tasselCount = Math.floor(width / 0.08);
      for (let side = 0; side < 2; side++) {
        for (let i = 0; i < tasselCount; i++) {
          const tasselGeo = new THREE.CylinderGeometry(0.003, 0.001, 0.03, 4);
          const tassel = new THREE.Mesh(tasselGeo, rugMat);
          tassel.position.set(
            -width / 2 + (i + 0.5) * (width / tasselCount),
            0.015,
            (side === 0 ? -depth / 2 : depth / 2) + (side === 0 ? -0.015 : 0.015)
          );
          tassel.castShadow = true;
          group.add(tassel);
        }
      }
      
      group.position.set(spec.x * GRID_SIZE, 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    // ==================== SHELVES ====================
    
    function createShelf(spec) {
      const group = new THREE.Group();
      
      const width = spec.width || 1.2;
      const depth = 0.25;
      const shelfThickness = 0.03;
      const numShelves = spec.shelves || 3;
      const height = numShelves * 0.45;
      
      const shelfMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x8b7355,
        roughness: 0.8,
        metalness: 0.1
      });
      
      // Back panel
      const backGeo = new THREE.BoxGeometry(width, height, 0.01);
      const back = new THREE.Mesh(backGeo, shelfMat);
      back.position.set(0, height / 2, -depth / 2);
      back.castShadow = true;
      back.receiveShadow = true;
      group.add(back);
      
      // Side panels
      const sideGeo = new THREE.BoxGeometry(0.02, height, depth);
      const leftSide = new THREE.Mesh(sideGeo, shelfMat);
      leftSide.position.set(-width / 2, height / 2, 0);
      leftSide.castShadow = true;
      group.add(leftSide);
      
      const rightSide = new THREE.Mesh(sideGeo, shelfMat);
      rightSide.position.set(width / 2, height / 2, 0);
      rightSide.castShadow = true;
      group.add(rightSide);
      
      // Shelves
      for (let i = 0; i < numShelves; i++) {
        const shelfGeo = new THREE.BoxGeometry(width, shelfThickness, depth);
        const shelf = new THREE.Mesh(shelfGeo, shelfMat);
        shelf.position.y = i * (height / numShelves) + shelfThickness / 2;
        shelf.castShadow = true;
        shelf.receiveShadow = true;
        group.add(shelf);
      }
      
      group.position.set(spec.x * GRID_SIZE, 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    // ==================== CEILING LIGHTS ====================
    
    function createCeilingLight(spec) {
      const group = new THREE.Group();
      const style = spec.style || 'modern'; // 'modern', 'strip', 'classic'
      
      if (style === 'modern') {
        // Modern pendant fixture
        const cableGeo = new THREE.CylinderGeometry(0.003, 0.003, 0.3, 8);
        const cableMat = new THREE.MeshStandardMaterial({
          color: 0x1a1a1a,
          roughness: 0.5,
          metalness: 0.8
        });
        const cable = new THREE.Mesh(cableGeo, cableMat);
        cable.position.y = WALL_HEIGHT - 0.15;
        group.add(cable);
        
        // Lamp shade (cone)
        const shadeGeo = new THREE.ConeGeometry(0.15, 0.2, 16, 1, true);
        const shadeMat = new THREE.MeshStandardMaterial({
          color: spec.color || 0xf0f0f0,
          roughness: 0.7,
          side: THREE.DoubleSide
        });
        const shade = new THREE.Mesh(shadeGeo, shadeMat);
        shade.position.y = WALL_HEIGHT - 0.35;
        shade.castShadow = true;
        group.add(shade);
        
        // Light source
        const bulbGeo = new THREE.SphereGeometry(0.04, 16, 16);
        const bulbMat = new THREE.MeshStandardMaterial({
          color: 0xffffcc,
          emissive: 0xffffcc,
          emissiveIntensity: 0.8
        });
        const bulb = new THREE.Mesh(bulbGeo, bulbMat);
        bulb.position.y = WALL_HEIGHT - 0.4;
        group.add(bulb);
        
        const light = new THREE.PointLight(0xffffcc, 0.8, 8);
        light.position.y = WALL_HEIGHT - 0.4;
        light.castShadow = true;
        group.add(light);
        
      } else if (style === 'strip') {
        // Modern strip light (for hallways)
        const stripWidth = spec.width || 1.2;
        const stripGeo = new THREE.BoxGeometry(stripWidth, 0.05, 0.15);
        const stripMat = new THREE.MeshStandardMaterial({
          color: 0xf0f0f0,
          emissive: 0xffffcc,
          emissiveIntensity: 0.6,
          roughness: 0.3
        });
        const strip = new THREE.Mesh(stripGeo, stripMat);
        strip.position.y = WALL_HEIGHT - 0.03;
        strip.castShadow = true;
        group.add(strip);
        
        // Light
        const light = new THREE.RectAreaLight(0xffffcc, 3, stripWidth, 0.15);
        light.position.y = WALL_HEIGHT - 0.08;
        light.rotation.x = Math.PI;
        group.add(light);
        
      } else if (style === 'classic') {
        // Classic glass disc light
        const baseGeo = new THREE.CylinderGeometry(0.25, 0.25, 0.05, 32);
        const baseMat = new THREE.MeshStandardMaterial({
          color: 0xffffff,
          roughness: 0.3,
          metalness: 0.5
        });
        const base = new THREE.Mesh(baseGeo, baseMat);
        base.position.y = WALL_HEIGHT - 0.05;
        base.castShadow = true;
        group.add(base);
        
        // Glass cover
        const glassGeo = new THREE.SphereGeometry(0.22, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
        const glassMat = new THREE.MeshStandardMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.6,
          roughness: 0.1,
          emissive: 0xffffcc,
          emissiveIntensity: 0.4
        });
        const glass = new THREE.Mesh(glassGeo, glassMat);
        glass.rotation.x = Math.PI;
        glass.position.y = WALL_HEIGHT - 0.08;
        group.add(glass);
        
        const light = new THREE.PointLight(0xffffcc, 1.2, 10);
        light.position.y = WALL_HEIGHT - 0.15;
        light.castShadow = true;
        group.add(light);
      }
      
      group.position.set(spec.x * GRID_SIZE, 0, spec.z * GRID_SIZE);
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    // ==================== FLOOR STYLING ====================
    // Using advanced FloorPatterns module for professional floor generation
    
    function createFloorStyling(bounds, style) {
      // Get random style if not specified
      if (!style) {
        style = FloorPatterns.getRandomPattern();
      }
      
      // Legacy style mapping to new patterns
      const styleMap = {
        'hardwood': 'hardwood-short',
        'tile': 'tile-broad',
        'carpet': 'carpet-plush'
      };
      
      const mappedStyle = styleMap[style] || style;
      
      // Create floor using advanced patterns module
      const floorGroup = FloorPatterns.createFloor(scene, bounds, mappedStyle, {
        gridSize: GRID_SIZE
      });
      
      if (floorGroup) {
        roomObjects.push(floorGroup);
      }
    }
    
    // ==================== LIVING ROOM FURNITURE ====================
    
    function createCouch(spec) {
      const group = new THREE.Group();
      
      const couchWidth = spec.width || 1.8;
      const couchDepth = 0.9;
      const couchHeight = 0.8;
      const armHeight = 0.6;
      
      const fabricMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x4a5a6a,
        roughness: 0.9
      });
      
      // Main seat
      const seatGeo = new THREE.BoxGeometry(couchWidth, 0.4, couchDepth);
      const seat = new THREE.Mesh(seatGeo, fabricMat);
      seat.position.y = 0.35;
      seat.castShadow = true;
      seat.receiveShadow = true;
      group.add(seat);
      
      // Backrest with rounded top
      const backGeo = new THREE.BoxGeometry(couchWidth, couchHeight - 0.35, 0.15, 8, 6, 2);
      const backPos = backGeo.attributes.position;
      for (let i = 0; i < backPos.count; i++) {
        const x = backPos.getX(i);
        const y = backPos.getY(i);
        const z = backPos.getZ(i);
        
        const yEdge = Math.abs(y) / ((couchHeight - 0.35) / 2);
        const xEdge = Math.abs(x) / (couchWidth / 2);
        
        if (yEdge > 0.8) {
          backPos.setX(i, x * 0.96);
          backPos.setZ(i, z * 0.93);
        }
      }
      backGeo.computeVertexNormals();
      
      const back = new THREE.Mesh(backGeo, fabricMat);
      back.position.set(0, couchHeight / 2 + 0.15, -couchDepth / 2 + 0.075);
      back.castShadow = true;
      group.add(back);
      
      // Left arm with rounded top
      const armGeo = new THREE.BoxGeometry(0.15, armHeight, couchDepth, 2, 4, 6);
      const armPos = armGeo.attributes.position;
      for (let i = 0; i < armPos.count; i++) {
        const x = armPos.getX(i);
        const y = armPos.getY(i);
        const z = armPos.getZ(i);
        
        const yEdge = Math.abs(y) / (armHeight / 2);
        if (yEdge > 0.8) {
          armPos.setX(i, x * 0.92);
          armPos.setZ(i, z * 0.95);
        }
      }
      armGeo.computeVertexNormals();
      
      const leftArm = new THREE.Mesh(armGeo, fabricMat);
      leftArm.position.set(-couchWidth / 2 + 0.075, armHeight / 2, 0);
      leftArm.castShadow = true;
      group.add(leftArm);
      
      // Right arm
      const rightArm = new THREE.Mesh(armGeo, fabricMat);
      rightArm.position.set(couchWidth / 2 - 0.075, armHeight / 2, 0);
      rightArm.castShadow = true;
      group.add(rightArm);
      
      // Cushions with rounded edges
      for (let i = 0; i < 3; i++) {
        const cushionGeo = new THREE.BoxGeometry(couchWidth / 3 - 0.05, 0.15, couchDepth * 0.8, 4, 2, 6);
        const cushPos = cushionGeo.attributes.position;
        
        for (let j = 0; j < cushPos.count; j++) {
          const x = cushPos.getX(j);
          const y = cushPos.getY(j);
          const z = cushPos.getZ(j);
          
          const xEdge = Math.abs(x) / ((couchWidth / 3 - 0.05) / 2);
          const zEdge = Math.abs(z) / ((couchDepth * 0.8) / 2);
          const yEdge = Math.abs(y) / 0.075;
          
          if (yEdge > 0.8 && (xEdge > 0.7 || zEdge > 0.7)) {
            cushPos.setX(j, x * 0.96);
            cushPos.setZ(j, z * 0.96);
          }
        }
        cushionGeo.computeVertexNormals();
        
        const cushion = new THREE.Mesh(cushionGeo, fabricMat);
        cushion.position.set(
          -couchWidth / 3 + i * (couchWidth / 3),
          0.55,
          -0.05
        );
        cushion.castShadow = true;
        group.add(cushion);
      }
      
      group.position.set(spec.x * GRID_SIZE, 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createTV(spec) {
      const group = new THREE.Group();
      
      const style = spec.style || 'flat'; // 'flat' or 'tube'
      const tvWidth = spec.width || 1.2;
      const tvHeight = tvWidth * 0.6;
      
      if (style === 'tube') {
        // Old school CRT TV with subtle barrel distortion
        const tvDepth = 0.45;
        
        // Create bulging screen with sphere segment (reduced curvature)
        const screenGeo = new THREE.SphereGeometry(tvWidth * 1.2, 48, 48, 0, Math.PI * 2, 0, Math.PI / 5);
        const screenMat = new THREE.MeshStandardMaterial({
          color: 0x1a1a2a,
          roughness: 0.2,
          metalness: 0.3
        });
        const screen = new THREE.Mesh(screenGeo, screenMat);
        screen.rotation.x = -Math.PI / 2;
        screen.position.set(0, 0.6, tvDepth / 2);
        screen.castShadow = true;
        group.add(screen);
        
        // Plastic casing
        const casingGeo = new THREE.BoxGeometry(tvWidth, tvHeight, tvDepth);
        const casingMat = new THREE.MeshStandardMaterial({
          color: 0x4a4a4a,
          roughness: 0.7,
          metalness: 0.1
        });
        const casing = new THREE.Mesh(casingGeo, casingMat);
        casing.position.y = 0.6;
        casing.castShadow = true;
        casing.receiveShadow = true;
        group.add(casing);
        
        // Control panel (buttons on front)
        const panelGeo = new THREE.BoxGeometry(0.15, 0.08, 0.02);
        const panelMat = new THREE.MeshStandardMaterial({
          color: 0x333333,
          roughness: 0.8
        });
        const panel = new THREE.Mesh(panelGeo, panelMat);
        panel.position.set(tvWidth * 0.35, 0.5, tvDepth / 2 + 0.01);
        group.add(panel);
        
        // Base/feet
        const baseGeo = new THREE.BoxGeometry(tvWidth * 0.9, 0.05, tvDepth * 0.8);
        const base = new THREE.Mesh(baseGeo, casingMat);
        base.position.y = 0.025;
        base.receiveShadow = true;
        group.add(base);
        
      } else {
        // Modern flat screen TV
        const tvDepth = 0.05;
        
        // TV screen
        const screenGeo = new THREE.BoxGeometry(tvWidth, tvHeight, tvDepth);
        const screenMat = new THREE.MeshStandardMaterial({
          color: 0x0a0a0a,
          roughness: 0.1,
          metalness: 0.8
        });
        const screen = new THREE.Mesh(screenGeo, screenMat);
        screen.position.y = 0.8;
        screen.castShadow = true;
        group.add(screen);
        
        // Frame/bezel
        const bezelGeo = new THREE.BoxGeometry(tvWidth + 0.04, tvHeight + 0.04, tvDepth - 0.01);
        const bezelMat = new THREE.MeshStandardMaterial({
          color: 0x1a1a1a,
          roughness: 0.6,
          metalness: 0.4
        });
        const bezel = new THREE.Mesh(bezelGeo, bezelMat);
        bezel.position.set(0, 0.8, -tvDepth / 2);
        bezel.castShadow = true;
        group.add(bezel);
        
        // Stand
        const standGeo = new THREE.CylinderGeometry(0.08, 0.12, 0.3, 16);
        const standMat = new THREE.MeshStandardMaterial({
          color: 0x2a2a2a,
          roughness: 0.7,
          metalness: 0.3
        });
        const stand = new THREE.Mesh(standGeo, standMat);
        stand.position.y = 0.45;
        stand.castShadow = true;
        group.add(stand);
        
        // Base
        const baseGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.02, 16);
        const base = new THREE.Mesh(baseGeo, standMat);
        base.position.y = 0.3;
        base.receiveShadow = true;
        group.add(base);
      }
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createTVStand(spec) {
      const group = new THREE.Group();
      
      const style = spec.style || 'modern'; // 'modern', 'classic', 'minimal'
      const width = spec.width || 1.5;
      const height = 0.5;
      const depth = 0.4;
      
      const woodMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x654321,
        roughness: 0.7,
        metalness: 0.1
      });
      
      if (style === 'modern') {
        // Floating shelf style
        const topGeo = new THREE.BoxGeometry(width, 0.05, depth);
        const top = new THREE.Mesh(topGeo, woodMat);
        top.position.y = height;
        top.castShadow = true;
        top.receiveShadow = true;
        group.add(top);
        
        // Two compartments
        const dividerGeo = new THREE.BoxGeometry(0.02, height - 0.05, depth * 0.95);
        const divider = new THREE.Mesh(dividerGeo, woodMat);
        divider.position.y = height / 2;
        divider.castShadow = true;
        group.add(divider);
        
        // Sides
        const sideGeo = new THREE.BoxGeometry(0.02, height, depth);
        [-width/2 + 0.01, width/2 - 0.01].forEach(x => {
          const side = new THREE.Mesh(sideGeo, woodMat);
          side.position.set(x, height / 2, 0);
          side.castShadow = true;
          group.add(side);
        });
        
        // Back panel
        const backGeo = new THREE.BoxGeometry(width, height, 0.01);
        const back = new THREE.Mesh(backGeo, woodMat);
        back.position.set(0, height / 2, -depth / 2 + 0.005);
        back.castShadow = true;
        group.add(back);
        
      } else if (style === 'classic') {
        // Traditional cabinet with doors
        const bodyGeo = new THREE.BoxGeometry(width, height, depth);
        const body = new THREE.Mesh(bodyGeo, woodMat);
        body.position.y = height / 2;
        body.castShadow = true;
        body.receiveShadow = true;
        group.add(body);
        
        // Doors (two panels)
        const doorMat = new THREE.MeshStandardMaterial({
          color: 0x5a4321,
          roughness: 0.8
        });
        [-width/4, width/4].forEach(x => {
          const doorGeo = new THREE.BoxGeometry(width / 2 - 0.05, height * 0.8, 0.02);
          const door = new THREE.Mesh(doorGeo, doorMat);
          door.position.set(x, height / 2, depth / 2 + 0.01);
          door.castShadow = true;
          group.add(door);
          
          // Handles
          const handleGeo = new THREE.CylinderGeometry(0.008, 0.008, 0.04, 8);
          const handleMat = new THREE.MeshStandardMaterial({
            color: 0xccaa44,
            roughness: 0.3,
            metalness: 0.8
          });
          const handle = new THREE.Mesh(handleGeo, handleMat);
          handle.rotation.z = Math.PI / 2;
          handle.position.set(x + (x > 0 ? -0.15 : 0.15), height / 2, depth / 2 + 0.03);
          group.add(handle);
        });
        
      } else {
        // Minimal style - just a platform
        const platformGeo = new THREE.BoxGeometry(width, 0.08, depth);
        const platform = new THREE.Mesh(platformGeo, woodMat);
        platform.position.y = height;
        platform.castShadow = true;
        platform.receiveShadow = true;
        group.add(platform);
        
        // Four legs
        const legGeo = new THREE.CylinderGeometry(0.02, 0.02, height - 0.08, 12);
        [[-width/2 + 0.1, -depth/2 + 0.1], [width/2 - 0.1, -depth/2 + 0.1],
         [-width/2 + 0.1, depth/2 - 0.1], [width/2 - 0.1, depth/2 - 0.1]].forEach(([x, z]) => {
          const leg = new THREE.Mesh(legGeo, woodMat);
          leg.position.set(x, (height - 0.08) / 2, z);
          leg.castShadow = true;
          group.add(leg);
        });
      }
      
      group.position.set(spec.x * GRID_SIZE, 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createGameConsole(spec) {
      const group = new THREE.Group();
      
      const type = spec.consoleType || 'modern'; // 'modern', 'classic', 'handheld'
      
      if (type === 'modern') {
        // PlayStation/Xbox style
        const width = 0.3;
        const height = 0.05;
        const depth = 0.25;
        
        const consoleGeo = new THREE.BoxGeometry(width, height, depth);
        const consoleMat = new THREE.MeshStandardMaterial({
          color: spec.color || 0x1a1a1a,
          roughness: 0.5,
          metalness: 0.4
        });
        const console = new THREE.Mesh(consoleGeo, consoleMat);
        console.position.y = height / 2;
        console.castShadow = true;
        console.receiveShadow = true;
        group.add(console);
        
        // Power LED
        const ledGeo = new THREE.CircleGeometry(0.003, 12);
        const ledMat = new THREE.MeshStandardMaterial({
          color: 0x00ff00,
          emissive: 0x00ff00,
          emissiveIntensity: 0.6
        });
        const led = new THREE.Mesh(ledGeo, ledMat);
        led.position.set(-width * 0.3, height + 0.001, 0);
        led.rotation.x = -Math.PI / 2;
        group.add(led);
        
        // Disc slot
        const slotGeo = new THREE.BoxGeometry(0.12, 0.002, 0.001);
        const slotMat = new THREE.MeshStandardMaterial({
          color: 0x000000
        });
        const slot = new THREE.Mesh(slotGeo, slotMat);
        slot.position.set(0, height / 2, depth / 2 + 0.001);
        group.add(slot);
        
      } else {
        // Classic cartridge console
        const width = 0.35;
        const height = 0.08;
        const depth = 0.2;
        
        const consoleGeo = new THREE.BoxGeometry(width, height, depth);
        const consoleMat = new THREE.MeshStandardMaterial({
          color: 0x888888,
          roughness: 0.7
        });
        const console = new THREE.Mesh(consoleGeo, consoleMat);
        console.position.y = height / 2;
        console.castShadow = true;
        console.receiveShadow = true;
        group.add(console);
        
        // Cartridge slot on top
        const slotGeo = new THREE.BoxGeometry(0.15, 0.04, 0.1);
        const slotMat = new THREE.MeshStandardMaterial({
          color: 0x333333
        });
        const slot = new THREE.Mesh(slotGeo, slotMat);
        slot.position.y = height + 0.02;
        group.add(slot);
      }
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createDVD(spec) {
      const group = new THREE.Group();
      
      const radius = 0.06;
      const thickness = 0.0012;
      
      // Disc
      const discGeo = new THREE.CylinderGeometry(radius, radius, thickness, 32);
      const discMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xccccff,
        roughness: 0.2,
        metalness: 0.8
      });
      const disc = new THREE.Mesh(discGeo, discMat);
      disc.position.y = thickness / 2;
      disc.castShadow = true;
      disc.receiveShadow = true;
      group.add(disc);
      
      // Center hole
      const holeGeo = new THREE.CylinderGeometry(0.0075, 0.0075, thickness + 0.001, 16);
      const holeMat = new THREE.MeshStandardMaterial({
        color: 0x1a1a1a
      });
      const hole = new THREE.Mesh(holeGeo, holeMat);
      hole.position.y = thickness / 2;
      group.add(hole);
      
      // Label (top side)
      const labelGeo = new THREE.CircleGeometry(radius * 0.7, 32);
      const labelMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.9
      });
      const label = new THREE.Mesh(labelGeo, labelMat);
      label.rotation.x = -Math.PI / 2;
      label.position.y = thickness + 0.0001;
      group.add(label);
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createDVDCase(spec) {
      const group = new THREE.Group();
      
      const width = 0.135;
      const height = 0.19;
      const depth = 0.014;
      
      // Case
      const caseGeo = new THREE.BoxGeometry(width, height, depth);
      const caseMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x000000,
        roughness: 0.6,
        transparent: true,
        opacity: 0.9
      });
      const dvdCase = new THREE.Mesh(caseGeo, caseMat);
      dvdCase.position.y = height / 2;
      dvdCase.castShadow = true;
      dvdCase.receiveShadow = true;
      group.add(dvdCase);
      
      // Cover art (front)
      const artGeo = new THREE.PlaneGeometry(width * 0.95, height * 0.95);
      const artMat = new THREE.MeshStandardMaterial({
        color: spec.coverColor || 0x4466ff,
        roughness: 0.8
      });
      const art = new THREE.Mesh(artGeo, artMat);
      art.position.set(0, height / 2, depth / 2 + 0.001);
      group.add(art);
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createRemote(spec) {
      const group = new THREE.Group();
      
      const width = 0.05;
      const height = 0.18;
      const depth = 0.025;
      
      // Remote body (rounded rectangle)
      const bodyGeo = new THREE.BoxGeometry(width, height, depth, 2, 4, 2);
      // Round the corners
      const positions = bodyGeo.attributes.position;
      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const y = positions.getY(i);
        const z = positions.getZ(i);
        const factor = 0.92 + 0.08 * Math.sqrt(x*x/width/width + z*z/depth/depth);
        positions.setXYZ(i, x * factor, y, z * factor);
      }
      bodyGeo.computeVertexNormals();
      
      const bodyMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x2a2a2a,
        roughness: 0.7,
        metalness: 0.1
      });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = height / 2;
      body.castShadow = true;
      body.receiveShadow = true;
      group.add(body);
      
      // Buttons - Power button at top (red)
      const powerButtonGeo = new THREE.CylinderGeometry(0.007, 0.007, 0.003, 16);
      const powerButtonMat = new THREE.MeshStandardMaterial({
        color: 0xff3333,
        roughness: 0.4,
        emissive: 0x330000,
        emissiveIntensity: 0.2
      });
      const powerButton = new THREE.Mesh(powerButtonGeo, powerButtonMat);
      powerButton.rotation.x = Math.PI / 2;
      powerButton.position.set(0, height * 0.85, depth / 2 + 0.0015);
      group.add(powerButton);
      
      // Navigation D-pad (center)
      const buttonMat = new THREE.MeshStandardMaterial({
        color: 0x4a4a4a,
        roughness: 0.5
      });
      
      const dpadPositions = [
        [0, 0.012, 0],       // Up
        [0, -0.012, 0],      // Down
        [-0.012, 0, 0],      // Left
        [0.012, 0, 0],       // Right
        [0, 0, 0]            // Center (OK button)
      ];
      
      dpadPositions.forEach(([dx, dy, dz]) => {
        const buttonGeo = new THREE.CylinderGeometry(0.005, 0.005, 0.002, 12);
        const button = new THREE.Mesh(buttonGeo, buttonMat);
        button.rotation.x = Math.PI / 2;
        button.position.set(dx, height * 0.6 + dy, depth / 2 + 0.0012);
        group.add(button);
      });
      
      // Number pad (3x3 grid)
      for (let row = 0; row < 3; row++) {
        for (let col = 0; col < 3; col++) {
          const buttonGeo = new THREE.CylinderGeometry(0.004, 0.004, 0.0018, 12);
          const button = new THREE.Mesh(buttonGeo, buttonMat);
          button.rotation.x = Math.PI / 2;
          button.position.set(
            -width * 0.3 + col * width * 0.3,
            height * 0.35 - row * 0.022,
            depth / 2 + 0.0012
          );
          group.add(button);
        }
      }
      
      // Bottom control buttons (volume, channel, etc.)
      for (let i = 0; i < 4; i++) {
        const buttonGeo = new THREE.BoxGeometry(0.008, 0.015, 0.002);
        const button = new THREE.Mesh(buttonGeo, buttonMat);
        button.position.set(
          -width * 0.35 + i * (width * 0.23),
          height * 0.15,
          depth / 2 + 0.0012
        );
        group.add(button);
      }
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createCoffeeTable(spec) {
      const shape = spec.shape || 'rectangle';
      const group = new THREE.Group();
      
      const tableMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x8b7355,
        roughness: 0.7,
        metalness: 0.1
      });
      
      const tableHeight = 0.4;
      const thickness = 0.04;
      
      // Tabletop based on shape
      let topGeo;
      if (shape === 'square') {
        topGeo = new THREE.BoxGeometry(0.8, thickness, 0.8);
      } else if (shape === 'circle') {
        topGeo = new THREE.CylinderGeometry(0.4, 0.4, thickness, 32);
      } else {
        topGeo = new THREE.BoxGeometry(1.2, thickness, 0.6);
      }
      
      const top = new THREE.Mesh(topGeo, tableMat);
      top.position.y = tableHeight;
      top.castShadow = true;
      top.receiveShadow = true;
      group.add(top);
      
      // Legs (4 legs)
      const legGeo = new THREE.CylinderGeometry(0.02, 0.025, tableHeight - thickness, 8);
      const legMat = new THREE.MeshStandardMaterial({
        color: 0x654321,
        roughness: 0.8
      });
      
      const positions = shape === 'circle' 
        ? [[0.3, 0, 0.3], [-0.3, 0, 0.3], [0.3, 0, -0.3], [-0.3, 0, -0.3]]
        : shape === 'square'
        ? [[0.35, 0, 0.35], [-0.35, 0, 0.35], [0.35, 0, -0.35], [-0.35, 0, -0.35]]
        : [[0.55, 0, 0.25], [-0.55, 0, 0.25], [0.55, 0, -0.25], [-0.55, 0, -0.25]];
      
      positions.forEach(([x, y, z]) => {
        const leg = new THREE.Mesh(legGeo, legMat);
        leg.position.set(x, (tableHeight - thickness) / 2, z);
        leg.castShadow = true;
        group.add(leg);
      });
      
      group.position.set(spec.x * GRID_SIZE, 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    // ==================== GAME PIECES ====================
    
    function createPlayingCard(spec) {
      const group = new THREE.Group();
      
      const cardWidth = 0.064;
      const cardHeight = 0.089;
      const cardThickness = 0.001;
      
      // Card body
      const cardGeo = new THREE.BoxGeometry(cardWidth, cardThickness, cardHeight);
      const cardMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.6
      });
      const card = new THREE.Mesh(cardGeo, cardMat);
      card.rotation.x = Math.PI / 2;
      card.position.y = cardThickness / 2;
      card.castShadow = true;
      card.receiveShadow = true;
      group.add(card);
      
      // Card back (simple pattern)
      const backGeo = new THREE.PlaneGeometry(cardWidth * 0.9, cardHeight * 0.9);
      const backMat = new THREE.MeshStandardMaterial({
        color: spec.suit === 'red' ? 0xff3333 : 0x3333ff,
        roughness: 0.7
      });
      const back = new THREE.Mesh(backGeo, backMat);
      back.position.y = cardThickness + 0.0001;
      back.rotation.x = -Math.PI / 2;
      group.add(back);
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createDice(spec) {
      const group = new THREE.Group();
      
      const size = spec.size || 0.015;
      const halfSize = size / 2;
      
      // Create rounded cube using merged geometry for barrel distortion effect
      const diceGeo = new THREE.BoxGeometry(size, size, size, 4, 4, 4);
      
      // Apply subtle barrel distortion to vertices
      const positions = diceGeo.attributes.position;
      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const y = positions.getY(i);
        const z = positions.getZ(i);
        
        // Normalize and apply barrel distortion
        const dist = Math.sqrt(x*x + y*y + z*z);
        if (dist > 0) {
          const factor = 1 + 0.08 * (dist / halfSize - 1);
          positions.setXYZ(i, x * factor, y * factor, z * factor);
        }
      }
      positions.needsUpdate = true;
      diceGeo.computeVertexNormals();
      
      const diceMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xffffff,
        roughness: 0.3,
        metalness: 0.1
      });
      const dice = new THREE.Mesh(diceGeo, diceMat);
      dice.position.y = size / 2;
      dice.castShadow = true;
      dice.receiveShadow = true;
      
      // Random rotation for natural look
      dice.rotation.set(
        Math.random() * Math.PI,
        Math.random() * Math.PI,
        Math.random() * Math.PI
      );
      
      group.add(dice);
      
      // Pip configurations for dice faces (1-6)
      const pipPatterns = {
        1: [[0, 0]], // center
        2: [[-0.25, -0.25], [0.25, 0.25]], // diagonal
        3: [[-0.25, -0.25], [0, 0], [0.25, 0.25]], // diagonal with center
        4: [[-0.25, -0.25], [0.25, -0.25], [-0.25, 0.25], [0.25, 0.25]], // corners
        5: [[-0.25, -0.25], [0.25, -0.25], [0, 0], [-0.25, 0.25], [0.25, 0.25]], // corners + center
        6: [[-0.25, -0.25], [0.25, -0.25], [-0.25, 0], [0.25, 0], [-0.25, 0.25], [0.25, 0.25]] // two columns
      };
      
      // Add pips to each face (scooped indentations)
      const pipRadius = size * 0.08;
      const pipDepth = size * 0.12;
      const pipMat = new THREE.MeshStandardMaterial({ 
        color: 0x000000,
        roughness: 0.8
      });
      
      // Face orientations: [rotation, position, pips]
      const faces = [
        { rot: [0, 0, 0], pos: [0, halfSize, 0], pips: 1 }, // top
        { rot: [Math.PI, 0, 0], pos: [0, -halfSize, 0], pips: 6 }, // bottom
        { rot: [Math.PI/2, 0, 0], pos: [0, 0, halfSize], pips: 2 }, // front
        { rot: [-Math.PI/2, 0, 0], pos: [0, 0, -halfSize], pips: 5 }, // back
        { rot: [0, 0, Math.PI/2], pos: [halfSize, 0, 0], pips: 3 }, // right
        { rot: [0, 0, -Math.PI/2], pos: [-halfSize, 0, 0], pips: 4 } // left
      ];
      
      faces.forEach(face => {
        const pattern = pipPatterns[face.pips];
        pattern.forEach(([px, pz]) => {
          // Create scooped pip using hemisphere
          const pipGeo = new THREE.SphereGeometry(pipRadius, 12, 8, 0, Math.PI * 2, 0, Math.PI / 2);
          const pip = new THREE.Mesh(pipGeo, pipMat);
          
          // Position on face
          pip.position.set(
            face.pos[0] + px * size,
            face.pos[1] + pz * size,
            face.pos[2]
          );
          
          // Rotate to align with face and point inward
          pip.rotation.set(...face.rot);
          pip.rotation.x += Math.PI; // flip to point inward
          
          // Offset slightly inward for scooped effect
          const offset = new THREE.Vector3(0, -pipDepth, 0);
          offset.applyEuler(new THREE.Euler(...face.rot));
          pip.position.add(offset);
          
          dice.add(pip);
        });
      });
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createPokerChip(spec) {
      const group = new THREE.Group();
      
      const radius = 0.02;
      const thickness = 0.003;
      
      // Chip body
      const chipGeo = new THREE.CylinderGeometry(radius, radius, thickness, 32);
      const chipMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xff3333,
        roughness: 0.5,
        metalness: 0.2
      });
      const chip = new THREE.Mesh(chipGeo, chipMat);
      chip.position.y = thickness / 2;
      chip.castShadow = true;
      chip.receiveShadow = true;
      group.add(chip);
      
      // Edge decoration (white ring)
      const ringGeo = new THREE.TorusGeometry(radius * 0.9, thickness * 0.3, 8, 32);
      const ringMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.6
      });
      const ring = new THREE.Mesh(ringGeo, ringMat);
      ring.rotation.x = Math.PI / 2;
      ring.position.y = thickness / 2;
      group.add(ring);
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createGameBoard(spec) {
      const group = new THREE.Group();
      
      const boardSize = spec.size || 0.5;
      const boardThickness = 0.015;
      const variant = spec.variant || 'checkers'; // 'checkers' or 'chess'
      
      // Board base with beveled edge
      const boardGeo = new THREE.BoxGeometry(boardSize, boardThickness, boardSize);
      const boardMat = new THREE.MeshStandardMaterial({
        color: 0xe8dcc0,
        roughness: 0.8
      });
      const board = new THREE.Mesh(boardGeo, boardMat);
      board.position.y = boardThickness / 2;
      board.castShadow = true;
      board.receiveShadow = true;
      group.add(board);
      
      // Border frame (decorative)
      const frameThickness = boardSize * 0.05;
      const frameGeo = new THREE.BoxGeometry(boardSize + frameThickness, boardThickness * 0.5, frameThickness);
      const frameMat = new THREE.MeshStandardMaterial({
        color: 0x654321,
        roughness: 0.7
      });
      
      // Four sides of frame
      [-boardSize/2, boardSize/2].forEach(z => {
        const frame = new THREE.Mesh(frameGeo, frameMat);
        frame.position.set(0, boardThickness * 0.75, z);
        frame.castShadow = true;
        group.add(frame);
      });
      
      const frameGeo2 = new THREE.BoxGeometry(frameThickness, boardThickness * 0.5, boardSize);
      [-boardSize/2, boardSize/2].forEach(x => {
        const frame = new THREE.Mesh(frameGeo2, frameMat);
        frame.position.set(x, boardThickness * 0.75, 0);
        frame.castShadow = true;
        group.add(frame);
      });
      
      // Checkerboard/chessboard pattern
      const squareSize = boardSize / 8;
      const squareThickness = 0.002;
      const squareGeo = new THREE.BoxGeometry(squareSize * 0.98, squareThickness, squareSize * 0.98);
      
      // Colors based on variant
      const darkColor = variant === 'chess' ? 0x3a2a1a : 0x000000; // Black for checkers
      const lightColor = variant === 'chess' ? 0xf4e4d4 : 0xcc0000; // Red for checkers
      
      const darkMat = new THREE.MeshStandardMaterial({
        color: darkColor,
        roughness: variant === 'chess' ? 0.6 : 0.9,
        metalness: variant === 'chess' ? 0.1 : 0
      });
      const lightMat = new THREE.MeshStandardMaterial({
        color: lightColor,
        roughness: variant === 'chess' ? 0.6 : 0.9,
        metalness: variant === 'chess' ? 0.1 : 0
      });
      
      for (let x = 0; x < 8; x++) {
        for (let z = 0; z < 8; z++) {
          const isDark = (x + z) % 2 === 0;
          const square = new THREE.Mesh(squareGeo, isDark ? darkMat : lightMat);
          square.position.set(
            -boardSize / 2 + x * squareSize + squareSize / 2,
            boardThickness + squareThickness / 2,
            -boardSize / 2 + z * squareSize + squareSize / 2
          );
          square.castShadow = true;
          square.receiveShadow = true;
          group.add(square);
        }
      }
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    // ==================== CHESS PIECES ====================
    
    function createChessPawn(spec) {
      const group = new THREE.Group();
      
      const scale = spec.scale || 1.0;
      const baseRadius = 0.015 * scale;
      const height = 0.05 * scale;
      
      const pawnMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xffffff,
        roughness: 0.4,
        metalness: 0.1
      });
      
      // Base (wider disk)
      const baseGeo = new THREE.CylinderGeometry(baseRadius * 1.2, baseRadius * 1.3, height * 0.15, 24);
      const base = new THREE.Mesh(baseGeo, pawnMat);
      base.position.y = height * 0.075;
      base.castShadow = true;
      base.receiveShadow = true;
      group.add(base);
      
      // Stem (tapered cylinder)
      const stemGeo = new THREE.CylinderGeometry(baseRadius * 0.5, baseRadius * 0.9, height * 0.5, 16);
      const stem = new THREE.Mesh(stemGeo, pawnMat);
      stem.position.y = height * 0.4;
      stem.castShadow = true;
      group.add(stem);
      
      // Collar (wider ring)
      const collarGeo = new THREE.CylinderGeometry(baseRadius * 0.75, baseRadius * 0.75, height * 0.1, 16);
      const collar = new THREE.Mesh(collarGeo, pawnMat);
      collar.position.y = height * 0.65;
      collar.castShadow = true;
      group.add(collar);
      
      // Head (sphere)
      const headGeo = new THREE.SphereGeometry(baseRadius * 0.6, 24, 16);
      const head = new THREE.Mesh(headGeo, pawnMat);
      head.position.y = height * 0.85;
      head.castShadow = true;
      group.add(head);
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    // ==================== SIDE TABLES & LAMPS ====================
    
    function createSideTable(spec) {
      const group = new THREE.Group();
      
      const tableWidth = 0.45;
      const tableDepth = 0.45;
      const tableHeight = 0.55;
      const topThickness = 0.04;
      
      const woodMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x8b7355,
        roughness: 0.7,
        metalness: 0.1
      });
      
      // Top surface
      const topGeo = new THREE.BoxGeometry(tableWidth, topThickness, tableDepth);
      const top = new THREE.Mesh(topGeo, woodMat);
      top.position.y = tableHeight;
      top.castShadow = true;
      top.receiveShadow = true;
      group.add(top);
      
      // Legs (4 tapered legs)
      const legGeo = new THREE.CylinderGeometry(0.02, 0.025, tableHeight - topThickness, 12);
      const legPositions = [
        [tableWidth * 0.4, 0, tableDepth * 0.4],
        [-tableWidth * 0.4, 0, tableDepth * 0.4],
        [tableWidth * 0.4, 0, -tableDepth * 0.4],
        [-tableWidth * 0.4, 0, -tableDepth * 0.4]
      ];
      
      legPositions.forEach(([x, y, z]) => {
        const leg = new THREE.Mesh(legGeo, woodMat);
        leg.position.set(x, (tableHeight - topThickness) / 2, z);
        leg.castShadow = true;
        group.add(leg);
      });
      
      // Lower shelf
      const shelfGeo = new THREE.BoxGeometry(tableWidth * 0.9, topThickness * 0.5, tableDepth * 0.9);
      const shelf = new THREE.Mesh(shelfGeo, woodMat);
      shelf.position.y = tableHeight * 0.3;
      shelf.castShadow = true;
      shelf.receiveShadow = true;
      group.add(shelf);
      
      group.position.set(spec.x * GRID_SIZE, 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createFloorLamp(spec) {
      const group = new THREE.Group();
      
      const lampHeight = 1.6;
      const baseRadius = 0.15;
      
      const metalMat = new THREE.MeshStandardMaterial({
        color: 0x3a3a3a,
        roughness: 0.4,
        metalness: 0.8
      });
      
      // Base (wide, heavy disk)
      const baseGeo = new THREE.CylinderGeometry(baseRadius, baseRadius * 1.1, 0.04, 32);
      const base = new THREE.Mesh(baseGeo, metalMat);
      base.position.y = 0.02;
      base.castShadow = true;
      base.receiveShadow = true;
      group.add(base);
      
      // Pole (thin cylinder)
      const poleGeo = new THREE.CylinderGeometry(0.015, 0.018, lampHeight - 0.3, 16);
      const pole = new THREE.Mesh(poleGeo, metalMat);
      pole.position.y = (lampHeight - 0.3) / 2 + 0.04;
      pole.castShadow = true;
      group.add(pole);
      
      // Shade holder (small sphere joint)
      const jointGeo = new THREE.SphereGeometry(0.025, 16, 16);
      const joint = new THREE.Mesh(jointGeo, metalMat);
      joint.position.y = lampHeight - 0.28;
      joint.castShadow = true;
      group.add(joint);
      
      // Lampshade (cone/frustum) - wider at bottom, narrow at top
      const shadeGeo = new THREE.CylinderGeometry(0.15, 0.25, 0.3, 32);
      const shadeMat = new THREE.MeshStandardMaterial({
        color: spec.shadeColor || 0xe8d4b0,
        roughness: 0.8,
        emissive: spec.lit ? 0xfff4e0 : 0x000000,
        emissiveIntensity: spec.lit ? 0.3 : 0
      });
      const shade = new THREE.Mesh(shadeGeo, shadeMat);
      shade.position.y = lampHeight - 0.15;
      shade.castShadow = true;
      group.add(shade);
      
      // Light bulb (sphere inside shade)
      const bulbGeo = new THREE.SphereGeometry(0.04, 16, 16);
      const bulbMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        emissive: spec.lit ? 0xfff4e0 : 0xffff99,
        emissiveIntensity: spec.lit ? 1.0 : 0.2,
        roughness: 0.3
      });
      const bulb = new THREE.Mesh(bulbGeo, bulbMat);
      bulb.position.y = lampHeight - 0.15;
      group.add(bulb);
      
      // Optional: Add point light if lamp is lit
      if (spec.lit) {
        const light = new THREE.PointLight(0xfff4e0, 0.8, 3);
        light.position.y = lampHeight - 0.15;
        light.castShadow = true;
        group.add(light);
      }
      
      group.position.set(spec.x * GRID_SIZE, 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createAlarmClock(spec) {
      const group = new THREE.Group();
      
      const width = 0.12;
      const height = 0.1;
      const depth = 0.05;
      
      const clockMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xff4444,
        roughness: 0.6,
        metalness: 0.3
      });
      
      // Main body (rounded box)
      const bodyGeo = new THREE.BoxGeometry(width, height, depth, 4, 4, 4);
      // Round the corners slightly
      const positions = bodyGeo.attributes.position;
      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const y = positions.getY(i);
        const z = positions.getZ(i);
        const factor = 0.95 + 0.05 * Math.sqrt(x*x/width/width + y*y/height/height + z*z/depth/depth);
        positions.setXYZ(i, x * factor, y * factor, z * factor);
      }
      bodyGeo.computeVertexNormals();
      
      const body = new THREE.Mesh(bodyGeo, clockMat);
      body.position.y = height / 2;
      body.castShadow = true;
      body.receiveShadow = true;
      group.add(body);
      
      // Clock face (screen)
      const faceGeo = new THREE.PlaneGeometry(width * 0.7, height * 0.5);
      const faceMat = new THREE.MeshStandardMaterial({
        color: 0x001100,
        emissive: 0x00ff00,
        emissiveIntensity: 0.6,
        roughness: 0.2
      });
      const face = new THREE.Mesh(faceGeo, faceMat);
      face.position.set(0, height * 0.55, depth / 2 + 0.001);
      group.add(face);
      
      // Bell tops (two small domes)
      const bellGeo = new THREE.SphereGeometry(0.02, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2);
      const bellMat = new THREE.MeshStandardMaterial({
        color: 0xccaa44,
        roughness: 0.3,
        metalness: 0.8
      });
      
      [-width * 0.4, width * 0.4].forEach(x => {
        const bell = new THREE.Mesh(bellGeo, bellMat);
        bell.position.set(x, height + 0.01, 0);
        bell.castShadow = true;
        group.add(bell);
        
        // Bell support (tiny cylinder)
        const supportGeo = new THREE.CylinderGeometry(0.003, 0.003, 0.02, 8);
        const support = new THREE.Mesh(supportGeo, bellMat);
        support.position.set(x, height - 0.01, 0);
        group.add(support);
      });
      
      // Connecting wire between bells
      const wireGeo = new THREE.CylinderGeometry(0.002, 0.002, width * 0.8, 8);
      const wire = new THREE.Mesh(wireGeo, bellMat);
      wire.rotation.z = Math.PI / 2;
      wire.position.y = height + 0.01;
      group.add(wire);
      
      // Feet (small rubber pads)
      const footGeo = new THREE.CylinderGeometry(0.01, 0.01, 0.005, 8);
      const footMat = new THREE.MeshStandardMaterial({
        color: 0x1a1a1a,
        roughness: 0.9
      });
      
      [[-width * 0.35, -depth * 0.35], [width * 0.35, -depth * 0.35],
       [-width * 0.35, depth * 0.35], [width * 0.35, depth * 0.35]].forEach(([x, z]) => {
        const foot = new THREE.Mesh(footGeo, footMat);
        foot.position.set(x, 0.0025, z);
        group.add(foot);
      });
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    // ==================== COMPUTER DESK ====================
    
    function createComputerDesk(spec) {
      const group = new THREE.Group();
      
      const deskWidth = 1.5;
      const deskDepth = 0.75;
      const deskHeight = 0.75;
      
      const woodMat = new THREE.MeshStandardMaterial({
        color: 0x8b7355,
        roughness: 0.7
      });
      
      // Desk surface
      const surfaceGeo = new THREE.BoxGeometry(deskWidth, 0.05, deskDepth);
      const surface = new THREE.Mesh(surfaceGeo, woodMat);
      surface.position.y = deskHeight;
      surface.castShadow = true;
      surface.receiveShadow = true;
      group.add(surface);
      
      // Legs
      const legGeo = new THREE.CylinderGeometry(0.03, 0.03, deskHeight - 0.05, 12);
      const legMat = new THREE.MeshStandardMaterial({
        color: 0x654321,
        roughness: 0.8
      });
      
      [[0.7, 0.35], [-0.7, 0.35], [0.7, -0.35], [-0.7, -0.35]].forEach(([x, z]) => {
        const leg = new THREE.Mesh(legGeo, legMat);
        leg.position.set(x, (deskHeight - 0.05) / 2, z);
        leg.castShadow = true;
        group.add(leg);
      });
      
      // Monitor
      const monitorGroup = new THREE.Group();
      
      // Screen
      const screenWidth = 0.5;
      const screenHeight = 0.3;
      const screenGeo = new THREE.BoxGeometry(screenWidth, screenHeight, 0.02);
      const screenMat = new THREE.MeshStandardMaterial({
        color: 0x1a1a1a,
        roughness: 0.2,
        metalness: 0.7
      });
      const screen = new THREE.Mesh(screenGeo, screenMat);
      screen.position.set(0, screenHeight / 2 + 0.05, 0);
      screen.castShadow = true;
      monitorGroup.add(screen);
      
      // Monitor bezel
      const bezelGeo = new THREE.BoxGeometry(screenWidth + 0.02, screenHeight + 0.02, 0.015);
      const bezelMat = new THREE.MeshStandardMaterial({
        color: 0x2a2a2a,
        roughness: 0.6
      });
      const bezel = new THREE.Mesh(bezelGeo, bezelMat);
      bezel.position.set(0, screenHeight / 2 + 0.05, -0.01);
      bezel.castShadow = true;
      monitorGroup.add(bezel);
      
      // Monitor stand
      const standGeo = new THREE.CylinderGeometry(0.03, 0.04, 0.08, 12);
      const standMat = new THREE.MeshStandardMaterial({
        color: 0x3a3a3a,
        roughness: 0.7
      });
      const stand = new THREE.Mesh(standGeo, standMat);
      stand.position.y = 0.04;
      stand.castShadow = true;
      monitorGroup.add(stand);
      
      monitorGroup.position.set(0, deskHeight + 0.025, -deskDepth / 4);
      group.add(monitorGroup);
      
      // Keyboard
      const keyboardGroup = new THREE.Group();
      
      const keyboardGeo = new THREE.BoxGeometry(0.45, 0.02, 0.15);
      const keyboardMat = new THREE.MeshStandardMaterial({
        color: 0x2a2a2a,
        roughness: 0.7
      });
      const keyboard = new THREE.Mesh(keyboardGeo, keyboardMat);
      keyboard.position.y = 0.01;
      keyboard.castShadow = true;
      keyboard.receiveShadow = true;
      keyboardGroup.add(keyboard);
      
      // Keys (simplified grid)
      const keySize = 0.012;
      const keyGeo = new THREE.BoxGeometry(keySize, 0.005, keySize);
      const keyMat = new THREE.MeshStandardMaterial({
        color: 0x4a4a4a,
        roughness: 0.5
      });
      
      for (let row = 0; row < 4; row++) {
        for (let col = 0; col < 10; col++) {
          const key = new THREE.Mesh(keyGeo, keyMat);
          key.position.set(
            -0.2 + col * 0.04 + 0.02,
            0.0125,
            -0.06 + row * 0.03 + 0.015
          );
          key.castShadow = true;
          keyboardGroup.add(key);
        }
      }
      
      keyboardGroup.position.set(0, deskHeight + 0.025, deskDepth / 4);
      group.add(keyboardGroup);
      
      group.position.set(spec.x * GRID_SIZE, 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    // ==================== CLOSET & DOORS ====================
    
    function createCloset(spec) {
      const group = new THREE.Group();
      
      const closetWidth = spec.width || 1.5;
      const closetDepth = 0.6;
      const closetHeight = 2.3;
      
      // Back and side walls
      const wallMat = new THREE.MeshStandardMaterial({
        color: 0xf0e6d2,
        roughness: 0.9
      });
      
      // Back wall
      const backWallGeo = new THREE.BoxGeometry(closetWidth, closetHeight, 0.1);
      const backWall = new THREE.Mesh(backWallGeo, wallMat);
      backWall.position.set(0, closetHeight / 2, -closetDepth / 2);
      backWall.castShadow = true;
      backWall.receiveShadow = true;
      group.add(backWall);
      
      // Side walls
      const sideWallGeo = new THREE.BoxGeometry(0.1, closetHeight, closetDepth);
      const leftWall = new THREE.Mesh(sideWallGeo, wallMat);
      leftWall.position.set(-closetWidth / 2, closetHeight / 2, 0);
      leftWall.castShadow = true;
      group.add(leftWall);
      
      const rightWall = new THREE.Mesh(sideWallGeo, wallMat);
      rightWall.position.set(closetWidth / 2, closetHeight / 2, 0);
      rightWall.castShadow = true;
      group.add(rightWall);
      
      // Door (hinged)
      const doorGroup = new THREE.Group();
      const doorMat = new THREE.MeshStandardMaterial({
        color: 0x8b7355,
        roughness: 0.8
      });
      
      const doorGeo = new THREE.BoxGeometry(closetWidth * 0.95, 2.0, 0.05);
      const door = new THREE.Mesh(doorGeo, doorMat);
      door.position.x = closetWidth * 0.475;
      door.position.y = 1.0;
      door.castShadow = true;
      doorGroup.add(door);
      
      // Door handle
      const handleGeo = new THREE.CylinderGeometry(0.015, 0.015, 0.08, 8);
      const handleMat = new THREE.MeshStandardMaterial({
        color: 0xc0c0c0,
        roughness: 0.3,
        metalness: 0.8
      });
      const handle = new THREE.Mesh(handleGeo, handleMat);
      handle.rotation.z = Math.PI / 2;
      handle.position.set(closetWidth * 0.4, 1.0, 0.03);
      doorGroup.add(handle);
      
      doorGroup.position.set(-closetWidth / 2, 0, closetDepth / 2);
      doorGroup.userData.isClosetDoor = true;
      doorGroup.userData.isOpen = false;
      group.add(doorGroup);
      
      // Register as interactive
      interactiveObjects.push(doorGroup);
      
      group.position.set(spec.x * GRID_SIZE, 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createEntranceDoor(spec) {
      const group = new THREE.Group();
      
      const doorWidth = 1.0;
      const doorHeight = 2.0;
      const crackHeight = 0.02; // Small crack at bottom
      
      // Door frame
      const frameMat = new THREE.MeshStandardMaterial({
        color: 0x8b7355,
        roughness: 0.8
      });
      
      // Door panel (hinged group)
      const doorGroup = new THREE.Group();
      const doorGeo = new THREE.BoxGeometry(doorWidth, doorHeight - crackHeight, 0.05);
      const door = new THREE.Mesh(doorGeo, frameMat);
      door.position.x = doorWidth / 2;
      door.position.y = (doorHeight - crackHeight) / 2 + crackHeight;
      door.castShadow = true;
      doorGroup.add(door);
      
      // Door handle
      const handleGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.1, 8);
      const handleMat = new THREE.MeshStandardMaterial({
        color: 0xc0c0c0,
        roughness: 0.3,
        metalness: 0.8
      });
      const handle = new THREE.Mesh(handleGeo, handleMat);
      handle.rotation.z = Math.PI / 2;
      handle.position.set(doorWidth * 0.85, 1.0, 0.03);
      doorGroup.add(handle);
      
      doorGroup.userData.isEntranceDoor = true;
      doorGroup.userData.isOpen = false;
      group.add(doorGroup);
      
      // Register as interactive
      interactiveObjects.push(doorGroup);
      
      // Door frame sides and top
      const frameThick = 0.08;
      const leftFrameGeo = new THREE.BoxGeometry(frameThick, doorHeight, frameThick);
      const leftFrame = new THREE.Mesh(leftFrameGeo, frameMat);
      leftFrame.position.set(-frameThick / 2, doorHeight / 2, 0);
      leftFrame.castShadow = true;
      group.add(leftFrame);
      
      const rightFrame = new THREE.Mesh(leftFrameGeo, frameMat);
      rightFrame.position.set(doorWidth + frameThick / 2, doorHeight / 2, 0);
      rightFrame.castShadow = true;
      group.add(rightFrame);
      
      const topFrameGeo = new THREE.BoxGeometry(doorWidth + frameThick * 2, frameThick, frameThick);
      const topFrame = new THREE.Mesh(topFrameGeo, frameMat);
      topFrame.position.set(doorWidth / 2, doorHeight, 0);
      topFrame.castShadow = true;
      group.add(topFrame);
      
      group.position.set(spec.x * GRID_SIZE, 0, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    // ==================== ART & DECORATIONS ====================
    
    function generateAbstractArt() {
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 256;
      const ctx = canvas.getContext('2d');
      
      // Random background
      const hue = Math.random() * 360;
      ctx.fillStyle = `hsl(${hue}, 70%, 85%)`;
      ctx.fillRect(0, 0, 256, 256);
      
      // Random shapes
      const shapeCount = 5 + Math.floor(Math.random() * 10);
      for (let i = 0; i < shapeCount; i++) {
        ctx.fillStyle = `hsla(${Math.random() * 360}, 70%, 50%, 0.7)`;
        const shapeType = Math.floor(Math.random() * 3);
        
        if (shapeType === 0) {
          // Circle
          ctx.beginPath();
          ctx.arc(
            Math.random() * 256,
            Math.random() * 256,
            20 + Math.random() * 60,
            0,
            Math.PI * 2
          );
          ctx.fill();
        } else if (shapeType === 1) {
          // Rectangle
          ctx.fillRect(
            Math.random() * 256,
            Math.random() * 256,
            30 + Math.random() * 80,
            30 + Math.random() * 80
          );
        } else {
          // Triangle
          ctx.beginPath();
          ctx.moveTo(Math.random() * 256, Math.random() * 256);
          ctx.lineTo(Math.random() * 256, Math.random() * 256);
          ctx.lineTo(Math.random() * 256, Math.random() * 256);
          ctx.closePath();
          ctx.fill();
        }
      }
      
      // Random lines/strokes
      ctx.strokeStyle = `hsla(${(hue + 180) % 360}, 60%, 30%, 0.5)`;
      ctx.lineWidth = 2 + Math.random() * 4;
      for (let i = 0; i < 3; i++) {
        ctx.beginPath();
        ctx.moveTo(Math.random() * 256, Math.random() * 256);
        ctx.lineTo(Math.random() * 256, Math.random() * 256);
        ctx.stroke();
      }
      
      return new THREE.CanvasTexture(canvas);
    }
    
    function createArtFrame(spec) {
      const group = new THREE.Group();
      
      // Size variations: small, medium, large
      const size = spec.size || 'medium';
      const sizes = {
        small: { width: 0.3, height: 0.4 },
        medium: { width: 0.5, height: 0.6 },
        large: { width: 0.8, height: 1.0 }
      };
      
      const frameWidth = sizes[size].width;
      const frameHeight = sizes[size].height;
      const frameDepth = 0.03;
      
      // Frame border
      const frameMat = new THREE.MeshStandardMaterial({
        color: spec.frameColor || 0x3d2817,
        roughness: 0.7
      });
      const frameGeo = new THREE.BoxGeometry(frameWidth, frameHeight, frameDepth);
      const frame = new THREE.Mesh(frameGeo, frameMat);
      frame.castShadow = true;
      group.add(frame);
      
      // Art canvas (with generated abstract art)
      const artTexture = generateAbstractArt();
      const artMat = new THREE.MeshStandardMaterial({ map: artTexture });
      const artGeo = new THREE.PlaneGeometry(frameWidth * 0.85, frameHeight * 0.85);
      const art = new THREE.Mesh(artGeo, artMat);
      art.position.z = frameDepth / 2 + 0.001;
      group.add(art);
      
      const defaultY = size === 'large' ? 1.6 : size === 'medium' ? 1.5 : 1.4;
      group.position.set(spec.x * GRID_SIZE, spec.y || defaultY, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      // If wall-mounted, rotate to face outward
      if (spec.wallMount) {
        group.rotation.y = spec.rotation || 0;
      }
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    function createWallClock(spec) {
      const group = new THREE.Group();
      
      // Clock body (cylinder)
      const bodyGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.05, 32);
      const bodyMat = new THREE.MeshStandardMaterial({
        color: 0x2a2a2a,
        roughness: 0.5,
        metalness: 0.3
      });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.rotation.x = Math.PI / 2;
      body.castShadow = true;
      group.add(body);
      
      // Clock face
      const faceGeo = new THREE.CircleGeometry(0.14, 32);
      const faceMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.8
      });
      const face = new THREE.Mesh(faceGeo, faceMat);
      face.position.z = 0.026;
      group.add(face);
      
      // Hour markers (small rectangles)
      const markerMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
      for (let i = 0; i < 12; i++) {
        const angle = (i / 12) * Math.PI * 2 - Math.PI / 2;
        const markerGeo = new THREE.BoxGeometry(0.01, 0.03, 0.01);
        const marker = new THREE.Mesh(markerGeo, markerMat);
        marker.position.set(
          Math.cos(angle) * 0.11,
          Math.sin(angle) * 0.11,
          0.03
        );
        marker.rotation.z = angle + Math.PI / 2;
        group.add(marker);
      }
      
      // Hour hand
      const hourGeo = new THREE.BoxGeometry(0.05, 0.01, 0.005);
      const hour = new THREE.Mesh(hourGeo, markerMat);
      hour.position.set(0.025, 0, 0.032);
      group.add(hour);
      
      // Minute hand
      const minuteGeo = new THREE.BoxGeometry(0.08, 0.008, 0.005);
      const minute = new THREE.Mesh(minuteGeo, markerMat);
      minute.position.set(0.04, 0, 0.034);
      minute.rotation.z = Math.PI / 4;
      group.add(minute);
      
      group.position.set(spec.x * GRID_SIZE, spec.y || 1.8, spec.z * GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      
      scene.add(group);
      roomObjects.push(group);
    }
    
    // ==================== INTERACTION SYSTEM ====================
    
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    
    function onMouseClick(event) {
      if (!controls.isLocked) return;
      
      // Center of screen when pointer locked
      mouse.x = 0;
      mouse.y = 0;
      
      raycaster.setFromCamera(mouse, camera);
      
      // Check interactive objects
      const intersects = raycaster.intersectObjects(interactiveObjects, true);
      
      if (intersects.length > 0) {
        let object = intersects[0].object;
        
        // Find parent group with userData
        while (object && !object.userData.isLid && !object.userData.isClosetDoor && !object.userData.isEntranceDoor) {
          object = object.parent;
        }
        
        if (object) {
          if (object.userData.isLid) {
            toggleToiletLid(object);
          } else if (object.userData.isClosetDoor) {
            toggleDoor(object, 90);
          } else if (object.userData.isEntranceDoor) {
            toggleDoor(object, 90);
          }
        }
      }
    }
    
    function toggleToiletLid(lidGroup) {
      const isOpen = lidGroup.userData.isOpen;
      const targetRotation = isOpen ? 0 : -Math.PI * 0.55; // Open upward/backward (negative for up)
      
      // Animate lid rotation
      const startRotation = lidGroup.rotation.x;
      const duration = 500; // ms
      const startTime = Date.now();
      
      function animate() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const eased = 1 - Math.pow(1 - progress, 3); // Ease out cubic
        
        lidGroup.rotation.x = startRotation + (targetRotation - startRotation) * eased;
        
        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          lidGroup.userData.isOpen = !isOpen;
        }
      }
      
      animate();
    }
    
    function toggleDoor(doorGroup, maxAngle) {
      const isOpen = doorGroup.userData.isOpen;
      const targetRotation = isOpen ? 0 : (maxAngle * Math.PI / 180);
      
      // Animate door rotation
      const startRotation = doorGroup.rotation.y;
      const duration = 600; // ms
      const startTime = Date.now();
      
      function animate() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const eased = 1 - Math.pow(1 - progress, 3); // Ease out cubic
        
        doorGroup.rotation.y = startRotation + (targetRotation - startRotation) * eased;
        
        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          doorGroup.userData.isOpen = !isOpen;
        }
      }
      
      animate();
    }
    
    // ==================== ASSET LIBRARY & SPAWNING ====================
    
    const ASSET_LIBRARY = [
      // FURNITURE - SEATING & SURFACES
      { name: 'ü™ë Desk (Square)', type: 'desk', shape: 'square' },
      { name: 'ü™ë Desk (Rectangle)', type: 'desk', shape: 'rectangle' },
      { name: 'ü™ë Desk (Circle)', type: 'desk', shape: 'circle' },
      { name: 'üõèÔ∏è Bed', type: 'bed' },
      { name: 'üõãÔ∏è Couch', type: 'couch' },
      { name: '‚òï Coffee Table (Rectangle)', type: 'coffeetable', shape: 'rectangle' },
      { name: '‚òï Coffee Table (Square)', type: 'coffeetable', shape: 'square' },
      { name: '‚òï Coffee Table (Circle)', type: 'coffeetable', shape: 'circle' },
      { name: 'üíª Computer Desk', type: 'computerdesk' },
      { name: 'üèÆ Side Table', type: 'sidetable' },
      
      // ENTERTAINMENT - DISPLAYS
      { name: 'üì∫ TV (Flat Screen)', type: 'tv', style: 'flat' },
      { name: 'üì∫ TV (Tube/CRT)', type: 'tv', style: 'tube' },
      { name: 'üì∫ TV Stand (Modern)', type: 'tvstand', style: 'modern' },
      { name: 'üì∫ TV Stand (Classic)', type: 'tvstand', style: 'classic' },
      { name: 'üì∫ TV Stand (Minimal)', type: 'tvstand', style: 'minimal' },
      
      // ENTERTAINMENT - CONSOLES & MEDIA
      { name: 'üéÆ Game Console (Modern)', type: 'gameconsole', consoleType: 'modern', color: 0x1a1a1a },
      { name: 'üéÆ Game Console (White)', type: 'gameconsole', consoleType: 'modern', color: 0xf0f0f0 },
      { name: 'üéÆ Game Console (Classic)', type: 'gameconsole', consoleType: 'classic' },
      { name: 'üíø DVD (Silver)', type: 'dvd', color: 0xccccff },
      { name: 'üíø DVD (Gold)', type: 'dvd', color: 0xffd700 },
      { name: 'üìÄ DVD Case (Black)', type: 'dvdcase', color: 0x000000, coverColor: 0x4466ff },
      { name: 'üìÄ DVD Case (Blue)', type: 'dvdcase', color: 0x0a0a3a, coverColor: 0xff6644 },
      { name: 'üìÄ DVD Case (Green)', type: 'dvdcase', color: 0x0a2a0a, coverColor: 0xffdd44 },
      { name: 'üéÆ Remote (Black)', type: 'remote', color: 0x2a2a2a },
      { name: 'üéÆ Remote (Silver)', type: 'remote', color: 0x8a8a8a },
      
      // LIGHTING
      { name: 'üí° Floor Lamp', type: 'floorlamp' },
      { name: 'üí° Ceiling Light (Modern)', type: 'ceilinglight', style: 'modern' },
      { name: 'üí° Ceiling Light (Strip)', type: 'ceilinglight', style: 'strip' },
      { name: 'üí° Ceiling Light (Classic)', type: 'ceilinglight', style: 'classic' },
      
      // HOME DECOR
      { name: 'üìö Shelf (3 shelves)', type: 'shelf', shelves: 3 },
      { name: 'üìö Shelf (4 shelves)', type: 'shelf', shelves: 4 },
      { name: 'üü´ Rug (Brown)', type: 'rug', color: 0x8b4513 },
      { name: 'üî¥ Rug (Red)', type: 'rug', color: 0xcc3333 },
      { name: 'üîµ Rug (Blue)', type: 'rug', color: 0x4444aa },
      
      // KITCHEN
      { name: 'üî≤ Kitchen Counter', type: 'counter' },
      { name: 'üçΩÔ∏è Plate', type: 'plate' },
      { name: 'ü•£ Bowl', type: 'bowl' },
      { name: 'üç¥ Fork', type: 'fork' },
      { name: 'üî™ Knife', type: 'knife' },
      { name: 'ü•Ñ Spoon', type: 'spoon' },
      { name: 'üßä Refrigerator (White)', type: 'refrigerator', color: 0xf0f0f0 },
      { name: 'üßä Refrigerator (Silver)', type: 'refrigerator', color: 0xc0c0c0 },
      { name: 'ü•õ Milk Carton', type: 'milkcarton' },
      { name: 'üçä Orange Juice', type: 'orangejuice' },
      { name: 'üßÄ Cheese', type: 'cheese' },
      { name: 'ü•ö Eggs', type: 'eggs' },
      
      // FRUIT
      { name: 'üçé Apple (Red)', type: 'apple', color: 0xff3333 },
      { name: 'üçè Apple (Green)', type: 'apple', color: 0x66ff66 },
      { name: 'üçê Pear', type: 'pear' },
      { name: 'üçå Banana', type: 'banana' },
      { name: 'üçá Grapes (Purple)', type: 'grapes', color: 0x6a0dad },
      { name: 'üçá Grapes (Green)', type: 'grapes', color: 0x90ee90 },
      { name: 'üçä Fruit Bowl', type: 'fruitbowl' },
      
      // DECORATIONS
      { name: 'ü™¥ Potted Plant', type: 'plant' },
      { name: 'üñºÔ∏è Art (Small)', type: 'artframe', size: 'small' },
      { name: 'üñºÔ∏è Art (Medium)', type: 'artframe', size: 'medium' },
      { name: 'üñºÔ∏è Art (Large)', type: 'artframe', size: 'large' },
      { name: 'üïê Wall Clock', type: 'clock' },
      { name: '‚è∞ Alarm Clock', type: 'alarmclock' },
      
      // BATHROOM
      { name: 'üöΩ Toilet', type: 'toilet' },
      { name: 'üöø Shower', type: 'shower' },
      
      // GAMES & TOYS
      { name: 'üÉè Playing Card (Red)', type: 'playingcard', suit: 'red' },
      { name: 'üÉè Playing Card (Blue)', type: 'playingcard', suit: 'blue' },
      { name: 'üé≤ Dice', type: 'dice' },
      { name: 'üî¥ Poker Chip (Red)', type: 'pokerchip', color: 0xff3333 },
      { name: 'üîµ Poker Chip (Blue)', type: 'pokerchip', color: 0x3333ff },
      { name: '‚ö´ Poker Chip (Black)', type: 'pokerchip', color: 0x1a1a1a },
      { name: 'üü¢ Poker Chip (Green)', type: 'pokerchip', color: 0x33ff33 },
      { name: '‚ôüÔ∏è Checkers Board', type: 'gameboard', variant: 'checkers' },
      { name: '‚ôüÔ∏è Chess Board', type: 'gameboard', variant: 'chess' },
      { name: '‚ôô Chess Pawn (White)', type: 'chesspawn', color: 0xffffff },
      { name: '‚ôü Chess Pawn (Black)', type: 'chesspawn', color: 0x1a1a1a },
      { name: 'üé≤ Jenga Tower (Clean)', type: 'jengatower', config: 'clean' },
      { name: 'üé≤ Jenga Tower (Random)', type: 'jengatower', config: 'random' },
      { name: '‚öæ Baseball', type: 'baseball' },
      { name: 'üèÄ Basketball', type: 'basketball' },
      { name: '‚öΩ Pixar Ball', type: 'pixarball' },
      
      // CLEANING SUPPLIES
      { name: 'üßπ Broom', type: 'broom' },
      { name: 'üßπ Dustpan', type: 'dustpan' },
      { name: 'üßπ Vacuum', type: 'vacuum' },
      { name: 'üßπ Handheld Vacuum', type: 'handheldvacuum' },
      { name: 'ü™£ Bucket', type: 'bucket' },
      { name: 'üßΩ Sponge', type: 'sponge' },
      { name: 'üßΩ Rag', type: 'rag' },
      { name: 'üßª Paper Towel Roll', type: 'papertowelroll' },
      { name: 'üßª Toilet Paper Roll', type: 'toiletpaperroll' },
      
      // OFFICE & DESK
      { name: 'üí° Desk Lamp (Luxo)', type: 'desklamp' }
    ];
    
    let assetLibraryVisible = false;
    
    function setupAssetLibrary() {
      const libraryDiv = document.createElement('div');
      libraryDiv.id = 'asset-library';
      libraryDiv.style.cssText = `
        position: fixed;
        top: 20px;
        right: 380px;
        background: rgba(15,20,28,.96);
        backdrop-filter: blur(16px);
        border: 1px solid rgba(74,124,255,.3);
        border-radius: 12px;
        padding: 18px;
        color: #e8edf7;
        font-size: 13px;
        max-width: 280px;
        max-height: 500px;
        overflow-y: auto;
        display: none;
        z-index: 100;
      `;
      
      libraryDiv.innerHTML = `
        <div style="font-size: 15px; font-weight: 700; color: #6a9cff; margin-bottom: 14px; text-transform: uppercase; letter-spacing: 1px; border-bottom: 2px solid rgba(74,124,255,.2); padding-bottom: 8px;">
          üì¶ Asset Library
        </div>
        <div style="font-size: 11px; color: #8ab4ff; margin-bottom: 12px;">
          Click to spawn in front of you
        </div>
        <div id="asset-list"></div>
      `;
      
      document.body.appendChild(libraryDiv);
      
      const assetList = document.getElementById('asset-list');
      ASSET_LIBRARY.forEach((asset, index) => {
        const assetButton = document.createElement('button');
        assetButton.textContent = asset.name;
        assetButton.style.cssText = `
          width: 100%;
          background: linear-gradient(180deg, #4a7cff 0%, #3a6cef 100%);
          border: 1px solid rgba(106,156,255,.6);
          border-radius: 6px;
          padding: 8px 12px;
          color: white;
          font-size: 12px;
          font-weight: 600;
          cursor: pointer;
          margin: 4px 0;
          transition: all 0.2s;
        `;
        
        assetButton.addEventListener('mouseenter', () => {
          assetButton.style.background = 'linear-gradient(180deg, #5a8cff 0%, #4a7cff 100%)';
          assetButton.style.transform = 'translateY(-1px)';
        });
        
        assetButton.addEventListener('mouseleave', () => {
          assetButton.style.background = 'linear-gradient(180deg, #4a7cff 0%, #3a6cef 100%)';
          assetButton.style.transform = 'translateY(0)';
        });
        
        assetButton.addEventListener('click', (e) => {
          e.stopPropagation();
          spawnAsset(asset);
        });
        
        assetList.appendChild(assetButton);
      });
      
      // Toggle with 'B' key
      document.addEventListener('keydown', (e) => {
        if (e.code === 'KeyB' && !controls.isLocked) {
          assetLibraryVisible = !assetLibraryVisible;
          libraryDiv.style.display = assetLibraryVisible ? 'block' : 'none';
        }
      });
    }
    
    function spawnAsset(assetDef) {
      // Spawn in front of camera
      const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
      const spawnPos = camera.position.clone().addScaledVector(forward, 2);
      
      // Snap to grid
      const gridX = Math.round(spawnPos.x / GRID_SIZE);
      const gridZ = Math.round(spawnPos.z / GRID_SIZE);
      
      const spec = {
        type: assetDef.type,
        x: gridX,
        z: gridZ,
        rotation: 0,
        shape: assetDef.shape,
        color: assetDef.color,
        y: 0
      };
      
      // Height adjustments for counter items
      if (['plate', 'bowl', 'apple', 'pear', 'banana', 'grapes', 'fruitbowl'].includes(spec.type)) {
        spec.y = 0.9; // Place on counter height
      }
      
      // Height adjustments for table items (coffee/side table)
      if (['playingcard', 'dice', 'pokerchip', 'gameboard', 'chesspawn', 'alarmclock'].includes(spec.type)) {
        spec.y = 0.4; // Place on coffee table height
      }
      
      // Height adjustments for side table items
      if (['alarmclock'].includes(spec.type)) {
        spec.y = 0.55; // Place on side table height
      }
      
      // Pass additional properties from assetDef
      if (assetDef.suit) spec.suit = assetDef.suit;
      if (assetDef.variant) spec.variant = assetDef.variant;
      if (assetDef.scale) spec.scale = assetDef.scale;
      if (assetDef.lit !== undefined) spec.lit = assetDef.lit;
      if (assetDef.shadeColor) spec.shadeColor = assetDef.shadeColor;
      if (assetDef.size) spec.size = assetDef.size;
      if (assetDef.style) spec.style = assetDef.style;
      if (assetDef.consoleType) spec.consoleType = assetDef.consoleType;
      if (assetDef.coverColor) spec.coverColor = assetDef.coverColor;
      if (assetDef.config) spec.config = assetDef.config;
      if (assetDef.shelves) spec.shelves = assetDef.shelves;
      if (assetDef.width) spec.width = assetDef.width;
      if (assetDef.depth) spec.depth = assetDef.depth;
      
      // Height adjustments for TV stands and entertainment centers
      if (['tvstand'].includes(spec.type)) {
        spec.y = 0; // Floor level
      }
      
      // Height adjustments for items on TV stands/media consoles
      if (['gameconsole', 'dvd', 'dvdcase', 'remote'].includes(spec.type)) {
        spec.y = 0.5; // Place on TV stand height
      }
      
      // Create the asset using handlers
      const handlers = {
        desk: createDesk,
        bed: createBed,
        toilet: createToilet,
        shower: createShower,
        counter: createKitchenCounter,
        plate: createPlate,
        plant: createPottedPlant,
        apple: createApple,
        pear: createPear,
        banana: createBanana,
        grapes: createGrapes,
        bowl: createBowl,
        fruitbowl: createFruitBowl,
        artframe: createArtFrame,
        clock: createWallClock,
        couch: createCouch,
        tv: createTV,
        tvstand: createTVStand,
        gameconsole: createGameConsole,
        dvd: createDVD,
        dvdcase: createDVDCase,
        remote: createRemote,
        coffeetable: createCoffeeTable,
        playingcard: createPlayingCard,
        dice: createDice,
        pokerchip: createPokerChip,
        gameboard: createGameBoard,
        computerdesk: createComputerDesk,
        chesspawn: createChessPawn,
        sidetable: createSideTable,
        floorlamp: createFloorLamp,
        alarmclock: createAlarmClock,
        broom: createBroom,
        dustpan: createDustpan,
        vacuum: createVacuum,
        handheldvacuum: createHandheldVacuum,
        bucket: createBucket,
        sponge: createSponge,
        rag: createRag,
        papertowelroll: createPaperTowelRoll,
        toiletpaperroll: createToiletPaperRoll,
        jengatower: createJengaTower,
        desklamp: createDeskLamp,
        pixarball: createPixarBall,
        basketball: createBasketball,
        baseball: createBaseball,
        rug: createRug,
        shelf: createShelf,
        ceilinglight: createCeilingLight,
        fork: createFork,
        knife: createKnife,
        spoon: createSpoon,
        refrigerator: createRefrigerator,
        milkcarton: createMilkCarton,
        orangejuice: createOrangeJuice,
        cheese: createCheese,
        eggs: createEggs
      };
      
      const handler = handlers[spec.type];
      if (handler) {
        handler(spec);
      }
      
      console.log(`Spawned ${assetDef.name} at grid (${gridX}, ${gridZ})`);
    }
    
    // ==================== ANIMATION LOOP ====================
    
    const clock = new THREE.Clock();
    
    function animate() {
      requestAnimationFrame(animate);
      
      const delta = clock.getDelta();
      updateMovement(delta);
      
      renderer.render(scene, camera);
    }
    
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    // ==================== GLOBAL FUNCTIONS ====================
    
    window.loadRoom = loadRoom;
    window.randomizeRoom = randomizeRoom;
    
    // ==================== START ====================
    
    init();
  </script>
</body>
</html>

