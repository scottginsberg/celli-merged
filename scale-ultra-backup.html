<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pockit Ultra ‚Äî Complete Scale Sandbox</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { height: 100%; overflow: hidden; background: #0a0d12; 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif; }
    
    /* UI Panels */
    .ui-panel {
      position: fixed;
      background: rgba(15,20,28,.96);
      backdrop-filter: blur(16px) saturate(180%);
      border: 1px solid rgba(74,124,255,.3);
      border-radius: 12px;
      padding: 18px;
      color: #e8edf7;
      font-size: 13px;
      line-height: 1.6;
      box-shadow: 0 8px 32px rgba(0,0,0,.5), 0 0 0 1px rgba(255,255,255,.05) inset;
      z-index: 100;
      transition: all .3s;
    }
    
    .ui-panel.minimized { opacity: 0; pointer-events: none; transform: scale(0.95); }
    
    #controls-panel { bottom: 20px; left: 20px; max-width: 420px; }
    #stats-panel { top: 20px; right: 20px; min-width: 260px; }
    #visual-panel { top: 20px; left: 20px; max-width: 320px; }
    #viewport-panel { top: 180px; left: 20px; max-width: 320px; display: none; }
    #viewport-panel.active { display: block; }
    
    .panel-title {
      font-size: 15px;
      font-weight: 700;
      color: #6a9cff;
      margin-bottom: 14px;
      text-transform: uppercase;
      letter-spacing: 1px;
      border-bottom: 2px solid rgba(74,124,255,.2);
      padding-bottom: 8px;
    }
    
    .section-title {
      font-size: 12px;
      font-weight: 600;
      color: #8ab4ff;
      margin: 12px 0 8px 0;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .control-row {
      display: flex;
      align-items: center;
      gap: 12px;
      margin: 8px 0;
      padding: 6px 0;
    }
    
    .control-label {
      flex: 1;
      color: #b8c5d9;
      font-size: 12px;
    }
    
    .control-value {
      color: #6a9cff;
      font-weight: 600;
      min-width: 70px;
      text-align: right;
      font-size: 13px;
    }
    
    kbd {
      background: linear-gradient(180deg, #2a3440 0%, #1a2130 100%);
      border: 1px solid rgba(106,156,255,.4);
      border-bottom-width: 2px;
      border-radius: 4px;
      padding: 3px 7px;
      font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
      font-size: 11px;
      color: #8ab4ff;
      box-shadow: 0 2px 4px rgba(0,0,0,.3);
      display: inline-block;
      min-width: 22px;
      text-align: center;
    }
    
    /* Sliders */
    input[type="range"] {
      width: 100%;
      height: 6px;
      background: linear-gradient(90deg, rgba(74,124,255,.15), rgba(106,156,255,.25));
      border-radius: 3px;
      outline: none;
      -webkit-appearance: none;
      margin: 8px 0;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: linear-gradient(135deg, #6a9cff, #4a7cff);
      cursor: grab;
      box-shadow: 0 2px 8px rgba(74,124,255,.6), 0 0 0 3px rgba(26,33,48,.8);
      transition: all .2s;
    }
    
    input[type="range"]::-webkit-slider-thumb:hover {
      box-shadow: 0 3px 12px rgba(74,124,255,.8), 0 0 0 4px rgba(26,33,48,.9);
      transform: scale(1.1);
    }
    
    input[type="range"]::-webkit-slider-thumb:active {
      cursor: grabbing;
      transform: scale(1.05);
    }
    
    input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: linear-gradient(135deg, #6a9cff, #4a7cff);
      cursor: grab;
      border: none;
      box-shadow: 0 2px 8px rgba(74,124,255,.6);
    }
    
    /* Buttons */
    button {
      background: linear-gradient(135deg, #4a7cff 0%, #6a9cff 100%);
      border: 1px solid rgba(255,255,255,.2);
      border-radius: 8px;
      padding: 10px 18px;
      color: white;
      font-weight: 600;
      cursor: pointer;
      transition: all .2s;
      font-size: 13px;
      box-shadow: 0 2px 8px rgba(74,124,255,.3);
      position: relative;
      overflow: hidden;
    }
    
    button::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(255,255,255,.2);
      transform: translate(-50%, -50%);
      transition: width .4s, height .4s;
    }
    
    button:hover::before {
      width: 300px;
      height: 300px;
    }
    
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(74,124,255,.5);
    }
    
    button:active {
      transform: translateY(0);
    }
    
    button.secondary {
      background: linear-gradient(135deg, #2a3440 0%, #1a2130 100%);
      border-color: rgba(106,156,255,.3);
    }
    
    /* Toggle Switch */
    .toggle-switch {
      position: relative;
      width: 48px;
      height: 24px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.1);
      border-radius: 12px;
      cursor: pointer;
      transition: all .3s ease;
    }
    
    .toggle-switch.active {
      background: linear-gradient(135deg, #4a7cff, #6a9cff);
      border-color: rgba(106,156,255,.5);
      box-shadow: 0 2px 8px rgba(74,124,255,.4);
    }
    
    .toggle-switch::after {
      content: '';
      position: absolute;
      top: 2px;
      left: 2px;
      width: 18px;
      height: 18px;
      background: white;
      border-radius: 50%;
      transition: left .3s ease;
      box-shadow: 0 2px 4px rgba(0,0,0,.2);
    }
    
    .toggle-switch.active::after {
      left: 26px;
    }
    
    /* Viewport Frame */
    #viewport-frame {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 50vw;
      height: 50vh;
      border: 3px dashed rgba(106,156,255,0.85);
      border-radius: 10px;
      pointer-events: none;
      opacity: 0;
      transition: opacity .25s ease;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.3), 0 0 20px rgba(74,124,255,0.2);
    }
    
    #viewport-frame.active { 
      opacity: 1; 
      animation: pulseFrame 2s ease-in-out infinite;
    }
    
    @keyframes pulseFrame {
      0%, 100% { border-color: rgba(106,156,255,0.85); }
      50% { border-color: rgba(138,180,255,0.95); }
    }
    
    /* Reticle */
    #reticle {
      position: fixed;
      left: 50%;
      top: 50%;
      width: 20px;
      height: 20px;
      margin: -10px 0 0 -10px;
      pointer-events: none;
      opacity: 0.9;
    }
    
    #reticle::before, #reticle::after {
      content: '';
      position: absolute;
      background: linear-gradient(135deg, rgba(106,156,255,0.9), rgba(138,180,255,1));
      box-shadow: 0 0 4px rgba(74,124,255,0.5);
    }
    
    #reticle::before {
      left: 9px;
      top: 0;
      width: 2px;
      height: 20px;
    }
    
    #reticle::after {
      top: 9px;
      left: 0;
      width: 20px;
      height: 2px;
    }
    
    /* Tooltip */
    #tooltip {
      position: fixed;
      background: rgba(15,20,28,.98);
      color: #e8edf7;
      padding: 10px 14px;
      border-radius: 8px;
      font-size: 13px;
      pointer-events: none;
      z-index: 300;
      display: none;
      transform: translate(-50%, -120%);
      border: 1px solid rgba(106,156,255,.4);
      box-shadow: 0 4px 16px rgba(0,0,0,.6);
      white-space: nowrap;
    }
    
    /* Info Panel */
    #info-panel {
      position: fixed;
      bottom: 120px;
      right: 20px;
      min-width: 300px;
      max-width: 400px;
      background: rgba(15,20,28,.98);
      color: #e8edf7;
      padding: 16px;
      border-radius: 10px;
      font-size: 13px;
      z-index: 250;
      display: none;
      border: 1px solid rgba(106,156,255,.4);
      box-shadow: 0 6px 24px rgba(0,0,0,.7);
      line-height: 1.6;
    }
    
    #info-panel.active {
      display: block;
    }
    
    #info-panel .info-title {
      font-size: 16px;
      font-weight: 700;
      color: #6a9cff;
      margin-bottom: 12px;
      border-bottom: 2px solid rgba(106,156,255,.3);
      padding-bottom: 8px;
    }
    
    #info-panel .info-row {
      margin: 6px 0;
      display: flex;
      gap: 8px;
    }
    
    #info-panel .info-label {
      color: #8ab4ff;
      font-weight: 600;
      min-width: 100px;
    }
    
    #info-panel .info-value {
      color: #b8c5d9;
      flex: 1;
    }
    
    /* HUD Mini Viewport */
    #hud-mini {
      position: fixed;
      right: 20px;
      top: 320px;
      width: 260px;
      height: 146px;
      border: 2px solid rgba(74,124,255,.3);
      border-radius: 8px;
      overflow: hidden;
      background: rgba(10,13,18,.95);
      backdrop-filter: blur(8px);
      box-shadow: 0 4px 16px rgba(0,0,0,.5);
      display: none;
    }
    
    #hud-mini.active {
      display: block;
    }
    
    #hud-mini canvas {
      width: 100%;
      height: 100%;
    }
    
    /* Loading */
    #loading {
      position: fixed;
      inset: 0;
      background: linear-gradient(135deg, #0a0d12 0%, #12161f 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 24px;
      z-index: 2000;
      transition: opacity .6s ease;
    }
    
    #loading.hidden {
      opacity: 0;
      pointer-events: none;
    }
    
    .spinner {
      width: 56px;
      height: 56px;
      border: 5px solid rgba(74,124,255,.15);
      border-top-color: #6a9cff;
      border-radius: 50%;
      animation: spin 1s cubic-bezier(0.68, -0.55, 0.265, 1.55) infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    .loading-text {
      color: #8ab4ff;
      font-size: 15px;
      font-weight: 500;
      letter-spacing: 0.5px;
    }
    
    /* Controls Grid */
    .controls-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      font-size: 12px;
      margin-top: 8px;
    }
    
    .control-item {
      display: flex;
      align-items: center;
      gap: 6px;
      color: #b8c5d9;
    }
    
    /* Button Row */
    .button-row {
      display: flex;
      gap: 8px;
      margin-top: 12px;
    }
    
    .button-row button {
      flex: 1;
      font-size: 12px;
      padding: 8px 12px;
    }
  </style>
</head>
<body>
  <div id="loading">
    <div class="spinner"></div>
    <div class="loading-text">Initializing Pockit Ultra...</div>
  </div>
  
  <!-- Visual Settings Panel -->
  <div id="visual-panel" class="ui-panel">
    <div class="panel-title">Visual Settings</div>
    
    <div class="control-row">
      <span class="control-label">Shadows Quality</span>
      <div class="toggle-switch active" id="toggle-shadows"></div>
    </div>
    
    <div class="control-row">
      <span class="control-label">Volumetric Fog</span>
      <div class="toggle-switch active" id="toggle-fog"></div>
    </div>
    
     <div class="control-row">
       <span class="control-label">Post-Processing</span>
       <div class="toggle-switch" id="toggle-postfx"></div>
     </div>
     
     <div class="control-row">
       <span class="control-label">Anti-Aliasing</span>
       <div class="toggle-switch" id="toggle-aa"></div>
     </div>
     
     <div class="control-row">
       <span class="control-label">Motion Blur</span>
       <div class="toggle-switch" id="toggle-motionblur"></div>
     </div>
    
    <div class="section-title">Camera</div>
    
    <div class="control-row">
      <span class="control-label">FOV</span>
      <span class="control-value" id="fov-value">75¬∞</span>
    </div>
    <input type="range" id="fov-slider" min="50" max="120" value="75">
    
    <div class="control-row">
      <span class="control-label">Render Scale</span>
      <span class="control-value" id="render-scale-value">1.0x</span>
    </div>
    <input type="range" id="render-scale-slider" min="50" max="200" value="100" step="10">
  </div>
  
  <!-- Viewport Panel -->
  <div id="viewport-panel" class="ui-panel">
    <div class="panel-title">Frame of Reference</div>
    
    <div class="control-row">
      <span class="control-label">Pluck Mode</span>
      <div class="toggle-switch" id="toggle-pluck"></div>
    </div>
    
    <div class="control-row">
      <span class="control-label">Distance</span>
      <span class="control-value" id="viewport-dist-value">0.9m</span>
    </div>
    <input type="range" id="viewport-dist-slider" min="20" max="500" value="90" step="5">
    
    <div class="section-title">Actions</div>
    
    <div class="button-row">
      <button id="btn-snapshot" class="secondary">üì∑ Snapshot</button>
      <button id="btn-clear" class="secondary">üóë Clear</button>
    </div>
    
    <div style="margin-top: 12px; font-size: 11px; color: #8a96a8; line-height: 1.5;">
      <strong>Pluck Mode:</strong><br>
      ‚Ä¢ Hover to highlight objects<br>
      ‚Ä¢ Click to grab & drag<br>
      ‚Ä¢ Scroll to adjust depth<br>
      ‚Ä¢ Objects rescale to frame<br>
      <br>
      <strong>Lock Mode:</strong><br>
      ‚Ä¢ Click to lock all in frame<br>
      ‚Ä¢ Right Click: Snapshot view<br>
      ‚Ä¢ Scroll: Frame distance
    </div>
  </div>
  
  <!-- Controls Panel -->
  <div id="controls-panel" class="ui-panel">
    <div class="panel-title">Controls</div>
    
    <div class="controls-grid">
      <div class="control-item"><kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> Move</div>
      <div class="control-item"><kbd>Space</kbd> Jump</div>
      <div class="control-item"><kbd>Shift</kbd> Sprint</div>
      <div class="control-item"><kbd>Q</kbd> / <kbd>E</kbd> Scale</div>
      <div class="control-item"><kbd>R</kbd> Reset</div>
      <div class="control-item"><kbd>V</kbd> Viewport</div>
      <div class="control-item"><kbd>P</kbd> Portals</div>
      <div class="control-item"><kbd>H</kbd> Hide UI</div>
      <div class="control-item"><kbd>I</kbd> Interior</div>
    </div>
    
    <div class="section-title">World</div>
    
    <div class="button-row">
      <button id="spawn-city">üèô New City</button>
      <button id="spawn-objects" class="secondary">üì¶ Objects</button>
    </div>
  </div>
  
  <!-- Stats Panel -->
  <div id="stats-panel" class="ui-panel">
    <div class="panel-title">Status</div>
    
    <div class="control-row">
      <span class="control-label">Player Scale</span>
      <span class="control-value" id="stat-scale">1.00x</span>
    </div>
    
    <div class="control-row">
      <span class="control-label">World Scale</span>
      <span class="control-value" id="stat-world-scale">1.00x</span>
    </div>
    
    <div class="control-row">
      <span class="control-label">Position</span>
      <span class="control-value" id="stat-position">0, 0, 0</span>
    </div>
    
    <div class="control-row">
      <span class="control-label">Velocity</span>
      <span class="control-value" id="stat-velocity">0.0 m/s</span>
    </div>
    
    <div class="control-row">
      <span class="control-label">FPS</span>
      <span class="control-value" id="stat-fps">60</span>
    </div>
    
    <div class="control-row">
      <span class="control-label">Buildings</span>
      <span class="control-value" id="stat-buildings">0</span>
    </div>
    
    <div class="control-row">
      <span class="control-label">Objects</span>
      <span class="control-value" id="stat-objects">0</span>
    </div>
  </div>
  
  <div id="viewport-frame"></div>
  <div id="reticle"></div>
  <div id="tooltip"></div>
  <div id="info-panel">
    <div class="info-title" id="info-title">Information</div>
    <div id="info-content"></div>
  </div>
  <div id="hud-mini"><canvas id="hud-mini-canvas" width="520" height="292"></canvas></div>
  
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
  
  <script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { SMAAPass } from 'three/addons/postprocessing/SMAAPass.js';
    import { SSAOPass } from 'three/addons/postprocessing/SSAOPass.js';
    import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
    import RAPIER from 'https://cdn.skypack.dev/@dimforge/rapier3d-compat@0.11.2';
    
    // ==================== MOTION BLUR SHADER ====================
    const MotionBlurShader = {
      uniforms: {
        tDiffuse: { value: null },
        velocityFactor: { value: 0.0 },
        delta: { value: new THREE.Vector2(0, 0) }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float velocityFactor;
        uniform vec2 delta;
        varying vec2 vUv;
        
        void main() {
          vec4 color = vec4(0.0);
          float total = 0.0;
          
          // Sample multiple times along motion direction for subtle blur
          float samples = 5.0;
          float intensity = velocityFactor * 0.015; // Reduced for subtlety
          
          for (float i = 0.0; i < samples; i++) {
            float t = (i / (samples - 1.0)) - 0.5;
            vec2 offset = delta * t * intensity;
            color += texture2D(tDiffuse, vUv + offset);
            total += 1.0;
          }
          
          gl_FragColor = color / total;
        }
      `
    };
    
    // ==================== CONFIGURATION ====================
    const CONFIG = {
      PLAYER_HEIGHT: 1.7,
      PLAYER_RADIUS: 0.35,
      PLAYER_DEFAULT_SCALE: 1.0,
      PLAYER_MIN_SCALE: 0.01,
      PLAYER_MAX_SCALE: 50.0,
      GRAVITY: -24.0,
      MOVE_SPEED: 6.0,
      SPRINT_MULTIPLIER: 2.2,
      JUMP_FORCE: 9.0,
      SHRINK_RATE: 1.0,
      GROW_RATE: 1.0,
       ROAD_WIDTH: 12,        // Width of roads - more to scale
       SIDEWALK_WIDTH: 3.0,   // Width of sidewalks
       SIDEWALK_HEIGHT: 0.2,  // Height of sidewalk above road
       BLOCK_SIZE: 60,        // Size of city blocks - bigger
       CITY_BLOCKS_X: 6,      // City size
       CITY_BLOCKS_Z: 6,      // City size
       BUILDINGS_PER_BLOCK_MIN: 2,  // Reduced for performance
       BUILDINGS_PER_BLOCK_MAX: 4,  // Reduced for performance
       BUILDING_MIN_HEIGHT: 10,
       BUILDING_MAX_HEIGHT: 80,
       CHUNK_LOAD_DISTANCE: 120,  // Load chunks within this distance (reduced)
       CHUNK_UNLOAD_DISTANCE: 180, // Unload chunks beyond this distance
    };
    
    // ==================== DISTRICT PROFILES ====================
    const DISTRICT_PROFILES = {
      financial: {
        name: 'Financial Core',
        buildingStyle: {
          heightRange: [40, 80],
          widthRange: [12, 18],
          depthRange: [12, 18],
          shaftSliceStyle: 'ribbons',
          cornerTreatment: 'thinBar',
          setbackChance: 0.85,  // More stepped buildings
          setbackSchedule: [
            { atFloor: 10, inset: 1.5 },
            { atFloor: 18, inset: 2.0 },
            { atFloor: 28, inset: 2.5 },
            { atFloor: 38, inset: 3.0 }
          ],
          crownStyle: ['antenna', 'steppedZiggurat', 'spire', 'pyramid', 'dome'],
          roofGarnishChance: 0.9
        },
        colorPalette: [0xA8B0B8, 0x8A9099, 0xB5B8BC, 0x7A8088, 0xC0C8D0],
        windowColors: ['blue', 'white', 'black']  // Mixed window colors per building
      },
      midtown: {
        name: 'Midtown Mix',
        buildingStyle: {
          heightRange: [25, 55],
          widthRange: [15, 25],
          depthRange: [14, 22],
          shaftSliceStyle: 'grid',
          cornerTreatment: 'thickPilaster',
          setbackChance: 0.75,  // More stepped buildings
          setbackSchedule: [
            { atFloor: 8, inset: 1.2 },
            { atFloor: 14, inset: 1.8 },
            { atFloor: 22, inset: 2.2 }
          ],
          crownStyle: ['flatMech', 'plate', 'dome', 'steppedZiggurat', 'pyramid'],
          roofGarnishChance: 0.7
        },
        colorPalette: [0xC8C2B8, 0xD4CCBE, 0xBFB5A8, 0xE0D8D0, 0xA89888],
        windowColors: ['yellow', 'white', 'black']
      },
      residential: {
        name: 'Residential Midrise',
        buildingStyle: {
          heightRange: [15, 35],
          widthRange: [18, 28],
          depthRange: [16, 24],
          shaftSliceStyle: 'horizBand',
          cornerTreatment: 'none',
          setbackChance: 0.65,  // More stepped buildings
          setbackSchedule: [
            { atFloor: 6, inset: 1.0 },
            { atFloor: 12, inset: 1.5 },
            { atFloor: 18, inset: 2.0 }
          ],
          crownStyle: ['flatMech', 'none', 'pyramid'],
          roofGarnishChance: 0.5
        },
        colorPalette: [0xA89F92, 0x9A9A9A, 0xB5B8BC, 0xC8C0B8, 0x888878],
        windowColors: ['yellow', 'white']
      },
      waterfront: {
        name: 'Waterfront Industrial',
        buildingStyle: {
          heightRange: [12, 22],
          widthRange: [20, 35],
          depthRange: [18, 30],
          shaftSliceStyle: 'pairedVerticals',
          cornerTreatment: 'none',
          setbackChance: 0.4,  // Some stepped buildings
          setbackSchedule: [
            { atFloor: 8, inset: 2.0 }
          ],
          crownStyle: ['flatMech', 'waterTank', 'none'],
          roofGarnishChance: 0.8
        },
        colorPalette: [0x8A9099, 0xA89F92, 0x9A9A9A, 0x7A7A7A],
        windowColors: ['blue', 'black']
      }
    };
    
    // ==================== GLOBAL STATE ====================
    let physics, world, scene, camera, renderer, composer;
    let player, playerBody, playerScale = CONFIG.PLAYER_DEFAULT_SCALE;
    let worldRoot, worldScale = 1.0;
    let keys = new Set();
    let velocity = new THREE.Vector3();
    let pointerLocked = false;
    let yaw = 0, pitch = 0;
    
    // City & Objects
    let buildings = [];
    let worldObjects = [];
    let portals = [];
    let doors = [];  // Array of door objects with position, state, light
    
    // Chunked City System
    const cityChunks = new Map();  // Map<"x,z", ChunkData>
    let activeChunks = new Set();  // Set of "x,z" keys for loaded chunks
    let chunkRoots = new Map();    // Map<"x,z", THREE.Group>
    
    // Viewport System
    let viewportEquipped = false;
    let heldViewport = null;
    let heldViewportDist = 0.9;
    let droppedViewport = null;
    let droppedViewportRT = null;
    let droppedViewportCam = null;
    let droppedViewportData = null;
    let pluckMode = false;
    let viewportLocked = new Set();
    let viewportActive = false;
    let pluckCandidates = new Set();
    let draggingObject = null;
    let draggingFrame = null;
    let dragDepth = 3.0;
    let blockPointerLock = false;
    let suppressedPhysics = new Set();
    
    // Raycasting
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    
    // Lasso / Grappling Hook System
    let lassoEnabled = false;
    let lassoVisual = null;
    let grapplingHook = null;
    let swingRope = null;
    let ropeVisual = null;
    
    // Bike System
    let bikeEnabled = false;
    let bikeBody = null;
    let bikeMesh = null;
    let bikeSpeed = 0;
    let bikeTargetSpeed = 0;
    const BIKE_MAX_SPEED = 65; // Increased from 35 to 65
    const BIKE_ACCEL = 35; // Increased from 25 to 35
    const BIKE_TURN_RATE = 2.5;
    let bikeTrailMesh = null;
    let bikeTrailPoints = [];
    const BIKE_TRAIL_MAX_POINTS = 100;
    let bikeAutoPilot = true; // Bike drives itself by default
    let permanentTrails = []; // Store trails when exiting bike
    let bikeWheelRotation = 0; // Track wheel rotation
    let bikeWheelieAngle = 0; // Track wheelie tilt
    let bikeJumpVelocity = 0; // Track jump state
    let bikeWheelieProgress = 0; // 0 to 1, tracks wheelie state
    let bikeCanJump = false; // True when wheelie is at max
    let bikeWallRiding = false; // True when riding on wall
    let bikeWallNormal = new THREE.Vector3(); // Wall surface normal
    
    // Pedestrian System
    const pedestrians = [];
    const pedestrianDatabase = new Map(); // id -> full character data
    const buildingDatabase = new Map(); // building mesh -> building data
    
    const firstNamesMale = [
      'James', 'Michael', 'Robert', 'David', 'John', 'William', 'Richard', 'Thomas', 
      'Daniel', 'Matthew', 'Anthony', 'Christopher', 'Joseph', 'Andrew', 'Ryan', 
      'Jason', 'Kevin', 'Brian', 'Eric', 'Steven', 'Paul', 'Mark', 'Kenneth', 'Joshua'
    ];
    
    const firstNamesFemale = [
      'Mary', 'Jennifer', 'Lisa', 'Linda', 'Patricia', 'Susan', 'Jessica', 'Sarah', 
      'Karen', 'Nancy', 'Margaret', 'Emily', 'Elizabeth', 'Michelle', 'Amanda', 
      'Ashley', 'Melissa', 'Nicole', 'Rebecca', 'Laura', 'Stephanie', 'Angela', 'Rachel', 'Samantha'
    ];
    
    const lastNames = [
      'Smith', 'Johnson', 'Williams', 'Brown', 'Jones', 'Garcia', 'Miller', 'Davis', 
      'Rodriguez', 'Martinez', 'Hernandez', 'Lopez', 'Gonzalez', 'Wilson', 'Anderson', 
      'Thomas', 'Taylor', 'Moore', 'Jackson', 'Martin', 'Lee', 'Thompson', 'White', 'Harris',
      'Clark', 'Lewis', 'Robinson', 'Walker', 'Young', 'Allen', 'King', 'Wright', 'Scott',
      'Torres', 'Nguyen', 'Hill', 'Flores', 'Green', 'Adams', 'Nelson', 'Baker', 'Hall', 'Rivera'
    ];
    
    const occupations = [
      'Analyst', 'Courier', 'Engineer', 'Archivist', 'Technician', 'Driver', 'Chef', 
      'Barista', 'Accountant', 'Researcher', 'Consultant', 'Inspector', 'Medic', 
      'Nurse', 'Receptionist', 'Librarian', 'Architect', 'Professor', 'Student', 
      'Security', 'Officer', 'Writer', 'Editor', 'Teacher', 'Designer', 'Artist',
      'Lawyer', 'Doctor', 'Trader', 'Manager', 'Developer', 'Salesperson', 'Cashier'
    ];
    
    const buildingTypes = ['Apartment', 'Office', 'Shop', 'Restaurant', 'Cafe', 'Bank', 'Hospital', 'School', 'Gym', 'Library'];
    const specialConstructions = ['Playground', 'ParkingLot', 'ParkingGarage']; // Can replace buildings
    
    const buildingNames = {
      Apartment: ['Riverside Apartments', 'Parkview Residences', 'Metro Tower', 'Sunset Heights', 'City Plaza Homes'],
      Office: ['Tech Hub', 'Financial Center', 'Business Plaza', 'Corporate Tower', 'Innovation Building'],
      Shop: ['Corner Market', 'City Goods', 'Main Street Store', 'Quick Shop', 'Urban Mart'],
      Restaurant: ['Bistro 42', 'The Grill House', 'Pasta Palace', 'Sushi Bar', 'Steakhouse'],
      Cafe: ['Coffee Corner', 'Brew & Bite', 'Morning Cup', 'Cafe Central', 'Bean Street'],
      Bank: ['First National', 'City Bank', 'Metro Financial', 'Trust Bank', 'Capital One'],
      Hospital: ['General Hospital', 'Medical Center', 'Health Clinic', 'Emergency Care', 'City Hospital'],
      School: ['Elementary School', 'High School', 'Academy', 'Learning Center', 'Public School'],
      Gym: ['Fitness Club', 'Power Gym', 'Health & Strength', 'Active Life', 'Body Works'],
      Library: ['Public Library', 'City Library', 'Central Library', 'Reading Center', 'Book Haven']
    };
    
    // Routine system (10-minute day cycle)
    const DAY_DURATION = 600; // 10 minutes in seconds
    let currentDayTime = 0; // 0-600 seconds
    
    // Pathfinding grid (for sidewalk navigation)
    const pathGrid = new Map(); // "x,z" -> walkable
    const GRID_CELL_SIZE = 2; // 2m per cell
    
    // Cloud System
    const cloudPrototypes = [];
    const activeClouds = [];
    
    // Rocket System
    let rocketEnabled = false;
    let rocketBody = null;
    let rocketMesh = null;
    let rocketVelocity = 0;
    let rocketAcceleration = 20; // m/s¬≤
    const ROCKET_MAX_SPEED = 200;
    let planetRadius = 400; // Planet radius for curvature
      let rocketCameraYaw = 0; // Horizontal orbit angle
      let rocketCameraPitch = -0.3; // Vertical orbit angle
      let rocketCameraDistance = 15; // Distance from rocket
      
      // Atmosphere transition system
      let atmosphereLayer = null;
      let starField = null;
      let planetoidMesh = null;
      const ATMOSPHERE_ALTITUDE = 150; // Altitude where we start atmosphere transition
      const SPACE_ALTITUDE = 400; // Altitude where we fully enter space
    
    // Time of Day System
    let sun = null;
    let hemiLight = null;
    let ambientLight = null;
    let starField = null;
    let timeOfDay = 12; // 0-24 hours (12 = noon)
    
     // Settings (post-processing disabled by default for performance)
     let postFXEnabled = false;
     let aaEnabled = false;
     let shadowsEnabled = true;
     let fogEnabled = true;
     let motionBlurEnabled = false;
     let motionBlurPass = null;
     let prevCameraPosition = new THREE.Vector3();
     let prevCameraRotation = new THREE.Euler();
    
    // Stats
    let frameCount = 0;
    let lastFPSUpdate = 0;
    let fpsValue = 60;
    
    // ==================== INITIALIZATION ====================
    async function init() {
      console.log('Initializing Pockit Ultra...');
      
      // Initialize Rapier Physics
      await RAPIER.init();
      physics = RAPIER;
      world = new RAPIER.World({ x: 0, y: CONFIG.GRAVITY, z: 0 });
      
      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);
      scene.fog = new THREE.FogExp2(0xBBD5EA, 0.006);
      
      // Camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 1000);
      camera.position.set(0, CONFIG.PLAYER_HEIGHT * 2, 15);
      
      // Renderer
      renderer = new THREE.WebGLRenderer({ 
        antialias: true, 
        powerPreference: 'high-performance',
        stencil: false,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.1;
      document.body.appendChild(renderer.domElement);
      
      // Post-processing
      composer = new EffectComposer(renderer);
      composer.addPass(new RenderPass(scene, camera));
      
       const bloomPass = new UnrealBloomPass(
         new THREE.Vector2(window.innerWidth, window.innerHeight),
         0.15, 0.4, 0.5  // Reduced intensity for performance
       );
       composer.addPass(bloomPass);
      
      const smaaPass = new SMAAPass(window.innerWidth, window.innerHeight);
      composer.addPass(smaaPass);
      
      // Motion blur pass (subtle, toggleable)
      motionBlurPass = new ShaderPass(MotionBlurShader);
      motionBlurPass.enabled = false; // Disabled by default
      composer.addPass(motionBlurPass);
      
      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      
       const sun = new THREE.DirectionalLight(0xFFF5E6, 1.4);
       sun.position.set(100, 150, 50);
       sun.castShadow = true;
      sun.shadow.mapSize.width = 256;  // Very low for best performance
      sun.shadow.mapSize.height = 256;
      sun.shadow.camera.left = -150;   // Smaller bounds for performance
      sun.shadow.camera.right = 150;
      sun.shadow.camera.top = 150;
      sun.shadow.camera.bottom = -150;
      sun.shadow.camera.far = 350;
       sun.shadow.bias = -0.0001;
       scene.add(sun);
      
      const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x8B7355, 0.7);
      scene.add(hemiLight);
      
      // World root for scaling
      worldRoot = new THREE.Group();
      scene.add(worldRoot);
      
      // Ground
      createGround();
      
      // Initialize tree prototypes (needed by chunks)
      createTreePrototypes();
      
      // Initialize sidewalk pathfinding grid
      initializeSidewalkGrid();
      
      // Initial city - will load chunks around player position
      // (chunks load automatically in animate loop via updateChunks)
      
      // Player
      createPlayer();
      
      // Portals
      createPortalPair();
      
      // Controls & UI
      setupControls();
      setupUI();
      
      // Spawn special constructions (playgrounds, parking, hospitals)
      spawnSpecialConstructions();
      
      // Spawn pedestrians - optimized count
      spawnPedestrians(40); // Reduced from 100 for better performance
      
      // Generate and spawn clouds - reduced for performance
      generateCloudPrototypes(3);
      spawnClouds(8);
      
      // Hide loading
      setTimeout(() => {
        document.getElementById('loading').classList.add('hidden');
      }, 500);
      
      // Start loop
      requestAnimationFrame(animate);
      
      console.log('Pockit Ultra initialized!');
    }
    
    // ==================== GROUND ====================
    function createGround() {
      const groundSize = 800;  // Larger ground for bigger city
      const segments = 40;  // More detail
       const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize, segments, segments);
      
      // Add noise to vertices
      const positions = groundGeometry.attributes.position;
      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const z = positions.getZ(i);
        const noise = (Math.sin(x * 0.05) * Math.cos(z * 0.05) + 
                      Math.sin(x * 0.1) * Math.cos(z * 0.08)) * 0.6;
        positions.setZ(i, noise);
      }
      groundGeometry.computeVertexNormals();
      
      const groundMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x5A7C3A,
        roughness: 0.9,
        metalness: 0.05,
        flatShading: false,
      });
      
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      worldRoot.add(ground);
      
      // Physics ground
      const groundBodyDesc = physics.RigidBodyDesc.fixed();
      const groundBody = world.createRigidBody(groundBodyDesc);
      const groundColliderDesc = physics.ColliderDesc.cuboid(groundSize / 2, 0.1, groundSize / 2);
      world.createCollider(groundColliderDesc, groundBody);
      
      // Grid helper
      const gridHelper = new THREE.GridHelper(groundSize, 60, 0x555555, 0x666666);
      gridHelper.material.opacity = 0.15;
      gridHelper.material.transparent = true;
      worldRoot.add(gridHelper);
    }
    
    // ==================== CHUNK MANAGEMENT SYSTEM ====================
    
    function getChunkKey(x, z) {
      return `${x},${z}`;
    }
    
    function getChunkCoords(worldX, worldZ) {
      const chunkSize = CONFIG.BLOCK_SIZE + CONFIG.ROAD_WIDTH;
      return {
        x: Math.floor(worldX / chunkSize),
        z: Math.floor(worldZ / chunkSize)
      };
    }
    
    let lastChunkUpdate = 0;
    const CHUNK_UPDATE_INTERVAL = 500; // Update chunks every 500ms
    
    function updateChunks() {
      if (!playerBody) return;
      
      // Throttle chunk updates
      const now = performance.now();
      if (now - lastChunkUpdate < CHUNK_UPDATE_INTERVAL) return;
      lastChunkUpdate = now;
      
      const playerPos = playerBody.translation();
      const playerChunk = getChunkCoords(playerPos.x, playerPos.z);
      
      const chunksToLoad = new Set();
      const loadRadius = Math.ceil(CONFIG.CHUNK_LOAD_DISTANCE / (CONFIG.BLOCK_SIZE + CONFIG.ROAD_WIDTH));
      
      // Find chunks that should be loaded
      for (let dx = -loadRadius; dx <= loadRadius; dx++) {
        for (let dz = -loadRadius; dz <= loadRadius; dz++) {
          const chunkX = playerChunk.x + dx;
          const chunkZ = playerChunk.z + dz;
          const key = getChunkKey(chunkX, chunkZ);
          chunksToLoad.add(key);
        }
      }
      
      // Load new chunks
      chunksToLoad.forEach(key => {
        if (!activeChunks.has(key)) {
          loadChunk(key);
          activeChunks.add(key);
        }
      });
      
      // Unload far chunks
      const unloadRadius = Math.ceil(CONFIG.CHUNK_UNLOAD_DISTANCE / (CONFIG.BLOCK_SIZE + CONFIG.ROAD_WIDTH));
      activeChunks.forEach(key => {
        const [x, z] = key.split(',').map(Number);
        const dist = Math.hypot(x - playerChunk.x, z - playerChunk.z);
        if (dist > unloadRadius) {
          unloadChunk(key);
          activeChunks.delete(key);
        }
      });
    }
    
    function loadChunk(key) {
      const [chunkX, chunkZ] = key.split(',').map(Number);
      
      // Determine district type based on distance from center
      const distFromCenter = Math.hypot(chunkX, chunkZ);
      let district;
      if (distFromCenter < 1.5) {
        district = 'financial';
      } else if (distFromCenter < 3) {
        district = 'midtown';
      } else if (distFromCenter < 4.5) {
        district = 'residential';
      } else {
        district = 'waterfront';
      }
      
      const chunkRoot = new THREE.Group();
      chunkRoot.name = `chunk_${key}`;
      
      const chunkSize = CONFIG.BLOCK_SIZE + CONFIG.ROAD_WIDTH;
      const chunkWorldX = chunkX * chunkSize;
      const chunkWorldZ = chunkZ * chunkSize;
      
      chunkRoot.position.set(chunkWorldX, 0, chunkWorldZ);
      worldRoot.add(chunkRoot);
      chunkRoots.set(key, chunkRoot);
      
      // Generate chunk buildings
      generateChunkBuildings(chunkRoot, chunkX, chunkZ, district);
      
      console.log(`Loaded chunk ${key} (${district})`);
    }
    
    function unloadChunk(key) {
      const chunkRoot = chunkRoots.get(key);
      if (chunkRoot) {
        // Remove all children and physics bodies
        chunkRoot.traverse(child => {
          if (child.geometry) child.geometry.dispose();
          if (child.material) {
            if (Array.isArray(child.material)) {
              child.material.forEach(m => m.dispose());
            } else {
              child.material.dispose();
            }
          }
        });
        
        worldRoot.remove(chunkRoot);
        chunkRoots.delete(key);
        
        // Clean up chunk data
        if (cityChunks.has(key)) {
          const chunk = cityChunks.get(key);
          // Remove building physics bodies
          if (chunk.buildings) {
            chunk.buildings.forEach(building => {
              if (building.body) {
                world.removeRigidBody(building.body);
              }
            });
          }
          // Remove other physics bodies
          if (chunk.bodies) {
            chunk.bodies.forEach(body => world.removeRigidBody(body));
          }
          cityChunks.delete(key);
        }
        
        console.log(`Unloaded chunk ${key}`);
      }
    }
    
    function addBuildingPhysics(building, chunkRoot) {
      if (!building || !building.group) return;
      
      // Get world position of the building
      const worldPos = new THREE.Vector3();
      building.group.getWorldPosition(worldPos);
      
      // Create static physics body for collision
      const bodyDesc = physics.RigidBodyDesc.fixed()
        .setTranslation(worldPos.x, building.height / 2, worldPos.z);
      const body = world.createRigidBody(bodyDesc);
      
      // Create box collider approximation
      const colliderDesc = physics.ColliderDesc.cuboid(
        building.width / 2,
        building.height / 2,
        building.depth / 2
      );
      world.createCollider(colliderDesc, body);
      
      // Store reference
      building.body = body;
    }
    
    function generateChunkBuildings(chunkRoot, chunkX, chunkZ, districtType) {
      const profile = DISTRICT_PROFILES[districtType];
      const numBuildings = CONFIG.BUILDINGS_PER_BLOCK_MIN + 
        Math.floor(Math.random() * (CONFIG.BUILDINGS_PER_BLOCK_MAX - CONFIG.BUILDINGS_PER_BLOCK_MIN + 1));
      
      console.log(`generateChunkBuildings: chunk (${chunkX},${chunkZ}) district=${districtType}, creating ${numBuildings} buildings`);
      
      const blockSize = CONFIG.BLOCK_SIZE;
      const roadWidth = CONFIG.ROAD_WIDTH;
      const sidewalkWidth = CONFIG.SIDEWALK_WIDTH;
      const sidewalkHeight = CONFIG.SIDEWALK_HEIGHT;
      const chunkBuildings = [];
      
      // Create chunk roads and sidewalks
      createChunkRoads(chunkRoot, blockSize, roadWidth, sidewalkWidth, sidewalkHeight);
      
      // Grid or random placement
      const useGrid = Math.random() > 0.3;
      
      if (useGrid) {
        const cols = Math.floor(Math.sqrt(numBuildings));
        const rows = Math.ceil(numBuildings / cols);
        const cellWidth = blockSize / cols;
        const cellDepth = blockSize / rows;
        
        for (let i = 0; i < numBuildings; i++) {
          const col = i % cols;
          const row = Math.floor(i / cols);
          
          const localX = col * cellWidth + cellWidth / 2;
          const localZ = row * cellDepth + cellDepth / 2;
          
          const building = createSegmentedBuilding(localX, localZ, profile, blockSize);
          if (building) {
            chunkRoot.add(building.group);
            chunkBuildings.push(building);
            
            // Add physics collider for building
            addBuildingPhysics(building, chunkRoot);
            
            // Add entry path from building to nearest sidewalk
            createEntryPath(chunkRoot, localX, localZ, building.width, building.depth, blockSize, sidewalkWidth, sidewalkHeight);
          }
        }
      } else {
        for (let i = 0; i < numBuildings; i++) {
          const margin = 3;
          const localX = margin + Math.random() * (blockSize - margin * 2);
          const localZ = margin + Math.random() * (blockSize - margin * 2);
          
          const building = createSegmentedBuilding(localX, localZ, profile, blockSize);
          if (building) {
            chunkRoot.add(building.group);
            chunkBuildings.push(building);
            
            // Add physics collider for building
            addBuildingPhysics(building, chunkRoot);
            
            // Add entry path from building to nearest sidewalk
            createEntryPath(chunkRoot, localX, localZ, building.width, building.depth, blockSize, sidewalkWidth, sidewalkHeight);
          }
        }
      }
      
      // Add park benches in grass areas
      createParkBenches(chunkRoot, blockSize, sidewalkWidth, sidewalkHeight);
      
      // Add curved sidewalks for large empty areas
      if (numBuildings < 3) {
        createCurvedSidewalk(chunkRoot, blockSize, sidewalkWidth, sidewalkHeight);
      }
      
      // Add grass blades to grassy areas
      createGrassField(chunkRoot, blockSize, sidewalkWidth, chunkBuildings);
      
      // Store chunk data
      const key = getChunkKey(chunkX, chunkZ);
      cityChunks.set(key, {
        district: districtType,
        buildings: chunkBuildings,
        bodies: []
      });
    }
    
    function createEntryPath(chunkRoot, buildingX, buildingZ, buildingWidth, buildingDepth, blockSize, sidewalkWidth, sidewalkHeight) {
      // Find nearest sidewalk edge
      const edges = [
        { side: 'left', dist: buildingX, x: -sidewalkWidth/2, z: buildingZ },
        { side: 'right', dist: blockSize - buildingX, x: blockSize + sidewalkWidth/2, z: buildingZ },
        { side: 'top', dist: buildingZ, x: buildingX, z: -sidewalkWidth/2 },
        { side: 'bottom', dist: blockSize - buildingZ, x: buildingX, z: blockSize + sidewalkWidth/2 }
      ];
      
      const nearest = edges.reduce((min, edge) => edge.dist < min.dist ? edge : min);
      
      // Create concrete path
      const pathMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x787878, 
        roughness: 0.9, 
        metalness: 0.05 
      });
      
      const pathWidth = 2.0;
      const pathHeight = sidewalkHeight - 0.01;
      
      if (nearest.side === 'left' || nearest.side === 'right') {
        // Horizontal path
        const pathLength = nearest.dist;
        const pathGeo = new THREE.BoxGeometry(pathLength, pathHeight, pathWidth);
        const path = new THREE.Mesh(pathGeo, pathMaterial);
        path.position.set(
          buildingX + (nearest.x - buildingX) / 2,
          pathHeight / 2,
          buildingZ
        );
        path.receiveShadow = true;
        chunkRoot.add(path);
      } else {
        // Vertical path
        const pathLength = nearest.dist;
        const pathGeo = new THREE.BoxGeometry(pathWidth, pathHeight, pathLength);
        const path = new THREE.Mesh(pathGeo, pathMaterial);
        path.position.set(
          buildingX,
          pathHeight / 2,
          buildingZ + (nearest.z - buildingZ) / 2
        );
        path.receiveShadow = true;
        chunkRoot.add(path);
      }
    }
    
    function createParkBenches(chunkRoot, blockSize, sidewalkWidth, sidewalkHeight) {
      const benchMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x4a3828, 
        roughness: 0.8, 
        metalness: 0.1 
      });
      
      // Add benches along sidewalks IN THE GRASS (inside block perimeter)
      const benchPositions = [];
      const benchInset = 2.5; // Distance from block edge into the grass
      
      // Left side (inside block, near west edge)
      for (let z = 10; z < blockSize - 10; z += 15) {
        if (Math.random() > 0.5) {
          benchPositions.push({ x: benchInset, z: z, rotation: -Math.PI/2 }); // Facing outward (west)
        }
      }
      
      // Right side (inside block, near east edge)
      for (let z = 10; z < blockSize - 10; z += 15) {
        if (Math.random() > 0.5) {
          benchPositions.push({ x: blockSize - benchInset, z: z, rotation: Math.PI/2 }); // Facing outward (east)
        }
      }
      
      // Top side (inside block, near north edge)
      for (let x = 10; x < blockSize - 10; x += 15) {
        if (Math.random() > 0.5) {
          benchPositions.push({ x: x, z: benchInset, rotation: Math.PI }); // Facing outward (north)
        }
      }
      
      // Bottom side (inside block, near south edge)
      for (let x = 10; x < blockSize - 10; x += 15) {
        if (Math.random() > 0.5) {
          benchPositions.push({ x: x, z: blockSize - benchInset, rotation: 0 }); // Facing outward (south)
        }
      }
      
      // Create simple benches (scaled up 2.5x)
      benchPositions.forEach(pos => {
        const benchGroup = new THREE.Group();
        const scale = 2.5; // Make benches bigger
        
        // Seat
        const seatGeo = new THREE.BoxGeometry(1.2 * scale, 0.08 * scale, 0.4 * scale);
        const seat = new THREE.Mesh(seatGeo, benchMaterial);
        seat.position.y = 0.35 * scale;
        benchGroup.add(seat);
        
        // Back rest
        const backGeo = new THREE.BoxGeometry(1.2 * scale, 0.4 * scale, 0.08 * scale);
        const back = new THREE.Mesh(backGeo, benchMaterial);
        back.position.set(0, 0.55 * scale, -0.16 * scale);
        benchGroup.add(back);
        
        // Legs (simple)
        const legGeo = new THREE.BoxGeometry(0.08 * scale, 0.35 * scale, 0.08 * scale);
        [-0.5, 0.5].forEach(xOff => {
          [-0.15, 0.15].forEach(zOff => {
            const leg = new THREE.Mesh(legGeo, benchMaterial);
            leg.position.set(xOff * scale, 0.175 * scale, zOff * scale);
            benchGroup.add(leg);
          });
        });
        
        benchGroup.position.set(pos.x, 0.01, pos.z); // On the ground, not on sidewalk
        benchGroup.rotation.y = pos.rotation;
        
        // Mark as atomic pickable object for viewport
        benchGroup.userData.isAtomic = true;
        benchGroup.userData.pickable = true;
        benchGroup.userData.objectType = 'bench';
        
        chunkRoot.add(benchGroup);
      });
    }
    
    function createCurvedSidewalk(chunkRoot, blockSize, sidewalkWidth, sidewalkHeight) {
      // Create a curved path through the grass connecting opposite sidewalks
      const sidewalkMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x666666, 
        roughness: 0.85, 
        metalness: 0.02 
      });
      
      // Helper to sample ground height (same as createGround noise function)
      const getGroundHeight = (worldX, worldZ) => {
        const noise = (Math.sin(worldX * 0.05) * Math.cos(worldZ * 0.05) + 
                      Math.sin(worldX * 0.1) * Math.cos(worldZ * 0.08)) * 0.6;
        return noise;
      };
      
      const pathWidth = 2.5; // Wider path
      const segments = 30; // More segments for better terrain following
      
      // Random curve type
      const curveType = Math.random();
      
      let curve;
      if (curveType < 0.5) {
        // Diagonal curve from one corner to opposite
        const points = [];
        for (let i = 0; i <= segments; i++) {
          const t = i / segments;
          const localX = t * blockSize;
          const localZ = t * blockSize + Math.sin(t * Math.PI) * (blockSize * 0.2);
          points.push(new THREE.Vector3(localX, 0, localZ));
        }
        curve = new THREE.CatmullRomCurve3(points);
      } else {
        // S-curve from one side to another
        const points = [];
        for (let i = 0; i <= segments; i++) {
          const t = i / segments;
          const localX = blockSize / 2 + Math.sin(t * Math.PI * 2) * (blockSize * 0.3);
          const localZ = t * blockSize;
          points.push(new THREE.Vector3(localX, 0, localZ));
        }
        curve = new THREE.CatmullRomCurve3(points);
      }
      
      // Get chunk world position for ground height sampling
      const chunkWorldPos = new THREE.Vector3();
      chunkRoot.getWorldPosition(chunkWorldPos);
      
      // Create path geometry along curve with terrain following
      const curvePoints = curve.getPoints(segments);
      const pathGeometry = new THREE.BufferGeometry();
      const vertices = [];
      const indices = [];
      
      for (let i = 0; i < curvePoints.length; i++) {
        const point = curvePoints[i];
        const tangent = curve.getTangent(i / (curvePoints.length - 1));
        const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
        
        // Calculate world position for this point
        const worldX = chunkWorldPos.x + point.x;
        const worldZ = chunkWorldPos.z + point.z;
        
        // Sample ground height at both edges of the path
        const leftWorldX = worldX + normal.x * pathWidth / 2;
        const leftWorldZ = worldZ + normal.z * pathWidth / 2;
        const rightWorldX = worldX - normal.x * pathWidth / 2;
        const rightWorldZ = worldZ - normal.z * pathWidth / 2;
        
        const leftHeight = getGroundHeight(leftWorldX, leftWorldZ) + sidewalkHeight;
        const rightHeight = getGroundHeight(rightWorldX, rightWorldZ) + sidewalkHeight;
        
        vertices.push(
          point.x + normal.x * pathWidth / 2, leftHeight, point.z + normal.z * pathWidth / 2,
          point.x - normal.x * pathWidth / 2, rightHeight, point.z - normal.z * pathWidth / 2
        );
        
        if (i < curvePoints.length - 1) {
          const base = i * 2;
          indices.push(base, base + 1, base + 2);
          indices.push(base + 1, base + 3, base + 2);
        }
      }
      
      pathGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      pathGeometry.setIndex(indices);
      pathGeometry.computeVertexNormals();
      
      const path = new THREE.Mesh(pathGeometry, sidewalkMaterial);
      path.receiveShadow = true;
      chunkRoot.add(path);
    }
    
    function createGrassField(chunkRoot, blockSize, sidewalkWidth, buildings) {
      // Create instanced grass blades for performance
      const grassBladesPerSqMeter = 6;
      const grassArea = blockSize * blockSize;
      const totalBlades = Math.floor(grassArea * grassBladesPerSqMeter);
      
      // Create tapered blade geometry (narrow at top)
      const bladeGeo = new THREE.BufferGeometry();
      const bladeSegments = 4;
      const positions = [];
      const uvs = [];
      const indices = [];
      
      // Build blade vertices - tapered
      for (let i = 0; i <= bladeSegments; i++) {
        const t = i / bladeSegments;
        const y = t;
        const width = (1 - t * 0.9); // Taper to 10% at top
        const bend = t * t * 0.1; // Quadratic bend
        
        positions.push(-width * 0.05 + bend, y, 0);
        positions.push(width * 0.05 + bend, y, 0);
        uvs.push(0, t);
        uvs.push(1, t);
        
        if (i < bladeSegments) {
          const base = i * 2;
          indices.push(base, base + 1, base + 2);
          indices.push(base + 1, base + 3, base + 2);
        }
      }
      
      bladeGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      bladeGeo.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
      bladeGeo.setIndex(indices);
      bladeGeo.computeVertexNormals();
      
      // Shader material with animated sway
      const grassMaterial = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          grassColor: { value: new THREE.Color(0x4a7c30) },
          tipColor: { value: new THREE.Color(0x6a9c40) }
        },
        vertexShader: `
          varying vec2 vUv;
          varying vec3 vPosition;
          uniform float time;
          
          void main() {
            vUv = uv;
            vPosition = position;
            
            // Sway animation - only affect top vertices
            float swayAmount = vUv.y; // More sway at top
            float sway = sin(time * 2.0 + position.x * 3.0 + position.z * 2.0) * 0.08 * swayAmount;
            float sway2 = cos(time * 1.5 + position.x * 2.0 + position.z * 3.0) * 0.05 * swayAmount;
            
            vec3 newPos = position;
            newPos.x += sway + sway2;
            newPos.z += sway * 0.5;
            
            vec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0);
            gl_Position = projectionMatrix * mvPosition;
          }
        `,
        fragmentShader: `
          uniform vec3 grassColor;
          uniform vec3 tipColor;
          varying vec2 vUv;
          varying vec3 vPosition;
          
          void main() {
            // Gradient from base to tip
            vec3 color = mix(grassColor, tipColor, vUv.y * vUv.y);
            
            // Add some variation
            color += vec3(sin(vPosition.x * 20.0) * 0.02);
            
            gl_FragColor = vec4(color, 1.0);
          }
        `,
        side: THREE.DoubleSide
      });
      
      const instancedGrass = new THREE.InstancedMesh(bladeGeo, grassMaterial, totalBlades);
      instancedGrass.receiveShadow = true;
      instancedGrass.castShadow = false;
      instancedGrass.userData.isGrass = true;
      instancedGrass.userData.material = grassMaterial;
      
      const matrix = new THREE.Matrix4();
      const position = new THREE.Vector3();
      const rotation = new THREE.Euler();
      const quaternion = new THREE.Quaternion();
      const scale = new THREE.Vector3();
      
      let instanceIndex = 0;
      
      // Place grass blades randomly
      for (let i = 0; i < totalBlades; i++) {
        const x = Math.random() * blockSize;
        const z = Math.random() * blockSize;
        
        // Check if too close to buildings
        let tooClose = false;
        for (const building of buildings) {
          const bx = building.group.position.x;
          const bz = building.group.position.z;
          const dist = Math.hypot(x - bx, z - bz);
          if (dist < (building.width + building.depth) / 2 + 2) {
            tooClose = true;
            break;
          }
        }
        
        if (tooClose) continue;
        
        position.set(x, 0, z);
        rotation.set(0, Math.random() * Math.PI * 2, 0);
        quaternion.setFromEuler(rotation);
        // Varied height and width
        const heightVar = 0.6 + Math.random() * 0.8;
        const widthVar = 0.7 + Math.random() * 0.6;
        scale.set(widthVar, heightVar, 1);
        
        matrix.compose(position, quaternion, scale);
        instancedGrass.setMatrixAt(instanceIndex, matrix);
        instanceIndex++;
      }
      
      instancedGrass.count = instanceIndex;
      instancedGrass.instanceMatrix.needsUpdate = true;
      
      chunkRoot.add(instancedGrass);
    }
    
    function createChunkRoads(chunkRoot, blockSize, roadWidth, sidewalkWidth, sidewalkHeight) {
      const roadMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x2a2a2a,
        roughness: 0.95,
        metalness: 0.05
      });
      
      const sidewalkMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x666666,
        roughness: 0.85,
        metalness: 0.02
      });
      
      // Create roads around perimeter (between blocks)
      const roadPositions = [
        // Left road (west)
        { x: -roadWidth/2 - sidewalkWidth, y: 0.02, z: blockSize/2, w: roadWidth - sidewalkWidth * 2, d: blockSize + roadWidth },
        // Right road (east)
        { x: blockSize + roadWidth/2 + sidewalkWidth, y: 0.02, z: blockSize/2, w: roadWidth - sidewalkWidth * 2, d: blockSize + roadWidth },
        // Top road (north)
        { x: blockSize/2, y: 0.02, z: -roadWidth/2 - sidewalkWidth, w: blockSize + roadWidth, d: roadWidth - sidewalkWidth * 2 },
        // Bottom road (south)
        { x: blockSize/2, y: 0.02, z: blockSize + roadWidth/2 + sidewalkWidth, w: blockSize + roadWidth, d: roadWidth - sidewalkWidth * 2 }
      ];
      
      roadPositions.forEach(pos => {
        const roadGeo = new THREE.PlaneGeometry(pos.w, pos.d);
        const road = new THREE.Mesh(roadGeo, roadMaterial);
        road.rotation.x = -Math.PI / 2;
        road.position.set(pos.x, pos.y, pos.z);
        road.receiveShadow = true;
        chunkRoot.add(road);
      });
      
      // Create sidewalks around perimeter of block
      const sidewalkPositions = [
        // Left sidewalk (west)
        { x: -sidewalkWidth/2, y: sidewalkHeight/2, z: blockSize/2, w: sidewalkWidth, h: sidewalkHeight, d: blockSize },
        // Right sidewalk (east)
        { x: blockSize + sidewalkWidth/2, y: sidewalkHeight/2, z: blockSize/2, w: sidewalkWidth, h: sidewalkHeight, d: blockSize },
        // Top sidewalk (north)
        { x: blockSize/2, y: sidewalkHeight/2, z: -sidewalkWidth/2, w: blockSize, h: sidewalkHeight, d: sidewalkWidth },
        // Bottom sidewalk (south)
        { x: blockSize/2, y: sidewalkHeight/2, z: blockSize + sidewalkWidth/2, w: blockSize, h: sidewalkHeight, d: sidewalkWidth }
      ];
      
      sidewalkPositions.forEach(pos => {
        const sidewalkGeo = new THREE.BoxGeometry(pos.w, pos.h, pos.d);
        const sidewalk = new THREE.Mesh(sidewalkGeo, sidewalkMaterial);
        sidewalk.position.set(pos.x, pos.y, pos.z);
        sidewalk.receiveShadow = true;
        sidewalk.castShadow = false;
        chunkRoot.add(sidewalk);
      });
      
      // Add trees along sidewalks
      const treePositions = [];
      for (let i = 5; i < blockSize; i += 8) {
        if (Math.random() > 0.3) {
          treePositions.push({ x: -sidewalkWidth/2, z: i });
          treePositions.push({ x: blockSize + sidewalkWidth/2, z: i });
        }
      }
      for (let i = 5; i < blockSize; i += 8) {
        if (Math.random() > 0.3) {
          treePositions.push({ x: i, z: -sidewalkWidth/2 });
          treePositions.push({ x: i, z: blockSize + sidewalkWidth/2 });
        }
      }
      
      // Place trees
      if (treePrototypes.length === 0) {
        createTreePrototypes();
      }
      
      treePositions.forEach(pos => {
        const protoIdx = Math.floor(Math.random() * treePrototypes.length);
        const treeClone = treePrototypes[protoIdx].clone();
        treeClone.position.set(pos.x, sidewalkHeight, pos.z);
        treeClone.rotation.y = Math.random() * Math.PI * 2;
        const scale = 0.9 + Math.random() * 0.3;
        treeClone.scale.set(scale, scale, scale);
        chunkRoot.add(treeClone);
      });
      
      // Add street lights (visual only - no actual point lights to avoid shader uniform limit)
      const lightPositions = [];
      for (let i = 10; i < blockSize; i += 20) {
        lightPositions.push({ x: -sidewalkWidth * 0.8, z: i });
        lightPositions.push({ x: blockSize + sidewalkWidth * 0.8, z: i + 10 });
      }
      for (let i = 10; i < blockSize; i += 20) {
        lightPositions.push({ x: i, z: -sidewalkWidth * 0.8 });
        lightPositions.push({ x: i + 10, z: blockSize + sidewalkWidth * 0.8 });
      }
      
      // Create simple street light (visual only - emissive materials, NO point lights)
      lightPositions.forEach(pos => {
        const lightGroup = new THREE.Group();
        
        // Pole
        const poleGeo = new THREE.CylinderGeometry(0.08, 0.1, 6, 6);
        const poleMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.6, metalness: 0.8 });
        const pole = new THREE.Mesh(poleGeo, poleMat);
        pole.position.y = 3;
        pole.castShadow = false;
        lightGroup.add(pole);
        
        // Light bulb (glowing, but no actual light source)
        const bulbGeo = new THREE.SphereGeometry(0.15, 6, 4);
        const bulbMat = new THREE.MeshStandardMaterial({ 
          color: 0xffffee, 
          emissive: 0xffdd88, 
          emissiveIntensity: 2.0  // Brighter emissive to fake lighting
        });
        const bulb = new THREE.Mesh(bulbGeo, bulbMat);
        bulb.position.y = 5.5;
        lightGroup.add(bulb);
        
        // NO point light - this was causing shader uniform overflow
        
        lightGroup.position.set(pos.x, sidewalkHeight, pos.z);
        chunkRoot.add(lightGroup);
      });
    }
    
    // ==================== SLIDING DOOR SYSTEM ====================
    // Note: Door system is handled by the existing addDoorToBuilding function
    // which creates doors compatible with the updateDoors animation system
    
    // ==================== LASSO / GRAPPLING HOOK SYSTEM ====================
    
    function toggleLasso() {
      lassoEnabled = !lassoEnabled;
      
      if (lassoEnabled) {
        createLassoVisual();
        console.log('Lasso enabled - M1 to grapple, M2 to swing');
      } else {
        removeLassoVisual();
        releaseGrapple();
        console.log('Lasso disabled');
      }
    }
    
    function createLassoVisual() {
      if (lassoVisual) return;
      
      // Create glowing green lasso indicator at screen center
      const lassoGeo = new THREE.RingGeometry(0.015, 0.025, 16);
      const lassoMat = new THREE.MeshBasicMaterial({ 
        color: 0x00ff00, 
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.8
      });
      lassoVisual = new THREE.Mesh(lassoGeo, lassoMat);
      
      // Position in front of camera
      lassoVisual.position.set(0, 0, -0.5);
      camera.add(lassoVisual);
    }
    
    function removeLassoVisual() {
      if (lassoVisual) {
        camera.remove(lassoVisual);
        lassoVisual.geometry.dispose();
        lassoVisual.material.dispose();
        lassoVisual = null;
      }
    }
    
    function fireGrapple() {
      if (!lassoEnabled || !playerBody) return;
      
      // Raycast from camera center
      raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
      const intersects = raycaster.intersectObjects(worldRoot.children, true);
      
      if (intersects.length > 0) {
        const hit = intersects[0];
        const hitPoint = hit.point;
        
        // Create grapple hook
        grapplingHook = {
          attachPoint: hitPoint.clone(),
          active: true,
          pullStrength: 50, // Strong pull
          maxDistance: 100
        };
        
        createRopeVisual(hitPoint);
        console.log('Grapple fired!');
      }
    }
    
    function fireSwingRope() {
      if (!lassoEnabled || !playerBody) return;
      
      const playerPos = playerBody.translation();
      const isGrounded = Math.abs(playerBody.linvel().y) < 0.1;
      
      if (isGrounded) {
        // On ground - acts like grapple
        fireGrapple();
        return;
      }
      
      // In air - create swing rope
      raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
      const intersects = raycaster.intersectObjects(worldRoot.children, true);
      
      if (intersects.length > 0) {
        const hit = intersects[0];
        const hitPoint = hit.point;
        const ropeLength = hitPoint.distanceTo(new THREE.Vector3(playerPos.x, playerPos.y, playerPos.z));
        
        // Create swing rope
        swingRope = {
          attachPoint: hitPoint.clone(),
          active: true,
          length: ropeLength,
          damping: 0.98,
          tension: 0.95
        };
        
        createRopeVisual(hitPoint);
        console.log('Swing rope attached!');
      }
    }
    
    function createRopeVisual(attachPoint) {
      if (ropeVisual) {
        scene.remove(ropeVisual);
        ropeVisual.geometry.dispose();
        ropeVisual.material.dispose();
      }
      
      const ropeMat = new THREE.LineBasicMaterial({ 
        color: 0x00ff00, 
        linewidth: 2,
        transparent: true,
        opacity: 0.8
      });
      
      const ropeGeo = new THREE.BufferGeometry();
      const positions = new Float32Array(6); // 2 points
      ropeGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      
      ropeVisual = new THREE.Line(ropeGeo, ropeMat);
      ropeVisual.userData.attachPoint = attachPoint;
      scene.add(ropeVisual);
    }
    
    function updateRopeVisual() {
      if (!ropeVisual || !playerBody) return;
      
      const playerPos = playerBody.translation();
      const attachPoint = ropeVisual.userData.attachPoint;
      
      const positions = ropeVisual.geometry.attributes.position.array;
      positions[0] = attachPoint.x;
      positions[1] = attachPoint.y;
      positions[2] = attachPoint.z;
      positions[3] = playerPos.x;
      positions[4] = playerPos.y + 1.0; // Attach at chest height
      positions[5] = playerPos.z;
      
      ropeVisual.geometry.attributes.position.needsUpdate = true;
    }
    
    function updateGrapplePhysics(deltaTime) {
      if (!grapplingHook || !grapplingHook.active || !playerBody) return;
      
      const playerPos = playerBody.translation();
      const playerVel = playerBody.linvel();
      const attachPoint = grapplingHook.attachPoint;
      
      const toAttach = new THREE.Vector3(
        attachPoint.x - playerPos.x,
        attachPoint.y - playerPos.y,
        attachPoint.z - playerPos.z
      );
      
      const distance = toAttach.length();
      
      if (distance > grapplingHook.maxDistance) {
        releaseGrapple();
        return;
      }
      
      // Pull toward attach point
      toAttach.normalize();
      const pullForce = grapplingHook.pullStrength * playerScale;
      
      // Apply force with momentum preservation
      const currentSpeed = Math.sqrt(playerVel.x * playerVel.x + playerVel.z * playerVel.z);
      const speedBoost = Math.min(1.5, 1 + currentSpeed * 0.1);
      
      playerBody.applyImpulse({
        x: toAttach.x * pullForce * deltaTime * speedBoost,
        y: toAttach.y * pullForce * deltaTime * speedBoost * 0.8, // Less upward pull
        z: toAttach.z * pullForce * deltaTime * speedBoost
      }, true);
    }
    
    function updateSwingPhysics(deltaTime) {
      if (!swingRope || !swingRope.active || !playerBody) return;
      
      const playerPos = playerBody.translation();
      const playerVel = playerBody.linvel();
      const attachPoint = swingRope.attachPoint;
      
      // Vector from player to attach point
      const ropeVec = new THREE.Vector3(
        attachPoint.x - playerPos.x,
        attachPoint.y - playerPos.y,
        attachPoint.z - playerPos.z
      );
      
      const currentLength = ropeVec.length();
      const targetLength = swingRope.length;
      
      // Spider-Man 2 Style Physics
      if (currentLength > targetLength * 0.95) { // Activate when near rope length
        const ropeDir = ropeVec.clone().normalize();
        
        // Velocity components
        const velocity = new THREE.Vector3(playerVel.x, playerVel.y, playerVel.z);
        const radialSpeed = velocity.dot(ropeDir); // Speed toward/away from anchor
        const radialVel = ropeDir.clone().multiplyScalar(radialSpeed);
        const tangentVel = velocity.clone().sub(radialVel); // Perpendicular velocity
        
        // Constraint: can't exceed rope length
        if (currentLength > targetLength) {
          // Hard constraint - set position
          const correction = ropeDir.clone().multiplyScalar(currentLength - targetLength);
          playerBody.setTranslation({
            x: playerPos.x + correction.x,
            y: playerPos.y + correction.y,
            z: playerPos.z + correction.z
          }, true);
          
          // Kill radial velocity if moving away
          if (radialSpeed > 0) {
            velocity.sub(radialVel); // Remove outward velocity
          }
        }
        
        // Apply pendulum physics - convert potential energy to kinetic
        // Gravity acceleration decomposed into rope direction
        const gravity = new THREE.Vector3(0, -9.81, 0);
        const tangentGravity = gravity.clone().sub(ropeDir.clone().multiplyScalar(gravity.dot(ropeDir)));
        
        // Apply tangential acceleration (swinging force)
        const swingForce = tangentGravity.multiplyScalar(playerScale * 2.5); // Boost for dramatic swings
        playerBody.applyImpulse({
          x: swingForce.x * deltaTime,
          y: swingForce.y * deltaTime,
          z: swingForce.z * deltaTime
        }, true);
        
        // Apply centripetal force to maintain circular motion
        const tangentSpeed = tangentVel.length();
        const centripetalForce = (tangentSpeed * tangentSpeed) / targetLength;
        const centripetalImpulse = ropeDir.clone().multiplyScalar(centripetalForce * playerScale * deltaTime);
        
        playerBody.applyImpulse({
          x: centripetalImpulse.x,
          y: centripetalImpulse.y,
          z: centripetalImpulse.z
        }, true);
        
        // Air control - guide swing momentum (Spider-Man style)
        if (keys.has('KeyW') || keys.has('KeyS') || keys.has('KeyA') || keys.has('KeyD')) {
          const camQuat = new THREE.Quaternion();
          camQuat.setFromEuler(new THREE.Euler(pitch, yaw, 0, 'YXZ'));
          
          const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camQuat);
          const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camQuat);
          forward.y = 0;
          right.y = 0;
          forward.normalize();
          right.normalize();
          
          const inputVec = new THREE.Vector3();
          if (keys.has('KeyW')) inputVec.add(forward);
          if (keys.has('KeyS')) inputVec.sub(forward);
          if (keys.has('KeyD')) inputVec.add(right);
          if (keys.has('KeyA')) inputVec.sub(right);
          
          if (inputVec.length() > 0) {
            inputVec.normalize();
            
            // Project input onto tangent plane (perpendicular to rope)
            const inputDotRope = inputVec.dot(ropeDir);
            const tangentInput = inputVec.clone().sub(ropeDir.clone().multiplyScalar(inputDotRope));
            
            // Check if input aligns with current tangent velocity
            const currentTangentDir = tangentVel.clone().normalize();
            const alignment = tangentInput.dot(currentTangentDir);
            
            // Boost momentum if aligned with swing direction
            let forceMultiplier = 20; // Base force
            if (alignment > 0.3) {
              // Pushing in direction of swing - boost momentum significantly!
              forceMultiplier = 35 * (1 + alignment * 0.5);
            } else if (alignment < -0.2) {
              // Trying to change direction - allow but with less force
              forceMultiplier = 15;
            }
            
            const airControlForce = tangentInput.multiplyScalar(forceMultiplier * playerScale * deltaTime);
            playerBody.applyImpulse({
              x: airControlForce.x,
              y: airControlForce.y,
              z: airControlForce.z
            }, true);
          }
        }
        
        // Minimal damping to preserve momentum (Spider-Man 2 style)
        const currentVel = playerBody.linvel();
        playerBody.setLinvel({
          x: currentVel.x * 0.998,
          y: currentVel.y * 0.999,
          z: currentVel.z * 0.998
        }, true);
        
      } else {
        // Below rope length - free fall with almost no drag (preserve momentum for launch)
        const currentVel = playerBody.linvel();
        playerBody.setLinvel({
          x: currentVel.x * 0.999,
          y: currentVel.y * 0.999,
          z: currentVel.z * 0.999
        }, true);
      }
    }
    
    function releaseGrapple() {
      // Apply momentum boost on release for dramatic launches (Spider-Man style)
      if ((grapplingHook || swingRope) && playerBody) {
        const currentVel = playerBody.linvel();
        const speed = Math.sqrt(currentVel.x * currentVel.x + currentVel.y * currentVel.y + currentVel.z * currentVel.z);
        
        // If moving fast, give a small boost for dramatic effect
        if (speed > 10) {
          const boostFactor = 1.15;
          playerBody.setLinvel({
            x: currentVel.x * boostFactor,
            y: currentVel.y * boostFactor,
            z: currentVel.z * boostFactor
          }, true);
          console.log(`Released with momentum! Speed: ${(speed * boostFactor).toFixed(1)}`);
        }
      }
      
      if (grapplingHook) {
        grapplingHook.active = false;
        grapplingHook = null;
      }
      
      if (swingRope) {
        swingRope.active = false;
        swingRope = null;
      }
      
      if (ropeVisual) {
        scene.remove(ropeVisual);
        ropeVisual.geometry.dispose();
        ropeVisual.material.dispose();
        ropeVisual = null;
      }
    }
    
    // ==================== SEGMENTED BUILDING SYSTEM ====================
    
    function createSegmentedBuilding(localX, localZ, profile, blockSize) {
      const buildingGroup = new THREE.Group();
      const style = profile.buildingStyle;
      
      // Building dimensions
      const width = style.widthRange[0] + Math.random() * (style.widthRange[1] - style.widthRange[0]);
      const depth = style.depthRange[0] + Math.random() * (style.depthRange[1] - style.depthRange[0]);
      const totalHeight = style.heightRange[0] + Math.random() * (style.heightRange[1] - style.heightRange[0]);
      
      buildingGroup.position.set(localX, 0, localZ);
      
      // Pick colors
      const baseColor = profile.colorPalette[Math.floor(Math.random() * profile.colorPalette.length)];
      const accentColor = new THREE.Color(baseColor).multiplyScalar(1.15).getHex();
      
      // Pick window color from array
      const windowColor = profile.windowColors[Math.floor(Math.random() * profile.windowColors.length)];
      
      // Determine which facade faces the nearest sidewalk
      const edges = [
        { side: 'front', dist: blockSize - localZ, facingZ: 1 },  // Front (+Z)
        { side: 'back', dist: localZ, facingZ: -1 },              // Back (-Z)
        { side: 'right', dist: blockSize - localX, facingX: 1 },  // Right (+X)
        { side: 'left', dist: localX, facingX: -1 }               // Left (-X)
      ];
      const nearestSide = edges.reduce((min, edge) => edge.dist < min.dist ? edge : min);
      
      // Create base/podium (first 2-3 floors) with door on correct facade
      const podiumHeight = 8 + Math.random() * 4;
      createPodium(buildingGroup, width, depth, podiumHeight, baseColor, nearestSide);
      
      // Create shaft with potential setbacks
      let currentY = podiumHeight;
      let currentWidth = width;
      let currentDepth = depth;
      
      const floorHeight = 4.0;
      const totalFloors = Math.floor((totalHeight - podiumHeight) / floorHeight);
      
      // Apply setbacks if enabled
      if (Math.random() < style.setbackChance && style.setbackSchedule.length > 0) {
        let nextSetback = 0;
        let floorsBuilt = 0;
        
        while (floorsBuilt < totalFloors && nextSetback < style.setbackSchedule.length) {
          const setback = style.setbackSchedule[nextSetback];
          const floorsUntilSetback = Math.min(setback.atFloor - floorsBuilt, totalFloors - floorsBuilt);
          
          if (floorsUntilSetback > 0) {
            const segmentHeight = floorsUntilSetback * floorHeight;
            createShaftSegment(buildingGroup, currentWidth, currentDepth, segmentHeight, currentY, 
              baseColor, accentColor, style, windowColor);
            currentY += segmentHeight;
            floorsBuilt += floorsUntilSetback;
          }
          
          // Apply setback
          currentWidth -= setback.inset * 2;
          currentDepth -= setback.inset * 2;
          nextSetback++;
        }
        
        // Build remaining floors
        if (floorsBuilt < totalFloors) {
          const segmentHeight = (totalFloors - floorsBuilt) * floorHeight;
          createShaftSegment(buildingGroup, currentWidth, currentDepth, segmentHeight, currentY,
            baseColor, accentColor, style, windowColor);
          currentY += segmentHeight;
        }
      } else {
        // No setbacks - single shaft
        const shaftHeight = totalFloors * floorHeight;
        createShaftSegment(buildingGroup, currentWidth, currentDepth, shaftHeight, podiumHeight,
          baseColor, accentColor, style, windowColor);
        currentY += shaftHeight;
      }
      
      // Add crown/topper
      const crownStyles = style.crownStyle;
      const crownType = crownStyles[Math.floor(Math.random() * crownStyles.length)];
      if (crownType !== 'none') {
        createCrown(buildingGroup, currentWidth, currentDepth, currentY, crownType, baseColor, accentColor);
      }
      
        console.log(`Created building at (${localX}, ${localZ}) with height ${currentY.toFixed(1)}m, ${buildingGroup.children.length} children`);
        
        // Mark as atomic pickable object for viewport
        buildingGroup.userData.isAtomic = true;
        buildingGroup.userData.pickable = true;
        buildingGroup.userData.objectType = 'building';
        
        return {
          group: buildingGroup,
          width: width,
          depth: depth,
          height: currentY
        };
    }
    
    function createPodium(parent, width, depth, height, color, doorFacing) {
      const geometries = [];
      
      // Main podium box
      const podiumGeo = new THREE.BoxGeometry(width, height, depth);
      const podiumMesh = new THREE.Mesh(podiumGeo);
      podiumMesh.position.y = height / 2;
      podiumMesh.updateMatrix();
      geometries.push(podiumMesh.geometry.clone().applyMatrix4(podiumMesh.matrix));
      
      // Merge all podium geometries
      const mergedGeo = BufferGeometryUtils.mergeGeometries(geometries);
      const podiumMat = new THREE.MeshStandardMaterial({ color, roughness: 0.75, metalness: 0.15 });
      const podium = new THREE.Mesh(mergedGeo, podiumMat);
      podium.castShadow = true;
      podium.receiveShadow = true;
      parent.add(podium);
      
      // Note: Door system handled elsewhere - removed incomplete implementation
    }
    
    function createShaftSegment(parent, width, depth, height, yOffset, baseColor, accentColor, style, windowColor) {
      const geometries = [];
      
      // Main shaft volume
      const shaftGeo = new THREE.BoxGeometry(width, height, depth);
      const shaftMesh = new THREE.Mesh(shaftGeo);
      shaftMesh.position.y = yOffset + height / 2;
      shaftMesh.updateMatrix();
      geometries.push(shaftMesh.geometry.clone().applyMatrix4(shaftMesh.matrix));
      
      // Corner treatment (merge with shaft)
      if (style.cornerTreatment === 'thinBar') {
        const barWidth = 0.15;
        const barGeo = new THREE.BoxGeometry(barWidth, height, barWidth);
        
        // Four corners
        [[-width/2, -depth/2], [width/2, -depth/2], [width/2, depth/2], [-width/2, depth/2]].forEach(([x, z]) => {
          const barMesh = new THREE.Mesh(barGeo);
          barMesh.position.set(x, yOffset + height/2, z);
          barMesh.updateMatrix();
          geometries.push(barMesh.geometry.clone().applyMatrix4(barMesh.matrix));
        });
      }
      
      // Merge shaft and corners
      const mergedGeo = BufferGeometryUtils.mergeGeometries(geometries);
      const shaftMat = new THREE.MeshStandardMaterial({ color: baseColor, roughness: 0.75, metalness: 0.15 });
      const shaft = new THREE.Mesh(mergedGeo, shaftMat);
      shaft.castShadow = true;
      shaft.receiveShadow = true;
      parent.add(shaft);
      
      // Add windows based on style - fewer for performance
      const floorHeight = 4.0;
      const floors = Math.max(2, Math.floor(height / floorHeight));
      
      // Window color variations
      let litColor, dimColor;
      if (windowColor === 'yellow') {
        litColor = 0xFFEB99;
        dimColor = 0x6A5A4A;
      } else if (windowColor === 'white') {
        litColor = 0xFFFFFF;
        dimColor = 0x8A8A8A;
      } else if (windowColor === 'black') {
        litColor = 0x2A2A2A;
        dimColor = 0x1A1A1A;
      } else { // blue
        litColor = 0x9DC6E8;
        dimColor = 0x4A5A6A;
      }
      
      // Add windows to ALL FOUR FACES
        // Add facade decorations (stripes, bands, columns)
        const decorType = Math.random();
        if (decorType < 0.25 && style.shaftSliceStyle !== 'ribbons') {
          // Vertical stripes
          const stripes = 3 + Math.floor(Math.random() * 5); // 3-7 stripes
          for (let i = 0; i < stripes; i++) {
            const stripeX = -width/2 + (i + 0.5) * (width / stripes);
            const stripeWidth = 0.12 + Math.random() * 0.15;
            const stripeGeo = new THREE.BoxGeometry(stripeWidth, height, 0.08);
            const stripeMat = new THREE.MeshStandardMaterial({ color: accentColor, roughness: 0.7, metalness: 0.2 });
            const stripe = new THREE.Mesh(stripeGeo, stripeMat);
            stripe.position.set(stripeX, yOffset + height/2, depth/2 + 0.04);
            parent.add(stripe);
            const stripeBack = stripe.clone();
            stripeBack.position.z = -depth/2 - 0.04;
            parent.add(stripeBack);
          }
        } else if (decorType >= 0.25 && decorType < 0.5) {
          // Horizontal bands
          const bands = 2 + Math.floor(Math.random() * 4); // 2-5 bands
          for (let i = 0; i < bands; i++) {
            const bandY = yOffset + (i + 1) * (height / (bands + 1));
            const bandHeight = 0.15 + Math.random() * 0.2;
            const bandGeo = new THREE.BoxGeometry(width + 0.1, bandHeight, 0.06);
            const bandMat = new THREE.MeshStandardMaterial({ color: accentColor, roughness: 0.75, metalness: 0.15 });
            const band = new THREE.Mesh(bandGeo, bandMat);
            band.position.set(0, bandY, depth/2 + 0.04);
            parent.add(band);
            const bandBack = band.clone();
            bandBack.position.z = -depth/2 - 0.04;
            parent.add(bandBack);
          }
        } else if (decorType >= 0.5 && decorType < 0.7) {
          // Columns with capitals
          const columns = 3 + Math.floor(Math.random() * 4); // 3-6 columns
          for (let i = 0; i < columns; i++) {
            const colX = -width/2 + (i + 0.5) * (width / columns);
            const colWidth = 0.18 + Math.random() * 0.12;
            const colGeo = new THREE.BoxGeometry(colWidth, height * 0.85, colWidth);
            const colMat = new THREE.MeshStandardMaterial({ color: accentColor, roughness: 0.8, metalness: 0.1 });
            const column = new THREE.Mesh(colGeo, colMat);
            column.position.set(colX, yOffset + height * 0.425, depth/2 + 0.05);
            parent.add(column);
            const headerGeo = new THREE.BoxGeometry(colWidth * 1.6, colWidth * 0.6, colWidth * 1.6);
            const header = new THREE.Mesh(headerGeo, colMat);
            header.position.set(colX, yOffset + height * 0.85 + colWidth * 0.3, depth/2 + 0.05);
            parent.add(header);
          }
        } else if (decorType >= 0.7 && decorType < 0.85) {
          // Inset panels
          const panels = 2 + Math.floor(Math.random() * 3); // 2-4 panels
          for (let i = 0; i < panels; i++) {
            const panelY = yOffset + (i + 0.5) * (height / panels);
            const panelH = height / panels * 0.7;
            const panelW = width * 0.6;
            const panelGeo = new THREE.BoxGeometry(panelW, panelH, 0.05);
            const panelMat = new THREE.MeshStandardMaterial({ 
              color: new THREE.Color(baseColor).multiplyScalar(0.85).getHex(), 
              roughness: 0.8, metalness: 0.05 
            });
            const panel = new THREE.Mesh(panelGeo, panelMat);
            panel.position.set(0, panelY, depth/2 + 0.02);
            parent.add(panel);
          }
        }
        
        if (style.shaftSliceStyle === 'ribbons') {
          // Vertical ribbons - continuous windows
          const ribbons = 3 + Math.floor(Math.random() * 3); // 3-5 ribbons
          
          // All four faces
          const faces = [
            { xOffset: 0, zOffset: depth/2 + 0.02, rotation: 0, axis: 'x', span: width },
            { xOffset: 0, zOffset: -depth/2 - 0.02, rotation: Math.PI, axis: 'x', span: width },
            { xOffset: width/2 + 0.02, zOffset: 0, rotation: Math.PI/2, axis: 'z', span: depth },
            { xOffset: -width/2 - 0.02, zOffset: 0, rotation: -Math.PI/2, axis: 'z', span: depth }
          ];
          
          faces.forEach(face => {
            for (let r = 0; r < ribbons; r++) {
              const offset = -face.span/2 + (r + 0.5) * (face.span / ribbons);
              for (let f = 1; f < floors; f += 2) {
                const y = yOffset + (f / floors) * height;
                const isLit = Math.random() > 0.3;
                if (face.axis === 'x') {
                  addWindow(parent, offset, y, face.zOffset, 0.8, 1.5, isLit ? litColor : dimColor, isLit, face.rotation);
                } else {
                  addWindow(parent, face.xOffset, y, offset, 0.8, 1.5, isLit ? litColor : dimColor, isLit, face.rotation);
                }
              }
            }
          });
          
        } else if (style.shaftSliceStyle === 'grid') {
          // Standard grid
          const cols = 3 + Math.floor(Math.random() * 3); // 3-5 columns
          
          // All four faces
          const faces = [
            { xOffset: 0, zOffset: depth/2 + 0.02, rotation: 0, axis: 'x', span: width },
            { xOffset: 0, zOffset: -depth/2 - 0.02, rotation: Math.PI, axis: 'x', span: width },
            { xOffset: width/2 + 0.02, zOffset: 0, rotation: Math.PI/2, axis: 'z', span: depth },
            { xOffset: -width/2 - 0.02, zOffset: 0, rotation: -Math.PI/2, axis: 'z', span: depth }
          ];
          
          faces.forEach(face => {
            for (let f = 1; f < floors; f += 2) {
              const y = yOffset + (f / floors) * height;
              for (let c = 0; c < cols; c++) {
                const offset = -face.span/2 + (c + 0.5) * (face.span / cols);
                const isLit = Math.random() > 0.3;
                if (face.axis === 'x') {
                  addWindow(parent, offset, y, face.zOffset, 1.0, 1.2, isLit ? litColor : dimColor, isLit, face.rotation);
                } else {
                  addWindow(parent, face.xOffset, y, offset, 1.0, 1.2, isLit ? litColor : dimColor, isLit, face.rotation);
                }
              }
            }
          });
        }
    }
    
    function addWindow(parent, x, y, z, w, h, color, isLit, rotationY = 0) {
      const winGeo = new THREE.PlaneGeometry(w, h);
      const winMat = new THREE.MeshStandardMaterial({ 
        color, 
        emissive: color, 
        emissiveIntensity: isLit ? 0.5 : 0.05,
        transparent: true,
        opacity: isLit ? 0.85 : 0.3,
        roughness: 0.3,
        metalness: 0.1
      });
      const win = new THREE.Mesh(winGeo, winMat);
      win.position.set(x, y, z);
      win.rotation.y = rotationY;
      parent.add(win);
      
      // Add simple sill with proper rotation
      const sillGeo = new THREE.BoxGeometry(w + 0.1, 0.04, 0.08);
      const sillMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.8, metalness: 0.1 });
      const sill = new THREE.Mesh(sillGeo, sillMat);
      sill.position.set(x, y - h/2 - 0.02, z);
      sill.rotation.y = rotationY;
      
      // Offset sill forward based on rotation
      const sillOffset = 0.04;
      if (rotationY === 0) { // Front (+Z)
        sill.position.z += sillOffset;
      } else if (Math.abs(rotationY - Math.PI) < 0.1) { // Back (-Z)
        sill.position.z -= sillOffset;
      } else if (Math.abs(rotationY - Math.PI/2) < 0.1) { // Right (+X)
        sill.position.x += sillOffset;
      } else if (Math.abs(rotationY + Math.PI/2) < 0.1) { // Left (-X)
        sill.position.x -= sillOffset;
      }
      
      sill.castShadow = false;
      sill.receiveShadow = false;
      sill.userData.isSill = true; // Mark for LOD
      parent.add(sill);
    }
    
    function createCrown(parent, width, depth, yOffset, crownType, baseColor, accentColor) {
      if (crownType === 'antenna') {
        // Multi-stage antenna
        const stages = 3;
        let currentY = yOffset;
        let currentRadius = Math.min(width, depth) * 0.15;
        
        for (let s = 0; s < stages; s++) {
          const stageHeight = 3 + s * 2;
          const stageGeo = new THREE.CylinderGeometry(currentRadius * 0.7, currentRadius, stageHeight, 8);
          const stageMat = new THREE.MeshStandardMaterial({ color: accentColor, roughness: 0.4, metalness: 0.6 });
          const stage = new THREE.Mesh(stageGeo, stageMat);
          stage.position.y = currentY + stageHeight / 2;
          stage.castShadow = true;
          parent.add(stage);
          
          currentY += stageHeight;
          currentRadius *= 0.6;
        }
        
        // Top sphere (blinking light)
        const sphereGeo = new THREE.SphereGeometry(currentRadius * 1.5, 8, 8);
        const sphereMat = new THREE.MeshStandardMaterial({ 
          color: 0xff4444, 
          emissive: 0xff0000, 
          emissiveIntensity: 0.8,
          roughness: 0.3,
          metalness: 0.1
        });
        const sphere = new THREE.Mesh(sphereGeo, sphereMat);
        sphere.position.y = currentY + currentRadius;
        parent.add(sphere);
        
      } else if (crownType === 'steppedZiggurat') {
        // Stepped pyramid
        const steps = 4;
        let currentY = yOffset;
        let currentW = width;
        let currentD = depth;
        
        for (let s = 0; s < steps; s++) {
          const stepHeight = 2.5;
          const stepGeo = new THREE.BoxGeometry(currentW, stepHeight, currentD);
          const stepMat = new THREE.MeshStandardMaterial({ 
            color: new THREE.Color(baseColor).multiplyScalar(1 - s * 0.05).getHex(),
            roughness: 0.75,
            metalness: 0.15
          });
          const step = new THREE.Mesh(stepGeo, stepMat);
          step.position.y = currentY + stepHeight / 2;
          step.castShadow = true;
          parent.add(step);
          
          currentY += stepHeight;
          currentW *= 0.8;
          currentD *= 0.8;
        }
      } else if (crownType === 'pyramid') {
        // Smooth pyramid crown
        const pyramidHeight = Math.min(width, depth) * 0.6;
        const pyramidGeo = new THREE.ConeGeometry(Math.min(width, depth) * 0.6, pyramidHeight, 4);
        pyramidGeo.rotateY(Math.PI / 4);
        const pyramidMat = new THREE.MeshStandardMaterial({ 
          color: new THREE.Color(baseColor).multiplyScalar(0.9).getHex(),
          roughness: 0.7,
          metalness: 0.2
        });
        const pyramid = new THREE.Mesh(pyramidGeo, pyramidMat);
        pyramid.position.y = yOffset + pyramidHeight / 2;
        pyramid.castShadow = true;
        parent.add(pyramid);
        
      } else if (crownType === 'dome') {
        // Dome crown
        const domeRadius = Math.min(width, depth) * 0.45;
        const domeGeo = new THREE.SphereGeometry(domeRadius, 12, 8, 0, Math.PI * 2, 0, Math.PI / 2);
        const domeMat = new THREE.MeshStandardMaterial({ 
          color: accentColor,
          roughness: 0.3,
          metalness: 0.6
        });
        const dome = new THREE.Mesh(domeGeo, domeMat);
        dome.position.y = yOffset;
        dome.castShadow = true;
        parent.add(dome);
        
      } else if (crownType === 'spire') {
        // Tall thin spire
        const spireHeight = 12;
        const spireGeo = new THREE.ConeGeometry(0.8, spireHeight, 8);
        const spireMat = new THREE.MeshStandardMaterial({ 
          color: accentColor,
          roughness: 0.4,
          metalness: 0.7
        });
        const spire = new THREE.Mesh(spireGeo, spireMat);
        spire.position.y = yOffset + spireHeight / 2;
        spire.castShadow = true;
        parent.add(spire);
        
      } else if (crownType === 'flatMech') {
        // Flat mechanical penthouse
        const mechHeight = 3;
        const mechGeo = new THREE.BoxGeometry(width * 0.9, mechHeight, depth * 0.9);
        const mechMat = new THREE.MeshStandardMaterial({ color: baseColor, roughness: 0.8, metalness: 0.2 });
        const mech = new THREE.Mesh(mechGeo, mechMat);
        mech.position.y = yOffset + mechHeight / 2;
        mech.castShadow = true;
        parent.add(mech);
      }
    }
    
    // ==================== FRACTAL TREE SYSTEM ====================
    const treePrototypes = [];
    
    function createTreePrototypes() {
      // Create 3 tree varieties
      const variants = [
        { trunkColor: 0x4a3828, foliageColor: 0x3a5a2a, branchAngle: 25, branchLength: 0.7 },
        { trunkColor: 0x3a2818, foliageColor: 0x2a4a1a, branchAngle: 35, branchLength: 0.65 },
        { trunkColor: 0x5a4838, foliageColor: 0x4a6a3a, branchAngle: 30, branchLength: 0.75 }
      ];
      
      variants.forEach(variant => {
        const treeGroup = new THREE.Group();
        
        // Generate fractal branches
        const branchGeometries = [];
        
        function addBranch(startPos, direction, radius, length, depth) {
          if (depth <= 0 || radius < 0.015) return;
          
          const endPos = startPos.clone().add(direction.clone().multiplyScalar(length));
          
          // Create cylinder for branch
          const branchGeo = new THREE.CylinderGeometry(radius * 0.75, radius, length, 4);
          branchGeo.translate(0, length / 2, 0);
          
          // Orient branch
          const branchMesh = new THREE.Mesh(branchGeo);
          branchMesh.position.copy(startPos);
          
          const axis = new THREE.Vector3(0, 1, 0);
          const quaternion = new THREE.Quaternion().setFromUnitVectors(axis, direction.clone().normalize());
          branchMesh.quaternion.copy(quaternion);
          
          branchMesh.updateMatrix();
          branchGeometries.push(branchMesh.geometry.clone().applyMatrix4(branchMesh.matrix));
          
          // Add leaf cluster along branch (not just at tip)
          if (depth <= 2) {
            const foliageSize = radius * 6 + 0.3;
            const foliageGeo = new THREE.SphereGeometry(foliageSize, 4, 4);
            const foliageMesh = new THREE.Mesh(foliageGeo);
            foliageMesh.position.copy(endPos);
            foliageMesh.updateMatrix();
            
            const foliageClone = foliageMesh.geometry.clone().applyMatrix4(foliageMesh.matrix);
            treeGroup.userData.foliageGeos = treeGroup.userData.foliageGeos || [];
            treeGroup.userData.foliageGeos.push(foliageClone);
          }
          
          // Recursively add child branches - extend in XZ plane
          if (depth > 1) {
            const numBranches = depth > 3 ? 2 : (depth > 2 ? 3 : 4);
            
            for (let i = 0; i < numBranches; i++) {
              // Spread branches around in XZ plane
              const azimuth = (i / numBranches) * Math.PI * 2 + Math.random() * 0.3;
              
              // Angle from vertical - branches extend more horizontally at higher levels
              const elevationAngle = (30 + Math.random() * 20 + (5 - depth) * 10) * Math.PI / 180;
              
              // Calculate new direction extending in XZ
              const newDir = new THREE.Vector3(
                Math.sin(elevationAngle) * Math.cos(azimuth),
                Math.cos(elevationAngle) * (0.5 + Math.random() * 0.3), // Some upward component with variation
                Math.sin(elevationAngle) * Math.sin(azimuth)
              ).normalize();
              
              addBranch(
                endPos.clone(),
                newDir,
                radius * variant.branchLength,
                length * variant.branchLength * 0.9,
                depth - 1
              );
            }
          }
        }
        
        // Start trunk
        const trunkHeight = 3.5;
        const trunkRadius = 0.35;
        addBranch(
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(0, 1, 0),
          trunkRadius,
          trunkHeight,
          4  // Reduced depth for performance
        );
        
        // Merge branch geometries
        const mergedBranches = BufferGeometryUtils.mergeGeometries(branchGeometries);
        const branchMat = new THREE.MeshStandardMaterial({ 
          color: variant.trunkColor, 
          roughness: 0.9,
          flatShading: true
        });
        const branchMesh = new THREE.Mesh(mergedBranches, branchMat);
        branchMesh.castShadow = true;
        branchMesh.receiveShadow = true;
        treeGroup.add(branchMesh);
        
        // Merge foliage geometries
        if (treeGroup.userData.foliageGeos && treeGroup.userData.foliageGeos.length > 0) {
          const mergedFoliage = BufferGeometryUtils.mergeGeometries(treeGroup.userData.foliageGeos);
          const foliageMat = new THREE.MeshStandardMaterial({ 
            color: variant.foliageColor, 
            roughness: 0.8,
            flatShading: true
          });
          const foliageMesh = new THREE.Mesh(mergedFoliage, foliageMat);
          foliageMesh.castShadow = true;
          foliageMesh.receiveShadow = true;
          treeGroup.add(foliageMesh);
        }
        
        treePrototypes.push(treeGroup);
      });
      
      console.log(`Created ${treePrototypes.length} tree prototypes`);
    }
    
    function createFractalTrees(positions, sidewalkHeight) {
      if (treePrototypes.length === 0) {
        createTreePrototypes();
      }
      
      positions.forEach(pos => {
        const protoIdx = Math.floor(Math.random() * treePrototypes.length);
        const treeClone = treePrototypes[protoIdx].clone();
        treeClone.position.set(pos.x, sidewalkHeight, pos.z);
        
        // Slight random rotation and scale variation
        treeClone.rotation.y = Math.random() * Math.PI * 2;
        const scale = 0.9 + Math.random() * 0.3;
        treeClone.scale.set(scale, scale, scale);
        
        worldRoot.add(treeClone);
      });
      
      console.log(`Placed ${positions.length} fractal trees`);
    }
    
    // ==================== ROAD SYSTEM ====================
    function createRoadNetwork() {
      const roadWidth = CONFIG.ROAD_WIDTH;
      const sidewalkWidth = CONFIG.SIDEWALK_WIDTH;
      const sidewalkHeight = CONFIG.SIDEWALK_HEIGHT;
      const blockSize = CONFIG.BLOCK_SIZE;
      const blocksX = CONFIG.CITY_BLOCKS_X;
      const blocksZ = CONFIG.CITY_BLOCKS_Z;
      
      const cityWidth = blocksX * (blockSize + roadWidth) + roadWidth;
      const cityDepth = blocksZ * (blockSize + roadWidth) + roadWidth;
      const offsetX = -cityWidth / 2;
      const offsetZ = -cityDepth / 2;
      
      const laneWidth = (roadWidth - sidewalkWidth * 2) / 2;
      const curbHeight = 0.1;
      
      const roadMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x2a2a2a,
        roughness: 0.95,
        metalness: 0.05
      });
      
      const sidewalkMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x666666,
        roughness: 0.85,
        metalness: 0.02
      });
      
      const curbMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x888888,
        roughness: 0.9,
        metalness: 0.0
      });
      
      // Yellow center line material
      const yellowLineMaterial = new THREE.MeshBasicMaterial({ 
        color: 0xffdd00,
        transparent: true,
        opacity: 0.9
      });
      
      // White edge line material
      const whiteLineMaterial = new THREE.MeshBasicMaterial({ 
        color: 0xf5f5f5,
        transparent: true,
        opacity: 0.8
      });
      
      // Instanced curb geometry
      const curbGeo = new THREE.BoxGeometry(0.15, curbHeight, 1);
      const curbPositions = [];
      const treePositions = [];
      const streetLightPositions = [];
      
      // Create horizontal roads (along Z axis)
      for (let x = 0; x <= blocksX; x++) {
        const roadX = offsetX + x * (blockSize + roadWidth) + roadWidth / 2;
        
        // Main road surface
        const roadGeo = new THREE.PlaneGeometry(roadWidth - sidewalkWidth * 2, cityDepth);
        const road = new THREE.Mesh(roadGeo, roadMaterial);
        road.rotation.x = -Math.PI / 2;
        road.position.set(roadX, 0.03, 0);
        road.receiveShadow = true;
        worldRoot.add(road);
        
        // Left 3D sidewalk
        const leftSidewalkGeo = new THREE.BoxGeometry(sidewalkWidth, sidewalkHeight, cityDepth);
        const leftSidewalk = new THREE.Mesh(leftSidewalkGeo, sidewalkMaterial);
        leftSidewalk.position.set(roadX - roadWidth/2 + sidewalkWidth/2, sidewalkHeight/2, 0);
        leftSidewalk.receiveShadow = true;
        leftSidewalk.castShadow = false;
        worldRoot.add(leftSidewalk);
        
        // Right 3D sidewalk
        const rightSidewalk = new THREE.Mesh(leftSidewalkGeo, sidewalkMaterial);
        rightSidewalk.position.set(roadX + roadWidth/2 - sidewalkWidth/2, sidewalkHeight/2, 0);
        rightSidewalk.receiveShadow = true;
        rightSidewalk.castShadow = false;
        worldRoot.add(rightSidewalk);
        
        // Collect curb positions along both sides
        for (let z = -cityDepth/2; z < cityDepth/2; z += 1) {
          // Left curb
          curbPositions.push({
            x: roadX - roadWidth/2 + sidewalkWidth,
            y: sidewalkHeight + curbHeight/2,
            z: z,
            rotY: 0
          });
          // Right curb
          curbPositions.push({
            x: roadX + roadWidth/2 - sidewalkWidth,
            y: sidewalkHeight + curbHeight/2,
            z: z,
            rotY: 0
          });
        }
        
        // Collect tree positions along sidewalks
        for (let z = -cityDepth/2 + 5; z < cityDepth/2; z += 8) {
          if (Math.random() > 0.3) {  // 70% chance of tree
            treePositions.push({
              x: roadX - roadWidth/2 + sidewalkWidth/2,
              z: z
            });
            treePositions.push({
              x: roadX + roadWidth/2 - sidewalkWidth/2,
              z: z
            });
          }
        }
        
        // Collect street light positions (every 20m, opposite side from trees)
        for (let z = -cityDepth/2 + 10; z < cityDepth/2; z += 20) {
          streetLightPositions.push({
            x: roadX - roadWidth/2 + sidewalkWidth * 0.8,
            z: z
          });
          streetLightPositions.push({
            x: roadX + roadWidth/2 - sidewalkWidth * 0.8,
            z: z + 10 // Offset for staggered pattern
          });
        }
        
        // Yellow center divider line (dashed)
        for (let z = -cityDepth/2; z < cityDepth/2; z += 8) {
          const dashGeo = new THREE.PlaneGeometry(0.15, 4);
          const dash = new THREE.Mesh(dashGeo, yellowLineMaterial);
          dash.rotation.x = -Math.PI / 2;
          dash.position.set(roadX, 0.05, z + 2);
          worldRoot.add(dash);
        }
        
        // White edge lines (solid)
        const edgeLineGeo = new THREE.PlaneGeometry(0.12, cityDepth);
        const leftEdge = new THREE.Mesh(edgeLineGeo, whiteLineMaterial);
        leftEdge.rotation.x = -Math.PI / 2;
        leftEdge.position.set(roadX - laneWidth, 0.05, 0);
        worldRoot.add(leftEdge);
        
        const rightEdge = new THREE.Mesh(edgeLineGeo, whiteLineMaterial);
        rightEdge.rotation.x = -Math.PI / 2;
        rightEdge.position.set(roadX + laneWidth, 0.05, 0);
        worldRoot.add(rightEdge);
      }
      
      // Create vertical roads (along X axis)
      for (let z = 0; z <= blocksZ; z++) {
        const roadZ = offsetZ + z * (blockSize + roadWidth) + roadWidth / 2;
        
        // Main road surface
        const roadGeo = new THREE.PlaneGeometry(cityWidth, roadWidth - sidewalkWidth * 2);
        const road = new THREE.Mesh(roadGeo, roadMaterial);
        road.rotation.x = -Math.PI / 2;
        road.position.set(0, 0.03, roadZ);
        road.receiveShadow = true;
        worldRoot.add(road);
        
        // Top 3D sidewalk
        const topSidewalkGeo = new THREE.BoxGeometry(cityWidth, sidewalkHeight, sidewalkWidth);
        const topSidewalk = new THREE.Mesh(topSidewalkGeo, sidewalkMaterial);
        topSidewalk.position.set(0, sidewalkHeight/2, roadZ - roadWidth/2 + sidewalkWidth/2);
        topSidewalk.receiveShadow = true;
        topSidewalk.castShadow = false;
        worldRoot.add(topSidewalk);
        
        // Bottom 3D sidewalk
        const bottomSidewalk = new THREE.Mesh(topSidewalkGeo, sidewalkMaterial);
        bottomSidewalk.position.set(0, sidewalkHeight/2, roadZ + roadWidth/2 - sidewalkWidth/2);
        bottomSidewalk.receiveShadow = true;
        bottomSidewalk.castShadow = false;
        worldRoot.add(bottomSidewalk);
        
        // Collect curb positions along both sides
        for (let x = -cityWidth/2; x < cityWidth/2; x += 1) {
          // Top curb
          curbPositions.push({
            x: x,
            y: sidewalkHeight + curbHeight/2,
            z: roadZ - roadWidth/2 + sidewalkWidth,
            rotY: Math.PI/2
          });
          // Bottom curb
          curbPositions.push({
            x: x,
            y: sidewalkHeight + curbHeight/2,
            z: roadZ + roadWidth/2 - sidewalkWidth,
            rotY: Math.PI/2
          });
        }
        
        // Collect tree positions along sidewalks
        for (let x = -cityWidth/2 + 5; x < cityWidth/2; x += 8) {
          if (Math.random() > 0.3) {  // 70% chance of tree
            treePositions.push({
              x: x,
              z: roadZ - roadWidth/2 + sidewalkWidth/2
            });
            treePositions.push({
              x: x,
              z: roadZ + roadWidth/2 - sidewalkWidth/2
            });
          }
        }
        
        // Collect street light positions (every 20m)
        for (let x = -cityWidth/2 + 10; x < cityWidth/2; x += 20) {
          streetLightPositions.push({
            x: x,
            z: roadZ - roadWidth/2 + sidewalkWidth * 0.8
          });
          streetLightPositions.push({
            x: x + 10,
            z: roadZ + roadWidth/2 - sidewalkWidth * 0.8
          });
        }
        
        // Yellow center divider line (dashed)
        for (let x = -cityWidth/2; x < cityWidth/2; x += 8) {
          const dashGeo = new THREE.PlaneGeometry(4, 0.15);
          const dash = new THREE.Mesh(dashGeo, yellowLineMaterial);
          dash.rotation.x = -Math.PI / 2;
          dash.position.set(x + 2, 0.05, roadZ);
          worldRoot.add(dash);
        }
        
        // White edge lines (solid)
        const edgeLineGeo = new THREE.PlaneGeometry(cityWidth, 0.12);
        const topEdge = new THREE.Mesh(edgeLineGeo, whiteLineMaterial);
        topEdge.rotation.x = -Math.PI / 2;
        topEdge.position.set(0, 0.05, roadZ - laneWidth);
        worldRoot.add(topEdge);
        
        const bottomEdge = new THREE.Mesh(edgeLineGeo, whiteLineMaterial);
        bottomEdge.rotation.x = -Math.PI / 2;
        bottomEdge.position.set(0, 0.05, roadZ + laneWidth);
        worldRoot.add(bottomEdge);
      }
      
      // Create instanced curbs
      if (curbPositions.length > 0) {
        const curbInstanceMesh = new THREE.InstancedMesh(curbGeo, curbMaterial, curbPositions.length);
        const matrix = new THREE.Matrix4();
        const quaternion = new THREE.Quaternion();
        
        curbPositions.forEach((pos, i) => {
          quaternion.setFromEuler(new THREE.Euler(0, pos.rotY, 0));
          matrix.compose(
            new THREE.Vector3(pos.x, pos.y, pos.z),
            quaternion,
            new THREE.Vector3(1, 1, 1)
          );
          curbInstanceMesh.setMatrixAt(i, matrix);
        });
        
        curbInstanceMesh.instanceMatrix.needsUpdate = true;
        curbInstanceMesh.castShadow = false;
        curbInstanceMesh.receiveShadow = false;
        worldRoot.add(curbInstanceMesh);
        console.log(`Created ${curbPositions.length} instanced curbs`);
      }
      
      // Create instanced fractal trees
      if (treePositions.length > 0) {
        createFractalTrees(treePositions, sidewalkHeight);
      }
      
      // Create instanced street lights
      if (streetLightPositions.length > 0) {
        createStreetLights(streetLightPositions, sidewalkHeight);
      }
      
      console.log('Road network with 3D sidewalks, curbs, trees, and street lights created');
    }
    
    // ==================== STREET LIGHT SYSTEM ====================
    function createStreetLights(positions, sidewalkHeight) {
      // Create single street light prototype
      const lightGroup = new THREE.Group();
      
      // Pole
      const poleHeight = 6;
      const poleRadius = 0.08;
      const poleGeo = new THREE.CylinderGeometry(poleRadius, poleRadius * 1.2, poleHeight, 8);
      const poleMat = new THREE.MeshStandardMaterial({ 
        color: 0x2a2a2a, 
        roughness: 0.6, 
        metalness: 0.8 
      });
      const pole = new THREE.Mesh(poleGeo, poleMat);
      pole.position.y = poleHeight / 2;
      pole.castShadow = true;
      lightGroup.add(pole);
      
      // Arm extending out
      const armLength = 1.2;
      const armGeo = new THREE.CylinderGeometry(poleRadius * 0.6, poleRadius * 0.6, armLength, 6);
      const arm = new THREE.Mesh(armGeo, poleMat);
      arm.position.set(armLength / 2, poleHeight - 0.3, 0);
      arm.rotation.z = Math.PI / 2;
      arm.castShadow = true;
      lightGroup.add(arm);
      
      // Light fixture
      const fixtureGeo = new THREE.ConeGeometry(0.25, 0.4, 8);
      const fixtureMat = new THREE.MeshStandardMaterial({ 
        color: 0x1a1a1a, 
        roughness: 0.4, 
        metalness: 0.6,
        emissive: 0xffaa44,
        emissiveIntensity: 0.3
      });
      const fixture = new THREE.Mesh(fixtureGeo, fixtureMat);
      fixture.position.set(armLength, poleHeight - 0.5, 0);
      fixture.rotation.x = Math.PI;
      fixture.castShadow = false;
      lightGroup.add(fixture);
      
      // Light bulb (emissive)
      const bulbGeo = new THREE.SphereGeometry(0.15, 8, 6);
      const bulbMat = new THREE.MeshStandardMaterial({ 
        color: 0xffffee, 
        emissive: 0xffdd88, 
        emissiveIntensity: 1.0,
        transparent: true,
        opacity: 0.9
      });
      const bulb = new THREE.Mesh(bulbGeo, bulbMat);
      bulb.position.set(armLength, poleHeight - 0.6, 0);
      lightGroup.add(bulb);
      
      // Add point light for illumination
      const pointLight = new THREE.PointLight(0xffdd88, 2.5, 15);
      pointLight.position.set(armLength, poleHeight - 0.6, 0);
      pointLight.castShadow = false; // Too many for shadows
      lightGroup.add(pointLight);
      
      // Place all street lights
      positions.forEach(pos => {
        const lightClone = lightGroup.clone();
        lightClone.position.set(pos.x, sidewalkHeight, pos.z);
        
        // Random rotation
        lightClone.rotation.y = Math.random() * Math.PI * 2;
        
        worldRoot.add(lightClone);
      });
      
      console.log(`Placed ${positions.length} street lights`);
    }
    
    // ==================== INSTANCED CITY GENERATION ====================
    let buildingPrototypes = [];
    let instancedBuildings = [];
    
    function createBuildingPrototypes() {
      console.log('Creating building prototypes...');
      buildingPrototypes = [];
      
      // Initialize shared geometries (windows + sills)
      initSharedGeometries();
      
      // Building color palettes - greys and beiges
      const colorPalettes = [
        0xA8B0B8, // Light grey
        0x8A9099, // Medium grey
        0xB5B8BC, // Warm grey
        0xC8C2B8, // Beige grey
        0xD4CCBE, // Light beige
        0xBFB5A8, // Medium beige
        0xA89F92, // Dark beige
        0x9A9A9A, // Cool grey
      ];
      
      // Create 8 building variants as prototypes with varied colors - BIGGER
      const variants = [
        { type: 'box', width: 15, height: 35, depth: 15, color: colorPalettes[0], windowColor: 'yellow' },
        { type: 'box', width: 12, height: 50, depth: 12, color: colorPalettes[1], windowColor: 'blue' },
        { type: 'box', width: 18, height: 28, depth: 14, color: colorPalettes[4], windowColor: 'yellow' },
        { type: 'stacked', width: 16, height: 60, depth: 15, color: colorPalettes[5], windowColor: 'blue' },
        { type: 'stacked', width: 14, height: 55, depth: 16, color: colorPalettes[2], windowColor: 'yellow' },
        { type: 'cylinder', radius: 6, height: 45, color: colorPalettes[3], windowColor: 'blue' },
        { type: 'cylinder', radius: 7, height: 62, color: colorPalettes[6], windowColor: 'yellow' },
        { type: 'box', width: 13, height: 42, depth: 13, color: colorPalettes[7], windowColor: 'blue' },
      ];
      
      variants.forEach((variant, idx) => {
        const windowGroup = new THREE.Group();
        
        if (variant.type === 'stacked') {
          // Create 3-section cascading building
          const sections = 3;
          let currentY = 0;
          
          for (let s = 0; s < sections; s++) {
            const sectionHeight = variant.height / sections;
            const scale = 1 - s * 0.18;  // Each section is 18% smaller
            const sectionWidth = variant.width * scale;
            const sectionDepth = variant.depth * scale;
            
            const sectionGeo = new THREE.BoxGeometry(sectionWidth, sectionHeight, sectionDepth);
            const material = new THREE.MeshStandardMaterial({
              color: new THREE.Color(variant.color).multiplyScalar(1 - s * 0.05),
              roughness: 0.75,
              metalness: 0.15
            });
            
            const section = new THREE.Mesh(sectionGeo, material);
            section.position.y = currentY + sectionHeight / 2 - variant.height / 2;
            section.castShadow = true;
            section.receiveShadow = true;
            windowGroup.add(section);
            
            // Add decoration and windows to each section
            const sectionVariant = { 
              ...variant, 
              width: sectionWidth, 
              height: sectionHeight, 
              depth: sectionDepth,
              type: 'box'
            };
            
            const sectionGroup = new THREE.Group();
            sectionGroup.position.copy(section.position);
            addFacadeDecoration(sectionGroup, sectionVariant);
            addSimpleWindows(sectionGroup, sectionVariant);
            windowGroup.add(sectionGroup);
            
            currentY += sectionHeight;
          }
        } else {
          // Regular box or cylinder
          let geometry;
          
          if (variant.type === 'box') {
            geometry = new THREE.BoxGeometry(variant.width, variant.height, variant.depth);
          } else {
            geometry = new THREE.CylinderGeometry(variant.radius, variant.radius * 1.1, variant.height, 12);
          }
          
          const material = new THREE.MeshStandardMaterial({
            color: variant.color,
            roughness: 0.75,
            metalness: 0.15
          });
          
          const baseMesh = new THREE.Mesh(geometry, material);
          baseMesh.castShadow = true;
          baseMesh.receiveShadow = true;
          windowGroup.add(baseMesh);
          
          // Add facade decoration beneath windows
          addFacadeDecoration(windowGroup, variant);
          
          // Add window decals on top of decoration
          addSimpleWindows(windowGroup, variant);
        }
        
        // Add building topper
        addBuildingTopper(windowGroup, variant);
        
        buildingPrototypes.push({
          group: windowGroup,
          variant,
          collider: variant.type === 'box' 
            ? { type: 'box', width: variant.width, height: variant.height, depth: variant.depth }
            : { type: 'cylinder', radius: variant.radius, height: variant.height }
        });
      });
      
      console.log(`Created ${buildingPrototypes.length} building prototypes`);
    }
    
     // LOD Settings (moved to updateLOD section for better organization)
     const frustum = new THREE.Frustum();
     const projScreenMatrix = new THREE.Matrix4();
    
    // Shared geometries (created once, reused)
    const sharedGeometries = {
      windowSquare: null,
      windowRectangle: null,
      windowCylinder: null,
      sillOverhang: null,
      sillBorderTop: null,
      sillBorderBottom: null,
      sillBorderLeft: null,
      sillBorderRight: null,
      sillBottomOnly: null,
      sillMinimal: null
    };
    
    // Initialize shared geometries once
    function initSharedGeometries() {
      const sillThickness = 0.05;  // Bigger sills
      const sillDepth = 0.12;
      const windowWidth = 1.2;  // Bigger windows
      const windowHeightRect = 1.8;
      const windowHeightSquare = 1.2;
      
      // Window geometries - bigger
      sharedGeometries.windowSquare = new THREE.PlaneGeometry(windowWidth, windowHeightSquare);
      sharedGeometries.windowRectangle = new THREE.PlaneGeometry(windowWidth, windowHeightRect);
      sharedGeometries.windowCylinder = new THREE.PlaneGeometry(1.0, 1.5);  // Bigger cylinder windows
      
      // Sill geometries
      sharedGeometries.sillOverhang = new THREE.BoxGeometry(windowWidth + 0.15, sillThickness, sillDepth);
      sharedGeometries.sillBorderTop = new THREE.BoxGeometry(windowWidth + 0.1, sillThickness, sillDepth * 0.6);
      sharedGeometries.sillBorderBottom = new THREE.BoxGeometry(windowWidth + 0.1, sillThickness, sillDepth);
      sharedGeometries.sillBorderLeft = new THREE.BoxGeometry(sillThickness, windowHeightRect, sillDepth * 0.6);
      sharedGeometries.sillBorderRight = new THREE.BoxGeometry(sillThickness, windowHeightRect, sillDepth * 0.6);
      sharedGeometries.sillBottomOnly = new THREE.BoxGeometry(windowWidth + 0.08, sillThickness, sillDepth * 0.7);
      sharedGeometries.sillMinimal = new THREE.BoxGeometry(windowWidth, sillThickness * 0.5, sillDepth * 0.4);
    }
    
     // Helper function to create window sills using shared geometries
     function createWindowSill(windowWidth, windowHeight, sillStyle, sillColor) {
       const sillGroup = new THREE.Group();
       sillGroup.userData.isSill = true;  // Mark for LOD system
       const sillThickness = 0.03;
       const sillDepth = 0.08;
       
       const sillMaterial = new THREE.MeshStandardMaterial({ 
         color: sillColor,
         roughness: 0.8,
         metalness: 0.1
       });
       
       if (sillStyle === 0) {
         // Overhang - bottom protruding sill
         const sill = new THREE.Mesh(sharedGeometries.sillOverhang, sillMaterial);
         sill.position.set(0, -windowHeight/2 - sillThickness/2, sillDepth/2 - 0.02);
         sill.userData.isSill = true;  // Mark mesh itself too
         sill.castShadow = false;  // Don't cast shadows for performance
         sill.receiveShadow = false;
         sillGroup.add(sill);
         
       } else if (sillStyle === 1) {
         // Complete border - frame around entire window
         // Top
         const top = new THREE.Mesh(sharedGeometries.sillBorderTop, sillMaterial);
         top.position.set(0, windowHeight/2 + sillThickness/2, sillDepth/4 - 0.02);
         top.userData.isSill = true;
         top.castShadow = false;
         top.receiveShadow = false;
         sillGroup.add(top);
         
         // Bottom
         const bottom = new THREE.Mesh(sharedGeometries.sillBorderBottom, sillMaterial);
         bottom.position.set(0, -windowHeight/2 - sillThickness/2, sillDepth/2 - 0.02);
         bottom.userData.isSill = true;
         bottom.castShadow = false;
         bottom.receiveShadow = false;
         sillGroup.add(bottom);
         
         // Left
         const left = new THREE.Mesh(sharedGeometries.sillBorderLeft, sillMaterial);
         left.position.set(-windowWidth/2 - sillThickness/2, 0, sillDepth/4 - 0.02);
         left.userData.isSill = true;
         left.castShadow = false;
         left.receiveShadow = false;
         sillGroup.add(left);
         
         // Right
         const right = new THREE.Mesh(sharedGeometries.sillBorderRight, sillMaterial);
         right.position.set(windowWidth/2 + sillThickness/2, 0, sillDepth/4 - 0.02);
         right.userData.isSill = true;
         right.castShadow = false;
         right.receiveShadow = false;
         sillGroup.add(right);
         
       } else if (sillStyle === 2) {
         // Bottom only - simple flat sill
         const sill = new THREE.Mesh(sharedGeometries.sillBottomOnly, sillMaterial);
         sill.position.set(0, -windowHeight/2 - sillThickness/2, sillDepth/3 - 0.02);
         sill.userData.isSill = true;
         sill.castShadow = false;
         sill.receiveShadow = false;
         sillGroup.add(sill);
         
       } else {
         // Minimal - tiny bottom edge only
         const sill = new THREE.Mesh(sharedGeometries.sillMinimal, sillMaterial);
         sill.position.set(0, -windowHeight/2 - sillThickness/4, sillDepth/6 - 0.02);
         sill.userData.isSill = true;
         sill.castShadow = false;
         sill.receiveShadow = false;
         sillGroup.add(sill);
       }
       
       return sillGroup;
     }
     
     // Helper function to create window sills for cylindrical buildings
     function createCylinderWindowSill(windowWidth, windowHeight, sillStyle, sillColor, radius) {
       const sillGroup = new THREE.Group();
       sillGroup.userData.isSill = true;
       const sillThickness = 0.03;
       const sillDepth = 0.08;
       
       const sillMaterial = new THREE.MeshStandardMaterial({ 
         color: sillColor,
         roughness: 0.8,
         metalness: 0.1
       });
       
       // Create curved sill using a small cylinder segment
       const sillArc = 0.15;  // Angular width of sill
       const sillGeo = new THREE.CylinderGeometry(
         radius + sillDepth/2, 
         radius + sillDepth/2, 
         sillThickness, 
         8, 
         1, 
         false, 
         -sillArc/2, 
         sillArc
       );
       
       const sill = new THREE.Mesh(sillGeo, sillMaterial);
       sill.rotation.x = Math.PI / 2;
       sill.position.set(0, -windowHeight/2 - sillThickness/2, 0);
       sill.userData.isSill = true;  // Mark mesh itself too
       sill.castShadow = false;
       sill.receiveShadow = false;
       sillGroup.add(sill);
       
       return sillGroup;
     }
     
     // Add building toppers (domes, antennas, trims, spires)
    function addBuildingTopper(buildingGroup, variant) {
      const topperStyle = Math.floor(Math.random() * 5);
      const topperColor = new THREE.Color(variant.color).multiplyScalar(0.85);
      
      let topWidth, topDepth, topY;
      
      if (variant.type === 'stacked') {
        // Topper on smallest (top) section
        topWidth = variant.width * (1 - 2 * 0.18);
        topDepth = variant.depth * (1 - 2 * 0.18);
        topY = variant.height / 2;
      } else if (variant.type === 'cylinder') {
        topWidth = variant.radius * 2;
        topDepth = variant.radius * 2;
        topY = variant.height / 2;
      } else {
        topWidth = variant.width;
        topDepth = variant.depth;
        topY = variant.height / 2;
      }
      
      const topperMat = new THREE.MeshStandardMaterial({ 
        color: topperColor,
        roughness: 0.7,
        metalness: 0.2
      });
      
      if (topperStyle === 0) {
        // Half dome
        const domeGeo = new THREE.SphereGeometry(Math.min(topWidth, topDepth) * 0.35, 8, 6, 0, Math.PI * 2, 0, Math.PI / 2);
        const dome = new THREE.Mesh(domeGeo, topperMat);
        dome.position.y = topY;
        buildingGroup.add(dome);
        
      } else if (topperStyle === 1) {
        // Antenna/spire
        const antennaHeight = variant.height * 0.15;
        const antennaGeo = new THREE.CylinderGeometry(0.1, 0.15, antennaHeight, 6);
        const antenna = new THREE.Mesh(antennaGeo, topperMat);
        antenna.position.y = topY + antennaHeight / 2;
        buildingGroup.add(antenna);
        
        // Small sphere at top
        const ballGeo = new THREE.SphereGeometry(0.2, 6, 6);
        const ball = new THREE.Mesh(ballGeo, topperMat);
        ball.position.y = topY + antennaHeight;
        buildingGroup.add(ball);
        
       } else if (topperStyle === 2) {
         // Crown/trim - circular overhang for cylinders
         const crownHeight = 0.6;
         let crownGeo;
         
         if (variant.type === 'cylinder') {
           // Circular disk overhang for cylindrical buildings
           crownGeo = new THREE.CylinderGeometry(topWidth * 0.6, topWidth * 0.6, crownHeight, 16);
         } else {
           crownGeo = new THREE.BoxGeometry(topWidth * 1.05, crownHeight, topDepth * 1.05);
         }
         
         const crown = new THREE.Mesh(crownGeo, topperMat);
         crown.position.y = topY + crownHeight / 2;
         buildingGroup.add(crown);
         
       } else if (topperStyle === 3) {
        // Pyramid top
        const pyramidHeight = Math.min(topWidth, topDepth) * 0.4;
        const pyramidGeo = new THREE.ConeGeometry(Math.min(topWidth, topDepth) * 0.5, pyramidHeight, 4);
        const pyramid = new THREE.Mesh(pyramidGeo, topperMat);
        pyramid.position.y = topY + pyramidHeight / 2;
        pyramid.rotation.y = Math.PI / 4;
        buildingGroup.add(pyramid);
        
       } else {
         // Flat roof with small edge trim - circular for cylinders
         const trimHeight = 0.3;
         let trimGeo;
         
         if (variant.type === 'cylinder') {
           // Circular disk trim for cylindrical buildings
           trimGeo = new THREE.CylinderGeometry(topWidth * 0.55, topWidth * 0.55, trimHeight, 16);
         } else {
           trimGeo = new THREE.BoxGeometry(topWidth * 1.02, trimHeight, topDepth * 1.02);
         }
         
         const trim = new THREE.Mesh(trimGeo, topperMat);
         trim.position.y = topY + trimHeight / 2;
         buildingGroup.add(trim);
       }
    }
    
    // Add facade decoration textures beneath windows
    function addFacadeDecoration(buildingGroup, variant) {
      const facadeStyle = Math.floor(Math.random() * 4);
      const decorColor = new THREE.Color(variant.color).multiplyScalar(0.92);
      
      if (variant.type === 'box') {
        const width = variant.width;
        const depth = variant.depth;
        const height = variant.height;
        
        if (facadeStyle === 0) {
          // Vertical stripes
          const stripeCount = 4 + Math.floor(Math.random() * 3);
          const stripeWidth = 0.15;
          const stripeGeo = new THREE.PlaneGeometry(stripeWidth, height);
          const stripeMat = new THREE.MeshStandardMaterial({ 
            color: decorColor,
            roughness: 0.85
          });
          
          // Front and back
          for (let i = 0; i < stripeCount; i++) {
            const x = -width/2 + (i + 0.5) * (width / stripeCount);
             const stripeFront = new THREE.Mesh(stripeGeo, stripeMat);
             stripeFront.position.set(x, 0, depth/2 + 0.005);
             stripeFront.userData.isDecoration = true;  // Mark for LOD
             buildingGroup.add(stripeFront);
             
             const stripeBack = new THREE.Mesh(stripeGeo, stripeMat);
             stripeBack.position.set(x, 0, -depth/2 - 0.005);
             stripeBack.rotation.y = Math.PI;
             stripeBack.userData.isDecoration = true;  // Mark for LOD
             buildingGroup.add(stripeBack);
          }
          
        } else if (facadeStyle === 1) {
          // Horizontal bands
          const bandCount = 3 + Math.floor(Math.random() * 2);
          const bandHeight = 0.12;
          
          for (let i = 0; i < bandCount; i++) {
            const y = -height/2 + (i + 1) * (height / (bandCount + 1));
            
            // Front
            const bandGeoFront = new THREE.PlaneGeometry(width, bandHeight);
            const bandMatFront = new THREE.MeshStandardMaterial({ 
              color: decorColor,
              roughness: 0.9
            });
             const bandFront = new THREE.Mesh(bandGeoFront, bandMatFront);
             bandFront.position.set(0, y, depth/2 + 0.005);
             bandFront.userData.isDecoration = true;  // Mark for LOD
             buildingGroup.add(bandFront);
             
             // Back
             const bandBack = new THREE.Mesh(bandGeoFront, bandMatFront);
             bandBack.position.set(0, y, -depth/2 - 0.005);
             bandBack.rotation.y = Math.PI;
             bandBack.userData.isDecoration = true;  // Mark for LOD
             buildingGroup.add(bandBack);
          }
          
        } else if (facadeStyle === 2) {
          // Column pilasters
          const columnCount = 2 + Math.floor(Math.random() * 2);
          const columnWidth = 0.25;
          const columnGeo = new THREE.PlaneGeometry(columnWidth, height * 0.9);
          const columnMat = new THREE.MeshStandardMaterial({ 
            color: decorColor,
            roughness: 0.88
          });
          
          for (let i = 0; i < columnCount; i++) {
            const x = -width/2 + (i + 1) * (width / (columnCount + 1));
            
             // Front
             const colFront = new THREE.Mesh(columnGeo, columnMat);
             colFront.position.set(x, height * 0.05, depth/2 + 0.005);
             colFront.userData.isDecoration = true;  // Mark for LOD
             buildingGroup.add(colFront);
             
             // Column header (capital)
             const headerGeo = new THREE.PlaneGeometry(columnWidth * 1.5, 0.2);
             const header = new THREE.Mesh(headerGeo, columnMat);
             header.position.set(x, height * 0.45, depth/2 + 0.006);
             header.userData.isDecoration = true;  // Mark for LOD
             buildingGroup.add(header);
          }
        }
        // facadeStyle 3 = no decoration (clean modern)
      }
    }
    
    function addSimpleWindows(buildingGroup, variant) {
      // Enhanced window system with variants
      // Window colors based on building variant
      const litWindowColor = variant.windowColor === 'yellow' 
        ? new THREE.Color(0xFFEB99)  // Warm yellow
        : new THREE.Color(0x9DC6E8);  // Cool blue
      const dimWindowColor = variant.windowColor === 'yellow'
        ? new THREE.Color(0x6A5A4A)  // Dim warm
        : new THREE.Color(0x4A5A6A);  // Dim cool
      
      // Variable row density - some buildings have more/fewer floors
      const densityVariant = Math.random();
      let floorSpacing;
      if (densityVariant < 0.3) {
        floorSpacing = 4.0;  // Dense (more floors)
      } else if (densityVariant < 0.7) {
        floorSpacing = 5.0;  // Medium
      } else {
        floorSpacing = 6.0;  // Sparse (fewer floors)
      }
       const floors = variant.type === 'box' ? 
         Math.max(3, Math.min(8, Math.floor(variant.height / floorSpacing))) : 
         Math.max(2, Math.min(6, Math.floor(variant.height / (floorSpacing + 0.5))));
      
       // Window variants: 3 or 4 windows per row
       const windowsPerRow = [3, 4][Math.floor(Math.random() * 2)];
      
      // Window shape: square or rectangle - scaled up
      const isSquare = Math.random() > 0.5;
      const windowWidth = 1.2;  // Bigger windows
      const windowHeight = isSquare ? 1.2 : 1.8;
      
      // Window sill style variants
      const sillStyle = Math.floor(Math.random() * 4);
      // 0: overhang, 1: complete border, 2: bottom only, 3: minimal
      
      // Sill color - slightly lighter than building
      const sillColor = new THREE.Color(variant.color).multiplyScalar(1.15);
      
      if (variant.type === 'box') {
        const width = variant.width;
        const depth = variant.depth;
        const height = variant.height;
        
        // All four faces get windows
        // Front face (Z+)
        for (let floor = 1; floor < floors; floor++) {
          const y = -height/2 + (floor / floors) * height;
          
          for (let w = 0; w < windowsPerRow; w++) {
            const isLit = Math.random() > 0.3;  // 70% chance lit
            const xPos = -width/2 + (w + 0.5) * (width / windowsPerRow);
            
            // Use shared geometry
            const windowGeo = isSquare ? sharedGeometries.windowSquare : sharedGeometries.windowRectangle;
            const windowMat = new THREE.MeshBasicMaterial({ 
              color: isLit ? litWindowColor : dimWindowColor,
              emissive: isLit ? litWindowColor : dimWindowColor,
              emissiveIntensity: isLit ? 0.5 : 0.05,
              transparent: true,
              opacity: isLit ? 0.85 : 0.3
            });
             const window = new THREE.Mesh(windowGeo, windowMat);
             window.position.set(xPos, y, depth/2 + 0.02);
             window.rotation.y = 0;
             window.userData.isWindow = true;  // Mark for LOD
             
             // Add window sill
             const sill = createWindowSill(windowWidth, windowHeight, sillStyle, sillColor);
             sill.position.copy(window.position);
             sill.rotation.copy(window.rotation);
             buildingGroup.add(sill);
             
             buildingGroup.add(window);
          }
        }
        
        // Back face (Z-)
        for (let floor = 1; floor < floors; floor++) {
          const y = -height/2 + (floor / floors) * height;
          
          for (let w = 0; w < windowsPerRow; w++) {
            const isLit = Math.random() > 0.3;
            const xPos = -width/2 + (w + 0.5) * (width / windowsPerRow);
            
            // Use shared geometry
            const windowGeo = isSquare ? sharedGeometries.windowSquare : sharedGeometries.windowRectangle;
            const windowMat = new THREE.MeshBasicMaterial({ 
              color: isLit ? litWindowColor : dimWindowColor,
              emissive: isLit ? litWindowColor : dimWindowColor,
              emissiveIntensity: isLit ? 0.5 : 0.05,
              transparent: true,
              opacity: isLit ? 0.85 : 0.3
            });
             const window = new THREE.Mesh(windowGeo, windowMat);
             window.position.set(xPos, y, -depth/2 - 0.02);
             window.rotation.y = Math.PI;
             window.userData.isWindow = true;  // Mark for LOD
             
             // Add window sill
             const sill = createWindowSill(windowWidth, windowHeight, sillStyle, sillColor);
             sill.position.copy(window.position);
             sill.rotation.copy(window.rotation);
             buildingGroup.add(sill);
             
             buildingGroup.add(window);
          }
        }
        
        // Left face (X-)
        const depthWindowsPerRow = Math.max(2, Math.floor(windowsPerRow * (depth / width)));
        for (let floor = 1; floor < floors; floor++) {
          const y = -height/2 + (floor / floors) * height;
          
          for (let w = 0; w < depthWindowsPerRow; w++) {
            const isLit = Math.random() > 0.3;
            const zPos = -depth/2 + (w + 0.5) * (depth / depthWindowsPerRow);
            
            // Use shared geometry
            const windowGeo = isSquare ? sharedGeometries.windowSquare : sharedGeometries.windowRectangle;
            const windowMat = new THREE.MeshBasicMaterial({ 
              color: isLit ? litWindowColor : dimWindowColor,
              emissive: isLit ? litWindowColor : dimWindowColor,
              emissiveIntensity: isLit ? 0.5 : 0.05,
              transparent: true,
              opacity: isLit ? 0.85 : 0.3
            });
             const window = new THREE.Mesh(windowGeo, windowMat);
             window.position.set(-width/2 - 0.02, y, zPos);
             window.rotation.y = -Math.PI / 2;
             window.userData.isWindow = true;  // Mark for LOD
             
             // Add window sill
             const sill = createWindowSill(windowWidth, windowHeight, sillStyle, sillColor);
             sill.position.copy(window.position);
             sill.rotation.copy(window.rotation);
             buildingGroup.add(sill);
             
             buildingGroup.add(window);
          }
        }
        
        // Right face (X+)
        for (let floor = 1; floor < floors; floor++) {
          const y = -height/2 + (floor / floors) * height;
          
          for (let w = 0; w < depthWindowsPerRow; w++) {
            const isLit = Math.random() > 0.3;
            const zPos = -depth/2 + (w + 0.5) * (depth / depthWindowsPerRow);
            
            // Use shared geometry
            const windowGeo = isSquare ? sharedGeometries.windowSquare : sharedGeometries.windowRectangle;
            const windowMat = new THREE.MeshBasicMaterial({ 
              color: isLit ? litWindowColor : dimWindowColor,
              emissive: isLit ? litWindowColor : dimWindowColor,
              emissiveIntensity: isLit ? 0.5 : 0.05,
              transparent: true,
              opacity: isLit ? 0.85 : 0.3
            });
             const window = new THREE.Mesh(windowGeo, windowMat);
             window.position.set(width/2 + 0.02, y, zPos);
             window.rotation.y = Math.PI / 2;
             window.userData.isWindow = true;  // Mark for LOD
             
             // Add window sill
             const sill = createWindowSill(windowWidth, windowHeight, sillStyle, sillColor);
             sill.position.copy(window.position);
             sill.rotation.copy(window.rotation);
             buildingGroup.add(sill);
             
             buildingGroup.add(window);
          }
        }
       } else {
         // Cylinder - radial windows around entire circumference
         const segments = 6 + Math.floor(Math.random() * 3);  // 6-8 windows around (reduced for performance)
         const radius = variant.radius;
         const height = variant.height;
        
        const cylinderWindowWidth = 0.5;
        const cylinderWindowHeight = isSquare ? 0.5 : 0.8;
        
        for (let floor = 1; floor < floors; floor++) {
          const y = -height/2 + (floor / floors) * height;
          
          for (let seg = 0; seg < segments; seg++) {
            const isLit = Math.random() > 0.3;
            const angle = (seg / segments) * Math.PI * 2;
            const x = Math.cos(angle) * (radius + 0.01);
            const z = Math.sin(angle) * (radius + 0.01);
            
            // Use shared geometry
            const windowGeo = sharedGeometries.windowCylinder;
            const windowMat = new THREE.MeshBasicMaterial({ 
              color: isLit ? litWindowColor : dimWindowColor,
              emissive: isLit ? litWindowColor : dimWindowColor,
              emissiveIntensity: isLit ? 0.45 : 0.05,
              transparent: true,
              opacity: isLit ? 0.85 : 0.3
            });
             const window = new THREE.Mesh(windowGeo, windowMat);
             window.position.set(x, y, z);
             window.lookAt(0, y, 0);
             window.userData.isWindow = true;  // Mark for LOD
             
             // Add window sill - wrapped to cylinder
             const sill = createCylinderWindowSill(cylinderWindowWidth, cylinderWindowHeight, sillStyle, sillColor, radius);
             sill.position.copy(window.position);
             sill.rotation.copy(window.rotation);
             buildingGroup.add(sill);
             
             buildingGroup.add(window);
          }
        }
      }
    }
    
     // OLD SYSTEM - Now using chunk-based generation
     async function generateCity() {
       console.log('OLD generateCity called - now using chunk system instead');
       
       // Clear existing buildings
       buildings.forEach(b => {
         worldRoot.remove(b.mesh);
         if (b.body) world.removeRigidBody(b.body);
       });
       buildings = [];
       
       instancedBuildings.forEach(inst => {
         worldRoot.remove(inst);
       });
       instancedBuildings = [];
       
       // Clear sill cache
       sillCache.clear();
       
       // Clear doors
       doors.forEach(door => {
         if (door.panels) door.panels.forEach(p => worldRoot.remove(p));
         if (door.frames) door.frames.forEach(f => worldRoot.remove(f));
         if (door.track) worldRoot.remove(door.track);
         if (door.lightPlane) worldRoot.remove(door.lightPlane);
         if (door.light) worldRoot.remove(door.light);
       });
       doors = [];
       
       // Create prototypes if not exists (still needed for old viewport system)
       if (buildingPrototypes.length === 0) {
         createBuildingPrototypes();
       }
       
       // Create global road network once
       // createRoadNetwork();
       // DISABLED - roads should be per-chunk now
       
       console.log('City generation delegated to chunk streaming system');
       
       // OLD building generation code commented out - now using chunks
       /*
       const roadWidth = CONFIG.ROAD_WIDTH;
       const blockSize = CONFIG.BLOCK_SIZE;
       const blocksX = CONFIG.CITY_BLOCKS_X;
       const blocksZ = CONFIG.CITY_BLOCKS_Z;
       ... building generation logic ...
       */
       
       return; // Exit early - chunk system handles everything
     }
     
     function placeBuildingInBlock(x, z, scaleFactor) {
       // Pick random prototype
       const protoIdx = Math.floor(Math.random() * buildingPrototypes.length);
       const proto = buildingPrototypes[protoIdx];
       
       // Random height variation
       const heightScale = (0.6 + Math.random() * 0.8) * scaleFactor;
       
       // Clone the prototype
       const buildingClone = proto.group.clone();
       buildingClone.position.set(x, proto.variant.height * heightScale / 2, z);
       buildingClone.scale.set(scaleFactor, heightScale, scaleFactor);
       
       // Mark all children for pluck system
       buildingClone.traverse(child => {
         if (child.isMesh) {
           child.userData._pluckParent = buildingClone;
         }
       });
       
       worldRoot.add(buildingClone);
       instancedBuildings.push(buildingClone);
       
       // Create physics body
       const bodyDesc = physics.RigidBodyDesc.fixed();
       const body = world.createRigidBody(bodyDesc);
       body.setTranslation({ 
         x: x, 
         y: proto.variant.height * heightScale / 2, 
         z: z 
       });
       
       let colliderDesc;
       if (proto.collider.type === 'box') {
         colliderDesc = physics.ColliderDesc.cuboid(
           proto.collider.width * scaleFactor / 2,
           proto.collider.height * heightScale / 2,
           proto.collider.depth * scaleFactor / 2
         );
       } else {
         colliderDesc = physics.ColliderDesc.cylinder(
           proto.collider.height * heightScale / 2,
           proto.collider.radius * scaleFactor
         );
       }
       
       world.createCollider(colliderDesc, body);
       
       const buildingData = {
         mesh: buildingClone,
         body,
         width: (proto.collider.width || proto.collider.radius * 2) * scaleFactor,
         height: proto.collider.height * heightScale,
         depth: (proto.collider.depth || proto.collider.radius * 2) * scaleFactor,
         type: proto.variant.type
       };
       
       buildings.push(buildingData);
       
       // Add door to box buildings only
       if (proto.variant.type === 'box') {
         addDoorToBuilding(buildingData, x, z, scaleFactor);
       }
     }
     
     // ==================== DOOR SYSTEM ====================
     function addDoorToBuilding(building, x, z, scaleFactor) {
       // Only add doors to some buildings for performance
       if (Math.random() > 0.5) return;  // 50% of buildings get doors
       
       const panelW = 1.0 * scaleFactor;  // Wider panels for bigger buildings
       const panelH = 3.0 * scaleFactor;  // Taller panels
       const panelT = 0.05 * scaleFactor;
       const gap = 0.03 * scaleFactor;
       const flushOffset = 0.04 * scaleFactor;
       
       // Place door on front face (Z+)
       const doorX = x;
       const doorZ = z + building.depth / 2 + 0.2;
       
       // Create 4 glass panels
       const panelGeo = new THREE.BoxGeometry(panelW, panelH, panelT);
       const glassMat = new THREE.MeshPhysicalMaterial({
         color: 0xcad7df,
         roughness: 0.85,
         transmission: 0.6,
         thickness: 0.5,
         ior: 1.5,
         attenuationColor: 0xaadfff,
         attenuationDistance: 1.5,
         metalness: 0.0,
         specularIntensity: 0.35,
         transparent: true
       });
       
       const panels = [];
       const w = panelW;
       
       // Panel positions closed
       const centersClosed = [
         doorX - 1.5*w - gap,         // outer left (fixed)
         doorX - 0.5*w - gap/2,       // inner left (slides left)
         doorX + 0.5*w + gap/2,       // inner right (slides right)
         doorX + 1.5*w + gap          // outer right (fixed)
       ];
       
       const centersOpen = [
         centersClosed[0],
         centersClosed[0],      // inner-left flush with outer-left
         centersClosed[3],      // inner-right flush with outer-right
         centersClosed[3]
       ];
       
       for (let i = 0; i < 4; i++) {
         const panel = new THREE.Mesh(panelGeo, glassMat);
         panel.position.set(centersClosed[i], panelH * 0.5, doorZ);
         panel.castShadow = false;
         panel.receiveShadow = false;
         worldRoot.add(panel);
         panels.push(panel);
       }
       
       // Create frame strips (4 per panel = 16 total)
       const stripT = 0.015 * scaleFactor;
       const stripD = 0.035 * scaleFactor;
       const frameStripGeo = new THREE.BoxGeometry(panelW + stripT*2, stripT, stripD);
       const frameMat = new THREE.MeshStandardMaterial({ 
         color: 0xb9c4cf, 
         roughness: 0.35, 
         metalness: 0.8
       });
       
       const frames = [];
       const halfW = panelW/2;
       const halfH = panelH/2;
       
       // Create frame strips for each panel
       for (let i = 0; i < 4; i++) {
         const cx = centersClosed[i];
         const y = panelH*0.5;
         
         // Top strip
         const topStrip = new THREE.Mesh(frameStripGeo, frameMat);
         topStrip.position.set(cx, y + halfH - stripT/2, doorZ);
         topStrip.castShadow = false;
         worldRoot.add(topStrip);
         frames.push(topStrip);
         
         // Bottom strip
         const bottomStrip = new THREE.Mesh(frameStripGeo, frameMat);
         bottomStrip.position.set(cx, y - halfH + stripT/2, doorZ);
         bottomStrip.castShadow = false;
         worldRoot.add(bottomStrip);
         frames.push(bottomStrip);
         
         // Left strip (rotated)
         const frameStripGeoVert = new THREE.BoxGeometry(panelW + stripT*2, stripT, stripD);
         const leftStrip = new THREE.Mesh(frameStripGeoVert, frameMat);
         leftStrip.position.set(cx - halfW - stripT/2, y, doorZ);
         leftStrip.rotation.z = Math.PI/2;
         leftStrip.castShadow = false;
         worldRoot.add(leftStrip);
         frames.push(leftStrip);
         
         // Right strip (rotated)
         const rightStrip = new THREE.Mesh(frameStripGeoVert, frameMat);
         rightStrip.position.set(cx + halfW + stripT/2, y, doorZ);
         rightStrip.rotation.z = Math.PI/2;
         rightStrip.castShadow = false;
         worldRoot.add(rightStrip);
         frames.push(rightStrip);
       }
       
       // Track bar at bottom
       const trackGeo = new THREE.BoxGeometry(panelW * 4, 0.03 * scaleFactor, 0.05 * scaleFactor);
       const trackMat = new THREE.MeshStandardMaterial({ 
         color: 0x4a4a4a,
         roughness: 0.7,
         metalness: 0.5
       });
       const track = new THREE.Mesh(trackGeo, trackMat);
       track.position.set(doorX, 0.01 * scaleFactor, doorZ);
       track.castShadow = false;
       worldRoot.add(track);
       
       // Light pane behind door
       const lightGeo = new THREE.PlaneGeometry(panelW * 3, panelH * 0.9);
       const lightMat = new THREE.MeshBasicMaterial({
         color: 0xffffff,
         emissive: 0xffffff,
         emissiveIntensity: 0,
         transparent: true,
         opacity: 0
       });
       const lightPlane = new THREE.Mesh(lightGeo, lightMat);
       lightPlane.position.set(doorX, panelH * 0.5, doorZ - 0.2);
       worldRoot.add(lightPlane);
       
       // Point light for illumination - bigger range for bigger doors
       const doorLight = new THREE.PointLight(0xffffff, 0, 15);
       doorLight.position.set(doorX, panelH * 0.5, doorZ);
       worldRoot.add(doorLight);
       
       doors.push({
         position: new THREE.Vector3(doorX, 0, doorZ),
         panels: panels,
         frames: frames,
         track: track,
         lightPlane: lightPlane,
         light: doorLight,
         openAmount: 0,
         targetOpen: 0,
         centersClosed: centersClosed,
         centersOpen: centersOpen,
         panelW: panelW,
         panelH: panelH,
         flushOffset: flushOffset
       });
     }
     
     function updateDoors(deltaTime) {
       if (!playerBody || doors.length === 0) return;
       
       const playerPos = new THREE.Vector3(
         playerBody.translation().x,
         playerBody.translation().y,
         playerBody.translation().z
       );
       
       // Easing function
       const ease = (t) => t < 0 ? 0 : t > 1 ? 1 : t*t*(3-2*t);
       
       doors.forEach(door => {
         // Check distance to player
         const dist = playerPos.distanceTo(door.position);
         const openThreshold = 6.0;  // Open when within 6 meters (bigger scale)
         
         // Set target based on proximity
         door.targetOpen = dist < openThreshold ? 1 : 0;
         
         // Smooth animation with easing
         const speed = 2.0;
         const dir = Math.sign(door.targetOpen - door.openAmount);
         door.openAmount = Math.min(1, Math.max(0, 
           door.openAmount + dir * speed * deltaTime
         ));
         
         const k = ease(door.openAmount);
         
         // Update all 4 panels
         for (let i = 0; i < 4; i++) {
           const panel = door.panels[i];
           const closedX = door.centersClosed[i];
           const openX = door.centersOpen[i];
           
           panel.position.x = THREE.MathUtils.lerp(closedX, openX, k);
           
           // Inner panels move slightly forward when open
           if (i === 1) {
             panel.position.z = door.position.z - door.flushOffset * k;
           } else if (i === 2) {
             panel.position.z = door.position.z + door.flushOffset * k;
           }
         }
         
         // Update frame strips (16 total, 4 per panel)
         for (let i = 0; i < 4; i++) {
           const closedX = door.centersClosed[i];
           const openX = door.centersOpen[i];
           const baseX = THREE.MathUtils.lerp(closedX, openX, k);
           
           const baseIdx = i * 4;
           const halfW = door.panelW / 2;
           const halfH = door.panelH / 2;
           const stripT = 0.015;
           const y = door.panelH * 0.5;
           
           // Top strip
           door.frames[baseIdx].position.x = baseX;
           door.frames[baseIdx].position.y = y + halfH - stripT/2;
           
           // Bottom strip
           door.frames[baseIdx + 1].position.x = baseX;
           door.frames[baseIdx + 1].position.y = y - halfH + stripT/2;
           
           // Left strip
           door.frames[baseIdx + 2].position.x = baseX - halfW - stripT/2;
           door.frames[baseIdx + 2].position.y = y;
           
           // Right strip
           door.frames[baseIdx + 3].position.x = baseX + halfW + stripT/2;
           door.frames[baseIdx + 3].position.y = y;
           
           // Inner panels' frames move with depth
           if (i === 1) {
             const zOffset = door.position.z - door.flushOffset * k;
             for (let j = 0; j < 4; j++) {
               door.frames[baseIdx + j].position.z = zOffset;
             }
           } else if (i === 2) {
             const zOffset = door.position.z + door.flushOffset * k;
             for (let j = 0; j < 4; j++) {
               door.frames[baseIdx + j].position.z = zOffset;
             }
           }
         }
         
         // Update light emission (more dramatic)
         door.lightPlane.material.emissiveIntensity = k * 3.0;
         door.lightPlane.material.opacity = k * 0.8;
         door.light.intensity = k * 15.0;
       });
     }
    
    // Modern building with setbacks
    function createModernBuilding(x, z, width, height, depth) {
      const group = new THREE.Group();
      
      // Base color
      const hue = 0.55 + Math.random() * 0.1; // Blue-ish
      const saturation = 0.15 + Math.random() * 0.2;
      const lightness = 0.45 + Math.random() * 0.25;
      const baseColor = new THREE.Color().setHSL(hue, saturation, lightness);
      
      // Create stacked sections
      const sections = 2 + Math.floor(Math.random() * 2);
      let currentY = 0;
      
      for (let s = 0; s < sections; s++) {
        const sectionHeight = height / sections;
        const scale = 1 - s * 0.12;
        const sectionWidth = width * scale;
        const sectionDepth = depth * scale;
        
        const sectionGeo = new THREE.BoxGeometry(sectionWidth, sectionHeight, sectionDepth);
        const material = new THREE.MeshStandardMaterial({ 
          color: baseColor.clone().multiplyScalar(1 - s * 0.08),
          roughness: 0.6,
          metalness: 0.3
        });
        
        const section = new THREE.Mesh(sectionGeo, material);
        section.position.y = currentY + sectionHeight / 2;
        section.castShadow = true;
        section.receiveShadow = true;
        group.add(section);
        
        // Add facade details
        addModernFacade(section, sectionWidth, sectionHeight, sectionDepth, baseColor);
        
        currentY += sectionHeight;
      }
      
      group.position.set(x, 0, z);
      
      // Physics (simplified box for all sections)
      const bodyDesc = physics.RigidBodyDesc.fixed();
      const body = world.createRigidBody(bodyDesc);
      body.setTranslation({ x, y: height / 2, z });
      const colliderDesc = physics.ColliderDesc.cuboid(width / 2, height / 2, depth / 2);
      world.createCollider(colliderDesc, body);
      
      return { mesh: group, body, width, height, depth };
    }
    
    // Classic building with regular windows
    function createClassicBuilding(x, z, width, height, depth) {
      const group = new THREE.Group();
      
      const hue = 0.08 + Math.random() * 0.15; // Orange-brown
      const baseColor = new THREE.Color().setHSL(hue, 0.3, 0.5);
      
      const geometry = new THREE.BoxGeometry(width, height, depth);
      const material = new THREE.MeshStandardMaterial({ 
        color: baseColor,
        roughness: 0.7,
        metalness: 0.1
      });
      
      const building = new THREE.Mesh(geometry, material);
      building.position.y = height / 2;
      building.castShadow = true;
      building.receiveShadow = true;
      group.add(building);
      
      // Add classic facade with grid windows
      addClassicFacade(building, width, height, depth, baseColor);
      
      group.position.set(x, 0, z);
      
      // Physics
      const bodyDesc = physics.RigidBodyDesc.fixed();
      const body = world.createRigidBody(bodyDesc);
      body.setTranslation({ x, y: height / 2, z });
      const colliderDesc = physics.ColliderDesc.cuboid(width / 2, height / 2, depth / 2);
      world.createCollider(colliderDesc, body);
      
      return { mesh: group, body, width, height, depth };
    }
    
    // Tower building (cylinder)
    function createTowerBuilding(x, z, width, height, depth) {
      const group = new THREE.Group();
      
      const hue = 0.5 + Math.random() * 0.2;
      const baseColor = new THREE.Color().setHSL(hue, 0.25, 0.55);
      
      const radius = Math.min(width, depth) / 2;
      const geometry = new THREE.CylinderGeometry(radius, radius * 1.1, height, 12);
      const material = new THREE.MeshStandardMaterial({ 
        color: baseColor,
        roughness: 0.65,
        metalness: 0.25
      });
      
      const tower = new THREE.Mesh(geometry, material);
      tower.position.y = height / 2;
      tower.castShadow = true;
      tower.receiveShadow = true;
      group.add(tower);
      
      // Add tower windows
      addTowerWindows(tower, radius, height, baseColor);
      
      group.position.set(x, 0, z);
      
      // Physics (cylinder collider)
      const bodyDesc = physics.RigidBodyDesc.fixed();
      const body = world.createRigidBody(bodyDesc);
      body.setTranslation({ x, y: height / 2, z });
      const colliderDesc = physics.ColliderDesc.cylinder(height / 2, radius);
      world.createCollider(colliderDesc, body);
      
      return { mesh: group, body, width: radius * 2, height, depth: radius * 2 };
    }
    
    // Modern facade with flat window decals
    function addModernFacade(building, width, height, depth, baseColor) {
      const windowColor = new THREE.Color(0xFFEB3B);
      const floors = Math.max(3, Math.floor(height / 2.5));
      const windowsPerSide = Math.max(2, Math.floor(width / 1.8));
      const windowWidth = 0.8;
      const windowHeight = 1.2;
      
      // Front and back facades (Z-axis)
      for (let side = 0; side < 2; side++) {
        const zOffset = side === 0 ? depth / 2 + 0.01 : -depth / 2 - 0.01;
        
        for (let floor = 1; floor <= floors; floor++) {
          for (let w = 0; w < windowsPerSide; w++) {
            if (Math.random() > 0.8) continue; // Some unlit windows
            
            const y = -height / 2 + floor * (height / (floors + 1));
            const xPos = -width / 2 + (w + 0.5) * (width / windowsPerSide);
            
            // Flat window decal
            const windowGeo = new THREE.PlaneGeometry(windowWidth, windowHeight);
            const windowMat = new THREE.MeshBasicMaterial({ 
              color: windowColor,
              emissive: windowColor,
              emissiveIntensity: 0.5,
              transparent: true,
              opacity: 0.9
            });
            const window = new THREE.Mesh(windowGeo, windowMat);
            window.position.set(xPos, y, zOffset);
            window.rotation.y = side === 0 ? 0 : Math.PI;
            building.add(window);
          }
        }
      }
      
      // Side facades (X-axis)
      for (let side = 0; side < 2; side++) {
        const xOffset = side === 0 ? width / 2 + 0.01 : -width / 2 - 0.01;
        const windowsPerSide = Math.max(2, Math.floor(depth / 1.8));
        
        for (let floor = 1; floor <= floors; floor++) {
          for (let w = 0; w < windowsPerSide; w++) {
            if (Math.random() > 0.8) continue;
            
            const y = -height / 2 + floor * (height / (floors + 1));
            const zPos = -depth / 2 + (w + 0.5) * (depth / windowsPerSide);
            
            // Flat window decal
            const windowGeo = new THREE.PlaneGeometry(windowWidth, windowHeight);
            const windowMat = new THREE.MeshBasicMaterial({ 
              color: windowColor,
              emissive: windowColor,
              emissiveIntensity: 0.5,
              transparent: true,
              opacity: 0.9
            });
            const window = new THREE.Mesh(windowGeo, windowMat);
            window.position.set(xOffset, y, zPos);
            window.rotation.y = side === 0 ? Math.PI / 2 : -Math.PI / 2;
            building.add(window);
          }
        }
      }
    }
    
    // Classic facade with flat window decals
    function addClassicFacade(building, width, height, depth, baseColor) {
      const windowColor = new THREE.Color(0xFFCC33);
      const floors = Math.max(3, Math.floor(height / 2.2));
      const windowsX = Math.max(3, Math.floor(width / 1.5));
      const windowsZ = Math.max(3, Math.floor(depth / 1.5));
      const windowSize = 0.6;
      
      // Z faces
      for (let side = 0; side < 2; side++) {
        const zOffset = side === 0 ? depth / 2 + 0.01 : -depth / 2 - 0.01;
        
        for (let floor = 0; floor < floors; floor++) {
          for (let w = 0; w < windowsX; w++) {
            if (Math.random() > 0.75) continue;
            
            const y = -height / 2 + (floor + 0.5) * (height / floors);
            const x = -width / 2 + (w + 0.5) * (width / windowsX);
            
            // Flat window decal
            const windowGeo = new THREE.PlaneGeometry(windowSize, windowSize);
            const windowMat = new THREE.MeshBasicMaterial({ 
              color: windowColor,
              emissive: windowColor,
              emissiveIntensity: 0.4,
              transparent: true,
              opacity: 0.85
            });
            const window = new THREE.Mesh(windowGeo, windowMat);
            window.position.set(x, y, zOffset);
            window.rotation.y = side === 0 ? 0 : Math.PI;
            building.add(window);
          }
        }
      }
      
      // X faces
      for (let side = 0; side < 2; side++) {
        const xOffset = side === 0 ? width / 2 + 0.01 : -width / 2 - 0.01;
        
        for (let floor = 0; floor < floors; floor++) {
          for (let w = 0; w < windowsZ; w++) {
            if (Math.random() > 0.75) continue;
            
            const y = -height / 2 + (floor + 0.5) * (height / floors);
            const z = -depth / 2 + (w + 0.5) * (depth / windowsZ);
            
            // Flat window decal
            const windowGeo = new THREE.PlaneGeometry(windowSize, windowSize);
            const windowMat = new THREE.MeshBasicMaterial({ 
              color: windowColor,
              emissive: windowColor,
              emissiveIntensity: 0.4,
              transparent: true,
              opacity: 0.85
            });
            const window = new THREE.Mesh(windowGeo, windowMat);
            window.position.set(xOffset, y, z);
            window.rotation.y = side === 0 ? Math.PI / 2 : -Math.PI / 2;
            building.add(window);
          }
        }
      }
    }
    
    // Tower windows (vertical strips) - flat decals
    function addTowerWindows(tower, radius, height, baseColor) {
      const windowColor = new THREE.Color(0x8AB4FF);
      const floors = Math.max(4, Math.floor(height / 2.0));
      const segments = 12;
      const windowHeight = 1.0;
      const windowWidth = 0.5;
      
      for (let seg = 0; seg < segments; seg++) {
        const angle = (seg / segments) * Math.PI * 2;
        const x = Math.cos(angle) * (radius + 0.01);
        const z = Math.sin(angle) * (radius + 0.01);
        
        for (let floor = 1; floor < floors; floor++) {
          if (Math.random() > 0.75) continue;
          
          const y = -height / 2 + floor * (height / floors);
          
          // Flat window decal on cylinder surface
          const windowGeo = new THREE.PlaneGeometry(windowWidth, windowHeight);
          const windowMat = new THREE.MeshBasicMaterial({ 
            color: windowColor,
            emissive: windowColor,
            emissiveIntensity: 0.35,
            transparent: true,
            opacity: 0.85
          });
          const window = new THREE.Mesh(windowGeo, windowMat);
          window.position.set(x, y, z);
          window.lookAt(0, y, 0);
          tower.add(window);
        }
      }
    }
    
     // ==================== PLAYER ====================
     function createPlayer() {
       const bodyDesc = physics.RigidBodyDesc.dynamic()
         .setTranslation(0, 5, 0)  // Spawn at city center
         .setLinearDamping(0.3)
         .setAngularDamping(10.0)
         .lockRotations();
      
      playerBody = world.createRigidBody(bodyDesc);
      
      const colliderDesc = physics.ColliderDesc.capsule(CONFIG.PLAYER_HEIGHT / 2, CONFIG.PLAYER_RADIUS)
        .setFriction(0.8)
        .setRestitution(0.0);
      world.createCollider(colliderDesc, playerBody);
      
      // Visual (optional, hidden in first-person)
      const playerGeometry = new THREE.CapsuleGeometry(CONFIG.PLAYER_RADIUS, CONFIG.PLAYER_HEIGHT, 4, 8);
      const playerMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x4a7cff,
        roughness: 0.4,
        metalness: 0.6
      });
      player = new THREE.Mesh(playerGeometry, playerMaterial);
      player.castShadow = true;
      player.visible = false; // Hide in FPS
      scene.add(player);
    }
    
    // ==================== PLANET GROUND ====================
    function createSphericalGround() {
      const radius = planetRadius;
      const geometry = new THREE.SphereGeometry(radius, 64, 64);
      
      // Apply noise/texture to the sphere
      const positions = geometry.attributes.position;
      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const y = positions.getY(i);
        const z = positions.getZ(i);
        
        // Add subtle noise for terrain variation
        const noise = Math.sin(x * 0.01) * Math.cos(z * 0.01) * 3;
        const scale = (radius + noise) / radius;
        
        positions.setXYZ(i, x * scale, y * scale, z * scale);
      }
      positions.needsUpdate = true;
      geometry.computeVertexNormals();
      
      // Create material with texture
      const material = new THREE.MeshStandardMaterial({
        color: 0x4a7c4e,
        roughness: 0.9,
        metalness: 0.1,
        flatShading: false
      });
      
      const planet = new THREE.Mesh(geometry, material);
      planet.receiveShadow = true;
      planet.castShadow = false;
      
      // Position player on top of planet
      planet.position.y = -radius;
      
      if (!worldRoot) {
        worldRoot = new THREE.Group();
        scene.add(worldRoot);
      }
      
      worldRoot.add(planet);
      
      console.log('Spherical planet ground created, radius:', radius);
      return planet;
    }
    
    // ==================== ROCKET SYSTEM ====================
    function createRocket() {
      const rocketGroup = new THREE.Group();
      
      // Main body (cylinder)
      const bodyRadius = 0.4;
      const bodyHeight = 4;
      const bodyGeo = new THREE.CylinderGeometry(bodyRadius, bodyRadius, bodyHeight, 16);
      const bodyMat = new THREE.MeshStandardMaterial({ 
        color: 0xEEEEEE,
        metalness: 0.6,
        roughness: 0.3
      });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = bodyHeight / 2;
      body.castShadow = true;
      rocketGroup.add(body);
      
      // Nose cone
      const coneHeight = 1.5;
      const coneGeo = new THREE.ConeGeometry(bodyRadius, coneHeight, 16);
      const coneMat = new THREE.MeshStandardMaterial({ 
        color: 0xFF4444,
        metalness: 0.5,
        roughness: 0.4
      });
      const cone = new THREE.Mesh(coneGeo, coneMat);
      cone.position.y = bodyHeight + coneHeight / 2;
      cone.castShadow = true;
      rocketGroup.add(cone);
      
      // Fins (4 fins)
      const finHeight = 1.2;
      const finWidth = 0.8;
      const finThickness = 0.1;
      const finGeo = new THREE.BoxGeometry(finWidth, finHeight, finThickness);
      const finMat = new THREE.MeshStandardMaterial({ 
        color: 0x444444,
        metalness: 0.7,
        roughness: 0.3
      });
      
      for (let i = 0; i < 4; i++) {
        const fin = new THREE.Mesh(finGeo, finMat);
        const angle = (i / 4) * Math.PI * 2;
        fin.position.x = Math.cos(angle) * bodyRadius;
        fin.position.z = Math.sin(angle) * bodyRadius;
        fin.position.y = finHeight / 2;
        fin.rotation.y = angle;
        fin.castShadow = true;
        rocketGroup.add(fin);
      }
      
      // Exhaust flame (hidden initially)
      const flameGeo = new THREE.ConeGeometry(bodyRadius * 0.8, 2, 8);
      const flameMat = new THREE.MeshBasicMaterial({ 
        color: 0xFF6600,
        transparent: true,
        opacity: 0.8
      });
      const flame = new THREE.Mesh(flameGeo, flameMat);
      flame.position.y = -1;
      flame.rotation.x = Math.PI;
      flame.visible = false;
      rocketGroup.add(flame);
      rocketGroup.userData.flame = flame;
      
      rocketMesh = rocketGroup;
      rocketMesh.visible = false;
      scene.add(rocketMesh);
      
      // Create rocket physics body
      const bodyDesc = physics.RigidBodyDesc.dynamic()
        .setTranslation(0, 5, 0)
        .setLinearDamping(0.1)
        .setAngularDamping(10.0)
        .lockRotations();
      
      rocketBody = world.createRigidBody(bodyDesc);
      
      const colliderDesc = physics.ColliderDesc.cylinder(bodyHeight / 2, bodyRadius);
      world.createCollider(colliderDesc, rocketBody);
      
      console.log('Rocket created');
    }
    
    function toggleRocket() {
      if (!rocketBody || !rocketMesh) {
        createRocket();
      }
      
      rocketEnabled = !rocketEnabled;
      rocketMesh.visible = rocketEnabled;
      player.visible = !rocketEnabled && !pointerLocked;
      
      if (rocketEnabled && playerBody && rocketBody) {
        // Transfer position from player to rocket
        const playerPos = playerBody.translation();
        rocketBody.setTranslation({ x: playerPos.x, y: playerPos.y, z: playerPos.z }, true);
        rocketBody.setLinvel({ x: 0, y: 0, z: 0 }, true);
        rocketVelocity = 0;
        
        // Show flame
        if (rocketMesh.userData.flame) {
          rocketMesh.userData.flame.visible = true;
        }
        
        console.log('Rocket mode enabled - launching!');
      } else if (!rocketEnabled && playerBody && rocketBody) {
        // Transfer position from rocket to player
        const rocketPos = rocketBody.translation();
        playerBody.setTranslation({ x: rocketPos.x, y: rocketPos.y, z: rocketPos.z }, true);
        playerBody.setLinvel({ x: 0, y: 0, z: 0 }, true);
        
        // Hide flame
        if (rocketMesh.userData.flame) {
          rocketMesh.userData.flame.visible = false;
        }
        
        console.log('Rocket mode disabled');
      }
    }
    
    function updateRocket(deltaTime) {
      if (!rocketEnabled || !rocketBody || !rocketMesh) return;
      
      const pos = rocketBody.translation();
      const vel = rocketBody.linvel();
      
      // Update rocket mesh position
      rocketMesh.position.set(pos.x, pos.y, pos.z);
      
      // Accelerate upward
      rocketVelocity = Math.min(ROCKET_MAX_SPEED, rocketVelocity + rocketAcceleration * deltaTime);
      
      // Apply upward velocity
      rocketBody.setLinvel({
        x: 0,
        y: rocketVelocity,
        z: 0
      }, true);
      
      // Animate flame
      if (rocketMesh.userData.flame) {
        const flame = rocketMesh.userData.flame;
        flame.scale.y = 1 + Math.sin(performance.now() * 0.01) * 0.3;
        flame.rotation.z += deltaTime * 5;
      }
      
      // Orbital camera controls (use pitch/yaw from mouse movement)
      // Clamp pitch to prevent flipping
      rocketCameraPitch = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, rocketCameraPitch));
      
      // Calculate camera position in spherical coordinates around rocket
      const camX = pos.x + rocketCameraDistance * Math.cos(rocketCameraPitch) * Math.sin(rocketCameraYaw);
      const camY = pos.y + rocketCameraDistance * Math.sin(rocketCameraPitch);
      const camZ = pos.z + rocketCameraDistance * Math.cos(rocketCameraPitch) * Math.cos(rocketCameraYaw);
      
      camera.position.set(camX, camY, camZ);
      
      // Camera look at rocket
      camera.lookAt(pos.x, pos.y, pos.z);
      
      // Mouse wheel to zoom
      // (handled in setupCameraControls)
      
      // Dynamic scaling based on altitude
      const altitude = pos.y;
      if (altitude > 100) {
        // Scale down world as rocket goes higher
        const scaleFactor = Math.max(0.1, 1 - (altitude - 100) / 500);
        worldRoot.scale.setScalar(scaleFactor);
        
        // Scale down player too
        if (altitude > 200) {
          playerScale = Math.max(0.01, 1 - (altitude - 200) / 300);
        }
      }
      
      console.log(`Rocket altitude: ${altitude.toFixed(1)}m, velocity: ${rocketVelocity.toFixed(1)}m/s`);
    }
    
    // ==================== BIKE SYSTEM ====================
    function createBike() {
      const bikeGroup = new THREE.Group();
      
      // Body (from lightbike.html) - rotated 90 degrees
      const bodyGeo = new THREE.BoxGeometry(3.6, 1, 1.05);
      const bodyMat = new THREE.MeshLambertMaterial({ 
        color: 0x00ffff, 
        emissive: 0x00ffff, 
        emissiveIntensity: 0.8 
      });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.set(0, 1.2, 0);
      body.rotation.y = Math.PI / 2; // Rotate body 90 degrees
      body.castShadow = true;
      bikeGroup.add(body);
      
      // Wheels - rotated 90 degrees from their default orientation
      const wheelR = 0.7;
      const wheelMat = new THREE.MeshLambertMaterial({ 
        color: 0xcccccc, 
        emissive: 0x888888, 
        emissiveIntensity: 0.3 
      });
      const wheelGeo = new THREE.CylinderGeometry(wheelR, wheelR, 0.3, 24);
      
      // Front wheel - rotated to roll along Z axis
      const w1 = new THREE.Mesh(wheelGeo, wheelMat);
      w1.rotation.x = Math.PI / 2; // Rotate 90 degrees to roll forward
      w1.position.set(0, wheelR, 1.4); // Along Z axis
      w1.castShadow = true;
      bikeGroup.add(w1);
      
      // Rear wheel - rotated to roll along Z axis
      const w2 = new THREE.Mesh(wheelGeo, wheelMat);
      w2.rotation.x = Math.PI / 2; // Rotate 90 degrees to roll forward
      w2.position.set(0, wheelR, -1.4); // Along Z axis
      w2.castShadow = true;
      bikeGroup.add(w2);
      
      bikeMesh = bikeGroup;
      bikeMesh.visible = false;
      scene.add(bikeMesh);
      
      // Create bike physics body (similar to player)
      const bodyDesc = physics.RigidBodyDesc.dynamic()
        .setTranslation(0, 2, 0)
        .setLinearDamping(0.5)
        .setAngularDamping(10.0)
        .lockRotations();
      
      bikeBody = world.createRigidBody(bodyDesc);
      
      const colliderDesc = physics.ColliderDesc.cuboid(0.52, 0.5, 1.8) // Swapped dimensions for rotation
        .setFriction(0.7)
        .setRestitution(0.1);
      world.createCollider(colliderDesc, bikeBody);
      
      // Create trail mesh
      createBikeTrail();
    }
    
    function createBikeTrail() {
      // Create vertical light trail like in lightbike.html
      const trailGeo = new THREE.BufferGeometry();
      const trailMat = new THREE.MeshBasicMaterial({
        color: 0x00ffff,
        transparent: true,
        opacity: 0.85,
        side: THREE.DoubleSide,
        depthWrite: false,
        blending: THREE.AdditiveBlending
      });
      
      bikeTrailMesh = new THREE.Mesh(trailGeo, trailMat);
      bikeTrailMesh.renderOrder = 2;
      bikeTrailMesh.frustumCulled = false;
      bikeTrailMesh.visible = false;
      scene.add(bikeTrailMesh);
    }
    
    function makeTrailPermanent() {
      // Convert current trail into a permanent mesh
      if (!bikeTrailMesh || bikeTrailPoints.length < 2) return;
      
      const permanentGeo = bikeTrailMesh.geometry.clone();
      const permanentMat = new THREE.MeshBasicMaterial({
        color: 0x00ffff,
        transparent: true,
        opacity: 0.7,
        side: THREE.DoubleSide,
        depthWrite: false,
        blending: THREE.AdditiveBlending
      });
      
      const permanentMesh = new THREE.Mesh(permanentGeo, permanentMat);
      permanentMesh.renderOrder = 2;
      permanentMesh.frustumCulled = false;
      scene.add(permanentMesh);
      
      permanentTrails.push(permanentMesh);
      console.log('Trail made permanent');
    }
    
    function updateBikeTrail() {
      if (!bikeEnabled || !bikeBody || !bikeMesh || !bikeTrailMesh) return;
      
      const pos = bikeBody.translation();
      const currentPoint = new THREE.Vector3(pos.x, pos.y, pos.z);
      
      // Add point if moved enough distance
      if (bikeTrailPoints.length === 0 || 
          currentPoint.distanceTo(bikeTrailPoints[bikeTrailPoints.length - 1]) > 0.5) {
        bikeTrailPoints.push(currentPoint.clone());
        
        // Keep only last N points
        if (bikeTrailPoints.length > BIKE_TRAIL_MAX_POINTS) {
          bikeTrailPoints.shift();
        }
      }
      
      // Rebuild trail geometry
      if (bikeTrailPoints.length >= 2) {
        const trailHeight = 2.5; // Reduced from 6.0 to 2.5
        const positions = new Float32Array(bikeTrailPoints.length * 2 * 3);
        let pOff = 0;
        
        for (let i = 0; i < bikeTrailPoints.length; i++) {
          const p = bikeTrailPoints[i];
          // Bottom vertex
          positions[pOff++] = p.x;
          positions[pOff++] = p.y;
          positions[pOff++] = p.z;
          // Top vertex
          positions[pOff++] = p.x;
          positions[pOff++] = p.y + trailHeight;
          positions[pOff++] = p.z;
        }
        
        const indices = [];
        for (let i = 0; i < bikeTrailPoints.length - 1; i++) {
          const i0 = i * 2;
          const i1 = i * 2 + 1;
          const i2 = (i + 1) * 2;
          const i3 = (i + 1) * 2 + 1;
          
          indices.push(i0, i2, i1);
          indices.push(i2, i3, i1);
        }
        
        bikeTrailMesh.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        bikeTrailMesh.geometry.setIndex(indices);
        bikeTrailMesh.geometry.computeVertexNormals();
        bikeTrailMesh.visible = true;
      }
    }
    
    function sharpTurnBike(direction) {
      if (!bikeEnabled || !bikeBody || !bikeMesh) return;
      
      // Sharp 90 degree turn
      // direction: 'left' increases yaw (turn left), 'right' decreases yaw (turn right)
      if (direction === 'left') {
        yaw += Math.PI / 2;
        console.log('Bike sharp LEFT turn!');
      } else {
        yaw -= Math.PI / 2;
        console.log('Bike sharp RIGHT turn!');
      }
      
      // Finalize current trail segment
      if (bikeTrailPoints.length > 0) {
        const pos = bikeBody.translation();
        bikeTrailPoints.push(new THREE.Vector3(pos.x, pos.y, pos.z));
      }
    }
    
    function toggleBike() {
      if (!bikeBody || !bikeMesh) {
        createBike();
      }
      
      bikeEnabled = !bikeEnabled;
      bikeMesh.visible = bikeEnabled;
      player.visible = !bikeEnabled && !pointerLocked; // Hide player mesh in FPS
      
      if (bikeEnabled && playerBody && bikeBody) {
        // Transfer position from player to bike (same height, no jump)
        const playerPos = playerBody.translation();
        bikeBody.setTranslation({ x: playerPos.x, y: playerPos.y, z: playerPos.z }, true);
        bikeBody.setLinvel({ x: 0, y: 0, z: 0 }, true);
        bikeSpeed = 0;
        bikeTargetSpeed = 0;
        bikeAutoPilot = true; // Enable autopilot by default
        // Clear trail
        bikeTrailPoints = [];
        if (bikeTrailMesh) {
          bikeTrailMesh.visible = false;
        }
        console.log('Bike enabled (autopilot on)');
      } else if (!bikeEnabled && playerBody && bikeBody) {
        // Transfer position from bike to player
        const bikePos = bikeBody.translation();
        playerBody.setTranslation({ x: bikePos.x, y: bikePos.y, z: bikePos.z }, true);
        playerBody.setLinvel({ x: 0, y: 0, z: 0 }, true);
        // Make trail permanent
        makeTrailPermanent();
        // Hide current trail
        if (bikeTrailMesh) {
          bikeTrailMesh.visible = false;
        }
        console.log('Bike disabled, trail left behind');
      }
    }
    
    function updateBike(deltaTime) {
      if (!bikeEnabled || !bikeBody || !bikeMesh) return;
      
      const pos = bikeBody.translation();
      const vel = bikeBody.linvel();
      
      // Update bike mesh position
      bikeMesh.position.set(pos.x, pos.y, pos.z);
      
      // Wheelie control (S or ArrowDown)
      const wheelieInput = keys.has('KeyS') || keys.has('ArrowDown');
      
      if (wheelieInput && !bikeWallRiding) {
        // Build up wheelie
        bikeWheelieProgress = Math.min(1.0, bikeWheelieProgress + deltaTime * 1.5);
      } else if (!bikeWallRiding) {
        // Release wheelie
        bikeWheelieProgress = Math.max(0, bikeWheelieProgress - deltaTime * 2.0);
      }
      
      // Wheelie angle (max 45 degrees)
      bikeWheelieAngle = bikeWheelieProgress * (Math.PI / 4);
      
      // Enable jump when wheelie is at max
      bikeCanJump = bikeWheelieProgress >= 0.95;
      
      // Jump control (Space when wheelie is maxed)
      if (keys.has('Space') && bikeCanJump && Math.abs(vel.y) < 0.1 && !bikeWallRiding) {
        bikeBody.applyImpulse({ x: 0, y: 15, z: 0 }, true);
        keys.delete('Space');
        console.log('Bike jump!');
      }
      
      // Check for wall collision while in air
      if (bikeWheelieProgress > 0.5 && Math.abs(vel.y) > 0.1) {
        checkWallRiding(pos, vel);
      }
      
      // Wall riding physics
      if (bikeWallRiding) {
        const forward = new THREE.Vector3(
          Math.sin(yaw),
          0,
          Math.cos(yaw)
        );
        
        // Project forward onto wall surface
        const wallForward = forward.clone().sub(bikeWallNormal.clone().multiplyScalar(forward.dot(bikeWallNormal))).normalize();
        
        // Move along wall
        bikeBody.setLinvel({
          x: wallForward.x * bikeSpeed,
          y: 0, // No gravity while wall riding
          z: wallForward.z * bikeSpeed
        }, true);
        
        // Check if still near wall
        const raycast = world.castRay(
          new physics.Ray(pos, new THREE.Vector3(bikeWallNormal.x, bikeWallNormal.y, bikeWallNormal.z).negate()),
          2.0,
          true
        );
        
        if (!raycast || raycast.toi > 1.0) {
          // Left wall
          bikeWallRiding = false;
          bikeWheelieProgress = 0;
          console.log('Left wall');
        }
      } else {
        // Normal bike control
        // Autopilot mode vs manual control
        if (bikeAutoPilot) {
          // Autopilot: drive forward automatically
          bikeTargetSpeed = BIKE_MAX_SPEED * 0.8; // 80% speed on autopilot
          
          // Optional steering in autopilot (A/D still work)
          let turnAmount = 0;
          if (keys.has('KeyA')) turnAmount = 1;  // A = left (increase yaw)
          if (keys.has('KeyD')) turnAmount = -1; // D = right (decrease yaw)
          yaw += turnAmount * BIKE_TURN_RATE * deltaTime;
        } else {
          // Manual control: W for acceleration
          if (keys.has('KeyW')) {
            bikeTargetSpeed = BIKE_MAX_SPEED;
          } else {
            bikeTargetSpeed = BIKE_MAX_SPEED * 0.3; // Coast
          }
          
          // Steering (A/D)
          let turnAmount = 0;
          if (keys.has('KeyA')) turnAmount = 1;  // A = left (increase yaw)
          if (keys.has('KeyD')) turnAmount = -1; // D = right (decrease yaw)
          yaw += turnAmount * BIKE_TURN_RATE * deltaTime;
        }
        
        // Smooth acceleration
        bikeSpeed += (bikeTargetSpeed - bikeSpeed) * BIKE_ACCEL * deltaTime;
        
        // Apply forward velocity
        const forward = new THREE.Vector3(
          Math.sin(yaw),
          0,
          Math.cos(yaw)
        );
        
        bikeBody.setLinvel({
          x: forward.x * bikeSpeed,
          y: vel.y, // Preserve vertical velocity
          z: forward.z * bikeSpeed
        }, true);
      }
      
      // Update bike mesh rotation with wheelie
      bikeMesh.rotation.y = yaw;
      bikeMesh.rotation.x = -bikeWheelieAngle; // Tilt back for wheelie
      
      // Wall riding orientation
      if (bikeWallRiding) {
        // Orient bike to wall
        const wallUp = bikeWallNormal.clone();
        bikeMesh.rotation.z = Math.atan2(wallUp.x, wallUp.y);
      } else {
        bikeMesh.rotation.z = 0;
      }
      
      // Camera position (above and behind bike)
      const cameraDistance = 10;
      const cameraHeight = 4;
      const forward = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
      camera.position.set(
        pos.x - forward.x * cameraDistance,
        pos.y + cameraHeight,
        pos.z - forward.z * cameraDistance
      );
      
      // Camera look-at (ahead of bike)
      const lookAhead = 15;
      camera.lookAt(
        pos.x + forward.x * lookAhead,
        pos.y + 1,
        pos.z + forward.z * lookAhead
      );
      
      // Update trail
      updateBikeTrail();
    }
    
    function checkWallRiding(pos, vel) {
      // Cast ray in forward direction to check for walls
      const forward = new THREE.Vector3(
        Math.sin(yaw),
        0,
        Math.cos(yaw)
      );
      
      const raycast = world.castRay(
        new physics.Ray(pos, forward),
        2.0,
        true
      );
      
      if (raycast && raycast.toi < 1.5) {
        // Hit a wall, start wall riding
        bikeWallRiding = true;
        
        // Get the normal from the raycast hit
        // Rapier returns the normal in the raycast object, but we need to check if it exists
        if (raycast.normal) {
          bikeWallNormal.set(raycast.normal.x, raycast.normal.y, raycast.normal.z);
        } else {
          // Fallback: use reverse of ray direction as approximate normal
          bikeWallNormal.set(-forward.x, -forward.y, -forward.z);
        }
        
        // Adjust yaw to be parallel to wall
        const wallTangent = new THREE.Vector3(-bikeWallNormal.z, 0, bikeWallNormal.x).normalize();
        yaw = Math.atan2(wallTangent.x, wallTangent.z);
        
        console.log('Started wall riding!');
      }
    }
    
    // ==================== PATHFINDING SYSTEM ====================
    function worldToGrid(x, z) {
      return {
        x: Math.floor(x / GRID_CELL_SIZE),
        z: Math.floor(z / GRID_CELL_SIZE)
      };
    }
    
    function gridToWorld(gx, gz) {
      return {
        x: gx * GRID_CELL_SIZE + GRID_CELL_SIZE / 2,
        z: gz * GRID_CELL_SIZE + GRID_CELL_SIZE / 2
      };
    }
    
    function gridKey(gx, gz) {
      return `${gx},${gz}`;
    }
    
    function markSidewalkWalkable(x, z, width, depth) {
      // Mark grid cells as walkable for sidewalks
      const g1 = worldToGrid(x - width/2, z - depth/2);
      const g2 = worldToGrid(x + width/2, z + depth/2);
      
      for (let gx = g1.x; gx <= g2.x; gx++) {
        for (let gz = g1.z; gz <= g2.z; gz++) {
          pathGrid.set(gridKey(gx, gz), true);
        }
      }
    }
    
    function findPath(startX, startZ, endX, endZ) {
      // A* pathfinding with 90-degree turns
      const start = worldToGrid(startX, startZ);
      const end = worldToGrid(endX, endZ);
      
      const openSet = [start];
      const cameFrom = new Map();
      const gScore = new Map();
      const fScore = new Map();
      
      gScore.set(gridKey(start.x, start.z), 0);
      fScore.set(gridKey(start.x, start.z), heuristic(start, end));
      
      function heuristic(a, b) {
        // Manhattan distance for grid-based movement
        return Math.abs(a.x - b.x) + Math.abs(a.z - b.z);
      }
      
      function getNeighbors(node) {
        // Only 90-degree turns (4 directions)
        const neighbors = [];
        const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
        
        for (const [dx, dz] of dirs) {
          const nx = node.x + dx;
          const nz = node.z + dz;
          const key = gridKey(nx, nz);
          
          // Check if walkable
          if (pathGrid.has(key)) {
            neighbors.push({ x: nx, z: nz });
          }
        }
        
        return neighbors;
      }
      
      while (openSet.length > 0) {
        // Find node with lowest fScore
        let current = openSet[0];
        let currentIdx = 0;
        let lowestF = fScore.get(gridKey(current.x, current.z)) || Infinity;
        
        for (let i = 1; i < openSet.length; i++) {
          const f = fScore.get(gridKey(openSet[i].x, openSet[i].z)) || Infinity;
          if (f < lowestF) {
            lowestF = f;
            current = openSet[i];
            currentIdx = i;
          }
        }
        
        // Check if we reached the goal
        if (current.x === end.x && current.z === end.z) {
          // Reconstruct path
          const path = [];
          let temp = current;
          
          while (temp) {
            const worldPos = gridToWorld(temp.x, temp.z);
            path.unshift(new THREE.Vector3(worldPos.x, 0, worldPos.z));
            const key = gridKey(temp.x, temp.z);
            temp = cameFrom.get(key);
          }
          
          return path;
        }
        
        // Remove current from openSet
        openSet.splice(currentIdx, 1);
        
        // Check neighbors
        const neighbors = getNeighbors(current);
        const currentKey = gridKey(current.x, current.z);
        const currentG = gScore.get(currentKey) || Infinity;
        
        for (const neighbor of neighbors) {
          const neighborKey = gridKey(neighbor.x, neighbor.z);
          const tentativeG = currentG + 1;
          const neighborG = gScore.get(neighborKey) || Infinity;
          
          if (tentativeG < neighborG) {
            cameFrom.set(neighborKey, current);
            gScore.set(neighborKey, tentativeG);
            fScore.set(neighborKey, tentativeG + heuristic(neighbor, end));
            
            // Add to openSet if not already there
            if (!openSet.some(n => n.x === neighbor.x && n.z === neighbor.z)) {
              openSet.push(neighbor);
            }
          }
        }
      }
      
      // No path found, return straight line
      return [
        new THREE.Vector3(startX, 0, startZ),
        new THREE.Vector3(endX, 0, endZ)
      ];
    }
    
    // ==================== SPECIAL CONSTRUCTIONS ====================
    function createPlayground(x, z, size = 15) {
      const playgroundGroup = new THREE.Group();
      
      // Ground (rubber surface)
      const groundGeo = new THREE.BoxGeometry(size, 0.1, size);
      const groundMat = new THREE.MeshStandardMaterial({ color: 0x4A7C59, roughness: 0.9 });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.position.y = 0.05;
      ground.receiveShadow = true;
      playgroundGroup.add(ground);
      
      // Swing set
      const swingPoleGeo = new THREE.CylinderGeometry(0.1, 0.1, 3, 8);
      const metalMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.6, roughness: 0.4 });
      
      const leftPole = new THREE.Mesh(swingPoleGeo, metalMat);
      leftPole.position.set(-4, 1.5, -3);
      leftPole.castShadow = true;
      playgroundGroup.add(leftPole);
      
      const rightPole = new THREE.Mesh(swingPoleGeo, metalMat);
      rightPole.position.set(4, 1.5, -3);
      rightPole.castShadow = true;
      playgroundGroup.add(rightPole);
      
      const topBar = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 8.5, 8), metalMat);
      topBar.rotation.z = Math.PI / 2;
      topBar.position.set(0, 3, -3);
      topBar.castShadow = true;
      playgroundGroup.add(topBar);
      
      // Swings with thick chain strings
      for (let i = -1; i <= 1; i++) {
        const seatGeo = new THREE.BoxGeometry(0.4, 0.1, 0.6);
        const seatMat = new THREE.MeshStandardMaterial({ color: 0xFF6B6B });
        const seat = new THREE.Mesh(seatGeo, seatMat);
        seat.position.set(i * 2, 0.8, -3);
        seat.castShadow = true;
        playgroundGroup.add(seat);
        
        // Create thick rope/chain strings using billboard sprites
        const ropeSegments = 8;
        const ropeLength = 3 - 0.8; // from top bar to seat
        
        // Left chain
        for (let seg = 0; seg < ropeSegments; seg++) {
          const t = seg / (ropeSegments - 1);
          const yPos = 3 - t * ropeLength;
          
          // Create sprite for chain link
          const canvas = document.createElement('canvas');
          canvas.width = 64;
          canvas.height = 64;
          const ctx = canvas.getContext('2d');
          ctx.fillStyle = '#666666';
          ctx.fillRect(24, 0, 16, 64);
          ctx.fillStyle = '#888888';
          ctx.fillRect(26, 0, 12, 64);
          
          const texture = new THREE.CanvasTexture(canvas);
          const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true });
          const sprite = new THREE.Sprite(spriteMat);
          sprite.position.set(i * 2 - 0.15, yPos, -3);
          sprite.scale.set(0.15, ropeLength / ropeSegments * 1.2, 1);
          playgroundGroup.add(sprite);
        }
        
        // Right chain
        for (let seg = 0; seg < ropeSegments; seg++) {
          const t = seg / (ropeSegments - 1);
          const yPos = 3 - t * ropeLength;
          
          const canvas = document.createElement('canvas');
          canvas.width = 64;
          canvas.height = 64;
          const ctx = canvas.getContext('2d');
          ctx.fillStyle = '#666666';
          ctx.fillRect(24, 0, 16, 64);
          ctx.fillStyle = '#888888';
          ctx.fillRect(26, 0, 12, 64);
          
          const texture = new THREE.CanvasTexture(canvas);
          const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true });
          const sprite = new THREE.Sprite(spriteMat);
          sprite.position.set(i * 2 + 0.15, yPos, -3);
          sprite.scale.set(0.15, ropeLength / ropeSegments * 1.2, 1);
          playgroundGroup.add(sprite);
        }
      }
      
      // Slide
      const slidePlatform = new THREE.Mesh(new THREE.BoxGeometry(2, 0.2, 2), metalMat);
      slidePlatform.position.set(-3, 2, 3);
      slidePlatform.castShadow = true;
      playgroundGroup.add(slidePlatform);
      
      const slideRamp = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.1, 4), new THREE.MeshStandardMaterial({ color: 0xFFCC00, metalness: 0.5 }));
      slideRamp.position.set(-3, 1, 1);
      slideRamp.rotation.x = -Math.PI / 6;
      slideRamp.castShadow = true;
      playgroundGroup.add(slideRamp);
      
      // Enhanced Monkey bars with side supports
      const monkeyBarWidth = 3;
      const monkeyBarHeight = 2.2;
      
      // Left support
      const leftSupport = new THREE.Mesh(swingPoleGeo, metalMat);
      leftSupport.position.set(-1.5, monkeyBarHeight / 2, 3);
      leftSupport.scale.y = monkeyBarHeight / 3;
      leftSupport.castShadow = true;
      playgroundGroup.add(leftSupport);
      
      // Right support
      const rightSupport = new THREE.Mesh(swingPoleGeo, metalMat);
      rightSupport.position.set(1.5, monkeyBarHeight / 2, 3);
      rightSupport.scale.y = monkeyBarHeight / 2;
      rightSupport.castShadow = true;
      playgroundGroup.add(rightSupport);
      
      // Horizontal bars
      for (let i = 0; i < 8; i++) {
        const bar = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, monkeyBarWidth, 8), metalMat);
        bar.rotation.z = Math.PI / 2;
        bar.position.set(0, monkeyBarHeight, 3 + i * 0.4 - 1.4);
        bar.castShadow = true;
        playgroundGroup.add(bar);
      }
      
      // Spinning merry-go-round
      const spinnerRadius = 1.5;
      const spinnerHeight = 0.15;
      
      // Base pole
      const spinnerPole = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 1.5, 12), metalMat);
      spinnerPole.position.set(4, 0.75, 3);
      spinnerPole.castShadow = true;
      playgroundGroup.add(spinnerPole);
      
      // Rotating platform
      const spinnerGroup = new THREE.Group();
      const platformGeo = new THREE.CylinderGeometry(spinnerRadius, spinnerRadius, spinnerHeight, 16);
      const platformMat = new THREE.MeshStandardMaterial({ color: 0x4488FF, metalness: 0.4, roughness: 0.6 });
      const platform = new THREE.Mesh(platformGeo, platformMat);
      platform.castShadow = true;
      spinnerGroup.add(platform);
      
      // Handle bars
      for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2;
        const handleGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.8, 8);
        const handle = new THREE.Mesh(handleGeo, metalMat);
        handle.position.set(
          Math.cos(angle) * spinnerRadius * 0.7,
          0.5,
          Math.sin(angle) * spinnerRadius * 0.7
        );
        handle.castShadow = true;
        spinnerGroup.add(handle);
      }
      
      spinnerGroup.position.set(4, 1.5, 3);
      spinnerGroup.userData.isSpinner = true;
      spinnerGroup.userData.spinSpeed = 0.5; // radians per second
      playgroundGroup.add(spinnerGroup);
      playgroundGroup.userData.spinner = spinnerGroup;
      
      // Sandbox with deformed sand
      const sandboxSize = 3;
      const sandboxWallHeight = 0.3;
      const sandboxWallThickness = 0.15;
      
      // Sandbox walls (wooden frame)
      const woodMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 });
      
      // Front wall
      const frontWall = new THREE.Mesh(
        new THREE.BoxGeometry(sandboxSize + sandboxWallThickness * 2, sandboxWallHeight, sandboxWallThickness),
        woodMat
      );
      frontWall.position.set(4, sandboxWallHeight / 2, -3 - sandboxSize / 2);
      frontWall.castShadow = true;
      playgroundGroup.add(frontWall);
      
      // Back wall
      const backWall = new THREE.Mesh(
        new THREE.BoxGeometry(sandboxSize + sandboxWallThickness * 2, sandboxWallHeight, sandboxWallThickness),
        woodMat
      );
      backWall.position.set(4, sandboxWallHeight / 2, -3 + sandboxSize / 2);
      backWall.castShadow = true;
      playgroundGroup.add(backWall);
      
      // Left wall
      const leftWall = new THREE.Mesh(
        new THREE.BoxGeometry(sandboxWallThickness, sandboxWallHeight, sandboxSize),
        woodMat
      );
      leftWall.position.set(4 - sandboxSize / 2, sandboxWallHeight / 2, -3);
      leftWall.castShadow = true;
      playgroundGroup.add(leftWall);
      
      // Right wall
      const rightWall = new THREE.Mesh(
        new THREE.BoxGeometry(sandboxWallThickness, sandboxWallHeight, sandboxSize),
        woodMat
      );
      rightWall.position.set(4 + sandboxSize / 2, sandboxWallHeight / 2, -3);
      rightWall.castShadow = true;
      playgroundGroup.add(rightWall);
      
      // Deformed sand mesh with hills
      const sandResolution = 20;
      const sandGeo = new THREE.PlaneGeometry(sandboxSize, sandboxSize, sandResolution, sandResolution);
      const sandMat = new THREE.MeshStandardMaterial({ color: 0xDDC894, roughness: 0.95 });
      
      // Deform vertices to create hills
      const positions = sandGeo.attributes.position;
      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const z = positions.getY(i); // Y in plane geometry becomes Z in 3D
        
        // Create hills using sine waves
        const hill1 = Math.sin(x * 3) * Math.cos(z * 3) * 0.08;
        const hill2 = Math.sin(x * 5 + 1) * Math.cos(z * 4 + 2) * 0.05;
        const hill3 = Math.sin(x * 2.5 + 2) * Math.cos(z * 2.5 + 1) * 0.06;
        
        positions.setZ(i, hill1 + hill2 + hill3);
      }
      positions.needsUpdate = true;
      sandGeo.computeVertexNormals();
      
      const sand = new THREE.Mesh(sandGeo, sandMat);
      sand.rotation.x = -Math.PI / 2;
      sand.position.set(4, 0.12, -3);
      sand.receiveShadow = true;
      playgroundGroup.add(sand);
      
      // Pail (bucket)
      const pailGeo = new THREE.CylinderGeometry(0.15, 0.12, 0.25, 12);
      const pailMat = new THREE.MeshStandardMaterial({ color: 0xFF4444, metalness: 0.2, roughness: 0.6 });
      const pail = new THREE.Mesh(pailGeo, pailMat);
      pail.position.set(4.5, 0.25, -2.5);
      pail.rotation.z = 0.2;
      pail.castShadow = true;
      playgroundGroup.add(pail);
      
      // Pail handle
      const handleCurve = new THREE.EllipseCurve(0, 0, 0.15, 0.2, 0, Math.PI, false, 0);
      const handlePoints = handleCurve.getPoints(16);
      const handleGeo = new THREE.TubeGeometry(
        new THREE.CatmullRomCurve3(handlePoints.map(p => new THREE.Vector3(p.x, p.y, 0))),
        16, 0.015, 6, false
      );
      const handleMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.6 });
      const handle = new THREE.Mesh(handleGeo, handleMat);
      handle.position.copy(pail.position);
      handle.position.y += 0.2;
      handle.rotation.copy(pail.rotation);
      playgroundGroup.add(handle);
      
      // Shovel
      const shovelHandleGeo = new THREE.CylinderGeometry(0.015, 0.015, 0.5, 6);
      const shovelHandleMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
      const shovelHandle = new THREE.Mesh(shovelHandleGeo, shovelHandleMat);
      shovelHandle.position.set(3.5, 0.15, -2.7);
      shovelHandle.rotation.z = Math.PI / 6;
      shovelHandle.castShadow = true;
      playgroundGroup.add(shovelHandle);
      
      // Shovel blade
      const shovelBladeGeo = new THREE.BoxGeometry(0.12, 0.15, 0.02);
      const shovelBladeMat = new THREE.MeshStandardMaterial({ color: 0x4444FF, metalness: 0.6 });
      const shovelBlade = new THREE.Mesh(shovelBladeGeo, shovelBladeMat);
      shovelBlade.position.set(3.3, 0.08, -2.65);
      shovelBlade.rotation.z = Math.PI / 6;
      shovelBlade.rotation.y = 0.1;
      shovelBlade.castShadow = true;
      playgroundGroup.add(shovelBlade);
      
      playgroundGroup.position.set(x, 0, z);
      playgroundGroup.userData.isAtomic = true;
      playgroundGroup.userData.pickable = true;
      playgroundGroup.userData.objectType = 'playground';
      
      return playgroundGroup;
    }
    
    function createParkingLot(x, z, width = 20, depth = 20) {
      const parkingGroup = new THREE.Group();
      
      // Asphalt ground
      const groundGeo = new THREE.BoxGeometry(width, 0.1, depth);
      const asphaltMat = new THREE.MeshStandardMaterial({ color: 0x2A2A2A, roughness: 0.95 });
      const ground = new THREE.Mesh(groundGeo, asphaltMat);
      ground.position.y = 0.05;
      ground.receiveShadow = true;
      parkingGroup.add(ground);
      
      // Parking lines (white stripes)
      const lineGeo = new THREE.PlaneGeometry(0.2, 5);
      const lineMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, side: THREE.DoubleSide });
      
      const spotsPerRow = Math.floor(width / 3);
      const rows = Math.floor(depth / 6);
      
      for (let row = 0; row < rows; row++) {
        for (let spot = 0; spot < spotsPerRow; spot++) {
          const line = new THREE.Mesh(lineGeo, lineMat);
          line.rotation.x = -Math.PI / 2;
          line.position.set(
            spot * 3 - width / 2 + 1.5,
            0.11,
            row * 6 - depth / 2 + 3
          );
          parkingGroup.add(line);
        }
      }
      
      // Spawn cars in parking lot - reduced for performance
      const carCount = Math.floor((spotsPerRow * rows) * 0.4); // 40% full
      for (let i = 0; i < carCount; i++) {
        const row = Math.floor(Math.random() * rows);
        const spot = Math.floor(Math.random() * spotsPerRow);
        const car = createCar();
        car.position.set(
          spot * 3 - width / 2 + 1.5,
          0,
          row * 6 - depth / 2 + 3
        );
        car.rotation.y = Math.random() > 0.5 ? 0 : Math.PI;
        parkingGroup.add(car);
      }
      
      parkingGroup.position.set(x, 0, z);
      parkingGroup.userData.isAtomic = true;
      parkingGroup.userData.pickable = true;
      parkingGroup.userData.objectType = 'parkingLot';
      
      return parkingGroup;
    }
    
    function createCar() {
      const carGroup = new THREE.Group();
      
      const colors = [0xFF0000, 0x0000FF, 0x00FF00, 0xFFFF00, 0xFF00FF, 0x00FFFF, 0xFFFFFF, 0x000000, 0x888888];
      const carColor = colors[Math.floor(Math.random() * colors.length)];
      
      // Body
      const bodyGeo = new THREE.BoxGeometry(1.8, 0.6, 4);
      const bodyMat = new THREE.MeshStandardMaterial({ color: carColor, metalness: 0.7, roughness: 0.3 });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = 0.5;
      body.castShadow = true;
      carGroup.add(body);
      
      // Cabin
      const cabinGeo = new THREE.BoxGeometry(1.6, 0.5, 2);
      const cabinMat = new THREE.MeshStandardMaterial({ color: carColor, metalness: 0.6, roughness: 0.4 });
      const cabin = new THREE.Mesh(cabinGeo, cabinMat);
      cabin.position.y = 1.05;
      cabin.position.z = -0.2;
      cabin.castShadow = true;
      carGroup.add(cabin);
      
      // Windows
      const windowGeo = new THREE.BoxGeometry(1.5, 0.4, 0.8);
      const windowMat = new THREE.MeshStandardMaterial({ color: 0x88CCFF, transparent: true, opacity: 0.6, metalness: 0.8 });
      
      const frontWindow = new THREE.Mesh(windowGeo, windowMat);
      frontWindow.position.set(0, 1.05, 0.6);
      carGroup.add(frontWindow);
      
      const backWindow = new THREE.Mesh(windowGeo, windowMat);
      backWindow.position.set(0, 1.05, -1);
      carGroup.add(backWindow);
      
      // Wheels
      const wheelGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 12);
      const wheelMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
      
      const wheels = [
        [-0.9, 0.3, 1.2],
        [0.9, 0.3, 1.2],
        [-0.9, 0.3, -1.2],
        [0.9, 0.3, -1.2]
      ];
      
      wheels.forEach(([x, y, z]) => {
        const wheel = new THREE.Mesh(wheelGeo, wheelMat);
        wheel.rotation.z = Math.PI / 2;
        wheel.position.set(x, y, z);
        wheel.castShadow = true;
        carGroup.add(wheel);
      });
      
      carGroup.userData.isAtomic = true;
      carGroup.userData.pickable = true;
      carGroup.userData.objectType = 'car';
      
      return carGroup;
    }
    
    function createParkingGarage(x, z, width = 25, depth = 25, levels = 4) {
      const garageGroup = new THREE.Group();
      
      const levelHeight = 3;
      const structureColor = 0x6A6A6A;
      
      // Columns
      const columnGeo = new THREE.BoxGeometry(0.5, levelHeight * levels, 0.5);
      const columnMat = new THREE.MeshStandardMaterial({ color: structureColor, roughness: 0.8 });
      
      const columnPositions = [
        [-width/2 + 2, 0, -depth/2 + 2],
        [width/2 - 2, 0, -depth/2 + 2],
        [-width/2 + 2, 0, depth/2 - 2],
        [width/2 - 2, 0, depth/2 - 2],
        [0, 0, -depth/2 + 2],
        [0, 0, depth/2 - 2],
        [-width/2 + 2, 0, 0],
        [width/2 - 2, 0, 0]
      ];
      
      columnPositions.forEach(([cx, cy, cz]) => {
        const column = new THREE.Mesh(columnGeo, columnMat);
        column.position.set(cx, (levelHeight * levels) / 2, cz);
        column.castShadow = true;
        column.receiveShadow = true;
        garageGroup.add(column);
      });
      
      // Floors for each level
      for (let level = 0; level < levels; level++) {
        const floorY = level * levelHeight;
        
        // Floor slab
        const floorGeo = new THREE.BoxGeometry(width, 0.3, depth);
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x4A4A4A, roughness: 0.9 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.position.y = floorY;
        floor.receiveShadow = true;
        floor.castShadow = true;
        garageGroup.add(floor);
        
        // Railing
        const railGeo = new THREE.BoxGeometry(width, 0.1, 0.1);
        const railMat = new THREE.MeshStandardMaterial({ color: 0xCCCCCC, metalness: 0.5 });
        
        // Front and back rails
        const frontRail = new THREE.Mesh(railGeo, railMat);
        frontRail.position.set(0, floorY + 1, depth/2);
        garageGroup.add(frontRail);
        
        const backRail = new THREE.Mesh(railGeo, railMat);
        backRail.position.set(0, floorY + 1, -depth/2);
        garageGroup.add(backRail);
        
        // Side rails
        const sideRailGeo = new THREE.BoxGeometry(0.1, 0.1, depth);
        const leftRail = new THREE.Mesh(sideRailGeo, railMat);
        leftRail.position.set(-width/2, floorY + 1, 0);
        garageGroup.add(leftRail);
        
        const rightRail = new THREE.Mesh(sideRailGeo, railMat);
        rightRail.position.set(width/2, floorY + 1, 0);
        garageGroup.add(rightRail);
        
        // Add cars on each level - reduced for performance
        const carsPerLevel = 4 + Math.floor(Math.random() * 3); // 4-6 cars per level
        for (let c = 0; c < carsPerLevel; c++) {
          const car = createCar();
          car.position.set(
            (Math.random() - 0.5) * (width - 4),
            floorY + 0.15,
            (Math.random() - 0.5) * (depth - 4)
          );
          car.rotation.y = Math.random() * Math.PI * 2;
          garageGroup.add(car);
        }
      }
      
      // Roof
      const roofGeo = new THREE.BoxGeometry(width, 0.4, depth);
      const roofMat = new THREE.MeshStandardMaterial({ color: 0x3A3A3A });
      const roof = new THREE.Mesh(roofGeo, roofMat);
      roof.position.y = levels * levelHeight + 0.2;
      roof.castShadow = true;
      garageGroup.add(roof);
      
      garageGroup.position.set(x, 0, z);
      garageGroup.userData.isAtomic = true;
      garageGroup.userData.pickable = true;
      garageGroup.userData.objectType = 'parkingGarage';
      garageGroup.userData.levels = levels;
      
      return garageGroup;
    }
    
    function createHospitalBuilding(x, z, width = 30, depth = 30, height = 25) {
      const hospitalGroup = new THREE.Group();
      
      // Main building
      const buildingGeo = new THREE.BoxGeometry(width, height, depth);
      const buildingMat = new THREE.MeshStandardMaterial({ color: 0xE8E8E8, roughness: 0.7 });
      const building = new THREE.Mesh(buildingGeo, buildingMat);
      building.position.y = height / 2;
      building.castShadow = true;
      building.receiveShadow = true;
      hospitalGroup.add(building);
      
      // Red cross on front
      const crossVertical = new THREE.Mesh(
        new THREE.BoxGeometry(2, 6, 0.1),
        new THREE.MeshBasicMaterial({ color: 0xFF0000 })
      );
      crossVertical.position.set(0, height * 0.7, depth/2 + 0.1);
      hospitalGroup.add(crossVertical);
      
      const crossHorizontal = new THREE.Mesh(
        new THREE.BoxGeometry(6, 2, 0.1),
        new THREE.MeshBasicMaterial({ color: 0xFF0000 })
      );
      crossHorizontal.position.set(0, height * 0.7, depth/2 + 0.1);
      hospitalGroup.add(crossHorizontal);
      
      // Windows (grid pattern)
      const windowGeo = new THREE.PlaneGeometry(1.2, 1.5);
      const windowMat = new THREE.MeshStandardMaterial({ 
        color: 0x88CCFF, 
        emissive: 0x4488FF,
        emissiveIntensity: 0.3,
        transparent: true,
        opacity: 0.8
      });
      
      const floors = Math.floor(height / 3.5);
      const windowsPerRow = Math.floor(width / 3);
      
      for (let floor = 0; floor < floors; floor++) {
        for (let w = 0; w < windowsPerRow; w++) {
          const window = new THREE.Mesh(windowGeo, windowMat);
          window.position.set(
            w * 3 - width/2 + 1.5,
            floor * 3.5 + 2,
            depth/2 + 0.05
          );
          hospitalGroup.add(window);
        }
      }
      
      // Emergency entrance
      const entranceGeo = new THREE.BoxGeometry(5, 4, 0.5);
      const entranceMat = new THREE.MeshStandardMaterial({ color: 0xFF6B6B });
      const entrance = new THREE.Mesh(entranceGeo, entranceMat);
      entrance.position.set(-width/3, 2, depth/2 + 0.3);
      hospitalGroup.add(entrance);
      
      // "EMERGENCY" sign
      const signGeo = new THREE.PlaneGeometry(4, 0.8);
      const signMat = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
      const sign = new THREE.Mesh(signGeo, signMat);
      sign.position.set(-width/3, 4.5, depth/2 + 0.6);
      hospitalGroup.add(sign);
      
      hospitalGroup.position.set(x, 0, z);
      hospitalGroup.userData.isAtomic = true;
      hospitalGroup.userData.pickable = true;
      hospitalGroup.userData.objectType = 'hospital';
      
      return hospitalGroup;
    }
    
    // ==================== DOOR & SIDEWALK INTEGRATION ====================
    function ensureBuildingHasDoor(buildingMesh, buildingPos, buildingWidth, buildingDepth) {
      // Find nearest sidewalk edge (simplified - assumes grid layout)
      // Doors should face outward toward nearest sidewalk
      
      // Determine which side is closest to a sidewalk (assuming grid layout)
      const gridX = Math.round(buildingPos.x / 60); // Assuming 60m blocks
      const gridZ = Math.round(buildingPos.z / 60);
      
      // Simple heuristic: door faces the nearest cardinal direction
      const offsetX = buildingPos.x - (gridX * 60);
      const offsetZ = buildingPos.z - (gridZ * 60);
      
      let doorSide = 'front'; // +Z
      let doorX = 0;
      let doorZ = buildingDepth / 2;
      let doorRotation = 0;
      
      if (Math.abs(offsetX) > Math.abs(offsetZ)) {
        // Door on X axis
        if (offsetX > 0) {
          doorSide = 'right';
          doorX = buildingWidth / 2;
          doorZ = 0;
          doorRotation = Math.PI / 2;
        } else {
          doorSide = 'left';
          doorX = -buildingWidth / 2;
          doorZ = 0;
          doorRotation = -Math.PI / 2;
        }
      } else {
        // Door on Z axis
        if (offsetZ > 0) {
          doorSide = 'front';
          doorX = 0;
          doorZ = buildingDepth / 2;
          doorRotation = 0;
        } else {
          doorSide = 'back';
          doorX = 0;
          doorZ = -buildingDepth / 2;
          doorRotation = Math.PI;
        }
      }
      
      // Create door mesh (simple for now)
      const doorWidth = 2;
      const doorHeight = 3;
      const doorGeo = new THREE.BoxGeometry(doorWidth, doorHeight, 0.2);
      const doorMat = new THREE.MeshStandardMaterial({ 
        color: 0x3a2a1a,
        metalness: 0.3,
        roughness: 0.8
      });
      const door = new THREE.Mesh(doorGeo, doorMat);
      door.position.set(
        buildingPos.x + doorX,
        doorHeight / 2,
        buildingPos.z + doorZ
      );
      door.rotation.y = doorRotation;
      door.castShadow = true;
      
      if (worldRoot) {
        worldRoot.add(door);
      } else {
        scene.add(door);
      }
      
      // Mark walkable path to door
      markSidewalkWalkable(
        buildingPos.x + doorX,
        buildingPos.z + doorZ,
        4, 4
      );
      
      return door;
    }
    
    function initializeSidewalkGrid() {
      // Create basic sidewalk grid (simplified - marks perimeter of blocks as walkable)
      const blockSize = 60;
      const citySize = 6; // 6x6 blocks
      
      for (let bx = -citySize; bx <= citySize; bx++) {
        for (let bz = -citySize; bz <= citySize; bz++) {
          const centerX = bx * blockSize;
          const centerZ = bz * blockSize;
          
          // Mark perimeter as sidewalk (3m wide)
          // North side
          markSidewalkWalkable(centerX, centerZ + blockSize/2, blockSize, 3);
          // South side
          markSidewalkWalkable(centerX, centerZ - blockSize/2, blockSize, 3);
          // East side
          markSidewalkWalkable(centerX + blockSize/2, centerZ, 3, blockSize);
          // West side
          markSidewalkWalkable(centerX - blockSize/2, centerZ, 3, blockSize);
        }
      }
      
      console.log(`Initialized pathfinding grid with ${pathGrid.size} walkable cells`);
    }
    
    // ==================== CHARACTER & BUILDING DATA ====================
    function generateBuildingData(buildingMesh, blockX, blockZ) {
      const types = buildingTypes;
      const type = types[Math.floor(Math.random() * types.length)];
      const names = buildingNames[type];
      const name = names[Math.floor(Math.random() * names.length)] + ' #' + Math.floor(Math.random() * 100);
      
      const data = {
        type,
        name,
        blockX,
        blockZ,
        position: buildingMesh.position.clone(),
        residents: [], // For apartments
        workers: []    // For workplaces
      };
      
      buildingDatabase.set(buildingMesh, data);
      return data;
    }
    
    function generateCharacterData(isFemale, isChild, chunkKey) {
      const id = 'ped_' + Math.random().toString(36).substr(2, 9);
      const firstName = isFemale ? 
        firstNamesFemale[Math.floor(Math.random() * firstNamesFemale.length)] :
        firstNamesMale[Math.floor(Math.random() * firstNamesMale.length)];
      const lastName = lastNames[Math.floor(Math.random() * lastNames.length)];
      const occupation = isChild ? 'Student' : occupations[Math.floor(Math.random() * occupations.length)];
      
      // Shirt colors - three primary colors
      const shirtColors = [0xE53935, 0x1E88E5, 0x43A047]; // Red, Blue, Green
      const shirtColor = shirtColors[Math.floor(Math.random() * shirtColors.length)];
      
      const data = {
        id,
        firstName,
        lastName,
        fullName: `${firstName} ${lastName}`,
        isFemale,
        isChild,
        age: isChild ? (6 + Math.floor(Math.random() * 12)) : (18 + Math.floor(Math.random() * 50)),
        occupation,
        shirtColor,
        hairColor: isFemale ? (Math.random() > 0.5 ? 'blonde' : 'brunette') : null,
        hairstyle: isFemale ? (Math.random() > 0.5 ? 'bob' : 'ponytail') : null,
        chunkKey,
        spouseId: null,
        homeBuilding: null,
        workBuilding: null,
        routine: [],
        currentActivity: null,
        activityProgress: 0
      };
      
      pedestrianDatabase.set(id, data);
      return data;
    }
    
    function generateMarriages() {
      // NYC same-gender marriage rate ~2-3% of population
      const pedestrianList = Array.from(pedestrianDatabase.values()).filter(p => !p.isChild && !p.spouseId);
      const marriageRate = 0.6; // 60% of adults are married
      const sameGenderRate = 0.03; // 3% same-gender marriages
      
      // Shuffle list
      for (let i = pedestrianList.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [pedestrianList[i], pedestrianList[j]] = [pedestrianList[j], pedestrianList[i]];
      }
      
      let i = 0;
      while (i < pedestrianList.length - 1 && Math.random() < marriageRate) {
        const person1 = pedestrianList[i];
        const person2 = pedestrianList[i + 1];
        
        // Decide if same-gender or opposite-gender
        const isSameGender = Math.random() < sameGenderRate;
        
        if (isSameGender) {
          // Find another person of same gender
          const sameGenderCandidates = pedestrianList.slice(i + 1).filter(p => 
            p.isFemale === person1.isFemale && !p.spouseId
          );
          
          if (sameGenderCandidates.length > 0) {
            const spouse = sameGenderCandidates[0];
            person1.spouseId = spouse.id;
            spouse.spouseId = person1.id;
            console.log(`Married (same-gender): ${person1.fullName} & ${spouse.fullName}`);
          }
        } else {
          // Opposite gender
          const oppositeGenderCandidates = pedestrianList.slice(i + 1).filter(p => 
            p.isFemale !== person1.isFemale && !p.spouseId
          );
          
          if (oppositeGenderCandidates.length > 0) {
            const spouse = oppositeGenderCandidates[0];
            person1.spouseId = spouse.id;
            spouse.spouseId = person1.id;
            console.log(`Married: ${person1.fullName} & ${spouse.fullName}`);
          }
        }
        
        i += 2;
      }
    }
    
    function assignHomesAndWorkplaces() {
      const buildingList = Array.from(buildingDatabase.values());
      const apartments = buildingList.filter(b => b.type === 'Apartment');
      const workplaces = buildingList.filter(b => b.type !== 'Apartment');
      
      pedestrianDatabase.forEach(char => {
        // Assign home
        if (apartments.length > 0) {
          const home = apartments[Math.floor(Math.random() * apartments.length)];
          char.homeBuilding = home;
          home.residents.push(char.id);
        }
        
        // Assign workplace (not for children)
        if (!char.isChild && workplaces.length > 0) {
          const work = workplaces[Math.floor(Math.random() * workplaces.length)];
          char.workBuilding = work;
          work.workers.push(char.id);
        }
      });
    }
    
    function generateDailyRoutine(charData) {
      // 10-minute day: 0-600 seconds
      // Morning (0-150s): Wake up, get ready
      // Work (150-450s): At workplace
      // Evening (450-600s): Home, socialize
      
      const routine = [];
      
      if (charData.isChild) {
        // Children: home -> school -> home
        routine.push({ activity: 'home', start: 0, end: 150, location: charData.homeBuilding });
        routine.push({ activity: 'school', start: 150, end: 450, location: charData.workBuilding });
        routine.push({ activity: 'home', start: 450, end: 600, location: charData.homeBuilding });
      } else {
        // Adults: home -> work -> optional socialize -> home
        routine.push({ activity: 'home', start: 0, end: 150, location: charData.homeBuilding });
        routine.push({ activity: 'work', start: 150, end: 420, location: charData.workBuilding });
        
        // 30% chance to socialize with spouse or friend
        if (Math.random() < 0.3 && charData.spouseId) {
          const spouseData = pedestrianDatabase.get(charData.spouseId);
          if (spouseData && spouseData.homeBuilding) {
            routine.push({ activity: 'socialize', start: 420, end: 480, location: spouseData.homeBuilding });
          }
        }
        
        routine.push({ activity: 'home', start: 480, end: 600, location: charData.homeBuilding });
      }
      
      charData.routine = routine;
      return routine;
    }
    
    // ==================== PEDESTRIAN SYSTEM ====================
    function createPedestrian(x, z, options = {}) {
      const isChild = options.isChild || false;
      const isFemale = options.isFemale !== undefined ? options.isFemale : Math.random() > 0.5;
      const scale = isChild ? 0.65 : 1.0;
      
      // Shirt colors - three primary colors
      const shirtColors = [0xE53935, 0x1E88E5, 0x43A047]; // Red, Blue, Green
      const shirtColor = options.shirtColor || shirtColors[Math.floor(Math.random() * shirtColors.length)];
      
      // Hair for females
      const hairColors = { blonde: 0xF5DEB3, brunette: 0x4A2511 };
      const hairColor = isFemale ? (Math.random() > 0.5 ? hairColors.blonde : hairColors.brunette) : null;
      const hairstyle = isFemale ? (Math.random() > 0.5 ? 'bob' : 'ponytail') : null;
      
      const pedestrianGroup = new THREE.Group();
      
      // Body scaling
      const bodyScale = scale;
      const torsoW = 0.5 * bodyScale;
      const torsoH = 0.8 * bodyScale;
      const torsoD = 0.3 * bodyScale;
      
      // Torso (colored shirt)
      const torsoGeo = new THREE.BoxGeometry(torsoW, torsoH, torsoD);
      const torsoMat = new THREE.MeshStandardMaterial({ color: shirtColor, roughness: 0.6 });
      const torso = new THREE.Mesh(torsoGeo, torsoMat);
      torso.position.y = torsoH / 2;
      torso.castShadow = true;
      pedestrianGroup.add(torso);
      
      // Head (skin tone)
      const headSize = 0.38 * bodyScale;
      const headGeo = new THREE.BoxGeometry(headSize, headSize, headSize * 0.9);
      const headMat = new THREE.MeshStandardMaterial({ color: 0xFFE0BD, roughness: 0.7 });
      const head = new THREE.Mesh(headGeo, headMat);
      head.position.y = torsoH + headSize / 2 + 0.05 * bodyScale;
      head.castShadow = true;
      pedestrianGroup.add(head);
      
      // Hair for females
      if (isFemale && hairColor) {
        const hairMat = new THREE.MeshStandardMaterial({ color: hairColor, roughness: 0.8 });
        
        if (hairstyle === 'bob') {
          // Bob cut - wider hair around head
          const bobGeo = new THREE.BoxGeometry(headSize * 1.15, headSize * 0.9, headSize * 1.1);
          const bob = new THREE.Mesh(bobGeo, hairMat);
          bob.position.y = head.position.y + headSize * 0.15;
          bob.castShadow = true;
          pedestrianGroup.add(bob);
        } else if (hairstyle === 'ponytail') {
          // Ponytail - hair on top and back
          const topGeo = new THREE.BoxGeometry(headSize * 1.1, headSize * 0.4, headSize * 0.9);
          const topHair = new THREE.Mesh(topGeo, hairMat);
          topHair.position.y = head.position.y + headSize * 0.4;
          topHair.castShadow = true;
          pedestrianGroup.add(topHair);
          
          // Ponytail back
          const ponytailGeo = new THREE.CylinderGeometry(0.08 * bodyScale, 0.06 * bodyScale, 0.5 * bodyScale, 8);
          const ponytail = new THREE.Mesh(ponytailGeo, hairMat);
          ponytail.rotation.x = Math.PI / 6;
          ponytail.position.set(0, head.position.y, -headSize * 0.5 - 0.15 * bodyScale);
          ponytail.castShadow = true;
          pedestrianGroup.add(ponytail);
        }
      }
      
      // Arms with forearms
      const armW = 0.14 * bodyScale;
      const armH = 0.42 * bodyScale;
      const forearmH = 0.38 * bodyScale;
      const armMat = new THREE.MeshStandardMaterial({ color: 0x86C7FF, roughness: 0.6 });
      const forearmMat = new THREE.MeshStandardMaterial({ color: 0x9CD3FF, roughness: 0.6 });
      
      // Left arm
      const armL = new THREE.Group();
      const armLUpper = new THREE.Mesh(new THREE.BoxGeometry(armW, armH, armW), armMat);
      armLUpper.position.y = -armH / 2;
      armLUpper.castShadow = true;
      armL.add(armLUpper);
      
      // Forearm pivot group positioned at bottom of upper arm
      const armLForearmPivot = new THREE.Group();
      armLForearmPivot.position.y = -armH; // At bottom edge of upper arm
      armLUpper.add(armLForearmPivot);
      
      const armLForearm = new THREE.Mesh(new THREE.BoxGeometry(armW * 0.9, forearmH, armW * 0.9), forearmMat);
      armLForearm.position.y = -forearmH / 2; // Offset down from pivot
      armLForearm.castShadow = true;
      armLForearmPivot.add(armLForearm);
      
      armL.position.set(-torsoW / 2 - armW / 2 - 0.02 * bodyScale, torsoH * 0.8, 0);
      armL.userData.upper = armLUpper;
      armL.userData.forearmPivot = armLForearmPivot;
      pedestrianGroup.add(armL);
      
      // Right arm
      const armR = new THREE.Group();
      const armRUpper = new THREE.Mesh(new THREE.BoxGeometry(armW, armH, armW), armMat);
      armRUpper.position.y = -armH / 2;
      armRUpper.castShadow = true;
      armR.add(armRUpper);
      
      // Forearm pivot group positioned at bottom of upper arm
      const armRForearmPivot = new THREE.Group();
      armRForearmPivot.position.y = -armH; // At bottom edge of upper arm
      armRUpper.add(armRForearmPivot);
      
      const armRForearm = new THREE.Mesh(new THREE.BoxGeometry(armW * 0.9, forearmH, armW * 0.9), forearmMat);
      armRForearm.position.y = -forearmH / 2; // Offset down from pivot
      armRForearm.castShadow = true;
      armRForearmPivot.add(armRForearm);
      
      armR.position.set(torsoW / 2 + armW / 2 + 0.02 * bodyScale, torsoH * 0.8, 0);
      armR.userData.upper = armRUpper;
      armR.userData.forearmPivot = armRForearmPivot;
      pedestrianGroup.add(armR);
      
      // Legs with knees
      const legW = 0.16 * bodyScale;
      const legH = 0.48 * bodyScale;
      const shinH = 0.46 * bodyScale;
      const legMat = new THREE.MeshStandardMaterial({ color: 0x4A5568, roughness: 0.7 });
      const shinMat = new THREE.MeshStandardMaterial({ color: 0x5A6678, roughness: 0.7 });
      
      // Left leg
      const legL = new THREE.Group();
      const legLThigh = new THREE.Mesh(new THREE.BoxGeometry(legW, legH, legW), legMat);
      legLThigh.position.y = -legH / 2;
      legLThigh.castShadow = true;
      legL.add(legLThigh);
      
      // Shin pivot group positioned at bottom of thigh
      const legLShinPivot = new THREE.Group();
      legLShinPivot.position.y = -legH; // At bottom edge of thigh
      legLThigh.add(legLShinPivot);
      
      const legLShin = new THREE.Mesh(new THREE.BoxGeometry(legW * 0.9, shinH, legW * 0.9), shinMat);
      legLShin.position.y = -shinH / 2; // Offset down from pivot
      legLShin.castShadow = true;
      legLShinPivot.add(legLShin);
      
      legL.position.set(-torsoW / 4, 0, 0);
      legL.userData.thigh = legLThigh;
      legL.userData.shinPivot = legLShinPivot;
      pedestrianGroup.add(legL);
      
      // Right leg
      const legR = new THREE.Group();
      const legRThigh = new THREE.Mesh(new THREE.BoxGeometry(legW, legH, legW), legMat);
      legRThigh.position.y = -legH / 2;
      legRThigh.castShadow = true;
      legR.add(legRThigh);
      
      // Shin pivot group positioned at bottom of thigh
      const legRShinPivot = new THREE.Group();
      legRShinPivot.position.y = -legH; // At bottom edge of thigh
      legRThigh.add(legRShinPivot);
      
      const legRShin = new THREE.Mesh(new THREE.BoxGeometry(legW * 0.9, shinH, legW * 0.9), shinMat);
      legRShin.position.y = -shinH / 2; // Offset down from pivot
      legRShin.castShadow = true;
      legRShinPivot.add(legRShin);
      
      legR.position.set(torsoW / 4, 0, 0);
      legR.userData.thigh = legRThigh;
      legR.userData.shinPivot = legRShinPivot;
      pedestrianGroup.add(legR);
      
      // Position pedestrian so feet are at ground level (legs extend down from torso)
      const feetOffset = legH + shinH; // Total leg height (thigh + shin)
      pedestrianGroup.position.set(x, feetOffset, z);
      
      // Generate or use character data
      const chunkKey = options.chunkKey || '0,0';
      const charData = options.charData || generateCharacterData(isFemale, isChild, chunkKey);
      
      // Mark as pickable and store character data
      pedestrianGroup.userData.isAtomic = true;
      pedestrianGroup.userData.pickable = true;
      pedestrianGroup.userData.objectType = 'pedestrian';
      pedestrianGroup.userData.characterId = charData.id;
      pedestrianGroup.userData.isFemale = isFemale;
      pedestrianGroup.userData.isChild = isChild;
      pedestrianGroup.userData.scale = scale;
      
      // Add profession label above head
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 64;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(0, 0, 256, 64);
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 24px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(charData.occupation, 128, 40);
      
      const texture = new THREE.CanvasTexture(canvas);
      const labelGeo = new THREE.PlaneGeometry(1.5, 0.4);
      const labelMat = new THREE.MeshBasicMaterial({ 
        map: texture, 
        transparent: true,
        side: THREE.DoubleSide
      });
      const label = new THREE.Mesh(labelGeo, labelMat);
      label.position.y = (torsoH + headSize + 0.3) * bodyScale;
      pedestrianGroup.add(label);
      pedestrianGroup.userData.label = label;
      
      scene.add(pedestrianGroup);
      
      // AI behavior with routine-based pathfinding
      const speed = (isChild ? 0.8 : 1.2) + Math.random() * 0.4;
      let pathToFollow = [];
      let pathIndex = 0;
      let destination = new THREE.Vector3(x, 0, z);
      let gait = Math.random() * Math.PI * 2;
      
      function updateRoutineDestination() {
        if (!charData || !charData.routine || charData.routine.length === 0) {
          // No routine, random walk
          const bounds = 20;
          destination.set(
            pedestrianGroup.position.x + (Math.random() - 0.5) * bounds,
            0,
            pedestrianGroup.position.z + (Math.random() - 0.5) * bounds
          );
          pathToFollow = [];
          return;
        }
        
        // Find current activity based on day time
        const activity = charData.routine.find(a => 
          currentDayTime >= a.start && currentDayTime < a.end
        );
        
        if (activity && activity.location && activity.location.position) {
          const target = activity.location.position;
          const dist = pedestrianGroup.position.distanceTo(target);
          
          // If far from destination, find path
          if (dist > 5) {
            pathToFollow = findPath(
              pedestrianGroup.position.x,
              pedestrianGroup.position.z,
              target.x,
              target.z
            );
            pathIndex = 0;
          } else {
            // Close enough, stay here
            destination.copy(target);
            pathToFollow = [];
          }
        }
      }
      
      function chooseNewDestination() {
        if (pathToFollow.length > 0 && pathIndex < pathToFollow.length) {
          // Follow path
          destination.copy(pathToFollow[pathIndex]);
          pathIndex++;
        } else {
          // Update routine
          updateRoutineDestination();
        }
      }
      
      function update(deltaTime) {
        // Move toward destination
        const toDestination = new THREE.Vector3(
          destination.x - pedestrianGroup.position.x,
          0,
          destination.z - pedestrianGroup.position.z
        );
        const distance = toDestination.length();
        
        if (distance < 0.5) {
          chooseNewDestination();
        } else {
          toDestination.normalize();
          
          // Move
          pedestrianGroup.position.x += toDestination.x * speed * deltaTime;
          pedestrianGroup.position.z += toDestination.z * speed * deltaTime;
          
          // Rotate to face direction
          const targetRotation = Math.atan2(toDestination.x, toDestination.z);
          pedestrianGroup.rotation.y = THREE.MathUtils.lerp(
            pedestrianGroup.rotation.y,
            targetRotation,
            5 * deltaTime
          );
          
          // Walking animation
          gait += 4.0 * deltaTime;
          const stepAmp = 0.6;
          
          // Animate legs with knee bending
          if (legL.userData.thigh && legL.userData.shinPivot) {
            // Thigh rotation
            legL.userData.thigh.rotation.x = Math.sin(gait) * stepAmp;
            // Knee bend (shin only bends forward)
            legL.userData.shinPivot.rotation.x = Math.max(0, -Math.sin(gait)) * 0.8;
          }
          if (legR.userData.thigh && legR.userData.shinPivot) {
            // Thigh rotation
            legR.userData.thigh.rotation.x = Math.sin(gait + Math.PI) * stepAmp;
            // Knee bend (shin only bends forward)
            legR.userData.shinPivot.rotation.x = Math.max(0, -Math.sin(gait + Math.PI)) * 0.8;
          }
          
          // Animate arms with elbow bending
          if (armL.userData.upper && armL.userData.forearmPivot) {
            // Shoulder swing
            armL.rotation.x = -Math.sin(gait) * 0.35;
            // Elbow bend
            armL.userData.forearmPivot.rotation.x = Math.abs(Math.sin(gait)) * 0.4;
          }
          if (armR.userData.upper && armR.userData.forearmPivot) {
            // Shoulder swing
            armR.rotation.x = Math.sin(gait) * 0.35;
            // Elbow bend
            armR.userData.forearmPivot.rotation.x = Math.abs(Math.sin(gait + Math.PI)) * 0.4;
          }
          
          // Bob torso
          torso.position.y = (torsoH / 2) + Math.abs(Math.sin(gait * 2)) * 0.05 * bodyScale;
        }
      }
      
      const pedestrianData = {
        group: pedestrianGroup,
        update,
        torso,
        head,
        armL,
        armR,
        legL,
        legR,
        isFemale,
        isChild,
        scale,
        charData
      };
      
      pedestrians.push(pedestrianData);
      return pedestrianData;
    }
    
    function spawnSpecialConstructions() {
      console.log('Spawning special constructions...');
      
      const blockSize = 60;
      const cityRadius = 3; // 3 blocks out from center
      
      // Playgrounds (2-3) - reduced for performance
      const playgroundCount = 2 + Math.floor(Math.random() * 2);
      for (let i = 0; i < playgroundCount; i++) {
        const angle = (i / playgroundCount) * Math.PI * 2 + Math.random() * 0.5;
        const radius = blockSize * (1 + Math.random() * 2);
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        
        const playground = createPlayground(x, z, 15);
        if (worldRoot) {
          worldRoot.add(playground);
        } else {
          scene.add(playground);
        }
        pluckCandidates.add(playground);
        console.log(`Playground at (${x.toFixed(1)}, ${z.toFixed(1)})`);
      }
      
      // Parking Lots (3-4) - reduced for performance
      const parkingLotCount = 3 + Math.floor(Math.random() * 2);
      for (let i = 0; i < parkingLotCount; i++) {
        const angle = (i / parkingLotCount) * Math.PI * 2 + Math.random() * 0.3;
        const radius = blockSize * (1.5 + Math.random() * 2);
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        
        const width = 20 + Math.floor(Math.random() * 10);
        const depth = 20 + Math.floor(Math.random() * 10);
        const parkingLot = createParkingLot(x, z, width, depth);
        if (worldRoot) {
          worldRoot.add(parkingLot);
        } else {
          scene.add(parkingLot);
        }
        pluckCandidates.add(parkingLot);
        console.log(`Parking lot at (${x.toFixed(1)}, ${z.toFixed(1)})`);
      }
      
      // Parking Garages (1-2) - reduced for performance
      const garageCount = 1 + Math.floor(Math.random() * 2);
      for (let i = 0; i < garageCount; i++) {
        const angle = (i / garageCount) * Math.PI * 2 + Math.random() * 0.7;
        const radius = blockSize * (2 + Math.random() * 1.5);
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        
        const levels = 3 + Math.floor(Math.random() * 3); // 3-5 levels
        const garage = createParkingGarage(x, z, 25, 25, levels);
        if (worldRoot) {
          worldRoot.add(garage);
        } else {
          scene.add(garage);
        }
        pluckCandidates.add(garage);
        console.log(`Parking garage (${levels} levels) at (${x.toFixed(1)}, ${z.toFixed(1)})`);
      }
      
      // Hospitals (2-3)
      const hospitalCount = 2 + Math.floor(Math.random() * 2);
      for (let i = 0; i < hospitalCount; i++) {
        const angle = (i / hospitalCount) * Math.PI * 2 + Math.random() * 0.8;
        const radius = blockSize * (1.8 + Math.random() * 1.2);
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        
        const hospital = createHospitalBuilding(x, z, 30, 30, 25);
        if (worldRoot) {
          worldRoot.add(hospital);
        } else {
          scene.add(hospital);
        }
        pluckCandidates.add(hospital);
        
        // Register as building data
        const buildingData = {
          type: 'Hospital',
          name: 'City Hospital #' + (i + 1),
          blockX: Math.round(x / blockSize),
          blockZ: Math.round(z / blockSize),
          position: new THREE.Vector3(x, 0, z),
          residents: [],
          workers: []
        };
        buildingDatabase.set(hospital, buildingData);
        console.log(`Hospital at (${x.toFixed(1)}, ${z.toFixed(1)})`);
      }
      
      console.log(`Spawned ${playgroundCount} playgrounds, ${parkingLotCount} parking lots, ${garageCount} parking garages, ${hospitalCount} hospitals`);
    }
    
    function spawnPedestrians(count = 50) { // Reduced from 100 for performance
      console.log(`Spawning ${count} pedestrians...`);
      
      for (let i = 0; i < count; i++) {
        const angle = (i / count) * Math.PI * 2;
        const radius = 15 + Math.random() * 35; // Reduced spawn radius
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        
        // Mix of adults and children, male and female
        const isChild = Math.random() < 0.15; // 15% children
        const isFemale = Math.random() > 0.5;
        
        const charData = generateCharacterData(isFemale, isChild, '0,0');
        createPedestrian(x, z, { isChild, isFemale, charData, chunkKey: '0,0' });
      }
      
      // Generate relationships and assign homes/workplaces
      console.log('Generating marriages...');
      generateMarriages();
      
      console.log('Assigning homes and workplaces...');
      assignHomesAndWorkplaces();
      
      // Generate daily routines for all
      console.log('Generating daily routines...');
      pedestrianDatabase.forEach(charData => {
        generateDailyRoutine(charData);
      });
      
      console.log(`Spawned ${count} pedestrians with ${pedestrianDatabase.size} character profiles`);
    }
    
    function updatePedestrians(deltaTime) {
      if (!playerBody) return;
      
      const playerPos = playerBody.translation();
      const maxDistance = 100; // Reduced from 150m for performance
      const maxDistanceSq = maxDistance * maxDistance;
      const closeDistance = 30; // Full animation within 30m
      const closeDistanceSq = closeDistance * closeDistance;
      
      // Only update a subset each frame for performance
      const updateChunkSize = Math.ceil(pedestrians.length / 3);
      const frameOffset = Math.floor(performance.now() / 16) % 3;
      const startIdx = frameOffset * updateChunkSize;
      const endIdx = Math.min(startIdx + updateChunkSize, pedestrians.length);
      
      for (let i = 0; i < pedestrians.length; i++) {
        const ped = pedestrians[i];
        if (!ped || !ped.group) continue;
        
        // Distance culling - hide and skip update for far pedestrians
        const distSq = Math.pow(ped.group.position.x - playerPos.x, 2) + 
                       Math.pow(ped.group.position.z - playerPos.z, 2);
        
        if (distSq > maxDistanceSq) {
          ped.group.visible = false;
          continue; // Skip update
        }
        
        ped.group.visible = true;
        
        // Only update pedestrians in current chunk OR very close pedestrians
        const shouldUpdate = (i >= startIdx && i < endIdx) || distSq < closeDistanceSq;
        
        // Update AI if not dragging and should update this frame
        if (shouldUpdate && ped.update && !ped.group.userData.isDragging) {
          ped.update(deltaTime);
        }
        
        // Disable shadows for distant pedestrians
        ped.group.traverse(obj => {
          if (obj.isMesh) {
            obj.castShadow = distSq < closeDistanceSq;
          }
        });
      }
    }
    
    // ==================== CLOUD SYSTEM ====================
    function createCloudPrototype(seed) {
      const cloudGroup = new THREE.Group();
      
      // Random cloud parameters based on seed
      const rng = () => {
        seed = (seed * 9301 + 49297) % 233280;
        return seed / 233280;
      };
      
      const puffCount = 3 + Math.floor(rng() * 5); // 3-7 puffs
      const baseScale = 8 + rng() * 6; // 8-14m scale
      
      // Cloud material - simple white diffuse
      const cloudMat = new THREE.MeshLambertMaterial({
        color: 0xFFFFFF,
        transparent: true,
        opacity: 0.85,
        fog: true
      });
      
      // Create puffs (low-poly spheres)
      for (let i = 0; i < puffCount; i++) {
        const puffGeo = new THREE.SphereGeometry(
          1 + rng() * 0.8, // Radius variation
          6, // Low-poly segments
          5
        );
        
        const puff = new THREE.Mesh(puffGeo, cloudMat);
        
        // Position puffs in cluster
        const angle = (i / puffCount) * Math.PI * 2;
        const radius = rng() * 1.5;
        puff.position.set(
          Math.cos(angle) * radius,
          (rng() - 0.5) * 0.8,
          Math.sin(angle) * radius
        );
        
        // Random scale per puff
        const puffScale = 0.7 + rng() * 0.6;
        puff.scale.set(puffScale, puffScale * 0.8, puffScale);
        
        cloudGroup.add(puff);
      }
      
      cloudGroup.scale.setScalar(baseScale);
      cloudGroup.userData.baseScale = baseScale;
      cloudGroup.userData.driftSpeed = 0.5 + rng() * 1.0; // Drift speed variation
      cloudGroup.userData.driftAngle = rng() * Math.PI * 2;
      
      return cloudGroup;
    }
    
    function generateCloudPrototypes(count = 5) {
      console.log('Generating cloud prototypes...');
      for (let i = 0; i < count; i++) {
        const proto = createCloudPrototype(i * 1000);
        cloudPrototypes.push(proto);
      }
      console.log(`Generated ${count} cloud prototypes`);
    }
    
    function spawnClouds(count = 15) {
      const cloudHeight = 80 + Math.random() * 40; // 80-120m high
      const spawnRadius = 200; // Spawn within 200m radius
      
      for (let i = 0; i < count; i++) {
        // Pick random prototype
        const proto = cloudPrototypes[Math.floor(Math.random() * cloudPrototypes.length)];
        const cloudInstance = proto.clone();
        
        // Random position
        const angle = Math.random() * Math.PI * 2;
        const radius = 50 + Math.random() * spawnRadius;
        cloudInstance.position.set(
          Math.cos(angle) * radius,
          cloudHeight + Math.random() * 20,
          Math.sin(angle) * radius
        );
        
        // Random rotation
        cloudInstance.rotation.y = Math.random() * Math.PI * 2;
        
        cloudInstance.userData.driftTime = Math.random() * 100; // Offset animation
        
        scene.add(cloudInstance);
        activeClouds.push(cloudInstance);
      }
      
      console.log(`Spawned ${count} clouds`);
    }
    
    let cloudUpdateTimer = 0;
    const CLOUD_UPDATE_INTERVAL = 0.1; // Update clouds every 100ms instead of every frame
    
    function updateClouds(deltaTime) {
      cloudUpdateTimer += deltaTime;
      if (cloudUpdateTimer < CLOUD_UPDATE_INTERVAL) return;
      
      const actualDelta = cloudUpdateTimer;
      cloudUpdateTimer = 0;
      
      // Disable shadows on all clouds for performance
      activeClouds.forEach(cloud => {
        // Slow drift
        cloud.userData.driftTime += actualDelta * cloud.userData.driftSpeed;
        const driftX = Math.cos(cloud.userData.driftAngle) * cloud.userData.driftSpeed * actualDelta;
        const driftZ = Math.sin(cloud.userData.driftAngle) * cloud.userData.driftSpeed * actualDelta;
        
        cloud.position.x += driftX;
        cloud.position.z += driftZ;
        
        // Gentle bobbing
        cloud.position.y += Math.sin(cloud.userData.driftTime) * 0.01;
        
        // Wrap clouds around - if they drift too far, teleport to opposite side
        const maxDist = 300;
        const distSq = cloud.position.x * cloud.position.x + cloud.position.z * cloud.position.z;
        if (distSq > maxDist * maxDist) {
          cloud.position.x = -cloud.position.x * 0.5;
          cloud.position.z = -cloud.position.z * 0.5;
        }
        
        // Disable shadows and receiving shadows on clouds
        cloud.traverse(obj => {
          if (obj.isMesh) {
            obj.castShadow = false;
            obj.receiveShadow = false;
          }
        });
      });
    }
    
    // ==================== PORTALS ====================
    function createPortalPair() {
      const portalGeometry = new THREE.RingGeometry(1.8, 2.2, 48);
      const portalInnerGeo = new THREE.CircleGeometry(1.8, 48);
      
      // Portal A (Cyan)
      const portal1Group = new THREE.Group();
      const portal1Ring = new THREE.Mesh(portalGeometry, new THREE.MeshBasicMaterial({ 
        color: 0x00ffff,
        side: THREE.DoubleSide
      }));
      const portal1Inner = new THREE.Mesh(portalInnerGeo, new THREE.MeshBasicMaterial({ 
        color: 0x00ffff,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide
      }));
      portal1Group.add(portal1Ring);
      portal1Group.add(portal1Inner);
      portal1Group.position.set(-25, 3, 0);
      portal1Group.rotation.y = Math.PI / 2;
      worldRoot.add(portal1Group);
      
      // Portal B (Magenta)
      const portal2Group = new THREE.Group();
      const portal2Ring = new THREE.Mesh(portalGeometry, new THREE.MeshBasicMaterial({ 
        color: 0xff00ff,
        side: THREE.DoubleSide
      }));
      const portal2Inner = new THREE.Mesh(portalInnerGeo, new THREE.MeshBasicMaterial({ 
        color: 0xff00ff,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide
      }));
      portal2Group.add(portal2Ring);
      portal2Group.add(portal2Inner);
      portal2Group.position.set(25, 3, 0);
      portal2Group.rotation.y = -Math.PI / 2;
      worldRoot.add(portal2Group);
      
      portals.push({ a: portal1Group, b: portal2Group, scale: 1.0, radius: 1.8 });
    }
    
    // ==================== VIEWPORT SYSTEM ====================
    function ensureHeldViewport() {
      if (heldViewport) return;
      
      const group = new THREE.Group();
      const w = 1.2, h = 0.7;
      
      // Transparent plane
      const planeGeo = new THREE.PlaneGeometry(w, h);
      const planeMat = new THREE.MeshBasicMaterial({ 
        color: 0x000000, 
        opacity: 0.12, 
        transparent: true 
      });
      const plane = new THREE.Mesh(planeGeo, planeMat);
      group.add(plane);
      
      // Frame bars
      const t = 0.03;
      const barMat = new THREE.MeshStandardMaterial({ 
        color: 0x6a9cff, 
        metalness: 0.2, 
        roughness: 0.5,
        emissive: 0x4a7cff,
        emissiveIntensity: 0.2
      });
      
      const topBar = new THREE.Mesh(new THREE.BoxGeometry(w, t, t), barMat);
      topBar.position.set(0, h/2 + t/2, 0);
      const botBar = new THREE.Mesh(new THREE.BoxGeometry(w, t, t), barMat);
      botBar.position.set(0, -h/2 - t/2, 0);
      const leftBar = new THREE.Mesh(new THREE.BoxGeometry(t, h + 2*t, t), barMat);
      leftBar.position.set(-w/2 - t/2, 0, 0);
      const rightBar = new THREE.Mesh(new THREE.BoxGeometry(t, h + 2*t, t), barMat);
      rightBar.position.set(w/2 + t/2, 0, 0);
      
      [topBar, botBar, leftBar, rightBar].forEach(b => {
        b.castShadow = false;
        b.receiveShadow = false;
        group.add(b);
      });
      
      group.userData.width = w;
      group.userData.height = h;
      group.userData.plane = plane;
      group.visible = false;
      
      heldViewport = group;
      scene.add(heldViewport);
    }
    
    function toggleViewportFrame() {
      viewportEquipped = !viewportEquipped;
      document.getElementById('viewport-frame').classList.toggle('active', viewportEquipped);
      document.getElementById('viewport-panel').classList.toggle('active', viewportEquipped);
      
      ensureHeldViewport();
      if (heldViewport) {
        heldViewport.visible = viewportEquipped;
      }
      
      if (!viewportEquipped) {
        pluckMode = false;
        document.getElementById('toggle-pluck').classList.remove('active');
      }
    }
    
    function updatePluckCandidates() {
      pluckCandidates.forEach(obj => {
        obj.traverse(node => {
          if (node.isMesh && node.material && node.userData._originalColor) {
            node.material.color.copy(node.userData._originalColor);
            node.material.emissiveIntensity = node.userData._originalEmissive || 0;
            delete node.userData._originalColor;
            delete node.userData._originalEmissive;
          }
        });
      });
      pluckCandidates.clear();
      
      if (!viewportEquipped || !pluckMode) return;
      
      // Check which objects are fully within viewport frame
      const vpRect = document.getElementById('viewport-frame').getBoundingClientRect();
      
      // Add buildings
      buildings.forEach(b => {
        if (isObjectInViewport(b.mesh, vpRect)) {
          pluckCandidates.add(b.mesh);
          b.mesh.traverse(node => {
            if (node.isMesh && node.material && node.material.color) {
              node.userData._originalColor = node.material.color.clone();
              node.userData._originalEmissive = node.material.emissiveIntensity || 0;
              node.material.color.lerp(new THREE.Color(0xffeb3b), 0.3);
              node.material.emissiveIntensity = 0.2;
            }
          });
        }
      });
      
      // Add world objects (spawned physics objects)
      worldObjects.forEach(wo => {
        if (isObjectInViewport(wo.mesh, vpRect)) {
          pluckCandidates.add(wo.mesh);
          wo.mesh.traverse(node => {
            if (node.isMesh && node.material && node.material.color) {
              node.userData._originalColor = node.material.color.clone();
              node.userData._originalEmissive = node.material.emissiveIntensity || 0;
              node.material.color.lerp(new THREE.Color(0xffeb3b), 0.3);
              node.material.emissiveIntensity = 0.2;
            }
          });
        }
      });
      
      // Add pedestrians
      pedestrians.forEach(ped => {
        if (ped && ped.group && isObjectInViewport(ped.group, vpRect)) {
          pluckCandidates.add(ped.group);
          ped.group.traverse(node => {
            if (node.isMesh && node.material && node.material.color) {
              node.userData._originalColor = node.material.color.clone();
              node.userData._originalEmissive = node.material.emissiveIntensity || 0;
              node.material.color.lerp(new THREE.Color(0xffeb3b), 0.3);
              node.material.emissiveIntensity = 0.2;
            }
          });
        }
      });
    }
    
    function isObjectInViewport(obj, rect) {
      const box = new THREE.Box3().setFromObject(obj);
      const corners = [
        new THREE.Vector3(box.min.x, box.min.y, box.min.z),
        new THREE.Vector3(box.min.x, box.min.y, box.max.z),
        new THREE.Vector3(box.min.x, box.max.y, box.min.z),
        new THREE.Vector3(box.min.x, box.max.y, box.max.z),
        new THREE.Vector3(box.max.x, box.min.y, box.min.z),
        new THREE.Vector3(box.max.x, box.min.y, box.max.z),
        new THREE.Vector3(box.max.x, box.max.y, box.min.z),
        new THREE.Vector3(box.max.x, box.max.y, box.max.z)
      ];
      
      for (const corner of corners) {
        const projected = corner.clone().project(camera);
        const x = (projected.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-projected.y * 0.5 + 0.5) * window.innerHeight;
        
        if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {
          return false;
        }
      }
      return true;
    }
    
    function dropViewportSnapshot() {
      if (!droppedViewportRT) {
        droppedViewportRT = new THREE.WebGLRenderTarget(512, 288, { depthBuffer: true });
      }
      if (!droppedViewportCam) {
        droppedViewportCam = new THREE.PerspectiveCamera(camera.fov, 512/288, 0.05, 500);
      }
      
      // Capture current view
      droppedViewportCam.position.copy(camera.position);
      droppedViewportCam.quaternion.copy(camera.quaternion);
      
      if (!droppedViewport) {
        const group = new THREE.Group();
        const w = 1.6, h = 0.9;
        
        const planeMat = new THREE.MeshBasicMaterial({ 
          map: droppedViewportRT.texture,
          toneMapped: false
        });
        const planeGeo = new THREE.PlaneGeometry(w, h);
        const plane = new THREE.Mesh(planeGeo, planeMat);
        group.add(plane);
        
        // Frame
        const t = 0.04;
        const barMat = new THREE.MeshStandardMaterial({ 
          color: 0x6a9cff, 
          metalness: 0.2, 
          roughness: 0.5 
        });
        
        const topBar = new THREE.Mesh(new THREE.BoxGeometry(w, t, t), barMat);
        topBar.position.set(0, h/2 + t/2, 0);
        const botBar = new THREE.Mesh(new THREE.BoxGeometry(w, t, t), barMat);
        botBar.position.set(0, -h/2 - t/2, 0);
        const leftBar = new THREE.Mesh(new THREE.BoxGeometry(t, h + 2*t, t), barMat);
        leftBar.position.set(-w/2 - t/2, 0, 0);
        const rightBar = new THREE.Mesh(new THREE.BoxGeometry(t, h + 2*t, t), barMat);
        rightBar.position.set(w/2 + t/2, 0, 0);
        
        [topBar, botBar, leftBar, rightBar].forEach(b => group.add(b));
        
        group.userData.width = w;
        group.userData.height = h;
        group.userData.plane = plane;
        
        droppedViewport = group;
        worldRoot.add(droppedViewport);
      }
      
      // Position in front of camera
      const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
      droppedViewport.position.copy(camera.position).addScaledVector(forward, 2.5);
      droppedViewport.quaternion.copy(camera.quaternion);
      
      droppedViewportData = {
        dist0: 2.5,
        scale0: playerScale,
        normal: forward.clone()
      };
      
      document.getElementById('hud-mini').classList.add('active');
    }
    
    function retractViewportSnapshot() {
      if (droppedViewport) {
        worldRoot.remove(droppedViewport);
        droppedViewport = null;
        droppedViewportData = null;
      }
      document.getElementById('hud-mini').classList.remove('active');
    }
    
    // ==================== OBJECT PICKING & MANIPULATION ====================
    function clientToFrameLocal(frame, clientX, clientY) {
      if (!frame) return null;
      
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      
      const n = new THREE.Vector3(0, 0, 1).applyQuaternion(frame.quaternion);
      const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(n, frame.position);
      const hit = new THREE.Vector3();
      
      if (!raycaster.ray.intersectPlane(plane, hit)) return null;
      
      const inv = new THREE.Matrix4().copy(frame.matrixWorld).invert();
      const local = hit.clone().applyMatrix4(inv);
      
      const w = frame.userData.width || 1.2;
      const h = frame.userData.height || 0.7;
      local.x = THREE.MathUtils.clamp(local.x, -w/2, w/2);
      local.y = THREE.MathUtils.clamp(local.y, -h/2, h/2);
      local.z = 0;
      
      return local;
    }
    
    function selectPluckAt(clientX, clientY) {
      if (pluckCandidates.size === 0) return null;
      
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      
      // Find all meshes in candidates
      const candidateMeshes = [];
      pluckCandidates.forEach(obj => {
        obj.traverse(node => {
          if (node.isMesh) {
            candidateMeshes.push(node);
            // Store reference to parent
            node.userData._pluckParent = obj;
          }
        });
      });
      
      const hits = raycaster.intersectObjects(candidateMeshes, true);
      
      if (hits.length === 0) return null;
      
      // Return the first hit's parent candidate
      const firstHit = hits[0];
      const parent = firstHit.object.userData._pluckParent;
      
      if (parent) {
        return { object: parent, hit: firstHit };
      }
      
      return null;
    }
    
    function startDraggingObject(obj, clientX, clientY) {
      console.log('Starting drag on object:', obj);
      
      const camPos = new THREE.Vector3();
      camera.getWorldPosition(camPos);
      
      const objPos = new THREE.Vector3();
      obj.getWorldPosition(objPos);
      
      const activeFrame = heldViewport && heldViewport.visible ? heldViewport : droppedViewport;
      
      if (activeFrame) {
        // Position relative to frame
        draggingFrame = activeFrame;
        const local = clientToFrameLocal(activeFrame, clientX, clientY);
        
        if (local) {
          const worldOnPlane = local.clone().applyMatrix4(activeFrame.matrixWorld);
          const n = new THREE.Vector3(0, 0, 1).applyQuaternion(activeFrame.quaternion);
          
          // Calculate offset from plane
          const toObj = new THREE.Vector3().subVectors(objPos, worldOnPlane);
          const offsetDist = toObj.dot(n);
          
          draggingObject = {
            obj,
            frame: activeFrame,
            offset: Math.max(0.5, Math.abs(offsetDist))  // Minimum 0.5m offset
          };
          
          console.log('Frame drag mode, offset:', draggingObject.offset);
        }
      } else {
        // Free drag at fixed depth
        dragDepth = Math.max(5.0, camPos.distanceTo(objPos));  // Minimum 5m depth
        draggingObject = {
          obj,
          frame: null,
          offset: 0
        };
        
        console.log('Free drag mode, depth:', dragDepth);
      }
      
      // Suppress physics for this object
      suppressedPhysics.add(obj);
      
      // Mark object as being dragged (stops AI/updates for pedestrians, benches, etc.)
      obj.userData.isDragging = true;
      
      // Find and suppress physics body from worldObjects
      const worldObj = worldObjects.find(wo => wo.mesh === obj);
      if (worldObj && worldObj.body) {
        // Make kinematic while dragging
        worldObj.body.setBodyType(physics.RigidBodyType.KinematicPositionBased, true);
        console.log('Made world object kinematic');
      }
      
      // Find if this is a building and convert to dynamic
      const building = buildings.find(b => b.mesh === obj);
      if (building && building.body) {
        console.log('Converting building to dynamic');
        
        // Remove old static body
        world.removeRigidBody(building.body);
        
        // Create new dynamic body
        const bodyDesc = physics.RigidBodyDesc.dynamic()
          .setTranslation(objPos.x, objPos.y, objPos.z)
          .setLinearDamping(2.0)
          .setAngularDamping(5.0);
        
        const newBody = world.createRigidBody(bodyDesc);
        
        // Add collider (approximate with box)
        const colliderDesc = physics.ColliderDesc.cuboid(
          building.width / 2,
          building.height / 2,
          building.depth / 2
        );
        world.createCollider(colliderDesc, newBody);
        
        // Make kinematic while dragging
        newBody.setBodyType(physics.RigidBodyType.KinematicPositionBased, true);
        
        building.body = newBody;
        building.isDynamic = true;
        
        console.log('Building is now dynamic and kinematic');
      }
      
      // Remove from pluck candidates to avoid re-highlighting
      pluckCandidates.delete(obj);
    }
    
    function updateDraggingObject(clientX, clientY) {
      if (!draggingObject) return;
      
      const obj = draggingObject.obj;
      const frame = draggingObject.frame;
      
      let targetPos;
      
      if (frame) {
        // Drag in front of frame
        const local = clientToFrameLocal(frame, clientX, clientY);
        if (local) {
          const worldOnPlane = local.clone().applyMatrix4(frame.matrixWorld);
          const n = new THREE.Vector3(0, 0, 1).applyQuaternion(frame.quaternion);
          targetPos = worldOnPlane.clone().addScaledVector(n, draggingObject.offset);
        }
      } else {
        // Free drag at depth
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        
        targetPos = raycaster.ray.origin.clone()
          .addScaledVector(raycaster.ray.direction, dragDepth);
      }
      
      if (targetPos) {
        // Direct movement for better responsiveness
        obj.position.copy(targetPos);
        
        // Update physics body if exists (keep in sync with mesh during drag)
        const worldObj = worldObjects.find(wo => wo.mesh === obj);
        if (worldObj && worldObj.body) {
          worldObj.body.setTranslation({ x: targetPos.x, y: targetPos.y, z: targetPos.z }, true);
          // Zero out velocity while dragging
          worldObj.body.setLinvel({ x: 0, y: 0, z: 0 }, true);
          worldObj.body.setAngvel({ x: 0, y: 0, z: 0 }, true);
        }
        
        // Update building physics body
        const building = buildings.find(b => b.mesh === obj);
        if (building && building.body && building.isDynamic) {
          building.body.setTranslation({ x: targetPos.x, y: targetPos.y, z: targetPos.z }, true);
          // Zero out velocity while dragging
          building.body.setLinvel({ x: 0, y: 0, z: 0 }, true);
          building.body.setAngvel({ x: 0, y: 0, z: 0 }, true);
        }
      }
    }
    
    function stopDraggingObject() {
      if (!draggingObject) return;
      
      const obj = draggingObject.obj;
      
      // Get final position from mesh
      const finalPos = obj.getWorldPosition(new THREE.Vector3());
      
      // Restore physics
      suppressedPhysics.delete(obj);
      
      // Restore world object physics
      const worldObj = worldObjects.find(wo => wo.mesh === obj);
      if (worldObj && worldObj.body) {
        // First zero out all velocities while still kinematic
        worldObj.body.setLinvel({ x: 0, y: 0, z: 0 }, true);
        worldObj.body.setAngvel({ x: 0, y: 0, z: 0 }, true);
        
        // Update position
        worldObj.body.setTranslation({ x: finalPos.x, y: finalPos.y, z: finalPos.z }, true);
        
        // Set higher damping for dropped objects
        worldObj.body.setLinearDamping(5.0);
        worldObj.body.setAngularDamping(10.0);
        
        // Switch to dynamic
        worldObj.body.setBodyType(physics.RigidBodyType.Dynamic, true);
        
        // Zero velocities again after type change
        worldObj.body.setLinvel({ x: 0, y: 0, z: 0 }, true);
        worldObj.body.setAngvel({ x: 0, y: 0, z: 0 }, true);
        
        console.log('Released object at:', finalPos);
      }
      
      // Restore building physics
      const building = buildings.find(b => b.mesh === obj);
      if (building && building.body && building.isDynamic) {
        // First zero out all velocities while still kinematic
        building.body.setLinvel({ x: 0, y: 0, z: 0 }, true);
        building.body.setAngvel({ x: 0, y: 0, z: 0 }, true);
        
        // Update position
        building.body.setTranslation({ x: finalPos.x, y: finalPos.y, z: finalPos.z }, true);
        
        // Building damping already set to 2.0/5.0 during creation, which is good
        
        // Switch to dynamic
        building.body.setBodyType(physics.RigidBodyType.Dynamic, true);
        
        // Zero velocities again after type change
        building.body.setLinvel({ x: 0, y: 0, z: 0 }, true);
        building.body.setAngvel({ x: 0, y: 0, z: 0 }, true);
        
        console.log('Released building at:', finalPos);
      }
      
      // For objects without physics (pedestrians, benches, etc.), they stay where they are
      // Keep isDragging flag set so they don't resume AI movement
      // They will remain static at their dropped position
      
      console.log('Released object (type:', obj.userData.objectType, '), isDragging:', obj.userData.isDragging);
      
      draggingObject = null;
      draggingFrame = null;
    }
    
    function highlightObject(obj, highlight) {
      obj.traverse(node => {
        if (node.isMesh && node.material) {
          if (highlight) {
            if (!node.userData._originalColor) {
              node.userData._originalColor = node.material.color.clone();
              node.userData._originalEmissive = node.material.emissive ? node.material.emissive.clone() : new THREE.Color(0);
              node.userData._originalEmissiveIntensity = node.material.emissiveIntensity || 0;
            }
            node.material.color.lerp(new THREE.Color(0xffeb3b), 0.4);
            if (node.material.emissive) {
              node.material.emissive.set(0xffaa00);
              node.material.emissiveIntensity = 0.3;
            }
          } else {
            if (node.userData._originalColor) {
              node.material.color.copy(node.userData._originalColor);
              if (node.material.emissive && node.userData._originalEmissive) {
                node.material.emissive.copy(node.userData._originalEmissive);
              }
              node.material.emissiveIntensity = node.userData._originalEmissiveIntensity || 0;
              delete node.userData._originalColor;
              delete node.userData._originalEmissive;
              delete node.userData._originalEmissiveIntensity;
            }
          }
        }
      });
    }
    
    let hoveredObject = null;
    let hoverCheckThrottle = 0;
    
    function updateHoverHighlight(clientX, clientY) {
      if (!viewportEquipped || !pluckMode) {
        if (hoveredObject) {
          highlightObject(hoveredObject, false);
          hoveredObject = null;
        }
        return;
      }
      
      // Throttle hover checks to every 100ms
      const now = performance.now();
      if (now - hoverCheckThrottle < 100) return;
      hoverCheckThrottle = now;
      
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      
      // Check all pluckable objects (use cached meshes)
      let newHovered = null;
      let closestDist = Infinity;
      
      pluckCandidates.forEach(candidate => {
        if (!candidate.userData._cachedMeshes) {
          candidate.userData._cachedMeshes = [];
          candidate.traverse(node => {
            if (node.isMesh) candidate.userData._cachedMeshes.push(node);
          });
        }
        
        const hits = raycaster.intersectObjects(candidate.userData._cachedMeshes, false);
        if (hits.length > 0 && hits[0].distance < closestDist) {
          closestDist = hits[0].distance;
          newHovered = candidate;
        }
      });
      
      if (newHovered !== hoveredObject) {
        if (hoveredObject) {
          highlightObject(hoveredObject, false);
        }
        if (newHovered) {
          highlightObject(newHovered, true);
          
          // Show tooltip
          const tooltip = document.getElementById('tooltip');
          tooltip.textContent = 'Click to grab';
          tooltip.style.left = clientX + 'px';
          tooltip.style.top = clientY + 'px';
          tooltip.style.display = 'block';
        } else {
          document.getElementById('tooltip').style.display = 'none';
        }
        hoveredObject = newHovered;
      }
    }
    
    // ==================== INTERIORS SYSTEM ====================
    // Complete integration of the interiors system from interiors.html
    
    let interiorsMode = false;
    let savedCityObjects = null;
    let savedPlayerChunk = null;
    let interiorsGroup = new THREE.Group();
    let interiorRoomObjects = [];
    let interiorInteractiveObjects = [];
    const INTERIORS_GRID_SIZE = 0.6;
    const INTERIORS_WALL_HEIGHT = 2.5;
    const INTERIORS_WALL_THICKNESS = 0.1;
    
    // Room configurations with proper shower/bathroom floor placement
    const INTERIORS_ROOM_CONFIGS = {
      studio: {
        name: 'Studio Apartment',
        mainRoom: 'studio',
        floorBounds: { minX: -6, maxX: 6, minZ: -6, maxZ: 6 },
        bathroom: { x: 4.5, z: -2.5, width: 2.4, depth: 5 },
        walls: [
          { x: -6, z: -6, dir: 'h', length: 12 },
          { x: -6, z: 6, dir: 'h', length: 12 },
          { x: -6, z: -6, dir: 'v', length: 12 },
          { x: 6, z: -6, dir: 'v', length: 12 },
          { x: 3, z: -6, dir: 'v', length: 5 },
          { x: 3, z: -1, dir: 'h', length: 3, hasDoor: true },
          { x: 6, z: -1, dir: 'v', length: 3 }
        ],
        furniture: [
          { type: 'toilet', x: 4.5, z: -4.5, rotation: 0 },
          { type: 'shower', x: 4.5, z: -0.8, rotation: 0 },
          { type: 'couch', x: -2, z: 0, rotation: Math.PI },
          { type: 'plant', x: -4, z: 2, rotation: 0 },
        ]
      }
    };
    
    function toggleInteriorsMode() {
      interiorsMode = !interiorsMode;
      
      if (interiorsMode) {
        console.log('Entering interiors mode...');
        
        // Save player chunk location
        if (playerBody) {
          const pos = playerBody.translation();
          savedPlayerChunk = { x: pos.x, y: pos.y, z: pos.z };
        }
        
        // Hide city (keep current chunk only)
        if (worldRoot) {
          worldRoot.visible = false;
        }
        
        // Generate interior room
        scene.add(interiorsGroup);
        generateInteriorRoom('studio');
        
        // Move player into room
        if (playerBody) {
          playerBody.setTranslation({ x: 0, y: 1.7, z: 0 }, true);
          playerBody.setLinvel({ x: 0, y: 0, z: 0 }, true);
        }
        
        console.log('Entered interiors mode');
      } else {
        console.log('Exiting interiors mode...');
        
        // Clear interior
        clearInteriorRoom();
        scene.remove(interiorsGroup);
        
        // Restore city
        if (worldRoot) {
          worldRoot.visible = true;
        }
        
        // Restore player position
        if (playerBody && savedPlayerChunk) {
          playerBody.setTranslation(savedPlayerChunk, true);
        }
        
        console.log('Exited interiors mode');
      }
    }
    
    function generateInteriorRoom(roomType) {
      const config = INTERIORS_ROOM_CONFIGS[roomType];
      if (!config) return;
      
      // Generate floor
      const floorGeo = new THREE.PlaneGeometry(
        (config.floorBounds.maxX - config.floorBounds.minX) * INTERIORS_GRID_SIZE,
        (config.floorBounds.maxZ - config.floorBounds.minZ) * INTERIORS_GRID_SIZE
      );
      const floorMat = new THREE.MeshStandardMaterial({ color: 0xccaa88, roughness: 0.9 });
      const floor = new THREE.Mesh(floorGeo, floorMat);
      floor.rotation.x = -Math.PI / 2;
      floor.receiveShadow = true;
      interiorsGroup.add(floor);
      
      // Generate bathroom floor if defined
      if (config.bathroom) {
        const bath = config.bathroom;
        const bathFloorGeo = new THREE.PlaneGeometry(bath.width, bath.depth);
        
        // Create checkered pattern for bathroom
        const canvas = document.createElement('canvas');
        canvas.width = 128;
        canvas.height = 128;
        const ctx = canvas.getContext('2d');
        const tileSize = 16;
        for (let y = 0; y < 128; y += tileSize) {
          for (let x = 0; x < 128; x += tileSize) {
            const isWhite = ((x / tileSize) + (y / tileSize)) % 2 === 0;
            ctx.fillStyle = isWhite ? '#ffffff' : '#4488ff';
            ctx.fillRect(x, y, tileSize, tileSize);
          }
        }
        const bathTexture = new THREE.CanvasTexture(canvas);
        bathTexture.repeat.set(4, 4);
        bathTexture.wrapS = bathTexture.wrapT = THREE.RepeatWrapping;
        
        const bathFloorMat = new THREE.MeshStandardMaterial({ map: bathTexture, roughness: 0.3 });
        const bathFloor = new THREE.Mesh(bathFloorGeo, bathFloorMat);
        bathFloor.rotation.x = -Math.PI / 2;
        bathFloor.position.set(bath.x * INTERIORS_GRID_SIZE, 0.01, bath.z * INTERIORS_GRID_SIZE);
        bathFloor.receiveShadow = true;
        interiorsGroup.add(bathFloor);
      }
      
      // Generate walls
      config.walls.forEach(wallSpec => {
        const wall = createInteriorWall(wallSpec);
        if (wall) interiorsGroup.add(wall);
      });
      
      // Generate furniture
      config.furniture.forEach(item => {
        const furniture = createInteriorFurniture(item);
        if (furniture) {
          interiorRoomObjects.push(furniture);
          interiorsGroup.add(furniture);
        }
      });
      
      // Add lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
      interiorsGroup.add(ambientLight);
      
      const pointLight = new THREE.PointLight(0xffffff, 1.0, 20);
      pointLight.position.set(0, 2.0, 0);
      pointLight.castShadow = true;
      interiorsGroup.add(pointLight);
    }
    
    function createInteriorWall(spec) {
      const group = new THREE.Group();
      
      const length = spec.length * INTERIORS_GRID_SIZE;
      const isHorizontal = spec.dir === 'h';
      
      if (spec.hasDoor) {
        // Wall with door opening
        const doorWidth = 0.9;
        const segment1Len = (length - doorWidth) / 2;
        
        if (segment1Len > 0.05) {
          const wallGeo1 = new THREE.BoxGeometry(
            isHorizontal ? segment1Len : INTERIORS_WALL_THICKNESS,
            INTERIORS_WALL_HEIGHT,
            isHorizontal ? INTERIORS_WALL_THICKNESS : segment1Len
          );
          const wallMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.8 });
          const wall1 = new THREE.Mesh(wallGeo1, wallMat);
          wall1.castShadow = true;
          wall1.receiveShadow = true;
          
          const wall2 = wall1.clone();
          
          if (isHorizontal) {
            wall1.position.set(spec.x * INTERIORS_GRID_SIZE + segment1Len / 2, INTERIORS_WALL_HEIGHT / 2, spec.z * INTERIORS_GRID_SIZE);
            wall2.position.set(spec.x * INTERIORS_GRID_SIZE + segment1Len + doorWidth + segment1Len / 2, INTERIORS_WALL_HEIGHT / 2, spec.z * INTERIORS_GRID_SIZE);
          } else {
            wall1.position.set(spec.x * INTERIORS_GRID_SIZE, INTERIORS_WALL_HEIGHT / 2, spec.z * INTERIORS_GRID_SIZE + segment1Len / 2);
            wall2.position.set(spec.x * INTERIORS_GRID_SIZE, INTERIORS_WALL_HEIGHT / 2, spec.z * INTERIORS_GRID_SIZE + segment1Len + doorWidth + segment1Len / 2);
          }
          
          group.add(wall1);
          group.add(wall2);
        }
      } else {
        // Solid wall
        const wallGeo = new THREE.BoxGeometry(
          isHorizontal ? length : INTERIORS_WALL_THICKNESS,
          INTERIORS_WALL_HEIGHT,
          isHorizontal ? INTERIORS_WALL_THICKNESS : length
        );
        const wallMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.8 });
        const wall = new THREE.Mesh(wallGeo, wallMat);
        wall.position.set(
          spec.x * INTERIORS_GRID_SIZE + (isHorizontal ? length / 2 : 0),
          INTERIORS_WALL_HEIGHT / 2,
          spec.z * INTERIORS_GRID_SIZE + (isHorizontal ? 0 : length / 2)
        );
        wall.castShadow = true;
        wall.receiveShadow = true;
        group.add(wall);
      }
      
      return group;
    }
    
    function createInteriorFurniture(spec) {
      const group = new THREE.Group();
      
      if (spec.type === 'toilet') {
        // Simple toilet geometry
        const bowlGeo = new THREE.SphereGeometry(0.22, 16, 16, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2);
        const bowlMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2 });
        const bowl = new THREE.Mesh(bowlGeo, bowlMat);
        bowl.position.y = 0.35;
        bowl.castShadow = true;
        group.add(bowl);
        
        const tankGeo = new THREE.BoxGeometry(0.4, 0.35, 0.15);
        const tank = new THREE.Mesh(tankGeo, bowlMat);
        tank.position.set(0, 0.525, 0.2);
        tank.castShadow = true;
        group.add(tank);
        
      } else if (spec.type === 'shower') {
        // Shower with white micro-tiling floor
        const showerGroup = new THREE.Group();
        
        // Shower floor (white micro-tiles)
        const tileSize = 0.05;
        const tilesX = Math.floor(1 / tileSize);
        const tilesZ = Math.floor(1 / tileSize);
        
        for (let i = 0; i < tilesX; i++) {
          for (let j = 0; j < tilesZ; j++) {
            const tileGeo = new THREE.BoxGeometry(tileSize * 0.98, 0.01, tileSize * 0.98);
            const tileMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
            const tile = new THREE.Mesh(tileGeo, tileMat);
            tile.position.set(
              -0.5 + i * tileSize + tileSize / 2,
              0.005,
              -0.5 + j * tileSize + tileSize / 2
            );
            tile.receiveShadow = true;
            showerGroup.add(tile);
          }
        }
        
        // Shower walls
        const wallGeo = new THREE.BoxGeometry(1, 2, 0.05);
        const wallMat = new THREE.MeshStandardMaterial({ color: 0xe8e8e8, transparent: true, opacity: 0.7 });
        const wall1 = new THREE.Mesh(wallGeo, wallMat);
        wall1.position.set(0, 1, -0.5);
        wall1.castShadow = true;
        showerGroup.add(wall1);
        
        const wall2 = wall1.clone();
        wall2.position.set(-0.5, 1, 0);
        wall2.rotation.y = Math.PI / 2;
        showerGroup.add(wall2);
        
        const wall3 = wall1.clone();
        wall3.position.set(0.5, 1, 0);
        wall3.rotation.y = Math.PI / 2;
        showerGroup.add(wall3);
        
        // Shower head
        const headGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.1, 8);
        const headMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.8 });
        const head = new THREE.Mesh(headGeo, headMat);
        head.position.set(0, 2, -0.4);
        head.rotation.x = Math.PI / 2;
        showerGroup.add(head);
        
        group.add(showerGroup);
        
      } else if (spec.type === 'couch') {
        // Simple couch
        const baseGeo = new THREE.BoxGeometry(1.5, 0.4, 0.8);
        const baseMat = new THREE.MeshStandardMaterial({ color: 0x666699, roughness: 0.8 });
        const base = new THREE.Mesh(baseGeo, baseMat);
        base.position.y = 0.4;
        base.castShadow = true;
        group.add(base);
        
        const backGeo = new THREE.BoxGeometry(1.5, 0.5, 0.15);
        const back = new THREE.Mesh(backGeo, baseMat);
        back.position.set(0, 0.65, 0.4);
        back.castShadow = true;
        group.add(back);
        
      } else if (spec.type === 'plant') {
        // Simple potted plant
        const potGeo = new THREE.CylinderGeometry(0.08, 0.06, 0.12, 8);
        const potMat = new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 0.9 });
        const pot = new THREE.Mesh(potGeo, potMat);
        pot.position.y = 0.06;
        pot.castShadow = true;
        group.add(pot);
        
        const leafGeo = new THREE.SphereGeometry(0.15, 8, 8);
        const leafMat = new THREE.MeshStandardMaterial({ color: 0x2a5a2a, roughness: 0.8 });
        const leaves = new THREE.Mesh(leafGeo, leafMat);
        leaves.position.y = 0.25;
        leaves.scale.set(1, 1.5, 1);
        leaves.castShadow = true;
        group.add(leaves);
      }
      
      group.position.set(
        spec.x * INTERIORS_GRID_SIZE,
        spec.y || 0,
        spec.z * INTERIORS_GRID_SIZE
      );
      group.rotation.y = spec.rotation || 0;
      
      return group;
    }
    
    function clearInteriorRoom() {
      interiorRoomObjects.forEach(obj => {
        if (obj.geometry) obj.geometry.dispose();
        if (obj.material) {
          if (Array.isArray(obj.material)) {
            obj.material.forEach(m => m.dispose());
          } else {
            obj.material.dispose();
          }
        }
      });
      
      interiorRoomObjects = [];
      interiorInteractiveObjects = [];
      
      while (interiorsGroup.children.length > 0) {
        interiorsGroup.remove(interiorsGroup.children[0]);
      }
    }
    
    // ==================== UNIVERSAL ASSET GENERATION LIBRARY ====================
    // COMPLETE DIRECT PORT from interiors.html - ALL functions
    // Universal functions callable from sequence builder, scale-ultra, and interiors
    // Parameters: spec (object config), targetScene (THREE.Scene), targetArray (array for cleanup)
    // Returns: THREE.Group for the created object
    
    // NOTE: These use GRID_SIZE constant from interiors - adapt as needed per context
    // For now they reference global GRID_SIZE, but can be parameterized further
    
    // ==================== CONTROLS ====================
    function setupControls() {
      window.addEventListener('keydown', (e) => {
        keys.add(e.code);
        
        if (e.code === 'KeyR') resetPlayer();
        if (e.code === 'KeyV') toggleViewportFrame();
        if (e.code === 'KeyH') toggleUI();
        if (e.code === 'KeyP') togglePortals();
        if (e.code === 'KeyL') toggleLasso();
        if (e.code === 'KeyB') toggleBike();
        if (e.code === 'KeyO') toggleRocket();
        if (e.code === 'KeyI') toggleInteriorsMode();
      });
      
      window.addEventListener('keyup', (e) => {
        keys.delete(e.code);
      });
      
      // Pointer lock
      renderer.domElement.addEventListener('click', () => {
        if (!pluckMode && !blockPointerLock) {
          renderer.domElement.requestPointerLock();
        }
      });
      
      document.addEventListener('pointerlockchange', () => {
        pointerLocked = document.pointerLockElement === renderer.domElement;
      });
      
      document.addEventListener('mousemove', (e) => {
        if (pointerLocked && !draggingObject) {
          const sensitivity = 0.002;
          
          // Update rocket orbit camera if rocket is enabled
          if (rocketEnabled) {
            rocketCameraYaw -= e.movementX * sensitivity;
            rocketCameraPitch -= e.movementY * sensitivity;
            // Pitch clamping happens in updateRocket()
          } else {
            // Normal player camera
            yaw -= e.movementX * sensitivity;
            pitch -= e.movementY * sensitivity;
            pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
          }
        }
        
        // Update mouse position for raycasting
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        
        // Update dragging
        if (draggingObject) {
          updateDraggingObject(e.clientX, e.clientY);
        }
        
        // Update hover highlight
        if (pluckMode && !draggingObject) {
          updateHoverHighlight(e.clientX, e.clientY);
        }
      });
      
      // Mouse buttons
      window.addEventListener('mousedown', (e) => {
        // Bike controls take priority when bike is enabled
        if (bikeEnabled) {
          if (e.button === 1) { // M3 - Toggle autopilot/halt
            e.preventDefault();
            bikeAutoPilot = !bikeAutoPilot;
            console.log(bikeAutoPilot ? 'Bike autopilot enabled' : 'Bike halted (manual control)');
            return;
          }
          if (pointerLocked) {
            if (e.button === 0) { // M1 - Sharp LEFT turn
              sharpTurnBike('left');
              return;
            }
            if (e.button === 2) { // M2 - Sharp RIGHT turn
              e.preventDefault();
              sharpTurnBike('right');
              return;
            }
          }
        }
        
        // Lasso mode takes priority when enabled
        if (lassoEnabled && pointerLocked) {
          if (e.button === 0) { // M1 - Grappling hook
            fireGrapple();
            return;
          }
          if (e.button === 2) { // M2 - Swing rope
            e.preventDefault();
            fireSwingRope();
            return;
          }
        }
        
        if (!viewportEquipped) return;
        
        if (e.button === 1) { // Middle click - toggle pluck
          pluckMode = !pluckMode;
          document.getElementById('toggle-pluck').classList.toggle('active', pluckMode);
          updatePluckCandidates();
          
          if (pluckMode) {
            blockPointerLock = true;
            if (pointerLocked) {
              document.exitPointerLock();
              pointerLocked = false;
            }
          } else {
            // Exit pluck mode - restore first person controls
            blockPointerLock = false;
            document.getElementById('tooltip').style.display = 'none';
            if (hoveredObject) {
              highlightObject(hoveredObject, false);
              hoveredObject = null;
            }
            // Re-enable pointer lock after a short delay
            setTimeout(() => {
              if (!blockPointerLock && !pointerLocked) {
                renderer.domElement.requestPointerLock();
              }
            }, 100);
          }
        }
        
        if (e.button === 2) { // Right click - snapshot
          e.preventDefault();
          if (droppedViewport) {
            retractViewportSnapshot();
          } else {
            dropViewportSnapshot();
          }
          updatePluckCandidates();
        }
        
        if (e.button === 0) { // Left click
          if (pluckMode) {
            // Try to grab and pop object out of frame
            const selected = selectPluckAt(e.clientX, e.clientY);
            if (selected) {
              console.log('Plucking object:', selected.object);
              
              const camPos = new THREE.Vector3();
              camera.getWorldPosition(camPos);
              
              const objPos = new THREE.Vector3();
              selected.object.getWorldPosition(objPos);
              
              const distOld = camPos.distanceTo(objPos);
              const activeFrame = heldViewport && heldViewport.visible ? heldViewport : droppedViewport;
              
              // Pop object to frame immediately
              if (activeFrame) {
                const distNew = camPos.distanceTo(activeFrame.position);
                const scaleFactor = distNew / Math.max(0.001, distOld);
                
                console.log('Popping to frame:', { distOld, distNew, scaleFactor });
                
                // Scale to maintain perceived size
                const currentScale = selected.object.scale.clone();
                selected.object.scale.copy(currentScale.multiplyScalar(scaleFactor));
                
                // Pop to frame position - use camera forward direction
                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                const popOffset = heldViewportDist + 0.1; // Slightly beyond frame
                const newPos = camPos.clone().addScaledVector(forward, popOffset);
                selected.object.position.copy(newPos);
                
                // Update physics body if building
                const building = buildings.find(b => b.mesh === selected.object);
                if (building && building.body && building.isDynamic) {
                  building.body.setTranslation(newPos, true);
                }
              }
              
              // Start dragging AFTER popping
              startDraggingObject(selected.object, e.clientX, e.clientY);
              document.getElementById('tooltip').style.display = 'none';
              
            } else {
              // Lock objects in viewport (viewport lock mode with distance-based scaling)
              viewportActive = true;
              lockObjectsInViewport();
            }
          }
        }
      });
      
      window.addEventListener('mouseup', (e) => {
        // Release grapple/swing on M1 or M2 release
        if (lassoEnabled && (e.button === 0 || e.button === 2)) {
          releaseGrapple();
        }
        
        if (e.button === 0) {
          if (draggingObject) {
            stopDraggingObject();
          }
          viewportActive = false;
        }
      });
      
      window.addEventListener('contextmenu', (e) => e.preventDefault());
      
      // Scroll wheel - viewport distance, drag offset, or rocket zoom
      window.addEventListener('wheel', (e) => {
        // Rocket camera zoom (always works in rocket mode)
        if (rocketEnabled) {
          e.preventDefault();
          const zoomFactor = Math.exp(e.deltaY * 0.001);
          rocketCameraDistance = THREE.MathUtils.clamp(rocketCameraDistance * zoomFactor, 5, 50);
          return;
        }
        
        if (!viewportEquipped) return;
        
        e.preventDefault();
        const factor = Math.exp(e.deltaY * 0.0015);
        
        if (draggingObject) {
          // Adjust drag depth/offset
          if (draggingObject.frame) {
            draggingObject.offset = THREE.MathUtils.clamp(
              draggingObject.offset * factor, 
              0.05, 
              3.0
            );
            // Update position immediately
            const rect = renderer.domElement.getBoundingClientRect();
            const cx = e.clientX ?? (rect.left + rect.width / 2);
            const cy = e.clientY ?? (rect.top + rect.height / 2);
            updateDraggingObject(cx, cy);
          } else {
            dragDepth = THREE.MathUtils.clamp(dragDepth * factor, 0.5, 20.0);
          }
        } else if (heldViewport && heldViewport.visible) {
          // Adjust viewport distance
          heldViewportDist = THREE.MathUtils.clamp(heldViewportDist * factor, 0.2, 5.0);
          document.getElementById('viewport-dist-value').textContent = heldViewportDist.toFixed(1) + 'm';
        }
      }, { passive: false });
      
      window.addEventListener('resize', onWindowResize);
    }
    
    function lockObjectsInViewport() {
      viewportLocked.clear();
      const vpRect = document.getElementById('viewport-frame').getBoundingClientRect();
      const camPos = new THREE.Vector3();
      camera.getWorldPosition(camPos);
      
      // Lock buildings
      buildings.forEach(b => {
        const pos = new THREE.Vector3();
        b.mesh.getWorldPosition(pos);
        const projected = pos.clone().project(camera);
        const x = (projected.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-projected.y * 0.5 + 0.5) * window.innerHeight;
        
        if (x >= vpRect.left && x <= vpRect.right && y >= vpRect.top && y <= vpRect.bottom) {
          const dist = camPos.distanceTo(pos);
          
          b.mesh.userData.viewportLock = {
            dist0: dist,
            scale0: b.mesh.scale.clone(),
            ndc: new THREE.Vector2(projected.x, projected.y),
            quat0: b.mesh.quaternion.clone(),
            camQuat0: camera.quaternion.clone()
          };
          
          viewportLocked.add(b.mesh);
        }
      });
      
      // Lock world objects
      worldObjects.forEach(wo => {
        const pos = new THREE.Vector3();
        wo.mesh.getWorldPosition(pos);
        const projected = pos.clone().project(camera);
        const x = (projected.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-projected.y * 0.5 + 0.5) * window.innerHeight;
        
        if (x >= vpRect.left && x <= vpRect.right && y >= vpRect.top && y <= vpRect.bottom) {
          const dist = camPos.distanceTo(pos);
          
          wo.mesh.userData.viewportLock = {
            dist0: dist,
            scale0: wo.mesh.scale.clone(),
            ndc: new THREE.Vector2(projected.x, projected.y),
            quat0: wo.mesh.quaternion.clone(),
            camQuat0: camera.quaternion.clone()
          };
          
          viewportLocked.add(wo.mesh);
        }
      });
    }
    
    function setupUI() {
      // Toggle switches
      document.getElementById('toggle-shadows').addEventListener('click', (e) => {
        shadowsEnabled = e.target.classList.toggle('active');
        renderer.shadowMap.enabled = shadowsEnabled;
      });
      
      document.getElementById('toggle-fog').addEventListener('click', (e) => {
        fogEnabled = e.target.classList.toggle('active');
        scene.fog = fogEnabled ? new THREE.FogExp2(0xBBD5EA, 0.006) : null;
      });
      
      document.getElementById('toggle-postfx').addEventListener('click', (e) => {
        postFXEnabled = e.target.classList.toggle('active');
      });
      
      document.getElementById('toggle-aa').addEventListener('click', (e) => {
        aaEnabled = e.target.classList.toggle('active');
      });
      
      document.getElementById('toggle-motionblur').addEventListener('click', (e) => {
        motionBlurEnabled = e.target.classList.toggle('active');
        if (motionBlurPass) {
          motionBlurPass.enabled = motionBlurEnabled;
        }
      });
      
      document.getElementById('toggle-pluck').addEventListener('click', (e) => {
        pluckMode = e.target.classList.contains('active');
        updatePluckCandidates();
      });
      
      // FOV
      document.getElementById('fov-slider').addEventListener('input', (e) => {
        camera.fov = parseInt(e.target.value);
        camera.updateProjectionMatrix();
        document.getElementById('fov-value').textContent = camera.fov + '¬∞';
      });
      
      // Render scale
      document.getElementById('render-scale-slider').addEventListener('input', (e) => {
        const scale = parseInt(e.target.value) / 100;
        renderer.setPixelRatio(window.devicePixelRatio * scale);
        composer.setPixelRatio(window.devicePixelRatio * scale);
        document.getElementById('render-scale-value').textContent = scale.toFixed(1) + 'x';
      });
      
      // Viewport distance
      document.getElementById('viewport-dist-slider').addEventListener('input', (e) => {
        heldViewportDist = parseInt(e.target.value) / 100;
        document.getElementById('viewport-dist-value').textContent = heldViewportDist.toFixed(1) + 'm';
      });
      
      // Buttons
      document.getElementById('spawn-city').addEventListener('click', () => {
        // Initial chunk load around player
        updateChunks();
        console.log('City generation started with chunk streaming');
      });
      document.getElementById('btn-snapshot').addEventListener('click', dropViewportSnapshot);
      document.getElementById('btn-clear').addEventListener('click', retractViewportSnapshot);
      
      document.getElementById('spawn-objects').addEventListener('click', () => {
        // Spawn some physics objects for interaction
        for (let i = 0; i < 5; i++) {
          spawnPhysicsObject();
        }
      });
    }
    
    function spawnPhysicsObject() {
      const size = 0.5 + Math.random() * 1.0;
      const geometry = Math.random() < 0.5 ? 
        new THREE.BoxGeometry(size, size, size) :
        new THREE.SphereGeometry(size / 2, 16, 12);
      
      const color = new THREE.Color().setHSL(Math.random(), 0.7, 0.6);
      const material = new THREE.MeshStandardMaterial({ 
        color,
        roughness: 0.5,
        metalness: 0.3
      });
      
      const mesh = new THREE.Mesh(geometry, material);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      
      const x = (Math.random() - 0.5) * 10;
      const z = (Math.random() - 0.5) * 10;
      mesh.position.set(x, 5 + Math.random() * 3, z);
      
      worldRoot.add(mesh);
      
      // Physics body
      const bodyDesc = physics.RigidBodyDesc.dynamic()
        .setTranslation(x, 5 + Math.random() * 3, z);
      const body = world.createRigidBody(bodyDesc);
      
      const colliderDesc = geometry.type === 'BoxGeometry' ?
        physics.ColliderDesc.cuboid(size/2, size/2, size/2) :
        physics.ColliderDesc.ball(size/2);
      
      world.createCollider(colliderDesc, body);
      
      worldObjects.push({ mesh, body });
    }
    
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    }
    
     function resetPlayer() {
       playerBody.setTranslation({ x: 0, y: 5, z: 0 });
       playerBody.setLinvel({ x: 0, y: 0, z: 0 });
       playerScale = CONFIG.PLAYER_DEFAULT_SCALE;
       yaw = 0;
       pitch = 0;
     }
    
    function toggleUI() {
      document.querySelectorAll('.ui-panel').forEach(panel => {
        if (panel.id !== 'viewport-panel' || viewportEquipped) {
          panel.classList.toggle('minimized');
        }
      });
      document.getElementById('hud-mini').classList.toggle('minimized');
    }
    
    function togglePortals() {
      portals.forEach(p => {
        p.a.visible = !p.a.visible;
        p.b.visible = !p.b.visible;
      });
    }
    
    function updateStats() {
      const pos = playerBody.translation();
      const vel = playerBody.linvel();
      const speed = Math.sqrt(vel.x * vel.x + vel.z * vel.z);
      
      document.getElementById('stat-scale').textContent = playerScale.toFixed(2) + 'x';
      document.getElementById('stat-world-scale').textContent = worldScale.toFixed(2) + 'x';
      document.getElementById('stat-position').textContent = 
        `${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}`;
      document.getElementById('stat-velocity').textContent = speed.toFixed(1) + ' m/s';
      document.getElementById('stat-buildings').textContent = buildings.length;
      document.getElementById('stat-objects').textContent = worldObjects.length;
      
      frameCount++;
      const now = performance.now();
      if (now - lastFPSUpdate > 1000) {
        fpsValue = frameCount;
        document.getElementById('stat-fps').textContent = fpsValue;
        frameCount = 0;
        lastFPSUpdate = now;
      }
    }
    
      // ==================== LOD SYSTEM ====================
      const LOD_CONFIG = {
        SILL_DISTANCE: 20,  // AGGRESSIVE: Only show sills within 20m
        BUILDING_CULL_DISTANCE: 200, // Hide entire buildings beyond 200m
        UPDATE_INTERVAL: 200  // Update LOD every 200ms
      };
      let lastLODUpdate = 0;
     
     // Cache sills on first pass for faster LOD updates
     const sillCache = new Map(); // building mesh -> array of sill objects
     const lodFrustum = new THREE.Frustum();
     const lodViewProjectionMatrix = new THREE.Matrix4();
     
     function cacheBuildingSills() {
       buildings.forEach(building => {
         const sills = [];
         building.mesh.traverse(child => {
           if (child.userData.isSill && child.isMesh) {
             sills.push(child);
           }
         });
         if (sills.length > 0) {
           sillCache.set(building.mesh, sills);
         }
       });
       console.log(`Cached sills for ${sillCache.size} buildings, total ${Array.from(sillCache.values()).reduce((sum, arr) => sum + arr.length, 0)} sills`);
     }
     
       function updateLOD(time) {
        // Throttle LOD updates
        if (time - lastLODUpdate < LOD_CONFIG.UPDATE_INTERVAL) return;
        lastLODUpdate = time;
        
        // Build sill cache on first run
        if (sillCache.size === 0 && buildings.length > 0) {
          cacheBuildingSills();
        }
        
        const camPos = new THREE.Vector3();
        camera.getWorldPosition(camPos);
        
        // Update frustum for culling
        camera.updateMatrixWorld();
        lodViewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        lodFrustum.setFromProjectionMatrix(lodViewProjectionMatrix);
        
        const sillDistSq = LOD_CONFIG.SILL_DISTANCE * LOD_CONFIG.SILL_DISTANCE;
        const cullDistSq = LOD_CONFIG.BUILDING_CULL_DISTANCE * LOD_CONFIG.BUILDING_CULL_DISTANCE;
        let sillsHidden = 0;
        let sillsVisible = 0;
        let buildingsCulled = 0;
        let buildingsSkipped = 0;
        
        // AGGRESSIVE: Update building LOD with hard distance culling
        buildings.forEach(building => {
          if (!building.mesh) return;
          
          const buildingPos = new THREE.Vector3();
          building.mesh.getWorldPosition(buildingPos);
          
          // Quick distance check first
          const distSq = camPos.distanceToSquared(buildingPos);
          
          // AGGRESSIVE: Hide entire buildings beyond cull distance
          if (distSq > cullDistSq) {
            building.mesh.visible = false;
            buildingsCulled++;
            return;
          }
          
          building.mesh.visible = true;
          
          // Skip if too far for detail processing
          if (distSq > sillDistSq * 16) { // 4x sill distance for early exit
            buildingsSkipped++;
            // Still hide sills
            const sills = sillCache.get(building.mesh);
            if (sills) {
              sills.forEach(sill => {
                sill.visible = false;
                sillsHidden++;
              });
            }
            return;
          }
          
          // Frustum culling
          if (!lodFrustum.intersectsObject(building.mesh)) {
            buildingsSkipped++;
            // Hide all details for buildings not in view
            building.mesh.traverse(child => {
              if (child.userData.isSill || child.userData.isDecoration) {
                child.visible = false;
                if (child.userData.isSill) sillsHidden++;
              }
            });
            return;
          }
          
          // AGGRESSIVE: Only show sills within very close range
          const showSills = distSq < sillDistSq;
          
          // Hide ALL decorations and sills beyond sill distance
          building.mesh.traverse(child => {
            if (child.userData.isSill) {
              child.visible = showSills;
              if (showSills) sillsVisible++;
              else sillsHidden++;
            } else if (child.userData.isDecoration) {
              child.visible = showSills; // Also hide decorations
            }
          });
        });
        
        // Log stats every 3 seconds
        if (time % 3000 < LOD_CONFIG.UPDATE_INTERVAL) {
          console.log(`LOD: ${sillsVisible} sills visible, ${sillsHidden} hidden, ${buildingsCulled} buildings culled`);
        }
      }
    
    // ==================== ANIMATION LOOP ====================
    let lastTime = 0;
    
    function animate(time) {
      requestAnimationFrame(animate);
      
      const deltaTime = Math.min((time - lastTime) / 1000, 0.05);
      lastTime = time;
      
      if (deltaTime === 0) return;
      
       // Update chunk streaming
      updateChunks();
       
       // Update LOD system
       updateLOD(time);
       
       // Update doors (proximity-based opening)
       updateDoors(deltaTime);
       
       // Update grappling hook and swing rope physics
       updateGrapplePhysics(deltaTime);
       updateSwingPhysics(deltaTime);
       
       // Update grass shader time
       scene.traverse(obj => {
         if (obj.userData.isGrass && obj.userData.material) {
           obj.userData.material.uniforms.time.value = time * 0.001;
         }
       });
       
       // Physics step
       world.step();
       
       // Update rope visual
       updateRopeVisual();
       
      // Update bike
      updateBike(deltaTime);
      
      // Update rocket
      updateRocket(deltaTime);
      
      // Update day/night cycle
      currentDayTime = (currentDayTime + deltaTime) % DAY_DURATION;
      
      // Update pedestrians
      updatePedestrians(deltaTime);
       
       // Update playground spinners
       scene.traverse(obj => {
         if (obj.userData.spinner) {
           obj.userData.spinner.rotation.y += obj.userData.spinner.userData.spinSpeed * deltaTime;
         }
       });
       
       // Update clouds
       updateClouds(deltaTime);
       
       // Update motion blur
       if (motionBlurPass && motionBlurEnabled) {
         const vel = bikeEnabled && bikeBody ? bikeBody.linvel() : (playerBody ? playerBody.linvel() : { x: 0, y: 0, z: 0 });
         const speed = Math.sqrt(vel.x * vel.x + vel.y * vel.y + vel.z * vel.z);
         
         // Calculate camera rotation change
         const cameraDelta = new THREE.Vector3().subVectors(camera.position, prevCameraPosition);
         const rotationDelta = new THREE.Euler().setFromQuaternion(camera.quaternion);
         const rotationChange = Math.abs(rotationDelta.x - prevCameraRotation.x) + 
                                Math.abs(rotationDelta.y - prevCameraRotation.y);
         
         // Subtle blur from speed and camera rotation
         let blurIntensity = 0;
         if (speed > 12) {
           blurIntensity = Math.min(speed / 25, 1.5);
         }
         blurIntensity += rotationChange * 30;
         
         // Extra blur when swinging
         if (swingRope && swingRope.active) {
           blurIntensity *= 1.3;
         }
         
         // Direction of blur
         const blurDirection = new THREE.Vector2(
           (rotationDelta.y - prevCameraRotation.y) * 8,
           -(rotationDelta.x - prevCameraRotation.x) * 8
         );
         
         motionBlurPass.uniforms.velocityFactor.value = blurIntensity;
         motionBlurPass.uniforms.delta.value.copy(blurDirection);
         
         prevCameraPosition.copy(camera.position);
         prevCameraRotation.copy(rotationDelta);
       }
      
      // Player movement (skip if bike or rocket is enabled)
      if (playerBody && !bikeEnabled && !rocketEnabled) {
        const pos = playerBody.translation();
        const vel = playerBody.linvel();
        
        // Camera rotation
        const quat = new THREE.Quaternion();
        quat.setFromEuler(new THREE.Euler(pitch, yaw, 0, 'YXZ'));
        
        // Movement
        const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(quat);
        const right = new THREE.Vector3(1, 0, 0).applyQuaternion(quat);
        forward.y = 0;
        right.y = 0;
        forward.normalize();
        right.normalize();
        
        const inputVec = new THREE.Vector3();
        if (keys.has('KeyW')) inputVec.add(forward);
        if (keys.has('KeyS')) inputVec.sub(forward);
        if (keys.has('KeyD')) inputVec.add(right);
        if (keys.has('KeyA')) inputVec.sub(right);
        
        if (inputVec.length() > 0) {
          inputVec.normalize();
          const speed = CONFIG.MOVE_SPEED * 
            (keys.has('ShiftLeft') || keys.has('ShiftRight') ? CONFIG.SPRINT_MULTIPLIER : 1) * 
            playerScale;
          inputVec.multiplyScalar(speed);
          playerBody.setLinvel({ x: inputVec.x, y: vel.y, z: inputVec.z }, true);
        }
        
        // Jump
        if (keys.has('Space') && Math.abs(vel.y) < 0.1) {
          playerBody.applyImpulse({ x: 0, y: CONFIG.JUMP_FORCE * playerScale, z: 0 }, true);
          keys.delete('Space');
        }
        
        // Scale
        if (keys.has('KeyQ')) {
          playerScale = Math.min(CONFIG.PLAYER_MAX_SCALE, playerScale + CONFIG.GROW_RATE * deltaTime);
        }
        if (keys.has('KeyE')) {
          playerScale = Math.max(CONFIG.PLAYER_MIN_SCALE, playerScale - CONFIG.SHRINK_RATE * deltaTime);
        }
        
        // Update camera
        camera.position.set(
          pos.x, 
          pos.y + CONFIG.PLAYER_HEIGHT * 0.4 * playerScale, 
          pos.z
        );
        camera.quaternion.copy(quat);
        
        // Update player visual
        player.position.set(pos.x, pos.y, pos.z);
        player.scale.setScalar(playerScale);
      }
      
      // Update world objects physics (skip objects being dragged)
      worldObjects.forEach(obj => {
        if (!suppressedPhysics.has(obj.mesh)) {
          const pos = obj.body.translation();
          const rot = obj.body.rotation();
          obj.mesh.position.set(pos.x, pos.y, pos.z);
          obj.mesh.quaternion.set(rot.x, rot.y, rot.z, rot.w);
        }
      });
      
      // Update dynamic building physics
      buildings.forEach(building => {
        if (building.isDynamic && building.body && !suppressedPhysics.has(building.mesh)) {
          const pos = building.body.translation();
          const rot = building.body.rotation();
          building.mesh.position.set(pos.x, pos.y, pos.z);
          building.mesh.quaternion.set(rot.x, rot.y, rot.z, rot.w);
        }
      });
      
      // Portal teleportation
      checkPortalTeleport();
      
      // Update held viewport
      if (heldViewport && heldViewport.visible) {
        const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
        heldViewport.position.copy(camera.position).addScaledVector(forward, heldViewportDist);
        heldViewport.quaternion.copy(camera.quaternion);
      }
      
      // Update viewport locks
      if (viewportActive && viewportLocked.size > 0) {
        const camPos = new THREE.Vector3();
        camera.getWorldPosition(camPos);
        
        viewportLocked.forEach(obj => {
          const lock = obj.userData.viewportLock;
          if (!lock) return;
          
          const targetWorld = new THREE.Vector3(lock.ndc.x, lock.ndc.y, 0.5).unproject(camera);
          const dir = targetWorld.sub(camPos).normalize();
          const newWorldPos = camPos.clone().addScaledVector(dir, lock.dist0);
          
          obj.position.copy(newWorldPos);
          
          const k = lock.dist0 / Math.max(0.0001, lock.dist0);
          obj.scale.copy(lock.scale0);
        });
      }
      
      // Render dropped viewport
      if (droppedViewport && droppedViewportRT && droppedViewportCam) {
        const n = new THREE.Vector3(0, 0, -1).applyQuaternion(droppedViewport.quaternion);
        droppedViewportCam.position.copy(droppedViewport.position).addScaledVector(n, 0.05);
        droppedViewportCam.quaternion.copy(droppedViewport.quaternion);
        
        renderer.setRenderTarget(droppedViewportRT);
        renderer.render(scene, droppedViewportCam);
        renderer.setRenderTarget(null);
        
        // Copy to HUD canvas
        const canvas = document.getElementById('hud-mini-canvas');
        const ctx = canvas.getContext('2d');
        const pixels = new Uint8Array(droppedViewportRT.width * droppedViewportRT.height * 4);
        renderer.readRenderTargetPixels(droppedViewportRT, 0, 0, droppedViewportRT.width, droppedViewportRT.height, pixels);
        
        const imageData = new ImageData(new Uint8ClampedArray(pixels), droppedViewportRT.width, droppedViewportRT.height);
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = droppedViewportRT.width;
        tempCanvas.height = droppedViewportRT.height;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.putImageData(imageData, 0, 0);
        
        ctx.save();
        ctx.scale(1, -1);
        ctx.drawImage(tempCanvas, 0, -canvas.height, canvas.width, canvas.height);
        ctx.restore();
      }
      
      // Update pluck candidates only when camera moves significantly (optimization)
      // Removed from animation loop - now called only on mode toggle
      
      // Update stats
      updateStats();
      
      // Render
      if (postFXEnabled) {
        composer.render();
      } else {
        renderer.render(scene, camera);
      }
    }
    
    function checkPortalTeleport() {
      if (!playerBody || portals.length === 0) return;
      
      const pos = playerBody.translation();
      const playerPos = new THREE.Vector3(pos.x, pos.y, pos.z);
      
      portals.forEach(portalPair => {
        const distA = playerPos.distanceTo(portalPair.a.position);
        const distB = playerPos.distanceTo(portalPair.b.position);
        
        if (distA < portalPair.radius) {
          const offset = new THREE.Vector3().subVectors(playerPos, portalPair.a.position);
          const newPos = new THREE.Vector3().addVectors(portalPair.b.position, offset);
          playerBody.setTranslation(newPos, true);
          playerScale *= portalPair.scale;
        } else if (distB < portalPair.radius) {
          const offset = new THREE.Vector3().subVectors(playerPos, portalPair.b.position);
          const newPos = new THREE.Vector3().addVectors(portalPair.a.position, offset);
          playerBody.setTranslation(newPos, true);
          playerScale /= portalPair.scale;
        }
      });
    }
    
    // ==================== START ====================
    init().catch(console.error);
  </script>
</body>
</html>

