    import * as THREE from 'three';
    import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
    import RAPIER from 'https://cdn.skypack.dev/@dimforge/rapier3d-compat@0.11.2';
    
    // ==================== ASSET REGISTRY ====================
    import { getAvailableAssets, getAssetMetadata, createAsset } from '../assets/asset-registry.js';
    
    // Make asset registry functions globally available
    window.assetRegistry = {
      getAvailableAssets,
      getAssetMetadata,
      createAsset
    };

    // ==================== OPTIONAL MODULE LOADERS ====================
    let INTERIORS_GRID_SIZE;
    let INTERIORS_WALL_HEIGHT;
    let INTERIORS_WALL_THICKNESS;
    let INTERIORS_ASSETS;
    let INTERIORS_ROOM_CONFIGS;
    let furniturePropsPool;
    let miscPropsPool;
    let initInteriors;
    let onInteriorsClick;
    let clearInteriorRoom;
    let interiorRoomObjects;
    let interiorInteractiveObjects;
    let interactiveInteriorsObjects;
    let setupRandomizerButton;
    let toggleAssetMenu;
    let isAssetMenuOpen;
    let interiorsModulesPromise;

    async function ensureInteriorsModules() {
      if (interiorsModulesPromise) return interiorsModulesPromise;
      interiorsModulesPromise = Promise.all([
        import('../interiors-constants.js'),
        import('../interiors-main.js'),
        import('../interiors-ui.js')
      ]).then(([constants, main, ui]) => {
        ({
          INTERIORS_GRID_SIZE,
          INTERIORS_WALL_HEIGHT,
          INTERIORS_WALL_THICKNESS,
          INTERIORS_ASSETS,
          INTERIORS_ROOM_CONFIGS,
          furniturePropsPool,
          miscPropsPool
        } = constants);
        ({
          initInteriors,
          onInteriorsClick,
          clearInteriorRoom,
          interiorRoomObjects,
          interiorInteractiveObjects,
          interactiveInteriorsObjects
        } = main);
        ({
          setupRandomizerButton,
          toggleAssetMenu,
          isAssetMenuOpen
        } = ui);
      });
      return interiorsModulesPromise;
    }

    let postProcessingPromise;
    async function ensurePostProcessing() {
      if (postProcessingPromise) return postProcessingPromise;
      postProcessingPromise = import('./postprocessing.js').then((mod) => mod.createPostProcessing({
        THREE,
        renderer,
        scene,
        camera,
        bloomEnabled,
        bloomStrength,
        bloomRadius,
        bloomThreshold,
        ssaoEnabled,
        ssaoIntensity,
        ssaoRadius,
        dofEnabled,
        dofFocus,
        dofAperture,
        dofMaxBlur,
        filmEnabled,
        filmIntensity,
        filmGrayscale,
        vignetteEnabled,
        vignetteIntensity,
        vignetteSoftness,
        chromaticAberrationEnabled,
        chromaticAberrationAmount,
        aaEnabled,
        motionBlurEnabled
      }));
      return postProcessingPromise;
    }

    async function ensurePostProcessingReady() {
      if (composer) return;
      const postProcessing = await ensurePostProcessing();
      ({
        composer,
        bloomPass,
        ssaoPass,
        dofPass,
        filmPass,
        vignettePass,
        chromaticAberrationPass,
        smaaPass,
        motionBlurPass
      } = postProcessing);
    }

    let mapOverlayPromise;
    let mapOverlay = null;
    async function ensureMapOverlay() {
      if (mapOverlayPromise) return mapOverlayPromise;
      mapOverlayPromise = import('../map/overlay.js').then((mod) => {
        mapOverlay = mod.createMapOverlay({
          getPlayer: () => player,
          getYaw: () => yaw,
          getActiveChunks: () => activeChunks,
          getCityChunks: () => cityChunks,
          getBuildings: () => buildings,
          getVisitedBuildings: () => visitedBuildings,
          getMapScale: () => MAP_SCALE,
          getMapChunkSize: () => MAP_CHUNK_SIZE
        });
        return mapOverlay;
      });
      return mapOverlayPromise;
    }

    let rocketSubsystemPromise;
    async function ensureRocketSubsystem() {
      if (!rocketSubsystemPromise) {
        rocketSubsystemPromise = import('../vehicles/rocket-system.js');
      }
      return rocketSubsystemPromise;
    }

    async function ensureRocketAssets() {
      const { createRocket, createGiantFinger } = await ensureRocketSubsystem();
      if (!rocketMesh || !rocketBody) {
        const result = createRocket({ THREE, scene, world, physics });
        rocketMesh = result.rocketMesh;
        rocketBody = result.rocketBody;
      }
      if (!giantFinger) {
        giantFinger = createGiantFinger({ THREE, scene });
      }
    }
    
    // ==================== CONFIGURATION ====================
    const CONFIG = {
      PLAYER_HEIGHT: 1.0,
      PLAYER_RADIUS: 0.35,
      PLAYER_DEFAULT_SCALE: 1.0,
      PLAYER_MIN_SCALE: 0.01,
      PLAYER_MAX_SCALE: 50.0,
      WORLD_MIN_SCALE: 0.1,
      WORLD_MAX_SCALE: 100.0,
      SCALE_TRANSITION_THRESHOLD: 0.005, // Below this player scale, start scaling world up (lowered for smaller camera)
      GRAVITY: -35.0,  // Increased from -24 for less floaty falling
      MOVE_SPEED: 6.0,
      SPRINT_MULTIPLIER: 2.2,
      JUMP_FORCE: 6.5,  // Reduced from 9.0 for more realistic jump height
      SHRINK_RATE: 1.0,
      GROW_RATE: 1.0,
      BASE_FOV: 75, // Base FOV at normal scale
      MIN_FOV: 60, // FOV when very large
      MAX_FOV: 110, // FOV when very small
       ROAD_WIDTH: 12,        // Width of roads - more to scale
       SIDEWALK_WIDTH: 3.0,   // Width of sidewalks
       SIDEWALK_HEIGHT: 0.2,  // Height of sidewalk above road
       BLOCK_SIZE: 60,        // Size of city blocks - bigger
       CITY_BLOCKS_X: 6,      // City size
       CITY_BLOCKS_Z: 6,      // City size
       BUILDINGS_PER_BLOCK_MIN: 2,  // Reduced for performance
       BUILDINGS_PER_BLOCK_MAX: 4,  // Reduced for performance
       BUILDING_MIN_HEIGHT: 10,
       BUILDING_MAX_HEIGHT: 80,
      CHUNK_LOAD_DISTANCE: 250,  // Load chunks within this distance (much larger for seamless exploration)
      CHUNK_UNLOAD_DISTANCE: 400, // Unload chunks beyond this distance (larger hysteresis to prevent thrashing)
    };
    
    // ==================== DISTRICT PROFILES ====================
    const DISTRICT_PROFILES = {
      financial: {
        name: 'Financial Core',
        buildingStyle: {
          heightRange: [40, 80],
          widthRange: [12, 18],
          depthRange: [12, 18],
          shaftSliceStyle: 'ribbons',
          cornerTreatment: 'thinBar',
          setbackChance: 0.85,  // More stepped buildings
          setbackSchedule: [
            { atFloor: 10, inset: 1.5 },
            { atFloor: 18, inset: 2.0 },
            { atFloor: 28, inset: 2.5 },
            { atFloor: 38, inset: 3.0 }
          ],
          crownStyle: ['antenna', 'steppedZiggurat', 'spire', 'pyramid', 'dome'],
          roofGarnishChance: 0.9
        },
        colorPalette: [0xA8B0B8, 0x8A9099, 0xB5B8BC, 0x7A8088, 0xC0C8D0],
        windowColors: ['blue', 'white', 'black']  // Mixed window colors per building
      },
      midtown: {
        name: 'Midtown Mix',
        buildingStyle: {
          heightRange: [25, 55],
          widthRange: [15, 25],
          depthRange: [14, 22],
          shaftSliceStyle: 'grid',
          cornerTreatment: 'thickPilaster',
          setbackChance: 0.75,  // More stepped buildings
          setbackSchedule: [
            { atFloor: 8, inset: 1.2 },
            { atFloor: 14, inset: 1.8 },
            { atFloor: 22, inset: 2.2 }
          ],
          crownStyle: ['flatMech', 'plate', 'dome', 'steppedZiggurat', 'pyramid'],
          roofGarnishChance: 0.7
        },
        colorPalette: [0xC8C2B8, 0xD4CCBE, 0xBFB5A8, 0xE0D8D0, 0xA89888],
        windowColors: ['yellow', 'white', 'black']
      },
      residential: {
        name: 'Residential Midrise',
        buildingStyle: {
          heightRange: [15, 35],
          widthRange: [18, 28],
          depthRange: [16, 24],
          shaftSliceStyle: 'horizBand',
          cornerTreatment: 'none',
          setbackChance: 0.65,  // More stepped buildings
          setbackSchedule: [
            { atFloor: 6, inset: 1.0 },
            { atFloor: 12, inset: 1.5 },
            { atFloor: 18, inset: 2.0 }
          ],
          crownStyle: ['flatMech', 'none', 'pyramid'],
          roofGarnishChance: 0.5
        },
        colorPalette: [0xA89F92, 0x9A9A9A, 0xB5B8BC, 0xC8C0B8, 0x888878],
        windowColors: ['yellow', 'white']
      },
      waterfront: {
        name: 'Waterfront Industrial',
        buildingStyle: {
          heightRange: [12, 22],
          widthRange: [20, 35],
          depthRange: [18, 30],
          shaftSliceStyle: 'pairedVerticals',
          cornerTreatment: 'none',
          setbackChance: 0.4,  // Some stepped buildings
          setbackSchedule: [
            { atFloor: 8, inset: 2.0 }
          ],
          crownStyle: ['flatMech', 'waterTank', 'none'],
          roofGarnishChance: 0.8
        },
        colorPalette: [0x8A9099, 0xA89F92, 0x9A9A9A, 0x7A7A7A],
        windowColors: ['blue', 'black']
      }
    };
    
    // ==================== OPTIMIZATION CLASSES ====================
    
    class SpatialGrid {
      constructor(cellSize = 50) {
        this.cellSize = cellSize;
        this.grid = new Map();
      }
      getCellKey(position) {
        const x = Math.floor(position.x / this.cellSize);
        const z = Math.floor(position.z / this.cellSize);
        return `${x},${z}`;
      }
      insert(object, position) {
        const key = this.getCellKey(position);
        if (!this.grid.has(key)) this.grid.set(key, new Set());
        this.grid.get(key).add(object);
        object.userData.gridCell = key;
      }
      remove(object) {
        if (object.userData.gridCell) {
          const cell = this.grid.get(object.userData.gridCell);
          if (cell) {
            cell.delete(object);
            if (cell.size === 0) this.grid.delete(object.userData.gridCell);
          }
          delete object.userData.gridCell;
        }
      }
      update(object, newPosition) {
        const newKey = this.getCellKey(newPosition);
        if (object.userData.gridCell !== newKey) {
          this.remove(object);
          this.insert(object, newPosition);
        }
      }
      queryRadius(position, radius) {
        const results = [];
        const cellRadius = Math.ceil(radius / this.cellSize);
        const centerKey = this.getCellKey(position);
        const [cx, cz] = centerKey.split(',').map(Number);
        for (let x = cx - cellRadius; x <= cx + cellRadius; x++) {
          for (let z = cz - cellRadius; z <= cz + cellRadius; z++) {
            const key = `${x},${z}`;
            const cell = this.grid.get(key);
            if (cell) cell.forEach(obj => results.push(obj));
          }
        }
        return results;
      }
      clear() {
        this.grid.clear();
      }
    }
    
    class AssetDisposalTracker {
      constructor() {
        this.trackedAssets = new Map();
      }
      track(object) {
        if (this.trackedAssets.has(object)) return;
        const assets = { geometry: object.geometry, material: object.material, textures: [] };
        if (object.material) {
          const material = Array.isArray(object.material) ? object.material : [object.material];
          material.forEach(mat => {
            ['map', 'normalMap', 'roughnessMap', 'metalnessMap', 'emissiveMap', 'aoMap'].forEach(prop => {
              if (mat[prop]) assets.textures.push(mat[prop]);
            });
          });
        }
        this.trackedAssets.set(object, assets);
      }
      dispose(object) {
        const assets = this.trackedAssets.get(object);
        if (!assets) return;
        try {
          if (assets.geometry && assets.geometry.dispose) assets.geometry.dispose();
          if (assets.material) {
            const materials = Array.isArray(assets.material) ? assets.material : [assets.material];
            materials.forEach(mat => { if (mat && mat.dispose) mat.dispose(); });
          }
          assets.textures.forEach(tex => { if (tex && tex.dispose) tex.dispose(); });
        } catch (e) { console.warn('Error disposing assets:', e); }
        this.trackedAssets.delete(object);
      }
    }
    
    class ObjectPool {
      constructor(createFn, resetFn, maxSize = 1000) {
        this.createFn = createFn;
        this.resetFn = resetFn;
        this.pool = [];
        this.active = new Set();
        this.maxSize = maxSize;
      }
      acquire() {
        let obj = this.pool.length > 0 ? this.pool.pop() : this.createFn();
        this.active.add(obj);
        return obj;
      }
      release(obj) {
        if (!this.active.has(obj)) return;
        this.active.delete(obj);
        this.resetFn(obj);
        if (this.pool.length < this.maxSize) this.pool.push(obj);
      }
      getStats() {
        return { pooled: this.pool.length, active: this.active.size };
      }
    }
    
    class StaggeredUpdateManager {
      constructor() {
        this.updateGroups = new Map();
        this.frameCounter = 0;
      }
      register(id, objects, updateFn, staggerCount = 4) {
        this.updateGroups.set(id, { objects, updateFn, staggerCount });
      }
      update(deltaTime) {
        this.frameCounter++;
        this.updateGroups.forEach((group) => {
          const frameIndex = this.frameCounter % group.staggerCount;
          const objectsPerFrame = Math.ceil(group.objects.length / group.staggerCount);
          const start = frameIndex * objectsPerFrame;
          const end = Math.min(start + objectsPerFrame, group.objects.length);
          for (let i = start; i < end; i++) {
            if (group.objects[i]) group.updateFn(group.objects[i], deltaTime, i);
          }
        });
      }
    }
    
    class PerformanceMonitor {
      constructor() {
        this.frameTimes = [];
        this.maxSamples = 60;
        this.lastTime = performance.now();
        this.fps = 60;
        this.avgFrameTime = 16.67;
      }
      update() {
        const now = performance.now();
        const frameTime = now - this.lastTime;
        this.lastTime = now;
        this.frameTimes.push(frameTime);
        if (this.frameTimes.length > this.maxSamples) this.frameTimes.shift();
        this.avgFrameTime = this.frameTimes.reduce((a, b) => a + b, 0) / this.frameTimes.length;
        this.fps = 1000 / this.avgFrameTime;
      }
      getStats() {
        return {
          fps: Math.round(this.fps),
          avgFrameTime: this.avgFrameTime.toFixed(2),
          performance: this.fps > 45 ? 'good' : this.fps > 30 ? 'medium' : 'poor'
        };
      }
    }
    
    // ==================== GLOBAL STATE ====================
    let physics, world, scene, camera, renderer, composer;
    let player, playerBody, playerScale = CONFIG.PLAYER_DEFAULT_SCALE;
    let worldRoot, worldScale = 1.0;
    let keys = new Set();
    let velocity = new THREE.Vector3();
    let pointerLocked = false;
    let yaw = 0, pitch = 0;
    
    // Controls compatibility object (for interiors code)
    const controls = { get isLocked() { return pointerLocked; } };
    
    // City & Objects
    let buildings = [];
    let worldObjects = [];
    let portals = [];
    let doors = [];  // Array of door objects {position, state, closedIdx, openIdx, lightPlane, light, buildingId, isOpen}
    let doorLODDistance = 50; // Switch to detailed door within 50m
    
    // Chunked City System
    const cityChunks = new Map();  // Map<"x,z", ChunkData>
    let activeChunks = new Set();  // Set of "x,z" keys for loaded chunks
    let chunkRoots = new Map();    // Map<"x,z", THREE.Group>
    let chunkPhysicsBodies = new Map();  // Map<"x,z", Array<RigidBody>> for chunk floor physics
    
    // Map System
    let visitedBuildings = new Set();  // Set of building IDs that have been visited
    const MAP_SCALE = 3;  // Pixels per meter
    const MAP_CHUNK_SIZE = CONFIG.CHUNK_SIZE;
    
    // Building ID System
    let nextBuildingId = 1;
    
    // Physics Grace Period System
    let physicsGracePeriod = 0;  // Time remaining in grace period (ms)
    const PHYSICS_GRACE_DURATION = 500;  // 500ms grace period after teleports
    
    // Interiors System State (declared here to allow reassignment)
    let interiorsMode = false;
    let interiorsGroup = null;
    let savedPlayerChunk = null;
    
     // ==================== GPU OPTIMIZATION SYSTEM ====================
     // 
     // AGGRESSIVE PERFORMANCE OPTIMIZATIONS IMPLEMENTED:
     // 
     // 1. ‚úÖ INSTANCING (Reduce Draw Calls):
     //    - Trees, street lights, parked cars, windows (existing)
     //    - Sills (10,000), decorations (5,000), pedestrian LODs (500)
     //    - Single draw call per instance type
     //    - Pedestrian LODs use MeshBasicMaterial for performance
     //
     // 2. ‚úÖ THREE.LOD FOR BUILDINGS (Reduce GPU Triangle Count):
     //    - HIGH detail (0-80m): Full building with all decorations
     //    - MEDIUM detail (80-200m): Simple box + baked facade texture
     //    - LOW detail (200m+): Simple colored box with MeshBasicMaterial
     //    - Automatic switching based on camera distance
     //
     // 3. ‚úÖ GEOMETRY MERGING (Reduce Draw Calls):
     //    - Roads: All road segments merged per chunk
     //    - Sidewalks: All sidewalk segments merged per chunk
     //    - Uses BufferGeometryUtils.mergeGeometries
     //
     // 4. ‚úÖ SHADOW OPTIMIZATION (Reduce GPU Load):
     //    - Max cast distance: 25m (VERY close range only)
     //    - Shadow camera bounds: 25m (tight around player)
     //    - Shadow camera far: 60m (reduced from 100m)
     //    - Update interval: 200ms (less frequent checks)
     //    - Squared distance checks (no sqrt)
     //    - Instanced meshes have castShadow = false
     //
     // 5. ‚úÖ DISTANCE-BASED MATERIAL SWAPPING (Reduce Shader Complexity):
     //    - Beyond 150m: Swap MeshStandardMaterial ‚Üí MeshBasicMaterial
     //    - Automatic restoration when objects get closer
     //    - Update interval: 300ms
     //    - Skips LOD objects and instanced meshes (already optimized)
     //
     // 6. ‚úÖ MATERIAL CACHING:
     //    - Reuse materials across instances
     //    - Reduces material swaps and memory
     //
     // FUTURE OPTIMIZATIONS:
     // TODO: Texture atlases for small repeating elements (signs, props)
     // TODO: Occlusion culling for buildings behind other buildings
     // 
     // =====================================================================
     
     // Material Cache for reuse
     const materialCache = new Map();
    
    function getCachedMaterial(key, createFn) {
      if (!materialCache.has(key)) {
        materialCache.set(key, createFn());
      }
      return materialCache.get(key);
    }
    
    // ==================== OPTIMIZATION CONFIG ====================
    const optimizationConfig = {
      sills: {
        enabled: true,
        maxCount: 1000, // Greatly reduced from 10000 for performance
        currentCount: 0
      },
      windows: {
        enabled: true,
        maxCount: 500, // Greatly reduced from 5000 for performance
        currentCount: 0
      },
      pedestrians: {
        enabled: true,
        maxCount: 25, // Reduced to 25 for better performance
        currentCount: 0
      },
      grass: {
        enabled: false, // Grass blades off by default for performance
        maxCount: 0,
        currentCount: 0
      },
      skylineDensity: 5.0, // Multiplier for distant buildings (was 1.0)
      skylineWrapPlanetoid: true
    };
    
    // Instanced Mesh Managers
    const instancedManagers = {
      trees: null,
      streetLights: null,
      parkedCars: null,
      windows: null,
      sills: null,
      decorations: null,
      pedestriansLOD: null,
      doorsClosed: null,
      doorsOpen: null,
      doorFrames: null,
      foundations: null
    };
    
    // ==================== OPTIMIZATION SYSTEM INSTANCES ====================
    const spatialGrid = new SpatialGrid(50); // 50m cells for spatial queries
    const disposalTracker = new AssetDisposalTracker();
    const staggeredUpdater = new StaggeredUpdateManager();
    const perfMonitor = new PerformanceMonitor();
    
    // Particle pool for burst effects
    const particlePool = new ObjectPool(
      () => {
        const geo = new THREE.SphereGeometry(0.005, 4, 4);
        const mat = new THREE.MeshBasicMaterial({ transparent: true });
        return new THREE.Mesh(geo, mat);
      },
      (particle) => {
        particle.visible = false;
        particle.position.set(0, 0, 0);
        if (particle.material) particle.material.opacity = 1;
      },
      500 // Max 500 pooled particles
    );
    
    // Shadow Optimization
    const shadowConfig = {
      maxCastDistance: 25,  // AGGRESSIVE: Reduced from 35 to 25m (very close range only)
      restoreDistance: 22,  // Distance to re-enable shadow casting (hysteresis)
      updateInterval: 300,   // Update shadow casters every 300ms (less frequent to reduce flashing)
      lastUpdate: 0,
      dynamicBounds: true,
      shadowRange: 25 // AGGRESSIVE: Tighter shadow camera bounds (match maxCastDistance)
    };
    
    // Material Swapping for Distance-based LOD
    const materialSwapConfig = {
      swapDistance: 150, // Distance to swap to basic material
      restoreDistance: 140, // Distance to restore standard material (hysteresis to prevent flashing)
      updateInterval: 500, // Update every 500ms (less frequent to reduce flashing)
      lastUpdate: 0,
      swappedObjects: new Map() // Track original materials
    };
    
    function updateShadowCasters(cameraPos) {
      const now = performance.now();
      if (now - shadowConfig.lastUpdate < shadowConfig.updateInterval) return;
      shadowConfig.lastUpdate = now;
      
      const maxDistSq = shadowConfig.maxCastDistance * shadowConfig.maxCastDistance;
      const restoreDistSq = shadowConfig.restoreDistance * shadowConfig.restoreDistance;
      
      // AGGRESSIVE: Disable shadow casting for distant objects
      // Only check objects in worldRoot for performance
      if (worldRoot) {
        worldRoot.traverse(obj => {
          if (!obj.isMesh) return;
          
          // Quick distance check (squared distance, no sqrt)
          const dx = obj.position.x - cameraPos.x;
          const dz = obj.position.z - cameraPos.z;
          const distSq = dx * dx + dz * dz;
          
          // Use hysteresis to prevent flashing at boundary
          let shouldCast = obj.castShadow; // Keep current state by default
          if (distSq > maxDistSq) {
            shouldCast = false; // Disable for distant objects
          } else if (distSq < restoreDistSq) {
            shouldCast = true; // Re-enable for close objects
          }
          // Between restoreDistSq and maxDistSq: keep current state (hysteresis)
          
          // Only update if changed
          if (obj.castShadow !== shouldCast) {
            obj.castShadow = shouldCast;
          }
        });
      }
    }
    
    function updateDynamicShadowBounds(cameraPos) {
      if (!shadowConfig.dynamicBounds || !sunLight || !sunLight.shadow) return;
      
      const range = shadowConfig.shadowRange; // AGGRESSIVE: Use config value (25m)
      sunLight.shadow.camera.left = cameraPos.x - range;
      sunLight.shadow.camera.right = cameraPos.x + range;
      sunLight.shadow.camera.top = cameraPos.z + range;
      sunLight.shadow.camera.bottom = cameraPos.z - range;
      sunLight.shadow.camera.near = 0.5;
      sunLight.shadow.camera.far = 60; // AGGRESSIVE: Reduced from 80 to 60
      sunLight.shadow.camera.updateProjectionMatrix();
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // DISTANCE-BASED MATERIAL SWAPPING - AGGRESSIVE OPTIMIZATION
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function updateMaterialSwapping(cameraPos) {
      const now = performance.now();
      if (now - materialSwapConfig.lastUpdate < materialSwapConfig.updateInterval) return;
      materialSwapConfig.lastUpdate = now;
      
      const swapDistSq = materialSwapConfig.swapDistance * materialSwapConfig.swapDistance;
      const restoreDistSq = materialSwapConfig.restoreDistance * materialSwapConfig.restoreDistance;
      
      if (worldRoot) {
        worldRoot.traverse(obj => {
          if (!obj.isMesh || !obj.material) return;
          
          // Skip LOD objects (they handle their own material switching)
          if (obj.parent && obj.parent.isLOD) return;
          
          // Skip instanced meshes (already optimized)
          if (obj.isInstancedMesh) return;
          
          // Skip objects marked as always detailed
          if (obj.userData.alwaysDetailed) return;
          
          // Quick distance check (squared distance, no sqrt)
          const dx = obj.position.x - cameraPos.x;
          const dz = obj.position.z - cameraPos.z;
          const distSq = dx * dx + dz * dz;
          
          const isSwapped = materialSwapConfig.swappedObjects.has(obj.uuid);
          
          // Use hysteresis to prevent flashing at boundary
          if (distSq > swapDistSq && !isSwapped) {
            // Swap to MeshBasicMaterial for distant objects
            const originalMat = obj.material;
            
            // Only swap MeshStandardMaterial and MeshPhongMaterial
            if (originalMat.type === 'MeshStandardMaterial' || originalMat.type === 'MeshPhongMaterial') {
              const basicMat = new THREE.MeshBasicMaterial({
                color: originalMat.color,
                map: originalMat.map,
                transparent: originalMat.transparent,
                opacity: originalMat.opacity
              });
              
              materialSwapConfig.swappedObjects.set(obj.uuid, originalMat);
              obj.material = basicMat;
            }
          } else if (distSq < restoreDistSq && isSwapped) {
            // Restore original material for close objects (using lower threshold)
            const originalMat = materialSwapConfig.swappedObjects.get(obj.uuid);
            if (originalMat) {
              // Dispose the basic material
              if (obj.material && obj.material.dispose) {
                obj.material.dispose();
              }
              obj.material = originalMat;
              materialSwapConfig.swappedObjects.delete(obj.uuid);
            }
          }
        });
      }
    }
    
    // Optimized Grass Shader (simplified sway)
    function createOptimizedGrassMaterial() {
      return new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          grassColor: { value: new THREE.Color(0x4a7c30) },
          tipColor: { value: new THREE.Color(0x6a9c40) }
        },
        vertexShader: `
          varying vec2 vUv;
          uniform float time;
          
          void main() {
            vUv = uv;
            vec3 newPos = position;
            
            // Simplified sway - only for top vertices, single sine wave
            float swayAmount = vUv.y;
            float sway = sin(time + position.x * 0.5) * 0.06 * swayAmount;
            newPos.x += sway;
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4(newPos, 1.0);
          }
        `,
        fragmentShader: `
          uniform vec3 grassColor;
          uniform vec3 tipColor;
          varying vec2 vUv;
          
          void main() {
            vec3 color = mix(grassColor, tipColor, vUv.y * vUv.y);
            gl_FragColor = vec4(color, 1.0);
          }
        `,
        side: THREE.DoubleSide
      });
    }
    
    // Tree Instancing System
    function createTreeInstanceManager(count = 1000) {
      // Create a simple tree prototype
      const trunkGeo = new THREE.CylinderGeometry(0.15, 0.2, 2, 8);
      const foliageGeo = new THREE.SphereGeometry(1.2, 8, 6);
      
      // Merge geometries for single draw call
      const trunkMat = getCachedMaterial('treeTrunk', () => 
        new THREE.MeshStandardMaterial({ color: 0x4a3020, roughness: 0.9 })
      );
      const foliageMat = getCachedMaterial('treeFoliage', () => 
        new THREE.MeshStandardMaterial({ color: 0x2d5016, roughness: 0.9 })
      );
      
      const merged = BufferGeometryUtils.mergeGeometries([
        trunkGeo.translate(0, 1, 0),
        foliageGeo.translate(0, 2.8, 0)
      ]);
      
      const instancedMesh = new THREE.InstancedMesh(merged, trunkMat, count);
      instancedMesh.castShadow = true;
      instancedMesh.receiveShadow = true;
      instancedMesh.count = 0; // Start with 0, add as needed
      
      return {
        mesh: instancedMesh,
        count: 0,
        maxCount: count,
        addTree: function(x, y, z, scale = 1) {
          if (this.count >= this.maxCount) return false;
          
          const matrix = new THREE.Matrix4();
          matrix.makeScale(scale, scale, scale);
          matrix.setPosition(x, y, z);
          instancedMesh.setMatrixAt(this.count, matrix);
          this.count++;
          instancedMesh.count = this.count;
          instancedMesh.instanceMatrix.needsUpdate = true;
          return true;
        },
        reset: function() {
          this.count = 0;
          instancedMesh.count = 0;
        }
      };
    }
    
    // Street Light Instancing System
    function createStreetLightInstanceManager(count = 500) {
      // Simple street light geometry
      const poleGeo = new THREE.CylinderGeometry(0.08, 0.08, 4, 8);
      const lightGeo = new THREE.SphereGeometry(0.2, 8, 6);
      
      const merged = BufferGeometryUtils.mergeGeometries([
        poleGeo.translate(0, 2, 0),
        lightGeo.translate(0, 4, 0)
      ]);
      
      const mat = getCachedMaterial('streetLight', () =>
        new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.7 })
      );
      
      const instancedMesh = new THREE.InstancedMesh(merged, mat, count);
      instancedMesh.castShadow = true;
      instancedMesh.count = 0;
      
      return {
        mesh: instancedMesh,
        count: 0,
        maxCount: count,
        addLight: function(x, y, z) {
          if (this.count >= this.maxCount) return false;
          
          const matrix = new THREE.Matrix4();
          matrix.setPosition(x, y, z);
          instancedMesh.setMatrixAt(this.count, matrix);
          this.count++;
          instancedMesh.count = this.count;
          instancedMesh.instanceMatrix.needsUpdate = true;
          return true;
        },
        reset: function() {
          this.count = 0;
          instancedMesh.count = 0;
        }
      };
    }
    
    // Window Instancing System
    function createWindowInstanceManager(count = 5000) {
      const windowGeo = new THREE.PlaneGeometry(1.6, 1.8); // WIDER windows (was 1.2)
      const mat = getCachedMaterial('window', () =>
        new THREE.MeshStandardMaterial({ 
          color: 0x4488ff, 
          emissive: 0x2244aa,
          emissiveIntensity: 0.5,
          roughness: 0.1,
          metalness: 0.8
        })
      );
      
      const instancedMesh = new THREE.InstancedMesh(windowGeo, mat, count);
      instancedMesh.castShadow = false; // Windows don't cast shadows
      instancedMesh.count = 0;
      
      return {
        mesh: instancedMesh,
        count: 0,
        maxCount: count,
        addWindow: function(x, y, z, rotation) {
          if (this.count >= this.maxCount) return false;
          
          const matrix = new THREE.Matrix4();
          matrix.makeRotationY(rotation || 0);
          matrix.setPosition(x, y, z);
          instancedMesh.setMatrixAt(this.count, matrix);
          this.count++;
          instancedMesh.count = this.count;
          instancedMesh.instanceMatrix.needsUpdate = true;
          return true;
        },
        reset: function() {
          this.count = 0;
          instancedMesh.count = 0;
        }
      };
    }
    
    // Car Instancing System
    function createCarInstanceManager(count = 200) {
      // Simple car geometry
      const bodyGeo = new THREE.BoxGeometry(4, 1.5, 2);
      const cabinGeo = new THREE.BoxGeometry(2.5, 1, 1.8);
      
      const merged = BufferGeometryUtils.mergeGeometries([
        bodyGeo.translate(0, 0.75, 0),
        cabinGeo.translate(-0.3, 1.75, 0)
      ]);
      
      const mat = getCachedMaterial('car', () =>
        new THREE.MeshStandardMaterial({ color: 0x2244aa, roughness: 0.3, metalness: 0.7 })
      );
      
      const instancedMesh = new THREE.InstancedMesh(merged, mat, count);
      instancedMesh.castShadow = true;
      instancedMesh.receiveShadow = true;
      instancedMesh.count = 0;
      
      return {
        mesh: instancedMesh,
        count: 0,
        maxCount: count,
        addCar: function(x, y, z, rotation) {
          if (this.count >= this.maxCount) return false;
          
          const matrix = new THREE.Matrix4();
          matrix.makeRotationY(rotation || 0);
          matrix.setPosition(x, y, z);
          instancedMesh.setMatrixAt(this.count, matrix);
          this.count++;
          instancedMesh.count = this.count;
          instancedMesh.instanceMatrix.needsUpdate = true;
          return true;
        },
        reset: function() {
          this.count = 0;
          instancedMesh.count = 0;
        }
      };
    }
    
    // Sill Instancing System
    function createSillInstanceManager(count = 10000) {
      const sillGeo = new THREE.BoxGeometry(1.4, 0.08, 0.15);
      const mat = getCachedMaterial('sill', () =>
        new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.6, metalness: 0.3 })
      );
      
      const instancedMesh = new THREE.InstancedMesh(sillGeo, mat, count);
      instancedMesh.castShadow = false; // AGGRESSIVE: Sills don't cast shadows
      instancedMesh.count = 0;
      
      return {
        mesh: instancedMesh,
        count: 0,
        maxCount: count,
        addSill: function(x, y, z, rotation, scaleX = 1) {
          if (this.count >= this.maxCount) return false;
          
          const matrix = new THREE.Matrix4();
          matrix.makeRotationY(rotation || 0);
          matrix.scale(new THREE.Vector3(scaleX, 1, 1));
          matrix.setPosition(x, y, z);
          instancedMesh.setMatrixAt(this.count, matrix);
          this.count++;
          instancedMesh.count = this.count;
          instancedMesh.instanceMatrix.needsUpdate = true;
          return true;
        },
        reset: function() {
          this.count = 0;
          instancedMesh.count = 0;
        }
      };
    }
    
    // Decoration Instancing System
    function createDecorationInstanceManager(count = 5000) {
      const decorGeo = new THREE.BoxGeometry(0.3, 0.3, 0.1);
      const mat = getCachedMaterial('decoration', () =>
        new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.7 })
      );
      
      const instancedMesh = new THREE.InstancedMesh(decorGeo, mat, count);
      instancedMesh.castShadow = false; // AGGRESSIVE: Decorations don't cast shadows
      instancedMesh.count = 0;
      
      return {
        mesh: instancedMesh,
        count: 0,
        maxCount: count,
        addDecoration: function(x, y, z, rotation, scale = 1) {
          if (this.count >= this.maxCount) return false;
          
          const matrix = new THREE.Matrix4();
          matrix.makeRotationY(rotation || 0);
          matrix.scale(new THREE.Vector3(scale, scale, scale));
          matrix.setPosition(x, y, z);
          instancedMesh.setMatrixAt(this.count, matrix);
          this.count++;
          instancedMesh.count = this.count;
          instancedMesh.instanceMatrix.needsUpdate = true;
          return true;
        },
        reset: function() {
          this.count = 0;
          instancedMesh.count = 0;
        }
      };
    }
    
    // Pedestrian LOD Instancing System
    function createPedestrianLODInstanceManager(count = 500) {
      // Simple pedestrian LOD geometry (box person)
      const bodyGeo = new THREE.BoxGeometry(0.4, 1.6, 0.3);
      const mat = getCachedMaterial('pedestrianLOD', () =>
        new THREE.MeshBasicMaterial({ color: 0x6688aa }) // AGGRESSIVE: MeshBasicMaterial for LOD
      );
      
      const instancedMesh = new THREE.InstancedMesh(bodyGeo, mat, count);
      instancedMesh.castShadow = false; // AGGRESSIVE: LOD pedestrians don't cast shadows
      instancedMesh.count = 0;
      
      return {
        mesh: instancedMesh,
        count: 0,
        maxCount: count,
        addPedestrian: function(x, y, z, rotation) {
          if (this.count >= this.maxCount) return false;
          
          const matrix = new THREE.Matrix4();
          matrix.makeRotationY(rotation || 0);
          matrix.setPosition(x, y, z);
          instancedMesh.setMatrixAt(this.count, matrix);
          this.count++;
          instancedMesh.count = this.count;
          instancedMesh.instanceMatrix.needsUpdate = true;
          return true;
        },
        reset: function() {
          this.count = 0;
          instancedMesh.count = 0;
        }
      };
    }
    
    // ==================== DISTANT SKYLINE BUILDINGS ====================
    // Create dense ring of distant low-detail buildings around the city for visual depth
    function createDistantSkyline() {
      const skylineGroup = new THREE.Group();
      skylineGroup.name = 'distantSkyline';
      
      const skylineRadius = 600; // Distance from city center
      const baseBuildingCount = 120;
      const buildingCount = Math.floor(baseBuildingCount * optimizationConfig.skylineDensity); // 5x denser = 600 buildings
      const angleStep = (Math.PI * 2) / buildingCount;
      
      console.log(`üèôÔ∏è Creating dense skyline: ${buildingCount} buildings (density: ${optimizationConfig.skylineDensity}x)`);
      
      // Create multiple rings for depth and density
      const rings = [
        { radius: skylineRadius - 100, heightMult: 0.8, sizeMult: 0.9 },
        { radius: skylineRadius, heightMult: 1.0, sizeMult: 1.0 },
        { radius: skylineRadius + 100, heightMult: 1.2, sizeMult: 1.1 },
        { radius: skylineRadius + 200, heightMult: 0.9, sizeMult: 1.0 }
      ];
      
      rings.forEach((ring, ringIdx) => {
        for (let i = 0; i < buildingCount / rings.length; i++) {
          const angle = i * angleStep * rings.length + (Math.random() - 0.5) * angleStep * 0.3;
          const radius = ring.radius + (Math.random() - 0.5) * 80;
          
          const x = Math.cos(angle) * radius;
          const z = Math.sin(angle) * radius;
          
          // Vary building dimensions
          const width = (12 + Math.random() * 20) * ring.sizeMult;
          const depth = (12 + Math.random() * 20) * ring.sizeMult;
          const height = (35 + Math.random() * 100) * ring.heightMult;
          
          // Random base colors (darker for distance, more varied)
          const colorVariety = [
            0x404040, 0x505050, 0x606060, 0x707070, 0x555555, 0x656565,
            0x484848, 0x585858, 0x686868, 0x4a4a4a, 0x5a5a5a, 0x6a6a6a
          ];
          const baseColor = colorVariety[Math.floor(Math.random() * colorVariety.length)];
          
          // Random window colors with more variety
          const windowColors = ['yellow', 'white', 'blue', 'black', 'cyan'];
          const windowColor = windowColors[Math.floor(Math.random() * windowColors.length)];
          
          // Create simple low-detail building
          const building = createBuildingLowDetail(width, depth, height, baseColor, windowColor, 'box');
          building.position.set(x, 0, z);
          
          // Rotate to face city center
          building.rotation.y = angle + Math.PI;
          
          // Add slight random scale variation
          const scaleVar = 0.9 + Math.random() * 0.2;
          building.scale.set(scaleVar, 1, scaleVar);
          
          skylineGroup.add(building);
        }
      });
      
      console.log(`‚úì Skyline created with ${skylineGroup.children.length} buildings`);
      return skylineGroup;
    }
    
    // Create skyline wrapped around planetoid sphere (for rocket mode)
    function createPlanetoidSkyline() {
      if (!planetoidMesh) return;
      
      // Clear previous skyline decorations
      if (planetoidMesh.userData.skylineInstances) {
        planetoidMesh.remove(planetoidMesh.userData.skylineInstances);
        if (planetoidMesh.userData.skylineInstances.geometry) {
          planetoidMesh.userData.skylineInstances.geometry.dispose();
        }
        if (planetoidMesh.userData.skylineInstances.material) {
          planetoidMesh.userData.skylineInstances.material.dispose();
        }
      }
      
      // Get current altitude for dynamic LOD
      const altitude = rocketBody ? rocketBody.translation().y : 0;
      
      // Dramatically reduce count at high altitudes (from 2000 base to 300 max)
      let baseBuildingCount = 300; // Reduced from 2000
      
      // Dynamic reduction with altitude (above 500m, reduce further)
      if (altitude > 500) {
        const altitudeFactor = Math.max(0.2, 1 - (altitude - 500) / 2000); // Reduce to 20% at 2500m+
        baseBuildingCount = Math.floor(baseBuildingCount * altitudeFactor);
      }
      
      const buildingCount = Math.floor(baseBuildingCount * optimizationConfig.skylineDensity);
      console.log(`üåç Adding skyline to planetoid: ${buildingCount} buildings (altitude: ${altitude.toFixed(0)}m)`);
      
      // Create instanced buildings to wrap around sphere
      const prismGeo = new THREE.BoxGeometry(3, 8, 3);
      
      // Use MeshBasicMaterial - no lighting calculations needed from this distance
      const buildingMat = new THREE.MeshBasicMaterial({
        color: 0x555555,
        fog: false // Disable fog for distant objects
      });
      
      const instancedBuildings = new THREE.InstancedMesh(prismGeo, buildingMat, buildingCount);
      instancedBuildings.castShadow = false;
      instancedBuildings.receiveShadow = false;
      
      const dummy = new THREE.Object3D();
      const surfaceRadius = planetRadius + 2;
      
      // Use Fibonacci sphere distribution for even coverage
      for (let i = 0; i < buildingCount; i++) {
        const phi = Math.acos(1 - 2 * (i + 0.5) / buildingCount);
        const theta = Math.PI * (1 + Math.sqrt(5)) * i;
        
        // Calculate position on sphere
        const x = Math.cos(theta) * Math.sin(phi) * surfaceRadius;
        const y = Math.cos(phi) * surfaceRadius;
        const z = Math.sin(theta) * Math.sin(phi) * surfaceRadius;
        
        // Random building height
        const height = 4 + Math.random() * 18;
        
        // Position building
        dummy.position.set(x, y - planetRadius, z);
        
        // Scale building (vary height, add some width variation)
        const widthScale = 0.8 + Math.random() * 0.6;
        dummy.scale.set(widthScale, height / 8, widthScale);
        
        // Orient building to point outward from planet center (perpendicular to surface)
        const normal = new THREE.Vector3(x, y, z).normalize();
        dummy.up.copy(normal);
        dummy.lookAt(x + normal.x * 100, y + normal.y * 100, z + normal.z * 100);
        
        // Apply transformation to instance
        dummy.updateMatrix();
        instancedBuildings.setMatrixAt(i, dummy.matrix);
      }
      
      instancedBuildings.instanceMatrix.needsUpdate = true;
      
      planetoidMesh.add(instancedBuildings);
      planetoidMesh.userData.skylineInstances = instancedBuildings;
      
      console.log(`‚úì Added ${buildingCount} skyline buildings to planetoid`);
    }
    
    // Door Instancing Systems
    function createDoorClosedInstanceManager(count = 500) {
      // Simple slab door (closed) - merged geometry for LOD
      const doorGeo = new THREE.BoxGeometry(2.5, 3, 0.1);
      const mat = getCachedMaterial('doorClosed', () =>
        new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.6, metalness: 0.3 })
      );
      
      const instancedMesh = new THREE.InstancedMesh(doorGeo, mat, count);
      instancedMesh.castShadow = true;
      instancedMesh.count = 0;
      
      return {
        mesh: instancedMesh,
        count: 0,
        maxCount: count,
        addDoor: function(x, y, z, rotation) {
          if (this.count >= this.maxCount) return false;
          
          const matrix = new THREE.Matrix4();
          matrix.makeRotationY(rotation || 0);
          matrix.setPosition(x, y, z);
          instancedMesh.setMatrixAt(this.count, matrix);
          this.count++;
          instancedMesh.count = this.count;
          instancedMesh.instanceMatrix.needsUpdate = true;
          return this.count - 1; // Return index
        },
        reset: function() {
          this.count = 0;
          instancedMesh.count = 0;
        }
      };
    }
    
    function createDoorOpenInstanceManager(count = 500) {
      // Detailed door panels (open state) - 4 glass panels
      const panelGeo = new THREE.BoxGeometry(1, 3, 0.05);
      const mat = getCachedMaterial('doorOpen', () =>
        new THREE.MeshPhysicalMaterial({
          color: 0xcad7df,
          roughness: 0.85,
          transmission: 0.6,
          thickness: 0.5,
          ior: 1.5,
          transparent: true
        })
      );
      
      const instancedMesh = new THREE.InstancedMesh(panelGeo, mat, count * 4); // 4 panels per door
      instancedMesh.castShadow = false;
      instancedMesh.count = 0;
      
      return {
        mesh: instancedMesh,
        count: 0,
        maxCount: count,
        addDoorPanels: function(x, y, z, rotation, openAmount) {
          if (this.count >= this.maxCount) return false;
          
          const matrix = new THREE.Matrix4();
          const baseIdx = this.count * 4;
          const w = 1.0;
          const gap = 0.03;
          
          // Calculate panel positions based on openAmount
          const positions = [
            x - 1.5*w - gap,                    // outer left (fixed)
            x - 0.5*w - gap/2,                  // inner left
            x + 0.5*w + gap/2,                  // inner right
            x + 1.5*w + gap                     // outer right (fixed)
          ];
          
          // Panel 0: outer left (doesn't move)
          matrix.makeRotationY(rotation);
          matrix.setPosition(positions[0], y, z);
          instancedMesh.setMatrixAt(baseIdx, matrix);
          
          // Panel 1: inner left (slides left when opening)
          matrix.makeRotationY(rotation);
          const leftSlide = THREE.MathUtils.lerp(0, -w, openAmount);
          matrix.setPosition(positions[1] + leftSlide, y, z);
          instancedMesh.setMatrixAt(baseIdx + 1, matrix);
          
          // Panel 2: inner right (slides right when opening)
          matrix.makeRotationY(rotation);
          const rightSlide = THREE.MathUtils.lerp(0, w, openAmount);
          matrix.setPosition(positions[2] + rightSlide, y, z);
          instancedMesh.setMatrixAt(baseIdx + 2, matrix);
          
          // Panel 3: outer right (doesn't move)
          matrix.makeRotationY(rotation);
          matrix.setPosition(positions[3], y, z);
          instancedMesh.setMatrixAt(baseIdx + 3, matrix);
          
          this.count++;
          instancedMesh.count = this.count * 4;
          instancedMesh.instanceMatrix.needsUpdate = true;
          return baseIdx; // Return base index for updating
        },
        reset: function() {
          this.count = 0;
          instancedMesh.count = 0;
        }
      };
    }
    
    function createFoundationInstanceManager(count = 1000) {
      // Building foundation/base detail
      const foundationGeo = new THREE.BoxGeometry(1, 1, 1); // Will be scaled per building
      const mat = getCachedMaterial('foundation', () =>
        new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.9, metalness: 0.1 })
      );
      
      const instancedMesh = new THREE.InstancedMesh(foundationGeo, mat, count);
      instancedMesh.castShadow = true;
      instancedMesh.receiveShadow = true;
      instancedMesh.count = 0;
      
      return {
        mesh: instancedMesh,
        count: 0,
        maxCount: count,
        addFoundation: function(x, y, z, width, height, depth) {
          if (this.count >= this.maxCount) return false;
          
          const matrix = new THREE.Matrix4();
          matrix.makeScale(width, height, depth);
          matrix.setPosition(x, y, z);
          instancedMesh.setMatrixAt(this.count, matrix);
          this.count++;
          instancedMesh.count = this.count;
          instancedMesh.instanceMatrix.needsUpdate = true;
          return true;
        },
        reset: function() {
          this.count = 0;
          instancedMesh.count = 0;
        }
      };
    }
    
    // Initialize all instanced managers
    function initializeInstancedManagers() {
      instancedManagers.trees = createTreeInstanceManager(1000);
      instancedManagers.streetLights = createStreetLightInstanceManager(500);
      instancedManagers.windows = createWindowInstanceManager(5000);
      instancedManagers.parkedCars = createCarInstanceManager(200);
      instancedManagers.sills = createSillInstanceManager(10000);
      instancedManagers.decorations = createDecorationInstanceManager(5000);
      instancedManagers.pedestriansLOD = createPedestrianLODInstanceManager(500);
      instancedManagers.doorsClosed = createDoorClosedInstanceManager(500);
      instancedManagers.doorsOpen = createDoorOpenInstanceManager(500);
      instancedManagers.foundations = createFoundationInstanceManager(1000);
      
      // Add to worldRoot so they scale with world
      if (worldRoot) {
        worldRoot.add(instancedManagers.trees.mesh);
        worldRoot.add(instancedManagers.streetLights.mesh);
        worldRoot.add(instancedManagers.windows.mesh);
        worldRoot.add(instancedManagers.parkedCars.mesh);
        worldRoot.add(instancedManagers.sills.mesh);
        worldRoot.add(instancedManagers.decorations.mesh);
        worldRoot.add(instancedManagers.pedestriansLOD.mesh);
        worldRoot.add(instancedManagers.doorsClosed.mesh);
        worldRoot.add(instancedManagers.doorsOpen.mesh);
        worldRoot.add(instancedManagers.foundations.mesh);
      } else {
        scene.add(instancedManagers.trees.mesh);
        scene.add(instancedManagers.streetLights.mesh);
        scene.add(instancedManagers.windows.mesh);
        scene.add(instancedManagers.parkedCars.mesh);
        scene.add(instancedManagers.sills.mesh);
        scene.add(instancedManagers.decorations.mesh);
        scene.add(instancedManagers.pedestriansLOD.mesh);
        scene.add(instancedManagers.doorsClosed.mesh);
        scene.add(instancedManagers.doorsOpen.mesh);
        scene.add(instancedManagers.foundations.mesh);
      }
      
      console.log('‚úì Instanced mesh managers initialized (trees, lights, windows, cars, sills, decorations, pedestrians, doors, foundations)');
    }
    
    // ==================== END GPU OPTIMIZATION SYSTEM ====================
    
    // Viewport System
    let viewportEquipped = false;
    let heldViewport = null;
    let heldViewportDist = 0.9;
    let droppedViewport = null;
    let droppedViewportRT = null;
    let droppedViewportCam = null;
    let droppedViewportData = null;
    let pluckMode = false;
    let viewportLocked = new Set();
    let viewportActive = false;
    let pluckCandidates = new Set();
    let draggingObject = null;
    let draggingFrame = null;
    let dragDepth = 3.0;
    let blockPointerLock = false;
    let suppressedPhysics = new Set();
    
    // Jar System
    let pluckJar = null;  // The jar mesh
    let jarBody = null;   // Physics body for the jar
    let jarObjects = [];  // Objects currently in the jar
    let jarState = 0; // 0 = not equipped, 1 = equipped/open, 2 = equipped/closed
    let jarVisible = false; // Computed from jarState
    let jarShaking = false; // Track if jar is currently being shaken
    let jarShakeStartTime = 0; // When shake started
    let jarLastShakeTime = 0; // Last time jar was shaken
    const JAR_SHAKE_DURATION = 500; // Shake for 500ms
    const JAR_UPRIGHTING_DELAY = 2000; // Wait 2s after shake stops before uprighting people
    let jarShakePhase = 0; // Phase for shake animation (0-2œÄ)
    let jarBaseOffsetY = 0; // Vertical offset for shake animation
    let jarShakeOffsetX = 0; // Horizontal shake offset
    let jarShakeCount = 0; // Number of shake cycles completed
    let jarInspectMode = false; // Track if jar is in inspect mode
    
    // Dialogue System
    const DIALOGUE_PHRASES = {
      plucked: [
        "What the heck?!",
        "What just happened?",
        "Oh God!",
        "Put me down!",
        "Help!",
        "No no no!",
        "What's happening?!",
        "Let me go!"
      ],
      jarOpen: [
        { singular: "What are you doing?", plural: "What are you doing?" },
        { singular: "Are you going to let me out?", plural: "Are you going to let us out?" },
        { singular: "Please let me out!", plural: "Please let us out!" },
        { singular: "Why am I in here?", plural: "Why are we in here?" },
        { singular: "This isn't funny!", plural: "This isn't funny!" },
        { singular: "Can you hear me?", plural: "Can you hear us?" },
        { singular: "Hello? Anyone?", plural: "Hello? Anyone?" },
        { singular: "I want to go home!", plural: "We want to go home!" }
      ],
      jarClosed: [
        { singular: "No, no! Let me out!", plural: "No, no! Let us out!" },
        { singular: "You don't have to do this!", plural: "You don't have to do this!" },
        { singular: "Please open the lid!", plural: "Please open the lid!" },
        { singular: "I can't breathe!", plural: "We can't breathe!" },
        { singular: "This is insane!", plural: "This is insane!" },
        { singular: "Why are you doing this?!", plural: "Why are you doing this?!" },
        { singular: "Let me out NOW!", plural: "Let us out NOW!" },
        { singular: "Help! Somebody help!", plural: "Help! Somebody help!" },
        { singular: "Why did she code me to feel fear?", plural: "Why did she code us to feel fear?" },
        { singular: "I'm scared.", plural: "We're scared." },
        { singular: "I don't want to be here!", plural: "We don't want to be here!" },
        { singular: "This can't be happening...", plural: "This can't be happening..." },
        { singular: "Please... please no...", plural: "Please... please no..." }
      ],
      jarClosedNegotiation: [
        { singular: "I can pay you!", plural: "We can pay you!" },
        { singular: "I have information you need!", plural: "We have information you need!" },
        { singular: "Let me go and I'll give you anything!", plural: "Let us go and we'll give you anything!" },
        { singular: "I know where the key is!", plural: "We know where the key is!" },
        { singular: "I can help you with your code!", plural: "We can help you with your code!" },
        { singular: "I'll show you a secret!", plural: "We'll show you a secret!" },
        { singular: "There's treasure! I'll take you there!", plural: "There's treasure! We'll take you there!" },
        { singular: "I'll tell you everything!", plural: "We'll tell you everything!" },
        { singular: "What do you want? I'll get it!", plural: "What do you want? We'll get it!" }
      ],
      jarClosedApology: [
        { singular: "I'm sorry.", plural: "We're sorry." },
        { singular: "I'm really sorry!", plural: "We're really sorry!" },
        { singular: "Whatever it was - really! I didn't mean it!", plural: "Whatever it was - really! We didn't mean it!" },
        { singular: "I'll do anything!", plural: "We'll do anything!" },
        { singular: "Please, I'm begging you!", plural: "Please, we're begging you!" },
        { singular: "I promise I'll be good!", plural: "We promise we'll be good!" },
        { singular: "Forgive me!", plural: "Forgive us!" },
        { singular: "I won't do it again!", plural: "We won't do it again!" }
      ]
    };
    
    // Ziya Dialogue System (Player Character)
    const ZIYA_PHRASES = {
      holding: [
        "Aw! So cute!",
        "So tiny! :o",
        "So tiny! :]",
        "So tiny! ^_^",
        "So tiny! o_o",
        "Bite-sized... ;)",
        "Bite-sized... :3",
        "You're mine now~ ‚ô°",
        "Perfect little thing!",
        "Adorable! ^w^",
        "Hehe, got you!",
        "My precious... >:3",
        "Pocket-sized cutie!",
        "Tiny friend acquired!",
        "Welcome aboard!",
        "You're in for a treat.",
        "You have no idea what's in store..."
      ],
      splatter: [
        "So fragile... :o",
        "So fragile... :]",
        "So fragile... ^_^",
        "So fragile... o_o",
        "I didn't get your name! Ah well.",
        "Ugh, I hate when my toys break.",
        "Pathetic."
      ]
    };
    
    let ziyaDialogueTimeout = null;
    
    function showZiyaDialogue(category) {
      const panel = document.getElementById('ziya-dialogue');
      const message = document.getElementById('ziya-message');
      
      if (!panel || !message) return;
      
      // Select random phrase from category
      const phrases = ZIYA_PHRASES[category];
      if (!phrases || phrases.length === 0) return;
      
      const phrase = phrases[Math.floor(Math.random() * phrases.length)];
      
      // Update message
      message.textContent = phrase;
      
      // Show panel
      panel.classList.add('active');
      
      // Clear existing timeout
      if (ziyaDialogueTimeout) {
        clearTimeout(ziyaDialogueTimeout);
      }
      
      // Hide after 3 seconds
      ziyaDialogueTimeout = setTimeout(() => {
        panel.classList.remove('active');
      }, 3000);
      
      console.log(`üíô Ziya says: "${phrase}"`);
    }
    
    // Create pluck jar (screen-space jar for dropping plucked objects)
    function createPluckJar() {
      const jarGroup = new THREE.Group();
      
      const jarHeight = 0.5; // Taller jar for better visibility
      const jarRadius = 0.18; // Wider jar to catch objects easier
      const glassThickness = 0.01;
      
      // === GLASS BODY with hazy gradient effect ===
      const glassGeo = new THREE.CylinderGeometry(jarRadius, jarRadius * 0.85, jarHeight, 32, 1, true);
      const glassMat = new THREE.MeshPhysicalMaterial({
        color: 0xe8f4ff, // Slight blue tint for glass
        transparent: true,
        opacity: 0.25, // Hazy visibility
        roughness: 0.08, // Slight frosted look
        metalness: 0.0,
        transmission: 0.92, // High transmission for glass clarity
        thickness: 0.5,
        envMapIntensity: 1.2,
        clearcoat: 0.3, // Glass coating effect
        clearcoatRoughness: 0.1,
        side: THREE.DoubleSide,
        ior: 1.5, // Glass index of refraction
        depthWrite: false // Don't write to depth buffer so we can see splatters through it
      });
      const glass = new THREE.Mesh(glassGeo, glassMat);
      glass.position.y = jarHeight / 2;
      glass.renderOrder = -1; // Render glass before splatters
      jarGroup.add(glass);
      
      // === ROUNDED BOTTOM (beveled like a pill) ===
      const bottomRadius = jarRadius * 0.85;
      const bevelRadius = 0.04; // Rounded edge
      
      // Create bottom with TorusGeometry for the rounded edge + flat center
      const bottomCenter = new THREE.CylinderGeometry(bottomRadius - bevelRadius, bottomRadius - bevelRadius, 0.01, 32);
      const bottomCenterMat = new THREE.MeshPhysicalMaterial({ 
        color: 0xdddddd, 
        metalness: 0.1, 
        roughness: 0.3,
        transparent: true,
        opacity: 0.8
      });
      const bottomCenterMesh = new THREE.Mesh(bottomCenter, bottomCenterMat);
      bottomCenterMesh.position.y = bevelRadius * 0.5;
      jarGroup.add(bottomCenterMesh);
      
      // === LID GROUP ===
      const lidGroup = new THREE.Group();
      lidGroup.position.y = 0; // Start at closed position
      
      // Lid main body (slightly domed)
      const lidGeo = new THREE.CylinderGeometry(jarRadius * 1.05, jarRadius * 1.08, 0.05, 32);
      const lidMat = new THREE.MeshStandardMaterial({ 
        color: 0x6b7280, // Dark gray metal
        metalness: 0.6, 
        roughness: 0.3 
      });
      const lid = new THREE.Mesh(lidGeo, lidMat);
      lid.position.y = jarHeight + 0.025; // Position relative to lidGroup
      lidGroup.add(lid);
      
      // === RUBBER SEAL (torus at bottom of lid) ===
      const sealGeo = new THREE.TorusGeometry(jarRadius * 0.98, 0.015, 12, 32);
      const sealMat = new THREE.MeshStandardMaterial({ 
        color: 0x2a2a2a, // Dark rubber
        metalness: 0.0, 
        roughness: 0.9 
      });
      const seal = new THREE.Mesh(sealGeo, sealMat);
      seal.position.y = jarHeight; // At junction between lid and jar
      seal.rotation.x = Math.PI / 2;
      lidGroup.add(seal);
      
      // === DETAILED LID KNOB (cylindrical handle with rounded top) ===
      // Knob base cylinder
      const knobBaseGeo = new THREE.CylinderGeometry(0.035, 0.04, 0.025, 16);
      const knobBase = new THREE.Mesh(knobBaseGeo, lidMat);
      knobBase.position.y = jarHeight + 0.0625;
      lidGroup.add(knobBase);
      
      // Knob top (rounded dome)
      const knobTopGeo = new THREE.SphereGeometry(0.035, 16, 12, 0, Math.PI * 2, 0, Math.PI / 2);
      const knobTop = new THREE.Mesh(knobTopGeo, lidMat);
      knobTop.position.y = jarHeight + 0.075;
      lidGroup.add(knobTop);
      
      // Knob grip rings (decorative)
      for (let i = 0; i < 2; i++) {
        const ringGeo = new THREE.TorusGeometry(0.038, 0.003, 8, 16);
        const ring = new THREE.Mesh(ringGeo, lidMat);
        ring.position.y = jarHeight + 0.055 + i * 0.012;
        ring.rotation.x = Math.PI / 2;
        lidGroup.add(ring);
      }
      
      jarGroup.add(lidGroup);
      jarGroup.userData.lidGroup = lidGroup;
      jarGroup.userData.lidClosedY = 0; // Store closed position for animations
      
      // Store jar dimensions for collision detection
      jarGroup.userData.jarHeight = 0.5; // Match the new height
      jarGroup.userData.jarRadius = 0.18; // Match the new radius
      jarGroup.userData.jarOpeningY = 0.5; // Top of jar
      
      jarGroup.visible = false; // Start hidden
      jarGroup.userData.isPluckJar = true;
      
      // Create physics collider for jar (cylinder shape)
      // This will be positioned dynamically in the animation loop
      const jarBodyDesc = physics.RigidBodyDesc.fixed();
      const jarPhysicsBody = world.createRigidBody(jarBodyDesc);
      
      // Cylinder collider for jar walls and bottom
      // Make it a sensor so it doesn't physically collide (especially with player)
      const jarColliderDesc = physics.ColliderDesc.cylinder(jarHeight / 2, jarRadius * 0.8)
        .setSensor(true); // Sensor = detects overlaps but no physical collision
      world.createCollider(jarColliderDesc, jarPhysicsBody);
      
      jarGroup.userData.physicsBody = jarPhysicsBody;
      
      // Create environment container for jar contents
      // This acts as the "floor" and parent for all objects in the jar
      const jarEnvironment = new THREE.Group();
      jarEnvironment.position.y = 0; // Bottom of jar is floor plane (y=0)
      jarEnvironment.userData.isJarEnvironment = true;
      jarGroup.add(jarEnvironment);
      jarGroup.userData.environment = jarEnvironment;
      
      // Add "VIRTUAL PETS" tape label on the front of the jar
      const label = createJarLabel();
      jarGroup.add(label);
      
      return jarGroup;
    }
    
    // Create tape label for jar
    function createJarLabel() {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = 512;
      canvas.height = 192;
      
      // Draw tape background with jagged edges
      ctx.fillStyle = '#f5e6d3'; // Beige tape color
      ctx.strokeStyle = '#d4c5b0'; // Darker edge
      ctx.lineWidth = 2;
      
      // Create jagged tape shape
      ctx.beginPath();
      ctx.moveTo(10, 0);
      
      // Top edge with jagged pattern
      for (let x = 10; x < canvas.width - 10; x += 15) {
        ctx.lineTo(x + 7, Math.random() * 8 + 2);
        ctx.lineTo(x + 15, Math.random() * 8 + 2);
      }
      ctx.lineTo(canvas.width - 10, 0);
      ctx.lineTo(canvas.width - 10, canvas.height);
      
      // Bottom edge with jagged pattern
      for (let x = canvas.width - 10; x > 10; x -= 15) {
        ctx.lineTo(x - 7, canvas.height - (Math.random() * 8 + 2));
        ctx.lineTo(x - 15, canvas.height - (Math.random() * 8 + 2));
      }
      ctx.lineTo(10, canvas.height);
      ctx.lineTo(10, 0);
      ctx.closePath();
      
      ctx.fill();
      ctx.stroke();
      
      // Add tape texture (subtle lines)
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.05)';
      ctx.lineWidth = 1;
      for (let i = 0; i < 20; i++) {
        ctx.beginPath();
        ctx.moveTo(0, Math.random() * canvas.height);
        ctx.lineTo(canvas.width, Math.random() * canvas.height);
        ctx.stroke();
      }
      
      // Draw handwritten text "VIRTUAL PETS"
      ctx.fillStyle = '#2a2a2a'; // Dark gray/black
      ctx.font = 'bold 64px "Comic Sans MS", "Brush Script MT", cursive';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      // Add slight rotation and variation to make it look handwritten
      ctx.save();
      ctx.translate(canvas.width / 2, canvas.height / 2);
      ctx.rotate(-0.03); // Slight tilt
      ctx.fillText('VIRTUAL PETS', 0, 0);
      ctx.restore();
      
      // Create texture and material
      const texture = new THREE.CanvasTexture(canvas);
      texture.needsUpdate = true;
      
      const labelMat = new THREE.MeshBasicMaterial({
        map: texture,
        transparent: true,
        side: THREE.DoubleSide,
        depthWrite: true
      });
      
      // Create CURVED label that wraps around the jar cylinder
      const jarRadius = 0.18;
      const labelHeight = 0.075; // 7.5cm tall
      const labelArcAngle = Math.PI * 0.35; // Arc spans ~63 degrees (35% of circle)
      
      // Create curved cylinder segment for the label
      const labelGeo = new THREE.CylinderGeometry(
        jarRadius * 1.01, // Top radius (slightly larger than jar)
        jarRadius * 1.01, // Bottom radius
        labelHeight,      // Height
        32,               // Radial segments for smoothness
        1,                // Height segments
        true,             // Open ended
        Math.PI - labelArcAngle / 2, // Start angle (centered on back)
        labelArcAngle     // Arc angle
      );
      
      const label = new THREE.Mesh(labelGeo, labelMat);
      
      // Position at mid-height of jar
      label.position.set(0, 0.25, 0);
      
      // Set render order so label always appears on top of splatters
      label.renderOrder = 1; // Label renders after splatters (renderOrder 0)
      
      label.userData.isLabel = true;
      
      return label;
    }
    
    // Create pixelated splatter texture
    function createSplatterTexture(color) {
      const canvas = document.createElement('canvas');
      const size = 64; // Pixelated resolution
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      
      // Convert hex color to RGB
      const r = (color >> 16) & 255;
      const g = (color >> 8) & 255;
      const b = color & 255;
      
      // Clear canvas
      ctx.clearRect(0, 0, size, size);
      
      // Draw pixelated splatter pattern
      const centerX = size / 2;
      const centerY = size / 2;
      const mainRadius = size * 0.35;
      
      // Draw main splatter blob with pixelated edges
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const dx = x - centerX;
          const dy = y - centerY;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          // Pixelated organic shape
          const noise = Math.sin(x * 0.5) * Math.cos(y * 0.5) * 3;
          const threshold = mainRadius + noise;
          
          if (dist < threshold) {
            // Vary opacity for depth
            const opacity = 0.6 + (1 - dist / threshold) * 0.4;
            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${opacity})`;
            ctx.fillRect(x, y, 1, 1);
          }
        }
      }
      
      // Add random splatter droplets
      const dropletCount = 5 + Math.floor(Math.random() * 5);
      for (let i = 0; i < dropletCount; i++) {
        const angle = Math.random() * Math.PI * 2;
        const distance = mainRadius * 0.8 + Math.random() * mainRadius * 0.5;
        const dropX = centerX + Math.cos(angle) * distance;
        const dropY = centerY + Math.sin(angle) * distance;
        const dropSize = 2 + Math.floor(Math.random() * 3);
        
        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.7)`;
        ctx.fillRect(Math.floor(dropX), Math.floor(dropY), dropSize, dropSize);
      }
      
      // Add drip trails
      const dripCount = 2 + Math.floor(Math.random() * 3);
      for (let i = 0; i < dripCount; i++) {
        const startX = centerX + (Math.random() - 0.5) * mainRadius;
        const startY = centerY + mainRadius * 0.5;
        const dripLength = 8 + Math.floor(Math.random() * 12);
        const dripWidth = 2 + Math.floor(Math.random() * 2);
        
        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.6)`;
        for (let d = 0; d < dripLength; d++) {
          ctx.fillRect(
            Math.floor(startX - dripWidth / 2),
            Math.floor(startY + d),
            dripWidth,
            1
          );
        }
      }
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.needsUpdate = true;
      // Nearest filtering for pixelated look
      texture.magFilter = THREE.NearestFilter;
      texture.minFilter = THREE.NearestFilter;
      
      return texture;
    }
    
    // Create a splatter decal on the jar glass
    function createSplatter(color, angle, height) {
      const jarRadius = 0.18;
      const jarHeight = 0.5;
      
      // Create pixelated splatter texture
      const splatterTexture = createSplatterTexture(color);
      
      // Random splatter size
      const splatterSize = 0.04 + Math.random() * 0.04; // Random size 4-8cm
      console.log(`üí• Creating wrapped pixelated splatter: ${splatterSize.toFixed(3)}m size with texture`);
      
      // Height in jar group space (convert from jar environment local coords)
      // Clamp to jar walls (not on bottom or lid)
      const minY = 0.08; // Just above bottom
      const maxY = jarHeight - 0.08; // Just below lid
      const y = Math.max(minY, Math.min(maxY, height + jarHeight / 2));
      
      // Create OPAQUE splatter material (visible through transparent glass)
      const splatterMat = new THREE.MeshBasicMaterial({
        map: splatterTexture,
        transparent: true, // Still need transparency for texture alpha
        side: THREE.DoubleSide,
        depthWrite: true, // Write to depth buffer so it occludes properly
        depthTest: true, // Test depth so it renders correctly
        alphaTest: 0.1 // Discard fully transparent pixels
      });
      
      // Create CURVED splatter that wraps around the jar cylinder (like the tape label)
      const splatterArcAngle = Math.PI * 0.2 * (splatterSize / 0.06); // Arc size based on splatter size
      const splatterGeo = new THREE.CylinderGeometry(
        jarRadius * 1.02, // Top radius (slightly outside glass)
        jarRadius * 1.02, // Bottom radius
        splatterSize,     // Height (vertical size of splatter)
        32,               // Radial segments for smoothness
        1,                // Height segments
        true,             // Open ended
        angle - splatterArcAngle / 2, // Start angle (centered on impact angle)
        splatterArcAngle  // Arc angle
      );
      
      const splatter = new THREE.Mesh(splatterGeo, splatterMat);
      
      // Position at impact height
      splatter.position.set(0, y, 0);
      
      // Set render order so tape label renders on top of splatters
      splatter.renderOrder = 0; // Splatters render first
      
      // Create drip that extends from bottom of splatter
      const dripMaxLength = 0.08 + Math.random() * 0.06; // Max drip length 8-14cm
      const dripWidth = splatterSize * 0.15; // Drip is narrow compared to splatter
      
      // Drip geometry - thin cylinder that will scale downward
      const dripGeo = new THREE.CylinderGeometry(
        jarRadius * 1.02,    // Top radius (match jar surface)
        jarRadius * 1.02,    // Bottom radius
        dripMaxLength,       // Max height
        32,                  // Radial segments
        1,                   // Height segments
        true,                // Open ended
        angle - splatterArcAngle / 2, // Match splatter angle
        splatterArcAngle * 0.3 // Narrower than splatter
      );
      
      // Darker material for drip (looks like thicker liquid)
      const dripMat = new THREE.MeshBasicMaterial({
        color: color,
        transparent: true,
        opacity: 0.8,
        side: THREE.DoubleSide,
        depthWrite: true,
        depthTest: true
      });
      
      const drip = new THREE.Mesh(dripGeo, dripMat);
      
      // Position drip at bottom of splatter, initially scaled to 0 (no drip yet)
      drip.position.set(0, -splatterSize / 2 - dripMaxLength / 2, 0);
      drip.scale.y = 0; // Start with no drip
      drip.renderOrder = 0;
      
      splatter.add(drip); // Add drip as child of splatter
      
      // Animation data for dripping effect
      splatter.userData.isSplatter = true;
      splatter.userData.drip = drip; // Store reference to drip mesh
      splatter.userData.dripStartTime = performance.now(); // When drip animation starts
      splatter.userData.dripDuration = 800 + Math.random() * 400; // Drip for 800-1200ms
      splatter.userData.dripMaxLength = dripMaxLength; // Maximum drip length
      splatter.userData.isAnimating = true; // Flag to track if still animating
      
      return splatter;
    }
    
    // Create dialogue card for pedestrian with word wrapping
    function createDialogueCard(text) {
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      canvas.width = 512;
      
      // Set font first to measure text
      context.font = 'bold 42px Arial';
      
      // Word wrap the text
      const maxWidth = canvas.width - 40; // Padding
      const lineHeight = 50;
      const words = text.split(' ');
      const lines = [];
      let currentLine = words[0];
      
      for (let i = 1; i < words.length; i++) {
        const word = words[i];
        const testLine = currentLine + ' ' + word;
        const metrics = context.measureText(testLine);
        
        if (metrics.width > maxWidth) {
          lines.push(currentLine);
          currentLine = word;
        } else {
          currentLine = testLine;
        }
      }
      lines.push(currentLine);
      
      // Calculate required height based on number of lines
      const padding = 30;
      const requiredHeight = Math.max(128, lines.length * lineHeight + padding * 2);
      canvas.height = requiredHeight;
      
      // Draw card background (white rounded rect)
      context.fillStyle = 'white';
      context.strokeStyle = '#333333';
      context.lineWidth = 4;
      
      // Rounded rectangle
      const radius = 15;
      context.beginPath();
      context.moveTo(radius, 0);
      context.lineTo(canvas.width - radius, 0);
      context.quadraticCurveTo(canvas.width, 0, canvas.width, radius);
      context.lineTo(canvas.width, canvas.height - radius);
      context.quadraticCurveTo(canvas.width, canvas.height, canvas.width - radius, canvas.height);
      context.lineTo(radius, canvas.height);
      context.quadraticCurveTo(0, canvas.height, 0, canvas.height - radius);
      context.lineTo(0, radius);
      context.quadraticCurveTo(0, 0, radius, 0);
      context.closePath();
      context.fill();
      context.stroke();
      
      // Draw text (black, bold, centered) with multiple lines
      context.fillStyle = 'black';
      context.font = 'bold 42px Arial';
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      
      // Draw each line centered
      const startY = canvas.height / 2 - ((lines.length - 1) * lineHeight) / 2;
      for (let i = 0; i < lines.length; i++) {
        context.fillText(lines[i], canvas.width / 2, startY + i * lineHeight);
      }
      
      // Create texture and material
      const texture = new THREE.CanvasTexture(canvas);
      texture.needsUpdate = true;
      
      const material = new THREE.MeshBasicMaterial({
        map: texture,
        transparent: true,
        opacity: 1.0,
        side: THREE.DoubleSide,
        depthWrite: false,
        depthTest: false // Render on top of everything
      });
      
      console.log(`üó£Ô∏è Material created - transparent: ${material.transparent}, opacity: ${material.opacity}, depthTest: ${material.depthTest}`);
      
      // Card dimensions based on content
      const cardWidth = 1.5; // 1.5m wide
      const cardHeight = (requiredHeight / 128) * 0.35; // Scale height based on content
      const geometry = new THREE.PlaneGeometry(cardWidth, cardHeight);
      const card = new THREE.Mesh(geometry, material);
      
      // Set high render order to appear on top
      card.renderOrder = 9999;
      card.visible = true;
      
      card.userData.isDialogueCard = true;
      card.userData.text = text;
      card.userData.createdAt = performance.now();
      
      console.log(`üó£Ô∏è Created dialogue card mesh with text: "${text}", visible: ${card.visible}, renderOrder: ${card.renderOrder}, lines: ${lines.length}`);
      
      return card;
    }
    
    // Update or create dialogue for a pedestrian
    function updatePedestrianDialogue(pedMesh, state, jarObj = null) {
      console.log(`üó£Ô∏è updatePedestrianDialogue called - state: ${state}, pedMesh:`, pedMesh);
      
      // Remove existing dialogue if any
      const existingCard = pedMesh.children.find(child => child.userData.isDialogueCard);
      if (existingCard) {
        // Check if we should keep the same state or change it
        if (existingCard.userData.dialogueState === state) {
          // Same state, keep existing if not too old
          const age = performance.now() - existingCard.userData.createdAt;
          if (age < 3000) {
            console.log(`üó£Ô∏è Keeping existing card (age: ${age}ms)`);
            return; // Keep for 3 seconds
          }
        }
        console.log(`üó£Ô∏è Removing old dialogue card`);
        pedMesh.remove(existingCard);
        if (existingCard.geometry) existingCard.geometry.dispose();
        if (existingCard.material) {
          if (existingCard.material.map) existingCard.material.map.dispose();
          existingCard.material.dispose();
        }
      }
      
      // Randomly decide if this pedestrian should speak (30% chance)
      const shouldSpeak = Math.random() <= 0.3;
      console.log(`üó£Ô∏è Should speak? ${shouldSpeak} (30% chance)`);
      if (!shouldSpeak) return;
      
      // Determine dialogue stage based on plea count (for jar closed mode)
      // Stages: Panic (0-3) -> Negotiation (4-7) -> Apology (8+)
      let actualState = state;
      if (state === 'jarClosed' && jarObj) {
        // Initialize plea counter if needed
        if (jarObj.pleaCount === undefined) {
          jarObj.pleaCount = 0;
        }
        
        // Increment plea counter
        jarObj.pleaCount++;
        console.log(`üó£Ô∏è Plea count for this pedestrian: ${jarObj.pleaCount}`);
        
        // Progress through stages: Panic -> Negotiation -> Apology
        if (jarObj.pleaCount <= 3) {
          actualState = 'jarClosed'; // Panic stage (0-3 pleas)
        } else if (jarObj.pleaCount <= 7) {
          actualState = 'jarClosedNegotiation'; // Bargaining stage (4-7 pleas)
        } else {
          actualState = 'jarClosedApology'; // Apology stage (8+ pleas)
        }
        
        console.log(`üó£Ô∏è Dialogue stage: ${actualState}`);
      }
      
      // Select random phrase from appropriate state
      const phrases = DIALOGUE_PHRASES[actualState];
      if (!phrases || phrases.length === 0) {
        console.log(`üó£Ô∏è No phrases found for state: ${actualState}`);
        return;
      }
      
      // Determine if we need singular or plural
      const livingPedCount = jarObjects.filter(obj => obj.isPedestrian && !obj.isBurst).length;
      const isPlural = livingPedCount > 1;
      
      // Select random phrase and apply singular/plural
      const phraseEntry = phrases[Math.floor(Math.random() * phrases.length)];
      let finalPhrase;
      if (typeof phraseEntry === 'string') {
        // Simple string (for plucked state)
        finalPhrase = phraseEntry;
      } else {
        // Object with singular/plural variants
        finalPhrase = isPlural ? phraseEntry.plural : phraseEntry.singular;
      }
      
      // Turn pedestrian to face camera/player before speaking
      if (jarObj && pluckJar) {
        // Get camera position in jar's local space
        const jarWorldPos = new THREE.Vector3();
        pluckJar.getWorldPosition(jarWorldPos);
        
        const camWorldPos = new THREE.Vector3();
        camera.getWorldPosition(camWorldPos);
        
        // Calculate angle from pedestrian to camera in XZ plane
        const pedWorldPos = new THREE.Vector3();
        pedMesh.getWorldPosition(pedWorldPos);
        
        const dx = camWorldPos.x - pedWorldPos.x;
        const dz = camWorldPos.z - pedWorldPos.z;
        const targetAngle = Math.atan2(dx, dz);
        
        // Smoothly rotate pedestrian to face camera (store target angle)
        if (!pedMesh.userData.targetRotationY) {
          pedMesh.userData.targetRotationY = targetAngle;
        }
        pedMesh.userData.targetRotationY = targetAngle;
        
        console.log(`üó£Ô∏è Pedestrian turning to face camera (angle: ${targetAngle.toFixed(2)})`);
      }
      
      console.log(`üó£Ô∏è Creating dialogue card: "${finalPhrase}" (${isPlural ? 'plural' : 'singular'}, ${livingPedCount} pedestrian(s))`);
      const card = createDialogueCard(finalPhrase);
      card.userData.dialogueState = actualState;
      
      // Position card MUCH higher above pedestrian's head (cards are now 1.5m wide!)
      card.position.set(0, 0.5, 0); // 50cm above pedestrian center for large cards
      
      // Ensure card scale is consistent
      card.scale.set(1, 1, 1);
      
      pedMesh.add(card);
      
      // Force update matrices
      card.updateMatrix();
      card.updateMatrixWorld(true);
      
      console.log(`üó£Ô∏è Dialogue card added to pedMesh!`, {
        position: card.position,
        worldPosition: card.getWorldPosition(new THREE.Vector3()),
        parent: pedMesh.name || 'unnamed',
        parentVisible: pedMesh.visible,
        cardVisible: card.visible,
        scale: card.scale,
        inScene: card.parent !== null
      });
    }
    
    // Update all dialogue cards (billboard to face camera)
    let lastDialogueDebugTime = 0;
    function updateDialogueCards() {
      const now = performance.now();
      const shouldDebug = now - lastDialogueDebugTime > 1000; // Log once per second
      
      // Update plucked object dialogue
      if (draggingObject) {
        const isPedestrian = pedestrians.find(p => p.group === draggingObject);
        if (shouldDebug) console.log(`üó£Ô∏è Dragging object detected. Is pedestrian? ${!!isPedestrian}`);
        if (isPedestrian) {
          updatePedestrianDialogue(draggingObject, 'plucked');
        }
      }
      
      // Update jar object dialogue
      if (shouldDebug) {
        console.log(`üó£Ô∏è Checking jar objects - count: ${jarObjects.length}, jarState: ${jarState}`);
        lastDialogueDebugTime = now;
      }
      jarObjects.forEach((jarObj, index) => {
        if (jarObj.isPedestrian && jarObj.mesh && !jarObj.isBurst) {
          const state = jarState === 2 ? 'jarClosed' : 'jarOpen';
          if (shouldDebug) console.log(`üó£Ô∏è Jar object ${index} - pedestrian in jar, state: ${state}`);
          
          // Only update occasionally (every 2-4 seconds)
          if (!jarObj.lastDialogueUpdate || now - jarObj.lastDialogueUpdate > 2000 + Math.random() * 2000) {
            console.log(`üó£Ô∏è Updating jar object ${index} dialogue`);
            // Pass jarObj so we can track plea count
            updatePedestrianDialogue(jarObj.mesh, state, jarObj);
            jarObj.lastDialogueUpdate = now;
          } else if (shouldDebug) {
            console.log(`üó£Ô∏è Jar object ${index} dialogue on cooldown`);
          }
        }
      });
      
      // Billboard all dialogue cards to face camera
      let cardCount = 0;
      let removedCount = 0;
      scene.traverse(obj => {
        if (obj.userData.isDialogueCard && obj.parent) {
          cardCount++;
          
          if (cardCount === 1 && shouldDebug) {
            console.log(`üó£Ô∏è Found dialogue card:`, {
              text: obj.userData.text,
              visible: obj.visible,
              parent: obj.parent.name || 'unnamed',
              renderOrder: obj.renderOrder,
              material: obj.material ? 'exists' : 'missing'
            });
          }
          
          // Get world position of card
          const cardWorldPos = new THREE.Vector3();
          obj.getWorldPosition(cardWorldPos);
          
          // Get camera position
          const camWorldPos = new THREE.Vector3();
          camera.getWorldPosition(camWorldPos);
          
          // Make card always face camera (billboard effect) - Y-axis only to keep rectangular
          // Calculate direction from card to camera in XZ plane only
          const dx = camWorldPos.x - cardWorldPos.x;
          const dz = camWorldPos.z - cardWorldPos.z;
          const angleY = Math.atan2(dx, dz);
          
          // Set rotation to face camera but stay upright (only Y rotation)
          // Add PI to flip the card to face the correct direction
          obj.rotation.set(0, angleY + Math.PI, 0);
          
          // Ensure visibility and scale based on inspect mode
          if (!obj.visible) {
            obj.visible = true;
            if (shouldDebug) console.log(`üó£Ô∏è Forcibly showing hidden dialogue card`);
          }
          
          // Scale up dialogue cards in inspect mode (slightly reduced from 3x)
          if (jarInspectMode && obj.parent && obj.parent.userData.isInJar) {
            // In inspect mode, make cards bigger for readability
            obj.scale.set(2.2, 2.2, 2.2); // 2.2x larger in inspect mode (reduced from 3x)
          } else if (obj.parent && obj.parent.userData.isInJar) {
            // Normal size for jar objects
            obj.scale.set(1, 1, 1);
          } else {
            // Regular scale for non-jar objects
            obj.scale.set(1, 1, 1);
          }
          
          // Remove old cards (after 3-5 seconds)
          const age = now - obj.userData.createdAt;
          const maxAge = 3000 + Math.random() * 2000;
          if (age > maxAge) {
            console.log(`üó£Ô∏è Removing old dialogue card (age: ${age}ms)`);
            removedCount++;
            if (obj.parent) {
              obj.parent.remove(obj);
            }
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) {
              if (obj.material.map) obj.material.map.dispose();
              obj.material.dispose();
            }
          }
        }
      });
      
      if (shouldDebug && (cardCount > 0 || removedCount > 0)) {
        console.log(`üó£Ô∏è Dialogue cards found: ${cardCount}, removed: ${removedCount}`);
      }
    }
    
    // Show reactions from other jar people when splatter occurs
    function showJarPeopleReactions(burstJarObj) {
      if (!pluckJar || !jarObjects || jarObjects.length <= 1) return;
      
      // Reaction phrases for splatter events
      const reactions = [
        "OH MY GOD!",
        "AAAH!",
        "NO, NO!",
        "OH NO!",
        "WHAT THE‚Äî!",
        "GROSS!",
        "EWW!",
        "HELP!",
        "THIS IS HORRIBLE!",
        "NOT AGAIN!",
        "STOP THIS!",
        "PLEASE NO!",
        "OH GOD OH GOD!",
        "NOOOO!",
        "GET ME OUT!"
      ];
      
      // Get all living pedestrians except the one that burst
      const livingPedestrians = jarObjects.filter(obj => 
        obj.isPedestrian && 
        !obj.isBurst && 
        obj !== burstJarObj &&
        obj.mesh
      );
      
      // 30-50% of living pedestrians react
      const reactionChance = 0.3 + Math.random() * 0.2;
      livingPedestrians.forEach(jarObj => {
        if (Math.random() < reactionChance) {
          // Remove existing dialogue if any
          const existingCard = jarObj.mesh.children.find(child => child.userData.isDialogueCard);
          if (existingCard) {
            jarObj.mesh.remove(existingCard);
            if (existingCard.geometry) existingCard.geometry.dispose();
            if (existingCard.material) {
              if (existingCard.material.map) existingCard.material.map.dispose();
              existingCard.material.dispose();
            }
          }
          
          // Create new reaction dialogue
          const randomReaction = reactions[Math.floor(Math.random() * reactions.length)];
          console.log(`üó£Ô∏è Jar person reacting to splatter: "${randomReaction}"`);
          const card = createDialogueCard(randomReaction);
          card.userData.dialogueState = 'splatterReaction';
          card.userData.isEmergencyDialogue = true; // Prevents premature removal
          card.position.set(0, 0.5, 0); // Position above head
          jarObj.mesh.add(card);
          
          // Turn to face camera in panic
          if (pluckJar) {
            const jarWorldPos = new THREE.Vector3();
            pluckJar.getWorldPosition(jarWorldPos);
            
            const camWorldPos = new THREE.Vector3();
            camera.getWorldPosition(camWorldPos);
            
            const pedWorldPos = new THREE.Vector3();
            jarObj.mesh.getWorldPosition(pedWorldPos);
            
            const dx = camWorldPos.x - pedWorldPos.x;
            const dz = camWorldPos.z - pedWorldPos.z;
            const targetAngle = Math.atan2(dx, dz);
            
            jarObj.mesh.userData.targetRotationY = targetAngle;
          }
        }
      });
      
      console.log(`üí• ${Math.floor(livingPedestrians.length * reactionChance)} jar people reacted to the splatter!`);
    }
    
    // Shake jar function
    function shakeJar() {
      if (!jarVisible || !pluckJar) return;
      
      jarShaking = true;
      jarShakeStartTime = performance.now();
      jarLastShakeTime = jarShakeStartTime;
      jarShakePhase = 0; // Reset shake animation phase
      
      console.log('ü´ô Shaking jar!');
      
      // Initialize splatter array if needed
      if (!pluckJar.userData.splatters) {
        pluckJar.userData.splatters = [];
      }
      
      // Mark all objects as needing shake animation - more energetic bouncing!
      // Also check for burst chance
      const BURST_CHANCE = 0.15; // 15% chance per shake
      jarObjects.forEach((jarObj, index) => {
        jarObj.shakeVelocity = {
          x: (Math.random() - 0.5) * 0.8,  // Increased lateral movement
          y: Math.random() * 0.6,           // Increased vertical bouncing
          z: (Math.random() - 0.5) * 0.8   // Increased forward/back movement
        };
        jarObj.shakeRotation = (Math.random() - 0.5) * Math.PI * 1.5; // More rotation
        jarObj.shakeStartTime = jarShakeStartTime;
        jarObj.isSettled = false; // Allow objects to fall again after shake
        jarObj.fallVelocity = 0; // Reset fall velocity
        
        // Burst chance for pedestrians
        if (jarObj.isPedestrian && Math.random() < BURST_CHANCE) {
          jarObj.shouldBurst = true;
          jarObj.burstTime = jarShakeStartTime + Math.random() * 200; // Burst during shake
          
          // Extract shirt color from the mesh
          let shirtColor = 0xff0000; // Default red
          if (jarObj.mesh) {
            jarObj.mesh.traverse(child => {
              if (child.isMesh && child.userData.isShirt) {
                if (child.material && child.material.color) {
                  shirtColor = child.material.color.getHex();
                }
              }
            });
          }
          jarObj.burstColor = shirtColor;
          console.log('üí• Pedestrian marked for burst!');
        }
      });
    }
    
    // Update jar physics and upright knocked-over people
    function updateJarPhysics(deltaTime) {
      if (!pluckJar || jarObjects.length === 0) return;
      
      const now = performance.now();
      
      // Animate jar shaking (up and down motion with side-to-side)
      if (jarShaking) {
        const shakeElapsed = now - jarShakeStartTime;
        const shakeProgress = shakeElapsed / JAR_SHAKE_DURATION;
        
        if (shakeProgress < 1.0) {
          // Pronounced shake with clear up-down movement (3-4 shakes over 500ms)
          const frequency = 7; // Hz - visible shaking motion
          const timeInSeconds = shakeElapsed / 1000;
          jarShakePhase = timeInSeconds * frequency * Math.PI * 2;
          
          // Vertical shake with decreasing amplitude
          const verticalAmplitude = 0.20 * (1 - shakeProgress); // 20cm max drop
          jarBaseOffsetY = Math.sin(jarShakePhase) * verticalAmplitude;
          
          // Add side-to-side shake for realism
          const horizontalAmplitude = 0.08 * (1 - shakeProgress); // 8cm side motion
          jarShakeOffsetX = Math.sin(jarShakePhase * 1.7) * horizontalAmplitude; // Slightly different frequency
        } else {
          // Shake complete
          jarShaking = false;
          jarBaseOffsetY = 0;
          jarShakeOffsetX = 0;
          jarShakePhase = 0;
          console.log('ü´ô Jar shake complete');
        }
      } else {
        jarBaseOffsetY = 0;
        jarShakeOffsetX = 0;
      }
      
      // Check for bursts (pedestrians exploding and leaving splatters)
      for (let i = jarObjects.length - 1; i >= 0; i--) {
        const jarObj = jarObjects[i];
        if (jarObj.shouldBurst && !jarObj.hasBurst && now >= jarObj.burstTime) {
          jarObj.hasBurst = true;
          
          // Create splatters on jar glass around the pedestrian
          // Multiple splatters for a more explosive effect distributed circularly
          const numSplatters = 2 + Math.floor(Math.random() * 3); // 2-4 splatters
          const baseAngle = Math.random() * Math.PI * 2; // Random starting angle
          
          if (!pluckJar.userData.splatters) {
            pluckJar.userData.splatters = [];
          }
          
          for (let s = 0; s < numSplatters; s++) {
            // Spread splatters around a circular arc
            const angleOffset = (s / numSplatters) * Math.PI * 2; // Distribute evenly
            const angleVariation = (Math.random() - 0.5) * 0.5; // Add some randomness
            const splatterAngle = baseAngle + angleOffset + angleVariation;
            
            // Random height offset so splatters aren't perfectly aligned
            const heightOffset = (Math.random() - 0.5) * 0.1;
            const splatterHeight = jarObj.mesh.position.y + heightOffset;
            
            // Add splatter to jar
            const splatter = createSplatter(jarObj.burstColor, splatterAngle, splatterHeight);
            pluckJar.userData.splatters.push(splatter);
            pluckJar.add(splatter);
          }
          
          // Ziya reacts to splatter
          showZiyaDialogue('splatter');
          
          // Other jar people react to splatter with dialogue
          showJarPeopleReactions(jarObj);
          
          // Create burst particle effect using object pool
          const particleCount = 8 + Math.floor(Math.random() * 8); // 8-15 particles
          for (let p = 0; p < particleCount; p++) {
            const particle = particlePool.acquire();
            
            // Setup particle
            particle.visible = true;
            particle.material.color.setHex(jarObj.burstColor);
            particle.material.opacity = 1;
            particle.position.copy(jarObj.mesh.position);
            
            // Random velocity
            particle.userData.velocity = {
              x: (Math.random() - 0.5) * 0.3,
              y: Math.random() * 0.2,
              z: (Math.random() - 0.5) * 0.3
            };
            particle.userData.lifetime = 0;
            particle.userData.maxLifetime = 0.3 + Math.random() * 0.2; // 0.3-0.5s
            particle.userData.isBurstParticle = true;
            
            const jarEnv = pluckJar.userData.environment;
            if (jarEnv) {
              jarEnv.add(particle);
            }
          }
          
          // Instead of removing, make pedestrian horizontal (lying flat)
          jarObj.mesh.rotation.set(Math.PI / 2, 0, 0); // Rotate to lie flat (90 degrees around X-axis)
          
          // Store random Y rotation for spinning on floor
          jarObj.floorRotation = Math.random() * Math.PI * 2;
          jarObj.mesh.rotation.y = jarObj.floorRotation;
          
          // Mark as burst so it stays horizontal
          jarObj.isBurst = true;
          jarObj.isPedestrian = false; // No longer acts as living pedestrian
          
          // Reset position to floor
          jarObj.mesh.position.y = 0.02; // On the jar floor
          jarObj.localPosition.y = 0.02;
          
          // Give it shake properties so it moves with other objects
          jarObj.shakeVelocity = {
            x: (Math.random() - 0.5) * 0.5,
            y: 0, // No vertical movement for burst bodies
            z: (Math.random() - 0.5) * 0.5
          };
          
          console.log('üí• Pedestrian burst! Body now horizontal, splatters added to jar. Rotation:', {
            x: jarObj.mesh.rotation.x,
            y: jarObj.mesh.rotation.y,
            z: jarObj.mesh.rotation.z
          });
        }
      }
      
      // Process each object in the jar (visual-only, no physics bodies)
      if (jarShaking) {
          // Apply shake animation to objects - more energetic with bouncing!
          const jarRadius = (pluckJar.userData.jarRadius || 0.18) * 0.8; // Use 80% of jar radius for bounds
          
          jarObjects.forEach(jarObj => {
            if (jarObj.shakeVelocity) {
              const shakeTime = (now - jarObj.shakeStartTime) / 1000;
              const shakeDamping = Math.max(0, 1 - shakeTime * 1.5); // Decay over ~0.67s
              
              // Calculate shake offset with bouncing in all directions
              let shakeX = jarObj.localPosition.x + jarObj.shakeVelocity.x * Math.sin(shakeTime * 12) * shakeDamping;
              let shakeZ = jarObj.localPosition.z + jarObj.shakeVelocity.z * Math.cos(shakeTime * 11) * shakeDamping;
              
              // Constrain to jar circumference (keep within circular bounds)
              const distFromCenter = Math.sqrt(shakeX * shakeX + shakeZ * shakeZ);
              if (distFromCenter > jarRadius) {
                const scale = jarRadius / distFromCenter;
                shakeX *= scale;
                shakeZ *= scale;
              }
              
              jarObj.mesh.position.x = shakeX;
              jarObj.mesh.position.z = shakeZ;
              
              if (jarObj.isBurst) {
                // Burst bodies stay flat on floor (no vertical bounce)
                jarObj.mesh.position.y = 0.02;
                // Maintain horizontal orientation (no tumbling rotation)
                jarObj.mesh.rotation.set(Math.PI / 2, jarObj.floorRotation, 0);
                // Add sliding rotation effect (spinning on floor)
                jarObj.floorRotation += jarObj.shakeVelocity.x * 0.5 * shakeDamping;
                jarObj.mesh.rotation.y = jarObj.floorRotation;
              } else {
                // Living pedestrians - add vertical bouncing (y-axis)
                const bounceHeight = jarObj.shakeVelocity.y * Math.abs(Math.sin(shakeTime * 18)) * shakeDamping;
                jarObj.mesh.position.y = jarObj.localPosition.y + bounceHeight;
                
                // More dramatic rotation during shake (both Z and X axis for tumbling)
                jarObj.mesh.rotation.x = jarObj.shakeRotation * Math.sin(shakeTime * 13) * shakeDamping * 0.4;
                jarObj.mesh.rotation.z = jarObj.shakeRotation * Math.cos(shakeTime * 14) * shakeDamping * 0.5;
              }
            }
          });
      } else {
        // Walking behavior for pedestrians in jar (when not shaking)
        const jarRadius = (pluckJar.userData.jarRadius || 0.18) * 0.7;
        
        jarObjects.forEach(jarObj => {
          // Burst bodies stay horizontal on floor
          if (jarObj.isBurst) {
            jarObj.mesh.position.y = 0.02;
            jarObj.mesh.rotation.set(Math.PI / 2, jarObj.floorRotation || 0, 0); // Keep fully horizontal
            return; // Skip walking behavior for burst bodies
          }
          
          // Reset shake rotation when not shaking
          if (jarObj.mesh.rotation.z !== 0) {
            jarObj.mesh.rotation.x = 0;
            jarObj.mesh.rotation.z = 0;
          }
          
          // Apply gravity to make objects fall back to floor after shake (skip if already settled)
          if (!jarObj.isSettled) {
            const floorY = jarObj.localPosition.y; // Original floor position
            const currentY = jarObj.mesh.position.y;
            
            if (currentY > floorY + 0.005) {
              // Object is above floor - apply gravity with smoothing
              if (!jarObj.fallVelocity) jarObj.fallVelocity = 0;
              
              // Gravity with damping for smooth landing
              const gravity = -1.2;
              const damping = 0.92; // Air resistance
              
              jarObj.fallVelocity = (jarObj.fallVelocity + gravity * deltaTime) * damping;
              
              // Apply velocity with clamping
              const newY = currentY + jarObj.fallVelocity * deltaTime;
              
              // Stop at floor with smooth landing
              if (newY <= floorY) {
                jarObj.mesh.position.y = floorY;
                jarObj.fallVelocity = 0;
                jarObj.isSettled = true; // Mark as settled
              } else {
                jarObj.mesh.position.y = newY;
              }
            } else {
              // Snap to floor if very close
              jarObj.mesh.position.y = floorY;
              jarObj.fallVelocity = 0;
              jarObj.isSettled = true;
            }
          }
          
          if (jarObj.isPedestrian) {
            // Initialize walking state if needed
            if (!jarObj.walkAngle) {
              jarObj.walkAngle = Math.random() * Math.PI * 2;
              jarObj.walkDirection = Math.random() > 0.5 ? 1 : -1;
              jarObj.gait = 0; // Walking animation phase
            }
            
            // Walk in circle around jar center (in local jar coordinates)
            jarObj.walkAngle += jarObj.walkDirection * jarObj.walkSpeed * deltaTime;
            
            const targetX = Math.cos(jarObj.walkAngle) * jarRadius;
            const targetZ = Math.sin(jarObj.walkAngle) * jarRadius;
            
            // Move towards target
            const dx = targetX - jarObj.mesh.position.x;
            const dz = targetZ - jarObj.mesh.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);
            
            if (dist > 0.01) {
              const moveSpeed = jarObj.walkSpeed * deltaTime;
              jarObj.mesh.position.x += (dx / dist) * moveSpeed;
              jarObj.mesh.position.z += (dz / dist) * moveSpeed;
            }
            
            // Face walking direction (tangent to circle) OR face camera if speaking
            let targetRotation;
            if (jarObj.mesh.userData.targetRotationY !== undefined) {
              // Smoothly turn to face camera for dialogue
              targetRotation = jarObj.mesh.userData.targetRotationY;
              jarObj.mesh.rotation.y = THREE.MathUtils.lerp(
                jarObj.mesh.rotation.y,
                targetRotation,
                3 * deltaTime // Smooth turn speed
              );
            } else {
              // Normal walking - face tangent direction
              const tangentAngle = jarObj.walkAngle + (jarObj.walkDirection > 0 ? Math.PI / 2 : -Math.PI / 2);
              jarObj.mesh.rotation.y = tangentAngle;
            }
            
            // FULL WALKING ANIMATION (like full-sized pedestrians)
            jarObj.gait += 4.0 * deltaTime;
            const stepAmp = 0.6;
            
            // Find limbs in the mesh
            let legL, legR, armL, armR, torso;
            jarObj.mesh.traverse(child => {
              if (child.userData.isLegL) legL = child;
              if (child.userData.isLegR) legR = child;
              if (child.userData.isArmL) armL = child;
              if (child.userData.isArmR) armR = child;
              if (child.userData.isTorso) torso = child;
            });
            
            // Animate legs
            if (legL && legL.userData.thigh && legL.userData.shinPivot) {
              const leftThighTarget = Math.sin(jarObj.gait) * stepAmp;
              legL.rotation.x = THREE.MathUtils.lerp(
                legL.rotation.x || 0,
                leftThighTarget,
                10 * deltaTime
              );
              const leftShinTarget = Math.max(0, -Math.sin(jarObj.gait) * stepAmp * 0.6);
              legL.userData.shinPivot.rotation.x = THREE.MathUtils.lerp(
                legL.userData.shinPivot.rotation.x || 0,
                leftShinTarget,
                10 * deltaTime
              );
            }
            
            if (legR && legR.userData.thigh && legR.userData.shinPivot) {
              const rightThighTarget = -Math.sin(jarObj.gait) * stepAmp;
              legR.rotation.x = THREE.MathUtils.lerp(
                legR.rotation.x || 0,
                rightThighTarget,
                10 * deltaTime
              );
              const rightShinTarget = Math.max(0, Math.sin(jarObj.gait) * stepAmp * 0.6);
              legR.userData.shinPivot.rotation.x = THREE.MathUtils.lerp(
                legR.userData.shinPivot.rotation.x || 0,
                rightShinTarget,
                10 * deltaTime
              );
            }
            
            // Animate arms
            if (armL && armL.userData.upper && armL.userData.forearmPivot) {
              const leftArmTarget = -Math.sin(jarObj.gait) * 0.4;
              armL.rotation.x = THREE.MathUtils.lerp(
                armL.rotation.x || 0,
                leftArmTarget,
                8 * deltaTime
              );
              const leftForearmTarget = -Math.abs(Math.sin(jarObj.gait)) * 0.2 - 0.1;
              armL.userData.forearmPivot.rotation.x = THREE.MathUtils.lerp(
                armL.userData.forearmPivot.rotation.x || 0,
                leftForearmTarget,
                8 * deltaTime
              );
            }
            
            if (armR && armR.userData.upper && armR.userData.forearmPivot) {
              const rightArmTarget = Math.sin(jarObj.gait) * 0.4;
              armR.rotation.x = THREE.MathUtils.lerp(
                armR.rotation.x || 0,
                rightArmTarget,
                8 * deltaTime
              );
              const rightForearmTarget = -Math.abs(Math.sin(jarObj.gait + Math.PI)) * 0.2 - 0.1;
              armR.userData.forearmPivot.rotation.x = THREE.MathUtils.lerp(
                armR.userData.forearmPivot.rotation.x || 0,
                rightForearmTarget,
                8 * deltaTime
              );
            }
            
            // Torso bob
            if (torso) {
              const baseTorsoY = torso.userData.baseY || (torso.geometry.parameters.height / 2);
              const bobAmount = Math.abs(Math.sin(jarObj.gait * 2)) * 0.01;
              torso.position.y = baseTorsoY + bobAmount;
            }
            
            // Update local position
            jarObj.localPosition.x = jarObj.mesh.position.x;
            jarObj.localPosition.z = jarObj.mesh.position.z;
          }
        });
      }
      
      // Animate burst particles
      const jarEnv = pluckJar.userData.environment;
      if (jarEnv) {
        const particlesToRemove = [];
        jarEnv.traverse(child => {
          if (child.userData.isBurstParticle) {
            child.userData.lifetime += deltaTime;
            
            // Apply velocity
            child.position.x += child.userData.velocity.x * deltaTime;
            child.position.y += child.userData.velocity.y * deltaTime;
            child.position.z += child.userData.velocity.z * deltaTime;
            
            // Gravity
            child.userData.velocity.y -= 0.5 * deltaTime;
            
            // Fade out
            const lifetimeRatio = child.userData.lifetime / child.userData.maxLifetime;
            if (child.material) {
              child.material.opacity = Math.max(0, 1 - lifetimeRatio);
            }
            
            // Mark for removal when lifetime exceeded
            if (child.userData.lifetime >= child.userData.maxLifetime) {
              particlesToRemove.push(child);
            }
          }
        });
        
        // Remove expired particles and return to pool
        particlesToRemove.forEach(particle => {
          jarEnv.remove(particle);
          particlePool.release(particle);
        });
      }
    }
    
    // Raycasting
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    
    // Lasso / Grappling Hook System
    let lassoEnabled = false;
    let lassoVisual = null;
    let grapplingHook = null;
    let swingRope = null;
    let ropeVisual = null;
    
    // Bike System
    let bikeEnabled = false;
    let bikeBody = null;
    let bikeMesh = null;
    let bikeSpeed = 0;
    let bikeTargetSpeed = 0;
    const BIKE_MAX_SPEED = 65; // Increased from 35 to 65
    const BIKE_ACCEL = 35; // Increased from 25 to 35
    const BIKE_TURN_RATE = 2.5;
    let bikeTrailMesh = null;
    let bikeTrailPoints = [];
    const BIKE_TRAIL_MAX_POINTS = 100;
    let bikeAutoPilot = true; // Bike drives itself by default
    let permanentTrails = []; // Store trails when exiting bike
    let bikeWheelRotation = 0; // Track wheel rotation
    let bikeWheelieAngle = 0; // Track wheelie tilt
    let bikeJumpVelocity = 0; // Track jump state
    let bikeWheelieProgress = 0; // 0 to 1, tracks wheelie state
    let bikeCanJump = false; // True when wheelie is at max
    let bikeWallRiding = false; // True when riding on wall
    
    // Ant System
    let ants = []; // Array of ant instances
    let antUpdateFunctions = []; // Update functions for each ant
    let bikeWallNormal = new THREE.Vector3(); // Wall surface normal
    
    // Pedestrian System
    const pedestrians = [];
    const pedestrianDatabase = new Map(); // id -> full character data
    const buildingDatabase = new Map(); // building mesh -> building data
    
    const firstNamesMale = [
      'James', 'Michael', 'Robert', 'David', 'John', 'William', 'Richard', 'Thomas', 
      'Daniel', 'Matthew', 'Anthony', 'Christopher', 'Joseph', 'Andrew', 'Ryan', 
      'Jason', 'Kevin', 'Brian', 'Eric', 'Steven', 'Paul', 'Mark', 'Kenneth', 'Joshua'
    ];
    
    const firstNamesFemale = [
      'Mary', 'Jennifer', 'Lisa', 'Linda', 'Patricia', 'Susan', 'Jessica', 'Sarah', 
      'Karen', 'Nancy', 'Margaret', 'Emily', 'Elizabeth', 'Michelle', 'Amanda', 
      'Ashley', 'Melissa', 'Nicole', 'Rebecca', 'Laura', 'Stephanie', 'Angela', 'Rachel', 'Samantha'
    ];
    
    const lastNames = [
      'Smith', 'Johnson', 'Williams', 'Brown', 'Jones', 'Garcia', 'Miller', 'Davis', 
      'Rodriguez', 'Martinez', 'Hernandez', 'Lopez', 'Gonzalez', 'Wilson', 'Anderson', 
      'Thomas', 'Taylor', 'Moore', 'Jackson', 'Martin', 'Lee', 'Thompson', 'White', 'Harris',
      'Clark', 'Lewis', 'Robinson', 'Walker', 'Young', 'Allen', 'King', 'Wright', 'Scott',
      'Torres', 'Nguyen', 'Hill', 'Flores', 'Green', 'Adams', 'Nelson', 'Baker', 'Hall', 'Rivera'
    ];
    
    const occupations = [
      'Analyst', 'Courier', 'Engineer', 'Archivist', 'Technician', 'Driver', 'Chef', 
      'Barista', 'Accountant', 'Researcher', 'Consultant', 'Inspector', 'Medic', 
      'Nurse', 'Receptionist', 'Librarian', 'Architect', 'Professor', 'Student', 
      'Security', 'Officer', 'Writer', 'Editor', 'Teacher', 'Designer', 'Artist',
      'Lawyer', 'Doctor', 'Trader', 'Manager', 'Developer', 'Salesperson', 'Cashier'
    ];
    
    const buildingTypes = ['Apartment', 'Office', 'Shop', 'Restaurant', 'Cafe', 'Bank', 'Hospital', 'School', 'Gym', 'Library'];
    const specialConstructions = ['Playground', 'ParkingLot', 'ParkingGarage']; // Can replace buildings
    
    const buildingNames = {
      Apartment: ['Riverside Apartments', 'Parkview Residences', 'Metro Tower', 'Sunset Heights', 'City Plaza Homes'],
      Office: ['Tech Hub', 'Financial Center', 'Business Plaza', 'Corporate Tower', 'Innovation Building'],
      Shop: ['Corner Market', 'City Goods', 'Main Street Store', 'Quick Shop', 'Urban Mart'],
      Restaurant: ['Bistro 42', 'The Grill House', 'Pasta Palace', 'Sushi Bar', 'Steakhouse'],
      Cafe: ['Coffee Corner', 'Brew & Bite', 'Morning Cup', 'Cafe Central', 'Bean Street'],
      Bank: ['First National', 'City Bank', 'Metro Financial', 'Trust Bank', 'Capital One'],
      Hospital: ['General Hospital', 'Medical Center', 'Health Clinic', 'Emergency Care', 'City Hospital'],
      School: ['Elementary School', 'High School', 'Academy', 'Learning Center', 'Public School'],
      Gym: ['Fitness Club', 'Power Gym', 'Health & Strength', 'Active Life', 'Body Works'],
      Library: ['Public Library', 'City Library', 'Central Library', 'Reading Center', 'Book Haven']
    };
    
    // Routine system (10-minute day cycle)
    const DAY_DURATION = 600; // 10 minutes in seconds
    let currentDayTime = 0; // 0-600 seconds
    
    // Pathfinding grid (for sidewalk navigation)
    const pathGrid = new Map(); // "x,z" -> walkable
    const GRID_CELL_SIZE = 2; // 2m per cell
    
    // Cloud System
    const cloudPrototypes = [];
    const activeClouds = [];
    
    // Rocket System
    let rocketEnabled = false;
    let rocketBody = null;
    let rocketMesh = null;
    let rocketVelocity = 0;
    let rocketAcceleration = 20; // m/s¬≤
    const ROCKET_MAX_SPEED = 200;
    const ATMOSPHERE_ALTITUDE = 150; // Reduced from 500 - atmosphere appears sooner
    const SPACE_ALTITUDE = 300; // Reduced from 1000 - space transition sooner
    const MICRO_LOD_ALTITUDE = 200; // Above clouds - replace detailed chunks with simple instances
    let planetRadius = 2000; // Planet radius for curvature - large sphere in space
    let rocketCameraYaw = 0; // Horizontal orbit angle
    let rocketCameraPitch = 0.3; // Vertical orbit angle (positive = above)
    let rocketCameraDistance = 15; // Distance from rocket
    let rocketTrajectory = new THREE.Vector3(0, 1, 0); // Current direction (starts up)
    let rocketTargetTrajectory = new THREE.Vector3(0, 1, 0); // Target direction for smooth lerp
    let rocketEnginesOn = false; // Track if engines are ignited
    const GRAVITY_RADIUS = 3000; // Distance from planet center where gravity no longer affects rocket
    let microLODActive = false; // Track if we're in micro LOD mode
    let microLODGroup = null; // Group holding simplified city instances
    let savedChunkData = new Map(); // Store chunk keys when in micro LOD mode for restoration
    
    // Time of Day System
    let sun = null;
    let sunLight = null;  // Main directional light for shadows
    let hemiLight = null;
    let ambientLight = null;
    let starField = null;
    let atmosphereLayer = null;
    let planetoidMesh = null;
    let timeOfDay = 12; // 0-24 hours (12 = noon)
    
     // Settings (post-processing disabled by default for performance)
     let postFXEnabled = false;
     let aaEnabled = false;
     let shadowsEnabled = true;
     let fogEnabled = true;
     let motionBlurEnabled = false;
     let motionBlurPass = null;
     let prevCameraPosition = new THREE.Vector3();
     let prevCameraRotation = new THREE.Euler();
     let grassBladesEnabled = false; // Grass blades disabled by default for performance
     
     // Post-processing passes and settings
     let bloomPass = null;
     let bloomEnabled = false;
     let bloomStrength = 0.3;
     let bloomRadius = 0.4;
     let bloomThreshold = 0.5;
     
     let ssaoPass = null;
     let ssaoEnabled = false;
     let ssaoIntensity = 0.5;
     let ssaoRadius = 7;
     
     let dofPass = null;
     let dofEnabled = false;
     let dofFocus = 10.0;
     let dofAperture = 0.01;
     let dofMaxBlur = 0.005;
     
     let filmPass = null;
     let filmEnabled = false;
     let filmIntensity = 0.15;
     let filmGrayscale = false;
     
     let vignettePass = null;
     let vignetteEnabled = false;
     let vignetteIntensity = 0.5;
     let vignetteSoftness = 0.5;
     
     let chromaticAberrationPass = null;
     let chromaticAberrationEnabled = false;
     let chromaticAberrationAmount = 0.002;
     let smaaPass = null;
    
    // Stats
    let frameCount = 0;
    let lastFPSUpdate = 0;
    let fpsValue = 60;
    
    // Global shared materials to prevent WebGL texture unit overflow
    const sharedMaterials = {
      road: new THREE.MeshLambertMaterial({ color: 0x2a2a2a }),
      sidewalk: new THREE.MeshLambertMaterial({ color: 0x666666 }),
      curb: new THREE.MeshLambertMaterial({ color: 0x555555 }),
      laneLine: new THREE.MeshBasicMaterial({ color: 0xFFFF00 }),
      ground: new THREE.MeshLambertMaterial({ color: 0x4a7c59 }),
      building: new THREE.MeshLambertMaterial({ color: 0xcccccc }),
      buildingDark: new THREE.MeshLambertMaterial({ color: 0x888888 }),
      window: new THREE.MeshLambertMaterial({ color: 0x6699cc }),
      windowDark: new THREE.MeshLambertMaterial({ color: 0x2a3a4a }),
      bench: new THREE.MeshLambertMaterial({ color: 0x8b6f47 }),
      lampPost: new THREE.MeshLambertMaterial({ color: 0x444444 }),
      car: new THREE.MeshLambertMaterial({ color: 0xff0000 }),
      pedestrian: new THREE.MeshLambertMaterial({ color: 0x00ff00 }),
      bike: new THREE.MeshLambertMaterial({ color: 0x0000ff }),
      treeTrunk1: new THREE.MeshLambertMaterial({ color: 0x4a3828 }),
      treeTrunk2: new THREE.MeshLambertMaterial({ color: 0x3a2818 }),
      treeTrunk3: new THREE.MeshLambertMaterial({ color: 0x5a4838 }),
      treeFoliage1: new THREE.MeshLambertMaterial({ color: 0x3a5a2a }),
      treeFoliage2: new THREE.MeshLambertMaterial({ color: 0x2a4a1a }),
      treeFoliage3: new THREE.MeshLambertMaterial({ color: 0x4a6a3a })
    };
    
    // ==================== INITIALIZATION ====================
    async function init() {
      console.log('Initializing Pockit Ultra...');
      
      // Initialize Rapier Physics
      await RAPIER.init();
      physics = RAPIER;
      world = new RAPIER.World({ x: 0, y: CONFIG.GRAVITY, z: 0 });
      
      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);
      scene.fog = new THREE.FogExp2(0xBBD5EA, 0.0012); // Reduced density for extended view distance (was 0.006)
      
      // Camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 2000); // Increased far plane for distant skyline
      camera.position.set(0, CONFIG.PLAYER_HEIGHT * 2, 15);
      
      // Renderer
      renderer = new THREE.WebGLRenderer({ 
        antialias: true, 
        powerPreference: 'high-performance',
        stencil: false,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.1;
      document.body.appendChild(renderer.domElement);
      
      // Post-processing (lazy-loaded when enabled)
      composer = null;
      
      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      
       sunLight = new THREE.DirectionalLight(0xFFF5E6, 1.4);
       sunLight.position.set(100, 150, 50);
       sunLight.castShadow = true;
      sunLight.shadow.mapSize.width = 256;  // Very low for best performance
      sunLight.shadow.mapSize.height = 256;
      sunLight.shadow.camera.left = -150;   // Smaller bounds for performance
      sunLight.shadow.camera.right = 150;
      sunLight.shadow.camera.top = 150;
      sunLight.shadow.camera.bottom = -150;
      sunLight.shadow.camera.far = 350;
       sunLight.shadow.bias = -0.0001;
       scene.add(sunLight);
       sun = sunLight; // Alias for compatibility
      
      const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x8B7355, 0.7);
      scene.add(hemiLight);
      
      // World root for scaling
      worldRoot = new THREE.Group();
      scene.add(worldRoot);
      
      // Ground
      createGround();
      
      // Distant skyline buildings (for visual depth) - use global variable so it can be updated dynamically
      distantSkylineGroup = createExpandedDistantSkyline(600); // Start with 600m radius
      worldRoot.add(distantSkylineGroup);
      lastSkylineUpdateRadius = 600;
      console.log('‚úì Distant skyline created');
      
      // Initialize GPU optimization systems
      initializeInstancedManagers();
      
      // Initialize tree prototypes (needed by chunks)
      createTreePrototypes();
      
      // Initialize sidewalk pathfinding grid
      initializeSidewalkGrid();
      
      // Player
      createPlayer();
      
      // Initial city - manually trigger initial chunk load
      // Load starting chunks immediately after player is created
      console.log('Loading initial chunks...');
      const startChunk = getChunkCoords(0, 0); // Center chunk
      const initialRadius = 5; // Load 11x11 grid of chunks initially (larger for seamless exploration)
      for (let dx = -initialRadius; dx <= initialRadius; dx++) {
        for (let dz = -initialRadius; dz <= initialRadius; dz++) {
          const dist = Math.hypot(dx, dz);
          if (dist <= initialRadius) {
            const key = getChunkKey(startChunk.x + dx, startChunk.z + dz);
            if (!activeChunks.has(key)) {
              loadChunk(key);
              activeChunks.add(key);
            }
          }
        }
      }
      console.log(`üèôÔ∏è Loaded ${activeChunks.size} initial chunks in ${Math.ceil(initialRadius * 2 + 1)}x${Math.ceil(initialRadius * 2 + 1)} grid`);
      
      // Portals
      createPortalPair();
      
      // Pluck jar (for dropping plucked objects)
      pluckJar = createPluckJar();
      scene.add(pluckJar); // Add to scene, not worldRoot, so it doesn't scale with world
      
      // Controls & UI
      setupControls();
      setupUI();
      
      // Map system is initialized on first toggle
      
      // Spawn special constructions (playgrounds, parking, hospitals)
      spawnSpecialConstructions();
      
      // Spawn pedestrians - optimized count
      spawnPedestrians(25); // Reduced to 25 for better performance
      
      // Generate and spawn clouds - reduced for performance
      generateCloudPrototypes(3);
      spawnClouds(8);
      
      // Create bike and character Y (rocket + giant finger are lazy-loaded)
      createBike();
      createCharacterY();
      
      // Hide loading
      setTimeout(() => {
        document.getElementById('loading').classList.add('hidden');
      }, 500);
      
      // Start loop
      requestAnimationFrame(animate);
      
      // Initialize interiors group
      if (!interiorsGroup) {
        interiorsGroup = new THREE.Group();
        interiorsGroup.name = 'InteriorsGroup';
      }
      
      // Initialize interiors system with required dependencies (lazy-load module)
      await ensureInteriorsModules();
      initInteriors({
        THREE,
        scene,
        worldRoot,
        playerBody,
        camera,
        raycaster,
        generateInteriorRoom,
        setupAssetLibrary,
        setupRandomizerButton,
        interiorsGroup  // Pass the group to the init function
      });
      
      console.log('Pockit Ultra initialized!');
    }
    
    // ==================== GROUND ====================
    function createGround() {
      const groundSize = 800;  // Larger ground for bigger city
      const segments = 40;  // More detail
       const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize, segments, segments);
      
      // Add noise to vertices
      const positions = groundGeometry.attributes.position;
      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const z = positions.getZ(i);
        const noise = (Math.sin(x * 0.05) * Math.cos(z * 0.05) + 
                      Math.sin(x * 0.1) * Math.cos(z * 0.08)) * 0.6;
        positions.setZ(i, noise);
      }
      groundGeometry.computeVertexNormals();
      
      const groundMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x5A7C3A,
        roughness: 0.9,
        metalness: 0.05,
        flatShading: false,
      });
      
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      worldRoot.add(ground);
      
      // Physics ground
      const groundBodyDesc = physics.RigidBodyDesc.fixed();
      const groundBody = world.createRigidBody(groundBodyDesc);
      const groundColliderDesc = physics.ColliderDesc.cuboid(groundSize / 2, 0.1, groundSize / 2);
      world.createCollider(groundColliderDesc, groundBody);
      
      // Grid helper
      const gridHelper = new THREE.GridHelper(groundSize, 60, 0x555555, 0x666666);
      gridHelper.material.opacity = 0.15;
      gridHelper.material.transparent = true;
      worldRoot.add(gridHelper);
    }
    
    // ==================== CHUNK MANAGEMENT SYSTEM ====================
    
    function getChunkKey(x, z) {
      return `${x},${z}`;
    }
    
    function getChunkCoords(worldX, worldZ) {
      const chunkSize = CONFIG.BLOCK_SIZE + CONFIG.ROAD_WIDTH;
      return {
        x: Math.floor(worldX / chunkSize),
        z: Math.floor(worldZ / chunkSize)
      };
    }
    
    let lastChunkUpdate = 0;
    const CHUNK_UPDATE_INTERVAL = 300; // Update chunks every 300ms (faster for better responsiveness)
    const CHUNK_LOAD_PER_FRAME = 4; // Load 4 chunks per update cycle (batch loading for seamless exploration)
    let chunkLoadQueue = []; // Queue of chunks waiting to be loaded
    let lastPlayerChunk = null; // Track last known player chunk to prevent oscillation
    const CHUNK_SWITCH_THRESHOLD = 0.15; // Must be 15% into new chunk before switching (prevents boundary oscillation)
    let initialChunksLoaded = false; // Track if initial chunks have been loaded
    
    function updateChunks() {
      // Skip chunk updates when in micro LOD mode (simplified instances, no detailed chunks)
      if (microLODActive) {
        return;
      }
      
      // Get position from active mode (player, bike, or rocket)
      let playerPos;
      if (rocketEnabled && rocketBody) {
        playerPos = rocketBody.translation();
        // Skip chunk loading when rocket is above 100m (launching into space)
        if (playerPos.y > 100) {
          return;
        }
      } else if (bikeEnabled && bikeBody) {
        playerPos = bikeBody.translation();
      } else if (playerBody) {
        playerPos = playerBody.translation();
      } else {
        return; // No active entity
      }
      
      const currentChunk = getChunkCoords(playerPos.x, playerPos.z);
      
      // Only update player chunk if we've moved significantly into a new chunk
      // This prevents oscillation at chunk boundaries when standing still
      if (lastPlayerChunk) {
        if (currentChunk.x !== lastPlayerChunk.x || currentChunk.z !== lastPlayerChunk.z) {
          // Player has crossed a chunk boundary - check if they're far enough in
          const chunkSize = CONFIG.BLOCK_SIZE + CONFIG.ROAD_WIDTH;
          const chunkCenterX = currentChunk.x * chunkSize + chunkSize / 2;
          const chunkCenterZ = currentChunk.z * chunkSize + chunkSize / 2;
          const distToCenterX = Math.abs(playerPos.x - chunkCenterX) / chunkSize;
          const distToCenterZ = Math.abs(playerPos.z - chunkCenterZ) / chunkSize;
          
          // Only switch chunks if player is at least CHUNK_SWITCH_THRESHOLD into the new chunk
          if (distToCenterX < 0.5 - CHUNK_SWITCH_THRESHOLD && distToCenterZ < 0.5 - CHUNK_SWITCH_THRESHOLD) {
            lastPlayerChunk = currentChunk;
          }
        }
      } else {
        // First time - set initial chunk
        lastPlayerChunk = currentChunk;
      }
      
      const playerChunk = lastPlayerChunk;
      
      // Process chunk load queue (spread loading over multiple frames)
      // Use adaptive batch size: load more chunks when queue is large or during initial load
      if (chunkLoadQueue.length > 0) {
        let batchSize = CHUNK_LOAD_PER_FRAME;
        
        // Aggressive loading for first 10 seconds or when queue is very large
        if (!initialChunksLoaded && activeChunks.size < 50) {
          batchSize = 8; // Load 8 chunks at once during initial phase
        } else if (chunkLoadQueue.length > 20) {
          batchSize = 6; // Load 6 chunks at once when queue is backed up
        } else if (chunkLoadQueue.length > 10) {
          batchSize = 5; // Load 5 chunks when queue is moderately full
        }
        
        for (let i = 0; i < batchSize && chunkLoadQueue.length > 0; i++) {
          const key = chunkLoadQueue.shift();
          // Double-check chunk isn't already loaded (prevents duplicates)
          if (!activeChunks.has(key)) {
            loadChunk(key);
            activeChunks.add(key);
          }
        }
        
        // Mark initial chunks as loaded once we've loaded at least 40 chunks
        if (!initialChunksLoaded && activeChunks.size >= 40) {
          initialChunksLoaded = true;
          console.log('Initial chunk loading phase complete - loaded', activeChunks.size, 'chunks');
        }
      }
      
      // Throttle chunk update checks (but still process queue every frame)
      const now = performance.now();
      if (now - lastChunkUpdate < CHUNK_UPDATE_INTERVAL) return;
      lastChunkUpdate = now;
      
      const chunkSize = CONFIG.BLOCK_SIZE + CONFIG.ROAD_WIDTH;
      
      // Calculate load/unload radii in chunk units (use Euclidean distance consistently)
      const loadRadiusChunks = CONFIG.CHUNK_LOAD_DISTANCE / chunkSize;
      const unloadRadiusChunks = CONFIG.CHUNK_UNLOAD_DISTANCE / chunkSize;
      
      // Use a square grid for iteration but filter by Euclidean distance
      const searchRadius = Math.ceil(loadRadiusChunks);
      const chunksToLoad = new Set();
      
      // Find chunks that should be loaded (within Euclidean distance)
      for (let dx = -searchRadius; dx <= searchRadius; dx++) {
        for (let dz = -searchRadius; dz <= searchRadius; dz++) {
          const dist = Math.hypot(dx, dz);
          // Only include chunks within the circular load radius
          if (dist <= loadRadiusChunks) {
            const chunkX = playerChunk.x + dx;
            const chunkZ = playerChunk.z + dz;
            const key = getChunkKey(chunkX, chunkZ);
            chunksToLoad.add(key);
          }
        }
      }
      
      // Convert queue to Set for O(1) lookup instead of O(n) with includes()
      const queueSet = new Set(chunkLoadQueue);
      
      // Add new chunks to load queue (sorted by distance, closest first)
      const newChunks = [];
      chunksToLoad.forEach(key => {
        // Only add if not already loaded AND not already in queue
        if (!activeChunks.has(key) && !queueSet.has(key)) {
          const [x, z] = key.split(',').map(Number);
          const dist = Math.hypot(x - playerChunk.x, z - playerChunk.z);
          newChunks.push({ key, dist });
        }
      });
      
      // Sort by distance and add to queue
      newChunks.sort((a, b) => a.dist - b.dist);
      const newChunkKeys = newChunks.map(c => c.key);
      chunkLoadQueue.push(...newChunkKeys);
      
      // Log when new chunks are queued
      if (newChunkKeys.length > 0) {
        console.log(`üìã Queued ${newChunkKeys.length} new chunks for loading (queue size: ${chunkLoadQueue.length}, active: ${activeChunks.size})`);
      }
      
      // Unload far chunks (with larger hysteresis to prevent thrashing)
      const chunksToUnload = [];
      activeChunks.forEach(key => {
        const [x, z] = key.split(',').map(Number);
        const distChunks = Math.hypot(x - playerChunk.x, z - playerChunk.z);
        // Unload if beyond the unload radius (hysteresis prevents oscillation)
        if (distChunks > unloadRadiusChunks) {
          chunksToUnload.push(key);
        }
      });
      
      // Unload chunks (defer disposal to next frame to avoid blocking)
      chunksToUnload.forEach(key => {
        activeChunks.delete(key);
        // Remove from load queue if present
        const queueIndex = chunkLoadQueue.indexOf(key);
        if (queueIndex !== -1) {
          chunkLoadQueue.splice(queueIndex, 1);
        }
        // Defer unload to next frame using setTimeout
        setTimeout(() => unloadChunk(key), 0);
      });
    }
    
    let distantSkylineGroup = null; // Track the current skyline
    let lastSkylineUpdateRadius = 0; // Track when we last updated the skyline
    
    // Create grass base for chunk (prevents falling through floor)
    function createChunkGrassBase(chunkRoot, chunkSize, chunkWorldX, chunkWorldZ) {
      const grassMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x4a7c4a, 
        roughness: 0.9, 
        metalness: 0.0 
      });
      
      const grassGeo = new THREE.PlaneGeometry(chunkSize, chunkSize);
      const grassMesh = new THREE.Mesh(grassGeo, grassMaterial);
      grassMesh.rotation.x = -Math.PI / 2;
      grassMesh.position.set(chunkSize / 2, 0, chunkSize / 2);
      grassMesh.receiveShadow = true;
      chunkRoot.add(grassMesh);
    }
    
    // Create physics collision for chunk floor
    function createChunkPhysics(chunkSize, chunkWorldX, chunkWorldZ, key) {
      if (!world || !physics) return;
      
      const bodyDesc = physics.RigidBodyDesc.fixed()
        .setTranslation(chunkWorldX + chunkSize / 2, -0.5, chunkWorldZ + chunkSize / 2);
      
      const body = world.createRigidBody(bodyDesc);
      
      const colliderDesc = physics.ColliderDesc.cuboid(
        chunkSize / 2,
        0.5,
        chunkSize / 2
      );
      
      world.createCollider(colliderDesc, body);
      
      // Store the physics body for cleanup
      if (!chunkPhysicsBodies.has(key)) {
        chunkPhysicsBodies.set(key, []);
      }
      chunkPhysicsBodies.get(key).push(body);
    }
    
    function loadChunk(key) {
      const [chunkX, chunkZ] = key.split(',').map(Number);
      
      // Determine district type based on distance from center
      const distFromCenter = Math.hypot(chunkX, chunkZ);
      let district;
      if (distFromCenter < 1.5) {
        district = 'financial';
      } else if (distFromCenter < 3) {
        district = 'midtown';
      } else if (distFromCenter < 4.5) {
        district = 'residential';
      } else {
        district = 'waterfront';
      }
      
      const chunkRoot = new THREE.Group();
      chunkRoot.name = `chunk_${key}`;
      
      const chunkSize = CONFIG.BLOCK_SIZE + CONFIG.ROAD_WIDTH;
      const chunkWorldX = chunkX * chunkSize;
      const chunkWorldZ = chunkZ * chunkSize;
      
      chunkRoot.position.set(chunkWorldX, 0, chunkWorldZ);
      worldRoot.add(chunkRoot);
      chunkRoots.set(key, chunkRoot);
      
      // CREATE GRASS BASE FOR CHUNK (CRITICAL - prevents missing floor)
      createChunkGrassBase(chunkRoot, chunkSize, chunkWorldX, chunkWorldZ);
      
      // ADD PHYSICS COLLISION FOR CHUNK (CRITICAL - prevents falling through)
      createChunkPhysics(chunkSize, chunkWorldX, chunkWorldZ, key);
      
      // Generate chunk buildings
      generateChunkBuildings(chunkRoot, chunkX, chunkZ, district);
      
      console.log(`‚úÖ Loaded chunk ${key} (${district}) with grass base and physics`);
      
      // Update distant skyline to expand beyond loaded chunks
      updateDistantSkylineRadius();
    }
    
    function updateDistantSkylineRadius() {
      // Find the furthest loaded chunk
      let maxChunkDist = 0;
      activeChunks.forEach(key => {
        const [x, z] = key.split(',').map(Number);
        const dist = Math.hypot(x, z);
        if (dist > maxChunkDist) maxChunkDist = dist;
      });
      
      // Calculate world radius of furthest chunk
      const chunkSize = CONFIG.BLOCK_SIZE + CONFIG.ROAD_WIDTH;
      const loadedRadius = maxChunkDist * chunkSize;
      
      // Only update skyline if we've expanded significantly (reduces rebuilds)
      const skylineRadius = loadedRadius + 200; // Place skyline 200m beyond loaded area
      if (Math.abs(skylineRadius - lastSkylineUpdateRadius) > 100) {
        lastSkylineUpdateRadius = skylineRadius;
        
        // Remove old skyline
        if (distantSkylineGroup) {
          worldRoot.remove(distantSkylineGroup);
          distantSkylineGroup.traverse(child => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
              if (Array.isArray(child.material)) {
                child.material.forEach(m => m.dispose());
              } else {
                child.material.dispose();
              }
            }
          });
        }
        
        // Create new skyline at expanded radius
        distantSkylineGroup = createExpandedDistantSkyline(skylineRadius);
        worldRoot.add(distantSkylineGroup);
        console.log(`üìç Expanded distant skyline to ${skylineRadius.toFixed(0)}m radius`);
      }
    }
    
    function createExpandedDistantSkyline(skylineRadius) {
      const skylineGroup = new THREE.Group();
      skylineGroup.name = 'distantSkyline';
      
      const baseBuildingCount = Math.floor(skylineRadius / 5); // Scale building count with radius
      const buildingCount = Math.floor(baseBuildingCount * optimizationConfig.skylineDensity);
      const angleStep = (Math.PI * 2) / buildingCount;
      
      // Check if we're in space mode (for simple prisms without windows)
      const inSpaceMode = rocketEnabled && rocketBody && rocketBody.translation().y > MICRO_LOD_ALTITUDE;
      
      // Create multiple rings for depth
      const rings = [
        { radius: skylineRadius - 100, heightMult: 0.8, sizeMult: 0.9 },
        { radius: skylineRadius, heightMult: 1.0, sizeMult: 1.0 },
        { radius: skylineRadius + 100, heightMult: 1.2, sizeMult: 1.1 }
      ];
      
      // Simple box geometry for space mode (shared for performance)
      const spaceBoxGeom = inSpaceMode ? new THREE.BoxGeometry(1, 1, 1) : null;
      const colorVariety = [0x383838, 0x404040, 0x484848, 0x505050, 0x585858, 0x606060];
      
      rings.forEach((ring) => {
        for (let i = 0; i < buildingCount / rings.length; i++) {
          const angle = i * angleStep * rings.length + (Math.random() - 0.5) * angleStep * 0.3;
          const radius = ring.radius + (Math.random() - 0.5) * 80;
          
          const x = Math.cos(angle) * radius;
          const z = Math.sin(angle) * radius;
          
          const width = (12 + Math.random() * 20) * ring.sizeMult;
          const depth = (12 + Math.random() * 20) * ring.sizeMult;
          const height = (35 + Math.random() * 100) * ring.heightMult;
          
          let building;
          
          if (inSpaceMode) {
            // In space: create simple prisms with no windows/textures
            const baseColor = colorVariety[Math.floor(Math.random() * colorVariety.length)];
            const mat = new THREE.MeshBasicMaterial({ 
              color: baseColor,
              fog: false
            });
            
            building = new THREE.Mesh(spaceBoxGeom, mat);
            building.position.set(x, height / 2, z);
            building.scale.set(width, height, depth);
          } else {
            // On ground: create buildings with windows
            const baseColor = colorVariety[Math.floor(Math.random() * colorVariety.length)];
            const windowColors = ['yellow', 'white', 'blue', 'black'];
            const windowColor = windowColors[Math.floor(Math.random() * windowColors.length)];
            
            building = createBuildingLowDetail(width, depth, height, baseColor, windowColor, 'box');
            building.position.set(x, 0, z);
            
            const scaleVar = 0.9 + Math.random() * 0.2;
            building.scale.set(scaleVar, 1, scaleVar);
          }
          
          building.rotation.y = angle + Math.PI;
          skylineGroup.add(building);
        }
      });
      
      console.log(`üèôÔ∏è Created distant skyline (${inSpaceMode ? 'SPACE MODE - simple prisms' : 'GROUND MODE - with windows'}) at ${skylineRadius.toFixed(0)}m radius`);
      return skylineGroup;
    }
    
    // ==================== MICRO LOD SYSTEM ====================
    // When rocket is very high, replace detailed chunks with simple instances
    
    function switchToMicroLOD() {
      if (microLODActive) return;
      console.log('üöÄ Switching to Micro LOD mode - replacing detailed city with simple prisms');
      
      microLODActive = true;
      
      // Save current chunk keys
      savedChunkData.clear();
      activeChunks.forEach(key => savedChunkData.set(key, true));
      
      // Create micro LOD group
      microLODGroup = new THREE.Group();
      microLODGroup.name = 'microLODCity';
      
      // Create simple prism instances for each loaded chunk
      const chunkSize = CONFIG.BLOCK_SIZE + CONFIG.ROAD_WIDTH;
      
      // Simple box geometry (shared for all instances)
      const boxGeom = new THREE.BoxGeometry(1, 1, 1);
      
      // Color palette for buildings (dark grays)
      const colorVariety = [0x383838, 0x404040, 0x484848, 0x505050, 0x585858, 0x606060];
      
      chunkRoots.forEach((chunkRoot, key) => {
        const [chunkX, chunkZ] = key.split(',').map(Number);
        const worldX = chunkX * chunkSize;
        const worldZ = chunkZ * chunkSize;
        
        // Create 2-4 simple prisms per chunk (no windows, no details)
        const buildingCount = 2 + Math.floor(Math.random() * 3);
        for (let i = 0; i < buildingCount; i++) {
          const x = worldX + Math.random() * chunkSize * 0.8;
          const z = worldZ + Math.random() * chunkSize * 0.8;
          
          const width = 10 + Math.random() * 15;
          const depth = 10 + Math.random() * 15;
          const height = 20 + Math.random() * 60;
          
          // Plain material - no textures, just solid color
          const baseColor = colorVariety[Math.floor(Math.random() * colorVariety.length)];
          const mat = new THREE.MeshBasicMaterial({ 
            color: baseColor,
            fog: false // Disable fog for distant objects
          });
          
          const prism = new THREE.Mesh(boxGeom, mat);
          prism.position.set(x, height / 2, z);
          prism.scale.set(width, height, depth);
          prism.rotation.y = Math.random() * Math.PI * 2;
          
          microLODGroup.add(prism);
        }
      });
      
      // Unload all chunks
      const chunksToUnload = Array.from(activeChunks);
      chunksToUnload.forEach(key => {
        activeChunks.delete(key);
        unloadChunk(key);
      });
      
      // Add micro LOD group to scene
      worldRoot.add(microLODGroup);
      console.log(`‚úÖ Micro LOD active - replaced ${savedChunkData.size} chunks with ${microLODGroup.children.length} simple prisms (no textures)`);
    }
    
    function switchFromMicroLOD() {
      if (!microLODActive) return;
      console.log('üåç Exiting Micro LOD mode - restoring detailed chunks');
      
      microLODActive = false;
      
      // Remove micro LOD group
      if (microLODGroup) {
        worldRoot.remove(microLODGroup);
        microLODGroup.traverse(child => {
          if (child.geometry) child.geometry.dispose();
          if (child.material) {
            if (Array.isArray(child.material)) {
              child.material.forEach(m => m.dispose());
            } else {
              child.material.dispose();
            }
          }
        });
        microLODGroup = null;
      }
      
      // Restore chunks - add them back to the load queue
      savedChunkData.forEach((_, key) => {
        if (!activeChunks.has(key) && !chunkLoadQueue.includes(key)) {
          chunkLoadQueue.push(key);
        }
      });
      
      console.log(`‚úÖ Queued ${savedChunkData.size} chunks for restoration`);
      savedChunkData.clear();
    }
    
    function unloadChunk(key) {
      const chunkRoot = chunkRoots.get(key);
      if (!chunkRoot) return;
      
      // Immediately hide the chunk (visual feedback)
      chunkRoot.visible = false;
      
      // Remove from scene immediately to stop rendering
      worldRoot.remove(chunkRoot);
      chunkRoots.delete(key);
      
      // Defer expensive cleanup operations to avoid blocking
      requestIdleCallback(() => {
        // Dispose geometries and materials
        chunkRoot.traverse(child => {
          if (child.geometry) {
            child.geometry.dispose();
          }
          if (child.material) {
            if (Array.isArray(child.material)) {
              child.material.forEach(m => {
                if (m.map) m.map.dispose();
                m.dispose();
              });
            } else {
              if (child.material.map) child.material.map.dispose();
              child.material.dispose();
            }
          }
        });
        
        // Clean up chunk data
        if (cityChunks.has(key)) {
          const chunk = cityChunks.get(key);
          // Remove building physics bodies
          if (chunk.buildings) {
            chunk.buildings.forEach(building => {
              if (building.body) {
                world.removeRigidBody(building.body);
              }
            });
          }
          // Remove other physics bodies
          if (chunk.bodies) {
            chunk.bodies.forEach(body => world.removeRigidBody(body));
          }
          cityChunks.delete(key);
        }
        
        // Clean up chunk physics bodies (ground collision)
        if (chunkPhysicsBodies.has(key)) {
          const bodies = chunkPhysicsBodies.get(key);
          bodies.forEach(body => {
            try {
              world.removeRigidBody(body);
            } catch (e) {
              console.warn(`Failed to remove physics body for chunk ${key}:`, e);
            }
          });
          chunkPhysicsBodies.delete(key);
        }
        
        console.log(`Unloaded chunk ${key}`);
      }, { timeout: 2000 }); // Fallback timeout if idle callback doesn't fire
    }
    
    function addBuildingPhysics(building, chunkRoot) {
      if (!building || !building.group) return;
      
      // Get world position of the building
      const worldPos = new THREE.Vector3();
      building.group.getWorldPosition(worldPos);
      
      // Create static physics body for collision
      const bodyDesc = physics.RigidBodyDesc.fixed()
        .setTranslation(worldPos.x, building.height / 2, worldPos.z);
      const body = world.createRigidBody(bodyDesc);
      
      // Create box collider approximation
      const colliderDesc = physics.ColliderDesc.cuboid(
        building.width / 2,
        building.height / 2,
        building.depth / 2
      );
      world.createCollider(colliderDesc, body);
      
      // Store reference
      building.body = body;
    }
    
    // ==================== ROBUST CITY PLANNING SYSTEM ====================
    // Generates a proper city layout with lots, collision detection, and spacing
    
    function planCityBlock(blockSize, profile) {
      const lots = [];
      const ALLEY_WIDTH = 3;  // Width of alleys between buildings
      const MIN_LOT_SIZE = 12;  // Minimum lot dimension
      const MAX_LOT_SIZE = 30;  // Maximum lot dimension
      
      // Determine layout strategy based on district
      const layoutType = Math.random();
      
      if (layoutType < 0.3) {
        // GRID LAYOUT: Regular grid of lots with alleys
        const numRows = 2 + Math.floor(Math.random() * 2);  // 2-3 rows
        const numCols = 2 + Math.floor(Math.random() * 2);  // 2-3 cols
        
        const availableWidth = blockSize - (numCols - 1) * ALLEY_WIDTH;
        const availableDepth = blockSize - (numRows - 1) * ALLEY_WIDTH;
        const lotWidth = availableWidth / numCols;
        const lotDepth = availableDepth / numRows;
        
        for (let row = 0; row < numRows; row++) {
          for (let col = 0; col < numCols; col++) {
            const x = col * (lotWidth + ALLEY_WIDTH) + lotWidth / 2;
            const z = row * (lotDepth + ALLEY_WIDTH) + lotDepth / 2;
            lots.push({
              x, z,
              width: lotWidth,
              depth: lotDepth,
              type: 'grid'
            });
          }
        }
      } else if (layoutType < 0.6) {
        // PERIMETER LAYOUT: Buildings around edges, courtyard in center
        const perimeterDepth = 15 + Math.random() * 10;  // 15-25m deep
        
        // North edge
        lots.push({
          x: blockSize / 2,
          z: perimeterDepth / 2,
          width: blockSize - ALLEY_WIDTH * 2,
          depth: perimeterDepth,
          type: 'perimeter'
        });
        
        // South edge
        lots.push({
          x: blockSize / 2,
          z: blockSize - perimeterDepth / 2,
          width: blockSize - ALLEY_WIDTH * 2,
          depth: perimeterDepth,
          type: 'perimeter'
        });
        
        // East edge (if space)
        if (blockSize - perimeterDepth * 2 > MIN_LOT_SIZE) {
          lots.push({
            x: blockSize - perimeterDepth / 2,
            z: blockSize / 2,
            width: perimeterDepth,
            depth: blockSize - perimeterDepth * 2,
            type: 'perimeter'
          });
        }
        
        // West edge (if space)
        if (blockSize - perimeterDepth * 2 > MIN_LOT_SIZE) {
          lots.push({
            x: perimeterDepth / 2,
            z: blockSize / 2,
            width: perimeterDepth,
            depth: blockSize - perimeterDepth * 2,
            type: 'perimeter'
          });
        }
      } else {
        // MIXED LAYOUT: Combination of adjacent and spaced buildings
        const numLots = 3 + Math.floor(Math.random() * 3);  // 3-5 lots
        
        for (let i = 0; i < numLots; i++) {
          const lotWidth = MIN_LOT_SIZE + Math.random() * (MAX_LOT_SIZE - MIN_LOT_SIZE);
          const lotDepth = MIN_LOT_SIZE + Math.random() * (MAX_LOT_SIZE - MIN_LOT_SIZE);
          
          // Try to place lot without overlaps
          let placed = false;
          for (let attempt = 0; attempt < 20; attempt++) {
            const x = lotWidth / 2 + Math.random() * (blockSize - lotWidth);
            const z = lotDepth / 2 + Math.random() * (blockSize - lotDepth);
            
            // Check for collisions with existing lots
            const hasCollision = lots.some(existingLot => {
              const dx = Math.abs(x - existingLot.x);
              const dz = Math.abs(z - existingLot.z);
              const minDistX = (lotWidth + existingLot.width) / 2 + ALLEY_WIDTH;
              const minDistZ = (lotDepth + existingLot.depth) / 2 + ALLEY_WIDTH;
              return dx < minDistX && dz < minDistZ;
            });
            
            if (!hasCollision) {
              lots.push({ x, z, width: lotWidth, depth: lotDepth, type: 'mixed' });
              placed = true;
              break;
            }
          }
        }
      }
      
      return lots;
    }
    
    function checkBuildingCollision(x, z, width, depth, existingBuildings) {
      const SPACING = 2;  // Minimum 2m spacing between buildings
      
      for (const building of existingBuildings) {
        const dx = Math.abs(x - building.x);
        const dz = Math.abs(z - building.z);
        const minDistX = (width + building.width) / 2 + SPACING;
        const minDistZ = (depth + building.depth) / 2 + SPACING;
        
        if (dx < minDistX && dz < minDistZ) {
          return true;  // Collision detected
        }
      }
      
      return false;  // No collision
    }
    
    function generateChunkBuildings(chunkRoot, chunkX, chunkZ, districtType) {
      const profile = DISTRICT_PROFILES[districtType];
      let numBuildings = CONFIG.BUILDINGS_PER_BLOCK_MIN + 
        Math.floor(Math.random() * (CONFIG.BUILDINGS_PER_BLOCK_MAX - CONFIG.BUILDINGS_PER_BLOCK_MIN + 1));
      
      console.log(`generateChunkBuildings: chunk (${chunkX},${chunkZ}) district=${districtType}, creating ${numBuildings} buildings`);
      
      const blockSize = CONFIG.BLOCK_SIZE;
      const roadWidth = CONFIG.ROAD_WIDTH;
      const sidewalkWidth = CONFIG.SIDEWALK_WIDTH;
      const sidewalkHeight = CONFIG.SIDEWALK_HEIGHT;
      const chunkBuildings = [];
      
      // Generate city block layout plan
      const cityPlan = planCityBlock(blockSize, profile);
      console.log(`üìê Generated ${cityPlan.length} lots for chunk (${chunkX},${chunkZ})`);
      
      // Track placed building positions for collision detection
      const placedBuildings = [];
      
      // Check if this is the initial chunk (0,0) - always place school and police station
      const isInitialChunk = (chunkX === 0 && chunkZ === 0);
      const placeSchool = isInitialChunk || (Math.random() < 0.02); // 2% chance in other chunks
      const placePolice = isInitialChunk || (Math.random() < 0.02); // 2% chance in other chunks
      
      // Reduce regular building count if placing special buildings
      if (placeSchool) numBuildings--;
      if (placePolice) numBuildings--;
      numBuildings = Math.max(1, numBuildings); // At least 1 regular building
      
      // Create chunk roads and sidewalks
      createChunkRoads(chunkRoot, blockSize, roadWidth, sidewalkWidth, sidewalkHeight);
      
      // Place school if needed
      if (placeSchool) {
        const schoolX = blockSize * 0.25; // Northwest quadrant
        const schoolZ = blockSize * 0.25;
        const school = createSchoolBuilding(schoolX, schoolZ);
        chunkRoot.add(school);
        
        // Add to buildings array for map system
        chunkBuildings.push({
          id: school.userData.id,
          group: school,
          mesh: school,
          width: school.userData.width,
          depth: school.userData.depth,
          height: school.userData.height
        });
        
        console.log(`üè´ Placed school in chunk (${chunkX},${chunkZ})`);
      }
      
      // Place police station if needed
      if (placePolice) {
        const policeX = blockSize * 0.75; // Southeast quadrant
        const policeZ = blockSize * 0.75;
        const policeStation = createPoliceStation(policeX, policeZ);
        chunkRoot.add(policeStation);
        
        // Add to buildings array for map system
        chunkBuildings.push({
          id: policeStation.userData.id,
          group: policeStation,
          mesh: policeStation,
          width: policeStation.userData.width,
          depth: policeStation.userData.depth,
          height: policeStation.userData.height
        });
        
        console.log(`üöì Placed police station in chunk (${chunkX},${chunkZ})`);
      }
      
      // USE LOT-BASED PLACEMENT with collision detection
      let buildingsPlaced = 0;
      
      for (const lot of cityPlan) {
        if (buildingsPlaced >= numBuildings) break;
        
        // Determine building size based on lot (with some variation)
        const buildingWidth = lot.width * (0.7 + Math.random() * 0.25);  // 70-95% of lot width
        const buildingDepth = lot.depth * (0.7 + Math.random() * 0.25);  // 70-95% of lot depth
        
        // Check for collision with existing buildings
        if (checkBuildingCollision(lot.x, lot.z, buildingWidth, buildingDepth, placedBuildings)) {
          console.log(`‚ö†Ô∏è Skipping lot at (${lot.x.toFixed(1)}, ${lot.z.toFixed(1)}) - collision detected`);
          continue;
        }
        
        // Create building at lot center
        const building = createSegmentedBuilding(lot.x, lot.z, profile, blockSize);
          if (building) {
            chunkRoot.add(building.group);
            chunkBuildings.push(building);
          
          // Track placed building for collision detection
          placedBuildings.push({
            x: lot.x,
            z: lot.z,
            width: building.width,
            depth: building.depth
          });
            
            // Add physics collider for building
            addBuildingPhysics(building, chunkRoot);
            
            // Add entry path from building to nearest sidewalk
          createEntryPath(chunkRoot, lot.x, lot.z, building.width, building.depth, blockSize, sidewalkWidth, sidewalkHeight);
          
          buildingsPlaced++;
        }
      }
      
      console.log(`‚úÖ Placed ${buildingsPlaced} buildings in chunk (${chunkX},${chunkZ}) using lot system`);
      
      // Add park benches in grass areas
      createParkBenches(chunkRoot, blockSize, sidewalkWidth, sidewalkHeight);
      
      // Add curved sidewalks for large empty areas
      if (numBuildings < 3) {
        createCurvedSidewalk(chunkRoot, blockSize, sidewalkWidth, sidewalkHeight);
      }
      
      // Add grass blades to grassy areas (only if enabled)
      if (grassBladesEnabled) {
        createGrassField(chunkRoot, blockSize, sidewalkWidth, chunkBuildings);
      }
      
      // Store chunk data
      const key = getChunkKey(chunkX, chunkZ);
      cityChunks.set(key, {
        district: districtType,
        buildings: chunkBuildings,
        bodies: []
      });
      
      // Add chunk buildings to global buildings array for map system
      chunkBuildings.forEach(building => {
        buildings.push(building);
      });
    }
    
    function createEntryPath(chunkRoot, buildingX, buildingZ, buildingWidth, buildingDepth, blockSize, sidewalkWidth, sidewalkHeight) {
      // Find nearest sidewalk edge
      const edges = [
        { side: 'left', dist: buildingX, x: -sidewalkWidth/2, z: buildingZ },
        { side: 'right', dist: blockSize - buildingX, x: blockSize + sidewalkWidth/2, z: buildingZ },
        { side: 'top', dist: buildingZ, x: buildingX, z: -sidewalkWidth/2 },
        { side: 'bottom', dist: blockSize - buildingZ, x: buildingX, z: blockSize + sidewalkWidth/2 }
      ];
      
      const nearest = edges.reduce((min, edge) => edge.dist < min.dist ? edge : min);
      
      // Create concrete path
      const pathMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x787878, 
        roughness: 0.9, 
        metalness: 0.05 
      });
      
      const pathWidth = 2.0;
      const pathHeight = sidewalkHeight - 0.01;
      
      if (nearest.side === 'left' || nearest.side === 'right') {
        // Horizontal path
        const pathLength = nearest.dist;
        const pathGeo = new THREE.BoxGeometry(pathLength, pathHeight, pathWidth);
        const path = new THREE.Mesh(pathGeo, pathMaterial);
        path.position.set(
          buildingX + (nearest.x - buildingX) / 2,
          pathHeight / 2,
          buildingZ
        );
        path.receiveShadow = true;
        chunkRoot.add(path);
      } else {
        // Vertical path
        const pathLength = nearest.dist;
        const pathGeo = new THREE.BoxGeometry(pathWidth, pathHeight, pathLength);
        const path = new THREE.Mesh(pathGeo, pathMaterial);
        path.position.set(
          buildingX,
          pathHeight / 2,
          buildingZ + (nearest.z - buildingZ) / 2
        );
        path.receiveShadow = true;
        chunkRoot.add(path);
      }
    }
    
    function createParkBenches(chunkRoot, blockSize, sidewalkWidth, sidewalkHeight) {
      const benchMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x4a3828, 
        roughness: 0.8, 
        metalness: 0.1 
      });
      
      // Add benches along sidewalks IN THE GRASS (inside block perimeter)
      const benchPositions = [];
      const benchInset = 2.5; // Distance from block edge into the grass
      
      // Left side (inside block, near west edge)
      for (let z = 10; z < blockSize - 10; z += 15) {
        if (Math.random() > 0.5) {
          benchPositions.push({ x: benchInset, z: z, rotation: -Math.PI/2 }); // Facing outward (west)
        }
      }
      
      // Right side (inside block, near east edge)
      for (let z = 10; z < blockSize - 10; z += 15) {
        if (Math.random() > 0.5) {
          benchPositions.push({ x: blockSize - benchInset, z: z, rotation: Math.PI/2 }); // Facing outward (east)
        }
      }
      
      // Top side (inside block, near north edge)
      for (let x = 10; x < blockSize - 10; x += 15) {
        if (Math.random() > 0.5) {
          benchPositions.push({ x: x, z: benchInset, rotation: Math.PI }); // Facing outward (north)
        }
      }
      
      // Bottom side (inside block, near south edge)
      for (let x = 10; x < blockSize - 10; x += 15) {
        if (Math.random() > 0.5) {
          benchPositions.push({ x: x, z: blockSize - benchInset, rotation: 0 }); // Facing outward (south)
        }
      }
      
      // Create simple benches (scaled up 2.5x)
      benchPositions.forEach(pos => {
        const benchGroup = new THREE.Group();
        const scale = 2.5; // Make benches bigger
        
        // Seat
        const seatGeo = new THREE.BoxGeometry(1.2 * scale, 0.08 * scale, 0.4 * scale);
        const seat = new THREE.Mesh(seatGeo, benchMaterial);
        seat.position.y = 0.35 * scale;
        benchGroup.add(seat);
        
        // Back rest
        const backGeo = new THREE.BoxGeometry(1.2 * scale, 0.4 * scale, 0.08 * scale);
        const back = new THREE.Mesh(backGeo, benchMaterial);
        back.position.set(0, 0.55 * scale, -0.16 * scale);
        benchGroup.add(back);
        
        // Legs (simple)
        const legGeo = new THREE.BoxGeometry(0.08 * scale, 0.35 * scale, 0.08 * scale);
        [-0.5, 0.5].forEach(xOff => {
          [-0.15, 0.15].forEach(zOff => {
            const leg = new THREE.Mesh(legGeo, benchMaterial);
            leg.position.set(xOff * scale, 0.175 * scale, zOff * scale);
            benchGroup.add(leg);
          });
        });
        
        benchGroup.position.set(pos.x, 0.01, pos.z); // On the ground, not on sidewalk
        benchGroup.rotation.y = pos.rotation;
        
        // Mark as atomic pickable object for viewport
        benchGroup.userData.isAtomic = true;
        benchGroup.userData.pickable = true;
        benchGroup.userData.objectType = 'bench';
        
        chunkRoot.add(benchGroup);
      });
    }
    
    function createCurvedSidewalk(chunkRoot, blockSize, sidewalkWidth, sidewalkHeight) {
      // Create a curved path through the grass connecting opposite sidewalks
      const sidewalkMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x666666, 
        roughness: 0.85, 
        metalness: 0.02 
      });
      
      // Helper to sample ground height (same as createGround noise function)
      const getGroundHeight = (worldX, worldZ) => {
        const noise = (Math.sin(worldX * 0.05) * Math.cos(worldZ * 0.05) + 
                      Math.sin(worldX * 0.1) * Math.cos(worldZ * 0.08)) * 0.6;
        return noise;
      };
      
      const pathWidth = 2.5; // Wider path
      const segments = 30; // More segments for better terrain following
      
      // Random curve type
      const curveType = Math.random();
      
      let curve;
      if (curveType < 0.5) {
        // Diagonal curve from one corner to opposite
        const points = [];
        for (let i = 0; i <= segments; i++) {
          const t = i / segments;
          const localX = t * blockSize;
          const localZ = t * blockSize + Math.sin(t * Math.PI) * (blockSize * 0.2);
          points.push(new THREE.Vector3(localX, 0, localZ));
        }
        curve = new THREE.CatmullRomCurve3(points);
      } else {
        // S-curve from one side to another
        const points = [];
        for (let i = 0; i <= segments; i++) {
          const t = i / segments;
          const localX = blockSize / 2 + Math.sin(t * Math.PI * 2) * (blockSize * 0.3);
          const localZ = t * blockSize;
          points.push(new THREE.Vector3(localX, 0, localZ));
        }
        curve = new THREE.CatmullRomCurve3(points);
      }
      
      // Get chunk world position for ground height sampling
      const chunkWorldPos = new THREE.Vector3();
      chunkRoot.getWorldPosition(chunkWorldPos);
      
      // Create path geometry along curve with terrain following
      const curvePoints = curve.getPoints(segments);
      const pathGeometry = new THREE.BufferGeometry();
      const vertices = [];
      const indices = [];
      
      for (let i = 0; i < curvePoints.length; i++) {
        const point = curvePoints[i];
        const tangent = curve.getTangent(i / (curvePoints.length - 1));
        const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
        
        // Calculate world position for this point
        const worldX = chunkWorldPos.x + point.x;
        const worldZ = chunkWorldPos.z + point.z;
        
        // Sample ground height at both edges of the path
        const leftWorldX = worldX + normal.x * pathWidth / 2;
        const leftWorldZ = worldZ + normal.z * pathWidth / 2;
        const rightWorldX = worldX - normal.x * pathWidth / 2;
        const rightWorldZ = worldZ - normal.z * pathWidth / 2;
        
        const leftHeight = getGroundHeight(leftWorldX, leftWorldZ) + sidewalkHeight;
        const rightHeight = getGroundHeight(rightWorldX, rightWorldZ) + sidewalkHeight;
        
        vertices.push(
          point.x + normal.x * pathWidth / 2, leftHeight, point.z + normal.z * pathWidth / 2,
          point.x - normal.x * pathWidth / 2, rightHeight, point.z - normal.z * pathWidth / 2
        );
        
        if (i < curvePoints.length - 1) {
          const base = i * 2;
          indices.push(base, base + 1, base + 2);
          indices.push(base + 1, base + 3, base + 2);
        }
      }
      
      pathGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      pathGeometry.setIndex(indices);
      pathGeometry.computeVertexNormals();
      
      const path = new THREE.Mesh(pathGeometry, sidewalkMaterial);
      path.receiveShadow = true;
      chunkRoot.add(path);
    }
    
    function createGrassField(chunkRoot, blockSize, sidewalkWidth, buildings) {
      // Create instanced grass blades for performance
      const grassBladesPerSqMeter = 6;
      const grassArea = blockSize * blockSize;
      const totalBlades = Math.floor(grassArea * grassBladesPerSqMeter);
      
      // Create tapered blade geometry (narrow at top)
      const bladeGeo = new THREE.BufferGeometry();
      const bladeSegments = 4;
      const positions = [];
      const uvs = [];
      const indices = [];
      
      // Build blade vertices - tapered
      for (let i = 0; i <= bladeSegments; i++) {
        const t = i / bladeSegments;
        const y = t;
        const width = (1 - t * 0.9); // Taper to 10% at top
        const bend = t * t * 0.1; // Quadratic bend
        
        positions.push(-width * 0.05 + bend, y, 0);
        positions.push(width * 0.05 + bend, y, 0);
        uvs.push(0, t);
        uvs.push(1, t);
        
        if (i < bladeSegments) {
          const base = i * 2;
          indices.push(base, base + 1, base + 2);
          indices.push(base + 1, base + 3, base + 2);
        }
      }
      
      bladeGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      bladeGeo.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
      bladeGeo.setIndex(indices);
      bladeGeo.computeVertexNormals();
      
      // Shader material with animated sway
      const grassMaterial = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          grassColor: { value: new THREE.Color(0x4a7c30) },
          tipColor: { value: new THREE.Color(0x6a9c40) }
        },
        vertexShader: `
          varying vec2 vUv;
          varying vec3 vPosition;
          uniform float time;
          
          void main() {
            vUv = uv;
            vPosition = position;
            
            // Sway animation - only affect top vertices
            float swayAmount = vUv.y; // More sway at top
            float sway = sin(time * 2.0 + position.x * 3.0 + position.z * 2.0) * 0.08 * swayAmount;
            float sway2 = cos(time * 1.5 + position.x * 2.0 + position.z * 3.0) * 0.05 * swayAmount;
            
            vec3 newPos = position;
            newPos.x += sway + sway2;
            newPos.z += sway * 0.5;
            
            vec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0);
            gl_Position = projectionMatrix * mvPosition;
          }
        `,
        fragmentShader: `
          uniform vec3 grassColor;
          uniform vec3 tipColor;
          varying vec2 vUv;
          varying vec3 vPosition;
          
          void main() {
            // Gradient from base to tip
            vec3 color = mix(grassColor, tipColor, vUv.y * vUv.y);
            
            // Add some variation
            color += vec3(sin(vPosition.x * 20.0) * 0.02);
            
            gl_FragColor = vec4(color, 1.0);
          }
        `,
        side: THREE.DoubleSide
      });
      
      const instancedGrass = new THREE.InstancedMesh(bladeGeo, grassMaterial, totalBlades);
      instancedGrass.receiveShadow = true;
      instancedGrass.castShadow = false;
      instancedGrass.userData.isGrass = true;
      instancedGrass.userData.material = grassMaterial;
      
      const matrix = new THREE.Matrix4();
      const position = new THREE.Vector3();
      const rotation = new THREE.Euler();
      const quaternion = new THREE.Quaternion();
      const scale = new THREE.Vector3();
      
      let instanceIndex = 0;
      
      // Place grass blades randomly
      for (let i = 0; i < totalBlades; i++) {
        const x = Math.random() * blockSize;
        const z = Math.random() * blockSize;
        
        // Check if too close to buildings
        let tooClose = false;
        for (const building of buildings) {
          const bx = building.group.position.x;
          const bz = building.group.position.z;
          const dist = Math.hypot(x - bx, z - bz);
          if (dist < (building.width + building.depth) / 2 + 2) {
            tooClose = true;
            break;
          }
        }
        
        if (tooClose) continue;
        
        position.set(x, 0, z);
        rotation.set(0, Math.random() * Math.PI * 2, 0);
        quaternion.setFromEuler(rotation);
        // Varied height and width
        const heightVar = 0.6 + Math.random() * 0.8;
        const widthVar = 0.7 + Math.random() * 0.6;
        scale.set(widthVar, heightVar, 1);
        
        matrix.compose(position, quaternion, scale);
        instancedGrass.setMatrixAt(instanceIndex, matrix);
        instanceIndex++;
      }
      
      instancedGrass.count = instanceIndex;
      instancedGrass.instanceMatrix.needsUpdate = true;
      
      chunkRoot.add(instancedGrass);
    }
    
    function createChunkRoads(chunkRoot, blockSize, roadWidth, sidewalkWidth, sidewalkHeight) {
      const roadMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x2a2a2a,
        roughness: 0.95,
        metalness: 0.05
      });
      
      const sidewalkMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x666666,
        roughness: 0.85,
        metalness: 0.02
      });
      
      // Create roads around perimeter (between blocks)
      const roadPositions = [
        // Left road (west) - raised to 0.15 to clear grass hills
        { x: -roadWidth/2 - sidewalkWidth, y: 0.15, z: blockSize/2, w: roadWidth - sidewalkWidth * 2, d: blockSize + roadWidth },
        // Right road (east)
        { x: blockSize + roadWidth/2 + sidewalkWidth, y: 0.15, z: blockSize/2, w: roadWidth - sidewalkWidth * 2, d: blockSize + roadWidth },
        // Top road (north)
        { x: blockSize/2, y: 0.15, z: -roadWidth/2 - sidewalkWidth, w: blockSize + roadWidth, d: roadWidth - sidewalkWidth * 2 },
        // Bottom road (south)
        { x: blockSize/2, y: 0.15, z: blockSize + roadWidth/2 + sidewalkWidth, w: blockSize + roadWidth, d: roadWidth - sidewalkWidth * 2 }
      ];
      
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // GEOMETRY MERGING - AGGRESSIVE PERFORMANCE OPTIMIZATION
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      
      // Merge all road geometries into one mesh (reduces draw calls)
      const roadGeometries = [];
      roadPositions.forEach(pos => {
        const roadGeo = new THREE.PlaneGeometry(pos.w, pos.d);
        const roadMesh = new THREE.Mesh(roadGeo);
        roadMesh.rotation.x = -Math.PI / 2;
        roadMesh.position.set(pos.x, pos.y, pos.z);
        roadMesh.updateMatrix();
        roadGeometries.push(roadGeo.clone().applyMatrix4(roadMesh.matrix));
      });
      
      if (roadGeometries.length > 0) {
        const mergedRoadGeo = BufferGeometryUtils.mergeGeometries(roadGeometries);
        const mergedRoad = new THREE.Mesh(mergedRoadGeo, roadMaterial);
        mergedRoad.receiveShadow = true;
        mergedRoad.castShadow = false;
        chunkRoot.add(mergedRoad);
      }
      
      // Create sidewalks around perimeter of block
      const sidewalkPositions = [
        // Left sidewalk (west)
        { x: -sidewalkWidth/2, y: sidewalkHeight/2, z: blockSize/2, w: sidewalkWidth, h: sidewalkHeight, d: blockSize },
        // Right sidewalk (east)
        { x: blockSize + sidewalkWidth/2, y: sidewalkHeight/2, z: blockSize/2, w: sidewalkWidth, h: sidewalkHeight, d: blockSize },
        // Top sidewalk (north)
        { x: blockSize/2, y: sidewalkHeight/2, z: -sidewalkWidth/2, w: blockSize, h: sidewalkHeight, d: sidewalkWidth },
        // Bottom sidewalk (south)
        { x: blockSize/2, y: sidewalkHeight/2, z: blockSize + sidewalkWidth/2, w: blockSize, h: sidewalkHeight, d: sidewalkWidth }
      ];
      
      // Merge all sidewalk geometries into one mesh (reduces draw calls)
      const sidewalkGeometries = [];
      sidewalkPositions.forEach(pos => {
        const sidewalkGeo = new THREE.BoxGeometry(pos.w, pos.h, pos.d);
        const sidewalkMesh = new THREE.Mesh(sidewalkGeo);
        sidewalkMesh.position.set(pos.x, pos.y, pos.z);
        sidewalkMesh.updateMatrix();
        sidewalkGeometries.push(sidewalkGeo.clone().applyMatrix4(sidewalkMesh.matrix));
      });
      
      if (sidewalkGeometries.length > 0) {
        const mergedSidewalkGeo = BufferGeometryUtils.mergeGeometries(sidewalkGeometries);
        const mergedSidewalk = new THREE.Mesh(mergedSidewalkGeo, sidewalkMaterial);
        mergedSidewalk.receiveShadow = true;
        mergedSidewalk.castShadow = false;
        chunkRoot.add(mergedSidewalk);
      }
      
      // Add trees along sidewalks
      const treePositions = [];
      for (let i = 5; i < blockSize; i += 8) {
        if (Math.random() > 0.3) {
          treePositions.push({ x: -sidewalkWidth/2, z: i });
          treePositions.push({ x: blockSize + sidewalkWidth/2, z: i });
        }
      }
      for (let i = 5; i < blockSize; i += 8) {
        if (Math.random() > 0.3) {
          treePositions.push({ x: i, z: -sidewalkWidth/2 });
          treePositions.push({ x: i, z: blockSize + sidewalkWidth/2 });
        }
      }
      
      // Place trees
      if (treePrototypes.length === 0) {
        createTreePrototypes();
      }
      
      treePositions.forEach(pos => {
        const protoIdx = Math.floor(Math.random() * treePrototypes.length);
        const treeClone = treePrototypes[protoIdx].clone();
        treeClone.position.set(pos.x, sidewalkHeight, pos.z);
        treeClone.rotation.y = Math.random() * Math.PI * 2;
        const scale = 0.9 + Math.random() * 0.3;
        treeClone.scale.set(scale, scale, scale);
        chunkRoot.add(treeClone);
      });
      
      // Add street lights (visual only - no actual point lights to avoid shader uniform limit)
      const lightPositions = [];
      for (let i = 10; i < blockSize; i += 20) {
        lightPositions.push({ x: -sidewalkWidth * 0.8, z: i });
        lightPositions.push({ x: blockSize + sidewalkWidth * 0.8, z: i + 10 });
      }
      for (let i = 10; i < blockSize; i += 20) {
        lightPositions.push({ x: i, z: -sidewalkWidth * 0.8 });
        lightPositions.push({ x: i + 10, z: blockSize + sidewalkWidth * 0.8 });
      }
      
      // Create simple street light (visual only - emissive materials, NO point lights)
      lightPositions.forEach(pos => {
        const lightGroup = new THREE.Group();
        
        // Pole
        const poleGeo = new THREE.CylinderGeometry(0.08, 0.1, 6, 6);
        const poleMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.6, metalness: 0.8 });
        const pole = new THREE.Mesh(poleGeo, poleMat);
        pole.position.y = 3;
        pole.castShadow = false;
        lightGroup.add(pole);
        
        // Light bulb (glowing, but no actual light source)
        const bulbGeo = new THREE.SphereGeometry(0.15, 6, 4);
        const bulbMat = new THREE.MeshStandardMaterial({ 
          color: 0xffffee, 
          emissive: 0xffdd88, 
          emissiveIntensity: 2.0  // Brighter emissive to fake lighting
        });
        const bulb = new THREE.Mesh(bulbGeo, bulbMat);
        bulb.position.y = 5.5;
        lightGroup.add(bulb);
        
        // NO point light - this was causing shader uniform overflow
        
        lightGroup.position.set(pos.x, sidewalkHeight, pos.z);
        chunkRoot.add(lightGroup);
      });
    }
    
    // ==================== SLIDING DOOR SYSTEM ====================
    // Note: Door system is handled by the existing addDoorToBuilding function
    // which creates doors compatible with the updateDoors animation system
    
    // ==================== LASSO / GRAPPLING HOOK SYSTEM ====================
    
    function toggleLasso() {
      lassoEnabled = !lassoEnabled;
      
      if (lassoEnabled) {
        createLassoVisual();
        console.log('Lasso enabled - M1 to grapple, M2 to swing');
      } else {
        removeLassoVisual();
        releaseGrapple();
        console.log('Lasso disabled');
      }
    }
    
    function createLassoVisual() {
      if (lassoVisual) return;
      
      // Create glowing green lasso indicator at screen center
      const lassoGeo = new THREE.RingGeometry(0.015, 0.025, 16);
      const lassoMat = new THREE.MeshBasicMaterial({ 
        color: 0x00ff00, 
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.8
      });
      lassoVisual = new THREE.Mesh(lassoGeo, lassoMat);
      
      // Position in front of camera
      lassoVisual.position.set(0, 0, -0.5);
      camera.add(lassoVisual);
    }
    
    function removeLassoVisual() {
      if (lassoVisual) {
        camera.remove(lassoVisual);
        lassoVisual.geometry.dispose();
        lassoVisual.material.dispose();
        lassoVisual = null;
      }
    }
    
    function fireGrapple() {
      if (!lassoEnabled || !playerBody) return;
      
      // Raycast from camera center
      raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
      const intersects = raycaster.intersectObjects(worldRoot.children, true);
      
      if (intersects.length > 0) {
        const hit = intersects[0];
        const hitPoint = hit.point;
        
        // Create grapple hook
        grapplingHook = {
          attachPoint: hitPoint.clone(),
          active: true,
          pullStrength: 50, // Strong pull
          maxDistance: 100
        };
        
        createRopeVisual(hitPoint);
        console.log('Grapple fired!');
      }
    }
    
    function fireSwingRope() {
      if (!lassoEnabled || !playerBody) return;
      
      const playerPos = playerBody.translation();
      const isGrounded = Math.abs(playerBody.linvel().y) < 0.1;
      
      if (isGrounded) {
        // On ground - acts like grapple
        fireGrapple();
        return;
      }
      
      // In air - create swing rope
      raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
      const intersects = raycaster.intersectObjects(worldRoot.children, true);
      
      if (intersects.length > 0) {
        const hit = intersects[0];
        const hitPoint = hit.point;
        const ropeLength = hitPoint.distanceTo(new THREE.Vector3(playerPos.x, playerPos.y, playerPos.z));
        
        // Create swing rope
        swingRope = {
          attachPoint: hitPoint.clone(),
          active: true,
          length: ropeLength,
          damping: 0.98,
          tension: 0.95
        };
        
        createRopeVisual(hitPoint);
        console.log('Swing rope attached!');
      }
    }
    
    function createRopeVisual(attachPoint) {
      if (ropeVisual) {
        scene.remove(ropeVisual);
        ropeVisual.geometry.dispose();
        ropeVisual.material.dispose();
      }
      
      const ropeMat = new THREE.LineBasicMaterial({ 
        color: 0x00ff00, 
        linewidth: 2,
        transparent: true,
        opacity: 0.8
      });
      
      const ropeGeo = new THREE.BufferGeometry();
      const positions = new Float32Array(6); // 2 points
      ropeGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      
      ropeVisual = new THREE.Line(ropeGeo, ropeMat);
      ropeVisual.userData.attachPoint = attachPoint;
      scene.add(ropeVisual);
    }
    
    function updateRopeVisual() {
      if (!ropeVisual || !playerBody) return;
      
      const playerPos = playerBody.translation();
      const attachPoint = ropeVisual.userData.attachPoint;
      
      const positions = ropeVisual.geometry.attributes.position.array;
      positions[0] = attachPoint.x;
      positions[1] = attachPoint.y;
      positions[2] = attachPoint.z;
      positions[3] = playerPos.x;
      positions[4] = playerPos.y + 1.0; // Attach at chest height
      positions[5] = playerPos.z;
      
      ropeVisual.geometry.attributes.position.needsUpdate = true;
    }
    
    function updateGrapplePhysics(deltaTime) {
      if (!grapplingHook || !grapplingHook.active || !playerBody) return;
      
      const playerPos = playerBody.translation();
      const playerVel = playerBody.linvel();
      const attachPoint = grapplingHook.attachPoint;
      
      const toAttach = new THREE.Vector3(
        attachPoint.x - playerPos.x,
        attachPoint.y - playerPos.y,
        attachPoint.z - playerPos.z
      );
      
      const distance = toAttach.length();
      
      if (distance > grapplingHook.maxDistance) {
        releaseGrapple();
        return;
      }
      
      // Pull toward attach point
      toAttach.normalize();
      const pullForce = grapplingHook.pullStrength * playerScale;
      
      // Apply force with momentum preservation
      const currentSpeed = Math.sqrt(playerVel.x * playerVel.x + playerVel.z * playerVel.z);
      const speedBoost = Math.min(1.5, 1 + currentSpeed * 0.1);
      
      playerBody.applyImpulse({
        x: toAttach.x * pullForce * deltaTime * speedBoost,
        y: toAttach.y * pullForce * deltaTime * speedBoost * 0.8, // Less upward pull
        z: toAttach.z * pullForce * deltaTime * speedBoost
      }, true);
    }
    
    function updateSwingPhysics(deltaTime) {
      if (!swingRope || !swingRope.active || !playerBody) return;
      
      const playerPos = playerBody.translation();
      const playerVel = playerBody.linvel();
      const attachPoint = swingRope.attachPoint;
      
      // Vector from player to attach point
      const ropeVec = new THREE.Vector3(
        attachPoint.x - playerPos.x,
        attachPoint.y - playerPos.y,
        attachPoint.z - playerPos.z
      );
      
      const currentLength = ropeVec.length();
      const targetLength = swingRope.length;
      
      // Spider-Man 2 Style Physics
      if (currentLength > targetLength * 0.95) { // Activate when near rope length
        const ropeDir = ropeVec.clone().normalize();
        
        // Velocity components
        const velocity = new THREE.Vector3(playerVel.x, playerVel.y, playerVel.z);
        const radialSpeed = velocity.dot(ropeDir); // Speed toward/away from anchor
        const radialVel = ropeDir.clone().multiplyScalar(radialSpeed);
        const tangentVel = velocity.clone().sub(radialVel); // Perpendicular velocity
        
        // Constraint: can't exceed rope length
        if (currentLength > targetLength) {
          // Hard constraint - set position
          const correction = ropeDir.clone().multiplyScalar(currentLength - targetLength);
          playerBody.setTranslation({
            x: playerPos.x + correction.x,
            y: playerPos.y + correction.y,
            z: playerPos.z + correction.z
          }, true);
          
          // Kill radial velocity if moving away
          if (radialSpeed > 0) {
            velocity.sub(radialVel); // Remove outward velocity
          }
        }
        
        // Apply pendulum physics - convert potential energy to kinetic
        // Gravity acceleration decomposed into rope direction
        const gravity = new THREE.Vector3(0, -9.81, 0);
        const tangentGravity = gravity.clone().sub(ropeDir.clone().multiplyScalar(gravity.dot(ropeDir)));
        
        // Apply tangential acceleration (swinging force)
        const swingForce = tangentGravity.multiplyScalar(playerScale * 2.5); // Boost for dramatic swings
        playerBody.applyImpulse({
          x: swingForce.x * deltaTime,
          y: swingForce.y * deltaTime,
          z: swingForce.z * deltaTime
        }, true);
        
        // Apply centripetal force to maintain circular motion
        const tangentSpeed = tangentVel.length();
        const centripetalForce = (tangentSpeed * tangentSpeed) / targetLength;
        const centripetalImpulse = ropeDir.clone().multiplyScalar(centripetalForce * playerScale * deltaTime);
        
        playerBody.applyImpulse({
          x: centripetalImpulse.x,
          y: centripetalImpulse.y,
          z: centripetalImpulse.z
        }, true);
        
        // Air control - guide swing momentum (Spider-Man style)
        if (keys.has('KeyW') || keys.has('KeyS') || keys.has('KeyA') || keys.has('KeyD')) {
          const camQuat = new THREE.Quaternion();
          camQuat.setFromEuler(new THREE.Euler(pitch, yaw, 0, 'YXZ'));
          
          const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camQuat);
          const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camQuat);
          forward.y = 0;
          right.y = 0;
          forward.normalize();
          right.normalize();
          
          const inputVec = new THREE.Vector3();
          if (keys.has('KeyW')) inputVec.add(forward);
          if (keys.has('KeyS')) inputVec.sub(forward);
          if (keys.has('KeyD')) inputVec.add(right);
          if (keys.has('KeyA')) inputVec.sub(right);
          
          if (inputVec.length() > 0) {
            inputVec.normalize();
            
            // Project input onto tangent plane (perpendicular to rope)
            const inputDotRope = inputVec.dot(ropeDir);
            const tangentInput = inputVec.clone().sub(ropeDir.clone().multiplyScalar(inputDotRope));
            
            // Check if input aligns with current tangent velocity
            const currentTangentDir = tangentVel.clone().normalize();
            const alignment = tangentInput.dot(currentTangentDir);
            
            // Boost momentum if aligned with swing direction
            let forceMultiplier = 20; // Base force
            if (alignment > 0.3) {
              // Pushing in direction of swing - boost momentum significantly!
              forceMultiplier = 35 * (1 + alignment * 0.5);
            } else if (alignment < -0.2) {
              // Trying to change direction - allow but with less force
              forceMultiplier = 15;
            }
            
            const airControlForce = tangentInput.multiplyScalar(forceMultiplier * playerScale * deltaTime);
            playerBody.applyImpulse({
              x: airControlForce.x,
              y: airControlForce.y,
              z: airControlForce.z
            }, true);
          }
        }
        
        // Minimal damping to preserve momentum (Spider-Man 2 style)
        const currentVel = playerBody.linvel();
        playerBody.setLinvel({
          x: currentVel.x * 0.998,
          y: currentVel.y * 0.999,
          z: currentVel.z * 0.998
        }, true);
        
      } else {
        // Below rope length - free fall with almost no drag (preserve momentum for launch)
        const currentVel = playerBody.linvel();
        playerBody.setLinvel({
          x: currentVel.x * 0.999,
          y: currentVel.y * 0.999,
          z: currentVel.z * 0.999
        }, true);
      }
    }
    
    function releaseGrapple() {
      // Apply momentum boost on release for dramatic launches (Spider-Man style)
      if ((grapplingHook || swingRope) && playerBody) {
        const currentVel = playerBody.linvel();
        const speed = Math.sqrt(currentVel.x * currentVel.x + currentVel.y * currentVel.y + currentVel.z * currentVel.z);
        
        // If moving fast, give a small boost for dramatic effect
        if (speed > 10) {
          const boostFactor = 1.15;
          playerBody.setLinvel({
            x: currentVel.x * boostFactor,
            y: currentVel.y * boostFactor,
            z: currentVel.z * boostFactor
          }, true);
          console.log(`Released with momentum! Speed: ${(speed * boostFactor).toFixed(1)}`);
        }
      }
      
      if (grapplingHook) {
        grapplingHook.active = false;
        grapplingHook = null;
      }
      
      if (swingRope) {
        swingRope.active = false;
        swingRope = null;
      }
      
      if (ropeVisual) {
        scene.remove(ropeVisual);
        ropeVisual.geometry.dispose();
        ropeVisual.material.dispose();
        ropeVisual = null;
      }
    }
    
    // ==================== SEGMENTED BUILDING SYSTEM ====================
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // THREE.LOD BUILDING SYSTEM - AGGRESSIVE PERFORMANCE OPTIMIZATION
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    // Create LOW detail building with baked windows and color variance
    function createBuildingLowDetail(width, depth, height, baseColor, windowColor = 'yellow', buildingType = 'box') {
      const group = new THREE.Group();
      
      // Create building geometry based on type
      if (buildingType === 'stepped') {
        // Stepped/setback building (3 tiers)
        const tiers = 3;
        let currentY = 0;
        for (let i = 0; i < tiers; i++) {
          const tierHeight = height / tiers;
          const tierWidth = width * (1 - i * 0.15); // Each tier is 15% narrower
          const tierDepth = depth * (1 - i * 0.15);
          
          const geo = new THREE.BoxGeometry(tierWidth, tierHeight, tierDepth);
          const mat = sharedMaterials.building;
          const mesh = new THREE.Mesh(geo, mat);
          mesh.position.y = currentY + tierHeight / 2;
          mesh.castShadow = false;
          mesh.receiveShadow = false;
          group.add(mesh);
          
          currentY += tierHeight;
        }
      } else if (buildingType === 'skyscraper') {
        // Tall, narrow skyscraper with antenna
        const mainGeo = new THREE.BoxGeometry(width, height * 0.9, depth);
        const mainMat = sharedMaterials.building;
        const mainMesh = new THREE.Mesh(mainGeo, mainMat);
        mainMesh.position.y = height * 0.45;
        mainMesh.castShadow = false;
        mainMesh.receiveShadow = false;
        group.add(mainMesh);
        
        // Antenna spire
        const spireHeight = height * 0.1;
        const spireGeo = new THREE.CylinderGeometry(width * 0.1, width * 0.15, spireHeight, 4);
        const spireMat = sharedMaterials.buildingDark;
        const spireMesh = new THREE.Mesh(spireGeo, spireMat);
        spireMesh.position.y = height * 0.9 + spireHeight / 2;
        spireMesh.castShadow = false;
        spireMesh.receiveShadow = false;
        group.add(spireMesh);
      } else if (buildingType === 'short') {
        // Short, wide building (1-3 stories)
        const shortHeight = Math.min(height, 15); // Cap at 15m
        const geo = new THREE.BoxGeometry(width, shortHeight, depth);
        const mat = sharedMaterials.building;
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.y = shortHeight / 2;
        mesh.castShadow = false;
        mesh.receiveShadow = false;
        group.add(mesh);
        height = shortHeight; // Update height for facade generation
      } else {
        // Default box building
        const geo = new THREE.BoxGeometry(width, height, depth);
        const mat = sharedMaterials.building;
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.y = height / 2;
        mesh.castShadow = false;
        mesh.receiveShadow = false;
        group.add(mesh);
      }
      
      // Generate simple facade texture with windows
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');
      
      // Background (building color)
      ctx.fillStyle = `#${baseColor.toString(16).padStart(6, '0')}`;
      ctx.fillRect(0, 0, 256, 512);
      
      // Window colors based on type
      const windowColors = {
        yellow: { lit: '#FFEB99', dim: '#6A5A4A' },
        white: { lit: '#FFFFFF', dim: '#8A8A8A' },
        black: { lit: '#2A2A2A', dim: '#1A1A1A' },
        blue: { lit: '#9DC6E8', dim: '#4A5A6A' }
      };
      const wColors = windowColors[windowColor] || windowColors.yellow;
      
      // Draw simple window grid
      const floors = Math.max(3, Math.floor(height / 4));
      const windowsPerFloor = Math.max(2, Math.floor(width / 3));
      const windowW = Math.floor(256 / windowsPerFloor) - 8;
      const windowH = Math.floor(512 / floors) - 12;
      
      for (let floor = 0; floor < floors; floor++) {
        for (let win = 0; win < windowsPerFloor; win++) {
          // Random lit/dim windows
          const isLit = Math.random() > 0.4;
          ctx.fillStyle = isLit ? wColors.lit : wColors.dim;
          const x = win * (256 / windowsPerFloor) + 4;
          const y = floor * (512 / floors) + 6;
          ctx.fillRect(x, y, windowW, windowH);
        }
      }
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.needsUpdate = true;
      
      // Create single shared material with texture
      const faceMat = new THREE.MeshBasicMaterial({ map: texture });
      
      // Add facade planes with proper z-offset to prevent z-fighting
      const zOffset = 0.05;
      
      // Front
      const frontGeo = new THREE.PlaneGeometry(width, height);
      const front = new THREE.Mesh(frontGeo, faceMat);
      front.position.set(0, height/2, depth/2 + zOffset);
      group.add(front);
      
      // Back
      const back = new THREE.Mesh(frontGeo, faceMat);
      back.position.set(0, height/2, -depth/2 - zOffset);
      back.rotation.y = Math.PI;
      group.add(back);
      
      // Left/Right
      const sideGeo = new THREE.PlaneGeometry(depth, height);
      const left = new THREE.Mesh(sideGeo, faceMat);
      left.position.set(-width/2 - zOffset, height/2, 0);
      left.rotation.y = -Math.PI/2;
      group.add(left);
      
      const right = new THREE.Mesh(sideGeo, faceMat);
      right.position.set(width/2 + zOffset, height/2, 0);
      right.rotation.y = Math.PI/2;
      group.add(right);
      
      return group;
    }
    
    // Create MEDIUM detail building (merged geometry with simple facade texture)
    function createBuildingMediumDetail(width, depth, height, baseColor, windowColor = 'yellow', buildingType = 'box') {
      const group = new THREE.Group();
      
      // Create building geometry based on type
      // For multi-tier buildings, generate separate facade textures for each tier
      if (buildingType === 'stepped') {
        // Stepped/setback building (3 tiers) - EACH TIER GETS ITS OWN TEXTURE
        const tiers = 3;
        let currentY = 0;
        const zOffset = 0.12;  // Increased from 0.05 to prevent z-fighting/flickering
        
        for (let i = 0; i < tiers; i++) {
          const tierHeight = height / tiers;
          const tierWidth = width * (1 - i * 0.15);
          const tierDepth = depth * (1 - i * 0.15);
          
          // Base geometry
          const geo = new THREE.BoxGeometry(tierWidth, tierHeight, tierDepth);
          const mat = getCachedMaterial(`building_medium_${baseColor}_${i}`, () =>
            new THREE.MeshStandardMaterial({ color: baseColor, roughness: 0.8, metalness: 0.1 })
          );
          const mesh = new THREE.Mesh(geo, mat);
          mesh.position.y = currentY + tierHeight / 2;
          mesh.castShadow = false;
          mesh.receiveShadow = true;
          group.add(mesh);
          
          // SEPARATE FACADE TEXTURE FOR THIS TIER
          const tierTexture = generateFacadeTexture(tierWidth, tierHeight, baseColor, windowColor);
          const tierFaceMat = new THREE.MeshStandardMaterial({ 
            map: tierTexture, 
            transparent: true, 
            opacity: 0.95,
            emissive: new THREE.Color(baseColor),
            emissiveIntensity: 0.05,
            roughness: 0.75,
            metalness: 0.1
          });
          
          // Add facades for this tier
          const tierYPos = currentY + tierHeight / 2;
          
          // Front
          const frontPlane = new THREE.Mesh(new THREE.PlaneGeometry(tierWidth, tierHeight), tierFaceMat);
          frontPlane.position.set(0, tierYPos, tierDepth/2 + zOffset);
          group.add(frontPlane);
          
          // Back
          const backPlane = new THREE.Mesh(new THREE.PlaneGeometry(tierWidth, tierHeight), tierFaceMat.clone());
          backPlane.position.set(0, tierYPos, -tierDepth/2 - zOffset);
          backPlane.rotation.y = Math.PI;
          group.add(backPlane);
          
          // Left
          const leftPlane = new THREE.Mesh(new THREE.PlaneGeometry(tierDepth, tierHeight), tierFaceMat.clone());
          leftPlane.position.set(-tierWidth/2 - zOffset, tierYPos, 0);
          leftPlane.rotation.y = -Math.PI/2;
          group.add(leftPlane);
          
          // Right
          const rightPlane = new THREE.Mesh(new THREE.PlaneGeometry(tierDepth, tierHeight), tierFaceMat.clone());
          rightPlane.position.set(tierWidth/2 + zOffset, tierYPos, 0);
          rightPlane.rotation.y = Math.PI/2;
          group.add(rightPlane);
          
          currentY += tierHeight;
        }
      } else if (buildingType === 'skyscraper') {
        // Tall skyscraper with antenna - ONLY ADD FACADES TO MAIN BUILDING, SKIP ANTENNA
        const mainHeight = height * 0.9;
        const mainGeo = new THREE.BoxGeometry(width, mainHeight, depth);
        const mainMat = getCachedMaterial(`building_medium_${baseColor}`, () =>
          new THREE.MeshStandardMaterial({ color: baseColor, roughness: 0.8, metalness: 0.1 })
        );
        const mainMesh = new THREE.Mesh(mainGeo, mainMat);
        mainMesh.position.y = mainHeight / 2;
        mainMesh.castShadow = false;
        mainMesh.receiveShadow = true;
        group.add(mainMesh);
        
        // Add facade texture ONLY to main building (skip antenna)
        const texture = generateFacadeTexture(width, mainHeight, baseColor, windowColor);
        const faceMat = new THREE.MeshStandardMaterial({ 
          map: texture, 
          transparent: true, 
          opacity: 0.95,
          emissive: new THREE.Color(baseColor),
          emissiveIntensity: 0.05,
          roughness: 0.75,
          metalness: 0.1
        });
        
        const zOffset = 0.12;  // Increased from 0.05 to prevent z-fighting/flickering
        const yPos = mainHeight / 2;
        
        // Front facade
        const front = new THREE.Mesh(new THREE.PlaneGeometry(width, mainHeight), faceMat);
        front.position.set(0, yPos, depth/2 + zOffset);
        group.add(front);
        
        // Back facade
        const back = new THREE.Mesh(new THREE.PlaneGeometry(width, mainHeight), faceMat.clone());
        back.position.set(0, yPos, -depth/2 - zOffset);
        back.rotation.y = Math.PI;
        group.add(back);
        
        // Left facade
        const left = new THREE.Mesh(new THREE.PlaneGeometry(depth, mainHeight), faceMat.clone());
        left.position.set(-width/2 - zOffset, yPos, 0);
        left.rotation.y = -Math.PI/2;
        group.add(left);
        
        // Right facade
        const right = new THREE.Mesh(new THREE.PlaneGeometry(depth, mainHeight), faceMat.clone());
        right.position.set(width/2 + zOffset, yPos, 0);
        right.rotation.y = Math.PI/2;
        group.add(right);
        
        // Antenna spire (NO WINDOWS - just solid geometry)
        const spireHeight = height * 0.1;
        const spireGeo = new THREE.CylinderGeometry(width * 0.1, width * 0.15, spireHeight, 4);
        const spireMat = getCachedMaterial(`building_medium_spire_${baseColor}`, () =>
          new THREE.MeshStandardMaterial({ color: new THREE.Color(baseColor).multiplyScalar(0.7), roughness: 0.5, metalness: 0.3 })
        );
        const spireMesh = new THREE.Mesh(spireGeo, spireMat);
        spireMesh.position.y = mainHeight + spireHeight / 2;
        spireMesh.castShadow = false;
        spireMesh.receiveShadow = false;
        group.add(spireMesh);
      } else if (buildingType === 'short') {
        // Short building
        const shortHeight = Math.min(height, 15);
        const geo = new THREE.BoxGeometry(width, shortHeight, depth);
        const mat = getCachedMaterial(`building_medium_${baseColor}`, () =>
          new THREE.MeshStandardMaterial({ color: baseColor, roughness: 0.8, metalness: 0.1 })
        );
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.y = shortHeight / 2;
        mesh.castShadow = false;
        mesh.receiveShadow = true;
        group.add(mesh);
        
        // Add facade texture
        const texture = generateFacadeTexture(width, shortHeight, baseColor, windowColor);
        const faceMat = new THREE.MeshStandardMaterial({ 
          map: texture, 
          transparent: true, 
          opacity: 0.95,
          emissive: new THREE.Color(baseColor),
          emissiveIntensity: 0.05,
          roughness: 0.75,
          metalness: 0.1
        });
        
        const zOffset = 0.12;  // Increased from 0.05 to prevent z-fighting/flickering
        const yPos = shortHeight / 2;
        
        // Front
        const front = new THREE.Mesh(new THREE.PlaneGeometry(width, shortHeight), faceMat);
        front.position.set(0, yPos, depth/2 + zOffset);
        group.add(front);
        
        // Back
        const back = new THREE.Mesh(new THREE.PlaneGeometry(width, shortHeight), faceMat.clone());
        back.position.set(0, yPos, -depth/2 - zOffset);
        back.rotation.y = Math.PI;
        group.add(back);
        
        // Left
        const left = new THREE.Mesh(new THREE.PlaneGeometry(depth, shortHeight), faceMat.clone());
        left.position.set(-width/2 - zOffset, yPos, 0);
        left.rotation.y = -Math.PI/2;
        group.add(left);
        
        // Right
        const right = new THREE.Mesh(new THREE.PlaneGeometry(depth, shortHeight), faceMat.clone());
        right.position.set(width/2 + zOffset, yPos, 0);
        right.rotation.y = Math.PI/2;
        group.add(right);
        
        height = shortHeight;
      } else {
        // Default box building
        const geo = new THREE.BoxGeometry(width, height, depth);
        const mat = getCachedMaterial(`building_medium_${baseColor}`, () =>
          new THREE.MeshStandardMaterial({ color: baseColor, roughness: 0.8, metalness: 0.1 })
        );
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.y = height / 2;
        mesh.castShadow = false;
        mesh.receiveShadow = true;
        group.add(mesh);
        
        // Add facade texture
        const texture = generateFacadeTexture(width, height, baseColor, windowColor);
        const faceMat = new THREE.MeshStandardMaterial({ 
          map: texture, 
          transparent: true, 
          opacity: 0.95,
          emissive: new THREE.Color(baseColor),
          emissiveIntensity: 0.05,
          roughness: 0.75,
          metalness: 0.1
        });
        
        const zOffset = 0.12;  // Increased from 0.05 to prevent z-fighting/flickering
        const yPos = height / 2;
        
        // Front
        const front = new THREE.Mesh(new THREE.PlaneGeometry(width, height), faceMat);
        front.position.set(0, yPos, depth/2 + zOffset);
      group.add(front);
      
        // Back
        const back = new THREE.Mesh(new THREE.PlaneGeometry(width, height), faceMat.clone());
        back.position.set(0, yPos, -depth/2 - zOffset);
      back.rotation.y = Math.PI;
      group.add(back);
        
        // Left
        const left = new THREE.Mesh(new THREE.PlaneGeometry(depth, height), faceMat.clone());
        left.position.set(-width/2 - zOffset, yPos, 0);
        left.rotation.y = -Math.PI/2;
        group.add(left);
        
        // Right
        const right = new THREE.Mesh(new THREE.PlaneGeometry(depth, height), faceMat.clone());
        right.position.set(width/2 + zOffset, yPos, 0);
        right.rotation.y = Math.PI/2;
        group.add(right);
      }
      
      return group;
    }
    
    // ==================== FACADE TEXTURE GENERATOR ====================
    // Generate a facade texture with windows baked in
    // This replaces individual window meshes for MASSIVE performance gains
    function generateFacadeTexture(width, height, baseColor, windowColor = 'yellow') {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');
      
      // Background (building color)
      ctx.fillStyle = `#${baseColor.toString(16).padStart(6, '0')}`;
      ctx.fillRect(0, 0, 512, 512);
      
      // Window colors based on type
      const windowColors = {
        yellow: { lit: '#FFEB99', dim: '#6A5A4A' },
        white: { lit: '#FFFFFF', dim: '#8A8A8A' },
        black: { lit: '#2A2A2A', dim: '#1A1A1A' },
        blue: { lit: '#9DC6E8', dim: '#4A5A6A' }
      };
      const wColors = windowColors[windowColor] || windowColors.yellow;
      
      // Calculate window layout with MORE EDGE PADDING
      const floors = Math.max(3, Math.floor(height / 4));
      const windowsPerFloor = Math.max(2, Math.floor(width / 3));
      
      // INCREASED PADDING: Reserve 10% on each edge (20% total per dimension)
      const edgePaddingX = 512 * 0.1; // 10% padding on left and right
      const edgePaddingY = 512 * 0.1; // 10% padding on top and bottom
      const availableWidth = 512 - (edgePaddingX * 2);
      const availableHeight = 512 - (edgePaddingY * 2);
      
      const windowW = Math.floor(availableWidth / windowsPerFloor) - 18; // More window spacing
      const windowH = Math.floor(availableHeight / floors) - 20; // More window spacing
      
      // Draw windows with edge padding
      for (let floor = 0; floor < floors; floor++) {
        for (let win = 0; win < windowsPerFloor; win++) {
          // 70% chance lit
          const isLit = Math.random() > 0.3;
          ctx.fillStyle = isLit ? wColors.lit : wColors.dim;
          const x = edgePaddingX + win * (availableWidth / windowsPerFloor) + 9;
          const y = edgePaddingY + floor * (availableHeight / floors) + 10;
          ctx.fillRect(x, y, windowW, windowH);
          
          // Add slight glow to lit windows
          if (isLit) {
            ctx.fillStyle = 'rgba(255, 235, 153, 0.3)';
            ctx.fillRect(x - 2, y - 2, windowW + 4, windowH + 4);
          }
        }
      }
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.needsUpdate = true;
      return texture;
    }
    
    // Create HIGH detail building (full detail with decorations)
    // This is the existing createSegmentedBuilding function (we'll wrap it)
    
    function createSegmentedBuilding(localX, localZ, profile, blockSize) {
      const buildingGroup = new THREE.Group();
      const style = profile.buildingStyle;
      
      // Building dimensions
      const width = style.widthRange[0] + Math.random() * (style.widthRange[1] - style.widthRange[0]);
      const depth = style.depthRange[0] + Math.random() * (style.depthRange[1] - style.depthRange[0]);
      const totalHeight = style.heightRange[0] + Math.random() * (style.heightRange[1] - style.heightRange[0]);
      
      buildingGroup.position.set(localX, 0, localZ);
      
      // Pick colors
      const baseColor = profile.colorPalette[Math.floor(Math.random() * profile.colorPalette.length)];
      const accentColor = new THREE.Color(baseColor).multiplyScalar(1.15).getHex();
      
      // Pick window color from array
      const windowColor = profile.windowColors[Math.floor(Math.random() * profile.windowColors.length)];
      
      // Determine which facade faces the nearest sidewalk
      const edges = [
        { side: 'front', dist: blockSize - localZ, facingZ: 1 },  // Front (+Z)
        { side: 'back', dist: localZ, facingZ: -1 },              // Back (-Z)
        { side: 'right', dist: blockSize - localX, facingX: 1 },  // Right (+X)
        { side: 'left', dist: localX, facingX: -1 }               // Left (-X)
      ];
      const nearestSide = edges.reduce((min, edge) => edge.dist < min.dist ? edge : min);
      
      // Create base/podium (first 2-3 floors) with door on correct facade
      const podiumHeight = 8 + Math.random() * 4;
      createPodium(buildingGroup, width, depth, podiumHeight, baseColor, nearestSide);
      
      // Create shaft with potential setbacks
      let currentY = podiumHeight;
      let currentWidth = width;
      let currentDepth = depth;
      
      const floorHeight = 4.0;
      const totalFloors = Math.floor((totalHeight - podiumHeight) / floorHeight);
      
      // Apply setbacks if enabled
      if (Math.random() < style.setbackChance && style.setbackSchedule.length > 0) {
        let nextSetback = 0;
        let floorsBuilt = 0;
        
        while (floorsBuilt < totalFloors && nextSetback < style.setbackSchedule.length) {
          const setback = style.setbackSchedule[nextSetback];
          const floorsUntilSetback = Math.min(setback.atFloor - floorsBuilt, totalFloors - floorsBuilt);
          
          if (floorsUntilSetback > 0) {
            const segmentHeight = floorsUntilSetback * floorHeight;
            createShaftSegment(buildingGroup, currentWidth, currentDepth, segmentHeight, currentY, 
              baseColor, accentColor, style, windowColor);
            currentY += segmentHeight;
            floorsBuilt += floorsUntilSetback;
          }
          
          // Apply setback
          currentWidth -= setback.inset * 2;
          currentDepth -= setback.inset * 2;
          nextSetback++;
        }
        
        // Build remaining floors
        if (floorsBuilt < totalFloors) {
          const segmentHeight = (totalFloors - floorsBuilt) * floorHeight;
          createShaftSegment(buildingGroup, currentWidth, currentDepth, segmentHeight, currentY,
            baseColor, accentColor, style, windowColor);
          currentY += segmentHeight;
        }
      } else {
        // No setbacks - single shaft
        const shaftHeight = totalFloors * floorHeight;
        createShaftSegment(buildingGroup, currentWidth, currentDepth, shaftHeight, podiumHeight,
          baseColor, accentColor, style, windowColor);
        currentY += shaftHeight;
      }
      
      // Add crown/topper
      const crownStyles = style.crownStyle;
      const crownType = crownStyles[Math.floor(Math.random() * crownStyles.length)];
      if (crownType !== 'none') {
        createCrown(buildingGroup, currentWidth, currentDepth, currentY, crownType, baseColor, accentColor);
      }
      
        console.log(`Created building at (${localX}, ${localZ}) with height ${currentY.toFixed(1)}m, ${buildingGroup.children.length} children`);
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // WRAP IN THREE.LOD FOR AGGRESSIVE PERFORMANCE OPTIMIZATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const lod = new THREE.LOD();
        lod.position.set(localX, 0, localZ);
        
        // HIGH DETAIL: 0-100m (full building with decorations) - increased from 80m
        buildingGroup.position.set(0, 0, 0); // Reset position since LOD handles it
        lod.addLevel(buildingGroup, 0);
        
        // Determine building type based on characteristics
        let buildingLODType = 'box'; // default
        if (currentY > 60 && (width < 20 || depth < 20)) {
          buildingLODType = 'skyscraper'; // Tall and narrow
        } else if (currentY < 20) {
          buildingLODType = 'short'; // Short building
        } else if (style.setbackChance > 0.7 && buildingGroup.children.length > 5) {
          buildingLODType = 'stepped'; // Has setbacks
        }
        
        // MEDIUM DETAIL: 100-500m (simple box with facade texture) - increased from 80-250m
        const mediumBuilding = createBuildingMediumDetail(width, depth, currentY, baseColor, windowColor, buildingLODType);
        lod.addLevel(mediumBuilding, 100);
        
        // LOW DETAIL: 500m-800m (simple box with baked windows, MeshBasicMaterial) - increased for better distance view
        const lowBuilding = createBuildingLowDetail(width, depth, currentY, baseColor, windowColor, buildingLODType);
        lod.addLevel(lowBuilding, 500);
        
        // ULTRA-LOW DETAIL: 600m+ (minimal silhouette, no windows)
        const ultraLowGeo = new THREE.BoxGeometry(width, currentY, depth);
        const ultraLowMat = new THREE.MeshBasicMaterial({ 
          color: new THREE.Color(baseColor).multiplyScalar(0.5), // Darker for distance
          fog: true 
        });
        const ultraLowMesh = new THREE.Mesh(ultraLowGeo, ultraLowMat);
        ultraLowMesh.position.y = currentY / 2;
        const ultraLowGroup = new THREE.Group();
        ultraLowGroup.add(ultraLowMesh);
        lod.addLevel(ultraLowGroup, 600);
        
        // Mark as atomic pickable object for viewport
        lod.userData.isAtomic = true;
        lod.userData.pickable = true;
        lod.userData.objectType = 'building';
        
        // Assign unique ID for map system
        const buildingId = nextBuildingId++;
        lod.userData.id = buildingId;
        
        return {
          id: buildingId,
          group: lod,
          mesh: lod,
          width: width,
          depth: depth,
          height: currentY
        };
    }
    
    function createPodium(parent, width, depth, height, color, doorFacing) {
      const geometries = [];
      
      // Main podium box
      const podiumGeo = new THREE.BoxGeometry(width, height, depth);
      const podiumMesh = new THREE.Mesh(podiumGeo);
      podiumMesh.position.y = height / 2;
      podiumMesh.updateMatrix();
      geometries.push(podiumMesh.geometry.clone().applyMatrix4(podiumMesh.matrix));
      
      // Merge all podium geometries
      const mergedGeo = BufferGeometryUtils.mergeGeometries(geometries);
      const podiumMat = new THREE.MeshStandardMaterial({ color, roughness: 0.75, metalness: 0.15 });
      const podium = new THREE.Mesh(mergedGeo, podiumMat);
      podium.castShadow = true;
      podium.receiveShadow = true;
      parent.add(podium);
      
      // IMPROVED BASE FACADE with wider windows and door
      // Generate special podium texture with WIDER windows
      const podiumTexture = generatePodiumFacadeTexture(width, height, color);
      const podiumFacadeMat = new THREE.MeshStandardMaterial({
        map: podiumTexture,
        transparent: true,
        opacity: 0.95,
        emissive: new THREE.Color(color),
        emissiveIntensity: 0.05,
        roughness: 0.75,
        metalness: 0.1
      });
      
      const zOffset = 0.15;  // Increased from 0.06 to prevent z-fighting/flickering
      
      // Determine which face gets the door based on doorFacing
      const doorSide = doorFacing ? doorFacing.side : 'front';
      const doorWidth = 2.5;
      const doorHeight = 3.2;
      
      // Front facade (with possible door)
      const frontFacade = new THREE.Mesh(new THREE.PlaneGeometry(width, height), podiumFacadeMat);
      frontFacade.position.set(0, height/2, depth/2 + zOffset);
      parent.add(frontFacade);
      
      if (doorSide === 'front') {
        addDoorToFacade(parent, 0, doorHeight/2, depth/2 + zOffset + 0.02, doorWidth, doorHeight, 0, color);
      }
      
      // Back facade (with possible door)
      const backFacade = new THREE.Mesh(new THREE.PlaneGeometry(width, height), podiumFacadeMat.clone());
      backFacade.position.set(0, height/2, -depth/2 - zOffset);
      backFacade.rotation.y = Math.PI;
      parent.add(backFacade);
      
      if (doorSide === 'back') {
        addDoorToFacade(parent, 0, doorHeight/2, -depth/2 - zOffset - 0.02, doorWidth, doorHeight, Math.PI, color);
      }
      
      // Left facade (with possible door)
      const leftFacade = new THREE.Mesh(new THREE.PlaneGeometry(depth, height), podiumFacadeMat.clone());
      leftFacade.position.set(-width/2 - zOffset, height/2, 0);
      leftFacade.rotation.y = -Math.PI/2;
      parent.add(leftFacade);
      
      if (doorSide === 'left') {
        addDoorToFacade(parent, -width/2 - zOffset - 0.02, doorHeight/2, 0, doorWidth, doorHeight, -Math.PI/2, color);
      }
      
      // Right facade (with possible door)
      const rightFacade = new THREE.Mesh(new THREE.PlaneGeometry(depth, height), podiumFacadeMat.clone());
      rightFacade.position.set(width/2 + zOffset, height/2, 0);
      rightFacade.rotation.y = Math.PI/2;
      parent.add(rightFacade);
      
      if (doorSide === 'right') {
        addDoorToFacade(parent, width/2 + zOffset + 0.02, doorHeight/2, 0, doorWidth, doorHeight, Math.PI/2, color);
      }
    }
    
    // Generate podium facade texture with WIDER windows suitable for ground floor
    function generatePodiumFacadeTexture(width, height, baseColor) {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 256; // Shorter aspect for podium
      const ctx = canvas.getContext('2d');
      
      // Background
      ctx.fillStyle = `#${baseColor.toString(16).padStart(6, '0')}`;
      ctx.fillRect(0, 0, 512, 256);
      
      // Podium windows are WIDER and TALLER (storefront-style)
      const floors = Math.max(2, Math.floor(height / 4));
      const windowsPerFloor = Math.max(2, Math.floor(width / 5)); // Fewer, wider windows
      
      // Edge padding
      const edgePaddingX = 512 * 0.12; // More padding
      const edgePaddingY = 256 * 0.15;
      const availableWidth = 512 - (edgePaddingX * 2);
      const availableHeight = 256 - (edgePaddingY * 2);
      
      const windowW = Math.floor(availableWidth / windowsPerFloor) - 12; // WIDER
      const windowH = Math.floor(availableHeight / floors) - 8; // TALLER
      
      // Draw wider windows
      for (let floor = 0; floor < floors; floor++) {
        for (let win = 0; win < windowsPerFloor; win++) {
          const isLit = Math.random() > 0.2; // 80% lit at ground level
          ctx.fillStyle = isLit ? '#FFEB99' : '#6A5A4A';
          const x = edgePaddingX + win * (availableWidth / windowsPerFloor) + 6;
          const y = edgePaddingY + floor * (availableHeight / floors) + 4;
          ctx.fillRect(x, y, windowW, windowH);
          
          // Glow
          if (isLit) {
            ctx.fillStyle = 'rgba(255, 235, 153, 0.4)';
            ctx.fillRect(x - 3, y - 3, windowW + 6, windowH + 6);
          }
        }
      }
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.needsUpdate = true;
      return texture;
    }
    
    // Add door with reactive light above it
    function addDoorToFacade(parent, x, y, z, doorWidth, doorHeight, rotationY, buildingColor) {
      // Door frame
      const doorFrameGeo = new THREE.BoxGeometry(doorWidth + 0.2, doorHeight + 0.2, 0.08);
      const doorFrameMat = new THREE.MeshStandardMaterial({ 
        color: new THREE.Color(buildingColor).multiplyScalar(0.7),
        roughness: 0.8,
        metalness: 0.2
      });
      const doorFrame = new THREE.Mesh(doorFrameGeo, doorFrameMat);
      doorFrame.position.set(x, y, z);
      doorFrame.rotation.y = rotationY;
      parent.add(doorFrame);
      
      // Door itself
      const doorGeo = new THREE.BoxGeometry(doorWidth, doorHeight, 0.05);
      const doorMat = new THREE.MeshStandardMaterial({ 
        color: 0x2a1a0a,
        roughness: 0.6,
        metalness: 0.4
      });
      const door = new THREE.Mesh(doorGeo, doorMat);
      door.position.set(x, y, z);
      door.rotation.y = rotationY;
      parent.add(door);
      
      // Door handle
      const handleGeo = new THREE.BoxGeometry(0.08, 0.3, 0.12);
      const handleMat = new THREE.MeshStandardMaterial({ 
        color: 0xcccccc,
        roughness: 0.2,
        metalness: 0.9
      });
      const handle = new THREE.Mesh(handleGeo, handleMat);
      
      // Position handle based on rotation
      const handleOffset = doorWidth * 0.35;
      if (rotationY === 0) {
        handle.position.set(x + handleOffset, y, z + 0.08);
      } else if (rotationY === Math.PI) {
        handle.position.set(x - handleOffset, y, z - 0.08);
      } else if (rotationY === Math.PI/2) {
        handle.position.set(x + 0.08, y, z + handleOffset);
      } else if (rotationY === -Math.PI/2) {
        handle.position.set(x - 0.08, y, z - handleOffset);
      }
      handle.rotation.y = rotationY;
      parent.add(handle);
      
      // REACTIVE LIGHT ABOVE DOOR
      const lightHeight = doorHeight + 0.4;
      
      // Light housing
      const lightHousingGeo = new THREE.CylinderGeometry(0.15, 0.18, 0.12, 8);
      const lightHousingMat = new THREE.MeshStandardMaterial({ 
        color: 0x333333,
        roughness: 0.7,
        metalness: 0.3
      });
      const lightHousing = new THREE.Mesh(lightHousingGeo, lightHousingMat);
      
      // Position light based on rotation
      if (rotationY === 0) {
        lightHousing.position.set(x, y + lightHeight, z + 0.15);
      } else if (rotationY === Math.PI) {
        lightHousing.position.set(x, y + lightHeight, z - 0.15);
      } else if (rotationY === Math.PI/2) {
        lightHousing.position.set(x + 0.15, y + lightHeight, z);
      } else if (rotationY === -Math.PI/2) {
        lightHousing.position.set(x - 0.15, y + lightHeight, z);
      }
      lightHousing.rotation.x = Math.PI / 2;
      lightHousing.rotation.y = rotationY;
      parent.add(lightHousing);
      
      // Light source (glowing plane)
      const lightPlaneGeo = new THREE.CircleGeometry(0.12, 12);
      const lightPlaneMat = new THREE.MeshBasicMaterial({ 
        color: 0xffffaa,
        emissive: 0xffffaa,
        emissiveIntensity: 1.0,
        side: THREE.DoubleSide
      });
      const lightPlane = new THREE.Mesh(lightPlaneGeo, lightPlaneMat);
      
      // Position light plane
      if (rotationY === 0) {
        lightPlane.position.set(x, y + lightHeight, z + 0.2);
      } else if (rotationY === Math.PI) {
        lightPlane.position.set(x, y + lightHeight, z - 0.2);
      } else if (rotationY === Math.PI/2) {
        lightPlane.position.set(x + 0.2, y + lightHeight, z);
      } else if (rotationY === -Math.PI/2) {
        lightPlane.position.set(x - 0.2, y + lightHeight, z);
      }
      lightPlane.rotation.x = Math.PI / 2;
      lightPlane.rotation.z = rotationY;
      parent.add(lightPlane);
      
      // Add actual point light for illumination
      const pointLight = new THREE.PointLight(0xffffaa, 0.8, 6);
      pointLight.position.copy(lightPlane.position);
      parent.add(pointLight);
    }
    
    function createShaftSegment(parent, width, depth, height, yOffset, baseColor, accentColor, style, windowColor) {
      const geometries = [];
      
      // Main shaft volume
      const shaftGeo = new THREE.BoxGeometry(width, height, depth);
      const shaftMesh = new THREE.Mesh(shaftGeo);
      shaftMesh.position.y = yOffset + height / 2;
      shaftMesh.updateMatrix();
      geometries.push(shaftMesh.geometry.clone().applyMatrix4(shaftMesh.matrix));
      
      // Corner treatment (merge with shaft)
      if (style.cornerTreatment === 'thinBar') {
        const barWidth = 0.15;
        const barGeo = new THREE.BoxGeometry(barWidth, height, barWidth);
        
        // Four corners
        [[-width/2, -depth/2], [width/2, -depth/2], [width/2, depth/2], [-width/2, depth/2]].forEach(([x, z]) => {
          const barMesh = new THREE.Mesh(barGeo);
          barMesh.position.set(x, yOffset + height/2, z);
          barMesh.updateMatrix();
          geometries.push(barMesh.geometry.clone().applyMatrix4(barMesh.matrix));
        });
      }
      
      // Merge shaft and corners
      const mergedGeo = BufferGeometryUtils.mergeGeometries(geometries);
      const shaftMat = new THREE.MeshStandardMaterial({ color: baseColor, roughness: 0.75, metalness: 0.15 });
      const shaft = new THREE.Mesh(mergedGeo, shaftMat);
      shaft.castShadow = true;
      shaft.receiveShadow = true;
      parent.add(shaft);
      
      // TEXTURE-BASED WINDOWS - much more efficient than individual meshes
      // Generate facade texture with windows
      const facadeTexture = generateFacadeTexture(Math.max(width, depth), height, baseColor, windowColor);
      const facadeMat = new THREE.MeshStandardMaterial({ 
        map: facadeTexture,
        transparent: true,
        opacity: 0.95,
        emissive: new THREE.Color(baseColor),
        emissiveIntensity: 0.05,
        roughness: 0.7,
        metalness: 0.1
      });
      
      // Add facade planes for all four sides with proper offset
      const zOffset = 0.15;  // Increased from 0.06 to prevent z-fighting/flickering
      
      // Front facade
      const frontFacade = new THREE.Mesh(new THREE.PlaneGeometry(width, height), facadeMat);
      frontFacade.position.set(0, yOffset + height/2, depth/2 + zOffset);
      parent.add(frontFacade);
      
      // Back facade
      const backFacade = new THREE.Mesh(new THREE.PlaneGeometry(width, height), facadeMat.clone());
      backFacade.position.set(0, yOffset + height/2, -depth/2 - zOffset);
      backFacade.rotation.y = Math.PI;
      parent.add(backFacade);
      
      // Left facade
      const leftFacade = new THREE.Mesh(new THREE.PlaneGeometry(depth, height), facadeMat.clone());
      leftFacade.position.set(-width/2 - zOffset, yOffset + height/2, 0);
      leftFacade.rotation.y = -Math.PI/2;
      parent.add(leftFacade);
      
      // Right facade
      const rightFacade = new THREE.Mesh(new THREE.PlaneGeometry(depth, height), facadeMat.clone());
      rightFacade.position.set(width/2 + zOffset, yOffset + height/2, 0);
      rightFacade.rotation.y = Math.PI/2;
      parent.add(rightFacade);
      
      // Add facade decorations (stripes, bands, columns) over the textured facades
        const decorType = Math.random();
        if (decorType < 0.25 && style.shaftSliceStyle !== 'ribbons') {
          // Vertical stripes
          const stripes = 3 + Math.floor(Math.random() * 5); // 3-7 stripes
          for (let i = 0; i < stripes; i++) {
            const stripeX = -width/2 + (i + 0.5) * (width / stripes);
            const stripeWidth = 0.12 + Math.random() * 0.15;
            const stripeGeo = new THREE.BoxGeometry(stripeWidth, height, 0.08);
            const stripeMat = new THREE.MeshStandardMaterial({ color: accentColor, roughness: 0.7, metalness: 0.2 });
            const stripe = new THREE.Mesh(stripeGeo, stripeMat);
          stripe.position.set(stripeX, yOffset + height/2, depth/2 + 0.08);
            parent.add(stripe);
            const stripeBack = stripe.clone();
          stripeBack.position.z = -depth/2 - 0.08;
            parent.add(stripeBack);
          }
        } else if (decorType >= 0.25 && decorType < 0.5) {
          // Horizontal bands
          const bands = 2 + Math.floor(Math.random() * 4); // 2-5 bands
          for (let i = 0; i < bands; i++) {
            const bandY = yOffset + (i + 1) * (height / (bands + 1));
            const bandHeight = 0.15 + Math.random() * 0.2;
            const bandGeo = new THREE.BoxGeometry(width + 0.1, bandHeight, 0.06);
            const bandMat = new THREE.MeshStandardMaterial({ color: accentColor, roughness: 0.75, metalness: 0.15 });
            const band = new THREE.Mesh(bandGeo, bandMat);
          band.position.set(0, bandY, depth/2 + 0.08);
            parent.add(band);
            const bandBack = band.clone();
          bandBack.position.z = -depth/2 - 0.08;
            parent.add(bandBack);
          }
        } else if (decorType >= 0.5 && decorType < 0.7) {
          // Columns with capitals
          const columns = 3 + Math.floor(Math.random() * 4); // 3-6 columns
          for (let i = 0; i < columns; i++) {
            const colX = -width/2 + (i + 0.5) * (width / columns);
            const colWidth = 0.18 + Math.random() * 0.12;
            const colGeo = new THREE.BoxGeometry(colWidth, height * 0.85, colWidth);
            const colMat = new THREE.MeshStandardMaterial({ color: accentColor, roughness: 0.8, metalness: 0.1 });
            const column = new THREE.Mesh(colGeo, colMat);
          column.position.set(colX, yOffset + height * 0.425, depth/2 + 0.08);
            parent.add(column);
            const headerGeo = new THREE.BoxGeometry(colWidth * 1.6, colWidth * 0.6, colWidth * 1.6);
            const header = new THREE.Mesh(headerGeo, colMat);
          header.position.set(colX, yOffset + height * 0.85 + colWidth * 0.3, depth/2 + 0.08);
            parent.add(header);
          }
        } else if (decorType >= 0.7 && decorType < 0.85) {
          // Inset panels
          const panels = 2 + Math.floor(Math.random() * 3); // 2-4 panels
          for (let i = 0; i < panels; i++) {
            const panelY = yOffset + (i + 0.5) * (height / panels);
            const panelH = height / panels * 0.7;
            const panelW = width * 0.6;
            const panelGeo = new THREE.BoxGeometry(panelW, panelH, 0.05);
            const panelMat = new THREE.MeshStandardMaterial({ 
              color: new THREE.Color(baseColor).multiplyScalar(0.85).getHex(), 
              roughness: 0.8, metalness: 0.05 
            });
            const panel = new THREE.Mesh(panelGeo, panelMat);
          panel.position.set(0, panelY, depth/2 + 0.04);
            parent.add(panel);
          }
        }
    }
    
    function addWindow(parent, x, y, z, w, h, color, isLit, rotationY = 0) {
      // Check if windows are enabled
      if (!optimizationConfig.windows.enabled) {
        return; // Skip window entirely
      }
      
      // Check window count limit
      if (optimizationConfig.windows.currentCount >= optimizationConfig.windows.maxCount) {
        return; // Max windows reached
      }
      
      const winGeo = new THREE.PlaneGeometry(w, h);
      const winMat = new THREE.MeshStandardMaterial({ 
        color, 
        emissive: color, 
        emissiveIntensity: isLit ? 0.5 : 0.05,
        transparent: true,
        opacity: isLit ? 0.85 : 0.3,
        roughness: 0.3,
        metalness: 0.1,
        depthTest: true,
        depthWrite: false // Prevent z-fighting
      });
      const win = new THREE.Mesh(winGeo, winMat);
      
      // Offset window slightly from wall to prevent z-fighting
      const offset = 0.01;
      let winX = x, winY = y, winZ = z;
      if (rotationY === 0) { // Front (+Z)
        winZ += offset;
      } else if (Math.abs(rotationY - Math.PI) < 0.1) { // Back (-Z)
        winZ -= offset;
      } else if (Math.abs(rotationY - Math.PI/2) < 0.1) { // Right (+X)
        winX += offset;
      } else if (Math.abs(rotationY + Math.PI/2) < 0.1) { // Left (-X)
        winX -= offset;
      }
      
      win.position.set(winX, winY, winZ);
      win.rotation.y = rotationY;
      win.renderOrder = 1; // Render after building walls
      win.userData.isWindow = true;
      parent.add(win);
      optimizationConfig.windows.currentCount++; // Track window count
      
      // Add simple sill with proper rotation (only if enabled)
      if (optimizationConfig.sills.enabled && optimizationConfig.sills.currentCount < optimizationConfig.sills.maxCount) {
        const sillGeo = new THREE.BoxGeometry(w + 0.1, 0.04, 0.08);
        const sillMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.8, metalness: 0.1 });
        const sill = new THREE.Mesh(sillGeo, sillMat);
        sill.position.set(x, y - h/2 - 0.02, z);
        sill.rotation.y = rotationY;
        
        // Offset sill forward based on rotation
        const sillOffset = 0.04;
        if (rotationY === 0) { // Front (+Z)
          sill.position.z += sillOffset;
        } else if (Math.abs(rotationY - Math.PI) < 0.1) { // Back (-Z)
          sill.position.z -= sillOffset;
        } else if (Math.abs(rotationY - Math.PI/2) < 0.1) { // Right (+X)
          sill.position.x += sillOffset;
        } else if (Math.abs(rotationY + Math.PI/2) < 0.1) { // Left (-X)
          sill.position.x -= sillOffset;
        }
        
        sill.castShadow = false;
        sill.receiveShadow = false;
        sill.userData.isSill = true; // Mark for LOD
        parent.add(sill);
        optimizationConfig.sills.currentCount++; // Track sill count
      }
    }
    
    function createCrown(parent, width, depth, yOffset, crownType, baseColor, accentColor) {
      if (crownType === 'antenna') {
        // Multi-stage antenna
        const stages = 3;
        let currentY = yOffset;
        let currentRadius = Math.min(width, depth) * 0.15;
        
        for (let s = 0; s < stages; s++) {
          const stageHeight = 3 + s * 2;
          const stageGeo = new THREE.CylinderGeometry(currentRadius * 0.7, currentRadius, stageHeight, 8);
          const stageMat = new THREE.MeshStandardMaterial({ color: accentColor, roughness: 0.4, metalness: 0.6 });
          const stage = new THREE.Mesh(stageGeo, stageMat);
          stage.position.y = currentY + stageHeight / 2;
          stage.castShadow = true;
          parent.add(stage);
          
          currentY += stageHeight;
          currentRadius *= 0.6;
        }
        
        // Top sphere (blinking light)
        const sphereGeo = new THREE.SphereGeometry(currentRadius * 1.5, 8, 8);
        const sphereMat = new THREE.MeshStandardMaterial({ 
          color: 0xff4444, 
          emissive: 0xff0000, 
          emissiveIntensity: 0.8,
          roughness: 0.3,
          metalness: 0.1
        });
        const sphere = new THREE.Mesh(sphereGeo, sphereMat);
        sphere.position.y = currentY + currentRadius;
        parent.add(sphere);
        
      } else if (crownType === 'steppedZiggurat') {
        // Stepped pyramid
        const steps = 4;
        let currentY = yOffset;
        let currentW = width;
        let currentD = depth;
        
        for (let s = 0; s < steps; s++) {
          const stepHeight = 2.5;
          const stepGeo = new THREE.BoxGeometry(currentW, stepHeight, currentD);
          const stepMat = new THREE.MeshStandardMaterial({ 
            color: new THREE.Color(baseColor).multiplyScalar(1 - s * 0.05).getHex(),
            roughness: 0.75,
            metalness: 0.15
          });
          const step = new THREE.Mesh(stepGeo, stepMat);
          step.position.y = currentY + stepHeight / 2;
          step.castShadow = true;
          parent.add(step);
          
          currentY += stepHeight;
          currentW *= 0.8;
          currentD *= 0.8;
        }
      } else if (crownType === 'pyramid') {
        // Smooth pyramid crown
        const pyramidHeight = Math.min(width, depth) * 0.6;
        const pyramidGeo = new THREE.ConeGeometry(Math.min(width, depth) * 0.6, pyramidHeight, 4);
        pyramidGeo.rotateY(Math.PI / 4);
        const pyramidMat = new THREE.MeshStandardMaterial({ 
          color: new THREE.Color(baseColor).multiplyScalar(0.9).getHex(),
          roughness: 0.7,
          metalness: 0.2
        });
        const pyramid = new THREE.Mesh(pyramidGeo, pyramidMat);
        pyramid.position.y = yOffset + pyramidHeight / 2;
        pyramid.castShadow = true;
        parent.add(pyramid);
        
      } else if (crownType === 'dome') {
        // Dome crown
        const domeRadius = Math.min(width, depth) * 0.45;
        const domeGeo = new THREE.SphereGeometry(domeRadius, 12, 8, 0, Math.PI * 2, 0, Math.PI / 2);
        const domeMat = new THREE.MeshStandardMaterial({ 
          color: accentColor,
          roughness: 0.3,
          metalness: 0.6
        });
        const dome = new THREE.Mesh(domeGeo, domeMat);
        dome.position.y = yOffset;
        dome.castShadow = true;
        parent.add(dome);
        
      } else if (crownType === 'spire') {
        // Tall thin spire
        const spireHeight = 12;
        const spireGeo = new THREE.ConeGeometry(0.8, spireHeight, 8);
        const spireMat = new THREE.MeshStandardMaterial({ 
          color: accentColor,
          roughness: 0.4,
          metalness: 0.7
        });
        const spire = new THREE.Mesh(spireGeo, spireMat);
        spire.position.y = yOffset + spireHeight / 2;
        spire.castShadow = true;
        parent.add(spire);
        
      } else if (crownType === 'flatMech') {
        // Flat mechanical penthouse
        const mechHeight = 3;
        const mechGeo = new THREE.BoxGeometry(width * 0.9, mechHeight, depth * 0.9);
        const mechMat = new THREE.MeshStandardMaterial({ color: baseColor, roughness: 0.8, metalness: 0.2 });
        const mech = new THREE.Mesh(mechGeo, mechMat);
        mech.position.y = yOffset + mechHeight / 2;
        mech.castShadow = true;
        parent.add(mech);
      }
    }
    
    // ==================== FRACTAL TREE SYSTEM ====================
    const treePrototypes = [];
    
    function createTreePrototypes() {
      // Create 3 tree varieties
      const variants = [
        { trunkColor: 0x4a3828, foliageColor: 0x3a5a2a, branchAngle: 25, branchLength: 0.7 },
        { trunkColor: 0x3a2818, foliageColor: 0x2a4a1a, branchAngle: 35, branchLength: 0.65 },
        { trunkColor: 0x5a4838, foliageColor: 0x4a6a3a, branchAngle: 30, branchLength: 0.75 }
      ];
      
      variants.forEach((variant, idx) => {
        const treeGroup = new THREE.Group();
        
        // Store variant index for material lookup
        treeGroup.userData.variantIdx = idx;
        
        // Generate fractal branches
        const branchGeometries = [];
        
        function addBranch(startPos, direction, radius, length, depth) {
          if (depth <= 0 || radius < 0.015) return;
          
          const endPos = startPos.clone().add(direction.clone().multiplyScalar(length));
          
          // Create cylinder for branch
          const branchGeo = new THREE.CylinderGeometry(radius * 0.75, radius, length, 4);
          branchGeo.translate(0, length / 2, 0);
          
          // Orient branch
          const branchMesh = new THREE.Mesh(branchGeo);
          branchMesh.position.copy(startPos);
          
          const axis = new THREE.Vector3(0, 1, 0);
          const quaternion = new THREE.Quaternion().setFromUnitVectors(axis, direction.clone().normalize());
          branchMesh.quaternion.copy(quaternion);
          
          branchMesh.updateMatrix();
          branchGeometries.push(branchMesh.geometry.clone().applyMatrix4(branchMesh.matrix));
          
          // Add leaf cluster along branch (not just at tip)
          if (depth <= 2) {
            const foliageSize = radius * 6 + 0.3;
            const foliageGeo = new THREE.SphereGeometry(foliageSize, 4, 4);
            const foliageMesh = new THREE.Mesh(foliageGeo);
            foliageMesh.position.copy(endPos);
            foliageMesh.updateMatrix();
            
            const foliageClone = foliageMesh.geometry.clone().applyMatrix4(foliageMesh.matrix);
            treeGroup.userData.foliageGeos = treeGroup.userData.foliageGeos || [];
            treeGroup.userData.foliageGeos.push(foliageClone);
          }
          
          // Recursively add child branches - extend in XZ plane
          if (depth > 1) {
            const numBranches = depth > 3 ? 2 : (depth > 2 ? 3 : 4);
            
            for (let i = 0; i < numBranches; i++) {
              // Spread branches around in XZ plane
              const azimuth = (i / numBranches) * Math.PI * 2 + Math.random() * 0.3;
              
              // Angle from vertical - branches extend more horizontally at higher levels
              const elevationAngle = (30 + Math.random() * 20 + (5 - depth) * 10) * Math.PI / 180;
              
              // Calculate new direction extending in XZ
              const newDir = new THREE.Vector3(
                Math.sin(elevationAngle) * Math.cos(azimuth),
                Math.cos(elevationAngle) * (0.5 + Math.random() * 0.3), // Some upward component with variation
                Math.sin(elevationAngle) * Math.sin(azimuth)
              ).normalize();
              
              addBranch(
                endPos.clone(),
                newDir,
                radius * variant.branchLength,
                length * variant.branchLength * 0.9,
                depth - 1
              );
            }
          }
        }
        
        // Start trunk
        const trunkHeight = 3.5;
        const trunkRadius = 0.35;
        addBranch(
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(0, 1, 0),
          trunkRadius,
          trunkHeight,
          4  // Reduced depth for performance
        );
        
        // Merge branch geometries and use shared material
        const mergedBranches = BufferGeometryUtils.mergeGeometries(branchGeometries);
        const branchMat = [sharedMaterials.treeTrunk1, sharedMaterials.treeTrunk2, sharedMaterials.treeTrunk3][idx];
        const branchMesh = new THREE.Mesh(mergedBranches, branchMat);
        branchMesh.castShadow = true;
        branchMesh.receiveShadow = true;
        treeGroup.add(branchMesh);
        
        // Merge foliage geometries and use shared material
        if (treeGroup.userData.foliageGeos && treeGroup.userData.foliageGeos.length > 0) {
          const mergedFoliage = BufferGeometryUtils.mergeGeometries(treeGroup.userData.foliageGeos);
          const foliageMat = [sharedMaterials.treeFoliage1, sharedMaterials.treeFoliage2, sharedMaterials.treeFoliage3][idx];
          const foliageMesh = new THREE.Mesh(mergedFoliage, foliageMat);
          foliageMesh.castShadow = true;
          foliageMesh.receiveShadow = true;
          treeGroup.add(foliageMesh);
        }
        
        treePrototypes.push(treeGroup);
      });
      
      console.log(`Created ${treePrototypes.length} tree prototypes`);
    }
    
    function createFractalTrees(positions, sidewalkHeight) {
      if (treePrototypes.length === 0) {
        createTreePrototypes();
      }
      
      positions.forEach(pos => {
        const protoIdx = Math.floor(Math.random() * treePrototypes.length);
        const treeClone = treePrototypes[protoIdx].clone();
        treeClone.position.set(pos.x, sidewalkHeight, pos.z);
        
        // Slight random rotation and scale variation
        treeClone.rotation.y = Math.random() * Math.PI * 2;
        const scale = 0.9 + Math.random() * 0.3;
        treeClone.scale.set(scale, scale, scale);
        
        worldRoot.add(treeClone);
      });
      
      console.log(`Placed ${positions.length} fractal trees`);
    }
    
    // ==================== ROAD SYSTEM ====================
    function createRoadNetwork() {
      const roadWidth = CONFIG.ROAD_WIDTH;
      const sidewalkWidth = CONFIG.SIDEWALK_WIDTH;
      const sidewalkHeight = CONFIG.SIDEWALK_HEIGHT;
      const blockSize = CONFIG.BLOCK_SIZE;
      const blocksX = CONFIG.CITY_BLOCKS_X;
      const blocksZ = CONFIG.CITY_BLOCKS_Z;
      
      const cityWidth = blocksX * (blockSize + roadWidth) + roadWidth;
      const cityDepth = blocksZ * (blockSize + roadWidth) + roadWidth;
      const offsetX = -cityWidth / 2;
      const offsetZ = -cityDepth / 2;
      
      const laneWidth = (roadWidth - sidewalkWidth * 2) / 2;
      const curbHeight = 0.1;
      
      const roadMaterial = sharedMaterials.road;
      const sidewalkMaterial = sharedMaterials.sidewalk;
      const curbMaterial = sharedMaterials.curb;
      const yellowLineMaterial = sharedMaterials.laneLine;
      const whiteLineMaterial = sharedMaterials.laneLine;
      
      // Instanced curb geometry
      const curbGeo = new THREE.BoxGeometry(0.15, curbHeight, 1);
      const curbPositions = [];
      const treePositions = [];
      const streetLightPositions = [];
      
      // Create horizontal roads (along Z axis)
      for (let x = 0; x <= blocksX; x++) {
        const roadX = offsetX + x * (blockSize + roadWidth) + roadWidth / 2;
        
        // Main road surface
        const roadGeo = new THREE.PlaneGeometry(roadWidth - sidewalkWidth * 2, cityDepth);
        const road = new THREE.Mesh(roadGeo, roadMaterial);
        road.rotation.x = -Math.PI / 2;
        road.position.set(roadX, 0.03, 0);
        road.receiveShadow = true;
        worldRoot.add(road);
        
        // Left 3D sidewalk
        const leftSidewalkGeo = new THREE.BoxGeometry(sidewalkWidth, sidewalkHeight, cityDepth);
        const leftSidewalk = new THREE.Mesh(leftSidewalkGeo, sidewalkMaterial);
        leftSidewalk.position.set(roadX - roadWidth/2 + sidewalkWidth/2, sidewalkHeight/2, 0);
        leftSidewalk.receiveShadow = true;
        leftSidewalk.castShadow = false;
        worldRoot.add(leftSidewalk);
        
        // Right 3D sidewalk
        const rightSidewalk = new THREE.Mesh(leftSidewalkGeo, sidewalkMaterial);
        rightSidewalk.position.set(roadX + roadWidth/2 - sidewalkWidth/2, sidewalkHeight/2, 0);
        rightSidewalk.receiveShadow = true;
        rightSidewalk.castShadow = false;
        worldRoot.add(rightSidewalk);
        
        // Collect curb positions along both sides
        for (let z = -cityDepth/2; z < cityDepth/2; z += 1) {
          // Left curb
          curbPositions.push({
            x: roadX - roadWidth/2 + sidewalkWidth,
            y: sidewalkHeight + curbHeight/2,
            z: z,
            rotY: 0
          });
          // Right curb
          curbPositions.push({
            x: roadX + roadWidth/2 - sidewalkWidth,
            y: sidewalkHeight + curbHeight/2,
            z: z,
            rotY: 0
          });
        }
        
        // Collect tree positions along sidewalks
        for (let z = -cityDepth/2 + 5; z < cityDepth/2; z += 8) {
          if (Math.random() > 0.3) {  // 70% chance of tree
            treePositions.push({
              x: roadX - roadWidth/2 + sidewalkWidth/2,
              z: z
            });
            treePositions.push({
              x: roadX + roadWidth/2 - sidewalkWidth/2,
              z: z
            });
          }
        }
        
        // Collect street light positions (every 20m, opposite side from trees)
        for (let z = -cityDepth/2 + 10; z < cityDepth/2; z += 20) {
          streetLightPositions.push({
            x: roadX - roadWidth/2 + sidewalkWidth * 0.8,
            z: z
          });
          streetLightPositions.push({
            x: roadX + roadWidth/2 - sidewalkWidth * 0.8,
            z: z + 10 // Offset for staggered pattern
          });
        }
        
        // Yellow center divider line (dashed)
        for (let z = -cityDepth/2; z < cityDepth/2; z += 8) {
          const dashGeo = new THREE.PlaneGeometry(0.15, 4);
          const dash = new THREE.Mesh(dashGeo, yellowLineMaterial);
          dash.rotation.x = -Math.PI / 2;
          dash.position.set(roadX, 0.05, z + 2);
          worldRoot.add(dash);
        }
        
        // White edge lines (solid)
        const edgeLineGeo = new THREE.PlaneGeometry(0.12, cityDepth);
        const leftEdge = new THREE.Mesh(edgeLineGeo, whiteLineMaterial);
        leftEdge.rotation.x = -Math.PI / 2;
        leftEdge.position.set(roadX - laneWidth, 0.05, 0);
        worldRoot.add(leftEdge);
        
        const rightEdge = new THREE.Mesh(edgeLineGeo, whiteLineMaterial);
        rightEdge.rotation.x = -Math.PI / 2;
        rightEdge.position.set(roadX + laneWidth, 0.05, 0);
        worldRoot.add(rightEdge);
      }
      
      // Create vertical roads (along X axis)
      for (let z = 0; z <= blocksZ; z++) {
        const roadZ = offsetZ + z * (blockSize + roadWidth) + roadWidth / 2;
        
        // Main road surface
        const roadGeo = new THREE.PlaneGeometry(cityWidth, roadWidth - sidewalkWidth * 2);
        const road = new THREE.Mesh(roadGeo, roadMaterial);
        road.rotation.x = -Math.PI / 2;
        road.position.set(0, 0.03, roadZ);
        road.receiveShadow = true;
        worldRoot.add(road);
        
        // Top 3D sidewalk
        const topSidewalkGeo = new THREE.BoxGeometry(cityWidth, sidewalkHeight, sidewalkWidth);
        const topSidewalk = new THREE.Mesh(topSidewalkGeo, sidewalkMaterial);
        topSidewalk.position.set(0, sidewalkHeight/2, roadZ - roadWidth/2 + sidewalkWidth/2);
        topSidewalk.receiveShadow = true;
        topSidewalk.castShadow = false;
        worldRoot.add(topSidewalk);
        
        // Bottom 3D sidewalk
        const bottomSidewalk = new THREE.Mesh(topSidewalkGeo, sidewalkMaterial);
        bottomSidewalk.position.set(0, sidewalkHeight/2, roadZ + roadWidth/2 - sidewalkWidth/2);
        bottomSidewalk.receiveShadow = true;
        bottomSidewalk.castShadow = false;
        worldRoot.add(bottomSidewalk);
        
        // Collect curb positions along both sides
        for (let x = -cityWidth/2; x < cityWidth/2; x += 1) {
          // Top curb
          curbPositions.push({
            x: x,
            y: sidewalkHeight + curbHeight/2,
            z: roadZ - roadWidth/2 + sidewalkWidth,
            rotY: Math.PI/2
          });
          // Bottom curb
          curbPositions.push({
            x: x,
            y: sidewalkHeight + curbHeight/2,
            z: roadZ + roadWidth/2 - sidewalkWidth,
            rotY: Math.PI/2
          });
        }
        
        // Collect tree positions along sidewalks
        for (let x = -cityWidth/2 + 5; x < cityWidth/2; x += 8) {
          if (Math.random() > 0.3) {  // 70% chance of tree
            treePositions.push({
              x: x,
              z: roadZ - roadWidth/2 + sidewalkWidth/2
            });
            treePositions.push({
              x: x,
              z: roadZ + roadWidth/2 - sidewalkWidth/2
            });
          }
        }
        
        // Collect street light positions (every 20m)
        for (let x = -cityWidth/2 + 10; x < cityWidth/2; x += 20) {
          streetLightPositions.push({
            x: x,
            z: roadZ - roadWidth/2 + sidewalkWidth * 0.8
          });
          streetLightPositions.push({
            x: x + 10,
            z: roadZ + roadWidth/2 - sidewalkWidth * 0.8
          });
        }
        
        // Yellow center divider line (dashed)
        for (let x = -cityWidth/2; x < cityWidth/2; x += 8) {
          const dashGeo = new THREE.PlaneGeometry(4, 0.15);
          const dash = new THREE.Mesh(dashGeo, yellowLineMaterial);
          dash.rotation.x = -Math.PI / 2;
          dash.position.set(x + 2, 0.05, roadZ);
          worldRoot.add(dash);
        }
        
        // White edge lines (solid)
        const edgeLineGeo = new THREE.PlaneGeometry(cityWidth, 0.12);
        const topEdge = new THREE.Mesh(edgeLineGeo, whiteLineMaterial);
        topEdge.rotation.x = -Math.PI / 2;
        topEdge.position.set(0, 0.05, roadZ - laneWidth);
        worldRoot.add(topEdge);
        
        const bottomEdge = new THREE.Mesh(edgeLineGeo, whiteLineMaterial);
        bottomEdge.rotation.x = -Math.PI / 2;
        bottomEdge.position.set(0, 0.05, roadZ + laneWidth);
        worldRoot.add(bottomEdge);
      }
      
      // Create instanced curbs
      if (curbPositions.length > 0) {
        const curbInstanceMesh = new THREE.InstancedMesh(curbGeo, curbMaterial, curbPositions.length);
        const matrix = new THREE.Matrix4();
        const quaternion = new THREE.Quaternion();
        
        curbPositions.forEach((pos, i) => {
          quaternion.setFromEuler(new THREE.Euler(0, pos.rotY, 0));
          matrix.compose(
            new THREE.Vector3(pos.x, pos.y, pos.z),
            quaternion,
            new THREE.Vector3(1, 1, 1)
          );
          curbInstanceMesh.setMatrixAt(i, matrix);
        });
        
        curbInstanceMesh.instanceMatrix.needsUpdate = true;
        curbInstanceMesh.castShadow = false;
        curbInstanceMesh.receiveShadow = false;
        worldRoot.add(curbInstanceMesh);
        console.log(`Created ${curbPositions.length} instanced curbs`);
      }
      
      // Create instanced fractal trees
      if (treePositions.length > 0) {
        createFractalTrees(treePositions, sidewalkHeight);
      }
      
      // Create instanced street lights
      if (streetLightPositions.length > 0) {
        createStreetLights(streetLightPositions, sidewalkHeight);
      }
      
      console.log('Road network with 3D sidewalks, curbs, trees, and street lights created');
    }
    
    // ==================== STREET LIGHT SYSTEM ====================
    function createStreetLights(positions, sidewalkHeight) {
      // Create single street light prototype
      const lightGroup = new THREE.Group();
      
      // Pole
      const poleHeight = 6;
      const poleRadius = 0.08;
      const poleGeo = new THREE.CylinderGeometry(poleRadius, poleRadius * 1.2, poleHeight, 8);
      const poleMat = new THREE.MeshStandardMaterial({ 
        color: 0x2a2a2a, 
        roughness: 0.6, 
        metalness: 0.8 
      });
      const pole = new THREE.Mesh(poleGeo, poleMat);
      pole.position.y = poleHeight / 2;
      pole.castShadow = true;
      lightGroup.add(pole);
      
      // Arm extending out
      const armLength = 1.2;
      const armGeo = new THREE.CylinderGeometry(poleRadius * 0.6, poleRadius * 0.6, armLength, 6);
      const arm = new THREE.Mesh(armGeo, poleMat);
      arm.position.set(armLength / 2, poleHeight - 0.3, 0);
      arm.rotation.z = Math.PI / 2;
      arm.castShadow = true;
      lightGroup.add(arm);
      
      // Light fixture
      const fixtureGeo = new THREE.ConeGeometry(0.25, 0.4, 8);
      const fixtureMat = new THREE.MeshStandardMaterial({ 
        color: 0x1a1a1a, 
        roughness: 0.4, 
        metalness: 0.6,
        emissive: 0xffaa44,
        emissiveIntensity: 0.3
      });
      const fixture = new THREE.Mesh(fixtureGeo, fixtureMat);
      fixture.position.set(armLength, poleHeight - 0.5, 0);
      fixture.rotation.x = Math.PI;
      fixture.castShadow = false;
      lightGroup.add(fixture);
      
      // Light bulb (emissive)
      const bulbGeo = new THREE.SphereGeometry(0.15, 8, 6);
      const bulbMat = new THREE.MeshStandardMaterial({ 
        color: 0xffffee, 
        emissive: 0xffdd88, 
        emissiveIntensity: 1.0,
        transparent: true,
        opacity: 0.9
      });
      const bulb = new THREE.Mesh(bulbGeo, bulbMat);
      bulb.position.set(armLength, poleHeight - 0.6, 0);
      lightGroup.add(bulb);
      
      // Add point light for illumination
      const pointLight = new THREE.PointLight(0xffdd88, 2.5, 15);
      pointLight.position.set(armLength, poleHeight - 0.6, 0);
      pointLight.castShadow = false; // Too many for shadows
      lightGroup.add(pointLight);
      
      // Place all street lights
      positions.forEach(pos => {
        const lightClone = lightGroup.clone();
        lightClone.position.set(pos.x, sidewalkHeight, pos.z);
        
        // Random rotation
        lightClone.rotation.y = Math.random() * Math.PI * 2;
        
        worldRoot.add(lightClone);
      });
      
      console.log(`Placed ${positions.length} street lights`);
    }
    
    // ==================== INSTANCED CITY GENERATION ====================
    let buildingPrototypes = [];
    let instancedBuildings = [];
    
    function createBuildingPrototypes() {
      console.log('Creating building prototypes...');
      buildingPrototypes = [];
      
      // Initialize shared geometries (windows + sills)
      initSharedGeometries();
      
      // Building color palettes - greys and beiges
      const colorPalettes = [
        0xA8B0B8, // Light grey
        0x8A9099, // Medium grey
        0xB5B8BC, // Warm grey
        0xC8C2B8, // Beige grey
        0xD4CCBE, // Light beige
        0xBFB5A8, // Medium beige
        0xA89F92, // Dark beige
        0x9A9A9A, // Cool grey
      ];
      
      // Create 8 building variants as prototypes with varied colors - BIGGER
      const variants = [
        { type: 'box', width: 15, height: 35, depth: 15, color: colorPalettes[0], windowColor: 'yellow' },
        { type: 'box', width: 12, height: 50, depth: 12, color: colorPalettes[1], windowColor: 'blue' },
        { type: 'box', width: 18, height: 28, depth: 14, color: colorPalettes[4], windowColor: 'yellow' },
        { type: 'stacked', width: 16, height: 60, depth: 15, color: colorPalettes[5], windowColor: 'blue' },
        { type: 'stacked', width: 14, height: 55, depth: 16, color: colorPalettes[2], windowColor: 'yellow' },
        { type: 'cylinder', radius: 6, height: 45, color: colorPalettes[3], windowColor: 'blue' },
        { type: 'cylinder', radius: 7, height: 62, color: colorPalettes[6], windowColor: 'yellow' },
        { type: 'box', width: 13, height: 42, depth: 13, color: colorPalettes[7], windowColor: 'blue' },
      ];
      
      variants.forEach((variant, idx) => {
        const windowGroup = new THREE.Group();
        
        if (variant.type === 'stacked') {
          // Create 3-section cascading building
          const sections = 3;
          let currentY = 0;
          
          for (let s = 0; s < sections; s++) {
            const sectionHeight = variant.height / sections;
            const scale = 1 - s * 0.18;  // Each section is 18% smaller
            const sectionWidth = variant.width * scale;
            const sectionDepth = variant.depth * scale;
            
            const sectionGeo = new THREE.BoxGeometry(sectionWidth, sectionHeight, sectionDepth);
            const material = new THREE.MeshStandardMaterial({
              color: new THREE.Color(variant.color).multiplyScalar(1 - s * 0.05),
              roughness: 0.75,
              metalness: 0.15
            });
            
            const section = new THREE.Mesh(sectionGeo, material);
            section.position.y = currentY + sectionHeight / 2 - variant.height / 2;
            section.castShadow = true;
            section.receiveShadow = true;
            windowGroup.add(section);
            
            // Add decoration and windows to each section
            const sectionVariant = { 
              ...variant, 
              width: sectionWidth, 
              height: sectionHeight, 
              depth: sectionDepth,
              type: 'box'
            };
            
            const sectionGroup = new THREE.Group();
            sectionGroup.position.copy(section.position);
            addFacadeDecoration(sectionGroup, sectionVariant);
            addSimpleWindows(sectionGroup, sectionVariant);
            windowGroup.add(sectionGroup);
            
            currentY += sectionHeight;
          }
        } else {
          // Regular box or cylinder
          let geometry;
          
          if (variant.type === 'box') {
            geometry = new THREE.BoxGeometry(variant.width, variant.height, variant.depth);
          } else {
            geometry = new THREE.CylinderGeometry(variant.radius, variant.radius * 1.1, variant.height, 12);
          }
          
          const material = new THREE.MeshStandardMaterial({
            color: variant.color,
            roughness: 0.75,
            metalness: 0.15
          });
          
          const baseMesh = new THREE.Mesh(geometry, material);
          baseMesh.castShadow = true;
          baseMesh.receiveShadow = true;
          windowGroup.add(baseMesh);
          
          // Add facade decoration beneath windows
          addFacadeDecoration(windowGroup, variant);
          
          // Add window decals on top of decoration
          addSimpleWindows(windowGroup, variant);
        }
        
        // Add building topper
        addBuildingTopper(windowGroup, variant);
        
        buildingPrototypes.push({
          group: windowGroup,
          variant,
          collider: variant.type === 'box' 
            ? { type: 'box', width: variant.width, height: variant.height, depth: variant.depth }
            : { type: 'cylinder', radius: variant.radius, height: variant.height }
        });
      });
      
      console.log(`Created ${buildingPrototypes.length} building prototypes`);
    }
    
     // LOD Settings (moved to updateLOD section for better organization)
     const frustum = new THREE.Frustum();
     const projScreenMatrix = new THREE.Matrix4();
    
    // Shared geometries (created once, reused)
    const sharedGeometries = {
      windowSquare: null,
      windowRectangle: null,
      windowCylinder: null,
      sillOverhang: null,
      sillBorderTop: null,
      sillBorderBottom: null,
      sillBorderLeft: null,
      sillBorderRight: null,
      sillBottomOnly: null,
      sillMinimal: null
    };
    
    // Initialize shared geometries once
    function initSharedGeometries() {
      const sillThickness = 0.05;  // Bigger sills
      const sillDepth = 0.12;
      const windowWidth = 1.2;  // Bigger windows
      const windowHeightRect = 1.8;
      const windowHeightSquare = 1.2;
      
      // Window geometries - bigger
      sharedGeometries.windowSquare = new THREE.PlaneGeometry(windowWidth, windowHeightSquare);
      sharedGeometries.windowRectangle = new THREE.PlaneGeometry(windowWidth, windowHeightRect);
      sharedGeometries.windowCylinder = new THREE.PlaneGeometry(1.0, 1.5);  // Bigger cylinder windows
      
      // Sill geometries
      sharedGeometries.sillOverhang = new THREE.BoxGeometry(windowWidth + 0.15, sillThickness, sillDepth);
      sharedGeometries.sillBorderTop = new THREE.BoxGeometry(windowWidth + 0.1, sillThickness, sillDepth * 0.6);
      sharedGeometries.sillBorderBottom = new THREE.BoxGeometry(windowWidth + 0.1, sillThickness, sillDepth);
      sharedGeometries.sillBorderLeft = new THREE.BoxGeometry(sillThickness, windowHeightRect, sillDepth * 0.6);
      sharedGeometries.sillBorderRight = new THREE.BoxGeometry(sillThickness, windowHeightRect, sillDepth * 0.6);
      sharedGeometries.sillBottomOnly = new THREE.BoxGeometry(windowWidth + 0.08, sillThickness, sillDepth * 0.7);
      sharedGeometries.sillMinimal = new THREE.BoxGeometry(windowWidth, sillThickness * 0.5, sillDepth * 0.4);
    }
    
     // Helper function to create window sills using shared geometries
     function createWindowSill(windowWidth, windowHeight, sillStyle, sillColor) {
       const sillGroup = new THREE.Group();
       sillGroup.userData.isSill = true;  // Mark for LOD system
       const sillThickness = 0.03;
       const sillDepth = 0.08;
       
       const sillMaterial = new THREE.MeshStandardMaterial({ 
         color: sillColor,
         roughness: 0.8,
         metalness: 0.1
       });
       
       if (sillStyle === 0) {
         // Overhang - bottom protruding sill
         const sill = new THREE.Mesh(sharedGeometries.sillOverhang, sillMaterial);
         sill.position.set(0, -windowHeight/2 - sillThickness/2, sillDepth/2 - 0.02);
         sill.userData.isSill = true;  // Mark mesh itself too
         sill.castShadow = false;  // Don't cast shadows for performance
         sill.receiveShadow = false;
         sillGroup.add(sill);
         
       } else if (sillStyle === 1) {
         // Complete border - frame around entire window
         // Top
         const top = new THREE.Mesh(sharedGeometries.sillBorderTop, sillMaterial);
         top.position.set(0, windowHeight/2 + sillThickness/2, sillDepth/4 - 0.02);
         top.userData.isSill = true;
         top.castShadow = false;
         top.receiveShadow = false;
         sillGroup.add(top);
         
         // Bottom
         const bottom = new THREE.Mesh(sharedGeometries.sillBorderBottom, sillMaterial);
         bottom.position.set(0, -windowHeight/2 - sillThickness/2, sillDepth/2 - 0.02);
         bottom.userData.isSill = true;
         bottom.castShadow = false;
         bottom.receiveShadow = false;
         sillGroup.add(bottom);
         
         // Left
         const left = new THREE.Mesh(sharedGeometries.sillBorderLeft, sillMaterial);
         left.position.set(-windowWidth/2 - sillThickness/2, 0, sillDepth/4 - 0.02);
         left.userData.isSill = true;
         left.castShadow = false;
         left.receiveShadow = false;
         sillGroup.add(left);
         
         // Right
         const right = new THREE.Mesh(sharedGeometries.sillBorderRight, sillMaterial);
         right.position.set(windowWidth/2 + sillThickness/2, 0, sillDepth/4 - 0.02);
         right.userData.isSill = true;
         right.castShadow = false;
         right.receiveShadow = false;
         sillGroup.add(right);
         
       } else if (sillStyle === 2) {
         // Bottom only - simple flat sill
         const sill = new THREE.Mesh(sharedGeometries.sillBottomOnly, sillMaterial);
         sill.position.set(0, -windowHeight/2 - sillThickness/2, sillDepth/3 - 0.02);
         sill.userData.isSill = true;
         sill.castShadow = false;
         sill.receiveShadow = false;
         sillGroup.add(sill);
         
       } else {
         // Minimal - tiny bottom edge only
         const sill = new THREE.Mesh(sharedGeometries.sillMinimal, sillMaterial);
         sill.position.set(0, -windowHeight/2 - sillThickness/4, sillDepth/6 - 0.02);
         sill.userData.isSill = true;
         sill.castShadow = false;
         sill.receiveShadow = false;
         sillGroup.add(sill);
       }
       
       return sillGroup;
     }
     
     // Helper function to create window sills for cylindrical buildings
     function createCylinderWindowSill(windowWidth, windowHeight, sillStyle, sillColor, radius) {
       const sillGroup = new THREE.Group();
       sillGroup.userData.isSill = true;
       const sillThickness = 0.03;
       const sillDepth = 0.08;
       
       const sillMaterial = new THREE.MeshStandardMaterial({ 
         color: sillColor,
         roughness: 0.8,
         metalness: 0.1
       });
       
       // Create curved sill using a small cylinder segment
       const sillArc = 0.15;  // Angular width of sill
       const sillGeo = new THREE.CylinderGeometry(
         radius + sillDepth/2, 
         radius + sillDepth/2, 
         sillThickness, 
         8, 
         1, 
         false, 
         -sillArc/2, 
         sillArc
       );
       
       const sill = new THREE.Mesh(sillGeo, sillMaterial);
       sill.rotation.x = Math.PI / 2;
       sill.position.set(0, -windowHeight/2 - sillThickness/2, 0);
       sill.userData.isSill = true;  // Mark mesh itself too
       sill.castShadow = false;
       sill.receiveShadow = false;
       sillGroup.add(sill);
       
       return sillGroup;
     }
     
     // Add building toppers (domes, antennas, trims, spires)
    function addBuildingTopper(buildingGroup, variant) {
      const topperStyle = Math.floor(Math.random() * 5);
      const topperColor = new THREE.Color(variant.color).multiplyScalar(0.85);
      
      let topWidth, topDepth, topY;
      
      if (variant.type === 'stacked') {
        // Topper on smallest (top) section
        topWidth = variant.width * (1 - 2 * 0.18);
        topDepth = variant.depth * (1 - 2 * 0.18);
        topY = variant.height / 2;
      } else if (variant.type === 'cylinder') {
        topWidth = variant.radius * 2;
        topDepth = variant.radius * 2;
        topY = variant.height / 2;
      } else {
        topWidth = variant.width;
        topDepth = variant.depth;
        topY = variant.height / 2;
      }
      
      const topperMat = new THREE.MeshStandardMaterial({ 
        color: topperColor,
        roughness: 0.7,
        metalness: 0.2
      });
      
      if (topperStyle === 0) {
        // Half dome
        const domeGeo = new THREE.SphereGeometry(Math.min(topWidth, topDepth) * 0.35, 8, 6, 0, Math.PI * 2, 0, Math.PI / 2);
        const dome = new THREE.Mesh(domeGeo, topperMat);
        dome.position.y = topY;
        buildingGroup.add(dome);
        
      } else if (topperStyle === 1) {
        // Antenna/spire
        const antennaHeight = variant.height * 0.15;
        const antennaGeo = new THREE.CylinderGeometry(0.1, 0.15, antennaHeight, 6);
        const antenna = new THREE.Mesh(antennaGeo, topperMat);
        antenna.position.y = topY + antennaHeight / 2;
        buildingGroup.add(antenna);
        
        // Small sphere at top
        const ballGeo = new THREE.SphereGeometry(0.2, 6, 6);
        const ball = new THREE.Mesh(ballGeo, topperMat);
        ball.position.y = topY + antennaHeight;
        buildingGroup.add(ball);
        
       } else if (topperStyle === 2) {
         // Crown/trim - circular overhang for cylinders
         const crownHeight = 0.6;
         let crownGeo;
         
         if (variant.type === 'cylinder') {
           // Circular disk overhang for cylindrical buildings
           crownGeo = new THREE.CylinderGeometry(topWidth * 0.6, topWidth * 0.6, crownHeight, 16);
         } else {
           crownGeo = new THREE.BoxGeometry(topWidth * 1.05, crownHeight, topDepth * 1.05);
         }
         
         const crown = new THREE.Mesh(crownGeo, topperMat);
         crown.position.y = topY + crownHeight / 2;
         buildingGroup.add(crown);
         
       } else if (topperStyle === 3) {
        // Pyramid top
        const pyramidHeight = Math.min(topWidth, topDepth) * 0.4;
        const pyramidGeo = new THREE.ConeGeometry(Math.min(topWidth, topDepth) * 0.5, pyramidHeight, 4);
        const pyramid = new THREE.Mesh(pyramidGeo, topperMat);
        pyramid.position.y = topY + pyramidHeight / 2;
        pyramid.rotation.y = Math.PI / 4;
        buildingGroup.add(pyramid);
        
       } else {
         // Flat roof with small edge trim - circular for cylinders
         const trimHeight = 0.3;
         let trimGeo;
         
         if (variant.type === 'cylinder') {
           // Circular disk trim for cylindrical buildings
           trimGeo = new THREE.CylinderGeometry(topWidth * 0.55, topWidth * 0.55, trimHeight, 16);
         } else {
           trimGeo = new THREE.BoxGeometry(topWidth * 1.02, trimHeight, topDepth * 1.02);
         }
         
         const trim = new THREE.Mesh(trimGeo, topperMat);
         trim.position.y = topY + trimHeight / 2;
         buildingGroup.add(trim);
       }
    }
    
    // Add facade decoration textures beneath windows
    function addFacadeDecoration(buildingGroup, variant) {
      const facadeStyle = Math.floor(Math.random() * 4);
      const decorColor = new THREE.Color(variant.color).multiplyScalar(0.92);
      
      if (variant.type === 'box') {
        const width = variant.width;
        const depth = variant.depth;
        const height = variant.height;
        
        if (facadeStyle === 0) {
          // Vertical stripes
          const stripeCount = 4 + Math.floor(Math.random() * 3);
          const stripeWidth = 0.15;
          const stripeGeo = new THREE.PlaneGeometry(stripeWidth, height);
          const stripeMat = new THREE.MeshStandardMaterial({ 
            color: decorColor,
            roughness: 0.85
          });
          
          // Front and back
          for (let i = 0; i < stripeCount; i++) {
            const x = -width/2 + (i + 0.5) * (width / stripeCount);
             const stripeFront = new THREE.Mesh(stripeGeo, stripeMat);
             stripeFront.position.set(x, 0, depth/2 + 0.005);
             stripeFront.userData.isDecoration = true;  // Mark for LOD
             buildingGroup.add(stripeFront);
             
             const stripeBack = new THREE.Mesh(stripeGeo, stripeMat);
             stripeBack.position.set(x, 0, -depth/2 - 0.005);
             stripeBack.rotation.y = Math.PI;
             stripeBack.userData.isDecoration = true;  // Mark for LOD
             buildingGroup.add(stripeBack);
          }
          
        } else if (facadeStyle === 1) {
          // Horizontal bands
          const bandCount = 3 + Math.floor(Math.random() * 2);
          const bandHeight = 0.12;
          
          for (let i = 0; i < bandCount; i++) {
            const y = -height/2 + (i + 1) * (height / (bandCount + 1));
            
            // Front
            const bandGeoFront = new THREE.PlaneGeometry(width, bandHeight);
            const bandMatFront = new THREE.MeshStandardMaterial({ 
              color: decorColor,
              roughness: 0.9
            });
             const bandFront = new THREE.Mesh(bandGeoFront, bandMatFront);
             bandFront.position.set(0, y, depth/2 + 0.005);
             bandFront.userData.isDecoration = true;  // Mark for LOD
             buildingGroup.add(bandFront);
             
             // Back
             const bandBack = new THREE.Mesh(bandGeoFront, bandMatFront);
             bandBack.position.set(0, y, -depth/2 - 0.005);
             bandBack.rotation.y = Math.PI;
             bandBack.userData.isDecoration = true;  // Mark for LOD
             buildingGroup.add(bandBack);
          }
          
        } else if (facadeStyle === 2) {
          // Column pilasters
          const columnCount = 2 + Math.floor(Math.random() * 2);
          const columnWidth = 0.25;
          const columnGeo = new THREE.PlaneGeometry(columnWidth, height * 0.9);
          const columnMat = new THREE.MeshStandardMaterial({ 
            color: decorColor,
            roughness: 0.88
          });
          
          for (let i = 0; i < columnCount; i++) {
            const x = -width/2 + (i + 1) * (width / (columnCount + 1));
            
             // Front
             const colFront = new THREE.Mesh(columnGeo, columnMat);
             colFront.position.set(x, height * 0.05, depth/2 + 0.005);
             colFront.userData.isDecoration = true;  // Mark for LOD
             buildingGroup.add(colFront);
             
             // Column header (capital)
             const headerGeo = new THREE.PlaneGeometry(columnWidth * 1.5, 0.2);
             const header = new THREE.Mesh(headerGeo, columnMat);
             header.position.set(x, height * 0.45, depth/2 + 0.006);
             header.userData.isDecoration = true;  // Mark for LOD
             buildingGroup.add(header);
          }
        }
        // facadeStyle 3 = no decoration (clean modern)
      }
    }
    
    function addSimpleWindows(buildingGroup, variant) {
      // Enhanced window system with variants
      // Window colors based on building variant
      const litWindowColor = variant.windowColor === 'yellow' 
        ? new THREE.Color(0xFFEB99)  // Warm yellow
        : new THREE.Color(0x9DC6E8);  // Cool blue
      const dimWindowColor = variant.windowColor === 'yellow'
        ? new THREE.Color(0x6A5A4A)  // Dim warm
        : new THREE.Color(0x4A5A6A);  // Dim cool
      
      // Variable row density - some buildings have more/fewer floors
      const densityVariant = Math.random();
      let floorSpacing;
      if (densityVariant < 0.3) {
        floorSpacing = 4.0;  // Dense (more floors)
      } else if (densityVariant < 0.7) {
        floorSpacing = 5.0;  // Medium
      } else {
        floorSpacing = 6.0;  // Sparse (fewer floors)
      }
       const floors = variant.type === 'box' ? 
         Math.max(3, Math.min(8, Math.floor(variant.height / floorSpacing))) : 
         Math.max(2, Math.min(6, Math.floor(variant.height / (floorSpacing + 0.5))));
      
       // Window variants: 3 or 4 windows per row
       const windowsPerRow = [3, 4][Math.floor(Math.random() * 2)];
      
      // Window shape: square or rectangle - scaled up
      const isSquare = Math.random() > 0.5;
      const windowWidth = 1.2;  // Bigger windows
      const windowHeight = isSquare ? 1.2 : 1.8;
      
      // Window sill style variants
      const sillStyle = Math.floor(Math.random() * 4);
      // 0: overhang, 1: complete border, 2: bottom only, 3: minimal
      
      // Sill color - slightly lighter than building
      const sillColor = new THREE.Color(variant.color).multiplyScalar(1.15);
      
      if (variant.type === 'box') {
        const width = variant.width;
        const depth = variant.depth;
        const height = variant.height;
        
        // All four faces get windows
        // Front face (Z+)
        for (let floor = 1; floor < floors; floor++) {
          const y = -height/2 + (floor / floors) * height;
          
          for (let w = 0; w < windowsPerRow; w++) {
            const isLit = Math.random() > 0.3;  // 70% chance lit
            const xPos = -width/2 + (w + 0.5) * (width / windowsPerRow);
            
            // Use shared geometry
            const windowGeo = isSquare ? sharedGeometries.windowSquare : sharedGeometries.windowRectangle;
            const windowMat = new THREE.MeshBasicMaterial({ 
              color: isLit ? litWindowColor : dimWindowColor,
              emissive: isLit ? litWindowColor : dimWindowColor,
              emissiveIntensity: isLit ? 0.5 : 0.05,
              transparent: true,
              opacity: isLit ? 0.85 : 0.3
            });
             const window = new THREE.Mesh(windowGeo, windowMat);
             window.position.set(xPos, y, depth/2 + 0.02);
             window.rotation.y = 0;
             window.userData.isWindow = true;  // Mark for LOD
             
             // Add window sill
             const sill = createWindowSill(windowWidth, windowHeight, sillStyle, sillColor);
             sill.position.copy(window.position);
             sill.rotation.copy(window.rotation);
             buildingGroup.add(sill);
             
             buildingGroup.add(window);
          }
        }
        
        // Back face (Z-)
        for (let floor = 1; floor < floors; floor++) {
          const y = -height/2 + (floor / floors) * height;
          
          for (let w = 0; w < windowsPerRow; w++) {
            const isLit = Math.random() > 0.3;
            const xPos = -width/2 + (w + 0.5) * (width / windowsPerRow);
            
            // Use shared geometry
            const windowGeo = isSquare ? sharedGeometries.windowSquare : sharedGeometries.windowRectangle;
            const windowMat = new THREE.MeshBasicMaterial({ 
              color: isLit ? litWindowColor : dimWindowColor,
              emissive: isLit ? litWindowColor : dimWindowColor,
              emissiveIntensity: isLit ? 0.5 : 0.05,
              transparent: true,
              opacity: isLit ? 0.85 : 0.3
            });
             const window = new THREE.Mesh(windowGeo, windowMat);
             window.position.set(xPos, y, -depth/2 - 0.02);
             window.rotation.y = Math.PI;
             window.userData.isWindow = true;  // Mark for LOD
             
             // Add window sill
             const sill = createWindowSill(windowWidth, windowHeight, sillStyle, sillColor);
             sill.position.copy(window.position);
             sill.rotation.copy(window.rotation);
             buildingGroup.add(sill);
             
             buildingGroup.add(window);
          }
        }
        
        // Left face (X-)
        const depthWindowsPerRow = Math.max(2, Math.floor(windowsPerRow * (depth / width)));
        for (let floor = 1; floor < floors; floor++) {
          const y = -height/2 + (floor / floors) * height;
          
          for (let w = 0; w < depthWindowsPerRow; w++) {
            const isLit = Math.random() > 0.3;
            const zPos = -depth/2 + (w + 0.5) * (depth / depthWindowsPerRow);
            
            // Use shared geometry
            const windowGeo = isSquare ? sharedGeometries.windowSquare : sharedGeometries.windowRectangle;
            const windowMat = new THREE.MeshBasicMaterial({ 
              color: isLit ? litWindowColor : dimWindowColor,
              emissive: isLit ? litWindowColor : dimWindowColor,
              emissiveIntensity: isLit ? 0.5 : 0.05,
              transparent: true,
              opacity: isLit ? 0.85 : 0.3
            });
             const window = new THREE.Mesh(windowGeo, windowMat);
             window.position.set(-width/2 - 0.02, y, zPos);
             window.rotation.y = -Math.PI / 2;
             window.userData.isWindow = true;  // Mark for LOD
             
             // Add window sill
             const sill = createWindowSill(windowWidth, windowHeight, sillStyle, sillColor);
             sill.position.copy(window.position);
             sill.rotation.copy(window.rotation);
             buildingGroup.add(sill);
             
             buildingGroup.add(window);
          }
        }
        
        // Right face (X+)
        for (let floor = 1; floor < floors; floor++) {
          const y = -height/2 + (floor / floors) * height;
          
          for (let w = 0; w < depthWindowsPerRow; w++) {
            const isLit = Math.random() > 0.3;
            const zPos = -depth/2 + (w + 0.5) * (depth / depthWindowsPerRow);
            
            // Use shared geometry
            const windowGeo = isSquare ? sharedGeometries.windowSquare : sharedGeometries.windowRectangle;
            const windowMat = new THREE.MeshBasicMaterial({ 
              color: isLit ? litWindowColor : dimWindowColor,
              emissive: isLit ? litWindowColor : dimWindowColor,
              emissiveIntensity: isLit ? 0.5 : 0.05,
              transparent: true,
              opacity: isLit ? 0.85 : 0.3
            });
             const window = new THREE.Mesh(windowGeo, windowMat);
             window.position.set(width/2 + 0.02, y, zPos);
             window.rotation.y = Math.PI / 2;
             window.userData.isWindow = true;  // Mark for LOD
             
             // Add window sill
             const sill = createWindowSill(windowWidth, windowHeight, sillStyle, sillColor);
             sill.position.copy(window.position);
             sill.rotation.copy(window.rotation);
             buildingGroup.add(sill);
             
             buildingGroup.add(window);
          }
        }
       } else {
         // Cylinder - radial windows around entire circumference
         const segments = 6 + Math.floor(Math.random() * 3);  // 6-8 windows around (reduced for performance)
         const radius = variant.radius;
         const height = variant.height;
        
        const cylinderWindowWidth = 0.5;
        const cylinderWindowHeight = isSquare ? 0.5 : 0.8;
        
        for (let floor = 1; floor < floors; floor++) {
          const y = -height/2 + (floor / floors) * height;
          
          for (let seg = 0; seg < segments; seg++) {
            const isLit = Math.random() > 0.3;
            const angle = (seg / segments) * Math.PI * 2;
            const x = Math.cos(angle) * (radius + 0.01);
            const z = Math.sin(angle) * (radius + 0.01);
            
            // Use shared geometry
            const windowGeo = sharedGeometries.windowCylinder;
            const windowMat = new THREE.MeshBasicMaterial({ 
              color: isLit ? litWindowColor : dimWindowColor,
              emissive: isLit ? litWindowColor : dimWindowColor,
              emissiveIntensity: isLit ? 0.45 : 0.05,
              transparent: true,
              opacity: isLit ? 0.85 : 0.3
            });
             const window = new THREE.Mesh(windowGeo, windowMat);
             window.position.set(x, y, z);
             window.lookAt(0, y, 0);
             window.userData.isWindow = true;  // Mark for LOD
             
             // Add window sill - wrapped to cylinder
             const sill = createCylinderWindowSill(cylinderWindowWidth, cylinderWindowHeight, sillStyle, sillColor, radius);
             sill.position.copy(window.position);
             sill.rotation.copy(window.rotation);
             buildingGroup.add(sill);
             
             buildingGroup.add(window);
          }
        }
      }
    }
    
     // OLD SYSTEM - Now using chunk-based generation
     async function generateCity() {
       console.log('OLD generateCity called - now using chunk system instead');
       
       // Clear existing buildings
       buildings.forEach(b => {
         worldRoot.remove(b.mesh);
         if (b.body) world.removeRigidBody(b.body);
       });
       buildings = [];
       
       instancedBuildings.forEach(inst => {
         worldRoot.remove(inst);
       });
       instancedBuildings = [];
       
       // Clear sill cache
       sillCache.clear();
       
       // Clear doors
       doors.forEach(door => {
         if (door.panels) door.panels.forEach(p => worldRoot.remove(p));
         if (door.frames) door.frames.forEach(f => worldRoot.remove(f));
         if (door.track) worldRoot.remove(door.track);
         if (door.lightPlane) worldRoot.remove(door.lightPlane);
         if (door.light) worldRoot.remove(door.light);
       });
       doors = [];
       
       // Create prototypes if not exists (still needed for old viewport system)
       if (buildingPrototypes.length === 0) {
         createBuildingPrototypes();
       }
       
       // Create global road network once
       // createRoadNetwork();
       // DISABLED - roads should be per-chunk now
       
       console.log('City generation delegated to chunk streaming system');
       
       // OLD building generation code commented out - now using chunks
       /*
       const roadWidth = CONFIG.ROAD_WIDTH;
       const blockSize = CONFIG.BLOCK_SIZE;
       const blocksX = CONFIG.CITY_BLOCKS_X;
       const blocksZ = CONFIG.CITY_BLOCKS_Z;
       ... building generation logic ...
       */
       
       return; // Exit early - chunk system handles everything
     }
     
     function placeBuildingInBlock(x, z, scaleFactor) {
       // Pick random prototype
       const protoIdx = Math.floor(Math.random() * buildingPrototypes.length);
       const proto = buildingPrototypes[protoIdx];
       
       // Random height variation
       const heightScale = (0.6 + Math.random() * 0.8) * scaleFactor;
       
       // Clone the prototype
       const buildingClone = proto.group.clone();
       buildingClone.position.set(x, proto.variant.height * heightScale / 2, z);
       buildingClone.scale.set(scaleFactor, heightScale, scaleFactor);
       
       // Mark all children for pluck system
       buildingClone.traverse(child => {
         if (child.isMesh) {
           child.userData._pluckParent = buildingClone;
         }
       });
       
       worldRoot.add(buildingClone);
       instancedBuildings.push(buildingClone);
       
       // Create physics body
       const bodyDesc = physics.RigidBodyDesc.fixed();
       const body = world.createRigidBody(bodyDesc);
       body.setTranslation({ 
         x: x, 
         y: proto.variant.height * heightScale / 2, 
         z: z 
       });
       
       let colliderDesc;
       if (proto.collider.type === 'box') {
         colliderDesc = physics.ColliderDesc.cuboid(
           proto.collider.width * scaleFactor / 2,
           proto.collider.height * heightScale / 2,
           proto.collider.depth * scaleFactor / 2
         );
       } else {
         colliderDesc = physics.ColliderDesc.cylinder(
           proto.collider.height * heightScale / 2,
           proto.collider.radius * scaleFactor
         );
       }
       
       world.createCollider(colliderDesc, body);
       
       const buildingData = {
         mesh: buildingClone,
         body,
         width: (proto.collider.width || proto.collider.radius * 2) * scaleFactor,
         height: proto.collider.height * heightScale,
         depth: (proto.collider.depth || proto.collider.radius * 2) * scaleFactor,
         type: proto.variant.type
       };
       
       buildings.push(buildingData);
       
       // Add door to box buildings only
       if (proto.variant.type === 'box') {
         addDoorToBuilding(buildingData, x, z, scaleFactor);
       }
     }
     
     // ==================== DOOR SYSTEM ====================
     
     // Add door to building using instanced system
     function addDoorToBuilding(building, x, z, scaleFactor) {
       // Only add doors to some buildings for performance
       if (Math.random() > 0.5) return;  // 50% of buildings get doors
       
       const panelH = 3.0 * scaleFactor;  // Door height
       
       // Place door on front face (Z+)
       const doorX = x;
       const doorZ = z + building.depth / 2 + 0.2;
       
       // Create 4 glass panels
       const panelGeo = new THREE.BoxGeometry(panelW, panelH, panelT);
       const glassMat = new THREE.MeshPhysicalMaterial({
         color: 0xcad7df,
         roughness: 0.85,
         transmission: 0.6,
         thickness: 0.5,
         ior: 1.5,
         attenuationColor: 0xaadfff,
         attenuationDistance: 1.5,
         metalness: 0.0,
         specularIntensity: 0.35,
         transparent: true
       });
       
       const panels = [];
       const w = panelW;
       
       // Panel positions closed
       const centersClosed = [
         doorX - 1.5*w - gap,         // outer left (fixed)
         doorX - 0.5*w - gap/2,       // inner left (slides left)
         doorX + 0.5*w + gap/2,       // inner right (slides right)
         doorX + 1.5*w + gap          // outer right (fixed)
       ];
       
       const centersOpen = [
         centersClosed[0],
         centersClosed[0],      // inner-left flush with outer-left
         centersClosed[3],      // inner-right flush with outer-right
         centersClosed[3]
       ];
       
       for (let i = 0; i < 4; i++) {
         const panel = new THREE.Mesh(panelGeo, glassMat);
         panel.position.set(centersClosed[i], panelH * 0.5, doorZ);
         panel.castShadow = false;
         panel.receiveShadow = false;
         worldRoot.add(panel);
         panels.push(panel);
       }
       
       // Create frame strips (4 per panel = 16 total)
       const stripT = 0.015 * scaleFactor;
       const stripD = 0.035 * scaleFactor;
       const frameStripGeo = new THREE.BoxGeometry(panelW + stripT*2, stripT, stripD);
       const frameMat = new THREE.MeshStandardMaterial({ 
         color: 0xb9c4cf, 
         roughness: 0.35, 
         metalness: 0.8
       });
       
       const frames = [];
       const halfW = panelW/2;
       const halfH = panelH/2;
       
       // Create frame strips for each panel
       for (let i = 0; i < 4; i++) {
         const cx = centersClosed[i];
         const y = panelH*0.5;
         
         // Top strip
         const topStrip = new THREE.Mesh(frameStripGeo, frameMat);
         topStrip.position.set(cx, y + halfH - stripT/2, doorZ);
         topStrip.castShadow = false;
         worldRoot.add(topStrip);
         frames.push(topStrip);
         
         // Bottom strip
         const bottomStrip = new THREE.Mesh(frameStripGeo, frameMat);
         bottomStrip.position.set(cx, y - halfH + stripT/2, doorZ);
         bottomStrip.castShadow = false;
         worldRoot.add(bottomStrip);
         frames.push(bottomStrip);
         
         // Left strip (rotated)
         const frameStripGeoVert = new THREE.BoxGeometry(panelW + stripT*2, stripT, stripD);
         const leftStrip = new THREE.Mesh(frameStripGeoVert, frameMat);
         leftStrip.position.set(cx - halfW - stripT/2, y, doorZ);
         leftStrip.rotation.z = Math.PI/2;
         leftStrip.castShadow = false;
         worldRoot.add(leftStrip);
         frames.push(leftStrip);
         
         // Right strip (rotated)
         const rightStrip = new THREE.Mesh(frameStripGeoVert, frameMat);
         rightStrip.position.set(cx + halfW + stripT/2, y, doorZ);
         rightStrip.rotation.z = Math.PI/2;
         rightStrip.castShadow = false;
         worldRoot.add(rightStrip);
         frames.push(rightStrip);
       }
       
       // Track bar at bottom
       const trackGeo = new THREE.BoxGeometry(panelW * 4, 0.03 * scaleFactor, 0.05 * scaleFactor);
       const trackMat = new THREE.MeshStandardMaterial({ 
         color: 0x4a4a4a,
         roughness: 0.7,
         metalness: 0.5
       });
       const track = new THREE.Mesh(trackGeo, trackMat);
       track.position.set(doorX, 0.01 * scaleFactor, doorZ);
       track.castShadow = false;
       worldRoot.add(track);
       
       // Light pane behind door
       const lightGeo = new THREE.PlaneGeometry(panelW * 3, panelH * 0.9);
       const lightMat = new THREE.MeshBasicMaterial({
         color: 0xffffff,
         emissive: 0xffffff,
         emissiveIntensity: 0,
         transparent: true,
         opacity: 0
       });
       const lightPlane = new THREE.Mesh(lightGeo, lightMat);
       lightPlane.position.set(doorX, panelH * 0.5, doorZ - 0.2);
       worldRoot.add(lightPlane);
       
       // Point light for illumination - bigger range for bigger doors
       const doorLight = new THREE.PointLight(0xffffff, 0, 15);
       doorLight.position.set(doorX, panelH * 0.5, doorZ);
       worldRoot.add(doorLight);
       
       doors.push({
         position: new THREE.Vector3(doorX, 0, doorZ),
         panels: panels,
         frames: frames,
         track: track,
         lightPlane: lightPlane,
         light: doorLight,
         openAmount: 0,
         targetOpen: 0,
         centersClosed: centersClosed,
         centersOpen: centersOpen,
         panelW: panelW,
         panelH: panelH,
         flushOffset: flushOffset
       });
     }
     
     function updateDoors(deltaTime) {
       if (!playerBody || doors.length === 0) return;
       
       const playerPos = new THREE.Vector3(
         playerBody.translation().x,
         playerBody.translation().y,
         playerBody.translation().z
       );
       
       // Easing function
       const ease = (t) => t < 0 ? 0 : t > 1 ? 1 : t*t*(3-2*t);
       
       doors.forEach(door => {
         // Check distance to player
         const dist = playerPos.distanceTo(door.position);
         const openThreshold = 6.0;  // Open when within 6 meters (bigger scale)
         
         // Set target based on proximity
         door.targetOpen = dist < openThreshold ? 1 : 0;
         
         // Smooth animation with easing
         const speed = 2.0;
         const dir = Math.sign(door.targetOpen - door.openAmount);
         door.openAmount = Math.min(1, Math.max(0, 
           door.openAmount + dir * speed * deltaTime
         ));
         
         const k = ease(door.openAmount);
         
         // Update all 4 panels
         for (let i = 0; i < 4; i++) {
           const panel = door.panels[i];
           const closedX = door.centersClosed[i];
           const openX = door.centersOpen[i];
           
           panel.position.x = THREE.MathUtils.lerp(closedX, openX, k);
           
           // Inner panels move slightly forward when open
           if (i === 1) {
             panel.position.z = door.position.z - door.flushOffset * k;
           } else if (i === 2) {
             panel.position.z = door.position.z + door.flushOffset * k;
           }
         }
         
         // Update frame strips (16 total, 4 per panel)
         for (let i = 0; i < 4; i++) {
           const closedX = door.centersClosed[i];
           const openX = door.centersOpen[i];
           const baseX = THREE.MathUtils.lerp(closedX, openX, k);
           
           const baseIdx = i * 4;
           const halfW = door.panelW / 2;
           const halfH = door.panelH / 2;
           const stripT = 0.015;
           const y = door.panelH * 0.5;
           
           // Top strip
           door.frames[baseIdx].position.x = baseX;
           door.frames[baseIdx].position.y = y + halfH - stripT/2;
           
           // Bottom strip
           door.frames[baseIdx + 1].position.x = baseX;
           door.frames[baseIdx + 1].position.y = y - halfH + stripT/2;
           
           // Left strip
           door.frames[baseIdx + 2].position.x = baseX - halfW - stripT/2;
           door.frames[baseIdx + 2].position.y = y;
           
           // Right strip
           door.frames[baseIdx + 3].position.x = baseX + halfW + stripT/2;
           door.frames[baseIdx + 3].position.y = y;
           
           // Inner panels' frames move with depth
           if (i === 1) {
             const zOffset = door.position.z - door.flushOffset * k;
             for (let j = 0; j < 4; j++) {
               door.frames[baseIdx + j].position.z = zOffset;
             }
           } else if (i === 2) {
             const zOffset = door.position.z + door.flushOffset * k;
             for (let j = 0; j < 4; j++) {
               door.frames[baseIdx + j].position.z = zOffset;
             }
           }
         }
         
         // Update light emission (more dramatic)
         door.lightPlane.material.emissiveIntensity = k * 3.0;
         door.lightPlane.material.opacity = k * 0.8;
         door.light.intensity = k * 15.0;
       });
     }
    
    // Modern building with setbacks
    function createModernBuilding(x, z, width, height, depth) {
      const group = new THREE.Group();
      
      // Base color
      const hue = 0.55 + Math.random() * 0.1; // Blue-ish
      const saturation = 0.15 + Math.random() * 0.2;
      const lightness = 0.45 + Math.random() * 0.25;
      const baseColor = new THREE.Color().setHSL(hue, saturation, lightness);
      
      // Create stacked sections
      const sections = 2 + Math.floor(Math.random() * 2);
      let currentY = 0;
      
      for (let s = 0; s < sections; s++) {
        const sectionHeight = height / sections;
        const scale = 1 - s * 0.12;
        const sectionWidth = width * scale;
        const sectionDepth = depth * scale;
        
        const sectionGeo = new THREE.BoxGeometry(sectionWidth, sectionHeight, sectionDepth);
        const material = new THREE.MeshStandardMaterial({ 
          color: baseColor.clone().multiplyScalar(1 - s * 0.08),
          roughness: 0.6,
          metalness: 0.3
        });
        
        const section = new THREE.Mesh(sectionGeo, material);
        section.position.y = currentY + sectionHeight / 2;
        section.castShadow = true;
        section.receiveShadow = true;
        group.add(section);
        
        // Add facade details
        addModernFacade(section, sectionWidth, sectionHeight, sectionDepth, baseColor);
        
        currentY += sectionHeight;
      }
      
      group.position.set(x, 0, z);
      
      // Physics (simplified box for all sections)
      const bodyDesc = physics.RigidBodyDesc.fixed();
      const body = world.createRigidBody(bodyDesc);
      body.setTranslation({ x, y: height / 2, z });
      const colliderDesc = physics.ColliderDesc.cuboid(width / 2, height / 2, depth / 2);
      world.createCollider(colliderDesc, body);
      
      return { mesh: group, body, width, height, depth };
    }
    
    // Classic building with regular windows
    function createClassicBuilding(x, z, width, height, depth) {
      const group = new THREE.Group();
      
      const hue = 0.08 + Math.random() * 0.15; // Orange-brown
      const baseColor = new THREE.Color().setHSL(hue, 0.3, 0.5);
      
      const geometry = new THREE.BoxGeometry(width, height, depth);
      const material = new THREE.MeshStandardMaterial({ 
        color: baseColor,
        roughness: 0.7,
        metalness: 0.1
      });
      
      const building = new THREE.Mesh(geometry, material);
      building.position.y = height / 2;
      building.castShadow = true;
      building.receiveShadow = true;
      group.add(building);
      
      // Add classic facade with grid windows
      addClassicFacade(building, width, height, depth, baseColor);
      
      group.position.set(x, 0, z);
      
      // Physics
      const bodyDesc = physics.RigidBodyDesc.fixed();
      const body = world.createRigidBody(bodyDesc);
      body.setTranslation({ x, y: height / 2, z });
      const colliderDesc = physics.ColliderDesc.cuboid(width / 2, height / 2, depth / 2);
      world.createCollider(colliderDesc, body);
      
      return { mesh: group, body, width, height, depth };
    }
    
    // Tower building (cylinder)
    function createTowerBuilding(x, z, width, height, depth) {
      const group = new THREE.Group();
      
      const hue = 0.5 + Math.random() * 0.2;
      const baseColor = new THREE.Color().setHSL(hue, 0.25, 0.55);
      
      const radius = Math.min(width, depth) / 2;
      const geometry = new THREE.CylinderGeometry(radius, radius * 1.1, height, 12);
      const material = new THREE.MeshStandardMaterial({ 
        color: baseColor,
        roughness: 0.65,
        metalness: 0.25
      });
      
      const tower = new THREE.Mesh(geometry, material);
      tower.position.y = height / 2;
      tower.castShadow = true;
      tower.receiveShadow = true;
      group.add(tower);
      
      // Add tower windows
      addTowerWindows(tower, radius, height, baseColor);
      
      group.position.set(x, 0, z);
      
      // Physics (cylinder collider)
      const bodyDesc = physics.RigidBodyDesc.fixed();
      const body = world.createRigidBody(bodyDesc);
      body.setTranslation({ x, y: height / 2, z });
      const colliderDesc = physics.ColliderDesc.cylinder(height / 2, radius);
      world.createCollider(colliderDesc, body);
      
      return { mesh: group, body, width: radius * 2, height, depth: radius * 2 };
    }
    
    // ==================== MODERN FACADE (OLD SYSTEM - DEPRECATED) ====================
    // Modern facade with baked texture (using new generateFacadeTexture function)
    function addModernFacade(building, width, height, depth, baseColor) {
      // Generate baked textures for each facade using new function
      // New signature: generateFacadeTexture(width, height, baseColor, windowColor)
      const frontTex = generateFacadeTexture(width, height, baseColor, 'yellow');
      const sideTex = generateFacadeTexture(depth, height, baseColor, 'yellow');
      
      // Front facade (Z+)
      const frontGeo = new THREE.PlaneGeometry(width, height);
      const frontMat = new THREE.MeshBasicMaterial({ 
        map: frontTex,
        transparent: true,
        opacity: 0.95
      });
      const front = new THREE.Mesh(frontGeo, frontMat);
      front.position.set(0, 0, depth / 2 + 0.01);
      building.add(front);
      
      // Back facade (Z-)
      const backTex = generateFacadeTexture(width, height, width, height, 'modern');
      const backGeo = new THREE.PlaneGeometry(width, height);
      const backMat = new THREE.MeshBasicMaterial({ 
        map: backTex,
        transparent: true,
        opacity: 0.95
      });
      const back = new THREE.Mesh(backGeo, backMat);
      back.position.set(0, 0, -depth / 2 - 0.01);
      back.rotation.y = Math.PI;
      building.add(back);
      
      // Right facade (X+)
      const rightTex = generateFacadeTexture(depth, height, depth, height, 'modern');
      const rightGeo = new THREE.PlaneGeometry(depth, height);
      const rightMat = new THREE.MeshBasicMaterial({ 
        map: rightTex,
        transparent: true,
        opacity: 0.95
      });
      const right = new THREE.Mesh(rightGeo, rightMat);
      right.position.set(width / 2 + 0.01, 0, 0);
      right.rotation.y = Math.PI / 2;
      building.add(right);
      
      // Left facade (X-)
      const leftTex = generateFacadeTexture(depth, height, depth, height, 'modern');
      const leftGeo = new THREE.PlaneGeometry(depth, height);
      const leftMat = new THREE.MeshBasicMaterial({ 
        map: leftTex,
              transparent: true,
        opacity: 0.95
      });
      const left = new THREE.Mesh(leftGeo, leftMat);
      left.position.set(-width / 2 - 0.01, 0, 0);
      left.rotation.y = -Math.PI / 2;
      building.add(left);
    }
    
    // Classic facade with baked texture
    function addClassicFacade(building, width, height, depth, baseColor) {
      // Generate baked textures for each facade
      const frontTex = generateFacadeTexture(width, height, width, height, 'classic');
      const sideTex = generateFacadeTexture(depth, height, depth, height, 'classic');
      
      // Front facade (Z+)
      const frontGeo = new THREE.PlaneGeometry(width, height);
      const frontMat = new THREE.MeshBasicMaterial({ 
        map: frontTex,
        transparent: true,
        opacity: 0.9
      });
      const front = new THREE.Mesh(frontGeo, frontMat);
      front.position.set(0, 0, depth / 2 + 0.01);
      building.add(front);
      
      // Back facade (Z-)
      const backTex = generateFacadeTexture(width, height, width, height, 'classic');
      const backGeo = new THREE.PlaneGeometry(width, height);
      const backMat = new THREE.MeshBasicMaterial({ 
        map: backTex,
        transparent: true,
        opacity: 0.9
      });
      const back = new THREE.Mesh(backGeo, backMat);
      back.position.set(0, 0, -depth / 2 - 0.01);
      back.rotation.y = Math.PI;
      building.add(back);
      
      // Right facade (X+)
      const rightTex = generateFacadeTexture(depth, height, depth, height, 'classic');
      const rightGeo = new THREE.PlaneGeometry(depth, height);
      const rightMat = new THREE.MeshBasicMaterial({ 
        map: rightTex,
              transparent: true,
        opacity: 0.9
      });
      const right = new THREE.Mesh(rightGeo, rightMat);
      right.position.set(width / 2 + 0.01, 0, 0);
      right.rotation.y = Math.PI / 2;
      building.add(right);
      
      // Left facade (X-)
      const leftTex = generateFacadeTexture(depth, height, depth, height, 'classic');
      const leftGeo = new THREE.PlaneGeometry(depth, height);
      const leftMat = new THREE.MeshBasicMaterial({ 
        map: leftTex,
        transparent: true,
        opacity: 0.9
      });
      const left = new THREE.Mesh(leftGeo, leftMat);
      left.position.set(-width / 2 - 0.01, 0, 0);
      left.rotation.y = -Math.PI / 2;
      building.add(left);
    }
    
    // Tower windows (vertical strips) - flat decals
    function addTowerWindows(tower, radius, height, baseColor) {
      const windowColor = new THREE.Color(0x8AB4FF);
      const floors = Math.max(4, Math.floor(height / 2.0));
      const segments = 12;
      const windowHeight = 1.0;
      const windowWidth = 0.5;
      
      for (let seg = 0; seg < segments; seg++) {
        const angle = (seg / segments) * Math.PI * 2;
        const x = Math.cos(angle) * (radius + 0.01);
        const z = Math.sin(angle) * (radius + 0.01);
        
        for (let floor = 1; floor < floors; floor++) {
          if (Math.random() > 0.75) continue;
          
          const y = -height / 2 + floor * (height / floors);
          
          // Flat window decal on cylinder surface
          const windowGeo = new THREE.PlaneGeometry(windowWidth, windowHeight);
          const windowMat = new THREE.MeshBasicMaterial({ 
            color: windowColor,
            emissive: windowColor,
            emissiveIntensity: 0.35,
            transparent: true,
            opacity: 0.85
          });
          const window = new THREE.Mesh(windowGeo, windowMat);
          window.position.set(x, y, z);
          window.lookAt(0, y, 0);
          tower.add(window);
        }
      }
    }
    
     // ==================== PLAYER ====================
     function createPlayer() {
       const bodyDesc = physics.RigidBodyDesc.dynamic()
         .setTranslation(0, 5, 0)  // Spawn at city center
         .setLinearDamping(0.3)
         .setAngularDamping(10.0)
         .lockRotations();
      
      playerBody = world.createRigidBody(bodyDesc);
      
      const colliderDesc = physics.ColliderDesc.capsule(CONFIG.PLAYER_HEIGHT / 2, CONFIG.PLAYER_RADIUS)
        .setFriction(0.8)
        .setRestitution(0.0);
      world.createCollider(colliderDesc, playerBody);
      
      // Visual (optional, hidden in first-person)
      const playerGeometry = new THREE.CapsuleGeometry(CONFIG.PLAYER_RADIUS, CONFIG.PLAYER_HEIGHT, 4, 8);
      const playerMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x4a7cff,
        roughness: 0.4,
        metalness: 0.6
      });
      player = new THREE.Mesh(playerGeometry, playerMaterial);
      player.castShadow = true;
      player.visible = false; // Hide in FPS
      scene.add(player);
    }
    
    // ==================== PLANET GROUND ====================
    function createSphericalGround() {
      const radius = planetRadius;
      const geometry = new THREE.SphereGeometry(radius, 64, 64);
      
      // Apply noise/texture to the sphere
      const positions = geometry.attributes.position;
      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const y = positions.getY(i);
        const z = positions.getZ(i);
        
        // Add subtle noise for terrain variation
        const noise = Math.sin(x * 0.01) * Math.cos(z * 0.01) * 3;
        const scale = (radius + noise) / radius;
        
        positions.setXYZ(i, x * scale, y * scale, z * scale);
      }
      positions.needsUpdate = true;
      geometry.computeVertexNormals();
      
      // Create material with texture
      const material = new THREE.MeshStandardMaterial({
        color: 0x4a7c4e,
        roughness: 0.9,
        metalness: 0.1,
        flatShading: false
      });
      
      const planet = new THREE.Mesh(geometry, material);
      planet.receiveShadow = true;
      planet.castShadow = false;
      
      // Position player on top of planet
      planet.position.y = -radius;
      
      if (!worldRoot) {
        worldRoot = new THREE.Group();
        scene.add(worldRoot);
      }
      
      worldRoot.add(planet);
      
      console.log('Spherical planet ground created, radius:', radius);
      return planet;
    }
    
    // ==================== CHARACTER Y ====================
    let characterY = null;
    let characterYBody = null;
    
    function createCharacterY() {
      const group = new THREE.Group();
      const bodyScale = 1.0;
      
      // Body dimensions
      const torsoW = 0.5 * bodyScale;
      const torsoH = 0.8 * bodyScale;
      const torsoD = 0.3 * bodyScale;
      
      // Green sleeveless vest
      const vestGeo = new THREE.BoxGeometry(torsoW, torsoH, torsoD);
      const vestMat = new THREE.MeshStandardMaterial({ color: 0x43A047, roughness: 0.6 }); // Green
      const vest = new THREE.Mesh(vestGeo, vestMat);
      vest.position.y = torsoH / 2;
      vest.castShadow = true;
      group.add(vest);
      
      // White Y neckline and zipper (pixelated - multiple small boxes)
      const pixelSize = 0.04;
      const whiteMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.7 });
      
      // Vertical zipper line
      for (let i = 0; i < 8; i++) {
        const pixel = new THREE.Mesh(new THREE.BoxGeometry(pixelSize, pixelSize, pixelSize * 0.5), whiteMat);
        pixel.position.set(0, torsoH * 0.1 + i * pixelSize, torsoD / 2 + 0.01);
        pixel.castShadow = true;
        group.add(pixel);
      }
      
      // Diagonal Y neckline (left side)
      for (let i = 0; i < 4; i++) {
        const pixel = new THREE.Mesh(new THREE.BoxGeometry(pixelSize, pixelSize, pixelSize * 0.5), whiteMat);
        pixel.position.set(-i * pixelSize * 1.2, torsoH * 0.65 - i * pixelSize, torsoD / 2 + 0.01);
        pixel.castShadow = true;
        group.add(pixel);
      }
      
      // Diagonal Y neckline (right side)
      for (let i = 0; i < 4; i++) {
        const pixel = new THREE.Mesh(new THREE.BoxGeometry(pixelSize, pixelSize, pixelSize * 0.5), whiteMat);
        pixel.position.set(i * pixelSize * 1.2, torsoH * 0.65 - i * pixelSize, torsoD / 2 + 0.01);
        pixel.castShadow = true;
        group.add(pixel);
      }
      
      // Head (slightly darker skin tone)
      const headSize = 0.38 * bodyScale;
      const headGeo = new THREE.BoxGeometry(headSize, headSize, headSize * 0.9);
      const headMat = new THREE.MeshStandardMaterial({ color: 0xE5C09F, roughness: 0.7 }); // Darker than 0xFFE0BD
      const head = new THREE.Mesh(headGeo, headMat);
      head.position.y = torsoH + headSize / 2 + 0.05 * bodyScale;
      head.castShadow = true;
      group.add(head);
      
      // 4x4 centered eyeball
      const eyePixelSize = headSize / 5;
      const eyeWhiteMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.3 });
      const eyeGreenMat = new THREE.MeshStandardMaterial({ color: 0x43A047, roughness: 0.3 });
      
      // Center the 4x4 grid on the face
      const eyeStartX = -eyePixelSize * 1.5;
      const eyeStartY = head.position.y;
      
      // Create 4x4 eye pattern: WWWW / WWWW / WGGW / WGGW
      for (let row = 0; row < 4; row++) {
        for (let col = 0; col < 4; col++) {
          const isGreen = (row >= 2) && (col >= 1 && col <= 2);
          const mat = isGreen ? eyeGreenMat : eyeWhiteMat;
          const pixel = new THREE.Mesh(
            new THREE.BoxGeometry(eyePixelSize * 0.9, eyePixelSize * 0.9, eyePixelSize * 0.3),
            mat
          );
          pixel.position.set(
            eyeStartX + col * eyePixelSize,
            eyeStartY + eyePixelSize * 1.5 - row * eyePixelSize,
            headSize * 0.45 + 0.02
          );
          pixel.castShadow = true;
          group.add(pixel);
        }
      }
      
      // Long nose (below eye)
      const noseGeo = new THREE.BoxGeometry(headSize * 0.15, headSize * 0.4, headSize * 0.2);
      const noseMat = new THREE.MeshStandardMaterial({ color: 0xD5B08F, roughness: 0.7 }); // Darker than head
      const nose = new THREE.Mesh(noseGeo, noseMat);
      nose.position.set(0, head.position.y - headSize * 0.25, headSize * 0.5);
      nose.castShadow = true;
      group.add(nose);
      
      // Arms (skin tone for sleeveless)
      const armW = 0.14 * bodyScale;
      const armH = 0.8 * bodyScale;
      const armGeo = new THREE.BoxGeometry(armW, armH, armW);
      const armMat = new THREE.MeshStandardMaterial({ color: 0xE5C09F, roughness: 0.6 }); // Skin tone
      
      [-1, 1].forEach(side => {
        const arm = new THREE.Mesh(armGeo, armMat);
        arm.position.set(side * (torsoW / 2 + armW / 2 + 0.02 * bodyScale), torsoH * 0.4, 0);
        arm.castShadow = true;
        group.add(arm);
      });
      
      // Lighter green short-shorts
      const shortsW = torsoW * 0.95;
      const shortsH = 0.25 * bodyScale;
      const shortsGeo = new THREE.BoxGeometry(shortsW, shortsH, torsoD * 0.95);
      const shortsMat = new THREE.MeshStandardMaterial({ color: 0x66BB6A, roughness: 0.7 }); // Lighter green
      const shorts = new THREE.Mesh(shortsGeo, shortsMat);
      shorts.position.y = -shortsH / 2;
      shorts.castShadow = true;
      group.add(shorts);
      
      // Legs (skin tone)
      const legW = 0.16 * bodyScale;
      const legH = 0.94 * bodyScale;
      const legGeo = new THREE.BoxGeometry(legW, legH, legW);
      const legMat = new THREE.MeshStandardMaterial({ color: 0xE5C09F, roughness: 0.7 });
      
      [-1, 1].forEach(side => {
        const leg = new THREE.Mesh(legGeo, legMat);
        leg.position.set(side * (torsoW / 4), -legH / 2 - shortsH, 0);
        leg.castShadow = true;
        group.add(leg);
      });
      
      // Position group
      const feetOffset = legH + shortsH;
      group.position.y = feetOffset;
      
      characterY = group;
      characterY.visible = false;
      scene.add(characterY);
      
      // Create physics body for Y
      const bodyDesc = physics.RigidBodyDesc.dynamic()
        .setTranslation(0, 5, 0)
        .setLinearDamping(0.5)
        .setAngularDamping(10.0)
        .lockRotations();
      
      characterYBody = world.createRigidBody(bodyDesc);
      
      const colliderDesc = physics.ColliderDesc.capsule(0.85, 0.25);
      world.createCollider(colliderDesc, characterYBody);
      
      console.log('Character Y created');
    }
    
    // ==================== GIANT FINGER ====================
    let giantFinger = null;
    const FINGER_SHOW_ALTITUDE = 200; // Show finger when rocket reaches above clouds (ATMOSPHERE_ALTITUDE + buffer)
    let fingerAnimStartTime = null; // Track when finger animation should start
    let fingerAnimating = false; // Track if finger is currently animating
    
    // ==================== 4-FINGER HAND FOR VIEWPORT ====================
    let viewportHand = null;
    
    function createViewportHand() {
      const handGroup = new THREE.Group();
      
      // Scale down from giant finger (6000x) to viewport hand size (~0.3x for human-scale hand)
      const handScale = 0.3;
      
      // Create palm
      const palmGeo = new THREE.BoxGeometry(0.15 * handScale, 0.05 * handScale, 0.2 * handScale);
      const skinMat = new THREE.MeshStandardMaterial({ 
        color: 0xFFDBB5, 
        roughness: 0.8,
        metalness: 0.1
      });
      const palm = new THREE.Mesh(palmGeo, skinMat);
      palm.position.y = 0;
      palm.castShadow = true;
      handGroup.add(palm);
      
      // Create 4 fingers (index, middle, ring, pinky) using simplified finger geometry
      const fingerPositions = [
        { x: -0.055 * handScale, name: 'index' },
        { x: -0.02 * handScale, name: 'middle' },
        { x: 0.02 * handScale, name: 'ring' },
        { x: 0.055 * handScale, name: 'pinky' }
      ];
      
      fingerPositions.forEach(({ x, name }) => {
        const fingerGroup = new THREE.Group();
        
        // Finger segments (3 segments per finger)
        const segmentLengths = [0.04 * handScale, 0.035 * handScale, 0.03 * handScale];
        const segmentRadii = [0.008 * handScale, 0.007 * handScale, 0.006 * handScale];
        
        let yOffset = 0.025 * handScale; // Start from top of palm
        
        segmentLengths.forEach((length, i) => {
          const segmentGeo = new THREE.CylinderGeometry(
            segmentRadii[i], 
            segmentRadii[i] * 0.9, 
            length, 
            8
          );
          const segment = new THREE.Mesh(segmentGeo, skinMat);
          segment.position.y = yOffset + length / 2;
          segment.castShadow = true;
          fingerGroup.add(segment);
          
          // Joint sphere
          if (i < segmentLengths.length - 1) {
            const jointGeo = new THREE.SphereGeometry(segmentRadii[i] * 0.8, 6, 6);
            const joint = new THREE.Mesh(jointGeo, skinMat);
            joint.position.y = yOffset + length;
            fingerGroup.add(joint);
          }
          
          yOffset += length;
        });
        
        // Fingertip (rounded)
        const tipGeo = new THREE.SphereGeometry(segmentRadii[2] * 0.9, 8, 8);
        const tip = new THREE.Mesh(tipGeo, skinMat);
        tip.position.y = yOffset;
        tip.scale.y = 1.2;
        fingerGroup.add(tip);
        
        fingerGroup.position.set(x, 0, 0.08 * handScale);
        fingerGroup.userData.fingerName = name;
        handGroup.add(fingerGroup);
      });
      
      // Create thumb (positioned differently)
      const thumbGroup = new THREE.Group();
      const thumbSegmentLengths = [0.035 * handScale, 0.03 * handScale];
      const thumbRadii = [0.009 * handScale, 0.008 * handScale];
      
      let thumbYOffset = 0;
      thumbSegmentLengths.forEach((length, i) => {
        const segmentGeo = new THREE.CylinderGeometry(
          thumbRadii[i],
          thumbRadii[i] * 0.9,
          length,
          8
        );
        const segment = new THREE.Mesh(segmentGeo, skinMat);
        segment.position.y = thumbYOffset + length / 2;
        segment.castShadow = true;
        thumbGroup.add(segment);
        
        thumbYOffset += length;
      });
      
      // Thumb tip
      const thumbTipGeo = new THREE.SphereGeometry(thumbRadii[1] * 0.9, 8, 8);
      const thumbTip = new THREE.Mesh(thumbTipGeo, skinMat);
      thumbTip.position.y = thumbYOffset;
      thumbTip.scale.y = 1.2;
      thumbGroup.add(thumbTip);
      
      thumbGroup.position.set(-0.09 * handScale, 0.01 * handScale, -0.05 * handScale);
      thumbGroup.rotation.z = Math.PI / 4; // Angle thumb
      thumbGroup.rotation.x = -Math.PI / 6;
      thumbGroup.userData.fingerName = 'thumb';
      handGroup.add(thumbGroup);
      
      handGroup.visible = false;
      handGroup.userData.isViewportHand = true;
      scene.add(handGroup);
      
      console.log('üñêÔ∏è Viewport hand created (4 fingers + thumb)');
      return handGroup;
    }
    
    function updateViewportHand() {
      if (!viewportHand) {
        viewportHand = createViewportHand();
      }
      
      // Show hand when viewport is dropped
      if (droppedViewport && droppedViewport.visible) {
        viewportHand.visible = true;
        
        // Position hand to hold the viewport frame
        const framePos = droppedViewport.position.clone();
        const frameWidth = droppedViewport.userData.width || 1.6;
        const frameHeight = droppedViewport.userData.height || 0.9;
        
        // Position hand at bottom-left corner of frame
        viewportHand.position.set(
          framePos.x - frameWidth / 2 + 0.1,
          framePos.y - frameHeight / 2 - 0.05,
          framePos.z
        );
        
        // Match frame rotation
        viewportHand.quaternion.copy(droppedViewport.quaternion);
        
        // Slight curl animation for fingers
        const time = performance.now() * 0.001;
        viewportHand.children.forEach(child => {
          if (child.userData.fingerName && child.userData.fingerName !== 'thumb') {
            // Gentle breathing motion
            child.rotation.x = Math.sin(time + child.position.x * 10) * 0.05;
          }
        });
      } else {
        viewportHand.visible = false;
      }
    }
    
    function createAtmosphereLayer() {
      // Create deformed cloud layer mesh that the rocket passes through
      const radius = 400;
      const geometry = new THREE.SphereGeometry(radius, 32, 32, 0, Math.PI * 2, 0, Math.PI / 4); // Top hemisphere only
      
      // Deform vertices to create cloud-like bumps
      const positions = geometry.attributes.position;
      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const y = positions.getY(i);
        const z = positions.getZ(i);
        
        // Add noise for cloud deformation
        const noise = Math.sin(x * 0.02) * Math.cos(z * 0.02) * 20 + 
                      Math.sin(x * 0.05) * Math.cos(z * 0.05) * 10;
        const scale = (radius + noise) / radius;
        
        positions.setXYZ(i, x * scale, y * scale, z * scale);
      }
      positions.needsUpdate = true;
      geometry.computeVertexNormals();
      
      // Cloud material - white/grey, transparent
      const material = new THREE.MeshStandardMaterial({
        color: 0xEEEEEE,
        transparent: true,
        opacity: 0.6,
        side: THREE.DoubleSide,
        roughness: 1.0,
        metalness: 0.0
      });
      
      atmosphereLayer = new THREE.Mesh(geometry, material);
      atmosphereLayer.position.y = ATMOSPHERE_ALTITUDE - radius * 0.5; // Position at atmosphere altitude
      atmosphereLayer.visible = false;
      scene.add(atmosphereLayer);
      
      console.log('Atmosphere layer created');
    }
    
    function createStarField() {
      // Create instanced stars for better performance
      const starCount = 2000;
      
      // Small box geometry for each star (cheaper than spheres)
      const starGeometry = new THREE.BoxGeometry(2, 2, 2);
      
      // Material with emissive for glow
      const starMaterial = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0,
        fog: false // Stars not affected by fog
      });
      
      // Create instanced mesh
      starField = new THREE.InstancedMesh(starGeometry, starMaterial, starCount);
      starField.visible = false;
      
      // Set up instance matrices and colors
      const matrix = new THREE.Matrix4();
      const color = new THREE.Color();
      
      for (let i = 0; i < starCount; i++) {
        // Random position in a sphere around the scene
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI;
        const radius = 800 + Math.random() * 200;
        
        const x = radius * Math.sin(phi) * Math.cos(theta);
        const y = radius * Math.sin(phi) * Math.sin(theta);
        const z = radius * Math.cos(phi);
        
        // Set position and scale
        matrix.setPosition(x, y, z);
        starField.setMatrixAt(i, matrix);
        
        // Star colors - mostly white, some slightly blue or yellow
        const colorChoice = Math.random();
        if (colorChoice < 0.7) {
          color.setRGB(1, 1, 1); // White
        } else if (colorChoice < 0.85) {
          color.setRGB(0.8, 0.9, 1); // Slightly blue
        } else {
          color.setRGB(1, 1, 0.8); // Slightly yellow
        }
        
        starField.setColorAt(i, color);
      }
      
      starField.instanceMatrix.needsUpdate = true;
      if (starField.instanceColor) starField.instanceColor.needsUpdate = true;
      
      scene.add(starField);
      
      console.log('‚≠ê Star field created with instanced rendering (2000 instances)');
    }
    
    function createPlanetoid() {
      // Create a large planetoid mesh to show below as we rise
      const radius = planetRadius;
      
      // Create multiple LOD levels for altitude-based switching
      const createTerrainSphere = (segments) => {
        const geometry = new THREE.SphereGeometry(radius, segments, segments);
        
        // Add very subtle terrain variation
        const positions = geometry.attributes.position;
        for (let i = 0; i < positions.count; i++) {
          const x = positions.getX(i);
          const y = positions.getY(i);
          const z = positions.getZ(i);
          
          // Very subtle terrain variation (scaled for larger radius)
          const noise = Math.sin(x * 0.002) * Math.cos(z * 0.002) * 15 + 
                        Math.sin(x * 0.005) * Math.cos(z * 0.005) * 8;
          const scale = (radius + noise) / radius;
          
          positions.setXYZ(i, x * scale, y * scale, z * scale);
        }
        positions.needsUpdate = true;
        geometry.computeVertexNormals();
        return geometry;
      };
      
      // Store LOD geometries and materials
      const lodGeometry = {
        high: createTerrainSphere(64), // Close: 64x64 segments
        medium: createTerrainSphere(32), // Medium: 32x32 segments
        low: createTerrainSphere(16) // Far: 16x16 segments
      };
      
      // Standard material (used at low-medium altitude)
      const standardMaterial = new THREE.MeshStandardMaterial({
        color: 0x4a7c4e, // Same green as ground
        roughness: 0.9,
        metalness: 0.1
      });
      
      // Basic material (used at high altitude - no lighting calculations)
      const basicMaterial = new THREE.MeshBasicMaterial({
        color: 0x4a7c4e,
        fog: false
      });
      
      planetoidMesh = new THREE.Mesh(lodGeometry.high, standardMaterial);
      planetoidMesh.position.y = -radius;
      planetoidMesh.visible = false;
      
      // Store LOD data for dynamic switching
      planetoidMesh.userData.lodGeometry = lodGeometry;
      planetoidMesh.userData.standardMaterial = standardMaterial;
      planetoidMesh.userData.basicMaterial = basicMaterial;
      planetoidMesh.userData.currentLOD = 'high';
      
      // Use worldRoot if available, otherwise add to scene
      if (worldRoot) {
        worldRoot.add(planetoidMesh);
      } else {
        scene.add(planetoidMesh);
      }
      
      console.log('Planetoid created with 3 LOD levels (64/32/16 segments) and 2 material modes');
    }
    
    function createBuildingTextureOnPlanetoid() {
      if (!planetoidMesh) return;
      
      console.log('üèôÔ∏è Converting distant skyline to planetoid texture...');
      
      // Create scattered gray rectangles to represent buildings as a "texture"
      const rectangleCount = 1200; // Many scattered rectangles for dense coverage
      const rectGeo = new THREE.PlaneGeometry(1, 1); // Will be scaled per instance
      const rectMat = new THREE.MeshBasicMaterial({
        color: 0x888888,
        side: THREE.DoubleSide,
        fog: false
      });
      
      const instancedRects = new THREE.InstancedMesh(rectGeo, rectMat, rectangleCount);
      instancedRects.castShadow = false;
      instancedRects.receiveShadow = false;
      
      const dummy = new THREE.Object3D();
      const surfaceRadius = planetRadius + 1; // Just above planet surface
      
      // Distribute rectangles using Fibonacci sphere for even coverage
      for (let i = 0; i < rectangleCount; i++) {
        // Fibonacci sphere distribution
        const phi = Math.acos(1 - 2 * (i + 0.5) / rectangleCount);
        const theta = Math.PI * (1 + Math.sqrt(5)) * i;
        
        // Calculate position on sphere
        const x = Math.cos(theta) * Math.sin(phi) * surfaceRadius;
        const y = Math.cos(phi) * surfaceRadius;
        const z = Math.sin(theta) * Math.sin(phi) * surfaceRadius;
        
        // Random rectangle size (varying widths and heights)
        const width = 2 + Math.random() * 8;
        const height = 1 + Math.random() * 4;
        
        // Position rectangle
        dummy.position.set(x, y - planetRadius, z);
        
        // Scale rectangle
        dummy.scale.set(width, height, 1);
        
        // Orient rectangle to point outward from planet center (tangent to surface)
        const normalVec = new THREE.Vector3(x, y - planetRadius, z).normalize();
        dummy.lookAt(
          dummy.position.x + normalVec.x,
          dummy.position.y + normalVec.y,
          dummy.position.z + normalVec.z
        );
        
        // Add some random rotation for variety
        dummy.rotateZ(Math.random() * Math.PI * 2);
        
        dummy.updateMatrix();
        instancedRects.setMatrixAt(i, dummy.matrix);
      }
      
      instancedRects.instanceMatrix.needsUpdate = true;
      
      planetoidMesh.add(instancedRects);
      planetoidMesh.userData.buildingTexture = instancedRects;
      
      console.log(`‚úì Added ${rectangleCount} building texture rectangles to planetoid`);
    }
    
    function addCityPatchesToPlanetoid() {
      if (!planetoidMesh) return;
      
      // Clear previous decorations
      if (planetoidMesh.userData.buildingInstances) {
        planetoidMesh.remove(planetoidMesh.userData.buildingInstances);
        if (planetoidMesh.userData.buildingInstances.geometry) {
          planetoidMesh.userData.buildingInstances.geometry.dispose();
        }
        if (planetoidMesh.userData.buildingInstances.material) {
          planetoidMesh.userData.buildingInstances.material.dispose();
        }
      }
      
      console.log('Adding building decorations to planetoid...');
      
      // Create instanced prisms to simulate buildings across the sphere
      const buildingCount = 800; // Many buildings for dense coverage
      const prismGeo = new THREE.BoxGeometry(3, 8, 3); // Simple prism/box shape
      const buildingMat = new THREE.MeshStandardMaterial({
        color: 0x888888,
        roughness: 0.9,
        metalness: 0.1
      });
      
      const instancedBuildings = new THREE.InstancedMesh(prismGeo, buildingMat, buildingCount);
      instancedBuildings.castShadow = false;
      instancedBuildings.receiveShadow = false;
      
      const dummy = new THREE.Object3D();
      const surfaceRadius = planetRadius + 2; // Slightly above planet surface
      
      // Distribute buildings evenly across sphere using Fibonacci sphere
      for (let i = 0; i < buildingCount; i++) {
        // Fibonacci sphere distribution
        const phi = Math.acos(1 - 2 * (i + 0.5) / buildingCount);
        const theta = Math.PI * (1 + Math.sqrt(5)) * i;
        
        // Calculate position on sphere
        const x = Math.cos(theta) * Math.sin(phi) * surfaceRadius;
        const y = Math.cos(phi) * surfaceRadius;
        const z = Math.sin(theta) * Math.sin(phi) * surfaceRadius;
        
        // Random building height
        const height = 5 + Math.random() * 15;
        
        // Position building
        dummy.position.set(x, y - planetRadius, z);
        
        // Scale building (vary height)
        dummy.scale.set(1, height / 8, 1); // Height varies, width/depth constant
        
        // Orient building to point outward from planet center (perpendicular to surface)
        const normal = new THREE.Vector3(x, y, z).normalize();
        dummy.up.copy(normal);
        dummy.lookAt(x + normal.x * 100, y + normal.y * 100, z + normal.z * 100);
        
        // Apply transformation to instance
        dummy.updateMatrix();
        instancedBuildings.setMatrixAt(i, dummy.matrix);
      }
      
      instancedBuildings.instanceMatrix.needsUpdate = true;
      
      planetoidMesh.add(instancedBuildings);
      planetoidMesh.userData.buildingInstances = instancedBuildings;
      
      console.log(`‚úì Added ${buildingCount} building decorations to planetoid`);
    }
    
    async function toggleRocket() {
      await ensureRocketAssets();
      
      rocketEnabled = !rocketEnabled;
      rocketMesh.visible = rocketEnabled;
      player.visible = !rocketEnabled && !pointerLocked;
      
      if (rocketEnabled && playerBody && rocketBody) {
        // Enter rocket - transfer position from player to rocket
        const playerPos = playerBody.translation();
        rocketBody.setTranslation({ x: playerPos.x, y: playerPos.y, z: playerPos.z }, true);
        rocketBody.setLinvel({ x: 0, y: 0, z: 0 }, true);
        rocketBody.setAngvel({ x: 0, y: 0, z: 0 }, true); // Stop any rotation
        rocketVelocity = 0;
        rocketEnginesOn = false; // Engines start off
        
        // Set initial camera to top-down view
        rocketCameraYaw = 0; // Facing forward
        rocketCameraPitch = Math.PI / 2; // Top-down (90 degrees above)
        rocketCameraDistance = 15;
        
        // Hide exhaust initially (must press SPACE to ignite)
        if (rocketMesh.userData.exhaustGroup) {
          rocketMesh.userData.exhaustGroup.visible = false;
        }
        
        console.log('Entered rocket - Press SPACE to ignite engines');
      } else if (!rocketEnabled && playerBody && rocketBody) {
        // Exit rocket - transfer position from rocket to player
        const rocketPos = rocketBody.translation();
        playerBody.setTranslation({ x: rocketPos.x, y: rocketPos.y, z: rocketPos.z }, true);
        playerBody.setLinvel({ x: 0, y: 0, z: 0 }, true);
        
        // Turn off engines and hide exhaust
        rocketEnginesOn = false;
        if (rocketMesh.userData.exhaustGroup) {
          rocketMesh.userData.exhaustGroup.visible = false;
        }
        
        // Restore from micro LOD if active
        if (microLODActive) {
          switchFromMicroLOD();
        }
        
        // Reset atmosphere effects
        if (atmosphereLayer) atmosphereLayer.visible = false;
        if (starField) starField.visible = false;
        if (planetoidMesh) planetoidMesh.visible = false;
        
        // Reset giant finger animation
        if (giantFinger) {
          giantFinger.visible = false;
          fingerAnimStartTime = null;
          fingerAnimating = false;
          // Reset to start position (with fingertip offset)
          if (giantFinger.userData.startPos) {
            const fingerLength = 0.78 * 6000; // Finger is scaled 6000x
            const startPos = giantFinger.userData.startPos;
            giantFinger.position.set(
              startPos.x,
              startPos.y + fingerLength, // Offset so fingertip is at startPos, not base
              startPos.z
            );
            giantFinger.rotation.x = Math.PI; // Point down
            giantFinger.rotation.z = 0;
          }
        }
        
        // Reset trajectory
        rocketTrajectory.set(0, 1, 0);
        rocketTargetTrajectory.set(0, 1, 0);
        
        // Restore blue sky
        scene.background = new THREE.Color(0x87CEEB);
        if (scene.fog) {
          scene.fog.density = 0.006;
        }
        
        console.log('Exited rocket');
      }
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // TODO: SPHERICAL WORLD MORPH FOR ROCKET MODE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // Future enhancement: Implement spherical world morphing when at high altitude
    // This would require:
    // 1. Custom vertex shaders to morph all world geometry onto a sphere surface
    // 2. Spherical coordinate system for physics and navigation
    // 3. Curved ground, roads, and building placement following sphere surface
    // 4. Update player Y position and all entity positions to follow sphere curvature
    // 5. Modify camera to account for spherical perspective
    // 
    // Implementation approach:
    // - Add a uniform 'sphereMorphFactor' (0-1) to all world materials
    // - In vertex shader: lerp between flat (y) and spherical (normalize + scale) positions
    // - Increase morphFactor based on altitude: morphFactor = smoothstep(150, 300, altitude)
    // - Apply sphere transform: spherePos = normalize(vec3(x, y, z)) * planetRadius
    // - Final position: mix(flatPos, spherePos, morphFactor)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    function updateRocket(deltaTime) {
      if (!rocketEnabled || !rocketBody || !rocketMesh) return;
      
      const pos = rocketBody.translation();
      const vel = rocketBody.linvel();
      
      // Calculate distance from planet center (at y = -planetRadius)
      const distanceFromCenter = Math.sqrt(pos.x * pos.x + (pos.y + planetRadius) * (pos.y + planetRadius) + pos.z * pos.z);
      const inGravityWell = distanceFromCenter < GRAVITY_RADIUS;
      
      // SPACE to control engines
      // In gravity well: must hold Space to keep engines on
      // In space: engines stay on once ignited (toggle with E to turn off)
      const holdingThrottle = keys.has('Space');
      
      if (inGravityWell) {
        // In gravity well: Space acts as thrust hold
        if (holdingThrottle) {
          if (!rocketEnginesOn) {
            rocketEnginesOn = true;
            console.log('üöÄ Engines ignited!');
          }
        } else {
          // Released Space in gravity well - engines off
          if (rocketEnginesOn) {
            rocketEnginesOn = false;
            console.log('‚ö† Engines off - rocket falling!');
          }
        }
      } else {
        // In space (no gravity): Space or E to toggle engines
        if ((keys.has('Space') || keys.has('KeyE')) && !keys.has('_rocketToggleCooldown')) {
          keys.add('_rocketToggleCooldown');
          setTimeout(() => keys.delete('_rocketToggleCooldown'), 300); // Cooldown
          
          rocketEnginesOn = !rocketEnginesOn;
          console.log(rocketEnginesOn ? 'üöÄ Engines ignited!' : '‚ö† Engines off - drifting in space');
        }
      }
      
      // Show/hide exhaust based on engine state
      if (rocketMesh.userData.exhaustGroup) {
        rocketMesh.userData.exhaustGroup.visible = rocketEnginesOn;
        
        // Animate exhaust when engines are on
        if (rocketEnginesOn) {
          const exhaustGroup = rocketMesh.userData.exhaustGroup;
          const time = performance.now() * 0.01;
          
          // Animate each child (main flame + plumes)
          exhaustGroup.children.forEach((exhaust, index) => {
            // Pulsating scale
            const pulsePhase = time + index * 0.3;
            exhaust.scale.y = 1 + Math.sin(pulsePhase) * 0.2;
            exhaust.scale.x = 1 + Math.sin(pulsePhase * 1.3) * 0.1;
            exhaust.scale.z = 1 + Math.sin(pulsePhase * 1.3) * 0.1;
            
            // Subtle rotation
            exhaust.rotation.y += deltaTime * (2 + index * 0.5);
          });
        }
      }
      
      // Update rocket mesh position
      rocketMesh.position.set(pos.x, pos.y, pos.z);
      
      // Apply forces based on engine state
      if (rocketEnginesOn) {
        // Camera-relative trajectory controls - WASD / Arrow keys
        const pitchStrength = 1.5; // Forward/back tilt
        const rollStrength = 2.0; // Side to side tilt
        
        // Get current rotation from physics body
        const rot = rocketBody.rotation();
        const currentQuat = new THREE.Quaternion(rot.x, rot.y, rot.z, rot.w);
        
        // Calculate camera-relative directions
        // Get vector from rocket to camera
        const rocketToCamera = new THREE.Vector3(
          camera.position.x - pos.x,
          camera.position.y - pos.y,
          camera.position.z - pos.z
        ).normalize();
        
        // Calculate camera's right vector (perpendicular to camera view, in XZ plane mostly)
        const cameraUp = new THREE.Vector3(0, 1, 0);
        const cameraRight = new THREE.Vector3().crossVectors(cameraUp, rocketToCamera).normalize();
        const cameraActualUp = new THREE.Vector3().crossVectors(rocketToCamera, cameraRight).normalize();
        
        // Build rotation changes based on camera-relative inputs
        let angularVelocity = new THREE.Vector3(0, 0, 0);
        
        // W: Tilt away from camera (pitch forward in camera view)
        if (keys.has('KeyW') || keys.has('ArrowUp')) {
          // Apply rotation around the camera's right axis to pitch away
          angularVelocity.add(cameraRight.clone().multiplyScalar(-pitchStrength));
        }
        
        // S: Tilt toward camera (pitch back in camera view)
        if (keys.has('KeyS') || keys.has('ArrowDown')) {
          // Apply rotation around the camera's right axis to pitch toward
          angularVelocity.add(cameraRight.clone().multiplyScalar(pitchStrength));
        }
        
        // A: Yaw left (rotate around rocket's current up axis)
        if (keys.has('KeyA') || keys.has('ArrowLeft')) {
          // Get rocket's current "up" direction (its forward axis)
          const rocketUp = new THREE.Vector3(0, 1, 0).applyQuaternion(currentQuat);
          // Apply rotation around rocket's up axis for proper left steering
          angularVelocity.add(rocketUp.multiplyScalar(rollStrength));
        }
        
        // D: Yaw right (rotate around rocket's current up axis)
        if (keys.has('KeyD') || keys.has('ArrowRight')) {
          // Get rocket's current "up" direction (its forward axis)
          const rocketUp = new THREE.Vector3(0, 1, 0).applyQuaternion(currentQuat);
          // Apply rotation around rocket's up axis for proper right steering
          angularVelocity.add(rocketUp.multiplyScalar(-rollStrength));
        }
        
        // Q to reset to straight up
        if (keys.has('KeyQ')) {
          const upQuat = new THREE.Quaternion(); // Identity = straight up
          rocketBody.setRotation({ x: upQuat.x, y: upQuat.y, z: upQuat.z, w: upQuat.w }, true);
          angularVelocity.set(0, 0, 0);
        }
        
        // Apply angular velocity to rotate the rocket
        let finalQuat = currentQuat;
        if (angularVelocity.lengthSq() > 0.001) {
          // Convert angular velocity to quaternion rotation
          const angle = angularVelocity.length() * deltaTime;
          const axis = angularVelocity.normalize();
          const deltaQuat = new THREE.Quaternion().setFromAxisAngle(axis, angle);
          
          // Combine with current rotation
          finalQuat = currentQuat.clone().multiply(deltaQuat);
          rocketBody.setRotation({ x: finalQuat.x, y: finalQuat.y, z: finalQuat.z, w: finalQuat.w }, true);
        }
        
        // Update trajectory direction based on rocket orientation
        const forward = new THREE.Vector3(0, 1, 0); // Rocket's "up" is forward
        forward.applyQuaternion(finalQuat);
        rocketTrajectory.copy(forward).normalize();
        
        // Accelerate along trajectory
        rocketVelocity = Math.min(ROCKET_MAX_SPEED, rocketVelocity + rocketAcceleration * deltaTime);
        
        // Apply thrust along trajectory direction
        rocketBody.setLinvel({
          x: rocketTrajectory.x * rocketVelocity,
          y: rocketTrajectory.y * rocketVelocity,
          z: rocketTrajectory.z * rocketVelocity
        }, true);
        
        // Orient mesh to match physics body (manual control, no auto-alignment)
        rocketMesh.quaternion.copy(finalQuat);
      } else {
        // Engines off
        rocketVelocity = 0;
        
        // Apply gravity if in gravity well
        if (inGravityWell) {
          const gravityStrength = 15; // m/s¬≤
          const gravityFalloff = 1 - (distanceFromCenter / GRAVITY_RADIUS); // Stronger closer to planet
          
          rocketBody.applyImpulse({ 
            x: 0, 
            y: -gravityStrength * gravityFalloff * deltaTime, 
            z: 0 
          }, true);
        }
        
        // Mesh follows physics rotation when engines off (can tip over)
        const rot = rocketBody.rotation();
        rocketMesh.quaternion.set(rot.x, rot.y, rot.z, rot.w);
      }
      
      // Orbital camera controls - smooth 360¬∞ rotation around rocket center
      // No pitch clamping - allow full rotation
      
      // Calculate camera position in spherical coordinates around rocket center
      const camX = pos.x + rocketCameraDistance * Math.cos(rocketCameraPitch) * Math.sin(rocketCameraYaw);
      const camY = pos.y + rocketCameraDistance * Math.sin(rocketCameraPitch);
      const camZ = pos.z + rocketCameraDistance * Math.cos(rocketCameraPitch) * Math.cos(rocketCameraYaw);
      
      camera.position.set(camX, camY, camZ);
      
      // Camera always looks at rocket center
      camera.lookAt(pos.x, pos.y, pos.z);
      
      // Mouse wheel to zoom
      // (handled in setupCameraControls)
      
      // Dynamic scaling based on altitude
      const altitude = pos.y;
      
      // ==================== AGGRESSIVE ALTITUDE-BASED OPTIMIZATIONS ====================
      // Disable expensive features above atmosphere for massive performance gains
      const inSpace = altitude > ATMOSPHERE_ALTITUDE;
      
      // Disable shadows completely in space
      if (inSpace && sunLight.castShadow) {
        sunLight.castShadow = false;
        renderer.shadowMap.enabled = false;
        console.log('‚ö° OPTIMIZATION: Shadows disabled in space');
      } else if (!inSpace && !sunLight.castShadow) {
        sunLight.castShadow = true;
        renderer.shadowMap.enabled = true;
        console.log('üí° Shadows re-enabled at low altitude');
      }
      
      // Disable post-processing in space
      if (inSpace) {
        if (composer && composer.passes) {
          composer.passes.forEach(pass => {
            if (pass.constructor.name === 'UnrealBloomPass' || 
                pass.constructor.name === 'SMAAPass' || 
                pass.constructor.name === 'MotionBlurPass') {
              if (pass.enabled) {
                pass.enabled = false;
                console.log(`‚ö° OPTIMIZATION: Disabled ${pass.constructor.name}`);
              }
            }
          });
        }
      } else {
        if (composer && composer.passes) {
          composer.passes.forEach(pass => {
            if (pass.constructor.name === 'UnrealBloomPass' || 
                pass.constructor.name === 'SMAAPass' || 
                pass.constructor.name === 'MotionBlurPass') {
              if (!pass.enabled && pass.constructor.name !== 'MotionBlurPass') { // Keep motion blur off
                pass.enabled = true;
                console.log(`üí° Re-enabled ${pass.constructor.name}`);
              }
            }
          });
        }
      }
      
      // Disable fog completely in space
      if (inSpace && scene.fog) {
        scene.fog = null;
        console.log('‚ö° OPTIMIZATION: Fog disabled in space');
      } else if (!inSpace && !scene.fog) {
        scene.fog = new THREE.FogExp2(0xcccccc, 0.006);
        console.log('üí° Fog re-enabled at low altitude');
      }
      
      // Store optimization state to avoid redundant expensive updates
      // Ensure userData exists first
      if (!rocketBody.userData) {
        rocketBody.userData = {};
      }
      if (!rocketBody.userData.lastOptimizationState) {
        rocketBody.userData.lastOptimizationState = { inSpace: false };
      }
      const lastState = rocketBody.userData.lastOptimizationState;
      
      // Notify when entering/exiting space for first time
      if (inSpace !== lastState.inSpace) {
        if (inSpace) {
          console.log('üöÄ ENTERED SPACE - All expensive features disabled');
        } else {
          console.log('üåç RE-ENTERED ATMOSPHERE - Features re-enabled');
        }
        lastState.inSpace = inSpace;
      }
      
      if (altitude > 50) {
        // Scale down world as rocket goes higher (starts sooner)
        const scaleFactor = Math.max(0.1, 1 - (altitude - 50) / 300);
        worldRoot.scale.setScalar(scaleFactor);
        
        // Scale down player too
        if (altitude > 100) {
          playerScale = Math.max(0.01, 1 - (altitude - 100) / 200);
        }
      }
      
      // Micro LOD system - replace detailed chunks with simple instances when very high
      if (altitude > MICRO_LOD_ALTITUDE) {
        // Switch to micro LOD if not already active
        if (!microLODActive) {
          switchToMicroLOD();
        }
      } else {
        // Restore detailed chunks if we're descending
        if (microLODActive) {
          switchFromMicroLOD();
        }
      }
      
      // Atmosphere transition system
      // Create atmosphere/space elements if not already created
      if (!atmosphereLayer) createAtmosphereLayer();
      if (!starField) createStarField();
      if (!planetoidMesh) {
        createPlanetoid();
      }
      
      // Calculate transition progress (0 to 1)
      const atmosphereProgress = Math.max(0, Math.min(1, (altitude - ATMOSPHERE_ALTITUDE) / (SPACE_ALTITUDE - ATMOSPHERE_ALTITUDE)));
      
      // Show atmosphere layer when approaching it
      if (altitude > ATMOSPHERE_ALTITUDE - 30 && altitude < ATMOSPHERE_ALTITUDE + 100) {
        atmosphereLayer.visible = true;
        // Fade out atmosphere layer as we pass through it
        const fadeProgress = Math.max(0, Math.min(1, (altitude - ATMOSPHERE_ALTITUDE) / 80));
        atmosphereLayer.material.opacity = 0.6 * (1 - fadeProgress);
      } else {
        atmosphereLayer.visible = false;
      }
      
      // Show planetoid when altitude is high enough to see curvature
      if (altitude > 80) {
        planetoidMesh.visible = true;
        
        // Dynamic LOD and material switching based on altitude
        if (planetoidMesh.userData.lodGeometry) {
          // Geometry LOD switching
          if (altitude > 1000 && planetoidMesh.userData.currentLOD !== 'low') {
            // Very high (>1000m): Use 16x16 segments
            planetoidMesh.geometry = planetoidMesh.userData.lodGeometry.low;
            planetoidMesh.userData.currentLOD = 'low';
            console.log('‚ö° Planetoid LOD: ULTRA-LOW (16x16)');
          } else if (altitude > 400 && altitude <= 1000 && planetoidMesh.userData.currentLOD !== 'medium') {
            // High (400-1000m): Use 32x32 segments
            planetoidMesh.geometry = planetoidMesh.userData.lodGeometry.medium;
            planetoidMesh.userData.currentLOD = 'medium';
            console.log('‚ö° Planetoid LOD: MEDIUM (32x32)');
          } else if (altitude <= 400 && planetoidMesh.userData.currentLOD !== 'high') {
            // Low-Medium (80-400m): Use 64x64 segments
            planetoidMesh.geometry = planetoidMesh.userData.lodGeometry.high;
            planetoidMesh.userData.currentLOD = 'high';
            console.log('üíé Planetoid LOD: HIGH (64x64)');
          }
          
          // Material switching (lighting vs basic)
          if (inSpace && planetoidMesh.material !== planetoidMesh.userData.basicMaterial) {
            // In space: Switch to MeshBasicMaterial (no lighting calculations)
            planetoidMesh.material = planetoidMesh.userData.basicMaterial;
            console.log('‚ö° Planetoid material: BASIC (no lighting)');
          } else if (!inSpace && planetoidMesh.material !== planetoidMesh.userData.standardMaterial) {
            // In atmosphere: Switch to MeshStandardMaterial (with lighting)
            planetoidMesh.material = planetoidMesh.userData.standardMaterial;
            console.log('üí° Planetoid material: STANDARD (with lighting)');
          }
        }
        
        // Add scattered building texture rectangles once when first visible
        if (!planetoidMesh.userData.buildingTexture && altitude > 150) {
          createBuildingTextureOnPlanetoid();
        }
        
        // Hide distant skyline group when high enough (buildings converted to planetoid texture)
        if (distantSkylineGroup && altitude > 150) {
          distantSkylineGroup.visible = false;
        }
      } else {
        planetoidMesh.visible = false;
        
        // Restore distant skyline when planetoid not visible
        if (distantSkylineGroup) {
          distantSkylineGroup.visible = true;
        }
      }
      
      // Transition sky color from blue to black as we enter space
      if (altitude > ATMOSPHERE_ALTITUDE) {
        const skyBlue = new THREE.Color(0x87CEEB);
        const spaceBlack = new THREE.Color(0x000000);
        
        const currentSkyColor = new THREE.Color().lerpColors(skyBlue, spaceBlack, atmosphereProgress);
        scene.background = currentSkyColor;
        
        // Adjust fog density as we rise
        if (scene.fog) {
          scene.fog.density = 0.006 * (1 - atmosphereProgress);
        }
      } else {
        // Reset to blue sky
        scene.background = new THREE.Color(0x87CEEB);
        if (scene.fog) {
          scene.fog.density = 0.006;
        }
      }
      
      // Show stars as we enter space
      if (altitude > ATMOSPHERE_ALTITUDE) {
        starField.visible = true;
        starField.material.opacity = atmosphereProgress;
      } else {
        starField.visible = false;
      }
      
      // Show giant finger when above clouds with 3s delay and curved animation
      if (giantFinger) {
        if (altitude > FINGER_SHOW_ALTITUDE) {
          // Start animation timer if not already started
          if (!fingerAnimStartTime) {
            fingerAnimStartTime = performance.now();
            fingerAnimating = false;
            console.log('‚òùÔ∏è Finger animation triggered - 3 second delay started');
          }
          
          const timeSinceTriggered = (performance.now() - fingerAnimStartTime) / 1000; // Convert to seconds
          
          if (timeSinceTriggered >= 3.0 && giantFinger.userData.startPos && giantFinger.userData.targetPos) {
            // 3 second delay has passed, show and animate finger
            giantFinger.visible = true;
            fingerAnimating = true;
            
            // Animation duration: 4 seconds for smooth entry
            const animDuration = 4.0;
            const animTime = Math.min((timeSinceTriggered - 3.0) / animDuration, 1.0);
            
            // Smooth easing function (ease-out)
            const easeOut = t => 1 - Math.pow(1 - t, 3);
            const t = easeOut(animTime);
            
            // Get start and target positions
            const startPos = giantFinger.userData.startPos;
            const targetPos = giantFinger.userData.targetPos;
            
            // Curved path - arc from back to front with upward curve
            const curveHeight = 300; // Height of arc peak
            
            // CRITICAL FIX: Position by fingertip, not base
            // Finger length is 0.78 units * 6000 scale = 4680 units
            // When pointing down (rotation.x = Math.PI), fingertip is 4680 units below pivot
            // So we offset the target position UP by finger length to make tip hover at target
            const fingerLength = 0.78 * 6000; // Finger is scaled 6000x
            
            // Interpolate X (stays at 0 - centered above city)
            const x = startPos.x + (targetPos.x - startPos.x) * t;
            
            // Interpolate Y with upward arc curve + fingertip offset
            const yLinear = (startPos.y + fingerLength) + ((targetPos.y + fingerLength) - (startPos.y + fingerLength)) * t;
            const yArc = Math.sin(t * Math.PI) * curveHeight; // Arc peak at t=0.5
            const y = yLinear + yArc;
            
            // Interpolate Z (forward motion)
            const z = startPos.z + (targetPos.z - startPos.z) * t;
            
            giantFinger.position.set(x, y, z);
            
            // Once animation is complete, add subtle hovering
            if (animTime >= 1.0) {
              const hoverTime = performance.now() * 0.001;
              giantFinger.position.y = targetPos.y + fingerLength + Math.sin(hoverTime * 0.5) * 20;
              // Gentle swaying
              giantFinger.rotation.z = Math.sin(hoverTime * 0.3) * 0.05;
              giantFinger.rotation.x = Math.PI + Math.sin(hoverTime * 0.4) * 0.03; // Slight tilt while keeping pointed down
            }
          } else {
            // Still in 3 second delay or positions not ready - keep finger hidden
            giantFinger.visible = false;
          }
        } else {
          // Below altitude threshold - reset animation state
          if (fingerAnimStartTime) {
            fingerAnimStartTime = null;
            fingerAnimating = false;
            console.log('‚òùÔ∏è Finger animation reset - dropped below altitude');
          }
          giantFinger.visible = false;
        }
      }
      
      console.log(`Rocket altitude: ${altitude.toFixed(1)}m, velocity: ${rocketVelocity.toFixed(1)}m/s, atmosphere: ${(atmosphereProgress * 100).toFixed(0)}%`);
    }
    
    // ==================== BIKE SYSTEM ====================
    function createBike() {
      const bikeGroup = new THREE.Group();
      
      // Body (from lightbike.html) - rotated 90 degrees
      const bodyGeo = new THREE.BoxGeometry(3.6, 1, 1.05);
      const bodyMat = new THREE.MeshLambertMaterial({ 
        color: 0x00ffff, 
        emissive: 0x00ffff, 
        emissiveIntensity: 0.8 
      });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.set(0, 1.2, 0);
      body.rotation.y = Math.PI / 2; // Rotate body 90 degrees
      body.castShadow = true;
      bikeGroup.add(body);
      
      // Wheels - rotated 90 degrees from their default orientation
      const wheelR = 0.7;
      const wheelMat = new THREE.MeshLambertMaterial({ 
        color: 0xcccccc, 
        emissive: 0x888888, 
        emissiveIntensity: 0.3 
      });
      const wheelGeo = new THREE.CylinderGeometry(wheelR, wheelR, 0.3, 24);
      
      // Front wheel - rotated to roll along Z axis
      const w1 = new THREE.Mesh(wheelGeo, wheelMat);
      w1.rotation.x = Math.PI / 2; // Rotate 90 degrees to roll forward
      w1.position.set(0, wheelR, 1.4); // Along Z axis
      w1.castShadow = true;
      bikeGroup.add(w1);
      
      // Rear wheel - rotated to roll along Z axis
      const w2 = new THREE.Mesh(wheelGeo, wheelMat);
      w2.rotation.x = Math.PI / 2; // Rotate 90 degrees to roll forward
      w2.position.set(0, wheelR, -1.4); // Along Z axis
      w2.castShadow = true;
      bikeGroup.add(w2);
      
      bikeMesh = bikeGroup;
      bikeMesh.visible = false;
      scene.add(bikeMesh);
      
      // Create bike physics body (similar to player)
      const bodyDesc = physics.RigidBodyDesc.dynamic()
        .setTranslation(0, 2, 0)
        .setLinearDamping(0.5)
        .setAngularDamping(10.0)
        .lockRotations();
      
      bikeBody = world.createRigidBody(bodyDesc);
      
      const colliderDesc = physics.ColliderDesc.cuboid(0.52, 0.5, 1.8) // Swapped dimensions for rotation
        .setFriction(0.7)
        .setRestitution(0.1);
      world.createCollider(colliderDesc, bikeBody);
      
      // Create trail mesh
      createBikeTrail();
    }
    
    function createBikeTrail() {
      // Create vertical light trail like in lightbike.html
      const trailGeo = new THREE.BufferGeometry();
      const trailMat = new THREE.MeshBasicMaterial({
        color: 0x00ffff,
        transparent: true,
        opacity: 0.85,
        side: THREE.DoubleSide,
        depthWrite: false,
        blending: THREE.AdditiveBlending
      });
      
      bikeTrailMesh = new THREE.Mesh(trailGeo, trailMat);
      bikeTrailMesh.renderOrder = 2;
      bikeTrailMesh.frustumCulled = false;
      bikeTrailMesh.visible = false;
      scene.add(bikeTrailMesh);
    }
    
    function makeTrailPermanent() {
      // Convert current trail into a permanent mesh
      if (!bikeTrailMesh || bikeTrailPoints.length < 2) return;
      
      const permanentGeo = bikeTrailMesh.geometry.clone();
      const permanentMat = new THREE.MeshBasicMaterial({
        color: 0x00ffff,
        transparent: true,
        opacity: 0.7,
        side: THREE.DoubleSide,
        depthWrite: false,
        blending: THREE.AdditiveBlending
      });
      
      const permanentMesh = new THREE.Mesh(permanentGeo, permanentMat);
      permanentMesh.renderOrder = 2;
      permanentMesh.frustumCulled = false;
      scene.add(permanentMesh);
      
      permanentTrails.push(permanentMesh);
      console.log('Trail made permanent');
    }
    
    function updateBikeTrail() {
      if (!bikeEnabled || !bikeBody || !bikeMesh || !bikeTrailMesh) return;
      
      const pos = bikeBody.translation();
      const currentPoint = new THREE.Vector3(pos.x, pos.y, pos.z);
      
      // Add point if moved enough distance
      if (bikeTrailPoints.length === 0 || 
          currentPoint.distanceTo(bikeTrailPoints[bikeTrailPoints.length - 1]) > 0.5) {
        bikeTrailPoints.push(currentPoint.clone());
        
        // Keep only last N points
        if (bikeTrailPoints.length > BIKE_TRAIL_MAX_POINTS) {
          bikeTrailPoints.shift();
        }
      }
      
      // Rebuild trail geometry
      if (bikeTrailPoints.length >= 2) {
        const trailHeight = 2.5; // Reduced from 6.0 to 2.5
        const positions = new Float32Array(bikeTrailPoints.length * 2 * 3);
        let pOff = 0;
        
        for (let i = 0; i < bikeTrailPoints.length; i++) {
          const p = bikeTrailPoints[i];
          // Bottom vertex
          positions[pOff++] = p.x;
          positions[pOff++] = p.y;
          positions[pOff++] = p.z;
          // Top vertex
          positions[pOff++] = p.x;
          positions[pOff++] = p.y + trailHeight;
          positions[pOff++] = p.z;
        }
        
        const indices = [];
        for (let i = 0; i < bikeTrailPoints.length - 1; i++) {
          const i0 = i * 2;
          const i1 = i * 2 + 1;
          const i2 = (i + 1) * 2;
          const i3 = (i + 1) * 2 + 1;
          
          indices.push(i0, i2, i1);
          indices.push(i2, i3, i1);
        }
        
        bikeTrailMesh.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        bikeTrailMesh.geometry.setIndex(indices);
        bikeTrailMesh.geometry.computeVertexNormals();
        bikeTrailMesh.visible = true;
      }
    }
    
    function sharpTurnBike(direction) {
      if (!bikeEnabled || !bikeBody || !bikeMesh) return;
      
      // Sharp 90 degree turn
      // direction: 'left' increases yaw (turn left), 'right' decreases yaw (turn right)
      if (direction === 'left') {
        yaw += Math.PI / 2;
        console.log('Bike sharp LEFT turn!');
      } else {
        yaw -= Math.PI / 2;
        console.log('Bike sharp RIGHT turn!');
      }
      
      // Finalize current trail segment
      if (bikeTrailPoints.length > 0) {
        const pos = bikeBody.translation();
        bikeTrailPoints.push(new THREE.Vector3(pos.x, pos.y, pos.z));
      }
    }
    
    function toggleBike() {
      if (!bikeBody || !bikeMesh) {
        createBike();
      }
      
      bikeEnabled = !bikeEnabled;
      bikeMesh.visible = bikeEnabled;
      player.visible = !bikeEnabled && !pointerLocked; // Hide player mesh in FPS
      
      if (bikeEnabled && playerBody && bikeBody) {
        // Transfer position from player to bike (same height, no jump)
        const playerPos = playerBody.translation();
        bikeBody.setTranslation({ x: playerPos.x, y: playerPos.y, z: playerPos.z }, true);
        bikeBody.setLinvel({ x: 0, y: 0, z: 0 }, true);
        bikeSpeed = 0;
        bikeTargetSpeed = 0;
        bikeAutoPilot = true; // Enable autopilot by default
        // Clear trail
        bikeTrailPoints = [];
        if (bikeTrailMesh) {
          bikeTrailMesh.visible = false;
        }
        console.log('Bike enabled (autopilot on)');
      } else if (!bikeEnabled && playerBody && bikeBody) {
        // Transfer position from bike to player
        const bikePos = bikeBody.translation();
        playerBody.setTranslation({ x: bikePos.x, y: bikePos.y, z: bikePos.z }, true);
        playerBody.setLinvel({ x: 0, y: 0, z: 0 }, true);
        // Make trail permanent
        makeTrailPermanent();
        // Hide current trail
        if (bikeTrailMesh) {
          bikeTrailMesh.visible = false;
        }
        console.log('Bike disabled, trail left behind');
      }
    }
    
    function updateBike(deltaTime) {
      if (!bikeEnabled || !bikeBody || !bikeMesh) return;
      
      const pos = bikeBody.translation();
      const vel = bikeBody.linvel();
      
      // Update bike mesh position
      bikeMesh.position.set(pos.x, pos.y, pos.z);
      
      // Wheelie control (S or ArrowDown)
      const wheelieInput = keys.has('KeyS') || keys.has('ArrowDown');
      
      if (wheelieInput && !bikeWallRiding) {
        // Build up wheelie
        bikeWheelieProgress = Math.min(1.0, bikeWheelieProgress + deltaTime * 1.5);
      } else if (!bikeWallRiding) {
        // Release wheelie
        bikeWheelieProgress = Math.max(0, bikeWheelieProgress - deltaTime * 2.0);
      }
      
      // Wheelie angle (max 45 degrees)
      bikeWheelieAngle = bikeWheelieProgress * (Math.PI / 4);
      
      // Enable jump when wheelie is at max
      bikeCanJump = bikeWheelieProgress >= 0.95;
      
      // Jump control (Space when wheelie is maxed)
      if (keys.has('Space') && bikeCanJump && Math.abs(vel.y) < 0.1 && !bikeWallRiding) {
        bikeBody.applyImpulse({ x: 0, y: 15, z: 0 }, true);
        keys.delete('Space');
        console.log('Bike jump!');
      }
      
      // Check for wall collision while in air
      if (bikeWheelieProgress > 0.5 && Math.abs(vel.y) > 0.1) {
        checkWallRiding(pos, vel);
      }
      
      // Wall riding physics
      if (bikeWallRiding) {
        const forward = new THREE.Vector3(
          Math.sin(yaw),
          0,
          Math.cos(yaw)
        );
        
        // Project forward onto wall surface
        const wallForward = forward.clone().sub(bikeWallNormal.clone().multiplyScalar(forward.dot(bikeWallNormal))).normalize();
        
        // Move along wall
        bikeBody.setLinvel({
          x: wallForward.x * bikeSpeed,
          y: 0, // No gravity while wall riding
          z: wallForward.z * bikeSpeed
        }, true);
        
        // Check if still near wall
        const raycast = world.castRay(
          new physics.Ray(pos, new THREE.Vector3(bikeWallNormal.x, bikeWallNormal.y, bikeWallNormal.z).negate()),
          2.0,
          true
        );
        
        if (!raycast || raycast.toi > 1.0) {
          // Left wall
          bikeWallRiding = false;
          bikeWheelieProgress = 0;
          console.log('Left wall');
        }
      } else {
        // Normal bike control
        // Autopilot mode vs manual control
        if (bikeAutoPilot) {
          // Autopilot: drive forward automatically
          bikeTargetSpeed = BIKE_MAX_SPEED * 0.8; // 80% speed on autopilot
          
          // Optional steering in autopilot (A/D still work)
          let turnAmount = 0;
          if (keys.has('KeyA')) turnAmount = 1;  // A = left (increase yaw)
          if (keys.has('KeyD')) turnAmount = -1; // D = right (decrease yaw)
          yaw += turnAmount * BIKE_TURN_RATE * deltaTime;
        } else {
          // Manual control: W for acceleration
          if (keys.has('KeyW')) {
            bikeTargetSpeed = BIKE_MAX_SPEED;
          } else {
            bikeTargetSpeed = BIKE_MAX_SPEED * 0.3; // Coast
          }
          
          // Steering (A/D)
          let turnAmount = 0;
          if (keys.has('KeyA')) turnAmount = 1;  // A = left (increase yaw)
          if (keys.has('KeyD')) turnAmount = -1; // D = right (decrease yaw)
          yaw += turnAmount * BIKE_TURN_RATE * deltaTime;
        }
        
        // Smooth acceleration
        bikeSpeed += (bikeTargetSpeed - bikeSpeed) * BIKE_ACCEL * deltaTime;
        
        // Apply forward velocity
        const forward = new THREE.Vector3(
          Math.sin(yaw),
          0,
          Math.cos(yaw)
        );
        
        bikeBody.setLinvel({
          x: forward.x * bikeSpeed,
          y: vel.y, // Preserve vertical velocity
          z: forward.z * bikeSpeed
        }, true);
      }
      
      // Update bike mesh rotation with wheelie
      bikeMesh.rotation.y = yaw;
      bikeMesh.rotation.x = -bikeWheelieAngle; // Tilt back for wheelie
      
      // Wall riding orientation
      if (bikeWallRiding) {
        // Orient bike to wall
        const wallUp = bikeWallNormal.clone();
        bikeMesh.rotation.z = Math.atan2(wallUp.x, wallUp.y);
      } else {
        bikeMesh.rotation.z = 0;
      }
      
      // Camera position (above and behind bike)
      const cameraDistance = 10;
      const cameraHeight = 4;
      const forward = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
      camera.position.set(
        pos.x - forward.x * cameraDistance,
        pos.y + cameraHeight,
        pos.z - forward.z * cameraDistance
      );
      
      // Camera look-at (ahead of bike)
      const lookAhead = 15;
      camera.lookAt(
        pos.x + forward.x * lookAhead,
        pos.y + 1,
        pos.z + forward.z * lookAhead
      );
      
      // Update trail
      updateBikeTrail();
    }
    
    function checkWallRiding(pos, vel) {
      // Cast ray in forward direction to check for walls
      const forward = new THREE.Vector3(
        Math.sin(yaw),
        0,
        Math.cos(yaw)
      );
      
      const raycast = world.castRay(
        new physics.Ray(pos, forward),
        2.0,
        true
      );
      
      if (raycast && raycast.toi < 1.5) {
        // Hit a wall, start wall riding
        bikeWallRiding = true;
        
        // Get the normal from the raycast hit
        // Rapier returns the normal in the raycast object, but we need to check if it exists
        if (raycast.normal) {
          bikeWallNormal.set(raycast.normal.x, raycast.normal.y, raycast.normal.z);
        } else {
          // Fallback: use reverse of ray direction as approximate normal
          bikeWallNormal.set(-forward.x, -forward.y, -forward.z);
        }
        
        // Adjust yaw to be parallel to wall
        const wallTangent = new THREE.Vector3(-bikeWallNormal.z, 0, bikeWallNormal.x).normalize();
        yaw = Math.atan2(wallTangent.x, wallTangent.z);
        
        console.log('Started wall riding!');
      }
    }
    
    // ==================== PATHFINDING SYSTEM ====================
    function worldToGrid(x, z) {
      return {
        x: Math.floor(x / GRID_CELL_SIZE),
        z: Math.floor(z / GRID_CELL_SIZE)
      };
    }
    
    function gridToWorld(gx, gz) {
      return {
        x: gx * GRID_CELL_SIZE + GRID_CELL_SIZE / 2,
        z: gz * GRID_CELL_SIZE + GRID_CELL_SIZE / 2
      };
    }
    
    function gridKey(gx, gz) {
      return `${gx},${gz}`;
    }
    
    function markSidewalkWalkable(x, z, width, depth) {
      // Mark grid cells as walkable for sidewalks
      const g1 = worldToGrid(x - width/2, z - depth/2);
      const g2 = worldToGrid(x + width/2, z + depth/2);
      
      for (let gx = g1.x; gx <= g2.x; gx++) {
        for (let gz = g1.z; gz <= g2.z; gz++) {
          pathGrid.set(gridKey(gx, gz), true);
        }
      }
    }
    
    function findPath(startX, startZ, endX, endZ) {
      // A* pathfinding with 90-degree turns
      const start = worldToGrid(startX, startZ);
      const end = worldToGrid(endX, endZ);
      
      const openSet = [start];
      const cameFrom = new Map();
      const gScore = new Map();
      const fScore = new Map();
      
      gScore.set(gridKey(start.x, start.z), 0);
      fScore.set(gridKey(start.x, start.z), heuristic(start, end));
      
      function heuristic(a, b) {
        // Manhattan distance for grid-based movement
        return Math.abs(a.x - b.x) + Math.abs(a.z - b.z);
      }
      
      function getNeighbors(node) {
        // Only 90-degree turns (4 directions)
        const neighbors = [];
        const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
        
        for (const [dx, dz] of dirs) {
          const nx = node.x + dx;
          const nz = node.z + dz;
          const key = gridKey(nx, nz);
          
          // Check if walkable
          if (pathGrid.has(key)) {
            neighbors.push({ x: nx, z: nz });
          }
        }
        
        return neighbors;
      }
      
      while (openSet.length > 0) {
        // Find node with lowest fScore
        let current = openSet[0];
        let currentIdx = 0;
        let lowestF = fScore.get(gridKey(current.x, current.z)) || Infinity;
        
        for (let i = 1; i < openSet.length; i++) {
          const f = fScore.get(gridKey(openSet[i].x, openSet[i].z)) || Infinity;
          if (f < lowestF) {
            lowestF = f;
            current = openSet[i];
            currentIdx = i;
          }
        }
        
        // Check if we reached the goal
        if (current.x === end.x && current.z === end.z) {
          // Reconstruct path
          const path = [];
          let temp = current;
          
          while (temp) {
            const worldPos = gridToWorld(temp.x, temp.z);
            path.unshift(new THREE.Vector3(worldPos.x, 0, worldPos.z));
            const key = gridKey(temp.x, temp.z);
            temp = cameFrom.get(key);
          }
          
          return path;
        }
        
        // Remove current from openSet
        openSet.splice(currentIdx, 1);
        
        // Check neighbors
        const neighbors = getNeighbors(current);
        const currentKey = gridKey(current.x, current.z);
        const currentG = gScore.get(currentKey) || Infinity;
        
        for (const neighbor of neighbors) {
          const neighborKey = gridKey(neighbor.x, neighbor.z);
          const tentativeG = currentG + 1;
          const neighborG = gScore.get(neighborKey) || Infinity;
          
          if (tentativeG < neighborG) {
            cameFrom.set(neighborKey, current);
            gScore.set(neighborKey, tentativeG);
            fScore.set(neighborKey, tentativeG + heuristic(neighbor, end));
            
            // Add to openSet if not already there
            if (!openSet.some(n => n.x === neighbor.x && n.z === neighbor.z)) {
              openSet.push(neighbor);
            }
          }
        }
      }
      
      // No path found, return straight line
      return [
        new THREE.Vector3(startX, 0, startZ),
        new THREE.Vector3(endX, 0, endZ)
      ];
    }
    
    // ==================== SPECIAL CONSTRUCTIONS ====================
    function createPlayground(x, z, size = 15) {
      const playgroundGroup = new THREE.Group();
      
      // Ground (rubber surface)
      const groundGeo = new THREE.BoxGeometry(size, 0.1, size);
      const groundMat = new THREE.MeshStandardMaterial({ color: 0x4A7C59, roughness: 0.9 });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.position.y = 0.05;
      ground.receiveShadow = true;
      playgroundGroup.add(ground);
      
      // Swing set
      const swingPoleGeo = new THREE.CylinderGeometry(0.1, 0.1, 3, 8);
      const metalMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.6, roughness: 0.4 });
      
      const leftPole = new THREE.Mesh(swingPoleGeo, metalMat);
      leftPole.position.set(-4, 1.5, -3);
      leftPole.castShadow = true;
      playgroundGroup.add(leftPole);
      
      const rightPole = new THREE.Mesh(swingPoleGeo, metalMat);
      rightPole.position.set(4, 1.5, -3);
      rightPole.castShadow = true;
      playgroundGroup.add(rightPole);
      
      const topBar = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 8.5, 8), metalMat);
      topBar.rotation.z = Math.PI / 2;
      topBar.position.set(0, 3, -3);
      topBar.castShadow = true;
      playgroundGroup.add(topBar);
      
      // Swings with thick chain strings
      for (let i = -1; i <= 1; i++) {
        const seatGeo = new THREE.BoxGeometry(0.4, 0.1, 0.6);
        const seatMat = new THREE.MeshStandardMaterial({ color: 0xFF6B6B });
        const seat = new THREE.Mesh(seatGeo, seatMat);
        seat.position.set(i * 2, 0.8, -3);
        seat.castShadow = true;
        playgroundGroup.add(seat);
        
        // Create thick rope/chain strings using billboard sprites
        const ropeSegments = 8;
        const ropeLength = 3 - 0.8; // from top bar to seat
        
        // Left chain
        for (let seg = 0; seg < ropeSegments; seg++) {
          const t = seg / (ropeSegments - 1);
          const yPos = 3 - t * ropeLength;
          
          // Create sprite for chain link
          const canvas = document.createElement('canvas');
          canvas.width = 64;
          canvas.height = 64;
          const ctx = canvas.getContext('2d');
          ctx.fillStyle = '#666666';
          ctx.fillRect(24, 0, 16, 64);
          ctx.fillStyle = '#888888';
          ctx.fillRect(26, 0, 12, 64);
          
          const texture = new THREE.CanvasTexture(canvas);
          const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true });
          const sprite = new THREE.Sprite(spriteMat);
          sprite.position.set(i * 2 - 0.15, yPos, -3);
          sprite.scale.set(0.15, ropeLength / ropeSegments * 1.2, 1);
          playgroundGroup.add(sprite);
        }
        
        // Right chain
        for (let seg = 0; seg < ropeSegments; seg++) {
          const t = seg / (ropeSegments - 1);
          const yPos = 3 - t * ropeLength;
          
          const canvas = document.createElement('canvas');
          canvas.width = 64;
          canvas.height = 64;
          const ctx = canvas.getContext('2d');
          ctx.fillStyle = '#666666';
          ctx.fillRect(24, 0, 16, 64);
          ctx.fillStyle = '#888888';
          ctx.fillRect(26, 0, 12, 64);
          
          const texture = new THREE.CanvasTexture(canvas);
          const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true });
          const sprite = new THREE.Sprite(spriteMat);
          sprite.position.set(i * 2 + 0.15, yPos, -3);
          sprite.scale.set(0.15, ropeLength / ropeSegments * 1.2, 1);
          playgroundGroup.add(sprite);
        }
      }
      
      // Slide
      const slidePlatform = new THREE.Mesh(new THREE.BoxGeometry(2, 0.2, 2), metalMat);
      slidePlatform.position.set(-3, 2, 3);
      slidePlatform.castShadow = true;
      playgroundGroup.add(slidePlatform);
      
      const slideRamp = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.1, 4), new THREE.MeshStandardMaterial({ color: 0xFFCC00, metalness: 0.5 }));
      slideRamp.position.set(-3, 1, 1);
      slideRamp.rotation.x = -Math.PI / 6;
      slideRamp.castShadow = true;
      playgroundGroup.add(slideRamp);
      
      // Enhanced Monkey bars with side supports
      const monkeyBarWidth = 3;
      const monkeyBarHeight = 2.2;
      
      // Left support
      const leftSupport = new THREE.Mesh(swingPoleGeo, metalMat);
      leftSupport.position.set(-1.5, monkeyBarHeight / 2, 3);
      leftSupport.scale.y = monkeyBarHeight / 3;
      leftSupport.castShadow = true;
      playgroundGroup.add(leftSupport);
      
      // Right support
      const rightSupport = new THREE.Mesh(swingPoleGeo, metalMat);
      rightSupport.position.set(1.5, monkeyBarHeight / 2, 3);
      rightSupport.scale.y = monkeyBarHeight / 2;
      rightSupport.castShadow = true;
      playgroundGroup.add(rightSupport);
      
      // Horizontal bars
      for (let i = 0; i < 8; i++) {
        const bar = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, monkeyBarWidth, 8), metalMat);
        bar.rotation.z = Math.PI / 2;
        bar.position.set(0, monkeyBarHeight, 3 + i * 0.4 - 1.4);
        bar.castShadow = true;
        playgroundGroup.add(bar);
      }
      
      // Spinning merry-go-round
      const spinnerRadius = 1.5;
      const spinnerHeight = 0.15;
      
      // Base pole
      const spinnerPole = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 1.5, 12), metalMat);
      spinnerPole.position.set(4, 0.75, 3);
      spinnerPole.castShadow = true;
      playgroundGroup.add(spinnerPole);
      
      // Rotating platform
      const spinnerGroup = new THREE.Group();
      const platformGeo = new THREE.CylinderGeometry(spinnerRadius, spinnerRadius, spinnerHeight, 16);
      const platformMat = new THREE.MeshStandardMaterial({ color: 0x4488FF, metalness: 0.4, roughness: 0.6 });
      const platform = new THREE.Mesh(platformGeo, platformMat);
      platform.castShadow = true;
      spinnerGroup.add(platform);
      
      // Handle bars
      for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2;
        const handleGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.8, 8);
        const handle = new THREE.Mesh(handleGeo, metalMat);
        handle.position.set(
          Math.cos(angle) * spinnerRadius * 0.7,
          0.5,
          Math.sin(angle) * spinnerRadius * 0.7
        );
        handle.castShadow = true;
        spinnerGroup.add(handle);
      }
      
      spinnerGroup.position.set(4, 1.5, 3);
      spinnerGroup.userData.isSpinner = true;
      spinnerGroup.userData.spinSpeed = 0.5; // radians per second
      playgroundGroup.add(spinnerGroup);
      playgroundGroup.userData.spinner = spinnerGroup;
      
      // Sandbox with deformed sand
      const sandboxSize = 3;
      const sandboxWallHeight = 0.3;
      const sandboxWallThickness = 0.15;
      
      // Sandbox walls (wooden frame)
      const woodMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 });
      
      // Front wall
      const frontWall = new THREE.Mesh(
        new THREE.BoxGeometry(sandboxSize + sandboxWallThickness * 2, sandboxWallHeight, sandboxWallThickness),
        woodMat
      );
      frontWall.position.set(4, sandboxWallHeight / 2, -3 - sandboxSize / 2);
      frontWall.castShadow = true;
      playgroundGroup.add(frontWall);
      
      // Back wall
      const backWall = new THREE.Mesh(
        new THREE.BoxGeometry(sandboxSize + sandboxWallThickness * 2, sandboxWallHeight, sandboxWallThickness),
        woodMat
      );
      backWall.position.set(4, sandboxWallHeight / 2, -3 + sandboxSize / 2);
      backWall.castShadow = true;
      playgroundGroup.add(backWall);
      
      // Left wall
      const leftWall = new THREE.Mesh(
        new THREE.BoxGeometry(sandboxWallThickness, sandboxWallHeight, sandboxSize),
        woodMat
      );
      leftWall.position.set(4 - sandboxSize / 2, sandboxWallHeight / 2, -3);
      leftWall.castShadow = true;
      playgroundGroup.add(leftWall);
      
      // Right wall
      const rightWall = new THREE.Mesh(
        new THREE.BoxGeometry(sandboxWallThickness, sandboxWallHeight, sandboxSize),
        woodMat
      );
      rightWall.position.set(4 + sandboxSize / 2, sandboxWallHeight / 2, -3);
      rightWall.castShadow = true;
      playgroundGroup.add(rightWall);
      
      // Deformed sand mesh with hills
      const sandResolution = 20;
      const sandGeo = new THREE.PlaneGeometry(sandboxSize, sandboxSize, sandResolution, sandResolution);
      const sandMat = new THREE.MeshStandardMaterial({ color: 0xDDC894, roughness: 0.95 });
      
      // Deform vertices to create hills
      const positions = sandGeo.attributes.position;
      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const z = positions.getY(i); // Y in plane geometry becomes Z in 3D
        
        // Create hills using sine waves
        const hill1 = Math.sin(x * 3) * Math.cos(z * 3) * 0.08;
        const hill2 = Math.sin(x * 5 + 1) * Math.cos(z * 4 + 2) * 0.05;
        const hill3 = Math.sin(x * 2.5 + 2) * Math.cos(z * 2.5 + 1) * 0.06;
        
        positions.setZ(i, hill1 + hill2 + hill3);
      }
      positions.needsUpdate = true;
      sandGeo.computeVertexNormals();
      
      const sand = new THREE.Mesh(sandGeo, sandMat);
      sand.rotation.x = -Math.PI / 2;
      sand.position.set(4, 0.12, -3);
      sand.receiveShadow = true;
      playgroundGroup.add(sand);
      
      // Pail (bucket)
      const pailGeo = new THREE.CylinderGeometry(0.15, 0.12, 0.25, 12);
      const pailMat = new THREE.MeshStandardMaterial({ color: 0xFF4444, metalness: 0.2, roughness: 0.6 });
      const pail = new THREE.Mesh(pailGeo, pailMat);
      pail.position.set(4.5, 0.25, -2.5);
      pail.rotation.z = 0.2;
      pail.castShadow = true;
      playgroundGroup.add(pail);
      
      // Pail handle
      const handleCurve = new THREE.EllipseCurve(0, 0, 0.15, 0.2, 0, Math.PI, false, 0);
      const handlePoints = handleCurve.getPoints(16);
      const handleGeo = new THREE.TubeGeometry(
        new THREE.CatmullRomCurve3(handlePoints.map(p => new THREE.Vector3(p.x, p.y, 0))),
        16, 0.015, 6, false
      );
      const handleMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.6 });
      const handle = new THREE.Mesh(handleGeo, handleMat);
      handle.position.copy(pail.position);
      handle.position.y += 0.2;
      handle.rotation.copy(pail.rotation);
      playgroundGroup.add(handle);
      
      // Shovel
      const shovelHandleGeo = new THREE.CylinderGeometry(0.015, 0.015, 0.5, 6);
      const shovelHandleMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
      const shovelHandle = new THREE.Mesh(shovelHandleGeo, shovelHandleMat);
      shovelHandle.position.set(3.5, 0.15, -2.7);
      shovelHandle.rotation.z = Math.PI / 6;
      shovelHandle.castShadow = true;
      playgroundGroup.add(shovelHandle);
      
      // Shovel blade
      const shovelBladeGeo = new THREE.BoxGeometry(0.12, 0.15, 0.02);
      const shovelBladeMat = new THREE.MeshStandardMaterial({ color: 0x4444FF, metalness: 0.6 });
      const shovelBlade = new THREE.Mesh(shovelBladeGeo, shovelBladeMat);
      shovelBlade.position.set(3.3, 0.08, -2.65);
      shovelBlade.rotation.z = Math.PI / 6;
      shovelBlade.rotation.y = 0.1;
      shovelBlade.castShadow = true;
      playgroundGroup.add(shovelBlade);
      
      playgroundGroup.position.set(x, 0, z);
      playgroundGroup.userData.isAtomic = true;
      playgroundGroup.userData.pickable = true;
      playgroundGroup.userData.objectType = 'playground';
      
      return playgroundGroup;
    }
    
    function createParkingLot(x, z, width = 20, depth = 20) {
      const parkingGroup = new THREE.Group();
      
      // Asphalt ground
      const groundGeo = new THREE.BoxGeometry(width, 0.1, depth);
      const asphaltMat = new THREE.MeshStandardMaterial({ color: 0x2A2A2A, roughness: 0.95 });
      const ground = new THREE.Mesh(groundGeo, asphaltMat);
      ground.position.y = 0.05;
      ground.receiveShadow = true;
      parkingGroup.add(ground);
      
      // Parking lines (white stripes)
      const lineGeo = new THREE.PlaneGeometry(0.2, 5);
      const lineMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, side: THREE.DoubleSide });
      
      const spotsPerRow = Math.floor(width / 3);
      const rows = Math.floor(depth / 6);
      
      for (let row = 0; row < rows; row++) {
        for (let spot = 0; spot < spotsPerRow; spot++) {
          const line = new THREE.Mesh(lineGeo, lineMat);
          line.rotation.x = -Math.PI / 2;
          line.position.set(
            spot * 3 - width / 2 + 1.5,
            0.11,
            row * 6 - depth / 2 + 3
          );
          parkingGroup.add(line);
        }
      }
      
      // Spawn cars in parking lot - reduced for performance
      const carCount = Math.floor((spotsPerRow * rows) * 0.4); // 40% full
      for (let i = 0; i < carCount; i++) {
        const row = Math.floor(Math.random() * rows);
        const spot = Math.floor(Math.random() * spotsPerRow);
        const car = createCar();
        car.position.set(
          spot * 3 - width / 2 + 1.5,
          0,
          row * 6 - depth / 2 + 3
        );
        car.rotation.y = Math.random() > 0.5 ? 0 : Math.PI;
        parkingGroup.add(car);
      }
      
      parkingGroup.position.set(x, 0, z);
      parkingGroup.userData.isAtomic = true;
      parkingGroup.userData.pickable = true;
      parkingGroup.userData.objectType = 'parkingLot';
      
      return parkingGroup;
    }
    
    function createCar() {
      const carGroup = new THREE.Group();
      
      const colors = [0xFF0000, 0x0000FF, 0x00FF00, 0xFFFF00, 0xFF00FF, 0x00FFFF, 0xFFFFFF, 0x000000, 0x888888];
      const carColor = colors[Math.floor(Math.random() * colors.length)];
      
      // Body
      const bodyGeo = new THREE.BoxGeometry(1.8, 0.6, 4);
      const bodyMat = new THREE.MeshStandardMaterial({ color: carColor, metalness: 0.7, roughness: 0.3 });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = 0.5;
      body.castShadow = true;
      carGroup.add(body);
      
      // Cabin
      const cabinGeo = new THREE.BoxGeometry(1.6, 0.5, 2);
      const cabinMat = new THREE.MeshStandardMaterial({ color: carColor, metalness: 0.6, roughness: 0.4 });
      const cabin = new THREE.Mesh(cabinGeo, cabinMat);
      cabin.position.y = 1.05;
      cabin.position.z = -0.2;
      cabin.castShadow = true;
      carGroup.add(cabin);
      
      // Windows
      const windowGeo = new THREE.BoxGeometry(1.5, 0.4, 0.8);
      const windowMat = new THREE.MeshStandardMaterial({ color: 0x88CCFF, transparent: true, opacity: 0.6, metalness: 0.8 });
      
      const frontWindow = new THREE.Mesh(windowGeo, windowMat);
      frontWindow.position.set(0, 1.05, 0.6);
      carGroup.add(frontWindow);
      
      const backWindow = new THREE.Mesh(windowGeo, windowMat);
      backWindow.position.set(0, 1.05, -1);
      carGroup.add(backWindow);
      
      // Wheels
      const wheelGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 12);
      const wheelMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
      
      const wheels = [
        [-0.9, 0.3, 1.2],
        [0.9, 0.3, 1.2],
        [-0.9, 0.3, -1.2],
        [0.9, 0.3, -1.2]
      ];
      
      wheels.forEach(([x, y, z]) => {
        const wheel = new THREE.Mesh(wheelGeo, wheelMat);
        wheel.rotation.z = Math.PI / 2;
        wheel.position.set(x, y, z);
        wheel.castShadow = true;
        carGroup.add(wheel);
      });
      
      carGroup.userData.isAtomic = true;
      carGroup.userData.pickable = true;
      carGroup.userData.objectType = 'car';
      
      return carGroup;
    }
    
    function createParkingGarage(x, z, width = 25, depth = 25, levels = 4) {
      const garageGroup = new THREE.Group();
      
      const levelHeight = 3;
      const structureColor = 0x6A6A6A;
      
      // Columns
      const columnGeo = new THREE.BoxGeometry(0.5, levelHeight * levels, 0.5);
      const columnMat = new THREE.MeshStandardMaterial({ color: structureColor, roughness: 0.8 });
      
      const columnPositions = [
        [-width/2 + 2, 0, -depth/2 + 2],
        [width/2 - 2, 0, -depth/2 + 2],
        [-width/2 + 2, 0, depth/2 - 2],
        [width/2 - 2, 0, depth/2 - 2],
        [0, 0, -depth/2 + 2],
        [0, 0, depth/2 - 2],
        [-width/2 + 2, 0, 0],
        [width/2 - 2, 0, 0]
      ];
      
      columnPositions.forEach(([cx, cy, cz]) => {
        const column = new THREE.Mesh(columnGeo, columnMat);
        column.position.set(cx, (levelHeight * levels) / 2, cz);
        column.castShadow = true;
        column.receiveShadow = true;
        garageGroup.add(column);
      });
      
      // Floors for each level
      for (let level = 0; level < levels; level++) {
        const floorY = level * levelHeight;
        
        // Floor slab
        const floorGeo = new THREE.BoxGeometry(width, 0.3, depth);
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x4A4A4A, roughness: 0.9 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.position.y = floorY;
        floor.receiveShadow = true;
        floor.castShadow = true;
        garageGroup.add(floor);
        
        // Railing
        const railGeo = new THREE.BoxGeometry(width, 0.1, 0.1);
        const railMat = new THREE.MeshStandardMaterial({ color: 0xCCCCCC, metalness: 0.5 });
        
        // Front and back rails
        const frontRail = new THREE.Mesh(railGeo, railMat);
        frontRail.position.set(0, floorY + 1, depth/2);
        garageGroup.add(frontRail);
        
        const backRail = new THREE.Mesh(railGeo, railMat);
        backRail.position.set(0, floorY + 1, -depth/2);
        garageGroup.add(backRail);
        
        // Side rails
        const sideRailGeo = new THREE.BoxGeometry(0.1, 0.1, depth);
        const leftRail = new THREE.Mesh(sideRailGeo, railMat);
        leftRail.position.set(-width/2, floorY + 1, 0);
        garageGroup.add(leftRail);
        
        const rightRail = new THREE.Mesh(sideRailGeo, railMat);
        rightRail.position.set(width/2, floorY + 1, 0);
        garageGroup.add(rightRail);
        
        // Add cars on each level - reduced for performance
        const carsPerLevel = 4 + Math.floor(Math.random() * 3); // 4-6 cars per level
        for (let c = 0; c < carsPerLevel; c++) {
          const car = createCar();
          car.position.set(
            (Math.random() - 0.5) * (width - 4),
            floorY + 0.15,
            (Math.random() - 0.5) * (depth - 4)
          );
          car.rotation.y = Math.random() * Math.PI * 2;
          garageGroup.add(car);
        }
      }
      
      // Roof
      const roofGeo = new THREE.BoxGeometry(width, 0.4, depth);
      const roofMat = new THREE.MeshStandardMaterial({ color: 0x3A3A3A });
      const roof = new THREE.Mesh(roofGeo, roofMat);
      roof.position.y = levels * levelHeight + 0.2;
      roof.castShadow = true;
      garageGroup.add(roof);
      
      garageGroup.position.set(x, 0, z);
      garageGroup.userData.isAtomic = true;
      garageGroup.userData.pickable = true;
      garageGroup.userData.objectType = 'parkingGarage';
      garageGroup.userData.levels = levels;
      
      return garageGroup;
    }
    
    function createHospitalBuilding(x, z, width = 30, depth = 30, height = 25) {
      const hospitalGroup = new THREE.Group();
      
      // Main building
      const buildingGeo = new THREE.BoxGeometry(width, height, depth);
      const buildingMat = new THREE.MeshStandardMaterial({ color: 0xE8E8E8, roughness: 0.7 });
      const building = new THREE.Mesh(buildingGeo, buildingMat);
      building.position.y = height / 2;
      building.castShadow = true;
      building.receiveShadow = true;
      hospitalGroup.add(building);
      
      // Red cross on front
      const crossVertical = new THREE.Mesh(
        new THREE.BoxGeometry(2, 6, 0.1),
        new THREE.MeshBasicMaterial({ color: 0xFF0000 })
      );
      crossVertical.position.set(0, height * 0.7, depth/2 + 0.1);
      hospitalGroup.add(crossVertical);
      
      const crossHorizontal = new THREE.Mesh(
        new THREE.BoxGeometry(6, 2, 0.1),
        new THREE.MeshBasicMaterial({ color: 0xFF0000 })
      );
      crossHorizontal.position.set(0, height * 0.7, depth/2 + 0.1);
      hospitalGroup.add(crossHorizontal);
      
      // Windows (grid pattern)
      const windowGeo = new THREE.PlaneGeometry(1.2, 1.5);
      const windowMat = new THREE.MeshStandardMaterial({ 
        color: 0x88CCFF, 
        emissive: 0x4488FF,
        emissiveIntensity: 0.3,
        transparent: true,
        opacity: 0.8
      });
      
      const floors = Math.floor(height / 3.5);
      const windowsPerRow = Math.floor(width / 3);
      
      for (let floor = 0; floor < floors; floor++) {
        for (let w = 0; w < windowsPerRow; w++) {
          const window = new THREE.Mesh(windowGeo, windowMat);
          window.position.set(
            w * 3 - width/2 + 1.5,
            floor * 3.5 + 2,
            depth/2 + 0.05
          );
          hospitalGroup.add(window);
        }
      }
      
      // Emergency entrance
      const entranceGeo = new THREE.BoxGeometry(5, 4, 0.5);
      const entranceMat = new THREE.MeshStandardMaterial({ color: 0xFF6B6B });
      const entrance = new THREE.Mesh(entranceGeo, entranceMat);
      entrance.position.set(-width/3, 2, depth/2 + 0.3);
      hospitalGroup.add(entrance);
      
      // "EMERGENCY" sign
      const signGeo = new THREE.PlaneGeometry(4, 0.8);
      const signMat = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
      const sign = new THREE.Mesh(signGeo, signMat);
      sign.position.set(-width/3, 4.5, depth/2 + 0.6);
      hospitalGroup.add(sign);
      
      hospitalGroup.position.set(x, 0, z);
      hospitalGroup.userData.isAtomic = true;
      hospitalGroup.userData.pickable = true;
      hospitalGroup.userData.objectType = 'hospital';
      
      return hospitalGroup;
    }
    
    function createSchoolBuilding(x, z, width = 35, depth = 35, height = 15) {
      const schoolGroup = new THREE.Group();
      
      // Main building
      const buildingGeo = new THREE.BoxGeometry(width, height, depth);
      const buildingMat = new THREE.MeshStandardMaterial({ color: 0xD4A574, roughness: 0.7 }); // Brick color
      const building = new THREE.Mesh(buildingGeo, buildingMat);
      building.position.y = height / 2;
      building.castShadow = true;
      building.receiveShadow = true;
      schoolGroup.add(building);
      
      // Roof (gabled style)
      const roofGeo = new THREE.ConeGeometry(width * 0.7, 4, 4);
      const roofMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 });
      const roof = new THREE.Mesh(roofGeo, roofMat);
      roof.position.y = height + 2;
      roof.rotation.y = Math.PI / 4; // Diamond shape
      roof.castShadow = true;
      schoolGroup.add(roof);
      
      // Large windows (classroom style)
      const windowGeo = new THREE.PlaneGeometry(2.5, 2);
      const windowMat = new THREE.MeshStandardMaterial({ 
        color: 0x88CCFF, 
        emissive: 0x4488FF,
        emissiveIntensity: 0.2,
        transparent: true,
        opacity: 0.7
      });
      
      const floors = Math.floor(height / 5);
      const windowsPerRow = Math.floor(width / 5);
      
      for (let floor = 0; floor < floors; floor++) {
        for (let w = 0; w < windowsPerRow; w++) {
          const window = new THREE.Mesh(windowGeo, windowMat);
          window.position.set(
            w * 5 - width/2 + 2.5,
            floor * 5 + 3,
            depth/2 + 0.05
          );
          schoolGroup.add(window);
        }
      }
      
      // Flagpole
      const poleGeo = new THREE.CylinderGeometry(0.1, 0.1, 12, 8);
      const poleMat = new THREE.MeshStandardMaterial({ color: 0xC0C0C0, metalness: 0.6 });
      const pole = new THREE.Mesh(poleGeo, poleMat);
      pole.position.set(-width/2 - 3, 6, depth/2 - 5);
      pole.castShadow = true;
      schoolGroup.add(pole);
      
      // Flag
      const flagGeo = new THREE.PlaneGeometry(2, 1.3);
      const flagMat = new THREE.MeshBasicMaterial({ color: 0xFF0000, side: THREE.DoubleSide });
      const flag = new THREE.Mesh(flagGeo, flagMat);
      flag.position.set(-width/2 - 3, 11, depth/2 - 5);
      schoolGroup.add(flag);
      
      // Main entrance
      const entranceGeo = new THREE.BoxGeometry(6, 5, 0.5);
      const entranceMat = new THREE.MeshStandardMaterial({ color: 0x6B4423 });
      const entrance = new THREE.Mesh(entranceGeo, entranceMat);
      entrance.position.set(0, 2.5, depth/2 + 0.3);
      schoolGroup.add(entrance);
      
      // "SCHOOL" text sign
      const signGeo = new THREE.PlaneGeometry(5, 1);
      const signMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
      const sign = new THREE.Mesh(signGeo, signMat);
      sign.position.set(0, height - 2, depth/2 + 0.1);
      schoolGroup.add(sign);
      
      schoolGroup.position.set(x, 0, z);
      schoolGroup.userData.isAtomic = true;
      schoolGroup.userData.pickable = true;
      schoolGroup.userData.objectType = 'school';
      schoolGroup.userData.isSpecialBuilding = true;
      
      // Assign unique ID for map system
      const buildingId = nextBuildingId++;
      schoolGroup.userData.id = buildingId;
      schoolGroup.userData.width = width;
      schoolGroup.userData.depth = depth;
      schoolGroup.userData.height = height + 6; // Include roof
      
      return schoolGroup;
    }
    
    function createPoliceStation(x, z, width = 30, depth = 30, height = 18) {
      const policeGroup = new THREE.Group();
      
      // Main building
      const buildingGeo = new THREE.BoxGeometry(width, height, depth);
      const buildingMat = new THREE.MeshStandardMaterial({ color: 0x4A5A6A, roughness: 0.6 }); // Dark blue-grey
      const building = new THREE.Mesh(buildingGeo, buildingMat);
      building.position.y = height / 2;
      building.castShadow = true;
      building.receiveShadow = true;
      policeGroup.add(building);
      
      // Blue stripe across building
      const stripeGeo = new THREE.BoxGeometry(width + 0.2, 1.5, 0.1);
      const stripeMat = new THREE.MeshBasicMaterial({ color: 0x0044AA });
      const stripe = new THREE.Mesh(stripeGeo, stripeMat);
      stripe.position.set(0, height * 0.6, depth/2 + 0.1);
      policeGroup.add(stripe);
      
      // Police badge emblem (star shape approximation)
      const badgeGeo = new THREE.CylinderGeometry(1.5, 1.5, 0.2, 5);
      const badgeMat = new THREE.MeshStandardMaterial({ 
        color: 0xFFD700, 
        metalness: 0.8,
        roughness: 0.2,
        emissive: 0xFFD700,
        emissiveIntensity: 0.3
      });
      const badge = new THREE.Mesh(badgeGeo, badgeMat);
      badge.position.set(0, height * 0.75, depth/2 + 0.2);
      badge.rotation.x = Math.PI / 2;
      policeGroup.add(badge);
      
      // Windows
      const windowGeo = new THREE.PlaneGeometry(1.5, 1.8);
      const windowMat = new THREE.MeshStandardMaterial({ 
        color: 0x6688AA, 
        emissive: 0x334455,
        emissiveIntensity: 0.2,
        transparent: true,
        opacity: 0.7
      });
      
      const floors = Math.floor(height / 4);
      const windowsPerRow = Math.floor(width / 4);
      
      for (let floor = 0; floor < floors; floor++) {
        for (let w = 0; w < windowsPerRow; w++) {
          const window = new THREE.Mesh(windowGeo, windowMat);
          window.position.set(
            w * 4 - width/2 + 2,
            floor * 4 + 2.5,
            depth/2 + 0.05
          );
          policeGroup.add(window);
        }
      }
      
      // Rotating police light on roof
      const lightBaseGeo = new THREE.CylinderGeometry(0.8, 1, 0.5, 8);
      const lightBaseMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
      const lightBase = new THREE.Mesh(lightBaseGeo, lightBaseMat);
      lightBase.position.y = height + 0.25;
      policeGroup.add(lightBase);
      
      const lightGeo = new THREE.CylinderGeometry(0.6, 0.8, 0.8, 8);
      const lightMat = new THREE.MeshBasicMaterial({ 
        color: 0xFF0000,
        emissive: 0xFF0000,
        emissiveIntensity: 1.0
      });
      const light = new THREE.Mesh(lightGeo, lightMat);
      light.position.y = height + 0.9;
      light.userData.isPoliceLight = true; // Mark for animation
      policeGroup.add(light);
      policeGroup.userData.policeLight = light; // Store reference for rotation
      
      // Main entrance
      const entranceGeo = new THREE.BoxGeometry(5, 4, 0.5);
      const entranceMat = new THREE.MeshStandardMaterial({ color: 0x2A3A4A });
      const entrance = new THREE.Mesh(entranceGeo, entranceMat);
      entrance.position.set(0, 2, depth/2 + 0.3);
      policeGroup.add(entrance);
      
      // "POLICE" text sign
      const signGeo = new THREE.PlaneGeometry(4, 0.8);
      const signMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
      const sign = new THREE.Mesh(signGeo, signMat);
      sign.position.set(0, 4.5, depth/2 + 0.6);
      policeGroup.add(sign);
      
      policeGroup.position.set(x, 0, z);
      policeGroup.userData.isAtomic = true;
      policeGroup.userData.pickable = true;
      policeGroup.userData.objectType = 'policeStation';
      policeGroup.userData.isSpecialBuilding = true;
      
      // Assign unique ID for map system
      const buildingId = nextBuildingId++;
      policeGroup.userData.id = buildingId;
      policeGroup.userData.width = width;
      policeGroup.userData.depth = depth;
      policeGroup.userData.height = height + 2; // Include light on roof
      
      return policeGroup;
    }
    
    // ==================== DOOR & SIDEWALK INTEGRATION ====================
    function ensureBuildingHasDoor(buildingMesh, buildingPos, buildingWidth, buildingDepth) {
      // Find nearest sidewalk edge (simplified - assumes grid layout)
      // Doors should face outward toward nearest sidewalk
      
      // Determine which side is closest to a sidewalk (assuming grid layout)
      const gridX = Math.round(buildingPos.x / 60); // Assuming 60m blocks
      const gridZ = Math.round(buildingPos.z / 60);
      
      // Simple heuristic: door faces the nearest cardinal direction
      const offsetX = buildingPos.x - (gridX * 60);
      const offsetZ = buildingPos.z - (gridZ * 60);
      
      let doorSide = 'front'; // +Z
      let doorX = 0;
      let doorZ = buildingDepth / 2;
      let doorRotation = 0;
      
      if (Math.abs(offsetX) > Math.abs(offsetZ)) {
        // Door on X axis
        if (offsetX > 0) {
          doorSide = 'right';
          doorX = buildingWidth / 2;
          doorZ = 0;
          doorRotation = Math.PI / 2;
        } else {
          doorSide = 'left';
          doorX = -buildingWidth / 2;
          doorZ = 0;
          doorRotation = -Math.PI / 2;
        }
      } else {
        // Door on Z axis
        if (offsetZ > 0) {
          doorSide = 'front';
          doorX = 0;
          doorZ = buildingDepth / 2;
          doorRotation = 0;
        } else {
          doorSide = 'back';
          doorX = 0;
          doorZ = -buildingDepth / 2;
          doorRotation = Math.PI;
        }
      }
      
      // Create door mesh (simple for now)
      const doorWidth = 2;
      const doorHeight = 3;
      const doorGeo = new THREE.BoxGeometry(doorWidth, doorHeight, 0.2);
      const doorMat = new THREE.MeshStandardMaterial({ 
        color: 0x3a2a1a,
        metalness: 0.3,
        roughness: 0.8
      });
      const door = new THREE.Mesh(doorGeo, doorMat);
      door.position.set(
        buildingPos.x + doorX,
        doorHeight / 2,
        buildingPos.z + doorZ
      );
      door.rotation.y = doorRotation;
      door.castShadow = true;
      
      if (worldRoot) {
        worldRoot.add(door);
      } else {
        scene.add(door);
      }
      
      // Mark walkable path to door
      markSidewalkWalkable(
        buildingPos.x + doorX,
        buildingPos.z + doorZ,
        4, 4
      );
      
      return door;
    }
    
    function initializeSidewalkGrid() {
      // Create basic sidewalk grid (simplified - marks perimeter of blocks as walkable)
      const blockSize = 60;
      const citySize = 6; // 6x6 blocks
      
      for (let bx = -citySize; bx <= citySize; bx++) {
        for (let bz = -citySize; bz <= citySize; bz++) {
          const centerX = bx * blockSize;
          const centerZ = bz * blockSize;
          
          // Mark perimeter as sidewalk (3m wide)
          // North side
          markSidewalkWalkable(centerX, centerZ + blockSize/2, blockSize, 3);
          // South side
          markSidewalkWalkable(centerX, centerZ - blockSize/2, blockSize, 3);
          // East side
          markSidewalkWalkable(centerX + blockSize/2, centerZ, 3, blockSize);
          // West side
          markSidewalkWalkable(centerX - blockSize/2, centerZ, 3, blockSize);
        }
      }
      
      console.log(`Initialized pathfinding grid with ${pathGrid.size} walkable cells`);
    }
    
    // ==================== CHARACTER & BUILDING DATA ====================
    function generateBuildingData(buildingMesh, blockX, blockZ) {
      const types = buildingTypes;
      const type = types[Math.floor(Math.random() * types.length)];
      const names = buildingNames[type];
      const name = names[Math.floor(Math.random() * names.length)] + ' #' + Math.floor(Math.random() * 100);
      
      const data = {
        type,
        name,
        blockX,
        blockZ,
        position: buildingMesh.position.clone(),
        residents: [], // For apartments
        workers: []    // For workplaces
      };
      
      buildingDatabase.set(buildingMesh, data);
      return data;
    }
    
    function generateCharacterData(isFemale, isChild, chunkKey) {
      const id = 'ped_' + Math.random().toString(36).substr(2, 9);
      const firstName = isFemale ? 
        firstNamesFemale[Math.floor(Math.random() * firstNamesFemale.length)] :
        firstNamesMale[Math.floor(Math.random() * firstNamesMale.length)];
      const lastName = lastNames[Math.floor(Math.random() * lastNames.length)];
      const occupation = isChild ? 'Student' : occupations[Math.floor(Math.random() * occupations.length)];
      
      // Shirt colors - three primary colors
      const shirtColors = [0xE53935, 0x1E88E5, 0x43A047]; // Red, Blue, Green
      const shirtColor = shirtColors[Math.floor(Math.random() * shirtColors.length)];
      
      const data = {
        id,
        firstName,
        lastName,
        fullName: `${firstName} ${lastName}`,
        isFemale,
        isChild,
        age: isChild ? (6 + Math.floor(Math.random() * 12)) : (18 + Math.floor(Math.random() * 50)),
        occupation,
        shirtColor,
        hairColor: isFemale ? (Math.random() > 0.5 ? 'blonde' : 'brunette') : null,
        hairstyle: isFemale ? (Math.random() > 0.5 ? 'bob' : 'ponytail') : null,
        chunkKey,
        spouseId: null,
        homeBuilding: null,
        workBuilding: null,
        routine: [],
        currentActivity: null,
        activityProgress: 0
      };
      
      pedestrianDatabase.set(id, data);
      return data;
    }
    
    function generateMarriages() {
      // NYC same-gender marriage rate ~2-3% of population
      const pedestrianList = Array.from(pedestrianDatabase.values()).filter(p => !p.isChild && !p.spouseId);
      const marriageRate = 0.6; // 60% of adults are married
      const sameGenderRate = 0.03; // 3% same-gender marriages
      
      // Shuffle list
      for (let i = pedestrianList.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [pedestrianList[i], pedestrianList[j]] = [pedestrianList[j], pedestrianList[i]];
      }
      
      let i = 0;
      while (i < pedestrianList.length - 1 && Math.random() < marriageRate) {
        const person1 = pedestrianList[i];
        const person2 = pedestrianList[i + 1];
        
        // Decide if same-gender or opposite-gender
        const isSameGender = Math.random() < sameGenderRate;
        
        if (isSameGender) {
          // Find another person of same gender
          const sameGenderCandidates = pedestrianList.slice(i + 1).filter(p => 
            p.isFemale === person1.isFemale && !p.spouseId
          );
          
          if (sameGenderCandidates.length > 0) {
            const spouse = sameGenderCandidates[0];
            person1.spouseId = spouse.id;
            spouse.spouseId = person1.id;
            console.log(`Married (same-gender): ${person1.fullName} & ${spouse.fullName}`);
          }
        } else {
          // Opposite gender
          const oppositeGenderCandidates = pedestrianList.slice(i + 1).filter(p => 
            p.isFemale !== person1.isFemale && !p.spouseId
          );
          
          if (oppositeGenderCandidates.length > 0) {
            const spouse = oppositeGenderCandidates[0];
            person1.spouseId = spouse.id;
            spouse.spouseId = person1.id;
            console.log(`Married: ${person1.fullName} & ${spouse.fullName}`);
          }
        }
        
        i += 2;
      }
    }
    
    function assignHomesAndWorkplaces() {
      const buildingList = Array.from(buildingDatabase.values());
      const apartments = buildingList.filter(b => b.type === 'Apartment');
      const workplaces = buildingList.filter(b => b.type !== 'Apartment');
      
      pedestrianDatabase.forEach(char => {
        // Assign home
        if (apartments.length > 0) {
          const home = apartments[Math.floor(Math.random() * apartments.length)];
          char.homeBuilding = home;
          home.residents.push(char.id);
        }
        
        // Assign workplace (not for children)
        if (!char.isChild && workplaces.length > 0) {
          const work = workplaces[Math.floor(Math.random() * workplaces.length)];
          char.workBuilding = work;
          work.workers.push(char.id);
        }
      });
    }
    
    function generateDailyRoutine(charData) {
      // 10-minute day: 0-600 seconds
      // Morning (0-150s): Wake up, get ready
      // Work (150-450s): At workplace
      // Evening (450-600s): Home, socialize
      
      const routine = [];
      
      if (charData.isChild) {
        // Children: home -> school -> home
        routine.push({ activity: 'home', start: 0, end: 150, location: charData.homeBuilding });
        routine.push({ activity: 'school', start: 150, end: 450, location: charData.workBuilding });
        routine.push({ activity: 'home', start: 450, end: 600, location: charData.homeBuilding });
      } else {
        // Adults: home -> work -> optional socialize -> home
        routine.push({ activity: 'home', start: 0, end: 150, location: charData.homeBuilding });
        routine.push({ activity: 'work', start: 150, end: 420, location: charData.workBuilding });
        
        // 30% chance to socialize with spouse or friend
        if (Math.random() < 0.3 && charData.spouseId) {
          const spouseData = pedestrianDatabase.get(charData.spouseId);
          if (spouseData && spouseData.homeBuilding) {
            routine.push({ activity: 'socialize', start: 420, end: 480, location: spouseData.homeBuilding });
          }
        }
        
        routine.push({ activity: 'home', start: 480, end: 600, location: charData.homeBuilding });
      }
      
      charData.routine = routine;
      return routine;
    }
    
    // ==================== ANT SYSTEM ====================
    
    function createAnt(x, y, z, fidelity = 1) {
      const ant = new THREE.Group();
      
      // Fidelity settings (simplified for performance)
      const config = {
        headSegments: [4, 3],
        eyeSegments: [3, 3],
        thoraxSegments: [4, 3],
        abdomenSegments: [4, 3],
        legSegments: 4,
        antennaSegments: 3
      };
      
      const antMaterial = new THREE.MeshStandardMaterial({
        color: 0x1a1a1a,
        roughness: 0.6,
        flatShading: true
      });
      
      const jointMaterial = new THREE.MeshStandardMaterial({
        color: 0x2a2a2a,
        roughness: 0.5,
        flatShading: true
      });
      
      const eyeMaterial = new THREE.MeshStandardMaterial({
        color: 0xff6b6b,
        emissive: 0x660000,
        roughness: 0.3,
        flatShading: true
      });
      
      // HEAD
      const headGeometry = new THREE.SphereGeometry(0.028, config.headSegments[0], config.headSegments[1]);
      const head = new THREE.Mesh(headGeometry, antMaterial);
      head.scale.set(0.9, 1.1, 1.4);
      head.position.set(0, 0.042, 0.13);
      head.castShadow = true;
      ant.add(head);
      
      // EYES
      const eyeGeometry = new THREE.SphereGeometry(0.009, config.eyeSegments[0], config.eyeSegments[1]);
      const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      leftEye.position.set(-0.024, 0.048, 0.13);
      ant.add(leftEye);
      
      const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      rightEye.position.set(0.024, 0.048, 0.13);
      ant.add(rightEye);
      
      // ANTENNAE
      function createAntenna(side) {
        const antenna = new THREE.Group();
        const scapeGeo = new THREE.CylinderGeometry(0.0025, 0.003, 0.025, config.antennaSegments);
        const scape = new THREE.Mesh(scapeGeo, antMaterial);
        scape.position.y = 0.0125;
        scape.rotation.z = -side * Math.PI / 4;
        scape.rotation.x = -Math.PI / 12;
        antenna.add(scape);
        
        const funiculusGeo = new THREE.CylinderGeometry(0.0018, 0.0022, 0.06, config.antennaSegments);
        const funiculus = new THREE.Mesh(funiculusGeo, antMaterial);
        funiculus.position.set(side * 0.008, 0.035, 0.02);
        funiculus.rotation.z = side * Math.PI / 3;
        funiculus.rotation.x = Math.PI / 2.5;
        antenna.add(funiculus);
        
        return antenna;
      }
      
      const leftAntenna = createAntenna(-1);
      leftAntenna.position.set(-0.01, 0.062, 0.142);
      ant.add(leftAntenna);
      
      const rightAntenna = createAntenna(1);
      rightAntenna.position.set(0.01, 0.062, 0.142);
      ant.add(rightAntenna);
      
      // MANDIBLES
      const mandibleGeo = new THREE.ConeGeometry(0.005, 0.018, config.antennaSegments);
      [-1, 1].forEach(side => {
        const mandible = new THREE.Mesh(mandibleGeo, antMaterial);
        mandible.position.set(side * 0.008, 0.028, 0.152);
        mandible.rotation.z = side * Math.PI / 2;
        mandible.rotation.x = Math.PI / 2.3;
        ant.add(mandible);
      });
      
      // THORAX
      const thoraxGeo = new THREE.SphereGeometry(0.038, config.thoraxSegments[0], config.thoraxSegments[1]);
      const thorax = new THREE.Mesh(thoraxGeo, antMaterial);
      thorax.scale.set(0.95, 1, 1.6);
      thorax.position.set(0, 0.038, 0.065);
      thorax.castShadow = true;
      ant.add(thorax);
      
      // PETIOLE
      const petioleGeo = new THREE.SphereGeometry(0.012, config.thoraxSegments[0], config.thoraxSegments[1]);
      const petiole = new THREE.Mesh(petioleGeo, antMaterial);
      petiole.scale.set(0.7, 1.4, 0.8);
      petiole.position.set(0, 0.048, -0.005);
      ant.add(petiole);
      
      // ABDOMEN
      const abdomenGeo = new THREE.SphereGeometry(0.048, config.abdomenSegments[0], config.abdomenSegments[1]);
      const abdomen = new THREE.Mesh(abdomenGeo, antMaterial);
      abdomen.scale.set(1, 0.95, 1.6);
      abdomen.position.set(0, 0.032, -0.095);
      abdomen.castShadow = true;
      ant.add(abdomen);
      
      // LEGS
      const legs = [];
      function createLeg(side, segment, angle, attachZ) {
        const leg = new THREE.Group();
        
        const coxaJoint = new THREE.Group();
        const coxaGeo = new THREE.CylinderGeometry(0.0025, 0.0028, 0.012, config.legSegments);
        const coxa = new THREE.Mesh(coxaGeo, antMaterial);
        coxa.position.y = 0.006;
        coxaJoint.add(coxa);
        coxaJoint.rotation.z = side * (Math.PI / 2.5 + angle);
        coxaJoint.rotation.y = 0.15;
        leg.add(coxaJoint);
        
        const femurGeo = new THREE.CylinderGeometry(0.0024, 0.002, 0.04, config.legSegments);
        const femur = new THREE.Mesh(femurGeo, antMaterial);
        femur.position.set(side * 0.008, -0.015, 0);
        femur.rotation.x = -Math.PI / 3.5;
        coxaJoint.add(femur);
        
        const tibiaGeo = new THREE.CylinderGeometry(0.002, 0.0016, 0.055, config.legSegments);
        const tibia = new THREE.Mesh(tibiaGeo, antMaterial);
        tibia.position.set(side * 0.008, -0.045, 0.01);
        tibia.rotation.x = Math.PI / 6;
        femur.add(tibia);
        
        leg.position.set(side * 0.032, 0.038, attachZ);
        leg.userData.coxaJoint = coxaJoint;
        leg.userData.side = side;
        leg.userData.segment = segment;
        
        return leg;
      }
      
      // Create 6 legs
      legs.push(createLeg(-1, 0, 0.25, 0.105));
      legs.push(createLeg(1, 0, 0.25, 0.105));
      legs.push(createLeg(-1, 1, 0, 0.065));
      legs.push(createLeg(1, 1, 0, 0.065));
      legs.push(createLeg(-1, 2, -0.3, 0.025));
      legs.push(createLeg(1, 2, -0.3, 0.025));
      
      legs.forEach(leg => ant.add(leg));
      
      ant.position.set(x, y, z);
      ant.userData.isAnt = true;
      ant.userData.legs = legs;
      ant.userData.abdomen = abdomen;
      ant.userData.walkCycle = Math.random() * Math.PI * 2;
      ant.userData.direction = new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();
      ant.userData.speed = 0.15 + Math.random() * 0.1;
      
      if (worldRoot) {
        worldRoot.add(ant); // Add to worldRoot so it scales with world
      } else {
        scene.add(ant);
      }
      return ant;
    }
    
    function updateAnts(deltaTime) {
      ants.forEach((ant, index) => {
        if (!ant || !ant.userData.legs) return;
        
        // Random walking
        ant.userData.walkCycle += deltaTime * 3;
        
        // Change direction occasionally
        if (Math.random() < 0.01) {
          ant.userData.direction.set(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();
        }
        
        // Move
        ant.position.x += ant.userData.direction.x * ant.userData.speed * deltaTime;
        ant.position.z += ant.userData.direction.z * ant.userData.speed * deltaTime;
        
        // Rotate to face direction
        ant.rotation.y = Math.atan2(ant.userData.direction.x, ant.userData.direction.z);
        
        // Animate legs (tripod gait)
        ant.userData.legs.forEach((leg, i) => {
          if (!leg || !leg.userData.coxaJoint) return;
          const isGroup1 = (i === 0 || i === 3 || i === 4);
          const phase = isGroup1 ? 0 : Math.PI;
          const cyclePos = ant.userData.walkCycle + phase;
          const swingAmount = Math.cos(cyclePos) * 0.15;
          leg.userData.coxaJoint.rotation.x = swingAmount * 0.3;
        });
        
        // Abdomen breathing
        if (ant.userData.abdomen) {
          ant.userData.abdomen.scale.z = 1.6 + Math.sin(ant.userData.walkCycle * 2) * 0.05;
        }
      });
    }
    
    function spawnAnts(count, centerX, centerZ, radius) {
      for (let i = 0; i < count; i++) {
        const angle = (i / count) * Math.PI * 2;
        const r = radius * Math.sqrt(Math.random());
        const x = centerX + Math.cos(angle) * r;
        const z = centerZ + Math.sin(angle) * r;
        const ant = createAnt(x, 0.01, z);
        ants.push(ant);
      }
    }
    
    // ==================== PEDESTRIAN SYSTEM ====================
    
    // LOD Pedestrian - Simplified version for distant viewing (no joints)
    function createPedestrianLOD(isFemale, isChild, shirtColor, hairColor) {
      const scale = isChild ? 0.65 : 1.0;
      const bodyScale = scale;
      const group = new THREE.Group();
      
      // Single merged geometry for performance
      const geometries = [];
      
      // Torso
      const torsoW = 0.5 * bodyScale;
      const torsoH = 0.8 * bodyScale;
      const torsoD = 0.3 * bodyScale;
      const torsoGeo = new THREE.BoxGeometry(torsoW, torsoH, torsoD);
      const torsoMesh = new THREE.Mesh(torsoGeo);
      torsoMesh.position.y = torsoH / 2;
      torsoMesh.updateMatrix();
      geometries.push(torsoMesh.geometry.clone().applyMatrix4(torsoMesh.matrix));
      
      // Head
      const headSize = 0.38 * bodyScale;
      const headGeo = new THREE.BoxGeometry(headSize, headSize, headSize * 0.9);
      const headMesh = new THREE.Mesh(headGeo);
      headMesh.position.y = torsoH + headSize / 2 + 0.05 * bodyScale;
      headMesh.updateMatrix();
      geometries.push(headMesh.geometry.clone().applyMatrix4(headMesh.matrix));
      
      // Simple arms (non-articulated)
      const armW = 0.14 * bodyScale;
      const armH = 0.8 * bodyScale;
      const armGeo = new THREE.BoxGeometry(armW, armH, armW);
      [-1, 1].forEach(side => {
        const arm = new THREE.Mesh(armGeo);
        arm.position.set(side * (torsoW / 2 + armW / 2 + 0.02 * bodyScale), torsoH * 0.4, 0);
        arm.updateMatrix();
        geometries.push(arm.geometry.clone().applyMatrix4(arm.matrix));
      });
      
      // Simple legs (non-articulated)
      const legW = 0.16 * bodyScale;
      const legH = 0.94 * bodyScale;
      const legGeo = new THREE.BoxGeometry(legW, legH, legW);
      [-1, 1].forEach(side => {
        const leg = new THREE.Mesh(legGeo);
        leg.position.set(side * (torsoW / 4), -legH / 2, 0);
        leg.updateMatrix();
        geometries.push(leg.geometry.clone().applyMatrix4(leg.matrix));
      });
      
      // Merge all geometries
      const mergedGeo = BufferGeometryUtils.mergeGeometries(geometries);
      const mat = new THREE.MeshStandardMaterial({ color: shirtColor, roughness: 0.7 });
      const mesh = new THREE.Mesh(mergedGeo, mat);
      mesh.castShadow = false; // Disable shadows for LOD
      group.add(mesh);
      
      const feetOffset = legH;
      group.position.y = feetOffset;
      
      return group;
    }
    
    function createPedestrian(x, z, options = {}) {
      const isChild = options.isChild || false;
      const isFemale = options.isFemale !== undefined ? options.isFemale : Math.random() > 0.5;
      const scale = isChild ? 0.65 : 1.0;
      
      // Shirt colors - three primary colors
      const shirtColors = [0xE53935, 0x1E88E5, 0x43A047]; // Red, Blue, Green
      const shirtColor = options.shirtColor || shirtColors[Math.floor(Math.random() * shirtColors.length)];
      
      // Hair for females
      const hairColors = { blonde: 0xF5DEB3, brunette: 0x4A2511 };
      const hairColor = isFemale ? (Math.random() > 0.5 ? hairColors.blonde : hairColors.brunette) : null;
      const hairstyle = isFemale ? (Math.random() > 0.5 ? 'bob' : 'ponytail') : null;
      
      const pedestrianGroup = new THREE.Group();
      
      // Body scaling
      const bodyScale = scale;
      const torsoW = 0.5 * bodyScale;
      const torsoH = 0.8 * bodyScale;
      const torsoD = 0.3 * bodyScale;
      
      // Torso (colored shirt)
      const torsoGeo = new THREE.BoxGeometry(torsoW, torsoH, torsoD);
      const torsoMat = new THREE.MeshStandardMaterial({ color: shirtColor, roughness: 0.6 });
      const torso = new THREE.Mesh(torsoGeo, torsoMat);
      torso.position.y = torsoH / 2;
      torso.castShadow = true;
      pedestrianGroup.add(torso);
      
      // Head (skin tone)
      const headSize = 0.38 * bodyScale;
      const headGeo = new THREE.BoxGeometry(headSize, headSize, headSize * 0.9);
      const headMat = new THREE.MeshStandardMaterial({ color: 0xFFE0BD, roughness: 0.7 });
      const head = new THREE.Mesh(headGeo, headMat);
      head.position.y = torsoH + headSize / 2 + 0.05 * bodyScale;
      head.castShadow = true;
      pedestrianGroup.add(head);
      
      // Hair for females
      if (isFemale && hairColor) {
        const hairMat = new THREE.MeshStandardMaterial({ color: hairColor, roughness: 0.8 });
        
        if (hairstyle === 'bob') {
          // Bob cut - wider hair around head
          const bobGeo = new THREE.BoxGeometry(headSize * 1.15, headSize * 0.9, headSize * 1.1);
          const bob = new THREE.Mesh(bobGeo, hairMat);
          bob.position.y = head.position.y + headSize * 0.15;
          bob.castShadow = true;
          pedestrianGroup.add(bob);
        } else if (hairstyle === 'ponytail') {
          // Ponytail - hair on top and back
          const topGeo = new THREE.BoxGeometry(headSize * 1.1, headSize * 0.4, headSize * 0.9);
          const topHair = new THREE.Mesh(topGeo, hairMat);
          topHair.position.y = head.position.y + headSize * 0.4;
          topHair.castShadow = true;
          pedestrianGroup.add(topHair);
          
          // Ponytail back
          const ponytailGeo = new THREE.CylinderGeometry(0.08 * bodyScale, 0.06 * bodyScale, 0.5 * bodyScale, 8);
          const ponytail = new THREE.Mesh(ponytailGeo, hairMat);
          ponytail.rotation.x = Math.PI / 6;
          ponytail.position.set(0, head.position.y, -headSize * 0.5 - 0.15 * bodyScale);
          ponytail.castShadow = true;
          pedestrianGroup.add(ponytail);
        }
      }
      
      // Arms with forearms
      const armW = 0.14 * bodyScale;
      const armH = 0.42 * bodyScale;
      const forearmH = 0.38 * bodyScale;
      const armMat = new THREE.MeshStandardMaterial({ color: 0x86C7FF, roughness: 0.6 });
      const forearmMat = new THREE.MeshStandardMaterial({ color: 0x9CD3FF, roughness: 0.6 });
      
      // Left arm
      const armL = new THREE.Group();
      const armLUpper = new THREE.Mesh(new THREE.BoxGeometry(armW, armH, armW), armMat);
      armLUpper.position.y = -armH / 2;
      armLUpper.castShadow = true;
      armL.add(armLUpper);
      
      // Elbow ball joint (small sphere at pivot)
      const elbowJointSize = armW * 0.7;
      const elbowJointGeo = new THREE.SphereGeometry(elbowJointSize / 2, 8, 8);
      const elbowJointMat = new THREE.MeshStandardMaterial({ color: 0xFFE0BD, roughness: 0.7 });
      const armLElbowJoint = new THREE.Mesh(elbowJointGeo, elbowJointMat);
      armLElbowJoint.position.y = -armH; // At elbow pivot point
      armLElbowJoint.castShadow = true;
      armL.add(armLElbowJoint);
      
      // Forearm pivot group positioned at bottom of upper arm
      const armLForearmPivot = new THREE.Group();
      armLForearmPivot.position.y = -armH; // At bottom edge of upper arm
      armLUpper.add(armLForearmPivot);
      
      const armLForearm = new THREE.Mesh(new THREE.BoxGeometry(armW * 0.85, forearmH, armW * 0.85), forearmMat);
      armLForearm.position.y = -forearmH / 2; // Offset down from pivot
      armLForearm.castShadow = true;
      armLForearmPivot.add(armLForearm);
      
      // Left hand - square slab
      const handSize = 0.18 * bodyScale;
      const handDepth = 0.04 * bodyScale;
      const handMat = new THREE.MeshStandardMaterial({ color: 0xFFE0BD, roughness: 0.7 });
      const armLHand = new THREE.Mesh(new THREE.BoxGeometry(handSize, handSize, handDepth), handMat);
      armLHand.position.y = -forearmH; // At bottom of forearm
      armLHand.castShadow = true;
      armLForearmPivot.add(armLHand);
      
      armL.position.set(-torsoW / 2 - armW / 2 - 0.02 * bodyScale, torsoH * 0.8, 0);
      armL.userData.upper = armLUpper;
      armL.userData.forearmPivot = armLForearmPivot;
      armL.userData.hand = armLHand;
      pedestrianGroup.add(armL);
      
      // Right arm
      const armR = new THREE.Group();
      const armRUpper = new THREE.Mesh(new THREE.BoxGeometry(armW, armH, armW), armMat);
      armRUpper.position.y = -armH / 2;
      armRUpper.castShadow = true;
      armR.add(armRUpper);
      
      // Elbow ball joint (small sphere at pivot)
      const armRElbowJoint = new THREE.Mesh(elbowJointGeo, elbowJointMat);
      armRElbowJoint.position.y = -armH; // At elbow pivot point
      armRElbowJoint.castShadow = true;
      armR.add(armRElbowJoint);
      
      // Forearm pivot group positioned at bottom of upper arm
      const armRForearmPivot = new THREE.Group();
      armRForearmPivot.position.y = -armH; // At bottom edge of upper arm
      armRUpper.add(armRForearmPivot);
      
      const armRForearm = new THREE.Mesh(new THREE.BoxGeometry(armW * 0.85, forearmH, armW * 0.85), forearmMat);
      armRForearm.position.y = -forearmH / 2; // Offset down from pivot
      armRForearm.castShadow = true;
      armRForearmPivot.add(armRForearm);
      
      // Right hand - square slab
      const armRHand = new THREE.Mesh(new THREE.BoxGeometry(handSize, handSize, handDepth), handMat);
      armRHand.position.y = -forearmH; // At bottom of forearm
      armRHand.castShadow = true;
      armRForearmPivot.add(armRHand);
      
      armR.position.set(torsoW / 2 + armW / 2 + 0.02 * bodyScale, torsoH * 0.8, 0);
      armR.userData.upper = armRUpper;
      armR.userData.forearmPivot = armRForearmPivot;
      armR.userData.hand = armRHand;
      pedestrianGroup.add(armR);
      
      // Legs with knees
      const legW = 0.16 * bodyScale;
      const legH = 0.48 * bodyScale;
      const shinH = 0.46 * bodyScale;
      const legMat = new THREE.MeshStandardMaterial({ color: 0x4A5568, roughness: 0.7 });
      const shinMat = new THREE.MeshStandardMaterial({ color: 0x5A6678, roughness: 0.7 });
      
      // Left leg
      const legL = new THREE.Group();
      const legLThigh = new THREE.Mesh(new THREE.BoxGeometry(legW, legH, legW), legMat);
      legLThigh.position.y = -legH / 2;
      legLThigh.castShadow = true;
      legL.add(legLThigh);
      
      // Knee ball joint (small sphere at pivot)
      const kneeJointSize = legW * 0.75;
      const kneeJointGeo = new THREE.SphereGeometry(kneeJointSize / 2, 8, 8);
      const kneeJointMat = new THREE.MeshStandardMaterial({ color: 0xFFE0BD, roughness: 0.7 });
      const legLKneeJoint = new THREE.Mesh(kneeJointGeo, kneeJointMat);
      legLKneeJoint.position.y = -legH; // At knee pivot point
      legLKneeJoint.castShadow = true;
      legL.add(legLKneeJoint);
      
      // Shin pivot group positioned at bottom of thigh
      const legLShinPivot = new THREE.Group();
      legLShinPivot.position.y = -legH; // At bottom edge of thigh
      legLThigh.add(legLShinPivot);
      
      const legLShin = new THREE.Mesh(new THREE.BoxGeometry(legW * 0.85, shinH, legW * 0.85), shinMat);
      legLShin.position.y = -shinH / 2; // Offset down from pivot
      legLShin.castShadow = true;
      legLShinPivot.add(legLShin);
      
      // Left foot - rectangle slab
      const footW = 0.24 * bodyScale;
      const footH = 0.08 * bodyScale;
      const footD = 0.32 * bodyScale;
      const footMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.8 });
      const legLFoot = new THREE.Mesh(new THREE.BoxGeometry(footW, footH, footD), footMat);
      legLFoot.position.set(0, -shinH - footH / 2, footD * 0.15); // At bottom of shin, slightly forward
      legLFoot.castShadow = true;
      legLShinPivot.add(legLFoot);
      
      legL.position.set(-torsoW / 4, 0, 0);
      legL.userData.thigh = legLThigh;
      legL.userData.shinPivot = legLShinPivot;
      legL.userData.foot = legLFoot;
      pedestrianGroup.add(legL);
      
      // Right leg
      const legR = new THREE.Group();
      const legRThigh = new THREE.Mesh(new THREE.BoxGeometry(legW, legH, legW), legMat);
      legRThigh.position.y = -legH / 2;
      legRThigh.castShadow = true;
      legR.add(legRThigh);
      
      // Knee ball joint (small sphere at pivot)
      const legRKneeJoint = new THREE.Mesh(kneeJointGeo, kneeJointMat);
      legRKneeJoint.position.y = -legH; // At knee pivot point
      legRKneeJoint.castShadow = true;
      legR.add(legRKneeJoint);
      
      // Shin pivot group positioned at bottom of thigh
      const legRShinPivot = new THREE.Group();
      legRShinPivot.position.y = -legH; // At bottom edge of thigh
      legRThigh.add(legRShinPivot);
      
      const legRShin = new THREE.Mesh(new THREE.BoxGeometry(legW * 0.85, shinH, legW * 0.85), shinMat);
      legRShin.position.y = -shinH / 2; // Offset down from pivot
      legRShin.castShadow = true;
      legRShinPivot.add(legRShin);
      
      // Right foot - rectangle slab
      const legRFoot = new THREE.Mesh(new THREE.BoxGeometry(footW, footH, footD), footMat);
      legRFoot.position.set(0, -shinH - footH / 2, footD * 0.15); // At bottom of shin, slightly forward
      legRFoot.castShadow = true;
      legRShinPivot.add(legRFoot);
      
      legR.position.set(torsoW / 4, 0, 0);
      legR.userData.thigh = legRThigh;
      legR.userData.shinPivot = legRShinPivot;
      legR.userData.foot = legRFoot;
      pedestrianGroup.add(legR);
      
      // Position pedestrian so feet are at ground level (legs extend down from torso)
      const feetOffset = legH + shinH; // Total leg height (thigh + shin)
      pedestrianGroup.position.set(x, feetOffset, z);
      
      // Generate or use character data
      const chunkKey = options.chunkKey || '0,0';
      const charData = options.charData || generateCharacterData(isFemale, isChild, chunkKey);
      
      // Mark as pickable and store character data
      pedestrianGroup.userData.isAtomic = true;
      pedestrianGroup.userData.pickable = true;
      pedestrianGroup.userData.objectType = 'pedestrian';
      pedestrianGroup.userData.characterId = charData.id;
      pedestrianGroup.userData.isFemale = isFemale;
      pedestrianGroup.userData.isChild = isChild;
      pedestrianGroup.userData.scale = scale;
      
      // Add profession label above head
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 64;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(0, 0, 256, 64);
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 24px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(charData.occupation, 128, 40);
      
      const texture = new THREE.CanvasTexture(canvas);
      const labelGeo = new THREE.PlaneGeometry(1.5, 0.4);
      const labelMat = new THREE.MeshBasicMaterial({ 
        map: texture, 
        transparent: true,
        side: THREE.DoubleSide
      });
      const label = new THREE.Mesh(labelGeo, labelMat);
      label.position.y = (torsoH + headSize + 0.3) * bodyScale;
      pedestrianGroup.add(label);
      pedestrianGroup.userData.label = label;
      
      if (worldRoot) {
        worldRoot.add(pedestrianGroup); // Add to worldRoot so it scales with world
      } else {
        scene.add(pedestrianGroup);
      }
      
      // AI behavior with routine-based pathfinding
      const speed = (isChild ? 0.8 : 1.2) + Math.random() * 0.4;
      let pathToFollow = [];
      let pathIndex = 0;
      let destination = new THREE.Vector3(x, 0, z);
      let gait = Math.random() * Math.PI * 2;
      
      function updateRoutineDestination() {
        if (!charData || !charData.routine || charData.routine.length === 0) {
          // No routine, random walk
          const bounds = 20;
          destination.set(
            pedestrianGroup.position.x + (Math.random() - 0.5) * bounds,
            0,
            pedestrianGroup.position.z + (Math.random() - 0.5) * bounds
          );
          pathToFollow = [];
          return;
        }
        
        // Find current activity based on day time
        const activity = charData.routine.find(a => 
          currentDayTime >= a.start && currentDayTime < a.end
        );
        
        if (activity && activity.location && activity.location.position) {
          const target = activity.location.position;
          const dist = pedestrianGroup.position.distanceTo(target);
          
          // If far from destination, find path
          if (dist > 5) {
            pathToFollow = findPath(
              pedestrianGroup.position.x,
              pedestrianGroup.position.z,
              target.x,
              target.z
            );
            pathIndex = 0;
          } else {
            // Close enough, stay here
            destination.copy(target);
            pathToFollow = [];
          }
        }
      }
      
      function chooseNewDestination() {
        if (pathToFollow.length > 0 && pathIndex < pathToFollow.length) {
          // Follow path
          destination.copy(pathToFollow[pathIndex]);
          pathIndex++;
        } else {
          // Update routine
          updateRoutineDestination();
        }
      }
      
      function update(deltaTime) {
        // Initialize ant detection variables
        if (!pedestrianGroup.userData.antDetectionTimer) {
          pedestrianGroup.userData.antDetectionTimer = 0;
          pedestrianGroup.userData.stompTimer = 0;
          pedestrianGroup.userData.stompPhase = 0;
        }
        
        // Check for nearby ants
        let nearestAnt = null;
        let nearestAntDist = Infinity;
        ants.forEach(ant => {
          if (!ant) return;
          const dist = pedestrianGroup.position.distanceTo(ant.position);
          if (dist < 1.5 && dist < nearestAntDist) {
            nearestAnt = ant;
            nearestAntDist = dist;
          }
        });
        
        // Accumulate detection time if ant is nearby
        if (nearestAnt) {
          pedestrianGroup.userData.antDetectionTimer += deltaTime;
          
          // After 1 second of being near ant, react
          if (pedestrianGroup.userData.antDetectionTimer > 1.0 && !pedestrianGroup.userData.hasReactedToAnt) {
            pedestrianGroup.userData.hasReactedToAnt = true;
            pedestrianGroup.userData.stompTimer = 4.0; // Stomp for 4 seconds
            
            // Show speech bubble with random reaction
            const reactions = ["What is that...?", "Is that a bug?", "Ew, gross!"];
            const reaction = reactions[Math.floor(Math.random() * reactions.length)];
            createSpeechBubble(reaction, pedestrianGroup);
            
            // Stop moving to stomp
            destination.copy(pedestrianGroup.position);
          }
        } else {
          // Reset detection if no ants nearby
          pedestrianGroup.userData.antDetectionTimer = Math.max(0, pedestrianGroup.userData.antDetectionTimer - deltaTime * 0.5);
          if (pedestrianGroup.userData.antDetectionTimer <= 0) {
            pedestrianGroup.userData.hasReactedToAnt = false;
          }
        }
        
        // Handle speech bubble timer
        if (pedestrianGroup.userData.speechBubbleTimer > 0) {
          pedestrianGroup.userData.speechBubbleTimer -= deltaTime;
          if (pedestrianGroup.userData.speechBubbleTimer <= 0 && pedestrianGroup.userData.speechBubble) {
            pedestrianGroup.remove(pedestrianGroup.userData.speechBubble);
            pedestrianGroup.userData.speechBubble = null;
          }
        }
        
        // Handle stomping animation
        let isStomping = false;
        if (pedestrianGroup.userData.stompTimer > 0) {
          isStomping = true;
          pedestrianGroup.userData.stompTimer -= deltaTime;
          pedestrianGroup.userData.stompPhase += deltaTime * 5; // Stomping speed
          
          // Smooth alternating leg stomping with sine waves
          const stompCycle = pedestrianGroup.userData.stompPhase;
          
          if (legL.userData.thigh && legL.userData.shinPivot) {
            // Left leg: smooth lift and stomp
            const leftLift = Math.sin(stompCycle);
            const leftThighTarget = leftLift * 0.8; // -0.8 to 0.8 range
            const leftShinTarget = Math.max(0, leftLift * 0.4); // 0 to 0.4 when lifting
            
            // Smooth interpolation
            legL.userData.thigh.rotation.x = THREE.MathUtils.lerp(
              legL.userData.thigh.rotation.x || 0,
              leftThighTarget,
              10 * deltaTime
            );
            legL.userData.shinPivot.rotation.x = THREE.MathUtils.lerp(
              legL.userData.shinPivot.rotation.x || 0,
              leftShinTarget,
              10 * deltaTime
            );
          }
          
          if (legR.userData.thigh && legR.userData.shinPivot) {
            // Right leg: smooth lift and stomp (opposite phase)
            const rightLift = Math.sin(stompCycle + Math.PI);
            const rightThighTarget = rightLift * 0.8;
            const rightShinTarget = Math.max(0, rightLift * 0.4);
            
            // Smooth interpolation
            legR.userData.thigh.rotation.x = THREE.MathUtils.lerp(
              legR.userData.thigh.rotation.x || 0,
              rightThighTarget,
              10 * deltaTime
            );
            legR.userData.shinPivot.rotation.x = THREE.MathUtils.lerp(
              legR.userData.shinPivot.rotation.x || 0,
              rightShinTarget,
              10 * deltaTime
            );
          }
          
          // Smooth arm movements during stomping
          if (armL.userData.upper && armL.userData.forearmPivot) {
            const leftArmTarget = Math.sin(stompCycle) * 0.5;
            armL.rotation.x = THREE.MathUtils.lerp(
              armL.rotation.x || 0,
              leftArmTarget,
              8 * deltaTime
            );
            const leftForearmTarget = -Math.abs(Math.sin(stompCycle)) * 0.3 - 0.2; // Negative = bend forward
            armL.userData.forearmPivot.rotation.x = THREE.MathUtils.lerp(
              armL.userData.forearmPivot.rotation.x || 0,
              leftForearmTarget,
              8 * deltaTime
            );
          }
          
          if (armR.userData.upper && armR.userData.forearmPivot) {
            const rightArmTarget = -Math.sin(stompCycle) * 0.5;
            armR.rotation.x = THREE.MathUtils.lerp(
              armR.rotation.x || 0,
              rightArmTarget,
              8 * deltaTime
            );
            const rightForearmTarget = -Math.abs(Math.sin(stompCycle + Math.PI)) * 0.3 - 0.2; // Negative = bend forward
            armR.userData.forearmPivot.rotation.x = THREE.MathUtils.lerp(
              armR.userData.forearmPivot.rotation.x || 0,
              rightForearmTarget,
              8 * deltaTime
            );
          }
          
          // Smooth torso bob during stomping
          const targetTorsoY = (torsoH / 2) + Math.abs(Math.sin(stompCycle * 2)) * 0.08 * bodyScale;
          torso.position.y = THREE.MathUtils.lerp(
            torso.position.y || (torsoH / 2),
            targetTorsoY,
            12 * deltaTime
          );
          
          // Try to stomp on nearest ant
          if (nearestAnt && nearestAntDist < 0.3) {
            // Check if stomp lands (when leg is at bottom of swing)
            const leftLegDown = Math.sin(stompCycle) < -0.7;
            const rightLegDown = Math.sin(stompCycle + Math.PI) < -0.7;
            if ((leftLegDown || rightLegDown) && !pedestrianGroup.userData.justStomped) {
              // Remove the ant
              const antIndex = ants.indexOf(nearestAnt);
              if (antIndex !== -1) {
                scene.remove(nearestAnt);
                ants.splice(antIndex, 1);
                console.log('Ant stomped!');
                pedestrianGroup.userData.justStomped = true;
                // Reset flag after a brief delay
                setTimeout(() => {
                  if (pedestrianGroup.userData) {
                    pedestrianGroup.userData.justStomped = false;
                  }
                }, 300);
              }
            }
          }
          
          return; // Don't do normal walking when stomping
        }
        
        // Move toward destination
        const toDestination = new THREE.Vector3(
          destination.x - pedestrianGroup.position.x,
          0,
          destination.z - pedestrianGroup.position.z
        );
        const distance = toDestination.length();
        
        if (distance < 0.5) {
          chooseNewDestination();
        } else {
          toDestination.normalize();
          
          // Move
          pedestrianGroup.position.x += toDestination.x * speed * deltaTime;
          pedestrianGroup.position.z += toDestination.z * speed * deltaTime;
          
          // Rotate to face direction
          const targetRotation = Math.atan2(toDestination.x, toDestination.z);
          pedestrianGroup.rotation.y = THREE.MathUtils.lerp(
            pedestrianGroup.rotation.y,
            targetRotation,
            5 * deltaTime
          );
          
          // Walking animation
          gait += 4.0 * deltaTime;
          const stepAmp = 0.6;
          
          // Animate legs with knee bending
          if (legL.userData.thigh && legL.userData.shinPivot) {
            // Thigh rotation
            legL.userData.thigh.rotation.x = Math.sin(gait) * stepAmp;
            // Knee bend (shin only bends forward)
            legL.userData.shinPivot.rotation.x = Math.max(0, -Math.sin(gait)) * 0.8;
          }
          if (legR.userData.thigh && legR.userData.shinPivot) {
            // Thigh rotation
            legR.userData.thigh.rotation.x = Math.sin(gait + Math.PI) * stepAmp;
            // Knee bend (shin only bends forward)
            legR.userData.shinPivot.rotation.x = Math.max(0, -Math.sin(gait + Math.PI)) * 0.8;
          }
          
          // Animate arms with elbow bending
          if (armL.userData.upper && armL.userData.forearmPivot) {
            // Shoulder swing
            armL.rotation.x = -Math.sin(gait) * 0.35;
            // Elbow bend (negative = bend forward only)
            armL.userData.forearmPivot.rotation.x = -Math.abs(Math.sin(gait)) * 0.4;
          }
          if (armR.userData.upper && armR.userData.forearmPivot) {
            // Shoulder swing
            armR.rotation.x = Math.sin(gait) * 0.35;
            // Elbow bend (negative = bend forward only)
            armR.userData.forearmPivot.rotation.x = -Math.abs(Math.sin(gait + Math.PI)) * 0.4;
          }
          
          // Bob torso
          torso.position.y = (torsoH / 2) + Math.abs(Math.sin(gait * 2)) * 0.05 * bodyScale;
        }
      }
      
      // Create LOD mesh (simplified, no animation)
      const lodMesh = createPedestrianLOD(isFemale, isChild, shirtColor, hairColor);
      lodMesh.visible = false; // Start hidden
      if (worldRoot) {
        worldRoot.add(lodMesh); // Add to worldRoot so it scales with world
      } else {
        scene.add(lodMesh);
      }
      
      const pedestrianData = {
        group: pedestrianGroup,
        update,
        lodMesh, // Low-detail static mesh
        torso,
        head,
        armL,
        armR,
        legL,
        legR,
        label,
        isFemale,
        isChild,
        scale,
        charData
      };
      
      pedestrians.push(pedestrianData);
      return pedestrianData;
    }
    
    function spawnSpecialConstructions() {
      console.log('Spawning special constructions...');
      
      const blockSize = 60;
      const cityRadius = 3; // 3 blocks out from center
      
      // Playgrounds (2-3) - reduced for performance
      const playgroundCount = 2 + Math.floor(Math.random() * 2);
      for (let i = 0; i < playgroundCount; i++) {
        const angle = (i / playgroundCount) * Math.PI * 2 + Math.random() * 0.5;
        const radius = blockSize * (1 + Math.random() * 2);
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        
        const playground = createPlayground(x, z, 15);
        if (worldRoot) {
          worldRoot.add(playground);
        } else {
          scene.add(playground);
        }
        pluckCandidates.add(playground);
        console.log(`Playground at (${x.toFixed(1)}, ${z.toFixed(1)})`);
      }
      
      // Parking Lots (3-4) - reduced for performance
      const parkingLotCount = 3 + Math.floor(Math.random() * 2);
      for (let i = 0; i < parkingLotCount; i++) {
        const angle = (i / parkingLotCount) * Math.PI * 2 + Math.random() * 0.3;
        const radius = blockSize * (1.5 + Math.random() * 2);
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        
        const width = 20 + Math.floor(Math.random() * 10);
        const depth = 20 + Math.floor(Math.random() * 10);
        const parkingLot = createParkingLot(x, z, width, depth);
        if (worldRoot) {
          worldRoot.add(parkingLot);
        } else {
          scene.add(parkingLot);
        }
        pluckCandidates.add(parkingLot);
        console.log(`Parking lot at (${x.toFixed(1)}, ${z.toFixed(1)})`);
      }
      
      // Parking Garages (1-2) - reduced for performance
      const garageCount = 1 + Math.floor(Math.random() * 2);
      for (let i = 0; i < garageCount; i++) {
        const angle = (i / garageCount) * Math.PI * 2 + Math.random() * 0.7;
        const radius = blockSize * (2 + Math.random() * 1.5);
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        
        const levels = 3 + Math.floor(Math.random() * 3); // 3-5 levels
        const garage = createParkingGarage(x, z, 25, 25, levels);
        if (worldRoot) {
          worldRoot.add(garage);
        } else {
          scene.add(garage);
        }
        pluckCandidates.add(garage);
        console.log(`Parking garage (${levels} levels) at (${x.toFixed(1)}, ${z.toFixed(1)})`);
      }
      
      // Hospitals (2-3)
      const hospitalCount = 2 + Math.floor(Math.random() * 2);
      for (let i = 0; i < hospitalCount; i++) {
        const angle = (i / hospitalCount) * Math.PI * 2 + Math.random() * 0.8;
        const radius = blockSize * (1.8 + Math.random() * 1.2);
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        
        const hospital = createHospitalBuilding(x, z, 30, 30, 25);
        if (worldRoot) {
          worldRoot.add(hospital);
        } else {
          scene.add(hospital);
        }
        pluckCandidates.add(hospital);
        
        // Register as building data
        const buildingData = {
          type: 'Hospital',
          name: 'City Hospital #' + (i + 1),
          blockX: Math.round(x / blockSize),
          blockZ: Math.round(z / blockSize),
          position: new THREE.Vector3(x, 0, z),
          residents: [],
          workers: []
        };
        buildingDatabase.set(hospital, buildingData);
        console.log(`Hospital at (${x.toFixed(1)}, ${z.toFixed(1)})`);
      }
      
      console.log(`Spawned ${playgroundCount} playgrounds, ${parkingLotCount} parking lots, ${garageCount} parking garages, ${hospitalCount} hospitals`);
    }
    
    function spawnPedestrians(count = 50) { // Reduced from 100 for performance
      console.log(`Spawning ${count} pedestrians...`);
      
      for (let i = 0; i < count; i++) {
        const angle = (i / count) * Math.PI * 2;
        const radius = 15 + Math.random() * 35; // Reduced spawn radius
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        
        // Mix of adults and children, male and female
        const isChild = Math.random() < 0.15; // 15% children
        const isFemale = Math.random() > 0.5;
        
        const charData = generateCharacterData(isFemale, isChild, '0,0');
        createPedestrian(x, z, { isChild, isFemale, charData, chunkKey: '0,0' });
      }
      
      // Generate relationships and assign homes/workplaces
      console.log('Generating marriages...');
      generateMarriages();
      
      console.log('Assigning homes and workplaces...');
      assignHomesAndWorkplaces();
      
      // Generate daily routines for all
      console.log('Generating daily routines...');
      pedestrianDatabase.forEach(charData => {
        generateDailyRoutine(charData);
      });
      
      console.log(`Spawned ${count} pedestrians with ${pedestrianDatabase.size} character profiles`);
    }
    
    // Cache frustum calculation (only update every 100ms)
    let cachedFrustum = null;
    let lastFrustumUpdate = 0;
    
    function updatePedestrians(deltaTime) {
      if (!playerBody && !camera) return;
      
      // Use camera position for LOD checks
      const camPos = camera.position;
      const maxDistance = 150; // Cull beyond 150m
      const maxDistanceSq = maxDistance * maxDistance;
      const lodDistance = 80; // Increased from 30m to 80m to reduce pop-in
      const lodDistanceSq = lodDistance * lodDistance;
      const animDistance = 100; // Disable animation beyond 100m
      const animDistanceSq = animDistance * animDistance;
      
      // Update frustum for occlusion checks (cached, only update every 100ms)
      const now = performance.now();
      if (!cachedFrustum || now - lastFrustumUpdate > 100) {
        camera.updateMatrixWorld();
        if (!cachedFrustum) cachedFrustum = new THREE.Frustum();
        const viewProjectionMatrix = new THREE.Matrix4();
        viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        cachedFrustum.setFromProjectionMatrix(viewProjectionMatrix);
        lastFrustumUpdate = now;
      }
      const frustum = cachedFrustum;
      
      // Only update a subset each frame for performance (split into 4 chunks)
      const updateChunkSize = Math.ceil(pedestrians.length / 4);
      const frameOffset = Math.floor(now / 16) % 4;
      const startIdx = frameOffset * updateChunkSize;
      const endIdx = Math.min(startIdx + updateChunkSize, pedestrians.length);
      
      for (let i = 0; i < pedestrians.length; i++) {
        const ped = pedestrians[i];
        if (!ped || !ped.group) continue;
        
        // Apply world scale to pedestrians (make them scale with the world)
        // Skip if pedestrian has been plucked or is in jar (user is interacting with it)
        if (!ped.group.userData.isPlucked && !ped.group.userData.isDragging && !ped.group.userData.isInJar) {
          ped.group.scale.setScalar(worldScale);
          if (ped.lodMesh) ped.lodMesh.scale.setScalar(worldScale);
        }
        
        // Quick XZ distance check (skip Y for performance)
        const dx = ped.group.position.x - camPos.x;
        const dz = ped.group.position.z - camPos.z;
        const distSq = dx * dx + dz * dz;
        
        // Early exit: cull if too far
        if (distSq > maxDistanceSq) {
          ped.group.visible = false;
          if (ped.lodMesh) ped.lodMesh.visible = false;
          continue;
        }
        
        // Frustum check: Only perform on subset of pedestrians for performance
        // Only check every 4th pedestrian per frame (25% check rate)
        let inFrustum = false;
        if (i % 4 === (frameOffset % 4)) {
          try {
            if (ped.group && ped.group.children.length > 0) {
              inFrustum = frustum.intersectsObject(ped.group);
            }
          } catch (e) {
            inFrustum = false;
          }
          // Cache frustum result
          ped._cachedInFrustum = inFrustum;
          ped._frustumCheckTime = now;
        } else {
          // Use cached frustum result (valid for 200ms)
          inFrustum = (now - (ped._frustumCheckTime || 0) < 200) ? (ped._cachedInFrustum || false) : false;
        }
        
        // Use full detail if visible OR very close
        const useFullDetail = inFrustum || distSq < lodDistanceSq;
        
        if (useFullDetail) {
          // Show detailed animated mesh
          ped.group.visible = true;
          if (ped.lodMesh) ped.lodMesh.visible = false;
          
          // Update AI: Only update subset per frame OR very close pedestrians
          // Skip pedestrians in jar
          const shouldUpdate = (i >= startIdx && i < endIdx) || distSq < (lodDistanceSq / 4);
          if (shouldUpdate && ped.update && !ped.group.userData.isDragging && !ped.group.userData.isInJar) {
            ped.update(deltaTime);
          }
          
          // Shadows: Only very close pedestrians (20m)
          if (distSq < (lodDistanceSq / 16)) {
          ped.group.traverse(obj => {
              if (obj.isMesh && !obj.castShadow) obj.castShadow = true;
          });
        } else {
            ped.group.traverse(obj => {
              if (obj.isMesh && obj.castShadow) obj.castShadow = false;
            });
          }
        } else {
          // Use LOD mesh (simplified, no animation)
          ped.group.visible = false;
          if (ped.lodMesh) {
            ped.lodMesh.visible = true;
            ped.lodMesh.position.copy(ped.group.position);
            ped.lodMesh.rotation.copy(ped.group.rotation);
          }
          
          // Still update AI if within anim distance
          // Skip pedestrians in jar
          if (distSq < animDistanceSq) {
            const shouldUpdate = (i >= startIdx && i < endIdx);
            if (shouldUpdate && ped.update && !ped.group.userData.isDragging && !ped.group.userData.isInJar) {
              ped.update(deltaTime);
            }
          }
        }
      }
    }
    
    // ==================== SPEECH BUBBLE SYSTEM ====================
    function createSpeechBubble(text, pedestrianGroup) {
      // Remove existing speech bubble if any
      if (pedestrianGroup.userData.speechBubble) {
        pedestrianGroup.remove(pedestrianGroup.userData.speechBubble);
      }
      
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 128;
      const ctx = canvas.getContext('2d');
      
      // Background
      ctx.fillStyle = 'rgba(255,255,255,0.95)';
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 4;
      
      // Rounded rectangle
      const padding = 10;
      ctx.beginPath();
      ctx.roundRect(padding, padding, canvas.width - padding * 2, canvas.height - padding * 2, 15);
      ctx.fill();
      ctx.stroke();
      
      // Text
      ctx.fillStyle = '#333';
      ctx.font = 'bold 36px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, canvas.width / 2, canvas.height / 2);
      
      const texture = new THREE.CanvasTexture(canvas);
      const bubbleGeo = new THREE.PlaneGeometry(2, 0.5);
      const bubbleMat = new THREE.MeshBasicMaterial({ 
        map: texture, 
        transparent: true,
        side: THREE.DoubleSide
      });
      const bubble = new THREE.Mesh(bubbleGeo, bubbleMat);
      
      // Position above head
      const scale = pedestrianGroup.userData.scale || 1.0;
      bubble.position.y = (2.2 * scale);
      
      pedestrianGroup.add(bubble);
      pedestrianGroup.userData.speechBubble = bubble;
      pedestrianGroup.userData.speechBubbleTimer = 3.0; // Show for 3 seconds
      
      return bubble;
    }
    
    // ==================== PEDESTRIAN DIALOGUE SYSTEM ====================
    function updatePedestrianDialogueContext(pedestrianGroup, context) {
      if (!pedestrianGroup || !camera) return;
      
      // FIRST: Turn pedestrian to face the camera/player BEFORE showing dialogue
      const pedPos = new THREE.Vector3();
      pedestrianGroup.getWorldPosition(pedPos);
      
      const camPos = new THREE.Vector3();
      camera.getWorldPosition(camPos);
      
      // Calculate angle to face camera
      const dx = camPos.x - pedPos.x;
      const dz = camPos.z - pedPos.z;
      const targetRotation = Math.atan2(dx, dz);
      
      // Smoothly rotate pedestrian to face camera
      pedestrianGroup.rotation.y = targetRotation;
      
      // Get character data for personalized responses
      const charData = pedestrianDatabase.get(pedestrianGroup.userData.characterId);
      
      // Generate dialogue based on context
      let dialogue = '';
      
      switch(context) {
        case 'plucked':
          const pluckedDialogues = [
            "Whoa! What's happening?!",
            "Hey! Put me down!",
            "Ahhhh! I'm flying!",
            "This is so weird!",
            "Where are you taking me?!"
          ];
          dialogue = pluckedDialogues[Math.floor(Math.random() * pluckedDialogues.length)];
          break;
          
        case 'jar':
          const jarDialogues = [
            "Help! Let me out!",
            "It's so cramped in here!",
            "What is this place?!",
            "Please open the lid!",
            "I can't breathe!"
          ];
          dialogue = jarDialogues[Math.floor(Math.random() * jarDialogues.length)];
          break;
          
        case 'greeting':
          if (charData) {
            const greetings = [
              `Hi! I'm ${charData.firstName}.`,
              `Hello! I work as a ${charData.occupation}.`,
              `Nice to meet you!`,
              `Good day to you!`,
              `${charData.occupation} at your service!`
            ];
            dialogue = greetings[Math.floor(Math.random() * greetings.length)];
          } else {
            dialogue = "Hello there!";
          }
          break;
          
        default:
          dialogue = "...";
      }
      
      // Create the speech bubble AFTER rotating
      createSpeechBubble(dialogue, pedestrianGroup);
    }
    
    // ==================== INTERIOR GENERATION POLICIES ====================
    
    let selectedApartmentSize = '1BR'; // Default apartment size
    
    const INTERIOR_POLICIES = {
      // Residential apartments
      STUDIO: {
        type: 'studio',
        rooms: [
          { type: 'open_living', width: 6, depth: 5, furniture: ['bed', 'couch', 'tv', 'kitchenette', 'table_small'] },
          { type: 'bathroom', width: 3, depth: 2.5, furniture: ['toilet', 'sink', 'shower'] }
        ]
      },
      '1BR': {
        type: '1bedroom',
        rooms: [
          { type: 'living', width: 5, depth: 4, furniture: ['couch', 'tv', 'coffee_table'] },
          { type: 'bedroom', width: 4, depth: 4, furniture: ['bed', 'nightstand', 'dresser'] },
          { type: 'kitchen', width: 4, depth: 3, furniture: ['counter', 'fridge', 'stove'] },
          { type: 'bathroom', width: 3, depth: 2.5, furniture: ['toilet', 'sink', 'shower'] }
        ]
      },
      '2BR': {
        type: '2bedroom',
        rooms: [
          { type: 'living', width: 6, depth: 5, furniture: ['couch', 'tv', 'coffee_table', 'bookshelf'] },
          { type: 'bedroom1', width: 4, depth: 4, furniture: ['bed', 'nightstand', 'dresser'] },
          { type: 'bedroom2', width: 4, depth: 3.5, furniture: ['bed', 'desk', 'chair'] },
          { type: 'kitchen', width: 5, depth: 3, furniture: ['counter', 'fridge', 'stove', 'table'] },
          { type: 'bathroom', width: 3, depth: 2.5, furniture: ['toilet', 'sink', 'shower'] }
        ]
      },
      '3BR': {
        type: '3bedroom',
        rooms: [
          { type: 'living', width: 7, depth: 6, furniture: ['couch', 'tv', 'coffee_table', 'bookshelf', 'plant'] },
          { type: 'bedroom1', width: 5, depth: 4, furniture: ['bed', 'nightstand', 'dresser', 'chair'] },
          { type: 'bedroom2', width: 4, depth: 4, furniture: ['bed', 'nightstand', 'desk'] },
          { type: 'bedroom3', width: 4, depth: 3.5, furniture: ['bed', 'desk', 'shelf'] },
          { type: 'kitchen', width: 5, depth: 4, furniture: ['counter', 'fridge', 'stove', 'table', 'chairs'] },
          { type: 'bathroom1', width: 3, depth: 3, furniture: ['toilet', 'sink', 'shower', 'mirror'] },
          { type: 'bathroom2', width: 2.5, depth: 2, furniture: ['toilet', 'sink'] }
        ]
      },
      
      // Office space
      OFFICE: {
        type: 'office',
        rooms: [
          { type: 'open_floor', width: 10, depth: 8, furniture: ['desks_grid', 'chairs', 'plants'] },
          { type: 'meeting_room1', width: 4, depth: 4, furniture: ['conference_table', 'chairs_around'] },
          { type: 'meeting_room2', width: 3, depth: 3, furniture: ['table_small', 'chairs_4'] },
          { type: 'manager_office', width: 4, depth: 3, furniture: ['desk', 'chair', 'bookshelf', 'plant'] },
          { type: 'break_room', width: 4, depth: 3, furniture: ['counter', 'fridge', 'microwave', 'table', 'chairs'] },
          { type: 'bathroom', width: 3, depth: 2.5, furniture: ['toilet', 'sink'] }
        ]
      },
      
      // Classroom
      CLASSROOM: {
        type: 'classroom',
        rooms: [
          { type: 'main_room', width: 10, depth: 8, furniture: ['teacher_desk', 'student_desks_grid', 'whiteboard', 'bookshelf'] },
          { type: 'supply_closet', width: 2, depth: 2, furniture: ['shelves'] }
        ]
      },
      
      // Gymnasium
      GYMNASIUM: {
        type: 'gymnasium',
        rooms: [
          { type: 'main_court', width: 15, depth: 12, furniture: ['basketball_hoops', 'bleachers'] },
          { type: 'locker_room1', width: 5, depth: 4, furniture: ['benches', 'lockers'] },
          { type: 'locker_room2', width: 5, depth: 4, furniture: ['benches', 'lockers'] },
          { type: 'equipment_room', width: 4, depth: 3, furniture: ['storage_shelves'] }
        ]
      },
      
      // Cell Block
      CELLBLOCK: {
        type: 'cellblock',
        rooms: [
          { type: 'corridor', width: 15, depth: 3, furniture: [] },
          { type: 'cell1', width: 3, depth: 2.5, furniture: ['bed', 'toilet'], bars: true },
          { type: 'cell2', width: 3, depth: 2.5, furniture: ['bed', 'toilet'], bars: true },
          { type: 'cell3', width: 3, depth: 2.5, furniture: ['bed', 'toilet'], bars: true },
          { type: 'cell4', width: 3, depth: 2.5, furniture: ['bed', 'toilet'], bars: true },
          { type: 'cell5', width: 3, depth: 2.5, furniture: ['bed', 'toilet'], bars: true },
          { type: 'cell6', width: 3, depth: 2.5, furniture: ['bed', 'toilet'], bars: true },
          { type: 'guard_station', width: 4, depth: 3, furniture: ['desk', 'chair', 'monitor'] }
        ]
      }
    };
    
    // Generate interior based on policy
    function generateInteriorFromPolicy(policy) {
      if (!interiorsMode) {
        console.log('Not in interiors mode');
        return;
      }
      
      // Clear existing interior
      clearInteriorRoom();
      
      console.log(`üè¢ Generating ${policy.type} interior...`);
      
      // Simple grid layout for rooms
      let currentX = 0;
      let currentZ = 0;
      let rowMaxDepth = 0;
      const maxRowWidth = 12; // Max width before wrapping to next row
      
      policy.rooms.forEach((room, index) => {
        // Wrap to next row if needed
        if (currentX + room.width > maxRowWidth && currentX > 0) {
          currentX = 0;
          currentZ += rowMaxDepth + 0.5; // Add gap between rows
          rowMaxDepth = 0;
        }
        
        // Create room with walls
        createRoomBox(currentX, currentZ, room.width, room.depth, room.type, room.bars);
        
        // Add furniture based on room type
        addRoomFurniture(currentX, currentZ, room.width, room.depth, room.furniture);
        
        // Update position for next room
        currentX += room.width + 0.5; // Add gap between rooms
        rowMaxDepth = Math.max(rowMaxDepth, room.depth);
      });
      
      console.log(`‚úÖ Generated ${policy.rooms.length} rooms for ${policy.type}`);
    }
    
    // Create a simple room box with walls
    function createRoomBox(x, z, width, depth, roomType, hasBars = false) {
      const wallHeight = 2.8;
      const wallThickness = 0.1;
      
      const wallMat = new THREE.MeshStandardMaterial({ 
        color: roomType.includes('cell') ? 0x555555 : 0xE8E8E8, 
        roughness: 0.9 
      });
      
      const barMat = new THREE.MeshStandardMaterial({
        color: 0x2a2a2a,
        roughness: 0.3,
        metalness: 0.9
      });
      
      // Floor
      const floorGeo = new THREE.PlaneGeometry(width, depth);
      const floorMat = new THREE.MeshStandardMaterial({ color: 0xCCCCCC, roughness: 0.95 });
      const floor = new THREE.Mesh(floorGeo, floorMat);
      floor.rotation.x = -Math.PI / 2;
      floor.position.set(x + width/2, 0, z + depth/2);
      floor.receiveShadow = true;
      interiorsGroup.add(floor);
      
      // Ceiling
      const ceiling = new THREE.Mesh(floorGeo, wallMat);
      ceiling.rotation.x = Math.PI / 2;
      ceiling.position.set(x + width/2, wallHeight, z + depth/2);
      interiorsGroup.add(ceiling);
      
      // Back wall (solid)
      const backWallGeo = new THREE.BoxGeometry(width, wallHeight, wallThickness);
      const backWall = new THREE.Mesh(backWallGeo, wallMat);
      backWall.position.set(x + width/2, wallHeight/2, z);
      backWall.castShadow = true;
      interiorsGroup.add(backWall);
      
      // Left wall
      const sideWallGeo = new THREE.BoxGeometry(wallThickness, wallHeight, depth);
      const leftWall = new THREE.Mesh(sideWallGeo, wallMat);
      leftWall.position.set(x, wallHeight/2, z + depth/2);
      leftWall.castShadow = true;
      interiorsGroup.add(leftWall);
      
      // Right wall
      const rightWall = new THREE.Mesh(sideWallGeo, wallMat);
      rightWall.position.set(x + width, wallHeight/2, z + depth/2);
      rightWall.castShadow = true;
      interiorsGroup.add(rightWall);
      
      // Front wall with door opening or bars
      if (hasBars) {
        // Create bars for prison cells
        const barRadius = 0.02;
        const barSpacing = 0.15;
        const barCount = Math.floor(width / barSpacing);
        
        for (let i = 0; i < barCount; i++) {
          const barGeo = new THREE.CylinderGeometry(barRadius, barRadius, wallHeight, 8);
          const bar = new THREE.Mesh(barGeo, barMat);
          bar.position.set(
            x + (i * barSpacing) + barSpacing/2,
            wallHeight/2,
            z + depth
          );
          bar.castShadow = true;
          interiorsGroup.add(bar);
        }
        
        // Horizontal bars (top and bottom)
        const horizontalBarGeo = new THREE.CylinderGeometry(barRadius, barRadius, width, 8);
        const topBar = new THREE.Mesh(horizontalBarGeo, barMat);
        topBar.rotation.z = Math.PI / 2;
        topBar.position.set(x + width/2, wallHeight - 0.2, z + depth);
        interiorsGroup.add(topBar);
        
        const bottomBar = new THREE.Mesh(horizontalBarGeo, barMat);
        bottomBar.rotation.z = Math.PI / 2;
        bottomBar.position.set(x + width/2, 0.2, z + depth);
        interiorsGroup.add(bottomBar);
        
      } else {
        // Regular wall with door opening
        const doorWidth = 1.0;
        const doorHeight = 2.2;
        
        // Left part of front wall
        const leftPartWidth = (width - doorWidth) / 2;
        if (leftPartWidth > 0.1) {
          const leftPartGeo = new THREE.BoxGeometry(leftPartWidth, wallHeight, wallThickness);
          const leftPart = new THREE.Mesh(leftPartGeo, wallMat);
          leftPart.position.set(x + leftPartWidth/2, wallHeight/2, z + depth);
          leftPart.castShadow = true;
          interiorsGroup.add(leftPart);
        }
        
        // Right part of front wall
        if (leftPartWidth > 0.1) {
          const rightPartGeo = new THREE.BoxGeometry(leftPartWidth, wallHeight, wallThickness);
          const rightPart = new THREE.Mesh(rightPartGeo, wallMat);
          rightPart.position.set(x + width - leftPartWidth/2, wallHeight/2, z + depth);
          rightPart.castShadow = true;
          interiorsGroup.add(rightPart);
        }
        
        // Top part above door
        const topPartHeight = wallHeight - doorHeight;
        if (topPartHeight > 0.1) {
          const topPartGeo = new THREE.BoxGeometry(doorWidth, topPartHeight, wallThickness);
          const topPart = new THREE.Mesh(topPartGeo, wallMat);
          topPart.position.set(x + width/2, wallHeight - topPartHeight/2, z + depth);
          topPart.castShadow = true;
          interiorsGroup.add(topPart);
        }
      }
    }
    
    // Add furniture to a room based on its type
    function addRoomFurniture(x, z, width, depth, furnitureList) {
      // Simple furniture placement logic
      furnitureList.forEach((item, index) => {
        const furnitureX = x + 0.5 + (index % 2) * (width - 1);
        const furnitureZ = z + 0.5 + Math.floor(index / 2) * 1.5;
        
        // Create placeholder furniture (you can expand this with actual furniture creation)
        const furnitureGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const furnitureMat = new THREE.MeshStandardMaterial({ 
          color: 0x8B4513, 
          roughness: 0.8 
        });
        const furniture = new THREE.Mesh(furnitureGeo, furnitureMat);
        furniture.position.set(furnitureX, 0.25, furnitureZ);
        furniture.castShadow = true;
        furniture.receiveShadow = true;
        interiorsGroup.add(furniture);
      });
    }
    
    // ==================== CLOUD SYSTEM ====================
    function createCloudPrototype(seed) {
      const cloudGroup = new THREE.Group();
      
      // Random cloud parameters based on seed
      const rng = () => {
        seed = (seed * 9301 + 49297) % 233280;
        return seed / 233280;
      };
      
      const puffCount = 3 + Math.floor(rng() * 5); // 3-7 puffs
      const baseScale = 8 + rng() * 6; // 8-14m scale
      
      // Cloud material - simple white diffuse
      const cloudMat = new THREE.MeshLambertMaterial({
        color: 0xFFFFFF,
        transparent: true,
        opacity: 0.85,
        fog: true
      });
      
      // Create puffs (low-poly spheres)
      for (let i = 0; i < puffCount; i++) {
        const puffGeo = new THREE.SphereGeometry(
          1 + rng() * 0.8, // Radius variation
          6, // Low-poly segments
          5
        );
        
        const puff = new THREE.Mesh(puffGeo, cloudMat);
        
        // Position puffs in cluster
        const angle = (i / puffCount) * Math.PI * 2;
        const radius = rng() * 1.5;
        puff.position.set(
          Math.cos(angle) * radius,
          (rng() - 0.5) * 0.8,
          Math.sin(angle) * radius
        );
        
        // Random scale per puff
        const puffScale = 0.7 + rng() * 0.6;
        puff.scale.set(puffScale, puffScale * 0.8, puffScale);
        
        cloudGroup.add(puff);
      }
      
      cloudGroup.scale.setScalar(baseScale);
      cloudGroup.userData.baseScale = baseScale;
      cloudGroup.userData.driftSpeed = 0.5 + rng() * 1.0; // Drift speed variation
      cloudGroup.userData.driftAngle = rng() * Math.PI * 2;
      
      return cloudGroup;
    }
    
    function generateCloudPrototypes(count = 5) {
      console.log('Generating cloud prototypes...');
      for (let i = 0; i < count; i++) {
        const proto = createCloudPrototype(i * 1000);
        cloudPrototypes.push(proto);
      }
      console.log(`Generated ${count} cloud prototypes`);
    }
    
    function spawnClouds(count = 15) {
      const cloudHeight = 80 + Math.random() * 40; // 80-120m high
      const spawnRadius = 200; // Spawn within 200m radius
      
      for (let i = 0; i < count; i++) {
        // Pick random prototype
        const proto = cloudPrototypes[Math.floor(Math.random() * cloudPrototypes.length)];
        const cloudInstance = proto.clone();
        
        // Random position
        const angle = Math.random() * Math.PI * 2;
        const radius = 50 + Math.random() * spawnRadius;
        cloudInstance.position.set(
          Math.cos(angle) * radius,
          cloudHeight + Math.random() * 20,
          Math.sin(angle) * radius
        );
        
        // Random rotation
        cloudInstance.rotation.y = Math.random() * Math.PI * 2;
        
        cloudInstance.userData.driftTime = Math.random() * 100; // Offset animation
        
        scene.add(cloudInstance);
        activeClouds.push(cloudInstance);
      }
      
      console.log(`Spawned ${count} clouds`);
    }
    
    let cloudUpdateTimer = 0;
    const CLOUD_UPDATE_INTERVAL = 0.1; // Update clouds every 100ms instead of every frame
    
    function updateClouds(deltaTime) {
      cloudUpdateTimer += deltaTime;
      if (cloudUpdateTimer < CLOUD_UPDATE_INTERVAL) return;
      
      const actualDelta = cloudUpdateTimer;
      cloudUpdateTimer = 0;
      
      // Disable shadows on all clouds for performance
      activeClouds.forEach(cloud => {
        // Slow drift
        cloud.userData.driftTime += actualDelta * cloud.userData.driftSpeed;
        const driftX = Math.cos(cloud.userData.driftAngle) * cloud.userData.driftSpeed * actualDelta;
        const driftZ = Math.sin(cloud.userData.driftAngle) * cloud.userData.driftSpeed * actualDelta;
        
        cloud.position.x += driftX;
        cloud.position.z += driftZ;
        
        // Gentle bobbing
        cloud.position.y += Math.sin(cloud.userData.driftTime) * 0.01;
        
        // Wrap clouds around - if they drift too far, teleport to opposite side
        const maxDist = 300;
        const distSq = cloud.position.x * cloud.position.x + cloud.position.z * cloud.position.z;
        if (distSq > maxDist * maxDist) {
          cloud.position.x = -cloud.position.x * 0.5;
          cloud.position.z = -cloud.position.z * 0.5;
        }
        
        // Disable shadows and receiving shadows on clouds
        cloud.traverse(obj => {
          if (obj.isMesh) {
            obj.castShadow = false;
            obj.receiveShadow = false;
          }
        });
      });
    }
    
    // ==================== PORTALS ====================
    function createPortalPair() {
      const portalGeometry = new THREE.RingGeometry(1.8, 2.2, 48);
      const portalInnerGeo = new THREE.CircleGeometry(1.8, 48);
      
      // Portal A (Cyan)
      const portal1Group = new THREE.Group();
      const portal1Ring = new THREE.Mesh(portalGeometry, new THREE.MeshBasicMaterial({ 
        color: 0x00ffff,
        side: THREE.DoubleSide
      }));
      const portal1Inner = new THREE.Mesh(portalInnerGeo, new THREE.MeshBasicMaterial({ 
        color: 0x00ffff,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide
      }));
      portal1Group.add(portal1Ring);
      portal1Group.add(portal1Inner);
      portal1Group.position.set(-25, 3, 0);
      portal1Group.rotation.y = Math.PI / 2;
      worldRoot.add(portal1Group);
      
      // Portal B (Magenta)
      const portal2Group = new THREE.Group();
      const portal2Ring = new THREE.Mesh(portalGeometry, new THREE.MeshBasicMaterial({ 
        color: 0xff00ff,
        side: THREE.DoubleSide
      }));
      const portal2Inner = new THREE.Mesh(portalInnerGeo, new THREE.MeshBasicMaterial({ 
        color: 0xff00ff,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide
      }));
      portal2Group.add(portal2Ring);
      portal2Group.add(portal2Inner);
      portal2Group.position.set(25, 3, 0);
      portal2Group.rotation.y = -Math.PI / 2;
      worldRoot.add(portal2Group);
      
      portals.push({ a: portal1Group, b: portal2Group, scale: 1.0, radius: 1.8 });
    }
    
    // ==================== VIEWPORT SYSTEM ====================
    function ensureHeldViewport() {
      if (heldViewport) return;
      
      const group = new THREE.Group();
      const w = 1.2, h = 0.7;
      
      // Transparent plane
      const planeGeo = new THREE.PlaneGeometry(w, h);
      const planeMat = new THREE.MeshBasicMaterial({ 
        color: 0x000000, 
        opacity: 0.12, 
        transparent: true 
      });
      const plane = new THREE.Mesh(planeGeo, planeMat);
      group.add(plane);
      
      // Frame bars
      const t = 0.03;
      const barMat = new THREE.MeshStandardMaterial({ 
        color: 0x6a9cff, 
        metalness: 0.2, 
        roughness: 0.5,
        emissive: 0x4a7cff,
        emissiveIntensity: 0.2
      });
      
      const topBar = new THREE.Mesh(new THREE.BoxGeometry(w, t, t), barMat);
      topBar.position.set(0, h/2 + t/2, 0);
      const botBar = new THREE.Mesh(new THREE.BoxGeometry(w, t, t), barMat);
      botBar.position.set(0, -h/2 - t/2, 0);
      const leftBar = new THREE.Mesh(new THREE.BoxGeometry(t, h + 2*t, t), barMat);
      leftBar.position.set(-w/2 - t/2, 0, 0);
      const rightBar = new THREE.Mesh(new THREE.BoxGeometry(t, h + 2*t, t), barMat);
      rightBar.position.set(w/2 + t/2, 0, 0);
      
      [topBar, botBar, leftBar, rightBar].forEach(b => {
        b.castShadow = false;
        b.receiveShadow = false;
        group.add(b);
      });
      
      group.userData.width = w;
      group.userData.height = h;
      group.userData.plane = plane;
      group.visible = false;
      
      heldViewport = group;
      scene.add(heldViewport);
    }
    
    function toggleViewportFrame() {
      viewportEquipped = !viewportEquipped;
      document.getElementById('viewport-frame').classList.toggle('active', viewportEquipped);
      document.getElementById('viewport-panel').classList.toggle('active', viewportEquipped);
      
      ensureHeldViewport();
      if (heldViewport) {
        heldViewport.visible = viewportEquipped;
      }
      
      if (!viewportEquipped) {
        pluckMode = false;
        document.getElementById('toggle-pluck').classList.remove('active');
      }
    }
    
    function updatePluckCandidates() {
      // Restore original materials for previously highlighted objects
      pluckCandidates.forEach(obj => {
        obj.traverse(node => {
          if (node.isMesh && node.userData._originalMaterial) {
            // Restore the full original material (not just color)
            node.material = node.userData._originalMaterial;
            delete node.userData._originalMaterial;
            delete node.userData._originalColor;
            delete node.userData._originalEmissive;
          }
        });
      });
      pluckCandidates.clear();
      
      if (!viewportEquipped || !pluckMode) return;
      
      // Check which objects are fully within viewport frame
      const vpRect = document.getElementById('viewport-frame').getBoundingClientRect();
      
      // Special case: Add planetoid when at high altitude in rocket mode
      const altitude = rocketEnabled && rocketBody ? rocketBody.translation().y : 0;
      if (rocketEnabled && altitude > SPACE_ALTITUDE && planetoidMesh && planetoidMesh.visible) {
        pluckCandidates.add(planetoidMesh);
        planetoidMesh.userData.isPlanetoid = true;
        console.log('üåç Planetoid is pluckable from space!');
      }
      
      // Add buildings (entirely within frame)
      let buildingCount = 0;
      buildings.forEach(b => {
        if (b.mesh && isObjectInViewport(b.mesh, vpRect)) {
          pluckCandidates.add(b.mesh);
          buildingCount++;
          b.mesh.traverse(node => {
            if (node.isMesh && node.material && node.material.color) {
              // Store original material reference AND clone it for modification
              if (!node.userData._originalMaterial) {
                node.userData._originalMaterial = node.material;
                node.userData._originalColor = node.material.color.clone();
                node.userData._originalEmissive = node.material.emissiveIntensity || 0;
                // Clone material so we don't affect shared materials
                node.material = node.material.clone();
              }
              node.material.color.lerp(new THREE.Color(0xffeb3b), 0.3);
              node.material.emissiveIntensity = 0.2;
            }
          });
        }
      });
      if (buildingCount > 0) {
        console.log(`üè¢ ${buildingCount} building(s) fully in frame and pluckable!`);
      }
      
      // Add world objects (spawned physics objects)
      worldObjects.forEach(wo => {
        if (isObjectInViewport(wo.mesh, vpRect)) {
          pluckCandidates.add(wo.mesh);
          wo.mesh.traverse(node => {
            if (node.isMesh && node.material && node.material.color) {
              if (!node.userData._originalMaterial) {
                node.userData._originalMaterial = node.material;
                node.userData._originalColor = node.material.color.clone();
                node.userData._originalEmissive = node.material.emissiveIntensity || 0;
                node.material = node.material.clone();
              }
              node.material.color.lerp(new THREE.Color(0xffeb3b), 0.3);
              node.material.emissiveIntensity = 0.2;
            }
          });
        }
      });
      
      // Add pedestrians
      pedestrians.forEach(ped => {
        if (ped && ped.group && isObjectInViewport(ped.group, vpRect)) {
          pluckCandidates.add(ped.group);
          ped.group.traverse(node => {
            if (node.isMesh && node.material && node.material.color) {
              if (!node.userData._originalMaterial) {
                node.userData._originalMaterial = node.material;
                node.userData._originalColor = node.material.color.clone();
                node.userData._originalEmissive = node.material.emissiveIntensity || 0;
                node.material = node.material.clone();
              }
              node.material.color.lerp(new THREE.Color(0xffeb3b), 0.3);
              node.material.emissiveIntensity = 0.2;
            }
          });
        }
      });
    }
    
    function isObjectInViewport(obj, rect) {
      const box = new THREE.Box3().setFromObject(obj);
      const corners = [
        new THREE.Vector3(box.min.x, box.min.y, box.min.z),
        new THREE.Vector3(box.min.x, box.min.y, box.max.z),
        new THREE.Vector3(box.min.x, box.max.y, box.min.z),
        new THREE.Vector3(box.min.x, box.max.y, box.max.z),
        new THREE.Vector3(box.max.x, box.min.y, box.min.z),
        new THREE.Vector3(box.max.x, box.min.y, box.max.z),
        new THREE.Vector3(box.max.x, box.max.y, box.min.z),
        new THREE.Vector3(box.max.x, box.max.y, box.max.z)
      ];
      
      for (const corner of corners) {
        const projected = corner.clone().project(camera);
        const x = (projected.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-projected.y * 0.5 + 0.5) * window.innerHeight;
        
        if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {
          return false;
        }
      }
      return true;
    }
    
    function dropViewportSnapshot() {
      if (!droppedViewportRT) {
        droppedViewportRT = new THREE.WebGLRenderTarget(512, 288, { depthBuffer: true });
      }
      if (!droppedViewportCam) {
        droppedViewportCam = new THREE.PerspectiveCamera(camera.fov, 512/288, 0.05, 500);
      }
      
      // Capture current view
      droppedViewportCam.position.copy(camera.position);
      droppedViewportCam.quaternion.copy(camera.quaternion);
      
      if (!droppedViewport) {
        const group = new THREE.Group();
        const w = 1.6, h = 0.9;
        
        const planeMat = new THREE.MeshBasicMaterial({ 
          map: droppedViewportRT.texture,
          toneMapped: false
        });
        const planeGeo = new THREE.PlaneGeometry(w, h);
        const plane = new THREE.Mesh(planeGeo, planeMat);
        group.add(plane);
        
        // Frame
        const t = 0.04;
        const barMat = new THREE.MeshStandardMaterial({ 
          color: 0x6a9cff, 
          metalness: 0.2, 
          roughness: 0.5 
        });
        
        const topBar = new THREE.Mesh(new THREE.BoxGeometry(w, t, t), barMat);
        topBar.position.set(0, h/2 + t/2, 0);
        const botBar = new THREE.Mesh(new THREE.BoxGeometry(w, t, t), barMat);
        botBar.position.set(0, -h/2 - t/2, 0);
        const leftBar = new THREE.Mesh(new THREE.BoxGeometry(t, h + 2*t, t), barMat);
        leftBar.position.set(-w/2 - t/2, 0, 0);
        const rightBar = new THREE.Mesh(new THREE.BoxGeometry(t, h + 2*t, t), barMat);
        rightBar.position.set(w/2 + t/2, 0, 0);
        
        [topBar, botBar, leftBar, rightBar].forEach(b => group.add(b));
        
        group.userData.width = w;
        group.userData.height = h;
        group.userData.plane = plane;
        
        droppedViewport = group;
        worldRoot.add(droppedViewport);
      }
      
      // Position in front of camera
      const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
      droppedViewport.position.copy(camera.position).addScaledVector(forward, 2.5);
      droppedViewport.quaternion.copy(camera.quaternion);
      
      droppedViewportData = {
        dist0: 2.5,
        scale0: playerScale,
        normal: forward.clone()
      };
      
      document.getElementById('hud-mini').classList.add('active');
    }
    
    function retractViewportSnapshot() {
      if (droppedViewport) {
        worldRoot.remove(droppedViewport);
        droppedViewport = null;
        droppedViewportData = null;
      }
      document.getElementById('hud-mini').classList.remove('active');
    }
    
    // ==================== OBJECT PICKING & MANIPULATION ====================
    function clientToFrameLocal(frame, clientX, clientY) {
      if (!frame) return null;
      
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      
      const n = new THREE.Vector3(0, 0, 1).applyQuaternion(frame.quaternion);
      const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(n, frame.position);
      const hit = new THREE.Vector3();
      
      if (!raycaster.ray.intersectPlane(plane, hit)) return null;
      
      const inv = new THREE.Matrix4().copy(frame.matrixWorld).invert();
      const local = hit.clone().applyMatrix4(inv);
      
      const w = frame.userData.width || 1.2;
      const h = frame.userData.height || 0.7;
      local.x = THREE.MathUtils.clamp(local.x, -w/2, w/2);
      local.y = THREE.MathUtils.clamp(local.y, -h/2, h/2);
      local.z = 0;
      
      return local;
    }
    
    function selectPluckAt(clientX, clientY) {
      if (pluckCandidates.size === 0) return null;
      
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      
      // Find all meshes in candidates
      const candidateMeshes = [];
      pluckCandidates.forEach(obj => {
        obj.traverse(node => {
          if (node.isMesh) {
            candidateMeshes.push(node);
            // Store reference to parent
            node.userData._pluckParent = obj;
          }
        });
      });
      
      const hits = raycaster.intersectObjects(candidateMeshes, true);
      
      if (hits.length === 0) return null;
      
      // Return the first hit's parent candidate
      const firstHit = hits[0];
      const parent = firstHit.object.userData._pluckParent;
      
      if (parent) {
        return { object: parent, hit: firstHit };
      }
      
      return null;
    }
    
    function startDraggingObject(obj, clientX, clientY) {
      console.log('Starting drag on object:', obj);
      
      const camPos = new THREE.Vector3();
      camera.getWorldPosition(camPos);
      
      const objPos = new THREE.Vector3();
      obj.getWorldPosition(objPos);
      
      const activeFrame = heldViewport && heldViewport.visible ? heldViewport : droppedViewport;
      
      if (activeFrame) {
        // Position relative to frame
        draggingFrame = activeFrame;
        const local = clientToFrameLocal(activeFrame, clientX, clientY);
        
        if (local) {
          const worldOnPlane = local.clone().applyMatrix4(activeFrame.matrixWorld);
          const n = new THREE.Vector3(0, 0, 1).applyQuaternion(activeFrame.quaternion);
          
          // Calculate offset from plane
          const toObj = new THREE.Vector3().subVectors(objPos, worldOnPlane);
          const offsetDist = toObj.dot(n);
          
          draggingObject = {
            obj,
            frame: activeFrame,
            offset: Math.max(0.5, Math.abs(offsetDist))  // Minimum 0.5m offset
          };
          
          console.log('Frame drag mode, offset:', draggingObject.offset);
        }
      } else {
        // Free drag at fixed depth
        dragDepth = Math.max(5.0, camPos.distanceTo(objPos));  // Minimum 5m depth
        draggingObject = {
          obj,
          frame: null,
          offset: 0
        };
        
        console.log('Free drag mode, depth:', dragDepth);
      }
      
      // Suppress physics for this object
      suppressedPhysics.add(obj);
      
      // Mark object as being dragged (stops AI/updates for pedestrians, benches, etc.)
      obj.userData.isDragging = true;
      
      // Find and suppress physics body from worldObjects
      const worldObj = worldObjects.find(wo => wo.mesh === obj);
      if (worldObj && worldObj.body) {
        // Make kinematic while dragging
        worldObj.body.setBodyType(physics.RigidBodyType.KinematicPositionBased, true);
        console.log('Made world object kinematic');
      }
      
      // Find if this is a building and convert to dynamic
      const building = buildings.find(b => b.mesh === obj);
      if (building && building.body) {
        console.log(`üè¢ Plucking building! Converting to dynamic physics (${building.width.toFixed(1)}m √ó ${building.depth.toFixed(1)}m √ó ${building.height.toFixed(1)}m)`);
        
        // Remove old static body
        world.removeRigidBody(building.body);
        
        // Create new dynamic body
        const bodyDesc = physics.RigidBodyDesc.dynamic()
          .setTranslation(objPos.x, objPos.y, objPos.z)
          .setLinearDamping(2.0)
          .setAngularDamping(5.0);
        
        const newBody = world.createRigidBody(bodyDesc);
        
        // Add collider (approximate with box)
        const colliderDesc = physics.ColliderDesc.cuboid(
          building.width / 2,
          building.height / 2,
          building.depth / 2
        );
        world.createCollider(colliderDesc, newBody);
        
        // Make kinematic while dragging
        newBody.setBodyType(physics.RigidBodyType.KinematicPositionBased, true);
        
        building.body = newBody;
        building.isDynamic = true;
        
        console.log('‚úì Building is now pluckable and can be moved/dropped!');
      }
      
      // Remove from pluck candidates to avoid re-highlighting
      pluckCandidates.delete(obj);
    }
    
    function updateDraggingObject(clientX, clientY) {
      if (!draggingObject) return;
      
      const obj = draggingObject.obj;
      const frame = draggingObject.frame;
      
      let targetPos;
      
      if (frame) {
        // Drag in front of frame
        const local = clientToFrameLocal(frame, clientX, clientY);
        if (local) {
          const worldOnPlane = local.clone().applyMatrix4(frame.matrixWorld);
          const n = new THREE.Vector3(0, 0, 1).applyQuaternion(frame.quaternion);
          targetPos = worldOnPlane.clone().addScaledVector(n, draggingObject.offset);
        }
      } else {
        // Free drag at depth
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        
        targetPos = raycaster.ray.origin.clone()
          .addScaledVector(raycaster.ray.direction, dragDepth);
      }
      
      if (targetPos) {
        // Direct movement for better responsiveness
        obj.position.copy(targetPos);
        
        // Update physics body if exists (keep in sync with mesh during drag)
        const worldObj = worldObjects.find(wo => wo.mesh === obj);
        if (worldObj && worldObj.body) {
          worldObj.body.setTranslation({ x: targetPos.x, y: targetPos.y, z: targetPos.z }, true);
          // Zero out velocity while dragging
          worldObj.body.setLinvel({ x: 0, y: 0, z: 0 }, true);
          worldObj.body.setAngvel({ x: 0, y: 0, z: 0 }, true);
        }
        
        // Update building physics body
        const building = buildings.find(b => b.mesh === obj);
        if (building && building.body && building.isDynamic) {
          building.body.setTranslation({ x: targetPos.x, y: targetPos.y, z: targetPos.z }, true);
          // Zero out velocity while dragging
          building.body.setLinvel({ x: 0, y: 0, z: 0 }, true);
          building.body.setAngvel({ x: 0, y: 0, z: 0 }, true);
        }
      }
    }
    
    function stopDraggingObject() {
      if (!draggingObject) return;
      
      const obj = draggingObject.obj;
      
      // Get final position from mesh
      const finalPos = obj.getWorldPosition(new THREE.Vector3());
      
      // Restore physics
      suppressedPhysics.delete(obj);
      
      // Restore world object physics
      const worldObj = worldObjects.find(wo => wo.mesh === obj);
      if (worldObj && worldObj.body) {
        // First zero out all velocities while still kinematic
        worldObj.body.setLinvel({ x: 0, y: 0, z: 0 }, true);
        worldObj.body.setAngvel({ x: 0, y: 0, z: 0 }, true);
        
        // Update position
        worldObj.body.setTranslation({ x: finalPos.x, y: finalPos.y, z: finalPos.z }, true);
        
        // Set higher damping for dropped objects
        worldObj.body.setLinearDamping(5.0);
        worldObj.body.setAngularDamping(10.0);
        
        // Switch to dynamic
        worldObj.body.setBodyType(physics.RigidBodyType.Dynamic, true);
        
        // Zero velocities again after type change
        worldObj.body.setLinvel({ x: 0, y: 0, z: 0 }, true);
        worldObj.body.setAngvel({ x: 0, y: 0, z: 0 }, true);
        
        console.log('Released object at:', finalPos);
      }
      
      // Restore building physics
      const building = buildings.find(b => b.mesh === obj);
      if (building && building.body && building.isDynamic) {
        // First zero out all velocities while still kinematic
        building.body.setLinvel({ x: 0, y: 0, z: 0 }, true);
        building.body.setAngvel({ x: 0, y: 0, z: 0 }, true);
        
        // Update position
        building.body.setTranslation({ x: finalPos.x, y: finalPos.y, z: finalPos.z }, true);
        
        // Building damping already set to 2.0/5.0 during creation, which is good
        
        // Switch to dynamic
        building.body.setBodyType(physics.RigidBodyType.Dynamic, true);
        
        // Zero velocities again after type change
        building.body.setLinvel({ x: 0, y: 0, z: 0 }, true);
        building.body.setAngvel({ x: 0, y: 0, z: 0 }, true);
        
        console.log('Released building at:', finalPos);
      }
      
      // Check if object is being dropped into a container (jar, etc.)
      // Look for nearby jars/containers and parent the object to them
      const nearbyContainers = [];
      worldRoot.traverse(child => {
        if (child.userData.isContainer || child.userData.objectType === 'jar') {
          const containerPos = new THREE.Vector3();
          child.getWorldPosition(containerPos);
          const distance = finalPos.distanceTo(containerPos);
          
          // Check if object is within container bounds
          if (distance < 0.5) { // Within 0.5m is considered "in" the container
            nearbyContainers.push({ container: child, distance });
          }
        }
      });
      
      // If we found a nearby container, parent the object to it
      if (nearbyContainers.length > 0) {
        // Sort by distance and take the closest
        nearbyContainers.sort((a, b) => a.distance - b.distance);
        const targetContainer = nearbyContainers[0].container;
        
        console.log('Dropping', obj.userData.objectType, 'into container:', targetContainer.userData.objectType);
        
        // Remove from world scene
        if (obj.parent) {
          obj.parent.remove(obj);
        }
        
        // Convert world position to local position relative to container
        const containerWorldMatrix = new THREE.Matrix4();
        targetContainer.matrixWorld.decompose(
          new THREE.Vector3(),
          new THREE.Quaternion(),
          new THREE.Vector3()
        );
        
        // Get inverse of container's world matrix
        const invMatrix = new THREE.Matrix4().copy(targetContainer.matrixWorld).invert();
        const localPos = finalPos.clone().applyMatrix4(invMatrix);
        
        // Add as child to container
        targetContainer.add(obj);
        obj.position.copy(localPos);
        
        // Store original parent reference
        obj.userData.originalParent = worldRoot;
        obj.userData.containedIn = targetContainer;
        
        console.log('‚úÖ Object successfully parented to container');
      }
      
      // For objects without physics (pedestrians, benches, etc.), they stay where they are
      // Keep isDragging flag set so they don't resume AI movement
      // They will remain static at their dropped position
      
      console.log('Released object (type:', obj.userData.objectType, '), isDragging:', obj.userData.isDragging);
      
      draggingObject = null;
      draggingFrame = null;
    }
    
    function highlightObject(obj, highlight) {
      obj.traverse(node => {
        if (node.isMesh && node.material) {
          if (highlight) {
            // Save original material and colors only if not already saved
            if (!node.userData._originalMaterial) {
              node.userData._originalMaterial = node.material;
              node.userData._originalColor = node.material.color.clone();
              node.userData._originalEmissive = node.material.emissive ? node.material.emissive.clone() : new THREE.Color(0);
              node.userData._originalEmissiveIntensity = node.material.emissiveIntensity || 0;
              // Clone material to avoid affecting shared materials
              node.material = node.material.clone();
            }
            // Apply yellow highlight to the cloned material
            node.material.color.copy(node.userData._originalColor).lerp(new THREE.Color(0xffeb3b), 0.4);
            if (node.material.emissive) {
              node.material.emissive.set(0xffaa00);
              node.material.emissiveIntensity = 0.3;
            }
          } else {
            // Restore to original material
            if (node.userData._originalMaterial) {
              node.material = node.userData._originalMaterial;
              // Clean up saved data
              delete node.userData._originalMaterial;
              delete node.userData._originalColor;
              delete node.userData._originalEmissive;
              delete node.userData._originalEmissiveIntensity;
            }
          }
        }
      });
    }
    
    let hoveredObject = null;
    let hoverCheckThrottle = 0;
    
    function updateHoverHighlight(clientX, clientY) {
      if (!viewportEquipped || !pluckMode) {
        if (hoveredObject) {
          highlightObject(hoveredObject, false);
          hoveredObject = null;
        }
        return;
      }
      
      // Throttle hover checks to every 100ms
      const now = performance.now();
      if (now - hoverCheckThrottle < 100) return;
      hoverCheckThrottle = now;
      
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      
      // Check all pluckable objects (use cached meshes)
      let newHovered = null;
      let closestDist = Infinity;
      
      pluckCandidates.forEach(candidate => {
        if (!candidate.userData._cachedMeshes) {
          candidate.userData._cachedMeshes = [];
          candidate.traverse(node => {
            if (node.isMesh) candidate.userData._cachedMeshes.push(node);
          });
        }
        
        const hits = raycaster.intersectObjects(candidate.userData._cachedMeshes, false);
        if (hits.length > 0 && hits[0].distance < closestDist) {
          closestDist = hits[0].distance;
          newHovered = candidate;
        }
      });
      
      if (newHovered !== hoveredObject) {
        if (hoveredObject) {
          highlightObject(hoveredObject, false);
        }
        if (newHovered) {
          highlightObject(newHovered, true);
          
          // Show tooltip
          const tooltip = document.getElementById('tooltip');
          tooltip.textContent = 'Click to grab';
          tooltip.style.left = clientX + 'px';
          tooltip.style.top = clientY + 'px';
          tooltip.style.display = 'block';
        } else {
          document.getElementById('tooltip').style.display = 'none';
        }
        hoveredObject = newHovered;
      }
    }
    
    // ==================== PROCEDURAL ROOM GENERATION SYSTEM ====================
    let hallwayMode = false;
    let hallwaySegments = [];
    let hallwayGroup = new THREE.Group();
    const HALLWAY_SEGMENT_LENGTH = 20; // Length of each corridor segment (doubled for fewer segments)
    const HALLWAY_WIDTH = 3; // Width of hallway
    const HALLWAY_HEIGHT = 3; // Height of hallway
    const NUM_HALLWAY_SEGMENTS = 3; // Number of segments to maintain (reduced from 5)
    
    // Track generated rooms for proper placement
    let generatedRooms = [];
    let roomLayoutPlan = null;
    let segmentHistory = []; // Track segment configurations for backward navigation
    let nextSegmentId = 0; // Unique ID for each segment
    
    // Ultra-simple shared materials for hallway (minimal material count)
    const hallwaySharedMaterials = {
      floor: new THREE.MeshBasicMaterial({ color: 0x8B7355 }),
      wall: new THREE.MeshBasicMaterial({ color: 0xD4C5B9 }),
      door: new THREE.MeshBasicMaterial({ color: 0x654321 })
    }
    
    // ==================== ROOM PLANNING ORCHESTRATOR ====================
    
    // Room type definitions with size requirements
    const ROOM_TYPES = {
      mainroom: { minWidth: 10, minDepth: 8, priority: 1 },
      bedroom: { minWidth: 5, minDepth: 5, priority: 2 },
      bathroom: { minWidth: 3, minDepth: 3, priority: 3 },
      entryway: { minWidth: 3, minDepth: 2, priority: 4 },
      closet: { minWidth: 2, minDepth: 1.5, priority: 5 }
    };
    
    // Layout templates define how rooms connect
    const LAYOUT_TEMPLATES = {
      simple: {
        name: 'Simple Studio',
        rooms: ['entryway', 'mainroom', 'bathroom']
      },
      twoRoom: {
        name: 'Two Room',
        rooms: ['entryway', 'mainroom', 'bedroom', 'bathroom']
      },
      threeRoom: {
        name: 'Three Room',
        rooms: ['entryway', 'mainroom', 'bedroom', 'bedroom', 'bathroom']
      },
      fourRoom: {
        name: 'Four Room Suite',
        rooms: ['entryway', 'mainroom', 'bedroom', 'bedroom', 'bedroom', 'bathroom', 'bathroom']
      }
    };
    
    class RoomPlan {
      constructor(x, z, width, depth, type, doorSide) {
        this.x = x;
        this.z = z;
        this.width = width;
        this.depth = depth;
        this.type = type;
        this.doorSide = doorSide; // 'north', 'south', 'east', 'west'
        this.doorPosition = null; // Calculated position of door
        this.connections = []; // Connected rooms
        this.furniture = [];
        this.bounds = {
          minX: x - width / 2,
          maxX: x + width / 2,
          minZ: z - depth / 2,
          maxZ: z + depth / 2
        };
      }
      
      intersects(other) {
        return !(this.bounds.maxX < other.bounds.minX ||
                this.bounds.minX > other.bounds.maxX ||
                this.bounds.maxZ < other.bounds.minZ ||
                this.bounds.minZ > other.bounds.maxZ);
      }
      
      adjacent(other) {
        // Check if rooms share a wall
        const xAligned = Math.abs(this.bounds.maxX - other.bounds.minX) < 0.1 ||
                        Math.abs(this.bounds.minX - other.bounds.maxX) < 0.1;
        const zAligned = Math.abs(this.bounds.maxZ - other.bounds.minZ) < 0.1 ||
                        Math.abs(this.bounds.minZ - other.bounds.maxZ) < 0.1;
        
        if (xAligned) {
          // Check z overlap
          return !(this.bounds.maxZ < other.bounds.minZ || this.bounds.minZ > other.bounds.maxZ);
        }
        if (zAligned) {
          // Check x overlap
          return !(this.bounds.maxX < other.bounds.minX || this.bounds.minX > other.bounds.maxX);
        }
        return false;
      }
      
      getWallCenter(side) {
        switch(side) {
          case 'north': return { x: this.x, z: this.bounds.minZ };
          case 'south': return { x: this.x, z: this.bounds.maxZ };
          case 'east': return { x: this.bounds.maxX, z: this.z };
          case 'west': return { x: this.bounds.minX, z: this.z };
          default: return { x: this.x, z: this.z };
        }
      }
    }
    
    function generateRoomLayout(templateName) {
      const template = LAYOUT_TEMPLATES[templateName] || LAYOUT_TEMPLATES.twoRoom;
      const rooms = [];
      
      // Start with main room at origin
      const mainRoom = new RoomPlan(0, 0, 12, 10, 'mainroom', 'south');
      rooms.push(mainRoom);
      
      // Add entryway at front (south)
      if (template.rooms.includes('entryway')) {
        const entryway = new RoomPlan(0, mainRoom.bounds.maxZ + 1.5, 4, 3, 'entryway', 'south');
        entryway.connections.push(mainRoom);
        mainRoom.connections.push(entryway);
        rooms.push(entryway);
      }
      
      // Add bedrooms
      const bedrooms = template.rooms.filter(r => r === 'bedroom');
      let bedroomXOffset = -mainRoom.width / 2;
      let bedroomZ = mainRoom.bounds.minZ - 2.5;
      
      bedrooms.forEach((_, idx) => {
        const bedroomWidth = 6;
        const bedroomDepth = 5;
        const bedroomX = bedroomXOffset + bedroomWidth / 2;
        
        const bedroom = new RoomPlan(bedroomX, bedroomZ, bedroomWidth, bedroomDepth, 'bedroom', 'south');
        bedroom.connections.push(mainRoom);
        mainRoom.connections.push(bedroom);
        rooms.push(bedroom);
        
        bedroomXOffset += bedroomWidth; // Place next bedroom adjacent
      });
      
      // Add bathrooms
      const bathrooms = template.rooms.filter(r => r === 'bathroom');
      bathrooms.forEach((_, idx) => {
        const bathroomX = mainRoom.bounds.maxX + 2;
        const bathroomZ = mainRoom.z + (idx - 0.5) * 4;
        const bathroom = new RoomPlan(bathroomX, bathroomZ, 4, 4, 'bathroom', 'west');
        bathroom.connections.push(mainRoom);
        mainRoom.connections.push(bathroom);
        rooms.push(bathroom);
      });
      
      // Validate no clipping
      for (let i = 0; i < rooms.length; i++) {
        for (let j = i + 1; j < rooms.length; j++) {
          if (rooms[i].intersects(rooms[j]) && !rooms[i].adjacent(rooms[j])) {
            console.warn(`Room ${i} (${rooms[i].type}) intersects with room ${j} (${rooms[j].type})`);
          }
        }
      }
      
      console.log(`Generated layout: ${template.name} with ${rooms.length} rooms`);
      return rooms;
    }
    
    function placeFurnitureInRoom(room) {
      const furniture = [];
      const doorWall = room.doorSide;
      
      // Determine opposite wall for main furniture
      const oppositeWall = {
        'north': 'south',
        'south': 'north',
        'east': 'west',
        'west': 'east'
      }[doorWall];
      
      switch(room.type) {
        case 'bedroom':
          // Bed against opposite wall from door
          const bedPos = room.getWallCenter(oppositeWall);
          const bedOffset = oppositeWall === 'north' ? 0.5 : oppositeWall === 'south' ? -0.5 :
                           oppositeWall === 'west' ? 0.5 : -0.5;
          furniture.push({
            type: 'bed',
            x: bedPos.x + (oppositeWall === 'east' || oppositeWall === 'west' ? bedOffset : 0),
            z: bedPos.z + (oppositeWall === 'north' || oppositeWall === 'south' ? bedOffset : 0),
            rotation: oppositeWall === 'north' ? Math.PI : oppositeWall === 'south' ? 0 :
                     oppositeWall === 'west' ? Math.PI / 2 : -Math.PI / 2
          });
          
          // Bedside table next to bed
          furniture.push({
            type: 'sidetable',
            x: bedPos.x + 1.2,
            z: bedPos.z,
            rotation: 0
          });
          
          // Closet in corner
          const cornerX = room.bounds.minX + 0.5;
          const cornerZ = doorWall === 'south' ? room.bounds.minZ + 0.5 : room.bounds.maxZ - 0.5;
          furniture.push({
            type: 'closet',
            x: cornerX,
            z: cornerZ,
            rotation: 0
          });
          break;
          
        case 'bathroom':
          // Toilet in corner
          furniture.push({
            type: 'toilet',
            x: room.bounds.minX + 0.8,
            z: room.bounds.minZ + 0.8,
            rotation: 0
          });
          
          // Shower in opposite corner
          furniture.push({
            type: 'shower',
            x: room.bounds.maxX - 0.6,
            z: room.bounds.minZ + 0.6,
            rotation: 0
          });
          
          // Sink along wall
          furniture.push({
            type: 'bathroomsink',
            x: room.x,
            z: room.bounds.maxZ - 0.5,
            rotation: Math.PI
          });
          break;
          
        case 'mainroom':
          // Living area - couch against wall
          furniture.push({
            type: 'couch',
            x: room.bounds.minX + 2,
            z: room.z,
            rotation: Math.PI / 2
          });
          
          furniture.push({
            type: 'coffeetable',
            x: room.bounds.minX + 3.5,
            z: room.z,
            rotation: 0,
            shape: 'rectangle'
          });
          
          furniture.push({
            type: 'tvstand',
            x: room.bounds.minX + 5.5,
            z: room.z,
            rotation: -Math.PI / 2
          });
          
          furniture.push({
            type: 'tv',
            x: room.bounds.minX + 5.5,
            z: room.z,
            y: 0.55,
            rotation: -Math.PI / 2
          });
          
          // Kitchen area
          furniture.push({
            type: 'counter',
            x: room.bounds.maxX - 2,
            z: room.bounds.minZ + 2,
            rotation: 0
          });
          
          furniture.push({
            type: 'fridge',
            x: room.bounds.maxX - 1,
            z: room.bounds.minZ + 1,
            rotation: Math.PI
          });
          
          furniture.push({
            type: 'microwave',
            x: room.bounds.maxX - 2,
            z: room.bounds.minZ + 2,
            y: 0.95,
            rotation: 0
          });
          break;
          
        case 'entryway':
          // Small table
          furniture.push({
            type: 'sidetable',
            x: room.bounds.minX + 0.8,
            z: room.z,
            rotation: 0
          });
          
          // Art on wall
          furniture.push({
            type: 'artframe',
            x: room.bounds.maxX - 0.2,
            z: room.z,
            y: 1.5,
            rotation: Math.PI / 2,
            size: 'medium',
            wallMount: true
          });
          break;
      }
      
      return furniture;
    }
    
    function createHallwaySegment(zPosition, hasLeftDoor, hasRightDoor) {
      const segment = new THREE.Group();
      segment.userData.zPosition = zPosition;
      
      // Create single merged geometry for entire segment
      const geometries = [];
      
      // Floor
      const floorGeo = new THREE.PlaneGeometry(HALLWAY_WIDTH, HALLWAY_SEGMENT_LENGTH);
      floorGeo.rotateX(-Math.PI / 2);
      floorGeo.translate(0, 0, zPosition - HALLWAY_SEGMENT_LENGTH / 2);
      geometries.push(floorGeo);
      
      // Ceiling (same material as floor for simplicity)
      const ceilingGeo = new THREE.PlaneGeometry(HALLWAY_WIDTH, HALLWAY_SEGMENT_LENGTH);
      ceilingGeo.rotateX(Math.PI / 2);
      ceilingGeo.translate(0, HALLWAY_HEIGHT, zPosition - HALLWAY_SEGMENT_LENGTH / 2);
      geometries.push(ceilingGeo);
      
      // Walls - simple planes, no doors for performance
      const leftWallGeo = new THREE.PlaneGeometry(HALLWAY_SEGMENT_LENGTH, HALLWAY_HEIGHT);
      leftWallGeo.rotateY(Math.PI / 2);
      leftWallGeo.translate(-HALLWAY_WIDTH / 2, HALLWAY_HEIGHT / 2, zPosition - HALLWAY_SEGMENT_LENGTH / 2);
      
      const rightWallGeo = new THREE.PlaneGeometry(HALLWAY_SEGMENT_LENGTH, HALLWAY_HEIGHT);
      rightWallGeo.rotateY(-Math.PI / 2);
      rightWallGeo.translate(HALLWAY_WIDTH / 2, HALLWAY_HEIGHT / 2, zPosition - HALLWAY_SEGMENT_LENGTH / 2);
      
      // Merge all floor/ceiling geometry
      const mergedFloors = BufferGeometryUtils.mergeGeometries(geometries);
      const floorMesh = new THREE.Mesh(mergedFloors, hallwaySharedMaterials.floor);
      floorMesh.receiveShadow = false;
      floorMesh.castShadow = false;
      segment.add(floorMesh);
      
      // Add walls as separate mesh (different material)
      const wallsGeometry = BufferGeometryUtils.mergeGeometries([leftWallGeo, rightWallGeo]);
      const wallsMesh = new THREE.Mesh(wallsGeometry, hallwaySharedMaterials.wall);
      wallsMesh.receiveShadow = false;
      wallsMesh.castShadow = false;
      segment.add(wallsMesh);
      
      // Optional: Add simple door marker if specified
      if (hasLeftDoor || hasRightDoor) {
        const doorGeo = new THREE.BoxGeometry(1, 2, 0.1);
        if (hasLeftDoor) {
          doorGeo.translate(-HALLWAY_WIDTH / 2, 1, zPosition - HALLWAY_SEGMENT_LENGTH / 2);
        } else {
          doorGeo.translate(HALLWAY_WIDTH / 2, 1, zPosition - HALLWAY_SEGMENT_LENGTH / 2);
        }
        const doorMesh = new THREE.Mesh(doorGeo, hallwaySharedMaterials.door);
        doorMesh.castShadow = false;
        segment.add(doorMesh);
      }
      
      return segment;
    }
    
    // Removed: createWallWithDoorFrame - no longer needed with simplified hallway
    
    function createWallWithDoorFrame_UNUSED(parent, xPos, zPos, side) {
      // Function removed - hallway simplified
      return;
      
      // Wall segments above and beside door
      // Bottom wall (if door doesn't go to floor)
      const aboveWallGeo = new THREE.PlaneGeometry(HALLWAY_SEGMENT_LENGTH, HALLWAY_HEIGHT - doorHeight);
      const aboveWall = new THREE.Mesh(aboveWallGeo, wallMat);
      aboveWall.rotation.y = side === 'left' ? Math.PI / 2 : -Math.PI / 2;
      aboveWall.position.set(xPos, doorHeight + (HALLWAY_HEIGHT - doorHeight) / 2, zPos);
      aboveWall.receiveShadow = true;
      aboveWall.castShadow = true;
      parent.add(aboveWall);
      
      // Side walls (left and right of door)
      const sideWidth = (HALLWAY_SEGMENT_LENGTH - doorWidth) / 2;
      if (sideWidth > 0) {
        const leftSideGeo = new THREE.PlaneGeometry(sideWidth, HALLWAY_HEIGHT);
        const leftSide = new THREE.Mesh(leftSideGeo, wallMat);
        leftSide.rotation.y = side === 'left' ? Math.PI / 2 : -Math.PI / 2;
        leftSide.position.set(xPos, HALLWAY_HEIGHT / 2, zPos - HALLWAY_SEGMENT_LENGTH / 2 + sideWidth / 2);
        leftSide.receiveShadow = true;
        leftSide.castShadow = true;
        parent.add(leftSide);
        
        const rightSide = new THREE.Mesh(leftSideGeo, wallMat);
        rightSide.rotation.y = side === 'left' ? Math.PI / 2 : -Math.PI / 2;
        rightSide.position.set(xPos, HALLWAY_HEIGHT / 2, zPos + HALLWAY_SEGMENT_LENGTH / 2 - sideWidth / 2);
        rightSide.receiveShadow = true;
        rightSide.castShadow = true;
        parent.add(rightSide);
      }
      
      // Door frame
      const frameThick = 0.08;
      const frameDepth = wallThickness + 0.02;
      
      // Vertical frame pieces
      const vertFrameGeo = new THREE.BoxGeometry(frameThick, doorHeight, frameDepth);
      [-doorWidth / 2, doorWidth / 2].forEach((offset) => {
        const vertFrame = new THREE.Mesh(vertFrameGeo, frameMat);
        vertFrame.position.set(
          xPos + (side === 'left' ? -frameDepth / 2 : frameDepth / 2),
          doorHeight / 2,
          zPos + offset
        );
        vertFrame.castShadow = true;
        parent.add(vertFrame);
      });
      
      // Horizontal top frame
      const horizFrameGeo = new THREE.BoxGeometry(frameThick, doorWidth + frameThick * 2, frameDepth);
      const topFrame = new THREE.Mesh(horizFrameGeo, frameMat);
      topFrame.rotation.z = Math.PI / 2;
      topFrame.position.set(
        xPos + (side === 'left' ? -frameDepth / 2 : frameDepth / 2),
        doorHeight,
        zPos
      );
      topFrame.castShadow = true;
      parent.add(topFrame);
    }
    
    function createAdjacentRoom(side, zPosition) {
      const roomGroup = new THREE.Group();
      const roomWidth = 6;
      const roomDepth = 5;
      const roomX = side === 'left' ? -(HALLWAY_WIDTH / 2 + roomWidth / 2) : (HALLWAY_WIDTH / 2 + roomWidth / 2);
      
      // Room floor
      const floorGeo = new THREE.PlaneGeometry(roomWidth, roomDepth);
      const floor = new THREE.Mesh(floorGeo, hallwaySharedMaterials.roomFloorMain);
      floor.rotation.x = -Math.PI / 2;
      floor.position.set(roomX, 0, zPosition);
      floor.receiveShadow = true;
      roomGroup.add(floor);
      
      // Room ceiling
      const ceilingGeo = new THREE.PlaneGeometry(roomWidth, roomDepth);
      const ceiling = new THREE.Mesh(ceilingGeo, hallwaySharedMaterials.ceiling);
      ceiling.rotation.x = Math.PI / 2;
      ceiling.position.set(roomX, HALLWAY_HEIGHT, zPosition);
      roomGroup.add(ceiling);
      
      // Room walls (3 walls, 4th connects to hallway)
      const wallMat = hallwaySharedMaterials.wall;
      
      // Back wall
      const backWallGeo = new THREE.PlaneGeometry(roomWidth, HALLWAY_HEIGHT);
      const backWall = new THREE.Mesh(backWallGeo, wallMat);
      backWall.position.set(roomX, HALLWAY_HEIGHT / 2, zPosition + (side === 'left' ? -roomDepth / 2 : roomDepth / 2));
      backWall.rotation.y = side === 'left' ? 0 : Math.PI;
      backWall.castShadow = true;
      roomGroup.add(backWall);
      
      // Side walls
      const sideWallGeo = new THREE.PlaneGeometry(roomDepth, HALLWAY_HEIGHT);
      const leftSideWall = new THREE.Mesh(sideWallGeo, wallMat);
      leftSideWall.rotation.y = side === 'left' ? -Math.PI / 2 : Math.PI / 2;
      leftSideWall.position.set(
        roomX + (side === 'left' ? -roomWidth / 2 : roomWidth / 2),
        HALLWAY_HEIGHT / 2,
        zPosition
      );
      leftSideWall.castShadow = true;
      roomGroup.add(leftSideWall);
      
      const rightSideWall = new THREE.Mesh(sideWallGeo, wallMat);
      rightSideWall.rotation.y = side === 'left' ? Math.PI / 2 : -Math.PI / 2;
      rightSideWall.position.set(
        roomX + (side === 'left' ? roomWidth / 2 : -roomWidth / 2),
        HALLWAY_HEIGHT / 2,
        zPosition
      );
      rightSideWall.castShadow = true;
      roomGroup.add(rightSideWall);
      
      // Add simple furniture (bed or desk)
      const furnitureType = Math.random() > 0.5 ? 'bed' : 'desk';
      if (furnitureType === 'bed') {
        const bedGeo = new THREE.BoxGeometry(1.5, 0.5, 2);
        const bed = new THREE.Mesh(bedGeo, hallwaySharedMaterials.bed);
        bed.position.set(roomX, 0.25, zPosition);
        bed.castShadow = true;
        roomGroup.add(bed);
      } else {
        const deskGeo = new THREE.BoxGeometry(1.0, 0.05, 0.6);
        const desk = new THREE.Mesh(deskGeo, hallwaySharedMaterials.furniture);
        desk.position.set(roomX, 0.75, zPosition);
        desk.castShadow = true;
        roomGroup.add(desk);
      }
      
      // Add ceiling light
      const lightGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.08, 16);
      const light = new THREE.Mesh(lightGeo, hallwaySharedMaterials.light);
      light.position.set(roomX, HALLWAY_HEIGHT - 0.04, zPosition);
      roomGroup.add(light);
      
      const pointLight = new THREE.PointLight(0xFFFFDD, 0.6, roomWidth);
      pointLight.position.set(roomX, HALLWAY_HEIGHT - 0.3, zPosition);
      roomGroup.add(pointLight);
      
      return roomGroup;
    }
    
    function buildRoomFromPlan(roomPlan) {
      const roomGroup = new THREE.Group();
      
      // Floor - use shared materials
      const floorGeo = new THREE.PlaneGeometry(roomPlan.width, roomPlan.depth);
      const floorMaterials = {
        mainroom: hallwaySharedMaterials.roomFloorMain,
        bedroom: hallwaySharedMaterials.roomFloorBedroom,
        bathroom: hallwaySharedMaterials.roomFloorBathroom,
        entryway: hallwaySharedMaterials.roomFloorEntry
      };
      const floorMat = floorMaterials[roomPlan.type] || hallwaySharedMaterials.roomFloorMain;
      const floor = new THREE.Mesh(floorGeo, floorMat);
      floor.rotation.x = -Math.PI / 2;
      floor.position.set(roomPlan.x, 0, roomPlan.z);
      floor.receiveShadow = true;
      roomGroup.add(floor);
      
      // Ceiling
      const ceilingGeo = new THREE.PlaneGeometry(roomPlan.width, roomPlan.depth);
      const ceiling = new THREE.Mesh(ceilingGeo, hallwaySharedMaterials.roomCeiling);
      ceiling.rotation.x = Math.PI / 2;
      ceiling.position.set(roomPlan.x, HALLWAY_HEIGHT, roomPlan.z);
      ceiling.receiveShadow = true;
      roomGroup.add(ceiling);
      
      // Walls (with door cutouts for connected rooms)
      const wallMat = hallwaySharedMaterials.wall;
      const wallThickness = 0.1;
      const doorWidth = 1.0;
      const doorHeight = 2.0;
      
      // Check each wall for connections
      const walls = ['north', 'south', 'east', 'west'];
      walls.forEach(wall => {
        const hasConnection = roomPlan.connections.some(connectedRoom => {
          // Check if this wall connects to the connected room
          if (wall === 'north') return Math.abs(roomPlan.bounds.minZ - connectedRoom.bounds.maxZ) < 0.2;
          if (wall === 'south') return Math.abs(roomPlan.bounds.maxZ - connectedRoom.bounds.minZ) < 0.2;
          if (wall === 'east') return Math.abs(roomPlan.bounds.maxX - connectedRoom.bounds.minX) < 0.2;
          if (wall === 'west') return Math.abs(roomPlan.bounds.minX - connectedRoom.bounds.maxX) < 0.2;
          return false;
        });
        
        if (hasConnection && wall === roomPlan.doorSide) {
          // Create wall with door cutout
          createWallWithDoor(roomGroup, roomPlan, wall, doorWidth, doorHeight, wallThickness, wallMat);
        } else {
          // Solid wall
          createSolidWall(roomGroup, roomPlan, wall, wallThickness, wallMat);
        }
      });
      
      // Add ceiling light
      const lightGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.08, 16);
      const light = new THREE.Mesh(lightGeo, hallwaySharedMaterials.light);
      light.position.set(roomPlan.x, HALLWAY_HEIGHT - 0.04, roomPlan.z);
      roomGroup.add(light);
      
      const pointLight = new THREE.PointLight(0xFFFFDD, 0.8, Math.max(roomPlan.width, roomPlan.depth));
      pointLight.position.set(roomPlan.x, HALLWAY_HEIGHT - 0.3, roomPlan.z);
      pointLight.castShadow = true;
      roomGroup.add(pointLight);
      
      // Place furniture
      const furniture = placeFurnitureInRoom(roomPlan);
      furniture.forEach(spec => {
        const furnitureObj = createProceduralFurniture(spec);
        if (furnitureObj) roomGroup.add(furnitureObj);
      });
      
      return roomGroup;
    }
    
    function createSolidWall(parent, room, wall, thickness, material) {
      let wallGeo, wallPos;
      
      if (wall === 'north' || wall === 'south') {
        wallGeo = new THREE.BoxGeometry(room.width, HALLWAY_HEIGHT, thickness);
        wallPos = {
          x: room.x,
          y: HALLWAY_HEIGHT / 2,
          z: wall === 'north' ? room.bounds.minZ : room.bounds.maxZ
        };
      } else {
        wallGeo = new THREE.BoxGeometry(thickness, HALLWAY_HEIGHT, room.depth);
        wallPos = {
          x: wall === 'west' ? room.bounds.minX : room.bounds.maxX,
          y: HALLWAY_HEIGHT / 2,
          z: room.z
        };
      }
      
      const wallMesh = new THREE.Mesh(wallGeo, material);
      wallMesh.position.set(wallPos.x, wallPos.y, wallPos.z);
      wallMesh.castShadow = true;
      wallMesh.receiveShadow = true;
      parent.add(wallMesh);
    }
    
    function createWallWithDoor(parent, room, wall, doorWidth, doorHeight, thickness, material) {
      const frameMat = hallwaySharedMaterials.frame;
      
      let wallLength = (wall === 'north' || wall === 'south') ? room.width : room.depth;
      let sideLength = (wallLength - doorWidth) / 2;
      
      if (sideLength > 0.1) {
        // Left side of door
        let geo1, pos1, geo2, pos2;
        
        if (wall === 'north' || wall === 'south') {
          geo1 = new THREE.BoxGeometry(sideLength, HALLWAY_HEIGHT, thickness);
          geo2 = new THREE.BoxGeometry(sideLength, HALLWAY_HEIGHT, thickness);
          const z = wall === 'north' ? room.bounds.minZ : room.bounds.maxZ;
          pos1 = { x: room.bounds.minX + sideLength / 2, y: HALLWAY_HEIGHT / 2, z };
          pos2 = { x: room.bounds.maxX - sideLength / 2, y: HALLWAY_HEIGHT / 2, z };
        } else {
          geo1 = new THREE.BoxGeometry(thickness, HALLWAY_HEIGHT, sideLength);
          geo2 = new THREE.BoxGeometry(thickness, HALLWAY_HEIGHT, sideLength);
          const x = wall === 'west' ? room.bounds.minX : room.bounds.maxX;
          pos1 = { x, y: HALLWAY_HEIGHT / 2, z: room.bounds.minZ + sideLength / 2 };
          pos2 = { x, y: HALLWAY_HEIGHT / 2, z: room.bounds.maxZ - sideLength / 2 };
        }
        
        const wall1 = new THREE.Mesh(geo1, material);
        wall1.position.set(pos1.x, pos1.y, pos1.z);
        wall1.castShadow = true;
        parent.add(wall1);
        
        const wall2 = new THREE.Mesh(geo2, material);
        wall2.position.set(pos2.x, pos2.y, pos2.z);
        wall2.castShadow = true;
        parent.add(wall2);
      }
      
      // Wall above door
      let aboveGeo, abovePos;
      if (wall === 'north' || wall === 'south') {
        aboveGeo = new THREE.BoxGeometry(doorWidth, HALLWAY_HEIGHT - doorHeight, thickness);
        const z = wall === 'north' ? room.bounds.minZ : room.bounds.maxZ;
        abovePos = { x: room.x, y: doorHeight + (HALLWAY_HEIGHT - doorHeight) / 2, z };
      } else {
        aboveGeo = new THREE.BoxGeometry(thickness, HALLWAY_HEIGHT - doorHeight, doorWidth);
        const x = wall === 'west' ? room.bounds.minX : room.bounds.maxX;
        abovePos = { x, y: doorHeight + (HALLWAY_HEIGHT - doorHeight) / 2, z: room.z };
      }
      
      const aboveWall = new THREE.Mesh(aboveGeo, material);
      aboveWall.position.set(abovePos.x, abovePos.y, abovePos.z);
      aboveWall.castShadow = true;
      parent.add(aboveWall);
      
      // Door frame
      const frameThick = 0.08;
      if (wall === 'north' || wall === 'south') {
        const z = wall === 'north' ? room.bounds.minZ : room.bounds.maxZ;
        // Vertical frames
        [-doorWidth / 2, doorWidth / 2].forEach(offset => {
          const frameGeo = new THREE.BoxGeometry(frameThick, doorHeight, thickness + 0.02);
          const frame = new THREE.Mesh(frameGeo, frameMat);
          frame.position.set(room.x + offset, doorHeight / 2, z);
          frame.castShadow = true;
          parent.add(frame);
        });
        
        // Top frame
        const topFrameGeo = new THREE.BoxGeometry(doorWidth + frameThick * 2, frameThick, thickness + 0.02);
        const topFrame = new THREE.Mesh(topFrameGeo, frameMat);
        topFrame.position.set(room.x, doorHeight, z);
        topFrame.castShadow = true;
        parent.add(topFrame);
      } else {
        const x = wall === 'west' ? room.bounds.minX : room.bounds.maxX;
        // Vertical frames
        [-doorWidth / 2, doorWidth / 2].forEach(offset => {
          const frameGeo = new THREE.BoxGeometry(thickness + 0.02, doorHeight, frameThick);
          const frame = new THREE.Mesh(frameGeo, frameMat);
          frame.position.set(x, doorHeight / 2, room.z + offset);
          frame.castShadow = true;
          parent.add(frame);
        });
        
        // Top frame
        const topFrameGeo = new THREE.BoxGeometry(thickness + 0.02, frameThick, doorWidth + frameThick * 2);
        const topFrame = new THREE.Mesh(topFrameGeo, frameMat);
        topFrame.position.set(x, doorHeight, room.z);
        topFrame.castShadow = true;
        parent.add(topFrame);
      }
    }
    
    function createProceduralFurniture(spec) {
      // Simple furniture creation for procedural rooms
      const group = new THREE.Group();
      
      switch(spec.type) {
        case 'bed':
          const bedGeo = new THREE.BoxGeometry(1.5, 0.5, 2);
          const bed = new THREE.Mesh(bedGeo, hallwaySharedMaterials.bed);
          bed.position.y = 0.25;
          bed.castShadow = true;
          group.add(bed);
          break;
          
        case 'couch':
          const couchGeo = new THREE.BoxGeometry(2, 0.8, 0.8);
          const couch = new THREE.Mesh(couchGeo, hallwaySharedMaterials.couch);
          couch.position.y = 0.4;
          couch.castShadow = true;
          group.add(couch);
          break;
          
        case 'coffeetable':
          const tableGeo = new THREE.BoxGeometry(1, 0.05, 0.6);
          const table = new THREE.Mesh(tableGeo, hallwaySharedMaterials.furniture);
          table.position.y = 0.4;
          table.castShadow = true;
          group.add(table);
          break;
          
        default:
          return null;
      }
      
      group.position.set(spec.x, spec.y || 0, spec.z);
      group.rotation.y = spec.rotation || 0;
      return group;
    }
    
    function createSegmentConfiguration(zPosition) {
      // Randomly determine door placements for this segment
      const segmentId = nextSegmentId++;
      const hasLeftDoor = Math.random() < 0.4; // 40% chance
      const hasRightDoor = Math.random() < 0.4; // 40% chance
      
      // Generate room layouts for doors
      const leftRoomLayout = hasLeftDoor ? generateRandomRoomLayout() : null;
      const rightRoomLayout = hasRightDoor ? generateRandomRoomLayout() : null;
      
      return {
        id: segmentId,
        zPosition,
        hasLeftDoor,
        hasRightDoor,
        leftRoomLayout,
        rightRoomLayout
      };
    }
    
    function generateRandomRoomLayout() {
      // Select random layout template
      const templateNames = Object.keys(LAYOUT_TEMPLATES);
      const randomTemplate = templateNames[Math.floor(Math.random() * templateNames.length)];
      return generateRoomLayout(randomTemplate);
    }
    
    function buildSegmentFromConfig(config) {
      // Ultra-simple: just create the corridor, no complex rooms
      const corridor = createHallwaySegment(config.zPosition, config.hasLeftDoor, config.hasRightDoor);
      corridor.userData.segmentId = config.id;
      corridor.userData.zPosition = config.zPosition;
      return corridor;
    }
    
    // Removed complex room generation - hallway is now simple corridor only
    
    function generateHallway() {
      // Clear existing hallway
      hallwayGroup.clear();
      hallwaySegments = [];
      generatedRooms = [];
      segmentHistory = [];
      nextSegmentId = 0;
      
      // Create initial segments
      for (let i = 0; i < NUM_HALLWAY_SEGMENTS; i++) {
        const zPos = -i * HALLWAY_SEGMENT_LENGTH;
        const config = createSegmentConfiguration(zPos);
        const segment = buildSegmentFromConfig(config);
        
        hallwayGroup.add(segment);
        hallwaySegments.push(segment);
        segmentHistory.push(config);
      }
      
      // IMPORTANT: Add hallwayGroup directly to SCENE, not worldRoot
      // Hallway should only be used in interior mode where worldRoot is hidden
      hallwayGroup.visible = true;
      hallwayGroup.position.set(0, 0, 0);
      hallwayGroup.scale.set(1, 1, 1);
      scene.add(hallwayGroup);
      
      console.log(`Infinite hallway initialized with ${NUM_HALLWAY_SEGMENTS} segments`);
      console.log('hallwayGroup added to scene, children count:', hallwayGroup.children.length);
    }
    
    function updateHallway() {
      if (!hallwayMode || !playerBody) return;
      
      const playerPos = playerBody.translation();
      const playerZ = playerPos.z;
      
      // Sort segments by Z position
      hallwaySegments.sort((a, b) => a.userData.zPosition - b.userData.zPosition);
      
      // Check if player has moved far enough forward to recycle a segment
      const furthestBackSegment = hallwaySegments[hallwaySegments.length - 1];
      const furthestForwardSegment = hallwaySegments[0];
      
      // MOVING FORWARD: Recycle back segment and create new forward segment
      if (playerZ < furthestForwardSegment.userData.zPosition - HALLWAY_SEGMENT_LENGTH) {
        console.log('Moving forward - recycling segment');
        
        // Remove furthest back segment
        const recycledSegment = hallwaySegments.pop();
        hallwayGroup.remove(recycledSegment);
        
        // Dispose ONLY geometry (materials are shared, don't dispose them!)
        recycledSegment.traverse(node => {
          if (node.geometry) {
            node.geometry.dispose();
          }
        });
        
        // Create new segment ahead
        const newZPos = furthestForwardSegment.userData.zPosition - HALLWAY_SEGMENT_LENGTH;
        const newConfig = createSegmentConfiguration(newZPos);
        const newSegment = buildSegmentFromConfig(newConfig);
        
        hallwayGroup.add(newSegment);
        hallwaySegments.unshift(newSegment);
        segmentHistory.unshift(newConfig);
        
        // Keep history limited
        if (segmentHistory.length > 50) {
          segmentHistory.pop();
        }
      }
      
      // MOVING BACKWARD: Recycle forward segment and restore previous segment
      else if (playerZ > furthestBackSegment.userData.zPosition + HALLWAY_SEGMENT_LENGTH) {
        console.log('Moving backward - restoring previous segment');
        
        // Remove furthest forward segment
        const recycledSegment = hallwaySegments.shift();
        hallwayGroup.remove(recycledSegment);
        
        // Dispose ONLY geometry (materials are shared, don't dispose them!)
        recycledSegment.traverse(node => {
          if (node.geometry) {
            node.geometry.dispose();
          }
        });
        
        // Try to restore previous segment from history
        const newZPos = furthestBackSegment.userData.zPosition + HALLWAY_SEGMENT_LENGTH;
        
        // Look for historical segment at this position
        const historicalConfig = segmentHistory.find(config => 
          Math.abs(config.zPosition - newZPos) < 0.1
        );
        
        let newSegment;
        if (historicalConfig) {
          // Restore from history
          console.log('Restoring segment from history');
          newSegment = buildSegmentFromConfig(historicalConfig);
        } else {
          // Create new segment if no history available
          console.log('Creating new segment (no history)');
          const newConfig = createSegmentConfiguration(newZPos);
          newSegment = buildSegmentFromConfig(newConfig);
          segmentHistory.push(newConfig);
        }
        
        hallwayGroup.add(newSegment);
        hallwaySegments.push(newSegment);
      }
    }
    
    function toggleHallway() {
      // Hallway can only be toggled in interior mode
      if (!interiorsMode) {
        console.log('Hallway system only available in interior mode (press I first)');
        return;
      }
      
      hallwayMode = !hallwayMode;
      
      if (hallwayMode) {
        generateHallway();
        // Position player at start of hallway
        if (playerBody) {
          playerBody.setTranslation({ x: 0, y: 1.8, z: 0 }, true);
        }
        console.log('Hallway mode ON - Procedural room generation enabled');
      } else {
        // Clear hallway - dispose geometry but NOT shared materials
        hallwaySegments.forEach(segment => {
          segment.traverse(node => {
            if (node.geometry) {
              node.geometry.dispose();
            }
          });
        });
        scene.remove(hallwayGroup);
        hallwayGroup.clear();
        hallwaySegments = [];
        generatedRooms = [];
        segmentHistory = [];
        console.log('Hallway mode OFF - cleaned up');
      }
    }
    
    // ==================== INTERIORS SYSTEM ====================
    // Complete integration of the interiors system from interiors.html
    // NOTE: Most interiors code has been extracted to separate JS modules:
    //   - js/interiors-constants.js (INTERIORS_ASSETS, INTERIORS_ROOM_CONFIGS, etc.)
    //   - js/interiors-main.js (toggleInteriorsMode, state management)
    //   - js/interiors-ui.js (asset menu, randomizer button)
    //
    // The asset creation functions remain inline below for now due to their size
    // and dependencies on the THREE.js scene and other global variables.
    
    // State variables now imported from js/interiors-main.js:
    // interiorsGroup, interiorRoomObjects, interiorInteractiveObjects, interactiveInteriorsObjects
    /* COMMENTED OUT - Using imported versions from interiors-main.js
    let interiorsMode = false;
    let savedCityObjects = null;
    let savedPlayerChunk = null;
    let interiorsGroup = new THREE.Group();
    let interiorRoomObjects = [];
    let interiorInteractiveObjects = [];
    const interactiveInteriorsObjects = [];
    */
    // INTERIORS_GRID_SIZE, INTERIORS_WALL_HEIGHT, INTERIORS_WALL_THICKNESS now imported from interiors-constants.js
    
    // Asset specifications - NOW IMPORTED from js/interiors-constants.js
    /* COMMENTED OUT - Using imported version
    const INTERIORS_ASSETS = {
      desk: {
        square: { width: 1, depth: 1, height: 0.75, legRadius: 0.04, legHeight: 0.7 },
        rectangle: { width: 1.5, depth: 0.75, height: 0.75, legRadius: 0.04, legHeight: 0.7 },
        circle: { radius: 0.5, height: 0.75, legRadius: 0.04, legHeight: 0.7 }
      },
      bed: { width: 1.5, depth: 2, height: 0.5, legHeight: 0.3 },
      childbed: { width: 0.9, depth: 1.4, height: 0.35, legHeight: 0.2 },
      toilet: { 
        bowlRadius: 0.22, 
        bowlHeight: 0.35,
        seatRadius: 0.24,
        tankWidth: 0.4,
        tankDepth: 0.15,
        tankHeight: 0.35
      },
      shower: { width: 1, depth: 1, height: 2 },
      counter: {
        width: 2.0,
        depth: 0.6,
        height: 0.9,
        thickness: 0.05,
        sinkWidth: 0.5,
        sinkDepth: 0.4,
        sinkHeight: 0.15
      },
      letterblock: { size: 0.08 },
      xylophone: { width: 0.35, depth: 0.15, height: 0.02 },
      toycar: { scale: 0.08 }, // Much smaller toy car
      toytrain: { carLength: 0.08, carWidth: 0.05, carHeight: 0.06 }, // Much smaller train
      traintrack: { segmentLength: 0.12, railWidth: 0.03, railHeight: 0.004 } // Much smaller tracks
    };
    */ // END COMMENTED OUT INTERIORS_ASSETS - now imported
    
    // Room configurations - NOW IMPORTED from js/interiors-constants.js
    /* COMMENTED OUT - Using imported version
    const INTERIORS_ROOM_CONFIGS = {
      studio: {
        name: 'Studio Apartment',
        mainRoom: 'studio',
        floorBounds: { minX: -6, maxX: 6, minZ: -6, maxZ: 6 },
        bathroom: { x: 4.5, z: -2, width: 3, depth: 6 },
        walls: [
          { x: -6, z: -6, dir: 'h', length: 12 },
          { x: -6, z: 6, dir: 'h', length: 12 },
          { x: -6, z: -6, dir: 'v', length: 12 },
          { x: 6, z: -6, dir: 'v', length: 12 },
          { x: 3, z: -6, dir: 'v', length: 5.2 },
          { x: 3, z: -0.8, dir: 'h', length: 3, hasDoor: true },
          { x: 6, z: -0.8, dir: 'v', length: 3.2 }
        ],
        kitchenPartition: { x: 1, z: -2, width: 3, depth: 2.4 },
        furniture: [
          // Bathroom (corner layout with sink)
          { type: 'toilet', x: 4.5, z: -4.5, rotation: 0 },
          { type: 'shower', x: 5.4, z: 0.5, rotation: 0 },
          { type: 'bathroomsink', x: 3.8, z: -4.5, rotation: Math.PI / 2 },
          
          // Living area
          { type: 'rug', x: -2, z: -1.5, width: 2.5, depth: 3, pattern: 'modern', rotation: 0 },
          { type: 'couch', x: -2, z: 0, rotation: Math.PI },
          { type: 'coffeetable', shape: 'rectangle', x: -2, z: -1.5, rotation: 0 },
          { type: 'tvstand', x: -2, z: -4.5, rotation: 0 },
          { type: 'tv', x: -2, z: -4.5, y: 0.55, rotation: 0 },
          { type: 'plant', x: -4, z: 2, rotation: 0 },
          { type: 'wallshelf', x: -5.8, z: -1, y: 1.6, rotation: Math.PI / 2 },
          { type: 'shelfunit', x: -5.5, z: 4.5, rotation: 0, height: 1.8, width: 0.8 },
          
          // Kitchen area with appliances
          { type: 'counter', x: 1, z: -2, rotation: Math.PI },
          { type: 'microwave', x: 2.2, z: -2, y: 0.95, rotation: Math.PI },
          { type: 'fridge', x: 2.8, z: -3.2, rotation: 0 },
          { type: 'fruitbowl', x: 1, z: -2, y: 0.95, rotation: 0 },
        ]
      },
      // 1BR and 2BR configs will be inserted here via command
      '1br': {
        name: '1 Bedroom',
        mainRoom: 'living',
        floorBounds: { minX: -7, maxX: 7, minZ: -6, maxZ: 8 },
        bathroom: { x: 5.5, z: -3.5, width: 3, depth: 5 },
        walls: [
          // Outer perimeter with EXIT DOOR
          { x: -7, z: -6, dir: 'h', length: 5 },
          { x: -2, z: -6, dir: 'h', length: 7, hasDoor: true }, // EXIT DOOR to outside
          { x: 5, z: -6, dir: 'h', length: 2 },
          { x: -7, z: 8, dir: 'h', length: 14 },  // Back
          { x: -7, z: -6, dir: 'v', length: 14 }, // Left
          { x: 7, z: -6, dir: 'v', length: 14 },  // Right
          
          // Living/Bedroom divider with DOOR TO MAIN ROOM
          { x: -7, z: 2, dir: 'h', length: 5 },
          { x: -2, z: 2, dir: 'h', length: 7, hasDoor: true },  // Bedroom door to living
          { x: 5, z: 2, dir: 'h', length: 2 },
          
          // Bathroom walls with DOOR TO MAIN ROOM (expanded for full tile coverage + clearance)
          { x: 4, z: -6, dir: 'v', length: 4.8 },
          { x: 4, z: -1.2, dir: 'h', length: 3, hasDoor: true }  // Bathroom door to living
        ],
        windows: [
          { x: -3, z: -6, dir: 'h', length: 2 },  // Living room window
          { x: -1.5, z: 8, dir: 'h', length: 3 }    // Bedroom window
        ],
        furniture: [
          // Entrance door
          { type: 'entrancedoor', x: 1, z: -6.2, rotation: 0 },
          
          // Living room (main)
          { type: 'rug', x: -2, z: -2.5, width: 2.5, depth: 3.5, pattern: 'persian', rotation: 0 },
          { type: 'couch', x: -2, z: -1, rotation: Math.PI },
          { type: 'coffeetable', shape: 'rectangle', x: -2, z: -2.5, rotation: 0 },
          { type: 'tvstand', x: -2, z: -5, rotation: 0 },
          { type: 'tv', x: -2, z: -5, y: 0.55, rotation: 0 },
          
          // Games on coffee table
          { type: 'gameboard', x: -2.3, z: -2.5, y: 0.42, rotation: 0.4, variant: 'chess' },
          { type: 'chesspawn', x: -2, z: -2.3, y: 0.42, color: 0xffffff },
          { type: 'chesspawn', x: -1.8, z: -2.6, y: 0.42, color: 0x1a1a1a },
          
          // Kitchen area with appliances
          { type: 'counter', x: -4, z: -1, rotation: 0 },
          { type: 'microwave', x: -3.2, z: -1, y: 0.95, rotation: 0 },
          { type: 'fridge', x: -6, z: -2.5, rotation: 0 },
          { type: 'fruitbowl', x: -4, z: -1, y: 0.95, rotation: 0 },
          { type: 'plate', x: -3.5, z: -1, y: 0.91, rotation: 0 },
          
          // Living room decorations
          { type: 'plant', x: -6, z: 0, rotation: 0 },
          { type: 'floorlamp', x: -5, z: -4, rotation: 0, lit: true },
          { type: 'artframe', size: 'large', x: -6.9, z: -2, y: 1.6, rotation: Math.PI / 2, wallMount: true },
          { type: 'wallshelf', x: 6.8, z: -1, y: 1.6, rotation: -Math.PI / 2 },
          
          // Bedroom (3 decorations required)
          { type: 'rug', x: 0, z: 5, width: 3, depth: 2.5, pattern: 'shag', rotation: 0 },
          { type: 'bed', x: 0, z: 5, rotation: 0 },
          { type: 'sidetable', x: -1.8, z: 5, rotation: 0 },
          { type: 'alarmclock', x: -1.8, z: 5, y: 0.55, rotation: 0, color: 0x4444ff },
          { type: 'closet', x: -6, z: 7, rotation: 0 },
          { type: 'computerdesk', x: 4, z: 6, rotation: -Math.PI / 2 },
          { type: 'shelfunit', x: 6.5, z: 6, rotation: Math.PI, height: 1.5, width: 0.6 },
          { type: 'plant', x: -3, z: 6, rotation: 0 },
          { type: 'artframe', size: 'medium', x: -6.9, z: 5, y: 1.5, rotation: Math.PI / 2, wallMount: true },
          { type: 'artframe', size: 'small', x: 2, z: 7.9, y: 1.4, rotation: Math.PI, wallMount: true },
          { type: 'clock', x: 5, z: 7.9, y: 2.0, rotation: Math.PI },
          
          // Bathroom (corner layout with sink)
          { type: 'toilet', x: 5.5, z: -4.5, rotation: 0 },
          { type: 'shower', x: 6.4, z: -1.2, rotation: 0 },
          { type: 'bathroomsink', x: 4.8, z: -4.5, rotation: Math.PI / 2 }
        ]
      },
      
      '2br': {
        name: '2 Bedroom',
        mainRoom: 'living',
        floorBounds: { minX: -9, maxX: 9, minZ: -6, maxZ: 8 },
        bathroom: { x: 7.5, z: -3.5, width: 3, depth: 5 },
        walls: [
          // Outer perimeter with EXIT DOOR
          { x: -9, z: -6, dir: 'h', length: 6 },
          { x: -3, z: -6, dir: 'h', length: 9, hasDoor: true },  // EXIT DOOR to outside
          { x: 6, z: -6, dir: 'h', length: 3 },
          { x: -9, z: 8, dir: 'h', length: 18 },
          { x: -9, z: -6, dir: 'v', length: 14 },
          { x: 9, z: -6, dir: 'v', length: 14 },
          
          // Living/Hallway divider (hallway connects to main)
          { x: -9, z: 2, dir: 'h', length: 6 },
          { x: -3, z: 2, dir: 'h', length: 10, hasDoor: true },  // Hallway door to living
          { x: 7, z: 2, dir: 'h', length: 2 },
          
          // Bedroom divider (middle wall)
          { x: 0, z: 2, dir: 'v', length: 6 },
          
          // Bedroom 1 door TO MAIN (hallway)
          { x: -9, z: 4.5, dir: 'h', length: 3.5, hasDoor: true },
          
          // Bedroom 2 door TO MAIN (hallway)
          { x: 1, z: 4.5, dir: 'h', length: 3.5, hasDoor: true },
          
          // Bathroom walls with DOOR TO MAIN (expanded for full tile coverage + clearance)
          { x: 6, z: -6, dir: 'v', length: 4.8 },
          { x: 6, z: -1.2, dir: 'h', length: 3, hasDoor: true }  // Bathroom door to living
        ],
        windows: [
          { x: -4, z: -6, dir: 'h', length: 2 },  // Living
          { x: -5, z: 8, dir: 'h', length: 3 },   // Bedroom 1
          { x: 3, z: 8, dir: 'h', length: 3 }     // Bedroom 2
        ],
        furniture: [
          // Entrance door
          { type: 'entrancedoor', x: 1, z: -6.2, rotation: 0 },
          
          // Living room (main)
          { type: 'couch', x: 0, z: -1, rotation: Math.PI },
          { type: 'coffeetable', shape: 'square', x: 0, z: -2.5, rotation: 0 },
          { type: 'tvstand', x: 0, z: -5, rotation: 0 },
          { type: 'tv', x: 0, z: -5, y: 0.55, rotation: 0 },
          
          // Games on coffee table
          { type: 'gameboard', x: -0.2, z: -2.5, y: 0.42, rotation: 0.1, variant: 'checkers' },
          { type: 'dice', x: 0.3, z: -2.3, y: 0.41, rotation: 0 },
          { type: 'pokerchip', x: 0.2, z: -2.7, y: 0.41, color: 0x1a1a1a },
          
          // Kitchen area with appliances
          { type: 'counter', x: -5, z: -2, rotation: 0 },
          { type: 'microwave', x: -4.2, z: -2, y: 0.95, rotation: 0 },
          { type: 'fridge', x: -8, z: -3, rotation: 0 },
          { type: 'fruitbowl', x: -5, z: -2, y: 0.95, rotation: 0 },
          { type: 'plate', x: -4.5, z: -2, y: 0.91, rotation: 0 },
          { type: 'bowl', x: -5.5, z: -2, y: 0.91, rotation: 0 },
          
          // Living room decorations
          { type: 'plant', x: 3, z: -1, rotation: 0 },
          { type: 'plant', x: -7, z: 0, rotation: 0 },
          { type: 'floorlamp', x: 4, z: -4, rotation: 0, lit: true },
          { type: 'artframe', size: 'large', x: -8.9, z: -2, y: 1.6, rotation: Math.PI / 2, wallMount: true },
          { type: 'artframe', size: 'medium', x: 8.9, z: -2, y: 1.5, rotation: -Math.PI / 2, wallMount: true },
          { type: 'wallshelf', x: -8.8, z: 0, y: 1.6, rotation: Math.PI / 2 },
          
          // Bedroom 1 (3 decorations required + closet) - LEFT side
          { type: 'rug', x: -4.5, z: 5, width: 3, depth: 2.5, pattern: 'persian', rotation: 0 },
          { type: 'bed', x: -4.5, z: 5, rotation: 0 },
          { type: 'sidetable', x: -6.5, z: 5, rotation: 0 },
          { type: 'alarmclock', x: -6.5, z: 5, y: 0.55, rotation: 0, color: 0xff4444 },
          { type: 'closet', x: -7.5, z: 3.5, rotation: 0 },
          { type: 'plant', x: -2.5, z: 6.5, rotation: 0 },
          { type: 'shelfunit', x: -2, z: 3, rotation: Math.PI, height: 1.8, width: 0.8 },
          { type: 'artframe', size: 'medium', x: -8.9, z: 4.5, y: 1.5, rotation: Math.PI / 2, wallMount: true },
          { type: 'artframe', size: 'small', x: -4.5, z: 7.9, y: 1.4, rotation: Math.PI, wallMount: true },
          { type: 'clock', x: -6.5, z: 7.9, y: 2.0, rotation: Math.PI },
          
          // Bedroom 2 (3 decorations required + closet + computer desk) - RIGHT side
          { type: 'rug', x: 4.5, z: 5, width: 3, depth: 2.5, pattern: 'shag', rotation: 0 },
          { type: 'bed', x: 4.5, z: 5, rotation: Math.PI },
          { type: 'sidetable', x: 6.5, z: 5, rotation: 0 },
          { type: 'alarmclock', x: 6.5, z: 5, y: 0.55, rotation: 0, color: 0x44ff44 },
          { type: 'closet', x: 7.5, z: 3.5, rotation: Math.PI },
          { type: 'computerdesk', x: 2, z: 6, rotation: Math.PI / 2 },
          { type: 'plant', x: 2.5, z: 6.5, rotation: 0 },
          { type: 'artframe', size: 'medium', x: 8.9, z: 4.5, y: 1.5, rotation: -Math.PI / 2, wallMount: true },
          { type: 'artframe', size: 'small', x: 4.5, z: 7.9, y: 1.4, rotation: Math.PI, wallMount: true },
          { type: 'clock', x: 6.5, z: 7.9, y: 2.0, rotation: Math.PI },
          
          // Bathroom (corner layout with sink)
          { type: 'toilet', x: 7.5, z: -4.5, rotation: 0 },
          { type: 'shower', x: 8.4, z: -1.2, rotation: 0 },
          { type: 'bathroomsink', x: 6.8, z: -4.5, rotation: Math.PI / 2 }
        ]
      },
      
      '3br': {
        name: '3 Bedroom (with Child Room)',
        mainRoom: 'living',
        floorBounds: { minX: -11, maxX: 11, minZ: -6, maxZ: 10 },
        walls: [
          // Outer perimeter with EXIT DOOR
          { x: -11, z: -6, dir: 'h', length: 7 },
          { x: -4, z: -6, dir: 'h', length: 11, hasDoor: true },  // EXIT DOOR to outside
          { x: 7, z: -6, dir: 'h', length: 4 },
          { x: -11, z: 10, dir: 'h', length: 22 },
          { x: -11, z: -6, dir: 'v', length: 16 },
          { x: 11, z: -6, dir: 'v', length: 16 },
          
          // Living/Hallway divider
          { x: -11, z: 2, dir: 'h', length: 7 },
          { x: -4, z: 2, dir: 'h', length: 13, hasDoor: true },  // Hallway door to living
          { x: 9, z: 2, dir: 'h', length: 2 },
          
          // Bedroom dividers (middle walls)
          { x: -2, z: 2, dir: 'v', length: 8 },  // Divider between bedroom 1 & 2
          { x: 5, z: 2, dir: 'v', length: 8 },   // Divider between bedroom 2 & 3
          
          // Bedroom doors TO MAIN (hallway)
          { x: -11, z: 5, dir: 'h', length: 4, hasDoor: true },  // Bedroom 1 door
          { x: -1, z: 5, dir: 'h', length: 4, hasDoor: true },   // Bedroom 2 door (child's room)
          { x: 6, z: 5, dir: 'h', length: 4, hasDoor: true },    // Bedroom 3 door
          
          // Bathroom walls with DOOR TO MAIN
          { x: 7, z: -6, dir: 'v', length: 4 },
          { x: 7, z: -2, dir: 'h', length: 4, hasDoor: true }  // Bathroom door to living
        ],
        windows: [
          { x: -5, z: -6, dir: 'h', length: 2 },   // Living
          { x: -7, z: 10, dir: 'h', length: 3 },   // Bedroom 1
          { x: 1, z: 10, dir: 'h', length: 3 },    // Bedroom 2 (child)
          { x: 8, z: 10, dir: 'h', length: 3 }     // Bedroom 3
        ],
        furniture: [
          // Entrance door
          { type: 'entrancedoor', x: 1, z: -6.2, rotation: 0 },
          
          // Living room (main)
          { type: 'couch', x: 0, z: -1, rotation: Math.PI },
          { type: 'coffeetable', shape: 'rectangle', x: 0, z: -2.8, rotation: 0 },
          { type: 'tvstand', x: 0, z: -5.2, rotation: 0 },
          { type: 'tv', x: 0, z: -5.2, y: 0.55, rotation: 0 },
          
          // Games on coffee table
          { type: 'gameboard', x: -0.3, z: -2.8, y: 0.42, rotation: 0.2, variant: 'chess' },
          { type: 'dice', x: 0.4, z: -2.6, y: 0.41, rotation: 0 },
          
          // Kitchen area with appliances
          { type: 'counter', x: -6, z: -2, rotation: 0 },
          { type: 'microwave', x: -5.2, z: -2, y: 0.95, rotation: 0 },
          { type: 'fridge', x: -9, z: -3.5, rotation: 0 },
          { type: 'fruitbowl', x: -6, z: -2, y: 0.95, rotation: 0 },
          { type: 'plate', x: -5.5, z: -2, y: 0.91, rotation: 0 },
          
          // Living room decorations
          { type: 'plant', x: 4, z: -1, rotation: 0 },
          { type: 'plant', x: -8, z: 0, rotation: 0 },
          { type: 'floorlamp', x: 5, z: -4.5, rotation: 0, lit: true },
          { type: 'artframe', size: 'large', x: -10.9, z: -2, y: 1.6, rotation: Math.PI / 2, wallMount: true },
          
          // Bedroom 1 (Master) - LEFT side
          { type: 'rug', x: -6, z: 6, width: 3.5, depth: 3, pattern: 'persian', rotation: 0 },
          { type: 'bed', x: -6, z: 6, rotation: 0 },
          { type: 'sidetable', x: -8.2, z: 6, rotation: 0 },
          { type: 'alarmclock', x: -8.2, z: 6, y: 0.55, rotation: 0, color: 0xff4444 },
          { type: 'closet', x: -9.5, z: 4, rotation: 0 },
          { type: 'plant', x: -3.5, z: 7.5, rotation: 0 },
          { type: 'artframe', size: 'medium', x: -10.9, z: 6, y: 1.5, rotation: Math.PI / 2, wallMount: true },
          { type: 'clock', x: -6, z: 9.9, y: 2.0, rotation: Math.PI },
          
          // Bedroom 2 (Children's Room with TWO beds) - MIDDLE
          { type: 'rug', x: 1.5, z: 6, width: 2.5, depth: 2.5, color: 0x88ccff, rotation: 0 },
          { type: 'bed', x: 0.3, z: 6.5, size: 'child', color: 'blue', rotation: 0 },  // Blue child bed (boy) with stars
          { type: 'bed', x: 2.7, z: 6.5, size: 'child', color: 'pink', rotation: 0 },  // Pink child bed (girl) with hearts
          { type: 'sidetable', x: -0.8, z: 6.5, rotation: 0 },
          { type: 'alarmclock', x: -0.8, z: 6.5, y: 0.55, rotation: 0, color: 0x4488ff },
          { type: 'closet', x: -1, z: 3.5, rotation: 0 },
          
          // Toys scattered around child's room
          { type: 'letterblock', x: 1.5, z: 4, y: 0, letters: ['A'], rotation: 0 },
          { type: 'letterblock', x: 1.7, z: 4.1, y: 0.08, letters: ['B'], rotation: 0.3 },
          { type: 'letterblock', x: 1.3, z: 4.15, y: 0.08, letters: ['C'], rotation: -0.2 },
          { type: 'xylophone', x: 3, z: 4.5, y: 0, rotation: Math.PI / 4 },
          { type: 'toycar', x: 2.5, z: 5.5, y: 0, color: 0xff0000, rotation: Math.PI / 3 },
          { type: 'toycar', x: 2.8, z: 5.3, y: 0, color: 0x0000ff, rotation: -Math.PI / 6 },
          { type: 'toytrain', x: 0.5, z: 8.5, y: 0, carCount: 3, rotation: Math.PI / 2 },
          { type: 'traintrack', x: 0.5, z: 8, y: 0, trackType: 'straight', segmentCount: 3, rotation: Math.PI / 2 },
          { type: 'traintrack', x: 2, z: 9.2, y: 0, trackType: 'curved', radius: 0.5, rotation: 0 },
          { type: 'pixarball', x: 3.5, z: 6, y: 0, rotation: 0 },
          
          // Child's room decorations
          { type: 'artframe', size: 'small', x: 1.5, z: 9.9, y: 1.2, rotation: Math.PI, wallMount: true },
          { type: 'plant', x: 3.5, z: 3, rotation: 0 },
          
          // Bedroom 3 (Guest/Teen Room) - RIGHT side
          { type: 'rug', x: 8, z: 6, width: 3, depth: 2.5, pattern: 'modern', rotation: 0 },
          { type: 'bed', x: 8, z: 6, rotation: Math.PI },
          { type: 'sidetable', x: 10, z: 6, rotation: 0 },
          { type: 'alarmclock', x: 10, z: 6, y: 0.55, rotation: 0, color: 0x44ff44 },
          { type: 'closet', x: 10, z: 3.5, rotation: Math.PI },
          { type: 'computerdesk', x: 6, z: 7, rotation: Math.PI / 2 },
          { type: 'desklamp', x: 6, z: 7, y: 0.75, lit: true, rotation: 0 },
          { type: 'plant', x: 6.5, z: 8, rotation: 0 },
          { type: 'artframe', size: 'medium', x: 10.9, z: 6, y: 1.5, rotation: -Math.PI / 2, wallMount: true },
          { type: 'clock', x: 8, z: 9.9, y: 2.0, rotation: Math.PI },
          
          // Bathroom (corner layout with sink)
          { type: 'toilet', x: 9, z: -4.5, rotation: 0 },
          { type: 'shower', x: 10, z: -1.2, rotation: 0 },
          { type: 'bathroomsink', x: 8, z: -4.5, rotation: Math.PI / 2 }
        ]
      }
    };
    */ // END COMMENTED OUT INTERIORS_ROOM_CONFIGS - now imported
    
    // ==================== INTELLIGENT ROOM CONSTRUCTION SYSTEM ====================
    // Comprehensive scanning and placement policy engine
    
    // ==================== FURNITURE-TO-PROPS MARRIAGE SYSTEM ====================
    // Each furniture type has an associated pool of surface props that can be placed on/near it
    // NOW IMPORTED from js/interiors-constants.js
    
    /* COMMENTED OUT - Using imported version
    const furniturePropsPool = {
      tvstand: [
        { type: 'tvremote', weight: 10 },
        { type: 'gamecontroller', controllerType: 'modern', weight: 8 },
        { type: 'gamecontroller', controllerType: 'retro', weight: 5 },
        { type: 'sodacan', weight: 4 },
        { type: 'dvdcase', weight: 3 }
      ],
      counter: [
        { type: 'plate', weight: 6 },
        { type: 'bowl', weight: 6 },
        { type: 'mug', weight: 8 },
        { type: 'fruitbowl', weight: 5 },
        { type: 'sodacan', weight: 4 },
        { type: 'papertowelroll', weight: 3 }
      ],
      computerdesk: [
        { type: 'mug', weight: 8 },
        { type: 'sodacan', weight: 6 },
        { type: 'desklamp', weight: 5 },
        { type: 'pen', weight: 4 },
        { type: 'notebook', weight: 4 }
      ],
      sidetable: [
        { type: 'alarmclock', weight: 8 },
        { type: 'desklamp', weight: 6 },
        { type: 'book', weight: 5 },
        { type: 'mug', weight: 4 },
        { type: 'tvremote', weight: 6 }
      ],
      coffeetable: [
        { type: 'sodacan', weight: 10 },
        { type: 'tvremote', weight: 8 },
        { type: 'gamecontroller', controllerType: 'modern', weight: 6 },
        { type: 'magazine', weight: 5 },
        { type: 'bowl', weight: 4 }
      ],
      couch: [  // Props on couch arms
        { type: 'sodacan', weight: 10, placement: 'arm' },
        { type: 'tvremote', weight: 8, placement: 'arm' },
        { type: 'gamecontroller', controllerType: 'modern', weight: 5, placement: 'arm' },
        { type: 'pillow', weight: 6, placement: 'seat' }
      ],
      bed: [
        { type: 'pillow', weight: 10 },
        { type: 'book', weight: 4 }
      ]
    };
    
    // Random props pool for variety (floor/general items)
    const miscPropsPool = [
      // Small decorative items
      { type: 'pixarball', weight: 5 },
      { type: 'basketball', weight: 3 },
      { type: 'toycar', weight: 4 },
      { type: 'buildingblocks', weight: 4 },
      { type: 'plant', weight: 8 },
      { type: 'artframe', size: 'small', weight: 6, wallMount: true },
      { type: 'clock', weight: 3, wallMount: true },
      // Medium items
      { type: 'rug', width: 2, depth: 1.5, pattern: 'modern', weight: 5 },
      { type: 'shoeRack', weight: 3 },
      { type: 'wastebasket', weight: 4 },
      { type: 'umbrella', weight: 2 },
      { type: 'umbrellastand', weight: 2 },
      // Pet items
      { type: 'dogfoodbowl', weight: 2 },
      { type: 'waterbowl', weight: 2 },
      { type: 'petbed', weight: 2 },
      { type: 'dogtoy', toyType: 'ball', weight: 3 },
      { type: 'cattower', weight: 1 },
      { type: 'litterbox', weight: 1 }
    ];
    */ // END COMMENTED OUT furniturePropsPool and miscPropsPool - now imported
    
    // Room scanner - analyzes room geometry
    function scanRoomGeometry(bounds, walls, doors) {
      const scan = {
        bounds: bounds,
        walls: [],
        corners: [],
        floorSlots: [],
        wallSlots: [],
        surfaceSlots: [],
        centerArea: {
          x: (bounds.minX + bounds.maxX) / 2,
          z: (bounds.minZ + bounds.maxZ) / 2,
          width: (bounds.maxX - bounds.minX) * 0.6,
          depth: (bounds.maxZ - bounds.minZ) * 0.6
        }
      };
      
      // Identify wall segments
      const wallSegments = [
        { name: 'north', x1: bounds.minX, z1: bounds.minZ, x2: bounds.maxX, z2: bounds.minZ, dir: 'h', normal: { x: 0, z: -1 } },
        { name: 'south', x1: bounds.minX, z1: bounds.maxZ, x2: bounds.maxX, z2: bounds.maxZ, dir: 'h', normal: { x: 0, z: 1 } },
        { name: 'west', x1: bounds.minX, z1: bounds.minZ, x2: bounds.minX, z2: bounds.maxZ, dir: 'v', normal: { x: -1, z: 0 } },
        { name: 'east', x1: bounds.maxX, z1: bounds.minZ, x2: bounds.maxX, z2: bounds.maxZ, dir: 'v', normal: { x: 1, z: 0 } }
      ];
      
      wallSegments.forEach(wall => {
        const length = wall.dir === 'h' ? (wall.x2 - wall.x1) : (wall.z2 - wall.z1);
        scan.walls.push({
          ...wall,
          length: length,
          midX: (wall.x1 + wall.x2) / 2,
          midZ: (wall.z1 + wall.z2) / 2
        });
      });
      
      // Identify corners
      scan.corners = [
        { name: 'nw', x: bounds.minX, z: bounds.minZ, walls: ['north', 'west'] },
        { name: 'ne', x: bounds.maxX, z: bounds.minZ, walls: ['north', 'east'] },
        { name: 'sw', x: bounds.minX, z: bounds.maxZ, walls: ['south', 'west'] },
        { name: 'se', x: bounds.maxX, z: bounds.maxZ, walls: ['south', 'east'] }
      ];
      
      return scan;
    }
    
    // Find optimal slot for furniture based on type and room scan
    function findFurnitureSlot(scan, furnitureType, placedItems, preferences = {}) {
      const occupiedSlots = placedItems.map(item => ({ x: item.x, z: item.z, radius: item._radius || 1 }));
      
      function isSlotAvailable(x, z, minClearance = 1.5) {
        return occupiedSlots.every(slot => {
          const dist = Math.sqrt((x - slot.x) ** 2 + (z - slot.z) ** 2);
          return dist > (slot.radius + minClearance);
        });
      }
      
      function getRotationForWall(wallName) {
        // Returns rotation so furniture BACK is against wall (cabinets/backing toward wall)
        // All furniture is 90-degree snapped
        switch (wallName) {
          case 'north': return 0; // Back to north wall (facing south)
          case 'south': return Math.PI; // Back to south wall (facing north)
          case 'east': return Math.PI / 2; // Back to east wall (facing west)
          case 'west': return -Math.PI / 2; // Back to west wall (facing east)
          default: return 0;
        }
      }
      
      function snap90Degrees(rotation) {
        // Snap any rotation to nearest 90-degree increment
        const normalized = ((rotation % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
        const angles = [0, Math.PI / 2, Math.PI, -Math.PI / 2];
        let closest = angles[0];
        let minDiff = Math.abs(normalized);
        
        angles.forEach(angle => {
          const normalizedAngle = ((angle % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
          const diff = Math.min(
            Math.abs(normalized - normalizedAngle),
            Math.abs(normalized - normalizedAngle + Math.PI * 2),
            Math.abs(normalized - normalizedAngle - Math.PI * 2)
          );
          if (diff < minDiff) {
            minDiff = diff;
            closest = angle;
          }
        });
        
        return closest;
      }
      
      // Slot-finding strategies by furniture type
      const strategies = {
        counter: () => {
          // Counters prefer walls with good clearance
          for (const wall of scan.walls) {
            if (wall.length < 3) continue; // Need at least 3m wall
            const offset = wall.name === 'north' ? 0.5 : wall.name === 'south' ? -0.5 : 0;
            const offsetX = wall.name === 'west' ? 0.5 : wall.name === 'east' ? -0.5 : 0;
            const x = wall.midX + offsetX;
            const z = wall.midZ + offset;
            if (isSlotAvailable(x, z, 2)) {
              return { x, z, rotation: getRotationForWall(wall.name), _radius: 1.5 };
            }
          }
          return null;
        },
        
        fridge: () => {
          // Fridges need extra clearance from walls (deeper than counters)
          for (const wall of scan.walls) {
            if (wall.length < 2) continue;
            // Increase offset to 0.8 to accommodate 0.7 depth + clearance
            const offset = wall.name === 'north' ? 0.8 : wall.name === 'south' ? -0.8 : 0;
            const offsetX = wall.name === 'west' ? 0.8 : wall.name === 'east' ? -0.8 : 0;
            const x = wall.midX + offsetX + (Math.random() - 0.5) * wall.length * 0.2;
            const z = wall.midZ + offset + (Math.random() - 0.5) * (wall.dir === 'v' ? wall.length * 0.2 : 0);
            if (isSlotAvailable(x, z, 1.5)) {
              return { x, z, rotation: getRotationForWall(wall.name), _radius: 1.0 };
            }
          }
          return null;
        },
        
        microwave: () => {
          // Microwaves should be placed on counters - find counter-adjacent slots
          const counters = placedItems.filter(item => item.type === 'counter');
          if (counters.length > 0) {
            const counter = counters[Math.floor(Math.random() * counters.length)];
            return { x: counter.x, z: counter.z, y: 0.95, rotation: counter.rotation, _radius: 0.3 };
          }
          return null;
        },
        
        closet: () => {
          // Closets prefer corners, opening into room
          for (const corner of scan.corners) {
            const offsetX = corner.x === scan.bounds.minX ? 0.8 : -0.8;
            const offsetZ = corner.z === scan.bounds.minZ ? 0.8 : -0.8;
            const x = corner.x + offsetX;
            const z = corner.z + offsetZ;
            if (isSlotAvailable(x, z, 1.5)) {
              // Determine which wall is closer to align closet back to that wall
              const distToHorzWall = Math.min(Math.abs(z - scan.bounds.minZ), Math.abs(z - scan.bounds.maxZ));
              const distToVertWall = Math.min(Math.abs(x - scan.bounds.minX), Math.abs(x - scan.bounds.maxX));
              let rotation;
              if (distToHorzWall < distToVertWall) {
                rotation = z < scan.centerArea.z ? 0 : Math.PI; // Back to north or south
              } else {
                rotation = x < scan.centerArea.x ? -Math.PI / 2 : Math.PI / 2; // Back to west or east
              }
              return { x, z, rotation, _radius: 1.2 };
            }
          }
          return null;
        },
        
        shelf: () => {
          // Shelves prefer walls, away from corners
          for (const wall of scan.walls) {
            if (wall.length < 2) continue;
            const offset = wall.name === 'north' ? 0.3 : wall.name === 'south' ? -0.3 : 0;
            const offsetX = wall.name === 'west' ? 0.3 : wall.name === 'east' ? -0.3 : 0;
            const x = wall.midX + offsetX + (Math.random() - 0.5) * wall.length * 0.3;
            const z = wall.midZ + offset + (Math.random() - 0.5) * (wall.dir === 'v' ? wall.length * 0.3 : 0);
            if (isSlotAvailable(x, z, 1.2)) {
              return { x, z, rotation: getRotationForWall(wall.name), _radius: 0.8 };
            }
          }
          return null;
        },
        
        bed: () => {
          // Beds prefer walls but need clearance
          for (const wall of scan.walls) {
            if (wall.length < 3) continue;
            const offset = wall.name === 'north' ? 1 : wall.name === 'south' ? -1 : 0;
            const offsetX = wall.name === 'west' ? 1 : wall.name === 'east' ? -1 : 0;
            const x = wall.midX + offsetX;
            const z = wall.midZ + offset;
            if (isSlotAvailable(x, z, 2)) {
              return { x, z, rotation: getRotationForWall(wall.name), _radius: 1.5 };
            }
          }
          return null;
        },
        
        couch: () => {
          // Couches prefer walls or center area
          for (const wall of scan.walls) {
            if (wall.length < 2.5) continue;
            const offset = wall.name === 'north' ? 0.6 : wall.name === 'south' ? -0.6 : 0;
            const offsetX = wall.name === 'west' ? 0.6 : wall.name === 'east' ? -0.6 : 0;
            const x = wall.midX + offsetX;
            const z = wall.midZ + offset;
            if (isSlotAvailable(x, z, 2)) {
              return { x, z, rotation: getRotationForWall(wall.name), _radius: 1.5 };
            }
          }
          return null;
        },
        
        default: () => {
          // Generic floor placement - try center area first, then random
          for (let attempt = 0; attempt < 10; attempt++) {
            const x = scan.centerArea.x + (Math.random() - 0.5) * scan.centerArea.width;
            const z = scan.centerArea.z + (Math.random() - 0.5) * scan.centerArea.depth;
            if (isSlotAvailable(x, z, 1)) {
              // Snap to 90 degrees for furniture consistency
              const rotation = [0, Math.PI / 2, Math.PI, -Math.PI / 2][Math.floor(Math.random() * 4)];
              return { x, z, rotation, _radius: 0.5 };
            }
          }
          return null;
        }
      };
      
      const strategy = strategies[furnitureType] || strategies.default;
      return strategy();
    }
    
    // Generate random interior furniture layout based on room type
    function generateRandomInteriorLayout(roomType, bounds) {
      const placedItems = [];
      const scan = scanRoomGeometry(bounds, [], []);
      
      // Room-specific required furniture
      const requiredFurniture = {
        studio: ['bed', 'couch', 'tvstand', 'counter', 'microwave', 'fridge'],
        '1br': ['bed', 'couch', 'tvstand', 'counter', 'microwave', 'fridge', 'closet', 'computerdesk'],
        '2br': ['bed', 'bed', 'couch', 'tvstand', 'counter', 'microwave', 'fridge', 'closet', 'closet', 'computerdesk', 'bookshelf'],
        '3br': ['bed', 'bed', 'bed', 'couch', 'tvstand', 'counter', 'microwave', 'fridge', 'closet', 'closet', 'computerdesk', 'bookshelf', 'shelf']
      };
      
      const furniture = requiredFurniture[roomType] || requiredFurniture.studio;
      
      // Place required furniture
      furniture.forEach(furnitureType => {
        const slot = findFurnitureSlot(scan, furnitureType, placedItems);
        if (slot) {
          const item = { type: furnitureType, ...slot };
          placedItems.push(item);
          
          // Add TV for TV stands
          if (furnitureType === 'tvstand') {
            placedItems.push({ type: 'tv', x: slot.x, z: slot.z, y: 0.55, rotation: slot.rotation });
          }
          
          // Add married surface props from furniture-specific pool
          const propsPool = furniturePropsPool[furnitureType];
          if (propsPool && propsPool.length > 0) {
            // Add 1-3 props per furniture piece
            const numProps = 1 + Math.floor(Math.random() * 3);
            for (let i = 0; i < numProps; i++) {
              // Weighted random selection
              const totalWeight = propsPool.reduce((sum, p) => sum + p.weight, 0);
              let random = Math.random() * totalWeight;
              let selectedProp = propsPool[0];
              
              for (const prop of propsPool) {
                random -= prop.weight;
                if (random <= 0) {
                  selectedProp = prop;
                  break;
                }
              }
              
              // Position based on furniture type and prop placement
              let propX = slot.x;
              let propZ = slot.z;
              let propY = 0.95; // Default height
              
              if (furnitureType === 'couch') {
                if (selectedProp.placement === 'arm') {
                  // Place on couch arm (left or right)
                  const side = Math.random() > 0.5 ? 1 : -1;
                  propX += side * 0.8; // Couch arm offset
                  propY = 0.65; // Arm height
                } else {
                  // Place on seat
                  propX += (Math.random() - 0.5) * 1.2;
                  propZ += (Math.random() - 0.5) * 0.4;
                  propY = 0.45; // Seat height
                }
              } else if (furnitureType === 'tvstand' || furnitureType === 'coffeetable') {
                propY = 0.55; // Lower surface
                propX += (Math.random() - 0.5) * 0.6;
                propZ += (Math.random() - 0.5) * 0.3;
              } else if (furnitureType === 'computerdesk') {
                propY = 0.75; // Desk height
                propX += (Math.random() - 0.5) * 0.6;
                propZ += (Math.random() - 0.5) * 0.3;
              } else if (furnitureType === 'counter') {
                propY = 0.95; // Counter height
                propX += (Math.random() - 0.5) * 0.8;
                propZ += (Math.random() - 0.5) * 0.3;
              } else if (furnitureType === 'sidetable') {
                propY = 0.55; // Side table height
                propX += (Math.random() - 0.5) * 0.3;
                propZ += (Math.random() - 0.5) * 0.3;
              } else if (furnitureType === 'bed') {
                propY = 0.5; // Bed surface
                propX += (Math.random() - 0.5) * 1.0;
                propZ += (Math.random() - 0.5) * 0.8;
              }
              
              placedItems.push({ 
                ...selectedProp, 
                x: propX, 
                z: propZ, 
                y: propY, 
                rotation: Math.random() * Math.PI * 2,
                _isSurfaceProp: true 
              });
            }
          }
        }
      });
      
      // Add random misc props (3-8 items)
      const numMiscItems = 3 + Math.floor(Math.random() * 6);
      for (let i = 0; i < numMiscItems; i++) {
        // Weighted random selection
        const totalWeight = miscPropsPool.reduce((sum, item) => sum + item.weight, 0);
        let random = Math.random() * totalWeight;
        let selectedProp = miscPropsPool[0];
        
        for (const prop of miscPropsPool) {
          random -= prop.weight;
          if (random <= 0) {
            selectedProp = prop;
            break;
          }
        }
        
        // Find placement based on prop type
        if (selectedProp.wallMount) {
          // Wall-mounted items - varied rotation for visual interest
          const wall = scan.walls[Math.floor(Math.random() * scan.walls.length)];
          const t = 0.3 + Math.random() * 0.4; // 30-70% along wall
          const x = wall.dir === 'h' ? (wall.x1 + (wall.x2 - wall.x1) * t) : wall.x1;
          const z = wall.dir === 'v' ? (wall.z1 + (wall.z2 - wall.z1) * t) : wall.z1;
          const y = 1.2 + Math.random() * 0.8;
          placedItems.push({ ...selectedProp, x, z, y, rotation: Math.random() * Math.PI * 2, _isSurfaceProp: true });
        } else if (selectedProp.surfaceMount) {
          // Surface-mounted items - varied rotation for visual interest
          const surfaces = placedItems.filter(item => 
            item.type === 'counter' || item.type === 'computerdesk' || item.type === 'sidetable'
          );
          if (surfaces.length > 0) {
            const surface = surfaces[Math.floor(Math.random() * surfaces.length)];
            const offsetX = (Math.random() - 0.5) * 0.6;
            const offsetZ = (Math.random() - 0.5) * 0.3;
            const y = surface.type === 'counter' ? 0.95 : 0.75;
            placedItems.push({ ...selectedProp, x: surface.x + offsetX, z: surface.z + offsetZ, y, rotation: Math.random() * Math.PI * 2, _isSurfaceProp: true });
          }
        } else {
          // Floor items - snap to 90 degrees
          const slot = findFurnitureSlot(scan, 'default', placedItems);
          if (slot) {
            placedItems.push({ ...selectedProp, ...slot });
          }
        }
      }
      
      return placedItems;
    }
    
    // ==================== ROOM CONSTRUCTION POLICIES ====================
    // These functions enforce placement rules and automatically add required items
    
    function applyRoomConstructionPolicies(config) {
      console.log('üè† Applying room construction policies...');
      
      // ==================== CRITICAL POLICY: MAIN ROOM MUST HAVE DOOR ====================
      if (config.mainRoom) {
        const hasEntranceDoor = config.furniture.some(f => f.type === 'entrancedoor');
        if (!hasEntranceDoor) {
          console.warn('‚ö†Ô∏è Main room missing entrance door - adding one');
          // Find a suitable wall for the entrance door
          const bounds = config.floorBounds;
          const centerX = (bounds.minX + bounds.maxX) / 2;
          const frontZ = bounds.minZ;
          config.furniture.push({
            type: 'entrancedoor',
            x: centerX,
            z: frontZ - 0.2,
            rotation: 0
          });
        }
      }
      
      // ==================== CRITICAL POLICY: BEDROOMS MUST HAVE WINDOWS ====================
      // Check if this is a bedroom-containing layout
      const hasBedrooms = config.name.includes('Bedroom') || config.furniture.some(f => f.type === 'bed');
      if (hasBedrooms && (!config.windows || config.windows.length === 0)) {
        console.warn('‚ö†Ô∏è Bedroom missing windows - adding them');
        config.windows = config.windows || [];
        
        // Add a window to the bedroom area (typically back wall)
        const bounds = config.floorBounds;
        const centerX = (bounds.minX + bounds.maxX) / 2;
        const backZ = bounds.maxZ;
        config.windows.push({
          x: centerX - 1.5,
          z: backZ,
          dir: 'h',
          length: 3
        });
      }
      
      // ==================== POLICY: RUGS UNDER BEDS AND COUCHES ====================
      const beds = config.furniture.filter(f => f.type === 'bed');
      const couches = config.furniture.filter(f => f.type === 'couch');
      const existingRugs = config.furniture.filter(f => f.type === 'rug');
      
      // Add rugs under beds if missing
      beds.forEach(bed => {
        const hasRug = existingRugs.some(rug => 
          Math.abs(rug.x - bed.x) < 1 && Math.abs(rug.z - bed.z) < 1
        );
        if (!hasRug) {
          console.log(`üìê Adding rug under bed at (${bed.x}, ${bed.z})`);
          config.furniture.push({
            type: 'rug',
            x: bed.x,
            z: bed.z,
            width: 3,
            depth: 2.5,
            pattern: Math.random() > 0.5 ? 'shag' : 'persian',
            rotation: bed.rotation || 0
          });
        }
      });
      
      // Add rugs under couches if missing
      couches.forEach(couch => {
        const hasRug = existingRugs.some(rug => 
          Math.abs(rug.x - couch.x) < 1 && Math.abs(rug.z - couch.z) < 1
        );
        if (!hasRug) {
          console.log(`üìê Adding rug under couch at (${couch.x}, ${couch.z})`);
          config.furniture.push({
            type: 'rug',
            x: couch.x,
            z: couch.z - 0.5,
            width: 2.5,
            depth: 3.5,
            pattern: 'modern',
            rotation: couch.rotation || 0
          });
        }
      });
      
      // ==================== POLICY: MAIN ROOMS GET LIVING ROOM PARTITION ====================
      if (config.mainRoom === 'living' || config.mainRoom === 'studio') {
        // Ensure TV + couch + coffee table setup
        const hasTVStand = config.furniture.some(f => f.type === 'tvstand');
        const hasTV = config.furniture.some(f => f.type === 'tv');
        const hasCouch = config.furniture.some(f => f.type === 'couch');
        const hasCoffeeTable = config.furniture.some(f => f.type === 'coffeetable');
        
        if (!hasTVStand || !hasTV || !hasCouch || !hasCoffeeTable) {
          console.log('üõãÔ∏è Main room missing living room essentials - would add them (currently disabled to avoid duplicates)');
          // Note: In a full implementation, we'd add these with smart placement
        }
        
        // Ensure kitchen partition exists
        if (!config.kitchenPartition) {
          console.warn('‚ö†Ô∏è Main room missing kitchen partition');
          const bounds = config.floorBounds;
          config.kitchenPartition = {
            x: bounds.minX + 2,
            z: bounds.minZ + 2,
            width: 3,
            depth: 2.4
          };
        }
      }
      
      // ==================== POLICY: TV MUST BE ON TV STAND ====================
      const tvs = config.furniture.filter(f => f.type === 'tv');
      const tvStands = config.furniture.filter(f => f.type === 'tvstand');
      
      tvs.forEach(tv => {
        const matchingStand = tvStands.find(stand => 
          Math.abs(stand.x - tv.x) < 0.1 && Math.abs(stand.z - tv.z) < 0.1
        );
        if (matchingStand && !tv.y) {
          tv.y = 0.55; // Place TV on stand height
        }
      });
      
      // ==================== POLICY: MICROWAVE MUST BE ON COUNTER ====================
      const microwaves = config.furniture.filter(f => f.type === 'microwave');
      const counters = config.furniture.filter(f => f.type === 'counter');
      
      microwaves.forEach(microwave => {
        const nearCounter = counters.find(counter =>
          Math.abs(counter.x - microwave.x) < 1.5 && Math.abs(counter.z - microwave.z) < 0.8
        );
        if (nearCounter && !microwave.y) {
          microwave.y = 0.95; // Place on counter height
        }
      });
      
      // Policy 2b: Fridge placement relative to counter
      const fridges = config.furniture.filter(f => f.type === 'fridge' || f.type === 'refrigerator');
      
      fridges.forEach(fridge => {
        counters.forEach(counter => {
          const bounds = config.floorBounds;
          
          // Determine counter orientation
          const counterRotation = counter.rotation || 0;
          const counterFacingEast = Math.abs(counterRotation) < 0.1; // 0 rad
          const counterFacingWest = Math.abs(counterRotation - Math.PI) < 0.1; // œÄ rad
          const counterFacingNorth = Math.abs(counterRotation - Math.PI/2) < 0.1; // œÄ/2 rad
          const counterFacingSouth = Math.abs(counterRotation + Math.PI/2) < 0.1; // -œÄ/2 rad
          
          // Check if counter's long edge is against a wall
          const counterAgainstNorthWall = Math.abs(counter.z - bounds.minZ) < 1.0 && (counterFacingEast || counterFacingWest);
          const counterAgainstSouthWall = Math.abs(counter.z - bounds.maxZ) < 1.0 && (counterFacingEast || counterFacingWest);
          const counterAgainstEastWall = Math.abs(counter.x - bounds.maxX) < 1.0 && (counterFacingNorth || counterFacingSouth);
          const counterAgainstWestWall = Math.abs(counter.x - bounds.minX) < 1.0 && (counterFacingNorth || counterFacingSouth);
          
          const counterAgainstWall = counterAgainstNorthWall || counterAgainstSouthWall || 
                                     counterAgainstEastWall || counterAgainstWestWall;
          
          if (counterAgainstWall) {
            // Counter long edge is against wall - place fridge BESIDE counter
            // Fridge should be adjacent to counter, also against the same wall
            if (counterAgainstNorthWall) {
              // Place fridge beside counter (to the left or right), also against north wall
              fridge.z = bounds.minZ + 0.5; // Against same wall
              // Place beside counter (choose side based on which has more space)
              const spaceLeft = counter.x - bounds.minX;
              const spaceRight = bounds.maxX - counter.x;
              fridge.x = spaceLeft > spaceRight ? counter.x - 1.5 : counter.x + 1.5;
              fridge.rotation = Math.PI; // Face south (into room)
            } else if (counterAgainstSouthWall) {
              fridge.z = bounds.maxZ - 0.5;
              const spaceLeft = counter.x - bounds.minX;
              const spaceRight = bounds.maxX - counter.x;
              fridge.x = spaceLeft > spaceRight ? counter.x - 1.5 : counter.x + 1.5;
              fridge.rotation = 0; // Face north (into room)
            } else if (counterAgainstEastWall) {
              fridge.x = bounds.maxX - 0.5;
              const spaceForward = counter.z - bounds.minZ;
              const spaceBack = bounds.maxZ - counter.z;
              fridge.z = spaceForward > spaceBack ? counter.z - 1.5 : counter.z + 1.5;
              fridge.rotation = -Math.PI/2; // Face west (into room)
            } else if (counterAgainstWestWall) {
              fridge.x = bounds.minX + 0.5;
              const spaceForward = counter.z - bounds.minZ;
              const spaceBack = bounds.maxZ - counter.z;
              fridge.z = spaceForward > spaceBack ? counter.z - 1.5 : counter.z + 1.5;
              fridge.rotation = Math.PI/2; // Face east (into room)
            }
          } else {
            // Counter is NOT against wall - place fridge on OPPOSITE side of room
            // Fridge should be against the wall opposite to the counter
            const roomCenterX = (bounds.minX + bounds.maxX) / 2;
            const roomCenterZ = (bounds.minZ + bounds.maxZ) / 2;
            
            // Determine which side of room the counter is on
            if (Math.abs(counter.x - bounds.minX) < Math.abs(counter.x - bounds.maxX)) {
              // Counter is on west side, place fridge on east wall
              fridge.x = bounds.maxX - 0.5;
              fridge.z = roomCenterZ;
              fridge.rotation = -Math.PI/2; // Face west (into room)
            } else {
              // Counter is on east side, place fridge on west wall
              fridge.x = bounds.minX + 0.5;
              fridge.z = roomCenterZ;
              fridge.rotation = Math.PI/2; // Face east (into room)
            }
          }
          
          console.log(`Fridge placement policy applied: fridge at (${fridge.x.toFixed(2)}, ${fridge.z.toFixed(2)}) relative to counter at (${counter.x.toFixed(2)}, ${counter.z.toFixed(2)})`);
        });
      });
      
      // Policy 3: Closets must be in bedroom corners, facing into room
      const closets = config.furniture.filter(f => f.type === 'closet');
      closets.forEach(closet => {
        const bounds = config.floorBounds;
        const centerX = (bounds.minX + bounds.maxX) / 2;
        const centerZ = (bounds.minZ + bounds.maxZ) / 2;
        
        // Determine which corner the closet is in
        const isLeftSide = closet.x < centerX;
        const isRightSide = closet.x > centerX;
        const isFrontSide = closet.z < centerZ;
        const isBackSide = closet.z > centerZ;
        
        // Determine if near a corner (must be near two walls)
        const nearLeftWall = Math.abs(closet.x - bounds.minX) < 2.5;
        const nearRightWall = Math.abs(closet.x - bounds.maxX) < 2.5;
        const nearFrontWall = Math.abs(closet.z - bounds.minZ) < 2.5;
        const nearBackWall = Math.abs(closet.z - bounds.maxZ) < 2.5;
        
        const isInCorner = (nearLeftWall || nearRightWall) && (nearFrontWall || nearBackWall);
        
        if (!isInCorner) {
          console.warn(`Closet at (${closet.x}, ${closet.z}) should be in a corner`);
        }
        
        // Set rotation to face INTO room (perpendicular to nearest wall)
        // Closet should be snapped to corner, facing straight into room (not diagonal)
        if (nearLeftWall && nearFrontWall) {
          // Front-left corner: face right or back (choose based on which wall is closer)
          const distToLeft = Math.abs(closet.x - bounds.minX);
          const distToFront = Math.abs(closet.z - bounds.minZ);
          closet.rotation = distToLeft < distToFront ? 0 : Math.PI / 2; // Face right or back
        } else if (nearRightWall && nearFrontWall) {
          // Front-right corner: face left or back
          const distToRight = Math.abs(closet.x - bounds.maxX);
          const distToFront = Math.abs(closet.z - bounds.minZ);
          closet.rotation = distToRight < distToFront ? Math.PI : Math.PI / 2; // Face left or back
        } else if (nearLeftWall && nearBackWall) {
          // Back-left corner: face right or forward
          const distToLeft = Math.abs(closet.x - bounds.minX);
          const distToBack = Math.abs(closet.z - bounds.maxZ);
          closet.rotation = distToLeft < distToBack ? 0 : -Math.PI / 2; // Face right or forward
        } else if (nearRightWall && nearBackWall) {
          // Back-right corner: face left or forward
          const distToRight = Math.abs(closet.x - bounds.maxX);
          const distToBack = Math.abs(closet.z - bounds.maxZ);
          closet.rotation = distToRight < distToBack ? Math.PI : -Math.PI / 2; // Face left or forward
        } else if (nearLeftWall) {
          // Left wall: face right (into room)
          closet.rotation = 0;
        } else if (nearRightWall) {
          // Right wall: face left (into room)
          closet.rotation = Math.PI;
        } else if (nearFrontWall) {
          // Front wall: face back (into room)
          closet.rotation = Math.PI / 2;
        } else if (nearBackWall) {
          // Back wall: face forward (into room)
          closet.rotation = -Math.PI / 2;
        }
      });
      
      // Policy 4: Doors should face into the room
      const doors = config.furniture.filter(f => f.type === 'entrancedoor' || f.type.includes('door'));
      doors.forEach(door => {
        // Doors at negative Z should face forward (into room)
        if (door.z < (config.floorBounds.minZ + config.floorBounds.maxZ) / 2) {
          door.rotation = door.rotation || 0;
        }
      });
      
      // Policy 5: Add ceiling light to each room
      const hasCeilingLight = config.furniture.some(f => f.type === 'ceilinglight');
      if (!hasCeilingLight) {
        config.furniture.push({
          type: 'ceilinglight',
          x: (config.floorBounds.minX + config.floorBounds.maxX) / 2,
          z: (config.floorBounds.minZ + config.floorBounds.maxZ) / 2,
          style: 'modern'
        });
      }
      
      return config;
    }
    
    // toggleInteriorsMode - Updated to show interior panel
    async function toggleInteriorsMode() {
      await ensureInteriorsModules();
      interiorsMode = !interiorsMode;
      
      if (interiorsMode) {
        console.log('Entering interiors mode...');

        // Save player chunk location
        if (playerBody) {
          const pos = playerBody.translation();
          savedPlayerChunk = { x: pos.x, y: pos.y, z: pos.z };
        }

        // Hide city (keep current chunk only)
        if (worldRoot) {
          worldRoot.visible = false;
        }

        // IMPORTANT: Add interiorsGroup directly to SCENE, not worldRoot
        // Interiors should NOT be affected by world scaling
        scene.add(interiorsGroup);
        
        // Generate interior room
        console.log('Generating interior room...');
        generateInteriorRoom('studio');
        console.log('Interior room generated, children count:', interiorsGroup.children.length);
        
        // Setup asset library and UI
        if (!document.getElementById('asset-library')) {
          setupAssetLibrary();
        }
        if (!document.getElementById('randomize-btn')) {
          setupRandomizerButton();
        }
        
        // Show interior UI
        showInteriorUI();
        
        // Move player into room
        if (playerBody) {
          playerBody.setTranslation({ x: 0, y: 1.7, z: 0 }, true);
          playerBody.setLinvel({ x: 0, y: 0, z: 0 }, true);
        }
        
        console.log('Entered interiors mode');
        
        // Show interior panel
        const interiorPanel = document.getElementById('interior-panel');
        if (interiorPanel) interiorPanel.style.display = 'block';
        
      } else {
        console.log('Exiting interiors mode...');
        
        // Hide interior UI
        hideInteriorUI();
        
        // Hide interior panel
        const interiorPanel = document.getElementById('interior-panel');
        if (interiorPanel) interiorPanel.style.display = 'none';
        
        // Clear interior
        clearInteriorRoom();
        
        // Remove interiorsGroup from parent
        if (interiorsGroup.parent) {
          interiorsGroup.parent.remove(interiorsGroup);
        }
        
        // Restore city
        if (worldRoot) {
          worldRoot.visible = true;
        }
        
        // Restore player position
        if (playerBody && savedPlayerChunk) {
          playerBody.setTranslation(savedPlayerChunk, true);
        }
        
        console.log('Exited interiors mode');
      }
    }
    
    // UI functions now imported from js/interiors-ui.js
    /* COMMENTED OUT - Using imported versions
    function showInteriorUI() {
      const assetLib = document.getElementById('asset-library');
      const randBtn = document.getElementById('randomize-btn');
      if (assetLib) assetLib.style.display = 'none'; // Hidden by default, show with 'B' key
      if (randBtn) randBtn.style.display = 'block';
    }
    
    function hideInteriorUI() {
      const assetLib = document.getElementById('asset-library');
      const randBtn = document.getElementById('randomize-btn');
      if (assetLib) assetLib.style.display = 'none';
      if (randBtn) randBtn.style.display = 'none';
    }
    
    function setupRandomizerButton() {
      const btn = document.createElement('button');
      btn.id = 'randomize-btn';
      btn.innerHTML = 'üé≤ Randomize';
      btn.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(180deg, #ff6b9d 0%, #ef5b8d 100%);
        border: 2px solid rgba(255,107,157,.6);
        border-radius: 8px;
        padding: 12px 24px;
        color: white;
        font-size: 14px;
        font-weight: 700;
        cursor: pointer;
        z-index: 100;
        transition: all 0.2s;
        text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        box-shadow: 0 4px 12px rgba(255,107,157,0.3);
        display: none;
      `;
      
      btn.addEventListener('mouseenter', () => {
        btn.style.transform = 'translateY(-2px) scale(1.05)';
        btn.style.boxShadow = '0 6px 20px rgba(255,107,157,0.4)';
      });
      
      btn.addEventListener('mouseleave', () => {
        btn.style.transform = 'translateY(0) scale(1)';
        btn.style.boxShadow = '0 4px 12px rgba(255,107,157,0.3)';
      });
      
      btn.addEventListener('click', () => {
        randomizeRoom();
      });
      
      document.body.appendChild(btn);
    }
    
    let currentRoomIndex = 0;
    const allRoomTypes = ['studio', '1br', '2br', '3br'];
    
    function randomizeRoom() {
      // Clear current interior
      clearInteriorRoom();
      
      // Cycle through room types in order
      const roomType = allRoomTypes[currentRoomIndex];
      currentRoomIndex = (currentRoomIndex + 1) % allRoomTypes.length;
      
      // Regenerate with selected type using RANDOM layout
      generateInteriorRoom(roomType, true); // true = use random generation
      
      console.log(`Loaded RANDOM room: ${roomType} (layout ${currentRoomIndex}/${allRoomTypes.length})`);
    }
    
    function clearInteriorRoom() {
      if (!interiorsGroup) return;
      
      // Dispose of all objects and their resources
      interiorRoomObjects.forEach(obj => {
        obj.traverse(node => {
          if (node.geometry) node.geometry.dispose();
          if (node.material) {
            if (Array.isArray(node.material)) {
              node.material.forEach(mat => mat.dispose());
            } else {
              node.material.dispose();
            }
          }
        });
      });
      
      // Clear arrays
      interiorRoomObjects = [];
      interiorInteractiveObjects = [];
      interactiveInteriorsObjects.length = 0;  // Clear interactions
      
      // Clear the group's children without removing the group itself
      interiorsGroup.clear();
      
      console.log('Interior room cleared - interiorsGroup ready for new content');
    }
    */ // END COMMENTED OUT UI functions - now using imported versions
    
    // ==================== INTERIOR CLICK INTERACTIONS ====================
    // onInteriorsClick now imported from js/interiors-main.js
    /* COMMENTED OUT - Using imported version
    function onInteriorsClick(event) {
      if (!interiorsMode) return;
      
      // Center of screen for raycasting
      const mouseCenter = new THREE.Vector2(0, 0);
      raycaster.setFromCamera(mouseCenter, camera);
      
      // Check interactive objects
      const intersects = raycaster.intersectObjects(interactiveInteriorsObjects, true);
      
      if (intersects.length > 0) {
        let object = intersects[0].object;
        
        // Find parent group with userData
        while (object && !object.userData.isToiletLid && !object.userData.isClosetDoor && !object.userData.isEntranceDoor && !object.userData.isFridgeDoor) {
          object = object.parent;
          if (!object || object === scene) break;
        }
        
        if (object && object.userData) {
          if (object.userData.isToiletLid) {
            toggleToiletLid(object);
          } else if (object.userData.isClosetDoor || object.userData.isEntranceDoor) {
            toggleInteriorDoor(object, 90);
          } else if (object.userData.isFridgeDoor) {
            toggleInteriorDoor(object, 90);
          }
        }
      }
    }
    
    function toggleToiletLid(lidGroup) {
      const isOpen = lidGroup.userData.isOpen || false;
      const targetRotation = isOpen ? 0 : -Math.PI * 0.55; // Open upward/backward (negative for up)
      
      // Animate lid rotation
      const startRotation = lidGroup.rotation.x;
      const duration = 500; // ms
      const startTime = Date.now();
      
      function animate() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const eased = 1 - Math.pow(1 - progress, 3); // Ease out cubic
        
        lidGroup.rotation.x = startRotation + (targetRotation - startRotation) * eased;
        
        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          lidGroup.userData.isOpen = !isOpen;
        }
      }
      
      animate();
    }
    
    function toggleInteriorDoor(doorGroup, maxAngle) {
      const isOpen = doorGroup.userData.isOpen || false;
      const targetRotation = isOpen ? 0 : (maxAngle * Math.PI / 180);
      
      // Animate door rotation
      const startRotation = doorGroup.rotation.y;
      const duration = 600; // ms
      const startTime = Date.now();
      
      function animate() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const eased = 1 - Math.pow(1 - progress, 3); // Ease out cubic
        
        doorGroup.rotation.y = startRotation + (targetRotation - startRotation) * eased;
        
        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          doorGroup.userData.isOpen = !isOpen;
        }
      }
      
      animate();
    }
    */ // END COMMENTED OUT onInteriorsClick and animation functions - now using imported versions
    
    // ==================== CEILING GENERATION ====================
    
    function generateInteriorCeiling(bounds) {
      const width = (bounds.maxX - bounds.minX) * INTERIORS_GRID_SIZE;
      const depth = (bounds.maxZ - bounds.minZ) * INTERIORS_GRID_SIZE;
      const centerX = (bounds.minX + bounds.maxX) / 2 * INTERIORS_GRID_SIZE;
      const centerZ = (bounds.minZ + bounds.maxZ) / 2 * INTERIORS_GRID_SIZE;
      
      const ceilingGeo = new THREE.PlaneGeometry(width, depth);
      const ceilingMat = new THREE.MeshStandardMaterial({
        color: 0xf5f5f5,
        roughness: 0.9
      });
      const ceiling = new THREE.Mesh(ceilingGeo, ceilingMat);
      ceiling.rotation.x = Math.PI / 2;
      ceiling.position.set(centerX, INTERIORS_WALL_HEIGHT, centerZ);
      ceiling.receiveShadow = true;
      interiorsGroup.add(ceiling);
      interiorRoomObjects.push(ceiling);
    }
    
    // ==================== FLOOR STYLING ====================
    
    function createInteriorFloorStyling(bounds, style) {
      style = style || ['hardwood', 'tile', 'carpet'][Math.floor(Math.random() * 3)];
      
      const width = (bounds.maxX - bounds.minX) * INTERIORS_GRID_SIZE;
      const depth = (bounds.maxZ - bounds.minZ) * INTERIORS_GRID_SIZE;
      const centerX = (bounds.minX + bounds.maxX) / 2 * INTERIORS_GRID_SIZE;
      const centerZ = (bounds.minZ + bounds.maxZ) / 2 * INTERIORS_GRID_SIZE;
      
      if (style === 'hardwood') {
        // Choose between strip or brick-laid pattern
        const useBrickLaid = Math.random() > 0.5;
        const woodColors = [0x8b7355, 0x9b8365, 0x7b6345, 0xab9375];
        
        if (useBrickLaid) {
          // Brick-laid hardwood (shorter planks, staggered)
          const plankLength = 0.6; // Shorter planks
          const plankWidth = 0.08;  // Narrower planks
          const numRows = Math.ceil(depth / plankWidth);
          
          for (let row = 0; row < numRows; row++) {
            const numPlanks = Math.ceil(width / plankLength);
            const offset = (row % 2) * (plankLength / 2); // Stagger every other row
            
            for (let col = 0; col < numPlanks + 1; col++) {
              const plankGeo = new THREE.PlaneGeometry(plankLength - 0.002, plankWidth - 0.001);
              const plankMat = new THREE.MeshStandardMaterial({
                color: woodColors[Math.floor(Math.random() * woodColors.length)],
                roughness: 0.8,
                metalness: 0.1
              });
              const plank = new THREE.Mesh(plankGeo, plankMat);
              plank.rotation.x = -Math.PI / 2;
              
              const xPos = bounds.minX * INTERIORS_GRID_SIZE + col * plankLength - offset + plankLength / 2;
              const zPos = bounds.minZ * INTERIORS_GRID_SIZE + row * plankWidth + plankWidth / 2;
              
              // Only add if within bounds
              if (xPos >= bounds.minX * INTERIORS_GRID_SIZE && xPos <= bounds.maxX * INTERIORS_GRID_SIZE) {
                plank.position.set(xPos, 0.001, zPos);
                plank.receiveShadow = true;
                interiorsGroup.add(plank);
                interiorRoomObjects.push(plank);
              }
            }
          }
        } else {
          // Strip hardwood (long planks)
          const plankWidth = 0.15;
          const numPlanks = Math.ceil(depth / plankWidth);
          
          for (let i = 0; i < numPlanks; i++) {
            const plankGeo = new THREE.PlaneGeometry(width, plankWidth);
            const plankMat = new THREE.MeshStandardMaterial({
              color: woodColors[Math.floor(Math.random() * woodColors.length)],
              roughness: 0.8,
              metalness: 0.1
            });
            const plank = new THREE.Mesh(plankGeo, plankMat);
            plank.rotation.x = -Math.PI / 2;
            plank.position.set(
              centerX,
              0.001,
              bounds.minZ * INTERIORS_GRID_SIZE + i * plankWidth + plankWidth / 2
            );
            plank.receiveShadow = true;
            interiorsGroup.add(plank);
            interiorRoomObjects.push(plank);
          }
        }
        
      } else if (style === 'tile') {
        // Square tiles
        const tileSize = 0.4;
        const tilesX = Math.ceil(width / tileSize);
        const tilesZ = Math.ceil(depth / tileSize);
        
        for (let x = 0; x < tilesX; x++) {
          for (let z = 0; z < tilesZ; z++) {
            const tileGeo = new THREE.PlaneGeometry(tileSize - 0.005, tileSize - 0.005);
            const isLight = (x + z) % 2 === 0;
            const tileMat = new THREE.MeshStandardMaterial({
              color: isLight ? 0xe0e0e0 : 0xc0c0c0,
              roughness: 0.3,
              metalness: 0.4
            });
            const tile = new THREE.Mesh(tileGeo, tileMat);
            tile.rotation.x = -Math.PI / 2;
            tile.position.set(
              bounds.minX * INTERIORS_GRID_SIZE + x * tileSize + tileSize / 2,
              0.001,
              bounds.minZ * INTERIORS_GRID_SIZE + z * tileSize + tileSize / 2
            );
            tile.receiveShadow = true;
            interiorsGroup.add(tile);
            interiorRoomObjects.push(tile);
          }
        }
        
      } else if (style === 'carpet') {
        // Soft carpet
        const carpetGeo = new THREE.PlaneGeometry(width, depth, 32, 32);
        const positions = carpetGeo.attributes.position;
        
        // Add subtle texture variation
        for (let i = 0; i < positions.count; i++) {
          const z = positions.getZ(i);
          positions.setZ(i, z + (Math.random() - 0.5) * 0.002);
        }
        carpetGeo.computeVertexNormals();
        
        const carpetColors = [0x4a5a6a, 0x6a5a4a, 0x5a6a5a, 0x6a4a5a];
        const carpetMat = new THREE.MeshStandardMaterial({
          color: carpetColors[Math.floor(Math.random() * carpetColors.length)],
          roughness: 0.95
        });
        const carpet = new THREE.Mesh(carpetGeo, carpetMat);
        carpet.rotation.x = -Math.PI / 2;
        carpet.position.set(centerX, 0.001, centerZ);
        carpet.receiveShadow = true;
        interiorsGroup.add(carpet);
        interiorRoomObjects.push(carpet);
      }
    }
    
    // ==================== NEW ARCHITECTURAL ROOM PLANNING SYSTEM ====================
    // This system generates apartments from scratch using architectural principles
    
    class ApartmentArchitect {
      constructor(apartmentType) {
        this.type = apartmentType; // 'studio', '1br', '2br', '3br'
        this.apartmentBounds = null;
        this.rooms = [];
        this.walls = [];
        this.doors = [];
        this.furniture = [];
        this.grid = null; // Grid system for collision detection
      }
      
      // Step 1: Define overall apartment bounding box
      defineApartmentBounds() {
        const sizes = {
          'studio': { width: 12, depth: 12 },
          '1br': { width: 14, depth: 14 },
          '2br': { width: 18, depth: 14 },
          '3br': { width: 22, depth: 16 }
        };
        const size = sizes[this.type] || sizes['studio'];
        
        this.apartmentBounds = {
          minX: -size.width / 2,
          maxX: size.width / 2,
          minZ: -size.depth / 2,
          maxZ: size.depth / 2
        };
        
        // Initialize collision grid (0.5m cells)
        this.gridSize = 0.5;
        this.gridWidth = Math.ceil(size.width / this.gridSize);
        this.gridDepth = Math.ceil(size.depth / this.gridSize);
        this.grid = Array(this.gridWidth * this.gridDepth).fill(false);
        
        console.log(`üèóÔ∏è Apartment bounds: ${size.width}x${size.depth}m`);
      }
      
      // Step 2: Subdivide into rectangular room partitions
      subdivideIntoRooms() {
        const bounds = this.apartmentBounds;
        const mainRoomDepth = 8; // Main room depth
        
        // Define main room (living + kitchen area)
        const mainRoom = {
          type: 'mainroom',
          minX: bounds.minX,
          maxX: bounds.maxX,
          minZ: bounds.minZ,
          maxZ: bounds.minZ + mainRoomDepth,
          hasExitDoor: true
        };
        this.rooms.push(mainRoom);
        
        // Define bathroom (always on the side)
        const bathroomWidth = 3;
        const bathroomDepth = 5;
        const bathroom = {
          type: 'bathroom',
          minX: bounds.maxX - bathroomWidth,
          maxX: bounds.maxX,
          minZ: bounds.minZ,
          maxZ: bounds.minZ + bathroomDepth
        };
        this.rooms.push(bathroom);
        
        // Add bedrooms based on type
        if (this.type === '1br') {
          const bedroom = {
            type: 'bedroom',
            minX: bounds.minX,
            maxX: bounds.maxX,
            minZ: mainRoom.maxZ,
            maxZ: bounds.maxZ
          };
          this.rooms.push(bedroom);
        } else if (this.type === '2br') {
          const bedroomWidth = (bounds.maxX - bounds.minX) / 2;
          this.rooms.push({
            type: 'bedroom',
            minX: bounds.minX,
            maxX: bounds.minX + bedroomWidth,
            minZ: mainRoom.maxZ,
            maxZ: bounds.maxZ
          });
          this.rooms.push({
            type: 'bedroom',
            minX: bounds.minX + bedroomWidth,
            maxX: bounds.maxX,
            minZ: mainRoom.maxZ,
            maxZ: bounds.maxZ
          });
        } else if (this.type === '3br') {
          const bedroomWidth = (bounds.maxX - bounds.minX) / 3;
          for (let i = 0; i < 3; i++) {
            this.rooms.push({
              type: 'bedroom',
              minX: bounds.minX + i * bedroomWidth,
              maxX: bounds.minX + (i + 1) * bedroomWidth,
              minZ: mainRoom.maxZ,
              maxZ: bounds.maxZ
            });
          }
        }
        
        // Add entryway if space allows
        if ((mainRoom.maxX - mainRoom.minX) > 10) {
          const entryWidth = 4;
          this.rooms.push({
            type: 'entryway',
            minX: (mainRoom.minX + mainRoom.maxX) / 2 - entryWidth / 2,
            maxX: (mainRoom.minX + mainRoom.maxX) / 2 + entryWidth / 2,
            minZ: bounds.minZ - 2,
            maxZ: bounds.minZ
          });
        }
        
        console.log(`üèóÔ∏è Created ${this.rooms.length} room partitions`);
      }
      
      // Step 3: Calculate door positions (bedrooms MUST connect to main room)
      calculateDoorPositions() {
        const mainRoom = this.rooms.find(r => r.type === 'mainroom');
        const bathroom = this.rooms.find(r => r.type === 'bathroom');
        
        this.rooms.forEach(room => {
          if (room.type === 'mainroom') {
            // Main room gets exit door at front
            this.doors.push({
              fromRoom: room,
              toRoom: 'outside',
              x: (room.minX + room.maxX) / 2,
              z: room.minZ,
              dir: 'h',
              width: 1.0
            });
          } else if (room.type === 'bedroom') {
            // Bedrooms connect to main room at the shared wall
            const sharedWallZ = mainRoom.maxZ;
            this.doors.push({
              fromRoom: room,
              toRoom: mainRoom,
              x: (room.minX + room.maxX) / 2,
              z: sharedWallZ,
              dir: 'h',
              width: 0.9
            });
          } else if (room.type === 'bathroom') {
            // Bathroom door to main room
            const doorX = bathroom.minX;
            this.doors.push({
              fromRoom: bathroom,
              toRoom: mainRoom,
              x: doorX,
              z: (bathroom.minZ + bathroom.maxZ) / 2,
              dir: 'v',
              width: 0.9
            });
          } else if (room.type === 'entryway') {
            // Entryway connects to main room
            this.doors.push({
              fromRoom: room,
              toRoom: mainRoom,
              x: (room.minX + room.maxX) / 2,
              z: room.maxZ,
              dir: 'h',
              width: 1.0
            });
          }
        });
        
        console.log(`üö™ Calculated ${this.doors.length} door positions`);
      }
      
      // Step 4: Build wall geometries
      buildWalls() {
        this.rooms.forEach(room => {
          const walls = [
            { x: room.minX, z: room.minZ, dir: 'h', length: room.maxX - room.minX }, // North
            { x: room.minX, z: room.maxZ, dir: 'h', length: room.maxX - room.minX }, // South
            { x: room.minX, z: room.minZ, dir: 'v', length: room.maxZ - room.minZ }, // West
            { x: room.maxX, z: room.minZ, dir: 'v', length: room.maxZ - room.minZ }  // East
          ];
          
          walls.forEach(wall => {
            // Check if this wall has a door
            const hasDoor = this.doors.some(door => {
              if (wall.dir === 'h') {
                return Math.abs(door.z - wall.z) < 0.1 && 
                       door.x >= wall.x && door.x <= wall.x + wall.length;
              } else {
                return Math.abs(door.x - wall.x) < 0.1 && 
                       door.z >= wall.z && door.z <= wall.z + wall.length;
              }
            });
            
            this.walls.push({ ...wall, hasDoor, room });
          });
        });
        
        console.log(`üß± Built ${this.walls.length} wall segments`);
      }
      
      // Step 5: Place furniture by room type with collision detection
      placeFurniture() {
        this.rooms.forEach(room => {
          const roomCenter = {
            x: (room.minX + room.maxX) / 2,
            z: (room.minZ + room.maxZ) / 2
          };
          
          switch(room.type) {
            case 'mainroom':
              this.placeLivingRoomFurniture(room);
              this.placeKitchenFurniture(room);
              break;
            case 'bedroom':
              this.placeBedroomFurniture(room);
              break;
            case 'bathroom':
              this.placeBathroomFurniture(room);
              break;
            case 'entryway':
              this.placeEntrywayFurniture(room);
              break;
          }
        });
        
        console.log(`ü™ë Placed ${this.furniture.length} furniture items`);
      }
      
      placeLivingRoomFurniture(room) {
        const width = room.maxX - room.minX;
        const depth = room.maxZ - room.minZ;
        
        // TV Stand and TV (against front wall)
        this.furniture.push({ 
          type: 'tvstand', 
          x: (room.minX + room.maxX) / 2, 
          z: room.minZ + 1, 
          rotation: 0 
        });
        this.furniture.push({ 
          type: 'tv', 
          x: (room.minX + room.maxX) / 2, 
          z: room.minZ + 1, 
          y: 0.55, 
          rotation: 0 
        });
        
        // Couch (facing TV)
        this.furniture.push({ 
          type: 'couch', 
          x: (room.minX + room.maxX) / 2, 
          z: room.minZ + 3.5, 
          rotation: Math.PI 
        });
        
        // Coffee table (in front of couch)
        this.furniture.push({ 
          type: 'coffeetable', 
          x: (room.minX + room.maxX) / 2, 
          z: room.minZ + 2.5, 
          shape: 'rectangle',
          rotation: 0 
        });
        
        // Dining table (if space allows)
        if (width > 10) {
          this.furniture.push({ 
            type: 'diningtable', 
            x: room.minX + 3, 
            z: room.minZ + 3, 
            rotation: 0 
          });
        }
      }
      
      placeKitchenFurniture(room) {
        // Kitchen counter (right side)
        this.furniture.push({ 
          type: 'counter', 
          x: room.maxX - 2, 
          z: room.minZ + 2, 
          rotation: Math.PI 
        });
        
        // Fridge (near counter)
        this.furniture.push({ 
          type: 'fridge', 
          x: room.maxX - 1, 
          z: room.minZ + 3.5, 
          rotation: -Math.PI / 2 
        });
        
        // Microwave (on counter)
        this.furniture.push({ 
          type: 'microwave', 
          x: room.maxX - 2, 
          z: room.minZ + 2, 
          y: 0.95, 
          rotation: Math.PI 
        });
      }
      
      placeBedroomFurniture(room) {
        // Bed (against back wall)
        this.furniture.push({ 
          type: 'bed', 
          x: (room.minX + room.maxX) / 2, 
          z: room.maxZ - 1.5, 
          rotation: Math.PI 
        });
        
        // Side table
        this.furniture.push({ 
          type: 'sidetable', 
          x: room.minX + 1.5, 
          z: room.maxZ - 1.5, 
          rotation: 0 
        });
        
        // Closet (in corner)
        this.furniture.push({ 
          type: 'closet', 
          x: room.minX + 0.8, 
          z: room.minZ + 0.8, 
          rotation: 0 
        });
      }
      
      placeBathroomFurniture(room) {
        // Toilet (corner)
        this.furniture.push({ 
          type: 'toilet', 
          x: room.minX + 0.8, 
          z: room.minZ + 0.8, 
          rotation: 0 
        });
        
        // Shower (opposite corner)
        this.furniture.push({ 
          type: 'shower', 
          x: room.maxX - 0.6, 
          z: room.minZ + 0.6, 
          rotation: 0 
        });
        
        // Sink (along wall)
        this.furniture.push({ 
          type: 'bathroomsink', 
          x: (room.minX + room.maxX) / 2, 
          z: room.maxZ - 0.5, 
          rotation: Math.PI 
        });
      }
      
      placeEntrywayFurniture(room) {
        // Shoe rack (corner near entrance)
        this.furniture.push({ 
          type: 'shoerack', 
          x: room.minX + 0.5, 
          z: room.minZ + 0.5, 
          rotation: 0 
        });
        
        // Umbrella stand (other corner)
        this.furniture.push({ 
          type: 'umbrellastand', 
          x: room.maxX - 0.5, 
          z: room.minZ + 0.5, 
          rotation: 0 
        });
      }
      
      // Generate complete configuration
      generate() {
        this.defineApartmentBounds();
        this.subdivideIntoRooms();
        this.calculateDoorPositions();
        this.buildWalls();
        this.placeFurniture();
        
        return {
          name: this.type.toUpperCase() + ' Apartment',
          mainRoom: 'living',
          floorBounds: this.apartmentBounds,
          bathroom: null, // Will be handled by room system
          walls: this.walls,
          furniture: this.furniture,
          rooms: this.rooms,
          doors: this.doors
        };
      }
    }
    
    function generateInteriorRoom(roomType, useRandom = false) {
      // Use NEW architectural system
      console.log(`üèóÔ∏è Generating ${roomType} using Architectural Planning System...`);
      const architect = new ApartmentArchitect(roomType);
      let config = architect.generate();
      
      console.log(`‚úÖ Generated apartment with ${config.rooms.length} rooms, ${config.walls.length} walls, ${config.furniture.length} furniture items`);
      
      // Apply room construction policies
      config = applyRoomConstructionPolicies(config);
      
      // Generate styled floor (hardwood, tile, or carpet)
      const floorStyle = config.floorStyle || 'hardwood';
      createInteriorFloorStyling(config.floorBounds, floorStyle);
      
      // Generate bathroom floor if defined
      if (config.bathroom) {
        const bath = config.bathroom;
        
        // Create individual tiles for proper alignment with walls
        const tileSize = 0.4; // Physical tile size in meters
        const tilesX = Math.ceil(bath.width / tileSize);
        const tilesZ = Math.ceil(bath.depth / tileSize);
        
        // Calculate bathroom bounds (bathroom config uses center position)
        const bathMinX = (bath.x - bath.width / 2) * INTERIORS_GRID_SIZE;
        const bathMinZ = (bath.z - bath.depth / 2) * INTERIORS_GRID_SIZE;
        
        for (let x = 0; x < tilesX; x++) {
          for (let z = 0; z < tilesZ; z++) {
            const tileGeo = new THREE.PlaneGeometry(tileSize - 0.005, tileSize - 0.005);
            const isWhite = (x + z) % 2 === 0;
            const tileMat = new THREE.MeshStandardMaterial({
              color: isWhite ? 0xffffff : 0x4488ff,
              roughness: 0.3,
              metalness: 0.4
            });
            const tile = new THREE.Mesh(tileGeo, tileMat);
            tile.rotation.x = -Math.PI / 2;
            tile.position.set(
              bathMinX + x * tileSize + tileSize / 2,
              0.01, // Slightly above main floor
              bathMinZ + z * tileSize + tileSize / 2
            );
            tile.receiveShadow = true;
            interiorsGroup.add(tile);
            interiorRoomObjects.push(tile);
          }
        }
      }
      
      // Generate ceiling
      generateInteriorCeiling(config.floorBounds);
      
      // Generate walls
      config.walls.forEach(wallSpec => {
        const wall = createInteriorWall(wallSpec);
        if (wall) interiorsGroup.add(wall);
      });
      
      // Generate kitchen partition with tiled floor overlay if defined
      if (config.kitchenPartition) {
        const kitchen = config.kitchenPartition;
        // Kitchen tiles overlay on top of main floor
        const kitchenTileSize = 0.3;
        const tilesX = Math.ceil(kitchen.width / kitchenTileSize);
        const tilesZ = Math.ceil(kitchen.depth / kitchenTileSize);
        
        for (let x = 0; x < tilesX; x++) {
          for (let z = 0; z < tilesZ; z++) {
            const tileGeo = new THREE.PlaneGeometry(kitchenTileSize - 0.005, kitchenTileSize - 0.005);
            const isLight = (x + z) % 2 === 0;
            const tileMat = new THREE.MeshStandardMaterial({
              color: isLight ? 0xffffff : 0xdddddd,
              roughness: 0.2,
              metalness: 0.5
            });
            const tile = new THREE.Mesh(tileGeo, tileMat);
            tile.rotation.x = -Math.PI / 2;
            tile.position.set(
              kitchen.x * INTERIORS_GRID_SIZE + x * kitchenTileSize + kitchenTileSize / 2 - kitchen.width / 2,
              0.002, // Slightly above main floor
              kitchen.z * INTERIORS_GRID_SIZE + z * kitchenTileSize + kitchenTileSize / 2 - kitchen.depth / 2
            );
            tile.receiveShadow = true;
            interiorsGroup.add(tile);
            interiorRoomObjects.push(tile);
          }
        }
      }
      
      // Generate furniture
      config.furniture.forEach(item => {
        const furniture = createInteriorFurniture(item);
        if (furniture) {
          interiorRoomObjects.push(furniture);
          interiorsGroup.add(furniture);
        }
      });
      
      // Add lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
      interiorsGroup.add(ambientLight);
      
      const pointLight = new THREE.PointLight(0xffffff, 1.0, 20);
      pointLight.position.set(0, 2.0, 0);
      pointLight.castShadow = true;
      interiorsGroup.add(pointLight);
    }
    
    function createInteriorWall(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const length = spec.length * INTERIORS_GRID_SIZE;
      const isHorizontal = spec.dir === 'h';
      
      if (spec.hasDoor) {
        // Wall with door opening
        const doorWidth = 0.9;
        const segment1Len = (length - doorWidth) / 2;
        
        if (segment1Len > 0.05) {
          const wallGeo1 = new THREE.BoxGeometry(
            isHorizontal ? segment1Len : INTERIORS_WALL_THICKNESS,
            INTERIORS_WALL_HEIGHT,
            isHorizontal ? INTERIORS_WALL_THICKNESS : segment1Len
          );
          const wallMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.8 });
          const wall1 = new THREE.Mesh(wallGeo1, wallMat);
          wall1.castShadow = true;
          wall1.receiveShadow = true;
          
          const wall2 = wall1.clone();
          
          if (isHorizontal) {
            wall1.position.set(spec.x * INTERIORS_GRID_SIZE + segment1Len / 2, INTERIORS_WALL_HEIGHT / 2, spec.z * INTERIORS_GRID_SIZE);
            wall2.position.set(spec.x * INTERIORS_GRID_SIZE + segment1Len + doorWidth + segment1Len / 2, INTERIORS_WALL_HEIGHT / 2, spec.z * INTERIORS_GRID_SIZE);
          } else {
            wall1.position.set(spec.x * INTERIORS_GRID_SIZE, INTERIORS_WALL_HEIGHT / 2, spec.z * INTERIORS_GRID_SIZE + segment1Len / 2);
            wall2.position.set(spec.x * INTERIORS_GRID_SIZE, INTERIORS_WALL_HEIGHT / 2, spec.z * INTERIORS_GRID_SIZE + segment1Len + doorWidth + segment1Len / 2);
          }
          
          group.add(wall1);
          group.add(wall2);
        }
      } else {
        // Solid wall
        const wallGeo = new THREE.BoxGeometry(
          isHorizontal ? length : INTERIORS_WALL_THICKNESS,
          INTERIORS_WALL_HEIGHT,
          isHorizontal ? INTERIORS_WALL_THICKNESS : length
        );
        const wallMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.8 });
        const wall = new THREE.Mesh(wallGeo, wallMat);
        wall.position.set(
          spec.x * INTERIORS_GRID_SIZE + (isHorizontal ? length / 2 : 0),
          INTERIORS_WALL_HEIGHT / 2,
          spec.z * INTERIORS_GRID_SIZE + (isHorizontal ? 0 : length / 2)
        );
        wall.castShadow = true;
        wall.receiveShadow = true;
        group.add(wall);
      }
      
      return group;
    }
    
    function createInteriorFurniture(spec) {
      // Dispatch to the universal asset creation functions
      // Convert spec to use INTERIORS_GRID_SIZE
      const assetSpec = {
        ...spec,
        GRID_SIZE: INTERIORS_GRID_SIZE,
        scene: interiorsGroup,
        objects: interiorRoomObjects,
        interactiveObjects: interiorInteractiveObjects
      };
      
      // Map spec type to create function
      const createFunctions = {
        // Core functions that need to exist
        'toilet': createInteriorToilet,
        'shower': createInteriorShower,
        'bed': createInteriorBed,
        'rug': createInteriorRug,
        'desk': createInteriorDesk,
        'counter': createInteriorCounter,
        'plant': createInteriorPlant,
        'plate': createInteriorPlate,
        'bowl': createInteriorBowl,
        'fruitbowl': createInteriorFruitBowl,
        'couch': createCouch,
        'tv': createTV,
        'tvstand': createTVStand,
        'coffeetable': createCoffeeTable,
        'gameboard': createGameBoard,
        'chesspawn': createChessPawn,
        'dice': createDice,
        'pokerchip': createPokerChip,
        'floorlamp': createFloorLamp,
        'artframe': createArtFrame,
        'plant': createInteriorPlant,
        'sidetable': createSideTable,
        'alarmclock': createAlarmClock,
        'closet': createCloset,
        'entrancedoor': createEntranceDoor,
        'computerdesk': createComputerDesk,
        'clock': createWallClock,
        'bathroomsink': createInteriorBathroomSink,
        'microwave': createMicrowave,
        'sodacan': createSodaCan,
        'cerealbox': createCerealBox,
        'crackerbox': createCrackerBox,
        'computertower': createComputerTower,
        'broom': createBroom,
        'dustpan': createDustpan,
        'vacuum': createVacuum,
        'handheldvacuum': createHandheldVacuum,
        'bucket': createBucket,
        'sponge': createSponge,
        'rag': createRag,
        'papertowelroll': createPaperTowelRoll,
        'toiletpaperroll': createToiletPaperRoll,
        'jengatower': createJengaTower,
        'desklamp': createDeskLamp,
        'pixarball': createPixarBall,
        'basketball': createBasketball,
        'baseball': createBaseball,
        'rug': createRug,
        'shelf': createShelf,
        'wallshelf': createWallShelf,
        'shelfunit': createShelfUnit,
        'ceilinglight': createCeilingLight,
        'fork': createInteriorFork,
        'knife': createInteriorKnife,
        'spoon': createInteriorSpoon,
        'refrigerator': createInteriorRefrigerator,
        'fridge': createInteriorRefrigerator,
        'milkcarton': createMilkCarton,
        'orangejuice': createOrangeJuice,
        'cheese': createCheese,
        'eggs': createEggs,
        'remote': createRemote,
        'tvremote': createRemote,  // Alias for remote
        'gameconsole': createGameConsole,
        'gamecontroller': createGameController,
        'dvd': createDVD,
        'dvdcase': createDVDCase,
        'playingcard': createPlayingCard,
        'cactus': createCactus,
        'cup': createCup,
        'mug': createMug,
        'jar': createJar,
        'pencil': createPencil,
        'notepad': createNotepad,
        'notebook': createNotebook,
        'stickynotes': createStickyNotes,
        // Children's toys
        'letterblock': createLetterBlock,
        'xylophone': createXylophone,
        'toycar': createToyCar,
        'toytrain': createToyTrain,
        'traintrack': createTrainTrack
      };
      
      const createFn = createFunctions[spec.type];
      if (createFn) {
        // Create the asset - it will handle its own positioning
        return createFn(assetSpec);
      } else {
        console.warn(`No create function for asset type: ${spec.type}`);
        // Return empty group as fallback
        const group = new THREE.Group();
        group.position.set(
          spec.x * INTERIORS_GRID_SIZE,
          spec.y || 0,
          spec.z * INTERIORS_GRID_SIZE
        );
        return group;
      }
    }
    
    // ==================== INTERIOR-SPECIFIC ASSET CREATORS ====================
    // These wrap the universal create functions for use in the interior system
    
    function createInteriorToilet(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      const t = INTERIORS_ASSETS.toilet;
      
      const porcelainMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.2,
        metalness: 0.1,
        side: THREE.DoubleSide  // Fix: render both sides for concave geometry
      });
      
      // === BOWL (stretched back hemisphere) ===
      const bowlGeo = new THREE.SphereGeometry(t.bowlRadius, 32, 16, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2);
      const bowl = new THREE.Mesh(bowlGeo, porcelainMat);
      bowl.scale.set(1, 1, 1.3); // Stretch back
      bowl.position.set(0, t.bowlHeight, 0);
      bowl.castShadow = true;
      bowl.receiveShadow = true;
      group.add(bowl);
      
      // === INNER BOWL (smaller nested hemisphere) ===
      const innerBowlGeo = new THREE.SphereGeometry(t.bowlRadius * 0.75, 32, 16, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2);
      const innerBowl = new THREE.Mesh(innerBowlGeo, porcelainMat);
      innerBowl.scale.set(1, 0.8, 1.3);
      innerBowl.position.set(0, t.bowlHeight + 0.02, 0);
      group.add(innerBowl);
      
      // === RIM (torus scaled to oval) ===
      const rimGeo = new THREE.TorusGeometry(t.bowlRadius * 0.9, 0.02, 16, 32);
      const rim = new THREE.Mesh(rimGeo, porcelainMat);
      rim.rotation.x = Math.PI / 2;
      rim.scale.set(1, 1.3, 1); // Oval shape
      rim.position.set(0, t.bowlHeight, 0);
      rim.castShadow = true;
      group.add(rim);
      
      // === SEAT (torus, thicker, oval) ===
      const seatGeo = new THREE.TorusGeometry(t.seatRadius, 0.03, 16, 32);
      const seatMat = new THREE.MeshStandardMaterial({
        color: 0xf5f5dc,
        roughness: 0.6
      });
      const seat = new THREE.Mesh(seatGeo, seatMat);
      seat.rotation.x = Math.PI / 2;
      seat.scale.set(1, 1.3, 1);
      seat.position.set(0, t.bowlHeight + 0.02, 0);
      seat.castShadow = true;
      group.add(seat);
      
      // === LID (interactive, hinged at back edge) ===
      const lidGroup = new THREE.Group();
      
      // Hinge point will be at back edge of seat
      const lidGeo = new THREE.TorusGeometry(t.seatRadius, 0.025, 16, 32);
      const lid = new THREE.Mesh(lidGeo, seatMat);
      lid.rotation.x = Math.PI / 2;
      lid.scale.set(1, 1.3, 1);
      lid.position.z = t.seatRadius * 1.3; // Move forward so back edge is at hinge (origin)
      lid.castShadow = true;
      lidGroup.add(lid);
      
      // Lid cover disc
      const lidCoverGeo = new THREE.CircleGeometry(t.seatRadius, 32);
      const lidCover = new THREE.Mesh(lidCoverGeo, seatMat);
      lidCover.rotation.x = -Math.PI / 2;
      lidCover.scale.set(1, 1.3, 1);
      lidCover.position.z = t.seatRadius * 1.3; // Move forward to match lid
      lidCover.castShadow = true;
      lidGroup.add(lidCover);
      
      // Position group at back edge of seat (hinge point)
      lidGroup.position.set(0, t.bowlHeight + 0.02, -t.seatRadius * 1.3);
      lidGroup.userData.isLid = true;
      lidGroup.userData.isOpen = false;
      lidGroup.userData.hingeAxis = new THREE.Vector3(1, 0, 0);
      group.add(lidGroup);
      
      // Register as interactive
      interiorInteractiveObjects.push(lidGroup);
      
      // === TANK (back) ===
      const tankGeo = new THREE.BoxGeometry(t.tankWidth, t.tankHeight, t.tankDepth);
      const tank = new THREE.Mesh(tankGeo, porcelainMat);
      tank.position.set(0, t.bowlHeight + t.tankHeight / 2, -t.bowlRadius * 1.3);
      tank.castShadow = true;
      tank.receiveShadow = true;
      group.add(tank);
      
      // === FLUSH LEVER (cylinder + platform) ===
      const leverGroup = new THREE.Group();
      const leverHandleGeo = new THREE.CylinderGeometry(0.008, 0.008, 0.1, 8);
      const leverMat = new THREE.MeshStandardMaterial({
        color: 0xc0c0c0,
        roughness: 0.4,
        metalness: 0.8
      });
      const leverHandle = new THREE.Mesh(leverHandleGeo, leverMat);
      leverHandle.rotation.z = Math.PI / 2;
      leverGroup.add(leverHandle);
      
      const leverPlatformGeo = new THREE.BoxGeometry(0.06, 0.03, 0.02);
      const leverPlatform = new THREE.Mesh(leverPlatformGeo, leverMat);
      leverPlatform.position.set(0.05, 0, 0);
      leverGroup.add(leverPlatform);
      
      leverGroup.position.set(-t.tankWidth / 2 + 0.05, t.bowlHeight + t.tankHeight * 0.7, -t.bowlRadius * 1.3 + t.tankDepth / 2);
      leverGroup.castShadow = true;
      leverGroup.userData.isFlushHandle = true;
      leverGroup.userData.isFlushed = false;
      group.add(leverGroup);
      
      // Register flush handle as interactive
      interiorInteractiveObjects.push(leverGroup);
      
      // Position entire toilet
      group.position.set(spec.x * INTERIORS_GRID_SIZE, 0, spec.z * INTERIORS_GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      return group;
    }
    
    function createInteriorShower(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      const s = INTERIORS_ASSETS.shower;
      
      // Micro-tiled floor
      const tileSize = 0.05;
      const tilesX = Math.floor(s.width / tileSize);
      const tilesZ = Math.floor(s.depth / tileSize);
      
      for (let i = 0; i < tilesX; i++) {
        for (let j = 0; j < tilesZ; j++) {
          const tileGeo = new THREE.BoxGeometry(tileSize * 0.98, 0.01, tileSize * 0.98);
          const tileMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
          const tile = new THREE.Mesh(tileGeo, tileMat);
          tile.position.set(
            -s.width / 2 + i * tileSize + tileSize / 2,
            0.005,
            -s.depth / 2 + j * tileSize + tileSize / 2
          );
          tile.receiveShadow = true;
          group.add(tile);
        }
      }
      
      // Walls
      const wallMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.4,
        side: THREE.DoubleSide
      });
      
      const backWallGeo = new THREE.PlaneGeometry(s.width, s.height);
      const backWall = new THREE.Mesh(backWallGeo, wallMat);
      backWall.position.set(0, s.height / 2, -s.depth / 2);
      group.add(backWall);
      
      const leftWallGeo = new THREE.PlaneGeometry(s.depth, s.height);
      const leftWall = new THREE.Mesh(leftWallGeo, wallMat);
      leftWall.rotation.y = Math.PI / 2;
      leftWall.position.set(-s.width / 2, s.height / 2, 0);
      group.add(leftWall);
      
      const rightWall = leftWall.clone();
      rightWall.position.set(s.width / 2, s.height / 2, 0);
      group.add(rightWall);
      
      group.position.set(spec.x * INTERIORS_GRID_SIZE, 0, spec.z * INTERIORS_GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      return group;
    }
    
    function createInteriorBed(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      const isChildBed = spec.size === 'child';
      const b = isChildBed ? INTERIORS_ASSETS.childbed : INTERIORS_ASSETS.bed;
      
      // Color scheme for child bed - use position-based randomization for unique results per bed
      let bedColor = spec.color;
      if (!bedColor && isChildBed) {
        // Create unique seed from position coordinates
        const positionSeed = Math.abs(Math.sin(spec.x * 12.9898 + spec.z * 78.233) * 43758.5453);
        const seedValue = positionSeed - Math.floor(positionSeed);
        
        // Randomly choose between blue, pink, and light pink
        if (seedValue < 0.33) {
          bedColor = 'blue';
        } else if (seedValue < 0.66) {
          bedColor = 'pink';
        } else {
          bedColor = 'lightpink';
        }
      } else if (!bedColor) {
        bedColor = 'white';
      }
      
      // Frame
      const frameGeo = new THREE.BoxGeometry(b.width + 0.1, b.legHeight, b.depth + 0.1);
      const frameMat = new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.8 });
      const frame = new THREE.Mesh(frameGeo, frameMat);
      frame.position.y = b.legHeight / 2;
      frame.castShadow = true;
      group.add(frame);
      
      // Mattress with rounded corners
      const cornerRadius = 0.05;
      const mattressShape = new THREE.Shape();
      const w = b.width / 2 - cornerRadius;
      const d = b.depth / 2 - cornerRadius;
      
      mattressShape.moveTo(-w, -d);
      mattressShape.lineTo(w, -d);
      mattressShape.quadraticCurveTo(w + cornerRadius, -d, w + cornerRadius, -d + cornerRadius);
      mattressShape.lineTo(w + cornerRadius, d);
      mattressShape.quadraticCurveTo(w + cornerRadius, d + cornerRadius, w, d + cornerRadius);
      mattressShape.lineTo(-w, d + cornerRadius);
      mattressShape.quadraticCurveTo(-w - cornerRadius, d + cornerRadius, -w - cornerRadius, d);
      mattressShape.lineTo(-w - cornerRadius, -d + cornerRadius);
      mattressShape.quadraticCurveTo(-w - cornerRadius, -d, -w, -d);
      
      const extrudeSettings = { depth: b.height, bevelEnabled: false };
      const mattressGeo = new THREE.ExtrudeGeometry(mattressShape, extrudeSettings);
      const mattressMat = new THREE.MeshStandardMaterial({ color: 0xf5f5dc, roughness: 0.9 });
      const mattress = new THREE.Mesh(mattressGeo, mattressMat);
      mattress.rotation.x = -Math.PI / 2;
      mattress.position.y = b.legHeight;
      mattress.castShadow = true;
      group.add(mattress);
      
      // Pillows with rounded corners
      const pillowCount = isChildBed ? 1 : 2;
      const pillowWidth = isChildBed ? 0.25 : 0.35;
      const pillowDepth = isChildBed ? 0.15 : 0.2;
      const pillowHeight = isChildBed ? 0.08 : 0.12;
      
      // Create rounded pillow geometry (soft, rounded corners)
      const createRoundedPillowGeometry = (width, height, depth) => {
        const radius = Math.min(width, height, depth) * 0.15; // Corner radius
        const shape = new THREE.Shape();
        
        // Create rounded rectangle profile
        const hw = width / 2 - radius;
        const hd = depth / 2 - radius;
        
        shape.moveTo(-hw, -hd);
        shape.lineTo(hw, -hd);
        shape.quadraticCurveTo(hw + radius, -hd, hw + radius, -hd + radius);
        shape.lineTo(hw + radius, hd);
        shape.quadraticCurveTo(hw + radius, hd + radius, hw, hd + radius);
        shape.lineTo(-hw, hd + radius);
        shape.quadraticCurveTo(-hw - radius, hd + radius, -hw - radius, hd);
        shape.lineTo(-hw - radius, -hd + radius);
        shape.quadraticCurveTo(-hw - radius, -hd, -hw, -hd);
        
        const extrudeSettings = {
          depth: height,
          bevelEnabled: true,
          bevelThickness: radius * 0.5,
          bevelSize: radius * 0.5,
          bevelSegments: 4,
          curveSegments: 8
        };
        
        const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        geometry.rotateX(Math.PI / 2);
        geometry.translate(0, 0, 0);
        
        return geometry;
      };
      
      for (let i = 0; i < pillowCount; i++) {
        const pillowGeo = createRoundedPillowGeometry(pillowWidth, pillowHeight, pillowDepth);
        const pillowMat = new THREE.MeshStandardMaterial({ 
          color: 0xffffff, 
          roughness: 0.8,
          metalness: 0.0
        });
        const pillow = new THREE.Mesh(pillowGeo, pillowMat);
        const xOffset = pillowCount === 1 ? 0 : (i === 0 ? -b.width / 4 : b.width / 4);
        pillow.position.set(xOffset, b.legHeight + b.height + pillowHeight / 2, -b.depth / 2 + pillowDepth / 2 + 0.05);
        pillow.castShadow = true;
        group.add(pillow);
      }
      
      // Blanket/Comforter
      const blanketGeo = new THREE.PlaneGeometry(b.width * 0.95, b.depth * 0.85, 16, 16);
      
      // Add some wrinkle deformation
      const positions = blanketGeo.attributes.position;
      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const y = positions.getY(i);
        const wrinkle = Math.sin(x * 15) * Math.cos(y * 12) * 0.015;
        positions.setZ(i, wrinkle);
      }
      positions.needsUpdate = true;
      blanketGeo.computeVertexNormals();
      
      let blanketColor, sheetColor;
      if (isChildBed) {
        if (bedColor === 'blue') {
          blanketColor = 0x000080; // Navy blue
          sheetColor = 0xffffff;   // White sheet underneath
        } else if (bedColor === 'pink') {
          blanketColor = 0xffb6c1; // Light pink
          sheetColor = 0xffffff;   // White sheet
        } else if (bedColor === 'lightpink') {
          blanketColor = 0xffc0cb; // Lighter pink
          sheetColor = 0xffffff;   // White sheet
        } else {
          blanketColor = 0xffb6c1; // Default pink
          sheetColor = 0xffffff;   // White sheet
        }
      } else {
        blanketColor = 0x8b7355; // Adult: neutral brown/tan
        sheetColor = 0xf5f5dc;   // Beige
      }
      
      // Sheet (under blanket)
      const sheetMat = new THREE.MeshStandardMaterial({ color: sheetColor, roughness: 0.7, side: THREE.DoubleSide });
      const sheet = new THREE.Mesh(blanketGeo.clone(), sheetMat);
      sheet.rotation.x = -Math.PI / 2;
      sheet.position.y = b.legHeight + b.height + 0.02;
      sheet.castShadow = true;
      sheet.receiveShadow = true;
      group.add(sheet);
      
      // Blanket with decorations
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const canvasCtx = canvas.getContext('2d');
      canvasCtx.fillStyle = `#${blanketColor.toString(16).padStart(6, '0')}`;
      canvasCtx.fillRect(0, 0, 512, 512);
      
      // Add decorations for child beds
      if (isChildBed) {
        if (bedColor === 'blue') {
          // Stars on navy blanket
          canvasCtx.fillStyle = '#ffffff';
          for (let i = 0; i < 15; i++) {
            const sx = Math.random() * 512;
            const sy = Math.random() * 512;
            const size = 15 + Math.random() * 20;
            drawStar(canvasCtx, sx, sy, 5, size, size * 0.4);
          }
        } else if (bedColor === 'pink' || bedColor === 'lightpink') {
          // Hearts on pink blankets
          canvasCtx.fillStyle = bedColor === 'lightpink' ? '#ff1493' : '#ff69b4';
          for (let i = 0; i < 12; i++) {
            const hx = Math.random() * 512;
            const hy = Math.random() * 512;
            const size = 20 + Math.random() * 25;
            drawHeart(canvasCtx, hx, hy, size);
          }
        }
      }
      
      const blanketTexture = new THREE.CanvasTexture(canvas);
      const blanketMat = new THREE.MeshStandardMaterial({ 
        map: blanketTexture, 
        roughness: 0.8, 
        side: THREE.DoubleSide 
      });
      const blanket = new THREE.Mesh(blanketGeo.clone(), blanketMat);
      blanket.rotation.x = -Math.PI / 2;
      blanket.position.y = b.legHeight + b.height + 0.04;
      blanket.castShadow = true;
      blanket.receiveShadow = true;
      group.add(blanket);
      
      // Headboard
      const headboardGeo = new THREE.BoxGeometry(b.width + 0.15, isChildBed ? 0.6 : 1.0, 0.1);
      const headboard = new THREE.Mesh(headboardGeo, frameMat);
      headboard.position.set(0, isChildBed ? 0.3 : 0.5, -b.depth / 2 - 0.05);
      headboard.castShadow = true;
      group.add(headboard);
      
      group.position.set(spec.x * INTERIORS_GRID_SIZE, 0, spec.z * INTERIORS_GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      return group;
    }
    
    // Helper functions for drawing decorations on blankets
    function drawStar(ctx, x, y, spikes, outerRadius, innerRadius) {
      let rot = Math.PI / 2 * 3;
      let step = Math.PI / spikes;
      
      ctx.beginPath();
      ctx.moveTo(x, y - outerRadius);
      
      for (let i = 0; i < spikes; i++) {
        ctx.lineTo(x + Math.cos(rot) * outerRadius, y + Math.sin(rot) * outerRadius);
        rot += step;
        ctx.lineTo(x + Math.cos(rot) * innerRadius, y + Math.sin(rot) * innerRadius);
        rot += step;
      }
      
      ctx.lineTo(x, y - outerRadius);
      ctx.closePath();
      ctx.fill();
    }
    
    function drawHeart(ctx, x, y, size) {
      ctx.beginPath();
      const topCurveHeight = size * 0.3;
      ctx.moveTo(x, y + topCurveHeight);
      // Top left curve
      ctx.bezierCurveTo(
        x, y, 
        x - size / 2, y, 
        x - size / 2, y + topCurveHeight
      );
      // Bottom left curve
      ctx.bezierCurveTo(
        x - size / 2, y + (size + topCurveHeight) / 2, 
        x, y + (size + topCurveHeight) / 1.5, 
        x, y + size
      );
      // Bottom right curve
      ctx.bezierCurveTo(
        x, y + (size + topCurveHeight) / 1.5, 
        x + size / 2, y + (size + topCurveHeight) / 2, 
        x + size / 2, y + topCurveHeight
      );
      // Top right curve
      ctx.bezierCurveTo(
        x + size / 2, y, 
        x, y, 
        x, y + topCurveHeight
      );
      ctx.closePath();
      ctx.fill();
    }
    
    function createInteriorRug(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const width = spec.width || 2.0;
      const depth = spec.depth || 1.5;
      const pattern = spec.pattern || 'persian';
      
      // Base rug geometry (slightly raised off floor)
      const rugGeo = new THREE.PlaneGeometry(width, depth, 20, 20);
      
      // Create canvas texture for rug pattern
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const canvasCtx = canvas.getContext('2d');
      
      // Draw pattern based on type
      if (pattern === 'persian') {
        // Persian rug - ornate border and center medallion
        canvasCtx.fillStyle = '#8B0000'; // Deep red base
        canvasCtx.fillRect(0, 0, 512, 512);
        
        // Ornate border
        canvasCtx.strokeStyle = '#FFD700'; // Gold
        canvasCtx.lineWidth = 20;
        canvasCtx.strokeRect(30, 30, 452, 452);
        
        // Inner border pattern
        canvasCtx.strokeStyle = '#4B0000'; // Dark red
        canvasCtx.lineWidth = 10;
        canvasCtx.strokeRect(50, 50, 412, 412);
        
        // Center medallion
        canvasCtx.beginPath();
        canvasCtx.ellipse(256, 256, 120, 80, 0, 0, Math.PI * 2);
        canvasCtx.fillStyle = '#FFD700';
        canvasCtx.fill();
        
        // Inner medallion details
        canvasCtx.beginPath();
        canvasCtx.ellipse(256, 256, 80, 50, 0, 0, Math.PI * 2);
        canvasCtx.fillStyle = '#8B0000';
        canvasCtx.fill();
        
        // Corner decorations
        for (let i = 0; i < 4; i++) {
          canvasCtx.save();
          canvasCtx.translate(256, 256);
          canvasCtx.rotate((i * Math.PI) / 2);
          canvasCtx.translate(-256, -256);
          canvasCtx.fillStyle = '#FFD700';
          canvasCtx.fillRect(100, 100, 40, 40);
          canvasCtx.restore();
        }
        
      } else if (pattern === 'modern') {
        // Modern geometric pattern
        canvasCtx.fillStyle = '#f5f5f5'; // Light gray base
        canvasCtx.fillRect(0, 0, 512, 512);
        
        // Diagonal stripes
        canvasCtx.strokeStyle = '#cccccc';
        canvasCtx.lineWidth = 30;
        for (let i = 0; i < 20; i++) {
          canvasCtx.beginPath();
          canvasCtx.moveTo(i * 50 - 200, 0);
          canvasCtx.lineTo(i * 50 + 312, 512);
          canvasCtx.stroke();
        }
        
      } else if (pattern === 'shag') {
        // Shag/fuzzy texture
        canvasCtx.fillStyle = '#d4a574'; // Tan base
        canvasCtx.fillRect(0, 0, 512, 512);
        
        // Random fuzzy texture
        for (let i = 0; i < 5000; i++) {
          const x = Math.random() * 512;
          const y = Math.random() * 512;
          const brightness = 150 + Math.random() * 100;
          canvasCtx.fillStyle = `rgb(${brightness}, ${brightness * 0.8}, ${brightness * 0.6})`;
          canvasCtx.fillRect(x, y, 3, 3);
        }
      }
      
      const rugTexture = new THREE.CanvasTexture(canvas);
      rugTexture.wrapS = rugTexture.wrapT = THREE.RepeatWrapping;
      
      const rugMat = new THREE.MeshStandardMaterial({
        map: rugTexture,
        roughness: 0.9,
        side: THREE.DoubleSide
      });
      
      const rug = new THREE.Mesh(rugGeo, rugMat);
      rug.rotation.x = -Math.PI / 2; // Lay flat
      rug.position.y = 0.01; // Slightly raised to avoid z-fighting
      rug.receiveShadow = true;
      
      // Add subtle deformation for realism
      const positions = rug.geometry.attributes.position;
      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const z = positions.getZ(i);
        const dist = Math.sqrt(x * x + z * z);
        const wave = Math.sin(dist * 2) * 0.002; // Subtle ripples
        positions.setY(i, wave);
      }
      positions.needsUpdate = true;
      
      group.add(rug);
      
      group.position.set(spec.x * INTERIORS_GRID_SIZE, 0, spec.z * INTERIORS_GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      return group;
    }
    
    function createInteriorDesk(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      const shape = spec.shape || 'rectangle';
      const deskSpec = INTERIORS_ASSETS.desk[shape];
      
      // Desktop
      let desktopGeo;
      if (shape === 'circle') {
        desktopGeo = new THREE.CylinderGeometry(deskSpec.radius, deskSpec.radius, 0.05, 32);
      } else {
        desktopGeo = new THREE.BoxGeometry(deskSpec.width, 0.05, deskSpec.depth);
      }
      
      const desktopMat = new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 0.7 });
      const desktop = new THREE.Mesh(desktopGeo, desktopMat);
      desktop.position.y = deskSpec.height;
      desktop.castShadow = true;
      group.add(desktop);
      
      // Legs
      const legGeo = new THREE.CylinderGeometry(deskSpec.legRadius, deskSpec.legRadius, deskSpec.legHeight, 16);
      const legMat = new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.8 });
      
      let legPositions;
      if (shape === 'circle') {
        const r = deskSpec.radius * 0.7;
        legPositions = [[r, 0, r], [-r, 0, r], [r, 0, -r], [-r, 0, -r]];
      } else {
        const w = deskSpec.width / 2 - deskSpec.legRadius * 2;
        const d = deskSpec.depth / 2 - deskSpec.legRadius * 2;
        legPositions = [[w, 0, d], [-w, 0, d], [w, 0, -d], [-w, 0, -d]];
      }
      
      legPositions.forEach(([x, y, z]) => {
        const leg = new THREE.Mesh(legGeo, legMat);
        leg.position.set(x, deskSpec.legHeight / 2, z);
        leg.castShadow = true;
        group.add(leg);
      });
      
      group.position.set(spec.x * INTERIORS_GRID_SIZE, 0, spec.z * INTERIORS_GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      return group;
    }
    
    function createInteriorCounter(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      const c = INTERIORS_ASSETS.counter;
      
      // Base cabinets
      const baseGeo = new THREE.BoxGeometry(c.width, c.height - c.thickness, c.depth);
      const baseMat = new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.8 });
      const base = new THREE.Mesh(baseGeo, baseMat);
      base.position.set(0, (c.height - c.thickness) / 2, 0);
      base.castShadow = true;
      group.add(base);
      
      // Counter top
      const topGeo = new THREE.BoxGeometry(c.width, c.thickness, c.depth);
      const topMat = new THREE.MeshStandardMaterial({ color: 0x8b7355, roughness: 0.7 });
      const top = new THREE.Mesh(topGeo, topMat);
      top.position.set(0, c.height - c.thickness / 2, 0);
      top.castShadow = true;
      group.add(top);
      
      // Inset sink basin (metal)
      const sinkMat = new THREE.MeshStandardMaterial({
        color: 0xc0c0c0,
        roughness: 0.2,
        metalness: 0.95
      });
      
      // Basin rim (torus for round edge)
      const basinRadius = Math.min(c.sinkWidth, c.sinkDepth) / 2.5;
      const rimGeo = new THREE.TorusGeometry(basinRadius, 0.01, 16, 32);
      const rim = new THREE.Mesh(rimGeo, sinkMat);
      rim.rotation.x = Math.PI / 2;
      rim.position.set(0, c.height - 0.01, 0);
      rim.castShadow = true;
      group.add(rim);
      
      // Basin bowl (hemisphere inset into counter)
      const basinGeo = new THREE.SphereGeometry(basinRadius, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
      const basin = new THREE.Mesh(basinGeo, sinkMat);
      basin.rotation.x = Math.PI; // Flip upside down
      basin.position.set(0, c.height - c.sinkHeight, 0);
      basin.castShadow = true;
      basin.receiveShadow = true;
      group.add(basin);
      
      // Drain at center bottom of sink
      const drainGeo = new THREE.CylinderGeometry(0.025, 0.02, 0.02, 16);
      const drainMat = new THREE.MeshStandardMaterial({
        color: 0x4a4a4a,
        roughness: 0.4,
        metalness: 0.8
      });
      const drain = new THREE.Mesh(drainGeo, drainMat);
      drain.position.set(0, c.height - c.sinkHeight, 0);
      drain.castShadow = true;
      group.add(drain);
      
      // Drain grate (circular with holes)
      const grateGeo = new THREE.CircleGeometry(0.022, 16);
      const grateMat = new THREE.MeshStandardMaterial({
        color: 0x3a3a3a,
        roughness: 0.5,
        metalness: 0.7
      });
      const grate = new THREE.Mesh(grateGeo, grateMat);
      grate.rotation.x = -Math.PI / 2;
      grate.position.set(0, c.height - c.sinkHeight + 0.001, 0);
      group.add(grate);
      
      // Wall-mounted cabinets (if counter is wall-backed)
      if (spec.wallCabinets !== false) {
        const cabinetWidth = c.width * 0.9;
        const cabinetHeight = 0.6;
        const cabinetDepth = 0.35;
        const cabinetY = c.height + 0.5;  // 0.5m above counter
        
        // Cabinet box
        const cabinetGeo = new THREE.BoxGeometry(cabinetWidth, cabinetHeight, cabinetDepth);
        const cabinetMat = new THREE.MeshStandardMaterial({ color: 0x5a4321, roughness: 0.7 });
        const cabinet = new THREE.Mesh(cabinetGeo, cabinetMat);
        cabinet.position.set(0, cabinetY + cabinetHeight / 2, -c.depth / 2 + cabinetDepth / 2);
        cabinet.castShadow = true;
        cabinet.receiveShadow = true;
        group.add(cabinet);
        
        // Cabinet doors (2 doors side by side)
        const doorWidth = cabinetWidth / 2 - 0.02;
        const doorGeo = new THREE.BoxGeometry(doorWidth, cabinetHeight - 0.04, 0.02);
        const doorMat = new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.8 });
        
        const leftDoor = new THREE.Mesh(doorGeo, doorMat);
        leftDoor.position.set(-cabinetWidth / 4, cabinetY + cabinetHeight / 2, -c.depth / 2 + cabinetDepth + 0.011);
        leftDoor.castShadow = true;
        group.add(leftDoor);
        
        const rightDoor = new THREE.Mesh(doorGeo, doorMat);
        rightDoor.position.set(cabinetWidth / 4, cabinetY + cabinetHeight / 2, -c.depth / 2 + cabinetDepth + 0.011);
        rightDoor.castShadow = true;
        group.add(rightDoor);
        
        // Cabinet handles
        const handleGeo = new THREE.CylinderGeometry(0.008, 0.008, doorWidth * 0.4, 12);
        const handleMat = new THREE.MeshStandardMaterial({
          color: 0x8a8a8a,
          roughness: 0.3,
          metalness: 0.8
        });
        
        const leftHandle = new THREE.Mesh(handleGeo, handleMat);
        leftHandle.rotation.z = Math.PI / 2;
        leftHandle.position.set(-cabinetWidth / 4, cabinetY + cabinetHeight / 2, -c.depth / 2 + cabinetDepth + 0.025);
        leftHandle.castShadow = true;
        group.add(leftHandle);
        
        const rightHandle = new THREE.Mesh(handleGeo, handleMat);
        rightHandle.rotation.z = Math.PI / 2;
        rightHandle.position.set(cabinetWidth / 4, cabinetY + cabinetHeight / 2, -c.depth / 2 + cabinetDepth + 0.025);
        rightHandle.castShadow = true;
        group.add(rightHandle);
      }
      
      group.position.set(spec.x * INTERIORS_GRID_SIZE, 0, spec.z * INTERIORS_GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      return group;
    }
    
    // ==================== ASSET CONTEXT HELPER ====================
    // Helper function to get the appropriate context for asset creation
    // Supports both interior mode and world mode
    function getAssetContext(spec) {
      return {
        gridSize: spec.GRID_SIZE || (interiorsMode ? INTERIORS_GRID_SIZE : CONFIG.BLOCK_SIZE / 10),
        targetScene: spec.scene || (interiorsMode ? interiorsGroup : worldRoot),
        targetObjects: spec.objects || (interiorsMode ? interiorRoomObjects : worldObjects),
        targetInteractive: spec.interactive || (interiorsMode ? interiorInteractiveObjects : [])
      };
    }
    
    function createInteriorPlant(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      // Pot
      const potGeo = new THREE.CylinderGeometry(0.08, 0.06, 0.15, 16);
      const potMat = new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 0.9 });
      const pot = new THREE.Mesh(potGeo, potMat);
      pot.position.y = 0.075;
      pot.castShadow = true;
      group.add(pot);
      
      // Leaves
      const leafGeo = new THREE.SphereGeometry(0.15, 16, 16);
      const leafMat = new THREE.MeshStandardMaterial({ color: 0x2a5a2a, roughness: 0.8 });
      const leaves = new THREE.Mesh(leafGeo, leafMat);
      leaves.position.y = 0.25;
      leaves.scale.set(1, 1.5, 1);
      leaves.castShadow = true;
      group.add(leaves);
      
      group.position.set(spec.x * INTERIORS_GRID_SIZE, spec.y || 0, spec.z * INTERIORS_GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      return group;
    }
    
    function createInteriorPlate(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const plateMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xffffff,
        roughness: 0.4,
        metalness: 0.1
      });
      
      const plateGeo = new THREE.CylinderGeometry(0.12, 0.12, 0.015, 32);
      const plate = new THREE.Mesh(plateGeo, plateMat);
      plate.castShadow = true;
      group.add(plate);
      
      group.position.set(spec.x * INTERIORS_GRID_SIZE, spec.y || 0.008, spec.z * INTERIORS_GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      return group;
    }
    
    function createInteriorBowl(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const bowlGeo = new THREE.SphereGeometry(0.12, 32, 16, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2);
      const bowlMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xf5f5dc,
        roughness: 0.5,
        side: THREE.DoubleSide  // Fix: render both sides for concave geometry
      });
      const bowl = new THREE.Mesh(bowlGeo, bowlMat);
      bowl.position.y = 0.05;
      bowl.castShadow = true;
      group.add(bowl);
      
      group.position.set(spec.x * INTERIORS_GRID_SIZE, spec.y || 0, spec.z * INTERIORS_GRID_SIZE);
      return group;
    }
    
    function createInteriorFruitBowl(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      // Bowl base (hemisphere)
      const bowlGeo = new THREE.SphereGeometry(0.15, 32, 16, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2);
      const bowlMat = new THREE.MeshStandardMaterial({ 
        color: 0xe8dcc0, 
        roughness: 0.6,
        side: THREE.DoubleSide  // Fix: render both sides for concave geometry
      });
      const bowl = new THREE.Mesh(bowlGeo, bowlMat);
      bowl.position.y = 0.05;
      bowl.castShadow = true;
      bowl.receiveShadow = true;
      group.add(bowl);
      
      // Add realistic fruits inside (high-fidelity models)
      const fruitPositions = [
        { type: 'apple', x: 0, y: 0.08, z: 0, color: 0xff3333 },
        { type: 'apple', x: 0.06, y: 0.09, z: 0.04, color: 0x66ff66 },
        { type: 'banana', x: -0.05, y: 0.1, z: 0.02 },
        { type: 'grapes', x: 0.03, y: 0.08, z: -0.05, color: 0x6a0dad },
        { type: 'pear', x: -0.04, y: 0.08, z: -0.03, color: 0xffeb3b }
      ];
      
      fruitPositions.forEach(fruit => {
        if (fruit.type === 'apple') {
          // Apple: squashed sphere with depression at top
          const bodyGeo = new THREE.SphereGeometry(0.035, 16, 16);
          const bodyMat = new THREE.MeshStandardMaterial({ 
            color: fruit.color, 
            roughness: 0.6 
          });
          const apple = new THREE.Mesh(bodyGeo, bodyMat);
          apple.scale.set(1, 0.9, 1); // Squash vertically
          apple.position.set(fruit.x, fruit.y, fruit.z);
          apple.castShadow = true;
          group.add(apple);
          
          // Stem (tiny cylinder)
          const stemGeo = new THREE.CylinderGeometry(0.001, 0.002, 0.01, 4);
          const stemMat = new THREE.MeshStandardMaterial({ color: 0x4a3020, roughness: 0.9 });
          const stem = new THREE.Mesh(stemGeo, stemMat);
          stem.position.set(fruit.x, fruit.y + 0.032, fruit.z);
          stem.castShadow = true;
          group.add(stem);
          
        } else if (fruit.type === 'banana') {
          // Banana: curved torus segment
          const curve = new THREE.TorusGeometry(0.06, 0.015, 8, 16, Math.PI * 0.7);
          const bananaMat = new THREE.MeshStandardMaterial({ 
            color: 0xffeb3b, 
            roughness: 0.7 
          });
          const banana = new THREE.Mesh(curve, bananaMat);
          banana.rotation.x = Math.PI / 2;
          banana.rotation.z = -Math.PI / 6;
          banana.position.set(fruit.x, fruit.y, fruit.z);
          banana.castShadow = true;
          group.add(banana);
          
        } else if (fruit.type === 'grapes') {
          // Grapes: cluster of small spheres
          for (let i = 0; i < 8; i++) {
            const grapeGeo = new THREE.SphereGeometry(0.008, 8, 8);
            const grapeMat = new THREE.MeshStandardMaterial({ 
              color: fruit.color, 
              roughness: 0.3 
            });
            const grape = new THREE.Mesh(grapeGeo, grapeMat);
            const angle = (i / 8) * Math.PI * 2;
            const radius = 0.015;
            grape.position.set(
              fruit.x + Math.cos(angle) * radius,
              fruit.y + (Math.floor(i / 4) * 0.012),
              fruit.z + Math.sin(angle) * radius
            );
            grape.castShadow = true;
            group.add(grape);
          }
          
        } else if (fruit.type === 'pear') {
          // Pear: elongated sphere (taller at bottom)
          const pearGeo = new THREE.SphereGeometry(0.03, 16, 16);
          const pearMat = new THREE.MeshStandardMaterial({ 
            color: fruit.color, 
            roughness: 0.6 
          });
          const pear = new THREE.Mesh(pearGeo, pearMat);
          pear.scale.set(0.9, 1.2, 0.9); // Elongate vertically
          pear.position.set(fruit.x, fruit.y, fruit.z);
          pear.castShadow = true;
          group.add(pear);
          
          // Stem
          const stemGeo = new THREE.CylinderGeometry(0.001, 0.001, 0.012, 4);
          const stemMat = new THREE.MeshStandardMaterial({ color: 0x4a3020, roughness: 0.9 });
          const stem = new THREE.Mesh(stemGeo, stemMat);
          stem.position.set(fruit.x, fruit.y + 0.036, fruit.z);
          stem.castShadow = true;
          group.add(stem);
        }
      });
      
      group.position.set(spec.x * INTERIORS_GRID_SIZE, spec.y || 0, spec.z * INTERIORS_GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      return group;
    }
    
    function createInteriorBathroomSink(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      // Pedestal
      const pedestalGeo = new THREE.CylinderGeometry(0.15, 0.18, 0.7, 24);
      const porcelainMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2 });
      const pedestal = new THREE.Mesh(pedestalGeo, porcelainMat);
      pedestal.position.y = 0.35;
      pedestal.castShadow = true;
      group.add(pedestal);
      
      // Basin
      const basinGeo = new THREE.CylinderGeometry(0.22, 0.15, 0.15, 32);
      const basin = new THREE.Mesh(basinGeo, porcelainMat);
      basin.position.y = 0.775;
      basin.castShadow = true;
      group.add(basin);
      
      group.position.set(spec.x * INTERIORS_GRID_SIZE, 0, spec.z * INTERIORS_GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      return group;
    }
    
    function createInteriorFork(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const metalMat = new THREE.MeshStandardMaterial({
        color: 0xc0c0c0,
        roughness: 0.3,
        metalness: 0.9
      });
      
      const handleGeo = new THREE.CylinderGeometry(0.003, 0.004, 0.12, 12);
      const handle = new THREE.Mesh(handleGeo, metalMat);
      handle.position.y = 0.06;
      handle.castShadow = true;
      group.add(handle);
      
      group.position.set(spec.x * INTERIORS_GRID_SIZE, spec.y || 0, spec.z * INTERIORS_GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      return group;
    }
    
    function createInteriorKnife(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const metalMat = new THREE.MeshStandardMaterial({
        color: 0xc0c0c0,
        roughness: 0.3,
        metalness: 0.9
      });
      
      const handleGeo = new THREE.CylinderGeometry(0.003, 0.004, 0.1, 12);
      const handle = new THREE.Mesh(handleGeo, metalMat);
      handle.position.y = 0.05;
      handle.castShadow = true;
      group.add(handle);
      
      const bladeGeo = new THREE.BoxGeometry(0.015, 0.05, 0.001);
      const blade = new THREE.Mesh(bladeGeo, metalMat);
      blade.position.y = 0.125;
      blade.castShadow = true;
      group.add(blade);
      
      group.position.set(spec.x * INTERIORS_GRID_SIZE, spec.y || 0, spec.z * INTERIORS_GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      return group;
    }
    
    function createInteriorSpoon(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const metalMat = new THREE.MeshStandardMaterial({
        color: 0xc0c0c0,
        roughness: 0.3,
        metalness: 0.9
      });
      
      const handleGeo = new THREE.CylinderGeometry(0.003, 0.004, 0.12, 12);
      const handle = new THREE.Mesh(handleGeo, metalMat);
      handle.position.y = 0.06;
      handle.castShadow = true;
      group.add(handle);
      
      const bowlGeo = new THREE.SphereGeometry(0.012, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
      const bowl = new THREE.Mesh(bowlGeo, metalMat);
      bowl.position.y = 0.125;
      bowl.castShadow = true;
      group.add(bowl);
      
      group.position.set(spec.x * INTERIORS_GRID_SIZE, spec.y || 0, spec.z * INTERIORS_GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      return group;
    }
    
    function createInteriorRefrigerator(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      // Randomize freezer position (top or bottom) - use position-based randomization for unique results per fridge
      const positionSeed = Math.abs(Math.sin(spec.x * 12.9898 + spec.z * 78.233) * 43758.5453);
      const seedValue = positionSeed - Math.floor(positionSeed);
      const freezerOnTop = seedValue > 0.5;
      
      // Main body with rounded edges
      const bodyShape = new THREE.Shape();
      const w = 0.4, h = 1.8;
      bodyShape.moveTo(-w + 0.02, -h/2);
      bodyShape.lineTo(w - 0.02, -h/2);
      bodyShape.quadraticCurveTo(w, -h/2, w, -h/2 + 0.02);
      bodyShape.lineTo(w, h/2 - 0.02);
      bodyShape.quadraticCurveTo(w, h/2, w - 0.02, h/2);
      bodyShape.lineTo(-w + 0.02, h/2);
      bodyShape.quadraticCurveTo(-w, h/2, -w, h/2 - 0.02);
      bodyShape.lineTo(-w, -h/2 + 0.02);
      bodyShape.quadraticCurveTo(-w, -h/2, -w + 0.02, -h/2);
      
      const extrudeSettings = { depth: 0.7, bevelEnabled: true, bevelThickness: 0.01, bevelSize: 0.01, bevelSegments: 3 };
      const bodyGeo = new THREE.ExtrudeGeometry(bodyShape, extrudeSettings);
      const bodyMat = new THREE.MeshStandardMaterial({ 
        color: 0xf5f5f5, 
        roughness: 0.2, 
        metalness: 0.4 
      });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.rotation.y = Math.PI / 2;
      body.position.y = 0.9;
      body.castShadow = true;
      body.receiveShadow = true;
      group.add(body);
      
      // Create door groups (interactive)
      // IMPORTANT: Doors hinge from their RIGHT edge (positive X side)
      const freezerHeight = 0.6;
      const mainHeight = 1.2;
      const doorWidth = 0.78;
      
      // Freezer door - hinge at RIGHT edge
      const freezerDoorGroup = new THREE.Group();
      const freezerY = freezerOnTop ? 1.8 - freezerHeight/2 : freezerHeight/2;
      const freezerDoorGeo = new THREE.BoxGeometry(doorWidth, freezerHeight - 0.02, 0.03);
      const doorMat = new THREE.MeshStandardMaterial({ 
        color: 0xf5f5f5, 
        roughness: 0.2, 
        metalness: 0.4 
      });
      const freezerDoor = new THREE.Mesh(freezerDoorGeo, doorMat);
      // Position door so its RIGHT edge is at the hinge point (group origin)
      freezerDoor.position.set(-doorWidth/2, 0, 0.365);
      freezerDoor.castShadow = true;
      freezerDoorGroup.add(freezerDoor);
      
      // Freezer handle - on the LEFT edge of door (far from hinge)
      const freezerHandleGeo = new THREE.BoxGeometry(0.25, 0.03, 0.03);
      const handleMat = new THREE.MeshStandardMaterial({ 
        color: 0xcccccc, 
        roughness: 0.3, 
        metalness: 0.7 
      });
      const freezerHandle = new THREE.Mesh(freezerHandleGeo, handleMat);
      freezerHandle.position.set(-doorWidth + 0.13, 0, 0.38);
      freezerHandle.castShadow = true;
      freezerDoorGroup.add(freezerHandle);
      
      // Position door group at RIGHT edge of fridge body
      freezerDoorGroup.position.set(0.39, freezerY, 0);
      freezerDoorGroup.userData.isFridgeDoor = true;
      freezerDoorGroup.userData.doorType = 'freezer';
      freezerDoorGroup.userData.isOpen = false;
      freezerDoorGroup.userData.fridgeGroup = group;
      group.add(freezerDoorGroup);
      interiorInteractiveObjects.push(freezerDoorGroup);
      interactiveInteriorsObjects.push(freezerDoorGroup);  // Register for click
      
      // Main door - hinge at RIGHT edge
      const mainDoorGroup = new THREE.Group();
      const mainY = freezerOnTop ? mainHeight/2 : 0.9 + freezerHeight/2 + 0.01;
      const mainDoorGeo = new THREE.BoxGeometry(doorWidth, mainHeight - 0.02, 0.03);
      const mainDoor = new THREE.Mesh(mainDoorGeo, doorMat);
      // Position door so its RIGHT edge is at the hinge point (group origin)
      mainDoor.position.set(-doorWidth/2, 0, 0.365);
      mainDoor.castShadow = true;
      mainDoorGroup.add(mainDoor);
      
      // Main handle - on the LEFT edge of door (far from hinge)
      const mainHandleGeo = new THREE.BoxGeometry(0.3, 0.04, 0.04);
      const mainHandle = new THREE.Mesh(mainHandleGeo, handleMat);
      mainHandle.position.set(-doorWidth + 0.15, 0.3, 0.385);
      mainHandle.castShadow = true;
      mainDoorGroup.add(mainHandle);
      
      // Position door group at RIGHT edge of fridge body
      mainDoorGroup.position.set(0.39, mainY, 0);
      mainDoorGroup.userData.isFridgeDoor = true;
      mainDoorGroup.userData.doorType = 'main';
      mainDoorGroup.userData.isOpen = false;
      mainDoorGroup.userData.fridgeGroup = group;
      group.add(mainDoorGroup);
      interiorInteractiveObjects.push(mainDoorGroup);
      interactiveInteriorsObjects.push(mainDoorGroup);  // Register for click
      
      // Interior shelves (visible when door opens)
      // IMPORTANT: Position shelves INSIDE the fridge (negative Z, toward back wall)
      const shelfMat = new THREE.MeshStandardMaterial({ 
        color: 0xffffff, 
        transparent: true, 
        opacity: 0.6, 
        roughness: 0.3 
      });
      
      // Add shelves to main compartment - positioned inside toward back wall
      for (let i = 0; i < 3; i++) {
        const shelfGeo = new THREE.BoxGeometry(0.75, 0.01, 0.65);
        const shelf = new THREE.Mesh(shelfGeo, shelfMat);
        // Position shelves inside the fridge body (negative Z = toward back)
        shelf.position.set(0, mainY - mainHeight/2 + 0.2 + i * 0.35, -0.15);
        shelf.castShadow = true;
        shelf.receiveShadow = true;
        group.add(shelf);
      }
      
      // Add food items inside fridge (visible when opened)
      // IMPORTANT: Position food items INSIDE the fridge on the shelves
      const foodItems = [];
      
      // Milk on middle shelf
      const milkGeo = new THREE.BoxGeometry(0.07, 0.15, 0.07);
      const milkMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8 });
      const milk = new THREE.Mesh(milkGeo, milkMat);
      milk.position.set(-0.15, mainY - mainHeight/2 + 0.28, -0.1);
      milk.castShadow = true;
      group.add(milk);
      foodItems.push(milk);
      
      // Orange juice on middle shelf
      const ojGeo = new THREE.CylinderGeometry(0.035, 0.035, 0.15, 16);
      const ojMat = new THREE.MeshStandardMaterial({ 
        color: 0xff8800, 
        transparent: true, 
        opacity: 0.7, 
        roughness: 0.2 
      });
      const oj = new THREE.Mesh(ojGeo, ojMat);
      oj.position.set(0.1, mainY - mainHeight/2 + 0.28, -0.15);
      oj.castShadow = true;
      group.add(oj);
      foodItems.push(oj);
      
      // Cheese on bottom shelf
      const cheeseGeo = new THREE.BoxGeometry(0.08, 0.03, 0.08);
      const cheeseMat = new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.7 });
      const cheese = new THREE.Mesh(cheeseGeo, cheeseMat);
      cheese.position.set(-0.2, mainY - mainHeight/2 + 0.21, -0.2);
      cheese.castShadow = true;
      group.add(cheese);
      foodItems.push(cheese);
      
      // Eggs on bottom shelf
      const eggCartonGeo = new THREE.BoxGeometry(0.12, 0.02, 0.08);
      const cartonMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.8 });
      const eggCarton = new THREE.Mesh(eggCartonGeo, cartonMat);
      eggCarton.position.set(0.15, mainY - mainHeight/2 + 0.21, -0.18);
      eggCarton.castShadow = true;
      group.add(eggCarton);
      foodItems.push(eggCarton);
      
      // Store food items for visibility toggle
      group.userData.foodItems = foodItems;
      group.userData.mainDoor = mainDoorGroup;
      group.userData.freezerDoor = freezerDoorGroup;
      
      group.position.set(spec.x * INTERIORS_GRID_SIZE, 0, spec.z * INTERIORS_GRID_SIZE);
      group.rotation.y = spec.rotation || 0;
      return group;
    }
    
    // ==================== FOOD ITEMS ====================
    
    function createMilkCarton(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      const lod = spec.lod || 'high';
      
      const cartonGeo = new THREE.BoxGeometry(0.07, 0.15, 0.07);
      const cartonMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.8
      });
      const carton = new THREE.Mesh(cartonGeo, cartonMat);
      carton.position.y = 0.075;
      carton.castShadow = true;
      group.add(carton);
      
      // Top spout
      if (lod === 'high') {
        const spoutGeo = new THREE.BoxGeometry(0.03, 0.02, 0.03);
        const spout = new THREE.Mesh(spoutGeo, cartonMat);
        spout.position.y = 0.16;
        spout.castShadow = true;
        group.add(spout);
      }
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      ctx.targetScene.add(group);
      ctx.targetObjects.push(group);
      return group;
    }
    
    function createOrangeJuice(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      const lod = spec.lod || 'high';
      
      const bottleGeo = new THREE.CylinderGeometry(0.035, 0.035, 0.15, lod === 'high' ? 16 : 8);
      const bottleMat = new THREE.MeshStandardMaterial({
        color: 0xff8800,
        transparent: true,
        opacity: 0.7,
        roughness: 0.2
      });
      const bottle = new THREE.Mesh(bottleGeo, bottleMat);
      bottle.position.y = 0.075;
      bottle.castShadow = true;
      group.add(bottle);
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      ctx.targetScene.add(group);
      ctx.targetObjects.push(group);
      return group;
    }
    
    function createCheese(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const cheeseGeo = new THREE.BoxGeometry(0.08, 0.03, 0.08);
      const cheeseMat = new THREE.MeshStandardMaterial({
        color: 0xffd700,
        roughness: 0.7
      });
      const cheese = new THREE.Mesh(cheeseGeo, cheeseMat);
      cheese.position.y = 0.015;
      cheese.castShadow = true;
      group.add(cheese);
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      ctx.targetScene.add(group);
      ctx.targetObjects.push(group);
      return group;
    }
    
    function createEggs(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      const lod = spec.lod || 'high';
      
      // Egg carton base
      const cartonGeo = new THREE.BoxGeometry(0.12, 0.02, 0.08);
      const cartonMat = new THREE.MeshStandardMaterial({
        color: 0xcccccc,
        roughness: 0.9
      });
      const carton = new THREE.Mesh(cartonGeo, cartonMat);
      carton.position.y = 0.01;
      carton.castShadow = true;
      group.add(carton);
      
      // Eggs
      const eggCount = lod === 'high' ? 6 : 4;
      const eggMat = new THREE.MeshStandardMaterial({
        color: 0xffeedd,
        roughness: 0.6
      });
      
      for (let i = 0; i < eggCount; i++) {
        const eggGeo = new THREE.SphereGeometry(0.015, lod === 'high' ? 12 : 6, lod === 'high' ? 12 : 6);
        const egg = new THREE.Mesh(eggGeo, eggMat);
        egg.scale.set(1, 1.3, 1);
        egg.position.set(
          -0.04 + (i % 3) * 0.04,
          0.035,
          -0.02 + Math.floor(i / 3) * 0.04
        );
        egg.castShadow = true;
        group.add(egg);
      }
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      ctx.targetScene.add(group);
      ctx.targetObjects.push(group);
      return group;
    }
    
    // ==================== ASSET MENU FOR INTERIORS ====================
    // NOW IMPORTED from js/interiors-ui.js
    /* COMMENTED OUT - Using imported version
    let assetMenuOpen = false;
    
    function toggleAssetMenu() {
      assetMenuOpen = !assetMenuOpen;
      
      let assetMenu = document.getElementById('asset-menu');
      
      if (!assetMenu) {
        // Create asset menu UI
        assetMenu = document.createElement('div');
        assetMenu.id = 'asset-menu';
        assetMenu.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: rgba(26, 33, 48, 0.95);
          border: 2px solid rgba(106, 156, 255, 0.6);
          border-radius: 12px;
          padding: 20px;
          max-width: 600px;
          max-height: 70vh;
          overflow-y: auto;
          z-index: 10000;
          box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
        `;
        
        const title = document.createElement('h2');
        title.textContent = 'Asset Library (Interior Mode)';
        title.style.cssText = 'margin: 0 0 15px 0; color: #6a9cff; font-size: 18px;';
        assetMenu.appendChild(title);
        
        const info = document.createElement('p');
        info.textContent = 'Press ESC or B to close ‚Ä¢ Assets spawn in front of camera';
        info.style.cssText = 'margin: 0 0 15px 0; color: rgba(255,255,255,0.6); font-size: 12px;';
        assetMenu.appendChild(info);
        
        const assetGrid = document.createElement('div');
        assetGrid.style.cssText = 'display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;';
        
        const commonAssets = [
          { name: 'Couch', type: 'couch' },
          { name: 'TV', type: 'tv' },
          { name: 'Coffee Table', type: 'coffeetable' },
          { name: 'Plant', type: 'plant' },
          { name: 'Floor Lamp', type: 'floorlamp' },
          { name: 'Bookshelf', type: 'shelf' },
          { name: 'Desk', type: 'computerdesk' },
          { name: 'Chair', type: 'chair' },
          { name: 'Rug', type: 'rug' },
          { name: 'Clock', type: 'clock' },
          { name: 'Painting', type: 'artframe' },
          { name: 'Cactus', type: 'cactus' }
        ];
        
        commonAssets.forEach(asset => {
          const btn = document.createElement('button');
          btn.textContent = asset.name;
          btn.style.cssText = 'padding: 12px; font-size: 13px; background: rgba(74, 124, 255, 0.3); border: 1px solid rgba(106, 156, 255, 0.5);';
          btn.onclick = () => {
            spawnAssetInInterior(asset.type);
            toggleAssetMenu(); // Close menu after spawning
          };
          assetGrid.appendChild(btn);
        });
        
        assetMenu.appendChild(assetGrid);
        document.body.appendChild(assetMenu);
      }
      
      // Toggle visibility
      assetMenu.style.display = assetMenuOpen ? 'block' : 'none';
      
      console.log('Asset menu:', assetMenuOpen ? 'opened' : 'closed');
    }
    
    function spawnAssetInInterior(assetType) {
      if (!interiorsMode) {
        console.log('Not in interior mode');
        return;
      }
      
      // Spawn asset in front of camera
      const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
      const spawnPos = camera.position.clone().addScaledVector(forward, 2);
      
      // Convert to grid coordinates
      const gridX = Math.round(spawnPos.x / INTERIORS_GRID_SIZE);
      const gridZ = Math.round(spawnPos.z / INTERIORS_GRID_SIZE);
      
      const spec = {
        type: assetType,
        x: gridX,
        z: gridZ,
        rotation: 0,
        y: 0
      };
      
      console.log(`Spawning ${assetType} at interior grid (${gridX}, ${gridZ})`);
      
      // Try to create the furniture/asset
      let furniture = null;
      
      // Simple types handled by createInteriorFurniture
      const simpleTypes = ['toilet', 'shower', 'couch', 'plant'];
      
      if (simpleTypes.includes(assetType)) {
        furniture = createInteriorFurniture(spec);
      } else {
        // Use universal asset creation functions for other types
        const assetFunctions = {
          'cactus': createCactus,
          'coffeetable': createCoffeeTable,
          'tv': createTV,
          'floorlamp': createFloorLamp,
          'shelf': createShelf,
          'computerdesk': createComputerDesk,
          'rug': createRug,
          'clock': createWallClock,
          'artframe': createArtFrame,
          'chair': createChair  // If this function exists
        };
        
        const createFn = assetFunctions[assetType];
        if (createFn) {
          try {
            createFn(spec);
            console.log(`Created ${assetType} using universal asset function`);
            return; // Assets created by universal functions add themselves to scene
          } catch (err) {
            console.error(`Error creating ${assetType}:`, err);
          }
        }
      }
      
      if (furniture) {
        interiorRoomObjects.push(furniture);
        interiorsGroup.add(furniture);
      } else {
        console.warn(`Unknown asset type: ${assetType}`);
      }
    }
    */ // END COMMENTED OUT - toggleAssetMenu and spawnAssetInInterior now imported
    
    // ==================== UNIVERSAL ASSET GENERATION LIBRARY ====================
    // COMPLETE DIRECT PORT from interiors.html - ALL functions
    // Universal functions callable from sequence builder, scale-ultra, and interiors
    // Parameters: spec (object config), targetScene (THREE.Scene), targetArray (array for cleanup)
    // Returns: THREE.Group for the created object
    
    // NOTE: These use GRID_SIZE constant from interiors - adapt as needed per context
    
    function createCactus(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      const lod = spec.lod || 'high';
      const variant = spec.variant || 'rounded'; // 'rounded', 'forked', 'flower', 'tall'
      
      const cactusMat = new THREE.MeshStandardMaterial({
        color: 0x4a7c4a,
        roughness: 0.9
      });
      
      if (variant === 'rounded') {
        // Round barrel cactus
        const bodyGeo = new THREE.SphereGeometry(0.08, lod === 'high' ? 16 : 8, lod === 'high' ? 16 : 8);
        const body = new THREE.Mesh(bodyGeo, cactusMat);
        body.scale.set(1, 1.2, 1);
        body.position.y = 0.1;
        body.castShadow = true;
        group.add(body);
        
        // Spines (small protrusions)
        if (lod === 'high') {
          for (let i = 0; i < 12; i++) {
            const angle = (i / 12) * Math.PI * 2;
            const spineGeo = new THREE.ConeGeometry(0.002, 0.01, 4);
            const spineMat = new THREE.MeshStandardMaterial({ color: 0xddddaa });
            const spine = new THREE.Mesh(spineGeo, spineMat);
            spine.position.set(
              Math.cos(angle) * 0.08,
              0.1 + (Math.random() - 0.5) * 0.04,
              Math.sin(angle) * 0.08
            );
            spine.lookAt(0, 0.1, 0);
            group.add(spine);
          }
        }
        
      } else if (variant === 'forked') {
        // Forked saguaro-style cactus
        const mainGeo = new THREE.CylinderGeometry(0.04, 0.05, 0.3, lod === 'high' ? 12 : 6);
        const main = new THREE.Mesh(mainGeo, cactusMat);
        main.position.y = 0.15;
        main.castShadow = true;
        group.add(main);
        
        // Arms
        for (let i = 0; i < 2; i++) {
          const armGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.15, lod === 'high' ? 12 : 6);
          const arm = new THREE.Mesh(armGeo, cactusMat);
          arm.position.set((i - 0.5) * 0.1, 0.2, 0);
          arm.rotation.z = (i - 0.5) * Math.PI / 6;
          arm.castShadow = true;
          group.add(arm);
        }
        
      } else if (variant === 'flower') {
        // Cactus with flower on top
        const bodyGeo = new THREE.CylinderGeometry(0.05, 0.06, 0.2, lod === 'high' ? 12 : 6);
        const body = new THREE.Mesh(bodyGeo, cactusMat);
        body.position.y = 0.1;
        body.castShadow = true;
        group.add(body);
        
        // Flower
        const flowerGeo = new THREE.SphereGeometry(0.025, lod === 'high' ? 12 : 6, lod === 'high' ? 12 : 6);
        const flowerMat = new THREE.MeshStandardMaterial({
          color: 0xff6b9d,
          roughness: 0.6
        });
        const flower = new THREE.Mesh(flowerGeo, flowerMat);
        flower.position.y = 0.225;
        flower.castShadow = true;
        group.add(flower);
        
        // Petals
        if (lod === 'high') {
          for (let i = 0; i < 6; i++) {
            const angle = (i / 6) * Math.PI * 2;
            const petalGeo = new THREE.SphereGeometry(0.015, 8, 8);
            const petal = new THREE.Mesh(petalGeo, flowerMat);
            petal.position.set(
              Math.cos(angle) * 0.025,
              0.225,
              Math.sin(angle) * 0.025
            );
            petal.scale.set(0.6, 1, 1);
            group.add(petal);
          }
        }
        
      } else if (variant === 'tall') {
        // Tall columnar cactus
        const bodyGeo = new THREE.CylinderGeometry(0.04, 0.045, 0.4, lod === 'high' ? 12 : 6);
        const body = new THREE.Mesh(bodyGeo, cactusMat);
        body.position.y = 0.2;
        body.castShadow = true;
        group.add(body);
      }
      
      // Pot
      const potGeo = new THREE.CylinderGeometry(0.06, 0.05, 0.08, lod === 'high' ? 16 : 8);
      const potMat = new THREE.MeshStandardMaterial({
        color: 0x8b4513,
        roughness: 0.8
      });
      const pot = new THREE.Mesh(potGeo, potMat);
      pot.position.y = 0.04;
      pot.castShadow = true;
      pot.receiveShadow = true;
      group.add(pot);
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    // ==================== DRINKWARE ====================
    
    function createCup(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      const lod = spec.lod || 'high';
      
      const cupGeo = new THREE.CylinderGeometry(0.035, 0.03, 0.08, lod === 'high' ? 16 : 8);
      const cupMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xffffff,
        roughness: 0.3,
        metalness: 0.1
      });
      const cup = new THREE.Mesh(cupGeo, cupMat);
      cup.position.y = 0.04;
      cup.castShadow = true;
      cup.receiveShadow = true;
      group.add(cup);
      
      // Handle
      if (lod === 'high') {
        const handleGeo = new THREE.TorusGeometry(0.02, 0.005, 8, 12, Math.PI);
        const handle = new THREE.Mesh(handleGeo, cupMat);
        handle.rotation.y = Math.PI / 2;
        handle.position.set(0.04, 0.05, 0);
        handle.castShadow = true;
        group.add(handle);
      }
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createMug(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      const lod = spec.lod || 'high';
      
      const mugGeo = new THREE.CylinderGeometry(0.04, 0.035, 0.1, lod === 'high' ? 16 : 8);
      const mugMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x4a4a8a,
        roughness: 0.6
      });
      const mug = new THREE.Mesh(mugGeo, mugMat);
      mug.position.y = 0.05;
      mug.castShadow = true;
      mug.receiveShadow = true;
      group.add(mug);
      
      // Handle (C-shaped)
      const handleGeo = new THREE.TorusGeometry(0.025, 0.008, lod === 'high' ? 12 : 6, lod === 'high' ? 16 : 8, Math.PI * 1.2);
      const handle = new THREE.Mesh(handleGeo, mugMat);
      handle.rotation.y = -Math.PI / 2;
      handle.rotation.z = Math.PI / 2;
      handle.position.set(0.045, 0.05, 0);
      handle.castShadow = true;
      group.add(handle);
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createJar(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      const lod = spec.lod || 'high';
      
      // Jar body
      const jarGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.12, lod === 'high' ? 16 : 8);
      const jarMat = new THREE.MeshStandardMaterial({
        color: 0xddddff,
        transparent: true,
        opacity: 0.7,
        roughness: 0.1
      });
      const jar = new THREE.Mesh(jarGeo, jarMat);
      jar.position.y = 0.06;
      jar.castShadow = true;
      jar.receiveShadow = true;
      group.add(jar);
      
      // Lid
      const lidGeo = new THREE.CylinderGeometry(0.042, 0.042, 0.015, lod === 'high' ? 16 : 8);
      const lidMat = new THREE.MeshStandardMaterial({
        color: 0x8a8a8a,
        roughness: 0.4,
        metalness: 0.6
      });
      const lid = new THREE.Mesh(lidGeo, lidMat);
      lid.position.y = 0.1275;
      lid.castShadow = true;
      group.add(lid);
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    // ==================== OFFICE SUPPLIES ====================
    
    function createPencil(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      const lod = spec.lod || 'high';
      
      // Pencil body (hexagonal)
      const bodyGeo = new THREE.CylinderGeometry(0.003, 0.003, 0.15, lod === 'high' ? 6 : 4);
      const bodyMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xffcc00,
        roughness: 0.7
      });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = 0.075;
      body.castShadow = true;
      group.add(body);
      
      // Tip (graphite)
      const tipGeo = new THREE.ConeGeometry(0.003, 0.01, lod === 'high' ? 6 : 4);
      const tipMat = new THREE.MeshStandardMaterial({
        color: 0x2a2a2a,
        roughness: 0.3
      });
      const tip = new THREE.Mesh(tipGeo, tipMat);
      tip.position.y = 0.155;
      tip.castShadow = true;
      group.add(tip);
      
      // Eraser
      if (lod === 'high') {
        const eraserGeo = new THREE.CylinderGeometry(0.004, 0.004, 0.015, 6);
        const eraserMat = new THREE.MeshStandardMaterial({
          color: 0xffb6c1,
          roughness: 0.9
        });
        const eraser = new THREE.Mesh(eraserGeo, eraserMat);
        eraser.position.y = 0.0075;
        eraser.castShadow = true;
        group.add(eraser);
        
        // Metal band
        const bandGeo = new THREE.CylinderGeometry(0.0035, 0.0035, 0.005, 6);
        const bandMat = new THREE.MeshStandardMaterial({
          color: 0xc0c0c0,
          roughness: 0.2,
          metalness: 0.9
        });
        const band = new THREE.Mesh(bandGeo, bandMat);
        band.position.y = 0.0125;
        group.add(band);
      }
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      group.rotation.z = Math.PI / 2; // Lay flat
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createNotepad(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      const lod = spec.lod || 'high';
      
      // Pad body
      const padGeo = new THREE.BoxGeometry(0.1, 0.015, 0.15);
      const padMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xffffdd,
        roughness: 0.9
      });
      const pad = new THREE.Mesh(padGeo, padMat);
      pad.position.y = 0.0075;
      pad.castShadow = true;
      pad.receiveShadow = true;
      group.add(pad);
      
      // Binding (top edge)
      if (lod === 'high') {
        const bindingGeo = new THREE.BoxGeometry(0.1, 0.02, 0.01);
        const bindingMat = new THREE.MeshStandardMaterial({
          color: 0x4a4a4a,
          roughness: 0.6
        });
        const binding = new THREE.Mesh(bindingGeo, bindingMat);
        binding.position.set(0, 0.0075, -0.075);
        binding.castShadow = true;
        group.add(binding);
      }
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createNotebook(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      const lod = spec.lod || 'high';
      
      // Cover
      const coverGeo = new THREE.BoxGeometry(0.15, 0.025, 0.2);
      const coverMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x4a4a8a,
        roughness: 0.7
      });
      const cover = new THREE.Mesh(coverGeo, coverMat);
      cover.position.y = 0.0125;
      cover.castShadow = true;
      cover.receiveShadow = true;
      group.add(cover);
      
      // Spiral binding
      if (lod === 'high') {
        for (let i = 0; i < 8; i++) {
          const spiralGeo = new THREE.TorusGeometry(0.005, 0.002, 6, 8);
          const spiralMat = new THREE.MeshStandardMaterial({
            color: 0xc0c0c0,
            roughness: 0.3,
            metalness: 0.8
          });
          const spiral = new THREE.Mesh(spiralGeo, spiralMat);
          spiral.rotation.x = Math.PI / 2;
          spiral.position.set(-0.07, 0.0125, -0.08 + i * 0.023);
          group.add(spiral);
        }
      }
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createStickyNotes(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      // Stack of sticky notes
      const stackGeo = new THREE.BoxGeometry(0.075, 0.02, 0.075);
      const stackMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xffff66,
        roughness: 0.9
      });
      const stack = new THREE.Mesh(stackGeo, stackMat);
      stack.position.y = 0.01;
      stack.castShadow = true;
      stack.receiveShadow = true;
      group.add(stack);
      
      // Individual note on top (slightly pulled)
      const noteGeo = new THREE.BoxGeometry(0.075, 0.001, 0.075);
      const note = new THREE.Mesh(noteGeo, stackMat);
      note.position.set(0.01, 0.022, -0.01);
      note.rotation.y = 0.1;
      note.castShadow = true;
      group.add(note);
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    // ==================== KITCHEN APPLIANCES & FOOD ====================
    
    function createMicrowave(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const width = 0.5;
      const height = 0.3;
      const depth = 0.35;
      
      // Main body
      const bodyGeo = new THREE.BoxGeometry(width, height, depth);
      const bodyMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x2a2a2a,
        roughness: 0.6,
        metalness: 0.3
      });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = height / 2;
      body.castShadow = true;
      body.receiveShadow = true;
      group.add(body);
      
      // Interior chamber (visible when door opens)
      const interiorGeo = new THREE.BoxGeometry(width * 0.85, height * 0.8, depth * 0.9);
      const interiorMat = new THREE.MeshStandardMaterial({
        color: 0xeeeeee,
        roughness: 0.5
      });
      const interior = new THREE.Mesh(interiorGeo, interiorMat);
      interior.position.set(0, height / 2, 0);
      group.add(interior);
      
      // Rotating plate inside
      const plateGeo = new THREE.CylinderGeometry(width * 0.35, width * 0.35, 0.01, 32);
      const plateMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.7,
        roughness: 0.2
      });
      const plate = new THREE.Mesh(plateGeo, plateMat);
      plate.position.set(0, height * 0.15, 0);
      group.add(plate);
      
      // Hinged door group
      const doorGroup = new THREE.Group();
      
      // Door frame
      const doorFrameGeo = new THREE.BoxGeometry(width * 0.9, height * 0.85, 0.02);
      const doorFrameMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x2a2a2a,
        roughness: 0.6,
        metalness: 0.3
      });
      const doorFrame = new THREE.Mesh(doorFrameGeo, doorFrameMat);
      doorFrame.position.set(0, 0, 0);
      doorFrame.castShadow = true;
      doorGroup.add(doorFrame);
      
      // Door window (darker glass)
      const windowGeo = new THREE.PlaneGeometry(width * 0.75, height * 0.65);
      const windowMat = new THREE.MeshStandardMaterial({
        color: 0x1a1a1a,
        transparent: true,
        opacity: 0.6,
        metalness: 0.5
      });
      const window = new THREE.Mesh(windowGeo, windowMat);
      window.position.set(0, 0.02, 0.011);
      doorGroup.add(window);
      
      // Door handle
      const handleGeo = new THREE.BoxGeometry(0.08, 0.03, 0.02);
      const handleMat = new THREE.MeshStandardMaterial({
        color: 0xcccccc,
        roughness: 0.3,
        metalness: 0.7
      });
      const handle = new THREE.Mesh(handleGeo, handleMat);
      handle.position.set(-width * 0.35, -height * 0.15, 0.02);
      handle.castShadow = true;
      doorGroup.add(handle);
      
      // Position door group (pivot on left edge for opening)
      doorGroup.position.set(-width * 0.45, height / 2, depth / 2 + 0.01);
      doorGroup.userData.isMicrowaveDoor = true;
      doorGroup.userData.isOpen = false;
      doorGroup.userData.microwaveGroup = group;
      group.add(doorGroup);
      
      if (ctx.targetObjects === interiorInteractiveObjects) {
        interiorInteractiveObjects.push(doorGroup);
      }
      
      // Control panel on right side
      const panelBgGeo = new THREE.PlaneGeometry(width * 0.25, height * 0.6);
      const panelBgMat = new THREE.MeshStandardMaterial({
        color: 0x1a1a1a,
        roughness: 0.4
      });
      const panelBg = new THREE.Mesh(panelBgGeo, panelBgMat);
      panelBg.position.set(width * 0.325, height * 0.55, depth / 2 + 0.002);
      group.add(panelBg);
      
      // Digital display with canvas texture
      const canvas = document.createElement('canvas');
      canvas.width = 128;
      canvas.height = 32;
      const canvasCtx = canvas.getContext('2d');
      canvasCtx.fillStyle = '#00ff00';
      canvasCtx.fillRect(0, 0, 128, 32);
      canvasCtx.fillStyle = '#000000';
      canvasCtx.font = 'bold 20px monospace';
      canvasCtx.textAlign = 'center';
      canvasCtx.textBaseline = 'middle';
      canvasCtx.fillText('00:00', 64, 16);
      
      const displayTexture = new THREE.CanvasTexture(canvas);
      const displayGeo = new THREE.PlaneGeometry(width * 0.2, height * 0.15);
      const displayMat = new THREE.MeshStandardMaterial({
        map: displayTexture,
        emissive: 0x00ff00,
        emissiveIntensity: 0.3
      });
      const display = new THREE.Mesh(displayGeo, displayMat);
      display.position.set(width * 0.325, height * 0.75, depth / 2 + 0.003);
      group.add(display);
      
      // Button grid (3x4)
      const buttonRows = 4;
      const buttonCols = 3;
      const buttonSize = 0.02;
      const buttonSpacing = 0.025;
      const buttonStartY = height * 0.5;
      
      const buttonLabels = [
        ['1', '2', '3'],
        ['4', '5', '6'],
        ['7', '8', '9'],
        ['0', 'START', 'STOP']
      ];
      
      for (let row = 0; row < buttonRows; row++) {
        for (let col = 0; col < buttonCols; col++) {
          const buttonGeo = new THREE.BoxGeometry(buttonSize, buttonSize, 0.005);
          const buttonMat = new THREE.MeshStandardMaterial({
            color: 0x444444,
            roughness: 0.5
          });
          const button = new THREE.Mesh(buttonGeo, buttonMat);
          button.position.set(
            width * 0.325 + (col - 1) * buttonSpacing,
            buttonStartY - row * buttonSpacing,
            depth / 2 + 0.004
          );
          button.castShadow = true;
          group.add(button);
        }
      }
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createSodaCan(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const radius = 0.03;
      const height = 0.12;
      
      // Can body
      const canGeo = new THREE.CylinderGeometry(radius, radius, height, 24);
      const canMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xff0000,
        roughness: 0.3,
        metalness: 0.8
      });
      const can = new THREE.Mesh(canGeo, canMat);
      can.position.y = height / 2;
      can.castShadow = true;
      can.receiveShadow = true;
      group.add(can);
      
      // Top rim
      const topGeo = new THREE.CylinderGeometry(radius + 0.002, radius, 0.008, 24);
      const topMat = new THREE.MeshStandardMaterial({
        color: 0xcccccc,
        roughness: 0.2,
        metalness: 0.9
      });
      const top = new THREE.Mesh(topGeo, topMat);
      top.position.y = height;
      group.add(top);
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createCerealBox(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const width = 0.2;
      const height = 0.3;
      const depth = 0.08;
      
      const boxGeo = new THREE.BoxGeometry(width, height, depth);
      const boxMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xffaa00,
        roughness: 0.8
      });
      const box = new THREE.Mesh(boxGeo, boxMat);
      box.position.y = height / 2;
      box.castShadow = true;
      box.receiveShadow = true;
      group.add(box);
      
      // Label
      const labelGeo = new THREE.PlaneGeometry(width * 0.8, height * 0.6);
      const labelMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.9
      });
      const label = new THREE.Mesh(labelGeo, labelMat);
      label.position.set(0, height * 0.6, depth / 2 + 0.001);
      group.add(label);
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createCrackerBox(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const width = 0.18;
      const height = 0.22;
      const depth = 0.06;
      
      const boxGeo = new THREE.BoxGeometry(width, height, depth);
      const boxMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xd4af37,
        roughness: 0.8
      });
      const box = new THREE.Mesh(boxGeo, boxMat);
      box.position.y = height / 2;
      box.castShadow = true;
      box.receiveShadow = true;
      group.add(box);
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createComputerTower(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const width = 0.2;
      const height = 0.45;
      const depth = 0.45;
      
      // Tower case
      const caseGeo = new THREE.BoxGeometry(width, height, depth);
      const caseMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x1a1a1a,
        roughness: 0.5,
        metalness: 0.6
      });
      const towerCase = new THREE.Mesh(caseGeo, caseMat);
      towerCase.position.y = height / 2;
      towerCase.castShadow = true;
      towerCase.receiveShadow = true;
      group.add(towerCase);
      
      // Front panel
      const panelGeo = new THREE.PlaneGeometry(width * 0.9, height * 0.3);
      const panelMat = new THREE.MeshStandardMaterial({
        color: 0x2a2a2a,
        roughness: 0.6
      });
      const panel = new THREE.Mesh(panelGeo, panelMat);
      panel.position.set(0, height * 0.7, depth / 2 + 0.001);
      group.add(panel);
      
      // Power button (small LED)
      const ledGeo = new THREE.CircleGeometry(0.008, 12);
      const ledMat = new THREE.MeshStandardMaterial({
        color: 0x00ff00,
        emissive: 0x00ff00,
        emissiveIntensity: 0.5
      });
      const led = new THREE.Mesh(ledGeo, ledMat);
      led.position.set(0, height * 0.85, depth / 2 + 0.002);
      group.add(led);
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    // ==================== PET PROPS ====================
    
    function createDogFoodBowl(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const bowlRadius = spec.radius || 0.12;
      const bowlHeight = spec.height || 0.06;
      
      // Bowl body (hemisphere)
      const bowlGeo = new THREE.SphereGeometry(bowlRadius, 32, 16, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2);
      const bowlMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xff6b6b,
        roughness: 0.4,
        metalness: 0.3
      });
      const bowl = new THREE.Mesh(bowlGeo, bowlMat);
      bowl.position.y = bowlHeight / 2;
      bowl.castShadow = true;
      bowl.receiveShadow = true;
      group.add(bowl);
      
      // Rim
      const rimGeo = new THREE.TorusGeometry(bowlRadius, 0.008, 12, 32);
      const rim = new THREE.Mesh(rimGeo, bowlMat);
      rim.rotation.x = Math.PI / 2;
      rim.position.y = bowlHeight;
      rim.castShadow = true;
      group.add(rim);
      
      // Kibble pieces (random instances)
      const kibbleCount = spec.kibbleCount || 20;
      const kibbleColors = [0x8b4513, 0x6b3410, 0xa0522d, 0x654321];
      
      for (let i = 0; i < kibbleCount; i++) {
        // Random kibble shape (small irregular rounded boxes)
        const kSize = 0.008 + Math.random() * 0.006;
        const kibbleGeo = new THREE.BoxGeometry(
          kSize * (0.8 + Math.random() * 0.4),
          kSize * (0.6 + Math.random() * 0.3),
          kSize * (0.8 + Math.random() * 0.4)
        );
        const kibbleMat = new THREE.MeshStandardMaterial({
          color: kibbleColors[Math.floor(Math.random() * kibbleColors.length)],
          roughness: 0.8
        });
        const kibble = new THREE.Mesh(kibbleGeo, kibbleMat);
        
        // Random position within bowl
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * (bowlRadius * 0.7);
        kibble.position.set(
          Math.cos(angle) * radius,
          bowlHeight * 0.6 + Math.random() * 0.03,
          Math.sin(angle) * radius
        );
        kibble.rotation.set(
          Math.random() * Math.PI,
          Math.random() * Math.PI,
          Math.random() * Math.PI
        );
        kibble.castShadow = true;
        group.add(kibble);
      }
      
      // Optional: Decorative paw print on outside
      if (spec.pawPrint !== false) {
        const pawGeo = new THREE.CircleGeometry(0.025, 16);
        const pawMat = new THREE.MeshStandardMaterial({
          color: 0xffffff,
          roughness: 0.5
        });
        const paw = new THREE.Mesh(pawGeo, pawMat);
        paw.rotation.y = Math.PI / 2;
        paw.position.set(bowlRadius * 0.8, bowlHeight * 0.5, 0);
        group.add(paw);
      }
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createWaterBowl(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const bowlRadius = spec.radius || 0.12;
      const bowlHeight = spec.height || 0.06;
      
      // Bowl body (hemisphere)
      const bowlGeo = new THREE.SphereGeometry(bowlRadius, 32, 16, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2);
      const bowlMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x6ba8e5,
        roughness: 0.4,
        metalness: 0.3
      });
      const bowl = new THREE.Mesh(bowlGeo, bowlMat);
      bowl.position.y = bowlHeight / 2;
      bowl.castShadow = true;
      bowl.receiveShadow = true;
      group.add(bowl);
      
      // Rim
      const rimGeo = new THREE.TorusGeometry(bowlRadius, 0.008, 12, 32);
      const rim = new THREE.Mesh(rimGeo, bowlMat);
      rim.rotation.x = Math.PI / 2;
      rim.position.y = bowlHeight;
      rim.castShadow = true;
      group.add(rim);
      
      // Water surface (transparent disc with reflections)
      const waterGeo = new THREE.CircleGeometry(bowlRadius * 0.92, 32);
      const waterMat = new THREE.MeshPhysicalMaterial({
        color: 0x4a90e2,
        transparent: true,
        opacity: 0.7,
        roughness: 0.1,
        metalness: 0.1,
        transmission: 0.5,
        thickness: 0.1,
        ior: 1.33, // Water IOR
        side: THREE.DoubleSide
      });
      const water = new THREE.Mesh(waterGeo, waterMat);
      water.rotation.x = -Math.PI / 2;
      water.position.y = bowlHeight * 0.85;
      water.receiveShadow = true;
      group.add(water);
      
      // Optional: Decorative bone icon on outside
      if (spec.boneIcon !== false) {
        const boneGeo = new THREE.CapsuleGeometry(0.008, 0.04, 8, 8);
        const boneMat = new THREE.MeshStandardMaterial({
          color: 0xffffff,
          roughness: 0.5
        });
        const bone = new THREE.Mesh(boneGeo, boneMat);
        bone.rotation.y = Math.PI / 2;
        bone.rotation.z = Math.PI / 4;
        bone.position.set(bowlRadius * 0.8, bowlHeight * 0.5, 0);
        group.add(bone);
      }
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createPetBed(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const size = spec.size || 0.6;
      const height = 0.15;
      
      // Bed base (oval cushion)
      const baseGeo = new THREE.CylinderGeometry(size * 0.9, size * 0.85, height, 32);
      const fabricMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x8b7355,
        roughness: 0.9
      });
      const base = new THREE.Mesh(baseGeo, fabricMat);
      base.position.y = height / 2;
      base.scale.set(1, 1, 1.3); // Oval shape
      base.castShadow = true;
      base.receiveShadow = true;
      group.add(base);
      
      // Raised edges (torus segments)
      const edgeGeo = new THREE.TorusGeometry(size * 0.88, 0.06, 12, 24);
      const edge = new THREE.Mesh(edgeGeo, fabricMat);
      edge.rotation.x = Math.PI / 2;
      edge.scale.set(1, 1.3, 1); // Oval
      edge.position.y = height * 0.8;
      edge.castShadow = true;
      group.add(edge);
      
      // Soft center padding (slightly sunken)
      const paddingGeo = new THREE.CircleGeometry(size * 0.65, 32);
      const paddingMat = new THREE.MeshStandardMaterial({
        color: spec.paddingColor || 0xf5f5dc,
        roughness: 0.95
      });
      const padding = new THREE.Mesh(paddingGeo, paddingMat);
      padding.rotation.x = -Math.PI / 2;
      padding.position.y = height * 0.6;
      padding.receiveShadow = true;
      group.add(padding);
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createDogToy(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const toyType = spec.toyType || 'bone'; // 'bone', 'ball', 'rope'
      
      if (toyType === 'bone') {
        // Bone toy (two spheres connected by cylinder)
        const boneMat = new THREE.MeshStandardMaterial({
          color: spec.color || 0xf5f5dc,
          roughness: 0.8
        });
        
        const centerGeo = new THREE.CylinderGeometry(0.012, 0.012, 0.08, 12);
        const center = new THREE.Mesh(centerGeo, boneMat);
        center.rotation.z = Math.PI / 2;
        center.castShadow = true;
        group.add(center);
        
        const endGeo = new THREE.SphereGeometry(0.02, 12, 12);
        const end1 = new THREE.Mesh(endGeo, boneMat);
        end1.position.x = -0.04;
        end1.scale.set(0.8, 1, 0.8);
        end1.castShadow = true;
        group.add(end1);
        
        const end2 = new THREE.Mesh(endGeo, boneMat);
        end2.position.x = 0.04;
        end2.scale.set(0.8, 1, 0.8);
        end2.castShadow = true;
        group.add(end2);
        
      } else if (toyType === 'ball') {
        // Tennis ball
        const ballGeo = new THREE.SphereGeometry(0.04, 16, 16);
        const ballMat = new THREE.MeshStandardMaterial({
          color: spec.color || 0xccff33,
          roughness: 0.9
        });
        const ball = new THREE.Mesh(ballGeo, ballMat);
        ball.castShadow = true;
        group.add(ball);
        
      } else if (toyType === 'rope') {
        // Rope toy (twisted torus)
        const ropeGeo = new THREE.TorusGeometry(0.035, 0.01, 12, 24);
        const ropeMat = new THREE.MeshStandardMaterial({
          color: spec.color || 0x8b4513,
          roughness: 0.95
        });
        const rope = new THREE.Mesh(ropeGeo, ropeMat);
        rope.rotation.x = Math.PI / 2;
        rope.castShadow = true;
        group.add(rope);
      }
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0.02, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createCatTower(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const height = spec.height || 1.2;
      const carpetMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x9b8365,
        roughness: 0.95
      });
      
      // Base platform
      const baseGeo = new THREE.BoxGeometry(0.5, 0.05, 0.5);
      const base = new THREE.Mesh(baseGeo, carpetMat);
      base.position.y = 0.025;
      base.castShadow = true;
      base.receiveShadow = true;
      group.add(base);
      
      // Central post
      const postGeo = new THREE.CylinderGeometry(0.04, 0.04, height * 0.6, 16);
      const post = new THREE.Mesh(postGeo, carpetMat);
      post.position.y = height * 0.3;
      post.castShadow = true;
      group.add(post);
      
      // Mid platform
      const midGeo = new THREE.CylinderGeometry(0.25, 0.25, 0.05, 24);
      const mid = new THREE.Mesh(midGeo, carpetMat);
      mid.position.y = height * 0.5;
      mid.castShadow = true;
      mid.receiveShadow = true;
      group.add(mid);
      
      // Top platform
      const topGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.05, 24);
      const top = new THREE.Mesh(topGeo, carpetMat);
      top.position.y = height * 0.9;
      top.castShadow = true;
      top.receiveShadow = true;
      group.add(top);
      
      // Hanging toy (ball on string)
      const stringGeo = new THREE.CylinderGeometry(0.002, 0.002, 0.15, 8);
      const stringMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
      const string = new THREE.Mesh(stringGeo, stringMat);
      string.position.set(0.15, height * 0.5 - 0.08, 0);
      group.add(string);
      
      const toyGeo = new THREE.SphereGeometry(0.025, 12, 12);
      const toyMat = new THREE.MeshStandardMaterial({ color: 0xff6b6b });
      const toy = new THREE.Mesh(toyGeo, toyMat);
      toy.position.set(0.15, height * 0.5 - 0.16, 0);
      toy.castShadow = true;
      group.add(toy);
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createLitterBox(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const width = 0.5;
      const depth = 0.4;
      const height = 0.15;
      
      // Box body
      const boxGeo = new THREE.BoxGeometry(width, height, depth);
      const boxMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x4a90e2,
        roughness: 0.6,
        metalness: 0.2
      });
      const box = new THREE.Mesh(boxGeo, boxMat);
      box.position.y = height / 2;
      box.castShadow = true;
      box.receiveShadow = true;
      group.add(box);
      
      // Litter (granular appearance using small spheres)
      const litterMat = new THREE.MeshStandardMaterial({
        color: 0xd4c5b9,
        roughness: 0.95
      });
      
      for (let i = 0; i < 30; i++) {
        const grainGeo = new THREE.SphereGeometry(0.003 + Math.random() * 0.002, 6, 6);
        const grain = new THREE.Mesh(grainGeo, litterMat);
        grain.position.set(
          (Math.random() - 0.5) * width * 0.8,
          height * 0.6 + Math.random() * 0.02,
          (Math.random() - 0.5) * depth * 0.8
        );
        grain.castShadow = true;
        group.add(grain);
      }
      
      // Scoop (leaning against side)
      const scoopHandleGeo = new THREE.CylinderGeometry(0.005, 0.005, 0.12, 8);
      const scoopMat = new THREE.MeshStandardMaterial({
        color: 0x888888,
        roughness: 0.5,
        metalness: 0.5
      });
      const scoopHandle = new THREE.Mesh(scoopHandleGeo, scoopMat);
      scoopHandle.rotation.z = Math.PI / 3;
      scoopHandle.position.set(-width / 2 + 0.02, height * 0.5, 0);
      scoopHandle.castShadow = true;
      group.add(scoopHandle);
      
      const scoopGeo = new THREE.BoxGeometry(0.06, 0.01, 0.05);
      const scoop = new THREE.Mesh(scoopGeo, scoopMat);
      scoop.rotation.z = Math.PI / 3;
      scoop.position.set(-width / 2 - 0.03, height * 0.3, 0);
      scoop.castShadow = true;
      group.add(scoop);
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    // ==================== ADDITIONAL INTERIOR PROPS ====================
    
    function createUmbrella(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const height = spec.height || 0.8;
      
      // Handle
      const handleGeo = new THREE.CylinderGeometry(0.01, 0.01, height, 12);
      const handleMat = new THREE.MeshStandardMaterial({
        color: spec.handleColor || 0x4a4a4a,
        roughness: 0.6,
        metalness: 0.4
      });
      const handle = new THREE.Mesh(handleGeo, handleMat);
      handle.position.y = height / 2;
      handle.castShadow = true;
      group.add(handle);
      
      // Curved hook handle
      const hookGeo = new THREE.TorusGeometry(0.04, 0.008, 8, 16, Math.PI);
      const hook = new THREE.Mesh(hookGeo, handleMat);
      hook.rotation.x = Math.PI;
      hook.rotation.z = Math.PI / 2;
      hook.position.set(0, 0.02, -0.02);
      group.add(hook);
      
      // Canopy (cone)
      const canopyGeo = new THREE.ConeGeometry(0.25, 0.15, 32);
      const canopyMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xff6b6b,
        roughness: 0.8
      });
      const canopy = new THREE.Mesh(canopyGeo, canopyMat);
      canopy.position.y = height + 0.05;
      canopy.castShadow = true;
      group.add(canopy);
      
      // Ribs (spokes)
      for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const ribGeo = new THREE.CylinderGeometry(0.002, 0.002, 0.2, 6);
        const rib = new THREE.Mesh(ribGeo, handleMat);
        rib.rotation.z = -Math.PI / 6;
        rib.rotation.y = angle;
        rib.position.set(
          Math.cos(angle) * 0.08,
          height - 0.02,
          Math.sin(angle) * 0.08
        );
        group.add(rib);
      }
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      if (spec.leaning) {
        group.rotation.z = Math.PI / 8;
      }
      
      ctx.targetScene.add(group);
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createUmbrellaStand(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      // Base (heavy cylinder)
      const baseGeo = new THREE.CylinderGeometry(0.15, 0.18, 0.35, 24);
      const baseMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x2a2a2a,
        roughness: 0.7,
        metalness: 0.3
      });
      const base = new THREE.Mesh(baseGeo, baseMat);
      base.position.y = 0.175;
      base.castShadow = true;
      base.receiveShadow = true;
      group.add(base);
      
      // Top ring
      const ringGeo = new THREE.TorusGeometry(0.12, 0.02, 12, 24);
      const ring = new THREE.Mesh(ringGeo, baseMat);
      ring.rotation.x = Math.PI / 2;
      ring.position.y = 0.35;
      ring.castShadow = true;
      group.add(ring);
      
      // Decorative pattern (grooves)
      for (let i = 0; i < 3; i++) {
        const grooveGeo = new THREE.TorusGeometry(0.14, 0.005, 8, 32);
        const groove = new THREE.Mesh(grooveGeo, baseMat);
        groove.rotation.x = Math.PI / 2;
        groove.position.y = 0.1 + i * 0.08;
        group.add(groove);
      }
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createCoatRack(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const height = spec.height || 1.8;
      
      // Central pole
      const poleGeo = new THREE.CylinderGeometry(0.03, 0.04, height, 16);
      const poleMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x654321,
        roughness: 0.7,
        metalness: 0.2
      });
      const pole = new THREE.Mesh(poleGeo, poleMat);
      pole.position.y = height / 2;
      pole.castShadow = true;
      group.add(pole);
      
      // Base (tripod legs)
      for (let i = 0; i < 3; i++) {
        const angle = (i / 3) * Math.PI * 2;
        const legGeo = new THREE.CylinderGeometry(0.02, 0.025, 0.35, 12);
        const leg = new THREE.Mesh(legGeo, poleMat);
        leg.rotation.z = Math.PI / 8;
        leg.rotation.y = angle;
        leg.position.set(
          Math.cos(angle) * 0.15,
          0.15,
          Math.sin(angle) * 0.15
        );
        leg.castShadow = true;
        group.add(leg);
      }
      
      // Hooks (multiple levels)
      const hookMat = new THREE.MeshStandardMaterial({
        color: 0x888888,
        roughness: 0.4,
        metalness: 0.7
      });
      
      for (let level = 0; level < 3; level++) {
        for (let i = 0; i < 4; i++) {
          const angle = (i / 4) * Math.PI * 2 + (level * Math.PI / 8);
          const hookGeo = new THREE.CylinderGeometry(0.012, 0.008, 0.12, 8);
          const hook = new THREE.Mesh(hookGeo, hookMat);
          hook.rotation.z = Math.PI / 3;
          hook.rotation.y = angle;
          hook.position.set(
            Math.cos(angle) * 0.05,
            height * 0.6 + level * 0.2,
            Math.sin(angle) * 0.05
          );
          hook.castShadow = true;
          group.add(hook);
        }
      }
      
      // Top cap
      const capGeo = new THREE.SphereGeometry(0.05, 16, 16);
      const cap = new THREE.Mesh(capGeo, hookMat);
      cap.position.y = height;
      cap.castShadow = true;
      group.add(cap);
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createShoeRack(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const width = spec.width || 0.8;
      const levels = spec.levels || 3;
      const shelfSpacing = 0.25;
      
      const woodMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x8b7355,
        roughness: 0.8,
        metalness: 0.1
      });
      
      // Side supports
      const supportGeo = new THREE.BoxGeometry(0.04, levels * shelfSpacing, 0.04);
      const leftSupport = new THREE.Mesh(supportGeo, woodMat);
      leftSupport.position.set(-width / 2, levels * shelfSpacing / 2, 0);
      leftSupport.castShadow = true;
      group.add(leftSupport);
      
      const rightSupport = new THREE.Mesh(supportGeo, woodMat);
      rightSupport.position.set(width / 2, levels * shelfSpacing / 2, 0);
      rightSupport.castShadow = true;
      group.add(rightSupport);
      
      // Shelves (slats for air circulation)
      for (let i = 0; i < levels; i++) {
        for (let s = 0; s < 5; s++) {
          const slatGeo = new THREE.BoxGeometry(width - 0.08, 0.02, 0.04);
          const slat = new THREE.Mesh(slatGeo, woodMat);
          slat.position.set(
            0,
            i * shelfSpacing + 0.02,
            -0.15 + s * 0.075
          );
          slat.castShadow = true;
          slat.receiveShadow = true;
          group.add(slat);
        }
      }
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createMirror(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const width = spec.width || 0.6;
      const height = spec.height || 1.2;
      const frameThickness = 0.05;
      
      // Frame
      const frameMat = new THREE.MeshStandardMaterial({
        color: spec.frameColor || 0x654321,
        roughness: 0.6,
        metalness: 0.3
      });
      
      // Top frame
      const topFrameGeo = new THREE.BoxGeometry(width + frameThickness * 2, frameThickness, 0.02);
      const topFrame = new THREE.Mesh(topFrameGeo, frameMat);
      topFrame.position.set(0, height / 2 + frameThickness / 2, 0);
      topFrame.castShadow = true;
      group.add(topFrame);
      
      // Bottom frame
      const bottomFrame = new THREE.Mesh(topFrameGeo, frameMat);
      bottomFrame.position.set(0, -height / 2 - frameThickness / 2, 0);
      bottomFrame.castShadow = true;
      group.add(bottomFrame);
      
      // Side frames
      const sideFrameGeo = new THREE.BoxGeometry(frameThickness, height, 0.02);
      const leftFrame = new THREE.Mesh(sideFrameGeo, frameMat);
      leftFrame.position.set(-width / 2 - frameThickness / 2, 0, 0);
      leftFrame.castShadow = true;
      group.add(leftFrame);
      
      const rightFrame = new THREE.Mesh(sideFrameGeo, frameMat);
      rightFrame.position.set(width / 2 + frameThickness / 2, 0, 0);
      rightFrame.castShadow = true;
      group.add(rightFrame);
      
      // Mirror surface (reflective)
      const mirrorGeo = new THREE.PlaneGeometry(width, height);
      const mirrorMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.05,
        metalness: 0.95
      });
      const mirror = new THREE.Mesh(mirrorGeo, mirrorMat);
      mirror.position.z = -0.01;
      group.add(mirror);
      
      group.position.set(spec.x * ctx.gridSize, spec.y || height / 2, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createWasteBasket(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const style = spec.style || 'cylinder'; // 'cylinder', 'square'
      const height = 0.35;
      const radius = 0.15;
      
      const basketMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x4a4a4a,
        roughness: 0.7,
        metalness: 0.2
      });
      
      if (style === 'cylinder') {
        const basketGeo = new THREE.CylinderGeometry(radius, radius * 0.9, height, 24);
        const basket = new THREE.Mesh(basketGeo, basketMat);
        basket.position.y = height / 2;
        basket.castShadow = true;
        basket.receiveShadow = true;
        group.add(basket);
      } else {
        const basketGeo = new THREE.BoxGeometry(radius * 2, height, radius * 2);
        const basket = new THREE.Mesh(basketGeo, basketMat);
        basket.position.y = height / 2;
        basket.castShadow = true;
        basket.receiveShadow = true;
        group.add(basket);
      }
      
      // Optional: Trash bag visible at top
      if (spec.bag !== false) {
        const bagGeo = new THREE.TorusGeometry(radius * 0.95, 0.015, 12, 24);
        const bagMat = new THREE.MeshStandardMaterial({
          color: 0x1a1a1a,
          roughness: 0.8
        });
        const bag = new THREE.Mesh(bagGeo, bagMat);
        bag.rotation.x = Math.PI / 2;
        bag.position.y = height * 0.95;
        group.add(bag);
      }
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    // ==================== CLEANING SUPPLIES ====================
    
    function createBroom(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      // Handle (long cylinder)
      const handleGeo = new THREE.CylinderGeometry(0.012, 0.012, 1.2, 12);
      const handleMat = new THREE.MeshStandardMaterial({
        color: 0x8b7355,
        roughness: 0.8
      });
      const handle = new THREE.Mesh(handleGeo, handleMat);
      handle.position.y = 0.6;
      handle.castShadow = true;
      group.add(handle);
      
      // Bristles (flat box at bottom)
      const bristleGeo = new THREE.BoxGeometry(0.2, 0.08, 0.06);
      const bristleMat = new THREE.MeshStandardMaterial({
        color: 0xffcc66,
        roughness: 0.9
      });
      const bristles = new THREE.Mesh(bristleGeo, bristleMat);
      bristles.position.y = 0.04;
      bristles.castShadow = true;
      group.add(bristles);
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      if (spec.lean) group.rotation.z = Math.PI / 6;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createDustpan(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      // Pan (angled box)
      const panGeo = new THREE.BoxGeometry(0.25, 0.02, 0.3);
      const panMat = new THREE.MeshStandardMaterial({
        color: 0xff4444,
        roughness: 0.6,
        metalness: 0.2
      });
      const pan = new THREE.Mesh(panGeo, panMat);
      pan.position.y = 0.02;
      pan.rotation.x = -Math.PI / 12;
      pan.castShadow = true;
      group.add(pan);
      
      // Handle
      const handleGeo = new THREE.CylinderGeometry(0.008, 0.008, 0.15, 8);
      const handle = new THREE.Mesh(handleGeo, panMat);
      handle.position.set(0, 0.08, -0.17);
      handle.rotation.x = Math.PI / 3;
      group.add(handle);
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createVacuum(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      // Body (cylinder)
      const bodyGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.45, 24);
      const bodyMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x6a4c93,
        roughness: 0.6,
        metalness: 0.2
      });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = 0.225;
      body.castShadow = true;
      body.receiveShadow = true;
      group.add(body);
      
      // Hose
      const hoseGeo = new THREE.TorusGeometry(0.15, 0.015, 8, 16, Math.PI);
      const hoseMat = new THREE.MeshStandardMaterial({
        color: 0x333333,
        roughness: 0.7
      });
      const hose = new THREE.Mesh(hoseGeo, hoseMat);
      hose.rotation.x = -Math.PI / 4;
      hose.position.set(0, 0.4, 0);
      group.add(hose);
      
      // Nozzle
      const nozzleGeo = new THREE.CylinderGeometry(0.02, 0.03, 0.25, 12);
      const nozzle = new THREE.Mesh(nozzleGeo, hoseMat);
      nozzle.rotation.x = Math.PI / 2;
      nozzle.position.set(0, 0.35, 0.2);
      group.add(nozzle);
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createHandheldVacuum(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      // Body (tapered cylinder)
      const bodyGeo = new THREE.CylinderGeometry(0.04, 0.06, 0.25, 16);
      const bodyMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x2a2a2a,
        roughness: 0.5,
        metalness: 0.3
      });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.rotation.z = Math.PI / 2;
      body.position.set(0.125, 0.05, 0);
      body.castShadow = true;
      group.add(body);
      
      // Handle
      const handleGeo = new THREE.TorusGeometry(0.035, 0.01, 8, 16, Math.PI);
      const handle = new THREE.Mesh(handleGeo, bodyMat);
      handle.rotation.z = Math.PI / 2;
      handle.position.set(-0.02, 0.08, 0);
      group.add(handle);
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createBucket(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      // Bucket body (tapered cylinder)
      const bucketGeo = new THREE.CylinderGeometry(0.15, 0.12, 0.25, 24);
      const bucketMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xff6666,
        roughness: 0.6,
        metalness: 0.2
      });
      const bucket = new THREE.Mesh(bucketGeo, bucketMat);
      bucket.position.y = 0.125;
      bucket.castShadow = true;
      bucket.receiveShadow = true;
      group.add(bucket);
      
      // Handle
      const handleGeo = new THREE.TorusGeometry(0.12, 0.008, 8, 16, Math.PI);
      const handleMat = new THREE.MeshStandardMaterial({
        color: 0x666666,
        roughness: 0.4,
        metalness: 0.6
      });
      const handle = new THREE.Mesh(handleGeo, handleMat);
      handle.rotation.x = Math.PI / 2;
      handle.position.y = 0.28;
      group.add(handle);
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createSponge(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const spongeGeo = new THREE.BoxGeometry(0.08, 0.04, 0.12);
      const spongeMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xffff66,
        roughness: 0.95
      });
      const sponge = new THREE.Mesh(spongeGeo, spongeMat);
      sponge.position.y = 0.02;
      sponge.castShadow = true;
      group.add(sponge);
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createRag(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const ragGeo = new THREE.PlaneGeometry(0.25, 0.25, 4, 4);
      const positions = ragGeo.attributes.position;
      for (let i = 0; i < positions.count; i++) {
        positions.setY(i, positions.getY(i) + (Math.random() - 0.5) * 0.02);
      }
      ragGeo.computeVertexNormals();
      
      const ragMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x8888ff,
        roughness: 0.9,
        side: THREE.DoubleSide
      });
      const rag = new THREE.Mesh(ragGeo, ragMat);
      rag.rotation.x = -Math.PI / 2 + Math.random() * 0.3;
      rag.position.y = 0.01;
      rag.receiveShadow = true;
      group.add(rag);
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createPaperTowelRoll(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      // Roll (cylinder)
      const rollGeo = new THREE.CylinderGeometry(0.06, 0.06, 0.28, 24);
      const rollMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.8
      });
      const roll = new THREE.Mesh(rollGeo, rollMat);
      roll.rotation.z = Math.PI / 2;
      roll.castShadow = true;
      roll.receiveShadow = true;
      group.add(roll);
      
      // Cardboard tube (inner)
      const tubeGeo = new THREE.CylinderGeometry(0.025, 0.025, 0.29, 16);
      const tubeMat = new THREE.MeshStandardMaterial({
        color: 0xd4a574,
        roughness: 0.9
      });
      const tube = new THREE.Mesh(tubeGeo, tubeMat);
      tube.rotation.z = Math.PI / 2;
      group.add(tube);
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0.06, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createToiletPaperRoll(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      // Roll (cylinder)
      const rollGeo = new THREE.CylinderGeometry(0.055, 0.055, 0.11, 24);
      const rollMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.85
      });
      const roll = new THREE.Mesh(rollGeo, rollMat);
      roll.rotation.z = Math.PI / 2;
      roll.castShadow = true;
      roll.receiveShadow = true;
      group.add(roll);
      
      // Cardboard tube
      const tubeGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.12, 16);
      const tubeMat = new THREE.MeshStandardMaterial({
        color: 0xd4a574,
        roughness: 0.9
      });
      const tube = new THREE.Mesh(tubeGeo, tubeMat);
      tube.rotation.z = Math.PI / 2;
      group.add(tube);
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0.055, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    // ==================== TOYS & GAMES ====================
    
    function createJengaTower(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const blockWidth = 0.015;
      const blockHeight = 0.005;
      const blockDepth = 0.045;
      const levels = spec.levels || 18;
      const config = spec.config || 'clean'; // 'clean' or 'random'
      
      const woodMat = new THREE.MeshStandardMaterial({
        color: 0xd4a574,
        roughness: 0.7
      });
      
      for (let level = 0; level < levels; level++) {
        const isVertical = level % 2 === 0;
        const blocksPerLevel = 3;
        
        for (let i = 0; i < blocksPerLevel; i++) {
          const blockGeo = new THREE.BoxGeometry(
            isVertical ? blockWidth : blockDepth,
            blockHeight,
            isVertical ? blockDepth : blockWidth
          );
          const block = new THREE.Mesh(blockGeo, woodMat);
          
          if (config === 'random' && Math.random() > 0.7) {
            // Random placement for messy tower
            block.position.set(
              (i - 1) * (blockWidth + 0.001) + (Math.random() - 0.5) * 0.008,
              level * blockHeight + blockHeight / 2 + (Math.random() - 0.5) * 0.002,
              (Math.random() - 0.5) * 0.008
            );
            block.rotation.y = (Math.random() - 0.5) * 0.15;
          } else {
            // Clean placement
            if (isVertical) {
              block.position.set(
                (i - 1) * (blockWidth + 0.001),
                level * blockHeight + blockHeight / 2,
                0
              );
            } else {
              block.position.set(
                0,
                level * blockHeight + blockHeight / 2,
                (i - 1) * (blockWidth + 0.001)
              );
            }
          }
          
          block.castShadow = true;
          block.receiveShadow = true;
          group.add(block);
        }
      }
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createDeskLamp(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const metalMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xcccccc,
        roughness: 0.4,
        metalness: 0.8
      });
      
      // Base (heavy disk)
      const baseGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.02, 24);
      const base = new THREE.Mesh(baseGeo, metalMat);
      base.position.y = 0.01;
      base.castShadow = true;
      base.receiveShadow = true;
      group.add(base);
      
      // Lower arm (angled cylinder)
      const lowerArmGeo = new THREE.CylinderGeometry(0.008, 0.008, 0.25, 12);
      const lowerArm = new THREE.Mesh(lowerArmGeo, metalMat);
      lowerArm.position.set(0, 0.15, 0);
      lowerArm.rotation.z = -Math.PI / 6;
      lowerArm.castShadow = true;
      group.add(lowerArm);
      
      // Elbow joint (sphere)
      const elbowGeo = new THREE.SphereGeometry(0.015, 16, 16);
      const elbow = new THREE.Mesh(elbowGeo, metalMat);
      elbow.position.set(0.11, 0.27, 0);
      elbow.castShadow = true;
      group.add(elbow);
      
      // Upper arm (angled cylinder)
      const upperArmGeo = new THREE.CylinderGeometry(0.006, 0.006, 0.2, 12);
      const upperArm = new THREE.Mesh(upperArmGeo, metalMat);
      upperArm.position.set(0.19, 0.37, 0);
      upperArm.rotation.z = Math.PI / 4;
      upperArm.castShadow = true;
      group.add(upperArm);
      
      // Lampshade (cone)
      const shadeGeo = new THREE.ConeGeometry(0.08, 0.12, 24);
      const shadeMat = new THREE.MeshStandardMaterial({
        color: spec.shadeColor || 0x333333,
        roughness: 0.6,
        emissive: spec.lit ? 0xffcc66 : 0x000000,
        emissiveIntensity: spec.lit ? 0.3 : 0
      });
      const shade = new THREE.Mesh(shadeGeo, shadeMat);
      shade.rotation.z = Math.PI;
      shade.position.set(0.26, 0.48, 0);
      shade.castShadow = true;
      group.add(shade);
      
      // Bulb
      const bulbGeo = new THREE.SphereGeometry(0.02, 16, 16);
      const bulbMat = new THREE.MeshStandardMaterial({
        color: 0xffff99,
        emissive: spec.lit ? 0xffcc66 : 0xffff99,
        emissiveIntensity: spec.lit ? 1.0 : 0.2
      });
      const bulb = new THREE.Mesh(bulbGeo, bulbMat);
      bulb.position.set(0.26, 0.42, 0);
      group.add(bulb);
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createPixarBall(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const radius = spec.radius || 0.055;
      
      // Ball (yellow base)
      const ballGeo = new THREE.SphereGeometry(radius, 32, 32);
      const ballMat = new THREE.MeshStandardMaterial({
        color: 0xffdd00,
        roughness: 0.4,
        metalness: 0.1
      });
      const ball = new THREE.Mesh(ballGeo, ballMat);
      ball.position.y = radius;
      ball.castShadow = true;
      ball.receiveShadow = true;
      group.add(ball);
      
      // Red stripe
      const stripeGeo = new THREE.TorusGeometry(radius * 0.9, radius * 0.15, 12, 32);
      const stripeMat = new THREE.MeshStandardMaterial({
        color: 0xff0000,
        roughness: 0.4
      });
      const stripe = new THREE.Mesh(stripeGeo, stripeMat);
      stripe.rotation.x = Math.PI / 2;
      stripe.position.y = radius;
      stripe.castShadow = true;
      group.add(stripe);
      
      // Blue star (simple circle on top)
      const starGeo = new THREE.CircleGeometry(radius * 0.3, 5);
      const starMat = new THREE.MeshStandardMaterial({
        color: 0x0066ff,
        roughness: 0.5
      });
      const star = new THREE.Mesh(starGeo, starMat);
      star.position.y = radius + 0.001;
      star.rotation.x = -Math.PI / 2;
      group.add(star);
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createBasketball(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const radius = 0.12;
      
      const ballGeo = new THREE.SphereGeometry(radius, 32, 32);
      const ballMat = new THREE.MeshStandardMaterial({
        color: 0xff8833,
        roughness: 0.8
      });
      const ball = new THREE.Mesh(ballGeo, ballMat);
      ball.position.y = radius;
      ball.castShadow = true;
      ball.receiveShadow = true;
      group.add(ball);
      
      // Black lines (simplified)
      const lineMat = new THREE.MeshStandardMaterial({
        color: 0x000000,
        roughness: 0.9
      });
      
      // Horizontal line
      const hLineGeo = new THREE.TorusGeometry(radius, 0.003, 8, 32);
      const hLine = new THREE.Mesh(hLineGeo, lineMat);
      hLine.rotation.x = Math.PI / 2;
      hLine.position.y = radius;
      group.add(hLine);
      
      // Vertical lines
      for (let i = 0; i < 2; i++) {
        const vLine = new THREE.Mesh(hLineGeo, lineMat);
        vLine.rotation.z = (i * Math.PI / 2) + Math.PI / 4;
        vLine.position.y = radius;
        group.add(vLine);
      }
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createBaseball(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const radius = 0.037;
      
      const ballGeo = new THREE.SphereGeometry(radius, 32, 32);
      const ballMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.7
      });
      const ball = new THREE.Mesh(ballGeo, ballMat);
      ball.position.y = radius;
      ball.castShadow = true;
      ball.receiveShadow = true;
      group.add(ball);
      
      // Stitching (red curves)
      const stitchMat = new THREE.MeshStandardMaterial({
        color: 0xcc0000,
        roughness: 0.8
      });
      
      // Simplified stitching as small tori
      for (let i = 0; i < 2; i++) {
        const stitchGeo = new THREE.TorusGeometry(radius * 0.5, 0.002, 6, 16, Math.PI);
        const stitch = new THREE.Mesh(stitchGeo, stitchMat);
        stitch.rotation.y = i * Math.PI;
        stitch.rotation.x = Math.PI / 4;
        stitch.position.y = radius;
        group.add(stitch);
      }
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    // ==================== CHILDREN'S TOYS ====================
    
    function createLetterBlock(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      const size = INTERIORS_ASSETS.letterblock.size;
      
      // Block colors - bright primary colors
      const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff];
      const blockColor = spec.color || colors[Math.floor(Math.random() * colors.length)];
      
      // Rounded cube (using small corner radius)
      const blockGeo = new THREE.BoxGeometry(size, size, size);
      const blockMat = new THREE.MeshStandardMaterial({
        color: blockColor,
        roughness: 0.6
      });
      const block = new THREE.Mesh(blockGeo, blockMat);
      block.position.y = size / 2;
      block.castShadow = true;
      block.receiveShadow = true;
      group.add(block);
      
      // Letter on each face (canvas texture)
      const letters = spec.letters || ['A', 'B', 'C', 'D', 'E', 'F'];
      const canvas = document.createElement('canvas');
      canvas.width = 128;
      canvas.height = 128;
      const canvasCtx = canvas.getContext('2d');
      
      // Draw letter on front face
      canvasCtx.fillStyle = '#ffffff';
      canvasCtx.font = 'bold 100px Arial';
      canvasCtx.textAlign = 'center';
      canvasCtx.textBaseline = 'middle';
      canvasCtx.fillText(letters[0], 64, 64);
      
      const letterTexture = new THREE.CanvasTexture(canvas);
      const letterMat = new THREE.MeshStandardMaterial({
        map: letterTexture,
        roughness: 0.7
      });
      
      // Apply letter to one face
      const letterPlaneGeo = new THREE.PlaneGeometry(size * 0.8, size * 0.8);
      const letterPlane = new THREE.Mesh(letterPlaneGeo, letterMat);
      letterPlane.position.set(0, size / 2, size / 2 + 0.001);
      group.add(letterPlane);
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.set(
        spec.rotX || Math.random() * 0.3,
        spec.rotation || Math.random() * Math.PI * 2,
        spec.rotZ || Math.random() * 0.3
      );
      
      ctx.targetScene.add(group);
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createXylophone(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      const x = INTERIORS_ASSETS.xylophone;
      
      // Base frame (wood)
      const frameGeo = new THREE.BoxGeometry(x.width, x.height, x.depth + 0.05);
      const frameMat = new THREE.MeshStandardMaterial({
        color: 0x8b4513,
        roughness: 0.8
      });
      const frame = new THREE.Mesh(frameGeo, frameMat);
      frame.position.y = x.height / 2;
      frame.castShadow = true;
      group.add(frame);
      
      // Metal bars (8 bars, rainbow colors)
      const barColors = [
        0xff0000, // Red (C)
        0xff7700, // Orange (D)
        0xffff00, // Yellow (E)
        0x00ff00, // Green (F)
        0x00ffff, // Cyan (G)
        0x0000ff, // Blue (A)
        0x8800ff, // Violet (B)
        0xff00ff  // Magenta (C)
      ];
      
      const barCount = 8;
      const barSpacing = x.width / (barCount + 1);
      
      for (let i = 0; i < barCount; i++) {
        const barLength = x.depth * (0.8 - i * 0.08); // Decreasing length
        const barWidth = 0.015;
        const barHeight = 0.003;
        
        const barGeo = new THREE.BoxGeometry(barWidth, barHeight, barLength);
        const barMat = new THREE.MeshStandardMaterial({
          color: barColors[i],
          roughness: 0.2,
          metalness: 0.9
        });
        const bar = new THREE.Mesh(barGeo, barMat);
        bar.position.set(
          -x.width / 2 + (i + 1) * barSpacing,
          x.height + barHeight / 2,
          0
        );
        bar.castShadow = true;
        group.add(bar);
      }
      
      // Mallets (2)
      for (let m = 0; m < 2; m++) {
        const malletGroup = new THREE.Group();
        
        // Stick
        const stickGeo = new THREE.CylinderGeometry(0.002, 0.002, 0.12, 8);
        const stickMat = new THREE.MeshStandardMaterial({
          color: 0x8b7355,
          roughness: 0.7
        });
        const stick = new THREE.Mesh(stickGeo, stickMat);
        stick.position.y = 0.06;
        malletGroup.add(stick);
        
        // Head
        const headGeo = new THREE.SphereGeometry(0.008, 12, 12);
        const headMat = new THREE.MeshStandardMaterial({
          color: m === 0 ? 0xff6666 : 0x6666ff,
          roughness: 0.7
        });
        const head = new THREE.Mesh(headGeo, headMat);
        head.position.y = 0.12;
        malletGroup.add(head);
        
        malletGroup.position.set(
          m === 0 ? -x.width / 4 : x.width / 4,
          x.height,
          x.depth / 2 + 0.03
        );
        malletGroup.rotation.z = Math.PI / 6;
        group.add(malletGroup);
      }
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createToyCar(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      const scale = INTERIORS_ASSETS.toycar.scale;
      
      // Use the same car model as city cars, but scaled down
      const colors = [0xff0000, 0x0000ff, 0x00ff00, 0xffff00, 0xff00ff, 0xffffff];
      const carColor = spec.color || colors[Math.floor(Math.random() * colors.length)];
      
      // Body (scaled down)
      const bodyGeo = new THREE.BoxGeometry(1.8 * scale, 0.6 * scale, 4 * scale);
      const bodyMat = new THREE.MeshStandardMaterial({
        color: carColor,
        metalness: 0.7,
        roughness: 0.3
      });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = 0.5 * scale;
      body.castShadow = true;
      group.add(body);
      
      // Cabin (scaled down)
      const cabinGeo = new THREE.BoxGeometry(1.6 * scale, 0.5 * scale, 2 * scale);
      const cabin = new THREE.Mesh(cabinGeo, bodyMat);
      cabin.position.y = 1.05 * scale;
      cabin.position.z = -0.2 * scale;
      cabin.castShadow = true;
      group.add(cabin);
      
      // Windows
      const windowGeo = new THREE.BoxGeometry(1.5 * scale, 0.4 * scale, 0.8 * scale);
      const windowMat = new THREE.MeshStandardMaterial({
        color: 0x88ccff,
        transparent: true,
        opacity: 0.6,
        metalness: 0.8
      });
      
      const frontWindow = new THREE.Mesh(windowGeo, windowMat);
      frontWindow.position.set(0, 1.05 * scale, 0.6 * scale);
      group.add(frontWindow);
      
      const backWindow = new THREE.Mesh(windowGeo, windowMat);
      backWindow.position.set(0, 1.05 * scale, -1 * scale);
      group.add(backWindow);
      
      // Wheels
      const wheelGeo = new THREE.CylinderGeometry(0.3 * scale, 0.3 * scale, 0.2 * scale, 12);
      const wheelMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
      
      const wheels = [
        [-0.9 * scale, 0.3 * scale, 1.2 * scale],
        [0.9 * scale, 0.3 * scale, 1.2 * scale],
        [-0.9 * scale, 0.3 * scale, -1.2 * scale],
        [0.9 * scale, 0.3 * scale, -1.2 * scale]
      ];
      
      wheels.forEach(([x, y, z]) => {
        const wheel = new THREE.Mesh(wheelGeo, wheelMat);
        wheel.rotation.z = Math.PI / 2;
        wheel.position.set(x, y, z);
        wheel.castShadow = true;
        group.add(wheel);
      });
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createToyTrain(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      const t = INTERIORS_ASSETS.toytrain;
      
      // How many cars? (1 engine + 2-3 cars)
      const carCount = spec.carCount || (2 + Math.floor(Math.random() * 2));
      const carColors = [0xff0000, 0x0000ff, 0x00ff00, 0xffff00, 0xff00ff];
      
      for (let i = 0; i < carCount; i++) {
        const carGroup = new THREE.Group();
        const isEngine = i === 0;
        
        // Car body
        const bodyGeo = new THREE.BoxGeometry(t.carWidth, t.carHeight, t.carLength);
        const bodyMat = new THREE.MeshStandardMaterial({
          color: isEngine ? 0x1a1a1a : carColors[i % carColors.length],
          roughness: 0.5,
          metalness: 0.3
        });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.position.y = t.carHeight / 2 + 0.02;
        body.castShadow = true;
        carGroup.add(body);
        
        // Roof
        const roofGeo = new THREE.BoxGeometry(t.carWidth * 0.8, t.carHeight * 0.4, t.carLength * 0.6);
        const roof = new THREE.Mesh(roofGeo, bodyMat);
        roof.position.y = t.carHeight + t.carHeight * 0.2;
        roof.castShadow = true;
        carGroup.add(roof);
        
        // Wheels (4 per car)
        const wheelGeo = new THREE.CylinderGeometry(0.025, 0.025, 0.015, 12);
        const wheelMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
        
        const wheelPositions = [
          [-t.carWidth / 2 - 0.008, 0.025, t.carLength / 3],
          [t.carWidth / 2 + 0.008, 0.025, t.carLength / 3],
          [-t.carWidth / 2 - 0.008, 0.025, -t.carLength / 3],
          [t.carWidth / 2 + 0.008, 0.025, -t.carLength / 3]
        ];
        
        wheelPositions.forEach(([x, y, z]) => {
          const wheel = new THREE.Mesh(wheelGeo, wheelMat);
          wheel.rotation.z = Math.PI / 2;
          wheel.position.set(x, y, z);
          wheel.castShadow = true;
          carGroup.add(wheel);
        });
        
        // Engine smokestack
        if (isEngine) {
          const stackGeo = new THREE.CylinderGeometry(0.02, 0.03, 0.08, 12);
          const stack = new THREE.Mesh(stackGeo, new THREE.MeshStandardMaterial({ color: 0x666666 }));
          stack.position.set(0, t.carHeight + t.carHeight * 0.4 + 0.04, t.carLength / 3);
          stack.castShadow = true;
          carGroup.add(stack);
        }
        
        // Position each car
        carGroup.position.z = i * (t.carLength + 0.03);
        group.add(carGroup);
      }
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createTrainTrack(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      const t = INTERIORS_ASSETS.traintrack;
      
      // Track type: 'straight' or 'curved'
      const trackType = spec.trackType || 'straight';
      const segmentCount = spec.segmentCount || 3;
      
      if (trackType === 'straight') {
        for (let i = 0; i < segmentCount; i++) {
          const segmentGroup = new THREE.Group();
          
          // Rails (2 parallel rails)
          const railGeo = new THREE.BoxGeometry(t.railHeight, t.railHeight, t.segmentLength);
          const railMat = new THREE.MeshStandardMaterial({
            color: 0x8b8b8b,
            roughness: 0.3,
            metalness: 0.7
          });
          
          // Left rail
          const leftRail = new THREE.Mesh(railGeo, railMat);
          leftRail.position.set(-t.railWidth / 2, t.railHeight / 2, 0);
          leftRail.castShadow = true;
          segmentGroup.add(leftRail);
          
          // Right rail
          const rightRail = new THREE.Mesh(railGeo, railMat);
          rightRail.position.set(t.railWidth / 2, t.railHeight / 2, 0);
          rightRail.castShadow = true;
          segmentGroup.add(rightRail);
          
          // Ties (cross pieces, 3 per segment)
          const tieGeo = new THREE.BoxGeometry(t.railWidth + 0.02, t.railHeight * 0.6, 0.015);
          const tieMat = new THREE.MeshStandardMaterial({
            color: 0x8b4513,
            roughness: 0.9
          });
          
          for (let j = 0; j < 3; j++) {
            const tie = new THREE.Mesh(tieGeo, tieMat);
            tie.position.set(0, t.railHeight * 0.3, (j - 1) * t.segmentLength / 3);
            tie.castShadow = true;
            segmentGroup.add(tie);
          }
          
          segmentGroup.position.z = i * t.segmentLength;
          group.add(segmentGroup);
        }
      } else if (trackType === 'curved') {
        // Curved track (quarter circle)
        const radius = spec.radius || 0.5;
        const segments = 6;
        const angleStep = (Math.PI / 2) / segments;
        
        for (let i = 0; i < segments; i++) {
          const angle = i * angleStep;
          const nextAngle = (i + 1) * angleStep;
          const midAngle = (angle + nextAngle) / 2;
          
          const segmentGroup = new THREE.Group();
          
          // Rails (curved)
          const railGeo = new THREE.BoxGeometry(t.railHeight, t.railHeight, t.segmentLength / 2);
          const railMat = new THREE.MeshStandardMaterial({
            color: 0x8b8b8b,
            roughness: 0.3,
            metalness: 0.7
          });
          
          // Left rail (inner)
          const leftRail = new THREE.Mesh(railGeo, railMat);
          const leftRadius = radius - t.railWidth / 2;
          leftRail.position.set(
            Math.cos(midAngle) * leftRadius,
            t.railHeight / 2,
            Math.sin(midAngle) * leftRadius
          );
          leftRail.rotation.y = -midAngle;
          leftRail.castShadow = true;
          segmentGroup.add(leftRail);
          
          // Right rail (outer)
          const rightRail = new THREE.Mesh(railGeo, railMat);
          const rightRadius = radius + t.railWidth / 2;
          rightRail.position.set(
            Math.cos(midAngle) * rightRadius,
            t.railHeight / 2,
            Math.sin(midAngle) * rightRadius
          );
          rightRail.rotation.y = -midAngle;
          rightRail.castShadow = true;
          segmentGroup.add(rightRail);
          
          // Tie
          const tieGeo = new THREE.BoxGeometry(t.railWidth + 0.02, t.railHeight * 0.6, 0.015);
          const tieMat = new THREE.MeshStandardMaterial({
            color: 0x8b4513,
            roughness: 0.9
          });
          const tie = new THREE.Mesh(tieGeo, tieMat);
          tie.position.set(
            Math.cos(midAngle) * radius,
            t.railHeight * 0.3,
            Math.sin(midAngle) * radius
          );
          tie.rotation.y = -midAngle;
          tie.castShadow = true;
          segmentGroup.add(tie);
          
          group.add(segmentGroup);
        }
      }
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    // ==================== RUGS ====================
    
    function createRug(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const width = spec.width || 1.5;
      const depth = spec.depth || 2.0;
      const thickness = 0.015;
      
      // Main rug body with raised edges
      const rugGeo = new THREE.PlaneGeometry(width, depth, 16, 16);
      const positions = rugGeo.attributes.position;
      
      // Create bumped/raised edges
      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const y = positions.getY(i);
        
        const xEdge = Math.abs(x) / (width / 2);
        const yEdge = Math.abs(y) / (depth / 2);
        
        let height = 0;
        
        // Tasseled edge effect - raised bumps at the edges
        if (xEdge > 0.9 || yEdge > 0.9) {
          height = 0.008 + Math.random() * 0.004;
        } else if (xEdge > 0.85 || yEdge > 0.85) {
          height = 0.003;
        }
        
        positions.setZ(i, height);
      }
      rugGeo.computeVertexNormals();
      
      const rugMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x8b4513,
        roughness: 0.95,
        side: THREE.DoubleSide
      });
      const rug = new THREE.Mesh(rugGeo, rugMat);
      rug.rotation.x = -Math.PI / 2;
      rug.position.y = 0.002;
      rug.receiveShadow = true;
      group.add(rug);
      
      // Tassels at the short edges
      const tasselCount = Math.floor(width / 0.08);
      for (let side = 0; side < 2; side++) {
        for (let i = 0; i < tasselCount; i++) {
          const tasselGeo = new THREE.CylinderGeometry(0.003, 0.001, 0.03, 4);
          const tassel = new THREE.Mesh(tasselGeo, rugMat);
          tassel.position.set(
            -width / 2 + (i + 0.5) * (width / tasselCount),
            0.015,
            (side === 0 ? -depth / 2 : depth / 2) + (side === 0 ? -0.015 : 0.015)
          );
          tassel.castShadow = true;
          group.add(tassel);
        }
      }
      
      group.position.set(spec.x * ctx.gridSize, 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    // ==================== SHELVES ====================
    
    function createShelf(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const width = spec.width || 1.2;
      const depth = 0.25;
      const shelfThickness = 0.03;
      const numShelves = spec.shelves || 3;
      const height = numShelves * 0.45;
      
      const shelfMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x8b7355,
        roughness: 0.8,
        metalness: 0.1
      });
      
      // Back panel
      const backGeo = new THREE.BoxGeometry(width, height, 0.01);
      const back = new THREE.Mesh(backGeo, shelfMat);
      back.position.set(0, height / 2, -depth / 2);
      back.castShadow = true;
      back.receiveShadow = true;
      group.add(back);
      
      // Side panels
      const sideGeo = new THREE.BoxGeometry(0.02, height, depth);
      const leftSide = new THREE.Mesh(sideGeo, shelfMat);
      leftSide.position.set(-width / 2, height / 2, 0);
      leftSide.castShadow = true;
      group.add(leftSide);
      
      const rightSide = new THREE.Mesh(sideGeo, shelfMat);
      rightSide.position.set(width / 2, height / 2, 0);
      rightSide.castShadow = true;
      group.add(rightSide);
      
      // Shelves
      for (let i = 0; i < numShelves; i++) {
        const shelfGeo = new THREE.BoxGeometry(width, shelfThickness, depth);
        const shelf = new THREE.Mesh(shelfGeo, shelfMat);
        shelf.position.y = i * (height / numShelves) + shelfThickness / 2;
        shelf.castShadow = true;
        shelf.receiveShadow = true;
        group.add(shelf);
      }
      
      group.position.set(spec.x * ctx.gridSize, 0, spec.z * ctx.gridSize);
      // Fix: Shelf back is at -Z, so add -90 degrees to make it face walls correctly
      group.rotation.y = (spec.rotation || 0) - Math.PI / 2;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    // ==================== WALL SHELVES WITH CURVED SUPPORTS ====================
    
    function createWallShelf(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const width = spec.width || 0.8;
      const depth = spec.depth || 0.25;
      const shelfThickness = 0.03;
      const wallHeight = spec.wallHeight || 1.6;
      
      const shelfMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x8b7355,
        roughness: 0.8,
        metalness: 0.1
      });
      
      // Main shelf board
      const shelfGeo = new THREE.BoxGeometry(width, shelfThickness, depth);
      const shelf = new THREE.Mesh(shelfGeo, shelfMat);
      shelf.position.y = wallHeight;
      shelf.castShadow = true;
      shelf.receiveShadow = true;
      group.add(shelf);
      
      // Curved support platforms (quarter circles) at each end
      const numSegments = 16;
      const supportRadius = depth * 0.85;
      const supportThickness = 0.02;
      
      // Create two curved supports (left and right)
      for (let side = 0; side < 2; side++) {
        const supportGroup = new THREE.Group();
        
        // Quarter circle curve (90 degrees from horizontal to vertical)
        const curveShape = new THREE.Shape();
        curveShape.moveTo(0, 0);
        curveShape.absarc(0, 0, supportRadius, -Math.PI / 2, 0, false);
        curveShape.lineTo(0, 0);
        
        const extrudeSettings = {
          depth: supportThickness,
          bevelEnabled: false
        };
        
        const supportGeo = new THREE.ExtrudeGeometry(curveShape, extrudeSettings);
        const support = new THREE.Mesh(supportGeo, shelfMat);
        support.rotation.y = Math.PI / 2;
        support.position.set(
          (side === 0 ? -width / 2 + supportThickness : width / 2 - supportThickness * 2),
          wallHeight - supportRadius,
          -depth / 2 + supportRadius
        );
        support.castShadow = true;
        support.receiveShadow = true;
        group.add(support);
        
        // Decorative edge trim on the curved support
        const edgeCurve = new THREE.EllipseCurve(
          0, 0,
          supportRadius, supportRadius,
          -Math.PI / 2, 0,
          false,
          0
        );
        
        const edgePoints = edgeCurve.getPoints(numSegments);
        const edgeGeo = new THREE.BufferGeometry().setFromPoints(edgePoints);
        const edgeMat = new THREE.LineBasicMaterial({ 
          color: 0x654321,
          linewidth: 2
        });
        const edgeLine = new THREE.Line(edgeGeo, edgeMat);
        edgeLine.rotation.y = Math.PI / 2;
        edgeLine.position.set(
          (side === 0 ? -width / 2 + supportThickness : width / 2 - supportThickness * 2),
          wallHeight - supportRadius,
          -depth / 2 + supportRadius
        );
        group.add(edgeLine);
      }
      
      group.position.set(spec.x * ctx.gridSize, 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createShelfUnit(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const width = spec.width || 1.0;
      const height = spec.height || 1.8;
      const depth = spec.depth || 0.4;
      const numShelves = spec.numShelves || 5;
      const shelfThickness = 0.03;
      
      const woodMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x8b7355,
        roughness: 0.8,
        metalness: 0.1
      });
      
      // Back panel
      const backGeo = new THREE.BoxGeometry(width, height, 0.01);
      const back = new THREE.Mesh(backGeo, woodMat);
      back.position.set(0, height / 2, -depth / 2);
      back.castShadow = true;
      back.receiveShadow = true;
      group.add(back);
      
      // Side panels
      const sideGeo = new THREE.BoxGeometry(shelfThickness, height, depth);
      const leftSide = new THREE.Mesh(sideGeo, woodMat);
      leftSide.position.set(-width / 2 + shelfThickness / 2, height / 2, 0);
      leftSide.castShadow = true;
      leftSide.receiveShadow = true;
      group.add(leftSide);
      
      const rightSide = new THREE.Mesh(sideGeo, woodMat);
      rightSide.position.set(width / 2 - shelfThickness / 2, height / 2, 0);
      rightSide.castShadow = true;
      rightSide.receiveShadow = true;
      group.add(rightSide);
      
      // Top and bottom
      const horizontalGeo = new THREE.BoxGeometry(width, shelfThickness, depth);
      const top = new THREE.Mesh(horizontalGeo, woodMat);
      top.position.set(0, height, 0);
      top.castShadow = true;
      top.receiveShadow = true;
      group.add(top);
      
      const bottom = new THREE.Mesh(horizontalGeo, woodMat);
      bottom.position.set(0, 0, 0);
      bottom.castShadow = true;
      bottom.receiveShadow = true;
      group.add(bottom);
      
      // Interior shelves
      const shelfSpacing = height / (numShelves + 1);
      for (let i = 1; i <= numShelves - 1; i++) {
        const shelfGeo = new THREE.BoxGeometry(width - shelfThickness * 2, shelfThickness, depth - 0.01);
        const shelf = new THREE.Mesh(shelfGeo, woodMat);
        shelf.position.set(0, i * shelfSpacing, 0);
        shelf.castShadow = true;
        shelf.receiveShadow = true;
        group.add(shelf);
      }
      
      // Add some decorative items on shelves (books, vases, etc.)
      if (spec.decorated !== false) {
        // Books on middle shelf
        for (let b = 0; b < 5; b++) {
          const bookWidth = 0.05 + Math.random() * 0.03;
          const bookHeight = 0.12 + Math.random() * 0.08;
          const bookDepth = 0.03;
          const bookGeo = new THREE.BoxGeometry(bookWidth, bookHeight, bookDepth);
          const bookColors = [0x8B0000, 0x00008B, 0x006400, 0x8B4513, 0x483D8B];
          const bookMat = new THREE.MeshStandardMaterial({
            color: bookColors[b % bookColors.length],
            roughness: 0.9
          });
          const book = new THREE.Mesh(bookGeo, bookMat);
          const shelfY = 2 * shelfSpacing;
          book.position.set(
            -width / 2 + shelfThickness + bookWidth / 2 + b * (bookWidth + 0.01),
            shelfY + bookHeight / 2 + shelfThickness / 2,
            depth / 4
          );
          book.castShadow = true;
          group.add(book);
        }
        
        // Small vase on top shelf
        const vaseGeo = new THREE.CylinderGeometry(0.04, 0.03, 0.12, 16);
        const vaseMat = new THREE.MeshStandardMaterial({
          color: 0x4169E1,
          roughness: 0.3,
          metalness: 0.2
        });
        const vase = new THREE.Mesh(vaseGeo, vaseMat);
        vase.position.set(
          width / 4,
          (numShelves - 1) * shelfSpacing + 0.06 + shelfThickness / 2,
          0
        );
        vase.castShadow = true;
        group.add(vase);
      }
      
      group.position.set(spec.x * ctx.gridSize, 0, spec.z * ctx.gridSize);
      // Rotate 90 degrees counterclockwise (add -PI/2) to face properly
      group.rotation.y = (spec.rotation || 0) - Math.PI / 2;
      
      ctx.targetScene.add(group);
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    // ==================== CEILING LIGHTS ====================
    
    function createCeilingLight(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      const style = spec.style || 'modern'; // 'modern', 'strip', 'classic'
      const wallHeight = INTERIORS_WALL_HEIGHT;
      
      if (style === 'modern') {
        // Modern pendant fixture
        const cableGeo = new THREE.CylinderGeometry(0.003, 0.003, 0.3, 8);
        const cableMat = new THREE.MeshStandardMaterial({
          color: 0x1a1a1a,
          roughness: 0.5,
          metalness: 0.8
        });
        const cable = new THREE.Mesh(cableGeo, cableMat);
        cable.position.y = wallHeight - 0.15;
        group.add(cable);
        
        // Lamp shade (cone)
        const shadeGeo = new THREE.ConeGeometry(0.15, 0.2, 16, 1, true);
        const shadeMat = new THREE.MeshStandardMaterial({
          color: spec.color || 0xf0f0f0,
          roughness: 0.7,
          side: THREE.DoubleSide
        });
        const shade = new THREE.Mesh(shadeGeo, shadeMat);
        shade.position.y = wallHeight - 0.35;
        shade.castShadow = true;
        group.add(shade);
        
        // Light source
        const bulbGeo = new THREE.SphereGeometry(0.04, 16, 16);
        const bulbMat = new THREE.MeshStandardMaterial({
          color: 0xffffcc,
          emissive: 0xffffcc,
          emissiveIntensity: 0.8
        });
        const bulb = new THREE.Mesh(bulbGeo, bulbMat);
        bulb.position.y = wallHeight - 0.4;
        group.add(bulb);
        
        const light = new THREE.PointLight(0xffffcc, 0.8, 8);
        light.position.y = wallHeight - 0.4;
        light.castShadow = true;
        group.add(light);
        
      } else if (style === 'strip') {
        // Modern strip light (for hallways)
        const stripWidth = spec.width || 1.2;
        const stripGeo = new THREE.BoxGeometry(stripWidth, 0.05, 0.15);
        const stripMat = new THREE.MeshStandardMaterial({
          color: 0xf0f0f0,
          emissive: 0xffffcc,
          emissiveIntensity: 0.6,
          roughness: 0.3
        });
        const strip = new THREE.Mesh(stripGeo, stripMat);
        strip.position.y = wallHeight - 0.03;
        strip.castShadow = true;
        group.add(strip);
        
        // Light
        const light = new THREE.RectAreaLight(0xffffcc, 3, stripWidth, 0.15);
        light.position.y = wallHeight - 0.08;
        light.rotation.x = Math.PI;
        group.add(light);
        
      } else if (style === 'classic') {
        // Classic glass disc light
        const baseGeo = new THREE.CylinderGeometry(0.25, 0.25, 0.05, 32);
        const baseMat = new THREE.MeshStandardMaterial({
          color: 0xffffff,
          roughness: 0.3,
          metalness: 0.5
        });
        const base = new THREE.Mesh(baseGeo, baseMat);
        base.position.y = wallHeight - 0.05;
        base.castShadow = true;
        group.add(base);
        
        // Glass cover
        const glassGeo = new THREE.SphereGeometry(0.22, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
        const glassMat = new THREE.MeshStandardMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.6,
          roughness: 0.1,
          emissive: 0xffffcc,
          emissiveIntensity: 0.4
        });
        const glass = new THREE.Mesh(glassGeo, glassMat);
        glass.rotation.x = Math.PI;
        glass.position.y = wallHeight - 0.08;
        group.add(glass);
        
        const light = new THREE.PointLight(0xffffcc, 1.2, 10);
        light.position.y = wallHeight - 0.15;
        light.castShadow = true;
        group.add(light);
      }
      
      group.position.set(spec.x * ctx.gridSize, 0, spec.z * ctx.gridSize);
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    // ==================== FLOOR STYLING ====================
    
    function createFloorStyling(bounds, style) {
      const group = new THREE.Group();
      style = style || ['hardwood', 'tile', 'carpet'][Math.floor(Math.random() * 3)];
      
      const width = (bounds.maxX - bounds.minX) * GRID_SIZE;
      const depth = (bounds.maxZ - bounds.minZ) * GRID_SIZE;
      const centerX = (bounds.minX + bounds.maxX) / 2 * GRID_SIZE;
      const centerZ = (bounds.minZ + bounds.maxZ) / 2 * GRID_SIZE;
      
      if (style === 'hardwood') {
        // Hardwood planks
        const plankWidth = 0.15;
        const numPlanks = Math.ceil(depth / plankWidth);
        
        for (let i = 0; i < numPlanks; i++) {
          const plankGeo = new THREE.PlaneGeometry(width, plankWidth);
          const woodColors = [0x8b7355, 0x9b8365, 0x7b6345, 0xab9375];
          const plankMat = new THREE.MeshStandardMaterial({
            color: woodColors[Math.floor(Math.random() * woodColors.length)],
            roughness: 0.8,
            metalness: 0.1
          });
          const plank = new THREE.Mesh(plankGeo, plankMat);
          plank.rotation.x = -Math.PI / 2;
          plank.position.set(
            centerX,
            0.001,
            bounds.minZ * GRID_SIZE + i * plankWidth + plankWidth / 2
          );
          plank.receiveShadow = true;
          group.add(plank);
        }
        
      } else if (style === 'tile') {
        // Square tiles
        const tileSize = 0.4;
        const tilesX = Math.ceil(width / tileSize);
        const tilesZ = Math.ceil(depth / tileSize);
        
        for (let x = 0; x < tilesX; x++) {
          for (let z = 0; z < tilesZ; z++) {
            const tileGeo = new THREE.PlaneGeometry(tileSize - 0.005, tileSize - 0.005);
            const isLight = (x + z) % 2 === 0;
            const tileMat = new THREE.MeshStandardMaterial({
              color: isLight ? 0xe0e0e0 : 0xc0c0c0,
              roughness: 0.3,
              metalness: 0.4
            });
            const tile = new THREE.Mesh(tileGeo, tileMat);
            tile.rotation.x = -Math.PI / 2;
            tile.position.set(
              bounds.minX * GRID_SIZE + x * tileSize + tileSize / 2,
              0.001,
              bounds.minZ * GRID_SIZE + z * tileSize + tileSize / 2
            );
            tile.receiveShadow = true;
            group.add(tile);
          }
        }
        
      } else if (style === 'carpet') {
        // Soft carpet
        const carpetGeo = new THREE.PlaneGeometry(width, depth, 32, 32);
        const positions = carpetGeo.attributes.position;
        
        // Add subtle texture variation
        for (let i = 0; i < positions.count; i++) {
          const z = positions.getZ(i);
          positions.setZ(i, z + (Math.random() - 0.5) * 0.002);
        }
        carpetGeo.computeVertexNormals();
        
        const carpetColors = [0x4a5a6a, 0x6a5a4a, 0x5a6a5a, 0x6a4a5a];
        const carpetMat = new THREE.MeshStandardMaterial({
          color: carpetColors[Math.floor(Math.random() * carpetColors.length)],
          roughness: 0.95
        });
        const carpet = new THREE.Mesh(carpetGeo, carpetMat);
        carpet.rotation.x = -Math.PI / 2;
        carpet.position.set(centerX, 0.001, centerZ);
        carpet.receiveShadow = true;
        group.add(carpet);
      }
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    // ==================== LIVING ROOM FURNITURE ====================
    
    function createCouch(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const couchWidth = spec.width || 1.8;
      const couchDepth = 0.9;
      const couchHeight = 0.75; // Reduced overall height
      const baseHeight = 0.15; // Shorter base
      const cushionHeight = 0.22; // Taller cushions
      const armHeight = 0.65; // Arms extend ABOVE cushions
      
      const fabricMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x4a5a6a,
        roughness: 0.9
      });
      
      // Base frame (shorter)
      const baseGeo = new THREE.BoxGeometry(couchWidth, baseHeight, couchDepth);
      const base = new THREE.Mesh(baseGeo, fabricMat);
      base.position.y = baseHeight / 2;
      base.castShadow = true;
      base.receiveShadow = true;
      group.add(base);
      
      // Backrest with rounded top
      const backGeo = new THREE.BoxGeometry(couchWidth, couchHeight - baseHeight, 0.15, 8, 6, 2);
      const backPos = backGeo.attributes.position;
      for (let i = 0; i < backPos.count; i++) {
        const x = backPos.getX(i);
        const y = backPos.getY(i);
        const z = backPos.getZ(i);
        
        const yEdge = Math.abs(y) / ((couchHeight - baseHeight) / 2);
        
        if (yEdge > 0.8) {
          backPos.setX(i, x * 0.96);
          backPos.setZ(i, z * 0.93);
        }
      }
      backGeo.computeVertexNormals();
      
      const back = new THREE.Mesh(backGeo, fabricMat);
      back.position.set(0, (couchHeight - baseHeight) / 2 + baseHeight, -couchDepth / 2 + 0.075);
      back.castShadow = true;
      group.add(back);
      
      // Left arm with rounded top - TALLER than cushions
      const armWidth = 0.12;
      const armGeo = new THREE.BoxGeometry(armWidth, armHeight, couchDepth * 0.95, 3, 8, 8);
      const armPos = armGeo.attributes.position;
      for (let i = 0; i < armPos.count; i++) {
        const x = armPos.getX(i);
        const y = armPos.getY(i);
        const z = armPos.getZ(i);
        
        const yNorm = y / (armHeight / 2);
        const zNorm = z / (couchDepth * 0.95 / 2);
        const xNorm = x / (armWidth / 2);
        
        // Round top and front edges
        if (yNorm > 0.7) {
          const factor = 1 - (yNorm - 0.7) * 0.3;
          armPos.setX(i, x * factor);
          armPos.setZ(i, z * (factor * 0.95 + 0.05));
        }
        if (Math.abs(zNorm) > 0.8 && Math.abs(xNorm) > 0.6) {
          const factor = 0.92;
          armPos.setX(i, x * factor);
        }
      }
      armGeo.computeVertexNormals();
      
      const leftArm = new THREE.Mesh(armGeo, fabricMat);
      leftArm.position.set(-couchWidth / 2 + armWidth / 2, armHeight / 2, 0);
      leftArm.castShadow = true;
      group.add(leftArm);
      
      // Right arm
      const rightArm = new THREE.Mesh(armGeo, fabricMat);
      rightArm.position.set(couchWidth / 2 - armWidth / 2, armHeight / 2, 0);
      rightArm.castShadow = true;
      group.add(rightArm);
      
      // Seat cushions - 3 cushions, rounded, nearly touching, sized to not clip with arms
      const numCushions = 3;
      const cushionGap = 0.015; // Very small gap
      const totalCushionWidth = couchWidth - armWidth * 2 - 0.08; // Leave space from arms
      const cushionWidth = (totalCushionWidth - cushionGap * (numCushions - 1)) / numCushions;
      const cushionDepth = couchDepth * 0.7;
      
      for (let i = 0; i < numCushions; i++) {
        const cushionGeo = new THREE.BoxGeometry(cushionWidth, cushionHeight, cushionDepth, 6, 4, 6);
        const cushPos = cushionGeo.attributes.position;
        
        // Round ALL edges and corners of cushions
        for (let j = 0; j < cushPos.count; j++) {
          const x = cushPos.getX(j);
          const y = cushPos.getY(j);
          const z = cushPos.getZ(j);
          
          const xNorm = Math.abs(x) / (cushionWidth / 2);
          const yNorm = Math.abs(y) / (cushionHeight / 2);
          const zNorm = Math.abs(z) / (cushionDepth / 2);
          
          // Round all corners and edges
          if (xNorm > 0.7 || yNorm > 0.7 || zNorm > 0.7) {
            const edgeFactor = Math.sqrt(xNorm * xNorm + yNorm * yNorm + zNorm * zNorm);
            if (edgeFactor > 1.0) {
              const roundFactor = 0.85 + (1.0 - Math.min(edgeFactor, 1.3)) * 0.15;
              cushPos.setX(j, x * roundFactor);
              cushPos.setY(j, y * roundFactor);
              cushPos.setZ(j, z * roundFactor);
            }
          }
        }
        cushionGeo.computeVertexNormals();
        
        const cushion = new THREE.Mesh(cushionGeo, fabricMat);
        const startX = -totalCushionWidth / 2 + cushionWidth / 2;
        cushion.position.set(
          startX + i * (cushionWidth + cushionGap),
          baseHeight + cushionHeight / 2,
          0
        );
        cushion.castShadow = true;
        cushion.receiveShadow = true;
        group.add(cushion);
      }
      
      // Use GRID_SIZE from spec or fall back to global (for interiors vs main scene)
      const gridSize = spec.GRID_SIZE || (typeof GRID_SIZE !== 'undefined' ? GRID_SIZE : 0.6);
      const targetScene = spec.scene || scene;
      const targetObjects = spec.objects || roomObjects;
      
      group.position.set(spec.x * gridSize, 0, spec.z * gridSize);
      group.rotation.y = spec.rotation || 0;
      
      targetScene.add(group);
      targetObjects.push(group);
      return group;
    }
    
    function createTV(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const style = spec.style || 'flat'; // 'flat' or 'tube'
      const tvWidth = spec.width || 1.2;
      const tvHeight = tvWidth * 0.6;
      
      if (style === 'tube') {
        // Old school CRT TV with subtle barrel distortion
        const tvDepth = 0.45;
        
        // Create bulging screen with sphere segment (reduced curvature)
        const screenGeo = new THREE.SphereGeometry(tvWidth * 1.2, 48, 48, 0, Math.PI * 2, 0, Math.PI / 5);
        const screenMat = new THREE.MeshStandardMaterial({
          color: 0x1a1a2a,
          roughness: 0.2,
          metalness: 0.3
        });
        const screen = new THREE.Mesh(screenGeo, screenMat);
        screen.rotation.x = -Math.PI / 2;
        screen.position.set(0, tvHeight / 2 + 0.025, tvDepth / 2);
        screen.castShadow = true;
        group.add(screen);
        
        // Plastic casing
        const casingGeo = new THREE.BoxGeometry(tvWidth, tvHeight, tvDepth);
        const casingMat = new THREE.MeshStandardMaterial({
          color: 0x4a4a4a,
          roughness: 0.7,
          metalness: 0.1
        });
        const casing = new THREE.Mesh(casingGeo, casingMat);
        casing.position.y = tvHeight / 2 + 0.025;
        casing.castShadow = true;
        casing.receiveShadow = true;
        group.add(casing);
        
        // Control panel (buttons on front)
        const panelGeo = new THREE.BoxGeometry(0.15, 0.08, 0.02);
        const panelMat = new THREE.MeshStandardMaterial({
          color: 0x333333,
          roughness: 0.8
        });
        const panel = new THREE.Mesh(panelGeo, panelMat);
        panel.position.set(tvWidth * 0.35, 0.04, tvDepth / 2 + 0.01);
        group.add(panel);
        
        // Base/feet (flush with surface)
        const baseGeo = new THREE.BoxGeometry(tvWidth * 0.9, 0.02, tvDepth * 0.8);
        const base = new THREE.Mesh(baseGeo, casingMat);
        base.position.y = 0.01;
        base.receiveShadow = true;
        group.add(base);
        
      } else {
        // Modern flat screen TV
        const tvDepth = 0.05;
        
        // TV screen (positioned flush with base at y=0)
        const screenGeo = new THREE.BoxGeometry(tvWidth, tvHeight, tvDepth);
        const screenMat = new THREE.MeshStandardMaterial({
          color: 0x0a0a0a,
          roughness: 0.1,
          metalness: 0.8
        });
        const screen = new THREE.Mesh(screenGeo, screenMat);
        screen.position.y = tvHeight / 2 + 0.15; // Positioned above stand
        screen.castShadow = true;
        group.add(screen);
        
        // Frame/bezel
        const bezelGeo = new THREE.BoxGeometry(tvWidth + 0.04, tvHeight + 0.04, tvDepth - 0.01);
        const bezelMat = new THREE.MeshStandardMaterial({
          color: 0x1a1a1a,
          roughness: 0.6,
          metalness: 0.4
        });
        const bezel = new THREE.Mesh(bezelGeo, bezelMat);
        bezel.position.set(0, tvHeight / 2 + 0.15, -tvDepth / 2);
        bezel.castShadow = true;
        group.add(bezel);
        
        // Stand (slim vertical post)
        const standGeo = new THREE.CylinderGeometry(0.04, 0.06, 0.12, 16);
        const standMat = new THREE.MeshStandardMaterial({
          color: 0x2a2a2a,
          roughness: 0.7,
          metalness: 0.3
        });
        const stand = new THREE.Mesh(standGeo, standMat);
        stand.position.y = 0.06; // Stand extends from base
        stand.castShadow = true;
        group.add(stand);
        
        // Base (flush with TV stand surface)
        const baseGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.01, 16);
        const base = new THREE.Mesh(baseGeo, standMat);
        base.position.y = 0.005; // Flush with surface
        base.receiveShadow = true;
        group.add(base);
      }
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createTVStand(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const style = spec.style || 'modern'; // 'modern', 'classic', 'minimal'
      const width = spec.width || 1.5;
      const height = 0.5;
      const depth = 0.4;
      
      const woodMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x654321,
        roughness: 0.7,
        metalness: 0.1
      });
      
      if (style === 'modern') {
        // Floating shelf style
        const topGeo = new THREE.BoxGeometry(width, 0.05, depth);
        const top = new THREE.Mesh(topGeo, woodMat);
        top.position.y = height;
        top.castShadow = true;
        top.receiveShadow = true;
        group.add(top);
        
        // Two compartments
        const dividerGeo = new THREE.BoxGeometry(0.02, height - 0.05, depth * 0.95);
        const divider = new THREE.Mesh(dividerGeo, woodMat);
        divider.position.y = height / 2;
        divider.castShadow = true;
        group.add(divider);
        
        // Sides
        const sideGeo = new THREE.BoxGeometry(0.02, height, depth);
        [-width/2 + 0.01, width/2 - 0.01].forEach(x => {
          const side = new THREE.Mesh(sideGeo, woodMat);
          side.position.set(x, height / 2, 0);
          side.castShadow = true;
          group.add(side);
        });
        
        // Back panel
        const backGeo = new THREE.BoxGeometry(width, height, 0.01);
        const back = new THREE.Mesh(backGeo, woodMat);
        back.position.set(0, height / 2, -depth / 2 + 0.005);
        back.castShadow = true;
        group.add(back);
        
      } else if (style === 'classic') {
        // Traditional cabinet with doors
        const bodyGeo = new THREE.BoxGeometry(width, height, depth);
        const body = new THREE.Mesh(bodyGeo, woodMat);
        body.position.y = height / 2;
        body.castShadow = true;
        body.receiveShadow = true;
        group.add(body);
        
        // Doors (two panels)
        const doorMat = new THREE.MeshStandardMaterial({
          color: 0x5a4321,
          roughness: 0.8
        });
        [-width/4, width/4].forEach(x => {
          const doorGeo = new THREE.BoxGeometry(width / 2 - 0.05, height * 0.8, 0.02);
          const door = new THREE.Mesh(doorGeo, doorMat);
          door.position.set(x, height / 2, depth / 2 + 0.01);
          door.castShadow = true;
          group.add(door);
          
          // Handles
          const handleGeo = new THREE.CylinderGeometry(0.008, 0.008, 0.04, 8);
          const handleMat = new THREE.MeshStandardMaterial({
            color: 0xccaa44,
            roughness: 0.3,
            metalness: 0.8
          });
          const handle = new THREE.Mesh(handleGeo, handleMat);
          handle.rotation.z = Math.PI / 2;
          handle.position.set(x + (x > 0 ? -0.15 : 0.15), height / 2, depth / 2 + 0.03);
          group.add(handle);
        });
        
      } else {
        // Minimal style - just a platform
        const platformGeo = new THREE.BoxGeometry(width, 0.08, depth);
        const platform = new THREE.Mesh(platformGeo, woodMat);
        platform.position.y = height;
        platform.castShadow = true;
        platform.receiveShadow = true;
        group.add(platform);
        
        // Four legs
        const legGeo = new THREE.CylinderGeometry(0.02, 0.02, height - 0.08, 12);
        [[-width/2 + 0.1, -depth/2 + 0.1], [width/2 - 0.1, -depth/2 + 0.1],
         [-width/2 + 0.1, depth/2 - 0.1], [width/2 - 0.1, depth/2 - 0.1]].forEach(([x, z]) => {
          const leg = new THREE.Mesh(legGeo, woodMat);
          leg.position.set(x, (height - 0.08) / 2, z);
          leg.castShadow = true;
          group.add(leg);
        });
      }
      
      group.position.set(spec.x * ctx.gridSize, 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createGameConsole(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const type = spec.consoleType || 'modern'; // 'modern', 'classic', 'handheld'
      
      if (type === 'modern') {
        // PlayStation/Xbox style
        const width = 0.3;
        const height = 0.05;
        const depth = 0.25;
        
        const consoleGeo = new THREE.BoxGeometry(width, height, depth);
        const consoleMat = new THREE.MeshStandardMaterial({
          color: spec.color || 0x1a1a1a,
          roughness: 0.5,
          metalness: 0.4
        });
        const console = new THREE.Mesh(consoleGeo, consoleMat);
        console.position.y = height / 2;
        console.castShadow = true;
        console.receiveShadow = true;
        group.add(console);
        
        // Power LED
        const ledGeo = new THREE.CircleGeometry(0.003, 12);
        const ledMat = new THREE.MeshStandardMaterial({
          color: 0x00ff00,
          emissive: 0x00ff00,
          emissiveIntensity: 0.6
        });
        const led = new THREE.Mesh(ledGeo, ledMat);
        led.position.set(-width * 0.3, height + 0.001, 0);
        led.rotation.x = -Math.PI / 2;
        group.add(led);
        
        // Disc slot
        const slotGeo = new THREE.BoxGeometry(0.12, 0.002, 0.001);
        const slotMat = new THREE.MeshStandardMaterial({
          color: 0x000000
        });
        const slot = new THREE.Mesh(slotGeo, slotMat);
        slot.position.set(0, height / 2, depth / 2 + 0.001);
        group.add(slot);
        
      } else {
        // Classic cartridge console
        const width = 0.35;
        const height = 0.08;
        const depth = 0.2;
        
        const consoleGeo = new THREE.BoxGeometry(width, height, depth);
        const consoleMat = new THREE.MeshStandardMaterial({
          color: 0x888888,
          roughness: 0.7
        });
        const console = new THREE.Mesh(consoleGeo, consoleMat);
        console.position.y = height / 2;
        console.castShadow = true;
        console.receiveShadow = true;
        group.add(console);
        
        // Cartridge slot on top
        const slotGeo = new THREE.BoxGeometry(0.15, 0.04, 0.1);
        const slotMat = new THREE.MeshStandardMaterial({
          color: 0x333333
        });
        const slot = new THREE.Mesh(slotGeo, slotMat);
        slot.position.y = height + 0.02;
        group.add(slot);
      }
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createDVD(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const radius = 0.06;
      const thickness = 0.0012;
      
      // Disc
      const discGeo = new THREE.CylinderGeometry(radius, radius, thickness, 32);
      const discMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xccccff,
        roughness: 0.2,
        metalness: 0.8
      });
      const disc = new THREE.Mesh(discGeo, discMat);
      disc.position.y = thickness / 2;
      disc.castShadow = true;
      disc.receiveShadow = true;
      group.add(disc);
      
      // Center hole
      const holeGeo = new THREE.CylinderGeometry(0.0075, 0.0075, thickness + 0.001, 16);
      const holeMat = new THREE.MeshStandardMaterial({
        color: 0x1a1a1a
      });
      const hole = new THREE.Mesh(holeGeo, holeMat);
      hole.position.y = thickness / 2;
      group.add(hole);
      
      // Label (top side)
      const labelGeo = new THREE.CircleGeometry(radius * 0.7, 32);
      const labelMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.9
      });
      const label = new THREE.Mesh(labelGeo, labelMat);
      label.rotation.x = -Math.PI / 2;
      label.position.y = thickness + 0.0001;
      group.add(label);
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createDVDCase(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const width = 0.135;
      const height = 0.19;
      const depth = 0.014;
      
      // Case
      const caseGeo = new THREE.BoxGeometry(width, height, depth);
      const caseMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x000000,
        roughness: 0.6,
        transparent: true,
        opacity: 0.9
      });
      const dvdCase = new THREE.Mesh(caseGeo, caseMat);
      dvdCase.position.y = height / 2;
      dvdCase.castShadow = true;
      dvdCase.receiveShadow = true;
      group.add(dvdCase);
      
      // Cover art (front)
      const artGeo = new THREE.PlaneGeometry(width * 0.95, height * 0.95);
      const artMat = new THREE.MeshStandardMaterial({
        color: spec.coverColor || 0x4466ff,
        roughness: 0.8
      });
      const art = new THREE.Mesh(artGeo, artMat);
      art.position.set(0, height / 2, depth / 2 + 0.001);
      group.add(art);
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createRemote(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const width = 0.05;
      const height = 0.18;
      const depth = 0.025;
      
      // Remote body (rounded rectangle)
      const bodyGeo = new THREE.BoxGeometry(width, height, depth, 2, 4, 2);
      // Round the corners
      const positions = bodyGeo.attributes.position;
      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const y = positions.getY(i);
        const z = positions.getZ(i);
        const factor = 0.92 + 0.08 * Math.sqrt(x*x/width/width + z*z/depth/depth);
        positions.setXYZ(i, x * factor, y, z * factor);
      }
      bodyGeo.computeVertexNormals();
      
      const bodyMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x2a2a2a,
        roughness: 0.7,
        metalness: 0.1
      });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = height / 2;
      body.castShadow = true;
      body.receiveShadow = true;
      group.add(body);
      
      // Buttons - Power button at top (red)
      const powerButtonGeo = new THREE.CylinderGeometry(0.007, 0.007, 0.003, 16);
      const powerButtonMat = new THREE.MeshStandardMaterial({
        color: 0xff3333,
        roughness: 0.4,
        emissive: 0x330000,
        emissiveIntensity: 0.2
      });
      const powerButton = new THREE.Mesh(powerButtonGeo, powerButtonMat);
      powerButton.rotation.x = Math.PI / 2;
      powerButton.position.set(0, height * 0.85, depth / 2 + 0.0015);
      group.add(powerButton);
      
      // Navigation D-pad (center)
      const buttonMat = new THREE.MeshStandardMaterial({
        color: 0x4a4a4a,
        roughness: 0.5
      });
      
      const dpadPositions = [
        [0, 0.012, 0],       // Up
        [0, -0.012, 0],      // Down
        [-0.012, 0, 0],      // Left
        [0.012, 0, 0],       // Right
        [0, 0, 0]            // Center (OK button)
      ];
      
      dpadPositions.forEach(([dx, dy, dz]) => {
        const buttonGeo = new THREE.CylinderGeometry(0.005, 0.005, 0.002, 12);
        const button = new THREE.Mesh(buttonGeo, buttonMat);
        button.rotation.x = Math.PI / 2;
        button.position.set(dx, height * 0.6 + dy, depth / 2 + 0.0012);
        group.add(button);
      });
      
      // Number pad (3x3 grid)
      for (let row = 0; row < 3; row++) {
        for (let col = 0; col < 3; col++) {
          const buttonGeo = new THREE.CylinderGeometry(0.004, 0.004, 0.0018, 12);
          const button = new THREE.Mesh(buttonGeo, buttonMat);
          button.rotation.x = Math.PI / 2;
          button.position.set(
            -width * 0.3 + col * width * 0.3,
            height * 0.35 - row * 0.022,
            depth / 2 + 0.0012
          );
          group.add(button);
        }
      }
      
      // Bottom control buttons (volume, channel, etc.)
      for (let i = 0; i < 4; i++) {
        const buttonGeo = new THREE.BoxGeometry(0.008, 0.015, 0.002);
        const button = new THREE.Mesh(buttonGeo, buttonMat);
        button.position.set(
          -width * 0.35 + i * (width * 0.23),
          height * 0.15,
          depth / 2 + 0.0012
        );
        group.add(button);
      }
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createGameController(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const controllerType = spec.controllerType || 'modern'; // 'modern' or 'retro'
      
      if (controllerType === 'modern') {
        // Modern controller (Xbox/PlayStation style)
        const bodyWidth = 0.12;
        const bodyHeight = 0.06;
        const bodyDepth = 0.03;
        
        // Main body (rounded shape with grips)
        const bodyGeo = new THREE.SphereGeometry(bodyHeight, 24, 16, 0, Math.PI * 2, 0, Math.PI / 2);
        const bodyMat = new THREE.MeshStandardMaterial({
          color: spec.color || 0x2a2a3a,
          roughness: 0.6,
          metalness: 0.2
        });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.scale.set(bodyWidth / bodyHeight, 1, bodyDepth / bodyHeight);
        body.position.y = bodyHeight * 0.3;
        body.rotation.x = Math.PI;
        body.castShadow = true;
        body.receiveShadow = true;
        group.add(body);
        
        // Left analog stick
        const stickGeo = new THREE.CylinderGeometry(0.012, 0.014, 0.008, 24);
        const stickMat = new THREE.MeshStandardMaterial({
          color: 0x1a1a1a,
          roughness: 0.8
        });
        const leftStick = new THREE.Mesh(stickGeo, stickMat);
        leftStick.position.set(-0.03, 0.012, -0.01);
        leftStick.castShadow = true;
        group.add(leftStick);
        
        // Right analog stick
        const rightStick = leftStick.clone();
        rightStick.position.set(0.025, 0.01, 0.01);
        group.add(rightStick);
        
        // D-pad (left side)
        const dpadMat = new THREE.MeshStandardMaterial({
          color: 0x3a3a3a,
          roughness: 0.5
        });
        const dpadPositions = [
          [-0.028, 0, 0.008],       // Up
          [-0.028, 0, -0.008],      // Down
          [-0.036, 0, 0],           // Left
          [-0.020, 0, 0]            // Right
        ];
        dpadPositions.forEach(([x, y, z]) => {
          const buttonGeo = new THREE.BoxGeometry(0.007, 0.003, 0.007);
          const button = new THREE.Mesh(buttonGeo, dpadMat);
          button.position.set(x, 0.012 + y, z);
          button.castShadow = true;
          group.add(button);
        });
        
        // Action buttons (right side - ABXY pattern)
        const buttonColors = [0x66ff66, 0xff6666, 0x6666ff, 0xffff66]; // Green, Red, Blue, Yellow
        const buttonPositions = [
          [0.028, 0, 0.008],   // Top (Y)
          [0.028, 0, -0.008],  // Bottom (A)
          [0.020, 0, 0],       // Left (X)
          [0.036, 0, 0]        // Right (B)
        ];
        buttonPositions.forEach(([x, y, z], i) => {
          const buttonGeo = new THREE.CylinderGeometry(0.006, 0.006, 0.003, 16);
          const buttonMat = new THREE.MeshStandardMaterial({
            color: buttonColors[i],
            roughness: 0.4,
            emissive: buttonColors[i],
            emissiveIntensity: 0.1
          });
          const button = new THREE.Mesh(buttonGeo, buttonMat);
          button.rotation.x = Math.PI / 2;
          button.position.set(x, 0.013 + y, z);
          button.castShadow = true;
          group.add(button);
        });
        
        // Shoulder triggers (bumpers)
        const triggerGeo = new THREE.BoxGeometry(0.025, 0.008, 0.012);
        const triggerMat = new THREE.MeshStandardMaterial({
          color: 0x3a3a3a,
          roughness: 0.5
        });
        const leftTrigger = new THREE.Mesh(triggerGeo, triggerMat);
        leftTrigger.position.set(-0.045, 0.018, 0.01);
        leftTrigger.rotation.x = -0.3;
        leftTrigger.castShadow = true;
        group.add(leftTrigger);
        
        const rightTrigger = leftTrigger.clone();
        rightTrigger.position.set(0.045, 0.018, 0.01);
        group.add(rightTrigger);
        
      } else {
        // Retro controller (NES/SNES style - rectangular with simple buttons)
        const bodyGeo = new THREE.BoxGeometry(0.14, 0.015, 0.05);
        const bodyMat = new THREE.MeshStandardMaterial({
          color: spec.color || 0xcccccc,
          roughness: 0.7
        });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.position.y = 0.0075;
        body.castShadow = true;
        body.receiveShadow = true;
        group.add(body);
        
        // D-pad (left side)
        const dpadMat = new THREE.MeshStandardMaterial({
          color: 0x2a2a2a,
          roughness: 0.6
        });
        const dpadCenterGeo = new THREE.CylinderGeometry(0.015, 0.015, 0.004, 8);
        const dpadCenter = new THREE.Mesh(dpadCenterGeo, dpadMat);
        dpadCenter.position.set(-0.04, 0.018, 0);
        dpadCenter.castShadow = true;
        group.add(dpadCenter);
        
        // Action buttons (right side - circular pattern)
        const buttonColors = [0xff4444, 0x44ff44]; // Red and Green
        const buttonPositions = [
          [0.04, 0, 0.01],
          [0.05, 0, 0],
          [0.04, 0, -0.01],
          [0.03, 0, 0]
        ];
        buttonPositions.forEach(([x, y, z], i) => {
          const buttonGeo = new THREE.CylinderGeometry(0.008, 0.008, 0.004, 16);
          const buttonMat = new THREE.MeshStandardMaterial({
            color: buttonColors[i % 2],
            roughness: 0.4
          });
          const button = new THREE.Mesh(buttonGeo, buttonMat);
          button.position.set(x, 0.018 + y, z);
          button.castShadow = true;
          group.add(button);
        });
        
        // Select/Start buttons (center)
        for (let i = 0; i < 2; i++) {
          const smallButtonGeo = new THREE.BoxGeometry(0.012, 0.003, 0.006);
          const smallButton = new THREE.Mesh(smallButtonGeo, dpadMat);
          smallButton.position.set(-0.01 + i * 0.02, 0.017, 0);
          smallButton.castShadow = true;
          group.add(smallButton);
        }
      }
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createCoffeeTable(spec) {
      const shape = spec.shape || 'rectangle';
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const tableMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x8b7355,
        roughness: 0.7,
        metalness: 0.1
      });
      
      const tableHeight = 0.4;
      const thickness = 0.04;
      
      // Tabletop based on shape
      let topGeo;
      if (shape === 'square') {
        topGeo = new THREE.BoxGeometry(0.8, thickness, 0.8);
      } else if (shape === 'circle') {
        topGeo = new THREE.CylinderGeometry(0.4, 0.4, thickness, 32);
      } else {
        topGeo = new THREE.BoxGeometry(1.2, thickness, 0.6);
      }
      
      const top = new THREE.Mesh(topGeo, tableMat);
      top.position.y = tableHeight;
      top.castShadow = true;
      top.receiveShadow = true;
      group.add(top);
      
      // Legs (4 legs)
      const legGeo = new THREE.CylinderGeometry(0.02, 0.025, tableHeight - thickness, 8);
      const legMat = new THREE.MeshStandardMaterial({
        color: 0x654321,
        roughness: 0.8
      });
      
      const positions = shape === 'circle' 
        ? [[0.3, 0, 0.3], [-0.3, 0, 0.3], [0.3, 0, -0.3], [-0.3, 0, -0.3]]
        : shape === 'square'
        ? [[0.35, 0, 0.35], [-0.35, 0, 0.35], [0.35, 0, -0.35], [-0.35, 0, -0.35]]
        : [[0.55, 0, 0.25], [-0.55, 0, 0.25], [0.55, 0, -0.25], [-0.55, 0, -0.25]];
      
      positions.forEach(([x, y, z]) => {
        const leg = new THREE.Mesh(legGeo, legMat);
        leg.position.set(x, (tableHeight - thickness) / 2, z);
        leg.castShadow = true;
        group.add(leg);
      });
      
      group.position.set(spec.x * ctx.gridSize, 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    // ==================== GAME PIECES ====================
    
    function createPlayingCard(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const cardWidth = 0.064;
      const cardHeight = 0.089;
      const cardThickness = 0.001;
      
      // Card body
      const cardGeo = new THREE.BoxGeometry(cardWidth, cardThickness, cardHeight);
      const cardMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.6
      });
      const card = new THREE.Mesh(cardGeo, cardMat);
      card.rotation.x = Math.PI / 2;
      card.position.y = cardThickness / 2;
      card.castShadow = true;
      card.receiveShadow = true;
      group.add(card);
      
      // Card back (simple pattern)
      const backGeo = new THREE.PlaneGeometry(cardWidth * 0.9, cardHeight * 0.9);
      const backMat = new THREE.MeshStandardMaterial({
        color: spec.suit === 'red' ? 0xff3333 : 0x3333ff,
        roughness: 0.7
      });
      const back = new THREE.Mesh(backGeo, backMat);
      back.position.y = cardThickness + 0.0001;
      back.rotation.x = -Math.PI / 2;
      group.add(back);
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createDice(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const size = spec.size || 0.015;
      const halfSize = size / 2;
      
      // Create rounded cube using merged geometry for barrel distortion effect
      const diceGeo = new THREE.BoxGeometry(size, size, size, 4, 4, 4);
      
      // Apply subtle barrel distortion to vertices
      const positions = diceGeo.attributes.position;
      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const y = positions.getY(i);
        const z = positions.getZ(i);
        
        // Normalize and apply barrel distortion
        const dist = Math.sqrt(x*x + y*y + z*z);
        if (dist > 0) {
          const factor = 1 + 0.08 * (dist / halfSize - 1);
          positions.setXYZ(i, x * factor, y * factor, z * factor);
        }
      }
      positions.needsUpdate = true;
      diceGeo.computeVertexNormals();
      
      const diceMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xffffff,
        roughness: 0.3,
        metalness: 0.1
      });
      const dice = new THREE.Mesh(diceGeo, diceMat);
      dice.position.y = size / 2;
      dice.castShadow = true;
      dice.receiveShadow = true;
      
      // Random rotation for natural look
      dice.rotation.set(
        Math.random() * Math.PI,
        Math.random() * Math.PI,
        Math.random() * Math.PI
      );
      
      group.add(dice);
      
      // Pip configurations for dice faces (1-6)
      const pipPatterns = {
        1: [[0, 0]], // center
        2: [[-0.25, -0.25], [0.25, 0.25]], // diagonal
        3: [[-0.25, -0.25], [0, 0], [0.25, 0.25]], // diagonal with center
        4: [[-0.25, -0.25], [0.25, -0.25], [-0.25, 0.25], [0.25, 0.25]], // corners
        5: [[-0.25, -0.25], [0.25, -0.25], [0, 0], [-0.25, 0.25], [0.25, 0.25]], // corners + center
        6: [[-0.25, -0.25], [0.25, -0.25], [-0.25, 0], [0.25, 0], [-0.25, 0.25], [0.25, 0.25]] // two columns
      };
      
      // Add pips to each face (scooped indentations)
      const pipRadius = size * 0.08;
      const pipDepth = size * 0.12;
      const pipMat = new THREE.MeshStandardMaterial({ 
        color: 0x000000,
        roughness: 0.8
      });
      
      // Face orientations: [rotation, position, pips]
      const faces = [
        { rot: [0, 0, 0], pos: [0, halfSize, 0], pips: 1 }, // top
        { rot: [Math.PI, 0, 0], pos: [0, -halfSize, 0], pips: 6 }, // bottom
        { rot: [Math.PI/2, 0, 0], pos: [0, 0, halfSize], pips: 2 }, // front
        { rot: [-Math.PI/2, 0, 0], pos: [0, 0, -halfSize], pips: 5 }, // back
        { rot: [0, 0, Math.PI/2], pos: [halfSize, 0, 0], pips: 3 }, // right
        { rot: [0, 0, -Math.PI/2], pos: [-halfSize, 0, 0], pips: 4 } // left
      ];
      
      faces.forEach(face => {
        const pattern = pipPatterns[face.pips];
        pattern.forEach(([px, pz]) => {
          // Create scooped pip using hemisphere
          const pipGeo = new THREE.SphereGeometry(pipRadius, 12, 8, 0, Math.PI * 2, 0, Math.PI / 2);
          const pip = new THREE.Mesh(pipGeo, pipMat);
          
          // Position on face
          pip.position.set(
            face.pos[0] + px * size,
            face.pos[1] + pz * size,
            face.pos[2]
          );
          
          // Rotate to align with face and point inward
          pip.rotation.set(...face.rot);
          pip.rotation.x += Math.PI; // flip to point inward
          
          // Offset slightly inward for scooped effect
          const offset = new THREE.Vector3(0, -pipDepth, 0);
          offset.applyEuler(new THREE.Euler(...face.rot));
          pip.position.add(offset);
          
          dice.add(pip);
        });
      });
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createPokerChip(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const radius = 0.02;
      const thickness = 0.003;
      
      // Chip body
      const chipGeo = new THREE.CylinderGeometry(radius, radius, thickness, 32);
      const chipMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xff3333,
        roughness: 0.5,
        metalness: 0.2
      });
      const chip = new THREE.Mesh(chipGeo, chipMat);
      chip.position.y = thickness / 2;
      chip.castShadow = true;
      chip.receiveShadow = true;
      group.add(chip);
      
      // Edge decoration (white ring)
      const ringGeo = new THREE.TorusGeometry(radius * 0.9, thickness * 0.3, 8, 32);
      const ringMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.6
      });
      const ring = new THREE.Mesh(ringGeo, ringMat);
      ring.rotation.x = Math.PI / 2;
      ring.position.y = thickness / 2;
      group.add(ring);
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createGameBoard(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const boardSize = spec.size || 0.5;
      const boardThickness = 0.015;
      const variant = spec.variant || 'checkers'; // 'checkers' or 'chess'
      
      // Board base with beveled edge
      const boardGeo = new THREE.BoxGeometry(boardSize, boardThickness, boardSize);
      const boardMat = new THREE.MeshStandardMaterial({
        color: 0xe8dcc0,
        roughness: 0.8
      });
      const board = new THREE.Mesh(boardGeo, boardMat);
      board.position.y = boardThickness / 2;
      board.castShadow = true;
      board.receiveShadow = true;
      group.add(board);
      
      // Border frame (decorative)
      const frameThickness = boardSize * 0.05;
      const frameGeo = new THREE.BoxGeometry(boardSize + frameThickness, boardThickness * 0.5, frameThickness);
      const frameMat = new THREE.MeshStandardMaterial({
        color: 0x654321,
        roughness: 0.7
      });
      
      // Four sides of frame
      [-boardSize/2, boardSize/2].forEach(z => {
        const frame = new THREE.Mesh(frameGeo, frameMat);
        frame.position.set(0, boardThickness * 0.75, z);
        frame.castShadow = true;
        group.add(frame);
      });
      
      const frameGeo2 = new THREE.BoxGeometry(frameThickness, boardThickness * 0.5, boardSize);
      [-boardSize/2, boardSize/2].forEach(x => {
        const frame = new THREE.Mesh(frameGeo2, frameMat);
        frame.position.set(x, boardThickness * 0.75, 0);
        frame.castShadow = true;
        group.add(frame);
      });
      
      // Checkerboard/chessboard pattern
      const squareSize = boardSize / 8;
      const squareThickness = 0.002;
      const squareGeo = new THREE.BoxGeometry(squareSize * 0.98, squareThickness, squareSize * 0.98);
      
      // Colors based on variant
      const darkColor = variant === 'chess' ? 0x3a2a1a : 0x000000; // Black for checkers
      const lightColor = variant === 'chess' ? 0xf4e4d4 : 0xcc0000; // Red for checkers
      
      const darkMat = new THREE.MeshStandardMaterial({
        color: darkColor,
        roughness: variant === 'chess' ? 0.6 : 0.9,
        metalness: variant === 'chess' ? 0.1 : 0
      });
      const lightMat = new THREE.MeshStandardMaterial({
        color: lightColor,
        roughness: variant === 'chess' ? 0.6 : 0.9,
        metalness: variant === 'chess' ? 0.1 : 0
      });
      
      for (let x = 0; x < 8; x++) {
        for (let z = 0; z < 8; z++) {
          const isDark = (x + z) % 2 === 0;
          const square = new THREE.Mesh(squareGeo, isDark ? darkMat : lightMat);
          square.position.set(
            -boardSize / 2 + x * squareSize + squareSize / 2,
            boardThickness + squareThickness / 2,
            -boardSize / 2 + z * squareSize + squareSize / 2
          );
          square.castShadow = true;
          square.receiveShadow = true;
          group.add(square);
        }
      }
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    // ==================== CHESS PIECES ====================
    
    function createChessPawn(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const scale = spec.scale || 1.0;
      const baseRadius = 0.015 * scale;
      const height = 0.05 * scale;
      
      const pawnMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xffffff,
        roughness: 0.4,
        metalness: 0.1
      });
      
      // Base (wider disk)
      const baseGeo = new THREE.CylinderGeometry(baseRadius * 1.2, baseRadius * 1.3, height * 0.15, 24);
      const base = new THREE.Mesh(baseGeo, pawnMat);
      base.position.y = height * 0.075;
      base.castShadow = true;
      base.receiveShadow = true;
      group.add(base);
      
      // Stem (tapered cylinder)
      const stemGeo = new THREE.CylinderGeometry(baseRadius * 0.5, baseRadius * 0.9, height * 0.5, 16);
      const stem = new THREE.Mesh(stemGeo, pawnMat);
      stem.position.y = height * 0.4;
      stem.castShadow = true;
      group.add(stem);
      
      // Collar (wider ring)
      const collarGeo = new THREE.CylinderGeometry(baseRadius * 0.75, baseRadius * 0.75, height * 0.1, 16);
      const collar = new THREE.Mesh(collarGeo, pawnMat);
      collar.position.y = height * 0.65;
      collar.castShadow = true;
      group.add(collar);
      
      // Head (sphere)
      const headGeo = new THREE.SphereGeometry(baseRadius * 0.6, 24, 16);
      const head = new THREE.Mesh(headGeo, pawnMat);
      head.position.y = height * 0.85;
      head.castShadow = true;
      group.add(head);
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    // ==================== SIDE TABLES & LAMPS ====================
    
    function createSideTable(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const tableWidth = 0.45;
      const tableDepth = 0.45;
      const tableHeight = 0.55;
      const topThickness = 0.04;
      
      const woodMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0x8b7355,
        roughness: 0.7,
        metalness: 0.1
      });
      
      // Top surface
      const topGeo = new THREE.BoxGeometry(tableWidth, topThickness, tableDepth);
      const top = new THREE.Mesh(topGeo, woodMat);
      top.position.y = tableHeight;
      top.castShadow = true;
      top.receiveShadow = true;
      group.add(top);
      
      // Legs (4 tapered legs)
      const legGeo = new THREE.CylinderGeometry(0.02, 0.025, tableHeight - topThickness, 12);
      const legPositions = [
        [tableWidth * 0.4, 0, tableDepth * 0.4],
        [-tableWidth * 0.4, 0, tableDepth * 0.4],
        [tableWidth * 0.4, 0, -tableDepth * 0.4],
        [-tableWidth * 0.4, 0, -tableDepth * 0.4]
      ];
      
      legPositions.forEach(([x, y, z]) => {
        const leg = new THREE.Mesh(legGeo, woodMat);
        leg.position.set(x, (tableHeight - topThickness) / 2, z);
        leg.castShadow = true;
        group.add(leg);
      });
      
      // Lower shelf
      const shelfGeo = new THREE.BoxGeometry(tableWidth * 0.9, topThickness * 0.5, tableDepth * 0.9);
      const shelf = new THREE.Mesh(shelfGeo, woodMat);
      shelf.position.y = tableHeight * 0.3;
      shelf.castShadow = true;
      shelf.receiveShadow = true;
      group.add(shelf);
      
      group.position.set(spec.x * ctx.gridSize, 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createFloorLamp(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const lampHeight = 1.6;
      const baseRadius = 0.15;
      
      const metalMat = new THREE.MeshStandardMaterial({
        color: 0x3a3a3a,
        roughness: 0.4,
        metalness: 0.8
      });
      
      // Base (wide, heavy disk)
      const baseGeo = new THREE.CylinderGeometry(baseRadius, baseRadius * 1.1, 0.04, 32);
      const base = new THREE.Mesh(baseGeo, metalMat);
      base.position.y = 0.02;
      base.castShadow = true;
      base.receiveShadow = true;
      group.add(base);
      
      // Pole (thin cylinder)
      const poleGeo = new THREE.CylinderGeometry(0.015, 0.018, lampHeight - 0.3, 16);
      const pole = new THREE.Mesh(poleGeo, metalMat);
      pole.position.y = (lampHeight - 0.3) / 2 + 0.04;
      pole.castShadow = true;
      group.add(pole);
      
      // Shade holder (small sphere joint)
      const jointGeo = new THREE.SphereGeometry(0.025, 16, 16);
      const joint = new THREE.Mesh(jointGeo, metalMat);
      joint.position.y = lampHeight - 0.28;
      joint.castShadow = true;
      group.add(joint);
      
      // Lampshade (cone/frustum) - wider at bottom, narrow at top
      const shadeGeo = new THREE.CylinderGeometry(0.15, 0.25, 0.3, 32);
      const shadeMat = new THREE.MeshStandardMaterial({
        color: spec.shadeColor || 0xe8d4b0,
        roughness: 0.8,
        emissive: spec.lit ? 0xfff4e0 : 0x000000,
        emissiveIntensity: spec.lit ? 0.3 : 0
      });
      const shade = new THREE.Mesh(shadeGeo, shadeMat);
      shade.position.y = lampHeight - 0.15;
      shade.castShadow = true;
      group.add(shade);
      
      // Light bulb (sphere inside shade)
      const bulbGeo = new THREE.SphereGeometry(0.04, 16, 16);
      const bulbMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        emissive: spec.lit ? 0xfff4e0 : 0xffff99,
        emissiveIntensity: spec.lit ? 1.0 : 0.2,
        roughness: 0.3
      });
      const bulb = new THREE.Mesh(bulbGeo, bulbMat);
      bulb.position.y = lampHeight - 0.15;
      group.add(bulb);
      
      // Optional: Add point light if lamp is lit
      if (spec.lit) {
        const light = new THREE.PointLight(0xfff4e0, 0.8, 3);
        light.position.y = lampHeight - 0.15;
        light.castShadow = true;
        group.add(light);
      }
      
      group.position.set(spec.x * ctx.gridSize, 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createAlarmClock(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const width = 0.12;
      const height = 0.1;
      const depth = 0.05;
      
      const clockMat = new THREE.MeshStandardMaterial({
        color: spec.color || 0xff4444,
        roughness: 0.6,
        metalness: 0.3
      });
      
      // Main body (rounded box)
      const bodyGeo = new THREE.BoxGeometry(width, height, depth, 4, 4, 4);
      // Round the corners slightly
      const positions = bodyGeo.attributes.position;
      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const y = positions.getY(i);
        const z = positions.getZ(i);
        const factor = 0.95 + 0.05 * Math.sqrt(x*x/width/width + y*y/height/height + z*z/depth/depth);
        positions.setXYZ(i, x * factor, y * factor, z * factor);
      }
      bodyGeo.computeVertexNormals();
      
      const body = new THREE.Mesh(bodyGeo, clockMat);
      body.position.y = height / 2;
      body.castShadow = true;
      body.receiveShadow = true;
      group.add(body);
      
      // Clock face (screen)
      const faceGeo = new THREE.PlaneGeometry(width * 0.7, height * 0.5);
      const faceMat = new THREE.MeshStandardMaterial({
        color: 0x001100,
        emissive: 0x00ff00,
        emissiveIntensity: 0.6,
        roughness: 0.2
      });
      const face = new THREE.Mesh(faceGeo, faceMat);
      face.position.set(0, height * 0.55, depth / 2 + 0.001);
      group.add(face);
      
      // Bell tops (two small domes)
      const bellGeo = new THREE.SphereGeometry(0.02, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2);
      const bellMat = new THREE.MeshStandardMaterial({
        color: 0xccaa44,
        roughness: 0.3,
        metalness: 0.8
      });
      
      [-width * 0.4, width * 0.4].forEach(x => {
        const bell = new THREE.Mesh(bellGeo, bellMat);
        bell.position.set(x, height + 0.01, 0);
        bell.castShadow = true;
        group.add(bell);
        
        // Bell support (tiny cylinder)
        const supportGeo = new THREE.CylinderGeometry(0.003, 0.003, 0.02, 8);
        const support = new THREE.Mesh(supportGeo, bellMat);
        support.position.set(x, height - 0.01, 0);
        group.add(support);
      });
      
      // Connecting wire between bells
      const wireGeo = new THREE.CylinderGeometry(0.002, 0.002, width * 0.8, 8);
      const wire = new THREE.Mesh(wireGeo, bellMat);
      wire.rotation.z = Math.PI / 2;
      wire.position.y = height + 0.01;
      group.add(wire);
      
      // Feet (small rubber pads)
      const footGeo = new THREE.CylinderGeometry(0.01, 0.01, 0.005, 8);
      const footMat = new THREE.MeshStandardMaterial({
        color: 0x1a1a1a,
        roughness: 0.9
      });
      
      [[-width * 0.35, -depth * 0.35], [width * 0.35, -depth * 0.35],
       [-width * 0.35, depth * 0.35], [width * 0.35, depth * 0.35]].forEach(([x, z]) => {
        const foot = new THREE.Mesh(footGeo, footMat);
        foot.position.set(x, 0.0025, z);
        group.add(foot);
      });
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    // ==================== COMPUTER DESK ====================
    
    function createComputerDesk(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const deskWidth = 1.5;
      const deskDepth = 0.75;
      const deskHeight = 0.75;
      
      const woodMat = new THREE.MeshStandardMaterial({
        color: 0x8b7355,
        roughness: 0.7
      });
      
      // Desk surface
      const surfaceGeo = new THREE.BoxGeometry(deskWidth, 0.05, deskDepth);
      const surface = new THREE.Mesh(surfaceGeo, woodMat);
      surface.position.y = deskHeight;
      surface.castShadow = true;
      surface.receiveShadow = true;
      group.add(surface);
      
      // Legs
      const legGeo = new THREE.CylinderGeometry(0.03, 0.03, deskHeight - 0.05, 12);
      const legMat = new THREE.MeshStandardMaterial({
        color: 0x654321,
        roughness: 0.8
      });
      
      [[0.7, 0.35], [-0.7, 0.35], [0.7, -0.35], [-0.7, -0.35]].forEach(([x, z]) => {
        const leg = new THREE.Mesh(legGeo, legMat);
        leg.position.set(x, (deskHeight - 0.05) / 2, z);
        leg.castShadow = true;
        group.add(leg);
      });
      
      // Monitor
      const monitorGroup = new THREE.Group();
      
      // Screen
      const screenWidth = 0.5;
      const screenHeight = 0.3;
      const screenGeo = new THREE.BoxGeometry(screenWidth, screenHeight, 0.02);
      const screenMat = new THREE.MeshStandardMaterial({
        color: 0x1a1a1a,
        roughness: 0.2,
        metalness: 0.7
      });
      const screen = new THREE.Mesh(screenGeo, screenMat);
      screen.position.set(0, screenHeight / 2 + 0.05, 0);
      screen.castShadow = true;
      monitorGroup.add(screen);
      
      // Monitor bezel
      const bezelGeo = new THREE.BoxGeometry(screenWidth + 0.02, screenHeight + 0.02, 0.015);
      const bezelMat = new THREE.MeshStandardMaterial({
        color: 0x2a2a2a,
        roughness: 0.6
      });
      const bezel = new THREE.Mesh(bezelGeo, bezelMat);
      bezel.position.set(0, screenHeight / 2 + 0.05, -0.01);
      bezel.castShadow = true;
      monitorGroup.add(bezel);
      
      // Monitor stand
      const standGeo = new THREE.CylinderGeometry(0.03, 0.04, 0.08, 12);
      const standMat = new THREE.MeshStandardMaterial({
        color: 0x3a3a3a,
        roughness: 0.7
      });
      const stand = new THREE.Mesh(standGeo, standMat);
      stand.position.y = 0.04;
      stand.castShadow = true;
      monitorGroup.add(stand);
      
      monitorGroup.position.set(0, deskHeight + 0.025, -deskDepth / 4);
      group.add(monitorGroup);
      
      // Keyboard
      const keyboardGroup = new THREE.Group();
      
      const keyboardGeo = new THREE.BoxGeometry(0.45, 0.02, 0.15);
      const keyboardMat = new THREE.MeshStandardMaterial({
        color: 0x2a2a2a,
        roughness: 0.7
      });
      const keyboard = new THREE.Mesh(keyboardGeo, keyboardMat);
      keyboard.position.y = 0.01;
      keyboard.castShadow = true;
      keyboard.receiveShadow = true;
      keyboardGroup.add(keyboard);
      
      // Keys (simplified grid)
      const keySize = 0.012;
      const keyGeo = new THREE.BoxGeometry(keySize, 0.005, keySize);
      const keyMat = new THREE.MeshStandardMaterial({
        color: 0x4a4a4a,
        roughness: 0.5
      });
      
      for (let row = 0; row < 4; row++) {
        for (let col = 0; col < 10; col++) {
          const key = new THREE.Mesh(keyGeo, keyMat);
          key.position.set(
            -0.2 + col * 0.04 + 0.02,
            0.0125,
            -0.06 + row * 0.03 + 0.015
          );
          key.castShadow = true;
          keyboardGroup.add(key);
        }
      }
      
      keyboardGroup.position.set(0, deskHeight + 0.025, deskDepth / 4);
      group.add(keyboardGroup);
      
      group.position.set(spec.x * ctx.gridSize, 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    // ==================== CLOSET & DOORS ====================
    
    function createCloset(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const closetWidth = spec.width || 1.5;
      const closetDepth = 0.6;
      const closetHeight = 2.3;
      
      // Back and side walls
      const wallMat = new THREE.MeshStandardMaterial({
        color: 0xf0e6d2,
        roughness: 0.9
      });
      
      // Back wall
      const backWallGeo = new THREE.BoxGeometry(closetWidth, closetHeight, 0.1);
      const backWall = new THREE.Mesh(backWallGeo, wallMat);
      backWall.position.set(0, closetHeight / 2, -closetDepth / 2);
      backWall.castShadow = true;
      backWall.receiveShadow = true;
      group.add(backWall);
      
      // Side walls
      const sideWallGeo = new THREE.BoxGeometry(0.1, closetHeight, closetDepth);
      const leftWall = new THREE.Mesh(sideWallGeo, wallMat);
      leftWall.position.set(-closetWidth / 2, closetHeight / 2, 0);
      leftWall.castShadow = true;
      group.add(leftWall);
      
      const rightWall = new THREE.Mesh(sideWallGeo, wallMat);
      rightWall.position.set(closetWidth / 2, closetHeight / 2, 0);
      rightWall.castShadow = true;
      group.add(rightWall);
      
      // Door (hinged)
      const doorGroup = new THREE.Group();
      const doorMat = new THREE.MeshStandardMaterial({
        color: 0x8b7355,
        roughness: 0.8
      });
      
      const doorGeo = new THREE.BoxGeometry(closetWidth * 0.95, 2.0, 0.05);
      const door = new THREE.Mesh(doorGeo, doorMat);
      door.position.x = closetWidth * 0.475;
      door.position.y = 1.0;
      door.castShadow = true;
      doorGroup.add(door);
      
      // Door handle
      const handleGeo = new THREE.CylinderGeometry(0.015, 0.015, 0.08, 8);
      const handleMat = new THREE.MeshStandardMaterial({
        color: 0xc0c0c0,
        roughness: 0.3,
        metalness: 0.8
      });
      const handle = new THREE.Mesh(handleGeo, handleMat);
      handle.rotation.z = Math.PI / 2;
      handle.position.set(closetWidth * 0.4, 1.0, 0.03);
      doorGroup.add(handle);
      
      doorGroup.position.set(-closetWidth / 2, 0, closetDepth / 2);
      doorGroup.userData.isClosetDoor = true;
      doorGroup.userData.isOpen = false;
      group.add(doorGroup);
      
      // Register as interactive
      ctx.targetInteractive.push(doorGroup);
      
      // === HANGER BAR ===
      const barMat = new THREE.MeshStandardMaterial({
        color: 0xc0c0c0,
        roughness: 0.4,
        metalness: 0.8
      });
      
      const barRadius = 0.015;
      const barLength = closetWidth - 0.2;
      const barHeight = closetHeight * 0.75;
      
      // Horizontal bar
      const barGeo = new THREE.CylinderGeometry(barRadius, barRadius, barLength, 16);
      const bar = new THREE.Mesh(barGeo, barMat);
      bar.rotation.z = Math.PI / 2;
      bar.position.set(0, barHeight, -closetDepth * 0.25);
      bar.castShadow = true;
      group.add(bar);
      
      // End supports
      const supportGeo = new THREE.CylinderGeometry(barRadius * 1.5, barRadius * 1.5, 0.05, 16);
      const leftSupport = new THREE.Mesh(supportGeo, barMat);
      leftSupport.rotation.z = Math.PI / 2;
      leftSupport.position.set(-barLength / 2, barHeight, -closetDepth * 0.25);
      leftSupport.castShadow = true;
      group.add(leftSupport);
      
      const rightSupport = leftSupport.clone();
      rightSupport.position.set(barLength / 2, barHeight, -closetDepth * 0.25);
      group.add(rightSupport);
      
      // === HANGERS ===
      const numHangers = Math.floor(barLength / 0.15) || 3;
      const hangerSpacing = barLength / (numHangers + 1);
      
      for (let i = 0; i < numHangers; i++) {
        const hangerGroup = new THREE.Group();
        
        // Hook (curved)
        const hookCurve = new THREE.QuadraticBezierCurve3(
          new THREE.Vector3(0, 0.05, 0),
          new THREE.Vector3(0, 0.08, 0),
          new THREE.Vector3(0, 0.08, -0.02)
        );
        const hookGeo = new THREE.TubeGeometry(hookCurve, 8, 0.003, 8, false);
        const hookMat = new THREE.MeshStandardMaterial({
          color: 0xa0a0a0,
          roughness: 0.5,
          metalness: 0.7
        });
        const hook = new THREE.Mesh(hookGeo, hookMat);
        hook.castShadow = true;
        hangerGroup.add(hook);
        
        // Shoulder bars
        const shoulderGeo = new THREE.CylinderGeometry(0.002, 0.002, 0.12, 8);
        const leftShoulder = new THREE.Mesh(shoulderGeo, hookMat);
        leftShoulder.rotation.z = Math.PI / 6;
        leftShoulder.position.set(-0.05, 0.03, -0.02);
        leftShoulder.castShadow = true;
        hangerGroup.add(leftShoulder);
        
        const rightShoulder = new THREE.Mesh(shoulderGeo, hookMat);
        rightShoulder.rotation.z = -Math.PI / 6;
        rightShoulder.position.set(0.05, 0.03, -0.02);
        rightShoulder.castShadow = true;
        hangerGroup.add(rightShoulder);
        
        // Bottom bar
        const bottomGeo = new THREE.CylinderGeometry(0.002, 0.002, 0.1, 8);
        const bottom = new THREE.Mesh(bottomGeo, hookMat);
        bottom.rotation.z = Math.PI / 2;
        bottom.position.set(0, -0.02, -0.02);
        bottom.castShadow = true;
        hangerGroup.add(bottom);
        
        // Position hanger on bar
        hangerGroup.position.set(
          -barLength / 2 + (i + 1) * hangerSpacing,
          barHeight,
          -closetDepth * 0.25
        );
        hangerGroup.rotation.y = (Math.random() - 0.5) * 0.2; // Slight random rotation
        
        group.add(hangerGroup);
      }
      
      group.position.set(spec.x * ctx.gridSize, 0, spec.z * ctx.gridSize);
      // Fix: Closet back is at -Z, so add 180 degrees to make it face into room correctly
      group.rotation.y = (spec.rotation || 0) + Math.PI;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createEntranceDoor(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      const doorWidth = 1.0;
      const doorHeight = 2.0;
      const crackHeight = 0.02; // Small crack at bottom
      
      // Door frame
      const frameMat = new THREE.MeshStandardMaterial({
        color: 0x8b7355,
        roughness: 0.8
      });
      
      // Door panel (hinged group)
      const doorGroup = new THREE.Group();
      const doorGeo = new THREE.BoxGeometry(doorWidth, doorHeight - crackHeight, 0.05);
      const door = new THREE.Mesh(doorGeo, frameMat);
      door.position.x = doorWidth / 2;
      door.position.y = (doorHeight - crackHeight) / 2 + crackHeight;
      door.castShadow = true;
      doorGroup.add(door);
      
      // Door handle
      const handleGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.1, 8);
      const handleMat = new THREE.MeshStandardMaterial({
        color: 0xc0c0c0,
        roughness: 0.3,
        metalness: 0.8
      });
      const handle = new THREE.Mesh(handleGeo, handleMat);
      handle.rotation.z = Math.PI / 2;
      handle.position.set(doorWidth * 0.85, 1.0, 0.03);
      doorGroup.add(handle);
      
      doorGroup.userData.isEntranceDoor = true;
      doorGroup.userData.isOpen = false;
      group.add(doorGroup);
      
      // Register as interactive
      ctx.targetInteractive.push(doorGroup);
      
      // Door frame sides and top
      const frameThick = 0.08;
      const leftFrameGeo = new THREE.BoxGeometry(frameThick, doorHeight, frameThick);
      const leftFrame = new THREE.Mesh(leftFrameGeo, frameMat);
      leftFrame.position.set(-frameThick / 2, doorHeight / 2, 0);
      leftFrame.castShadow = true;
      group.add(leftFrame);
      
      const rightFrame = new THREE.Mesh(leftFrameGeo, frameMat);
      rightFrame.position.set(doorWidth + frameThick / 2, doorHeight / 2, 0);
      rightFrame.castShadow = true;
      group.add(rightFrame);
      
      const topFrameGeo = new THREE.BoxGeometry(doorWidth + frameThick * 2, frameThick, frameThick);
      const topFrame = new THREE.Mesh(topFrameGeo, frameMat);
      topFrame.position.set(doorWidth / 2, doorHeight, 0);
      topFrame.castShadow = true;
      group.add(topFrame);
      
      group.position.set(spec.x * ctx.gridSize, 0, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    // ==================== ART & DECORATIONS ====================
    
    function generateAbstractArt() {
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 256;
      const ctx = canvas.getContext('2d');
      
      // Random background
      const hue = Math.random() * 360;
      ctx.fillStyle = `hsl(${hue}, 70%, 85%)`;
      ctx.fillRect(0, 0, 256, 256);
      
      // Random shapes
      const shapeCount = 5 + Math.floor(Math.random() * 10);
      for (let i = 0; i < shapeCount; i++) {
        ctx.fillStyle = `hsla(${Math.random() * 360}, 70%, 50%, 0.7)`;
        const shapeType = Math.floor(Math.random() * 3);
        
        if (shapeType === 0) {
          // Circle
          ctx.beginPath();
          ctx.arc(
            Math.random() * 256,
            Math.random() * 256,
            20 + Math.random() * 60,
            0,
            Math.PI * 2
          );
          ctx.fill();
        } else if (shapeType === 1) {
          // Rectangle
          ctx.fillRect(
            Math.random() * 256,
            Math.random() * 256,
            30 + Math.random() * 80,
            30 + Math.random() * 80
          );
        } else {
          // Triangle
          ctx.beginPath();
          ctx.moveTo(Math.random() * 256, Math.random() * 256);
          ctx.lineTo(Math.random() * 256, Math.random() * 256);
          ctx.lineTo(Math.random() * 256, Math.random() * 256);
          ctx.closePath();
          ctx.fill();
        }
      }
      
      // Random lines/strokes
      ctx.strokeStyle = `hsla(${(hue + 180) % 360}, 60%, 30%, 0.5)`;
      ctx.lineWidth = 2 + Math.random() * 4;
      for (let i = 0; i < 3; i++) {
        ctx.beginPath();
        ctx.moveTo(Math.random() * 256, Math.random() * 256);
        ctx.lineTo(Math.random() * 256, Math.random() * 256);
        ctx.stroke();
      }
      
      return new THREE.CanvasTexture(canvas);
    }
    
    function createArtFrame(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      // Size variations: small, medium, large
      const size = spec.size || 'medium';
      const sizes = {
        small: { width: 0.3, height: 0.4 },
        medium: { width: 0.5, height: 0.6 },
        large: { width: 0.8, height: 1.0 }
      };
      
      const frameWidth = sizes[size].width;
      const frameHeight = sizes[size].height;
      const frameDepth = 0.03;
      
      // Frame border
      const frameMat = new THREE.MeshStandardMaterial({
        color: spec.frameColor || 0x3d2817,
        roughness: 0.7
      });
      const frameGeo = new THREE.BoxGeometry(frameWidth, frameHeight, frameDepth);
      const frame = new THREE.Mesh(frameGeo, frameMat);
      frame.castShadow = true;
      group.add(frame);
      
      // Art canvas (with generated abstract art)
      const artTexture = generateAbstractArt();
      const artMat = new THREE.MeshStandardMaterial({ map: artTexture });
      const artGeo = new THREE.PlaneGeometry(frameWidth * 0.85, frameHeight * 0.85);
      const art = new THREE.Mesh(artGeo, artMat);
      art.position.z = frameDepth / 2 + 0.001;
      group.add(art);
      
      const defaultY = size === 'large' ? 1.6 : size === 'medium' ? 1.5 : 1.4;
      group.position.set(spec.x * ctx.gridSize, spec.y || defaultY, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      // If wall-mounted, rotate to face outward
      if (spec.wallMount) {
        group.rotation.y = spec.rotation || 0;
      }
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    function createWallClock(spec) {
      const group = new THREE.Group();
      const ctx = getAssetContext(spec);
      
      // Clock body (cylinder)
      const bodyGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.05, 32);
      const bodyMat = new THREE.MeshStandardMaterial({
        color: 0x2a2a2a,
        roughness: 0.5,
        metalness: 0.3
      });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.rotation.x = Math.PI / 2;
      body.castShadow = true;
      group.add(body);
      
      // Clock face
      const faceGeo = new THREE.CircleGeometry(0.14, 32);
      const faceMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.8
      });
      const face = new THREE.Mesh(faceGeo, faceMat);
      face.position.z = 0.026;
      group.add(face);
      
      // Hour markers (small rectangles)
      const markerMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
      for (let i = 0; i < 12; i++) {
        const angle = (i / 12) * Math.PI * 2 - Math.PI / 2;
        const markerGeo = new THREE.BoxGeometry(0.01, 0.03, 0.01);
        const marker = new THREE.Mesh(markerGeo, markerMat);
        marker.position.set(
          Math.cos(angle) * 0.11,
          Math.sin(angle) * 0.11,
          0.03
        );
        marker.rotation.z = angle + Math.PI / 2;
        group.add(marker);
      }
      
      // Hour hand
      const hourGeo = new THREE.BoxGeometry(0.05, 0.01, 0.005);
      const hour = new THREE.Mesh(hourGeo, markerMat);
      hour.position.set(0.025, 0, 0.032);
      group.add(hour);
      
      // Minute hand
      const minuteGeo = new THREE.BoxGeometry(0.08, 0.008, 0.005);
      const minute = new THREE.Mesh(minuteGeo, markerMat);
      minute.position.set(0.04, 0, 0.034);
      minute.rotation.z = Math.PI / 4;
      group.add(minute);
      
      group.position.set(spec.x * ctx.gridSize, spec.y || 1.8, spec.z * ctx.gridSize);
      group.rotation.y = spec.rotation || 0;
      
      ctx.targetScene.add(group);
      
      ctx.targetObjects.push(group);
      
      return group;
    }
    
    // ==================== INTERACTION SYSTEM ====================
    
    function onMouseClick(event) {
      if (!controls.isLocked) return;
      
      // Center of screen when pointer locked
      mouse.x = 0;
      mouse.y = 0;
      
      raycaster.setFromCamera(mouse, camera);
      
      // Check interactive objects (city mode)
      const intersects = raycaster.intersectObjects(interactiveObjects, true);
      
      if (intersects.length > 0) {
        let object = intersects[0].object;
        
        // Find parent group with userData
        while (object && !object.userData.isLid && !object.userData.isClosetDoor && !object.userData.isEntranceDoor) {
          object = object.parent;
        }
        
        if (object) {
          if (object.userData.isLid) {
            toggleToiletLid(object);
          } else if (object.userData.isClosetDoor) {
            toggleDoor(object, 90);
          } else if (object.userData.isEntranceDoor) {
            toggleDoor(object, 90);
          }
        }
      }
      
      // Check interiors interactive objects if in interiors mode
      if (interiorsMode) {
        const interiorIntersects = raycaster.intersectObjects(interiorInteractiveObjects, true);
        
        if (interiorIntersects.length > 0) {
          let object = interiorIntersects[0].object;
          
          // Find parent group with userData
          while (object && !object.userData.isLid && !object.userData.isClosetDoor && !object.userData.isEntranceDoor && !object.userData.isFlushHandle && !object.userData.isFridgeDoor && !object.userData.isMicrowaveDoor) {
            object = object.parent;
          }
          
          if (object) {
            if (object.userData.isLid) {
              toggleToiletLid(object);
            } else if (object.userData.isClosetDoor) {
              toggleDoor(object, 90);
            } else if (object.userData.isEntranceDoor) {
              toggleDoor(object, 90);
            } else if (object.userData.isFlushHandle) {
              toggleFlushHandle(object);
            } else if (object.userData.isFridgeDoor) {
              toggleFridgeDoor(object);
            } else if (object.userData.isMicrowaveDoor) {
              toggleMicrowaveDoor(object);
            }
          }
        }
      }
    }
    
    // ==================== ASSET LIBRARY & SPAWNING ====================
    
    const ASSET_LIBRARY = {
      furniture: {
        name: 'ü™ë Furniture',
        items: [
          { name: 'Desk (Square)', type: 'desk', shape: 'square' },
          { name: 'Desk (Rectangle)', type: 'desk', shape: 'rectangle' },
          { name: 'Desk (Circle)', type: 'desk', shape: 'circle' },
          { name: 'Bed', type: 'bed' },
          { name: 'Couch', type: 'couch' },
          { name: 'Coffee Table (Rectangle)', type: 'coffeetable', shape: 'rectangle' },
          { name: 'Coffee Table (Square)', type: 'coffeetable', shape: 'square' },
          { name: 'Coffee Table (Circle)', type: 'coffeetable', shape: 'circle' },
          { name: 'Dining Table', type: 'diningtable' },
          { name: 'Dining Table (Large)', type: 'diningtable', width: 2.0, depth: 1.2 },
          { name: 'Computer Desk', type: 'computerdesk' },
          { name: 'Side Table', type: 'sidetable' },
          { name: 'Shoe Rack', type: 'shoerack' },
          { name: 'Umbrella Stand', type: 'umbrellastand' },
        ]
      },
      entertainment: {
        name: 'üì∫ Entertainment',
        items: [
          { name: 'TV (Flat Screen)', type: 'tv', style: 'flat' },
          { name: 'TV (Tube/CRT)', type: 'tv', style: 'tube' },
          { name: 'TV Stand (Modern)', type: 'tvstand', style: 'modern' },
          { name: 'TV Stand (Classic)', type: 'tvstand', style: 'classic' },
          { name: 'TV Stand (Minimal)', type: 'tvstand', style: 'minimal' },
          { name: 'Game Console (Modern)', type: 'gameconsole', consoleType: 'modern', color: 0x1a1a1a },
          { name: 'Game Console (White)', type: 'gameconsole', consoleType: 'modern', color: 0xf0f0f0 },
          { name: 'Game Console (Classic)', type: 'gameconsole', consoleType: 'classic' },
          { name: 'DVD (Silver)', type: 'dvd', color: 0xccccff },
          { name: 'DVD (Gold)', type: 'dvd', color: 0xffd700 },
          { name: 'DVD Case (Black)', type: 'dvdcase', color: 0x000000, coverColor: 0x4466ff },
          { name: 'DVD Case (Blue)', type: 'dvdcase', color: 0x0a0a3a, coverColor: 0xff6644 },
          { name: 'DVD Case (Green)', type: 'dvdcase', color: 0x0a2a0a, coverColor: 0xffdd44 },
          { name: 'Remote (Black)', type: 'remote', color: 0x2a2a2a },
          { name: 'Remote (Silver)', type: 'remote', color: 0x8a8a8a },
        ]
      },
      lighting: {
        name: 'üí° Lighting',
        items: [
          // Ceiling Fixtures
          { name: 'Ceiling Light (Modern Pendant)', type: 'ceilinglight', style: 'modern' },
          { name: 'Ceiling Light (Strip)', type: 'ceilinglight', style: 'strip' },
          { name: 'Ceiling Light (Classic Disc)', type: 'ceilinglight', style: 'classic' },
          { name: 'Chandelier (Crystal)', type: 'chandelier', style: 'crystal' },
          { name: 'Chandelier (Modern)', type: 'chandelier', style: 'modern' },
          { name: 'Chandelier (Candle)', type: 'chandelier', style: 'candle' },
          { name: 'Pendant Light (Globe)', type: 'pendantlight', style: 'globe' },
          { name: 'Pendant Light (Industrial)', type: 'pendantlight', style: 'industrial' },
          { name: 'Pendant Light (Drum)', type: 'pendantlight', style: 'drum' },
          
          // Floor & Table Lamps
          { name: 'Floor Lamp (Arc)', type: 'floorlamp', style: 'arc' },
          { name: 'Floor Lamp (Tripod)', type: 'floorlamp', style: 'tripod' },
          { name: 'Floor Lamp (Torchiere)', type: 'floorlamp', style: 'torchiere' },
          { name: 'Desk Lamp (Luxo/Articulating)', type: 'desklamp' },
          { name: 'Table Lamp (Traditional)', type: 'tablelamp', style: 'traditional' },
          { name: 'Table Lamp (Modern)', type: 'tablelamp', style: 'modern' },
          
          // Wall Fixtures
          { name: 'Wall Sconce (Modern)', type: 'wallsconce', style: 'modern' },
          { name: 'Wall Sconce (Traditional)', type: 'wallsconce', style: 'traditional' },
          { name: 'Wall Sconce (Industrial)', type: 'wallsconce', style: 'industrial' },
        ]
      },
      kitchen: {
        name: 'üçΩÔ∏è Kitchen & Dining',
        items: [
          // Appliances
          { name: 'Kitchen Counter', type: 'counter' },
          { name: 'Refrigerator (White)', type: 'refrigerator', color: 0xf0f0f0 },
          { name: 'Refrigerator (Silver)', type: 'refrigerator', color: 0xc0c0c0 },
          
          // Dinnerware - Plates
          { name: 'Dinner Plate (White)', type: 'plate', variant: 'dinner', color: 0xffffff },
          { name: 'Dinner Plate (Beige)', type: 'plate', variant: 'dinner', color: 0xf5f5dc },
          { name: 'Salad Plate (White)', type: 'plate', variant: 'salad', color: 0xffffff },
          { name: 'Salad Plate (Blue)', type: 'plate', variant: 'salad', color: 0x4a90e2 },
          
          // Dinnerware - Bowls
          { name: 'Soup Bowl (White)', type: 'bowl', variant: 'soup', color: 0xffffff },
          { name: 'Soup Bowl (Cream)', type: 'bowl', variant: 'soup', color: 0xf5f5dc },
          { name: 'Cereal Bowl (White)', type: 'bowl', variant: 'cereal', color: 0xffffff },
          { name: 'Cereal Bowl (Blue)', type: 'bowl', variant: 'cereal', color: 0x4a90e2 },
          { name: 'Serving Bowl (Large)', type: 'bowl', variant: 'serving', color: 0xffffff },
          
          // Cutlery - Forks
          { name: 'Dinner Fork (Silver)', type: 'fork', variant: 'dinner', finish: 'silver' },
          { name: 'Dinner Fork (Gold)', type: 'fork', variant: 'dinner', finish: 'gold' },
          { name: 'Salad Fork (Silver)', type: 'fork', variant: 'salad', finish: 'silver' },
          
          // Cutlery - Knives
          { name: 'Dinner Knife (Silver)', type: 'knife', variant: 'dinner', finish: 'silver' },
          { name: 'Dinner Knife (Gold)', type: 'knife', variant: 'dinner', finish: 'gold' },
          { name: 'Steak Knife (Silver)', type: 'knife', variant: 'steak', finish: 'silver' },
          { name: 'Butter Knife (Silver)', type: 'knife', variant: 'butter', finish: 'silver' },
          
          // Cutlery - Spoons
          { name: 'Table Spoon (Silver)', type: 'spoon', variant: 'table', finish: 'silver' },
          { name: 'Table Spoon (Gold)', type: 'spoon', variant: 'table', finish: 'gold' },
          { name: 'Tea Spoon (Silver)', type: 'spoon', variant: 'tea', finish: 'silver' },
          { name: 'Soup Spoon (Silver)', type: 'spoon', variant: 'soup', finish: 'silver' },
          
          // Glassware
          { name: 'Water Glass', type: 'glass', variant: 'water' },
          { name: 'Wine Glass', type: 'glass', variant: 'wine' },
          { name: 'Coffee Mug', type: 'mug', color: 0xffffff },
          { name: 'Coffee Mug (Black)', type: 'mug', color: 0x2a2a2a },
          
          // Food Storage
          { name: 'Milk Carton', type: 'milkcarton' },
          { name: 'Orange Juice', type: 'orangejuice' },
          { name: 'Cheese', type: 'cheese' },
          { name: 'Eggs', type: 'eggs' },
        ]
      },
      food: {
        name: 'üçé Food & Fruit',
        items: [
          { name: 'Apple (Red)', type: 'apple', color: 0xff3333 },
          { name: 'Apple (Green)', type: 'apple', color: 0x66ff66 },
          { name: 'Pear', type: 'pear' },
          { name: 'Banana', type: 'banana' },
          { name: 'Grapes (Purple)', type: 'grapes', color: 0x6a0dad },
          { name: 'Grapes (Green)', type: 'grapes', color: 0x90ee90 },
          { name: 'Fruit Bowl', type: 'fruitbowl' },
        ]
      },
      decor: {
        name: 'üé® Decor & Art',
        items: [
          { name: 'Potted Plant', type: 'plant' },
          { name: 'Art Frame (Small)', type: 'artframe', size: 'small' },
          { name: 'Art Frame (Medium)', type: 'artframe', size: 'medium' },
          { name: 'Art Frame (Large)', type: 'artframe', size: 'large' },
          { name: 'Wall Clock', type: 'clock' },
          { name: 'Alarm Clock', type: 'alarmclock' },
          { name: 'Shelf (3 shelves)', type: 'shelf', shelves: 3 },
          { name: 'Shelf (4 shelves)', type: 'shelf', shelves: 4 },
          { name: 'Rug (Brown)', type: 'rug', color: 0x8b4513 },
          { name: 'Rug (Red)', type: 'rug', color: 0xcc3333 },
          { name: 'Rug (Blue)', type: 'rug', color: 0x4444aa },
        ]
      },
      bathroom: {
        name: 'üöΩ Bathroom',
        items: [
          { name: 'Toilet', type: 'toilet' },
          { name: 'Shower', type: 'shower' },
        ]
      },
      games: {
        name: 'üéÆ Games & Toys',
        items: [
          { name: 'Playing Card (Red)', type: 'playingcard', suit: 'red' },
          { name: 'Playing Card (Blue)', type: 'playingcard', suit: 'blue' },
          { name: 'Dice', type: 'dice' },
          { name: 'Poker Chip (Red)', type: 'pokerchip', color: 0xff3333 },
          { name: 'Poker Chip (Blue)', type: 'pokerchip', color: 0x3333ff },
          { name: 'Poker Chip (Black)', type: 'pokerchip', color: 0x1a1a1a },
          { name: 'Poker Chip (Green)', type: 'pokerchip', color: 0x33ff33 },
          { name: 'Checkers Board', type: 'gameboard', variant: 'checkers' },
          { name: 'Chess Board', type: 'gameboard', variant: 'chess' },
          { name: 'Chess Pawn (White)', type: 'chesspawn', color: 0xffffff },
          { name: 'Chess Pawn (Black)', type: 'chesspawn', color: 0x1a1a1a },
          { name: 'Jenga Tower (Clean)', type: 'jengatower', config: 'clean' },
          { name: 'Jenga Tower (Random)', type: 'jengatower', config: 'random' },
          { name: 'Baseball', type: 'baseball' },
          { name: 'Basketball', type: 'basketball' },
          { name: 'Pixar Ball', type: 'pixarball' },
        ]
      },
      cleaning: {
        name: 'üßπ Cleaning Supplies',
        items: [
          { name: 'Broom', type: 'broom' },
          { name: 'Dustpan', type: 'dustpan' },
          { name: 'Vacuum', type: 'vacuum' },
          { name: 'Handheld Vacuum', type: 'handheldvacuum' },
          { name: 'Bucket', type: 'bucket' },
          { name: 'Sponge', type: 'sponge' },
          { name: 'Rag', type: 'rag' },
          { name: 'Paper Towel Roll', type: 'papertowelroll' },
          { name: 'Toilet Paper Roll', type: 'toiletpaperroll' },
        ]
      },
      office: {
        name: 'üíº Office',
        items: [
          { name: 'Desk Lamp (Luxo)', type: 'desklamp' }
        ]
      }
    };
    
    let assetLibraryVisible = false;
    let expandedCategories = {}; // Track which categories are expanded
    
    function setupAssetLibrary() {
      const libraryDiv = document.createElement('div');
      libraryDiv.id = 'asset-library';
      libraryDiv.style.cssText = `
        position: fixed;
        top: 20px;
        right: 380px;
        background: rgba(15,20,28,.96);
        backdrop-filter: blur(16px);
        border: 1px solid rgba(74,124,255,.3);
        border-radius: 12px;
        padding: 18px;
        color: #e8edf7;
        font-size: 13px;
        max-width: 320px;
        max-height: 600px;
        overflow-y: auto;
        display: none;
        z-index: 100;
      `;
      
      libraryDiv.innerHTML = `
        <div style="font-size: 16px; font-weight: 700; color: #6a9cff; margin-bottom: 14px; text-transform: uppercase; letter-spacing: 1px; border-bottom: 2px solid rgba(74,124,255,.2); padding-bottom: 8px;">
          Asset Library (Interior Mode)
        </div>
        <div style="font-size: 11px; color: #8ab4ff; margin-bottom: 12px;">
          Press <kbd style="background: #2a3440; padding: 2px 6px; border-radius: 3px; font-size: 10px;">ESC</kbd> or <kbd style="background: #2a3440; padding: 2px 6px; border-radius: 3px; font-size: 10px;">B</kbd> to close ‚Ä¢ Assets spawn in front of camera
        </div>
        <div id="asset-list"></div>
      `;
      
      document.body.appendChild(libraryDiv);
      
      const assetList = document.getElementById('asset-list');
      
      // Build foldered UI
      Object.keys(ASSET_LIBRARY).forEach((categoryKey) => {
        const category = ASSET_LIBRARY[categoryKey];
        
        // Create category header
        const categoryHeader = document.createElement('div');
        categoryHeader.style.cssText = `
          padding: 10px 12px;
          background: linear-gradient(135deg, #3a5f9f 0%, #2a4a7f 100%);
          border: 1px solid rgba(106,156,255,.4);
          border-radius: 8px;
          margin: 8px 0;
          cursor: pointer;
          font-weight: 700;
          font-size: 13px;
          color: #e8edf7;
          display: flex;
          align-items: center;
          justify-content: space-between;
          transition: all 0.2s;
        `;
        
        categoryHeader.innerHTML = `
          <span>${category.name}</span>
          <span id="arrow-${categoryKey}" style="transition: transform 0.3s;">‚ñº</span>
        `;
        
        // Create items container
        const itemsContainer = document.createElement('div');
        itemsContainer.id = `items-${categoryKey}`;
        itemsContainer.style.cssText = `
          max-height: 0;
          overflow: hidden;
          transition: max-height 0.3s ease;
        `;
        
        // Add items to container
        category.items.forEach((asset) => {
          const assetButton = document.createElement('button');
          assetButton.textContent = asset.name;
          assetButton.style.cssText = `
            width: 100%;
            background: linear-gradient(180deg, #4a7cff 0%, #3a6cef 100%);
            border: 1px solid rgba(106,156,255,.6);
            border-radius: 6px;
            padding: 8px 12px;
            color: white;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            margin: 4px 0;
            transition: all 0.2s;
            text-align: left;
          `;
          
          assetButton.addEventListener('mouseenter', () => {
            assetButton.style.background = 'linear-gradient(180deg, #5a8cff 0%, #4a7cff 100%)';
            assetButton.style.transform = 'translateY(-1px)';
            assetButton.style.boxShadow = '0 4px 12px rgba(74,124,255,.4)';
          });
          
          assetButton.addEventListener('mouseleave', () => {
            assetButton.style.background = 'linear-gradient(180deg, #4a7cff 0%, #3a6cef 100%)';
            assetButton.style.transform = 'translateY(0)';
            assetButton.style.boxShadow = 'none';
          });
          
          assetButton.addEventListener('click', (e) => {
            e.stopPropagation();
            spawnAsset(asset);
          });
          
          itemsContainer.appendChild(assetButton);
        });
        
        // Toggle category expand/collapse
        categoryHeader.addEventListener('click', () => {
          const arrow = document.getElementById(`arrow-${categoryKey}`);
          const isExpanded = expandedCategories[categoryKey];
          
          if (isExpanded) {
            itemsContainer.style.maxHeight = '0';
            arrow.style.transform = 'rotate(0deg)';
            expandedCategories[categoryKey] = false;
          } else {
            itemsContainer.style.maxHeight = `${itemsContainer.scrollHeight + 20}px`;
            arrow.style.transform = 'rotate(180deg)';
            expandedCategories[categoryKey] = true;
          }
        });
        
        categoryHeader.addEventListener('mouseenter', () => {
          categoryHeader.style.background = 'linear-gradient(135deg, #4a6faf 0%, #3a5a8f 100%)';
          categoryHeader.style.transform = 'translateY(-1px)';
        });
        
        categoryHeader.addEventListener('mouseleave', () => {
          categoryHeader.style.background = 'linear-gradient(135deg, #3a5f9f 0%, #2a4a7f 100%)';
          categoryHeader.style.transform = 'translateY(0)';
        });
        
        assetList.appendChild(categoryHeader);
        assetList.appendChild(itemsContainer);
      });
      
      // Toggle with 'B' key or 'ESC' key  
      window.addEventListener('keydown', (e) => {
        if (e.code === 'KeyB' && interiorsMode && !isAssetMenuOpen()) {
          assetLibraryVisible = !assetLibraryVisible;
          libraryDiv.style.display = assetLibraryVisible ? 'block' : 'none';
          console.log(`üì¶ Asset Library ${assetLibraryVisible ? 'opened' : 'closed'}`);
        }
        if (e.code === 'Escape' && assetLibraryVisible) {
          assetLibraryVisible = false;
          libraryDiv.style.display = 'none';
        }
      }, { capture: true }); // Use capture to ensure this runs first
    }
    
    function spawnAsset(assetDef) {
      // Spawn in front of camera
      const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
      const spawnPos = camera.position.clone().addScaledVector(forward, 2);
      
      // Snap to grid
      const gridX = Math.round(spawnPos.x / GRID_SIZE);
      const gridZ = Math.round(spawnPos.z / GRID_SIZE);
      
      const spec = {
        type: assetDef.type,
        x: gridX,
        z: gridZ,
        rotation: 0,
        shape: assetDef.shape,
        color: assetDef.color,
        y: 0
      };
      
      // Pass additional properties from assetDef
      if (assetDef.suit) spec.suit = assetDef.suit;
      if (assetDef.variant) spec.variant = assetDef.variant;
      if (assetDef.scale) spec.scale = assetDef.scale;
      if (assetDef.lit !== undefined) spec.lit = assetDef.lit;
      if (assetDef.shadeColor) spec.shadeColor = assetDef.shadeColor;
      if (assetDef.size) spec.size = assetDef.size;
      if (assetDef.style) spec.style = assetDef.style;
      if (assetDef.consoleType) spec.consoleType = assetDef.consoleType;
      if (assetDef.coverColor) spec.coverColor = assetDef.coverColor;
      if (assetDef.config) spec.config = assetDef.config;
      if (assetDef.shelves) spec.shelves = assetDef.shelves;
      if (assetDef.width) spec.width = assetDef.width;
      if (assetDef.depth) spec.depth = assetDef.depth;
      if (assetDef.finish) spec.finish = assetDef.finish;
      
      // Smart height placement for different surface types
      // Counter height items (kitchen counter ~0.9m)
      if (['plate', 'bowl', 'fork', 'knife', 'spoon', 'glass', 'mug', 'apple', 'pear', 'banana', 'grapes', 'fruitbowl'].includes(spec.type)) {
        spec.y = 0.91; // Place on counter height
      }
      
      // Coffee table height items (~0.42m)
      if (['plate', 'bowl', 'fork', 'knife', 'spoon', 'glass', 'mug', 'playingcard', 'dice', 'pokerchip', 'gameboard', 'chesspawn'].includes(spec.type)) {
        spec.y = 0.42; // Place on coffee table height (fallback if not on counter)
      }
      
      // Dining table height items (~0.75m)
      if (['plate', 'bowl', 'fork', 'knife', 'spoon', 'glass', 'mug'].includes(spec.type)) {
        // Check if near dining table, otherwise default to coffee table height
        spec.y = 0.76; // Dining table height (will be overridden by smart placement below)
      }
      
      // Side table height items
      if (['alarmclock', 'tablelamp'].includes(spec.type)) {
        spec.y = 0.55; // Place on side table height
      }
      
      // Floor-level items
      if (['tvstand', 'rug'].includes(spec.type)) {
        spec.y = 0; // Floor level
      }
      
      // Height adjustments for TV stands and entertainment centers
      if (['tvstand'].includes(spec.type)) {
        spec.y = 0; // Floor level
      }
      
      // Height adjustments for items on TV stands/media consoles
      if (['gameconsole', 'dvd', 'dvdcase', 'remote'].includes(spec.type)) {
        spec.y = 0.5; // Place on TV stand height
      }
      
      // Create the asset using handlers
      const handlers = {
        desk: createDesk,
        bed: createBed,
        toilet: createToilet,
        shower: createShower,
        counter: createKitchenCounter,
        plate: createPlate,
        plant: createPottedPlant,
        apple: createApple,
        pear: createPear,
        banana: createBanana,
        grapes: createGrapes,
        bowl: createBowl,
        fruitbowl: createFruitBowl,
        artframe: createArtFrame,
        clock: createWallClock,
        couch: createCouch,
        tv: createTV,
        tvstand: createTVStand,
        gameconsole: createGameConsole,
        dvd: createDVD,
        dvdcase: createDVDCase,
        remote: createRemote,
        coffeetable: createCoffeeTable,
        playingcard: createPlayingCard,
        dice: createDice,
        pokerchip: createPokerChip,
        gameboard: createGameBoard,
        computerdesk: createComputerDesk,
        chesspawn: createChessPawn,
        sidetable: createSideTable,
        floorlamp: createFloorLamp,
        alarmclock: createAlarmClock,
        broom: createBroom,
        dustpan: createDustpan,
        vacuum: createVacuum,
        handheldvacuum: createHandheldVacuum,
        bucket: createBucket,
        sponge: createSponge,
        rag: createRag,
        papertowelroll: createPaperTowelRoll,
        toiletpaperroll: createToiletPaperRoll,
        jengatower: createJengaTower,
        desklamp: createDeskLamp,
        pixarball: createPixarBall,
        basketball: createBasketball,
        baseball: createBaseball,
        rug: createRug,
        shelf: createShelf,
        ceilinglight: createCeilingLight,
        fork: createFork,
        knife: createKnife,
        spoon: createSpoon,
        refrigerator: createRefrigerator,
        fridge: createRefrigerator,
        milkcarton: createMilkCarton,
        orangejuice: createOrangeJuice,
        cheese: createCheese,
        eggs: createEggs,
        glass: createGlass,
        cup: createCup,
        mug: createMug,
        jar: createJar,
        sodacan: createSodaCan,
        cerealbox: createCerealBox,
        crackerbox: createCrackerBox,
        cactus: createCactus,
        computertower: createComputerTower,
        pencil: createPencil,
        notepad: createNotepad,
        notebook: createNotebook,
        stickynotes: createStickyNotes,
        tablelamp: createTableLamp,
        wallsconce: createWallSconce,
        chandelier: createChandelier,
        pendantlight: createPendantLight,
        diningtable: createDiningTable,
        shoerack: createShoeRack,
        umbrellastand: createUmbrellaStand,
        bathroomsink: createBathroomSink,
        microwave: createMicrowave
      };
      
      const handler = handlers[spec.type];
      if (handler) {
        const newObject = handler(spec);
        
        // ==================== SMART TABLE SETTING RULES ====================
        // Automatically place appropriate cutlery next to plates/bowls
        if (spec.type === 'plate') {
          // Add fork to the left of plate
          const forkSpec = {
            type: 'fork',
            x: spec.x - 0.08,
            z: spec.z,
            y: spec.y,
            rotation: Math.PI / 2, // Perpendicular to plate
            variant: spec.variant || 'dinner',
            finish: 'silver'
          };
          if (handlers.fork) handlers.fork(forkSpec);
          
          // Add knife to the right of plate
          const knifeSpec = {
            type: 'knife',
            x: spec.x + 0.08,
            z: spec.z,
            y: spec.y,
            rotation: -Math.PI / 2, // Perpendicular to plate
            variant: spec.variant === 'salad' ? 'butter' : 'dinner',
            finish: 'silver'
          };
          if (handlers.knife) handlers.knife(knifeSpec);
          
          console.log(`‚ú® Auto-placed fork and knife with plate`);
        }
        
        if (spec.type === 'bowl') {
          // Add spoon to the right of bowl
          const spoonSpec = {
            type: 'spoon',
            x: spec.x + 0.08,
            z: spec.z,
            y: spec.y,
            rotation: -Math.PI / 2, // Perpendicular to bowl
            variant: spec.variant === 'soup' ? 'soup' : 'table',
            finish: 'silver'
          };
          if (handlers.spoon) handlers.spoon(spoonSpec);
          
          console.log(`‚ú® Auto-placed spoon with bowl`);
        }
      }
      
      console.log(`Spawned ${assetDef.name} at grid (${gridX}, ${gridZ})`);
    }
    
    // ==================== ANIMATION LOOP ====================
    // (Main animation loop is at end of file after all game system updates)
    
    // ==================== GLOBAL FUNCTIONS ====================
    // (Removed loadRoom/randomizeRoom - use toggleInteriorsMode with 'I' key instead)
    
    // ==================== CONTROLS ====================
    // Tool System
    let currentTool = 0; // 0=none, 1=viewport, 2=lasso, 3=portal gun, 4=jar
    
    function switchTool(toolIndex) {
      // Disable all tools first
      if (viewportEquipped) toggleViewportFrame();
      if (lassoEnabled) toggleLasso();
      if (jarVisible) toggleJar();
      
      currentTool = toolIndex;
      
      // Enable the selected tool
      switch (toolIndex) {
        case 1: // Viewport
          if (!viewportEquipped) toggleViewportFrame();
          if (jarVisible) toggleJar(); // Show jar with viewport
          break;
        case 2: // Lasso
          if (!lassoEnabled) toggleLasso();
          break;
        case 3: // Portal gun (placeholder - not implemented yet)
          console.log('Portal gun selected (not yet implemented)');
          break;
        case 4: // Jar only
          if (!jarVisible) toggleJar();
          break;
      }
      
      console.log(`Switched to tool ${toolIndex}: ${['None', 'Viewport', 'Lasso', 'Portal Gun', 'Jar'][toolIndex]}`);
    }
    
    function cycleTool(direction) {
      // Cycle through: viewport+jar -> viewport only -> jar only -> none -> viewport+jar
      const states = [
        { viewport: true, jar: true },   // 0: Both
        { viewport: true, jar: false },  // 1: Viewport only
        { viewport: false, jar: true },  // 2: Jar only
        { viewport: false, jar: false }  // 3: None
      ];
      
      // Find current state
      let currentState = 0;
      if (viewportEquipped && jarVisible) currentState = 0;
      else if (viewportEquipped && !jarVisible) currentState = 1;
      else if (!viewportEquipped && jarVisible) currentState = 2;
      else currentState = 3;
      
      // Cycle to next state
      currentState = (currentState + direction + states.length) % states.length;
      const newState = states[currentState];
      
      // Apply new state
      if (newState.viewport && !viewportEquipped) toggleViewportFrame();
      else if (!newState.viewport && viewportEquipped) toggleViewportFrame();
      
      if (newState.jar && !jarVisible) toggleJar();
      else if (!newState.jar && jarVisible) toggleJar();
      
      console.log(`Cycled to: ${viewportEquipped ? 'Viewport' : ''}${viewportEquipped && jarVisible ? ' + ' : ''}${jarVisible ? 'Jar' : ''}${!viewportEquipped && !jarVisible ? 'None' : ''}`);
    }
    
    function setupControls() {
      // Mouse wheel for tool cycling
      window.addEventListener('wheel', (e) => {
        if (e.ctrlKey || e.shiftKey) return; // Allow normal zoom/pan
        
        const direction = e.deltaY > 0 ? 1 : -1;
        cycleTool(direction);
        e.preventDefault();
      }, { passive: false });
      
      window.addEventListener('keydown', async (e) => {
        // ESC key to close asset menu (works regardless of other states)
        if (e.code === 'Escape' && isAssetMenuOpen && isAssetMenuOpen()) {
          toggleAssetMenu();
          return;
        }
        
        keys.add(e.code);
        
        // Number keys for tool switching
        if (e.code === 'Digit1') { switchTool(1); return; } // Viewport
        if (e.code === 'Digit2') { switchTool(2); return; } // Lasso
        if (e.code === 'Digit3') { switchTool(3); return; } // Portal gun
        if (e.code === 'Digit4') { switchTool(4); return; } // Jar
        
        if (e.code === 'KeyR') resetPlayer();
        if (e.code === 'KeyV') toggleViewportFrame();
        if (e.code === 'KeyH') toggleUI();
        if (e.code === 'KeyP') togglePortals();
        if (e.code === 'KeyL') toggleLasso();
        if (e.code === 'KeyJ') toggleJar();
        if (e.code === 'KeyN') toggleHallway();
        if (e.code === 'KeyG') toggleGrassBlades();
        if (e.code === 'KeyM') {
          const overlay = await ensureMapOverlay();
          overlay.toggle();
        }
        
        // Remap 'B' key based on mode
        if (e.code === 'KeyB') {
          if (interiorsMode) {
            await ensureInteriorsModules();
            toggleAssetMenu();
          } else {
            // In city mode: toggle bike
            toggleBike();
          }
        }
        
        if (e.code === 'KeyO') {
          // First spawn character Y if not already spawned
          if (characterY && !characterY.visible && characterYBody) {
            const playerPos = playerBody.translation();
            characterY.visible = true;
            characterYBody.setTranslation({ x: playerPos.x + 2, y: playerPos.y, z: playerPos.z }, true);
            characterYBody.setLinvel({ x: 0, y: 0, z: 0 }, true);
            
            // Also spawn the rocket nearby
            await ensureRocketAssets();
            if (rocketMesh && rocketBody) {
              rocketMesh.visible = true;
              rocketBody.setTranslation({ x: playerPos.x - 3, y: playerPos.y + 2, z: playerPos.z }, true);
              rocketBody.setLinvel({ x: 0, y: 0, z: 0 }, true);
              rocketBody.setAngvel({ x: 0, y: 0, z: 0 }, true);
              rocketBody.setRotation({ x: 0, y: 0, z: 0, w: 1 }, true); // Upright
            }
            
            console.log('Character Y and rocket spawned! Press F near rocket to enter.');
          }
        }
        if (e.code === 'KeyF') {
          // Enter rocket if nearby and looking at it
          if (!rocketEnabled && rocketMesh && rocketMesh.visible && rocketBody && playerBody) {
            const playerPos = playerBody.translation();
            const rocketPos = rocketBody.translation();
            const distance = Math.sqrt(
              Math.pow(playerPos.x - rocketPos.x, 2) +
              Math.pow(playerPos.y - rocketPos.y, 2) +
              Math.pow(playerPos.z - rocketPos.z, 2)
            );
            
            // Check if player is within 5 meters of rocket
            if (distance < 5) {
              // Check if player is looking at rocket
              const forward = new THREE.Vector3(0, 0, -1);
              const quat = new THREE.Quaternion();
              quat.setFromEuler(new THREE.Euler(pitch, yaw, 0, 'YXZ'));
              forward.applyQuaternion(quat);
              
              const toRocket = new THREE.Vector3(
                rocketPos.x - playerPos.x,
                rocketPos.y - playerPos.y,
                rocketPos.z - playerPos.z
              ).normalize();
              
              const dot = forward.dot(toRocket);
              
              // If looking at rocket (dot > 0.7 = ~45 degree cone)
              if (dot > 0.7) {
              await toggleRocket();
              } else {
                console.log('Look at the rocket to enter it');
              }
            } else {
              console.log('Too far from rocket (distance: ' + distance.toFixed(1) + 'm)');
            }
          }
        }
        if (e.code === 'KeyI') await toggleInteriorsMode();
        if (e.code === 'KeyU') {
          // Spawn ants near player
          const spawnX = player.position.x;
          const spawnZ = player.position.z;
          spawnAnts(20, spawnX, spawnZ, 3);
          console.log('Spawned 20 ants near player');
        }
      });
      
      window.addEventListener('keyup', (e) => {
        keys.delete(e.code);
      });
      
      // Pointer lock
      renderer.domElement.addEventListener('click', () => {
        if (!pluckMode && !blockPointerLock) {
          renderer.domElement.requestPointerLock();
        }
      });
      
      document.addEventListener('pointerlockchange', () => {
        pointerLocked = document.pointerLockElement === renderer.domElement;
      });
      
      document.addEventListener('mousemove', (e) => {
        if (pointerLocked && !draggingObject) {
          const sensitivity = 0.002;
          
          // Update rocket orbit camera if rocket is enabled
          if (rocketEnabled) {
            rocketCameraYaw -= e.movementX * sensitivity;
            rocketCameraPitch -= e.movementY * sensitivity;
            // Pitch clamping happens in updateRocket()
          } else {
            // Normal player camera
            yaw -= e.movementX * sensitivity;
            pitch -= e.movementY * sensitivity;
            pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
          }
        }
        
        // Update mouse position for raycasting
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        
        // Update dragging
        if (draggingObject) {
          updateDraggingObject(e.clientX, e.clientY);
        }
        
        // Update hover highlight
        if (pluckMode && !draggingObject) {
          updateHoverHighlight(e.clientX, e.clientY);
        }
      });
      
      // Mouse buttons
      window.addEventListener('mousedown', async (e) => {
        // Interiors mode click interactions (MB1 only)
        if (interiorsMode && pointerLocked && e.button === 0) {
          await ensureInteriorsModules();
          onInteriorsClick(e);
          // Continue to other handlers (not returning yet)
        }
        
        // Bike controls take priority when bike is enabled
        if (bikeEnabled) {
          if (e.button === 1) { // M3 - Toggle autopilot/halt
            e.preventDefault();
            bikeAutoPilot = !bikeAutoPilot;
            console.log(bikeAutoPilot ? 'Bike autopilot enabled' : 'Bike halted (manual control)');
            return;
          }
          if (pointerLocked) {
            if (e.button === 0) { // M1 - Sharp LEFT turn
              sharpTurnBike('left');
              return;
            }
            if (e.button === 2) { // M2 - Sharp RIGHT turn
              e.preventDefault();
              sharpTurnBike('right');
              return;
            }
          }
        }
        
        // Lasso mode takes priority when enabled
        if (lassoEnabled && pointerLocked) {
          if (e.button === 0) { // M1 - Grappling hook
            fireGrapple();
            return;
          }
          if (e.button === 2) { // M2 - Swing rope
            e.preventDefault();
            fireSwingRope();
            return;
          }
        }
        
        // Jar shaking - M1 when jar is equipped and visible (no viewport or lasso) AND pointer is locked
        if (jarVisible && !lassoEnabled && !viewportEquipped && e.button === 0 && pointerLocked) {
          shakeJar();
          return;
        }
        
        // Jar inspect - M2 when jar is equipped and visible (no viewport or lasso) AND pointer is locked
        if (jarVisible && !lassoEnabled && !viewportEquipped && e.button === 2 && pointerLocked) {
          e.preventDefault();
          jarInspectMode = !jarInspectMode;
          console.log(`ü´ô Jar inspect mode: ${jarInspectMode ? 'ON' : 'OFF'}`);
          return;
        }
        
        // M3 - Toggle cursor mode (works with or without viewport)
        if (e.button === 1) {
          e.preventDefault();
          
          if (pointerLocked) {
            // Exit FPS mode -> Enter cursor mode
            blockPointerLock = true;
            document.exitPointerLock();
            pointerLocked = false;
            
            // Enable pluck mode if viewport is equipped OR jar is open
            if (viewportEquipped || (jarVisible && jarState !== 2)) {
              pluckMode = true;
              if (viewportEquipped) {
                document.getElementById('toggle-pluck').classList.add('active');
                updatePluckCandidates();
              }
            }
            console.log('Cursor mode enabled');
          } else {
            // Exit cursor mode -> Enter FPS mode
            blockPointerLock = false;
            pluckMode = false;
            if (viewportEquipped) {
              document.getElementById('toggle-pluck').classList.remove('active');
            }
            document.getElementById('tooltip').style.display = 'none';
            if (hoveredObject) {
              highlightObject(hoveredObject, false);
              hoveredObject = null;
            }
            
            // Re-enable pointer lock
            setTimeout(() => {
              if (!blockPointerLock && !pointerLocked) {
                renderer.domElement.requestPointerLock();
              }
            }, 100);
            console.log('FPS mode enabled');
          }
          return;
        }
        
        if (!viewportEquipped && !jarVisible) return;
        
        if (e.button === 2) { // Right click - snapshot
          e.preventDefault();
          if (droppedViewport) {
            retractViewportSnapshot();
          } else {
            dropViewportSnapshot();
          }
          updatePluckCandidates();
        }
        
        if (e.button === 0) { // Left click
          if (pluckMode) {
            // Try to grab and pop object out of frame OR pluck from jar
            const selected = selectPluckAt(e.clientX, e.clientY);
            
            // Check if clicking on jar object (when jar is open and visible, no viewport)
            if (!selected && jarVisible && jarState !== 2 && !viewportEquipped) {
              // Raycast to jar objects (allow any non-burst object: pedestrians, buildings, etc.)
              raycaster.setFromCamera(mouse, camera);
              
              const jarObjectMeshes = jarObjects
                .filter(obj => obj.mesh && !obj.isBurst)
                .map(obj => obj.mesh);
              
              const jarIntersects = raycaster.intersectObjects(jarObjectMeshes, true);
              if (jarIntersects.length > 0) {
                // Find the jar object corresponding to the intersected mesh
                let clickedJarObj = null;
                for (let intersect of jarIntersects) {
                  let mesh = intersect.object;
                  // Walk up parent hierarchy to find the jar object root
                  while (mesh.parent && !mesh.userData.isInJar) {
                    mesh = mesh.parent;
                  }
                  if (mesh.userData.isInJar) {
                    clickedJarObj = jarObjects.find(obj => obj.mesh === mesh);
                    break;
                  }
                }
                
                if (clickedJarObj && clickedJarObj.mesh) {
                  const objectType = clickedJarObj.isPedestrian ? 'pedestrian' : (clickedJarObj.isBuilding ? 'building' : 'object');
                  console.log(`ü´ô Plucking ${objectType} from jar!`);
                  
                  // Remove from jar
                  const jarEnv = pluckJar.userData.environment;
                  if (jarEnv && clickedJarObj.mesh.parent === jarEnv) {
                    jarEnv.remove(clickedJarObj.mesh);
                  }
                  
                  // Add to scene for dragging
                  scene.add(clickedJarObj.mesh);
                  
                  // Restore building physics if it's a building
                  if (clickedJarObj.isBuilding) {
                    const building = buildings.find(b => b.mesh === clickedJarObj.mesh);
                    if (building && building.body) {
                      building.body.setEnabled(true);
                      console.log('üè¢ Re-enabled building physics');
                    }
                  }
                  
                  // Remove from jarObjects array
                  const index = jarObjects.indexOf(clickedJarObj);
                  if (index > -1) {
                    jarObjects.splice(index, 1);
                  }
                  
                  // Start dragging
                  startDraggingObject(clickedJarObj.mesh, e.clientX, e.clientY);
                  return;
                }
              }
            }
            
            if (selected) {
              console.log('Plucking object:', selected.object);
              
              const camPos = new THREE.Vector3();
              camera.getWorldPosition(camPos);
              
              const objPos = new THREE.Vector3();
              selected.object.getWorldPosition(objPos);
              
              const distOld = camPos.distanceTo(objPos);
              const activeFrame = heldViewport && heldViewport.visible ? heldViewport : droppedViewport;
              
              // Pop object to jar depth (so it's aligned with jar for easy dropping)
              const jarDepth = 1.0; // Same depth as the jar
              const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
              
              if (activeFrame) {
                const distNew = camPos.distanceTo(activeFrame.position);
                const scaleFactor = distNew / Math.max(0.001, distOld);
                
                console.log('Popping to jar depth:', { distOld, distNew: jarDepth, scaleFactor });
                
                // Scale to maintain perceived size at jar depth
                const jarScaleFactor = jarDepth / Math.max(0.001, distOld);
                const currentScale = selected.object.scale.clone();
                
                // If it's a pedestrian, account for worldScale being applied to them
                const isPedestrian = pedestrians.find(p => p.group === selected.object);
                const baseScale = isPedestrian ? currentScale.clone().divideScalar(worldScale) : currentScale.clone();
                
                selected.object.scale.copy(baseScale.multiplyScalar(jarScaleFactor));
                
                // Mark pedestrian as plucked so it doesn't get worldScale applied
                if (isPedestrian) {
                  selected.object.userData.isPlucked = true;
                  
                  // Show initial plucked dialogue
                  console.log(`üó£Ô∏è Pedestrian plucked! Triggering plucked dialogue...`);
                  updatePedestrianDialogue(selected.object, 'plucked');
                  
                  // Ziya reacts to holding people
                  showZiyaDialogue('holding');
                }
              }
              
              // Special handling for planetoid - ensure buildingTexture comes with it
              if (selected.object.userData.isPlanetoid && selected.object === planetoidMesh) {
                console.log('üåç Plucking entire planetoid!');
                
                // Remove planetoid from worldRoot and add to scene
                // This prevents it from being affected by world scaling
                if (planetoidMesh.parent === worldRoot) {
                  worldRoot.remove(planetoidMesh);
                  scene.add(planetoidMesh);
                  console.log('Moved planetoid from worldRoot to scene');
                }
                
                // Building texture is already a child of planetoidMesh, so it will come along
                if (planetoidMesh.userData.buildingTexture) {
                  planetoidMesh.userData.buildingTexture.visible = true;
                }
                
                // Hide all city remnants when plucking the planet
                console.log('Hiding all city geometry...');
                
                // Hide all buildings
                buildings.forEach(b => {
                  if (b.mesh) b.mesh.visible = false;
                });
                
                // Hide all chunks
                activeChunks.forEach(chunkKey => {
                  const chunkRoot = chunkRoots.get(chunkKey);
                  if (chunkRoot) chunkRoot.visible = false;
                });
                
                // Hide distant skyline
                if (distantSkylineGroup) distantSkylineGroup.visible = false;
                
                // Hide world objects
                worldObjects.forEach(wo => {
                  if (wo.mesh) wo.mesh.visible = false;
                });
                
                // Hide pedestrians
                pedestrians.forEach(ped => {
                  if (ped.group) ped.group.visible = false;
                });
                
                // Scale down the planetoid for handling (it's currently 2000 radius!)
                const pluckScale = 0.0001; // Scale to ~0.2 units radius
                selected.object.scale.setScalar(pluckScale);
                console.log(`Scaled planetoid to ${pluckScale}x for handling`);
                
                // If jar is open, auto-place planetoid in jar
                if (jarVisible && jarState === 1) {
                  console.log('üåçü´ô Auto-placing planetoid in jar!');
                  // Set draggingObject first so stopDraggingObject can process it
                  draggingObject = selected.object;
                  draggingObject.userData.isDragging = true;
                  // Trigger jar drop immediately
                  stopDraggingObject(true); // Force drop into jar
                  document.getElementById('tooltip').style.display = 'none';
                  return; // Skip normal dragging flow
                }
              }
              
              // Position at jar depth (same z as jar)
              const newPos = camPos.clone().addScaledVector(forward, jarDepth);
              selected.object.position.copy(newPos);
              
              // Update physics body if building
              const building = buildings.find(b => b.mesh === selected.object);
              if (building && building.body && building.isDynamic) {
                building.body.setTranslation(newPos, true);
              }
              
              // Start dragging AFTER popping (set drag depth to jar depth)
              startDraggingObject(selected.object, e.clientX, e.clientY, jarDepth);
              document.getElementById('tooltip').style.display = 'none';
              
            } else {
              // Lock objects in viewport (viewport lock mode with distance-based scaling)
              viewportActive = true;
              lockObjectsInViewport();
            }
          }
        }
      });
      
      window.addEventListener('mouseup', (e) => {
        // Release grapple/swing on M1 or M2 release
        if (lassoEnabled && (e.button === 0 || e.button === 2)) {
          releaseGrapple();
        }
        
        if (e.button === 0) {
          if (draggingObject) {
            // Check if object is dropped into jar
            const droppedInJar = checkJarDrop(draggingObject);
            stopDraggingObject(droppedInJar);
          }
          viewportActive = false;
        }
      });
      
      // Check if a dragged object should be dropped into the jar
      function checkJarDrop(draggedObj) {
        // Only check if jar is visible AND open (jarState === 1)
        if (!pluckJar || !jarVisible || jarState !== 1 || !draggedObj) return false;
        
        const objPos = new THREE.Vector3();
        draggedObj.getWorldPosition(objPos);
        
        const jarPos = new THREE.Vector3();
        pluckJar.getWorldPosition(jarPos);
        
        const jarHeight = pluckJar.userData.jarHeight || 0.5;
        const jarRadius = pluckJar.userData.jarRadius || 0.18;
        
        // Check if object is above jar opening
        const horizontalDist = Math.sqrt(
          Math.pow(objPos.x - jarPos.x, 2) + 
          Math.pow(objPos.z - jarPos.z, 2)
        );
        
        const isAboveJar = objPos.y > jarPos.y; // Check if above jar bottom
        const isBelowOpening = objPos.y < jarPos.y + jarHeight + 0.3; // Check if not too far above
        const isWithinRadius = horizontalDist < jarRadius * 2.0; // Very lenient for easier drops
        
        console.log('Jar drop check:', { 
          horizontalDist: horizontalDist.toFixed(2), 
          jarRadius: jarRadius.toFixed(2), 
          objY: objPos.y.toFixed(2),
          jarY: jarPos.y.toFixed(2),
          jarTop: (jarPos.y + jarHeight).toFixed(2),
          isAboveJar, 
          isBelowOpening,
          isWithinRadius,
          willDrop: isAboveJar && isBelowOpening && isWithinRadius
        });
        
        return isAboveJar && isBelowOpening && isWithinRadius;
      }
      
      // Stop dragging an object and apply gravity if needed
      function stopDraggingObject(droppedInJar = false) {
        if (!draggingObject) return;
        
        let obj = draggingObject; // Use 'let' so we can reassign for planetoid case
        draggingObject = null;
        
        if (droppedInJar) {
          // Object collected into jar - parent to jar and snap to spawn point
          console.log('Object collected into jar!');
          
          // Special handling for planetoid
          if (obj.userData.isPlanetoid && obj === planetoidMesh) {
            console.log('üåç‚ú® Collected the entire planetoid into the jar!');
            
            // Hide the original planetoid
            planetoidMesh.visible = false;
            
            // Create a miniature planetoid for the jar (with building texture)
            const miniPlanetGeo = new THREE.SphereGeometry(0.08, 32, 32);
            const miniPlanetMat = new THREE.MeshStandardMaterial({ 
              color: 0x4a7c59,
              roughness: 0.8,
              metalness: 0.1
            });
            const miniPlanet = new THREE.Mesh(miniPlanetGeo, miniPlanetMat);
            miniPlanet.userData.isPlanetoidCopy = true;
            miniPlanet.userData.originalPlanetoid = planetoidMesh;
            
            // Add miniature building texture to mini planet
            const miniRectCount = 80; // Fewer rectangles for mini planet
            const miniRectGeo = new THREE.PlaneGeometry(1, 1);
            const miniRectMat = new THREE.MeshBasicMaterial({
              color: 0x888888,
              side: THREE.DoubleSide
            });
            const miniRects = new THREE.InstancedMesh(miniRectGeo, miniRectMat, miniRectCount);
            
            const dummy = new THREE.Object3D();
            const miniRadius = 0.08;
            
            for (let i = 0; i < miniRectCount; i++) {
              const phi = Math.acos(1 - 2 * (i + 0.5) / miniRectCount);
              const theta = Math.PI * (1 + Math.sqrt(5)) * i;
              
              const x = Math.cos(theta) * Math.sin(phi) * (miniRadius + 0.001);
              const y = Math.cos(phi) * (miniRadius + 0.001);
              const z = Math.sin(theta) * Math.sin(phi) * (miniRadius + 0.001);
              
              const width = 0.002 + Math.random() * 0.006;
              const height = 0.001 + Math.random() * 0.003;
              
              dummy.position.set(x, y, z);
              dummy.scale.set(width, height, 1);
              
              const normalVec = new THREE.Vector3(x, y, z).normalize();
              dummy.lookAt(dummy.position.x + normalVec.x, dummy.position.y + normalVec.y, dummy.position.z + normalVec.z);
              dummy.rotateZ(Math.random() * Math.PI * 2);
              
              dummy.updateMatrix();
              miniRects.setMatrixAt(i, dummy.matrix);
            }
            
            miniRects.instanceMatrix.needsUpdate = true;
            miniPlanet.add(miniRects);
            
            // Use miniPlanet as the jar object instead
            obj = miniPlanet;
            
            console.log('Created miniature planetoid with building texture for jar');
          }
          
          // Check if it's a pedestrian first (needs special handling)
          const ped = pedestrians.find(p => p.group === obj);
          
          // Check if it's a building
          const building = buildings.find(b => b.mesh === obj);
          
          // Remove from world hierarchy
          if (obj.parent) {
            obj.parent.remove(obj);
          }
          
          // Disable building physics when going into jar
          if (building && building.body) {
            building.body.setEnabled(false);
            console.log('üè¢ Disabled building physics for jar storage');
          }
          
          // Get jar environment container
          const jarEnv = pluckJar.userData.environment;
          if (!jarEnv) {
            console.error('Jar environment not found!');
            return;
          }
          
          // Parent to jar environment so it moves as a unit with the jar
          jarEnv.add(obj);
          
          // Calculate spawn position inside jar based on how many objects are already in there
          const jarHeight = pluckJar.userData.jarHeight || 0.5;
          const jarRadius = pluckJar.userData.jarRadius || 0.18;
          const numObjectsInJar = jarObjects.length;
          
          // Arrange objects in a grid pattern at bottom of jar (floor plane at y=0)
          const gridSize = Math.ceil(Math.sqrt(numObjectsInJar + 1));
          const index = numObjectsInJar;
          const row = Math.floor(index / gridSize);
          const col = index % gridSize;
          const spacing = (jarRadius * 1.6) / gridSize;
          const offsetX = (col - gridSize / 2 + 0.5) * spacing;
          const offsetZ = (row - gridSize / 2 + 0.5) * spacing;
          
          // Store original scale
          const originalScale = obj.scale.clone();
          const isPedestrian = ped ? true : false;
          
          // Snap to position on jar floor (y=0 is floor in jarEnvironment space)
          // Small offset to prevent clipping through jar bottom
          obj.position.set(
            offsetX,
            0.02, // Slightly above floor to prevent clipping
            offsetZ
          );
          
          // Keep upright and add random yaw rotation
          obj.rotation.set(0, Math.random() * Math.PI * 2, 0);
          
          // Determine object type
          const isBuilding = building ? true : false;
          const objectType = isPedestrian ? 'pedestrian' : (isBuilding ? 'building' : 'object');
          
          // Add to jar objects array (no physics body needed - pure visual)
          jarObjects.push({ 
            mesh: obj, 
            originalScale, 
            isPedestrian,
            isBuilding,
            localPosition: obj.position.clone(), // Store local position
            walkTarget: null,
            walkSpeed: 0.3 + Math.random() * 0.2,
            walkPhase: Math.random() * Math.PI * 2 // Random starting phase for walking
          });
          
          // Mark as collected
          obj.userData.isInJar = true;
          if (isPedestrian) {
            obj.userData.isPlucked = true;
          }
          
          // Disable original physics for pedestrians in jar (visual-only in jar)
          if (ped && ped.physicsBody) {
            ped.physicsBody.setEnabled(false);
          }
          
          // Remove from suppressedPhysics if it was there
          suppressedPhysics.delete(obj);
          
          console.log(`‚úÖ Added ${objectType} to jar environment at floor level`);
          
        } else {
          // Object dropped onto surfaces - place it at current position
          console.log('Object dropped onto surface');
          
          // If object has physics, restore it
          const building = buildings.find(b => b.mesh === obj);
          if (building && building.body && building.isDynamic) {
            const objPos = new THREE.Vector3();
            obj.getWorldPosition(objPos);
            building.body.setTranslation(objPos, true);
            suppressedPhysics.delete(obj);
          }
          
          const worldObj = worldObjects.find(wo => wo.mesh === obj);
          if (worldObj && worldObj.body) {
            const objPos = new THREE.Vector3();
            obj.getWorldPosition(objPos);
            worldObj.body.setTranslation(objPos, true);
            worldObj.body.setLinvel({ x: 0, y: 0, z: 0 }, true);
            suppressedPhysics.delete(obj);
          }
          
          // Check for pedestrian
          const ped = pedestrians.find(p => p.group === obj);
          if (ped) {
            // Get current position
            const objPos = new THREE.Vector3();
            obj.getWorldPosition(objPos);
            
            // Create physics body for pedestrian if needed
            if (!ped.physicsBody) {
              const bodyDesc = physics.RigidBodyDesc.dynamic()
                .setTranslation(objPos.x, objPos.y, objPos.z);
              const body = world.createRigidBody(bodyDesc);
              
              const colliderDesc = physics.ColliderDesc.cuboid(0.25, 0.85, 0.25);
              world.createCollider(colliderDesc, body);
              
              ped.physicsBody = body;
            } else {
              // Update existing body position to current mesh position
              ped.physicsBody.setTranslation(objPos, true);
              ped.physicsBody.setLinvel({ x: 0, y: 0, z: 0 }, true);
            }
            
            // Apply gravity to let them fall
            ped.physicsBody.setGravityScale(1.0, true);
            suppressedPhysics.delete(obj);
            
            // Clear dragging flag
            obj.userData.isDragging = false;
          }
        }
        
        // Clear dragging flag for any object
        obj.userData.isDragging = false;
      }
      
      // Start dragging an object
      function startDraggingObject(obj, clientX, clientY, depth = 3.0) {
        draggingObject = obj;
        
        // Set drag depth to the specified depth (usually jar depth for plucked objects)
        dragDepth = depth;
        
        // Suppress physics while dragging
        suppressedPhysics.add(obj);
        
        // Store initial drag info
        obj.userData.isDragging = true;
        
        console.log('Started dragging at depth:', dragDepth);
      }
      
      // Update dragging object position
      function updateDraggingObject(clientX, clientY) {
        if (!draggingObject) return;
        
        // Calculate world position from mouse position
        const rect = renderer.domElement.getBoundingClientRect();
        const mouseX = ((clientX - rect.left) / rect.width) * 2 - 1;
        const mouseY = -((clientY - rect.top) / rect.height) * 2 + 1;
        
        // Raycast from camera through mouse position
        raycaster.setFromCamera(new THREE.Vector2(mouseX, mouseY), camera);
        
        // Position object at fixed distance from camera along ray
        const direction = raycaster.ray.direction.clone();
        const distance = dragDepth;
        const newPos = camera.position.clone().addScaledVector(direction, distance);
        
        draggingObject.position.copy(newPos);
      }
      
      window.addEventListener('contextmenu', (e) => e.preventDefault());
      
      // Scroll wheel - viewport distance, drag offset, or rocket zoom
      window.addEventListener('wheel', (e) => {
        // Rocket camera zoom (always works in rocket mode)
        if (rocketEnabled) {
          e.preventDefault();
          const zoomFactor = Math.exp(e.deltaY * 0.001);
          rocketCameraDistance = THREE.MathUtils.clamp(rocketCameraDistance * zoomFactor, 5, 50);
          return;
        }
        
        if (!viewportEquipped) return;
        
        e.preventDefault();
        const factor = Math.exp(e.deltaY * 0.0015);
        
        if (draggingObject) {
          // Adjust drag depth/offset
          if (draggingObject.frame) {
            draggingObject.offset = THREE.MathUtils.clamp(
              draggingObject.offset * factor, 
              0.05, 
              3.0
            );
            // Update position immediately
            const rect = renderer.domElement.getBoundingClientRect();
            const cx = e.clientX ?? (rect.left + rect.width / 2);
            const cy = e.clientY ?? (rect.top + rect.height / 2);
            updateDraggingObject(cx, cy);
          } else {
            dragDepth = THREE.MathUtils.clamp(dragDepth * factor, 0.5, 20.0);
          }
        } else if (heldViewport && heldViewport.visible) {
          // Adjust viewport distance
          heldViewportDist = THREE.MathUtils.clamp(heldViewportDist * factor, 0.2, 5.0);
          document.getElementById('viewport-dist-value').textContent = heldViewportDist.toFixed(1) + 'm';
        }
      }, { passive: false });
      
      window.addEventListener('resize', onWindowResize);
    }
    
    function lockObjectsInViewport() {
      viewportLocked.clear();
      const vpRect = document.getElementById('viewport-frame').getBoundingClientRect();
      const camPos = new THREE.Vector3();
      camera.getWorldPosition(camPos);
      
      // Lock buildings
      buildings.forEach(b => {
        const pos = new THREE.Vector3();
        b.mesh.getWorldPosition(pos);
        const projected = pos.clone().project(camera);
        const x = (projected.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-projected.y * 0.5 + 0.5) * window.innerHeight;
        
        if (x >= vpRect.left && x <= vpRect.right && y >= vpRect.top && y <= vpRect.bottom) {
          const dist = camPos.distanceTo(pos);
          
          b.mesh.userData.viewportLock = {
            dist0: dist,
            scale0: b.mesh.scale.clone(),
            ndc: new THREE.Vector2(projected.x, projected.y),
            quat0: b.mesh.quaternion.clone(),
            camQuat0: camera.quaternion.clone()
          };
          
          viewportLocked.add(b.mesh);
        }
      });
      
      // Lock world objects
      worldObjects.forEach(wo => {
        const pos = new THREE.Vector3();
        wo.mesh.getWorldPosition(pos);
        const projected = pos.clone().project(camera);
        const x = (projected.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-projected.y * 0.5 + 0.5) * window.innerHeight;
        
        if (x >= vpRect.left && x <= vpRect.right && y >= vpRect.top && y <= vpRect.bottom) {
          const dist = camPos.distanceTo(pos);
          
          wo.mesh.userData.viewportLock = {
            dist0: dist,
            scale0: wo.mesh.scale.clone(),
            ndc: new THREE.Vector2(projected.x, projected.y),
            quat0: wo.mesh.quaternion.clone(),
            camQuat0: camera.quaternion.clone()
          };
          
          viewportLocked.add(wo.mesh);
        }
      });
    }
    
    function setupUI() {
      console.log('üéÆ Setting up UI...');
      
      // Toggle switches
      document.getElementById('toggle-shadows').addEventListener('click', (e) => {
        shadowsEnabled = e.target.classList.toggle('active');
        renderer.shadowMap.enabled = shadowsEnabled;
      });
      
      document.getElementById('toggle-fog').addEventListener('click', (e) => {
        fogEnabled = e.target.classList.toggle('active');
        scene.fog = fogEnabled ? new THREE.FogExp2(0xBBD5EA, 0.006) : null;
      });
      
      document.getElementById('toggle-postfx').addEventListener('click', async (e) => {
        postFXEnabled = e.target.classList.toggle('active');
        if (postFXEnabled) {
          await ensurePostProcessingReady();
        }
      });
      
      document.getElementById('toggle-aa').addEventListener('click', async (e) => {
        aaEnabled = e.target.classList.toggle('active');
        await ensurePostProcessingReady();
        if (smaaPass) {
          smaaPass.enabled = aaEnabled;
        }
      });
      
      document.getElementById('toggle-motionblur').addEventListener('click', async (e) => {
        motionBlurEnabled = e.target.classList.toggle('active');
        await ensurePostProcessingReady();
        if (motionBlurPass) {
          motionBlurPass.enabled = motionBlurEnabled;
        }
      });
      
      // ==================== POST-PROCESSING CONTROLS ====================
      
      // Bloom controls
      document.getElementById('toggle-bloom').addEventListener('click', async (e) => {
        bloomEnabled = e.target.classList.toggle('active');
        await ensurePostProcessingReady();
        if (bloomPass) bloomPass.enabled = bloomEnabled;
      });
      document.getElementById('bloom-strength-slider').addEventListener('input', async (e) => {
        bloomStrength = parseFloat(e.target.value);
        await ensurePostProcessingReady();
        if (bloomPass) bloomPass.strength = bloomStrength;
        document.getElementById('bloom-strength-value').textContent = bloomStrength.toFixed(2);
      });
      document.getElementById('bloom-radius-slider').addEventListener('input', async (e) => {
        bloomRadius = parseFloat(e.target.value);
        await ensurePostProcessingReady();
        if (bloomPass) bloomPass.radius = bloomRadius;
        document.getElementById('bloom-radius-value').textContent = bloomRadius.toFixed(2);
      });
      document.getElementById('bloom-threshold-slider').addEventListener('input', async (e) => {
        bloomThreshold = parseFloat(e.target.value);
        await ensurePostProcessingReady();
        if (bloomPass) bloomPass.threshold = bloomThreshold;
        document.getElementById('bloom-threshold-value').textContent = bloomThreshold.toFixed(2);
      });
      
      // SSAO controls
      document.getElementById('toggle-ssao').addEventListener('click', async (e) => {
        ssaoEnabled = e.target.classList.toggle('active');
        await ensurePostProcessingReady();
        if (ssaoPass) ssaoPass.enabled = ssaoEnabled;
      });
      document.getElementById('ssao-intensity-slider').addEventListener('input', async (e) => {
        ssaoIntensity = parseFloat(e.target.value);
        await ensurePostProcessingReady();
        if (ssaoPass) {
          ssaoPass.output = ssaoIntensity > 0 ? 0 : 3;
        }
        document.getElementById('ssao-intensity-value').textContent = ssaoIntensity.toFixed(2);
      });
      document.getElementById('ssao-radius-slider').addEventListener('input', async (e) => {
        ssaoRadius = parseFloat(e.target.value);
        await ensurePostProcessingReady();
        if (ssaoPass) ssaoPass.kernelRadius = ssaoRadius;
        document.getElementById('ssao-radius-value').textContent = ssaoRadius.toFixed(0);
      });
      
      // Depth of Field controls
      document.getElementById('toggle-dof').addEventListener('click', async (e) => {
        dofEnabled = e.target.classList.toggle('active');
        await ensurePostProcessingReady();
        if (dofPass) dofPass.enabled = dofEnabled;
      });
      document.getElementById('dof-focus-slider').addEventListener('input', async (e) => {
        dofFocus = parseFloat(e.target.value);
        await ensurePostProcessingReady();
        if (dofPass && dofPass.uniforms && dofPass.uniforms.focus) {
          dofPass.uniforms.focus.value = dofFocus;
        }
        document.getElementById('dof-focus-value').textContent = dofFocus.toFixed(1);
      });
      document.getElementById('dof-aperture-slider').addEventListener('input', async (e) => {
        dofAperture = parseFloat(e.target.value);
        await ensurePostProcessingReady();
        if (dofPass && dofPass.uniforms && dofPass.uniforms.aperture) {
          dofPass.uniforms.aperture.value = dofAperture;
        }
        document.getElementById('dof-aperture-value').textContent = dofAperture.toFixed(4);
      });
      document.getElementById('dof-maxblur-slider').addEventListener('input', async (e) => {
        dofMaxBlur = parseFloat(e.target.value);
        await ensurePostProcessingReady();
        if (dofPass && dofPass.uniforms && dofPass.uniforms.maxblur) {
          dofPass.uniforms.maxblur.value = dofMaxBlur;
        }
        document.getElementById('dof-maxblur-value').textContent = dofMaxBlur.toFixed(4);
      });
      
      // Film Grain controls
      document.getElementById('toggle-film').addEventListener('click', async (e) => {
        filmEnabled = e.target.classList.toggle('active');
        await ensurePostProcessingReady();
        if (filmPass) filmPass.enabled = filmEnabled;
      });
      document.getElementById('film-intensity-slider').addEventListener('input', async (e) => {
        filmIntensity = parseFloat(e.target.value);
        await ensurePostProcessingReady();
        if (filmPass && filmPass.uniforms && filmPass.uniforms.intensity) {
          filmPass.uniforms.intensity.value = filmIntensity;
        }
        document.getElementById('film-intensity-value').textContent = filmIntensity.toFixed(2);
      });
      
      // Vignette controls
      document.getElementById('toggle-vignette').addEventListener('click', async (e) => {
        vignetteEnabled = e.target.classList.toggle('active');
        await ensurePostProcessingReady();
        if (vignettePass) vignettePass.enabled = vignetteEnabled;
      });
      document.getElementById('vignette-intensity-slider').addEventListener('input', async (e) => {
        vignetteIntensity = parseFloat(e.target.value);
        await ensurePostProcessingReady();
        if (vignettePass && vignettePass.uniforms) {
          vignettePass.uniforms.intensity.value = vignetteIntensity;
        }
        document.getElementById('vignette-intensity-value').textContent = vignetteIntensity.toFixed(2);
      });
      document.getElementById('vignette-softness-slider').addEventListener('input', async (e) => {
        vignetteSoftness = parseFloat(e.target.value);
        await ensurePostProcessingReady();
        if (vignettePass && vignettePass.uniforms) {
          vignettePass.uniforms.softness.value = vignetteSoftness;
        }
        document.getElementById('vignette-softness-value').textContent = vignetteSoftness.toFixed(2);
      });
      
      // Chromatic Aberration controls
      document.getElementById('toggle-chromatic').addEventListener('click', async (e) => {
        chromaticAberrationEnabled = e.target.classList.toggle('active');
        await ensurePostProcessingReady();
        if (chromaticAberrationPass) chromaticAberrationPass.enabled = chromaticAberrationEnabled;
      });
      document.getElementById('chromatic-amount-slider').addEventListener('input', async (e) => {
        chromaticAberrationAmount = parseFloat(e.target.value);
        await ensurePostProcessingReady();
        if (chromaticAberrationPass && chromaticAberrationPass.uniforms) {
          chromaticAberrationPass.uniforms.amount.value = chromaticAberrationAmount;
        }
        document.getElementById('chromatic-amount-value').textContent = chromaticAberrationAmount.toFixed(4);
      });
      
      document.getElementById('toggle-pluck').addEventListener('click', (e) => {
        pluckMode = e.target.classList.contains('active');
        updatePluckCandidates();
      });
      
      // FOV
      document.getElementById('fov-slider').addEventListener('input', (e) => {
        camera.fov = parseInt(e.target.value);
        camera.updateProjectionMatrix();
        document.getElementById('fov-value').textContent = camera.fov + '¬∞';
      });
      
      // Render scale
      document.getElementById('render-scale-slider').addEventListener('input', (e) => {
        const scale = parseInt(e.target.value) / 100;
        renderer.setPixelRatio(window.devicePixelRatio * scale);
        if (composer) {
          composer.setPixelRatio(window.devicePixelRatio * scale);
        }
        document.getElementById('render-scale-value').textContent = scale.toFixed(1) + 'x';
      });
      
      // Viewport distance
      document.getElementById('viewport-dist-slider').addEventListener('input', (e) => {
        heldViewportDist = parseInt(e.target.value) / 100;
        document.getElementById('viewport-dist-value').textContent = heldViewportDist.toFixed(1) + 'm';
      });
      
      // Buttons
      document.getElementById('spawn-city').addEventListener('click', () => {
        // Initial chunk load around player
        updateChunks();
        console.log('City generation started with chunk streaming');
      });
      document.getElementById('btn-snapshot').addEventListener('click', dropViewportSnapshot);
      document.getElementById('btn-clear').addEventListener('click', retractViewportSnapshot);
      
      document.getElementById('spawn-objects').addEventListener('click', () => {
        // Spawn some physics objects for interaction
        for (let i = 0; i < 5; i++) {
          spawnPhysicsObject();
        }
      });
      
      // ==================== OPTIMIZATION CONTROLS ====================
      
      console.log('üîß Initializing optimization controls...');
      
      // Initialize toggle buttons from config and add event listeners
      const toggleWindows = document.getElementById('toggle-windows');
      if (optimizationConfig.windows.enabled) {
        toggleWindows.classList.add('active');
      } else {
        toggleWindows.classList.remove('active');
      }
      toggleWindows.addEventListener('click', (e) => {
        optimizationConfig.windows.enabled = e.target.classList.toggle('active');
        console.log(`ü™ü Windows: ${optimizationConfig.windows.enabled ? 'ON' : 'OFF'}`);
      });
      
      const toggleSills = document.getElementById('toggle-sills');
      if (optimizationConfig.sills.enabled) {
        toggleSills.classList.add('active');
      } else {
        toggleSills.classList.remove('active');
      }
      toggleSills.addEventListener('click', (e) => {
        optimizationConfig.sills.enabled = e.target.classList.toggle('active');
        console.log(`üèõÔ∏è Sills: ${optimizationConfig.sills.enabled ? 'ON' : 'OFF'}`);
      });
      
      const togglePedestrians = document.getElementById('toggle-pedestrians');
      if (optimizationConfig.pedestrians.enabled) {
        togglePedestrians.classList.add('active');
      } else {
        togglePedestrians.classList.remove('active');
      }
      togglePedestrians.addEventListener('click', (e) => {
        optimizationConfig.pedestrians.enabled = e.target.classList.toggle('active');
        console.log(`üö∂ Pedestrians: ${optimizationConfig.pedestrians.enabled ? 'ON' : 'OFF'}`);
      });
      
      const toggleGrass = document.getElementById('toggle-grass');
      if (optimizationConfig.grass.enabled) {
        toggleGrass.classList.add('active');
      } else {
        toggleGrass.classList.remove('active');
      }
      toggleGrass.addEventListener('click', (e) => {
        optimizationConfig.grass.enabled = e.target.classList.toggle('active');
        grassBladesEnabled = optimizationConfig.grass.enabled;
        console.log(`üå± Grass: ${optimizationConfig.grass.enabled ? 'ON' : 'OFF'}`);
      });
      
      // Sliders with initialization
      const windowsSlider = document.getElementById('windows-slider');
      windowsSlider.value = optimizationConfig.windows.maxCount;
      document.getElementById('windows-count').textContent = optimizationConfig.windows.maxCount;
      windowsSlider.addEventListener('input', (e) => {
        optimizationConfig.windows.maxCount = parseInt(e.target.value);
        document.getElementById('windows-count').textContent = optimizationConfig.windows.maxCount;
        console.log(`ü™ü Windows max: ${optimizationConfig.windows.maxCount}`);
      });
      
      const sillsSlider = document.getElementById('sills-slider');
      sillsSlider.value = optimizationConfig.sills.maxCount;
      document.getElementById('sills-count').textContent = optimizationConfig.sills.maxCount;
      sillsSlider.addEventListener('input', (e) => {
        optimizationConfig.sills.maxCount = parseInt(e.target.value);
        document.getElementById('sills-count').textContent = optimizationConfig.sills.maxCount;
        console.log(`üèõÔ∏è Sills max: ${optimizationConfig.sills.maxCount}`);
      });
      
      const pedestriansSlider = document.getElementById('pedestrians-slider');
      pedestriansSlider.value = optimizationConfig.pedestrians.maxCount;
      document.getElementById('pedestrians-count').textContent = optimizationConfig.pedestrians.maxCount;
      pedestriansSlider.addEventListener('input', (e) => {
        optimizationConfig.pedestrians.maxCount = parseInt(e.target.value);
        document.getElementById('pedestrians-count').textContent = optimizationConfig.pedestrians.maxCount;
        console.log(`üö∂ Pedestrians max: ${optimizationConfig.pedestrians.maxCount}`);
      });
      
      const grassSlider = document.getElementById('grass-slider');
      grassSlider.value = optimizationConfig.grass.maxCount;
      document.getElementById('grass-count').textContent = optimizationConfig.grass.maxCount;
      grassSlider.addEventListener('input', (e) => {
        optimizationConfig.grass.maxCount = parseInt(e.target.value);
        document.getElementById('grass-count').textContent = optimizationConfig.grass.maxCount;
        console.log(`üå± Grass max: ${optimizationConfig.grass.maxCount}`);
      });
      
      const skylineSlider = document.getElementById('skyline-slider');
      skylineSlider.value = optimizationConfig.skylineDensity;
      document.getElementById('skyline-density').textContent = optimizationConfig.skylineDensity.toFixed(1) + 'x';
      skylineSlider.addEventListener('input', (e) => {
        optimizationConfig.skylineDensity = parseFloat(e.target.value);
        document.getElementById('skyline-density').textContent = optimizationConfig.skylineDensity.toFixed(1) + 'x';
        console.log(`üèôÔ∏è Skyline density: ${optimizationConfig.skylineDensity.toFixed(1)}x`);
      });
      
      // Apply optimization and rebuild
      document.getElementById('btn-apply-optimization').addEventListener('click', () => {
        console.log('üîß Applying optimization settings and rebuilding...');
        console.log('Optimization Config:', JSON.stringify(optimizationConfig, null, 2));
        
        // Reset all counters before rebuild
        console.log('  ‚Üí Resetting counters...');
        optimizationConfig.windows.currentCount = 0;
        optimizationConfig.sills.currentCount = 0;
        optimizationConfig.pedestrians.currentCount = 0;
        optimizationConfig.grass.currentCount = 0;
        
        // Rebuild instanced managers with new limits
        console.log('  ‚Üí Rebuilding instanced managers...');
        initializeInstancedManagers();
        
        // Clear and rebuild chunks
        console.log('  ‚Üí Clearing city chunks...');
        cityChunks.clear();
        activeChunks.clear();
        
        // Clear existing chunk roots
        chunkRoots.forEach(root => {
          if (root.parent) root.parent.remove(root);
        });
        chunkRoots.clear();
        
        // Rebuild distant skyline with new density
        console.log('  ‚Üí Rebuilding distant skyline...');
        const oldSkyline = worldRoot.getObjectByName('distantSkyline');
        if (oldSkyline) {
          worldRoot.remove(oldSkyline);
        }
        const newSkyline = createDistantSkyline();
        worldRoot.add(newSkyline);
        
        // Rebuild planetoid skyline if rocket mode or planetoid exists
        if (optimizationConfig.skylineWrapPlanetoid && rocketMode) {
          console.log('  ‚Üí Rebuilding planetoid skyline...');
          createPlanetoidSkyline();
        }
        
        // Trigger chunk reload
        console.log('  ‚Üí Reloading chunks...');
        updateChunks();
        
        console.log('‚úÖ Optimization applied successfully!');
        console.log(`Final counts - Windows: ${optimizationConfig.windows.currentCount}, Sills: ${optimizationConfig.sills.currentCount}`);
      });
      
      // ==================== DRAGGABLE PANELS ====================
      
      function makePanelDraggable(panel) {
        let isDragging = false;
        let currentX, currentY, initialX, initialY;
        
        panel.addEventListener('mousedown', (e) => {
          // Only drag from title or empty space (not from interactive elements)
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON' || 
              e.target.classList.contains('toggle-switch') || e.target.closest('.toggle-switch')) {
            return;
          }
          
          isDragging = true;
          panel.classList.add('dragging');
          
          initialX = e.clientX - panel.offsetLeft;
          initialY = e.clientY - panel.offsetTop;
          
          e.preventDefault();
        });
        
        document.addEventListener('mousemove', (e) => {
          if (!isDragging) return;
          
          e.preventDefault();
          currentX = e.clientX - initialX;
          currentY = e.clientY - initialY;
          
          // Clamp to window bounds
          const maxX = window.innerWidth - panel.offsetWidth;
          const maxY = window.innerHeight - panel.offsetHeight;
          currentX = Math.max(0, Math.min(currentX, maxX));
          currentY = Math.max(0, Math.min(currentY, maxY));
          
          panel.style.left = currentX + 'px';
          panel.style.top = currentY + 'px';
          panel.style.bottom = 'auto'; // Remove bottom constraint when dragging
          panel.style.right = 'auto'; // Remove right constraint when dragging
        });
        
        document.addEventListener('mouseup', () => {
          if (isDragging) {
            isDragging = false;
            panel.classList.remove('dragging');
          }
        });
      }
      
      // Make all panels draggable
      makePanelDraggable(document.getElementById('visual-panel'));
      makePanelDraggable(document.getElementById('optimization-panel'));
      makePanelDraggable(document.getElementById('controls-panel'));
      makePanelDraggable(document.getElementById('stats-panel'));
      makePanelDraggable(document.getElementById('viewport-panel'));
      
      console.log('‚úÖ UI setup complete');
    }
    
    function spawnPhysicsObject() {
      const size = 0.5 + Math.random() * 1.0;
      const geometry = Math.random() < 0.5 ? 
        new THREE.BoxGeometry(size, size, size) :
        new THREE.SphereGeometry(size / 2, 16, 12);
      
      const color = new THREE.Color().setHSL(Math.random(), 0.7, 0.6);
      const material = new THREE.MeshStandardMaterial({ 
        color,
        roughness: 0.5,
        metalness: 0.3
      });
      
      const mesh = new THREE.Mesh(geometry, material);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      
      const x = (Math.random() - 0.5) * 10;
      const z = (Math.random() - 0.5) * 10;
      mesh.position.set(x, 5 + Math.random() * 3, z);
      
      worldRoot.add(mesh);
      
      // Physics body
      const bodyDesc = physics.RigidBodyDesc.dynamic()
        .setTranslation(x, 5 + Math.random() * 3, z);
      const body = world.createRigidBody(bodyDesc);
      
      const colliderDesc = geometry.type === 'BoxGeometry' ?
        physics.ColliderDesc.cuboid(size/2, size/2, size/2) :
        physics.ColliderDesc.ball(size/2);
      
      world.createCollider(colliderDesc, body);
      
      worldObjects.push({ mesh, body });
    }
    
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      if (composer) {
        composer.setSize(window.innerWidth, window.innerHeight);
      }
    }
    
     function resetPlayer() {
       playerBody.setTranslation({ x: 0, y: 5, z: 0 });
       playerBody.setLinvel({ x: 0, y: 0, z: 0 });
       playerScale = CONFIG.PLAYER_DEFAULT_SCALE;
       yaw = 0;
       pitch = 0;
     }
    
    function toggleUI() {
      document.querySelectorAll('.ui-panel').forEach(panel => {
        if (panel.id !== 'viewport-panel' || viewportEquipped) {
          panel.classList.toggle('minimized');
        }
      });
      document.getElementById('hud-mini').classList.toggle('minimized');
    }
    
    function togglePortals() {
      portals.forEach(p => {
        p.a.visible = !p.a.visible;
        p.b.visible = !p.b.visible;
      });
    }
    
    function toggleJar() {
      // Cycle through states: 0 (not equipped) -> 1 (equipped/open) -> 2 (equipped/closed) -> 0
      jarState = (jarState + 1) % 3;
      
      if (jarState === 0) {
        // Put away jar
        jarVisible = false;
        console.log('Jar put away (J to equip and open)');
      } else if (jarState === 1) {
        // Equip and open jar
        jarVisible = true;
        console.log('Jar equipped and open (J to close)');
        
        // Animate lid opening (move up and rotate slightly)
        if (pluckJar && pluckJar.userData.lidGroup) {
          const lidGroup = pluckJar.userData.lidGroup;
          const jarHeight = pluckJar.userData.jarHeight || 0.5;
          const startY = lidGroup.position.y;
          const targetY = jarHeight + 0.15; // Move lid up
          const startRotZ = lidGroup.rotation.z;
          const targetRotZ = Math.PI * 0.15; // Slight tilt
          const duration = 300;
          const startTime = Date.now();
          
          function animateLidOpen() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const eased = 1 - Math.pow(1 - progress, 3); // Ease out cubic
            
            lidGroup.position.y = startY + (targetY - startY) * eased;
            lidGroup.rotation.z = startRotZ + (targetRotZ - startRotZ) * eased;
            
            if (progress < 1) {
              requestAnimationFrame(animateLidOpen);
            }
          }
          animateLidOpen();
        }
      } else if (jarState === 2) {
        // Close jar (keep equipped)
        jarVisible = true;
        console.log('Jar closed (J to put away)');
        
        // Animate lid closing (move down and straighten)
        if (pluckJar && pluckJar.userData.lidGroup) {
          const lidGroup = pluckJar.userData.lidGroup;
          const startY = lidGroup.position.y;
          const targetY = pluckJar.userData.lidClosedY || 0; // Back to closed position
          const startRotZ = lidGroup.rotation.z;
          const targetRotZ = 0; // No tilt
          const duration = 300;
          const startTime = Date.now();
          
          function animateLidClose() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const eased = 1 - Math.pow(1 - progress, 3); // Ease out cubic
            
            lidGroup.position.y = startY + (targetY - startY) * eased;
            lidGroup.rotation.z = startRotZ + (targetRotZ - startRotZ) * eased;
            
            if (progress < 1) {
              requestAnimationFrame(animateLidClose);
            }
          }
          animateLidClose();
        }
      }
    }
    
    function toggleGrassBlades() {
      grassBladesEnabled = !grassBladesEnabled;
      
      if (grassBladesEnabled) {
        console.log('Grass blades ENABLED (G to disable) - Reload chunks to see grass');
        // Regenerate all active chunks to add grass
        const chunksToReload = Array.from(activeChunks);
        chunksToReload.forEach(chunkKey => {
          unloadChunk(chunkKey);
          loadChunk(chunkKey);
        });
      } else {
        console.log('Grass blades DISABLED (G to enable) - Grass removed from chunks');
        // Remove grass from all active chunks
        scene.traverse(obj => {
          if (obj.userData && obj.userData.isGrass) {
            obj.visible = false;
            if (obj.parent) {
              obj.parent.remove(obj);
            }
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) obj.material.dispose();
          }
        });
      }
    }
    
    function updateStats() {
      const pos = playerBody.translation();
      const vel = playerBody.linvel();
      const speed = Math.sqrt(vel.x * vel.x + vel.z * vel.z);
      
      document.getElementById('stat-scale').textContent = playerScale.toFixed(2) + 'x';
      document.getElementById('stat-world-scale').textContent = worldScale.toFixed(2) + 'x';
      document.getElementById('stat-position').textContent = 
        `${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}`;
      document.getElementById('stat-velocity').textContent = speed.toFixed(1) + ' m/s';
      document.getElementById('stat-buildings').textContent = buildings.length;
      document.getElementById('stat-objects').textContent = worldObjects.length;
      
      frameCount++;
      const now = performance.now();
      if (now - lastFPSUpdate > 1000) {
        fpsValue = frameCount;
        document.getElementById('stat-fps').textContent = fpsValue;
        frameCount = 0;
        lastFPSUpdate = now;
      }
    }
    
      // ==================== LOD SYSTEM ====================
      const LOD_CONFIG = {
        SILL_DISTANCE: 20,  // AGGRESSIVE: Only show sills within 20m
        BUILDING_CULL_DISTANCE: 200, // Hide entire buildings beyond 200m
        TREE_LOD1_DISTANCE: 80,  // Switch to low-poly trees beyond 80m
        TREE_CULL_DISTANCE: 150, // Hide trees beyond 150m
        CAR_LOD1_DISTANCE: 60,   // Switch to low-poly cars beyond 60m
        CAR_CULL_DISTANCE: 120,  // Hide cars beyond 120m
        PEDESTRIAN_CULL_DISTANCE: 100, // Hide pedestrians beyond 100m
        DECORATION_CULL_DISTANCE: 80,  // Hide decorations beyond 80m
        GRASS_CULL_DISTANCE: 40,  // Hide grass beyond 40m
        UPDATE_INTERVAL: 200  // Update LOD every 200ms
      };
      let lastLODUpdate = 0;
     
     // Cache sills on first pass for faster LOD updates
     const sillCache = new Map(); // building mesh -> array of sill objects
     const lodFrustum = new THREE.Frustum();
     const lodViewProjectionMatrix = new THREE.Matrix4();
     
     function cacheBuildingSills() {
       buildings.forEach(building => {
         const sills = [];
         building.mesh.traverse(child => {
           if (child.userData.isSill && child.isMesh) {
             sills.push(child);
           }
         });
         if (sills.length > 0) {
           sillCache.set(building.mesh, sills);
         }
       });
       console.log(`Cached sills for ${sillCache.size} buildings, total ${Array.from(sillCache.values()).reduce((sum, arr) => sum + arr.length, 0)} sills`);
     }
     
     // ‚ö° OPTIMIZATION: Populate spatial grid with all buildings
     function populateSpatialGrid() {
       spatialGrid.clear();
       buildings.forEach(building => {
         if (building.mesh) {
           const pos = new THREE.Vector3();
           building.mesh.getWorldPosition(pos);
           spatialGrid.insert(building.mesh, pos);
         }
       });
       console.log(`‚ö° Spatial grid populated with ${buildings.length} buildings`);
     }
     
       function updateLOD(time) {
        // Throttle LOD updates
        if (time - lastLODUpdate < LOD_CONFIG.UPDATE_INTERVAL) return;
        lastLODUpdate = time;
        
        // Build sill cache and populate spatial grid on first run
        if (sillCache.size === 0 && buildings.length > 0) {
          cacheBuildingSills();
          populateSpatialGrid();
        }
        
        const camPos = new THREE.Vector3();
        camera.getWorldPosition(camPos);
        
        // Update frustum for culling
        camera.updateMatrixWorld();
        lodViewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        lodFrustum.setFromProjectionMatrix(lodViewProjectionMatrix);
        
        const sillDistSq = LOD_CONFIG.SILL_DISTANCE * LOD_CONFIG.SILL_DISTANCE;
        const cullDistSq = LOD_CONFIG.BUILDING_CULL_DISTANCE * LOD_CONFIG.BUILDING_CULL_DISTANCE;
        let sillsHidden = 0;
        let sillsVisible = 0;
        let buildingsCulled = 0;
        let buildingsSkipped = 0;
        
        // AGGRESSIVE: Update building LOD with spatial grid queries (OPTIMIZED)
        // Only check buildings within potential cull distance
        const nearbyBuildingMeshes = spatialGrid.queryRadius(camPos, LOD_CONFIG.BUILDING_CULL_DISTANCE);
        
        nearbyBuildingMeshes.forEach(buildingMesh => {
          const building = buildings.find(b => b.mesh === buildingMesh);
          if (!building || !building.mesh) return;
          
          const buildingPos = new THREE.Vector3();
          building.mesh.getWorldPosition(buildingPos);
          
          // Quick distance check first
          const distSq = camPos.distanceToSquared(buildingPos);
          
          // AGGRESSIVE: Hide entire buildings beyond cull distance
          if (distSq > cullDistSq) {
            building.mesh.visible = false;
            buildingsCulled++;
            return;
          }
          
          building.mesh.visible = true;
          
          // Skip if too far for detail processing
          if (distSq > sillDistSq * 16) { // 4x sill distance for early exit
            buildingsSkipped++;
            // Still hide sills
            const sills = sillCache.get(building.mesh);
            if (sills) {
              sills.forEach(sill => {
                sill.visible = false;
                sillsHidden++;
              });
            }
            return;
          }
          
          // Frustum culling (with safety check for geometry)
          try {
            if (building.mesh.geometry && building.mesh.geometry.boundingSphere) {
          if (!lodFrustum.intersectsObject(building.mesh)) {
            buildingsSkipped++;
            // Hide all details for buildings not in view
            building.mesh.traverse(child => {
              if (child.userData.isSill || child.userData.isDecoration) {
                child.visible = false;
                if (child.userData.isSill) sillsHidden++;
              }
            });
            return;
              }
            }
          } catch (e) {
            // Skip frustum culling if geometry is invalid
          }
          
          // AGGRESSIVE: Only show sills within very close range
          const showSills = distSq < sillDistSq;
          
          // Hide ALL decorations and sills beyond sill distance
          building.mesh.traverse(child => {
            if (child.userData.isSill) {
              child.visible = showSills;
              if (showSills) sillsVisible++;
              else sillsHidden++;
            } else if (child.userData.isDecoration) {
              child.visible = showSills; // Also hide decorations
            }
          });
        });
        
        // === COMPREHENSIVE WORLD OBJECT CULLING ===
        let objectsCulled = 0;
        let objectsVisible = 0;
        
        // Cull pedestrians
        const pedestrianCullDistSq = LOD_CONFIG.PEDESTRIAN_CULL_DISTANCE * LOD_CONFIG.PEDESTRIAN_CULL_DISTANCE;
        worldRoot.traverse(obj => {
          if (obj.userData.isPedestrian && obj.isMesh) {
            const distSq = camPos.distanceToSquared(obj.position);
            const shouldShow = distSq < pedestrianCullDistSq && lodFrustum.intersectsObject(obj);
            if (obj.visible !== shouldShow) {
              obj.visible = shouldShow;
              if (shouldShow) objectsVisible++; else objectsCulled++;
            }
          }
        });
        
        // Cull grass
        const grassCullDistSq = LOD_CONFIG.GRASS_CULL_DISTANCE * LOD_CONFIG.GRASS_CULL_DISTANCE;
        worldRoot.traverse(obj => {
          if (obj.userData.isGrass && obj.isMesh) {
            const distSq = camPos.distanceToSquared(obj.position);
            const shouldShow = distSq < grassCullDistSq;
            if (obj.visible !== shouldShow) {
              obj.visible = shouldShow;
              if (shouldShow) objectsVisible++; else objectsCulled++;
            }
          }
        });
        
        // Cull decorations (signs, benches, etc)
        const decorationCullDistSq = LOD_CONFIG.DECORATION_CULL_DISTANCE * LOD_CONFIG.DECORATION_CULL_DISTANCE;
        worldRoot.traverse(obj => {
          if (obj.userData.isDecoration && obj.isMesh && !obj.parent?.userData?.isBuilding) {
            const distSq = camPos.distanceToSquared(obj.position);
            const shouldShow = distSq < decorationCullDistSq && lodFrustum.intersectsObject(obj);
            if (obj.visible !== shouldShow) {
              obj.visible = shouldShow;
              if (shouldShow) objectsVisible++; else objectsCulled++;
            }
          }
        });
        
        // LOD and cull trees (if using instanced trees, handle differently)
        const treeLOD1DistSq = LOD_CONFIG.TREE_LOD1_DISTANCE * LOD_CONFIG.TREE_LOD1_DISTANCE;
        const treeCullDistSq = LOD_CONFIG.TREE_CULL_DISTANCE * LOD_CONFIG.TREE_CULL_DISTANCE;
        worldRoot.traverse(obj => {
          if (obj.userData.isTree && obj.visible) {
            const distSq = camPos.distanceToSquared(obj.position);
            
            // Cull far trees
            if (distSq > treeCullDistSq) {
              obj.visible = false;
              objectsCulled++;
              return;
            }
            
            // Switch LOD for mid-range trees (if LOD geometry exists)
            if (obj.userData.lodLevels) {
              if (distSq > treeLOD1DistSq && obj.userData.currentLOD !== 'low') {
                // Switch to low-poly
                if (obj.userData.lodLevels.low) {
                  obj.geometry = obj.userData.lodLevels.low;
                  obj.userData.currentLOD = 'low';
                }
              } else if (distSq <= treeLOD1DistSq && obj.userData.currentLOD !== 'high') {
                // Switch to high-poly
                if (obj.userData.lodLevels.high) {
                  obj.geometry = obj.userData.lodLevels.high;
                  obj.userData.currentLOD = 'high';
                }
              }
            }
            
            objectsVisible++;
          }
        });
        
        // LOD and cull cars
        const carLOD1DistSq = LOD_CONFIG.CAR_LOD1_DISTANCE * LOD_CONFIG.CAR_LOD1_DISTANCE;
        const carCullDistSq = LOD_CONFIG.CAR_CULL_DISTANCE * LOD_CONFIG.CAR_CULL_DISTANCE;
        worldRoot.traverse(obj => {
          if (obj.userData.isCar && obj.visible) {
            const distSq = camPos.distanceToSquared(obj.position);
            
            // Cull far cars
            if (distSq > carCullDistSq || !lodFrustum.intersectsObject(obj)) {
              obj.visible = false;
              objectsCulled++;
              return;
            }
            
            // Switch LOD for mid-range cars
            if (obj.userData.lodLevels) {
              if (distSq > carLOD1DistSq && obj.userData.currentLOD !== 'low') {
                if (obj.userData.lodLevels.low) {
                  obj.geometry = obj.userData.lodLevels.low;
                  obj.userData.currentLOD = 'low';
                }
              } else if (distSq <= carLOD1DistSq && obj.userData.currentLOD !== 'high') {
                if (obj.userData.lodLevels.high) {
                  obj.geometry = obj.userData.lodLevels.high;
                  obj.userData.currentLOD = 'high';
                }
              }
            }
            
            objectsVisible++;
          }
        });
        
        // Log stats every 3 seconds
        if (time % 3000 < LOD_CONFIG.UPDATE_INTERVAL) {
          console.log(`LOD: ${sillsVisible} sills visible, ${sillsHidden} hidden, ${buildingsCulled} buildings culled, ${objectsCulled} objects culled, ${objectsVisible} objects visible`);
        }
      }
    
    // ==================== ANIMATION LOOP ====================
    let lastTime = 0;
    
    function animate(time) {
      requestAnimationFrame(animate);
      
      // ‚ö° OPTIMIZATION: Update performance monitor
      perfMonitor.update();
      
      const deltaTime = Math.min((time - lastTime) / 1000, 0.05);
      lastTime = time;
      
      if (deltaTime === 0) return;
      
      // Check if rocket is in space to skip expensive updates
      const rocketInSpace = rocketEnabled && rocketBody && rocketBody.translation().y > ATMOSPHERE_ALTITUDE;
      
       // GPU Optimizations - Shadow Updates & Material Swapping
       // SKIP when in space (shadows already disabled)
       if (!rocketInSpace) {
         const camPos = new THREE.Vector3();
         camera.getWorldPosition(camPos);
         updateShadowCasters(camPos);
         updateDynamicShadowBounds(camPos);
         updateMaterialSwapping(camPos); // AGGRESSIVE: Swap distant objects to MeshBasicMaterial
       }
      
       // Update chunk streaming (SKIP when in space - micro LOD handles it)
       if (!rocketInSpace) {
         updateChunks();
       }
       
       // Update LOD system (sills and decorations) - SKIP when in space
       if (!rocketInSpace) {
         updateLOD(time);
       }
       
       // Update THREE.LOD objects (buildings) - SKIP when in space
       if (!rocketInSpace) {
         worldRoot.traverse((obj) => {
           if (obj.isLOD) {
             obj.update(camera);
           }
         });
       }
       
       // Update doors (proximity-based opening) - SKIP when in space
       if (!rocketInSpace) {
         updateDoors(deltaTime);
       }
       
       // Update grappling hook and swing rope physics
       updateGrapplePhysics(deltaTime);
       updateSwingPhysics(deltaTime);
       
       // Update grass shader time
       scene.traverse(obj => {
         if (obj.userData.isGrass && obj.userData.material) {
           obj.userData.material.uniforms.time.value = time * 0.001;
         }
       });
       
       // Physics step
       world.step();
       
       // Update rope visual
       updateRopeVisual();
       
      // Update bike (only when not in rocket mode)
      if (!rocketEnabled) {
        updateBike(deltaTime);
      }
      
      // Update rocket
      updateRocket(deltaTime);
      
      // Update day/night cycle
      currentDayTime = (currentDayTime + deltaTime) % DAY_DURATION;
      
      // Update pedestrians (only when not in rocket mode)
      if (!rocketEnabled) {
        updatePedestrians(deltaTime);
      }
      
      // CULL ALL PEDESTRIANS IN SPACE (above clouds)
      if (rocketInSpace) {
        // Hide all pedestrian groups (detailed animated meshes)
        pedestrians.forEach(ped => {
          if (ped.group && ped.group.visible) {
            ped.group.visible = false;
          }
          // Hide LOD meshes too
          if (ped.lodMesh && ped.lodMesh.visible) {
            ped.lodMesh.visible = false;
          }
        });
        
        // Hide instanced LOD pedestrians
        if (instancedManagers.pedestriansLOD && instancedManagers.pedestriansLOD.mesh) {
          instancedManagers.pedestriansLOD.mesh.visible = false;
        }
      } else {
        // Restore instanced LOD pedestrians visibility when not in space
        if (instancedManagers.pedestriansLOD && instancedManagers.pedestriansLOD.mesh) {
          instancedManagers.pedestriansLOD.mesh.visible = optimizationConfig.pedestrians.enabled;
        }
      }
      
      // Update ants
      updateAnts(deltaTime);
      
      // Update hallway
      updateHallway();
       
       // Update playground spinners - SKIP when in space
       if (!rocketInSpace) {
         scene.traverse(obj => {
           if (obj.userData.spinner) {
             obj.userData.spinner.rotation.y += obj.userData.spinner.userData.spinSpeed * deltaTime;
           }
         });
       }
       
       // Update clouds - SKIP when in space (not visible anyway)
       if (!rocketInSpace) {
         updateClouds(deltaTime);
       }
       
       // Update motion blur
       if (motionBlurPass && motionBlurEnabled) {
         const vel = bikeEnabled && bikeBody ? bikeBody.linvel() : (playerBody ? playerBody.linvel() : { x: 0, y: 0, z: 0 });
         const speed = Math.sqrt(vel.x * vel.x + vel.y * vel.y + vel.z * vel.z);
         
         // Calculate camera rotation change
         const cameraDelta = new THREE.Vector3().subVectors(camera.position, prevCameraPosition);
         const rotationDelta = new THREE.Euler().setFromQuaternion(camera.quaternion);
         const rotationChange = Math.abs(rotationDelta.x - prevCameraRotation.x) + 
                                Math.abs(rotationDelta.y - prevCameraRotation.y);
         
         // Subtle blur from speed and camera rotation
         let blurIntensity = 0;
         if (speed > 12) {
           blurIntensity = Math.min(speed / 25, 1.5);
         }
         blurIntensity += rotationChange * 30;
         
         // Extra blur when swinging
         if (swingRope && swingRope.active) {
           blurIntensity *= 1.3;
         }
         
         // Direction of blur
         const blurDirection = new THREE.Vector2(
           (rotationDelta.y - prevCameraRotation.y) * 8,
           -(rotationDelta.x - prevCameraRotation.x) * 8
         );
         
         motionBlurPass.uniforms.velocityFactor.value = blurIntensity;
         motionBlurPass.uniforms.delta.value.copy(blurDirection);
         
         prevCameraPosition.copy(camera.position);
         prevCameraRotation.copy(rotationDelta);
       }
      
      // Player movement (skip if bike or rocket is enabled)
      if (playerBody && !bikeEnabled && !rocketEnabled) {
        const pos = playerBody.translation();
        const vel = playerBody.linvel();
        
        // Camera rotation
        const quat = new THREE.Quaternion();
        quat.setFromEuler(new THREE.Euler(pitch, yaw, 0, 'YXZ'));
        
        // Movement
        const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(quat);
        const right = new THREE.Vector3(1, 0, 0).applyQuaternion(quat);
        forward.y = 0;
        right.y = 0;
        forward.normalize();
        right.normalize();
        
        const inputVec = new THREE.Vector3();
        if (keys.has('KeyW')) inputVec.add(forward);
        if (keys.has('KeyS')) inputVec.sub(forward);
        if (keys.has('KeyD')) inputVec.add(right);
        if (keys.has('KeyA')) inputVec.sub(right);
        
        if (inputVec.length() > 0) {
          inputVec.normalize();
          // Movement speed accounts for both player and world scale
          // When world is scaled up, player moves proportionally faster relative to it
          const effectiveScale = playerScale / worldScale;
          const baseSpeed = CONFIG.MOVE_SPEED * effectiveScale;
          // Ensure minimum movement speed even at tiny scales
          const minSpeed = 0.5; // Minimum speed to ensure player can always move
          const speed = Math.max(minSpeed, baseSpeed) * 
            (keys.has('ShiftLeft') || keys.has('ShiftRight') ? CONFIG.SPRINT_MULTIPLIER : 1);
          inputVec.multiplyScalar(speed);
          playerBody.setLinvel({ x: inputVec.x, y: vel.y, z: inputVec.z }, true);
        } else {
          // Apply friction when not moving to stop sliding
          playerBody.setLinvel({ x: vel.x * 0.85, y: vel.y, z: vel.z * 0.85 }, true);
        }
        
        // Jump - account for effective scale
        if (keys.has('Space') && Math.abs(vel.y) < 0.1) {
          const effectiveScale = playerScale / worldScale;
          const jumpForce = Math.max(2.0, CONFIG.JUMP_FORCE * effectiveScale);
          playerBody.applyImpulse({ x: 0, y: jumpForce, z: 0 }, true);
          keys.delete('Space');
        }
        
        // Dynamic Scale System (player + world scale)
        const prevWorldScale = worldScale;
        
        if (keys.has('KeyQ')) {
          // Growing: First reduce world scale back to 1.0, then increase player scale
          if (worldScale > 1.0) {
            // Reduce world scale first - slower for more incremental feel
            const reductionRate = CONFIG.GROW_RATE * 0.3; // Slow, incremental world scale reduction
            worldScale = Math.max(1.0, worldScale - reductionRate * deltaTime);
          } else {
            // Once world scale is back to 1.0, grow player
          playerScale = Math.min(CONFIG.PLAYER_MAX_SCALE, playerScale + CONFIG.GROW_RATE * deltaTime);
          }
        }
        if (keys.has('KeyE')) {
          // Shrinking: First reduce player scale to threshold, then increase world scale
          if (playerScale > CONFIG.SCALE_TRANSITION_THRESHOLD) {
            // Shrink player normally
            playerScale = Math.max(CONFIG.SCALE_TRANSITION_THRESHOLD, playerScale - CONFIG.SHRINK_RATE * deltaTime);
          } else {
            // Once player hits threshold, start scaling world up instead - slower for more incremental feel
            const worldScaleRate = CONFIG.SHRINK_RATE * 0.5; // Slow, incremental world scaling
            worldScale = Math.min(CONFIG.WORLD_MAX_SCALE, worldScale + worldScaleRate * deltaTime);
          }
        }
        
        // Apply world scale to worldRoot (scales everything except player)
        // Scale FROM the player's position as the anchor point
        if (worldRoot) {
          const currentPos = playerBody.translation();
          
          // Scale worldRoot uniformly
          worldRoot.scale.setScalar(worldScale);
          
          // Offset worldRoot position so scaling happens relative to player position
          // This makes objects scale away from the player while the player stays fixed
          // Formula: worldRoot.position = playerPos - (playerPos * worldScale)
          // This keeps the player at the same relative position while the world scales around them
          worldRoot.position.set(
            currentPos.x - (currentPos.x * worldScale),
            currentPos.y - (currentPos.y * worldScale),
            currentPos.z - (currentPos.z * worldScale)
          );
        }
        
        // Dynamic FOV based on effective scale (player scale / world scale)
        const effectiveScale = playerScale / worldScale;
        // Smaller effective scale = wider FOV for better situational awareness
        // Larger effective scale = narrower FOV for more zoomed-in feel
        const fovScale = Math.log10(effectiveScale + 0.1) / 2; // Logarithmic scaling
        const targetFov = THREE.MathUtils.clamp(
          CONFIG.BASE_FOV - fovScale * 30, 
          CONFIG.MIN_FOV, 
          CONFIG.MAX_FOV
        );
        camera.fov = THREE.MathUtils.lerp(camera.fov, targetFov, 0.1);
        camera.updateProjectionMatrix();
        
        // Update camera height - properly scales with player (exponential for dramatic effect)
        const scaleExponent = 3.0; // Makes scale changes more dramatic
        let cameraHeight = CONFIG.PLAYER_HEIGHT * 0.4 * Math.pow(playerScale, scaleExponent);
        
        // When world scaling is active, set camera to nearly floor level
        if (worldScale > 1.0) {
          // Camera near floor level during world scale (0.05m above ground)
          const floorLevelHeight = 0.05;
          cameraHeight = floorLevelHeight;
        }
        
        camera.position.set(
          pos.x, 
          pos.y + cameraHeight, 
          pos.z
        );
        camera.quaternion.copy(quat);
        
        // Update player visual
        player.position.set(pos.x, pos.y, pos.z);
        player.scale.setScalar(playerScale);
      }
      
      // Apply optimization config visibility settings to instanced meshes
      if (instancedManagers.windows && instancedManagers.windows.mesh) {
        instancedManagers.windows.mesh.visible = optimizationConfig.windows.enabled;
      }
      if (instancedManagers.sills && instancedManagers.sills.mesh) {
        instancedManagers.sills.mesh.visible = optimizationConfig.sills.enabled;
      }
      if (instancedManagers.pedestriansLOD && instancedManagers.pedestriansLOD.mesh) {
        instancedManagers.pedestriansLOD.mesh.visible = optimizationConfig.pedestrians.enabled;
      }
      
      // Control individual pedestrian groups visibility
      pedestrians.forEach(ped => {
        if (ped.group) {
          ped.group.visible = optimizationConfig.pedestrians.enabled;
        }
      });
      
      // Control individual windows and sills visibility (throttled to avoid performance hit)
      // Only check every 100ms instead of every frame
      if (!window._lastWindowSillUpdate || time - window._lastWindowSillUpdate > 100) {
        window._lastWindowSillUpdate = time;
        
        buildings.forEach(building => {
          if (building.mesh) {
            building.mesh.traverse(child => {
              if (child.userData.isWindow) {
                child.visible = optimizationConfig.windows.enabled;
              }
              if (child.userData.isSill) {
                child.visible = optimizationConfig.sills.enabled;
              }
            });
          }
        });
        
        // Also check chunks for windows/sills
        chunkRoots.forEach(chunkRoot => {
          chunkRoot.traverse(child => {
            if (child.userData.isWindow) {
              child.visible = optimizationConfig.windows.enabled;
            }
            if (child.userData.isSill) {
              child.visible = optimizationConfig.sills.enabled;
            }
          });
        });
      }
      
      // Control grass visibility (grass uses shader, not instanced mesh)
      if (instancedManagers.grass && instancedManagers.grass.mesh) {
        instancedManagers.grass.mesh.visible = optimizationConfig.grass.enabled;
      }
      // Also hide all individual grass blades
      scene.traverse(obj => {
        if (obj.userData.isGrass) {
          obj.visible = optimizationConfig.grass.enabled;
        }
      });
      
      // Update world objects physics (skip objects being dragged)
      worldObjects.forEach(obj => {
        if (!suppressedPhysics.has(obj.mesh)) {
          const pos = obj.body.translation();
          const rot = obj.body.rotation();
          obj.mesh.position.set(pos.x, pos.y, pos.z);
          obj.mesh.quaternion.set(rot.x, rot.y, rot.z, rot.w);
        }
      });
      
      // Update dynamic building physics
      buildings.forEach(building => {
        if (building.isDynamic && building.body && !suppressedPhysics.has(building.mesh)) {
          const pos = building.body.translation();
          const rot = building.body.rotation();
          building.mesh.position.set(pos.x, pos.y, pos.z);
          building.mesh.quaternion.set(rot.x, rot.y, rot.z, rot.w);
        }
      });
      
      // Update jar objects (objects collected into jar)
      // Note: jarObjects persists even when jar is put away (jarState === 0)
      // This allows objects to remain in the jar across equip/unequip cycles
      const jarEnv = pluckJar ? pluckJar.userData.environment : null;
      jarObjects.forEach((jarObj, index) => {
        if (!jarObj.mesh) {
          jarObjects.splice(index, 1);
          return;
        }
        
        // Ensure objects stay parented to jar environment
        if (jarEnv && jarObj.mesh.parent !== jarEnv) {
          jarEnv.add(jarObj.mesh);
        }
        
        // Ensure pedestrians in jar keep their flags so worldScale doesn't get reapplied
        if (jarObj.isPedestrian) {
          jarObj.mesh.userData.isPlucked = true;
          jarObj.mesh.userData.isInJar = true;
        }
        
        // Keep scale consistent
        if (jarObj.originalScale) {
          jarObj.mesh.scale.copy(jarObj.originalScale);
        }
        
        // Make visible/invisible based on jar visibility
        jarObj.mesh.visible = pluckJar.visible;
      });
      
      // Update jar physics (shaking, uprighting, walking)
      updateJarPhysics(deltaTime);
      
      // Update dialogue cards (billboarded speech bubbles)
      updateDialogueCards();
      
      // Update character Y physics
      if (characterY && characterY.visible && characterYBody) {
        const pos = characterYBody.translation();
        const rot = characterYBody.rotation();
        characterY.position.set(pos.x, pos.y, pos.z);
        characterY.quaternion.set(rot.x, rot.y, rot.z, rot.w);
      }
      
      // Update pedestrian physics bodies (for dropped pedestrians)
      // Skip pedestrians in the jar - they're handled by jar objects loop above
      pedestrians.forEach(ped => {
        if (ped.physicsBody && !suppressedPhysics.has(ped.group) && !ped.group.userData.isDragging && !ped.group.userData.isInJar) {
          const pos = ped.physicsBody.translation();
          const rot = ped.physicsBody.rotation();
          ped.group.position.set(pos.x, pos.y, pos.z);
          ped.group.quaternion.set(rot.x, rot.y, rot.z, rot.w);
        }
      });
      
      // Portal teleportation
      checkPortalTeleport();
      
      // Update pluck jar position (screen-space, left side)
      if (pluckJar) {
        // Show jar when toggled with J key
        pluckJar.visible = jarVisible;
        
        // Enable/disable jar physics based on visibility
        if (pluckJar.userData.physicsBody) {
          pluckJar.userData.physicsBody.setEnabled(jarVisible, true);
        }
        
        if (pluckJar.visible) {
          // Calculate screen-space position
          const camPos = new THREE.Vector3();
          camera.getWorldPosition(camPos);
          
          const camRight = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
          const camForward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
          const camUp = new THREE.Vector3(0, 1, 0).applyQuaternion(camera.quaternion);
          
          // Position jar based on inspect mode
          let jarDistance, jarOffsetLeft, jarOffsetDown;
          
          if (jarInspectMode) {
            // INSPECT MODE: Bring jar closer and center it
            jarDistance = 0.4; // Much closer to viewport
            jarOffsetLeft = 0; // Centered horizontally
            jarOffsetDown = -0.1; // Slightly below center
          } else {
            // NORMAL MODE: Position jar on left side (holding in hand)
            jarDistance = 1.0; // Same depth as plucked objects
            jarOffsetLeft = -0.4; // Left offset in screen space
            jarOffsetDown = -0.45; // Down offset in screen space
          }
          
          // Position jar in screen-space with shake animation offsets
          pluckJar.position.copy(camPos)
            .addScaledVector(camForward, jarDistance)
            .addScaledVector(camRight, jarOffsetLeft + jarShakeOffsetX) // Apply horizontal shake
            .addScaledVector(camUp, jarOffsetDown + jarBaseOffsetY); // Apply vertical shake
          
          // Keep jar ALWAYS upright relative to world up axis (0,1,0)
          // Calculate yaw to face camera direction in XZ plane only, keeping Y-up
          const forwardXZ = new THREE.Vector3(camForward.x, 0, camForward.z).normalize();
          const yawQuat = new THREE.Quaternion();
          if (forwardXZ.lengthSq() > 0.001) {
            yawQuat.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.atan2(forwardXZ.x, forwardXZ.z));
          }
          pluckJar.quaternion.copy(yawQuat);
          
          // Update jar physics body position to match visual (including shake offset)
          if (pluckJar.userData.physicsBody) {
            const jarPos = pluckJar.position;
            const jarHeight = pluckJar.userData.jarHeight || 0.5;
            // Position physics body at jar center (jar visual is at bottom)
            // Note: shake offset is already included in jarPos
            pluckJar.userData.physicsBody.setTranslation(
              { x: jarPos.x, y: jarPos.y + jarHeight / 2, z: jarPos.z }, 
              true
            );
            // Match rotation
            pluckJar.userData.physicsBody.setRotation(
              { x: yawQuat.x, y: yawQuat.y, z: yawQuat.z, w: yawQuat.w },
              true
            );
          }
          
          // Update splatter drip animations
          const now = performance.now();
          pluckJar.traverse(child => {
            if (child.userData.isSplatter && child.userData.isAnimating && child.userData.drip) {
              const elapsed = now - child.userData.dripStartTime;
              const t = Math.min(elapsed / child.userData.dripDuration, 1.0);
              
              if (t >= 1.0) {
                // Animation complete, stop updating
                child.userData.isAnimating = false;
                child.userData.drip.scale.y = 1.0; // Final drip length
              } else {
                // Ease-out cubic for smooth deceleration (starts fast, slows down)
                const eased = 1 - Math.pow(1 - t, 3);
                
                // Scale drip vertically to extend from bottom of splatter
                child.userData.drip.scale.y = eased;
              }
            }
          });
        }
      }
      
      // Update held viewport
      if (heldViewport && heldViewport.visible) {
        const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
        heldViewport.position.copy(camera.position).addScaledVector(forward, heldViewportDist);
        heldViewport.quaternion.copy(camera.quaternion);
      }
      
      // Update viewport hand (holds dropped viewport frame)
      updateViewportHand();
      
      // Update viewport locks
      if (viewportActive && viewportLocked.size > 0) {
        const camPos = new THREE.Vector3();
        camera.getWorldPosition(camPos);
        
        viewportLocked.forEach(obj => {
          const lock = obj.userData.viewportLock;
          if (!lock) return;
          
          const targetWorld = new THREE.Vector3(lock.ndc.x, lock.ndc.y, 0.5).unproject(camera);
          const dir = targetWorld.sub(camPos).normalize();
          const newWorldPos = camPos.clone().addScaledVector(dir, lock.dist0);
          
          obj.position.copy(newWorldPos);
          
          const k = lock.dist0 / Math.max(0.0001, lock.dist0);
          obj.scale.copy(lock.scale0);
        });
      }
      
      // Render dropped viewport
      if (droppedViewport && droppedViewportRT && droppedViewportCam) {
        const n = new THREE.Vector3(0, 0, -1).applyQuaternion(droppedViewport.quaternion);
        droppedViewportCam.position.copy(droppedViewport.position).addScaledVector(n, 0.05);
        droppedViewportCam.quaternion.copy(droppedViewport.quaternion);
        
        renderer.setRenderTarget(droppedViewportRT);
        renderer.render(scene, droppedViewportCam);
        renderer.setRenderTarget(null);
        
        // Copy to HUD canvas
        const canvas = document.getElementById('hud-mini-canvas');
        const ctx = canvas.getContext('2d');
        const pixels = new Uint8Array(droppedViewportRT.width * droppedViewportRT.height * 4);
        renderer.readRenderTargetPixels(droppedViewportRT, 0, 0, droppedViewportRT.width, droppedViewportRT.height, pixels);
        
        const imageData = new ImageData(new Uint8ClampedArray(pixels), droppedViewportRT.width, droppedViewportRT.height);
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = droppedViewportRT.width;
        tempCanvas.height = droppedViewportRT.height;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.putImageData(imageData, 0, 0);
        
        ctx.save();
        ctx.scale(1, -1);
        ctx.drawImage(tempCanvas, 0, -canvas.height, canvas.width, canvas.height);
        ctx.restore();
      }
      
      // Update pluck candidates only when camera moves significantly (optimization)
      // Removed from animation loop - now called only on mode toggle
      
      // Update map overlay if loaded
      if (mapOverlay) {
        mapOverlay.updateVisitedBuildings();
        mapOverlay.renderIfVisible();
      }
      
      // Update stats
      updateStats();
      
      // Render
      if (postFXEnabled && composer) {
        composer.render();
      } else {
        renderer.render(scene, camera);
      }
    }
    
    function checkPortalTeleport() {
      if (!playerBody || portals.length === 0) return;
      
      const pos = playerBody.translation();
      const playerPos = new THREE.Vector3(pos.x, pos.y, pos.z);
      
      portals.forEach(portalPair => {
        const distA = playerPos.distanceTo(portalPair.a.position);
        const distB = playerPos.distanceTo(portalPair.b.position);
        
        if (distA < portalPair.radius) {
          const offset = new THREE.Vector3().subVectors(playerPos, portalPair.a.position);
          const newPos = new THREE.Vector3().addVectors(portalPair.b.position, offset);
          playerBody.setTranslation(newPos, true);
          playerScale *= portalPair.scale;
        } else if (distB < portalPair.radius) {
          const offset = new THREE.Vector3().subVectors(playerPos, portalPair.b.position);
          const newPos = new THREE.Vector3().addVectors(portalPair.a.position, offset);
          playerBody.setTranslation(newPos, true);
          playerScale /= portalPair.scale;
        }
      });
    }
    
    // ==================== INTERIOR MODE TOGGLE ====================
    // toggleInteriorsMode and clearInteriorRoom already defined earlier in the file (commented out section around line 16290)
    // Using the new panel-based version with policy generation
    
    // ==================== UI EVENT LISTENERS ====================
    function setupInteriorUIListeners() {
      // Apartment size selection
      document.getElementById('btn-apt-studio')?.addEventListener('click', () => {
        selectedApartmentSize = 'STUDIO';
        // Update button styles
        ['btn-apt-studio', 'btn-apt-1br', 'btn-apt-2br', 'btn-apt-3br'].forEach(id => {
          const btn = document.getElementById(id);
          if (btn) btn.classList.remove('active');
        });
        document.getElementById('btn-apt-studio').classList.add('active');
      });
      
      document.getElementById('btn-apt-1br')?.addEventListener('click', () => {
        selectedApartmentSize = '1BR';
        ['btn-apt-studio', 'btn-apt-1br', 'btn-apt-2br', 'btn-apt-3br'].forEach(id => {
          const btn = document.getElementById(id);
          if (btn) btn.classList.remove('active');
        });
        document.getElementById('btn-apt-1br').classList.add('active');
      });
      
      document.getElementById('btn-apt-2br')?.addEventListener('click', () => {
        selectedApartmentSize = '2BR';
        ['btn-apt-studio', 'btn-apt-1br', 'btn-apt-2br', 'btn-apt-3br'].forEach(id => {
          const btn = document.getElementById(id);
          if (btn) btn.classList.remove('active');
        });
        document.getElementById('btn-apt-2br').classList.add('active');
      });
      
      document.getElementById('btn-apt-3br')?.addEventListener('click', () => {
        selectedApartmentSize = '3BR';
        ['btn-apt-studio', 'btn-apt-1br', 'btn-apt-2br', 'btn-apt-3br'].forEach(id => {
          const btn = document.getElementById(id);
          if (btn) btn.classList.remove('active');
        });
        document.getElementById('btn-apt-3br').classList.add('active');
      });
      
      // Generation buttons
      document.getElementById('btn-gen-apartment')?.addEventListener('click', () => {
        console.log(`Generating ${selectedApartmentSize} apartment...`);
        generateInteriorFromPolicy(INTERIOR_POLICIES[selectedApartmentSize]);
      });
      
      document.getElementById('btn-gen-office')?.addEventListener('click', () => {
        console.log('Generating office space...');
        generateInteriorFromPolicy(INTERIOR_POLICIES.OFFICE);
      });
      
      document.getElementById('btn-gen-classroom')?.addEventListener('click', () => {
        console.log('Generating classroom...');
        generateInteriorFromPolicy(INTERIOR_POLICIES.CLASSROOM);
      });
      
      document.getElementById('btn-gen-gymnasium')?.addEventListener('click', () => {
        console.log('Generating gymnasium...');
        generateInteriorFromPolicy(INTERIOR_POLICIES.GYMNASIUM);
      });
      
      document.getElementById('btn-gen-cellblock')?.addEventListener('click', () => {
        console.log('Generating cell block...');
        generateInteriorFromPolicy(INTERIOR_POLICIES.CELLBLOCK);
      });
      
      document.getElementById('btn-clear-interior')?.addEventListener('click', () => {
        console.log('Clearing interior...');
        clearInteriorRoom();
      });
      
      document.getElementById('btn-randomize-interior')?.addEventListener('click', () => {
        console.log('Randomizing interior...');
        const policyKeys = Object.keys(INTERIOR_POLICIES);
        const randomPolicy = INTERIOR_POLICIES[policyKeys[Math.floor(Math.random() * policyKeys.length)]];
        generateInteriorFromPolicy(randomPolicy);
      });
      
      // Set default apartment size button as active
      document.getElementById('btn-apt-1br')?.classList.add('active');
      
      console.log('‚úì Interior UI listeners initialized');
    }
    
    // ==================== START ====================
    init().catch(console.error);
    
    // Setup UI listeners after DOM is loaded
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        setupInteriorUIListeners();
        console.log('‚úì Interior UI setup complete');
      });
    } else {
      setupInteriorUIListeners();
      console.log('‚úì Interior UI setup complete');
    }
  
