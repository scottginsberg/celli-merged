<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Creator / Creation / Consumer</title>
<style>
  html,body{
    margin:0;
    height:100%;
    background:#000;
    color:#fff;
    font-family:system-ui, sans-serif;
    overflow:hidden;
  }
  canvas { display:block; }
  #spotify-player {
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 300px;
    max-width: 90%;
    z-index: 1000;
    opacity: 0.95;
    pointer-events: auto;
  }
  #spotify-player iframe {
    position: relative;
    z-index: 1;
  }
  #spotify-mask {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: #000;
    pointer-events: auto;
    z-index: 2;
    transition: opacity 0.5s ease;
    -webkit-mask-image: radial-gradient(circle 26px at calc(100% - 36px) calc(100% - 36px), transparent 0%, transparent 26px, black 27px);
    mask-image: radial-gradient(circle 26px at calc(100% - 36px) calc(100% - 36px), transparent 0%, transparent 26px, black 27px);
  }
  #spotify-mask.hidden {
    opacity: 0;
    pointer-events: none;
  }
  #play-button-cutout {
    position: absolute;
    bottom: 16px;
    right: 16px;
    width: 40px;
    height: 40px;
    background: transparent;
    border-radius: 50%;
    z-index: 3;
    pointer-events: none;
    transition: all 0.3s ease;
    box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.3), 0 0 20px rgba(102, 126, 234, 0.6);
    animation: pulse 2s ease-in-out infinite;
  }
  #play-button-cutout.hidden {
    opacity: 0;
  }
  #play-button-overlay {
    position: absolute;
    bottom: 12px;
    right: 12px;
    width: 48px;
    height: 48px;
    background: transparent;
    border-radius: 50%;
    z-index: 3;
    cursor: pointer;
    pointer-events: auto;
  }
  #play-button-overlay.hidden {
    pointer-events: none;
  }
  #play-hint {
    position: absolute;
    bottom: 20px;
    right: 70px;
    color: rgba(255, 255, 255, 0.9);
    font-family: monospace;
    font-size: 13px;
    font-weight: bold;
    z-index: 3;
    pointer-events: none;
    white-space: nowrap;
    text-shadow: 0 2px 8px rgba(0, 0, 0, 0.8);
    animation: fadeInOut 3s ease-in-out infinite;
    transition: opacity 0.3s ease;
  }
  #play-hint.hidden {
    opacity: 0;
  }
  @keyframes fadeInOut {
    0%, 100% { opacity: 0.5; }
    50% { opacity: 1; }
  }
  @keyframes pulse {
    0%, 100% {
      box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.3), 0 0 20px rgba(102, 126, 234, 0.6);
    }
    50% {
      box-shadow: 0 0 0 5px rgba(255, 255, 255, 0.5), 0 0 35px rgba(102, 126, 234, 0.9);
    }
  }
  #controls-panel {
    position: fixed;
    top: 20px;
    right: 20px;
    background: rgba(0, 0, 0, 0.85);
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-radius: 8px;
    padding: 20px;
    color: #fff;
    font-family: monospace;
    font-size: 14px;
    min-width: 280px;
    z-index: 2000;
    display: none;
    backdrop-filter: blur(10px);
  }
  #controls-panel.visible {
    display: block;
  }
  #controls-panel h3 {
    margin: 0 0 15px 0;
    font-size: 16px;
    color: #ffcc66;
    border-bottom: 1px solid rgba(255, 255, 255, 0.2);
    padding-bottom: 8px;
  }
  .control-group {
    margin: 12px 0;
  }
  .control-group label {
    display: block;
    margin-bottom: 5px;
    color: #aaa;
  }
  .control-group input[type="checkbox"] {
    margin-right: 8px;
  }
  .control-group input[type="range"] {
    width: 100%;
    margin-top: 5px;
  }
  .control-value {
    display: inline-block;
    min-width: 40px;
    text-align: right;
    color: #ffcc66;
  }
  .hint {
    position: fixed;
    top: 20px;
    right: 20px;
    color: rgba(255, 255, 255, 0.5);
    font-family: monospace;
    font-size: 12px;
    z-index: 1500;
    pointer-events: none;
  }
  #node-card {
    position: fixed;
    left: 20px;
    top: 50%;
    transform: translateY(-50%);
    width: 380px;
    max-height: 80vh;
    background: rgba(0, 0, 0, 0.92);
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-radius: 0;
    padding: 0;
    color: #fff;
    font-family: monospace;
    font-size: 13px;
    z-index: 2500;
    display: none;
    overflow: hidden;
    /* Pixelated rounded corners using clip-path */
    clip-path: polygon(
      4px 0, calc(100% - 4px) 0,
      100% 4px, 100% calc(100% - 4px),
      calc(100% - 4px) 100%, 4px 100%,
      0 calc(100% - 4px), 0 4px
    );
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
  }
  #node-card.visible {
    display: block;
    animation: slideInLeft 0.3s ease-out;
  }
  @keyframes slideInLeft {
    from {
      opacity: 0;
      transform: translateY(-50%) translateX(-30px);
    }
    to {
      opacity: 1;
      transform: translateY(-50%) translateX(0);
    }
  }
  .node-card-header {
    background: rgba(255, 255, 255, 0.1);
    padding: 16px 20px;
    border-bottom: 2px solid rgba(255, 255, 255, 0.2);
    position: relative;
  }
  .node-card-title {
    font-size: 16px;
    font-weight: bold;
    margin: 0 0 8px 0;
    color: #ffcc66;
    word-wrap: break-word;
  }
  .node-card-meta {
    font-size: 11px;
    color: #aaa;
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
  }
  .node-card-meta span {
    display: inline-flex;
    align-items: center;
    gap: 4px;
  }
  .node-card-close {
    position: absolute;
    top: 12px;
    right: 12px;
    width: 24px;
    height: 24px;
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.3);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    line-height: 1;
    color: #fff;
    transition: all 0.2s;
    clip-path: polygon(2px 0, calc(100% - 2px) 0, 100% 2px, 100% calc(100% - 2px), calc(100% - 2px) 100%, 2px 100%, 0 calc(100% - 2px), 0 2px);
  }
  .node-card-close:hover {
    background: rgba(255, 80, 80, 0.3);
    border-color: #ff5050;
  }
  .node-card-body {
    padding: 20px;
    max-height: calc(80vh - 100px);
    overflow-y: auto;
  }
  .node-card-body::-webkit-scrollbar {
    width: 8px;
  }
  .node-card-body::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.05);
  }
  .node-card-body::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.2);
    border-radius: 0;
  }
  .node-card-section {
    margin-bottom: 20px;
  }
  .node-card-section:last-child {
    margin-bottom: 0;
  }
  .node-card-section-title {
    font-size: 12px;
    color: #888;
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-bottom: 8px;
    padding-bottom: 4px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  }
  .node-card-definition {
    font-size: 13px;
    line-height: 1.6;
    color: #ddd;
    margin-bottom: 12px;
  }
  .node-card-example {
    font-size: 12px;
    line-height: 1.5;
    color: #bbb;
    font-style: italic;
    padding: 8px 12px;
    background: rgba(255, 255, 255, 0.03);
    border-left: 2px solid rgba(255, 204, 102, 0.5);
    margin-bottom: 8px;
  }
  .node-connections-list {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }
  .connection-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.1);
    cursor: pointer;
    transition: all 0.2s;
    clip-path: polygon(2px 0, calc(100% - 2px) 0, 100% 2px, 100% calc(100% - 2px), calc(100% - 2px) 100%, 2px 100%, 0 calc(100% - 2px), 0 2px);
  }
  .connection-item:hover {
    background: rgba(255, 255, 255, 0.15);
    border-color: rgba(255, 204, 102, 0.5);
    transform: translateX(4px);
  }
  .connection-type {
    font-size: 10px;
    color: #888;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    min-width: 60px;
  }
  .connection-arrow {
    color: #ffcc66;
    font-size: 12px;
  }
  .connection-target {
    font-size: 12px;
    color: #fff;
    flex: 1;
  }
  .connection-era-badge {
    font-size: 9px;
    padding: 2px 6px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 2px;
    color: #aaa;
  }
</style>
</head>
<body>
<div id="spotify-player">
  <iframe id="spotify-iframe" data-testid="embed-iframe" style="border-radius:12px" src="https://open.spotify.com/embed/track/0cqNGWvuukhCiKvEX7utys?utm_source=generator&theme=0" width="100%" height="152" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" loading="eager"></iframe>
  <div id="spotify-mask"></div>
  <div id="play-button-cutout"></div>
  <div id="play-button-overlay" title="Click to start"></div>
  <div id="play-hint">Click to begin â†’</div>
</div>

<div class="hint" id="esc-hint">Press ESC for settings</div>

<div id="node-card">
  <div class="node-card-header">
    <h3 class="node-card-title" id="node-card-title">Node Title</h3>
    <div class="node-card-meta" id="node-card-meta"></div>
    <div class="node-card-close" id="node-card-close">Ã—</div>
  </div>
  <div class="node-card-body" id="node-card-body"></div>
</div>

<div id="controls-panel">
  <h3>Visual Settings</h3>
  
  <div class="control-group">
    <label>
      <input type="checkbox" id="toggle-chromatic" checked>
      Chromatic Aberration
    </label>
    <input type="range" id="chromatic-strength" min="0" max="10" step="0.1" value="2">
    <span class="control-value" id="chromatic-value">2.0</span>
  </div>
  
  <div class="control-group">
    <label>
      <input type="checkbox" id="toggle-crt" checked>
      CRT Scanlines
    </label>
    <input type="range" id="crt-intensity" min="0" max="1" step="0.05" value="0.3">
    <span class="control-value" id="crt-value">0.30</span>
  </div>
  
  <div class="control-group">
    <label>
      <input type="checkbox" id="toggle-bloom" checked>
      Bloom
    </label>
    <input type="range" id="bloom-strength" min="0" max="3" step="0.1" value="0.7">
    <span class="control-value" id="bloom-value">0.70</span>
  </div>
  
  <div style="margin-top: 20px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.2); color: #666; font-size: 11px;">
    Press ESC to close
  </div>
</div>
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>
<script type="module">
/* ===== Imports via CDN ===== */
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";

/* ===== Basic Scene Setup ===== */
const renderer = new THREE.WebGLRenderer({ antialias:false });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(
  45,
  window.innerWidth/window.innerHeight,
  0.1,
  100
);
camera.position.set(0,0,6);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.enablePan = false;
controls.enableZoom = false;
controls.rotateSpeed = 0.4;

/* ===== Bloom Composer ===== */
const composer = new EffectComposer(renderer);
const renderPass = new RenderPass(scene, camera);
composer.addPass(renderPass);

const bloomPass = new UnrealBloomPass(
  new THREE.Vector2(window.innerWidth, window.innerHeight),
  0.7,   // strength
  0.8,   // radius
  0.0    // threshold
);
composer.addPass(bloomPass);

// Chromatic Aberration Shader
const chromaticAberrationShader = {
  uniforms: {
    tDiffuse: { value: null },
    amount: { value: 2.0 },
    enabled: { value: 1.0 }
  },
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform sampler2D tDiffuse;
    uniform float amount;
    uniform float enabled;
    varying vec2 vUv;
    
    void main() {
      if(enabled < 0.5) {
        gl_FragColor = texture2D(tDiffuse, vUv);
        return;
      }
      
      vec2 offset = amount * 0.001 * (vUv - 0.5);
      vec4 cr = texture2D(tDiffuse, vUv + offset);
      vec4 cg = texture2D(tDiffuse, vUv);
      vec4 cb = texture2D(tDiffuse, vUv - offset);
      
      gl_FragColor = vec4(cr.r, cg.g, cb.b, cg.a);
    }
  `
};

const chromaticPass = new ShaderPass(chromaticAberrationShader);
composer.addPass(chromaticPass);

// CRT Scanlines Shader
const crtShader = {
  uniforms: {
    tDiffuse: { value: null },
    intensity: { value: 0.3 },
    resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
    time: { value: 0.0 },
    enabled: { value: 1.0 }
  },
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform sampler2D tDiffuse;
    uniform float intensity;
    uniform vec2 resolution;
    uniform float time;
    uniform float enabled;
    varying vec2 vUv;
    
    void main() {
      vec4 color = texture2D(tDiffuse, vUv);
      
      if(enabled < 0.5) {
        gl_FragColor = color;
        return;
      }
      
      // Scanlines
      float scanline = sin(vUv.y * resolution.y * 2.0) * 0.5 + 0.5;
      scanline = pow(scanline, 3.0);
      
      // Vignette
      vec2 center = vUv - 0.5;
      float vignette = 1.0 - dot(center, center) * 0.5;
      
      // CRT curvature (subtle)
      vec2 curve = vUv * (1.0 - vUv.yx);
      float vig = curve.x * curve.y * 15.0;
      vig = pow(vig, 0.25);
      
      // Combine effects
      color.rgb *= mix(1.0, scanline, intensity);
      color.rgb *= vignette;
      color.rgb *= vig;
      
      // RGB shift on edges (chromatic aberration effect)
      float edge = length(center);
      color.rgb += vec3(0.02) * edge * intensity;
      
      gl_FragColor = color;
    }
  `
};

const crtPass = new ShaderPass(crtShader);
crtPass.renderToScreen = true;
composer.addPass(crtPass);

/* ===== Utilities ===== */

// createGlowyDot: small emissive sphere
function createGlowyDot(color=0xffcc66) {
  const geo = new THREE.SphereGeometry(0.08, 32, 32);
  const mat = new THREE.MeshBasicMaterial({
    color,
    transparent:true
  });
  const mesh = new THREE.Mesh(geo, mat);

  // subtle aura (billboard plane w/ additive)
  const auraGeo = new THREE.PlaneGeometry(0.6,0.6);
  const auraMat = new THREE.ShaderMaterial({
    transparent:true,
    blending:THREE.AdditiveBlending,
    depthWrite:false,
    uniforms:{
      uColor:{ value:new THREE.Color(color) },
      uTime:{ value:0.0 }
    },
    vertexShader:`
      varying vec2 vUv;
      void main() {
        vUv = uv;
        vec4 mvPosition = modelViewMatrix * vec4(position,1.0);
        gl_Position = projectionMatrix * mvPosition;
      }
    `,
    fragmentShader:`
      varying vec2 vUv;
      uniform vec3 uColor;
      uniform float uTime;
      void main(){
        float d = distance(vUv, vec2(0.5));
        float glow = smoothstep(0.6,0.0,d);
        // pulsate
        glow *= 0.7 + 0.3*sin(uTime*3.0);
        gl_FragColor = vec4(uColor * glow, glow);
      }
    `
  });
  const aura = new THREE.Mesh(auraGeo, auraMat);
  aura.renderOrder = -1;
  mesh.add(aura);

  // make aura face camera each frame -> we'll rotate in tick
  aura.userData.isBillboard = true;

  return mesh;
}

// ===== OPTIMIZED TEXT ATLAS SYSTEM =====
// 
// Performance Benefits:
// - Single shared texture atlas (128x72px) for ALL text rendering
// - No per-label canvas/texture creation (massive memory savings)
// - Reduced draw calls via shared texture
// - Efficient geometry reuse via indexed BufferGeometry
// 
// Previous system: Each text label = new canvas + new texture + new material
// New system: All text = 1 shared texture atlas + individual geometries
//
// Memory savings: ~90-95% reduction in texture memory
// GPU calls: ~50% reduction via texture sharing

// Create texture atlas with all printable ASCII characters
const textAtlas = (() => {
  // Character set: printable ASCII (32-126) + common symbols
  const chars = ' !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~';
  
  // Character dimensions
  const charWidth = 8;
  const charHeight = 12;
  const charsPerRow = 16;
  const rows = Math.ceil(chars.length / charsPerRow);
  
  // Create canvas for atlas
  const atlasWidth = charsPerRow * charWidth;
  const atlasHeight = rows * charHeight;
  const canvas = document.createElement('canvas');
  canvas.width = atlasWidth;
  canvas.height = atlasHeight;
  const ctx = canvas.getContext('2d');
  
  // Clear canvas
  ctx.fillStyle = 'rgba(0,0,0,0)';
  ctx.fillRect(0, 0, atlasWidth, atlasHeight);
  
  // Render each character
  ctx.font = 'bold 11px monospace';
  ctx.fillStyle = '#ffffff';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.imageSmoothingEnabled = false;
  
  const charMap = {};
  
  for (let i = 0; i < chars.length; i++) {
    const char = chars[i];
    const col = i % charsPerRow;
    const row = Math.floor(i / charsPerRow);
    const x = col * charWidth;
    const y = row * charHeight;
    
    // Draw character
    ctx.fillText(char, x + 1, y + 1);
    
    // Store UV coordinates
    charMap[char] = {
      u: x / atlasWidth,
      v: y / atlasHeight,
      u2: (x + charWidth) / atlasWidth,
      v2: (y + charHeight) / atlasHeight,
      width: charWidth,
      height: charHeight
    };
  }
  
  // Create texture
  const texture = new THREE.CanvasTexture(canvas);
  texture.minFilter = THREE.NearestFilter;
  texture.magFilter = THREE.NearestFilter;
  texture.generateMipmaps = false;
  texture.flipY = false; // Don't flip - our UVs match canvas coordinate system
  
  console.log(`âœ… Text atlas created: ${chars.length} characters, ${atlasWidth}x${atlasHeight}px`);
  
  return {
    texture,
    charMap,
    charWidth,
    charHeight
  };
})();

// Optimized pixelTextSprite using texture atlas
function pixelTextSprite(text, color="#ffffff") {
  if (!text || text.length === 0) {
    text = " "; // Prevent empty text
  }
  
  const { texture, charMap, charWidth, charHeight } = textAtlas;
  const textLength = text.length;
  
  // Create geometry for all characters
  const geometry = new THREE.BufferGeometry();
  const vertices = [];
  const uvs = [];
  const indices = [];
  
  for (let i = 0; i < textLength; i++) {
    const char = text[i];
    const charData = charMap[char] || charMap[' ']; // Fallback to space
    
    // Calculate position for this character (centered)
    const xOffset = (i - textLength / 2) * charWidth;
    
    // Vertex positions (quad)
    const x0 = xOffset;
    const x1 = xOffset + charWidth;
    const y0 = -charHeight / 2;
    const y1 = charHeight / 2;
    
    vertices.push(
      x0, y1, 0,  // top-left
      x1, y1, 0,  // top-right
      x1, y0, 0,  // bottom-right
      x0, y0, 0   // bottom-left
    );
    
    // UV coordinates from atlas
    uvs.push(
      charData.u, charData.v,      // top-left
      charData.u2, charData.v,     // top-right
      charData.u2, charData.v2,    // bottom-right
      charData.u, charData.v2      // bottom-left
    );
    
    // Indices for two triangles
    const baseIndex = i * 4;
    indices.push(
      baseIndex, baseIndex + 1, baseIndex + 2,
      baseIndex, baseIndex + 2, baseIndex + 3
    );
  }
  
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
  geometry.setIndex(indices);
  
  // Create material with colored texture (clone texture to allow different colors)
  const colorObj = new THREE.Color(color);
  const material = new THREE.MeshBasicMaterial({
    map: texture,
    transparent: true,
    depthWrite: false,
    color: colorObj,
    side: THREE.DoubleSide
  });
  
  // Create mesh
  const mesh = new THREE.Mesh(geometry, material);
  
  // Scale to world units
  const scaleFactor = 0.02;
  mesh.scale.set(scaleFactor, scaleFactor, scaleFactor);
  
  // Make mesh always face camera
  mesh.userData.isBillboard = true;
  mesh.userData.isTextMesh = true;
  
  return mesh;
}

// createDottedLine: simple dotted line between A and B
function createDottedLine(color=0xffcc66){
  const SEGMENTS = 64;
  const geo = new THREE.BufferGeometry();
  const positions = new Float32Array(SEGMENTS*3);
  
  for(let i=0;i<SEGMENTS;i++){
    const t = i/(SEGMENTS-1);
    positions.set([t,0,0], i*3);
  }
  geo.setAttribute("position", new THREE.BufferAttribute(positions,3));
  
  const mat = new THREE.ShaderMaterial({
    transparent:true,
    blending:THREE.AdditiveBlending,
    depthWrite:false,
    uniforms:{
      uTime:{ value:0 },
      uColor:{ value:new THREE.Color(color) },
      uA:{ value:new THREE.Vector3() },
      uB:{ value:new THREE.Vector3(1,0,0) },
    },
    vertexShader:`
      uniform float uTime;
      uniform vec3 uA;
      uniform vec3 uB;
      varying float vT;
      void main(){
        float t = position.x;
        vT = t;
        vec3 pos = mix(uA, uB, t);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos,1.0);
        gl_PointSize = 4.0;
      }
    `,
    fragmentShader:`
      uniform float uTime;
      uniform vec3 uColor;
      varying float vT;
      void main(){
        float dotPattern = step(0.5, fract(vT*15.0 - uTime*3.0));
        float a = dotPattern * 0.8;
        gl_FragColor = vec4(uColor * 1.5, a);
      }
    `
  });
  
  const points = new THREE.Points(geo, mat);
  return points;
}

// createCurvedDottedLine: curved dotted line with bezier control point
function createCurvedDottedLine(color=0xffcc66){
  const SEGMENTS = 64;
  const geo = new THREE.BufferGeometry();
  const positions = new Float32Array(SEGMENTS*3);
  
  for(let i=0;i<SEGMENTS;i++){
    const t = i/(SEGMENTS-1);
    positions.set([t,0,0], i*3);
  }
  geo.setAttribute("position", new THREE.BufferAttribute(positions,3));
  
  const mat = new THREE.ShaderMaterial({
    transparent:true,
    blending:THREE.AdditiveBlending,
    depthWrite:false,
    uniforms:{
      uTime:{ value:0 },
      uColor:{ value:new THREE.Color(color) },
      uA:{ value:new THREE.Vector3() },
      uB:{ value:new THREE.Vector3(1,0,0) },
      uC:{ value:new THREE.Vector3(0.5,0.5,0) }, // control point
    },
    vertexShader:`
      uniform float uTime;
      uniform vec3 uA;
      uniform vec3 uB;
      uniform vec3 uC;
      varying float vT;
      void main(){
        float t = position.x;
        vT = t;
        // Quadratic bezier: (1-t)^2 * P0 + 2*(1-t)*t * P1 + t^2 * P2
        vec3 pos = (1.0-t)*(1.0-t)*uA + 2.0*(1.0-t)*t*uC + t*t*uB;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos,1.0);
        gl_PointSize = 4.0;
      }
    `,
    fragmentShader:`
      uniform float uTime;
      uniform vec3 uColor;
      varying float vT;
      void main(){
        float dotPattern = step(0.5, fract(vT*15.0 - uTime*3.0));
        float a = dotPattern * 0.8;
        gl_FragColor = vec4(uColor * 1.5, a);
      }
    `
  });
  
  const points = new THREE.Points(geo, mat);
  return points;
}

// createConnectionWaves: geometry+shader for pulsating ribbon between A and B
function createConnectionWaves(color=0xffcc66){
  // We'll build a strip along param t in [0..1].
  // Vertex shader offsets the strip with 2 sine waves mirrored.

  const SEGMENTS = 64;
  const geo = new THREE.BufferGeometry();
  const positions = new Float32Array(SEGMENTS*2*3); // two verts per segment
  const uvs = new Float32Array(SEGMENTS*2*2);
  const indices = [];

  for (let i=0;i<SEGMENTS;i++){
    const t = i/(SEGMENTS-1);
    // two side verts placeholder, x=t, y = +/-1 in local space
    const x = t;
    // We just store param, offset dir in uv.y
    positions.set([x, -1, 0], (i*2+0)*3);
    positions.set([x,  1, 0], (i*2+1)*3);

    uvs.set([t,0], (i*2+0)*2);
    uvs.set([t,1], (i*2+1)*2);

    if(i<SEGMENTS-1){
      const a = i*2;
      const b = i*2+1;
      const c = i*2+2;
      const d = i*2+3;
      indices.push(a,b,c, b,d,c);
    }
  }
  geo.setAttribute("position", new THREE.BufferAttribute(positions,3));
  geo.setAttribute("uv", new THREE.BufferAttribute(uvs,2));
  geo.setIndex(indices);

  const mat = new THREE.ShaderMaterial({
    transparent:true,
    blending:THREE.AdditiveBlending,
    depthWrite:false,
    depthTest:true,
    side:THREE.DoubleSide,
    uniforms:{
      uTime:{ value:0 },
      uColor:{ value:new THREE.Color(color) },
      uA:{ value:new THREE.Vector3() },
      uB:{ value:new THREE.Vector3(1,0,0) },
    },
    vertexShader:`
      uniform float uTime;
      uniform vec3 uA;
      uniform vec3 uB;
      uniform vec3 uColor;
      varying float vT;
      varying float vAlpha;
      varying vec3 vColorish;

      void main(){
        // param t along line
        float t = uv.x;
        vT = t;

        // base line point
        vec3 basePos = mix(uA, uB, t);

        // direction A->B
        vec3 dir = normalize(uB - uA);
        // find some perpendiculars to make ribbon thickness
        // quick hack: pick world up, cross, etc.
        vec3 up = vec3(0.0, 1.0, 0.0);
        vec3 side = normalize(cross(dir, up));
        if(length(side) < 0.001){
          up = vec3(1.0, 0.0, 0.0);
          side = normalize(cross(dir, up));
        }

        // wave offset magnitude
        float waveMag = 0.08;
        float wave1 = sin(t * 20.0 - uTime * 4.0);
        float wave2 = sin(t * 25.0 + uTime * 6.0);

        // uv.y is 0 or 1 from our setup
        float stripSide = (uv.y * 2.0 - 1.0); // -1 or 1
        // make two waves separating outward
        float sep = stripSide * (0.04 + 0.03 * sin(uTime * 2.0 + t * 10.0));
        vec3 offset = side * (waveMag * (wave1 * 0.5 + wave2 * 0.5)) + normalize(cross(dir, side)) * sep;

        vec3 finalPos = basePos + offset;

        vAlpha = 0.8 + 0.2 * sin(uTime * 5.0 + t * 10.0);
        vColorish = uColor;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(finalPos, 1.0);
      }
    `,
    fragmentShader:`
      varying float vT;
      varying float vAlpha;
      varying vec3 vColorish;
      
      void main(){
        float fadeEnds = smoothstep(0.0, 0.15, vT) * smoothstep(1.0, 0.85, vT);
        float a = vAlpha * fadeEnds * 0.7;
        gl_FragColor = vec4(vColorish * 2.0, a);
      }
    `
  });

  const mesh = new THREE.Mesh(geo, mat);
  mesh.renderOrder = 1;
  return mesh;
}

/* ===== Entities ===== */

const DOT_COLOR = 0xffffff; // white

const dots = [];
const labels = [];
const connections = []; // {mesh, iA, iB} indexing into dots

// We'll create up to 3 dots but start with only first visible.
for (let i=0;i<3;i++){
  const d = createGlowyDot(DOT_COLOR);
  d.visible = (i===0); // only first at init
  d.position.set(0,0,0);
  d.userData.target = new THREE.Vector3(0,0,0);
  d.userData.baseScale = 1;
  scene.add(d);
  dots.push(d);

  const labelText = (i===0) ? "CREATOR" : (i===1) ? "CREATION" : "CONSUMER";
  const label = pixelTextSprite(labelText, "#ffee88");
  label.visible = d.visible;
  scene.add(label);
  labels.push(label);
}

// line meshes for up to 3 connections (AB, AC, BC)
for (let c=0;c<3;c++){
  const line = createConnectionWaves(DOT_COLOR);
  line.visible = false;
  scene.add(line);
  connections.push(line);
}
// connections[0] = 0-1
// connections[1] = 0-2
// connections[2] = 1-2

// Create 3 colored dots for the flipped triangle (yellow, blue, red)
const coloredDots = [];
const coloredColors = [0xffff00, 0x0099ff, 0xff0033];
for (let i=0;i<3;i++){
  const d = createGlowyDot(coloredColors[i]);
  d.visible = false;
  d.position.set(0,0,0);
  d.userData.target = new THREE.Vector3(0,0,0);
  d.userData.baseScale = 0.8; // smaller
  scene.add(d);
  coloredDots.push(d);
}

// No connections for colored dots - they don't have wave lines
const coloredConnections = [];

// Chains extending from colored dots
// Red dot chain (coloredDots[2])
const redChainLabels = ["Thought", "Idea", "Concept"];
const redChain = [];
redChainLabels.forEach((label, idx) => {
  const chainLink = {
    line: createDottedLine(0xff0033),
    dot: createGlowyDot(0xff0033),
    labelSprite: pixelTextSprite(label, "#ff3366"),
    scale: 0.3 + idx * 0.15, // progressively larger dots
    progress: 0, // 0 to 1, animated over time
    label
  };
  chainLink.line.visible = false;
  chainLink.dot.visible = false;
  chainLink.labelSprite.visible = false;
  chainLink.dot.userData.baseScale = chainLink.scale;
  chainLink.labelSprite.scale.multiplyScalar(0.5);
  scene.add(chainLink.line);
  scene.add(chainLink.dot);
  scene.add(chainLink.labelSprite);
  redChain.push(chainLink);
});

// Yellow dot chain (coloredDots[0])
const yellowChainLabels = ["Intention", "Action", "Impact"];
const yellowChain = [];
yellowChainLabels.forEach((label, idx) => {
  const chainLink = {
    line: createDottedLine(0xffff00),
    dot: createGlowyDot(0xffff00),
    labelSprite: pixelTextSprite(label, "#ffff66"),
    scale: 0.4 + idx * 0.2, // progressively larger dots
    progress: 0,
    label
  };
  chainLink.line.visible = false;
  chainLink.dot.visible = false;
  chainLink.labelSprite.visible = false;
  chainLink.dot.userData.baseScale = chainLink.scale;
  chainLink.labelSprite.scale.multiplyScalar(0.5);
  scene.add(chainLink.line);
  scene.add(chainLink.dot);
  scene.add(chainLink.labelSprite);
  yellowChain.push(chainLink);
});

// Blue dot chain (coloredDots[1])
const blueChainLabels = ["Material", "Selection", "Synthesis"];
const blueChain = [];
blueChainLabels.forEach((label, idx) => {
  const chainLink = {
    line: createDottedLine(0x0099ff),
    dot: createGlowyDot(0x0099ff),
    labelSprite: pixelTextSprite(label, "#66aaff"),
    scale: 0.35 + idx * 0.2, // progressively larger dots
    progress: 0,
    label
  };
  chainLink.line.visible = false;
  chainLink.dot.visible = false;
  chainLink.labelSprite.visible = false;
  chainLink.dot.userData.baseScale = chainLink.scale;
  chainLink.labelSprite.scale.multiplyScalar(0.5);
  scene.add(chainLink.line);
  scene.add(chainLink.dot);
  scene.add(chainLink.labelSprite);
  blueChain.push(chainLink);
});

// Shared white chain links (Framework, System, World) for all three chains
const sharedChainLabels = ["Framework", "System", "World"];
const sharedRedChain = [];
const sharedYellowChain = [];
const sharedBlueChain = [];

[sharedRedChain, sharedYellowChain, sharedBlueChain].forEach((chainArray, chainIdx) => {
  sharedChainLabels.forEach((label, idx) => {
    const chainLink = {
      line: createDottedLine(0xffffff),
      dot: createGlowyDot(0xffffff),
      labelSprite: pixelTextSprite(label, "#ffffff"),
      scale: 0.5 + idx * 0.2,
      progress: 0,
      label
    };
    chainLink.line.visible = false;
    chainLink.dot.visible = false;
    chainLink.labelSprite.visible = false;
    chainLink.dot.userData.baseScale = chainLink.scale;
    chainLink.labelSprite.scale.multiplyScalar(0.5);
    scene.add(chainLink.line);
    scene.add(chainLink.dot);
    scene.add(chainLink.labelSprite);
    chainArray.push(chainLink);
  });
});

// Inter-chain connection lines
const interChainConnections = [
  { from: 'yellow', fromIdx: 0, to: 'red', toIdx: 1, label: 'Intention â†’ Idea' },
  { from: 'yellow', fromIdx: 0, to: 'blue', toIdx: 1, label: 'Intention â†’ Selection' },
  { from: 'blue', fromIdx: 1, to: 'red', toIdx: 2, label: 'Selection â†’ Concept' },
  { from: 'red', fromIdx: 2, to: 'yellow', toIdx: 1, label: 'Concept â†’ Action' },
  { from: 'yellow', fromIdx: 1, to: 'blue', toIdx: 2, label: 'Action â†’ Synthesis' },
];

const interChainLines = [];
interChainConnections.forEach(conn => {
  const line = createCurvedDottedLine(0xaaaaaa);
  line.visible = false;
  scene.add(line);
  interChainLines.push({
    line,
    connection: conn,
    progress: 0
  });
});

// Cross connections: colored dots to white dots (9 total: 3x3)
const crossConnections = [];
const crossTexts = [
  // Yellow (coloredDots[0]) connections
  { colorIdx: 0, whiteIdx: 0, text: "I'm doing it.", variations: ["Creating", "Making", "Building"], color: 0xffff00 },
  { colorIdx: 0, whiteIdx: 1, text: "I want to do them justice.", variations: ["Honoring", "Respecting", "Caring"], color: 0xffff00 },
  { colorIdx: 0, whiteIdx: 2, text: "I want to know what to do.", variations: ["Learning", "Seeking", "Exploring"], color: 0xffff00 },
  // Blue (coloredDots[1]) connections
  { colorIdx: 1, whiteIdx: 0, text: "I want it to sing.", variations: ["Harmonize", "Resonate", "Flow"], color: 0x0099ff },
  { colorIdx: 1, whiteIdx: 1, text: "I'm doing it.", variations: ["Performing", "Executing", "Realizing"], color: 0x0099ff },
  { colorIdx: 1, whiteIdx: 2, text: "I want to see what can be made.", variations: ["Imagining", "Envisioning", "Dreaming"], color: 0x0099ff },
  // Red (coloredDots[2]) connections
  { colorIdx: 2, whiteIdx: 0, text: "What will they think?", variations: ["Wondering", "Questioning", "Doubting"], color: 0xff0033 },
  { colorIdx: 2, whiteIdx: 1, text: "I am what they thought.", variations: ["Reflected", "Shaped", "Formed"], color: 0xff0033 },
  { colorIdx: 2, whiteIdx: 2, text: "I have thoughts.", variations: ["Pondering", "Considering", "Reflecting"], color: 0xff0033 },
];

crossTexts.forEach((info, i) => {
  const line = createDottedLine(info.color);
  line.visible = false;
  scene.add(line);
  
  const textSprite = pixelTextSprite(info.text, `#${info.color.toString(16).padStart(6,'0')}`);
  textSprite.visible = false;
  textSprite.scale.multiplyScalar(0.6); // smaller text
  scene.add(textSprite);
  
  // Create variation sprites (smaller, floating around main text)
  const variationSprites = [];
  info.variations.forEach((varText, vIdx) => {
    const varSprite = pixelTextSprite(varText, `#${info.color.toString(16).padStart(6,'0')}`);
    varSprite.visible = false;
    varSprite.scale.multiplyScalar(0.35); // much smaller
    scene.add(varSprite);
    variationSprites.push({
      sprite: varSprite,
      emitTime: 0.3 + vIdx * 0.2, // stagger emission
      angle: vIdx * (Math.PI * 2 / 3), // distribute around main text
      speed: 0.8 + Math.random() * 0.4
    });
  });
  
  crossConnections.push({
    line,
    textSprite,
    variationSprites,
    colorIdx: info.colorIdx,
    whiteIdx: info.whiteIdx,
    text: info.text,
    offset: i * 0.7 // phase offset for animation
  });
});

/* ===== Wireframe Geometric Transformations for the Three Concepts ===== */

// Geometric transformation animations for Creator/Creation/Consumer
const geometricForms = {
  creator: {
    position: new THREE.Vector3(0, 0, 0), // Will be set dynamically
    currentForm: 0, // 0=dot, 1=line, 2=triangle, 3=pyramid, 4=double pyramid
    progress: 0,
    forms: [],
    visible: false,
    startTime: -1
  },
  creation: {
    position: new THREE.Vector3(0, 0, 0),
    currentForm: 0, // 0=dot, 1=line, 2=box, 3=blue box
    progress: 0,
    forms: [],
    visible: false,
    startTime: -1
  },
  consumer: {
    position: new THREE.Vector3(0, 0, 0),
    currentForm: 0, // 0=dot, 1=cross, 2=diamond, 3=circle, 4=sphere
    progress: 0,
    forms: [],
    visible: false,
    startTime: -1
  }
};

// Create wireframe materials
const wireframeMat = new THREE.LineBasicMaterial({ 
  color: 0xffffff, 
  transparent: true, 
  opacity: 0.8,
  blending: THREE.AdditiveBlending
});

// Creator forms: dot â†’ line â†’ triangle â†’ pyramid â†’ double pyramids
function createCreatorForms() {
  const forms = [];
  
  // Dot (small sphere)
  const dotGeo = new THREE.SphereGeometry(0.05, 8, 8);
  const dotEdges = new THREE.EdgesGeometry(dotGeo);
  const dot = new THREE.LineSegments(dotEdges, wireframeMat.clone());
  forms.push(dot);
  
  // Line
  const lineGeo = new THREE.BufferGeometry();
  lineGeo.setAttribute('position', new THREE.Float32BufferAttribute([0, -0.3, 0, 0, 0.3, 0], 3));
  const line = new THREE.Line(lineGeo, wireframeMat.clone());
  forms.push(line);
  
  // Triangle
  const triShape = new THREE.Shape();
  triShape.moveTo(0, 0.3);
  triShape.lineTo(-0.3, -0.3);
  triShape.lineTo(0.3, -0.3);
  triShape.lineTo(0, 0.3);
  const triGeo = new THREE.ShapeGeometry(triShape);
  const triEdges = new THREE.EdgesGeometry(triGeo);
  const triangle = new THREE.LineSegments(triEdges, wireframeMat.clone());
  forms.push(triangle);
  
  // Pyramid (tetrahedron) - Yellow
  const pyramidGeo = new THREE.TetrahedronGeometry(0.4);
  const pyramidEdges = new THREE.EdgesGeometry(pyramidGeo);
  const pyramidMat = new THREE.LineBasicMaterial({ 
    color: 0xffff00, 
    transparent: true, 
    opacity: 0.8,
    blending: THREE.AdditiveBlending
  });
  const pyramid = new THREE.LineSegments(pyramidEdges, pyramidMat);
  forms.push(pyramid);
  
  // Double pyramids (one upside down) - Yellow, bases touching
  const doublePyramid = new THREE.Group();
  const pyramidSize = 0.3;
  
  const pyr1Geo = new THREE.TetrahedronGeometry(pyramidSize);
  const pyr1Edges = new THREE.EdgesGeometry(pyr1Geo);
  const pyr1Mat = new THREE.LineBasicMaterial({ 
    color: 0xffff00, 
    transparent: true, 
    opacity: 0.8,
    blending: THREE.AdditiveBlending
  });
  const pyr1 = new THREE.LineSegments(pyr1Edges, pyr1Mat);
  // First pyramid pointing up, positioned at origin
  pyr1.position.y = 0;
  
  const pyr2Geo = new THREE.TetrahedronGeometry(pyramidSize);
  const pyr2Edges = new THREE.EdgesGeometry(pyr2Geo);
  const pyr2Mat = new THREE.LineBasicMaterial({ 
    color: 0xffff00, 
    transparent: true, 
    opacity: 0.8,
    blending: THREE.AdditiveBlending
  });
  const pyr2 = new THREE.LineSegments(pyr2Edges, pyr2Mat);
  pyr2.rotation.x = Math.PI; // Flip upside down
  // Second pyramid at same position, flipped (bases will overlap/touch)
  pyr2.position.y = 0;
  
  doublePyramid.add(pyr1, pyr2);
  forms.push(doublePyramid);
  
  return forms;
}

// Creation forms: dot â†’ line â†’ box â†’ blue box
function createCreationForms() {
  const forms = [];
  
  // Dot
  const dotGeo = new THREE.SphereGeometry(0.05, 8, 8);
  const dotEdges = new THREE.EdgesGeometry(dotGeo);
  const dot = new THREE.LineSegments(dotEdges, wireframeMat.clone());
  forms.push(dot);
  
  // Line
  const lineGeo = new THREE.BufferGeometry();
  lineGeo.setAttribute('position', new THREE.Float32BufferAttribute([0, -0.3, 0, 0, 0.3, 0], 3));
  const line = new THREE.Line(lineGeo, wireframeMat.clone());
  forms.push(line);
  
  // Box
  const boxGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
  const boxEdges = new THREE.EdgesGeometry(boxGeo);
  const box = new THREE.LineSegments(boxEdges, wireframeMat.clone());
  forms.push(box);
  
  // Blue box
  const blueBoxGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
  const blueBoxEdges = new THREE.EdgesGeometry(blueBoxGeo);
  const blueMat = new THREE.LineBasicMaterial({ 
    color: 0x4444ff, 
    transparent: true, 
    opacity: 0.9,
    blending: THREE.AdditiveBlending
  });
  const blueBox = new THREE.LineSegments(blueBoxEdges, blueMat);
  forms.push(blueBox);
  
  return forms;
}

// Consumer forms: dot â†’ 5-dot cross â†’ diamond â†’ circle â†’ sphere
function createConsumerForms() {
  const forms = [];
  
  // Dot
  const dotGeo = new THREE.SphereGeometry(0.05, 8, 8);
  const dotEdges = new THREE.EdgesGeometry(dotGeo);
  const dot = new THREE.LineSegments(dotEdges, wireframeMat.clone());
  forms.push(dot);
  
  // 5-dot cross
  const crossGroup = new THREE.Group();
  const dotSize = 0.05;
  [-0.2, 0, 0.2].forEach(y => {
    const d = new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.SphereGeometry(dotSize, 8, 8)), wireframeMat.clone());
    d.position.y = y;
    crossGroup.add(d);
  });
  [-0.2, 0.2].forEach(x => {
    const d = new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.SphereGeometry(dotSize, 8, 8)), wireframeMat.clone());
    d.position.x = x;
    crossGroup.add(d);
  });
  forms.push(crossGroup);
  
  // Diamond
  const diamondGeo = new THREE.OctahedronGeometry(0.3);
  const diamondEdges = new THREE.EdgesGeometry(diamondGeo);
  const diamond = new THREE.LineSegments(diamondEdges, wireframeMat.clone());
  forms.push(diamond);
  
  // Circle
  const circleGeo = new THREE.RingGeometry(0.25, 0.27, 32);
  const circleEdges = new THREE.EdgesGeometry(circleGeo);
  const circle = new THREE.LineSegments(circleEdges, wireframeMat.clone());
  forms.push(circle);
  
  // Sphere - Red
  const sphereGeo = new THREE.SphereGeometry(0.35, 16, 16);
  const sphereEdges = new THREE.EdgesGeometry(sphereGeo);
  const sphereMat = new THREE.LineBasicMaterial({ 
    color: 0xff0000, 
    transparent: true, 
    opacity: 0.8,
    blending: THREE.AdditiveBlending
  });
  const sphere = new THREE.LineSegments(sphereEdges, sphereMat);
  forms.push(sphere);
  
  return forms;
}

// Initialize geometric forms
geometricForms.creator.forms = createCreatorForms();
geometricForms.creation.forms = createCreationForms();
geometricForms.consumer.forms = createConsumerForms();

// Add all forms to scene (initially hidden)
Object.values(geometricForms).forEach(concept => {
  concept.forms.forEach((form, idx) => {
    form.visible = false;
    form.userData.formIndex = idx;
    scene.add(form);
  });
});

/* ===== Central Pulsing Dot ===== */

// Central pulsing dot with cycling label
const centralDot = {
  active: false,
  waitingForFirstPulse: true,
  mesh: null,
  label: null,
  labelTexts: ['CONNECTION', '?', 'CONSUMPTION', '?'],
  currentLabelIndex: 0,
  pulseStartTime: 0,
  pulsePeriod: 2.0, // Seconds per pulse (faster cycling)
  lastPulseIndex: -1
};

// Create central dot
function createCentralDot() {
  // Tiny dot at center
  const dotGeo = new THREE.SphereGeometry(0.03, 8, 8);
  const dotMat = new THREE.MeshBasicMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0.9,
    blending: THREE.AdditiveBlending
  });
  centralDot.mesh = new THREE.Mesh(dotGeo, dotMat);
  centralDot.mesh.position.set(0, 0, 0);
  centralDot.mesh.visible = false;
  scene.add(centralDot.mesh);
  
  // Label above dot
  centralDot.label = pixelTextSprite(centralDot.labelTexts[0], '#ffffff');
  centralDot.label.scale.multiplyScalar(0.4); // Small but readable
  centralDot.label.position.set(0, 0.15, 0);
  centralDot.label.visible = false;
  scene.add(centralDot.label);
}

// Update central dot
function updateCentralDot(time) {
  if (!centralDot.active || !centralDot.mesh || !centralDot.label) return;
  
  // Show immediately on first update after activation
  if (centralDot.waitingForFirstPulse) {
    centralDot.mesh.visible = true;
    centralDot.label.visible = true;
    centralDot.waitingForFirstPulse = false;
    centralDot.pulseStartTime = time; // Start pulse timing
    centralDot.lastPulseIndex = 0;
    console.log('ðŸ”´ Central dot visible immediately');
  }
  
  // Calculate current pulse cycle
  const elapsed = time - centralDot.pulseStartTime;
  const pulseIndex = Math.floor(elapsed / centralDot.pulsePeriod);
  
  // Change label on each new pulse
  if (pulseIndex !== centralDot.lastPulseIndex && pulseIndex > 0) {
    centralDot.lastPulseIndex = pulseIndex;
    centralDot.currentLabelIndex = (centralDot.currentLabelIndex + 1) % centralDot.labelTexts.length;
    
    // Update label text
    const newText = centralDot.labelTexts[centralDot.currentLabelIndex];
    const newLabel = pixelTextSprite(newText, '#ffffff');
    newLabel.scale.multiplyScalar(0.4);
    newLabel.position.set(0, 0.15, 0);
    newLabel.visible = true;
    
    scene.remove(centralDot.label);
    centralDot.label = newLabel;
    scene.add(centralDot.label);
    
    console.log(`ðŸ”„ Central label changed to: ${newText}`);
  }
  
  // Pulsing animation
  const pulsePhase = (elapsed % centralDot.pulsePeriod) / centralDot.pulsePeriod;
  const pulse = 1.0 + Math.sin(pulsePhase * Math.PI * 2) * 0.3;
  centralDot.mesh.scale.setScalar(pulse);
  
  // Update label position (always above dot)
  if (centralDot.label) {
    centralDot.label.position.set(0, 0.15, 0);
  }
}

// Initialize central dot
createCentralDot();

/* ===== Animation Timeline =====
   We'll drive positions/visibility with a simple keyframe state machine.

   States:
   0: one dot (creator) wobbling
   1: split into two (creator + creation) + link
   2: merge back to one in center
   3: explode to triangle with 3 dots + all links, pulsate 3 times
   4: dots get sucked back to center
   5: both triangles appear (white original + colored flipped)
*/

let state = 0;
let stateTime = 0;
let pulseCount = 0;
let rotationStep = 0;
let state5Mode = 'pulsate'; // 'pulsate', 'rotate', or 'rotate3d'
let worldSpawnTime = -1; // time when "World" spawns
let rotationsAfterWorld = 0; // count rotations after world spawns
let rotation3DPhase = 0; // for 3D rotation animation

function setState(s){
  state = s;
  stateTime = 0;
  if(state===0){
    // one dot in center
    dots[0].visible = true;
    dots[1].visible = false;
    dots[2].visible = false;

    labels[0].visible = true;
    labels[1].visible = false;
    labels[2].visible = false;

    connections.forEach(l=> l.visible=false);
    coloredDots.forEach(d=> d.visible=false);
    coloredConnections.forEach(l=> l.visible=false);
    crossConnections.forEach(c=> {
      c.line.visible = false;
      c.textSprite.visible = false;
      c.variationSprites.forEach(v=> v.sprite.visible = false);
    });

    dots[0].userData.target.set(0,0,0);
  }
  if(state===1){
    // split into two
    dots[0].visible = true;
    dots[1].visible = true;
    dots[2].visible = false;

    labels[0].visible = true;
    labels[1].visible = true;
    labels[2].visible = false;

    connections[0].visible = true; // 0-1
    connections[1].visible = false;
    connections[2].visible = false;

    coloredDots.forEach(d=> d.visible=false);
    coloredConnections.forEach(l=> l.visible=false);
    crossConnections.forEach(c=> {
      c.line.visible = false;
      c.textSprite.visible = false;
      c.variationSprites.forEach(v=> v.sprite.visible = false);
    });
  }
  if(state===2){
    // merge back to center (we'll animate them converging)
    dots[0].visible = true;
    dots[1].visible = true; // still visible briefly, then overlap
    dots[2].visible = false;

    labels[0].visible = true;
    labels[1].visible = true;
    labels[2].visible = false;

    connections[0].visible = true;
    connections[1].visible = false;
    connections[2].visible = false;

    coloredDots.forEach(d=> d.visible=false);
    coloredConnections.forEach(l=> l.visible=false);
    crossConnections.forEach(c=> {
      c.line.visible = false;
      c.textSprite.visible = false;
      c.variationSprites.forEach(v=> v.sprite.visible = false);
    });
  }
  if(state===3){
    pulseCount = 0;
    dots[0].visible = true;
    dots[1].visible = true;
    dots[2].visible = true;

    labels[0].visible = true;
    labels[1].visible = true;
    labels[2].visible = true;

    connections[0].visible = true;
    connections[1].visible = true;
    connections[2].visible = true;

    coloredDots.forEach(d=> d.visible=false);
    coloredConnections.forEach(l=> l.visible=false);
    crossConnections.forEach(c=> {
      c.line.visible = false;
      c.textSprite.visible = false;
      c.variationSprites.forEach(v=> v.sprite.visible = false);
    });
  }
  if(state===4){
    // suck back to center
    dots[0].visible = true;
    dots[1].visible = true;
    dots[2].visible = true;

    labels[0].visible = true;
    labels[1].visible = true;
    labels[2].visible = true;

    connections[0].visible = true;
    connections[1].visible = true;
    connections[2].visible = true;

    coloredDots.forEach(d=> d.visible=false);
    coloredConnections.forEach(l=> l.visible=false);
    crossConnections.forEach(c=> {
      c.line.visible = false;
      c.textSprite.visible = false;
      c.variationSprites.forEach(v=> v.sprite.visible = false);
    });
  }
  if(state===5){
    // both triangles visible
    state5Mode = 'pulsate';
    rotationStep = 0;
    
    dots[0].visible = true;
    dots[1].visible = true;
    dots[2].visible = true;

    labels[0].visible = true;
    labels[1].visible = true;
    labels[2].visible = true;

    connections[0].visible = true;
    connections[1].visible = true;
    connections[2].visible = true;

    coloredDots.forEach(d=> d.visible=true);
    coloredConnections.forEach(l=> l.visible=true);
    
    crossConnections.forEach(c=> {
      c.line.visible = true;
      c.textSprite.visible = true;
    });
  }
}

// call initial
setState(0);

/* ===== Resize ===== */
window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  composer.setSize(window.innerWidth, window.innerHeight);
  bloomPass.setSize(window.innerWidth, window.innerHeight);
});

/* ===== Helpers for lerp, etc. ===== */
function lerp(a,b,t){ return a+(b-a)*t; }
function vecLerp(out,a,b,t){
  out.set(
    lerp(a.x,b.x,t),
    lerp(a.y,b.y,t),
    lerp(a.z,b.z,t)
  );
  return out;
}

/* ===== UI Controls ===== */
const controlsPanel = document.getElementById('controls-panel');
const escHint = document.getElementById('esc-hint');

// ESC key handler (for controls panel, but not if node card is open)
document.addEventListener('keydown', (e) => {
  if(e.key === 'Escape') {
    // Priority: close node card first if it's open
    if (nodeCard && nodeCard.classList.contains('visible')) {
      // Handled by node card system
      return;
    }
    // Otherwise toggle controls panel
    controlsPanel.classList.toggle('visible');
    escHint.style.display = controlsPanel.classList.contains('visible') ? 'none' : 'block';
  }
});

// Chromatic Aberration controls
document.getElementById('toggle-chromatic').addEventListener('change', (e) => {
  chromaticPass.uniforms.enabled.value = e.target.checked ? 1.0 : 0.0;
});

document.getElementById('chromatic-strength').addEventListener('input', (e) => {
  const value = parseFloat(e.target.value);
  chromaticPass.uniforms.amount.value = value;
  document.getElementById('chromatic-value').textContent = value.toFixed(1);
});

// CRT controls
document.getElementById('toggle-crt').addEventListener('change', (e) => {
  crtPass.uniforms.enabled.value = e.target.checked ? 1.0 : 0.0;
});

document.getElementById('crt-intensity').addEventListener('input', (e) => {
  const value = parseFloat(e.target.value);
  crtPass.uniforms.intensity.value = value;
  document.getElementById('crt-value').textContent = value.toFixed(2);
});

// Bloom controls
document.getElementById('toggle-bloom').addEventListener('change', (e) => {
  bloomPass.enabled = e.target.checked;
});

document.getElementById('bloom-strength').addEventListener('input', (e) => {
  const value = parseFloat(e.target.value);
  bloomPass.strength = value;
  document.getElementById('bloom-value').textContent = value.toFixed(2);
});

/* ===== Main Animate Loop ===== */
let clock = new THREE.Clock();
clock.stop(); // Start paused
let animationStarted = false;

function animate(){
  // Only update time if animation has started
  let dt = 0;
  let tAbs = 0;
  if(animationStarted){
    dt = clock.getDelta();
    tAbs = clock.elapsedTime;
  stateTime += dt;
  }

  // State machine timing
  // state 0 lasts ~2s then ->1
  // state 1 lasts ~2s then ->2
  // state 2 lasts ~1.5s then ->3
  // state 3 pulsates (3 pulses ~1.2s each = ~3.6s) then ->4
  // state 4 suck in (~1.5s) then ->5
  // state 5 persists
  if(state===0 && stateTime>2.0){ setState(1); }
  if(state===1 && stateTime>2.0){ setState(2); }
  if(state===2 && stateTime>1.5){ setState(3); }
  if(state===3){
    // count pulses based on sine wave cycles
    const pulsePeriod = 1.2;
    const currentCycle = Math.floor(stateTime / pulsePeriod);
    if(currentCycle !== pulseCount){
      pulseCount = currentCycle;
    }
    if(pulseCount >= 3 && stateTime > 3.6){ setState(4); }
  }
  if(state===4 && stateTime>1.5){ setState(5); }

  // Update per-state targets / motion
  if(state===0){
    // single dot at origin, amoeba wobble by scaling
    dots[0].userData.target.set(0,0,0);
  }

  if(state===1){
    // split two dots apart and label them
    // we'll ease outward during first 1.0s, then drift
    const spread = Math.min(1.0, stateTime/1.0)*1.5;
    dots[0].userData.target.set(-spread*0.5,0,0);
    dots[1].userData.target.set(spread*0.5,0,0);
  }

  if(state===2){
    // converge back to center
    const mergeT = Math.min(1.0, stateTime/1.0);
    const aStart = new THREE.Vector3(-1.5*0.5,0,0);
    const bStart = new THREE.Vector3(1.5*0.5,0,0);
    vecLerp(dots[0].userData.target, aStart, new THREE.Vector3(0,0,0), mergeT);
    vecLerp(dots[1].userData.target, bStart, new THREE.Vector3(0,0,0), mergeT);
  }

  if(state===3){
    // triangle layout with 3 dots, pulsating away from center
    const baseR = 1.2;
    const pulsePeriod = 1.2;
    const pulsePhase = (stateTime % pulsePeriod) / pulsePeriod;
    // sine wave that goes 0 -> 1 -> 0 over each period
    const pulseAmt = Math.sin(pulsePhase * Math.PI) * 0.3; // 0 to 0.3 and back
    const R = baseR + pulseAmt;
    
    // Base triangle positions (centered at origin)
    dots[0].userData.target.set(-R, -0.6*R/baseR, 0);
    dots[1].userData.target.set(R, -0.6*R/baseR, 0);
    dots[2].userData.target.set(0, 1.0*R/baseR, 0);
  }

  if(state===4){
    // suck back to center
    const suckT = Math.min(1.0, stateTime/1.5);
    const easeT = 1.0 - Math.pow(1.0 - suckT, 3); // ease in cubic
    
    const baseR = 1.2;
    const startPos = [
      new THREE.Vector3(-baseR, -0.6, 0),
      new THREE.Vector3(baseR, -0.6, 0),
      new THREE.Vector3(0, 1.0, 0)
    ];
    const center = new THREE.Vector3(0,0,0);
    
    for(let i=0;i<3;i++){
      vecLerp(dots[i].userData.target, startPos[i], center, easeT);
    }
  }

  if(state===5){
    // Base triangle vertex positions (indices)
    const whiteBase = [
      [-1.2, -0.6, 0],  // 0: left bottom
      [1.2, -0.6, 0],   // 1: right bottom
      [0, 1.0, 0]       // 2: top
    ];
    const coloredBase = [
      [-0.9, 0.6*0.75, 0],  // 0: yellow left top
      [0.9, 0.6*0.75, 0],   // 1: blue right top
      [0, -1.0*0.75, 0]     // 2: red bottom
    ];
    
    // Phase 1: Split out (first 1 second)
    const splitT = Math.min(1.0, stateTime/1.0);
    
    // Phase 2: Start pulsating after 1 second
    if(stateTime > 1.0 && state5Mode === 'pulsate'){
      const pulsePeriod = 1.5;
      const pulseTime = stateTime - 1.0;
      const pulsePhase = (pulseTime % pulsePeriod) / pulsePeriod;
      const numPulsesBeforeRotate = 4; // 4 pulses before switching to rotation
      
      // After multiple pulses, switch to rotation mode
      if(pulseTime > pulsePeriod * numPulsesBeforeRotate){
        state5Mode = 'rotate';
        rotationStep = 0;
      }
      
      // Calculate how many pulses have been completed (grows progressively)
      const pulsesCompleted = Math.floor(pulseTime / pulsePeriod);
      const progressiveFactor = Math.min(pulsesCompleted * 0.25, 1.0); // grows by 0.25 per pulse, max 1.0
      
      // Inverse pulsating: when white grows, colored shrinks and vice versa
      const pulseWave = Math.sin(pulsePhase * Math.PI * 2.0); // -1 to 1
      const whiteScale = 1.0 + pulseWave * 0.25; // 0.75 to 1.25
      
      // Colored triangle: both expands more AND shrinks more each pulse
      // Progressively grows range from 0.6-1.4 to 0.4-2.4 (both extremes increase)
      const coloredMinScale = 0.6 - progressiveFactor * 0.2; // shrinks from 0.6 to 0.4
      const coloredMaxScale = 1.4 + progressiveFactor * 1.0; // grows from 1.4 to 2.4
      const coloredScale = pulseWave > 0 ? 
        lerp(1.0, coloredMaxScale, pulseWave) : 
        lerp(1.0, coloredMinScale, -pulseWave);
      
      for(let i=0;i<3;i++){
        dots[i].userData.target.set(
          whiteBase[i][0] * whiteScale * splitT,
          whiteBase[i][1] * whiteScale * splitT,
          whiteBase[i][2] * whiteScale * splitT
        );
        coloredDots[i].userData.target.set(
          coloredBase[i][0] * coloredScale * splitT,
          coloredBase[i][1] * coloredScale * splitT,
          coloredBase[i][2] * coloredScale * splitT
        );
      }
    } else if(state5Mode === 'rotate'){
      // Phase 3: Stepped rotation
      const rotationPeriod = 1.5; // time per rotation step
      const rotTime = stateTime - 1.0 - 6.0; // time since rotation started (1s split + 6s pulsating)
      const currentStep = Math.floor(rotTime / rotationPeriod) % 3;
      
      if(currentStep !== rotationStep){
        rotationStep = currentStep;
      }
      
      // Calculate total full rotations completed (each full rotation = 3 steps)
      const totalSteps = Math.floor(rotTime / rotationPeriod);
      const fullRotations = Math.floor(totalSteps / 3);
      
      // If World has spawned, count rotations after that point
      if(worldSpawnTime > 0 && tAbs > worldSpawnTime){
        const previousRotations = rotationsAfterWorld;
        rotationsAfterWorld = fullRotations - Math.floor((worldSpawnTime - (stateTime - rotTime)) / (rotationPeriod * 3));
        
        // After 1 rotation since World spawned, switch to 3D rotation mode (earlier)
        if(rotationsAfterWorld >= 1 && state5Mode === 'rotate'){
          state5Mode = 'rotate3d';
          rotation3DPhase = 0;
        }
      }
      
      // Alternate: 3 rotations opposite, 3 rotations same, repeat
      const rotationGroup = Math.floor(fullRotations / 3);
      const isOpposite = (rotationGroup % 2) === 0; // even groups = opposite, odd = same
      
      // Smooth transition between steps
      const stepProgress = (rotTime % rotationPeriod) / rotationPeriod;
      const easeT = stepProgress < 0.5 ? 2 * stepProgress * stepProgress : 1 - Math.pow(-2 * stepProgress + 2, 2) / 2;
      
      for(let i=0;i<3;i++){
        // White always rotates clockwise
        const whiteFromIdx = (i + rotationStep) % 3;
        const whiteToIdx = (i + rotationStep + 1) % 3;
        const whiteFrom = whiteBase[whiteFromIdx];
        const whiteTo = whiteBase[whiteToIdx];
        dots[i].userData.target.set(
          lerp(whiteFrom[0], whiteTo[0], easeT) * splitT,
          lerp(whiteFrom[1], whiteTo[1], easeT) * splitT,
          lerp(whiteFrom[2], whiteTo[2], easeT) * splitT
        );
        
        // Colored alternates between opposite and same direction
        let coloredFromIdx, coloredToIdx;
        if(isOpposite){
          // Counterclockwise (opposite to white)
          coloredFromIdx = (i - rotationStep + 9) % 3;
          coloredToIdx = (i - rotationStep - 1 + 9) % 3;
        } else {
          // Clockwise (same as white)
          coloredFromIdx = (i + rotationStep) % 3;
          coloredToIdx = (i + rotationStep + 1) % 3;
        }
        const coloredFrom = coloredBase[coloredFromIdx];
        const coloredTo = coloredBase[coloredToIdx];
        coloredDots[i].userData.target.set(
          lerp(coloredFrom[0], coloredTo[0], easeT) * splitT,
          lerp(coloredFrom[1], coloredTo[1], easeT) * splitT,
          lerp(coloredFrom[2], coloredTo[2], easeT) * splitT
        );
      }
    } else if(state5Mode === 'rotate3d'){
      // Phase 4: 3D rotation - create multidimensional structures
      rotation3DPhase += dt * 0.3; // slower rotation for dramatic effect
      
      // Create rotation matrices for interesting 3D motion
      const rotX = rotation3DPhase * 0.7;
      const rotY = rotation3DPhase * 1.3;
      const rotZ = rotation3DPhase * 0.5;
      
      // Apply different rotation axes to create complex motion
      for(let i=0;i<3;i++){
        // White dots: rotate around Y and X axes
        const whitePos = new THREE.Vector3(whiteBase[i][0], whiteBase[i][1], whiteBase[i][2]);
        whitePos.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotY);
        whitePos.applyAxisAngle(new THREE.Vector3(1, 0, 0), rotX * 0.5);
        dots[i].userData.target.copy(whitePos);
        
        // Colored dots: rotate in opposite direction with different axes
        const coloredPos = new THREE.Vector3(coloredBase[i][0], coloredBase[i][1], coloredBase[i][2]);
        coloredPos.applyAxisAngle(new THREE.Vector3(1, 0, 0), -rotX);
        coloredPos.applyAxisAngle(new THREE.Vector3(0, 1, 0), -rotY * 0.7);
        coloredPos.applyAxisAngle(new THREE.Vector3(0, 0, 1), rotZ * 0.3);
        coloredDots[i].userData.target.copy(coloredPos);
      }
      
      // Also rotate chain dots in 3D
      const rotateChainIn3D = (chain, colorIdx, reverseRot) => {
        const colorDot = coloredDots[colorIdx];
        const center = new THREE.Vector3(0, 0, 0);
        const baseDir = new THREE.Vector3().subVectors(colorDot.userData.target, center).normalize();
        
        chain.forEach((link, idx) => {
          const distance = 0.4 + idx * 0.35;
          const rotOffset = reverseRot ? -rotZ : rotZ;
          const radialDir = baseDir.clone();
          radialDir.applyAxisAngle(new THREE.Vector3(0, 0, 1), rotOffset + idx * 0.2);
          radialDir.applyAxisAngle(new THREE.Vector3(1, 0, 0), Math.sin(rotation3DPhase + idx * 0.5) * 0.3);
          const targetPos = colorDot.userData.target.clone().add(radialDir.multiplyScalar(distance));
          // Smoothly interpolate to new position
          if(!link.dot.userData.target3D) link.dot.userData.target3D = targetPos.clone();
          link.dot.userData.target3D.lerp(targetPos, 0.05);
        });
      };
      
      rotateChainIn3D(redChain, 2, false);
      rotateChainIn3D(yellowChain, 0, true);
      rotateChainIn3D(blueChain, 1, false);
      rotateChainIn3D(sharedRedChain, 2, false);
      rotateChainIn3D(sharedYellowChain, 0, true);
      rotateChainIn3D(sharedBlueChain, 1, false);
    } else {
      // Initial split animation
      for(let i=0;i<3;i++){
        dots[i].userData.target.set(
          whiteBase[i][0] * splitT,
          whiteBase[i][1] * splitT,
          whiteBase[i][2] * splitT
        );
        coloredDots[i].userData.target.set(
          coloredBase[i][0] * splitT,
          coloredBase[i][1] * splitT,
          coloredBase[i][2] * splitT
        );
      }
    }
  }

  // Smoothly move dots toward target, wobble scale
  dots.forEach((d,i)=>{
    if(!d.visible) return;
    d.position.lerp(d.userData.target, 0.08);

    // In early states (0,1,2), add wavy deformation from circle to rounded square
    if(state <= 2){
      const deformSpeed = 1.5;
      const deformTime = tAbs * deformSpeed + i * 0.5;
      
      // Create wavy rounded square effect by modulating X and Y differently
      const squareWave = Math.sin(deformTime) * 0.5 + 0.5; // 0 to 1
      const waveX = 1.0 + 0.2 * Math.sin(deformTime * 2.0) + squareWave * 0.15;
      const waveY = 1.0 + 0.2 * Math.sin(deformTime * 2.0 + Math.PI/2) + squareWave * 0.15;
      const waveZ = 1.0 + 0.15 * Math.sin(deformTime * 1.5 + Math.PI);
      
      // Add extra wobble for organic feel
      const microWobble = 0.08 * Math.sin(tAbs * 5.0 + i * 2.1);
      
      d.scale.set(
        d.userData.baseScale * (waveX + microWobble),
        d.userData.baseScale * (waveY + microWobble),
        d.userData.baseScale * (waveZ + microWobble)
      );
    } else if(state5Mode === 'rotate3d'){
      // In 3D mode: static scale, no wobble
      d.scale.setScalar(d.userData.baseScale);
    } else {
      // Normal wobble for intermediate states
    const wobble = 1.0 + 0.15*Math.sin(tAbs*3.0 + i*1.7);
    const wobble2 = 1.0 + 0.1*Math.sin(tAbs*2.2 + i*3.1 + 1.0);
      const s = d.userData.baseScale * wobble * wobble2;
      d.scale.setScalar(s);
    }

    // keep aura billboarded toward camera
    d.children.forEach(child=>{
      if(child.userData.isBillboard){
        child.quaternion.copy(camera.quaternion);
        child.material.uniforms.uTime.value = tAbs;
      }
    });
  });

  // Update colored dots
  coloredDots.forEach((d,i)=>{
    if(!d.visible) return;
    d.position.lerp(d.userData.target, 0.08);

    // In 3D mode: static scale, no wobble
    if(state5Mode === 'rotate3d'){
      d.scale.setScalar(d.userData.baseScale);
    } else {
    const wobble = 1.0 + 0.15*Math.sin(tAbs*3.0 + i*1.7 + 0.5);
    const wobble2 = 1.0 + 0.1*Math.sin(tAbs*2.2 + i*3.1 + 1.5);
    const s = d.userData.baseScale * wobble * wobble2;
    d.scale.setScalar(s);
    }

    // keep aura billboarded toward camera
    d.children.forEach(child=>{
      if(child.userData.isBillboard){
        child.quaternion.copy(camera.quaternion);
        child.material.uniforms.uTime.value = tAbs;
      }
    });
  });

  // Update labels to hover near dots, billboard, pixel scale lock
  labels.forEach((lab,i)=>{
    if(!lab.visible || !dots[i].visible) return;
    const dp = dots[i].position;
    // offset label slightly up
    lab.position.set(dp.x, dp.y+0.35, dp.z);
    lab.quaternion.copy(camera.quaternion);
  });

  // Update connection lines (wave shader uniforms + endpoints)
  // 0-1
  if(connections[0].visible){
    const A = dots[0].position;
    const B = dots[1].position;
    connections[0].material.uniforms.uTime.value = tAbs;
    connections[0].material.uniforms.uA.value.copy(A);
    connections[0].material.uniforms.uB.value.copy(B);
  }
  // 0-2
  if(connections[1].visible){
    const A = dots[0].position;
    const B = dots[2].position;
    connections[1].material.uniforms.uTime.value = tAbs;
    connections[1].material.uniforms.uA.value.copy(A);
    connections[1].material.uniforms.uB.value.copy(B);
  }
  // 1-2
  if(connections[2].visible){
    const A = dots[1].position;
    const B = dots[2].position;
    connections[2].material.uniforms.uTime.value = tAbs;
    connections[2].material.uniforms.uA.value.copy(A);
    connections[2].material.uniforms.uB.value.copy(B);
  }

  // Update cross connections (colored to white dots) and animate text
  crossConnections.forEach((conn, i) => {
    if(!conn.line.visible) return;
    
    const A = coloredDots[conn.colorIdx].position;
    const B = dots[conn.whiteIdx].position;
    
    // Update line endpoints
    conn.line.material.uniforms.uTime.value = tAbs;
    conn.line.material.uniforms.uA.value.copy(A);
    conn.line.material.uniforms.uB.value.copy(B);
    
    // Animate main text along the line (from colored to white)
    const textSpeed = 0.15; // speed of text movement
    const cycleTime = 1.5;
    const t = ((tAbs * textSpeed + conn.offset) % cycleTime) / cycleTime; // 0 to 1, with offset
    
    if(t <= 1.0){
      conn.textSprite.visible = true;
      // Lerp position from A to B
      conn.textSprite.position.lerpVectors(A, B, t);
      // Billboard to camera
      conn.textSprite.quaternion.copy(camera.quaternion);
      // Fade in/out at ends
      const fadeIn = Math.min(1.0, t * 5.0);
      const fadeOut = Math.min(1.0, (1.0 - t) * 5.0);
      conn.textSprite.material.opacity = fadeIn * fadeOut * 0.8;
      
      // Animate variation sprites floating around main text
      conn.variationSprites.forEach((varData, vIdx) => {
        const varT = t - varData.emitTime;
        
        if(varT > 0 && varT < 0.7){ // variations have shorter lifespan
          varData.sprite.visible = true;
          
          // Base position along path
          const basePos = new THREE.Vector3().lerpVectors(A, B, t);
          
          // Orbital offset from main text (spiraling outward)
          const orbitRadius = 0.15 * (varT * 2.0); // expand outward
          const orbitAngle = varData.angle + varT * varData.speed * Math.PI * 2;
          const wobble = Math.sin(tAbs * 4.0 + vIdx * 2.0) * 0.03;
          
          // Perpendicular to A-B line
          const lineDir = new THREE.Vector3().subVectors(B, A).normalize();
          const perpX = new THREE.Vector3(-lineDir.y, lineDir.x, 0);
          const perpY = new THREE.Vector3(0, 0, 1);
          
          varData.sprite.position.copy(basePos);
          varData.sprite.position.add(perpX.multiplyScalar(Math.cos(orbitAngle) * orbitRadius + wobble));
          varData.sprite.position.add(perpY.multiplyScalar(Math.sin(orbitAngle) * orbitRadius + wobble));
          
          // Billboard to camera
          varData.sprite.quaternion.copy(camera.quaternion);
          
          // Fade based on lifetime
          const varFadeIn = Math.min(1.0, varT * 10.0);
          const varFadeOut = Math.min(1.0, (0.7 - varT) / 0.3);
          varData.sprite.material.opacity = varFadeIn * varFadeOut * 0.6;
        } else {
          varData.sprite.visible = false;
        }
      });
    } else {
      conn.textSprite.visible = false;
      conn.variationSprites.forEach(varData => {
        varData.sprite.visible = false;
      });
    }
  });

  // Animate chains in state 5
  if(state === 5){
    const chainStartTime = 3.0; // start chains after 3 seconds into state 5
    const chainTime = Math.max(0, stateTime - chainStartTime);
    const linkDuration = 0.8; // time for each link to grow
    
    // Red chain animation
    redChain.forEach((link, idx) => {
      const linkStart = idx * linkDuration;
      const linkProgress = Math.min(1.0, Math.max(0, (chainTime - linkStart) / linkDuration));
      link.progress = linkProgress;
      
      if(linkProgress > 0){
        const redDot = coloredDots[2]; // red dot
        const startPos = idx === 0 ? redDot.position.clone() : redChain[idx - 1].dot.position.clone();
        
        // Calculate direction away from triangle center
        const center = new THREE.Vector3(0, 0, 0); // center of triangles
        const awayDir = new THREE.Vector3().subVectors(redDot.position, center).normalize();
        
        // Calculate end position radiating outward from center
        const distance = 0.4 + idx * 0.4; // increasing distance per link
        let endPos = redDot.position.clone().add(awayDir.multiplyScalar(distance));
        
        // In 3D rotation mode, use target3D if available
        if(state5Mode === 'rotate3d' && link.dot.userData.target3D){
          endPos = link.dot.userData.target3D.clone();
        }
        
        // Update line with wiggle
        link.line.visible = true;
        link.line.material.uniforms.uTime.value = tAbs;
        
        // Add wiggle to line endpoints
        const wiggleAmount = 0.05;
        const wiggleSpeed = 2.0;
        const wiggleX = Math.sin(tAbs * wiggleSpeed + idx * 1.5) * wiggleAmount;
        const wiggleY = Math.cos(tAbs * wiggleSpeed * 0.8 + idx * 2.1) * wiggleAmount;
        
        const wiggledStart = startPos.clone().add(new THREE.Vector3(wiggleX, wiggleY, 0));
        const wiggledEnd = new THREE.Vector3().lerpVectors(startPos, endPos, linkProgress);
        wiggledEnd.add(new THREE.Vector3(wiggleX * 0.5, wiggleY * 0.5, 0));
        
        link.line.material.uniforms.uA.value.copy(wiggledStart);
        link.line.material.uniforms.uB.value.copy(wiggledEnd);
        
        // Update dot at end of line
        if(linkProgress > 0.5){
          link.dot.visible = true;
          if(state5Mode === 'rotate3d' && link.dot.userData.target3D){
            link.dot.position.lerp(link.dot.userData.target3D, 0.1);
          } else {
            link.dot.position.lerpVectors(startPos, endPos, linkProgress);
          }
          
          // Wobble scale
          const wobble = 1.0 + 0.1*Math.sin(tAbs*2.0 + idx*1.3);
          link.dot.scale.setScalar(link.scale * wobble);
          
          // Update aura
          link.dot.children.forEach(child=>{
            if(child.userData.isBillboard){
              child.quaternion.copy(camera.quaternion);
              child.material.uniforms.uTime.value = tAbs;
            }
          });
        }
        
        // Update label
        if(linkProgress > 0.7){
          link.labelSprite.visible = true;
          link.labelSprite.position.copy(link.dot.position);
          link.labelSprite.position.y += 0.25;
          link.labelSprite.quaternion.copy(camera.quaternion);
          link.labelSprite.material.opacity = Math.min(1.0, (linkProgress - 0.7) / 0.3);
          
          // Trigger node swarm when "Concept" appears (index 2 in red chain)
          if(idx === 2 && link.label === 'Concept' && !nodeSwarmActive){
            console.log('âœ“ Concept appeared! Starting chronological node spiral');
            startNodeSwarm();
          }
        }
      }
    });
    
    // Yellow chain animation
    yellowChain.forEach((link, idx) => {
      const linkStart = idx * linkDuration;
      const linkProgress = Math.min(1.0, Math.max(0, (chainTime - linkStart) / linkDuration));
      link.progress = linkProgress;
      
      if(linkProgress > 0){
        const yellowDot = coloredDots[0]; // yellow dot
        const startPos = idx === 0 ? yellowDot.position.clone() : yellowChain[idx - 1].dot.position.clone();
        
        // Calculate direction away from triangle center
        const center = new THREE.Vector3(0, 0, 0); // center of triangles
        const awayDir = new THREE.Vector3().subVectors(yellowDot.position, center).normalize();
        
        // Calculate end position radiating outward from center
        const distance = 0.4 + idx * 0.35; // increasing distance per link
        let endPos = yellowDot.position.clone().add(awayDir.multiplyScalar(distance));
        
        // In 3D rotation mode, use target3D if available
        if(state5Mode === 'rotate3d' && link.dot.userData.target3D){
          endPos = link.dot.userData.target3D.clone();
        }
        
        // Update line with wiggle
        link.line.visible = true;
        link.line.material.uniforms.uTime.value = tAbs;
        
        // Add wiggle to line endpoints
        const wiggleAmount = 0.05;
        const wiggleSpeed = 2.0;
        const wiggleX = Math.sin(tAbs * wiggleSpeed + idx * 1.3) * wiggleAmount;
        const wiggleY = Math.cos(tAbs * wiggleSpeed * 0.8 + idx * 1.9) * wiggleAmount;
        
        const wiggledStart = startPos.clone().add(new THREE.Vector3(wiggleX, wiggleY, 0));
        const wiggledEnd = new THREE.Vector3().lerpVectors(startPos, endPos, linkProgress);
        wiggledEnd.add(new THREE.Vector3(wiggleX * 0.5, wiggleY * 0.5, 0));
        
        link.line.material.uniforms.uA.value.copy(wiggledStart);
        link.line.material.uniforms.uB.value.copy(wiggledEnd);
        
        // Update dot at end of line
        if(linkProgress > 0.5){
          link.dot.visible = true;
          if(state5Mode === 'rotate3d' && link.dot.userData.target3D){
            link.dot.position.lerp(link.dot.userData.target3D, 0.1);
          } else {
            link.dot.position.lerpVectors(startPos, endPos, linkProgress);
          }
          
          // Wobble scale
          const wobble = 1.0 + 0.1*Math.sin(tAbs*2.0 + idx*1.3);
          link.dot.scale.setScalar(link.scale * wobble);
          
          // Update aura
          link.dot.children.forEach(child=>{
            if(child.userData.isBillboard){
              child.quaternion.copy(camera.quaternion);
              child.material.uniforms.uTime.value = tAbs;
            }
          });
        }
        
        // Update label
        if(linkProgress > 0.7){
          link.labelSprite.visible = true;
          link.labelSprite.position.copy(link.dot.position);
          link.labelSprite.position.y += 0.25;
          link.labelSprite.quaternion.copy(camera.quaternion);
          link.labelSprite.material.opacity = Math.min(1.0, (linkProgress - 0.7) / 0.3);
        }
      }
    });
    
    // Blue chain animation
    blueChain.forEach((link, idx) => {
      const linkStart = idx * linkDuration;
      const linkProgress = Math.min(1.0, Math.max(0, (chainTime - linkStart) / linkDuration));
      link.progress = linkProgress;
      
      if(linkProgress > 0){
        const blueDot = coloredDots[1]; // blue dot
        const startPos = idx === 0 ? blueDot.position.clone() : blueChain[idx - 1].dot.position.clone();
        
        // Calculate direction away from triangle center
        const center = new THREE.Vector3(0, 0, 0); // center of triangles
        const awayDir = new THREE.Vector3().subVectors(blueDot.position, center).normalize();
        
        // Calculate end position radiating outward from center
        const distance = 0.4 + idx * 0.35; // increasing distance per link
        let endPos = blueDot.position.clone().add(awayDir.multiplyScalar(distance));
        
        // In 3D rotation mode, use target3D if available
        if(state5Mode === 'rotate3d' && link.dot.userData.target3D){
          endPos = link.dot.userData.target3D.clone();
        }
        
        // Update line with wiggle
        link.line.visible = true;
        link.line.material.uniforms.uTime.value = tAbs;
        
        // Add wiggle to line endpoints
        const wiggleAmount = 0.05;
        const wiggleSpeed = 2.0;
        const wiggleX = Math.sin(tAbs * wiggleSpeed + idx * 1.7) * wiggleAmount;
        const wiggleY = Math.cos(tAbs * wiggleSpeed * 0.8 + idx * 2.3) * wiggleAmount;
        
        const wiggledStart = startPos.clone().add(new THREE.Vector3(wiggleX, wiggleY, 0));
        const wiggledEnd = new THREE.Vector3().lerpVectors(startPos, endPos, linkProgress);
        wiggledEnd.add(new THREE.Vector3(wiggleX * 0.5, wiggleY * 0.5, 0));
        
        link.line.material.uniforms.uA.value.copy(wiggledStart);
        link.line.material.uniforms.uB.value.copy(wiggledEnd);
        
        // Update dot at end of line
        if(linkProgress > 0.5){
          link.dot.visible = true;
          if(state5Mode === 'rotate3d' && link.dot.userData.target3D){
            link.dot.position.lerp(link.dot.userData.target3D, 0.1);
          } else {
            link.dot.position.lerpVectors(startPos, endPos, linkProgress);
          }
          
          // Wobble scale
          const wobble = 1.0 + 0.1*Math.sin(tAbs*2.0 + idx*1.3);
          link.dot.scale.setScalar(link.scale * wobble);
          
          // Update aura
          link.dot.children.forEach(child=>{
            if(child.userData.isBillboard){
              child.quaternion.copy(camera.quaternion);
              child.material.uniforms.uTime.value = tAbs;
            }
          });
        }
        
        // Update label
        if(linkProgress > 0.7){
          link.labelSprite.visible = true;
          link.labelSprite.position.copy(link.dot.position);
          link.labelSprite.position.y += 0.25;
          link.labelSprite.quaternion.copy(camera.quaternion);
          link.labelSprite.material.opacity = Math.min(1.0, (linkProgress - 0.7) / 0.3);
        }
      }
    });
    
    // Determine when all chains are complete
    const allChainsTime = Math.max(redChain.length, yellowChain.length, blueChain.length) * linkDuration;
    const interConnectionTime = chainTime - allChainsTime - 0.5; // start 0.5s after chains complete
    
    // Inter-chain connections
    if(interConnectionTime > 0){
      const interDuration = 0.6;
      interChainLines.forEach((inter, idx) => {
        const interStart = idx * interDuration * 0.5; // stagger slightly
        const interProgress = Math.min(1.0, Math.max(0, (interConnectionTime - interStart) / interDuration));
        
        if(interProgress > 0){
          const getChainDot = (chainName, dotIdx) => {
            if(chainName === 'red') return redChain[dotIdx].dot.position;
            if(chainName === 'yellow') return yellowChain[dotIdx].dot.position;
            if(chainName === 'blue') return blueChain[dotIdx].dot.position;
          };
          
          const fromPos = getChainDot(inter.connection.from, inter.connection.fromIdx).clone();
          const toPos = getChainDot(inter.connection.to, inter.connection.toIdx).clone();
          
          // Create curved path - arc away from center for convex, toward for concave
          const center = new THREE.Vector3(0, 0, 0);
          const midPoint = new THREE.Vector3().lerpVectors(fromPos, toPos, 0.5);
          const dirFromCenter = new THREE.Vector3().subVectors(midPoint, center).normalize();
          
          // Alternate between convex (away) and concave (toward) based on connection index
          const curveAmount = (idx % 2 === 0) ? 0.3 : -0.3;
          const controlPoint = midPoint.clone().add(dirFromCenter.multiplyScalar(curveAmount));
          
          // Calculate current endpoint along the bezier curve for animated reveal
          const currentPoint = new THREE.Vector3();
          const t = interProgress;
          currentPoint.x = (1-t)*(1-t)*fromPos.x + 2*(1-t)*t*controlPoint.x + t*t*toPos.x;
          currentPoint.y = (1-t)*(1-t)*fromPos.y + 2*(1-t)*t*controlPoint.y + t*t*toPos.y;
          currentPoint.z = (1-t)*(1-t)*fromPos.z + 2*(1-t)*t*controlPoint.z + t*t*toPos.z;
          
          inter.line.visible = true;
          inter.line.material.uniforms.uTime.value = tAbs;
          inter.line.material.uniforms.uA.value.copy(fromPos);
          inter.line.material.uniforms.uB.value.copy(currentPoint);
          inter.line.material.uniforms.uC.value.copy(controlPoint);
        }
      });
    }
    
    // After inter-connections, converge and extend with white chains
    const convergTime = interConnectionTime - (interChainLines.length * 0.3 + 1.0);
    
    if(convergTime > 0){
      // Check if World has fully spawned (last link of shared chains is complete)
      const lastLinkTime = (sharedChainLabels.length - 1) * linkDuration;
      if(worldSpawnTime < 0 && convergTime > lastLinkTime + linkDuration){
        worldSpawnTime = tAbs;
      }
      
      // This implementation would be complex - for now just show the shared white chains
      // extending from the end of each colored chain
      [
        {chain: redChain, shared: sharedRedChain, color: coloredDots[2]},
        {chain: yellowChain, shared: sharedYellowChain, color: coloredDots[0]},
        {chain: blueChain, shared: sharedBlueChain, color: coloredDots[1]}
      ].forEach(({chain, shared, color}) => {
        shared.forEach((link, idx) => {
          const linkStart = idx * linkDuration;
          const linkProgress = Math.min(1.0, Math.max(0, (convergTime - linkStart) / linkDuration));
          
          if(linkProgress > 0){
            const lastColoredLink = chain[chain.length - 1];
            const startPos = idx === 0 ? lastColoredLink.dot.position.clone() : shared[idx - 1].dot.position.clone();
            
            const center = new THREE.Vector3(0, 0, 0);
            const awayDir = new THREE.Vector3().subVectors(color.position, center).normalize();
            const baseDistance = chain.length * 0.4;
            const distance = baseDistance + 0.4 + idx * 0.45;
            let endPos = color.position.clone().add(awayDir.clone().multiplyScalar(distance));
            
            // In 3D rotation mode, use target3D if available
            if(state5Mode === 'rotate3d' && link.dot.userData.target3D){
              endPos = link.dot.userData.target3D.clone();
            }
            
            // Update line with wiggle
            link.line.visible = true;
            link.line.material.uniforms.uTime.value = tAbs;
            
            const wiggleAmount = 0.05;
            const wiggleSpeed = 2.0;
            const wiggleX = Math.sin(tAbs * wiggleSpeed + idx * 1.5) * wiggleAmount;
            const wiggleY = Math.cos(tAbs * wiggleSpeed * 0.8 + idx * 2.1) * wiggleAmount;
            
            const wiggledStart = startPos.clone().add(new THREE.Vector3(wiggleX, wiggleY, 0));
            const wiggledEnd = new THREE.Vector3().lerpVectors(startPos, endPos, linkProgress);
            wiggledEnd.add(new THREE.Vector3(wiggleX * 0.5, wiggleY * 0.5, 0));
            
            link.line.material.uniforms.uA.value.copy(wiggledStart);
            link.line.material.uniforms.uB.value.copy(wiggledEnd);
            
            if(linkProgress > 0.5){
              link.dot.visible = true;
              if(state5Mode === 'rotate3d' && link.dot.userData.target3D){
                link.dot.position.lerp(link.dot.userData.target3D, 0.1);
              } else {
                link.dot.position.lerpVectors(startPos, endPos, linkProgress);
              }
              
              const wobble = 1.0 + 0.1*Math.sin(tAbs*2.0 + idx*1.3);
              link.dot.scale.setScalar(link.scale * wobble);
              
              link.dot.children.forEach(child=>{
                if(child.userData.isBillboard){
                  child.quaternion.copy(camera.quaternion);
                  child.material.uniforms.uTime.value = tAbs;
                }
              });
            }
            
            if(linkProgress > 0.7){
              link.labelSprite.visible = true;
              link.labelSprite.position.copy(link.dot.position);
              link.labelSprite.position.y += 0.25;
              link.labelSprite.quaternion.copy(camera.quaternion);
              link.labelSprite.material.opacity = Math.min(1.0, (linkProgress - 0.7) / 0.3);
            }
          }
        });
      });
    }
  } else {
    // Hide chains in other states
    redChain.forEach(link => {
      link.line.visible = false;
      link.dot.visible = false;
      link.labelSprite.visible = false;
      link.progress = 0;
    });
    yellowChain.forEach(link => {
      link.line.visible = false;
      link.dot.visible = false;
      link.labelSprite.visible = false;
      link.progress = 0;
    });
    blueChain.forEach(link => {
      link.line.visible = false;
      link.dot.visible = false;
      link.labelSprite.visible = false;
      link.progress = 0;
    });
    interChainLines.forEach(inter => {
      inter.line.visible = false;
      inter.progress = 0;
    });
    [sharedRedChain, sharedYellowChain, sharedBlueChain].forEach(chain => {
      chain.forEach(link => {
        link.line.visible = false;
        link.dot.visible = false;
        link.labelSprite.visible = false;
        link.progress = 0;
      });
    });
  }

  // Update node swarm spiral animation
  if(animationStarted){
    updateNodeSwarm(dt, tAbs);
    updateGeometricForms(dt, tAbs);
    updateCentralDot(tAbs);
  }

  // Update billboarding for all text meshes
  scene.traverse((obj) => {
    if (obj.userData.isTextMesh || obj.userData.isBillboard) {
      obj.quaternion.copy(camera.quaternion);
    }
  });

  controls.update();
  composer.render();
  requestAnimationFrame(animate);
}

// Update geometric form animations
function updateGeometricForms(dt, time) {
  // Activate geometric forms after enough nodes have spawned
  if (nodesSpawned < GEOMETRIC_ACTIVATION_THRESHOLD) return;
  
  // Position forms near the white triangle dots (tracking their rotation)
  let extensionDistance = 1.6; // Close to the dots
  
  // Track the white dots whenever 3 are visible (states 3, 4, 5)
  if ((state >= 3 || (state === 1 && dots[0].visible && dots[1].visible)) && 
      dots[0].visible && dots[1].visible && dots[2].visible) {
    // Use actual dot positions with slight offset outward
    const dot0Pos = dots[0].position.clone();
    const dot1Pos = dots[1].position.clone();
    const dot2Pos = dots[2].position.clone();
    
    // Extend slightly outward from center
    const center = new THREE.Vector3(0, 0, 0);
    const dir0 = dot0Pos.clone().sub(center).normalize();
    const dir1 = dot1Pos.clone().sub(center).normalize();
    const dir2 = dot2Pos.clone().sub(center).normalize();
    
    geometricForms.creator.position.copy(dot0Pos).add(dir0.multiplyScalar(0.6));
    geometricForms.creation.position.copy(dot1Pos).add(dir1.multiplyScalar(0.6));
    geometricForms.consumer.position.copy(dot2Pos).add(dir2.multiplyScalar(0.6));
  } else if (state === 1 && dots[0].visible && dots[1].visible) {
    // Two dots visible - position near them
    const dot0Pos = dots[0].position.clone();
    const dot1Pos = dots[1].position.clone();
    
    const center = new THREE.Vector3(0, 0, 0);
    const dir0 = dot0Pos.clone().sub(center).normalize();
    const dir1 = dot1Pos.clone().sub(center).normalize();
    
    geometricForms.creator.position.copy(dot0Pos).add(dir0.multiplyScalar(0.6));
    geometricForms.creation.position.copy(dot1Pos).add(dir1.multiplyScalar(0.6));
    geometricForms.consumer.position.set(0, -2, 0); // Hide third one below
  } else {
    // Single dot or early state - use fixed positions
    const angleOffset = Math.PI / 2;
    geometricForms.creator.position.set(
      Math.cos(angleOffset) * extensionDistance,
      0.5,
      Math.sin(angleOffset) * extensionDistance
    );
    geometricForms.creation.position.set(
      Math.cos(angleOffset + Math.PI * 2/3) * extensionDistance,
      0.5,
      Math.sin(angleOffset + Math.PI * 2/3) * extensionDistance
    );
    geometricForms.consumer.position.set(
      Math.cos(angleOffset + Math.PI * 4/3) * extensionDistance,
      0.5,
      Math.sin(angleOffset + Math.PI * 4/3) * extensionDistance
    );
  }
  
  // Update each concept
  Object.entries(geometricForms).forEach(([name, concept]) => {
    // Start animation if not started
    if (concept.startTime < 0) {
      concept.startTime = time;
      concept.visible = true;
      console.log(`ðŸ”· ${name} geometric animation started`);
    }
    
    const elapsed = time - concept.startTime;
    const totalForms = concept.forms.length;
    
    // Calculate which form should be showing
    const formIndex = Math.floor(elapsed / GEOMETRIC_FORM_DURATION);
    const formProgress = (elapsed % GEOMETRIC_FORM_DURATION) / GEOMETRIC_FORM_DURATION;
    
    // Determine current form (stay on last form permanently)
    const currentFormIndex = Math.min(formIndex, totalForms - 1);
    
    // Hide all forms first
    concept.forms.forEach(f => f.visible = false);
    
    // Show current form
    const currentForm = concept.forms[currentFormIndex];
    currentForm.visible = true;
    currentForm.position.copy(concept.position);
    
    // Check if completed
    checkGeometricCompletion(name, currentFormIndex, totalForms);
    
    // Fade in (permanent full visibility once faded in)
    const fadeIn = currentFormIndex === formIndex ? Math.min(1, formProgress * 4) : 1.0;
    const opacity = fadeIn;
    
    // Update material opacity (full opacity when complete)
    const finalOpacity = currentFormIndex === totalForms - 1 ? opacity : opacity * 0.8;
    
    if (currentForm.material) {
      currentForm.material.opacity = finalOpacity;
    } else if (currentForm.children) {
      currentForm.children.forEach(child => {
        if (child.material) child.material.opacity = finalOpacity;
      });
    }
    
    // Animate specific forms
    if (name === 'creator' && currentFormIndex === 4) {
      // Double pyramids - position them at extended offset from creator dot
      const pyr1 = currentForm.children[0];
      const pyr2 = currentForm.children[1];
      
      // Calculate anchor point (creator dot position)
      const anchorPos = concept.position.clone();
      
      // Calculate extended offset position (further out from center)
      const center = new THREE.Vector3(0, 0, 0);
      const dirFromCenter = anchorPos.clone().sub(center).normalize();
      const extendedOffset = 0.8; // Additional extension beyond anchor
      const pyramidAnchor = anchorPos.clone().add(dirFromCenter.multiplyScalar(extendedOffset));
      
      // Move the group to the extended anchor position
      currentForm.position.copy(pyramidAnchor);
      
      // Pyramids remain vertically aligned (bases touching at y=0 in local space)
      // They're already positioned correctly in creation:
      // pyr1 at centerToBase, pyr2 at -centerToBase - pyramidHeight
      // No need to reposition - they maintain their base-to-base configuration
      
      // Simple rotation around Y axis for visual interest
      currentForm.rotation.y = time * 0.3;
    }
    
    // Rotation animation (skip for creator double pyramids - they have custom orientation)
    if (!(name === 'creator' && currentFormIndex === 4)) {
      currentForm.rotation.y = time * 0.5;
      if (name === 'creator') {
        currentForm.rotation.x = time * 0.3;
      }
    }
    
    // Scale animation (subtle breathing)
    const breathe = 1.0 + Math.sin(time * 2.0 + currentFormIndex) * 0.05;
    currentForm.scale.setScalar(breathe);
  });
}

// Log when geometric forms reach final stage
let geometricFormsCompleted = {creator: false, creation: false, consumer: false};
function checkGeometricCompletion(name, formIndex, totalForms) {
  if (!geometricFormsCompleted[name] && formIndex === totalForms - 1) {
    geometricFormsCompleted[name] = true;
    console.log(`âœ“ ${name} transformation complete`);
  }
}

/* ===== Node Data Parser ===== */
let nodesData = [];
let nodeParticles = [];  // Visual particles for each node
let connectionLines = []; // Connection lines between nodes
let nodeConnections = []; // Parsed connection relationships between nodes
let nodesSpawned = 0;  // Track how many nodes have been revealed
let nodeSwarmActive = false;
let spiralAngle = 0;   // Current angle in the spiral
let spiralRadius = 2;  // Starting radius for spiral (reduced for tighter start)
let formationCenter = new THREE.Vector3(0, 0, 0); // Centroid of visible nodes
const SPIRAL_EXPANSION = 0.018;  // How much radius grows per node (slightly increased)
const NODES_PER_BURST = 8; // Spawn nodes in small bursts (increased for faster spawning)
const BURST_INTERVAL = 0.5; // Seconds between bursts (faster for categories to appear)
const NODE_STAGGER_DELAY = 0.08; // Delay between individual nodes in a burst (seconds)
const LABEL_DELAY_FOR_FIRST_NODES = 1.5; // Seconds before labels appear on first nodes
const FIRST_NODES_COUNT = 12; // Number of initial nodes that get delayed labels
let burstAccumulator = 0;
let pendingSpawns = []; // Queue of nodes waiting to spawn with delays

// Node cluster animation
let nodeClusters = {}; // Grouped by era or category
const clusterConfigs = {
  'Taxonomy': { rotationSpeed: 0.25, pulsePeriod: 3.0, pulseAmount: 0.3, direction: 1 },      // Clockwise, steady pulse
  'Genesis': { rotationSpeed: 0.22, pulsePeriod: 2.5, pulseAmount: 0.35, direction: -1 },    // Counter-clockwise, faster pulse
  'Evolution': { rotationSpeed: 0.28, pulsePeriod: 3.5, pulseAmount: 0.25, direction: 1 },   // Clockwise, slow pulse
  'Contemporary': { rotationSpeed: 0.3, pulsePeriod: 2.0, pulseAmount: 0.4, direction: -1 }, // Counter-clockwise, rapid pulse
  'Other': { rotationSpeed: 0.15, pulsePeriod: 4.0, pulseAmount: 0.2, direction: 1 }         // Clockwise, very slow pulse
};

// Category-based gravity system
let categoryNodes = new Map(); // Map of category name -> category node particle
let categoryGravityActive = false;
const CATEGORY_GRAVITY_THRESHOLD = 50; // Activate gravity after this many nodes
const GRAVITY_STRENGTH = 0.015; // How strong the gravitational pull is
const GRAVITY_RADIUS = 2.5; // Max distance for gravity effect
const CATEGORY_SCALE = 1.5; // Category nodes are larger
const CATEGORY_ACTIVATION_THRESHOLD = 1; // Min sub-nodes before category gets ring/color (lowered for visibility)
const MAX_CONNECTIONS_PER_NODE = 5; // Max visual connections to prevent performance issues (lowered)

// Geometric forms animation
const GEOMETRIC_FORM_DURATION = 2.0; // seconds per form transition
const GEOMETRIC_ACTIVATION_THRESHOLD = 3; // nodes spawned before activating (appear almost immediately)

// Spark particles for collision effects
const sparkParticles = [];

function createSparkEffect(position, color) {
  const sparkCount = 12 + Math.floor(Math.random() * 8);
  
  for (let i = 0; i < sparkCount; i++) {
    const spark = {
      position: position.clone(),
      velocity: new THREE.Vector3(
        (Math.random() - 0.5) * 2.0,
        (Math.random() - 0.5) * 2.0,
        (Math.random() - 0.5) * 2.0
      ),
      color: color,
      life: 1.0,
      size: 0.02 + Math.random() * 0.03
    };
    
    // Create spark mesh
    const geo = new THREE.SphereGeometry(spark.size, 4, 4);
    const mat = new THREE.MeshBasicMaterial({
      color: color,
      transparent: true,
      blending: THREE.AdditiveBlending
    });
    spark.mesh = new THREE.Mesh(geo, mat);
    spark.mesh.position.copy(position);
    scene.add(spark.mesh);
    
    sparkParticles.push(spark);
  }
}

function updateSparkParticles(dt) {
  for (let i = sparkParticles.length - 1; i >= 0; i--) {
    const spark = sparkParticles[i];
    
    // Update position
    spark.position.add(spark.velocity.clone().multiplyScalar(dt));
    spark.mesh.position.copy(spark.position);
    
    // Apply gravity
    spark.velocity.y -= dt * 2.0;
    
    // Fade out
    spark.life -= dt * 2.0;
    spark.mesh.material.opacity = Math.max(0, spark.life);
    spark.mesh.scale.setScalar(spark.life);
    
    // Remove dead sparks
    if (spark.life <= 0) {
      scene.remove(spark.mesh);
      sparkParticles.splice(i, 1);
    }
  }
}

// Twinkling Light Particle for Nodes
class NodeParticle {
  constructor(nodeData, spiralAngle, spiralRadius) {
    this.data = nodeData;
    this.id = nodeData.id; // Node ID for matching
    this.title = nodeData.title;
    this.importance = nodeData.importance || 1;
    this.era = nodeData.era;
    
    // Track-based positioning system
    this.spokeAngle = spiralAngle; // Angle of the spoke this node is on
    this.initialSpokeAngle = spiralAngle; // Remember starting angle
    this.spokeDistance = spiralRadius; // Distance along the spoke from center
    this.initialSpokeDistance = spiralRadius; // Remember starting distance
    this.height = (Math.random() - 0.5) * 0.8; // Y position
    this.inwardSpeed = 0.005; // Speed sliding toward center along spoke
    this.hasCompletedFirstRotation = false; // Track if one rotation is done
    this.totalRotation = 0; // Accumulated rotation amount
    
    // Calculate initial position from spoke
    this.position = new THREE.Vector3(
      Math.cos(this.spokeAngle) * this.spokeDistance,
      this.height,
      Math.sin(this.spokeAngle) * this.spokeDistance
    );
    
    this.twinklePhase = Math.random() * Math.PI * 2;
    this.twinkleSpeed = 3.0 + Math.random() * 2.0;
    
    // Cluster info for group animation
    this.clusterKey = nodeData.era || 'Other';
    this.clusterPhaseOffset = Math.random() * Math.PI * 2;
    
    // Category system - identify if this is a category node or a sub-node
    // Categories are identified by having CAT. prefix OR being the target of category relationships
    this.isCategory = nodeData.id.startsWith('CAT.') || nodeData.isCategory === true;
    this.category = nodeData.category || null; // Category ID this node belongs to
    this.attractedCount = 0; // Track how many sub-nodes are attracted (for categories)
    this.categoryActivated = false; // Whether category styling is active
    
    // Drift behavior - nodes occasionally drift toward connected nodes
    this.isDrifting = false;
    this.driftTarget = null; // Target node to drift toward
    this.driftProgress = 0; // 0 to 1 progress along drift path
    this.driftSpeed = 0; // Current speed (accelerates)
    this.driftStartPos = null;
    this.driftStartTime = 0;
    
    // Make particles larger and more visible (category nodes are bigger)
    const baseSize = 0.08 + (this.importance / 10) * 0.04;
    const size = this.isCategory ? baseSize * CATEGORY_SCALE : baseSize;
    const geo = new THREE.SphereGeometry(size, 8, 8);
    
    // Store era color
    let eraColor = 0xaaaaaa;
    if(nodeData.era === 'Taxonomy') eraColor = 0x88ddff;
    else if(nodeData.era === 'Genesis') eraColor = 0xffaacc;
    else if(nodeData.era === 'Evolution') eraColor = 0xaaffaa;
    else if(nodeData.era === 'Contemporary') eraColor = 0xffcc66;
    this.eraColor = eraColor;
    
    // Categories start with a subtle white/bright color, regular nodes yellow/orange
    let color = this.isCategory ? 0xeeeeee : 0xffaa44;
    this.baseColor = color;
    this.colorTransitionProgress = 0; // 0 = base color, 1 = era color
    
    // Debug log for categories
    if (this.isCategory) {
      console.log(`ðŸŽ¨ Creating category "${nodeData.title}" with white color: #${color.toString(16)}, size: ${size.toFixed(3)}`);
    }
    
    const mat = new THREE.MeshBasicMaterial({
      color,
      transparent: true,
      opacity: 0.0,
      blending: THREE.AdditiveBlending
    });
    
    this.mesh = new THREE.Mesh(geo, mat);
    this.mesh.position.copy(this.position);
    this.mesh.visible = false;
    scene.add(this.mesh);
    
    // Add subtle ring glow for category nodes (visible but subtle, brightens on activation)
    if (this.isCategory) {
      const ringGeo = new THREE.RingGeometry(size * 1.5, size * 2.0, 16);
      const ringMat = new THREE.MeshBasicMaterial({
        color,
        transparent: true,
        opacity: 0.15, // Start subtle
        side: THREE.DoubleSide,
        blending: THREE.AdditiveBlending
      });
      this.ring = new THREE.Mesh(ringGeo, ringMat);
      this.ring.visible = false; // Will be visible when spawned
      this.mesh.add(this.ring);
    }
    
    // Create label sprite (main title)
    const colorHex = '#' + color.toString(16).padStart(6, '0');
    this.labelSprite = pixelTextSprite(this.title, colorHex);
    this.labelSprite.visible = false;
    this.labelSprite.scale.multiplyScalar(0.5); // Larger labels for better visibility
    scene.add(this.labelSprite);
    
    // Create metadata text lines (smaller, dimmer) with typing animation
    const r = ((color >> 16) & 0xff) * 0.6;
    const g = ((color >> 8) & 0xff) * 0.6;
    const b = (color & 0xff) * 0.6;
    const dimColor = (Math.floor(r) << 16) | (Math.floor(g) << 8) | Math.floor(b);
    const dimColorHex = '#' + dimColor.toString(16).padStart(6, '0');
    this.metaLabels = [];
    this.metaTexts = []; // Store full text for typing animation
    this.typingProgress = 0; // Characters revealed so far
    this.typingSpeed = 0.02; // Seconds per character (faster typing)
    this.lastTypingTime = 0;
    
    // Helper function to wrap text at word boundaries
    const wrapText = (text, maxLength) => {
      const lines = [];
      let currentLine = '';
      const words = text.split(' ');
      
      for (const word of words) {
        const testLine = currentLine ? `${currentLine} ${word}` : word;
        if (testLine.length <= maxLength) {
          currentLine = testLine;
        } else {
          if (currentLine) lines.push(currentLine);
          currentLine = word;
          // If single word is longer than maxLength, truncate it
          if (word.length > maxLength) {
            currentLine = word.substring(0, maxLength - 3) + '...';
          }
        }
      }
      if (currentLine) lines.push(currentLine);
      return lines;
    };
    
    // Build metadata lines with full text
    const metaLines = [];
    
    // Category line
    if (nodeData.category) {
      metaLines.push({ text: `[Category: ${nodeData.category}]`, scale: 0.2 });
    }
    
    // Description lines (wrap at word boundaries)
    if (nodeData.definition) {
      const defLines = wrapText(nodeData.definition, 40); // Shorter line length for better wrapping
      defLines.slice(0, 3).forEach(line => { // Max 3 lines
        metaLines.push({ text: line, scale: 0.16 });
      });
      if (defLines.length > 3) {
        // Add ellipsis to last line if truncated
        const lastLine = metaLines[metaLines.length - 1];
        lastLine.text = lastLine.text.substring(0, 37) + '...';
      }
    }
    
    // Year/When introduced
    if (nodeData.when && nodeData.when !== 'â€”') {
      metaLines.push({ text: `Year: ${nodeData.when}`, scale: 0.15 });
    }
    
    // Proto-example (wrap at word boundaries)
    if (nodeData.protoExample) {
      const protoLines = wrapText(`"${nodeData.protoExample}"`, 35);
      protoLines.slice(0, 2).forEach(line => { // Max 2 lines
        metaLines.push({ text: line, scale: 0.15 });
      });
      if (protoLines.length > 2) {
        // Add ellipsis to last line if truncated
        const lastLine = metaLines[metaLines.length - 1];
        lastLine.text = lastLine.text.substring(0, 32) + '...';
      }
    }
    
    // Connection line (will be set later when connections are available)
    metaLines.push({ text: '', scale: 0.12 }); // Placeholder
    
    // Create sprite for each line
    metaLines.forEach((line, idx) => {
      const label = pixelTextSprite(line.text, dimColorHex);
      label.visible = false;
      label.scale.multiplyScalar(line.scale);
      label.userData.fullText = line.text;
      label.userData.currentText = '';
      label.userData.lineIndex = idx;
      scene.add(label);
      this.metaLabels.push(label);
      this.metaTexts.push(line.text);
    });
    
    this.visible = false;
    this.opacity = 0.0;
    this.connections = []; // IDs of connected nodes
    this.labelsVisible = false; // Track label visibility separately
    this.labelShowTime = 0; // When labels should appear
    this.isHovered = false; // Track hover state
    this.hoverTransition = 0.0; // Smooth transition for hover effect (0 to 1)
  }
  
  spawn(spawnTime, showLabelsImmediately = true) {
    this.visible = true;
    this.mesh.visible = true;
    
    // Delayed labels for first nodes, immediate for rest
    if (showLabelsImmediately) {
      this.labelSprite.visible = true;
      this.metaLabels.forEach(label => label.visible = true);
      this.labelsVisible = true;
    } else {
      this.labelSprite.visible = false;
      this.metaLabels.forEach(label => label.visible = false);
      this.labelShowTime = spawnTime + LABEL_DELAY_FOR_FIRST_NODES;
      this.labelsVisible = false;
    }
    
    // Show ring immediately for categories (subtle at first, brightens on activation)
    if (this.ring) this.ring.visible = true;
    this.lastTypingTime = spawnTime; // Start typing animation timer
    
  }
  
  // Add a connection line to metadata
  addConnectionLine(targetNodeTitle) {
    const lastLabel = this.metaLabels[this.metaLabels.length - 1];
    if (lastLabel && !lastLabel.userData.fullText) {
      const connText = `â†’ Leads to: ${targetNodeTitle}`;
      lastLabel.userData.fullText = connText;
      this.metaTexts[this.metaTexts.length - 1] = connText;
      
      // Recreate sprite with new text
      const newLabel = pixelTextSprite(connText, lastLabel.material.map ? '#888888' : '#ffffff');
      newLabel.visible = lastLabel.visible;
      newLabel.scale.copy(lastLabel.scale);
      newLabel.position.copy(lastLabel.position);
      newLabel.userData.fullText = connText;
      newLabel.userData.currentText = '';
      newLabel.userData.lineIndex = lastLabel.userData.lineIndex;
      scene.remove(lastLabel);
      scene.add(newLabel);
      this.metaLabels[this.metaLabels.length - 1] = newLabel;
    }
  }
  
  update(dt, time) {
    // Skip if disposed or mesh is null
    if (!this.visible || !this.mesh) return;
    
    // Fade in
    if (this.opacity < 1.0) {
      this.opacity = Math.min(1.0, this.opacity + dt * 2.0);
    }
    
    // Check if labels should appear (for delayed labels)
    if (!this.labelsVisible && this.labelShowTime > 0 && time >= this.labelShowTime) {
      this.labelSprite.visible = true;
      this.metaLabels.forEach(label => label.visible = true);
      this.labelsVisible = true;
    }
    
    // Category activation: only activate when enough sub-nodes are attracted
    if (this.isCategory && !this.categoryActivated) {
      // Debug log occasionally for categories
      if (Math.random() < 0.001) {
        console.log(`ðŸ” Category ${this.title}: ${this.attractedCount}/${CATEGORY_ACTIVATION_THRESHOLD} attracted`);
      }
      
      if (this.attractedCount >= CATEGORY_ACTIVATION_THRESHOLD) {
        this.categoryActivated = true;
        // Brighten the ring (it's already visible)
        if (this.ring) this.ring.material.opacity = 0.4;
        console.log(`âœ¨ Category activated: ${this.title} (${this.attractedCount} sub-nodes)`);
      }
    }
    
    // Color transition from yellow/orange to era color
    // For categories: only after activation
    // For regular nodes: after threshold
    const shouldTransition = this.isCategory ? this.categoryActivated : (nodesSpawned >= CATEGORY_GRAVITY_THRESHOLD);
    
    if (shouldTransition && this.colorTransitionProgress < 1.0) {
      this.colorTransitionProgress = Math.min(1.0, this.colorTransitionProgress + dt * 0.3);
      
      // Lerp between yellow/orange and era color
      const r1 = (this.baseColor >> 16) & 0xff;
      const g1 = (this.baseColor >> 8) & 0xff;
      const b1 = this.baseColor & 0xff;
      const r2 = (this.eraColor >> 16) & 0xff;
      const g2 = (this.eraColor >> 8) & 0xff;
      const b2 = this.eraColor & 0xff;
      
      const t = this.colorTransitionProgress;
      const r = Math.floor(r1 + (r2 - r1) * t);
      const g = Math.floor(g1 + (g2 - g1) * t);
      const b = Math.floor(b1 + (b2 - b1) * t);
      const newColor = (r << 16) | (g << 8) | b;
      
      this.mesh.material.color.setHex(newColor);
      if (this.ring) this.ring.material.color.setHex(newColor);
    }
    
    // Typing animation for metadata
    if (time - this.lastTypingTime > this.typingSpeed) {
      this.typingProgress++;
      this.lastTypingTime = time;
    }
    
    // Smooth hover transition
    const hoverSpeed = 6.0; // Speed of hover fade in/out
    if (this.isHovered) {
      this.hoverTransition = Math.min(1.0, this.hoverTransition + dt * hoverSpeed);
    } else {
      this.hoverTransition = Math.max(0.0, this.hoverTransition - dt * hoverSpeed);
    }
    
    // Twinkling effect - make brighter and more visible
    // Categories are brighter overall, even brighter when activated
    const baseTwinkle = 0.5 + 0.5 * Math.sin(time * this.twinkleSpeed + this.twinklePhase);
    let twinkle = baseTwinkle;
    if (this.isCategory) {
      twinkle = this.categoryActivated ? 0.8 + 0.2 * baseTwinkle : 0.6 + 0.3 * baseTwinkle;
    }
    
    // Hover effect: boost opacity to full and add extra brightness
    const hoverBoost = this.hoverTransition * 0.5; // Extra opacity when hovered
    const finalOpacity = Math.min(1.0, this.opacity * twinkle + hoverBoost);
    if (this.mesh.material) {
      this.mesh.material.opacity = finalOpacity;
    }
    
    // Subtle pulse scale (amplified when hovered)
    const pulseAmount = 0.2 + this.hoverTransition * 0.15; // Larger pulse when hovered
    const pulse = 1.0 + Math.sin(time * 2.0 + this.twinklePhase) * pulseAmount;
    if (this.mesh.scale) {
      this.mesh.scale.setScalar(pulse);
    }
    
    // Animate category ring (visible for all categories, brighter when activated and when hovered)
    if (this.ring && this.ring.visible && this.ring.material) {
      this.ring.rotation.z = time * 0.5; // Slow rotation
      const baseOpacity = this.categoryActivated ? 0.35 : 0.15;
      const pulseAmount = this.categoryActivated ? 0.15 : 0.05;
      const hoverRingBoost = this.hoverTransition * 0.3; // Extra glow when hovered
      const ringOpacity = baseOpacity + pulseAmount * Math.sin(time * 1.5 + this.twinklePhase) + hoverRingBoost;
      this.ring.material.opacity = Math.min(0.8, ringOpacity);
      // Billboard to camera (with safety check)
      if (typeof camera !== 'undefined' && camera && camera.position) {
        this.ring.lookAt(camera.position);
      }
    }
    
    // Track-based positioning system - much simpler and more efficient
    const config = clusterConfigs[this.clusterKey] || clusterConfigs.Other;
    
    // Spoke rotation (the track rotates around the center)
    const motionScale = (this.isCategory && this.categoryActivated) ? 0.3 : 1.0;
    const rotationSpeed = config.rotationSpeed * config.direction * motionScale;
    const rotationDelta = rotationSpeed * dt;
    this.spokeAngle += rotationDelta; // Rotate the spoke
    
    // Track total rotation to detect first full rotation
    if (!this.hasCompletedFirstRotation) {
      this.totalRotation += Math.abs(rotationDelta);
      if (this.totalRotation >= Math.PI * 2) {
        this.hasCompletedFirstRotation = true;
        // Only log for first few nodes to avoid spam
        if (nodeParticles.filter(p => p.hasCompletedFirstRotation).length < 5) {
          console.log(`âœ“ Node "${this.title}" completed first rotation - begin inward slide`);
        }
      }
    }
    
    // Slide inward along the spoke (only after first rotation completes)
    if (this.hasCompletedFirstRotation) {
      this.spokeDistance -= this.inwardSpeed * dt * 60; // Slide toward center
      this.spokeDistance = Math.max(0, this.spokeDistance); // Don't go past center
    }
    
    // Pulsating effect - slight radial movement
    const pulseFactor = Math.sin(time / config.pulsePeriod + this.clusterPhaseOffset) * config.pulseAmount * motionScale;
    const currentDistance = this.spokeDistance * (1.0 + pulseFactor * 0.3);
    
    // Wave form - Y variance based on spoke angle
    const waveAmplitude = 0.6; // Height of the wave
    const waveFrequency = 2.0; // Number of waves around the circle
    const waveY = Math.sin(this.spokeAngle * waveFrequency) * waveAmplitude;
    
    // Gentle vertical oscillation (additional)
    const drift = Math.sin(time * 0.5 + this.twinklePhase) * 0.02;
    
    // Calculate position from spoke (angle + distance)
    let targetX = Math.cos(this.spokeAngle) * currentDistance;
    let targetY = this.height + waveY + drift; // Base height + wave + gentle drift
    let targetZ = Math.sin(this.spokeAngle) * currentDistance;
    
    // Handle drift behavior (overrides normal movement)
    if (this.isDrifting && this.driftTarget && this.driftTarget.visible && this.driftTarget.mesh && this.driftTarget.mesh.position && this.mesh && this.mesh.position) {
      // Accelerate drift speed
      this.driftSpeed = Math.min(this.driftSpeed + dt * 0.15, 0.8); // Cap at 0.8
      this.driftProgress += this.driftSpeed * dt * 2.0;
      
      // Lerp from start to target
      const targetPos = this.driftTarget.mesh.position;
      this.mesh.position.lerpVectors(this.driftStartPos, targetPos, this.driftProgress);
      
      // Check if reached target (within collision distance)
      const distance = this.mesh.position.distanceTo(targetPos);
      if (this.driftProgress >= 1.0 || distance < 0.1) {
        // Collision! Create spark effect
        createSparkEffect(this.mesh.position.clone(), this.baseColor);
        
        // Dispose of this node
        this.dispose();
        this.isDrifting = false;
      }
    } else if (this.isDrifting) {
      // Target was disposed, cancel drift
      this.isDrifting = false;
      this.driftTarget = null;
    }
    
    if (!this.isDrifting) {
      // Set final position (normal cluster/gravity behavior)
      if (this.mesh && this.mesh.position) {
        this.mesh.position.set(targetX, targetY, targetZ);
        
        // Cull nodes that have reached the center (completed their journey)
        const visibleCount = nodeParticles.filter(p => p && p.visible).length;
        
        if (visibleCount > 20 && this.spokeDistance < 0.5 && this.opacity >= 0.9) {
          // Node has reached the synthesis point at center
          createSparkEffect(this.mesh.position.clone(), this.baseColor);
          this.dispose(); // Dispose of all resources
        }
      }
    }
    
    // Update label position (above the node) - sprites auto-billboard to camera
    if (this.labelSprite && this.labelSprite.visible && this.labelSprite.position && this.mesh && this.mesh.position) {
      this.labelSprite.position.copy(this.mesh.position);
      this.labelSprite.position.y += 0.2; // Higher offset for better visibility
      // Brighten label when hovered
      if (this.labelSprite.material) {
        const labelOpacity = Math.min(1.0, this.opacity + this.hoverTransition * 0.5);
        this.labelSprite.material.opacity = labelOpacity;
      }
      this.labelSprite.renderOrder = 999; // Ensure labels render on top
    }
    
    // Update metadata labels with typing animation (stacked below main label)
    let yOffset = 0.10; // Start below main label
    let totalChars = 0;
    
    if (this.metaLabels && this.mesh && this.mesh.position) {
      this.metaLabels.forEach((label, idx) => {
        // Safety check: ensure label still exists
        if (!label || !label.position) return;
        
        const fullText = this.metaTexts[idx] || '';
        const charsBeforeThisLine = totalChars;
        totalChars += fullText.length;
        
        // Calculate how many characters of this line should be visible
        const visibleChars = Math.max(0, this.typingProgress - charsBeforeThisLine);
        const currentText = fullText.substring(0, visibleChars);
        
        // Only recreate sprite if text changed
        if (currentText !== label.userData.currentText && currentText.length > 0) {
          label.userData.currentText = currentText;
          
          // Recreate sprite with current visible text
          const dimColorHex = label.material && label.material.color ? 
            '#' + label.material.color.getHexString() : '#888888';
          const newSprite = pixelTextSprite(currentText, dimColorHex);
          newSprite.visible = label.visible;
          newSprite.scale.copy(label.scale);
          newSprite.userData.fullText = fullText;
          newSprite.userData.currentText = currentText;
          newSprite.userData.lineIndex = idx;
          
          // Dispose old sprite resources
          scene.remove(label);
          if (label.geometry) label.geometry.dispose();
          if (label.material) label.material.dispose();
          
          scene.add(newSprite);
          this.metaLabels[idx] = newSprite;
          label = newSprite;
        }
        
        // Position label
        if (label.position && this.mesh && this.mesh.position) {
          label.position.copy(this.mesh.position);
          label.position.y += yOffset;
          // Brighten metadata labels when hovered too
          if (label.material) {
            const metaOpacity = Math.min(0.9, (this.opacity * 0.7) + (this.hoverTransition * 0.4));
            label.material.opacity = metaOpacity;
          }
          label.renderOrder = 998; // Ensure metadata labels render on top (but below main label)
        }
        
        // Spacing between lines (0.08 for better readability with wrapped text)
        yOffset -= 0.08;
      });
    }
  }
  
  // Start drifting toward a target node
  startDrift(targetParticle) {
    if (this.isDrifting || !targetParticle || !targetParticle.mesh || !this.visible) return;
    
    this.isDrifting = true;
    this.driftTarget = targetParticle;
    this.driftProgress = 0;
    this.driftSpeed = 0.02; // Start slow
    this.driftStartPos = this.mesh.position.clone();
    this.driftStartTime = performance.now();
  }
  
  hide() {
    this.visible = false;
    if (this.mesh) this.mesh.visible = false;
    if (this.labelSprite) {
      this.labelSprite.visible = false;
    }
    if (this.metaLabels) {
      this.metaLabels.forEach(label => {
        if (label) label.visible = false;
      });
    }
    if (this.ring) this.ring.visible = false;
  }
  
  // Dispose of all resources (called when node is culled)
  dispose() {
    // Mark as not visible and disposed immediately
    this.visible = false;
    this.isHovered = false;
    this.isDrifting = false;
    this.driftTarget = null;
    
    // Remove and dispose mesh
    if (this.mesh) {
      scene.remove(this.mesh);
      if (this.mesh.geometry) this.mesh.geometry.dispose();
      if (this.mesh.material) this.mesh.material.dispose();
      this.mesh = null; // Clear reference for garbage collection
    }
    
    // Remove and dispose ring
    if (this.ring) {
      if (this.ring.geometry) this.ring.geometry.dispose();
      if (this.ring.material) this.ring.material.dispose();
      this.ring = null;
    }
    
    // Remove and dispose label sprite (now a mesh)
    if (this.labelSprite) {
      scene.remove(this.labelSprite);
      if (this.labelSprite.geometry) this.labelSprite.geometry.dispose();
      if (this.labelSprite.material) this.labelSprite.material.dispose();
      // Note: We don't dispose the atlas texture since it's shared across all text
      this.labelSprite = null;
    }
    
    // Remove and dispose metadata labels
    if (this.metaLabels) {
      this.metaLabels.forEach(label => {
        if (label) {
          scene.remove(label);
          if (label.geometry) label.geometry.dispose();
          if (label.material) label.material.dispose();
          // Note: We don't dispose the atlas texture since it's shared across all text
        }
      });
      this.metaLabels = [];
    }
  }
}

// Parse node connections from data
function parseNodeConnections(nodes) {
  const connections = [];
  const nodeMap = new Map(nodes.map(n => [n.id, n]));
  const categoryMap = new Map(); // Track category relationships
  
  nodes.forEach(node => {
    // Parse structured connections if they exist (check multiple possible field names)
    const connField = node.connections || node.relations || node.links || [];
    if (Array.isArray(connField)) {
      connField.forEach(conn => {
        // Handle both object and string formats
        let targetId, connType;
        if (typeof conn === 'string') {
          targetId = conn;
          connType = 'default';
        } else {
          targetId = conn.target || conn.to || conn.id || conn.node;
          connType = (conn.type || conn.relation || conn.relationType || 'default').toLowerCase();
        }
        
        if (nodeMap.has(targetId) && targetId !== node.id) {
          connections.push({
            from: node.id,
            to: targetId,
            type: connType,
            strength: 1
          });
          
          // Track category relationships
          // 1. Explicit category connection types
          if (connType === 'categories' || connType === 'categorized as category' || 
              connType === 'category' || connType === 'is-a' || connType === 'isa') {
            categoryMap.set(node.id, targetId);
            node.category = targetId;
          }
          // 2. Any connection to a CAT. node from a non-category node
          else if (targetId.startsWith('CAT.') && !node.id.startsWith('CAT.')) {
            if (!node.category) { // Only set if not already set
              categoryMap.set(node.id, targetId);
              node.category = targetId;
            }
          }
        }
      });
    }
    
    // Extract references from definition and examples
    const textContent = [
      node.definition || '',
      node.protoExample || '',
      ...(node.examples || [])
    ].join(' ');
    
    // Find other node references (e.g., "NODE.X" or "CAT.X")
    const refs = textContent.match(/(?:NODE|CAT)\.\w+/gi) || [];
    refs.forEach(refId => {
      const normalizedRefId = refId.toUpperCase(); // Normalize to uppercase
      if (nodeMap.has(normalizedRefId) && normalizedRefId !== node.id) {
        connections.push({
          from: node.id,
          to: normalizedRefId,
          strength: 1
        });
        
        // If this is a reference to a category node, set it as this node's category
        if (normalizedRefId.startsWith('CAT.') && !node.id.startsWith('CAT.')) {
          if (!node.category) { // Only set if not already set
            node.category = normalizedRefId;
            categoryMap.set(node.id, normalizedRefId);
          }
        }
      }
    });
    
    // Infer connections from same era (weaker)
    nodes.forEach(other => {
      if (other.id !== node.id && other.era === node.era && Math.random() < 0.1) {
        connections.push({
          from: node.id,
          to: other.id,
          strength: 0.5
        });
      }
    });
  });
  
  // Find the "Category" or "Categories" node and use its connections
  const categoryNode = nodes.find(n => 
    n.title === 'Category' || 
    n.title === 'Categories' || 
    n.id === 'Category' || 
    n.id === 'Categories'
  );
  
  const categoryNodeIds = new Set();
  
  if (categoryNode) {
    console.log(`ðŸ“ Found Category master node: ${categoryNode.title} (${categoryNode.id})`);
    
    // Find all connections FROM the Category node with type "categorizes"
    connections.forEach(conn => {
      if (conn.from === categoryNode.id && conn.type === 'categorizes') {
        categoryNodeIds.add(conn.to);
        const targetNode = nodes.find(n => n.id === conn.to);
        if (targetNode) {
          console.log(`âœ… Category found via "categorizes" connection: ${targetNode.title} (${conn.to})`);
        }
      }
    });
  } else {
    console.warn('âš ï¸ No "Category" master node found - falling back to CAT. prefix detection');
    
    // Fallback: Use CAT. prefix
    nodes.forEach(node => {
      if (node.id.startsWith('CAT.')) {
        categoryNodeIds.add(node.id);
        console.log(`ðŸ“‚ Found CAT. prefix: ${node.id} (${node.title})`);
      }
    });
  }
  
  // Mark category nodes in the data
  nodes.forEach(node => {
    if (categoryNodeIds.has(node.id)) {
      node.isCategory = true;
    }
  });
  
  console.log(`ðŸ“Š Total categories identified: ${categoryNodeIds.size}`);
  
  // Log connection type statistics
  const connectionTypes = {};
  connections.forEach(conn => {
    const type = conn.type || 'default';
    connectionTypes[type] = (connectionTypes[type] || 0) + 1;
  });
  
  console.log(`ðŸ“ Found ${categoryMap.size} category relationships (nodes with assigned categories)`);
  console.log(`ðŸ“ Identified ${categoryNodeIds.size} category nodes`);
  console.log(`ðŸ”— Connection types:`, connectionTypes);
  
  // List all category nodes for debugging
  const categoryList = [];
  nodes.forEach(node => {
    if (node.isCategory) {
      categoryList.push(node.title);
    }
  });
  console.log(`ðŸ“‹ Category nodes:`, categoryList.slice(0, 10).join(', '), `... (${categoryList.length} total)`);
  
  // Log category distribution
  const categoryDistribution = new Map();
  categoryMap.forEach((catId) => {
    categoryDistribution.set(catId, (categoryDistribution.get(catId) || 0) + 1);
  });
  console.log(`ðŸ“Š Category distribution (top 10):`);
  const topCategories = Array.from(categoryDistribution.entries())
    .sort((a, b) => b[1] - a[1])
    .slice(0, 10);
  topCategories.forEach(([catId, count]) => {
    const catNode = nodes.find(n => n.id === catId);
    console.log(`   ${catNode ? catNode.title : catId}: ${count} nodes`);
  });
  
  // Log first few category relationships for debugging
  if (categoryMap.size > 0) {
    console.log('ðŸ“‹ Sample category relationships:');
    let count = 0;
    categoryMap.forEach((catId, nodeId) => {
      if (count < 3) {
        const node = nodes.find(n => n.id === nodeId);
        const cat = nodes.find(n => n.id === catId);
        if (node && cat) {
          console.log(`   ${node.title} â†’ ${cat.title}`);
        }
        count++;
      }
    });
  }
  
  return connections;
}

// Organize nodes chronologically with hierarchy priority
function organizeNodesChronologically(nodes) {
  // Extract timestamp from meta.operations if available
  const getTimestamp = (node) => {
    if (node.meta && node.meta.operations && node.meta.operations.length > 0) {
      return new Date(node.meta.operations[0].timestamp).getTime();
    }
    if (node.when && node.when !== 'â€”') {
      return new Date(node.when).getTime();
    }
    return 0;
  };
  
  // Hierarchical priority: Systems first, then mix categories with regular nodes
  const getHierarchyPriority = (node) => {
    // Check if it's a System node (from Framework)
    if (node.title === 'System' || node.title === 'Framework' || 
        node.id.includes('System') || node.id.includes('Framework')) {
      return 0;
    }
    // Categories and regular nodes both get priority 1 (will be mixed by era/time)
    return 1;
  };
  
  // Group by era priority
  const eraPriority = {
    'Taxonomy': 0,
    'Genesis': 1,
    'Evolution': 2,
    'Contemporary': 3
  };
  
  // First, separate categories from regular nodes
  const regularNodes = nodes.filter(n => !n.isCategory);
  const categoryNodesArray = nodes.filter(n => n.isCategory);
  
  // Sort regular nodes
  const sortedRegular = regularNodes.sort((a, b) => {
    const hierA = getHierarchyPriority(a);
    const hierB = getHierarchyPriority(b);
    if (hierA !== hierB) return hierA - hierB;
    
    const eraA = eraPriority[a.era] || 999;
    const eraB = eraPriority[b.era] || 999;
    if (eraA !== eraB) return eraA - eraB;
    
    return getTimestamp(a) - getTimestamp(b);
  });
  
  // Sort categories by era and timestamp
  const sortedCategories = categoryNodesArray.sort((a, b) => {
    const eraA = eraPriority[a.era] || 999;
    const eraB = eraPriority[b.era] || 999;
    if (eraA !== eraB) return eraA - eraB;
    
    return getTimestamp(a) - getTimestamp(b);
  });
  
  // Interleave categories between regular nodes (every ~20-30 nodes)
  const interleavedNodes = [];
  const categoryInterval = Math.floor(sortedRegular.length / Math.max(1, sortedCategories.length + 1));
  let catIndex = 0;
  
  for (let i = 0; i < sortedRegular.length; i++) {
    interleavedNodes.push(sortedRegular[i]);
    
    // Insert category after every N regular nodes
    if ((i + 1) % categoryInterval === 0 && catIndex < sortedCategories.length) {
      interleavedNodes.push(sortedCategories[catIndex]);
      console.log(`ðŸ”· Inserting category "${sortedCategories[catIndex].title}" at position ${interleavedNodes.length - 1}`);
      catIndex++;
    }
  }
  
  // Add any remaining categories at the end
  while (catIndex < sortedCategories.length) {
    interleavedNodes.push(sortedCategories[catIndex]);
    console.log(`ðŸ”· Adding remaining category "${sortedCategories[catIndex].title}" at position ${interleavedNodes.length - 1}`);
    catIndex++;
  }
  
  console.log(`ðŸ”¢ Total: ${interleavedNodes.length} nodes (${sortedRegular.length} regular, ${sortedCategories.length} categories)`);
  console.log(`ðŸ”¢ Category interval: every ${categoryInterval} nodes`);
  console.log(`ðŸ”¢ First 10 categories:`, sortedCategories.slice(0, 10).map(n => n.title));
  
  return interleavedNodes;
}

// Load and parse nodes with proper data ingestion
async function loadNodeData() {
  try {
    // Try to load from external file first
    const response = await fetch('./node-data/nodes.json');
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    const data = await response.json();
    nodesData = data;
    console.log(`âœ“ Loaded ${nodesData.length} nodes from node-data/nodes.json`);
  } catch(err) {
    console.error('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    console.error('âŒ Failed to load node data:', err.message);
    console.error('');
    console.error('   The file:// protocol does not support fetch().');
    console.error('   To fix this, run a local web server:');
    console.error('');
    console.error('   Option 1 (Python):');
    console.error('     python -m http.server 8000');
    console.error('     Then open: http://localhost:8000/triangle.html');
    console.error('');
    console.error('   Option 2 (Node.js):');
    console.error('     npx http-server -p 8000');
    console.error('     Then open: http://localhost:8000/triangle.html');
    console.error('');
    console.error('   The node swarm will remain disabled until data is loaded.');
    console.error('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    nodesData = [];
    return;
  }
  
  if (nodesData.length === 0) {
    console.warn('No nodes loaded, swarm will be disabled');
    return;
  }
  
  // Debug: log first node to see structure
  if (nodesData.length > 0) {
    console.log('ðŸ“‹ Sample node structure:', nodesData[0]);
  }
  
  // IMPORTANT: Parse connections FIRST to mark categories, THEN organize
  nodeConnections = parseNodeConnections(nodesData);
  
  // Organize nodes chronologically (now with category flags set)
  nodesData = organizeNodesChronologically(nodesData);
  
  console.log(`âœ“ Parsed ${nodeConnections.length} connection relationships`);
  console.log(`âœ“ Organized ${nodesData.length} nodes chronologically`);
  console.log(`âœ“ Ready to spawn when "Concept" appears`);
}

// Start the node swarm spiral
function startNodeSwarm() {
  if (nodeSwarmActive) return;
  if (nodesData.length === 0) {
    console.warn('Cannot start node swarm: no data loaded');
    return;
  }
  
  nodeSwarmActive = true;
  nodesSpawned = 0;
  spiralAngle = 0;
  spiralRadius = 2.5; // Start closer to center for visibility
  burstAccumulator = 0;
  
  console.log(`Starting node swarm with ${nodesData.length} nodes`);
}

// Spawn next burst of nodes in spiral (with staggered delays)
function spawnNodeBurst(time) {
  if (nodesSpawned >= nodesData.length) return;
  
  const burstSize = Math.min(NODES_PER_BURST, nodesData.length - nodesSpawned);
  
  // Queue nodes with staggered spawn times
  for (let i = 0; i < burstSize; i++) {
    const nodeData = nodesData[nodesSpawned];
    const spawnDelay = i * NODE_STAGGER_DELAY; // Each node delayed more than the previous
    
    pendingSpawns.push({
      nodeData,
      spawnTime: time + spawnDelay,
      spiralAngle,
      spiralRadius
    });
    
    // Advance spiral for next node
    spiralAngle += Math.PI * 0.4; // ~72 degrees
    spiralRadius += SPIRAL_EXPANSION;
    nodesSpawned++;
  }
}

// Process pending spawns (called each frame)
function processPendingSpawns(time) {
  // Filter and spawn nodes whose time has come
  const toSpawn = [];
  pendingSpawns = pendingSpawns.filter(pending => {
    if (time >= pending.spawnTime) {
      toSpawn.push(pending);
      return false; // Remove from queue
    }
    return true; // Keep in queue
  });
  
  // Spawn nodes
  toSpawn.forEach(pending => {
    const { nodeData, spiralAngle, spiralRadius } = pending;
    
    // Debug log BEFORE creating particle
    if (nodeData.isCategory || nodeData.id.startsWith('CAT.')) {
      console.log(`ðŸ”¶ About to create category particle: ${nodeData.title} (${nodeData.id}), isCategory flag:`, nodeData.isCategory);
    }
    
    // Create particle in spiral at the REAR (furthest out position)
    const particle = new NodeParticle(nodeData, spiralAngle, spiralRadius);
    const particleIndex = nodeParticles.length;
    nodeParticles.push(particle);
    
    // First nodes get delayed labels, rest get immediate labels
    const showLabelsImmediately = particleIndex >= FIRST_NODES_COUNT;
    particle.spawn(time, showLabelsImmediately);
    
    // Debug log AFTER creating particle
    if (particle.isCategory) {
      console.log(`ðŸ”· Category particle created: ${particle.title}, mesh visible:`, particle.mesh.visible, 'ring:', !!particle.ring);
    }
    
    // Add connection info if available
    if (nodeData.connections && nodeData.connections.length > 0) {
      const firstConn = nodeData.connections[0];
      const targetId = typeof firstConn === 'string' ? firstConn : 
                       (firstConn.target || firstConn.to || firstConn.id || firstConn.node);
      if (targetId) {
        const targetNode = nodesData.find(n => n.id === targetId);
        if (targetNode) {
          particle.addConnectionLine(targetNode.title);
        }
      }
    }
    
    // Add to cluster tracking
    const clusterKey = particle.clusterKey;
    if (!nodeClusters[clusterKey]) {
      nodeClusters[clusterKey] = [];
      const config = clusterConfigs[clusterKey] || clusterConfigs.Other;
      console.log(`âœ¨ New cluster formed: ${clusterKey} (rotation: ${config.direction > 0 ? 'clockwise' : 'counter-clockwise'}, pulse: ${config.pulsePeriod}s)`);
    }
    nodeClusters[clusterKey].push(particle);
    
    // Track category nodes and update existing particles
    if (particle.isCategory) {
      const catKey = particle.id; // Use node ID as category key
      categoryNodes.set(catKey, particle);
      console.log(`ðŸ“ Category node emerged: ${particle.title} (${catKey}) - WHITE with RING visible`);
      
      // Retroactively assign this category as gravity target to existing sub-nodes
      let attracted = 0;
      nodeParticles.forEach(p => {
        if (!p.isCategory && p.category === catKey && !p.gravityTarget && p.mesh && p.visible) {
          p.gravityTarget = particle.mesh.position;
          attracted++;
        }
      });
      if (attracted > 0) {
        particle.attractedCount += attracted; // Add to existing count
        console.log(`   â†³ Attracted ${attracted} existing sub-nodes (total: ${particle.attractedCount}/${CATEGORY_ACTIVATION_THRESHOLD})`);
      }
    }
    
    // Assign gravity target to sub-nodes if category exists
    if (!particle.isCategory && particle.category) {
      const categoryNode = categoryNodes.get(particle.category);
      if (categoryNode && categoryNode.mesh && categoryNode.visible) {
        particle.gravityTarget = categoryNode.mesh.position;
        categoryNode.attractedCount++; // Increment category's attracted count
        // Log category attraction progress
        if (categoryNode.attractedCount <= CATEGORY_ACTIVATION_THRESHOLD + 2) {
          console.log(`ðŸ”— Sub-node ${particle.title} â†’ category ${categoryNode.title} (count: ${categoryNode.attractedCount}/${CATEGORY_ACTIVATION_THRESHOLD})`);
        }
      } else {
        // Category not spawned yet - log for debugging
        if (Math.random() < 0.02) {
          console.log(`âš ï¸ Sub-node ${particle.title} has category ${particle.category} but category not yet spawned`);
        }
      }
    } else if (!particle.isCategory && !particle.gravityTarget && categoryGravityActive && categoryNodes.size > 0) {
      // Orphaned node: assign to nearest category node
      let nearestCat = null;
      let nearestDist = Infinity;
      categoryNodes.forEach(catNode => {
        // Skip disposed category nodes
        if (!catNode.mesh || !catNode.visible) return;
        
        const dx = catNode.mesh.position.x - particle.mesh.position.x;
        const dy = catNode.mesh.position.y - particle.mesh.position.y;
        const dz = catNode.mesh.position.z - particle.mesh.position.z;
        const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
        if (dist < nearestDist) {
          nearestDist = dist;
          nearestCat = catNode;
        }
      });
      if (nearestCat && nearestCat.mesh) {
        particle.gravityTarget = nearestCat.mesh.position;
      }
    }
    
    // Activate gravity system after threshold
    if (nodesSpawned >= CATEGORY_GRAVITY_THRESHOLD && !categoryGravityActive) {
      categoryGravityActive = true;
      console.log(`ðŸŒŒ Category gravity activated! ${categoryNodes.size} category nodes pulling ${nodeParticles.length - categoryNodes.size} sub-nodes`);
    }
    
    // Debug: log particles with emphasis on categories
    const currentCount = nodeParticles.length;
    if (currentCount < 10 || particle.isCategory) {
      const colorHex = '#' + particle.baseColor.toString(16).padStart(6, '0');
      const logPrefix = particle.isCategory ? 'ðŸ·ï¸ CATEGORY' : 'ðŸ“Œ';
      console.log(`${logPrefix} Spawned node ${currentCount}: ${particle.title}`, 
        'isCategory:', particle.isCategory, 
        'color:', colorHex,
        'hasRing:', !!particle.ring,
        'ringVisible:', particle.ring ? particle.ring.visible : 'N/A',
        'size:', particle.mesh.geometry.parameters.radius.toFixed(2),
        'visible:', particle.visible);
    }
  });
}

// Create connection lines based on parsed connections (with max limit per node)
function createConnectionLinesForNewNodes(startIdx, endIdx) {
  const nodeMap = new Map(nodeParticles.map(p => [p.id, p]));
  const newConnections = connectionLines.length;
  
  // Track connections per node to enforce max limit
  const connectionCounts = new Map();
  connectionLines.forEach(conn => {
    const fromId = conn.particleA.id;
    const toId = conn.particleB.id;
    connectionCounts.set(fromId, (connectionCounts.get(fromId) || 0) + 1);
    connectionCounts.set(toId, (connectionCounts.get(toId) || 0) + 1);
  });
  
  // Find connections in connectionLines array that involve the new nodes
  nodesData.slice(startIdx, endIdx).forEach((nodeData) => {
    const fromParticle = nodeMap.get(nodeData.id);
    if (!fromParticle) return;
    
    let nodeConnCount = connectionCounts.get(fromParticle.id) || 0;
    
    // Find connections from parseNodeConnections
    nodeConnections.forEach(conn => {
      // Check max connection limit
      if (nodeConnCount >= MAX_CONNECTIONS_PER_NODE) return;
      
      if (conn.from === nodeData.id) {
        const toParticle = nodeMap.get(conn.to);
        const toCount = connectionCounts.get(conn.to) || 0;
        
        if (toParticle && toParticle.visible && toCount < MAX_CONNECTIONS_PER_NODE) {
          const created = createConnectionLine(fromParticle, toParticle, conn.strength);
          if (created) {
            nodeConnCount++;
            connectionCounts.set(fromParticle.id, nodeConnCount);
            connectionCounts.set(toParticle.id, toCount + 1);
          }
        }
      }
      if (conn.to === nodeData.id) {
        const fromParticle2 = nodeMap.get(conn.from);
        const fromCount = connectionCounts.get(conn.from) || 0;
        
        if (fromParticle2 && fromParticle2.visible && 
            nodeConnCount < MAX_CONNECTIONS_PER_NODE && 
            fromCount < MAX_CONNECTIONS_PER_NODE) {
          const created = createConnectionLine(fromParticle2, fromParticle, conn.strength);
          if (created) {
            nodeConnCount++;
            connectionCounts.set(fromParticle.id, nodeConnCount);
            connectionCounts.set(fromParticle2.id, fromCount + 1);
          }
        }
      }
    });
  });
  
  const created = connectionLines.length - newConnections;
  if (created > 0) {
    console.log(`Created ${created} new connection lines`);
  }
}

// Create a single connection line between two particles
function createConnectionLine(particleA, particleB, strength) {
  // Check if connection already exists
  const exists = connectionLines.some(conn => 
    (conn.particleA === particleA && conn.particleB === particleB) ||
    (conn.particleA === particleB && conn.particleB === particleA)
  );
  
  if (exists) return false;
  
  // Create line geometry with multiple segments for smooth pulses
  const segments = 32;
  const positions = new Float32Array((segments + 1) * 3);
  const progress = new Float32Array(segments + 1);
  
  // Initialize progress values
  for (let i = 0; i <= segments; i++) {
    progress[i] = i / segments;
  }
  
  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geo.setAttribute('progress', new THREE.BufferAttribute(progress, 1));
  
  // Shader material for animated glowing pulses
  const mat = new THREE.ShaderMaterial({
    uniforms: {
      uTime: { value: 0 },
      uColor: { value: new THREE.Color(0x6688ff) },
      uOpacity: { value: 0.3 * strength },
      uPulseSpeed: { value: 0.5 + Math.random() * 0.5 }, // Vary speed
      uPhaseOffset: { value: Math.random() * Math.PI * 2 } // Random start phase
    },
    vertexShader: `
      attribute float progress;
      varying float vProgress;
      void main() {
        vProgress = progress;
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        gl_Position = projectionMatrix * mvPosition;
      }
    `,
    fragmentShader: `
      uniform float uTime;
      uniform vec3 uColor;
      uniform float uOpacity;
      uniform float uPulseSpeed;
      uniform float uPhaseOffset;
      varying float vProgress;
      
      void main() {
        // Create traveling pulse effect
        float pulsePos = fract(uTime * uPulseSpeed + uPhaseOffset);
        float distToPulse = abs(vProgress - pulsePos);
        
        // Sharp glowing pulse
        float pulse = smoothstep(0.15, 0.0, distToPulse);
        
        // Base line visibility
        float baseLine = 0.3;
        
        // Combine base line with pulse
        float finalAlpha = (baseLine + pulse * 2.0) * uOpacity;
        
        // Brighten color near pulse
        vec3 finalColor = uColor * (1.0 + pulse * 1.5);
        
        gl_FragColor = vec4(finalColor, finalAlpha);
      }
    `,
    transparent: true,
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });
  
  const line = new THREE.Line(geo, mat);
  line.visible = true;
  scene.add(line);
  
  connectionLines.push({
    line,
    particleA,
    particleB,
    segments,
    strength,
    createdAt: performance.now() // Track creation time
  });
  
  // Remove oldest connections if we exceed global limit
  const GLOBAL_MAX_CONNECTIONS = 100; // Limit total connections for performance
  if (connectionLines.length > GLOBAL_MAX_CONNECTIONS) {
    // Sort by creation time and remove oldest
    connectionLines.sort((a, b) => a.createdAt - b.createdAt);
    const toRemove = connectionLines.splice(0, connectionLines.length - GLOBAL_MAX_CONNECTIONS);
    toRemove.forEach(conn => {
      scene.remove(conn.line);
      conn.line.geometry.dispose();
      conn.line.material.dispose();
    });
  }
  
  return true; // Connection created successfully
}

// Update node swarm animation
function updateNodeSwarm(dt, time) {
  if (!nodeSwarmActive) return;
  
  // Process pending spawns (staggered node appearance)
  processPendingSpawns(time);
  
  // Activate central dot after a few nodes have spawned
  if (!centralDot.active && nodesSpawned >= 5) {
    centralDot.active = true;
    centralDot.waitingForFirstPulse = true;
    centralDot.pulseStartTime = time;
    console.log('ðŸ”´ Central dot activated - waiting for first pulse');
  }
  
  // Update burst spawning
  if (nodesSpawned < nodesData.length) {
    burstAccumulator += dt;
    if (burstAccumulator >= BURST_INTERVAL) {
      burstAccumulator = 0;
      spawnNodeBurst(time);
    }
  } else {
    // Log cluster summary once when all nodes are spawned
    if (nodesSpawned === nodesData.length && Object.keys(nodeClusters).length > 0) {
      const categoryCount = Array.from(categoryNodes.values()).length;
      const subNodeCount = nodeParticles.length - categoryCount;
      const nodesWithGravity = nodeParticles.filter(p => !p.isCategory && p.gravityTarget).length;
      
      console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      console.log('ðŸŒ€ All nodes spawned! Cluster animation active:');
      console.log(`ðŸ“Š Total: ${nodeParticles.length} nodes | ðŸ“ ${categoryCount} categories | ðŸ”— ${subNodeCount} sub-nodes`);
      console.log(`ðŸŒŒ Gravity: ${categoryGravityActive ? 'ACTIVE' : 'inactive'} | ${nodesWithGravity} sub-nodes attracted to categories`);
      console.log('');
      Object.entries(nodeClusters).forEach(([key, particles]) => {
        const config = clusterConfigs[key] || clusterConfigs.Other;
        const catCount = particles.filter(p => p.isCategory).length;
        const subCount = particles.filter(p => !p.isCategory).length;
        console.log(`   ${key}: ${particles.length} nodes (${catCount} cat, ${subCount} sub) | ${config.direction > 0 ? 'â†» CW' : 'â†º CCW'} | pulse: ${config.pulsePeriod}s`);
      });
      console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      // Set flag to prevent re-logging
      nodesSpawned++;
    }
  }
  
  // Formation center is the origin point from which the spiral radiates
  formationCenter.set(0, 0, 0);
  
  // Remove disposed particles BEFORE update to prevent errors
  const beforeCleanup = nodeParticles.length;
  nodeParticles = nodeParticles.filter(p => p && p.mesh && (p.visible || p.mesh)); // Keep only valid particles
  const removed = beforeCleanup - nodeParticles.length;
  if (removed > 0 && Math.random() < 0.1) {
    console.log(`ðŸ§¹ Cleaned up ${removed} disposed nodes (${nodeParticles.length} remain)`);
  }
  
  // Update all particles
  nodeParticles.forEach(particle => particle.update(dt, time));
  
  // Clean up disposed category nodes from the Map
  const disposedCategories = [];
  categoryNodes.forEach((catNode, catId) => {
    if (!catNode.visible || !catNode.mesh) {
      disposedCategories.push(catId);
    }
  });
  disposedCategories.forEach(catId => categoryNodes.delete(catId));
  
  // Update spark particles
  updateSparkParticles(dt);
  
  // Randomly trigger drift behavior for nodes with connections
  if (nodesSpawned > 20 && Math.random() < 0.02) { // 2% chance per frame
    const visibleParticles = nodeParticles.filter(p => p.visible && p.mesh && !p.isDrifting && !p.isCategory);
    if (visibleParticles.length > 0) {
      const sourceParticle = visibleParticles[Math.floor(Math.random() * visibleParticles.length)];
      
      // Find a connected node as target
      const possibleTargets = nodeConnections
        .filter(conn => conn.from === sourceParticle.id)
        .map(conn => nodeParticles.find(p => p.id === conn.to && p.visible && p.mesh))
        .filter(p => p);
      
      if (possibleTargets.length > 0) {
        const targetParticle = possibleTargets[Math.floor(Math.random() * possibleTargets.length)];
        sourceParticle.startDrift(targetParticle);
      }
    }
  }
  
  // Debug: log particle count occasionally
  if (nodeParticles.length > 0 && nodeParticles.length <= 15 && Math.random() < 0.01) {
    console.log(`Particles: ${nodeParticles.length}, visible: ${nodeParticles.filter(p => p.visible).length}`);
  }
  
  // Clean up connection lines attached to invisible/culled nodes
  connectionLines = connectionLines.filter(conn => {
    // More thorough check: ensure particles and their meshes exist
    if (!conn.particleA || !conn.particleA.mesh || !conn.particleA.visible ||
        !conn.particleB || !conn.particleB.mesh || !conn.particleB.visible) {
      if (conn.line) {
        scene.remove(conn.line);
        if (conn.line.geometry) conn.line.geometry.dispose();
        if (conn.line.material) conn.line.material.dispose();
      }
      return false;
    }
    return true;
  });
  
  // Update connection lines with animated pulses
  connectionLines.forEach(conn => {
    // Safety check: ensure both particles still have valid meshes
    if (!conn.particleA || !conn.particleA.mesh || !conn.particleB || !conn.particleB.mesh) {
      return;
    }
    
    const posA = conn.particleA.mesh.position;
    const posB = conn.particleB.mesh.position;
    const pos = conn.line.geometry.attributes.position.array;
    const segments = conn.segments || 1;
    
    // Interpolate positions along the line in 3D space
    for (let i = 0; i <= segments; i++) {
      const t = i / segments;
      const idx = i * 3;
      pos[idx] = posA.x + (posB.x - posA.x) * t;
      pos[idx + 1] = posA.y + (posB.y - posA.y) * t;
      pos[idx + 2] = posA.z + (posB.z - posA.z) * t;
    }
    
    conn.line.geometry.attributes.position.needsUpdate = true;
    
    // Update shader time for pulse animation
    if (conn.line.material.uniforms && conn.line.material.uniforms.uTime) {
      conn.line.material.uniforms.uTime.value = time;
    }
  });
}

// Initialize node data on page load
loadNodeData();

/* ===== Node Card UI System ===== */

// Raycaster for detecting clicks on nodes
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let selectedNode = null;

// Node card elements
const nodeCard = document.getElementById('node-card');
const nodeCardTitle = document.getElementById('node-card-title');
const nodeCardMeta = document.getElementById('node-card-meta');
const nodeCardBody = document.getElementById('node-card-body');
const nodeCardClose = document.getElementById('node-card-close');

// Close card handler
nodeCardClose.addEventListener('click', () => {
  hideNodeCard();
});

// Click ESC to close card
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && nodeCard.classList.contains('visible')) {
    hideNodeCard();
  }
});

// Hide node card
function hideNodeCard() {
  nodeCard.classList.remove('visible');
  selectedNode = null;
}

// Show node card with data
function showNodeCard(particle) {
  if (!particle || !particle.data) return;
  
  selectedNode = particle;
  const data = particle.data;
  
  // Set title
  nodeCardTitle.textContent = data.title || 'Unknown Node';
  
  // Set meta information
  nodeCardMeta.innerHTML = '';
  if (data.era) {
    const eraSpan = document.createElement('span');
    eraSpan.innerHTML = `<strong>Era:</strong> ${data.era}`;
    nodeCardMeta.appendChild(eraSpan);
  }
  if (data.importance) {
    const impSpan = document.createElement('span');
    impSpan.innerHTML = `<strong>Importance:</strong> ${data.importance}/10`;
    nodeCardMeta.appendChild(impSpan);
  }
  if (data.when && data.when !== 'â€”') {
    const whenSpan = document.createElement('span');
    whenSpan.innerHTML = `<strong>Year:</strong> ${data.when}`;
    nodeCardMeta.appendChild(whenSpan);
  }
  
  // Build body content
  let bodyHTML = '';
  
  // Definition section
  if (data.definition) {
    bodyHTML += `
      <div class="node-card-section">
        <div class="node-card-section-title">Definition</div>
        <div class="node-card-definition">${escapeHtml(data.definition)}</div>
      </div>
    `;
  }
  
  // Proto-example section
  if (data.protoExample) {
    bodyHTML += `
      <div class="node-card-section">
        <div class="node-card-section-title">Example</div>
        <div class="node-card-example">"${escapeHtml(data.protoExample)}"</div>
      </div>
    `;
  }
  
  // Additional examples
  if (data.examples && data.examples.length > 0) {
    bodyHTML += `<div class="node-card-section">`;
    if (!data.protoExample) {
      bodyHTML += `<div class="node-card-section-title">Examples</div>`;
    }
    data.examples.forEach(ex => {
      bodyHTML += `<div class="node-card-example">"${escapeHtml(ex)}"</div>`;
    });
    bodyHTML += `</div>`;
  }
  
  // Category section
  if (data.category) {
    const categoryNode = nodesData.find(n => n.id === data.category);
    const categoryTitle = categoryNode ? categoryNode.title : data.category;
    bodyHTML += `
      <div class="node-card-section">
        <div class="node-card-section-title">Category</div>
        <div class="connection-item" onclick="jumpToNode('${data.category}')">
          <span class="connection-type">Member of</span>
          <span class="connection-arrow">â†’</span>
          <span class="connection-target">${escapeHtml(categoryTitle)}</span>
        </div>
      </div>
    `;
  }
  
  // Connections section - organized by type
  const outgoingConnections = nodeConnections.filter(c => c.from === data.id);
  const incomingConnections = nodeConnections.filter(c => c.to === data.id);
  
  if (outgoingConnections.length > 0 || incomingConnections.length > 0) {
    bodyHTML += `<div class="node-card-section">`;
    bodyHTML += `<div class="node-card-section-title">Connections (${outgoingConnections.length + incomingConnections.length})</div>`;
    bodyHTML += `<div class="node-connections-list">`;
    
    // Outgoing connections
    if (outgoingConnections.length > 0) {
      // Group by type
      const byType = {};
      outgoingConnections.forEach(conn => {
        const type = conn.type || 'related';
        if (!byType[type]) byType[type] = [];
        byType[type].push(conn);
      });
      
      Object.entries(byType).forEach(([type, conns]) => {
        conns.forEach(conn => {
          const targetNode = nodesData.find(n => n.id === conn.to);
          if (targetNode) {
            const eraColor = getEraColor(targetNode.era);
            bodyHTML += `
              <div class="connection-item" onclick="jumpToNode('${conn.to}')">
                <span class="connection-type">${escapeHtml(type)}</span>
                <span class="connection-arrow">â†’</span>
                <span class="connection-target">${escapeHtml(targetNode.title)}</span>
                ${targetNode.era ? `<span class="connection-era-badge" style="background: ${eraColor}22; color: ${eraColor}">${targetNode.era}</span>` : ''}
              </div>
            `;
          }
        });
      });
    }
    
    // Incoming connections
    if (incomingConnections.length > 0) {
      // Group by type
      const byType = {};
      incomingConnections.forEach(conn => {
        const type = conn.type || 'related';
        if (!byType[type]) byType[type] = [];
        byType[type].push(conn);
      });
      
      Object.entries(byType).forEach(([type, conns]) => {
        conns.forEach(conn => {
          const sourceNode = nodesData.find(n => n.id === conn.from);
          if (sourceNode) {
            const eraColor = getEraColor(sourceNode.era);
            bodyHTML += `
              <div class="connection-item" onclick="jumpToNode('${conn.from}')">
                <span class="connection-type">${escapeHtml(type)}</span>
                <span class="connection-arrow">â†</span>
                <span class="connection-target">${escapeHtml(sourceNode.title)}</span>
                ${sourceNode.era ? `<span class="connection-era-badge" style="background: ${eraColor}22; color: ${eraColor}">${sourceNode.era}</span>` : ''}
              </div>
            `;
          }
        });
      });
    }
    
    bodyHTML += `</div></div>`;
  }
  
  nodeCardBody.innerHTML = bodyHTML;
  nodeCard.classList.add('visible');
  
  console.log(`ðŸ“‹ Node card opened: ${data.title}`);
}

// Helper: Escape HTML
function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// Helper: Get era color
function getEraColor(era) {
  switch(era) {
    case 'Taxonomy': return '#88ddff';
    case 'Genesis': return '#ffaacc';
    case 'Evolution': return '#aaffaa';
    case 'Contemporary': return '#ffcc66';
    default: return '#aaaaaa';
  }
}

// Jump to another node (called when clicking connection links)
window.jumpToNode = function(nodeId) {
  const particle = nodeParticles.find(p => p.id === nodeId);
  if (particle && particle.visible) {
    // Show the new node's card
    showNodeCard(particle);
    
    // Animate camera to look at the node
    const targetPos = particle.mesh.position;
    const currentPos = camera.position;
    const direction = new THREE.Vector3().subVectors(currentPos, targetPos).normalize();
    const distance = 4; // Distance from node
    const newCameraPos = targetPos.clone().add(direction.multiplyScalar(distance));
    
    // Smooth camera movement (you can make this fancier with animations)
    camera.position.lerp(newCameraPos, 0.3);
    controls.target.lerp(targetPos, 0.3);
    controls.update();
    
    console.log(`ðŸŽ¯ Jumped to node: ${particle.title}`);
  } else {
    console.warn(`Node ${nodeId} not found or not visible yet`);
  }
};

// Mouse hover handler for cursor feedback and node highlighting
const tempVector = new THREE.Vector3();
renderer.domElement.addEventListener('mousemove', (event) => {
  // Calculate mouse position
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  
  // Update raycaster
  raycaster.setFromCamera(mouse, camera);
  
  // Get all visible node particles
  const visibleParticles = nodeParticles.filter(p => p.visible && p.mesh && p.mesh.visible);
  
  // Check for direct intersections
  const nodeMeshes = visibleParticles.map(p => p.mesh);
  const intersects = raycaster.intersectObjects(nodeMeshes);
  
  let hoveredNode = null;
  
  if (intersects.length > 0) {
    // Direct hit - find the particle
    const hitMesh = intersects[0].object;
    hoveredNode = visibleParticles.find(p => p.mesh === hitMesh);
  } else {
    // No direct hit - check for proximity in screen space
    const HOVER_RADIUS = 40; // pixels
    const mouseScreenX = event.clientX;
    const mouseScreenY = event.clientY;
    
    let closestParticle = null;
    let closestDistance = HOVER_RADIUS;
    
    for (const particle of visibleParticles) {
      // Project particle position to screen space
      tempVector.copy(particle.mesh.position);
      tempVector.project(camera);
      
      const screenX = (tempVector.x * 0.5 + 0.5) * window.innerWidth;
      const screenY = (-(tempVector.y * 0.5) + 0.5) * window.innerHeight;
      
      // Calculate distance to mouse
      const dx = screenX - mouseScreenX;
      const dy = screenY - mouseScreenY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      // Check if within hover radius and closest so far
      if (distance < closestDistance) {
        closestDistance = distance;
        closestParticle = particle;
      }
    }
    
    hoveredNode = closestParticle;
  }
  
  // Update hover states for all particles
  visibleParticles.forEach(particle => {
    particle.isHovered = (particle === hoveredNode);
  });
  
  // Change cursor if hovering over a node
  renderer.domElement.style.cursor = hoveredNode ? 'pointer' : 'default';
});

// Mouse click handler for nodes
renderer.domElement.addEventListener('click', (event) => {
  // Don't handle clicks if card is visible and click is on card
  if (nodeCard.classList.contains('visible')) {
    const cardRect = nodeCard.getBoundingClientRect();
    if (event.clientX >= cardRect.left && event.clientX <= cardRect.right &&
        event.clientY >= cardRect.top && event.clientY <= cardRect.bottom) {
      return; // Click was on card, let it handle
    }
  }
  
  // Calculate mouse position in normalized device coordinates (-1 to +1)
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  
  // Update raycaster
  raycaster.setFromCamera(mouse, camera);
  
  // Get all visible node particles
  const visibleParticles = nodeParticles.filter(p => p.visible && p.mesh && p.mesh.visible);
  
  // Check for direct intersections
  const nodeMeshes = visibleParticles.map(p => p.mesh);
  const intersects = raycaster.intersectObjects(nodeMeshes);
  
  let clickedNode = null;
  
  if (intersects.length > 0) {
    // Direct hit - find the particle
    const hitMesh = intersects[0].object;
    clickedNode = visibleParticles.find(p => p.mesh === hitMesh);
  } else {
    // No direct hit - check for proximity in screen space (same as hover)
    const CLICK_RADIUS = 40; // pixels
    const mouseScreenX = event.clientX;
    const mouseScreenY = event.clientY;
    
    let closestParticle = null;
    let closestDistance = CLICK_RADIUS;
    
    for (const particle of visibleParticles) {
      // Project particle position to screen space
      tempVector.copy(particle.mesh.position);
      tempVector.project(camera);
      
      const screenX = (tempVector.x * 0.5 + 0.5) * window.innerWidth;
      const screenY = (-(tempVector.y * 0.5) + 0.5) * window.innerHeight;
      
      // Calculate distance to mouse
      const dx = screenX - mouseScreenX;
      const dy = screenY - mouseScreenY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      // Check if within click radius and closest so far
      if (distance < closestDistance) {
        closestDistance = distance;
        closestParticle = particle;
      }
    }
    
    clickedNode = closestParticle;
  }
  
  if (clickedNode) {
    showNodeCard(clickedNode);
  } else {
    // Clicked on empty space - hide card
    if (nodeCard.classList.contains('visible')) {
      hideNodeCard();
    }
  }
});

// Play button overlay logic
const playButtonOverlay = document.getElementById('play-button-overlay');
const playButtonCutout = document.getElementById('play-button-cutout');
const spotifyMask = document.getElementById('spotify-mask');
const spotifyIframe = document.getElementById('spotify-iframe');
const playHint = document.getElementById('play-hint');

// When overlay is clicked, start animation and let click pass through to Spotify
playButtonOverlay.addEventListener('click', (e) => {
  if (!animationStarted) {
  // Start the animation
  animationStarted = true;
  clock.start();
  
    // Hide the overlay elements immediately
    playButtonOverlay.classList.add('hidden');
    spotifyMask.classList.add('hidden');
    playButtonCutout.classList.add('hidden');
    playHint.classList.add('hidden');
    
    // The click will naturally pass through to the Spotify iframe
  }
}, { capture: true });

// Keyboard shortcut: 's' to toggle Spotify player visibility
document.addEventListener('keydown', (e) => {
  if (e.key === 's' || e.key === 'S') {
    const spotifyPlayer = document.getElementById('spotify-player');
    if (spotifyPlayer) {
      if (spotifyPlayer.style.display === 'none') {
        spotifyPlayer.style.display = '';
        console.log('ðŸŽµ Spotify player shown');
      } else {
        spotifyPlayer.style.display = 'none';
        console.log('ðŸŽµ Spotify player hidden');
      }
    }
  }
});

animate();

</script>
</body>
</html>
