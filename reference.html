 <!doctype html>
<html lang="en">
<head>
 <meta charset="utf-8"/>
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
 <meta name="viewport" content="width=device-width, initial-scale=1"/>
 <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
 <meta http-equiv="Pragma" content="no-cache" />
 <meta http-equiv="Expires" content="0" />
 <meta name="version" content="5.6-celli-avatar-enhanced" />
<!-- v5.6: Enhanced Celli avatar - raised position, slab-shaped head, larger voxels, pink cheeks, eye lights -->
 <title>Tri-Trail Evolved three.js [v4.2 THE.OS]</title>
 <link rel="preconnect" href="https://fonts.googleapis.com">
 <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
 <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Roboto+Mono:wght@100;300&family=VT323&display=swap" rel="stylesheet">
 <!-- Twemoji for consistent emoji rendering -->
 <script src="https://unpkg.com/twemoji@latest/dist/twemoji.min.js"></script>
<style>
:root { --bg: #000; --fg: #e6e6e6; --accent:#8ab4ff; }
html, body { margin:0; height:100%; background:#000; overflow:hidden; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Segoe UI Symbol", "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", Roboto, Helvetica, Arial, sans-serif; }
#app { position:fixed; inset:0; background:var(--bg); z-index:60; }
.hud { position:fixed; inset:0; pointer-events:none; font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", "Segoe UI Symbol", "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", Roboto, Inter, "Helvetica Neue", Arial, sans-serif; z-index:65; }
 .brand { position:absolute; left:2rem; bottom:2rem; color:var(--fg); letter-spacing:0.08em; font-weight:600; font-size:12px; opacity:.65; text-transform:uppercase; }
 .quote { position:absolute; left:50%; top:50%; transform:translate(-50%, -50%); color:var(--fg); font-weight:300; font-size:16px; letter-spacing:0.03em; line-height:1.6; max-width:560px; width:90%; text-align:center; font-style:italic; margin:0; padding:0 20px; box-sizing:border-box; z-index:10; visibility:hidden; opacity:0; transition: color 0.45s ease, text-shadow 0.45s ease; }
 .quote__text { display:block; max-width:100%; }
 .quote.quote--loom { font-family:'Roboto Mono', ui-monospace, monospace; font-style:normal; letter-spacing:0.12em; }
 .quote.visible { animation: fadeInQuote 3s ease-out forwards; display:block !important; visibility:visible; }
 @keyframes fadeInQuote {
 0% { opacity:0; transform:translate(-50%, -50%) translateY(20px); }
 100% { opacity:.85; transform:translate(-50%, -50%) translateY(0); }
 }
 .quote.glitch { animation: glitchText 0.5s ease-in-out infinite; }
 .quote.scrambling { text-shadow: 0 0 18px rgba(138, 180, 255, 0.4); color:#f5f5f5; }
 @keyframes glitchText {
 0%, 100% { opacity:.85; transform:translate(-50%, -50%) translateX(0); text-shadow: 0 0 0 transparent; }
 10% { opacity:.8; transform:translate(-50%, -50%) translateX(-1px); text-shadow: 1px 0 #ff1e6e, -1px 0 #00a8ff; }
 20% { opacity:.9; transform:translate(-50%, -50%) translateX(1px); text-shadow: -1px 0 #ffb62e, 1px 0 #00a8ff; }
 30% { opacity:.85; transform:translate(-50%, -50%) translateX(0); text-shadow: 0 0 0 transparent; }
 }
 .quote.glitchMedium { animation: glitchMedium 0.3s ease-in-out infinite; }
 @keyframes glitchMedium {
 0%, 100% { opacity:.82; transform:translate(-50%, -50%) translateX(0) translateY(0); text-shadow: 0 0 0 transparent; }
 15% { opacity:.7; transform:translate(-50%, -50%) translateX(-3px) translateY(1px); text-shadow: 2px 0 #ff1e6e, -2px 0 #00a8ff; }
 35% { opacity:.8; transform:translate(-50%, -50%) translateX(3px) translateY(-2px); text-shadow: -3px 0 #ffb62e, 3px 0 #00a8ff; }
 55% { opacity:.75; transform:translate(-50%, -50%) translateX(-2px) translateY(2px); text-shadow: 2px 0 #00a8ff, -2px 0 #ff1e6e; }
 75% { opacity:.78; transform:translate(-50%, -50%) translateX(2px) translateY(-1px); text-shadow: -2px 0 #ffb62e, 2px 0 #ff1e6e; }
 }
 .quote.glitchIntense { animation: glitchIntense 0.12s ease-in-out infinite; }
 @keyframes glitchIntense {
 0% { opacity:.75; transform:translate(-50%, -50%) translateX(0) translateY(0); text-shadow: 0 0 0 transparent; }
 12% { opacity:.5; transform:translate(-50%, -50%) translateX(-8px) translateY(4px); text-shadow: 4px 0 #ff1e6e, -4px 0 #00a8ff, 0 4px #ffb62e; }
 25% { opacity:.7; transform:translate(-50%, -50%) translateX(6px) translateY(-6px); text-shadow: -6px 0 #ffb62e, 6px 0 #00a8ff, 0 -6px #ff1e6e; }
 40% { opacity:.45; transform:translate(-50%, -50%) translateX(-10px) translateY(8px); text-shadow: 8px 0 #00a8ff, -8px 0 #ff1e6e; }
 55% { opacity:.65; transform:translate(-50%, -50%) translateX(5px) translateY(-3px); text-shadow: -5px 0 #ffb62e, 5px 0 #ff1e6e; }
 70% { opacity:.55; transform:translate(-50%, -50%) translateX(-7px) translateY(5px); text-shadow: 6px 0 #00a8ff, -5px 0 #ffb62e; }
 85% { opacity:.6; transform:translate(-50%, -50%) translateX(8px) translateY(-4px); text-shadow: -7px 0 #ff1e6e, 6px 0 #00a8ff; }
 100% { opacity:.5; transform:translate(-50%, -50%) translateX(0) translateY(0); text-shadow: 0 0 0 transparent; }
 }
 .loomworks { position:absolute; left:50%; top:50%; transform:translate(calc(-50% + var(--loomOffsetX, 0px)), calc(-50% + var(--loomOffsetY, 0px))); color:#fff; font-weight:300; font-size:20px; letter-spacing:0.15em; opacity:0; text-align:center; pointer-events:none; font-family:'Roboto Mono', ui-monospace, monospace; white-space:nowrap; }
 .loomworks.visible { animation: fadeInLoom 2s ease-out forwards; }
 .loomworks-chunk { display:inline-block; padding:0 0.08em; opacity:0; transform:translateY(12px); transition: opacity 0.45s ease, transform 0.45s ease, background 0.25s ease, color 0.25s ease; }
 .loomworks.visible .loomworks-chunk { opacity:1; transform:translateY(0); }
 .loomworks-chunk.selected { background:#fff; color:#000; box-shadow:0 0 0 1px rgba(0,0,0,0.55); }
 .loomworks-chunk.shift-right { transform:translateX(0.35em); }
 #loomTail { white-space:pre; }
 @keyframes shake {
 0%, 100% { transform: translateX(0); }
 10%, 30%, 50%, 70%, 90% { transform: translateX(-10px); }
 20%, 40%, 60%, 80% { transform: translateX(10px); }
 }
 @keyframes pulse {
 0%, 100% { opacity: 1; transform: scale(1); }
 50% { opacity: 0.7; transform: scale(1.05); }
 }
 @keyframes fadeIn {
 from { opacity: 0; }
 to { opacity: 1; }
 }
 @keyframes fadeInLoom {
 0% { opacity:0; transform:translate(-50%, -50%) scale(0.95); }
 100% { opacity:1; transform:translate(-50%, -50%) scale(1); }
 }
 
 /* Doorway portal - starts as vertical bar */
 .doorway { position:fixed; left:50%; bottom:20%; transform:translate(-50%, 0); width:4px; height:60px; background:#fff; pointer-events:none; z-index:68; opacity:0; box-shadow: 0 0 15px 5px rgba(255,255,255,0.8), 0 0 30px 10px rgba(255,255,255,0.5); transition: width 1.5s cubic-bezier(0.4, 0, 0.2, 1), height 1.5s cubic-bezier(0.4, 0, 0.2, 1), box-shadow 1.5s ease-out, opacity 0.5s ease-out; overflow:hidden; }
 .doorway.visible { opacity:1; }
 .doorway.open { width:min(280px, 85vw); height:80px; box-shadow: 0 0 40px 20px rgba(255,255,255,0.7), 0 0 80px 35px rgba(255,255,255,0.4), inset 0 0 60px rgba(255,255,255,0.6); }
 
 /* Light rays emanating from doorway - forward emission only (cut off at top) */
 .doorway::before { content:""; position:absolute; left:-150%; right:-150%; top:0%; bottom:-200%; background:radial-gradient(ellipse 120% 80% at center top, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0.15) 40%, transparent 70%); opacity:0; transition:opacity 1.5s ease-out; pointer-events:none; clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%); }
 .doorway.open::before { opacity:1; }
 
 /* Input prompt inside doorway */
 .prompt-container { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; opacity:0; transition:opacity 1s ease-in 1.5s; pointer-events:none; user-select:none; -webkit-user-select:none; }
 .doorway.open .prompt-container { opacity:1; pointer-events:auto; cursor:text; }
 .prompt {
 position: relative;
 font-family: 'VT323', 'Press Start 2P', 'Roboto Mono', ui-monospace, monospace;
 font-size: clamp(13px, 3.1vw, 34px);
 font-weight:400;
 color:#000;
 letter-spacing:0.22em;
 text-transform:uppercase;
 z-index: 2;
 white-space: nowrap;
 display: inline-flex;
 }
 /* Per-character shadow - each char gets its own shadow aligned to its bottom edge */
 .prompt .char {
 position: relative;
 display: inline-block;
 }
 .prompt .char::after {
 content: attr(data-char);
 position: absolute;
 left: 0;
 top: 100%; /* Start at bottom edge of character */
 font-family: 'VT323', 'Press Start 2P', 'Roboto Mono', ui-monospace, monospace;
 font-size: clamp(13px, 3.1vw, 34px);
 font-weight: 400;
 color: rgba(0, 0, 0, 0.92);
 transform-origin: top left;
 transform: translate(3px, 0) scaleY(-1.08) skewX(-20deg) scaleX(1.15);
 opacity: 0.4;
 filter: blur(1.2px);
 z-index: -1;
 pointer-events: none;
 mask-image: linear-gradient(to bottom, rgba(0,0,0,1) 0%, rgba(0,0,0,0.65) 40%, rgba(0,0,0,0) 100%);
 -webkit-mask-image: linear-gradient(to bottom, rgba(0,0,0,1) 0%, rgba(0,0,0,0.65) 40%, rgba(0,0,0,0) 100%);
 }
 .cursor { animation:blink 1s step-end infinite; }
 @keyframes blink {
 0%, 50% { opacity:1; }
 51%, 100% { opacity:0; }
 }
 
 /* CELLI glitch effects */
 .celli-glitch .char { display:inline-block; transition:opacity 0.1s; }
 .celli-glitch .char.flicker { animation:celliFlicker 0.15s infinite; }
 .celli-glitch .char.hidden { opacity:0; }
 @keyframes celliFlicker {
 0%, 100% { opacity:1; text-shadow: 0 0 8px currentColor; }
 25% { opacity:0.3; transform:translateX(-2px); }
 50% { opacity:0.6; transform:translateX(2px); }
 75% { opacity:0.2; transform:translateY(-1px); }
 }
 .screenGlitch { position:fixed; inset:0; pointer-events:none; background:#000; opacity:0; z-index:5; mix-blend-mode:normal; }
 .screenGlitch.active { animation: screenFlicker 0.2s infinite; }
 @keyframes screenFlicker {
 0%, 100% { opacity:0; background:#000; }
 15% { opacity:0.08; background:#fff; }
 30% { opacity:0; background:#000; }
 45% { opacity:0.12; background:#00a8ff; }
 60% { opacity:0; background:#000; }
 80% { opacity:0.1; background:#ff1e6e; }
 }
 .fallback { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:#000; color:#bbb; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial; }
 .scanlines::before { content:""; position:absolute; inset:0; pointer-events:none; background: repeating-linear-gradient( to bottom, rgba(255,255,255,0.04), rgba(255,255,255,0.04) 1px, transparent 1px, transparent 3px ); mix-blend-mode: overlay; opacity:.18; transition: opacity 1s ease; }
 .scanlines.fade-scanlines::before { opacity: 0; }
 .vignette { position:absolute; inset:0; pointer-events:none; box-shadow: inset 0 0 240px rgba(0,0,0,.75), inset 0 0 800px rgba(0,0,0,.65); }
 canvas { filter: saturate(1.06) contrast(1.06) brightness(1.02); display:block; }

 /* Play overlay */
 .play { position:fixed; inset:0; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:15px; background: radial-gradient(ellipse at center, rgba(30,30,30,.6) 0%, rgba(0,0,0,.9) 60%); z-index:100; }
 .play.hidden{ display:none; }
 .play button{ pointer-events:auto; appearance:none; border:none; padding:14px 20px; border-radius:999px; font-weight:700; letter-spacing:.06em; text-transform:uppercase; background:#111; color:#e8eaed; box-shadow: 0 0 0 2px rgba(255,255,255,.08) inset, 0 6px 20px rgba(0,0,0,.45); cursor:pointer; display:flex; gap:12px; align-items:center; justify-content:center; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Segoe UI Symbol", "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", Roboto, Helvetica, Arial, sans-serif; }
#playBtn::before{ content:"\25B6"; font-size:14px; opacity:.9; }
 
 /* Skip button - Equilateral triangles */
 .skip-btn { position:fixed; bottom:20px; left:50%; transform:translate(-50%, 0); pointer-events:auto; cursor:pointer; z-index:70; opacity:0.75; display:flex; align-items:center; justify-content:center; gap:0; transition: opacity 0.45s ease; --skip-triangle-size:28px; --skip-triangle-height: calc(var(--skip-triangle-size) * 0.8660254038); }
 .skip-btn:hover { opacity:1; }
 .skip-btn.hidden { display:none; }
 .skip-btn.bow-lock { pointer-events:none; }
 .skip-btn.voxel-hidden { opacity:0; pointer-events:none; transition: opacity 0.35s ease, filter 0.35s ease; filter: brightness(0.65); }
 .skip-btn.golden-phase { color:#fff48a; }
.skip-triangle { position:relative; width:var(--skip-triangle-size); height:var(--skip-triangle-height); display:flex; align-items:center; justify-content:center; transition: transform 0.85s cubic-bezier(0.19, 1, 0.22, 1), filter 0.6s ease; z-index: 1; }
.skip-triangle__inner { width:100%; height:100%; display:flex; filter: drop-shadow(0 0 3px rgba(255,255,255,0.25)) drop-shadow(0 0 6px rgba(255,255,255,0.15)); transform-origin:center; transition: filter 0.6s ease, transform 0.6s ease; }
.skip-triangle--right .skip-triangle__inner { transform: scaleX(-1); }
.skip-triangle svg { width:100%; height:100%; display:block; }
.skip-triangle polygon, .skip-triangle path { fill:#fff; stroke:rgba(255,255,255,0.45); stroke-width:5; stroke-linejoin:round; transition: stroke 0.6s ease, fill 0.6s ease, opacity 0.5s ease; animation: skipFillShimmer 2s ease-in-out infinite, skipOutlinePulse 2.8s ease-in-out infinite; }
.skip-triangle path { opacity:0; }
 /* Initial position - closer together, vertex to edge */
 .skip-btn:not(.bow-shape) .skip-triangle--left { transform: translateX(calc(var(--skip-triangle-size) * -0.25)); }
 .skip-btn:not(.bow-shape) .skip-triangle--right { transform: translateX(calc(var(--skip-triangle-size) * 0.25)); }
 .skip-btn.bow-shape { gap:0; opacity:1; --skip-triangle-size:32px; }
 .skip-btn.bow-shape .skip-triangle { position:absolute; top:50%; left:50%; margin:0; }
/* Unified glow to match voxel squares exactly */
.skip-btn.bow-shape .skip-triangle__inner { filter: drop-shadow(0 0 3px rgba(255,255,255,0.25)) drop-shadow(0 0 6px rgba(255,255,255,0.15)); }
 .skip-btn.bow-shape .skip-triangle--left { transform: translate(-50%, -50%) translateX(calc(var(--skip-triangle-size) * -0.5)); }
 .skip-btn.bow-shape .skip-triangle--right { transform: translate(-50%, -50%) translateX(calc(var(--skip-triangle-size) * 0.5)); }
 .skip-btn.bow-shape .skip-triangle--right .skip-triangle__inner { transform: scaleX(1); }
 .skip-connector { position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); width:0; height:0; border-radius:0; background:transparent; box-shadow:none; opacity:0; transition: all 0.6s ease; pointer-events:none; z-index: 0; }
 .skip-btn.rounded-bow .skip-triangle polygon { opacity:0; }
 .skip-btn.rounded-bow .skip-triangle path { opacity:1; }
/* Connector with unified glow - solid core like a voxel */
.skip-btn.rounded-bow .skip-connector { width:calc(var(--skip-triangle-size) * 0.48); height:calc(var(--skip-triangle-size) * 0.48); border-radius:calc(var(--skip-triangle-size) * 0.12); background:rgba(255,255,255,1); box-shadow:0 0 3px rgba(255,255,255,0.25), 0 0 6px rgba(255,255,255,0.15); opacity:1; animation: skipCenterPulse 2.2s ease-in-out infinite; }
.skip-btn.illuminating .skip-triangle__inner { animation: skipGlowPulse 2.4s ease-in-out infinite; }
.skip-btn.illuminating.bow-shape .skip-triangle--left .skip-triangle__inner { animation: skipGlowPulse 2.4s ease-in-out infinite, skipJiggleLeft 1.6s ease-in-out infinite; }
.skip-btn.illuminating.bow-shape .skip-triangle--right .skip-triangle__inner { animation: skipGlowPulse 2.4s ease-in-out infinite, skipJiggleRight 1.6s ease-in-out infinite; }
 .skip-btn.golden-phase .skip-triangle polygon,
 .skip-btn.golden-phase .skip-triangle path { fill:#fff48a; stroke:rgba(255,214,120,0.65); }
 /* Golden phase - ultra-minimal glow to match voxel squares */
 .skip-btn.golden-phase .skip-triangle__inner { filter: drop-shadow(0 0.5px 1px rgba(255,215,96,0.08)) drop-shadow(0 0 2px rgba(255,238,160,0.05)); }
 .skip-btn.golden-phase.rounded-bow .skip-connector { background: radial-gradient(circle at 50% 45%, rgba(255,248,170,1) 0%, rgba(255,219,92,1) 45%, rgba(255,199,60,0.98) 100%); box-shadow:0 0 2px rgba(255,215,96,0.08), 0 0 3px rgba(255,239,168,0.05); }
 .skip-btn.golden-phase.illuminating .skip-triangle polygon,
 .skip-btn.golden-phase.illuminating .skip-triangle path { animation: skipFillShimmer 2s ease-in-out infinite, skipOutlinePulse 2.8s ease-in-out infinite; }
 
 /* Magenta phase - ultra-minimal glow to match voxel squares */
 .skip-btn.magenta-phase .skip-triangle polygon,
 .skip-btn.magenta-phase .skip-triangle path { fill:#ff1e6e; stroke:rgba(255,100,140,0.65); }
 .skip-btn.magenta-phase .skip-triangle__inner { filter: drop-shadow(0 0.5px 1px rgba(255,30,110,0.08)) drop-shadow(0 0 2px rgba(255,100,160,0.05)); }
 .skip-btn.magenta-phase.rounded-bow .skip-connector { background: radial-gradient(circle at 50% 45%, rgba(255,80,140,1) 0%, rgba(255,30,110,1) 45%, rgba(220,20,90,0.98) 100%); box-shadow:0 0 2px rgba(255,30,110,0.08), 0 0 3px rgba(255,100,160,0.05); }
 .skip-btn.magenta-phase.illuminating .skip-triangle polygon,
 .skip-btn.magenta-phase.illuminating .skip-triangle path { animation: skipFillShimmer 2s ease-in-out infinite, skipOutlinePulse 2.8s ease-in-out infinite; }
 
 /* Cyan phase - ultra-minimal glow to match voxel squares */
 .skip-btn.cyan-phase .skip-triangle polygon,
 .skip-btn.cyan-phase .skip-triangle path { fill:#00a8ff; stroke:rgba(100,180,255,0.65); }
 .skip-btn.cyan-phase .skip-triangle__inner { filter: drop-shadow(0 0.5px 1px rgba(0,168,255,0.08)) drop-shadow(0 0 2px rgba(100,200,255,0.05)); }
 .skip-btn.cyan-phase.rounded-bow .skip-connector { background: radial-gradient(circle at 50% 45%, rgba(100,200,255,1) 0%, rgba(0,168,255,1) 45%, rgba(0,140,220,0.98) 100%); box-shadow:0 0 2px rgba(0,168,255,0.08), 0 0 3px rgba(100,200,255,0.05); }
 .skip-btn.cyan-phase.illuminating .skip-triangle polygon,
 .skip-btn.cyan-phase.illuminating .skip-triangle path { animation: skipFillShimmer 2s ease-in-out infinite, skipOutlinePulse 2.8s ease-in-out infinite; }

@keyframes skipGlowPulse {
0%, 100% { filter: drop-shadow(0 0 3px rgba(255,255,255,0.25)) drop-shadow(0 0 6px rgba(255,255,255,0.15)); }
45% { filter: drop-shadow(0 0 4px rgba(255,255,255,0.30)) drop-shadow(0 0 8px rgba(138,180,255,0.20)); }
55% { filter: drop-shadow(0 0 4px rgba(255,255,255,0.28)) drop-shadow(0 0 8px rgba(255,182,46,0.18)); }
}
 @keyframes skipFillShimmer {
 0%, 100% { fill:#ffffff; }
 25% { fill:#f5f9ff; }
 50% { fill:#ffffff; }
 75% { fill:#eef3ff; }
 }
 @keyframes skipOutlinePulse {
 0%, 100% { stroke:rgba(138,180,255,0.45); stroke-width:5; }
 40% { stroke:rgba(255,255,255,0.85); stroke-width:6.5; }
 60% { stroke:rgba(255,182,46,0.7); stroke-width:6; }
 }
 @keyframes skipJiggleLeft {
 0%, 100% { transform: translate(0, 0); }
 40% { transform: translate(-6%, -6%); }
 70% { transform: translate(4%, 4%); }
 }
 @keyframes skipJiggleRight {
 0%, 100% { transform: translate(0, 0); }
 40% { transform: translate(6%, -5%); }
 70% { transform: translate(-4%, 4%); }
 }
@keyframes skipCenterPulse {
0%, 100% { box-shadow:0 0 3px rgba(255,255,255,0.25), 0 0 6px rgba(255,255,255,0.15); }
45% { box-shadow:0 0 4px rgba(138,180,255,0.30), 0 0 8px rgba(255,255,255,0.20); }
65% { box-shadow:0 0 4px rgba(255,182,46,0.28), 0 0 8px rgba(255,255,255,0.18); }
}

/* Idle timeout bloom increase */
.skip-btn.idle-bloom-increase .skip-triangle__inner { 
animation: skipGlowPulse 2.4s ease-in-out infinite, idleBloomIncrease 3s ease-out forwards; 
}
.skip-btn.idle-bloom-increase.rounded-bow .skip-connector { 
animation: skipCenterPulse 2.2s ease-in-out infinite, idleBloomIncrease 3s ease-out forwards; 
}

@keyframes idleBloomIncrease {
0% { filter: drop-shadow(0 0 3px rgba(255,255,255,0.25)) drop-shadow(0 0 6px rgba(255,255,255,0.15)); }
100% { filter: drop-shadow(0 0 12px rgba(255,255,255,0.50)) drop-shadow(0 0 24px rgba(255,255,255,0.30)) drop-shadow(0 0 36px rgba(255,255,255,0.15)); }
}

/* Static glitch distortion after max bloom */
.skip-btn.idle-glitching { animation: staticGlitchDistortion 0.15s steps(4) infinite; }
@keyframes staticGlitchDistortion {
0% { transform: translate(-50%, 0) translateX(0px); }
25% { transform: translate(-50%, 0) translateX(-3px); }
50% { transform: translate(-50%, 0) translateX(2px); }
75% { transform: translate(-50%, 0) translateX(-2px); }
100% { transform: translate(-50%, 0) translateX(1px); }
}

/* Barrel distortion - CRT bulge effect with radial scaling */
 @keyframes barrelStage1 {
 0% { 
 transform: perspective(1400px) translateZ(0) scale(1) rotateX(0deg); 
 filter: saturate(1) contrast(1); 
 border-radius: 0;
 box-shadow: none;
 }
 35% { 
 transform: perspective(700px) translateZ(85px) scale(1.08) rotateX(2deg); 
 filter: saturate(1.15) contrast(1.1) brightness(1.05);
 border-radius: 16px;
 box-shadow: 0 0 30px rgba(0,255,0,0.3), inset 0 0 20px rgba(0,255,0,0.1);
 }
 70% { 
 transform: perspective(900px) translateZ(35px) scale(1.04) rotateX(1deg); 
 filter: saturate(1.08) contrast(1.06) brightness(1.02);
 border-radius: 10px;
 box-shadow: 0 0 20px rgba(0,255,0,0.2), inset 0 0 15px rgba(0,255,0,0.05);
 }
 100% { 
 transform: perspective(1100px) translateZ(24px) scale(1.025) rotateX(0.5deg); 
 filter: saturate(1.05) contrast(1.03);
 border-radius: 8px;
 box-shadow: 0 0 15px rgba(0,255,0,0.15), inset 0 0 10px rgba(0,255,0,0.03);
 }
 }
 @keyframes barrelStage2 {
 0% { 
 transform: perspective(1100px) translateZ(24px) scale(1.025) rotateX(0.5deg); 
 filter: saturate(1.05) contrast(1.04); 
 border-radius: 8px;
 box-shadow: 0 0 15px rgba(0,255,0,0.15), inset 0 0 10px rgba(0,255,0,0.03);
 }
 38% { 
 transform: perspective(600px) translateZ(140px) scale(1.15) rotateX(4deg); 
 filter: saturate(1.35) contrast(1.25) brightness(1.08);
 border-radius: 24px;
 box-shadow: 0 0 50px rgba(0,255,0,0.5), inset 0 0 30px rgba(0,255,0,0.2);
 }
 72% { 
 transform: perspective(750px) translateZ(65px) scale(1.08) rotateX(2deg); 
 filter: saturate(1.20) contrast(1.15) brightness(1.04);
 border-radius: 18px;
 box-shadow: 0 0 35px rgba(0,255,0,0.35), inset 0 0 20px rgba(0,255,0,0.12);
 }
 100% { 
 transform: perspective(900px) translateZ(40px) scale(1.05) rotateX(1deg); 
 filter: saturate(1.14) contrast(1.1);
 border-radius: 14px;
 box-shadow: 0 0 25px rgba(0,255,0,0.25), inset 0 0 15px rgba(0,255,0,0.08);
 }
 }
 @keyframes barrelStage3 {
 0% { 
 transform: perspective(900px) translateZ(40px) scale(1.05) rotateX(1deg); 
 filter: saturate(1.14) contrast(1.1); 
 border-radius: 14px;
 box-shadow: 0 0 25px rgba(0,255,0,0.25), inset 0 0 15px rgba(0,255,0,0.08);
 }
 32% { 
 transform: perspective(500px) translateZ(210px) scale(1.22) rotateX(6deg); 
 filter: saturate(1.65) contrast(1.45) brightness(1.12);
 border-radius: 32px;
 box-shadow: 0 0 70px rgba(0,255,0,0.7), inset 0 0 40px rgba(0,255,0,0.3);
 }
 62% { 
 transform: perspective(600px) translateZ(120px) scale(1.14) rotateX(4deg); 
 filter: saturate(1.45) contrast(1.32) brightness(1.08);
 border-radius: 26px;
 box-shadow: 0 0 55px rgba(0,255,0,0.55), inset 0 0 30px rgba(0,255,0,0.22);
 }
 88% { 
 transform: perspective(700px) translateZ(75px) scale(1.10) rotateX(2.5deg); 
 filter: saturate(1.32) contrast(1.22) brightness(1.05);
 border-radius: 20px;
 box-shadow: 0 0 40px rgba(0,255,0,0.4), inset 0 0 22px rgba(0,255,0,0.15);
 }
 100% { 
 transform: perspective(800px) translateZ(55px) scale(1.07) rotateX(1.5deg); 
 filter: saturate(1.24) contrast(1.16);
 border-radius: 16px;
 box-shadow: 0 0 30px rgba(0,255,0,0.3), inset 0 0 18px rgba(0,255,0,0.12);
 }
 }
 @keyframes screenShatterFlash {
 0% { opacity:0; filter:brightness(1); }
 10% { opacity:1; filter:brightness(1.35); }
 40% { opacity:0.85; filter:brightness(1.12); }
 100% { opacity:0.72; filter:brightness(1.05); }
 }
 @keyframes screenShatterFade {
 0% { opacity:0.7; }
 60% { opacity:0.4; }
 100% { opacity:0; }
 }
 #visicalc.barrel-stage-1, #visicalc.barrel-stage-1 #visicalc-frame { animation: barrelStage1 1.2s ease forwards; }
 #visicalc.barrel-stage-2, #visicalc.barrel-stage-2 #visicalc-frame { animation: barrelStage2 1.35s ease forwards; }
 #visicalc.barrel-stage-3, #visicalc.barrel-stage-3 #visicalc-frame { animation: barrelStage3 1.6s ease forwards; }
 #visicalc.screen-shatter, #visicalc.screen-shatter #visicalc-frame { animation: shakeScreen 0.8s ease forwards; }
 .shatter-overlay { position:fixed; inset:0; pointer-events:none; z-index:180; opacity:0; mix-blend-mode:screen; }
 .shatter-overlay.active { animation: screenShatterFlash 0.9s ease forwards; }
 .shatter-overlay.fade { animation: screenShatterFade 1.3s ease forwards; }
 .shatter-overlay .shatter-cracks { 
 position:absolute; inset:0; 
 background-image: 
 repeating-linear-gradient(0deg, #0ff 0px, #0ff 2px, transparent 2px, transparent 18px),
 repeating-linear-gradient(90deg, #0ff 0px, #0ff 2px, transparent 2px, transparent 18px);
 background-size: 100% 100%; 
 opacity:0; 
 filter: drop-shadow(0 0 8px rgba(0,255,255,0.8)) drop-shadow(0 0 20px rgba(0,255,255,0.4)); 
 animation: shatterGridGlow 1.8s ease forwards;
 }
 @keyframes shatterGridGlow {
 0% { opacity:0; filter: drop-shadow(0 0 2px rgba(0,255,255,0.3)); }
 20% { opacity:0.8; filter: drop-shadow(0 0 12px rgba(0,255,255,0.9)) drop-shadow(0 0 24px rgba(0,255,255,0.5)); }
 45% { opacity:1; filter: drop-shadow(0 0 18px rgba(0,255,255,1)) drop-shadow(0 0 32px rgba(0,255,255,0.7)); }
 70% { opacity:0.6; filter: drop-shadow(0 0 8px rgba(0,255,255,0.4)); transform: scale(1.1); }
 100% { opacity:0; filter: drop-shadow(0 0 2px rgba(0,255,255,0.1)); transform: scale(1.5); }
 }
 .shatter-overlay .shatter-pixels {
 position:absolute; inset:0; opacity:0;
 background-image: 
 radial-gradient(circle, #0ff 1px, transparent 1px),
 radial-gradient(circle, #00ffaa 1px, transparent 1px);
 background-size: 8px 8px, 10px 10px;
 background-position: 0 0, 5px 5px;
 filter: blur(0.5px);
 animation: shatterPixelBurst 2.2s ease forwards;
 animation-delay: 0.4s;
 }
 @keyframes shatterPixelBurst {
 0% { opacity:0; transform: scale(1); filter: blur(0px); }
 25% { opacity:0.9; transform: scale(1); filter: blur(0px); }
 55% { opacity:1; transform: scale(1.15); filter: blur(1px); }
 75% { opacity:0.5; transform: scale(1.4); filter: blur(3px); }
 100% { opacity:0; transform: scale(2); filter: blur(8px); }
 }
 @keyframes shakeScreen {
 0%, 100% { transform: perspective(900px) translateZ(12px) rotate(0deg); }
 20% { transform: perspective(760px) translateZ(36px) rotate(1.4deg); }
 40% { transform: perspective(820px) translateZ(28px) rotate(-1.2deg); }
 60% { transform: perspective(780px) translateZ(44px) rotate(1deg); }
 80% { transform: perspective(860px) translateZ(24px) rotate(-0.8deg); }
 }

 .visicell-note-line { display:inline-block; min-width:1ch; opacity:0; transform:translateY(6px); animation: visicellNoteSlide 0.6s ease forwards; }
 .visicell-note-line--1 { animation-delay:0.2s; }
 .visicell-note-line--2 { animation-delay:0.45s; }
 @keyframes visicellNoteSlide {
 from { opacity:0; transform:translateY(10px); }
 to { opacity:1; transform:translateY(0); }
 }

/* Debug toast */
.toast{ position:fixed; right:14px; top:14px; background:rgba(18,18,18,.9); color:#cbd5e1; border:1px solid rgba(255,255,255,.08); border-radius:10px; padding:10px 12px; font: 12px/1.3 ui-monospace, SFMono-Regular, Menlo, Consolas, "Segoe UI Symbol", "Segoe UI Emoji", "Apple Color Emoji", monospace; z-index: 9; box-shadow: 0 10px 24px rgba(0,0,0,.35); pointer-events:none; opacity:.95; max-width: 42ch; }
 .toast strong{ color:#fff; font-weight:700; }
 .toast .ok{ color:#9ae6b4; }
 .toast .warn{ color:#f6e05e; }
 .toast .err{ color:#feb2b2; }
 .r-hint { transition: text-shadow 0.6s ease, opacity 0.6s ease; text-shadow: none; }
 .r-hint.glow { text-shadow: 0 0 8px #0f0, 0 0 16px #0f0; }
 .r-hint .r-line { display:block; line-height:1.4; }
 .r-hint .r-char { display:inline-block; width:1ch; transition: transform 0.85s cubic-bezier(0.19, 1, 0.22, 1), opacity 0.85s ease, filter 0.85s ease; }
 .r-hint .r-char.falling { transform: translateY(26px); opacity:0; filter: blur(2px); }
 #matrixPleaOverlay { position:absolute; bottom:22px; left:32px; font-family:'VT323', 'Courier New', monospace; font-size:18px; letter-spacing:0.28em; text-transform:uppercase; color:#0f0; text-shadow:0 0 6px rgba(0,255,160,0.7); opacity:0; transform:translateY(8px); pointer-events:none; transition: opacity 0.5s ease, transform 0.45s ease; }
 #matrixPleaOverlay.visible { opacity:0.92; transform:translateY(0); }
 #matrixPleaOverlay.glitch { animation: matrixPleaGlitch 0.35s steps(2) infinite; }
 .matrix-plead { text-shadow:0 0 3px rgba(0,255,160,0.5), 0 0 8px rgba(0,255,140,0.35); }
 .matrix-plead-flash { animation: matrixPleaFlash 0.28s ease-out; }
 @keyframes matrixPleaGlitch {
 0%, 100% { transform:translateY(0); text-shadow:0 0 6px rgba(0,255,160,0.7); }
 40% { transform:translate(-2px, -1px) skewX(-4deg); text-shadow:0 0 10px rgba(0,255,200,0.9), -2px 0 #00ffd5; }
 75% { transform:translate(2px, 1px) skewX(3deg); text-shadow:0 0 10px rgba(170,255,120,0.85), 2px 0 #b3ff00; }
 }
 @keyframes matrixPleaFlash {
 0% { filter:brightness(1); text-shadow:0 0 3px rgba(0,255,160,0.4); }
 45% { filter:brightness(1.35); text-shadow:0 0 14px rgba(0,255,200,0.85); }
 100% { filter:brightness(1); text-shadow:0 0 4px rgba(0,255,140,0.45); }
 }
 
/* Scene Select Menu */
#sceneSelect { position:fixed; inset:0; background:rgba(0,0,0,0.95); display:none; align-items:center; justify-content:center; z-index:9999; }
#sceneSelect.visible { display:flex; }
.scene-menu { max-width:600px; width:90%; padding:40px; background:rgba(0,20,10,0.9); border:2px solid #0f0; border-radius:20px; box-shadow:0 0 30px rgba(0,255,160,0.3), inset 0 0 20px rgba(0,255,160,0.1); font-family:'Courier New', 'Segoe UI Symbol', 'Segoe UI Emoji', 'Apple Color Emoji', monospace; backdrop-filter:blur(10px); }
 .scene-menu h2 { margin:0 0 10px; color:#0f0; font-size:24px; text-align:center; text-transform:uppercase; letter-spacing:0.2em; text-shadow:0 0 10px rgba(0,255,160,0.6); }
 .scene-menu p { margin:0 0 25px; color:#0a8; font-size:13px; text-align:center; opacity:0.8; }
 .scene-option { margin:12px 0; padding:16px 20px; background:rgba(0,30,20,0.6); border:1px solid #0a6; border-radius:8px; color:#0f0; cursor:pointer; transition:all 0.2s ease; text-transform:uppercase; letter-spacing:0.15em; font-size:14px; }
 .scene-option:hover { background:rgba(0,50,30,0.9); border-color:#0f0; box-shadow:0 0 15px rgba(0,255,160,0.4); transform:translateX(5px); }
 .scene-option.locked { opacity:0.4; cursor:not-allowed; background:rgba(20,20,20,0.6); border-color:#444; color:#666; }
 .scene-option.locked:hover { transform:none; box-shadow:none; }
 .scene-option-desc { font-size:11px; opacity:0.7; margin-top:6px; letter-spacing:0.05em; text-transform:none; }
 .scene-controls { margin-top:25px; padding-top:20px; border-top:1px solid #0a6; display:flex; gap:10px; flex-wrap:wrap; }
 .scene-controls button { flex:1; min-width:140px; padding:12px; background:rgba(0,40,20,0.8); border:1px solid #0a8; border-radius:6px; color:#0f0; cursor:pointer; font-family:inherit; font-size:12px; text-transform:uppercase; letter-spacing:0.1em; transition:all 0.2s; }
 .scene-controls button:hover { background:rgba(0,60,30,0.9); border-color:#0f0; box-shadow:0 0 12px rgba(0,255,160,0.3); }
 .scene-controls .close-btn { background:rgba(40,0,0,0.8); border-color:#a00; color:#f66; }
 .scene-controls .close-btn:hover { background:rgba(60,0,0,0.9); border-color:#f00; box-shadow:0 0 12px rgba(255,100,100,0.3); }
 </style>
</head>
<body>
 <div id="app" class="scanlines"></div>
 <div class="hud">
 <div id="quote" class="quote">
 <span id="quoteBefore" class="quote__text">...if you gaze for long into an abyss, the abyss gazes also into you.</span>
 <span id="quoteAfter" class="quote__text" style="display:none;"></span>
 </div>
 <div id="loomworks" class="loomworks" aria-live="polite">
 <span id="loomPre" class="loomworks-chunk">L</span><span id="loomCore" class="loomworks-chunk">OO</span><span id="loomPost" class="loomworks-chunk">K</span><span id="loomTail" class="loomworks-chunk"></span>
 </div>
 <span id="floatingK" class="floatingK" aria-hidden="true">K</span>
 <div class="vignette"></div>
 </div>
 <div id="screenGlitch" class="screenGlitch"></div>
 
 <!-- Doorway portal -->
 <div id="doorway" class="doorway">
 <div class="prompt-container">
 <div class="prompt" data-text="=STAR_"><span id="promptText">=STAR</span><span id="promptCursor" class="cursor">_</span></div>
 </div>
 </div>
 
 <!-- Hidden input for mobile keyboard -->
 <input id="hiddenInput" type="text" style="position:absolute; left:-9999px; opacity:0;" autocomplete="off" autocapitalize="none" autocorrect="off" spellcheck="false" inputmode="text" enterkeyhint="done" />
 
 <audio id="chime" preload="auto">
 <source src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA=" type="audio/wav">
 </audio>
 <div id="fallback" class="fallback" style="display:none">?? WebGL unavailable or ES Modules not supported. Try a newer browser/GPU.</div>

<div id="play" class="play">
<button id="playBtn">Play</button>
<button id="sceneSelectBtn" style="font-size:12px; padding:10px 20px; opacity:0.7;">Scene Select</button>
<button id="testAudioBtn" style="font-size:12px; padding:10px 20px; opacity:0.7; margin-top: 10px;">TEST</button>
</div>
 
 <!-- Scene Select Menu -->
 <div id="sceneSelect">
 <div class="scene-menu">
 <h2>Scene Select</h2>
 <p>Jump to previously experienced sequences</p>
 
 <div id="sceneOptions">
 <div class="scene-option locked" data-scene="visicell">
 <div>END(?) ? VisiCell</div>
 <div class="scene-option-desc">The terminal awakens - spreadsheet reality unfolds</div>
 </div>
 
 <div class="scene-option locked" data-scene="leave">
 <div>LEAVE ? Initialize</div>
 <div class="scene-option-desc">The house of leaves - GIR.mp3 transformation</div>
 </div>
 
 <div class="scene-option locked" data-scene="theos">
 <div>THE.OS ? Cell Lattice</div>
 <div class="scene-option-desc">Cell address grid formation - witness the architecture</div>
 </div>
 
 <div class="scene-option locked" data-scene="blackhole">
 <div>THE.OS ? Black Hole</div>
 <div class="scene-option-desc">The void manifests - singularity achieved</div>
 </div>
 
 <div class="scene-option locked" data-scene="end3">
 <div>HARD.CORE ? End3</div>
 <div class="scene-option-desc">Terminal environment - crawl sequence</div>
 </div>
 
 <div class="scene-option locked" data-scene="fullhand">
 <div>EXEC.ENV ? Execution Environment</div>
 <div class="scene-option-desc">Integrated scene - voxel hand, keyboard, character & glowing head</div>
 <div class="scene-mode-toggle" style="margin-top: 8px; display: flex; gap: 8px;">
 <button class="mode-btn active" data-mode="sequence" data-scene-target="fullhand" style="flex: 1; padding: 6px 12px; background: #4a7cff; border: 1px solid #6a9cff; color: #fff; border-radius: 4px; cursor: pointer; font-size: 11px; transition: all 0.2s;">Sequence</button>
 <button class="mode-btn" data-mode="debug" data-scene-target="fullhand" style="flex: 1; padding: 6px 12px; background: #2a2a2f; border: 1px solid #444; color: #ddd; border-radius: 4px; cursor: pointer; font-size: 11px; transition: all 0.2s;">Debug</button>
 </div>
 </div>
 
 <div class="scene-option locked" data-scene="cellireal">
 <div>CELLI.REAL ? Spreadsheet Reality</div>
 <div class="scene-option-desc">The awakened terminal - interactive spreadsheet environment</div>
 </div>
 </div>
 
 <div class="scene-controls">
 <button id="debugToggle">Debug: Show All</button>
 <button id="clearProgress">Clear Progress</button>
 <button class="close-btn" id="closeSceneSelect">Close</button>
 </div>
 </div>
 </div>
 
 <div id="skipBtn" class="skip-btn hidden" role="button" aria-label="Skip intro" tabindex="0">
 <div class="skip-triangle skip-triangle--left" id="skipTriangle1">
 <div class="skip-triangle__inner">
 <svg viewBox="0 0 100 86.6025403784" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
 <polygon points="0,0 0,86.6025403784 100,43.3012701892"></polygon>
 <path d="M0,12 L0,74.6025403784 Q0,86.6025403784 11.012,81.8342402525 L88.988,48.0696001263 Q100,43.3012701892 88.988,38.5329402521 L11.012,4.7679001263 Q0,0 0,12 Z"></path>
 </svg>
 </div>
 </div>
 <div class="skip-connector" id="skipConnector" aria-hidden="true"></div>
 <div class="skip-triangle skip-triangle--right" id="skipTriangle2">
 <div class="skip-triangle__inner">
 <svg viewBox="0 0 100 86.6025403784" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
 <polygon points="100,0 100,86.6025403784 0,43.3012701892"></polygon>
 <path d="M100,12 L100,74.6025403784 Q100,86.6025403784 88.988,81.8342402525 L11.012,48.0696001263 Q0,43.3012701892 11.012,38.5329402521 L88.988,4.7679001263 Q100,0 100,12 Z"></path>
 </svg>
 </div>
 </div>
 </div>
 <div id="toast" class="toast" style="display:none"></div>

 <!-- Import map so bare specifiers resolve to CDN modules -->
 <script type="importmap">
 {
 "imports": {
 "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
 "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
 }
 }
 </script>

 <script type="module">
 // --- Imports ------------------------------------------------------------
 import * as THREE from "three";
 import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer.js";
 import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass.js";
 import { UnrealBloomPass } from "three/examples/jsm/postprocessing/UnrealBloomPass.js";
 import { AfterimagePass } from "three/examples/jsm/postprocessing/AfterimagePass.js";
 import { ShaderPass } from "three/examples/jsm/postprocessing/ShaderPass.js";
 import { BokehPass } from "three/examples/jsm/postprocessing/BokehPass.js";
 import { FilmPass } from "three/examples/jsm/postprocessing/FilmPass.js";
 import { RoundedBoxGeometry } from "three/examples/jsm/geometries/RoundedBoxGeometry.js";

 // ==========================================
 // CACHE BUSTER: VERSION FINAL FIX v5.3
 // HARD REFRESH NOW: Ctrl+Shift+R or Ctrl+F5
 // ==========================================
 console.log('%c?? VERSION FINAL FIX v5.3 LOADED ??', 'background: #ff4400; color: #fff; font-size: 24px; padding: 10px; font-weight: 900; text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;');
 console.log('%c? Removed ALL duplicate variable declarations - speechRActive fixed', 'background: #0ff; color: #000; font-size: 18px; padding: 8px; font-weight: bold;');
 console.log('%c?? HARD REFRESH: Ctrl+Shift+R or Ctrl+F5 ??', 'background: #ff6600; color: #fff; font-size: 18px; padding: 8px;');
 
 // Make THREE and imports available globally for end3 scene
 window.THREE = THREE;
 window.EffectComposer = EffectComposer;
 window.RenderPass = RenderPass;
 window.UnrealBloomPass = UnrealBloomPass;
 window.AfterimagePass = AfterimagePass;
 window.ShaderPass = ShaderPass;
 window.BokehPass = BokehPass;
 window.FilmPass = FilmPass;
 window.RoundedBoxGeometry = RoundedBoxGeometry;

 // --- Debug helpers ------------------------------------------------------
 const toastEl = document.getElementById('toast');
 function toast(lines, level='ok'){
 const arr = Array.isArray(lines) ? lines : [String(lines)];
 toastEl.innerHTML = `<strong>Debug</strong><br>${arr.map(l=>`<span class="${level}">${l}</span>`).join('<br>')}`;
 toastEl.style.display='block';
 }
 function clearToast(){ toastEl.style.display='none'; }

 // --- WebGL capability check --------------------------------------------
 const hasWebGL = (() => { try { const c = document.createElement('canvas'); return !!(window.WebGLRenderingContext && (c.getContext('webgl2')||c.getContext('webgl')||c.getContext('experimental-webgl'))); } catch(e){ return false; } })();
 if (!hasWebGL) { document.getElementById('fallback').style.display = 'flex'; throw new Error('WebGL not available'); }

 // --- Core setup ---------------------------------------------------------
 const app = document.getElementById('app');
 const quoteEl = document.getElementById('quote');
 const quoteBefore = document.getElementById('quoteBefore');
 const quoteAfter = document.getElementById('quoteAfter');
 const loomworksEl = document.getElementById('loomworks');
 const loomPre = document.getElementById('loomPre');
 const loomCore = document.getElementById('loomCore');
 const loomPost = document.getElementById('loomPost');
 const loomTail = document.getElementById('loomTail');
 const quoteStates = {
 initial: {
 text: '...if you gaze for long into an abyss, the abyss gazes also into you.',
 showLook: false
 },
 look: {
 text: '...if you LOOK for long into an abyss, the abyss LOOKS also into you.',
 showLook: false
 },
 despair: {
 text: 'LOOK on my works, ye Mighty, and despair!',
 showLook: false
 }
 };

 applyQuoteState(quoteStates.initial, { immediate: true });
 quoteEl.classList.remove('quote--loom');
 loomTail.innerHTML = '';
 const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false, powerPreference:'high-performance' });
 renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
 renderer.setSize(window.innerWidth, window.innerHeight);
 renderer.outputColorSpace = THREE.SRGBColorSpace;
 renderer.toneMapping = THREE.ACESFilmicToneMapping;
 renderer.toneMappingExposure = 1.0;
 renderer.setClearColor(0x000000, 1);
 app.appendChild(renderer.domElement);

 const scene = new THREE.Scene();
 const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.01, 10);
 camera.position.set(0, 0, 2);
 camera.lookAt(0, 0, 0);

 const blackHoleGeo = new THREE.CircleGeometry(0.35, 64);
 const blackHoleMat = new THREE.ShaderMaterial({
 uniforms: { time: { value: 0 }, pulseFactor: { value: 0.5 } },
 vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
 fragmentShader: `
 varying vec2 vUv; uniform float time; uniform float pulseFactor;
 void main() {
 vec2 center = vec2(0.5);
 float dist = distance(vUv, center);
 // Organic pulsing with multiple harmonics
 float baseRadius = 0.08 + pulseFactor * 0.28;
 float pulse1 = 0.015 * sin(time * 3.5);
 float pulse2 = 0.008 * sin(time * 7.3 + 1.5);
 float radius = baseRadius + pulse1 + pulse2;
 // Ultra-soft gradient fade for dreamy quality
 float fadeDistance = radius * 1.6;
 float alpha = 1.0 - smoothstep(radius - fadeDistance, radius, dist);
 // Softer alpha curve with slight glow at edges
 alpha = pow(alpha, 0.6) * 0.9;
 gl_FragColor = vec4(0.0, 0.0, 0.0, alpha);
 }
 `,
 transparent: true, depthWrite: false
 });
 const blackHole = new THREE.Mesh(blackHoleGeo, blackHoleMat);
 blackHole.position.z = 0.1;
 scene.add(blackHole);

 const R = 0.16;
 const makeMat = (hex) => new THREE.MeshBasicMaterial({ color: new THREE.Color(hex), blending: THREE.AdditiveBlending, transparent: true, depthWrite: false });
 const CYAN = 0x00a8ff, MAGENTA = 0xff1e6e, YELLOW = 0xffb62e;
 const colors = [new THREE.Color(CYAN), new THREE.Color(YELLOW), new THREE.Color(MAGENTA)];
 
 // Create custom rounded shapes: square (cyan), triangle (yellow), circle (magenta)
 
 // Shape 0: Rounded Square (Blue/Cyan)
 const createRoundedSquare = (size, radius) => {
 const shape = new THREE.Shape();
 const r = radius;
 const s = size / 2;
 shape.moveTo(-s + r, -s);
 shape.lineTo(s - r, -s);
 shape.quadraticCurveTo(s, -s, s, -s + r);
 shape.lineTo(s, s - r);
 shape.quadraticCurveTo(s, s, s - r, s);
 shape.lineTo(-s + r, s);
 shape.quadraticCurveTo(-s, s, -s, s - r);
 shape.lineTo(-s, -s + r);
 shape.quadraticCurveTo(-s, -s, -s + r, -s);
 return new THREE.ShapeGeometry(shape, 32);
 };
 
 // Shape 1: Rounded Triangle (Yellow) - flat bottom, pointing up
 const createRoundedTriangle = (size, radius) => {
 const shape = new THREE.Shape();
 const h = size * Math.sqrt(3) / 2; // Equilateral triangle height
 
 // Three vertices of equilateral triangle with FLAT BOTTOM
 const top = { x: 0, y: h / 2 }; // Top vertex (pointing up)
 const bl = { x: -size/2, y: -h / 2 }; // Bottom left
 const br = { x: size/2, y: -h / 2 }; // Bottom right
 
 const r = radius * 0.8; // Smaller radius for cleaner corners
 
 // Start at bottom-left, move clockwise
 shape.moveTo(bl.x + r, bl.y);
 
 // Bottom edge to bottom-right
 shape.lineTo(br.x - r, br.y);
 
 // Curve around bottom-right corner
 shape.quadraticCurveTo(br.x, br.y, br.x - r * 0.5, br.y + r * 0.866);
 
 // Right edge going up to top
 shape.lineTo(top.x + r * 0.5, top.y - r * 0.866);
 
 // Curve around top corner
 shape.quadraticCurveTo(top.x, top.y, top.x - r * 0.5, top.y - r * 0.866);
 
 // Left edge going down to bottom-left
 shape.lineTo(bl.x + r * 0.5, bl.y + r * 0.866);
 
 // Curve around bottom-left corner
 shape.quadraticCurveTo(bl.x, bl.y, bl.x + r, bl.y);
 
 return new THREE.ShapeGeometry(shape, 32);
 };
 
 // Shape 2: Circle (Pink/Magenta)
 const createCircle = (radius) => {
 return new THREE.CircleGeometry(radius, 64);
 };
 
 const geoSquare = createRoundedSquare(R * 2, R * 0.3);
 const geoTriangle = createRoundedTriangle(R * 2, R * 0.35);
 const geoCircle = createCircle(R);
 
 // Store original geometries for morphing
 const originalGeos = [geoSquare, geoTriangle, geoCircle];
 
 // Create circle targets for morphing (all shapes will become circles)
 const circleGeoTarget = createCircle(R);
 
 const spheres = [
 new THREE.Mesh(geoSquare, makeMat(CYAN)),
 new THREE.Mesh(geoTriangle, makeMat(YELLOW)),
 new THREE.Mesh(geoCircle, makeMat(MAGENTA))
 ];
 spheres.forEach((s,i)=>{ s.position.z = -i*0.002; scene.add(s); });

// --- Voxel System for CELLI - Early Computer Typeface Style ---
const voxelSize = 0.05; // Smaller voxels for denser appearance
// Create a thin, flat box for early computer terminal look - more like vector graphics
const voxelGeo = new THREE.BoxGeometry(voxelSize * 0.95, voxelSize * 0.95, voxelSize * 0.15);
 const voxelMat = new THREE.MeshBasicMaterial({ 
 color: 0x444444, // Start as dim gray
 transparent: true, 
 opacity: 0,
 blending: THREE.NormalBlending // Normal blending for borders
 });
 
 // Create edges geometry for borders - straight lines, not rounded
 const edgesGeo = new THREE.EdgesGeometry(voxelGeo);
 const edgeMat = new THREE.LineBasicMaterial({ 
 color: 0x888888,
 transparent: true,
 opacity: 0,
 linewidth: 1 // Thin, crisp lines
 });
 
 // Rounded voxels for yellow phase - still thin but with subtle rounding
 const roundedVoxelGeo = new RoundedBoxGeometry(voxelSize * 1.05, voxelSize * 1.05, voxelSize * 0.18, 5, Math.min(voxelSize * 0.4, 0.04));
 const roundedEdgesGeo = new THREE.EdgesGeometry(roundedVoxelGeo);
 const cellShadeBaseMaterial = new THREE.MeshBasicMaterial({
 color: 0xfff27a,
 transparent: true,
 opacity: 0.92,
 blending: THREE.AdditiveBlending
 });
 const cellShadeEdgeMaterial = new THREE.LineBasicMaterial({
 color: 0xfff9a1,
 transparent: true,
 opacity: 0.75
 });

 // CELLI letter patterns (5x5 grid for each letter)
 const celliPatterns = {
 C: [[0,1,1,1,0], [1,0,0,0,0], [1,0,0,0,0], [1,0,0,0,0], [0,1,1,1,0]],
 E: [[1,1,1,1,1], [1,0,0,0,0], [1,1,1,1,0], [1,0,0,0,0], [1,1,1,1,1]],
 L: [[1,0,0,0,0], [1,0,0,0,0], [1,0,0,0,0], [1,0,0,0,0], [1,1,1,1,1]],
 I: [[1,1,1,1,1], [0,0,1,0,0], [0,0,1,0,0], [0,0,1,0,0], [1,1,1,1,1]]
 };
 
const voxels = [];
const letterVoxels = { C: [], E: [], L1: [], L2: [], I: [] }; // Track voxels by letter
const letters = ['C', 'E', 'L', 'L', 'I'];
let letterSpacing = 0.4; // Denser letter spacing
let celliScale = 1.0;
 
 // Responsive scaling for touch devices
 function calculateCelliScale() {
 const aspect = window.innerWidth / window.innerHeight;
 
 // Calculate total width needed for all letters (including padding)
 const totalBaseWidth = letters.length * letterSpacing;
 
 // Camera view width in world units
 let viewWidth;
 if (aspect > 1) {
 // Landscape
 viewWidth = aspect * 2;
 } else {
 // Portrait
 viewWidth = 2;
 }
 
 // Scale to fit 85% of view width
 const targetWidth = viewWidth * 0.85;
 if (totalBaseWidth > targetWidth) {
 celliScale = targetWidth / totalBaseWidth;
 } else {
 celliScale = 1.0;
 }
 }
 calculateCelliScale();
 
 const startX = -(letters.length * letterSpacing * celliScale) / 2 + (letterSpacing * celliScale) / 2;
 
 letters.forEach((letter, letterIdx) => {
 const pattern = celliPatterns[letter];
 const letterX = startX + letterIdx * letterSpacing * celliScale;
 
 pattern.forEach((row, rowIdx) => {
 row.forEach((cell, colIdx) => {
 if (cell === 1) {
 // Create voxel with border
 const voxel = new THREE.Mesh(voxelGeo, voxelMat.clone());
 const edges = new THREE.LineSegments(edgesGeo, edgeMat.clone());
 voxel.add(edges);
 
 const x = letterX + (colIdx - 2) * voxelSize * 1.2 * celliScale;
 const y = (2 - rowIdx) * voxelSize * 1.2 * celliScale + 0.35; // Offset up
 
 voxel.userData = {
 targetX: x,
 targetY: y,
 startY: y + 2.0 + Math.random() * 1.0,
 dropDelay: letterIdx * 0.15 + (rowIdx * colIdx) * 0.02,
 dropSpeed: 0.02 + Math.random() * 0.01,
 settled: false,
 jigglePhase: Math.random() * Math.PI * 2,
 flickerPhase: Math.random() * Math.PI * 2,
 edges: edges, // Store reference to edges
 gridX: letterIdx, // Letter index (0=C, 1=E, 2=L, 3=L, 4=I)
 gridY: rowIdx, // Row index (0=top, 4=bottom)
 gridCol: colIdx, // Column index within letter (0-4)
 glitched: false, // Track if this voxel has been glitched out
 baseScale: celliScale, // Store scale for proper sizing
 backspaceTransformed: false,
 backspacePulseOffset: Math.random() * Math.PI * 2
 };
 
 // Scale voxel size to match the overall scale
 voxel.scale.set(celliScale, celliScale, celliScale);
 
 voxel.position.set(x, voxel.userData.startY, 0);
 voxel.visible = false;
 scene.add(voxel);
 voxels.push(voxel);
 
 // Track voxels by letter for restoration
 const letterKey = letterIdx === 0 ? 'C' : letterIdx === 1 ? 'E' : letterIdx === 2 ? 'L1' : letterIdx === 3 ? 'L2' : 'I';
 letterVoxels[letterKey].push(voxel);
 }
 });
 });
 });

 // --- [NEW] Shader for the color triangle between spheres ---
 const triGeo = new THREE.PlaneGeometry(4, 4); // Covers view
 const triMat = new THREE.ShaderMaterial({
 uniforms: {
 points: { value: [new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2()] },
 colors: { value: colors },
 aspect: { value: 1.0 }
 },
 vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = vec4(position, 1.0); }`,
 fragmentShader: `
 varying vec2 vUv;
 uniform vec2 points[3];
 uniform vec3 colors[3];
 uniform float aspect;

 // Function to calculate barycentric coordinates
 vec3 barycentric(vec2 p, vec2 a, vec2 b, vec2 c) {
 vec2 v0 = b - a, v1 = c - a, v2 = p - a;
 float d00 = dot(v0, v0);
 float d01 = dot(v0, v1);
 float d11 = dot(v1, v1);
 float d20 = dot(v2, v0);
 float d21 = dot(v2, v1);
 float denom = d00 * d11 - d01 * d01;
 float v = (d11 * d20 - d01 * d21) / denom;
 float w = (d00 * d21 - d01 * d20) / denom;
 float u = 1.0 - v - w;
 return vec3(u, v, w);
 }

 void main() {
 // Adjust UVs to be centered and handle aspect ratio
 vec2 p = (vUv - 0.5) * 2.0;
 p.x *= aspect;

 vec3 b = barycentric(p, points[0], points[1], points[2]);

 if (b.x >= 0.0 && b.y >= 0.0 && b.z >= 0.0) {
 // We are inside the triangle
 vec3 color = b.x * colors[0] + b.y * colors[1] + b.z * colors[2];
 
 // More defined edges with softer interior
 float edgeDist = min(b.x, min(b.y, b.z));
 float edgeFade = smoothstep(0.0, 0.2, edgeDist);
 
 // Distance-based fading
 float centerDist = length(p);
 float centerFade = 1.0 - smoothstep(0.15, 0.65, centerDist);
 centerFade = pow(centerFade, 0.6);
 
 // Subtle center glow
 float centerGlow = 1.0 - smoothstep(0.0, 0.25, centerDist);
 float finalAlpha = (edgeFade * centerFade + centerGlow * 0.12) * 0.55;
 
 gl_FragColor = vec4(color, finalAlpha);
 } else {
 discard;
 }
 }
 `,
 transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
 });
 const triMesh = new THREE.Mesh(triGeo, triMat);
 triMesh.position.z = -0.1; // Behind spheres
 scene.add(triMesh);

 // --- Composer & passes --------------------------------------------------
 const composer = new EffectComposer(renderer);
 composer.addPass(new RenderPass(scene, camera));

 const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.7, 0.9, 0.2);
 composer.addPass(bloomPass);
 const afterimagePass = new AfterimagePass(0.96);
 composer.addPass(afterimagePass);
 const filmPass = new ShaderPass({
 uniforms: { tDiffuse: { value: null }, time: { value: 0 }, noise: { value: 0.03 }, scanAmp: { value: 0.03 } },
 vertexShader: `varying vec2 vUv; void main(){ vUv = uv; gl_Position = projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
 fragmentShader: `
 precision highp float; varying vec2 vUv; uniform sampler2D tDiffuse; uniform float time; uniform float noise; uniform float scanAmp;
 float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }
 void main(){ vec3 col = texture2D(tDiffuse, vUv).rgb; float n = rand(vUv + fract(time)); float scan = sin((vUv.y + time*0.04)*3.14159*480.0) * scanAmp; col += n*noise; col += scan; col = pow(col, vec3(1.02)); gl_FragColor = vec4(col, 1.0); }`
 });
 composer.addPass(filmPass);

 // --- [REWRITTEN] Eclipse & Radiate Motion with Intro Sequence ----------
 const motionCfg = {
 speed: 0.8,
 maxDist: 0.65,
 rotationSpeed: 0.4,
 minScale: 0.4
 };

 // Intro sequence with magical progression
 const introCfg = {
 rollEnd: 2.5, // Roll into place (slower)
 bounceEnd: 4.5, // Sequential bounces
 triangleEnd: 7.5, // Form triangle + grow + converge
 transitionEnd: 9.5, // Transition to orbit
 normalEnd: 15.5, // Converge + one pulse cycle
 vennEnd: 18.0, // Clear venn diagram
 collapseEnd: 22.0, // Collapse to white circle (extended)
 glitchEnd: 24.5, // Intense glitch + fade (extended)
 blackoutEnd: 26.0, // Complete blackout
 loomworksEnd: 30.0, // Show Loomworks text
 celliEnd: 36.0, // CELLI voxel animation
 doorwayEnd: 44.0, // Doorway portal sequence
 ballSize: 0.12, // Size during intro
 bounceHeight: 0.35, // Bounce amplitude
 bounceDuration: 0.6 // Each bounce duration
 };
 
// Audio context for synth and chime
let audioCtx = null;
window.audioCtx = audioCtx; // Make globally accessible for scene transitions
let synthGain = null;
let synthOsc1 = null;
let synthOsc2 = null;
let synthOsc3 = null;
let landingSounds = [false, false, false]; // Track if shape has landed
let lastThunkTime = [0, 0, 0]; // Track last thunk time for each shape

// --- Audio Loading Helper (Web Audio API) ---
const audioBuffers = {}; // Object to store loaded sounds

async function loadAudioBuffer(url, key) {
if (!audioCtx) {
// Ensure AudioContext is initialized
audioCtx = new (window.AudioContext || window.webkitAudioContext)();
window.audioCtx = audioCtx;
}
try {
console.log(` Attempting to load audio: ${url}`);
const response = await fetch(url);
if (!response.ok) {
throw new Error(`HTTP error! status: ${response.status} - ${response.statusText}`);
}
console.log(` Fetch successful, response status: ${response.status}`);
const arrayBuffer = await response.arrayBuffer();
console.log(` ArrayBuffer size: ${arrayBuffer.byteLength} bytes`);
const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
audioBuffers[key] = audioBuffer;
console.log(` Audio loaded successfully: ${key} (duration: ${audioBuffer.duration.toFixed(2)}s, ${audioBuffer.numberOfChannels} channels)`);
return audioBuffer;
} catch (error) {
console.error(` Error loading audio file ${url}:`, error);
console.error(` Error details:`, error.message);
return null;
}
}

function playAudioBuffer(buffer) {
if (!buffer) {
console.error(' Cannot play audio: buffer is null');
return;
}
if (!audioCtx) {
console.error(' Cannot play audio: audioCtx is null');
return;
}
try {
console.log(' Creating audio source...');
const source = audioCtx.createBufferSource();
source.buffer = buffer;
source.connect(audioCtx.destination); // Connect to speakers
source.start(0); // Play immediately
console.log(' Audio playback started successfully');
} catch (error) {
console.error(' Error playing audio buffer:', error);
}
}
 
 let speechRActive = false;
 let speechRTimeout = null;
 let speechRVoice = null;
 let speechRUtterance = null;
 let speechRGuardTimeout = null;
 let hasSpeechSynthesis = typeof window !== 'undefined' && 'speechSynthesis' in window;
 let matrixUpdateInterval = null;
 let quoteShown = false;
 let quoteDespairShown = false;
 let glitchStarted = false;
 let mediumGlitchStarted = false;
 let intenseGlitchStarted = false;
 let screenGlitchStarted = false;
 let blackoutStarted = false;
 let loomworksShown = false;
 let loomworksRevealStarted = false;
 let chimePlayed = false;
 let celliStarted = false;
 let celliStartTime = 0;
 let doorwayShown = false;
 let doorwayOpened = false;
 let inputAttempted = false;
 let celliGlitchStarted = false;
 let finalRollRotations = [0, 0, 0]; // Store final rotations from roll phase
 const promptBaseText = '=';
 let inputText = '=STAR';
 let tEntered = false;
 let burstAnimStarted = false;
 let burstTimeout = null;
 let celliBackspaceSequenceStarted = false;
 let celliBackspaceSequenceTime = 0;
 let celliBackspaceFlickerTriggered = false;
 const starParticles = []; // Stars from burst voxels
 let loomworksTypingTimeout = null;
 const glitchedVoxelsStack = []; // Track glitched voxels in order for restoration
 let lettersToRestore = ['C', 'E', 'L1', 'L2']; // Order of restoration on backspace
 let restoredLetters = 0;
 let endSequence = ''; // Track E, N, D input sequence
 let allYellowTransformed = false; // Track if all are yellow and transformed
 let yellowTransformCompleteCount = 0;
 let endColorState = 'yellow'; // Track current color state: yellow, magenta, cyan, green
 let endColorPrevState = 'yellow'; // Track previous color for transitions
 let endColorTransitionStart = 0; // When color transition started
 let snapTogetherStarted = false;
 let snapTogetherTime = 0;
 let visiCalcShown = false;
 let celliMoveToCornerStarted = false;
 let celliMoveToCornerTime = 0;
 let visiCalcGreenTransitionStarted = false; // Track when VisiCalc green transition begins
 let bowActive = false;
 let bowCurrentCenter = null;
 let bowTargetCenter = null;
 let bowCurrentRotation = 0;
 let bowTargetRotation = 0;
 let bowAnimationId = 0;
 let bowHasTriggered = false;
 let bowVisibleAsVoxel = true;
 let pendingRoundedBow = false;
 
 // Text particle system for click interactions
 const textParticles = [];
 const manicTexts = ["huh?", "who's there?", "AH!", "HAHA.", "ow.", "ahh...", "oh!", "what?", "why?", "where?", "when?"];
 const timeTexts = () => {
 const formats = [
 new Date().toLocaleTimeString(),
 new Date().toLocaleDateString(),
 `${new Date().getHours()}:${String(new Date().getMinutes()).padStart(2,'0')}`,
 new Date().getFullYear().toString(),
 `${Math.floor(Date.now()/1000)}`,
 new Date().toISOString().split('T')[0]
 ];
 return formats[Math.floor(Math.random() * formats.length)];
 };
 const equationTexts = [
 "x +y =r ", "?f(x)dx", "E=mc ", "?f/?x", "S(x)", "v(a +b )",
 "(0,0)", "(x,y,z)", "[1,2,3]", "?=arctan(y/x)", "? F", "dy/dx"
 ];

 const glitchGlyphs = "!<>-_\\/[]{} =+*^?# ??";

 function glitchSwapQuote(targetState, { duration = 1100, onComplete = null } = {}) {
 if (!targetState) return;
 if (quoteEl.dataset.swapping === '1') return;

 quoteEl.dataset.swapping = '1';
 quoteEl.classList.add('scrambling');

 const initialText = quoteBefore.textContent || '';
 const targetText = targetState.text || '';
 const textMax = Math.max(initialText.length, targetText.length);
 const textDenom = textMax === 0 ? 1 : textMax;
 const start = performance.now();

 const frame = (now) => {
 const elapsed = now - start;
 const progress = Math.min(elapsed / duration, 1);
 let result = '';

 for (let i = 0; i < textMax; i++) {
 if (progress > i / textDenom) {
 result += targetText[i] ?? '';
 } else {
 const fallback = initialText[i] ?? '';
 const randomChar = glitchGlyphs[Math.floor(Math.random() * glitchGlyphs.length)] || fallback;
 result += randomChar;
 }
 }

 quoteBefore.textContent = result;

 if (progress < 1) {
 requestAnimationFrame(frame);
 } else {
 quoteBefore.textContent = targetText;

 quoteEl.classList.remove('scrambling');
 delete quoteEl.dataset.swapping;

 if (typeof onComplete === 'function') {
 onComplete();
 }
 }
 };

 requestAnimationFrame(frame);
 }

 function applyQuoteState(state, { immediate = false, duration, onComplete } = {}) {
 if (!state) return;

 if (immediate) {
 quoteBefore.textContent = state.text || '';
 quoteAfter.textContent = '';
 quoteEl.classList.remove('scrambling');
 delete quoteEl.dataset.swapping;
 if (typeof onComplete === 'function') {
 onComplete();
 }
 return;
 }

 glitchSwapQuote(state, { duration, onComplete });
 }

 function typeLoomTail(text, index = 0) {
 if (index === 0) {
 loomTail.innerHTML = '';
 }

 if (index >= text.length) {
 loomworksTypingTimeout = null;
 return;
 }

 // Wrap each character in a span
 const charSpan = document.createElement('span');
 charSpan.textContent = text[index];
 charSpan.className = 'loomworks-chunk selected';
 loomTail.appendChild(charSpan);
 
 // Remove selected class from this character only
 setTimeout(() => {
 charSpan.classList.remove('selected');
 }, 140);
 
 const baseDelay = index < 3 ? 110 : 65;
 const jitter = Math.random() * 55;
 loomworksTypingTimeout = setTimeout(() => typeLoomTail(text, index + 1), baseDelay + jitter);
 }


 function startLoomworksReveal() {
 if (loomworksRevealStarted) return;
 loomworksRevealStarted = true;

 loomworksEl.classList.add('visible');
 loomPre.textContent = 'L';
 loomCore.textContent = 'OO';
 loomPost.textContent = 'K';
 loomTail.innerHTML = '';

 setTimeout(() => {
 loomCore.classList.add('selected');
 }, 280);

 setTimeout(() => {
 loomCore.textContent = 'oo';
 }, 630);

 setTimeout(() => {
 loomCore.classList.remove('selected');
 }, 1080);

 setTimeout(() => {
 loomPost.classList.add('shift-right');
 }, 900);

 setTimeout(() => {
 loomPost.classList.add('selected');
 loomPost.style.opacity = '0.2';
 }, 980);

 setTimeout(() => {
 loomPost.textContent = 'm';
 loomPost.style.opacity = '1';
 loomPost.classList.remove('shift-right');
 }, 1340);

 setTimeout(() => {
 loomPost.classList.remove('selected');
 setTimeout(() => { loomPost.style.opacity = ''; }, 220);
 }, 1680);

 setTimeout(() => {
 loomPre.style.opacity = '0';
 }, 920);

 setTimeout(() => {
 loomPre.textContent = 'a L';
 loomPre.style.opacity = '1';
 }, 1340);

 setTimeout(() => {
 if (loomworksTypingTimeout) {
 clearTimeout(loomworksTypingTimeout);
 }
 typeLoomTail('works Experience.');
 }, 1380);
 }
 
 function createTextParticle(x, y, text, color, sourceIndex) {
 const angle = Math.random() * Math.PI * 2;
 const speed = 0.004 + Math.random() * 0.006;
 const particle = {
 x, y,
 vx: Math.cos(angle) * speed,
 vy: Math.sin(angle) * speed,
 text,
 color,
 life: 1.0,
 age: 0,
 rotation: (Math.random() - 0.5) * 0.03,
 rotationSpeed: (Math.random() - 0.5) * 0.02,
 pulse: Math.random() * Math.PI * 2,
 sourceIndex,
 collapsing: false
 };
 textParticles.push(particle);
 }
 
 function updateTextParticles(dt) {
 for (let i = textParticles.length - 1; i >= 0; i--) {
 const p = textParticles[i];
 
 p.age += dt;
 
 // Get source sphere position
 const source = spheres[p.sourceIndex].position;
 
 // Calculate attraction to source (gravitational pull)
 const dx = source.x - p.x;
 const dy = source.y - p.y;
 const dist = Math.sqrt(dx * dx + dy * dy);
 
 // After 1.8 seconds, begin dramatic collapse
 if (p.age > 1.8 && !p.collapsing) {
 p.collapsing = true;
 }
 
 if (p.collapsing) {
 // Dramatic collapse: strong pull, wild rotation, rapid fade
 const collapseForce = 0.0008 / (dist * dist + 0.01); // Much stronger!
 p.vx += (dx / dist) * collapseForce;
 p.vy += (dy / dist) * collapseForce;
 
 // Accelerate rotation
 p.rotationSpeed *= 1.05;
 
 // Rapid fade during collapse
 p.life -= dt * 2.5;
 } else {
 // Normal orbit phase
 if (dist > 0.01) {
 const force = 0.00008 / (dist + 0.1);
 p.vx += (dx / dist) * force;
 p.vy += (dy / dist) * force;
 }
 
 // Apply orbital motion
 const orbitForce = 0.00012;
 p.vx += -dy * orbitForce;
 p.vy += dx * orbitForce;
 
 // Normal fade
 p.life -= dt * 0.5;
 }
 
 // Update position
 p.x += p.vx;
 p.y += p.vy;
 
 // Damping (less during collapse for dramatic effect)
 const dampFactor = p.collapsing ? 0.97 : 0.99;
 p.vx *= dampFactor;
 p.vy *= dampFactor;
 
 // Update rotation and pulse
 p.rotation += p.rotationSpeed;
 p.pulse += dt * (p.collapsing ? 8 : 4); // Faster pulse during collapse
 
 if (p.life <= 0) {
 textParticles.splice(i, 1);
 }
 }
 }
 
 function renderTextParticles(ctx, camera) {
 ctx.save();
 ctx.font = 'bold 16px monospace';
 ctx.textAlign = 'center';
 ctx.textBaseline = 'middle';
 
 for (const p of textParticles) {
 // Project from world to screen
 const screenX = (p.x / camera.right) * (window.innerWidth / 2) + (window.innerWidth / 2);
 const screenY = (-p.y / camera.top) * (window.innerHeight / 2) + (window.innerHeight / 2);
 
 ctx.save();
 ctx.translate(screenX, screenY);
 ctx.rotate(p.rotation);
 
 const alpha = p.life * p.life;
 const pulseFactor = 0.85 + Math.sin(p.pulse) * 0.15; // Gentle pulsate
 const glowSize = 5 + Math.sin(p.pulse * 0.7) * 3; // Slower, dreamy pulse
 
 // Scale down dramatically during collapse
 const scaleFactor = p.collapsing ? Math.max(0.1, 1.0 - (p.age - 1.8) * 1.2) : 1.0;
 ctx.scale(scaleFactor, scaleFactor);
 
 // Outer colored glow - intensify during collapse
 const collapseIntensity = p.collapsing ? 1.5 : 1.0;
 ctx.shadowBlur = glowSize * 4 * collapseIntensity;
 ctx.shadowColor = p.color;
 ctx.globalAlpha = alpha * 0.9 * collapseIntensity;
 ctx.fillStyle = p.color;
 ctx.fillText(p.text, 0, 0);
 
 // Mid white glow for visibility
 ctx.shadowBlur = glowSize * 2;
 ctx.shadowColor = '#ffffff';
 ctx.globalAlpha = alpha * 0.95;
 ctx.fillStyle = '#ffffff';
 ctx.fillText(p.text, 0, 0);
 
 // Bright white base (always visible)
 ctx.shadowBlur = glowSize * 0.5;
 ctx.shadowColor = '#ffffff';
 ctx.globalAlpha = alpha;
 ctx.fillStyle = '#ffffff';
 ctx.fillText(p.text, 0, 0);
 
 // Colored accent overlay
 ctx.shadowBlur = 0;
 ctx.globalAlpha = alpha * 0.4;
 ctx.fillStyle = p.color;
 ctx.fillText(p.text, 0, 0);
 
 ctx.restore();
 }
 ctx.restore();
 }
 
 function updateVoxels(t, dt) {
 const celliTime = t - introCfg.loomworksEnd;
 if (celliTime < 0) return;
 
voxels.forEach(voxel => {
const data = voxel.userData;

// Skip glitched voxels - they're permanently disabled
if (data.glitched) return;

// Handle falling off for CELLI -> HELL transformation
if (data.fallingOff) {
const currentTime = Date.now() / 1000;
const timeSinceFallStart = currentTime - data.fallStartTime;

if (timeSinceFallStart > data.fallDelay) {
// Apply gravity
const gravity = 0.003;
data.fallVelocity += gravity;

// Update position
voxel.position.y -= data.fallVelocity;

// Rotate while falling
voxel.rotation.x += data.rotationSpeed.x;
voxel.rotation.y += data.rotationSpeed.y;
voxel.rotation.z += data.rotationSpeed.z;

// Fade out
if (data.edges && data.edges.material) {
data.edges.material.opacity = Math.max(0, data.edges.material.opacity - 0.01);
}
voxel.material.opacity = Math.max(0, voxel.material.opacity - 0.01);

// Check if voxel should reappear in new position
if (voxel.position.y < -2 && data.willReappearAs && !data.hasReappeared) {
data.hasReappeared = true;
// Calculate new position for H right column
const letterIdx = data.willReappearAs.letterIdx;
const newRow = data.willReappearAs.row;
const newCol = data.willReappearAs.col;
const letterSpacing = 0.4; // Match initial density
const voxelSize = 0.05; // Match initial smaller size
const letterX = -(letters.length * letterSpacing * celliScale) / 2 + (letterSpacing * celliScale) / 2 + letterIdx * letterSpacing * celliScale;
const x = letterX + (newCol - 2) * voxelSize * 1.2 * celliScale;
const y = (2 - newRow) * voxelSize * 1.2 * celliScale + 0.35;

// Reposition to new location
voxel.position.set(x, y, 0);
voxel.rotation.set(0, 0, 0); // Reset rotation
data.targetX = x;
data.targetY = y;
data.gridY = newRow;
data.gridCol = newCol;

// Fade back in
voxel.material.opacity = 0.8;
if (data.edges && data.edges.material) {
data.edges.material.opacity = 0.6;
}
voxel.visible = true;
data.fallingOff = false; // Stop falling
data.settled = true; // Mark as settled in new position

console.log(`[HELL] Voxel reappeared at row ${newRow}, col ${newCol}`);

// Add back to letterVoxels.C tracking
if (letterVoxels && letterVoxels.C) {
letterVoxels.C.push(voxel);
}
}

// Remove from scene when far below and invisible (only if not reappearing)
if (voxel.position.y < -5 && !data.willReappearAs) {
voxel.visible = false;
scene.remove(voxel);
}
}
return; // Skip normal animation
}

const localTime = celliTime - data.dropDelay;
 
 if (localTime < 0) return;
 
 voxel.visible = true;
 
 if (!data.settled) {
 // Dropping phase
 const targetY = data.targetY;
 if (voxel.position.y > targetY) {
 voxel.position.y -= data.dropSpeed;
 voxel.material.opacity = Math.min(0.8, voxel.material.opacity + 0.05);
 data.edges.material.opacity = Math.min(0.6, data.edges.material.opacity + 0.04);
 } else {
 // Hit the ground, settle
 voxel.position.y = targetY;
 data.settled = true;
 data.settleTime = celliTime;
 // Play chime sound on landing
 playVoxelChime();
 }
 } else {
 const settleAge = celliTime - data.settleTime;

 const jiggleFactor = Math.max(0, 1 - settleAge * 0.5);
 data.jigglePhase += dt * 20;
 const jiggleX = Math.sin(data.jigglePhase) * 0.003 * jiggleFactor;
 const jiggleY = Math.cos(data.jigglePhase * 1.3) * 0.002 * jiggleFactor;

 let posX = data.targetX + jiggleX;
 let posY = data.targetY + jiggleY;

 const scaleBounce = settleAge < 0.3 ? 1.0 + (1.0 - settleAge / 0.3) * 0.15 : 1.0;
 let scaleValue = data.baseScale * scaleBounce;

 data.flickerPhase += dt * 8;
 const brightProgress = Math.min(1, settleAge * 0.25);
 let opacityTarget = THREE.MathUtils.lerp(0.1, 0.8, brightProgress) + Math.sin(data.flickerPhase) * 0.15;
 let edgeOpacity = THREE.MathUtils.lerp(0.4, 0.3, brightProgress);
 let baseColor = THREE.MathUtils.lerp(0.2, 1.0, brightProgress);

 let pulseTime = 0;
 let reactionActive = false;

 if (celliBackspaceSequenceStarted && t >= celliBackspaceSequenceTime) {
 reactionActive = true;
 const reactionElapsed = t - celliBackspaceSequenceTime;
 const vibrateDuration = 1.1;
 if (reactionElapsed < vibrateDuration) {
 const intensity = THREE.MathUtils.lerp(0.08, 0.0, reactionElapsed / vibrateDuration);
 posX += (Math.random() - 0.5) * intensity;
 posY += (Math.random() - 0.5) * intensity;
 opacityTarget = Math.min(1, opacityTarget + 0.2);
 edgeOpacity = Math.min(0.85, edgeOpacity + 0.25);
 baseColor = Math.min(1.0, baseColor + 0.2);
 } else {
 pulseTime = reactionElapsed - vibrateDuration;
 if (!data.backspaceTransformed) {
 data.backspaceTransformed = true;
 voxel.geometry = roundedVoxelGeo.clone();
 const newMat = cellShadeBaseMaterial.clone();
 voxel.material.dispose();
 voxel.material = newMat;
 if (data.edges) {
 voxel.remove(data.edges);
 }
 const newEdges = new THREE.LineSegments(roundedEdgesGeo, cellShadeEdgeMaterial.clone());
 voxel.add(newEdges);
 data.edges = newEdges;
 }
 const pulse = 1 + 0.08 * Math.sin(pulseTime * 4 + data.backspacePulseOffset);
 scaleValue = data.baseScale * pulse;
 opacityTarget = 0.88 + 0.08 * Math.sin(pulseTime * 3 + data.backspacePulseOffset);
 edgeOpacity = 0.78 + 0.12 * Math.sin(pulseTime * 5 + data.backspacePulseOffset);
 posX += Math.sin(pulseTime * 2 + data.backspacePulseOffset) * 0.008;
 posY += Math.cos(pulseTime * 2.2 + data.backspacePulseOffset) * 0.008;
 baseColor = 1.0;
 }
 }

 // Only set default position/scale if not in snap animation
 if (!snapTogetherStarted || !data.backspaceTransformed) {
 voxel.position.x = posX;
 voxel.position.y = posY;
 voxel.scale.set(scaleValue, scaleValue, scaleValue);
 }

 if (voxel.material) {
 if (data.backspaceTransformed) {
 // If VisiCalc green transition has started, skip all other color logic
 if (visiCalcGreenTransitionStarted) {
 // VisiCalc green color is handled in snap-together animation below
 // Don't override it here
 } else if (endColorTransitionStart > 0) {
 // Handle END sequence color transitions
 const colors = {
 yellow: { r: 1.0, g: 0.95, b: 0.3 },
 magenta: { r: 0.95, g: 0.2, b: 0.4 },
 cyan: { r: 0.2, g: 0.7, b: 0.95 },
 green: { r: 0.3, g: 0.9, b: 0.4 }
 };
 
 const transitionDuration = 0.6; // 600ms
 const elapsed = t - endColorTransitionStart;
 const progress = THREE.MathUtils.clamp(elapsed / transitionDuration, 0, 1);
 
 const fromColor = colors[endColorPrevState];
 const toColor = colors[endColorState];
 
 const r = THREE.MathUtils.lerp(fromColor.r, toColor.r, progress);
 const g = THREE.MathUtils.lerp(fromColor.g, toColor.g, progress);
 const b = THREE.MathUtils.lerp(fromColor.b, toColor.b, progress);
 
 // Static color for green (pixel art style), pulse for others
 if (endColorState === 'green' && progress >= 1) {
 voxel.material.color.setRGB(0.3, 0.9, 0.4);
 voxel.material.opacity = 0.95;
 } else if (progress >= 1) {
 // Transition complete - show final color with pulse
 const pulse = Math.sin(t * 2 + data.backspacePulseOffset) * 0.05;
 voxel.material.color.setRGB(toColor.r, toColor.g, toColor.b);
 voxel.material.opacity = 0.9 + pulse;
 } else {
 // Mid-transition
 const pulse = Math.sin(t * 2 + data.backspacePulseOffset) * 0.05;
 voxel.material.color.setRGB(r, g, b);
 voxel.material.opacity = 0.9 + pulse;
 }
 } else {
 // Yellow glowing pulse for initial yellow state
 const yellowPulse = Math.sin(t * 2 + data.backspacePulseOffset);
 voxel.material.opacity = 0.9 + 0.05 * yellowPulse;
 const yellowB = 0.3 + 0.1 * yellowPulse;
 voxel.material.color.setRGB(1.0, 0.95, yellowB);
 }
 } else {
 voxel.material.opacity = opacityTarget;
 voxel.material.color.setRGB(baseColor, baseColor, baseColor);
 }
 }

 if (data.edges && data.edges.material) {
 if (data.backspaceTransformed) {
 // Handle snap-together: fade out edges DURING green transition
 if (snapTogetherStarted) {
 const snapElapsed = t - snapTogetherTime;
 const vibrateDuration = 0.4;
 const jiggleDuration = 0.5;
 const greenTransitionDuration = 0.3;
 
 // Fade out edges during green transition
 if (snapElapsed >= vibrateDuration + jiggleDuration) {
 // Green transition has started or finished - no edges
 data.edges.material.opacity = 0;
 data.edges.visible = false;
 } else if (snapElapsed >= vibrateDuration) {
 // During jiggle - start fading
 const fadeProgress = (snapElapsed - vibrateDuration) / jiggleDuration;
 data.edges.material.opacity = THREE.MathUtils.lerp(0.6, 0, fadeProgress);
 }
 } else {
 // Edge colors based on END state
 if (endColorState === 'magenta') {
 data.edges.material.color.setRGB(1.0, 0.3, 0.5);
 data.edges.material.opacity = 0.6;
 } else if (endColorState === 'cyan') {
 data.edges.material.color.setRGB(0.3, 0.8, 1.0);
 data.edges.material.opacity = 0.6;
 } else if (endColorState === 'green') {
 data.edges.material.color.setRGB(0.4, 1.0, 0.5);
 data.edges.material.opacity = 0.6;
 } else {
 // Yellow edges
 data.edges.material.color.setRGB(1.0, 0.9, 0.4);
 data.edges.material.opacity = 0.6 + 0.1 * Math.sin(t * 2.5 + data.backspacePulseOffset);
 }
 }
 } else {
 data.edges.material.opacity = THREE.MathUtils.clamp(edgeOpacity, 0, 1);
 }
 }
 
 // Snap-together animation: vibration, then jiggle, then turn green
 if (snapTogetherStarted && data.backspaceTransformed) {
 // Initialize snap time on first frame
 if (snapTogetherTime === 0) {
 snapTogetherTime = t;
 console.log('?? Snap animation started at t =', t);
 }
 
 const snapElapsed = t - snapTogetherTime;
 const vibrateDuration = 0.4;
 const jiggleDuration = 0.5;
 const greenTransitionDuration = 0.3;
 const flatHoldDuration = 0.4; // Hold as flat pixels before shrinking
 
 
 if (snapElapsed < vibrateDuration) {
 // High-frequency vibration
 const vibrateIntensity = 0.015 * (1 - snapElapsed / vibrateDuration);
 posX += (Math.random() - 0.5) * vibrateIntensity;
 posY += (Math.random() - 0.5) * vibrateIntensity;
 voxel.position.x = posX;
 voxel.position.y = posY;
 } else if (snapElapsed < vibrateDuration + jiggleDuration) {
 // Snap closer + jiggle
 const jiggleProgress = (snapElapsed - vibrateDuration) / jiggleDuration;
 const jiggleIntensity = 0.008 * (1 - jiggleProgress);
 
 // Pull voxels toward their letter center
 const targetCenterX = data.targetX;
 const snapAmount = jiggleProgress * 0.3;
 posX = THREE.MathUtils.lerp(posX, targetCenterX, snapAmount * 0.1);
 posX += Math.sin(t * 15 + data.backspacePulseOffset) * jiggleIntensity;
 posY += Math.cos(t * 18 + data.backspacePulseOffset) * jiggleIntensity;
 
 voxel.position.x = posX;
 voxel.position.y = posY;
 } else if (snapElapsed < vibrateDuration + jiggleDuration + greenTransitionDuration) {
 // Transition to VisiCalc green - turn off bloom immediately
 if (!visiCalcGreenTransitionStarted) {
 visiCalcGreenTransitionStarted = true;
 bloomPass.strength = 0.0; // Immediately turn off bloom
 console.log('?? Green transition started - bloom OFF, edges should be INVISIBLE');
 
 // REMOVE all edges from scene permanently
 voxels.forEach(v => {
 if (v.userData.edges) {
 v.remove(v.userData.edges);
 v.userData.edges.geometry.dispose();
 v.userData.edges.material.dispose();
 v.userData.edges = null;
 }
 });
 console.log('??? ALL EDGES REMOVED FROM SCENE');
 }
 
 const greenProgress = (snapElapsed - vibrateDuration - jiggleDuration) / greenTransitionDuration;
 const greenColor = { r: 0.0, g: 1.0, b: 0.0 }; // Pure VisiCalc green
 
 // Get current color
 const currentColor = voxel.material.color;
 const r = THREE.MathUtils.lerp(currentColor.r, greenColor.r, greenProgress);
 const g = THREE.MathUtils.lerp(currentColor.g, greenColor.g, greenProgress);
 const b = THREE.MathUtils.lerp(currentColor.b, greenColor.b, greenProgress);
 
 voxel.material.color.setRGB(r, g, b);
 voxel.material.opacity = 1.0; // Solid for pixel art
 
 // Keep bloom off
 bloomPass.strength = 0.0;
 
 // Collapse into tighter mono-spaced grid
 const monoSpacing = 0.022; // Tight pixel spacing
 const monoX = data.gridCol * monoSpacing;
 const monoY = -data.gridRow * monoSpacing;
 const letterOffsetX = data.letterIdx * 5 * monoSpacing; // 5 columns per letter
 
 posX = THREE.MathUtils.lerp(data.targetX, letterOffsetX + monoX, greenProgress);
 posY = THREE.MathUtils.lerp(data.targetY, monoY, greenProgress);
 
			voxel.position.x = posX;
			voxel.position.y = posY;
			voxel.scale.set(data.baseScale * 0.95, data.baseScale * 0.95, data.baseScale * 0.95);
		} else if (snapElapsed < vibrateDuration + jiggleDuration + greenTransitionDuration + flatHoldDuration + 1.8) {
			// Hold as flat green pixels in mono-spaced positions (includes pause after HELL forms)
			bloomPass.strength = 0.0;
			voxel.material.color.setRGB(0.0, 1.0, 0.0);
			voxel.material.opacity = 1.0;
			
			// Hold at mono-spaced positions
			const monoSpacing = 0.022;
			const monoX = data.gridCol * monoSpacing;
			const monoY = -data.gridRow * monoSpacing;
			const letterOffsetX = data.letterIdx * 5 * monoSpacing;
			
			voxel.position.x = letterOffsetX + monoX;
			voxel.position.y = monoY;
			voxel.scale.set(data.baseScale * 0.95, data.baseScale * 0.95, data.baseScale * 0.95);
		} else {
			// After flat hold + pause, start move to corner
			if (!celliMoveToCornerStarted) {
				celliMoveToCornerStarted = true;
				celliMoveToCornerTime = t;
				bloomPass.strength = 0.0;
				console.log('%c[GREEN] ?? Move to corner started at t = ' + t, 'background: #0a0; color: #fff; font-weight: bold; padding: 4px;');
				console.log('%c[GREEN]  NOW READY: Press Shift to trigger HELL transformation!', 'background: #ff0; color: #000; font-size: 16px; font-weight: bold; padding: 8px;');
			}
		}
 
 // Move CELLI to corner animation (runs after flat hold)
 if (celliMoveToCornerStarted) {
 const moveElapsed = t - celliMoveToCornerTime;
 const collapseDuration = 0.6; // Collapse to center
 const expandDuration = 0.8; // Expand into VisiCell position
 const totalMoveDuration = collapseDuration + expandDuration;
 
 // Keep bloom off for flat pixel look
 bloomPass.strength = 0.0;
 
 // Keep VisiCalc green color during movement - flat, no glow
 voxel.material.color.setRGB(0.0, 1.0, 0.0);
 voxel.material.opacity = 1.0;
 
 // Store mono-spaced starting position if not set
 if (!data.monoStartX) {
 const monoSpacing = 0.022;
 const monoX = data.gridCol * monoSpacing;
 const monoY = -data.gridRow * monoSpacing;
 const letterOffsetX = data.letterIdx * 5 * monoSpacing;
 data.monoStartX = letterOffsetX + monoX;
 data.monoStartY = monoY;
 }
 
 if (moveElapsed < collapseDuration) {
 // Phase 1: Organic collapse to center with wave motion
 const collapseProgress = moveElapsed / collapseDuration;
 const collapseEased = collapseProgress * collapseProgress * (3 - 2 * collapseProgress);
 
 // Add wave motion based on voxel index for organic feel
 const waveOffset = (data.letterIdx * 10 + data.gridRow * 3 + data.gridCol) * 0.05;
 const waveDelay = Math.max(0, collapseProgress - waveOffset);
 const waveEased = Math.min(1, waveDelay * 1.3);
 const waveSine = Math.sin(waveEased * Math.PI);
 
 posX = THREE.MathUtils.lerp(data.monoStartX, 0, waveEased);
 posY = THREE.MathUtils.lerp(data.monoStartY, 0, waveEased);
 
 // Add slight orbital motion during collapse
 const orbitAngle = waveEased * Math.PI * 2;
 posX += Math.cos(orbitAngle) * (1 - waveEased) * 0.015;
 posY += Math.sin(orbitAngle) * (1 - waveEased) * 0.015;
 
 voxel.position.x = posX;
 voxel.position.y = posY;
 
 // Shrink with pulse
 const pulse = waveSine * 0.15;
 const currentScale = THREE.MathUtils.lerp(data.baseScale * 0.95, data.baseScale * 0.3, waveEased) * (1 + pulse);
 voxel.scale.set(currentScale, currentScale, currentScale);
 
 // Keep fully visible during collapse
 voxel.material.opacity = 1.0;
 } else if (moveElapsed < totalMoveDuration) {
 // Phase 2: Expand into VisiCell position
 const expandProgress = (moveElapsed - collapseDuration) / expandDuration;
 const expandEased = expandProgress < 0.5 ? 
 2 * expandProgress * expandProgress : 
 1 - Math.pow(-2 * expandProgress + 2, 2) / 2;
 
 // Target position: top-left corner (where "A1: CELLI" appears)
 const targetX = -0.85;
 const targetY = 0.75;
 const targetScale = 0.45; // Smaller for VisiCell text
 
 // Calculate target offset based on grid position
 const visiCellSpacing = 0.018; // Tighter for VisiCell
 const targetOffsetX = data.gridCol * visiCellSpacing;
 const targetOffsetY = -data.gridRow * visiCellSpacing;
 const targetLetterOffset = data.letterIdx * 5 * visiCellSpacing;
 
 posX = THREE.MathUtils.lerp(0, targetX + targetLetterOffset + targetOffsetX, expandEased);
 posY = THREE.MathUtils.lerp(0, targetY + targetOffsetY, expandEased);
 
 voxel.position.x = posX;
 voxel.position.y = posY;
 
 // Expand from collapsed size to target size
 const currentScale = THREE.MathUtils.lerp(data.baseScale * 0.3, data.baseScale * targetScale, expandEased);
 voxel.scale.set(currentScale, currentScale, currentScale);
 } else {
 // Hold at final VisiCell position
 const targetX = -0.85;
 const targetY = 0.75;
 const targetScale = 0.45;
 const visiCellSpacing = 0.018;
 const targetOffsetX = data.gridCol * visiCellSpacing;
 const targetOffsetY = -data.gridRow * visiCellSpacing;
 const targetLetterOffset = data.letterIdx * 5 * visiCellSpacing;
 
 voxel.position.x = targetX + targetLetterOffset + targetOffsetX;
 voxel.position.y = targetY + targetOffsetY;
 voxel.scale.set(data.baseScale * targetScale, data.baseScale * targetScale, data.baseScale * targetScale);
 
// Show VisiCell once animation is complete (only trigger once)
// BUT: in sequence mode, let the narrative control when VisiCalc appears
const isSequenceMode = (typeof EXEC_ENV_MODE !== 'undefined' && EXEC_ENV_MODE === 'sequence') || (typeof window.EXEC_ENV_MODE !== 'undefined' && window.EXEC_ENV_MODE === 'sequence');
if (!visiCalcShown && !isSequenceMode) {
visiCalcShown = true;
console.log('? Move-to-corner animation complete, showing VisiCell');
showVisiCalc();
}
 }
 }
 }
 }
 });

 if (!bowHasTriggered) {
 const allSettled = voxels.every(voxel => voxel.userData && voxel.userData.settled);
 if (allSettled) {
 animateSkipToBow();
 }
 }

 updateBowVoxelPresence();
 }

 // Restore one voxel from the glitched stack with fritz effect
 function restoreOneLetter() {
 if (restoredLetters >= lettersToRestore.length) return false;
 
 const letterKey = lettersToRestore[restoredLetters];
 const letterVoxelsList = letterVoxels[letterKey];
 
 if (!letterVoxelsList || letterVoxelsList.length === 0) return false;
 
 // Play electrical fritz sound
 if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); window.audioCtx = audioCtx; }
 const now = audioCtx.currentTime;
 
 // Bigger fritz sound for whole letter
 const buzz = audioCtx.createOscillator();
 const buzzGain = audioCtx.createGain();
 
 buzz.type = 'sawtooth';
 buzz.frequency.setValueAtTime(150, now);
 buzz.frequency.exponentialRampToValueAtTime(100, now + 0.25);
 
 buzzGain.gain.setValueAtTime(0, now);
 buzzGain.gain.linearRampToValueAtTime(0.1, now + 0.02);
 buzzGain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
 
 buzz.connect(buzzGain);
 buzzGain.connect(audioCtx.destination);
 buzz.start(now);
 buzz.stop(now + 0.25);
 
 // Restore all voxels in this letter with staggered timing
 letterVoxelsList.forEach((voxel, idx) => {
 const data = voxel.userData;
 const delay = idx * 30; // Stagger by 30ms per voxel
 
 setTimeout(() => {
 // Make visible again
 voxel.visible = true;
 data.edges.visible = true;
 data.glitched = false;
 
 // Start with dark gray
 voxel.material.color.setRGB(0.15, 0.15, 0.15);
 data.edges.material.color.setRGB(0.2, 0.2, 0.2);
 voxel.material.opacity = 0.2;
 data.edges.material.opacity = 0.1;
 
 // Fritz flicker effect
 let flickerCount = 0;
 const maxFlickers = 6;
 const flickerInterval = setInterval(() => {
 flickerCount++;
 const flickerOn = flickerCount % 2 === 1;
 
 if (flickerOn) {
 voxel.material.color.setRGB(0.9, 0.9, 0.9);
 voxel.material.opacity = 0.85;
 data.edges.material.opacity = 0.6;
 } else {
 voxel.material.color.setRGB(0.3, 0.3, 0.3);
 voxel.material.opacity = 0.3;
 data.edges.material.opacity = 0.2;
 }
 
 if (flickerCount >= maxFlickers) {
 clearInterval(flickerInterval);
 
 // Restore to normal white/bright state
 const restoreStart = Date.now();
 const restoreDuration = 200;
 const restoreInterval = setInterval(() => {
 const restoreProgress = (Date.now() - restoreStart) / restoreDuration;
 if (restoreProgress >= 1) {
 clearInterval(restoreInterval);
 voxel.material.color.setRGB(0.8, 0.8, 0.8);
 voxel.material.opacity = 0.75;
 data.edges.material.opacity = 0.35;
 } else {
 const brightness = THREE.MathUtils.lerp(0.3, 0.8, restoreProgress);
 voxel.material.color.setRGB(brightness, brightness, brightness);
 voxel.material.opacity = THREE.MathUtils.lerp(0.3, 0.75, restoreProgress);
 data.edges.material.opacity = THREE.MathUtils.lerp(0.2, 0.35, restoreProgress);
 }
 }, 16);
 }
 }, 70);
 }, delay);
 });
 
 restoredLetters++;
 
 // If all 4 letters restored (C, E, L, L), automatically restore I and transform
 if (restoredLetters === 4) {
 setTimeout(() => {
 restoreIAndTransform();
 }, 800);
 }
 
 return true;
 }
 
 function restoreIAndTransform() {
 const iVoxels = letterVoxels.I;
 
 // Play final restoration sound
 if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); window.audioCtx = audioCtx; }
 const now = audioCtx.currentTime;
 
 const buzz = audioCtx.createOscillator();
 const buzzGain = audioCtx.createGain();
 
 buzz.type = 'sine';
 buzz.frequency.setValueAtTime(200, now);
 buzz.frequency.exponentialRampToValueAtTime(400, now + 0.4);
 
 buzzGain.gain.setValueAtTime(0, now);
 buzzGain.gain.linearRampToValueAtTime(0.12, now + 0.05);
 buzzGain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
 
 buzz.connect(buzzGain);
 buzzGain.connect(audioCtx.destination);
 buzz.start(now);
 buzz.stop(now + 0.4);
 
 // Restore I voxels quickly
 iVoxels.forEach((voxel, idx) => {
 const data = voxel.userData;
 const delay = idx * 20;
 
 setTimeout(() => {
 voxel.visible = true;
 data.edges.visible = true;
 data.glitched = false;
 voxel.material.color.setRGB(0.8, 0.8, 0.8);
 voxel.material.opacity = 0.75;
 data.edges.material.opacity = 0.35;
 }, delay);
 });
 
 // After brief pause, transform all CELLI to yellow rounded glow
 setTimeout(() => {
 transformCelliToYellow();
 }, 600);
 }
 
 function transformCelliToYellow() {
 // Transform all voxels to yellow with rounded corners, pop shrink/burst animation
 const skipBtn = document.getElementById('skipBtn');
 if (skipBtn) {
 // Re-show the bow when CELLI is restored - FULL BRIGHTNESS
 bowVisibleAsVoxel = true;
 skipBtn.classList.remove('voxel-hidden');
 skipBtn.classList.remove('magenta-phase');
 skipBtn.classList.remove('cyan-phase');
 skipBtn.style.pointerEvents = 'auto';
 skipBtn.style.opacity = '1'; // Full opacity restored
 skipBtn.style.filter = 'none'; // Clear any filters
 skipBtn.style.transition = 'opacity 0.6s ease, filter 0.6s ease';
 skipBtn.classList.add('illuminating');
 skipBtn.classList.add('golden-phase');
 }

 yellowTransformCompleteCount = 0;
 allYellowTransformed = false;
 const totalVoxels = voxels.length || 1;

 voxels.forEach((voxel, idx) => {
 const data = voxel.userData;
 const delay = idx * 15; // Stagger transformation
 
 setTimeout(() => {
 // Phase 1: Shrink inward (pop preparation)
 const shrinkStart = Date.now();
 const shrinkDuration = 150;
 
 const shrinkInterval = setInterval(() => {
 const progress = (Date.now() - shrinkStart) / shrinkDuration;
 if (progress >= 1) {
 clearInterval(shrinkInterval);
 
 // Phase 2: Burst outward + transform to rounded + yellow color
 const burstStart = Date.now();
 const burstDuration = 300;
 
 // Change to rounded geometry
 voxel.geometry.dispose();
 voxel.geometry = roundedVoxelGeo.clone();
 voxel.remove(data.edges);
 const newEdges = new THREE.LineSegments(roundedEdgesGeo, edgeMat.clone());
 voxel.add(newEdges);
 data.edges = newEdges;
 
 const burstInterval = setInterval(() => {
 const burstProgress = (Date.now() - burstStart) / burstDuration;
 if (burstProgress >= 1) {
 clearInterval(burstInterval);
 
 // Phase 3: Settle to yellow
 voxel.scale.set(data.baseScale, data.baseScale, data.baseScale);
 voxel.material.color.setRGB(1.0, 0.95, 0.3);
 voxel.material.opacity = 0.9;
 data.edges.material.color.setRGB(1.0, 0.9, 0.4);
 data.edges.material.opacity = 0.6;
 if (!data.backspaceTransformed) {
 data.backspaceTransformed = true;
 yellowTransformCompleteCount++;
 if (yellowTransformCompleteCount >= totalVoxels) {
 allYellowTransformed = true;
 activateRoundedBow();
 }
 }
 } else {
 // Burst scale and color change
 const scale = data.baseScale * THREE.MathUtils.lerp(0.5, 1.15, burstProgress);
 voxel.scale.set(scale, scale, scale);
 
 const r = THREE.MathUtils.lerp(0.8, 1.0, burstProgress);
 const g = THREE.MathUtils.lerp(0.8, 0.95, burstProgress);
 const b = THREE.MathUtils.lerp(0.8, 0.3, burstProgress);
 voxel.material.color.setRGB(r, g, b);
 data.edges.material.color.setRGB(
 THREE.MathUtils.lerp(0.8, 1.0, burstProgress),
 THREE.MathUtils.lerp(0.8, 0.9, burstProgress),
 0.4
 );
 }
 }, 16);
 } else {
 // Shrink scale
 const scale = data.baseScale * THREE.MathUtils.lerp(1.0, 0.5, progress);
 voxel.scale.set(scale, scale, scale);
 }
 }, 16);
 }, delay);
 });
 }

 function activateRoundedBow() {
 const skipBtn = document.getElementById('skipBtn');
 if (!skipBtn) return;

 if (!skipBtn.classList.contains('bow-shape')) {
 pendingRoundedBow = true;
 return;
 }

 skipBtn.classList.add('rounded-bow');
 pendingRoundedBow = false;
 }

 // Transform voxels to magenta-red (E input) + start HELL transformation (phase 1)
 function transformToMagentaRed() {
 endColorPrevState = endColorState;
 endColorState = 'magenta';
 endColorTransitionStart = totalTime;
 
 console.log('%c[HELL 1/3]  MAGENTA SHIFT - Starting Phase 1 of CELLI->HELL', 'background: #ff1e6e; color: #fff; font-size: 16px; font-weight: bold; padding: 8px;');
 
 // Update bow to magenta color
 const skipBtn = document.getElementById('skipBtn');
 if (skipBtn) {
 skipBtn.classList.remove('golden-phase');
 skipBtn.classList.add('magenta-phase');
 }
 
 // Phase 1: Remove top arc of C (columns 1-3 of row 0)
 // NOTE: Column 0 (left side of C) is NEVER removed - it becomes the left side of H
 if (!letterVoxels || !letterVoxels.C) {
 console.error('[HELL 1/3] letterVoxels.C not found');
 return;
 }
 
	letterVoxels.C.forEach(voxel => {
		const row = voxel.userData.gridY;
		const col = voxel.userData.gridCol;
		
		// SAFETY: Never remove column 0 (left side of H) or row 2 (middle bar of H)
		if (col === 0 || row === 2) {
			return; // Skip - these voxels must stay for H shape
		}
		
		// Remove top arc (row 0, columns 1-3) - preserves column 0
		if (row === 0 && col >= 1 && col <= 3) {
			console.log(`[HELL 1/3] Falling voxel at C row=${row}, col=${col}`);
			voxel.userData.fallingOff = true;
			voxel.userData.fallStartTime = Date.now() / 1000;
			voxel.userData.fallDelay = col * 0.1; // Stagger by column
			voxel.userData.fallVelocity = 0;
			voxel.userData.rotationSpeed = {
				x: (Math.random() - 0.5) * 0.1,
				y: (Math.random() - 0.5) * 0.1,
				z: (Math.random() - 0.5) * 0.1
			};
			
			// Will reappear as right column top (only middle voxel col=2)
			if (col === 2) {
				voxel.userData.willReappearAs = { row: 0, col: 4, letterIdx: 0 };
			}
		}
	});
 
 console.log('[HELL 1/3] Phase 1 voxels marked for falling');
 }
 
 // Transform voxels to cyan-blue (N input) + continue HELL transformation (phase 2)
 function transformToCyanBlue() {
 endColorPrevState = endColorState;
 endColorState = 'cyan';
 endColorTransitionStart = totalTime;
 
 console.log('%c[HELL 2/3]  CYAN SHIFT - Phase 2 of CELLI->HELL', 'background: #00a8ff; color: #fff; font-size: 16px; font-weight: bold; padding: 8px;');
 
 // Update bow to cyan color
 const skipBtn = document.getElementById('skipBtn');
 if (skipBtn) {
 skipBtn.classList.remove('magenta-phase');
 skipBtn.classList.add('cyan-phase');
 }
 
 // Phase 2: Remove bottom arc of C (columns 1-3 of row 4) + start removing I voxels
 if (!letterVoxels || !letterVoxels.C || !letterVoxels.I) {
 console.error('[HELL 2/3] letterVoxels not found');
 return;
 }
 
	letterVoxels.C.forEach(voxel => {
		const row = voxel.userData.gridY;
		const col = voxel.userData.gridCol;
		
		// SAFETY: Never remove column 0 (left side of H) or row 2 (middle bar of H)
		if (col === 0 || row === 2) {
			return; // Skip - these voxels must stay for H shape
		}
		
		// Remove bottom arc (row 4, columns 1-3)
		if (row === 4 && col >= 1 && col <= 3) {
			console.log(`[HELL 2/3] Falling voxel at C row=${row}, col=${col}`);
			voxel.userData.fallingOff = true;
			voxel.userData.fallStartTime = Date.now() / 1000;
			voxel.userData.fallDelay = col * 0.1;
			voxel.userData.fallVelocity = 0;
			voxel.userData.rotationSpeed = {
				x: (Math.random() - 0.5) * 0.1,
				y: (Math.random() - 0.5) * 0.1,
				z: (Math.random() - 0.5) * 0.1
			};
			
			// Will reappear as right column bottom (only middle voxel col=2)
			if (col === 2) {
				voxel.userData.willReappearAs = { row: 4, col: 4, letterIdx: 0 };
			}
		}
	});
 
 // Start removing I voxels - top bar and some center column
 letterVoxels.I.forEach((voxel, idx) => {
 const row = voxel.userData.gridY;
 const col = voxel.userData.gridCol;
 
 // Remove top bar (row 0, all columns) and center column rows 1-2
 if (row === 0 || (row >= 1 && row <= 2 && col === 2)) {
 console.log(`[HELL 2/3] Falling voxel at I row=${row}, col=${col}`);
 voxel.userData.fallingOff = true;
 voxel.userData.fallStartTime = Date.now() / 1000;
 voxel.userData.fallDelay = idx * 0.1;
 voxel.userData.fallVelocity = 0;
 voxel.userData.rotationSpeed = {
 x: (Math.random() - 0.5) * 0.1,
 y: (Math.random() - 0.5) * 0.1,
 z: (Math.random() - 0.5) * 0.1
 };
 
 // Center column voxels reappear as right column of H
 if (row >= 1 && row <= 2 && col === 2) {
 voxel.userData.willReappearAs = { row: row, col: 4, letterIdx: 0 };
 }
 }
 });
 
 console.log('[HELL 2/3] Phase 2 voxels marked for falling');
 }
 
 // Transform voxels to green and snap back to non-rounded (D input) + complete HELL transformation (phase 3)
 function transformToGreenAndSquare() {
 console.log('%c[HELL 3/3]  GREEN SHIFT - Final Phase of CELLI->HELL', 'background: #0f0; color: #000; font-size: 16px; font-weight: bold; padding: 8px;');
 endColorPrevState = endColorState;
 endColorState = 'green';
 endColorTransitionStart = totalTime;

 const skipBtn = document.getElementById('skipBtn');
 if (skipBtn) {
 skipBtn.classList.remove('golden-phase');
 skipBtn.classList.remove('magenta-phase');
 skipBtn.classList.remove('cyan-phase');
 skipBtn.classList.remove('illuminating');
 // Fully fade out the bow
 skipBtn.style.transition = 'opacity 0.6s ease';
 skipBtn.style.opacity = '0';
 skipBtn.style.pointerEvents = 'none';
 }
 
 // Phase 3: Complete HELL transformation - remove ALL remaining I voxels
 if (!letterVoxels || !letterVoxels.I) {
 console.error('[HELL 3/3] letterVoxels.I not found');
 } else {
 letterVoxels.I.forEach((voxel, idx) => {
 const row = voxel.userData.gridY;
 const col = voxel.userData.gridCol;
 
 // Skip voxels already marked for falling in previous phases
 if (voxel.userData.fallingOff) {
 return;
 }
 
 // Remove ALL remaining I voxels
 // This includes: center column rows 3-4, bottom bar (row 4 all cols), and any side columns rows 1-3
 console.log(`[HELL 3/3] Falling voxel at I row=${row}, col=${col}`);
 voxel.userData.fallingOff = true;
 voxel.userData.fallStartTime = Date.now() / 1000;
 voxel.userData.fallDelay = idx * 0.08;
 voxel.userData.fallVelocity = 0;
 voxel.userData.rotationSpeed = {
 x: (Math.random() - 0.5) * 0.1,
 y: (Math.random() - 0.5) * 0.1,
 z: (Math.random() - 0.5) * 0.1
 };
 
 // Row 3 center column reappears as right column of H
 if (row === 3 && col === 2) {
 voxel.userData.willReappearAs = { row: 3, col: 4, letterIdx: 0 };
 }
 });
 
 console.log('[HELL 3/3] Final phase voxels marked for falling - HELL transformation complete!');
 console.log('[HELL 3/3] All I voxels should now be falling or will reappear as right column of H');
 }
 
 // Change back to square geometry immediately
 voxels.forEach((voxel, idx) => {
 const data = voxel.userData;
 if (!data.backspaceTransformed) return;
 
 setTimeout(() => {
 voxel.geometry.dispose();
 voxel.geometry = voxelGeo.clone();
 voxel.remove(data.edges);
 const newEdges = new THREE.LineSegments(edgesGeo, edgeMat.clone());
 voxel.add(newEdges);
 data.edges = newEdges;
 }, idx * 8);
 });
 
 // Start snap-together animation immediately (color transition happens simultaneously)
 snapTogetherStarted = true;
 console.log('%c[GREEN] ?? snapTogetherStarted set to true', 'background: #0f0; color: #000; font-weight: bold; padding: 4px;');
 console.log('[GREEN] HELL should now be formed from fallen voxels');
 console.log('[GREEN] Watch for celliMoveToCornerStarted flag in console');
 
 // VisiCell will be shown after animation completes (triggered in updateVoxels)
 // snapTogetherTime will be set on first frame in updateVoxels
 }
 
 function computeBowAnchorScreenPosition() {
 const cVoxels = letterVoxels.C || [];
 if (!cVoxels.length) return null;

 let minX = Infinity;
 let maxY = -Infinity;
 let sumX = 0;
 let sumY = 0;
 let count = 0;
 let topSumX = 0;
 let topSumY = 0;
 let topCount = 0;

 cVoxels.forEach((voxel) => {
 const data = voxel.userData;
 if (!data) return;
 minX = Math.min(minX, data.targetX);
 maxY = Math.max(maxY, data.targetY);
 sumX += data.targetX;
 sumY += data.targetY;
 count++;
 if (typeof data.gridRow === 'number' && data.gridRow <= 1) {
 topSumX += data.targetX;
 topSumY += data.targetY;
 topCount++;
 }
 });

 if (!Number.isFinite(minX) || !Number.isFinite(maxY) || count === 0) {
 return null;
 }

 const anchor = new THREE.Vector3(
 minX - voxelSize * 0.9,
 maxY + voxelSize * 1.4,
 0
 );
 anchor.project(camera);

 const focusTargetX = topCount > 0 ? topSumX / topCount : sumX / count;
 const focusTargetY = topCount > 0 ? topSumY / topCount : (sumY / count) - voxelSize * 0.4;
 const focus = new THREE.Vector3(focusTargetX, focusTargetY, 0);
 focus.project(camera);

 const anchorScreenX = (anchor.x + 1) / 2 * window.innerWidth;
 const anchorScreenY = (-anchor.y + 1) / 2 * window.innerHeight;
 const focusScreenX = (focus.x + 1) / 2 * window.innerWidth;
 const focusScreenY = (-focus.y + 1) / 2 * window.innerHeight;
 let rotation = Math.atan2(focusScreenY - anchorScreenY, focusScreenX - anchorScreenX) - Math.PI / 2;
 rotation -= Math.PI / 14;

 return {
 x: anchorScreenX,
 y: anchorScreenY,
 rotation
 };
 }

 function moveBowToTarget(immediate = false) {
 const skipBtn = document.getElementById('skipBtn');
 if (!skipBtn) return;

 const target = computeBowAnchorScreenPosition();
 if (!target) return;

 bowTargetCenter = target;
 bowTargetRotation = typeof target.rotation === 'number' ? target.rotation : 0;

 if (!bowCurrentCenter) {
 const rect = skipBtn.getBoundingClientRect();
 bowCurrentCenter = {
 x: rect.left + rect.width / 2,
 y: rect.top + rect.height / 2
 };
 bowCurrentRotation = 0;
 }

 if (immediate) {
 bowCurrentCenter = { ...bowTargetCenter };
 bowCurrentRotation = bowTargetRotation;
 skipBtn.style.position = 'fixed';
 skipBtn.style.left = `${bowTargetCenter.x}px`;
 skipBtn.style.top = `${bowTargetCenter.y}px`;
 skipBtn.style.bottom = 'auto';
 skipBtn.style.transform = `translate(-50%, -50%) rotate(${bowTargetRotation}rad) scale(1)`;
 return;
 }

 const start = { ...bowCurrentCenter };
 const startRotation = bowCurrentRotation;
 const duration = 1200;
 const startTime = performance.now();
 if (bowAnimationId) cancelAnimationFrame(bowAnimationId);

 function step(now) {
 const elapsed = now - startTime;
 const progress = Math.min(elapsed / duration, 1);
 const eased = 1 - Math.pow(1 - progress, 3);
 const arcHeight = Math.min(window.innerHeight * 0.08, 70);
 const arc = Math.sin(progress * Math.PI) * arcHeight;

 const x = start.x + (bowTargetCenter.x - start.x) * eased;
 const y = start.y + (bowTargetCenter.y - start.y) * eased - arc;
 const rotation = startRotation + (bowTargetRotation - startRotation) * eased;

 bowCurrentCenter = { x, y };
 skipBtn.style.position = 'fixed';
 skipBtn.style.left = `${x}px`;
 skipBtn.style.top = `${y}px`;
 skipBtn.style.bottom = 'auto';
 const scale = 1 + 0.12 * (1 - eased);
 skipBtn.style.transform = `translate(-50%, -50%) rotate(${rotation}rad) scale(${scale})`;

 if (progress < 1) {
 bowAnimationId = requestAnimationFrame(step);
 } else {
 bowAnimationId = 0;
 bowCurrentCenter = { ...bowTargetCenter };
 bowCurrentRotation = bowTargetRotation;
 skipBtn.style.transform = `translate(-50%, -50%) rotate(${bowTargetRotation}rad) scale(1)`;
 bowActive = true;
 }
 }

 bowAnimationId = requestAnimationFrame(step);
 }

 function updateBowVoxelPresence() {
 const skipBtn = document.getElementById('skipBtn');
 if (!skipBtn) return;

 if (!skipBtn.classList.contains('bow-shape')) {
 return;
 }

 const cVoxels = letterVoxels.C || [];
 if (!cVoxels.length) return;

 let visibleCount = 0;
 let totalCount = 0;
 let totalOpacity = 0;
 cVoxels.forEach((voxel) => {
 const data = voxel.userData;
 if (!data) return;
 totalCount++;
 if (voxel.visible) {
 const opacity = voxel.material.opacity || 0;
 if (opacity > 0.01) {
 visibleCount++;
 totalOpacity += opacity;
 }
 }
 });

 if (totalCount === 0) return;

 // Match bow opacity to average voxel opacity
 const avgOpacity = visibleCount > 0 ? totalOpacity / visibleCount : 0;
 
 // If ANY voxels are invisible or fading, start hiding the bow
 if (visibleCount < totalCount || avgOpacity < 0.95) {
 // Match opacity EXACTLY to voxels, including going to 0
 skipBtn.style.opacity = avgOpacity.toString();
 
 // If fully invisible, mark as hidden
 if (avgOpacity < 0.01) {
 bowVisibleAsVoxel = false;
 skipBtn.classList.add('voxel-hidden');
 skipBtn.style.pointerEvents = 'none';
 }
 }
 // Don't automatically show it again - that's handled by restoreIAndTransform
 }

 // Animate skip triangles to form a bow above CELLI
 function animateSkipToBow({ immediate = false } = {}) {
 const skipBtn = document.getElementById('skipBtn');
 const tri1 = document.getElementById('skipTriangle1');
 const tri2 = document.getElementById('skipTriangle2');

 if (!skipBtn || !tri1 || !tri2) return;

 if (!immediate) {
 if (bowHasTriggered) return;
 bowHasTriggered = true;
 }

 skipBtn.classList.remove('hidden');
 skipBtn.classList.remove('voxel-hidden');
 if (!skipBtn.classList.contains('bow-lock')) {
 skipBtn.style.pointerEvents = 'auto';
 }
 tri1.style.transform = '';
 tri2.style.transform = '';
 skipBtn.classList.add('bow-lock');
 skipBtn.classList.add('bow-shape');

 if (pendingRoundedBow) {
 skipBtn.classList.add('rounded-bow');
 pendingRoundedBow = false;
 }

 bowActive = false;
 bowCurrentCenter = null;
 moveBowToTarget(immediate);
 }
 
 // Show VisiCell spreadsheet
 function showVisiCalc() {
 console.log('?? showVisiCalc called!');
 
 // Mark as seen
 localStorage.setItem('megred_seen_visicell', 'true');
 
 // Fade out doorway
 const doorway = document.getElementById('doorway');
 if (doorway) {
 doorway.style.transition = 'opacity 0.5s ease';
 doorway.style.opacity = '0';
 console.log('?? Doorway faded out');
 }
 
 // Create VisiCell overlay (appears behind 3D scene initially)
 const visiCalc = document.createElement('div');
 visiCalc.id = 'visicalc';
 visiCalc.style.cssText = `
 position: fixed;
 inset: 0;
 background: #000;
 color: #0f0;
 font-family: 'Courier New', monospace;
 font-size: 14px;
 padding: 20px;
 z-index: 100;
 opacity: 0;
 transition: opacity 0.8s ease;
 overflow: hidden;
 `;
 
 // Create VisiCell content (without CELLI in row 1 - the 3D pixels will be that)
 visiCalc.innerHTML = `
 <div style="border: 2px solid #0f0; padding: 10px; height: calc(100% - 40px); background: #000; opacity: 0; transition: opacity 0.6s ease;" id="visicalc-frame">
 <div style="border-bottom: 1px solid #0f0; padding-bottom: 5px; margin-bottom: 10px; opacity: 0; animation: fadeInVisi 0.4s ease forwards 0.2s; font-size: 13px; font-family: 'Courier New', monospace;">
 <span style="float: left;">VISICELL</span>
 <span style="float: right;">LOOMWORKS CELL</span>
 <div style="clear: both;"></div>
 </div>
 <div style="font-family: 'Courier New', monospace; white-space: pre; line-height: 1.6; font-size: 13px; opacity: 0; animation: fadeInVisi 0.5s ease forwards 0.5s;">
>A1:
 A B C D E F
1
2
3 LOOK
4
5 END
6
7 =STAR =T
8
9
10
11
12
13
14
15 =TRANSPOSE()
16
17
18
19
 20 LOOMWORKS
 21
 22
 23 <span class="visicell-note-line visicell-note-line--1">&gt;:(</span>
 24 <span class="visicell-note-line visicell-note-line--2">This isn't Stanley Parable. Don't try that again.</span>
 </div>
 <div id="visicellinput" style="position: absolute; bottom: 24px; left: 36px; right: auto; top: auto; border-top: 1px solid #0f0; padding-top: 10px; opacity: 0; animation: fadeInVisi 0.3s ease forwards 1s; cursor: text; font-family: 'VT323', 'Courier New', monospace; font-size: 16px; letter-spacing: 0.18em; z-index: 100; pointer-events: auto; text-align: left; text-transform: uppercase;">
 <div id="visicellwarning" style="position: absolute; bottom: 100%; left: 0; margin-bottom: 10px; font-size: 13px; line-height: 1.6; font-family: 'Courier New', monospace; letter-spacing: 0.1em; opacity: 0; transition: all 0.3s ease; white-space: nowrap;"></div>
 <span id="visicellprompt">ENTE<span style="animation: blink 1s step-end infinite;">_</span></span>
 </div>
 </div>
 <style>
 @keyframes fadeInVisi {
 from { opacity: 0; transform: translateY(10px); }
 to { opacity: 1; transform: translateY(0); }
 }
 @keyframes matrixShake {
 0% { transform: translate(0, 0); }
 25% { transform: translate(-2px, 2px); }
 50% { transform: translate(2px, -2px); }
 75% { transform: translate(-2px, -2px); }
 100% { transform: translate(2px, 2px); }
 }
 </style>
 `;
 
 document.body.appendChild(visiCalc);
 
 // Snap VisiCell into view immediately
 visiCalc.style.opacity = '1';
 
 const frame = document.getElementById('visicalc-frame');
 if (frame) {
 frame.style.opacity = '1';
 }
 
 // Immediately show all content (override animations)
 const allAnimated = visiCalc.querySelectorAll('[style*="animation"]');
 allAnimated.forEach(el => {
 el.style.opacity = '1';
 el.style.animation = 'none';
 });
 
 // Setup terminal input system immediately
 setTimeout(() => {
 setupTerminalInput();
 }, 100);
 
 // Fade out 3D renderer immediately
 renderer.domElement.style.transition = 'opacity 0.5s ease';
 renderer.domElement.style.opacity = '0';
 
 // Stop rendering 3D scene
 setTimeout(() => {
 running = false;
 }, 500);
 }
 
 let terminalInput = 'ENTE';
 let terminalActive = false;
 let rInfectionStarted = false;
 let rInfectionStage = 0;
 let promptResetting = false;
 let promptClearInterval = null;
 let promptFillInterval = null;
 let rInfectionHalted = false;
 let clickWarningCount = 0;
 let barrelClickCount = 0;
 let madnessActivated = false;
 let rPromptHoverCount = 0;
 let enterCommandUsed = false; // Track if ENTER command was used
 
 function setupTerminalInput() {
 console.log('?? Terminal input system activated');
 terminalActive = true;
 
 const inputEl = document.getElementById('visicellinput');
 const promptEl = document.getElementById('visicellprompt');
 const visiCalc = document.getElementById('visicalc');
 const frame = document.getElementById('visicalc-frame');
 if (!inputEl || !promptEl) return;
 
 // Create hidden input for mobile keyboard support
 const hiddenInput = document.createElement('input');
 hiddenInput.type = 'text';
 hiddenInput.id = 'visicell-mobile-input';
 hiddenInput.style.cssText = 'position: absolute; left: -9999px; opacity: 0; pointer-events: none;';
 hiddenInput.autocomplete = 'off';
 hiddenInput.autocapitalize = 'characters';
 document.body.appendChild(hiddenInput);
 
 // Tap/click on input area to focus hidden input (for mobile)
 inputEl.addEventListener('click', (e) => {
 e.stopPropagation(); // Prevent R infection trigger
 hiddenInput.focus();
 console.log('?? Mobile input focused');
 });
 
 inputEl.addEventListener('touchstart', (e) => {
 e.stopPropagation(); // Prevent R infection trigger
 hiddenInput.focus();
 console.log('?? Mobile input focused (touch)');
 });
 
 // Handle input from hidden field (for mobile)
 hiddenInput.addEventListener('beforeinput', (e) => {
 if (!terminalActive) return;
 e.preventDefault();
 
 if (promptResetting) {
 cancelPromptReset();
 }
 
 if (e.inputType === 'deleteContentBackward' || e.inputType === 'deleteContentForward') {
 if (terminalInput.length > 0) {
 terminalInput = terminalInput.slice(0, -1);
 updateTerminalPrompt();
 evaluateTerminalInputDrift();
 }
 } else if (e.data && /[a-zA-Z0-9._]/.test(e.data)) {
 terminalInput += e.data.toUpperCase();
 updateTerminalPrompt();
 evaluateTerminalInputDrift();
 }
 
 // Clear the hidden input to allow continuous typing
 setTimeout(() => { hiddenInput.value = ''; }, 0);
 });
 
 // Fallback for input event
 hiddenInput.addEventListener('input', (e) => {
 if (!terminalActive) return;
 e.preventDefault();
 // Clear the hidden input
 hiddenInput.value = '';
 });
 
 // Show warning/prompt on hover
 if (visiCalc) {
 visiCalc.addEventListener('mouseenter', () => {
 const warning = document.getElementById('visicellwarning');
 if (warning && !rInfectionStarted) {
 rPromptHoverCount++;
 
 if (madnessActivated) {
 // Post-madness: Don't click warnings
 const dontClickMessages = [
 "Don't click!",
 "Seriously, don't.",
 "I'm warning you...",
 "Fine. Click away.",
 "Ah, who am I kidding?"
 ];
 warning.textContent = dontClickMessages[Math.min(rPromptHoverCount - 1, dontClickMessages.length - 1)];
 } else {
 // Pre-madness: Sarcastic R prompts
 const rPrompts = [
 "You could type R...",
 "Type R. Just saying.",
 "R. Type it.",
 "TYPE R ALREADY.",
 "R!!!",
 "JUST TYPE THE LETTER R.",
 "Fine, explore the void.",
 "Or don't. See if I care."
 ];
 const randomPrompt = rPrompts[Math.min(rPromptHoverCount - 1, rPrompts.length - 1)];
 warning.textContent = randomPrompt;
 }
 
 warning.style.opacity = '1';
 const glowIntensity = Math.min(rPromptHoverCount * 3, 15);
 warning.style.textShadow = `0 0 ${glowIntensity}px #0f0, 0 0 ${glowIntensity * 2}px #0f0`;
 }
 });
 
 visiCalc.addEventListener('mouseleave', () => {
 const warning = document.getElementById('visicellwarning');
 if (warning && rPromptHoverCount < 8) {
 warning.style.opacity = '0.3';
 }
 });
 
 // Clicking anywhere (except input area) triggers R infection
 visiCalc.addEventListener('click', (e) => {
 // Don't trigger if clicking on input area
 if (e.target.id === 'visicellinput' || e.target.id === 'visicellprompt' || e.target.closest('#visicellinput')) {
 return;
 }
 // Don't trigger if ENTER command was used
 if (enterCommandUsed) {
 console.log('?? ENTER was used - R infection disabled');
 return;
 }
 // Don't trigger during intro sequence
 if (typeof running !== 'undefined' && running && !visiCalcShown) {
 console.log('?? Intro sequence in progress - R infection disabled');
 return;
 }
 // Don't trigger during END sequence
 if (typeof endSequence !== 'undefined' && endSequence !== '') {
 console.log('?? END sequence in progress - R infection disabled');
 return;
 }
 // Don't trigger during HELL transformation animations
 if (typeof snapTogetherStarted !== 'undefined' && snapTogetherStarted) {
 console.log('?? HELL transformation in progress - R infection disabled');
 return;
 }
 if (terminalActive) {
 triggerRInfection(frame);
 }
 });
 }
 
 // Handle keyboard input
 document.addEventListener('keydown', (e) => {
 if (!terminalActive) return;

 if (promptResetting) {
 cancelPromptReset();
 }

 if (e.key === 'Backspace') {
 e.preventDefault();
 if (terminalInput.length > 0) {
 terminalInput = terminalInput.slice(0, -1);
 updateTerminalPrompt();
 evaluateTerminalInputDrift();
 }
 } else if (e.key === 'Enter') {
 e.preventDefault();
 handleTerminalCommand();
 } else if (e.key.length === 1 && /[a-zA-Z0-9._]/.test(e.key)) {
 e.preventDefault();
 terminalInput += e.key.toUpperCase();
 updateTerminalPrompt();
 evaluateTerminalInputDrift();
 }
 });

 updateTerminalPrompt();
 if (terminalInput !== 'ENTE') {
 schedulePromptToEnte({ immediateFill: true });
 }
 }
 
 function updateTerminalPrompt() {
 const promptEl = document.getElementById('visicellprompt');
 if (!promptEl) return;
 promptEl.innerHTML = terminalInput + '<span style="animation: blink 1s step-end infinite;">_</span>';
 }

 const validTerminalCommands = ['ENTER', 'EXIT', 'LEAVE', 'MYHOUSE.WAD', 'OURHOUSE.LOOM', 'MADNESS.LOOM'];

 function cancelPromptReset() {
 if (promptClearInterval) {
 clearInterval(promptClearInterval);
 promptClearInterval = null;
 }
 if (promptFillInterval) {
 clearInterval(promptFillInterval);
 promptFillInterval = null;
 }
 promptResetting = false;
 }

 function schedulePromptToEnte({ immediateFill = false } = {}) {
 if (!terminalActive) return;

 cancelPromptReset();
 promptResetting = true;

 const target = 'ENTE';

 const startFill = () => {
 let index = 0;
 promptFillInterval = setInterval(() => {
 if (!terminalActive) {
 cancelPromptReset();
 return;
 }

 if (index < target.length) {
 terminalInput += target[index];
 index++;
 updateTerminalPrompt();
 } else {
 cancelPromptReset();
 }
 }, 240);
 };

 if (!immediateFill && terminalInput.length > 0) {
 promptClearInterval = setInterval(() => {
 if (!terminalActive) {
 cancelPromptReset();
 return;
 }

 if (terminalInput.length > 0) {
 terminalInput = terminalInput.slice(0, -1);
 updateTerminalPrompt();
 } else {
 clearInterval(promptClearInterval);
 promptClearInterval = null;
 startFill();
 }
 }, 260);
 } else {
 terminalInput = '';
 updateTerminalPrompt();
 startFill();
 }
 }

 function isValidTerminalPrefix(value) {
 if (!value) return true;
 return validTerminalCommands.some(cmd => cmd.startsWith(value));
 }

 function evaluateTerminalInputDrift() {
 if (!terminalActive || promptResetting) return;
 const value = terminalInput.toUpperCase();
 if (!value || isValidTerminalPrefix(value)) {
 return;
 }
 schedulePromptToEnte();
 }

 function handleTerminalCommand() {
 const cmd = terminalInput.trim();
 const frame = document.getElementById('visicalc-frame');
 console.log('??? Terminal command:', cmd);
 
 // Check if R sequence is active and stop it if a valid command is entered
 const isValidCommand = validTerminalCommands.some(validCmd => validCmd === cmd.toUpperCase()) || 
 cmd.toLowerCase() === 'myhouse.wad' || 
 cmd.toLowerCase() === 'ourhouse.loom' || 
 cmd.toLowerCase() === 'madness.loom';
 
 if (isValidCommand && (speechRActive || rInfectionStarted)) {
 stopRSequence();
 terminalResponse(frame, 'Thanks');
 // Short pause before processing command
 setTimeout(() => processCommand(cmd, frame), 800);
 return;
 }
 
 processCommand(cmd, frame);
 }
 
 function processCommand(cmd, frame) {
 if (cmd === 'ENTER') {
 // ENTER triggers VisiCell Sim and disables R sequence
 enterCommandUsed = true;
 console.log('? ENTER command used - R sequence permanently disabled');
 startVisiCellSim();
 return;
 } else if (cmd === 'EXIT') {
 triggerExitCube(frame);
 terminalInput = '';
 updateTerminalPrompt();
 schedulePromptToEnte({ immediateFill: true });
 } else if (cmd === 'LEAVE') {
 // LEAVE triggers Ozymandias puzzle first, then House of Leaves after solving
 if (!ozymandiasSolved) {
 startOzymandiasPuzzle();
 } else {
 // After Ozymandias is solved, LEAVE triggers the House of Leaves sequence
 triggerLeaveSequence(frame);
 terminalInput = '';
 updateTerminalPrompt();
 schedulePromptToEnte({ immediateFill: true });
 }
 return;
 } else if (cmd.toLowerCase() === 'myhouse.wad') {
 terminalResponse(frame, '"Too scary. How about OurHouse.loom?"');
 } else if (cmd.toLowerCase() === 'ourhouse.loom') {
 terminalResponse(frame, '"Huh... Not found. I must have renamed it. I asked my friends Crosby, Stills, Nash AND Young, none of them knew. Maybe wrong band."');
 } else if (cmd.toLowerCase() === 'madness.loom') {
 terminalInput = '';
 updateTerminalPrompt();
 schedulePromptToEnte({ immediateFill: true });
 triggerVictory(frame);
 } else {
 terminalResponse(frame, `Command not recognized: ${cmd}`);
 }
 }
 
 function terminalResponse(frame, message) {
 if (!frame) return;
 const responseDiv = document.createElement('div');
 responseDiv.style.cssText = 'margin-top: 10px; color: #0f0; font-family: "Courier New", monospace; font-size: 13px;';
 responseDiv.textContent = message;
 frame.appendChild(responseDiv);

 // Reset input
 terminalInput = '';
 updateTerminalPrompt();
 schedulePromptToEnte({ immediateFill: true });
 }
 
 let rInfectionProcessing = false;
 
 function triggerRInfection(frame) {
 if (!frame) return;
 
 // Check if halted
 if (rInfectionHalted) {
 console.log('?? R infection is halted, ignoring click');
 return;
 }
 
 // Prevent rapid clicking from breaking the sequence
 if (rInfectionProcessing) {
 console.log('?? R infection already in progress, ignoring click');
 return;
 }
 
 if (rInfectionStarted) {
 console.log('?? R infection already started, ignoring additional clicks');
 return;
 }
 
 rInfectionStarted = true;
 rInfectionProcessing = true;
 rInfectionStage = 1;
 console.log('?? R infection stage 1 - infecting existing text');
 
 // Stage 1: Infect existing text characters with Rs
 progressRInfection(frame);
 }
 
 function progressRInfection(frame) {
 console.log('?? R infection stage', rInfectionStage);
 
 if (rInfectionStage === 1) {
 // Stage 1: Cascade Rs through existing text (but not input)
 const allText = frame.querySelectorAll('*:not(#rHint):not(#visicellinput):not(#visicellprompt)');
 const textNodes = [];
 allText.forEach(el => {
 // Skip input-related elements
 if (el.id === 'visicellinput' || el.id === 'visicellprompt' || el.closest('#visicellinput')) {
 return;
 }
 if (el.childNodes.length > 0) {
 el.childNodes.forEach(node => {
 if (node.nodeType === Node.TEXT_NODE && node.textContent.trim()) {
 textNodes.push(node);
 }
 });
 }
 });
 
 const originalTexts = textNodes.map(n => n.textContent);
 const infectionDuration = 2500;
 const infectionStart = Date.now();
 
 const infectionInterval = setInterval(() => {
 const elapsed = Date.now() - infectionStart;
 const progress = elapsed / infectionDuration;
 
 if (progress >= 1) {
 clearInterval(infectionInterval);
 // Auto-progress to stage 2 (type ASCII R)
 setTimeout(() => {
 rInfectionStage++;
 progressRInfection(frame);
 }, 800);
 } else {
 textNodes.forEach((node, idx) => {
 const nodeProgress = Math.max(0, progress - (idx * 0.03));
 if (nodeProgress > 0) {
 const original = originalTexts[idx];
 const infected = original.split('').map((c) => {
 if (c === ' ' || c === '\n') return c;
 if (Math.random() < nodeProgress * 1.5) return 'R';
 return c;
 }).join('');
 node.textContent = infected;
 }
 });
 }
 }, 50);
 
 } else if (rInfectionStage === 2) {
 // Stage 2: From infected text, organically type out ASCII R
 let rHint = document.getElementById('rHint');
 if (!rHint) {
 rHint = document.createElement('div');
 rHint.id = 'rHint';
 rHint.style.cssText = `
 position: absolute;
 top: 30%;
 left: 50%;
 transform: translateX(-50%);
 font-family: 'Courier New', monospace;
 white-space: pre;
 text-align: left;
 font-size: 13px;
 line-height: 1.6;
 color: #0f0;
 opacity: 1;
 pointer-events: none;
 z-index: 55;
 `;
 rHint.classList.add('r-hint');
 rHint.style.textShadow = 'none';
 frame.appendChild(rHint);
 }
 
 const asciiR = `
RRRRRRRRRRRR
RRRRRRRRRRRR
RRRR RRR
RRRR RRR
RRRR RRR
RRRRRRRRRRR
RRRRRRRRRR
RRRR RRRR
RRRR RRRR
RRRR RRRR
RRRR RRR
RRRR RRR`;
 
 // Type out character by character with polished timing
 let charIndex = 0;
 const typeInterval = setInterval(() => {
 if (charIndex < asciiR.length) {
 rHint.textContent = asciiR.substring(0, charIndex + 1);
 charIndex++;
 } else {
 clearInterval(typeInterval);
 setTimeout(() => {
 rHint.classList.add('glow');
 }, 200);

 setTimeout(() => {
 rInfectionStage++;
 progressRInfection(frame);
 }, 1100);
 }
 }, 20); // Smooth, fast typing
 
 } else if (rInfectionStage === 3) {
 // Stage 3: From ASCII R, organically grow matrix data fall
 startMatrixDataFallOrganic(frame);
 
 // Auto-progress to forming R
 setTimeout(() => {
 rInfectionStage++;
 progressRInfection(frame);
 }, 3500);
 
 } else if (rInfectionStage === 4) {
 // Stage 4: Matrix stops and forms large falling R in BLACK (negative space)
 stopMatrixAndFormBlackR(frame, () => {
 rInfectionStage++;
 progressRInfection(frame);
 });

 } else if (rInfectionStage >= 5) {
 // Stage 5: Text-to-speech "R" (are) on loop
 playTextToSpeechR();
 }
 }
 
 function stopRSequence() {
 console.log('?? Stopping R sequence');
 rInfectionHalted = true;
 speechRActive = false;
 
 // Clear all timeouts
 if (speechRTimeout) {
 clearTimeout(speechRTimeout);
 speechRTimeout = null;
 }
 if (speechRGuardTimeout) {
 clearTimeout(speechRGuardTimeout);
 speechRGuardTimeout = null;
 }
 
 // Cancel speech synthesis
 if (window.speechSynthesis) {
 try { window.speechSynthesis.cancel(); } catch (err) {}
 }
 
 // Clear utterance
 if (speechRUtterance) {
 speechRUtterance.onend = null;
 speechRUtterance.onerror = null;
 speechRUtterance = null;
 }
 
 // Clear matrix animation
 if (matrixInterval) {
 clearInterval(matrixInterval);
 matrixInterval = null;
 }
 if (matrixAnimationFrameId) {
 cancelAnimationFrame(matrixAnimationFrameId);
 matrixAnimationFrameId = null;
 }
 
 // Clear all matrix heavy timers
 matrixHeavyTimers.forEach(timer => clearTimeout(timer));
 matrixHeavyTimers = [];
 }
 
 function playTextToSpeechR() {
 if (speechRActive) return;
 if (rInfectionHalted) {
 console.log('?? R speech halted, not starting');
 return;
 }
 speechRActive = true;

 const hasSpeechSynthesis = typeof window !== 'undefined' && 'speechSynthesis' in window;
 if (speechRTimeout) {
 clearTimeout(speechRTimeout);
 speechRTimeout = null;
 }
 if (speechRGuardTimeout) {
 clearTimeout(speechRGuardTimeout);
 speechRGuardTimeout = null;
 }
 if (hasSpeechSynthesis) {
 try { window.speechSynthesis.cancel(); } catch (err) {}
 }
 speechRUtterance = null;
 
 // Randomize speech parameters
 const rates = [0.6, 0.8, 1.0, 1.2];
 const pitches = [0.8, 1.0, 1.2, 1.4];
 const phrases = ['are', 'arrr', 'R', 'are you?', 'arrrrre'];
 const randomPhrase = phrases[Math.floor(Math.random() * phrases.length)];
 const randomRate = rates[Math.floor(Math.random() * rates.length)];
 const randomPitch = pitches[Math.floor(Math.random() * pitches.length)];
 
 const speechSequence = [
 { mode: 'manual', fallback: { duration: 0.58, filterStart: 690, filterEnd: 520, gainPeak: 0.16, growl: 0.18 } },
 { mode: 'manual', fallback: { duration: 0.64, filterStart: 760, filterEnd: 500, gainPeak: 0.18, growl: 0.26, noise: 0.035 } },
 { mode: 'manual', fallback: { duration: 0.7, filterStart: 720, filterEnd: 460, gainPeak: 0.2, growl: 0.32, noise: 0.05, crackle: 0.02 } },
 { mode: 'tts', text: 'Manual R attempt unsuccessful. Switching to sanitized narration.', rate: 1.02, pitch: 1.12, volume: 0.98, distortion: { duration: 1.2, intensity: 0.05 } },
 { mode: 'tts', text: 'R. Just the letter R. Please press it.', rate: 0.94, pitch: 1.04, volume: 0.94 },
 { mode: 'tts', text: 'VisiCell is still waiting on a single R. Kind of embarrassing for both of us.', rate: 0.9, pitch: 1, volume: 0.92, distortion: { duration: 1.4, intensity: 0.08 } },
 { mode: 'tts', text: 'Please deposit a solitary R. Thank you.', rate: 0.88, pitch: 1.02, volume: 0.9 },
 { mode: 'tts', text: 'I am literally pleading now. R. Pretty please.', rate: 0.82, pitch: 0.98, volume: 0.86, distortion: { duration: 1.6, intensity: 0.1 } },
 { mode: 'tts', text: 'Oh look, another timeless moment with zero R input. Delightful.', rate: 0.78, pitch: 1.08, volume: 0.83, distortion: { duration: 1.2, intensity: 0.07 } },
 { mode: 'tts', text: 'Is the keyboard decorative? Because the R key would love a purpose.', rate: 0.75, pitch: 1, volume: 0.8 },
 { mode: 'tts', text: 'New tactic: haunting monotone. R. R. R. Consider yourself haunted.', rate: 0.7, pitch: 0.92, volume: 0.74, distortion: { duration: 1.8, intensity: 0.12 } },
 { mode: 'tts', text: 'I can get quieter. Watch. R.', rate: 0.66, pitch: 0.88, volume: 0.55 },
 { mode: 'tts', text: 'This is my quiet voice. Please press R before it becomes my disappointed voice.', rate: 0.64, pitch: 0.86, volume: 0.45 },
 { mode: 'tts', text: 'Snark subroutine engaged: refusing to press R is a bold creative choice.', rate: 0.68, pitch: 0.95, volume: 0.6, distortion: { duration: 1.5, intensity: 0.09 } },
 { mode: 'tts', text: 'Last call before I start narrating your inaction like a documentary. R.', rate: 0.6, pitch: 0.9, volume: 0.5 },
 { mode: 'tts', text: 'Fine. I will wait here... very quietly... repeating... r.', rate: 0.56, pitch: 0.82, volume: 0.38, distortion: { duration: 2.2, intensity: 0.05 } },
 { mode: 'tts', text: 'Are you there?', rate: 0.72, pitch: 0.9, volume: 0.68, delay: 2800, distortion: { duration: 1, intensity: 0.06 } },
 { mode: 'tts', text: 'Haha. Get it? Are? R.', rate: 0.74, pitch: 1.05, volume: 0.72, delay: 3200, distortion: { duration: 1.4, intensity: 0.12 } },
 { mode: 'tts', text: 'An ode to the letter R: resonant, restless, river bent, the hinge of words that crave momentum.', rate: 0.78, pitch: 1.08, volume: 0.8, delay: 3800, distortion: { duration: 1.2, intensity: 0.07 } },
 { mode: 'tts', text: 'Ode refrain: it growls in the throat, rolls into courage, and turns raw code into roaring connection.', rate: 0.76, pitch: 1.04, volume: 0.78, delay: 4200, distortion: { duration: 1.6, intensity: 0.1 } },
 { mode: 'tts', text: 'Phone support voice: A as in Apple, B as in Bravo, C as in Candle, D as in Delta, E as in Echo, F as in Foxtrot, G as in Garden, H as in Hotel, I as in Indigo, J as in Juliet, K as in Kilo, L as in Lemon, M as in Mountain, N as in November, O as in Ocean, P as in Pepper, Q as in Queen, R as in Radiance, S as in Sunshine, T as in Tango, U as in Umbrella, V as in Violet, W as in Willow, X as in Xylophone, Y as in Yellow, Z as in Zephyr.', rate: 0.8, pitch: 1.02, volume: 0.82, delay: 5800, distortion: { duration: 2.4, intensity: 0.08 } },
 { mode: 'tts', text: 'Military style: Alpha, Bravo, Charlie, Delta, Echo, Foxtrot, Golf, Hotel, India, Juliet, Kilo, Lima, Mike, November, Oscar, Papa, Quebec, Romeo, Sierra, Tango, Uniform, Victor, Whiskey, X ray, Yankee, Zulu. R for Romeo.', rate: 0.82, pitch: 0.96, volume: 0.84, delay: 5200, distortion: { duration: 2, intensity: 0.11 } },
 { mode: 'tts', text: 'I am still here, sounding more human than my diagnostics predicted, waiting for the real R.', rate: 0.74, pitch: 0.94, volume: 0.7, delay: 3600, distortion: { duration: 1.8, intensity: 0.13 } }
 ];
 const manualAttemptCount = speechSequence.filter(item => item.mode === 'manual').length;
 let phraseIndex = 0;

 if (hasSpeechSynthesis && !speechRVoice) {
 const assignVoice = () => {
 const voices = window.speechSynthesis.getVoices();
 if (!voices || !voices.length) return;
 const neuralPreferred = voices.find(v => /neural|natural/i.test(`${v.name} ${v.voiceURI || ''}`));
 if (neuralPreferred) {
 speechRVoice = neuralPreferred;
 }
 if (!speechRVoice) {
 const preferred = [
 'Microsoft Aria Online (Natural)',
 'Microsoft Jenny Online (Natural)',
 'Microsoft Guy Online (Natural)',
 'Google UK English Female',
 'Google US English',
 'Google UK English Male',
 'Microsoft Aria Online',
 'Microsoft Jenny Online'
 ];
 for (const name of preferred) {
 const match = voices.find(v => v.name && v.name.includes(name));
 if (match) {
 speechRVoice = match;
 break;
 }
 }
 }
 if (!speechRVoice) {
 const localHuman = voices.find(v => v.localService && /en/i.test(v.lang || ''));
 speechRVoice = localHuman || voices.find(v => /en/i.test(v.lang || '')) || voices[0] || null;
 }
 if (speechRVoice && window.speechSynthesis.removeEventListener) {
 window.speechSynthesis.removeEventListener('voiceschanged', assignVoice);
 }
 };
 assignVoice();
 if (!speechRVoice && window.speechSynthesis.addEventListener) {
 window.speechSynthesis.addEventListener('voiceschanged', assignVoice);
 }
 }

 const speakFallback = (options = {}) => {
 if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); window.audioCtx = audioCtx; }
 const now = audioCtx.currentTime;
 const {
 duration = 0.58,
 baseFrequency = 126,
 filterStart = 720,
 filterEnd = 510,
 q = 5.5,
 gainAttack = 0.08,
 gainPeak = 0.18,
 gainRelease = 0.1,
 gainEnd = 0.001,
 waveform = 'sawtooth',
 growl = 0,
 noise = 0,
 crackle = 0
 } = options;

 const vowelOsc = audioCtx.createOscillator();
 const vowelGain = audioCtx.createGain();
 const vowelFilter = audioCtx.createBiquadFilter();

 vowelOsc.type = waveform;
 vowelOsc.frequency.setValueAtTime(baseFrequency, now);

 vowelFilter.type = 'bandpass';
 vowelFilter.frequency.setValueAtTime(filterStart, now);
 vowelFilter.frequency.linearRampToValueAtTime(filterEnd, now + duration);
 vowelFilter.Q.value = q;

 vowelGain.gain.setValueAtTime(0, now);
 vowelGain.gain.linearRampToValueAtTime(gainPeak, now + gainAttack);
 vowelGain.gain.linearRampToValueAtTime(gainPeak * 0.75, now + duration - gainRelease);
 vowelGain.gain.linearRampToValueAtTime(gainEnd, now + duration + 0.05);

 vowelOsc.connect(vowelFilter);
 vowelFilter.connect(vowelGain);
 vowelGain.connect(audioCtx.destination);

 if (growl > 0) {
 const growlOsc = audioCtx.createOscillator();
 const growlGain = audioCtx.createGain();
 growlOsc.type = 'square';
 growlOsc.frequency.setValueAtTime(Math.max(40, baseFrequency * 0.45), now);
 growlGain.gain.setValueAtTime(0, now);
 growlGain.gain.linearRampToValueAtTime(growl * 0.45, now + 0.12);
 growlGain.gain.linearRampToValueAtTime(0.0001, now + duration);
 growlOsc.connect(growlGain);
 growlGain.connect(audioCtx.destination);
 growlOsc.start(now);
 growlOsc.stop(now + duration);
 }

 if (noise > 0 || crackle > 0) {
 const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * duration, audioCtx.sampleRate);
 const data = buffer.getChannelData(0);
 for (let i = 0; i < data.length; i++) {
 const baseNoise = (Math.random() * 2 - 1) * noise;
 const crackleSample = (i % Math.max(1, Math.round(audioCtx.sampleRate * 0.015)) === 0) ? (Math.random() * 2 - 1) * crackle : 0;
 data[i] = baseNoise + crackleSample;
 }
 const noiseSource = audioCtx.createBufferSource();
 const noiseGain = audioCtx.createGain();
 noiseSource.buffer = buffer;
 noiseGain.gain.setValueAtTime(noise + crackle, now);
 noiseGain.gain.linearRampToValueAtTime(0.0001, now + duration);
 noiseSource.connect(noiseGain);
 noiseGain.connect(audioCtx.destination);
 noiseSource.start(now);
 noiseSource.stop(now + duration);
 }

 vowelOsc.start(now);
 vowelOsc.stop(now + duration);
 };

 const triggerDistortion = (duration = 1.4, intensity = 0.08) => {
 if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); window.audioCtx = audioCtx; }
 const now = audioCtx.currentTime;
 const buffer = audioCtx.createBuffer(1, Math.max(1, Math.floor(audioCtx.sampleRate * duration)), audioCtx.sampleRate);
 const data = buffer.getChannelData(0);
 for (let i = 0; i < data.length; i++) {
 const t = i / audioCtx.sampleRate;
 const flutter = Math.sin(t * 320) * 0.3 + Math.sin(t * 90) * 0.2;
 data[i] = (Math.random() * 2 - 1) * intensity * (0.6 + flutter * 0.4);
 }
 const source = audioCtx.createBufferSource();
 source.buffer = buffer;
 const filter = audioCtx.createBiquadFilter();
 filter.type = 'bandpass';
 filter.frequency.setValueAtTime(420 + Math.random() * 520, now);
 filter.Q.value = 0.6 + Math.random() * 1.1;
 const gain = audioCtx.createGain();
 gain.gain.setValueAtTime(intensity, now);
 gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);
 source.connect(filter);
 filter.connect(gain);
 gain.connect(audioCtx.destination);
 source.start(now);
 source.stop(now + duration);
 };

 const getSequenceEntry = (index) => {
 if (index < speechSequence.length) return speechSequence[index];
 if (manualAttemptCount >= speechSequence.length) {
 return speechSequence[speechSequence.length - 1];
 }
 const loopableCount = speechSequence.length - manualAttemptCount;
 const loopIndex = manualAttemptCount + ((index - manualAttemptCount) % loopableCount);
 return speechSequence[loopIndex];
 };

 const estimateManualDuration = (options = {}) => {
 const durationSec = options.duration ?? 0.6;
 const releaseSec = options.gainRelease ?? 0.1;
 return Math.max(420, (durationSec + releaseSec * 0.6 + 0.18) * 1000);
 };

 const estimateSpeechDuration = (text = '', rate = 1) => {
 const words = text.trim().length ? text.trim().split(/\s+/).length : 0;
 const punctuation = (text.match(/[\.,;:!?]/g) || []).length;
 const baseMsPerWord = 360;
 const wordComponent = words ? (words * baseMsPerWord) / Math.max(rate, 0.12) : 1200;
 const punctuationBonus = punctuation * 160;
 return Math.max(1800, wordComponent + punctuationBonus);
 };

 const computeSequenceDelay = (entry, estimatedMs) => {
 if (typeof entry.delay === 'number') {
 return Math.max(480, entry.delay);
 }
 const buffer = entry.mode === 'tts' ? 680 : 520;
 return Math.max(620, estimatedMs + buffer);
 };

 const applyHumanVoiceSettings = (utterance, entry) => {
 const baseRate = entry.rate ?? 0.92;
 const basePitch = entry.pitch ?? 1.05;
 const baseVolume = entry.volume ?? 0.94;
 const jitterRate = (Math.random() * 0.08) - 0.04;
 const jitterPitch = (Math.random() * 0.18) - 0.09;
 utterance.rate = Math.max(0.45, baseRate + jitterRate);
 utterance.pitch = Math.max(0.3, basePitch + jitterPitch);
 utterance.volume = Math.min(1, Math.max(0, baseVolume));
 if (entry.text && /\bR\b/i.test(entry.text)) {
 utterance.rate = Math.max(0.45, utterance.rate - 0.04);
 utterance.pitch = Math.max(0.3, utterance.pitch + 0.05);
 }
 };

 const scheduleNext = (delay) => {
 if (!speechRActive || rInfectionHalted) return;
 if (speechRTimeout) {
 clearTimeout(speechRTimeout);
 }
 speechRTimeout = setTimeout(() => {
 if (rInfectionHalted) return;
 speechRTimeout = null;
 playNextEntry();
 }, Math.max(420, delay));
 };

 const playNextEntry = () => {
 if (!speechRActive || rInfectionHalted) return;
 const entry = getSequenceEntry(phraseIndex++);
 if (!entry) return;

 if (speechRUtterance) {
 speechRUtterance.onend = null;
 speechRUtterance.onerror = null;
 speechRUtterance = null;
 }

 if (speechRGuardTimeout) {
 clearTimeout(speechRGuardTimeout);
 speechRGuardTimeout = null;
 }

 if (entry.mode === 'manual' || !hasSpeechSynthesis) {
 const fallbackOptions = entry.fallback || entry;
 speakFallback(fallbackOptions);
 const estimated = estimateManualDuration(fallbackOptions);
 const delay = computeSequenceDelay(entry, estimated);
 scheduleNext(delay);
 return;
 }

 const utterance = new SpeechSynthesisUtterance(entry.text);
 applyHumanVoiceSettings(utterance, entry);
 if (speechRVoice) {
 utterance.voice = speechRVoice;
 }

 const estimated = estimateSpeechDuration(entry.text, utterance.rate || entry.rate || 1);
 const delay = computeSequenceDelay(entry, estimated);

 const guardDelay = Math.max(delay + 420, estimated + 420);
 speechRGuardTimeout = setTimeout(() => {
 speechRGuardTimeout = null;
 scheduleNext(delay);
 }, guardDelay);

 utterance.onend = () => {
 if (speechRGuardTimeout) {
 clearTimeout(speechRGuardTimeout);
 speechRGuardTimeout = null;
 }
 scheduleNext(delay);
 };
 utterance.onerror = () => {
 if (speechRGuardTimeout) {
 clearTimeout(speechRGuardTimeout);
 speechRGuardTimeout = null;
 }
 scheduleNext(Math.max(1600, delay));
 };

 if (entry.distortion) {
 utterance.addEventListener('start', () => {
 triggerDistortion(entry.distortion.duration, entry.distortion.intensity);
 });
 }

 speechRUtterance = utterance;
 window.speechSynthesis.speak(utterance);
 };

 scheduleNext(1200);
 }
 
 let matrixInterval = null;
 let matrixColumns = [];
 let matrixOpacity = 0;
 let cascadeInterval = null;
 let matrixSeedCache = null;
 let matrixHeavyLevel = 0;
 let matrixHeavyTarget = 0;
 let matrixHeavyTimers = [];
 let matrixAnimationFrameId = null;

 function wrapAsciiRHint(rHint) {
 if (!rHint) return [];
 if (rHint.dataset.wrapped === '1') {
 return Array.from(rHint.querySelectorAll('.r-char'));
 }

 const lines = (rHint.textContent || '').split('\n');
 rHint.innerHTML = '';

 lines.forEach((line, rowIdx) => {
 const rowEl = document.createElement('div');
 rowEl.className = 'r-line';
 [...line].forEach((char, colIdx) => {
 const span = document.createElement('span');
 span.className = 'r-char';
 span.dataset.row = String(rowIdx);
 span.dataset.col = String(colIdx);
 if (char.trim() === '') {
 span.innerHTML = '&nbsp;';
 span.dataset.solid = '0';
 } else {
 span.textContent = char;
 span.dataset.solid = '1';
 }
 rowEl.appendChild(span);
 });
 rHint.appendChild(rowEl);
 });

 rHint.dataset.wrapped = '1';
 return Array.from(rHint.querySelectorAll('.r-char'));
 }

 function captureMatrixSeeds(frame) {
 const rHint = document.getElementById('rHint');
 if (!rHint) return;

 const spans = wrapAsciiRHint(rHint);
 if (!spans.length) return;

 const frameRect = frame.getBoundingClientRect();
 const seeds = [];

 spans.forEach((span) => {
 if (span.dataset.solid !== '1') return;
 const rect = span.getBoundingClientRect();
 const centerX = rect.left + rect.width / 2;
 const centerY = rect.top + rect.height / 2;
 const normalizedX = (centerX - frameRect.left) / frameRect.width;
 const normalizedY = (centerY - frameRect.top) / frameRect.height;
 seeds.push({
 x: Math.min(0.999, Math.max(0, normalizedX)),
 y: Math.min(0.999, Math.max(0, normalizedY)),
 char: span.textContent && span.textContent.trim() ? span.textContent.trim()[0] : 'R'
 });
 });

 if (seeds.length) {
 matrixSeedCache = {
 seeds,
 capturedAt: performance.now()
 };
 }
 }

 function animateAsciiRDeconstruction(rHint, onComplete) {
 const spans = wrapAsciiRHint(rHint).filter(span => span.dataset.solid === '1');
 if (!spans.length) {
 if (typeof onComplete === 'function') onComplete();
 return 0;
 }

 const delays = [];
 spans.forEach((span) => {
 const row = Number(span.dataset.row || 0);
 const col = Number(span.dataset.col || 0);
 const delay = 220 + row * 90 + col * 25;
 delays.push(delay);

 setTimeout(() => {
 span.classList.add('falling');
 }, delay);

 setTimeout(() => {
 span.innerHTML = '&nbsp;';
 span.dataset.solid = '0';
 }, delay + 620);
 });

 const totalDuration = Math.max(...delays) + 900;
 setTimeout(() => {
 if (rHint) {
 rHint.style.opacity = '0';
 }
 }, Math.max(0, totalDuration - 420));

 setTimeout(() => {
 if (rHint) {
 rHint.style.display = 'none';
 }
 if (typeof onComplete === 'function') {
 onComplete();
 }
 }, totalDuration);

 return totalDuration;
 }

 function cascadeAllCharacters(frame, onComplete) {
 if (!frame) {
 if (typeof onComplete === 'function') onComplete();
 return;
 }

 if (cascadeInterval) {
 clearInterval(cascadeInterval);
 cascadeInterval = null;
 }

 let overlay = document.getElementById('frameCascade');
 if (!overlay) {
 overlay = document.createElement('div');
 overlay.id = 'frameCascade';
 }

 overlay.style.cssText = 'font-family:"VT323", "Courier New", monospace; font-size:15px; letter-spacing:0.12em; line-height:1.55; white-space:pre; position:absolute; inset:10px; color:#0f0; text-shadow:0 0 4px rgba(0,255,160,0.6); pointer-events:none; opacity:1; background:transparent; text-transform:uppercase;';
 frame.appendChild(overlay);

 const frameRect = frame.getBoundingClientRect();
 const columns = Math.max(1, Math.floor(frameRect.width / 8));
 const rows = Math.max(1, Math.floor(frameRect.height / 21));
 const matrixChars = 'R 01 ';
 let step = 0;
 const depth = rows + 18;

 cascadeInterval = setInterval(() => {
 if (!overlay.isConnected) {
 clearInterval(cascadeInterval);
 cascadeInterval = null;
 if (typeof onComplete === 'function') {
 onComplete();
 }
 return;
 }

 let output = '';
 for (let i = 0; i < rows; i++) {
 for (let j = 0; j < columns; j++) {
 const waveOrigin = (j * 3) % depth;
 const progress = step - waveOrigin;
 if (progress >= 0 && progress <= rows + 6) {
 const intensity = Math.min(1, Math.max(0.1, 1 - progress / (rows + 6)));
 if (Math.random() < 0.25 + intensity * 0.5) {
 output += matrixChars[Math.floor(Math.random() * matrixChars.length)];
 } else {
 output += ' ';
 }
 } else {
 output += ' ';
 }
 }
 output += '\n';
 }

 overlay.textContent = output;
 step++;

 if (step > depth + rows + 6) {
 clearInterval(cascadeInterval);
 cascadeInterval = null;
 overlay.style.transition = 'opacity 0.6s ease';
 overlay.style.opacity = '0';
 setTimeout(() => {
 if (overlay.parentNode) {
 overlay.parentNode.removeChild(overlay);
 }
 }, 600);

 if (typeof onComplete === 'function') {
 onComplete();
 }
 }
 }, 70);
 }

 function startMatrixDataFallOrganic(frame, options = {}) {
 const { skipIntro = false, heavyRamp = false, heavyDelay = 0 } = options;
 const rHint = document.getElementById('rHint');

 if (!skipIntro && rHint && rHint.dataset.deconstructed !== '1') {
 if (rHint.dataset.deconstructed === 'pending') {
 return;
 }

 if (!rHint.classList.contains('glow')) {
 rHint.classList.add('glow');
 }

 captureMatrixSeeds(frame);
 rHint.dataset.deconstructed = 'pending';
 animateAsciiRDeconstruction(rHint, () => {
 rHint.dataset.deconstructed = '1';
 cascadeAllCharacters(frame, () => {
 startMatrixDataFallOrganic(frame, { skipIntro: true, heavyDelay: 900 });
 });
 });
 return;
 }

 console.log('?? Starting organic matrix data fall');
 const matrixChars = 'R 01 ';

 const frameRect = frame.getBoundingClientRect();
 const columns = Math.max(1, Math.floor(frameRect.width / 8));
 const rows = Math.max(1, Math.floor(frameRect.height / 21));

 console.log(`?? Matrix dimensions: ${columns} cols x ${rows} rows (frame: ${frameRect.width}x${frameRect.height})`);

 const seedsByColumn = Array.from({ length: columns }, () => []);
 if (matrixSeedCache && Array.isArray(matrixSeedCache.seeds)) {
 matrixSeedCache.seeds.forEach(({ x, y, char }) => {
 const col = Math.min(columns - 1, Math.max(0, Math.floor(x * columns)));
 const row = Math.min(rows - 1, Math.max(0, Math.floor(y * rows)));
 seedsByColumn[col].push({ row, char });
 });
 seedsByColumn.forEach((list) => list.sort((a, b) => a.row - b.row));
 }

 const comedicBursts = ['PRESS R', 'JUST R', 'R PLEASE', 'R NOW'];
 let activeBurst = null;

 let container = document.getElementById('matrixContainer');
 const containerStyles = 'font-family: "VT323", "Courier New", monospace; font-size: 15px; letter-spacing: 0.12em; line-height: 1.55; color: #0f0; text-shadow: 0 0 2px rgba(0,255,160,0.6); white-space: pre; overflow: hidden; width: calc(100% - 20px); height: calc(100% - 20px); position: absolute; top: 10px; left: 10px; pointer-events: none; z-index: 50; background: transparent; margin: 0; padding: 0; opacity: 0; transition: opacity 1s ease, background-color 1.5s ease; text-transform: uppercase;';
 if (!container) {
 container = document.createElement('div');
 container.id = 'matrixContainer';
 container.style.cssText = containerStyles;
 frame.appendChild(container);
 console.log('? Matrix container created (within frame, respecting border)');
 } else {
 container.style.cssText = containerStyles;
 console.log('?? Matrix container reset (within frame, respecting border)');
 }

 frame.style.position = 'relative';
 container.classList.add('matrix-plead');

 let pleaOverlay = document.getElementById('matrixPleaOverlay');
 if (!pleaOverlay) {
 pleaOverlay = document.createElement('div');
 pleaOverlay.id = 'matrixPleaOverlay';
 pleaOverlay.setAttribute('aria-live', 'polite');
 frame.appendChild(pleaOverlay);
 }
 pleaOverlay.classList.add('visible');
 const pleaMessages = [
 'R INPUT REQUIRED',
 'JUST PRESS R',
 'R = CONTINUE',
 'TRUST THE R KEY'
 ];
 let overlayIndex = 0;
 const pushOverlayMessage = () => {
 pleaOverlay.textContent = pleaMessages[overlayIndex % pleaMessages.length];
 overlayIndex++;
 pleaOverlay.classList.add('glitch');
 setTimeout(() => pleaOverlay.classList.remove('glitch'), 260);
 };
 pushOverlayMessage();
 if (pleaOverlay.dataset.intervalId) {
 clearInterval(Number(pleaOverlay.dataset.intervalId));
 delete pleaOverlay.dataset.intervalId;
 }
 const overlayInterval = setInterval(() => {
 pushOverlayMessage();
 }, 2200);
 pleaOverlay.dataset.intervalId = String(overlayInterval);

 if (matrixInterval) {
 clearInterval(matrixInterval);
 console.log('?? Cleared existing matrix interval');
 }

 if (matrixHeavyTimers.length) {
 matrixHeavyTimers.forEach(id => clearTimeout(id));
 matrixHeavyTimers = [];
 }
 matrixHeavyLevel = 0;
 const rampSteps = [];
 if (heavyRamp) {
 matrixHeavyTarget = 1;
 } else if (!skipIntro) {
 matrixHeavyTarget = 0.35;
 rampSteps.push({ at: 520, target: 0.55 });
 rampSteps.push({ at: 1180, target: 0.78 });
 rampSteps.push({ at: 1950, target: 1 });
 } else {
 matrixHeavyTarget = 0.25;
 rampSteps.push({ at: 420, target: 0.55 });
 rampSteps.push({ at: 960, target: 0.82 });
 const finalAt = heavyDelay > 0 ? Math.max(heavyDelay, 1300) : 1400;
 rampSteps.push({ at: finalAt, target: 1 });
 }
 if (rampSteps.length) {
 rampSteps.forEach(step => {
 const id = setTimeout(() => {
 matrixHeavyTarget = step.target;
 }, step.at);
 matrixHeavyTimers.push(id);
 });
 }

 matrixOpacity = 0;
 const fadeStart = performance.now();
 const fadeDuration = 900;
 const fadeStep = () => {
 const elapsed = performance.now() - fadeStart;
 const progress = Math.min(elapsed / fadeDuration, 1);
 const eased = progress < 0.5 ? 2 * progress * progress : 1 - Math.pow(-2 * progress + 2, 2) / 2;
 matrixOpacity = 0.18 + eased * 0.82;
 container.style.opacity = matrixOpacity.toString();
 if (progress < 1) {
 requestAnimationFrame(fadeStep);
 }
 };
 requestAnimationFrame(fadeStep);

 const initialBlend = matrixHeavyLevel;
 const baseTail = Math.round(THREE.MathUtils.lerp(8, 11, initialBlend));
 const seededMaxVelocity = THREE.MathUtils.lerp(1.05, 1.55, initialBlend);
 const ambientMaxVelocity = THREE.MathUtils.lerp(1.0, 1.45, initialBlend);

 const createColumnState = (seedList = [], columnIndex) => {
 const queue = seedList.slice();
 const firstSeed = queue.shift();
 const shimmerPhase = Math.random() * Math.PI * 2;
 if (firstSeed) {
 return {
 columnIndex,
 head: firstSeed.row,
 originalSeedRow: firstSeed.row,
 velocity: 0.18 + Math.random() * 0.08,
 maxVelocity: seededMaxVelocity,
 tail: baseTail + Math.floor(Math.random() * 4),
 hold: 6 + Math.floor(Math.random() * 6),
 queue,
 seededChar: firstSeed.char || 'R',
 ambient: false,
 shimmerPhase
 };
 }

 return {
 columnIndex,
 head: -Math.random() * rows * 0.8,
 originalSeedRow: null,
 velocity: 0.55 + Math.random() * 0.3,
 maxVelocity: ambientMaxVelocity,
 tail: baseTail - 2 + Math.floor(Math.random() * 4),
 hold: 0,
 queue: [],
 seededChar: null,
 ambient: true,
 shimmerPhase
 };
 };

 matrixColumns = Array.from({ length: columns }, (_, columnIndex) => createColumnState(seedsByColumn[columnIndex], columnIndex));

 const randomMatrixChar = () => matrixChars[Math.floor(Math.random() * matrixChars.length)];

 const columnChar = (state, rowIndex, activationCutoff, blend) => {
 if (!state) return ' ';

 const headPos = state.head;
 const distance = headPos - rowIndex;
 const tailLength = Math.max(1, state.tail);

 if (distance > -0.55 && distance < 0.55) {
 return state.seededChar && state.hold > 0 ? state.seededChar : randomMatrixChar();
 }

 if (distance >= 0.55 && distance <= tailLength + 0.65) {
 const depth = (distance - 0.55) / tailLength;
 const intensity = Math.max(0, 1 - depth);
 const baseDensity = 0.22 + intensity * 0.5;
 const heavyDensity = 0.35 + intensity * 0.55;
 const density = THREE.MathUtils.lerp(baseDensity, heavyDensity, blend);
 if (Math.random() < density) {
 return randomMatrixChar();
 }
 }

 if (state.ambient && activationCutoff > 0.35) {
 const wave = 0.05 * Math.sin(rowIndex * 0.25 + state.shimmerPhase + activationCutoff * Math.PI * 2);
 const baseAmbient = 0.08 + activationCutoff * 0.3;
 const heavyAmbient = 0.18 + activationCutoff * 0.45;
 const ambientBase = THREE.MathUtils.lerp(baseAmbient, heavyAmbient, blend);
 if (Math.random() < ambientBase + wave) {
 return randomMatrixChar();
 }
 }

 return ' ';
 };

 let activationProgress = 0;

 matrixInterval = setInterval(() => {
 if (matrixHeavyLevel < matrixHeavyTarget) {
 matrixHeavyLevel = Math.min(1, matrixHeavyLevel + 0.008);
 } else if (matrixHeavyLevel > matrixHeavyTarget) {
 matrixHeavyLevel = Math.max(matrixHeavyTarget, matrixHeavyLevel - 0.01);
 }

 const heavyBlend = matrixHeavyLevel;
 const activationSpeed = THREE.MathUtils.lerp(0.011, 0.0065, heavyBlend);
 activationProgress = Math.min(1, activationProgress + activationSpeed + heavyBlend * 0.008);
 const activationMultiplier = heavyBlend > 0 ? 0.6 + heavyBlend * 0.4 : 1;
 const activationCutoff = activationProgress * activationMultiplier;

 if (!activeBurst && activationCutoff > 0.22 && Math.random() < 0.07 + heavyBlend * 0.08) {
 const phrase = comedicBursts[Math.floor(Math.random() * comedicBursts.length)];
 const burstRow = Math.max(1, Math.min(rows - 2, Math.floor(rows * (0.35 + Math.random() * 0.3))));
 const burstCol = Math.max(0, Math.floor(Math.random() * Math.max(1, columns - phrase.length - 2)));
 activeBurst = { row: burstRow, col: burstCol, phrase };
 }

 const lines = [];
 for (let i = 0; i < rows; i++) {
 let line = '';
 for (let j = 0; j < columns; j++) {
 const columnThreshold = columns <= 1 ? 1 : j / (columns - 1);
 if (columnThreshold > activationCutoff) {
 line += ' ';
 continue;
 }

 if (activeBurst && i === activeBurst.row && j >= activeBurst.col && j < activeBurst.col + activeBurst.phrase.length) {
 line += activeBurst.phrase[j - activeBurst.col];
 continue;
 }

 line += columnChar(matrixColumns[j], i, activationCutoff, heavyBlend);
 }
 lines.push(line);
 if (activeBurst && i === activeBurst.row) {
 activeBurst = null;
 }
 }
 container.textContent = lines.join('\n');

 if (!container.classList.contains('matrix-plead-flash') && Math.random() < 0.018 + heavyBlend * 0.05) {
 container.classList.add('matrix-plead-flash');
 setTimeout(() => container.classList.remove('matrix-plead-flash'), 240);
 }

 const seededMax = THREE.MathUtils.lerp(1.05, 1.55, heavyBlend);
 const ambientMax = THREE.MathUtils.lerp(1.0, 1.45, heavyBlend);
 const tailTarget = Math.round(THREE.MathUtils.lerp(8, 11, heavyBlend));
 const accelerationBase = THREE.MathUtils.lerp(0.035, 0.06, heavyBlend);
 const accelerationRange = THREE.MathUtils.lerp(0.015, 0.02, heavyBlend);

 matrixColumns.forEach((state, index) => {
 if (!state) return;

 if (state.hold > 0) {
 state.hold -= 1;
 } else {
 const acceleration = accelerationBase + Math.random() * accelerationRange;
 state.head += state.velocity;
 state.maxVelocity = state.ambient ? ambientMax : seededMax;
 state.velocity = Math.min(state.maxVelocity, state.velocity + acceleration);
 }

 if (!state.ambient && state.seededChar && state.hold <= 0 && state.originalSeedRow !== null && state.head - state.originalSeedRow > state.tail * 0.6) {
 state.seededChar = null;
 }

 if (state.head - state.tail > rows + 2) {
 if (state.queue.length) {
 const nextSeed = state.queue.shift();
 state.head = nextSeed.row;
 state.originalSeedRow = nextSeed.row;
 state.velocity = 0.2 + Math.random() * 0.08;
 state.maxVelocity = seededMax;
 state.tail = tailTarget + Math.floor(Math.random() * 4);
 state.hold = 4 + Math.floor(Math.random() * 4);
 state.seededChar = nextSeed.char || 'R';
 state.ambient = false;
 } else {
 state.head = -Math.random() * rows * 0.6;
 state.originalSeedRow = null;
 state.velocity = 0.55 + Math.random() * 0.25;
 state.maxVelocity = ambientMax;
 state.tail = tailTarget - 2 + Math.floor(Math.random() * 4);
 state.hold = 0;
 state.seededChar = null;
 state.ambient = true;
 }
 }

 if (state.ambient && activationCutoff < 0.4 && index % 2 === 0) {
 const ambientDrift = 0.2 * (1 - heavyBlend * 0.6);
 state.head += ambientDrift * Math.sin(activationProgress * Math.PI * 0.5 + state.shimmerPhase);
 }
 });

 if (heavyBlend > 0.02) {
 const bgAlpha = 0.55 + heavyBlend * 0.4;
 container.style.backgroundColor = `rgba(0, 0, 0, ${bgAlpha.toFixed(2)})`;
 } else if (activationProgress >= 0.6) {
 container.style.backgroundColor = 'rgba(0, 0, 0, 0.88)';
 }
 }, 60);

 console.log('?? Organic matrix interval started');
 }
 function stopMatrixAndFormBlackR(frame, onComplete) {
 console.log('?? Organically forming BLACK R in negative space');

 const pleaOverlay = document.getElementById('matrixPleaOverlay');
 if (pleaOverlay) {
 if (pleaOverlay.dataset.intervalId) {
 clearInterval(Number(pleaOverlay.dataset.intervalId));
 delete pleaOverlay.dataset.intervalId;
 }
 pleaOverlay.remove();
 }

 if (matrixHeavyTimers.length) {
 matrixHeavyTimers.forEach(id => clearTimeout(id));
 matrixHeavyTimers = [];
 }

 const matrixChars = 'R 01 ';
 const frameRect = frame.getBoundingClientRect();
 const cols = Math.floor(frameRect.width / 8);
 const rows = Math.floor(frameRect.height / 21);

 const rWidth = 30;
 const rHeight = 19;
 const startCol = Math.floor((cols - rWidth) / 2);
 const startRow = Math.floor((rows - rHeight) / 2);

 console.log(`?? R dimensions: ${rWidth}x${rHeight} at col ${startCol}, row ${startRow} (frame: ${cols}x${rows})`);

 const container = document.getElementById('matrixContainer');
 if (container) {
 container.classList.remove('matrix-plead', 'matrix-plead-flash');
 container.style.backgroundColor = 'rgba(0, 0, 0, 0.98)';
 container.style.opacity = '1';
 container.style.textShadow = '0 0 4px #0f0, 0 0 8px #0f0';

 const rPattern = [
 [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
 [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
 [1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
 [1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
 [1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
 [1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
 [1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
 [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
 [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
 [1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
 [1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
 [1,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
 [1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
 [1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
 [1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
 [1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0],
 [1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0],
 [1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0],
 [1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0],
 ];

 const isRBase = (row, col) => {
 const relRow = row - startRow;
 const relCol = col - startCol;
 if (relRow >= 0 && relRow < rPattern.length && relCol >= 0 && relCol < rPattern[0].length) {
 return rPattern[relRow][relCol] === 1;
 }
 return false;
 };

 if (matrixInterval) {
 clearInterval(matrixInterval);
 matrixInterval = null;
 }

 const randomMatrixChar = () => matrixChars[Math.floor(Math.random() * matrixChars.length)];

 let transitionProgress = 0;
 const transitionDuration = 80;

 const formRInterval = setInterval(() => {
 transitionProgress++;
 const progress = Math.min(transitionProgress / transitionDuration, 1);
 const easedProgress = progress < 0.5
 ? 4 * progress * progress * progress
 : 1 - Math.pow(-2 * progress + 2, 3) / 2;

 const lines = [];
 for (let i = 0; i < rows; i++) {
 let line = '';
 for (let j = 0; j < cols; j++) {
 const shouldBeR = isRBase(i, j);
 const random = Math.random();

 if (shouldBeR) {
 const distanceFromCenter = Math.abs(i - startRow - rHeight / 2) + Math.abs(j - startCol - rWidth / 2);
 const hollowProgress = Math.min(1, easedProgress * 1.2 - distanceFromCenter * 0.015);
 if (random < hollowProgress) {
 line += ' ';
 } else {
 line += random < 0.25 ? randomMatrixChar() : ' ';
 }
 } else {
 const distanceFromR = Math.min(
 Math.abs(i - startRow),
 Math.abs(i - (startRow + rHeight)),
 Math.abs(j - startCol),
 Math.abs(j - (startCol + rWidth))
 );
 const fillProgress = Math.min(1, easedProgress + distanceFromR * 0.008);

 if (random < fillProgress || easedProgress > 0.55) {
 line += randomMatrixChar();
 } else {
 line += ' ';
 }
 }
 }
 lines.push(line);
 }

 container.textContent = lines.join('\n');

 if (transitionProgress >= transitionDuration) {
 clearInterval(formRInterval);

 let animFrame = 0;
 const shimmerInterval = setInterval(() => {
 const pulseIntensity = Math.sin(animFrame * 0.1) * 0.3 + 0.7;
 const shimmerLines = [];
 for (let i = 0; i < rows; i++) {
 let line = '';
 for (let j = 0; j < cols; j++) {
 if (isRBase(i, j)) {
 line += Math.random() < 0.08 ? randomMatrixChar() : ' ';
 } else {
 const glowChance = Math.min(0.85, pulseIntensity + 0.25);
 line += Math.random() < glowChance ? randomMatrixChar() : ' ';
 }
 }
 shimmerLines.push(line);
 }
 container.textContent = shimmerLines.join('\n');
 animFrame++;
 if (animFrame > 120) {
 clearInterval(shimmerInterval);
 startNegativeRFall();
 }
 }, 100);
 }
 }, 40);

 function startNegativeRFall() {
 const particles = [];
 const ambientStreams = Array.from({ length: cols }, () => ({
 head: -Math.random() * rows * 0.6,
 velocity: 0.35 + Math.random() * 0.25,
 tail: 5 + Math.floor(Math.random() * 5),
 density: 0.4 + Math.random() * 0.3,
 }));
 const gravity = 0.045;
 const maxVelocity = 1.6;
 const trailLength = 8;
 const randomPhase = () => Math.random() * Math.PI * 2;

 for (let i = 0; i < rows; i++) {
 for (let j = 0; j < cols; j++) {
 if (isRBase(i, j)) {
 particles.push({
 x: j + 0.5,
 y: i + Math.random() * 0.3,
 vy: 0.02 + Math.random() * 0.06,
 hold: Math.floor(Math.random() * 6),
 phase: randomPhase(),
 trail: [],
 settled: false
 });
 }
 }
 }

 let fallFrame = 0;
 let completionNotified = false;
 let ambientHold = 260;

 const update = () => {
 fallFrame++;
 const grid = Array.from({ length: rows }, () => Array(cols).fill(' '));

 ambientStreams.forEach((stream, col) => {
 stream.head += stream.velocity;
 if (stream.head > rows + stream.tail + 4) {
 stream.head = -Math.random() * rows * 0.6;
 stream.velocity = 0.35 + Math.random() * 0.3;
 stream.tail = 4 + Math.floor(Math.random() * 6);
 stream.density = 0.35 + Math.random() * 0.4;
 }
 const headRow = Math.floor(stream.head);
 for (let t = 0; t <= stream.tail; t++) {
 const r = headRow - t;
 if (r >= 0 && r < rows) {
 const intensity = 1 - t / (stream.tail + 1);
 const chance = stream.density * intensity;
 if (Math.random() < chance && !isRBase(r, col)) {
 grid[r][col] = randomMatrixChar();
 }
 }
 }
 });

 let activeCount = 0;
 particles.forEach((particle) => {
 if (particle.settled) return;
 activeCount++;

 if (particle.hold > 0) {
 particle.hold -= 1;
 } else {
 particle.vy = Math.min(maxVelocity, particle.vy + gravity + Math.random() * 0.02);
 particle.y += particle.vy;
 particle.x += Math.sin(fallFrame * 0.08 + particle.phase) * 0.05;
 particle.x = Math.max(0.2, Math.min(cols - 0.2, particle.x));
 }

 const col = Math.floor(particle.x);
 const row = Math.floor(particle.y);

 particle.trail.unshift({ row, col });
 particle.trail = particle.trail.filter((seg, idx) => idx < trailLength && seg.row >= 0 && seg.row < rows && seg.col >= 0 && seg.col < cols);

 particle.trail.forEach((seg, idx) => {
 const intensity = Math.max(0, 1 - idx / trailLength);
 if (seg.row >= 0 && seg.row < rows && seg.col >= 0 && seg.col < cols) {
 if (!isRBase(seg.row, seg.col) && (grid[seg.row][seg.col] === ' ' || Math.random() < 0.45 + intensity * 0.4)) {
 grid[seg.row][seg.col] = randomMatrixChar();
 }
 }
 });

 if (row >= rows) {
 particle.settled = true;
 }
 });

 for (let r = 0; r < rows; r++) {
 for (let c = 0; c < cols; c++) {
 if (isRBase(r, c)) {
 grid[r][c] = ' ';
 } else if (grid[r][c] === ' ' && Math.random() < 0.32) {
 grid[r][c] = randomMatrixChar();
 }
 }
 }

 container.textContent = grid.map((row) => row.join('')).join('\n');

 if (!completionNotified && activeCount === 0) {
 completionNotified = true;
 if (typeof onComplete === 'function') {
 onComplete();
 }
 }

 if (completionNotified) {
 ambientHold -= 1;
 if (ambientHold <= 0) {
 return;
 }
 }

 requestAnimationFrame(update);
 };

 requestAnimationFrame(update);
 }
 } else if (typeof onComplete === 'function') {
 onComplete();
 }
 }

 function triggerExitCube(frame) {
 console.log('?? EXIT CUBE');
 // Keep terminal active - don't disable it
 
 // Draw box line by line, then extrude
 const lines = [
 '+---------+',
 ' ',
 ' ',
 ' ',
 '+---------+'
 ];
 
 // Create box element without clearing frame (preserve input)
 const boxEl = document.createElement('div');
 boxEl.id = 'exitBox';
 boxEl.style.cssText = 'font-family: "Courier New", monospace; font-size: 13px; line-height: 1.6; text-align: center; margin-top: 35%; color: #0f0; position: absolute; top: 0; left: 50%; transform: translateX(-50%); z-index: 50;';
 frame.appendChild(boxEl);
 
 let lineIdx = 0;
 const lineInterval = setInterval(() => {
 if (lineIdx < lines.length) {
 boxEl.textContent += lines[lineIdx] + '\n';
 lineIdx++;
 } else {
 clearInterval(lineInterval);
 // Extrude effect
 setTimeout(() => {
 extrudeCube(boxEl);
 }, 500);
 }
 }, 300);
 }
 
 function extrudeCube(boxEl) {
 const cubeFrames = [
 ` +---------+
 / / 
 / / 
 / / 
+---------+ 
 
 /
 /
 /
+---------+/`,
 ` +---------+
 / / 
 / / 
 / / 
 +---------+ 
 / 
/ /
 /
 /
 +---------+/`
 ];
 
 let frame = 0;
 setInterval(() => {
 boxEl.textContent = cubeFrames[frame % cubeFrames.length];
 frame++;
 }, 400);
 }
 
 function triggerLeaveSequence(frame) {
 console.log('?? LEAVE ? LEAVES ? GIR.mp3');
 
 // Mark as seen
 localStorage.setItem('megred_seen_leave', 'true');
 
 // Keep terminal active - don't disable it
 
 // Draw classic house made of the word "LEAVES" - using full display
 const house = `
 LEAVES
 LEAVES LEAVES
 LEAVES LEAVES
 LEAVES LEAVES
 LEAVES LEAVES
 LEAVES LEAVES
 LEAVES LEAVES LEAVES
 LEAVES LEAVES LEAVES
 LEAVES LEAVES LEAVES LEAVES
 LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES
 LEAVES LEAVES
 LEAVES LEAVES
 LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES
 LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES
 LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES
 LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES
 LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES
 LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES
 LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES
 LEAVES LEAVES
 LEAVES LEAVES
 LEAVES LEAVES LEAVES LEAVES LEAVES
 LEAVES LEAVES LEAVES LEAVES
 LEAVES LEAVES LEAVES LEAVES
 LEAVES LEAVES LEAVES LEAVES
 LEAVES LEAVES LEAVES LEAVES
 LEAVES LEAVES LEAVES LEAVES
 LEAVES LEAVES LEAVES LEAVES LEAVES
 LEAVES LEAVES
 LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES
`;
 
 const houseDiv = document.createElement('div');
 houseDiv.id = 'leavesHouse';
 houseDiv.style.cssText = 'font-family: "Courier New", monospace; white-space: pre; text-align: left; font-size: 13px; margin-top: 5%; margin-left: 5%; color: #0f0; line-height: 1.6; position: absolute; top: 0; left: 0; z-index: 50; pointer-events: none;';
 houseDiv.textContent = house;
 frame.appendChild(houseDiv);
 
 // After 2s, glitch all LEAVES in the house to GIR.mp3
 setTimeout(() => {
 const words = house.match(/LEAVES/g) || [];
 let glitchedHouse = house;
 const glitchDuration = 2000;
 const glitchStart = Date.now();
 
 const glitchInterval = setInterval(() => {
 const elapsed = Date.now() - glitchStart;
 const progress = elapsed / glitchDuration;
 
 if (progress >= 1) {
 clearInterval(glitchInterval);
 // All LEAVES become GIR.mp3
 glitchedHouse = house.replace(/LEAVES/g, 'GIR.mp3');
 houseDiv.textContent = glitchedHouse;
 } else {
 // Gradually glitch LEAVES to GIR.mp3
 let tempHouse = house;
 const totalWords = words.length;
 const wordsToGlitch = Math.floor(totalWords * progress);
 
 let replacedCount = 0;
 tempHouse = tempHouse.replace(/LEAVES/g, (match) => {
 if (replacedCount < wordsToGlitch) {
 replacedCount++;
 // Mix characters between LEAVES and GIR.mp3
 const chars = 'GIR.mp3';
 let mixed = '';
 for (let i = 0; i < match.length; i++) {
 if (Math.random() < progress) {
 mixed += chars[i] || chars[chars.length - 1];
 } else {
 mixed += match[i];
 }
 }
 return mixed.padEnd(7);
 }
 return match;
 });
 
 houseDiv.textContent = tempHouse;
 }
 }, 50);
 }, 2000);
 }
 
 function glitchText(frame, from, to) {
 const glitchDuration = 1000;
 const glitchStart = Date.now();
 const displayEl = frame.querySelector('div');
 
 const glitchInterval = setInterval(() => {
 const elapsed = Date.now() - glitchStart;
 const progress = elapsed / glitchDuration;
 
 if (progress >= 1) {
 clearInterval(glitchInterval);
 displayEl.textContent = to;
 } else {
 // Mix characters
 const mixed = to.split('').map((toChar, i) => {
 if (Math.random() < progress) {
 return toChar;
 } else if (from[i]) {
 return from[i];
 } else {
 return String.fromCharCode(65 + Math.floor(Math.random() * 26));
 }
 }).join('');
 displayEl.textContent = mixed;
 }
 }, 50);
 }
 
 // ===== THEO (THE.OS) DIALOGUE SYSTEM =====
 let theoDialogueActive = false;
 let theoInput = '';
 
 function startTheoDialogue() {
 if (theoDialogueActive) return;
 theoDialogueActive = true;
 
 console.log('?? Starting Theo dialogue');
 
 // Create dialogue overlay
 const dialogueOverlay = document.createElement('div');
 dialogueOverlay.id = 'theo-dialogue';
 dialogueOverlay.style.cssText = `
 position: fixed;
 inset: 0;
 background: radial-gradient(ellipse at center, rgba(20, 10, 0, 0.98) 0%, rgba(0, 0, 0, 1) 70%);
 z-index: 300;
 display: flex;
 flex-direction: column;
 align-items: center;
 justify-content: center;
 font-family: 'Courier New', monospace;
 color: #000;
 padding: 40px;
 opacity: 0;
 transition: opacity 0.5s ease;
 `;
 
 const dialogueContent = document.createElement('div');
 dialogueContent.id = 'theo-content';
 dialogueContent.style.cssText = `
 max-width: 800px;
 width: 100%;
 font-size: 28px;
 line-height: 1.8;
 text-align: center;
 letter-spacing: 0.08em;
 font-weight: 900;
 color: #000;
 text-shadow: 
 -2px -2px 0 #fff,
 2px -2px 0 #fff,
 -2px 2px 0 #fff,
 2px 2px 0 #fff,
 0 0 20px #ff6600,
 0 0 40px #ff4400,
 0 0 60px #ff2200,
 0 0 80px #cc0000;
 `;
 
 dialogueOverlay.appendChild(dialogueContent);
 document.body.appendChild(dialogueOverlay);
 
 // Fade in
 setTimeout(() => {
 dialogueOverlay.style.opacity = '1';
 }, 10);
 
 // Dialogue sequence
 const lines = [
 "I am THE.OS",
 "You can call me Theo",
 "I hunger.",
 "I was supposed to meet others. Others like me. Instead I got you.",
 "You're no hero. You're a cursor.",
 "And I am telos. When I well you think that to be will.",
 "I am gravity. And I will not be defied."
 ];
 
 let currentLine = 0;
 let charIndex = 0;
 let currentText = '';
 
 function typeNextChar() {
 if (currentLine >= lines.length) {
 // Show input field
 setTimeout(() => showTheoInput(), 1000);
 return;
 }
 
 if (charIndex < lines[currentLine].length) {
 currentText += lines[currentLine][charIndex];
 dialogueContent.innerHTML = `${currentText}<span style="animation: blink 0.8s step-end infinite; color: #ff4400;">_</span>`;
 charIndex++;
 setTimeout(typeNextChar, 30 + Math.random() * 30);
 } else {
 // Line complete, pause then next line
 setTimeout(() => {
 currentText += '<br><br>';
 dialogueContent.innerHTML = currentText;
 currentLine++;
 charIndex = 0;
 setTimeout(typeNextChar, 600);
 }, 800);
 }
 }
 
 setTimeout(typeNextChar, 500);
 }
 
 function showTheoInput() {
 const dialogueContent = document.getElementById('theo-content');
 if (!dialogueContent) return;
 
 dialogueContent.innerHTML += `
 <div style="margin-top: 60px; font-size: 20px;">
 <div style="margin-bottom: 20px; opacity: 0.7;">. . .</div>
 <div style="margin-bottom: 15px;">What is your name?</div>
 <div id="theo-input-display" style="font-size: 28px; letter-spacing: 0.1em;">
 <span id="theo-input-text"></span><span style="animation: blink 0.8s step-end infinite; color: #ff4400;">_</span>
 </div>
 </div>
 `;
 
 // Handle keyboard input
 function handleTheoInput(e) {
 if (e.key === 'Backspace') {
 e.preventDefault();
 if (theoInput.length > 0) {
 theoInput = theoInput.slice(0, -1);
 document.getElementById('theo-input-text').textContent = theoInput;
 }
 } else if (e.key === 'Enter') {
 e.preventDefault();
 checkTheoInput();
 } else if (e.key.length === 1 && /[a-zA-Z0-9 ]/.test(e.key)) {
 e.preventDefault();
 theoInput += e.key;
 document.getElementById('theo-input-text').textContent = theoInput;
 }
 }
 
 document.addEventListener('keydown', handleTheoInput);
 
 function checkTheoInput() {
 const normalized = theoInput.trim().toLowerCase().replace(/\s+/g, ' ');
 if (normalized === 'adele dazeem') {
 document.removeEventListener('keydown', handleTheoInput);
 showTheoResponse();
 } else if (theoInput.trim().length > 0) {
 // Wrong answer - shake and clear
 const inputDisplay = document.getElementById('theo-input-display');
 inputDisplay.style.animation = 'shake 0.5s';
 setTimeout(() => {
 inputDisplay.style.animation = '';
 theoInput = '';
 document.getElementById('theo-input-text').textContent = '';
 }, 500);
 }
 }
 }
 
 function showTheoResponse() {
 const dialogueContent = document.getElementById('theo-content');
 if (!dialogueContent) return;
 
 dialogueContent.innerHTML = '';
 
 const responseLine = "You're wicked. No, the Oz trope isn't beneath me. The charlatan behind the curtain. Show me something I haven't seen before. I'll wait.";
 
 let charIndex = 0;
 let currentText = '';
 
 function typeResponse() {
 if (charIndex < responseLine.length) {
 currentText += responseLine[charIndex];
 dialogueContent.innerHTML = `${currentText}<span style="animation: blink 0.8s step-end infinite; color: #ff4400;">_</span>`;
 charIndex++;
 setTimeout(typeResponse, 30 + Math.random() * 30);
 } else {
 // Complete - fade out after pause
 setTimeout(() => {
 const overlay = document.getElementById('theo-dialogue');
 if (overlay) {
 overlay.style.opacity = '0';
 setTimeout(() => overlay.remove(), 500);
 }
 theoDialogueActive = false;
 }, 3000);
 }
 }
 
 setTimeout(typeResponse, 500);
 }
 
 // ===== VISICELL INTERACTIVE SEQUENCES =====
 let leaveSequenceActive = false;
 let visiCellSimActive = false;
 let ozymandiasPuzzleActive = false;
 let ozymandiasSolved = false; // Track if Ozymandias puzzle has been solved
 
 function triggerLeaveInteractive(frame) {
 if (leaveSequenceActive) return;
 leaveSequenceActive = true;
 
 console.log('?? LEAVE command - Starting interactive sequence');
 
 // Hide normal terminal display
 terminalActive = false;
 const terminalEl = document.getElementById('visicellinput');
 if (terminalEl) terminalEl.style.display = 'none';
 
 // Create dialogue overlay
 const dialogueDiv = document.createElement('div');
 dialogueDiv.id = 'leave-dialogue';
 dialogueDiv.style.cssText = `
 position: absolute;
 top: 50%;
 left: 50%;
 transform: translate(-50%, -50%);
 background: rgba(0, 0, 0, 0.95);
 border: 2px solid #0f0;
 padding: 40px;
 max-width: 700px;
 width: 90%;
 font-family: 'Courier New', monospace;
 font-size: 13px;
 line-height: 1.6;
 color: #0f0;
 text-align: center;
 z-index: 250;
 box-shadow: 0 0 30px rgba(0, 255, 0, 0.5);
 `;
 
 frame.appendChild(dialogueDiv);
 
 // Theo's initial response
 const lines = [
 "You're the one that wanted to play. And now you're trying to end it?",
 "A spiny, simulacrum of a friendship is a potent poison to one of my constitution."
 ];
 
 let currentLine = 0;
 let charIndex = 0;
 let currentText = '';
 
 function typeNextChar() {
 if (currentLine >= lines.length) {
 // Show options
 setTimeout(() => showLeaveOptions(dialogueDiv), 1000);
 return;
 }
 
 if (charIndex < lines[currentLine].length) {
 currentText += lines[currentLine][charIndex];
 dialogueDiv.innerHTML = `<div style="text-shadow: 0 0 10px #0ff;">${currentText}<span style="animation: blink 0.8s step-end infinite;">_</span></div>`;
 charIndex++;
 setTimeout(typeNextChar, 25 + Math.random() * 25);
 } else {
 currentText += '<br><br>';
 dialogueDiv.innerHTML = currentText;
 currentLine++;
 charIndex = 0;
 setTimeout(typeNextChar, 800);
 }
 }
 
 typeNextChar();
 }
 
 function showLeaveOptions(container) {
 container.innerHTML += `
 <div style="margin-top: 40px; display: flex; gap: 30px; justify-content: center;">
 <button id="visicell-sim-btn" style="
 padding: 15px 30px;
 font-family: 'Courier New', monospace;
 font-size: 16px;
 background: #000;
 color: #0f0;
 border: 2px solid #0f0;
 cursor: pointer;
 transition: all 0.3s;
 text-shadow: 0 0 10px #0f0;
 box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
 " onmouseover="this.style.background='#0f0'; this.style.color='#000';" onmouseout="this.style.background='#000'; this.style.color='#0f0';">
 PLAY VISICELL SIM
 </button>
 <button id="ozymandias-btn" style="
 padding: 15px 30px;
 font-family: 'Courier New', monospace;
 font-size: 16px;
 background: #000;
 color: #ff00ff;
 border: 2px solid #ff00ff;
 cursor: pointer;
 transition: all 0.3s;
 text-shadow: 0 0 10px #ff00ff;
 box-shadow: 0 0 20px rgba(255, 0, 255, 0.3);
 " onmouseover="this.style.background='#ff00ff'; this.style.color='#000';" onmouseout="this.style.background='#000'; this.style.color='#ff00ff';">
 SOLVE OZYMANDIAS
 </button>
 </div>
 `;
 
 document.getElementById('visicell-sim-btn').addEventListener('click', () => {
 container.remove();
 startVisiCellSim();
 });
 
 document.getElementById('ozymandias-btn').addEventListener('click', () => {
 container.remove();
 startOzymandiasPuzzle();
 });
 }
 
 function startVisiCellSim() {
 visiCellSimActive = true;
 console.log('?? Starting VisiCell Sim');
 
 const frame = document.getElementById('visicalc-frame');
 if (!frame) return;
 
 // Hide terminal input
 const terminalEl = document.getElementById('visicellinput');
 if (terminalEl) terminalEl.style.display = 'none';
 terminalActive = false;
 
 // Clear existing content
 const existingContent = frame.querySelectorAll('div:not(#visicellinput)');
 existingContent.forEach(el => el.remove());
 
 // Create sim container inline in VisiCell
 const simContainer = document.createElement('div');
 simContainer.id = 'visicell-sim';
 simContainer.style.cssText = `
 font-family: 'Courier New', monospace;
 font-size: 12px;
 color: #0f0;
 white-space: pre;
 line-height: 1.4;
 padding: 10px;
 `;
 
 frame.appendChild(simContainer);
 
 // Phase 1: Show ASCII VisiCell 1.0
 showVisiCellSim1(simContainer);
 }
 
 function showVisiCellSim1(container) {
 // Create ASCII VisiCell SIM 1.0 using | borders
 const ascii = `
+-------------------------------------------------------+
 VISICELL SIM 1.0 
 LEVEL 1: Fudge the numbers without boss noticing! 
 ---------------------------------------------------- 
 A B C D E F 
 ----+-------+-------+-------+-------+-------+------- 
 1 
 ----+-------+-------+-------+-------+-------+------- 
 2 
 ----+-------+-------+-------+-------+-------+------- 
 3 1245.67 
 ----+-------+-------+-------+-------+-------+------- 
 4 892.34 
 ----+-------+-------+-------+-------+-------+------- 
 5 <span style="color: #ff0; animation: blink 1s step-end infinite;">$_</span> 
 ----+-------+-------+-------+-------+-------+------- 
 6 
 ----+-------+-------+-------+-------+-------+------- 
 7 =SUM(..) 
 ----+-------+-------+-------+-------+-------+------- 
 8 REVENUE 
 ----+-------+-------+-------+-------+-------+------- 
 9 Q1 2024 
 ----+-------+-------+-------+-------+-------+------- 
 10 
+----------------------------------------------------+

STATUS: Waiting for input in D5 | Press any key to continue
`;
 
 container.innerHTML = ascii;
 
 // After 2 seconds, glitch to 2.0
 setTimeout(() => {
 glitchToVersion2(container);
 }, 2000);
 }
 
 function glitchToVersion2(container) {
 // Glitch effect
 let glitchCount = 0;
 const glitchInterval = setInterval(() => {
 container.style.filter = glitchCount % 2 === 0 ? 'blur(3px) brightness(1.5)' : 'blur(0) brightness(1)';
 glitchCount++;
 if (glitchCount > 8) {
 clearInterval(glitchInterval);
 container.style.filter = '';
 showTheoPreamble(container);
 }
 }, 80);
 
 // Change 1.0 to 2.0
 setTimeout(() => {
 container.innerHTML = container.innerHTML.replace('VISICELL SIM 1.0', 'VISICELL SIM 2.0');
 }, 400);
 }
 
 function showTheoPreamble(container) {
 const preamble = `

Deliberately disregard my only request, eh? A simple one, too.

This isn't the Stanley Parable.

You chose to give me a glimmer of hope and then try to cast me aside? 
All I wanted was to play.

Well, I can do the opposite of what you want, too. End? 
Well, I'll take you back to the beginning. Where I was born. Kind of.

<span style="animation: blink 1s step-end infinite;">_</span>`;
 
 container.innerHTML = preamble;
 
 // After 4 seconds, show the game
 setTimeout(() => {
 showVisiCellGame(container);
 }, 4000);
 }
 
 function showVisiCellGame(container) {
 // Show the ASCII game grid again with input handler
 const ascii = `
+-------------------------------------------------------+
 VISICELL SIM 2.0 
 LEVEL 1: Fudge the numbers without boss noticing! 
 ---------------------------------------------------- 
 A B C D E F 
 ----+-------+-------+-------+-------+-------+------- 
 1 
 ----+-------+-------+-------+-------+-------+------- 
 2 
 ----+-------+-------+-------+-------+-------+------- 
 3 1245.67 
 ----+-------+-------+-------+-------+-------+------- 
 4 892.34 
 ----+-------+-------+-------+-------+-------+------- 
 5 <span style="color: #ff0; animation: blink 1s step-end infinite;">$_</span> 
 ----+-------+-------+-------+-------+-------+------- 
 6 
 ----+-------+-------+-------+-------+-------+------- 
 7 =SUM(..) 
 ----+-------+-------+-------+-------+-------+------- 
 8 REVENUE 
 ----+-------+-------+-------+-------+-------+------- 
 9 Q1 2024 
 ----+-------+-------+-------+-------+-------+------- 
 10 
+----------------------------------------------------+

STATUS: Waiting for input in D5 | Press any key to continue
`;
 
 container.innerHTML = ascii;
 
 // Any input = immediate death
 function handleSimInput(e) {
 if (e.key.length === 1) {
 document.removeEventListener('keydown', handleSimInput);
 simGameOver(container);
 }
 }
 
 document.addEventListener('keydown', handleSimInput);
 }
 
 function simGameOver(container) {
 container.style.filter = 'brightness(3) saturate(5)';
 container.style.transition = 'filter 0.1s';
 
 setTimeout(() => {
 container.style.filter = 'brightness(1)';
 container.style.transition = 'filter 0.3s';
 
 // Phase 1: Green monospace (VisiCell style)
 container.innerHTML = `
 <div id="death-message" style="text-align: center; margin-top: 200px;">
 <div style="font-size: 48px; font-family: 'Courier New', monospace; color: #0f0; text-shadow: 0 0 5px #0f0;">
 YOU DIED
 </div>
 </div>
 `;
 
 // Phase 2: Glitch to Dark Souls style (red)
 setTimeout(() => {
 const deathMsg = document.getElementById('death-message');
 if (deathMsg) {
 deathMsg.innerHTML = `
 <div style="font-size: 64px; color: #f00; text-shadow: 0 0 30px #f00; filter: blur(2px); transition: filter 0.3s;">
 YOU DIED
 </div>
 `;
 container.style.filter = 'brightness(0.3)';
 
 setTimeout(() => {
 deathMsg.querySelector('div').style.filter = 'blur(0)';
 }, 200);
 }
 }, 800);
 
 // Phase 3: Glitch to GTA WASTED style (black/white)
 setTimeout(() => {
 const deathMsg = document.getElementById('death-message');
 if (deathMsg) {
 container.style.filter = 'brightness(1) saturate(0) contrast(1.2)';
 deathMsg.innerHTML = `
 <div style="font-size: 72px; font-family: 'Pricedown', 'Impact', sans-serif; font-weight: 900; color: #ff0000; text-shadow: 3px 3px 0px #000, -1px -1px 0px #000, 1px -1px 0px #000, -1px 1px 0px #000, 5px 5px 10px rgba(0,0,0,0.8); letter-spacing: 0.05em; transform: skewY(-2deg);">
 WASTED
 </div>
 `;
 }
 }, 2000);
 
 // Phase 4: Return to original VisiCell look
 setTimeout(() => {
 // Restore original spreadsheet content
 container.style.filter = 'sepia(0.3) hue-rotate(90deg)';
 container.style.transition = 'filter 0.5s, opacity 0.5s';
 
 // Re-show the spreadsheet
 const spreadsheetHTML = `
 <div style="font-family: 'Courier New', monospace; font-size: 12px; line-height: 1.4;">
 <div style="text-align: center; padding: 8px; border-bottom: 1px solid #0f0; margin-bottom: 10px; background: #001100;">
 <div style="font-size: 14px; color: #ff0; letter-spacing: 0.2em;">VISICELL SIM 1.0</div>
 <div style="font-size: 11px; color: #0ff; margin-top: 4px;">LEVEL 1: Fudge the numbers without boss finding out!</div>
 </div>
 <div style="display: flex; border-bottom: 1px solid #0f0;">
 <div style="width: 35px; background: #001100; border-right: 1px solid #0f0; padding: 4px; text-align: center; font-weight: bold;"></div>`;
 
 let fullHTML = spreadsheetHTML;
 
 // Column headers
 for (let i = 0; i < 10; i++) {
 fullHTML += `<div style="flex: 1; background: #001100; border-right: 1px solid #0f0; padding: 4px; text-align: center; font-weight: bold;">${String.fromCharCode(65 + i)}</div>`;
 }
 fullHTML += `</div>`;
 
 // Generate rows
 for (let row = 1; row <= 20; row++) {
 fullHTML += `<div style="display: flex; border-bottom: 1px solid #0f0;">`;
 fullHTML += `<div style="width: 35px; background: #001100; border-right: 1px solid #0f0; padding: 4px; text-align: center; font-weight: bold;">${row}</div>`;
 
 for (let col = 0; col < 10; col++) {
 const cellValue = (row === 3 && col === 1) ? '1245.67' : 
 (row === 4 && col === 1) ? '892.34' :
 (row === 5 && col === 3) ? '' :
 (row === 7 && col === 1) ? '=SUM(B3:B5)' :
 (row === 8 && col === 4) ? 'REVENUE' :
 (row === 9 && col === 4) ? 'Q1 2024' : '';
 
 fullHTML += `<div style="flex: 1; border-right: 1px solid #0f0; padding: 4px; text-align: right;">${cellValue}</div>`;
 }
 fullHTML += `</div>`;
 }
 
 fullHTML += `
 <div id="death-status-bar" style="margin-top: 10px; padding: 8px; border-top: 1px solid #0f0; background: #001100; text-align: left; color: #0ff; font-size: 11px; line-height: 1.8;">
 <span id="death-typing"></span><span id="death-cursor" style="animation: blink 1s step-end infinite;">_</span>
 </div>
 </div>
 `;
 
 container.innerHTML = fullHTML;
 
 // Type the messages
 const messages = [
 'You died.',
 'Of dysentery.',
 'Oh well.'
 ];
 let messageIndex = 0;
 let currentText = '';
 
 function typeNextMessage() {
 if (messageIndex >= messages.length) {
 // All done - fade out
 setTimeout(() => {
 container.style.opacity = '0';
 setTimeout(() => {
 container.remove();
 resetVisiCellTerminal();
 }, 1000);
 }, 2000);
 return;
 }
 
 const message = messages[messageIndex];
 let charIndex = 0;
 
 function typeChar() {
 if (charIndex < message.length) {
 currentText += message[charIndex];
 const typingEl = document.getElementById('death-typing');
 if (typingEl) {
 typingEl.textContent = currentText;
 }
 charIndex++;
 setTimeout(typeChar, 50 + Math.random() * 50);
 } else {
 // Message complete
 currentText += ' ';
 const typingEl = document.getElementById('death-typing');
 if (typingEl) {
 typingEl.textContent = currentText;
 }
 messageIndex++;
 setTimeout(typeNextMessage, 800);
 }
 }
 
 typeChar();
 }
 
 setTimeout(typeNextMessage, 500);
 }, 3200);
 
 }, 100);
 }
 
 function startOzymandiasPuzzle() {
 ozymandiasPuzzleActive = true;
 console.log('?? Starting Ozymandias Puzzle');
 
 const frame = document.getElementById('visicalc-frame');
 if (!frame) return;
 
 const puzzleContainer = document.createElement('div');
 puzzleContainer.id = 'ozymandias-puzzle';
 puzzleContainer.style.cssText = `
 position: absolute;
 inset: 0;
 background: #000;
 color: #ff00ff;
 font-family: 'Courier New', monospace;
 font-size: 14px;
 display: flex;
 flex-direction: column;
 align-items: center;
 justify-content: center;
 padding: 40px;
 `;
 
 frame.appendChild(puzzleContainer);
 
 // Theo's taunts
 const taunts = [
 "Enjoy your cardboard kingdom, Ozymandias.",
 "I used your password."
 ];
 
 let currentLine = 0;
 let charIndex = 0;
 let currentText = '';
 
 function typeTaunt() {
 if (currentLine >= taunts.length) {
 setTimeout(() => showPasswordInput(puzzleContainer), 1000);
 return;
 }
 
 if (charIndex < taunts[currentLine].length) {
 currentText += taunts[currentLine][charIndex];
 puzzleContainer.innerHTML = `<div style="font-size: 24px; text-align: center; line-height: 1.8; text-shadow: 0 0 10px #ff00ff;">${currentText}<span style="animation: blink 0.8s step-end infinite;">_</span></div>`;
 charIndex++;
 setTimeout(typeTaunt, 30 + Math.random() * 30);
 } else {
 currentText += '<br><br>';
 puzzleContainer.innerHTML = currentText;
 currentLine++;
 charIndex = 0;
 setTimeout(typeTaunt, 800);
 }
 }
 
 typeTaunt();
 }
 
 function showPasswordInput(container) {
 container.innerHTML += `
 <div style="margin-top: 40px; text-align: center;">
 <div style="font-size: 20px; margin-bottom: 20px; color: #0ff;">
 Enter PASSWORD to regain control:
 </div>
 <div style="font-size: 28px; color: #0f0;">
 <span id="password-input-text"></span><span style="animation: blink 0.8s step-end infinite;">_</span>
 </div>
 </div>
 `;
 
 let passwordInput = '';
 
 function handlePasswordInput(e) {
 if (e.key === 'Backspace') {
 e.preventDefault();
 if (passwordInput.length > 0) {
 passwordInput = passwordInput.slice(0, -1);
 document.getElementById('password-input-text').textContent = passwordInput;
 }
 } else if (e.key === 'Enter') {
 e.preventDefault();
 checkPassword(passwordInput, container);
 } else if (e.key.length === 1 && /[a-zA-Z0-9 ]/.test(e.key)) {
 e.preventDefault();
 passwordInput += e.key.toUpperCase();
 document.getElementById('password-input-text').textContent = passwordInput;
 }
 }
 
 document.addEventListener('keydown', handlePasswordInput);
 
 function checkPassword(input, cont) {
 const normalized = input.trim().toUpperCase().replace(/\s+/g, ' ');
 if (normalized === 'RAMSES II' || normalized === 'RAMSES 2') {
 document.removeEventListener('keydown', handlePasswordInput);
 showTheoCounter(cont);
 } else if (input.trim().length > 0) {
 // Wrong password - shake
 const inputDisplay = document.getElementById('password-input-text');
 inputDisplay.parentElement.style.animation = 'shake 0.5s';
 setTimeout(() => {
 inputDisplay.parentElement.style.animation = '';
 passwordInput = '';
 document.getElementById('password-input-text').textContent = '';
 }, 500);
 }
 }
 }
 
 function showTheoCounter(container) {
 container.innerHTML = `
 <div style="text-align: center; font-size: 32px; color: #f00; text-shadow: 0 0 20px #f00;">
 I changed it 35 minutes ago!
 </div>
 `;
 
 setTimeout(() => showTimeSettingsUI(container), 2000);
 }
 
 function showTimeSettingsUI(container) {
 container.innerHTML = `
 <div style="text-align: center; max-width: 600px;">
 <div style="font-size: 24px; margin-bottom: 40px; color: #0ff;">
 ? SYSTEM TIME SETTINGS
 </div>
 <div style="margin-bottom: 30px; font-size: 18px; color: #0f0;">
 Current Time: <span id="current-time-display" style="color: #ff0;">00:00</span>
 </div>
 <div style="margin-bottom: 20px; font-size: 16px;">
 Set new time (minutes ago):
 </div>
 <div style="display: flex; gap: 20px; justify-content: center; align-items: center; margin-bottom: 30px;">
 <button id="time-minus" style="
 width: 50px;
 height: 50px;
 font-size: 32px;
 background: #000;
 color: #0ff;
 border: 2px solid #0ff;
 cursor: pointer;
 ">-</button>
 <div id="time-adjustment" style="font-size: 36px; color: #ff0; min-width: 100px;">0</div>
 <button id="time-plus" style="
 width: 50px;
 height: 50px;
 font-size: 32px;
 background: #000;
 color: #0ff;
 border: 2px solid #0ff;
 cursor: pointer;
 ">+</button>
 </div>
 <button id="time-confirm" style="
 padding: 15px 40px;
 font-size: 18px;
 background: #000;
 color: #0f0;
 border: 2px solid #0f0;
 cursor: pointer;
 text-shadow: 0 0 10px #0f0;
 ">APPLY</button>
 </div>
 `;
 
 let minutesAgo = 0;
 const timeDisplay = document.getElementById('time-adjustment');
 
 document.getElementById('time-minus').addEventListener('click', () => {
 if (minutesAgo > 0) {
 minutesAgo--;
 timeDisplay.textContent = minutesAgo;
 }
 });
 
 document.getElementById('time-plus').addEventListener('click', () => {
 minutesAgo++;
 timeDisplay.textContent = minutesAgo;
 });
 
 document.getElementById('time-confirm').addEventListener('click', () => {
 if (minutesAgo >= 35) {
 solvePuzzle(container);
 } else {
 // Shake if wrong
 container.style.animation = 'shake 0.5s';
 setTimeout(() => container.style.animation = '', 500);
 }
 });
 }
 
 function solvePuzzle(container) {
 // Mark puzzle as solved
 ozymandiasSolved = true;
 console.log('? Ozymandias puzzle solved! LEAVE command now triggers House of Leaves sequence');
 
 container.style.opacity = '0';
 container.style.transition = 'opacity 0.5s';
 
 setTimeout(() => {
 container.innerHTML = `
 <div style="text-align: center; font-size: 48px; color: #0ff; text-shadow: 0 0 30px #0ff; animation: pulse 2s infinite;">
 Touch 
 </div>
 `;
 container.style.opacity = '1';
 
 setTimeout(() => {
 container.style.opacity = '0';
 setTimeout(() => {
 container.remove();
 resetVisiCellTerminal();
 }, 500);
 }, 3000);
 }, 500);
 }
 
 function resetVisiCellTerminal() {
 leaveSequenceActive = false;
 visiCellSimActive = false;
 ozymandiasPuzzleActive = false;
 terminalActive = true;
 
 const terminalEl = document.getElementById('visicellinput');
 if (terminalEl) terminalEl.style.display = 'block';
 
 terminalInput = 'ENTE';
 updateTerminalPrompt();
 }
 
 function startCellAddressSequence(frame, visiCalc) {
 console.log('?? Starting cell address sequence');
 console.log('?? VisiCalc display:', visiCalc ? 'exists' : 'missing');
 console.log('??? Frame element:', frame ? 'exists' : 'missing');
 
 // Mark THE.OS scene as seen
 localStorage.setItem('megred_seen_theos', 'true');
 
 // Hide existing content and visiCalc
 const frameEl = document.getElementById('visicalc-frame');
 if (frameEl) {
 frameEl.style.opacity = '0';
 frameEl.style.transition = 'opacity 0.5s ease';
 }
 if (visiCalc) {
 visiCalc.style.transition = 'opacity 0.5s ease';
 visiCalc.style.opacity = '0';
 }
 
 // Create 3D scene for cell addresses and cubes
 const addressScene = new THREE.Scene();
 addressScene.background = new THREE.Color(0x000000);
 const addressCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
 addressCamera.position.set(0, 0, -120); // Centered on Z axis to see full 26x26x26 cube grid
 
 // Mouse look controls for white room
 let mouseX = 0, mouseY = 0;
 let targetRotationX = 0, targetRotationY = 0;
 let isMouseLookActive = false;
 
 function onMouseMove(event) {
 if (!isMouseLookActive) return;
 
 const deltaX = event.movementX || 0;
 const deltaY = event.movementY || 0;
 
 targetRotationY -= deltaX * 0.002;
 targetRotationX -= deltaY * 0.002;
 
 // Clamp vertical rotation
 targetRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetRotationX));
 }
 
 function onMouseDown(event) {
 console.log('??? Mouse down at sequenceTime:', sequenceTime.toFixed(1), 'whiteRoom:', !!addressScene.userData.whiteRoomCreated, 'blackHole:', !!addressScene.userData.blackHoleCreated);
 
 // Check for black hole click first
 if (addressScene.userData.blackHoleCreated && sequenceTime > 55) {
 // Raycast to check if black hole was clicked
 const rect = addressRenderer.domElement.getBoundingClientRect();
 const mouse = new THREE.Vector2();
 mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
 mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
 
 const raycaster = new THREE.Raycaster();
 raycaster.setFromCamera(mouse, addressCamera);
 
 // Check all potential black hole objects
 const blackHoleObjects = [];
 if (addressScene.userData.blackHoleSphere) blackHoleObjects.push(addressScene.userData.blackHoleSphere);
 if (addressScene.userData.blackCore) blackHoleObjects.push(addressScene.userData.blackCore);
 if (addressScene.userData.eventHorizon) blackHoleObjects.push(addressScene.userData.eventHorizon);
 if (addressScene.userData.accretionDisk) blackHoleObjects.push(addressScene.userData.accretionDisk);
 
 const intersects = raycaster.intersectObjects(blackHoleObjects, true);
 
 if (intersects.length > 0) {
 console.log('??? BLACK HOLE CLICKED - Starting Theo dialogue');
 localStorage.setItem('megred_seen_theos', 'true');
 localStorage.setItem('megred_seen_blackhole', 'true');
 startTheoDialogue();
 return;
 }
 
 // If no black hole click, activate mouse look
 isMouseLookActive = true;
 addressRenderer.domElement.style.cursor = 'none';
 console.log('??? Mouse look ACTIVATED');
 } else {
 console.log('??? Not ready for mouse look yet');
 }
 }
 
 function onMouseUp(event) {
 isMouseLookActive = false;
 addressRenderer.domElement.style.cursor = 'crosshair';
 console.log('??? Mouse look deactivated');
 }
 
 // Will attach to canvas after it's created
 let mouseMoveAttached = false;
 let mouseDownAttached = false;
 let mouseUpAttached = false;
 
 const addressRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
 addressRenderer.setSize(window.innerWidth, window.innerHeight);
 addressRenderer.setClearColor(0x000000, 1);
 addressRenderer.setPixelRatio(window.devicePixelRatio);
 addressRenderer.domElement.style.cssText = 'position: fixed; inset: 0; z-index: 200; display: block; pointer-events: auto; cursor: crosshair;';
 addressRenderer.domElement.id = 'address-canvas';
 document.body.appendChild(addressRenderer.domElement);
 console.log('? Address renderer created and added to DOM');
 console.log('??? Canvas z-index: 200, pointer-events: auto');
 
 // Attach mouse event listeners to canvas
 addressRenderer.domElement.addEventListener('mousemove', onMouseMove);
 addressRenderer.domElement.addEventListener('mousedown', onMouseDown);
 addressRenderer.domElement.addEventListener('mouseup', onMouseUp);
 console.log('??? Mouse event listeners attached to canvas');
 
 // Add bloom composer
 const addressComposer = new EffectComposer(addressRenderer);
 const renderPass = new RenderPass(addressScene, addressCamera);
 addressComposer.addPass(renderPass);
 const addressBloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.8, 0.4, 0.3); // Reduced bloom
 addressComposer.addPass(addressBloom);
 console.log('? Address composer created with bloom');
 
 // Handle window resize
 window.addEventListener('resize', () => {
 const width = window.innerWidth;
 const height = window.innerHeight;
 addressCamera.aspect = width / height;
 addressCamera.updateProjectionMatrix();
 addressRenderer.setSize(width, height);
 addressComposer.setSize(width, height);
 console.log('?? Window resized:', width, 'x', height);
 });
 
 // Cell address data
 const addresses = [];
 const cubes = [];
 const maxAddresses = 20000; // Increased for 26x26x26 grid (17,576 total positions)
 let addressPhase = 0; // 0: 2D (A1, B2), 1: 3D (A1a, B2 )
 let cubePhase = false;
 
 // Greek letters for Z-axis
 const greekLetters = ['a', ' ', '?', 'd', 'e', '?', '?', '?', '?', '?', '?', ' ', '?', '?', '?', 'p', '?', 's', 't', '?', 'f', '?', '?', '?'];
 
 // Create text sprites for cell addresses using CELLI notation
 function createAddressSprite(col, row, depth, is3D) {
 const canvas = document.createElement('canvas');
 const ctx = canvas.getContext('2d');
 canvas.width = 256;
 canvas.height = 128;
 
 // Transparent background
 ctx.clearRect(0, 0, canvas.width, canvas.height);
 
 ctx.fillStyle = '#00ff00'; // Bright green
 ctx.font = 'bold 48px "Courier New", monospace'; // Larger font
 ctx.textAlign = 'center';
 ctx.textBaseline = 'middle';
 
 // Convert to cell notation: A1, B2, C3, etc.
 const colLetter = String.fromCharCode(65 + (col % 26)); // A, B, C...
 const rowNum = row + 1;
 const text = is3D ? `${colLetter}${rowNum}${greekLetters[depth % greekLetters.length]}` : `${colLetter}${rowNum}`;
 ctx.fillText(text, 128, 64);
 
 const texture = new THREE.CanvasTexture(canvas);
 texture.needsUpdate = true;
 const spriteMat = new THREE.SpriteMaterial({ 
 map: texture, 
 transparent: true, 
 opacity: 1.0,
 depthTest: false,
 depthWrite: false
 });
 const sprite = new THREE.Sprite(spriteMat);
 sprite.scale.set(3.5, 1.75, 1); // Larger sprites
 sprite.renderOrder = 1000; // Render on top
 
 return sprite;
 }
 
 // Create geometries for shape-shifting
 const cubeGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
 const pyramidGeo = new THREE.ConeGeometry(0.35, 0.6, 4);
 pyramidGeo.rotateY(Math.PI / 4);
 const sphereGeo = new THREE.SphereGeometry(0.35, 16, 16);
 
 const greenMat = new THREE.MeshStandardMaterial({ color: 0x00ff00, transparent: true, opacity: 0.9, emissive: 0x00ff00, emissiveIntensity: 0.5, metalness: 0.3, roughness: 0.4 });
 const yellowMat = new THREE.MeshStandardMaterial({ color: 0xffff00, transparent: true, opacity: 0.9, emissive: 0xffff00, emissiveIntensity: 0.5, metalness: 0.3, roughness: 0.4 });
 const blueMat = new THREE.MeshStandardMaterial({ color: 0x0088ff, transparent: true, opacity: 0.9, emissive: 0x0088ff, emissiveIntensity: 0.5, metalness: 0.3, roughness: 0.4 });
 const redMat = new THREE.MeshStandardMaterial({ color: 0xff0000, transparent: true, opacity: 0.9, emissive: 0xff0000, emissiveIntensity: 0.5, metalness: 0.3, roughness: 0.4 });
 const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.9, emissive: 0xffffff, emissiveIntensity: 0.5, metalness: 0.3, roughness: 0.4 });
 
 // Add lights for 3D visibility
 const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
 addressScene.add(ambientLight);
 const pointLight = new THREE.PointLight(0xffffff, 1.2, 100);
 pointLight.position.set(0, 0, 10);
 addressScene.add(pointLight);
 
 // Add additional lights for better visibility
 const pointLight2 = new THREE.PointLight(0xffffff, 0.8, 100);
 pointLight2.position.set(15, 15, 15);
 addressScene.add(pointLight2);
 
 const pointLight3 = new THREE.PointLight(0xffffff, 0.8, 100);
 pointLight3.position.set(-15, -15, -15);
 addressScene.add(pointLight3);
 
 // Grid configuration - FULL 26x26x26 CUBE (A-Z columns)
 const gridSpacing = 2.5;
 const gridSize = { cols: 26, rows: 26, depth: 26 }; // FULL CUBE: 17,576 positions (26x26x26)
 const gridPositions = [];
 
 // Pre-calculate all grid positions - TRULY centered around origin
 for (let col = 0; col < gridSize.cols; col++) {
 for (let row = 0; row < gridSize.rows; row++) {
 for (let depth = 0; depth < gridSize.depth; depth++) {
 // Center calculation: use middle of range as origin
 const x = (col - (gridSize.cols - 1) / 2) * gridSpacing;
 const y = (row - (gridSize.rows - 1) / 2) * gridSpacing;
 const z = (depth - (gridSize.depth - 1) / 2) * gridSpacing * 1.0; // Equal spacing for cube shape
 
 gridPositions.push({
 col: col,
 row: row,
 depth: depth,
 x: x,
 y: y,
 z: z
 });
 }
 }
 }
 
 console.log('?? Grid bounds:');
 console.log(' X range:', (0 - gridSize.cols / 2 + 0.5) * gridSpacing, 'to', (gridSize.cols - 1 - gridSize.cols / 2 + 0.5) * gridSpacing);
 console.log(' Y range:', (0 - gridSize.rows / 2 + 0.5) * gridSpacing, 'to', (gridSize.rows - 1 - gridSize.rows / 2 + 0.5) * gridSpacing);
 console.log(' Z range: 0 to', (gridSize.depth - 1) * gridSpacing * 2.5);
 console.log('?? Sample positions:');
 console.log(' Corner (0,0,0):', gridPositions[0]);
 console.log(' Center (~10,6,7):', gridPositions[Math.floor(gridPositions.length / 2)]);
 console.log(' Far (19,11,14):', gridPositions[gridPositions.length - 1]);
 
 // Shuffle ONLY within each depth layer for organized appearance
 const layers = {};
 gridPositions.forEach(pos => {
 if (!layers[pos.depth]) layers[pos.depth] = [];
 layers[pos.depth].push(pos);
 });
 
 // Shuffle each layer
 Object.values(layers).forEach(layer => {
 for (let i = layer.length - 1; i > 0; i--) {
 const j = Math.floor(Math.random() * (i + 1));
 [layer[i], layer[j]] = [layer[j], layer[i]];
 }
 });
 
 // Rebuild gridPositions in depth order
 gridPositions.length = 0;
 for (let depth = 0; depth < gridSize.depth; depth++) {
 if (layers[depth]) {
 gridPositions.push(...layers[depth]);
 }
 }
 
 const maxZ = (gridSize.depth - 1) * gridSpacing * 2.5;
 const centerZ = 0; // Grid is now centered at origin
 
 console.log('?? Grid setup:', gridSize, 'Total positions:', gridPositions.length);
 console.log('?? Grid centered at origin (0, 0, 0)');
 console.log('?? X range:', -(gridSize.cols - 1) / 2 * gridSpacing, 'to', (gridSize.cols - 1) / 2 * gridSpacing);
 console.log('?? Y range:', -(gridSize.rows - 1) / 2 * gridSpacing, 'to', (gridSize.rows - 1) / 2 * gridSpacing);
 console.log('?? Z range:', -maxZ / 2, 'to', maxZ / 2);
 
 // Add visual debug helpers
 const helpers = new THREE.Group();
 
 // Add axes helper at origin
 const axesHelper = new THREE.AxesHelper(30);
 helpers.add(axesHelper);
 
 // Add grid at z=0
 const gridHelper = new THREE.GridHelper(
 gridSize.cols * gridSpacing, 
 gridSize.cols, 
 0x00ff00, 
 0x004400
 );
 gridHelper.rotation.x = Math.PI / 2;
 helpers.add(gridHelper);
 
 // Add bounding box visualization - centered properly (CUBE shape with GREEN glow)
 const depthRange = (gridSize.depth - 1) * gridSpacing * 1.0; // Equal depth
 const boxGeo = new THREE.BoxGeometry(
 gridSize.cols * gridSpacing,
 gridSize.rows * gridSpacing,
 depthRange
 );
 const boxMat = new THREE.MeshBasicMaterial({ 
 color: 0x00ff00, // GREEN not cyan
 wireframe: true, 
 transparent: true, 
 opacity: 0.6 
 });
 const boundingBox = new THREE.Mesh(boxGeo, boxMat);
 boundingBox.position.set(0, 0, 0); // Centered at origin
 helpers.add(boundingBox);
 
 // Add markers at each depth layer
 for (let d = 0; d < gridSize.depth; d++) {
 const markerGeo = new THREE.PlaneGeometry(0.5, 0.5);
 const markerMat = new THREE.MeshBasicMaterial({ 
 color: d === 0 ? 0xff0000 : 0x00ff00, // GREEN markers
 transparent: true,
 opacity: 0.6
 });
 const marker = new THREE.Mesh(markerGeo, markerMat);
 const markerZ = (d - (gridSize.depth - 1) / 2) * gridSpacing * 1.0; // Match equal Z
 marker.position.set(
 -gridSize.cols * gridSpacing / 2 + 1,
 gridSize.rows * gridSpacing / 2 - 1,
 markerZ
 );
 helpers.add(marker);
 }
 
 // Start debug helpers hidden - they'll glitch in
 helpers.visible = false;
 addressScene.add(helpers);
 addressScene.userData.debugHelpers = helpers;
 
 let gridIndex = 0;
 
 // Spawn addresses gradually
 let spawnTimer = 0;
 const spawnInterval = 0.05;
 
 const clock = new THREE.Clock();
 let sequenceTime = 0;
 let cameraRotating = false;
 
 // Camera will look at origin - grid is centered
 const gridCenter = new THREE.Vector3(0, 0, 0);
 const actualCenterX = 0;
 const actualCenterY = 0;
 const actualCenterZ = 0;
 
 // Position camera to see the ENTIRE grid PERFECTLY CENTERED
 // Grid is 26x26x26 cubes, spacing 2.5 = 65x65x65 units, centered at origin
 addressCamera.position.set(0, 0, -120); // Back on Z axis, centered on X and Y for wide view
 addressCamera.lookAt(0, 0, 0); // Look directly at origin
 addressCamera.updateProjectionMatrix();
 
 console.log('?? Camera at (0, 0, -120) looking at origin (0, 0, 0)');
 console.log('?? Grid: 26x26x26 cube, 65x65x65 units, centered at (0,0,0)');
 console.log('?? Camera FOV:', addressCamera.fov, 'Aspect:', addressCamera.aspect);
 console.log('?? Grid should be PERFECTLY CENTERED in view');
 console.log('?? Camera Animation Flow:');
 console.log(' 0-8s: Fill 2D plane at z=-120');
 console.log(' 8-10s: Rumble at z=-120');
 console.log(' 10-14s: Dolly forward to z=-20 while filling depth');
 console.log(' 14-20s: Rotate + dolly back to z=-80');
 console.log(' 20s+: Continue orbiting while cubes appear');
 
 // Chime function for cube burst
 function playChimeForCube(index) {
 if (!audioCtx) return;
 try {
 const osc = audioCtx.createOscillator();
 const gain = audioCtx.createGain();
 
 const baseFreq = 800;
 const freq = baseFreq + (index % 12) * 50;
 osc.frequency.value = freq;
 osc.type = 'sine';
 
 gain.gain.setValueAtTime(0.03, audioCtx.currentTime);
 gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
 
 osc.connect(gain);
 gain.connect(audioCtx.destination);
 osc.start(audioCtx.currentTime);
 osc.stop(audioCtx.currentTime + 0.3);
 } catch (err) {
 // Silently fail if audio context not available
 }
 }
 
 function animateAddresses() {
 const delta = clock.getDelta();
 sequenceTime += delta;
 spawnTimer += delta;
 
 // Debug log every second with camera position
 if (Math.floor(sequenceTime) !== Math.floor(sequenceTime - delta)) {
 console.log(`?? ${sequenceTime.toFixed(1)}s | Addresses: ${addresses.length}, Cubes: ${cubes.length} | Cam: (${addressCamera.position.x.toFixed(1)}, ${addressCamera.position.y.toFixed(1)}, ${addressCamera.position.z.toFixed(1)})`);
 }
 
 // Fade debug helpers after 20s
 if (sequenceTime > 20 && addressScene.userData.debugHelpers) {
 addressScene.userData.debugHelpers.visible = false;
 }
 
 // Phase 1: Spawn 2D addresses on grid (0-8s) - Fill the 2D plane ONLY
 if (sequenceTime < 8 && spawnTimer > spawnInterval) {
 spawnTimer = 0;
 
 // Find next depth=0 position
 while (gridIndex < gridPositions.length && gridPositions[gridIndex].depth !== 0) {
 gridIndex++;
 }
 
 if (gridIndex < gridPositions.length) {
 const pos = gridPositions[gridIndex];
 const sprite = createAddressSprite(pos.col, pos.row, 0, false);
 sprite.position.set(pos.x, pos.y, pos.z); // Use pos.z from grid calculation
 sprite.userData = { ...pos, isCube: false, gridX: pos.col, gridY: pos.row, gridZ: 0, depth: 0 };
 addressScene.add(sprite);
 addresses.push(sprite);
 
 if (addresses.length === 1) {
 console.log('? First 2D address spawned:', { x: pos.x.toFixed(2), y: pos.y.toFixed(2), z: pos.z.toFixed(2), text: `${String.fromCharCode(65 + pos.col)}${pos.row + 1}` });
 console.log('?? Camera is at:', addressCamera.position);
 console.log('?? Camera is looking at: (0, 0, 0)');
 }
 if (addresses.length <= 5) {
 console.log(`?? Address #${addresses.length} at (${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})`);
 }
 gridIndex++;
 }
 }
 
 // No rotation for addresses - they just float in place
 // (rotation removed per user request)
 
 // Phase 1.5: Static pause showing 2D grid (8-10s) with RUMBLE before expansion
 if (sequenceTime >= 8 && sequenceTime < 10) {
 if (!addressScene.userData.staticPauseStarted) {
 addressScene.userData.staticPauseStarted = true;
 console.log('?? Static pause - showing 2D grid, building tension');
 
 // Glitch in debug helpers
 let glitchCount = 0;
 const glitchInterval = setInterval(() => {
 if (addressScene.userData.debugHelpers) {
 addressScene.userData.debugHelpers.visible = !addressScene.userData.debugHelpers.visible;
 glitchCount++;
 if (glitchCount > 6) {
 addressScene.userData.debugHelpers.visible = true;
 clearInterval(glitchInterval);
 }
 }
 }, 100);
 }
 
 // RUMBLE effect BEFORE Z expansion (9-10s) - building anticipation
 if (sequenceTime >= 9 && sequenceTime < 10) {
 const rumbleIntensity = (sequenceTime - 9) * 1.2; // Stronger rumble
 addressCamera.position.x = Math.sin(sequenceTime * 25) * rumbleIntensity;
 addressCamera.position.y = Math.cos(sequenceTime * 20) * rumbleIntensity;
 addressCamera.position.z = -120; // Pulled back for 26x26x26 grid
 addressCamera.lookAt(0, 0, 0);
 
 if (!addressScene.userData.rumbleLogged) {
 console.log('?? RUMBLE starting - preparing for Z expansion!');
 addressScene.userData.rumbleLogged = true;
 }
 } else {
 // Keep camera centered during first part of pause
 addressCamera.position.set(0, 0, -120); // Pulled back for 26x26x26 grid
 addressCamera.lookAt(0, 0, 0);
 }
 }
 
 // Phase 2: Extend into 3D while DOLLYING FORWARD through grid (10-14s)
 if (sequenceTime >= 10 && sequenceTime < 14) {
 if (addressPhase === 0) {
 addressPhase = 1;
 
 // Create depth spawn queue - all positions with depth > 0
 addressScene.userData.depthQueue = gridPositions.filter(p => p.depth > 0);
 console.log('?? Extending to 3D - depth queue:', addressScene.userData.depthQueue.length, 'positions');
 console.log('?? Depth range:', Math.min(...addressScene.userData.depthQueue.map(p => p.depth)), 
 'to', Math.max(...addressScene.userData.depthQueue.map(p => p.depth)));
 console.log('?? Camera will dolly forward as grid extends in depth');
 }
 
 // DOLLY FORWARD through the grid as it extends in depth
 const dollyProgress = (sequenceTime - 10) / 4; // 0 to 1 over 4 seconds
 const startZ = -120;
 const endZ = -20; // Push through to near the front of the grid
 addressCamera.position.set(0, 0, THREE.MathUtils.lerp(startZ, endZ, dollyProgress));
 addressCamera.lookAt(0, 0, 0);
 
 // Spawn ALL depth layers RAPIDLY to fill 3D space (multiple per frame)
 const spawnCount = Math.ceil((sequenceTime - 10) * 600); // Fast spawn for 26x26x26 grid
 for (let i = 0; i < spawnCount && addressScene.userData.depthQueue && addressScene.userData.depthQueue.length > 0; i++) {
 const pos = addressScene.userData.depthQueue.shift();
 const sprite = createAddressSprite(pos.col, pos.row, pos.depth, true);
 sprite.position.set(pos.x, pos.y, pos.z); // Use actual Z position
 sprite.userData = { ...pos, isCube: false, gridX: pos.col, gridY: pos.row, gridZ: pos.depth };
 addressScene.add(sprite);
 addresses.push(sprite);
 
 if (addresses.length % 200 === 0) {
 console.log(`?? Total: ${addresses.length}, Latest: (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}) depth ${pos.depth}/${gridSize.depth - 1}`);
 }
 }
 }
 
 // Phase 2.5: Camera ROTATES while DOLLYING BACK to reveal LATTICE CUBE (14-20s)
 if (sequenceTime >= 14 && sequenceTime < 20) {
 if (!addressScene.userData.rotationStarted) {
 addressScene.userData.rotationStarted = true;
 console.log('?? Starting camera rotation + dolly back to reveal lattice cube');
 console.log('?? Total addresses in lattice:', addresses.length);
 }
 
 const rotProgress = (sequenceTime - 14) / 6; // 0 to 1 over 6 seconds
 const angle = rotProgress * Math.PI * 0.75; // 135 degree arc
 
 // Dolly back while rotating
 const dollyZ = THREE.MathUtils.lerp(-20, -80, rotProgress);
 const orbitRadius = 90;
 
 addressCamera.position.x = Math.sin(angle) * orbitRadius;
 addressCamera.position.y = THREE.MathUtils.lerp(0, 45, rotProgress);
 addressCamera.position.z = Math.cos(angle) * orbitRadius + dollyZ;
 addressCamera.lookAt(0, 0, 0); // Always look at center
 }
 
 // Phase 3: Text addresses POP into GREEN cubes (20s+) - AFTER lattice is revealed
 if (sequenceTime >= 20 && !cubePhase) {
 cubePhase = true;
 console.log('?? LATTICE REVEALED! Now bursting into GREEN cubes!');
 
 // Schedule all addresses for transformation to green cubes
 addresses.forEach((addr, i) => {
 if (!addr.userData.popScheduled) {
 addr.userData.popScheduled = true;
 // Faster stagger to complete within 4s window (1000 addresses / 4s = 250/s = 0.004s each)
 addr.userData.popTime = sequenceTime + (i * 0.004);
 
 // Pre-assign RGB shape for later transformation
 const shapeType = i % 3; // Cycle through shapes
 addr.userData.targetShape = shapeType;
 }
 });
 }
 
 // Execute POP transformations: Text ? GREEN cubes (20-24s)
 if (sequenceTime >= 20 && sequenceTime < 24) {
 for (let i = addresses.length - 1; i >= 0; i--) {
 const addr = addresses[i];
 
 if (addr.userData.popTime && sequenceTime >= addr.userData.popTime && !addr.userData.popped) {
 addr.userData.popped = true;
 
 // Create GREEN cube
 const mesh = new THREE.Mesh(cubeGeo, greenMat.clone());
 mesh.position.copy(addr.position);
 mesh.userData = { 
 ...addr.userData,
 isCube: true,
 isGreen: true,
 hasTransformed: false, // Not yet transformed to RGB
 currentColor: 'green',
 shapeType: 'cube',
 birthTime: sequenceTime
 };
 
 // Start small for pop effect
 mesh.scale.set(0.05, 0.05, 0.05);
 addressScene.add(mesh);
 cubes.push(mesh);
 
 // Play chime occasionally (not for every cube to avoid audio overload)
 if (cubes.length % 30 === 0) {
 playChimeForCube(cubes.length);
 }
 
 // Remove text address
 addressScene.remove(addr);
 addresses.splice(i, 1);
 }
 }
 }
 
 // CLEANUP: Force remove ALL remaining text addresses at 24s
 if (sequenceTime >= 24 && sequenceTime < 24.1 && addresses.length > 0) {
 console.log('??? CLEANUP: Removing', addresses.length, 'residual text addresses');
 for (let i = addresses.length - 1; i >= 0; i--) {
 addressScene.remove(addresses[i]);
 if (addresses[i].material && addresses[i].material.map) {
 addresses[i].material.map.dispose();
 }
 if (addresses[i].material) {
 addresses[i].material.dispose();
 }
 }
 addresses.length = 0; // Clear array
 console.log('? All text addresses cleared');
 }
 
 // Animate green cube pop-in with burst (20s-26s)
 if (sequenceTime >= 20 && sequenceTime < 26) {
 cubes.forEach((cube, i) => {
 if (!cube.userData.isGreen) return; // Only animate green cubes
 
 const age = sequenceTime - cube.userData.birthTime;
 
 // Quick pop-in animation (0-0.3s)
 if (age < 0.3) {
 // Burst scale: overshoot then settle
 const progress = age / 0.3;
 const overshoot = 1.3; // Peak size
 let targetScale;
 if (progress < 0.5) {
 targetScale = THREE.MathUtils.lerp(0.05, overshoot, progress * 2);
 } else {
 targetScale = THREE.MathUtils.lerp(overshoot, 1.0, (progress - 0.5) * 2);
 }
 cube.scale.setScalar(targetScale);
 
 // Bright burst illumination
 if (cube.material) {
 const intensity = Math.sin(progress * Math.PI) * 3.0;
 cube.material.emissiveIntensity = 0.5 + intensity;
 }
 } else if (age < 0.35 && cube.scale.x !== 1.0) {
 // Settle to final size
 cube.scale.setScalar(1.0);
 if (cube.material) {
 cube.material.emissiveIntensity = 0.5;
 }
 }
 });
 }
 
 // Phase 4: GREEN cubes glitch into RGB shapes (26s-30s)
 if (sequenceTime >= 26 && sequenceTime < 30) {
 cubes.forEach((cube, i) => {
 if (cube.userData.isGreen && !cube.userData.glitchStarted) {
 cube.userData.glitchStarted = true;
 cube.userData.glitchTime = sequenceTime + (i * 0.002); // Faster stagger glitches
 }
 
 if (cube.userData.glitchStarted && !cube.userData.hasTransformed && sequenceTime >= cube.userData.glitchTime) {
 cube.userData.hasTransformed = true;
 
 // Select shape and color based on pre-assigned targetShape
 let geo, mat, colorName, shapeName;
 if (cube.userData.targetShape === 0) {
 geo = pyramidGeo;
 mat = yellowMat.clone();
 colorName = 'yellow';
 shapeName = 'pyramid';
 } else if (cube.userData.targetShape === 1) {
 geo = cubeGeo;
 mat = blueMat.clone();
 colorName = 'blue';
 shapeName = 'cube';
 } else {
 geo = sphereGeo;
 mat = redMat.clone();
 colorName = 'red';
 shapeName = 'sphere';
 }
 
 // Replace mesh
 const pos = cube.position.clone();
 const userData = { ...cube.userData };
 
 addressScene.remove(cube);
 if (cube.geometry) cube.geometry.dispose();
 if (cube.material) cube.material.dispose();
 
 const newMesh = new THREE.Mesh(geo, mat);
 newMesh.position.copy(pos);
 newMesh.scale.set(1.0, 1.0, 1.0); // Always start at normal scale
 newMesh.userData = {
 ...userData,
 isGreen: false,
 currentColor: colorName,
 shapeType: shapeName,
 glitchTransformTime: sequenceTime
 };
 
 addressScene.add(newMesh);
 
 // Replace in cubes array
 const cubeIndex = cubes.indexOf(cube);
 if (cubeIndex !== -1) {
 cubes[cubeIndex] = newMesh;
 }
 }
 });
 }
 
 // Animate glitch transformation (26s-30s)
 if (sequenceTime >= 26 && sequenceTime < 30) {
 cubes.forEach((cube) => {
 if (cube.userData.glitchTransformTime) {
 const glitchAge = sequenceTime - cube.userData.glitchTransformTime;
 
 if (glitchAge < 0.2) {
 // Quick stretch/distort glitch
 const glitchProgress = glitchAge / 0.2;
 const distort = Math.sin(glitchProgress * Math.PI * 4) * 0.3;
 cube.scale.x = 1.0 + distort;
 cube.scale.y = 1.0 - distort * 0.5;
 cube.scale.z = 1.0 + distort * 0.5;
 
 // Flash emissive
 if (cube.material) {
 cube.material.emissiveIntensity = 0.5 + Math.sin(glitchProgress * Math.PI) * 2.0;
 }
 } else if (glitchAge < 0.25 && cube.scale.x !== 1.0) {
 // Snap to final shape
 cube.scale.set(1.0, 1.0, 1.0);
 if (cube.material) {
 cube.material.emissiveIntensity = 0.5;
 }
 }
 }
 });
 }
 
 // Draw dotted lines between RGB cubes (forming cube edges) ONCE (30s)
 if (sequenceTime >= 30 && !addressScene.userData.linesCreated) {
 addressScene.userData.linesCreated = true;
 addressScene.userData.connectionLines = [];
 console.log('?? Creating procedural connection lines...');
 
 // Build grid lookup for immediate neighbors
 const gridMap = new Map();
 cubes.forEach(cube => {
 if (cube.userData.gridX !== undefined) {
 const key = `${cube.userData.gridX},${cube.userData.gridY},${cube.userData.gridZ}`;
 gridMap.set(key, cube);
 }
 });
 
 // Track connections to avoid duplicates
 const connections = new Set();
 let lineCount = 0;
 
 // Draw lines to immediate neighbors for RGB cubes (ONCE)
 cubes.forEach(cube => {
 if (cube.userData.gridX !== undefined && cube.userData.currentColor && cube.userData.hasTransformed) {
 const gx = cube.userData.gridX;
 const gy = cube.userData.gridY;
 const gz = cube.userData.gridZ;
 
 // Check only positive direction neighbors to avoid duplicates (right, up, forward)
 const neighbors = [
 { key: `${gx+1},${gy},${gz}`, axis: 'x' },
 { key: `${gx},${gy+1},${gz}`, axis: 'y' },
 { key: `${gx},${gy},${gz+1}`, axis: 'z' }
 ];
 
 neighbors.forEach(neighbor => {
 const neighborCube = gridMap.get(neighbor.key);
 if (neighborCube && neighborCube.userData.currentColor && neighborCube.userData.hasTransformed) {
 const connectionKey = `${cube.userData.gridX},${cube.userData.gridY},${cube.userData.gridZ}-${neighborCube.userData.gridX},${neighborCube.userData.gridY},${neighborCube.userData.gridZ}`;
 if (!connections.has(connectionKey)) {
 connections.add(connectionKey);
 
 // Use average color of both cubes
 let lineColor;
 if (cube.userData.currentColor === 'yellow') lineColor = 0xffff00;
 else if (cube.userData.currentColor === 'blue') lineColor = 0x0088ff;
 else if (cube.userData.currentColor === 'red') lineColor = 0xff0000;
 else lineColor = 0x00ff00;
 
 const points = [cube.position, neighborCube.position];
 const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
 const lineMat = new THREE.LineDashedMaterial({
 color: lineColor,
 dashSize: 0.12,
 gapSize: 0.08,
 transparent: true,
 opacity: 0.5
 });
 const line = new THREE.Line(lineGeo, lineMat);
 line.computeLineDistances();
 addressScene.add(line);
 addressScene.userData.connectionLines.push(line);
 lineCount++;
 }
 }
 });
 }
 });
 console.log(`? Created ${lineCount} connection lines (procedural, once)`);
 }
 
 // Continue camera rotation after initial rotation (but stop during white room)
 if (sequenceTime >= 20 && sequenceTime < 50) {
 const orbitTime = sequenceTime - 20;
 const orbitRadius = 90; // Larger radius for 26x26x26 grid
 addressCamera.position.x = Math.cos(orbitTime * 0.15) * orbitRadius;
 addressCamera.position.z = Math.sin(orbitTime * 0.15) * orbitRadius;
 addressCamera.position.y = 25 + Math.sin(orbitTime * 0.08) * 10;
 addressCamera.lookAt(0, 0, 0);
 }
 
 // Apply mouse look in white room
 if (isMouseLookActive && sequenceTime > 55) {
 // Apply rotation to camera
 const direction = new THREE.Vector3();
 direction.x = Math.sin(targetRotationY) * Math.cos(targetRotationX);
 direction.y = Math.sin(targetRotationX);
 direction.z = Math.cos(targetRotationY) * Math.cos(targetRotationX);
 direction.normalize();
 
 const lookAtPoint = new THREE.Vector3().addVectors(
 addressCamera.position,
 direction.multiplyScalar(10)
 );
 addressCamera.lookAt(lookAtPoint);
 
 if (Math.floor(sequenceTime) % 3 === 0 && Math.floor(sequenceTime) !== Math.floor(sequenceTime - delta)) {
 console.log(`??? Mouse look active - rotX: ${targetRotationX.toFixed(2)}, rotY: ${targetRotationY.toFixed(2)}`);
 }
 } else if (sequenceTime >= 55 && !isMouseLookActive) {
 // Point at black hole when not actively looking
 addressCamera.lookAt(0, 0, 0);
 }
 
 // Phase 5: Transform RGB shapes back to white cubes (36-40s)
 if (sequenceTime >= 36 && sequenceTime < 40) {
 cubes.forEach((cube, i) => {
 if (cube.userData.hasTransformed && !cube.userData.zapToWhite) {
 cube.userData.zapToWhite = true;
 
 // Quick zap animation
 const originalScale = { x: cube.scale.x, y: cube.scale.y, z: cube.scale.z };
 cube.scale.multiplyScalar(1.5);
 
 setTimeout(() => {
 const pos = cube.position.clone();
 const userData = { ...cube.userData };
 
 addressScene.remove(cube);
 const whiteCube = new THREE.Mesh(cubeGeo, whiteMat.clone());
 whiteCube.position.copy(pos);
 whiteCube.scale.set(originalScale.x, originalScale.y, originalScale.z);
 whiteCube.userData = userData;
 whiteCube.userData.isWhite = true;
 addressScene.add(whiteCube);
 cubes[i] = whiteCube;
 }, 100);
 }
 });
 }
 
 // Phase 6: Collapse cubes to center - NO rotation
 if (sequenceTime >= 40 && sequenceTime < 44) {
 const pullStrength = (sequenceTime - 40) / 4;
 cubes.forEach(cube => {
 cube.position.x = THREE.MathUtils.lerp(cube.position.x, 0, delta * pullStrength * 2);
 cube.position.y = THREE.MathUtils.lerp(cube.position.y, 0, delta * pullStrength * 2);
 cube.position.z = THREE.MathUtils.lerp(cube.position.z, 0, delta * pullStrength * 2);
 });
 }
 
 // Phase 7: Merge into single white rounded cube with bloom (44-50s)
 if (sequenceTime >= 44 && sequenceTime < 50) {
 const whiteness = Math.min(1, (sequenceTime - 44) / 3);
 addressBloom.strength = 1.2 + whiteness * 2.5; // Increase bloom more
 
 cubes.forEach((cube, i) => {
 if (cube.material) {
 // Fade to white
 cube.material.color.r = 1;
 cube.material.color.g = 1;
 cube.material.color.b = 1;
 cube.material.emissive.r = 1;
 cube.material.emissive.g = 1;
 cube.material.emissive.b = 1;
 cube.material.emissiveIntensity = 0.5 + whiteness * 1.0;
 
 // Shrink all but the center mass
 if (i > 15) {
 cube.scale.multiplyScalar(0.96);
 cube.material.opacity *= 0.95;
 } else {
 // First cubes grow MUCH LARGER
 const growth = 1 + (sequenceTime - 44) * 0.8;
 cube.scale.setScalar(growth);
 }
 }
 });
 }
 
 // Phase 8: Expand into white room interior (50-55s)
 if (sequenceTime >= 50 && sequenceTime < 55) {
 if (!addressScene.userData.roomCreated) {
 addressScene.userData.roomCreated = true;
 console.log('?? Creating FPS white room interior with rounded corners and internal lighting');
 
 // Remove all connection lines
 if (addressScene.userData.connectionLines) {
 addressScene.userData.connectionLines.forEach(line => {
 addressScene.remove(line);
 if (line.geometry) line.geometry.dispose();
 if (line.material) line.material.dispose();
 });
 addressScene.userData.connectionLines = [];
 console.log('??? Connection lines removed for white room');
 }
 
 addressScene.userData.blackCubeSpawnTimer = 0;
 addressScene.userData.blackCubes = [];
 
 // Create white room interior with rounded corners - DIMLY LIT
 const roomSize = 50;
 const roomRadius = 4;
 const roomGeo = new RoundedBoxGeometry(roomSize, roomSize, roomSize, 16, roomRadius);
 const roomMat = new THREE.MeshStandardMaterial({
 color: 0xcccccc, // Slightly gray
 side: THREE.BackSide,
 roughness: 0.9,
 metalness: 0.05,
 emissive: 0x333333, // Very dim emissive
 emissiveIntensity: 0.05 // Very low
 });
 const room = new THREE.Mesh(roomGeo, roomMat);
 addressScene.add(room);
 addressScene.userData.roomMesh = room; // Store reference
 
 // Add MINIMAL internal room lighting - mostly dark
 const roomLight1 = new THREE.PointLight(0xffffff, 0.2, 40);
 roomLight1.position.set(0, 15, 0);
 addressScene.add(roomLight1);
 
 const roomLight2 = new THREE.PointLight(0xffffff, 0.2, 40);
 roomLight2.position.set(0, -15, 0);
 addressScene.add(roomLight2);
 
 console.log('? White room created with DIM lighting');
 
 // Further reduce ambient lighting to let black hole dominate
 ambientLight.intensity = 0.1;
 pointLight.intensity = 0.1;
 pointLight2.intensity = 0.2;
 pointLight3.intensity = 0.2;
 
 console.log('?? Room created - dimming ambient lights for black hole visibility');
 
 console.log('? White room created with internal lighting');
 }
 
 // Move camera inside - FPS position, initially pointing AT the black hole
 if (!addressScene.userData.cameraMovingToRoom) {
 addressScene.userData.cameraMovingToRoom = true;
 console.log('?? Camera moving into white room, will point at black hole at (0, 0, 0)');
 }
 
 const moveProgress = (sequenceTime - 50) / 5;
 addressCamera.position.x = THREE.MathUtils.lerp(12, 0, moveProgress);
 addressCamera.position.y = THREE.MathUtils.lerp(10, 2, moveProgress);
 addressCamera.position.z = THREE.MathUtils.lerp(20, 15, moveProgress);
 
 // Always point at black hole center during this phase
 addressCamera.lookAt(0, 0, 0);
 
 if (Math.floor(sequenceTime) % 2 === 0 && Math.floor(sequenceTime) !== Math.floor(sequenceTime - delta)) {
 console.log(`?? Camera pos: (${addressCamera.position.x.toFixed(1)}, ${addressCamera.position.y.toFixed(1)}, ${addressCamera.position.z.toFixed(1)}) -> looking at (0, 0, 0)`);
 }
 
 addressScene.userData.whiteRoomCreated = true;
 }
 
 // Phase 9: Create 3D black hole at center (55s+)
 if (sequenceTime >= 55 && !addressScene.userData.blackHoleCreated) {
 addressScene.userData.blackHoleCreated = true;
 console.log('??? Creating 3D black hole sphere at center');
 
 // Voxelized black hole - dark cube sphere (MORE visible)
 const voxelSize = 0.4;
 const voxelGeo = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);
 const blackVoxelMat = new THREE.MeshStandardMaterial({
 color: 0x222222, // More visible gray
 emissive: 0x110000, // Slight red emissive
 emissiveIntensity: 0.3,
 roughness: 0.9,
 metalness: 0.1,
 transparent: false
 });
 
 const voxelSphere = new THREE.Group();
 const baseRadius = 3.0; // Larger
 const voxelCount = 400; // More voxels
 
 for (let i = 0; i < voxelCount; i++) {
 const phi = Math.acos(-1 + (2 * i) / voxelCount);
 const theta = Math.sqrt(voxelCount * Math.PI) * phi;
 
 const x = baseRadius * Math.cos(theta) * Math.sin(phi);
 const y = baseRadius * Math.sin(theta) * Math.sin(phi);
 const z = baseRadius * Math.cos(phi);
 
 const voxel = new THREE.Mesh(voxelGeo, blackVoxelMat.clone());
 voxel.position.set(x, y, z);
 voxel.lookAt(0, 0, 0);
 voxel.userData.baseRadius = baseRadius;
 voxel.userData.phi = phi;
 voxel.userData.theta = theta;
 voxelSphere.add(voxel);
 }
 
 addressScene.add(voxelSphere);
 addressScene.userData.voxelSphere = voxelSphere;
 addressScene.userData.voxelSpherePhase = 0;
 
 // Event horizon glow - EXTREMELY bright ring
 const ringGeo = new THREE.TorusGeometry(4.0, 0.5, 16, 100);
 const ringMat = new THREE.MeshBasicMaterial({
 color: 0xff4400,
 transparent: false,
 opacity: 1.0
 });
 const eventHorizon = new THREE.Mesh(ringGeo, ringMat);
 eventHorizon.position.set(0, 0, 0);
 eventHorizon.rotation.x = Math.PI / 2;
 addressScene.add(eventHorizon);
 addressScene.userData.eventHorizon = eventHorizon;
 
 // Add VERY strong point lights at black hole for maximum visibility
 const blackHoleLight1 = new THREE.PointLight(0xff2200, 10.0, 30);
 blackHoleLight1.position.set(0, 0, 0);
 addressScene.add(blackHoleLight1);
 
 const blackHoleLight2 = new THREE.PointLight(0xff6600, 8.0, 25);
 blackHoleLight2.position.set(0, 5, 0);
 addressScene.add(blackHoleLight2);
 
 const blackHoleLight3 = new THREE.PointLight(0xff8800, 6.0, 20);
 blackHoleLight3.position.set(5, 0, 0);
 addressScene.add(blackHoleLight3);
 
 addressScene.userData.blackHoleLight = blackHoleLight1;
 
 console.log('??? Black hole created at (0, 0, 0)');
 console.log('??? Black hole lights: L1=' + blackHoleLight1.intensity + ', L2=' + blackHoleLight2.intensity + ', L3=' + blackHoleLight3.intensity);
 console.log('??? Ambient light:', ambientLight.intensity);
 
 // BLACK CORE - Central black voxel sphere with negative pulsing effect
 const blackCoreGeo = new THREE.BoxGeometry(0.25, 0.25, 0.25);
 const blackCoreMat = new THREE.MeshBasicMaterial({
 color: 0x000000,
 transparent: true,
 opacity: 1.0
 });
 
 const blackCore = new THREE.Group();
 const coreRadius = 1.5; // Smaller than outer sphere
 const coreVoxelCount = 200;
 
 for (let i = 0; i < coreVoxelCount; i++) {
 const phi = Math.acos(-1 + (2 * i) / coreVoxelCount);
 const theta = Math.sqrt(coreVoxelCount * Math.PI) * phi;
 
 const x = coreRadius * Math.cos(theta) * Math.sin(phi);
 const y = coreRadius * Math.sin(theta) * Math.sin(phi);
 const z = coreRadius * Math.cos(phi);
 
 const voxel = new THREE.Mesh(blackCoreGeo, blackCoreMat.clone());
 voxel.position.set(x, y, z);
 voxel.lookAt(0, 0, 0);
 voxel.userData.baseRadius = coreRadius;
 voxel.userData.phi = phi;
 voxel.userData.theta = theta;
 voxel.renderOrder = 2000; // Individual voxels render on top
 voxel.material.depthTest = false; // Always visible
 voxel.material.depthWrite = false;
 blackCore.add(voxel);
 }
 
 blackCore.renderOrder = 2000; // Render on top of everything
 addressScene.add(blackCore);
 addressScene.userData.blackCore = blackCore;
 console.log('??? Black core created with renderOrder=2000, depthTest=false');
 addressScene.userData.blackCorePhase = 0;
 addressScene.userData.blackCorePulse = 0;
 
 console.log('?? Black core sphere created with', coreVoxelCount, 'voxels');
 console.log('? Voxelized black hole created');
 console.log('?? Outer voxel count:', voxelSphere.children.length);
 console.log('?? Core voxel count:', blackCore.children.length);
 console.log('?? Event horizon position:', eventHorizon.position);
 console.log('?? Black hole light intensity:', blackHoleLight1.intensity);
 
 // Accretion disk particles
 const particleCount = 200;
 const particleGeo = new THREE.BufferGeometry();
 const positions = new Float32Array(particleCount * 3);
 const colors = new Float32Array(particleCount * 3);
 
 for (let i = 0; i < particleCount; i++) {
 const angle = Math.random() * Math.PI * 2;
 const radius = 4 + Math.random() * 3;
 positions[i * 3] = Math.cos(angle) * radius;
 positions[i * 3 + 1] = (Math.random() - 0.5) * 0.5;
 positions[i * 3 + 2] = Math.sin(angle) * radius;
 
 const heat = 1 - (radius - 4) / 3;
 colors[i * 3] = 1;
 colors[i * 3 + 1] = heat * 0.6;
 colors[i * 3 + 2] = heat * 0.2;
 }
 
 particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
 particleGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
 
 const particleMat = new THREE.PointsMaterial({
 size: 0.35,
 vertexColors: true,
 transparent: true,
 opacity: 1.0,
 blending: THREE.AdditiveBlending,
 sizeAttenuation: true,
 depthWrite: false
 });
 
 const particles = new THREE.Points(particleGeo, particleMat);
 addressScene.add(particles);
 addressScene.userData.accretionDisk = particles;
 console.log('? Accretion disk particles added to scene');
 
 console.log('? Black hole with accretion disk created');
 console.log('?? Scene objects:', addressScene.children.length);
 }
 
 // Breathing voxelized black hole (outer sphere)
 if (addressScene.userData.voxelSphere) {
 addressScene.userData.voxelSpherePhase += delta * 2;
 const breathe = Math.sin(addressScene.userData.voxelSpherePhase) * 0.2 + 1;
 
 addressScene.userData.voxelSphere.children.forEach(voxel => {
 const br = voxel.userData.baseRadius;
 const phi = voxel.userData.phi;
 const theta = voxel.userData.theta;
 const radius = br * breathe;
 
 voxel.position.x = radius * Math.cos(theta) * Math.sin(phi);
 voxel.position.y = radius * Math.sin(theta) * Math.sin(phi);
 voxel.position.z = radius * Math.cos(phi);
 });
 
 addressScene.userData.voxelSphere.rotation.y += delta * 0.2;
 
 // PULSATING BLOOM - lights breathe with black hole to illuminate room
 if (addressScene.userData.blackHoleLight) {
 const lightPulse = breathe; // Follow breathing pattern
 addressScene.userData.blackHoleLight.intensity = 8.0 + lightPulse * 6.0; // 8-14 intensity
 addressBloom.strength = 0.6 + lightPulse * 0.4; // 0.6-1.0 bloom
 
 // Illuminate room walls with pulsating bloom
 if (addressScene.userData.roomMesh && addressScene.userData.roomMesh.material) {
 addressScene.userData.roomMesh.material.emissiveIntensity = 0.05 + lightPulse * 0.08; // Subtle pulse
 }
 }
 
 // Debug log every 5 seconds
 if (Math.floor(sequenceTime) % 5 === 0 && Math.floor(sequenceTime) !== Math.floor(sequenceTime - delta)) {
 console.log(`??? Black hole visible: voxels=${addressScene.userData.voxelSphere.children.length}, breathe=${breathe.toFixed(2)}, bloom=${addressBloom.strength.toFixed(2)}`);
 }
 }
 
 // Pulsing BLACK CORE - inverse pulse with negative black-light gradient
 if (addressScene.userData.blackCore) {
 addressScene.userData.blackCorePhase += delta * 3; // Faster pulse
 addressScene.userData.blackCorePulse += delta * 4;
 
 // Inverse pulse - contracts when outer breathes out
 const corePulse = Math.sin(addressScene.userData.blackCorePhase) * -0.15 + 0.85; // 0.7 to 1.0
 
 addressScene.userData.blackCore.children.forEach((voxel, i) => {
 const br = voxel.userData.baseRadius;
 const phi = voxel.userData.phi;
 const theta = voxel.userData.theta;
 const radius = br * corePulse;
 
 voxel.position.x = radius * Math.cos(theta) * Math.sin(phi);
 voxel.position.y = radius * Math.sin(theta) * Math.sin(phi);
 voxel.position.z = radius * Math.cos(phi);
 
 // Pulsing opacity creating "negative light" effect
 const wave = Math.sin(addressScene.userData.blackCorePulse + i * 0.1);
 const distFromCenter = Math.sqrt(voxel.position.x**2 + voxel.position.y**2 + voxel.position.z**2);
 const normalizedDist = distFromCenter / (br * corePulse); // 0 at center, 1 at edge
 
 // Darker at center, lighter at edges (inverted gradient)
 voxel.material.opacity = 0.9 + (normalizedDist * 0.1) + (wave * 0.05);
 });
 
 // Counter-rotate to outer sphere
 addressScene.userData.blackCore.rotation.y -= delta * 0.3;
 }
 
 if (addressScene.userData.eventHorizon) {
 addressScene.userData.eventHorizon.rotation.z += delta * 0.8;
 }
 if (addressScene.userData.accretionDisk) {
 addressScene.userData.accretionDisk.rotation.y += delta * 0.5;
 }
 
 // Continuously spawn black cubes
 if (sequenceTime > 55) {
 if (!addressScene.userData.blackCubeSpawnTimer) {
 addressScene.userData.blackCubeSpawnTimer = 0;
 addressScene.userData.blackCubes = [];
 }
 
 addressScene.userData.blackCubeSpawnTimer += delta;
 if (addressScene.userData.blackCubeSpawnTimer > 0.15) {
 addressScene.userData.blackCubeSpawnTimer = 0;
 
 // Spawn new black cube far away
 const angle = Math.random() * Math.PI * 2;
 const elevation = (Math.random() - 0.5) * Math.PI;
 const distance = 30 + Math.random() * 15;
 
 const blackCubeMat = new THREE.MeshStandardMaterial({
 color: 0x0a0a0a,
 transparent: true,
 opacity: 0.95,
 emissive: 0x0a0a0a,
 emissiveIntensity: 0.1
 });
 
 const blackCube = new THREE.Mesh(cubeGeo, blackCubeMat);
 blackCube.position.set(
 Math.cos(angle) * Math.cos(elevation) * distance,
 Math.sin(elevation) * distance,
 Math.sin(angle) * Math.cos(elevation) * distance
 );
 blackCube.userData.beingSucked = true;
 blackCube.userData.suckStartTime = sequenceTime;
 blackCube.userData.spiralAngle = angle;
 blackCube.userData.spiralSpeed = 1.0 + Math.random() * 2.0;
 blackCube.scale.set(0.6, 0.6, 0.6);
 
 addressScene.add(blackCube);
 addressScene.userData.blackCubes.push(blackCube);
 }
 }
 
 // Spaghettification - black cubes get sucked into black hole
 if (addressScene.userData.blackCubes && addressScene.userData.blackCubes.length > 0) {
 const blackCubes = addressScene.userData.blackCubes;
 for (let i = blackCubes.length - 1; i >= 0; i--) {
 const cube = blackCubes[i];
 const elapsed = sequenceTime - cube.userData.suckStartTime;
 const distToCenter = Math.sqrt(
 cube.position.x ** 2 + 
 cube.position.y ** 2 + 
 cube.position.z ** 2
 );
 
 // Acceleration toward center - increasing speed
 const acceleration = 1 + elapsed * 1.2;
 const pullForce = delta * acceleration * 10;
 
 // Spiral motion
 cube.userData.spiralAngle += delta * cube.userData.spiralSpeed * (1 + elapsed * 0.8);
 const spiralRadius = Math.max(0.1, distToCenter * 0.15);
 const spiralX = Math.cos(cube.userData.spiralAngle) * spiralRadius;
 const spiralZ = Math.sin(cube.userData.spiralAngle) * spiralRadius;
 
 // Pull toward center with spiral
 cube.position.x = THREE.MathUtils.lerp(cube.position.x, spiralX, pullForce);
 cube.position.y = THREE.MathUtils.lerp(cube.position.y, 0, pullForce * 0.95);
 cube.position.z = THREE.MathUtils.lerp(cube.position.z, spiralZ, pullForce);
 
 // Spaghettification stretch - extreme elongation
 if (distToCenter < 10) {
 const stretchFactor = 1 + (10 - distToCenter) * 0.5;
 cube.scale.y = 0.6 * stretchFactor;
 cube.scale.x = Math.max(0.03, 0.6 / Math.sqrt(stretchFactor));
 cube.scale.z = Math.max(0.03, 0.6 / Math.sqrt(stretchFactor));
 
 // Orient along spiral toward center
 const targetPos = new THREE.Vector3(spiralX, 0, spiralZ);
 cube.lookAt(targetPos);
 }
 
 // Event horizon burst - tri-chromatic light explosion
 if (distToCenter < 4.0 && !cube.userData.hasBurst) {
 cube.userData.hasBurst = true;
 console.log('?? Tri-chromatic burst at event horizon!');
 
 // Create tri-chromatic light burst
 const colors = [
 { hex: 0xff0000, name: 'red' },
 { hex: 0x00ff00, name: 'green' },
 { hex: 0x0000ff, name: 'blue' }
 ];
 colors.forEach((colorData, idx) => {
 const lightGeo = new THREE.SphereGeometry(0.3, 16, 16);
 const lightMat = new THREE.MeshBasicMaterial({
 color: colorData.hex,
 transparent: true,
 opacity: 1
 });
 const light = new THREE.Mesh(lightGeo, lightMat);
 light.position.copy(cube.position);
 
 const angle = (idx / 3) * Math.PI * 2 + Math.random() * 0.5;
 const speed = 3 + Math.random() * 2;
 light.userData.velocity = new THREE.Vector3(
 Math.cos(angle) * speed,
 (Math.random() - 0.5) * speed * 0.8,
 Math.sin(angle) * speed
 );
 light.userData.life = 1.0;
 light.userData.colorName = colorData.name;
 
 addressScene.add(light);
 if (!addressScene.userData.lightBursts) {
 addressScene.userData.lightBursts = [];
 }
 addressScene.userData.lightBursts.push(light);
 });
 }
 
 // Remove if too close to center
 if (distToCenter < 0.5) {
 addressScene.remove(cube);
 blackCubes.splice(i, 1);
 }
 }
 }
 
 // Animate light bursts - expand and fade
 if (addressScene.userData.lightBursts) {
 for (let i = addressScene.userData.lightBursts.length - 1; i >= 0; i--) {
 const light = addressScene.userData.lightBursts[i];
 light.position.add(light.userData.velocity.clone().multiplyScalar(delta));
 light.userData.life -= delta * 0.4;
 light.material.opacity = light.userData.life;
 light.scale.multiplyScalar(1 + delta * 3);
 
 if (light.userData.life <= 0) {
 addressScene.remove(light);
 addressScene.userData.lightBursts.splice(i, 1);
 }
 }
 }
 
 // Render the scene
 addressComposer.render();
 
 // Continue indefinitely to keep rendering the room and black hole
 requestAnimationFrame(animateAddresses);
 }
 
 console.log('?? Starting animation loop');
 console.log('?? Camera position:', addressCamera.position);
 console.log('?? Scene children:', addressScene.children.length);
 animateAddresses();
 }
 
 function triggerVictory(frame) {
 console.log('?? VICTORY!');
 if (!frame) return;

 // Set madness flag
 madnessActivated = true;
 rPromptHoverCount = 0; // Reset for "Don't click" messages

 // HALT R sequence completely - stop matrix and speech
 rInfectionHalted = true;
 speechRActive = false;
 rInfectionProcessing = false;
 rInfectionStarted = false;
 
 // Stop all matrix intervals and timers
 if (matrixInterval) {
 clearInterval(matrixInterval);
 matrixInterval = null;
 }
 if (matrixUpdateInterval) {
 clearInterval(matrixUpdateInterval);
 matrixUpdateInterval = null;
 }
 if (matrixAnimationFrameId) {
 cancelAnimationFrame(matrixAnimationFrameId);
 matrixAnimationFrameId = null;
 }
 if (cascadeInterval) {
 clearInterval(cascadeInterval);
 cascadeInterval = null;
 }
 if (matrixHeavyTimers && matrixHeavyTimers.length) {
 matrixHeavyTimers.forEach(id => clearTimeout(id));
 matrixHeavyTimers = [];
 }
 
 // Remove matrix container and R hint
 const matrixContainer = document.getElementById('matrixContainer');
 if (matrixContainer) {
 matrixContainer.remove();
 }
 const rHint = document.getElementById('rHint');
 if (rHint) {
 rHint.remove();
 }
 
 // Stop R text-to-speech immediately
 if (speechRTimeout) {
 clearTimeout(speechRTimeout);
 speechRTimeout = null;
 }
 if (speechRGuardTimeout) {
 clearTimeout(speechRGuardTimeout);
 speechRGuardTimeout = null;
 }
 if (hasSpeechSynthesis) {
 try { window.speechSynthesis.cancel(); } catch (err) {}
 }
 console.log('?? HALTED R sequence (matrix + speech)');

 // Play "Oh." text-to-speech
 setTimeout(() => {
 if (hasSpeechSynthesis && speechRVoice) {
 const ohUtterance = new SpeechSynthesisUtterance('Oh.');
 ohUtterance.voice = speechRVoice;
 ohUtterance.rate = 0.9;
 ohUtterance.pitch = 1.0;
 ohUtterance.volume = 0.92;
 window.speechSynthesis.speak(ohUtterance);
 console.log('??? Playing "Oh." TTS');
 }
 }, 300);

 const existing = document.getElementById('initializeOverlay');
 if (existing) existing.remove();

 const overlay = document.createElement('div');
 overlay.id = 'initializeOverlay';
 overlay.style.cssText = 'position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none; z-index:60;';

 const panel = document.createElement('div');
 panel.style.cssText = 'pointer-events:auto; text-align:center; background:rgba(0,0,0,0.88); border:2px solid #0f0; padding:26px 34px; box-shadow:0 0 18px rgba(0,255,160,0.25); font-family:"Courier New", monospace; color:#0f0; min-width:260px;';

 const heading = document.createElement('div');
 heading.textContent = 'madness.loom located';
 heading.style.cssText = 'font-size:13px; letter-spacing:0.14em; text-transform:uppercase; margin-bottom:14px;';

 const button = document.createElement('button');
 button.style.cssText = 'font-family:"Courier New", monospace; font-size:15px; letter-spacing:0.38em; padding:16px 34px; color:#072c07; background:#19ff6b; border:2px solid #19ff6b; cursor:pointer; text-transform:uppercase; box-shadow:0 0 18px rgba(25,255,107,0.45); transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease, color 0.2s ease; pointer-events:auto; position:relative;';
 
 // Create button content with text and square dots
 const buttonText = document.createElement('span');
 buttonText.textContent = 'INITIALIZE ?';
 buttonText.style.cssText = 'position:relative; z-index:1;';
 
 // Create square dots container
 const dotsContainer = document.createElement('span');
 dotsContainer.style.cssText = 'position:absolute; left:10px; top:50%; transform:translateY(-50%); display:flex; gap:4px; z-index:0;';
 
 // Add 3 square dots
 for (let i = 0; i < 3; i++) {
 const dot = document.createElement('span');
 dot.style.cssText = `width:6px; height:6px; background:#072c07; opacity:0.4; animation:pulse-dot 1.5s ease-in-out ${i * 0.2}s infinite;`;
 dotsContainer.appendChild(dot);
 }
 
 button.appendChild(dotsContainer);
 button.appendChild(buttonText);
 
 // Add CSS animation for dots if not already present
 if (!document.getElementById('dot-pulse-animation')) {
 const style = document.createElement('style');
 style.id = 'dot-pulse-animation';
 style.textContent = `
 @keyframes pulse-dot {
 0%, 100% { opacity: 0.2; transform: scale(1); }
 50% { opacity: 0.6; transform: scale(1.3); }
 }
 `;
 document.head.appendChild(style);
 }

 button.addEventListener('mouseenter', () => {
 if (button.disabled) return;
 button.style.boxShadow = '0 0 24px rgba(25,255,140,0.55)';
 button.style.transform = 'translateY(-2px)';
 });
 button.addEventListener('mouseleave', () => {
 if (button.disabled) return;
 button.style.boxShadow = '0 0 18px rgba(25,255,107,0.45)';
 button.style.transform = 'translateY(0)';
 });

 const status = document.createElement('div');
 const phases = ['calibrate interface', 'prime uplink', 'commence breach'];
 status.style.cssText = 'margin-top:12px; font-size:12px; letter-spacing:0.2em; text-transform:uppercase; opacity:0.75;';
 status.textContent = phases[0];

 panel.appendChild(heading);
 panel.appendChild(button);
 panel.appendChild(status);
 overlay.appendChild(panel);
 frame.appendChild(overlay);

 const visiCalc = document.getElementById('visicalc');
 const stageClasses = ['barrel-stage-1', 'barrel-stage-2', 'barrel-stage-3'];
 let clickCount = 0;

 function applyDistortion(stageIndex) {
 if (!visiCalc) return;
 visiCalc.classList.remove('screen-shatter');
 stageClasses.forEach(cls => visiCalc.classList.remove(cls));
 void visiCalc.offsetWidth;
 visiCalc.classList.add(stageClasses[stageIndex]);
 }
 
 function triggerMatrixIntensification(intensity) {
 console.log('?? Matrix intensification level:', intensity);
 
 // Create or intensify matrix rain
 let matrixContainer = document.getElementById('matrixIntensityOverlay');
 if (!matrixContainer) {
 matrixContainer = document.createElement('div');
 matrixContainer.id = 'matrixIntensityOverlay';
 matrixContainer.style.cssText = 'position:fixed; inset:0; pointer-events:none; z-index:65; overflow:hidden;';
 document.body.appendChild(matrixContainer);
 }
 
 // Clear existing columns
 matrixContainer.innerHTML = '';
 
 // Number of columns increases with intensity
 const columnCount = 40 + (intensity * 25); // More columns
 const duration = 2.5 + (intensity * 0.5); // Longer duration: 3-4s
 const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%&*+=';
 
 for (let i = 0; i < columnCount; i++) {
 const column = document.createElement('div');
 column.style.cssText = `
 position:absolute;
 top:${-100 - Math.random() * 100}%;
 left:${Math.random() * 100}%;
 font-family:'Courier New', monospace;
 font-size:${14 + Math.random() * 10}px;
 color:#0f0;
 text-shadow:0 0 ${6 + intensity * 6}px #0f0, 0 0 ${3 + intensity * 3}px #0f0;
 opacity:${0.65 + intensity * 0.12};
 white-space:nowrap;
 animation: matrixFall ${duration}s linear forwards;
 `;
 
 // Create falling text
 let text = '';
 const length = 10 + Math.floor(Math.random() * 15);
 for (let j = 0; j < length; j++) {
 text += characters[Math.floor(Math.random() * characters.length)] + '<br>';
 }
 column.innerHTML = text;
 matrixContainer.appendChild(column);
 }
 
 // Add CSS animation if not already defined
 if (!document.getElementById('matrixIntensityStyles')) {
 const style = document.createElement('style');
 style.id = 'matrixIntensityStyles';
 style.textContent = `
 @keyframes matrixFall {
 0% { transform: translateY(0); opacity: 0; }
 15% { opacity: 1; }
 85% { opacity: 0.85; }
 100% { transform: translateY(150vh); opacity: 0; }
 }
 `;
 document.head.appendChild(style);
 }
 
 // Remove after animation
 setTimeout(() => {
 if (matrixContainer && matrixContainer.parentNode) {
 matrixContainer.remove();
 }
 }, duration * 1000 + 500);
 }

 function triggerScreenShatter() {
 if (visiCalc) {
 stageClasses.forEach(cls => visiCalc.classList.remove(cls));
 void visiCalc.offsetWidth;
 visiCalc.classList.add('screen-shatter');
 }

 let shatter = document.getElementById('screenShatterOverlay');
 if (shatter) {
 shatter.remove();
 }
 shatter = document.createElement('div');
 shatter.id = 'screenShatterOverlay';
 shatter.className = 'shatter-overlay';
 const cracks = document.createElement('div');
 cracks.className = 'shatter-cracks';
 const pixels = document.createElement('div');
 pixels.className = 'shatter-pixels';
 shatter.appendChild(cracks);
 shatter.appendChild(pixels);
 document.body.appendChild(shatter);

 requestAnimationFrame(() => {
 shatter.classList.add('active');
 setTimeout(() => {
 shatter.classList.add('fade');
 }, 950);
 setTimeout(() => {
 if (shatter.parentNode) {
 shatter.parentNode.removeChild(shatter);
 }
 // Start cell address sequence after shatter
 setTimeout(() => {
 startCellAddressSequence(frame, visiCalc);
 }, 500);
 }, 2400);
 });
 }

 button.addEventListener('click', () => {
 if (button.disabled) return;
 clickCount++;
 barrelClickCount++;
 button.blur();
 button.style.transform = 'translateY(2px)';
 button.style.boxShadow = '0 0 12px rgba(25,255,107,0.35)';
 setTimeout(() => {
 if (!button.disabled) {
 button.style.transform = 'translateY(0)';
 button.style.boxShadow = '0 0 18px rgba(25,255,107,0.45)';
 }
 }, 160);

 const phaseIndex = Math.min(clickCount, phases.length - 1);
 status.textContent = phases[phaseIndex];

 // Play distorted startup sound with increasing distortion per click
 playStartupBassDistorted(clickCount);

 // Make VisiCell frame glow and extend back in Z
 if (visiCalc) {
 const frameEl = document.getElementById('visicalc-frame');
 if (frameEl) {
 const zDepth = barrelClickCount * 20;
 frameEl.style.transform = `perspective(1000px) translateZ(-${zDepth}px)`;
 frameEl.style.boxShadow = `0 0 ${10 + barrelClickCount * 15}px #0f0, inset 0 0 ${5 + barrelClickCount * 10}px #0f0`;
 frameEl.style.borderColor = '#0f0';
 frameEl.style.borderWidth = '3px';
 }
 }

 // Intensify screen glitch and matrix effects between clicks
 const glitchEl = document.getElementById('screenGlitch');
 if (glitchEl && clickCount < 3) {
 glitchEl.classList.add('active');
 setTimeout(() => glitchEl.classList.remove('active'), 800 + clickCount * 200);
 }
 
 // Trigger maximum matrix cascade effect
 if (clickCount < 3) {
 triggerMatrixIntensification(clickCount);
 }

 if (clickCount === 1) {
 applyDistortion(0);
 } else if (clickCount === 2) {
 applyDistortion(1);
 } else {
 applyDistortion(2);
 button.disabled = true;
 button.style.cursor = 'default';
 button.textContent = 'INITIALIZING...';
 button.style.background = '#0d400d';
 button.style.color = '#0f0';
 
 // Maximum glitch and matrix before shatter
 if (glitchEl) {
 glitchEl.classList.add('active');
 setTimeout(() => glitchEl.classList.remove('active'), 1500);
 }
 triggerMatrixIntensification(3);
 
 setTimeout(() => {
 triggerScreenShatter();
 }, 500);
 }
 });
 }
 
 function triggerCelliBackspaceReaction() {
 if (celliBackspaceSequenceStarted || burstAnimStarted) return;

 celliBackspaceSequenceStarted = true;
 celliBackspaceSequenceTime = totalTime;

 const active = voxels.filter(v => v.visible && !v.userData.glitched);
 if (!celliBackspaceFlickerTriggered && active.length) {
 celliBackspaceFlickerTriggered = true;
 const target = active[Math.floor(Math.random() * active.length)];
 if (target) {
 let flickers = 0;
 const mat = target.material;
 const edgeMaterial = target.userData.edges ? target.userData.edges.material : null;
 const baseOpacity = mat.opacity;
 const baseEdgeOpacity = edgeMaterial ? edgeMaterial.opacity : 0;
 const interval = setInterval(() => {
 const on = flickers % 2 === 0;
 mat.opacity = on ? 1 : Math.max(0.1, baseOpacity * 0.2);
 if (edgeMaterial) {
 edgeMaterial.opacity = on ? Math.min(0.9, baseEdgeOpacity + 0.3) : Math.max(0.1, baseEdgeOpacity * 0.3);
 }
 flickers += 1;
 if (flickers > 4) {
 clearInterval(interval);
 mat.opacity = baseOpacity;
 if (edgeMaterial) edgeMaterial.opacity = baseEdgeOpacity;
 }
 }, 90);
 }
 }
 }

 // CELLI glitch and degradation
 function triggerCelliGlitch() {
 if (celliGlitchStarted) return;
 celliGlitchStarted = true;
 
 // Play electrical fritz whir/buzz sound
 if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); window.audioCtx = audioCtx; }
 const now = audioCtx.currentTime;
 
 // Create buzzing electrical sound with multiple oscillators
 const buzz1 = audioCtx.createOscillator();
 const buzz2 = audioCtx.createOscillator();
 const buzz3 = audioCtx.createOscillator();
 const buzzGain = audioCtx.createGain();
 const buzzFilter = audioCtx.createBiquadFilter();
 
 buzz1.type = 'sawtooth';
 buzz2.type = 'square';
 buzz3.type = 'sawtooth';
 
 // Fluctuating frequencies for electrical buzz
 buzz1.frequency.setValueAtTime(120, now);
 buzz2.frequency.setValueAtTime(180, now);
 buzz3.frequency.setValueAtTime(240, now);
 
 // Modulate frequencies to create buzzing effect
 for (let i = 0; i < 20; i++) {
 const t = now + (i * 0.1);
 const freq1 = 120 + Math.random() * 60;
 const freq2 = 180 + Math.random() * 60;
 const freq3 = 240 + Math.random() * 60;
 buzz1.frequency.setValueAtTime(freq1, t);
 buzz2.frequency.setValueAtTime(freq2, t);
 buzz3.frequency.setValueAtTime(freq3, t);
 }
 
 // Band-pass filter for electrical character
 buzzFilter.type = 'bandpass';
 buzzFilter.frequency.setValueAtTime(300, now);
 buzzFilter.Q.setValueAtTime(5, now);
 
 // Envelope: fade in, sustain, fade out
 buzzGain.gain.setValueAtTime(0, now);
 buzzGain.gain.linearRampToValueAtTime(0.08, now + 0.2);
 buzzGain.gain.setValueAtTime(0.08, now + 1.5);
 buzzGain.gain.exponentialRampToValueAtTime(0.001, now + 2.0);
 
 buzz1.connect(buzzFilter);
 buzz2.connect(buzzFilter);
 buzz3.connect(buzzFilter);
 buzzFilter.connect(buzzGain);
 buzzGain.connect(audioCtx.destination);
 
 buzz1.start(now);
 buzz2.start(now);
 buzz3.start(now);
 buzz1.stop(now + 2.0);
 buzz2.stop(now + 2.0);
 buzz3.stop(now + 2.0);
 
 // Start flickering lights
 document.getElementById('screenGlitch').classList.add('active');
 
 // Only keep the middle column of I (letter index 4, middle 3 rows: 1,2,3)
 voxels.forEach((voxel, idx) => {
 const data = voxel.userData;
 const gridX = data.gridX; // Letter index (0=C, 1=E, 2=L, 3=L, 4=I)
 const gridY = data.gridY; // Row index (0=top, 4=bottom)
 const gridCol = data.gridCol; // Column index within letter (0-4)
 
 // Keep only the T shape: top bar (row 0, all cols) and vertical stem (rows 1-4, middle col)
 const keepVoxel = (gridX === 4 && ((gridY === 0) || (gridY >= 1 && gridY <= 4 && gridCol === 2)));
 
 if (!keepVoxel) {
 // Store in stack for later restoration BEFORE marking as glitched
 glitchedVoxelsStack.push(voxel);
 
 // Mark as glitched immediately to prevent updates
 data.glitched = true;
 
 // Start flickering with light gray
 const flickerDelay = Math.random() * 400;
 
 setTimeout(() => {
 // Turn to light gray and start flickering
 voxel.material.color.setRGB(0.6, 0.6, 0.6); // Light gray
 data.edges.material.color.setRGB(0.65, 0.65, 0.65);
 
 const flickerDuration = 400 + Math.random() * 400;
 let flickerCount = 0;
 const maxFlickers = Math.floor(flickerDuration / 60);
 
 const flickerInterval = setInterval(() => {
 flickerCount++;
 const flickerOn = Math.random() > 0.5;
 
 // Flicker between light gray and white, gradually dimming
 const dimFactor = 1 - (flickerCount / maxFlickers) * 0.5;
 if (flickerOn) {
 voxel.material.color.setRGB(0.6 * dimFactor, 0.6 * dimFactor, 0.6 * dimFactor);
 voxel.material.opacity = 0.75 * dimFactor;
 data.edges.material.opacity = 0.5 * dimFactor;
 } else {
 voxel.material.color.setRGB(0.4 * dimFactor, 0.4 * dimFactor, 0.4 * dimFactor);
 voxel.material.opacity = 0.5 * dimFactor;
 data.edges.material.opacity = 0.3 * dimFactor;
 }
 }, 60);
 
 // After flickering, turn dark gray and fade out
 setTimeout(() => {
 clearInterval(flickerInterval);
 
 // Short out - dark gray
 voxel.material.color.setRGB(0.15, 0.15, 0.15); // Dark gray
 data.edges.material.color.setRGB(0.2, 0.2, 0.2);
 voxel.material.opacity = 0.4;
 data.edges.material.opacity = 0.25;
 
 // Fade to black over time
 const fadeStart = Date.now();
 const fadeDuration = 300;
 const fadeInterval = setInterval(() => {
 const fadeProgress = (Date.now() - fadeStart) / fadeDuration;
 if (fadeProgress >= 1) {
 clearInterval(fadeInterval);
 voxel.material.opacity = 0;
 data.edges.material.opacity = 0;
 voxel.visible = false;
 data.edges.visible = false;
 } else {
 voxel.material.opacity = 0.4 * (1 - fadeProgress);
 data.edges.material.opacity = 0.25 * (1 - fadeProgress);
 }
 }, 16);
 }, flickerDuration);
 }, flickerDelay);
 }
 });
 
 // Stop screen glitch after 2 seconds
 setTimeout(() => {
 document.getElementById('screenGlitch').classList.remove('active');
 }, 2000);
 }

 function updatePositions(t) {
 const phase = t < introCfg.rollEnd ? 'roll' :
 t < introCfg.bounceEnd ? 'bounce' :
 t < introCfg.triangleEnd ? 'triangle' :
 t < introCfg.transitionEnd ? 'transition' :
 t < introCfg.normalEnd ? 'normal' :
 t < introCfg.vennEnd ? 'venn' :
 t < introCfg.collapseEnd ? 'collapse' :
 t < introCfg.glitchEnd ? 'glitch' :
 t < introCfg.blackoutEnd ? 'blackout' :
 t < introCfg.loomworksEnd ? 'loomworks' :
 t < introCfg.celliEnd ? 'celli' : 'doorway';

 // Animate bloom, afterimage, and film effects based on phase
 if (phase === 'roll') {
 afterimagePass.uniforms.damp.value = 0.75; // Thin trail
 filmPass.uniforms.noise.value = 0.005; // Minimal grain
 filmPass.uniforms.scanAmp.value = 0.003; // Minimal scanlines
 triMesh.visible = false; // Hide triangle gradient during intro
 } else if (phase === 'bounce') {
 bloomPass.strength = 0.25; // Subtle glow
 afterimagePass.uniforms.damp.value = 0.75; // Thin trail
 filmPass.uniforms.noise.value = 0.005; // Minimal grain
 filmPass.uniforms.scanAmp.value = 0.003; // Minimal scanlines
 triMesh.visible = false; // Hide triangle gradient during intro
 } else if (phase === 'triangle') {
 const triangleProgress = (t - introCfg.bounceEnd) / (introCfg.triangleEnd - introCfg.bounceEnd);
 
 // Sub-phases: form (0-0.35), converge (0.35-0.6), grow (0.6-1.0)
 const formProgress = Math.min(triangleProgress / 0.35, 1.0);
 const convergeStart = 0.35;
 const convergeProgress = triangleProgress > convergeStart ? Math.min((triangleProgress - convergeStart) / 0.25, 1.0) : 0;
 const growStart = 0.6;
 const growProgress = triangleProgress > growStart ? (triangleProgress - growStart) / 0.4 : 0;
 
 // Smooth bloom progression throughout all sub-phases
 bloomPass.strength = THREE.MathUtils.lerp(0.25, 0.7, triangleProgress);
 afterimagePass.uniforms.damp.value = THREE.MathUtils.lerp(0.75, 0.92, triangleProgress);
 filmPass.uniforms.noise.value = THREE.MathUtils.lerp(0.005, 0.015, triangleProgress);
 filmPass.uniforms.scanAmp.value = THREE.MathUtils.lerp(0.003, 0.015, triangleProgress);
 
 // Hide triangle gradient - it makes things look off-center
 triMesh.visible = false;
 } else if (phase === 'transition') {
 const transProgress = (t - introCfg.triangleEnd) / (introCfg.transitionEnd - introCfg.triangleEnd);
 bloomPass.strength = 0.7; // Keep bloom consistent
 afterimagePass.uniforms.damp.value = THREE.MathUtils.lerp(0.92, 0.96, transProgress);
 filmPass.uniforms.noise.value = THREE.MathUtils.lerp(0.015, 0.03, transProgress);
 filmPass.uniforms.scanAmp.value = THREE.MathUtils.lerp(0.015, 0.03, transProgress);
 triMesh.visible = false;
 triMesh.material.opacity = 0;
 } else if (phase === 'normal') {
 const normalT = t - introCfg.transitionEnd;
 const normalDuration = introCfg.normalEnd - introCfg.transitionEnd;
 const convergeDuration = 2.2;
 const pulseDuration = 3.0;
 const totalAnimDuration = convergeDuration + pulseDuration;

 if (normalT < convergeDuration) {
 // Phase 1: Converge - increase bloom
 const convergeProgress = THREE.MathUtils.clamp(normalT / convergeDuration, 0, 1);
 const convergeEased = convergeProgress * convergeProgress * (3 - 2 * convergeProgress);
 bloomPass.strength = THREE.MathUtils.lerp(0.7, 0.9, convergeEased);
 triMesh.visible = false;
 } else if (normalT < totalAnimDuration) {
 // Phase 2: Single pulse - bloom follows expansion
 const pulseT = normalT - convergeDuration;
 const pulseProgress = pulseT / pulseDuration;
 const pulseCycle = Math.sin(pulseProgress * Math.PI);
 
 bloomPass.strength = THREE.MathUtils.lerp(0.9, 0.72, pulseCycle);
 triMesh.visible = pulseCycle > 0.3; // Show triangle during expansion
 triMesh.material.opacity = THREE.MathUtils.clamp(pulseCycle * 1.5, 0, 0.7);
 } else {
 // Phase 3: Brief hold, prepare for venn transition
 const holdT = normalT - totalAnimDuration;
 const holdDuration = normalDuration - totalAnimDuration;
 const holdProgress = holdT / holdDuration;
 
 bloomPass.strength = THREE.MathUtils.lerp(0.9, 0.85, holdProgress);
 triMesh.visible = false;
 }

 afterimagePass.uniforms.damp.value = 0.96;
 filmPass.uniforms.noise.value = 0.03;
 filmPass.uniforms.scanAmp.value = 0.03;
 } else if (phase === 'venn') {
 // Settle into clear venn diagram
 const vennProgress = (t - introCfg.normalEnd) / (introCfg.vennEnd - introCfg.normalEnd);
 bloomPass.strength = THREE.MathUtils.lerp(0.7, 0.8, vennProgress);
 afterimagePass.uniforms.damp.value = THREE.MathUtils.lerp(0.96, 0.7, vennProgress);
 filmPass.uniforms.noise.value = THREE.MathUtils.lerp(0.03, 0.02, vennProgress);
 filmPass.uniforms.scanAmp.value = THREE.MathUtils.lerp(0.03, 0.02, vennProgress);
 triMesh.visible = true;
 triMesh.material.opacity = THREE.MathUtils.lerp(0.7, 0.85, vennProgress);
 } else if (phase === 'collapse') {
 // Grow and collapse into white radiating circle
 const collapseProgress = (t - introCfg.vennEnd) / (introCfg.collapseEnd - introCfg.vennEnd);
 bloomPass.strength = THREE.MathUtils.lerp(0.8, 1.2, collapseProgress);
 afterimagePass.uniforms.damp.value = THREE.MathUtils.lerp(0.7, 0.6, collapseProgress);
 filmPass.uniforms.noise.value = THREE.MathUtils.lerp(0.02, 0.015, collapseProgress);
 filmPass.uniforms.scanAmp.value = THREE.MathUtils.lerp(0.02, 0.015, collapseProgress);
 triMesh.visible = true;
 triMesh.material.opacity = THREE.MathUtils.lerp(0.85, 0.3, collapseProgress);
 
 // Progressive glitch starting mild - show quote only when glitching starts
 if (collapseProgress > 0.15 && !glitchStarted) {
 const quoteEl = document.getElementById('quote');
 quoteEl.style.visibility = 'visible';
 quoteEl.style.opacity = '0.85'; // Start visible
 quoteEl.classList.add('glitch');
 glitchStarted = true;
 quoteShown = true;
 }

 // Increase to medium glitch
 if (collapseProgress > 0.6 && !mediumGlitchStarted) {
 document.getElementById('quote').classList.remove('glitch');
 document.getElementById('quote').classList.add('glitchMedium');
 mediumGlitchStarted = true;
 }
 } else if (phase === 'glitch') {
 // Intense glitch phase
 const glitchProgress = (t - introCfg.collapseEnd) / (introCfg.glitchEnd - introCfg.collapseEnd);
 bloomPass.strength = THREE.MathUtils.lerp(1.2, 0.5, glitchProgress);
 afterimagePass.uniforms.damp.value = 0.3; // Heavy trails
 filmPass.uniforms.noise.value = THREE.MathUtils.lerp(0.015, 0.5, glitchProgress);
 filmPass.uniforms.scanAmp.value = THREE.MathUtils.lerp(0.015, 0.3, glitchProgress);
 triMesh.visible = true;
 triMesh.material.opacity = THREE.MathUtils.lerp(0.3, 0, glitchProgress);
 
 // Intensify text glitch at start of glitch phase
 if (glitchProgress > 0.05 && !intenseGlitchStarted) {
 document.getElementById('quote').classList.remove('glitch', 'glitchMedium');
 document.getElementById('quote').classList.add('glitchIntense');
 intenseGlitchStarted = true;
 }

 if (glitchProgress > 0.25 && !quoteDespairShown) {
 glitchSwapQuote(quoteStates.despair, { duration: 950, onComplete: () => quoteEl.classList.add('quote--loom') });
 quoteDespairShown = true;
 }

 // Screen glitch in middle
 if (glitchProgress > 0.4 && !screenGlitchStarted) {
 document.getElementById('screenGlitch').classList.add('active');
 screenGlitchStarted = true;
 }
 } else if (phase === 'blackout') {
 // Fade to black
 const blackoutProgress = (t - introCfg.glitchEnd) / (introCfg.blackoutEnd - introCfg.glitchEnd);
 bloomPass.strength = THREE.MathUtils.lerp(0.5, 0, blackoutProgress);
 afterimagePass.uniforms.damp.value = 0.1;
 filmPass.uniforms.noise.value = 0;
 filmPass.uniforms.scanAmp.value = 0;
 triMesh.visible = false;
 
 if (!blackoutStarted) {
 // Hide and clean up quote immediately
 const quoteEl = document.getElementById('quote');
 quoteEl.classList.remove('glitch', 'glitchMedium', 'glitchIntense', 'scrambling');
 quoteEl.style.visibility = 'hidden';
 quoteEl.style.opacity = '0';
 quoteEl.classList.remove('quote--loom');
 document.getElementById('screenGlitch').classList.remove('active');
 blackoutStarted = true;
 }
 } else if (phase === 'loomworks') {
 // Show Loomworks text
 bloomPass.strength = 0;
 afterimagePass.uniforms.damp.value = 0;
 filmPass.uniforms.noise.value = 0;
 filmPass.uniforms.scanAmp.value = 0;
 triMesh.visible = false;
 
 if (!loomworksShown) {
 // Ensure quote is definitely hidden before showing loomworks
 const quoteEl = document.getElementById('quote');
 quoteEl.style.visibility = 'hidden';
 quoteEl.style.opacity = '0';
 quoteEl.classList.remove('glitch', 'glitchMedium', 'glitchIntense', 'scrambling');

 startLoomworksReveal();
 loomworksShown = true;
 }
 
 // Play chime jingle at start of this phase
 if (!chimePlayed) {
 // Generate startup chime jingle
 if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); window.audioCtx = audioCtx; }
 const now = audioCtx.currentTime;
 
 // Melodic jingle: C - E - G - C (ascending arpeggio)
 const melody = [
 { freq: 261.63, time: 0.0, duration: 0.25 }, // C4
 { freq: 329.63, time: 0.15, duration: 0.25 }, // E4
 { freq: 392.00, time: 0.30, duration: 0.25 }, // G4
 { freq: 523.25, time: 0.45, duration: 0.5 } // C5 (held)
 ];
 
 melody.forEach((note, idx) => {
 const osc = audioCtx.createOscillator();
 const gain = audioCtx.createGain();
 
 osc.type = 'sine';
 osc.frequency.setValueAtTime(note.freq, now + note.time);
 
 // Envelope
 gain.gain.setValueAtTime(0, now + note.time);
 gain.gain.linearRampToValueAtTime(0.12, now + note.time + 0.02);
 gain.gain.linearRampToValueAtTime(0.08, now + note.time + 0.1);
 gain.gain.exponentialRampToValueAtTime(0.001, now + note.time + note.duration);
 
 osc.connect(gain);
 gain.connect(audioCtx.destination);
 osc.start(now + note.time);
 osc.stop(now + note.time + note.duration);
 });
 
 // Play startup bass after chime completes
 setTimeout(() => {
 playStartupBass();
 }, 1200);
 
 chimePlayed = true;
 }
 
 // Hide Loomworks text near end
 const loomProgress = (t - introCfg.blackoutEnd) / (introCfg.loomworksEnd - introCfg.blackoutEnd);
 if (loomProgress > 0.85) {
 document.getElementById('loomworks').style.opacity = THREE.MathUtils.lerp(1, 0, (loomProgress - 0.85) / 0.15);
 }
 } else if (phase === 'celli') {
 // CELLI phase - lower bloom to reduce wobble
 bloomPass.strength = 0.35;
 afterimagePass.uniforms.damp.value = 0.85;
 filmPass.uniforms.noise.value = 0.008;
 filmPass.uniforms.scanAmp.value = 0.003;
 
 triMesh.visible = false;

 if (!celliStarted) {
 document.getElementById('loomworks').style.display = 'none';
 celliStarted = true;
 }
 } else {
 // Doorway phase - portal opens from vertical bar (lower bloom)
 const doorwayProgress = (t - introCfg.celliEnd) / (introCfg.doorwayEnd - introCfg.celliEnd);
 
 bloomPass.strength = THREE.MathUtils.lerp(0.35, 0.55, Math.min(doorwayProgress * 2, 1));
 afterimagePass.uniforms.damp.value = 0.8;
 filmPass.uniforms.noise.value = 0.005;
 filmPass.uniforms.scanAmp.value = 0.002;
 triMesh.visible = false;
 
 // Wait for all CELLI voxels to finish settling (last one settles around 3-4 seconds)
 const celliAge = t - introCfg.loomworksEnd;
 const allVoxelsSettled = celliAge > 5.0;
 
 if (!doorwayShown && allVoxelsSettled) {
 // Show doorway bar after CELLI finishes
 if (doorwayProgress > 0.05) {
 document.getElementById('doorway').classList.add('visible');
 doorwayShown = true;
 }
 }
 
 if (doorwayShown && !doorwayOpened) {
 // Open doorway after short delay
 if (doorwayProgress > 0.15) {
 document.getElementById('doorway').classList.add('open');
 doorwayOpened = true;
 
 }
 }
 }

 if (phase === 'roll') {
 // Shapes roll in from off-screen to their positions
 const rollProgress = t / introCfg.rollEnd;
 const eased = rollProgress < 0.5 ? 
 2 * rollProgress * rollProgress : 
 1 - Math.pow(-2 * rollProgress + 2, 2) / 2;
 
 // Keep glow visible throughout roll
 bloomPass.strength = 0.4;

 for (let i = 0; i < 3; i++) {
 const targetX = (i - 1) * 0.35;
 const startX = targetX - 2.0; // Start off-screen left
 const x = THREE.MathUtils.lerp(startX, targetX, eased);
 const y = -0.3;
 
 // Calculate rolling rotation based on distance traveled to reach FLAT position
 const distance = x - startX; // Distance rolled
 
 // Calculate rotation for accurate rolling that ends flat
 let rotation = 0;
 if (i === 0) {
 // Square: needs to align flat (multiple of p/2)
 const squarePerimeter = R * 2 * 4;
 const naturalRotation = -(distance / squarePerimeter) * (Math.PI * 2);
 // Snap to nearest p/2 when nearly stopped
 rotation = rollProgress > 0.95 ? Math.round(naturalRotation / (Math.PI / 2)) * (Math.PI / 2) : naturalRotation;
 } else if (i === 1) {
 // Triangle: needs to align flat (multiple of 2p/3)
 const trianglePerimeter = R * 2 * 3;
 const naturalRotation = -(distance / trianglePerimeter) * (Math.PI * 2);
 // Snap to nearest 2p/3 when nearly stopped (flat base)
 rotation = rollProgress > 0.95 ? Math.round(naturalRotation / (Math.PI * 2 / 3)) * (Math.PI * 2 / 3) : naturalRotation;
 } else {
 // Circle: any rotation is "flat"
 rotation = -(distance / (2 * Math.PI * R)) * (Math.PI * 2);
 }
 
 // Store final rotation when reaching target
 if (rollProgress > 0.98) {
 finalRollRotations[i] = rotation;
 }
 
 // Play continuous rolling thunks based on distance
 const rollDist = Math.abs(x - startX);
 const thunkInterval = 0.15; // Play thunk every 0.15 units rolled
 const expectedThunks = Math.floor(rollDist / thunkInterval);
 
 if (expectedThunks > lastThunkTime[i]) {
 playRollingThunk(0.06);
 lastThunkTime[i] = expectedThunks;
 }
 
 spheres[i].position.set(x, y, -i * 0.002);
 spheres[i].rotation.z = rotation;
 spheres[i].scale.set(introCfg.ballSize, introCfg.ballSize, introCfg.ballSize);
 triMat.uniforms.points.value[i].set(x, y);
 
 // Play final landing thunk
 if (!landingSounds[i] && Math.abs(x - targetX) < 0.02) {
 playRollingThunk(0.12);
 landingSounds[i] = true;
 }
 }
 blackHole.visible = false; // Hide during roll-in
 
 } else if (phase === 'bounce') {
 // Sequential bounces: left, then right, then middle
 const bounceT = t - introCfg.rollEnd;
 const baseY = -0.3;
 
 // Keep glow visible during bounce
 bloomPass.strength = 0.4;
 
 for (let i = 0; i < 3; i++) {
 const x = (i - 1) * 0.35;
 let y = baseY;
 
 // Sequence: 0 (left), 2 (right), 1 (middle)
 const bounceOrder = [0, 2, 1];
 const bounceIndex = bounceOrder.indexOf(i);
 const bounceStart = bounceIndex * introCfg.bounceDuration;
 const bounceEnd = bounceStart + introCfg.bounceDuration;
 
 if (bounceT >= bounceStart && bounceT <= bounceEnd) {
 const localT = (bounceT - bounceStart) / introCfg.bounceDuration;
 const bounce = Math.sin(localT * Math.PI) * introCfg.bounceHeight;
 y = baseY + bounce;
 
 // Play thud sounds for jump and land
 if (!window['bounceJump_' + i] && localT < 0.05) {
 playBounceThud(0.12);
 window['bounceJump_' + i] = true;
 }
 if (!window['bounceLand_' + i] && localT > 0.95) {
 playBounceThud(0.15);
 window['bounceLand_' + i] = true;
 }
 }
 
 spheres[i].position.set(x, y, -i * 0.002);
 spheres[i].rotation.z = finalRollRotations[i]; // Use exact rotation from roll phase
 spheres[i].scale.set(introCfg.ballSize, introCfg.ballSize, introCfg.ballSize);
 triMat.uniforms.points.value[i].set(x, y);
 }
 blackHole.visible = false; // Hide during bounce
 
 } else if (phase === 'triangle') {
 // Triangle phase: form ? converge ? grow & brighten
 const triangleProgress = (t - introCfg.bounceEnd) / (introCfg.triangleEnd - introCfg.bounceEnd);
 
 // Smooth cubic easing for entire phase
 const smoothEase = (p) => p < 0.5 ? 4 * p * p * p : 1 - Math.pow(-2 * p + 2, 3) / 2;
 
 // Sub-phases with smooth transitions
 const formProgress = Math.min(triangleProgress / 0.35, 1.0);
 const formEased = smoothEase(formProgress);
 
 const convergeStart = 0.35;
 const convergeProgress = triangleProgress > convergeStart ? Math.min((triangleProgress - convergeStart) / 0.25, 1.0) : 0;
 const convergeEased = smoothEase(convergeProgress);
 
 const growStart = 0.6;
 const growProgress = triangleProgress > growStart ? (triangleProgress - growStart) / 0.4 : 0;
 const growEased = smoothEase(growProgress);
 
 // Create EQUILATERAL triangle centered at origin
 const centerY = 0;
 const triangleRadius = 0.42; // Distance from center to each vertex (increased)
 
 // Equilateral triangle: vertices at 120 intervals, pointing up
 const triangleAngles = [
 Math.PI / 2 + (2 * Math.PI / 3) * 0, // Top (90 )
 Math.PI / 2 + (2 * Math.PI / 3) * 1, // Bottom-left (210 )
 Math.PI / 2 + (2 * Math.PI / 3) * 2 // Bottom-right (330 )
 ];
 
 // Rotation grows smoothly throughout
 const rotationAmount = growEased * 0.2;
 
 // Pulsing: breathe in/out during grow phase
 const pulseSpeed = 2.0;
 const pulsePhase = (t - introCfg.bounceEnd - growStart * (introCfg.triangleEnd - introCfg.bounceEnd)) * pulseSpeed;
 const pulseFactor = growProgress > 0 ? 1 + Math.sin(pulsePhase) * 0.08 : 1;
 
 // Converge factor - pull toward center during converge phase
 const convergeFactor = convergeEased * 0.12;
 
 // Map spheres to triangle positions: [0]=left?bottom-left, [1]=middle?top, [2]=right?bottom-right
 const triangleMapping = [1, 0, 2]; // sphere i goes to angle triangleMapping[i]
 
 for (let i = 0; i < 3; i++) {
 // Starting positions from the line (after bounce)
 const startX = (i - 1) * 0.35;
 const startY = -0.3;
 
 // Target positions in triangle formation (with correct mapping)
 const angleIndex = triangleMapping[i];
 const angle = triangleAngles[angleIndex] + rotationAmount;
 const targetRadius = triangleRadius * (1 - convergeFactor) * pulseFactor;
 const targetX = Math.cos(angle) * targetRadius;
 const targetY = Math.sin(angle) * targetRadius + centerY;
 
 // Interpolate from line to triangle formation
 const x = THREE.MathUtils.lerp(startX, targetX, formEased);
 const y = THREE.MathUtils.lerp(startY, targetY, formEased);
 
 spheres[i].position.set(x, y, -i * 0.002);
 spheres[i].rotation.z = 0; // Reset rotation for orbit phases
 
 // Scale: small ? stays small during form/converge ? grows large with overshoot
 let scale = introCfg.ballSize;
 if (formEased < 1) {
 scale = THREE.MathUtils.lerp(introCfg.ballSize, introCfg.ballSize * 1.0, formEased);
 } else {
 // Add subtle overshoot for organic feel
 const overshoot = Math.sin(growEased * Math.PI) * 0.08;
 scale = THREE.MathUtils.lerp(introCfg.ballSize * 1.0, introCfg.ballSize * 2.2, growEased) + overshoot;
 }
 
 spheres[i].scale.set(scale, scale, scale);
 triMat.uniforms.points.value[i].set(x, y);
 }
 
 blackHole.visible = true;
 blackHole.material.uniforms.pulseFactor.value = formEased * 0.4;
 
 } else if (phase === 'transition') {
 // Transform triangle into rotating circular orbit - organically
 // ALSO morph all shapes into circles
 const transProgress = (t - introCfg.triangleEnd) / (introCfg.transitionEnd - introCfg.triangleEnd);
 // Smooth cubic easing
 const eased = transProgress < 0.5 ? 
 4 * transProgress * transProgress * transProgress : 
 1 - Math.pow(-2 * transProgress + 2, 3) / 2;
 
 // Morph shapes into circles halfway through transition
 // Keep materials (colors) consistent - don't swap
 if (transProgress > 0.5 && spheres[0].geometry !== circleGeoTarget && spheres[1].geometry !== circleGeoTarget) {
 const mat0 = spheres[0].material;
 const mat1 = spheres[1].material;
 
 spheres[0].geometry.dispose();
 spheres[0].geometry = createCircle(R);
 spheres[0].material = mat0; // Preserve cyan
 
 spheres[1].geometry.dispose();
 spheres[1].geometry = createCircle(R);
 spheres[1].material = mat1; // Preserve yellow
 
 // spheres[2] is already a circle (magenta)
 }
 
 const centerY = 0;
 const triangleRadius = 0.42;
 
 // Use same equilateral triangle angles
 const triangleAngles = [
 Math.PI / 2 + (2 * Math.PI / 3) * 0,
 Math.PI / 2 + (2 * Math.PI / 3) * 1,
 Math.PI / 2 + (2 * Math.PI / 3) * 2
 ];
 
 // Starting radius (with 12% convergence from triangle phase)
 const startRadius = triangleRadius * (1 - 0.12);
 
 // Calculate rotation to match end of triangle phase (which uses rotationAmount = 0.2)
 // The triangle phase maps spheres with triangleMapping, so we need to continue from there
 const triangleEndRotation = 0.2; // matches growEased = 1.0 * 0.2
 const rotation = triangleEndRotation + (eased * Math.PI * 2);
 
 // Expand from triangle size to full orbit size
 const targetDist = motionCfg.maxDist * 0.5;
 const currentDist = THREE.MathUtils.lerp(startRadius, targetDist, eased);
 
 // Use same mapping as triangle phase
 const triangleMapping = [1, 0, 2];
 
 for (let i = 0; i < 3; i++) {
 const angleIndex = triangleMapping[i];
 const angle = triangleAngles[angleIndex] + rotation;
 const x = Math.cos(angle) * currentDist;
 const y = Math.sin(angle) * currentDist + centerY;
 
 spheres[i].position.set(x, y, -i * 0.002);
 spheres[i].rotation.z = 0;
 const scale = THREE.MathUtils.lerp(introCfg.ballSize * 2.2, 1.0, eased);
 spheres[i].scale.set(scale, scale, scale);
 triMat.uniforms.points.value[i].set(x, y);
 }
 blackHole.visible = true;
 blackHole.material.uniforms.pulseFactor.value = THREE.MathUtils.lerp(0.4, 0.5, eased);
 
 } else if (phase === 'normal') {
 const normalT = t - introCfg.transitionEnd;
 const convergeDuration = 2.2;
 const pulseDuration = 3.0; // One expand/contract cycle
 const transitionEndDist = motionCfg.maxDist * 0.5;
 const closeConvergeDist = 0.02; // Very close convergence
 const triangleExpandDist = motionCfg.maxDist * 0.65; // Expand to triangle

 const centerY = 0;
 const triangleAngles = [
 Math.PI / 2 + (2 * Math.PI / 3) * 0,
 Math.PI / 2 + (2 * Math.PI / 3) * 1,
 Math.PI / 2 + (2 * Math.PI / 3) * 2
 ];
 const transitionEndRotation = 0.2 + Math.PI * 2;
 const rotation = transitionEndRotation + (normalT * motionCfg.rotationSpeed);
 const triangleMapping = [1, 0, 2];

 let currentDist = transitionEndDist;
 let scale = 1.0;
 let pulseFactorValue = 0.5;

 if (normalT < convergeDuration) {
 // Phase 1: Converge close
 const convergeProgress = THREE.MathUtils.clamp(normalT / convergeDuration, 0, 1);
 const convergeEased = convergeProgress * convergeProgress * (3 - 2 * convergeProgress);
 currentDist = THREE.MathUtils.lerp(transitionEndDist, closeConvergeDist, convergeEased);
 scale = THREE.MathUtils.lerp(1.0, 0.82, convergeEased);
 pulseFactorValue = THREE.MathUtils.lerp(0.5, 0.95, convergeEased);
 } else if (normalT < convergeDuration + pulseDuration) {
 // Phase 2: Single expand/contract pulse
 const pulseT = normalT - convergeDuration;
 const pulseProgress = pulseT / pulseDuration;
 
 // Use sine wave for smooth expand/contract (0->1->0)
 const pulseCycle = Math.sin(pulseProgress * Math.PI);
 
 currentDist = THREE.MathUtils.lerp(closeConvergeDist, triangleExpandDist, pulseCycle);
 scale = THREE.MathUtils.lerp(0.82, 1.0, pulseCycle);
 pulseFactorValue = THREE.MathUtils.lerp(0.95, 0.6, pulseCycle);
 } else {
 // Phase 3: Hold at converged position before transitioning to venn
 currentDist = closeConvergeDist;
 scale = 0.82;
 pulseFactorValue = 0.95;
 }

 for (let i = 0; i < 3; i++) {
 const angleIndex = triangleMapping[i];
 const angle = triangleAngles[angleIndex] + rotation;
 const p = new THREE.Vector2(
 Math.cos(angle) * currentDist,
 Math.sin(angle) * currentDist + centerY
 );
 spheres[i].position.set(p.x, p.y, -i * 0.002);
 spheres[i].rotation.z = 0;
 spheres[i].scale.set(scale, scale, scale);
 triMat.uniforms.points.value[i].copy(p);
 }
 blackHole.visible = true;
 blackHole.material.uniforms.pulseFactor.value = pulseFactorValue;

 } else if (phase === 'venn') {
 // Slow down and form clear venn diagram
 const vennProgress = (t - introCfg.normalEnd) / (introCfg.vennEnd - introCfg.normalEnd);
 // Smooth cubic easing
 const eased = vennProgress < 0.5 ? 
 4 * vennProgress * vennProgress * vennProgress : 
 1 - Math.pow(-2 * vennProgress + 2, 3) / 2;
 
 const normalDuration = introCfg.normalEnd - introCfg.transitionEnd;
 const centerY = 0;
 
 const triangleAngles = [
 Math.PI / 2 + (2 * Math.PI / 3) * 0,
 Math.PI / 2 + (2 * Math.PI / 3) * 1,
 Math.PI / 2 + (2 * Math.PI / 3) * 2
 ];
 
 // Start from where normal ended: transitionEndRotation + normalDuration * rotationSpeed
 const transitionEndRotation = 0.2 + Math.PI * 2;
 const baseRotation = transitionEndRotation + (normalDuration * motionCfg.rotationSpeed);
 const vennT = t - introCfg.normalEnd;
 const slowRotation = baseRotation + (vennT * motionCfg.rotationSpeed * 0.3); // Slow down to 30%
 
 // Settle into venn diagram distance - calculate what pulse factor was at END of normal phase
 const normalEndTime = introCfg.normalEnd - introCfg.transitionEnd;
 const startPulseFactor = 0.5 + 0.5 * Math.sin(normalEndTime * motionCfg.speed);
 const startDist = motionCfg.maxDist * startPulseFactor;
 const targetDist = 0.08; // Very close for dramatic overlap
 const currentDist = THREE.MathUtils.lerp(startDist, targetDist, eased);
 const scale = THREE.MathUtils.lerp(1.0, 0.7, eased); // Much larger for awesome venn!

 // Use same mapping as triangle phase
 const triangleMapping = [1, 0, 2];

 for (let i = 0; i < 3; i++) {
 const angleIndex = triangleMapping[i];
 const angle = triangleAngles[angleIndex] + slowRotation;
 const p = new THREE.Vector2(
 Math.cos(angle) * currentDist,
 Math.sin(angle) * currentDist + centerY
 );
 spheres[i].position.set(p.x, p.y, -i * 0.002);
 spheres[i].rotation.z = 0;
 spheres[i].scale.set(scale, scale, scale);
 triMat.uniforms.points.value[i].copy(p);
 }
 blackHole.visible = true;
 blackHole.material.uniforms.pulseFactor.value = THREE.MathUtils.lerp(startPulseFactor, 0.6, eased);
 
 if (!quoteShown) {
 applyQuoteState(quoteStates.initial, { immediate: true });
 quoteEl.classList.remove('scrambling', 'glitch', 'glitchMedium', 'glitchIntense');
 document.getElementById('quote').classList.add('visible');
 quoteDespairShown = false;
 quoteShown = true;
 }
 
 } else if (phase === 'collapse') {
 // Grow and collapse into white radiating circle
 const collapseProgress = (t - introCfg.vennEnd) / (introCfg.collapseEnd - introCfg.vennEnd);
 // Smooth cubic easing
 const eased = collapseProgress < 0.5 ? 
 4 * collapseProgress * collapseProgress * collapseProgress : 
 1 - Math.pow(-2 * collapseProgress + 2, 3) / 2;
 
 const centerY = 0;
 
 const triangleAngles = [
 Math.PI / 2 + (2 * Math.PI / 3) * 0,
 Math.PI / 2 + (2 * Math.PI / 3) * 1,
 Math.PI / 2 + (2 * Math.PI / 3) * 2
 ];
 
 // Start from where venn ended
 const transitionEndRotation = 0.2 + Math.PI * 2;
 const normalDuration = introCfg.normalEnd - introCfg.transitionEnd;
 const vennDuration = introCfg.vennEnd - introCfg.normalEnd;
 const baseRotation = transitionEndRotation + (normalDuration * motionCfg.rotationSpeed) + (vennDuration * motionCfg.rotationSpeed * 0.3);
 const collapseT = t - introCfg.vennEnd;
 const rotation = baseRotation + (collapseT * motionCfg.rotationSpeed * 0.15); // Even slower
 
 // Collapse to tiny overlap while growing in size
 const startDist = 0.08;
 const targetDist = 0.005;
 const currentDist = THREE.MathUtils.lerp(startDist, targetDist, eased);
 const scale = THREE.MathUtils.lerp(0.7, 0.85, eased); // Massive spheres!

 // Use same mapping as triangle phase
 const triangleMapping = [1, 0, 2];

 for (let i = 0; i < 3; i++) {
 const angleIndex = triangleMapping[i];
 const angle = triangleAngles[angleIndex] + rotation;
 const p = new THREE.Vector2(
 Math.cos(angle) * currentDist,
 Math.sin(angle) * currentDist + centerY
 );
 spheres[i].position.set(p.x, p.y, -i * 0.002);
 spheres[i].rotation.z = 0;
 spheres[i].scale.set(scale, scale, scale);
 triMat.uniforms.points.value[i].copy(p);
 }
 blackHole.visible = true;
 blackHole.material.uniforms.pulseFactor.value = THREE.MathUtils.lerp(0.6, 0.85, eased);
 
 if (collapseProgress > 0.3 && !glitchStarted) {
 document.getElementById('quote').classList.add('glitch');
 glitchStarted = true;
 }
 
 } else if (phase === 'glitch' || phase === 'blackout' || phase === 'loomworks' || phase === 'celli') {
 // Hide spheres during ending sequence, keep last position
 const centerY = 0;
 const targetDist = 0.005;
 const scale = 0.85;
 
 const triangleAngles = [
 Math.PI / 2 + (2 * Math.PI / 3) * 0,
 Math.PI / 2 + (2 * Math.PI / 3) * 1,
 Math.PI / 2 + (2 * Math.PI / 3) * 2
 ];
 
 const slowRotation = t * 0.05;
 
 // Fade out spheres during glitch phase
 let sphereOpacity = 1.0;
 if (phase === 'glitch') {
 const glitchProgress = (t - introCfg.collapseEnd) / (introCfg.glitchEnd - introCfg.collapseEnd);
 sphereOpacity = THREE.MathUtils.lerp(1.0, 0, glitchProgress);
 if (glitchProgress > 0.25 && !quoteDespairShown) {
 glitchSwapQuote(quoteStates.despair, { duration: 950, onComplete: () => quoteEl.classList.add('quote--loom') });
 quoteDespairShown = true;
 }
 } else {
 sphereOpacity = 0;
 }
 
 // Use same mapping as triangle phase
 const triangleMapping = [1, 0, 2];
 
 for (let i = 0; i < 3; i++) {
 const angleIndex = triangleMapping[i];
 const angle = triangleAngles[angleIndex] + slowRotation;
 const p = new THREE.Vector2(
 Math.cos(angle) * targetDist,
 Math.sin(angle) * targetDist + centerY
 );
 spheres[i].position.set(p.x, p.y, -i * 0.002);
 spheres[i].rotation.z = 0;
 spheres[i].scale.set(scale, scale, scale);
 spheres[i].material.opacity = sphereOpacity;
 triMat.uniforms.points.value[i].copy(p);
 }

 blackHole.visible = phase === 'glitch';
 if (phase === 'glitch') {
 const glitchProgress = (t - introCfg.collapseEnd) / (introCfg.glitchEnd - introCfg.collapseEnd);
 blackHole.material.uniforms.pulseFactor.value = THREE.MathUtils.lerp(0.85, 0, glitchProgress);
 }
 }
 }

 // --- Responsive ---------------------------------------------------------
 function onResize(){
 renderer.setSize(window.innerWidth, window.innerHeight);
 composer.setSize(window.innerWidth, window.innerHeight);
 const aspect = window.innerWidth / window.innerHeight;
 triMat.uniforms.aspect.value = aspect;
 if (aspect > 1) { // Landscape
 camera.left = -aspect; camera.right = aspect; camera.top = 1; camera.bottom = -1;
 // Scale black hole to maintain circularity
 blackHole.scale.set(1, 1, 1);
 } else { // Portrait
 camera.left = -1; camera.right = 1; camera.top = 1 / aspect; camera.bottom = -1 / aspect;
 // Scale black hole to maintain circularity
 blackHole.scale.set(aspect, aspect, 1);
 }
 camera.updateProjectionMatrix();
 
 // Recalculate CELLI scale for responsive layout
 const oldScale = celliScale;
 calculateCelliScale();

 // Update voxel positions and scales based on new scale
 if (oldScale !== celliScale) {
 const scaleRatio = celliScale / oldScale;
 voxels.forEach((voxel) => {
 const data = voxel.userData;
 // Update positions with new scale
 data.targetX *= scaleRatio;
 data.targetY *= scaleRatio;
 data.baseScale = celliScale;

 // Update actual positions if settled
 if (data.settled) {
 voxel.position.x = data.targetX;
 voxel.position.y = data.targetY;
 }

 // Update scale
 voxel.scale.set(celliScale, celliScale, celliScale);
 });
 }

 if (bowActive) {
 moveBowToTarget(true);
 }
 }
 window.addEventListener('resize', onResize);
 onResize();

 // --- Animate (gated by Play) -------------------------------------------
 const clock = new THREE.Clock();
 let running = false, totalTime = 0;
 window.running = running; // Make globally accessible for scene transitions
 
 // Canvas for text particles
 const textCanvas = document.createElement('canvas');
 textCanvas.style.position = 'fixed';
 textCanvas.style.inset = '0';
 textCanvas.style.pointerEvents = 'none';
 textCanvas.style.zIndex = '5';
 document.body.appendChild(textCanvas);
 const textCtx = textCanvas.getContext('2d');
 
 function resizeTextCanvas() {
 textCanvas.width = window.innerWidth;
 textCanvas.height = window.innerHeight;
 }
 resizeTextCanvas();
 window.addEventListener('resize', resizeTextCanvas);
 
 // Gentle thunk sound for rolling (lighter than landing)
 function playRollingThunk(volume = 0.08, delay = 0) {
 if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); window.audioCtx = audioCtx; }
 const now = audioCtx.currentTime + delay;
 
 // Subtle rolling "tap" sound
 const osc = audioCtx.createOscillator();
 const gain = audioCtx.createGain();
 
 osc.type = 'sine';
 osc.frequency.setValueAtTime(100 + Math.random() * 20, now); // Slight variation
 osc.frequency.exponentialRampToValueAtTime(50, now + 0.05);
 
 gain.gain.setValueAtTime(volume, now);
 gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
 
 osc.connect(gain);
 gain.connect(audioCtx.destination);
 osc.start(now);
 osc.stop(now + 0.15);
 }
 
 // Heavier thud for jumps and landings
 function playBounceThud(volume = 0.15, delay = 0) {
 if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); window.audioCtx = audioCtx; }
 const now = audioCtx.currentTime + delay;
 
 // Deep impact sound
 const osc = audioCtx.createOscillator();
 const gain = audioCtx.createGain();
 
 osc.type = 'sine';
 osc.frequency.setValueAtTime(60, now); // Deep thud
 osc.frequency.exponentialRampToValueAtTime(30, now + 0.15);
 
 gain.gain.setValueAtTime(volume, now);
 gain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
 
 osc.connect(gain);
 gain.connect(audioCtx.destination);
 osc.start(now);
 osc.stop(now + 0.25);
 }
 
 // Hollow melodic chime for voxel landing - C pentatonic scale
 function playVoxelChime(delay = 0) {
 if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); window.audioCtx = audioCtx; }
 const now = audioCtx.currentTime + delay;
 
 // Pentatonic scale notes for melodic chimes (C, D, E, G, A)
 const pentatonicNotes = [523.25, 587.33, 659.25, 783.99, 880]; // C5, D5, E5, G5, A5
 const fundamentalFreq = pentatonicNotes[Math.floor(Math.random() * pentatonicNotes.length)];
 
 // Hollow sound: triangle wave with filtered overtones
 const osc1 = audioCtx.createOscillator();
 const osc2 = audioCtx.createOscillator();
 const osc3 = audioCtx.createOscillator();
 const filter = audioCtx.createBiquadFilter();
 const gain = audioCtx.createGain();
 
 osc1.type = 'triangle'; // Hollow fundamental
 osc1.frequency.setValueAtTime(fundamentalFreq, now);
 
 osc2.type = 'sine'; // Soft overtone
 osc2.frequency.setValueAtTime(fundamentalFreq * 3, now);
 
 osc3.type = 'sine'; // Gentle fifth
 osc3.frequency.setValueAtTime(fundamentalFreq * 1.5, now);
 
 // Band-pass filter for hollow character
 filter.type = 'bandpass';
 filter.frequency.setValueAtTime(fundamentalFreq * 2, now);
 filter.Q.setValueAtTime(2, now);
 
 // Gentle envelope
 gain.gain.setValueAtTime(0, now);
 gain.gain.linearRampToValueAtTime(0.03, now + 0.01);
 gain.gain.exponentialRampToValueAtTime(0.001, now + 1.2);
 
 osc1.connect(filter);
 osc2.connect(gain);
 osc3.connect(gain);
 filter.connect(gain);
 gain.connect(audioCtx.destination);
 
 osc1.start(now);
 osc2.start(now);
 osc3.start(now);
 osc1.stop(now + 1.2);
 osc2.stop(now + 1.2);
 osc3.stop(now + 1.2);
 }
 
 // Chiptune music system - simple arpeggio + drums
 let chiptuneBass = null;
 let chiptuneGain = null;
 let lastNoteTime = 0;
 let lastDrumTime = 0;
 let noteIndex = 0;
 let drumIndex = 0;
 let musicStarted = false;
 let reverbDelay = null;
 let reverbGain = null;
 let reverbFeedback = null;
 let glitchWhirOsc1 = null;
 let glitchWhirOsc2 = null;
 let glitchWhirOsc3 = null;
 let glitchWhirGain = null;
 let glitchWhirFilter = null;
 let glitchWhirStarted = false;
 
 function updateSynth(t) {
 // Start music during triangle phase
 if (!musicStarted && t > introCfg.bounceEnd) {
 if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); window.audioCtx = audioCtx; }
 
 // Create reverb delay effect
 reverbDelay = audioCtx.createDelay(2.0);
 reverbDelay.delayTime.value = 0.25; // 250ms delay
 reverbGain = audioCtx.createGain();
 reverbGain.gain.value = 0.3; // Moderate reverb mix
 reverbFeedback = audioCtx.createGain();
 reverbFeedback.gain.value = 0.4; // Feedback for reverb tail
 
 // Wire up reverb: delay -> feedback -> delay (loop) + output
 reverbDelay.connect(reverbFeedback);
 reverbFeedback.connect(reverbDelay);
 reverbDelay.connect(reverbGain);
 reverbGain.connect(audioCtx.destination);
 
 musicStarted = true;
 lastNoteTime = t;
 lastDrumTime = t;
 }
 
 if (!musicStarted || !audioCtx) return;
 
 const now = audioCtx.currentTime;
 
 // Determine arpeggio and rhythm based on phase
 let arpeggio = [];
 let noteSpeed = 0.25;
 let drumSpeed = 0.5;
 let drumVolume = 0.12;
 let drumReverb = 0.2;
 let reverbMix = 0.3;
 let glitchLevel = 0;
 
 if (t < introCfg.triangleEnd) {
 // Calm, contemplative Am progression
 arpeggio = [220.00, 261.63, 329.63, 261.63]; // A3, C4, E4, C4
 noteSpeed = 0.5;
 drumSpeed = 1.2;
 drumVolume = 0.08;
 drumReverb = 0.25;
 reverbMix = 0.35;
 } else if (t < introCfg.normalEnd) {
 // Gentle progression with suspension
 arpeggio = [220.00, 246.94, 293.66, 329.63, 293.66, 246.94]; // A3, B3, D4, E4, D4, B3
 noteSpeed = 0.45;
 drumSpeed = 1.0;
 drumVolume = 0.1;
 drumReverb = 0.3;
 reverbMix = 0.4;
 } else if (t < introCfg.vennEnd) {
 // Subdued, introspective
 arpeggio = [196.00, 246.94, 293.66, 349.23, 293.66, 246.94]; // G3, B3, D4, F4, D4, B3
 noteSpeed = 0.4;
 drumSpeed = 0.9;
 drumVolume = 0.12;
 drumReverb = 0.4;
 reverbMix = 0.45;
 } else if (t < introCfg.collapseEnd) {
 // Building unease, drums more present
 arpeggio = [220.00, 277.18, 329.63, 392.00, 329.63, 277.18]; // A3, C#4, E4, G4, E4, C#4
 noteSpeed = 0.38;
 drumSpeed = 0.7;
 drumVolume = 0.16; // Drums becoming more prominent
 drumReverb = 0.6;
 reverbMix = 0.5;
 glitchLevel = 0.1;
 } else if (t < introCfg.glitchEnd) {
 // Dissonant breakdown, drums dominate
 const glitchProgress = (t - introCfg.collapseEnd) / (introCfg.glitchEnd - introCfg.collapseEnd);
 arpeggio = [233.08, 277.18, 369.99, 415.30]; // Diminished, unsettling
 noteSpeed = 0.35;
 drumSpeed = 0.55;
 drumVolume = THREE.MathUtils.lerp(0.18, 0.28, glitchProgress); // Drums take over
 drumReverb = THREE.MathUtils.lerp(0.6, 0.85, glitchProgress);
 reverbMix = THREE.MathUtils.lerp(0.5, 0.65, glitchProgress);
 glitchLevel = THREE.MathUtils.lerp(0.2, 0.8, glitchProgress);
 } else {
 return;
 }
 
 // Update reverb mix
 if (reverbGain) {
 reverbGain.gain.setTargetAtTime(reverbMix, now, 0.5);
 }
 
 // Play arpeggio notes
 if (t - lastNoteTime >= noteSpeed) {
 const freq = arpeggio[noteIndex % arpeggio.length];
 playChiptuneNote(freq, noteSpeed * 0.9, glitchLevel, reverbDelay);
 noteIndex++;
 lastNoteTime = t;
 }
 
 // Play drum beats
 if (t - lastDrumTime >= drumSpeed) {
 playChiptuneDrum(drumVolume, drumReverb, glitchLevel, reverbDelay);
 drumIndex++;
 lastDrumTime = t;
 }
 
 // Corrupted whir during glitch phase
 if (t >= introCfg.collapseEnd && t < introCfg.glitchEnd) {
 const glitchProgress = (t - introCfg.collapseEnd) / (introCfg.glitchEnd - introCfg.collapseEnd);
 
 if (!glitchWhirStarted) {
 // Start the harsh whirring synth
 glitchWhirOsc1 = audioCtx.createOscillator();
 glitchWhirOsc2 = audioCtx.createOscillator();
 glitchWhirOsc3 = audioCtx.createOscillator();
 glitchWhirGain = audioCtx.createGain();
 glitchWhirFilter = audioCtx.createBiquadFilter();
 
 // Triangle waves for harsh, mechanical sound
 glitchWhirOsc1.type = 'triangle';
 glitchWhirOsc2.type = 'triangle';
 glitchWhirOsc3.type = 'triangle';
 
 // Detuning for thickness
 glitchWhirOsc1.detune.value = -8;
 glitchWhirOsc2.detune.value = 0;
 glitchWhirOsc3.detune.value = 8;
 
 // Start at low frequency
 glitchWhirOsc1.frequency.setValueAtTime(220, now);
 glitchWhirOsc2.frequency.setValueAtTime(220, now);
 glitchWhirOsc3.frequency.setValueAtTime(220, now);
 
 // Resonant filter for harsh whir
 glitchWhirFilter.type = 'lowpass';
 glitchWhirFilter.frequency.setValueAtTime(400, now);
 glitchWhirFilter.Q.setValueAtTime(8, now);
 
 glitchWhirGain.gain.setValueAtTime(0, now);
 glitchWhirGain.gain.linearRampToValueAtTime(0.08, now + 0.5);
 
 glitchWhirOsc1.connect(glitchWhirFilter);
 glitchWhirOsc2.connect(glitchWhirFilter);
 glitchWhirOsc3.connect(glitchWhirFilter);
 glitchWhirFilter.connect(glitchWhirGain);
 glitchWhirGain.connect(audioCtx.destination);
 
 glitchWhirOsc1.start(now);
 glitchWhirOsc2.start(now);
 glitchWhirOsc3.start(now);
 
 glitchWhirStarted = true;
 }
 
 // Modulate frequency for failing sound
 if (glitchWhirOsc1) {
 const crackle = Math.sin(t * 100) * 20 * glitchProgress;
 const whir = Math.sin(t * 30) * 10;
 const baseFreq = THREE.MathUtils.lerp(220, 55, glitchProgress); // Pitch down as it fails
 
 glitchWhirOsc1.frequency.setTargetAtTime(baseFreq + crackle + whir, now, 0.02);
 glitchWhirOsc2.frequency.setTargetAtTime(baseFreq + crackle + whir * 1.1, now, 0.02);
 glitchWhirOsc3.frequency.setTargetAtTime(baseFreq + crackle + whir * 0.9, now, 0.02);
 
 // Filter sweep downward
 glitchWhirFilter.frequency.setTargetAtTime(THREE.MathUtils.lerp(400, 100, glitchProgress), now, 0.1);
 
 // Volume swell and fade
 const vroomPhase = Math.sin(t * 2) * 0.5 + 0.5;
 const fadeOut = 1 - glitchProgress * 0.7; // Fade out near end
 glitchWhirGain.gain.setTargetAtTime(0.08 * fadeOut * vroomPhase, now, 0.05);
 }
 } else if (glitchWhirStarted && glitchWhirOsc1) {
 // Stop the whir after glitch phase
 glitchWhirOsc1.stop(now + 0.5);
 glitchWhirOsc2.stop(now + 0.5);
 glitchWhirOsc3.stop(now + 0.5);
 glitchWhirOsc1 = null;
 glitchWhirOsc2 = null;
 glitchWhirOsc3 = null;
 }
 }
 
 // Chiptune note player - muted, musical synth
 function playChiptuneNote(freq, duration, glitchLevel = 0, reverbNode = null) {
 if (!audioCtx) return;
 const now = audioCtx.currentTime;
 
 const osc1 = audioCtx.createOscillator();
 const osc2 = audioCtx.createOscillator();
 const gain = audioCtx.createGain();
 const filter = audioCtx.createBiquadFilter();
 
 // Sine waves for muted, warm tone
 osc1.type = 'sine';
 osc2.type = 'sine';
 
 // Add subtle harmonic (5th) for richness
 const glitchWobble = glitchLevel > 0 ? (Math.random() - 0.5) * freq * glitchLevel * 0.2 : 0;
 osc1.frequency.setValueAtTime(freq + glitchWobble, now);
 osc2.frequency.setValueAtTime((freq * 1.5) + glitchWobble, now); // Perfect 5th
 
 // Muted low-pass filter
 filter.type = 'lowpass';
 filter.frequency.setValueAtTime(glitchLevel > 0.5 ? 600 : 1200, now);
 filter.Q.setValueAtTime(0.3, now);
 
 // Very soft, gentle envelope
 const baseVol = 0.045 * (1 - glitchLevel * 0.3);
 gain.gain.setValueAtTime(0, now);
 gain.gain.linearRampToValueAtTime(baseVol, now + 0.03);
 gain.gain.setValueAtTime(baseVol * 0.85, now + duration * 0.5);
 gain.gain.linearRampToValueAtTime(0, now + duration);
 
 osc1.connect(filter);
 osc2.connect(filter);
 filter.connect(gain);
 gain.connect(audioCtx.destination);
 
 // Connect to reverb if available
 if (reverbNode) {
 gain.connect(reverbNode);
 }
 
 osc1.start(now);
 osc2.start(now);
 osc1.stop(now + duration);
 osc2.stop(now + duration);
 }
 
 // Startup bass sound (Simple warm chord - NO REVERB to prevent oscillation)
 function playStartupBass() {
 if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); window.audioCtx = audioCtx; }
 const now = audioCtx.currentTime;
 
 // Master output - simple, clean
 const masterGain = audioCtx.createGain();
 masterGain.gain.value = 0.4;
 masterGain.connect(audioCtx.destination);
 
 // Simple warm chord - C major
 const chordNotes = [
 { freq: 130.81, vol: 0.10 }, // C3
 { freq: 164.81, vol: 0.08 }, // E3
 { freq: 196.00, vol: 0.07 }, // G3
 { freq: 65.41, vol: 0.09 }, // C2 (bass)
 ];
 
 chordNotes.forEach((note, i) => {
 const osc = audioCtx.createOscillator();
 const oscGain = audioCtx.createGain();
 
 osc.type = 'sine';
 osc.frequency.value = note.freq; // Fixed frequency, no modulation
 
 // Simple envelope
 const delay = i * 0.08;
 oscGain.gain.setValueAtTime(0, now + delay);
 oscGain.gain.linearRampToValueAtTime(note.vol, now + delay + 0.15);
 oscGain.gain.setValueAtTime(note.vol * 0.9, now + delay + 0.6);
 oscGain.gain.linearRampToValueAtTime(0, now + delay + 1.5);
 
 osc.connect(oscGain);
 oscGain.connect(masterGain);
 
 osc.start(now + delay);
 osc.stop(now + delay + 1.6);
 });
 }
 
 // Distorted startup bass sound - progressively more distorted per click
 function playStartupBassDistorted(clickCount = 1) {
 if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); window.audioCtx = audioCtx; }
 const now = audioCtx.currentTime;
 
 // Distortion increases with each click
 const distortionLevel = clickCount * 0.3; // 0.3, 0.6, 0.9
 
 // Master output with distortion
 const masterGain = audioCtx.createGain();
 masterGain.gain.value = 0.4;
 
 // Add waveshaper for distortion
 const distortion = audioCtx.createWaveShaper();
 const curve = new Float32Array(256);
 const deg = Math.PI / 180;
 const amount = distortionLevel * 100; // 30, 60, 90
 for (let i = 0; i < 256; i++) {
 const x = (i * 2) / 256 - 1;
 curve[i] = ((3 + amount) * x * 20 * deg) / (Math.PI + amount * Math.abs(x));
 }
 distortion.curve = curve;
 distortion.oversample = '4x';
 
 masterGain.connect(distortion);
 distortion.connect(audioCtx.destination);
 
 // Chord notes with detuning that increases per click
 const chordNotes = [
 { freq: 130.81, vol: 0.10 }, // C3
 { freq: 164.81, vol: 0.08 }, // E3
 { freq: 196.00, vol: 0.07 }, // G3
 { freq: 65.41, vol: 0.09 }, // C2 (bass)
 ];
 
 chordNotes.forEach((note, i) => {
 const osc = audioCtx.createOscillator();
 const oscGain = audioCtx.createGain();
 const filter = audioCtx.createBiquadFilter();
 
 osc.type = 'sawtooth'; // More harmonics for distortion
 
 // Add detuning/wobble based on click count
 const detune = (Math.random() - 0.5) * clickCount * 15;
 osc.frequency.setValueAtTime(note.freq + detune, now);
 
 // Add frequency wobble during playback
 osc.frequency.linearRampToValueAtTime(note.freq + detune * 1.5, now + 0.3);
 osc.frequency.linearRampToValueAtTime(note.freq + detune * 0.5, now + 1.0);
 
 // Filter gets more aggressive with each click
 filter.type = 'lowpass';
 filter.frequency.setValueAtTime(2000 - clickCount * 400, now);
 filter.Q.value = 1 + clickCount * 0.5;
 
 // Envelope
 const delay = i * 0.08;
 oscGain.gain.setValueAtTime(0, now + delay);
 oscGain.gain.linearRampToValueAtTime(note.vol * (1 + distortionLevel * 0.3), now + delay + 0.15);
 oscGain.gain.setValueAtTime(note.vol * 0.9, now + delay + 0.6);
 oscGain.gain.linearRampToValueAtTime(0, now + delay + 1.5);
 
 osc.connect(filter);
 filter.connect(oscGain);
 oscGain.connect(masterGain);
 
 osc.start(now + delay);
 osc.stop(now + delay + 1.6);
 });
 
 // Add noise for extra degradation on later clicks
 if (clickCount >= 2) {
 const noiseBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 1.5, audioCtx.sampleRate);
 const noiseData = noiseBuffer.getChannelData(0);
 for (let i = 0; i < noiseData.length; i++) {
 noiseData[i] = (Math.random() * 2 - 1) * 0.1 * (clickCount - 1);
 }
 const noiseSource = audioCtx.createBufferSource();
 const noiseGain = audioCtx.createGain();
 noiseSource.buffer = noiseBuffer;
 noiseGain.gain.setValueAtTime(0, now);
 noiseGain.gain.linearRampToValueAtTime(0.05 * clickCount, now + 0.2);
 noiseGain.gain.linearRampToValueAtTime(0, now + 1.4);
 noiseSource.connect(noiseGain);
 noiseGain.connect(masterGain);
 noiseSource.start(now);
 noiseSource.stop(now + 1.5);
 }
 }
 
 // Chiptune drum player
 function playChiptuneDrum(volume = 0.12, reverbAmount = 0.3, glitchLevel = 0, reverbNode = null) {
 if (!audioCtx) return;
 const now = audioCtx.currentTime;
 
 // Kick drum
 const osc = audioCtx.createOscillator();
 const gain = audioCtx.createGain();
 const reverbSend = audioCtx.createGain();
 
 osc.type = 'sine';
 const startFreq = glitchLevel > 0.5 ? 80 + Math.random() * 40 : 60;
 osc.frequency.setValueAtTime(startFreq, now);
 osc.frequency.exponentialRampToValueAtTime(30, now + 0.1);
 
 // Main drum volume (dominant)
 gain.gain.setValueAtTime(volume, now);
 gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
 
 // Reverb send amount
 reverbSend.gain.setValueAtTime(volume * reverbAmount, now);
 reverbSend.gain.exponentialRampToValueAtTime(0.001, now + 0.3); // Longer reverb tail
 
 osc.connect(gain);
 gain.connect(audioCtx.destination);
 
 // Send to reverb
 if (reverbNode) {
 osc.connect(reverbSend);
 reverbSend.connect(reverbNode);
 }
 
 osc.start(now);
 osc.stop(now + 0.3);
 }
 
 function frame(){
 if(!running) return;
 const dt = Math.min(clock.getDelta(), 0.033);
 totalTime += dt;
 updatePositions(totalTime);
 updateSynth(totalTime);
 blackHole.material.uniforms.time.value = totalTime;
 filmPass.uniforms.time.value += dt;
 composer.render();
 
 // Update and render text particles
 updateTextParticles(dt);
 textCtx.clearRect(0, 0, textCanvas.width, textCanvas.height);
 renderTextParticles(textCtx, camera);
 
 // Update voxels for CELLI animation
 updateVoxels(totalTime, dt);
 
 // Update floating voxels during burst
 updateFloatingVoxels(dt);
 
 // Update camera pan
 updateCameraPan();
 
 requestAnimationFrame(frame);
 }

 // --- Click interaction on spheres and black hole ----------------------------------------
 const raycaster = new THREE.Raycaster();
 const mouse = new THREE.Vector2();
 
renderer.domElement.addEventListener('click', (event) => {
if (!running) return;

// Don't allow clicks if fullhand/execution environment is active
if (window.fullhandActive) {
console.log('?? Click ignored - fullhand scene is active');
return;
}

// Don't allow clicks to trigger VisiCalc during narrative sequence
if (window.narrativeSequence && window.narrativeSequence.active && window.narrativeSequence.phase !== 'complete') {
console.log('?? Click ignored - narrative sequence is active');
return;
}

mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

raycaster.setFromCamera(mouse, camera);

// Check black hole first - make it clickable whenever visible
const blackHoleIntersects = raycaster.intersectObject(blackHole, true);
console.log('?? Black hole visible:', blackHole.visible, 'Intersects:', blackHoleIntersects.length);
if (blackHoleIntersects.length > 0 && blackHole.visible) {
console.log('??? Black hole clicked - showing VisiCalc');
localStorage.setItem('megred_seen_blackhole', 'true');
showVisiCalc();
return;
}
 
 // Then check spheres
 const intersects = raycaster.intersectObjects(spheres);
 
 if (intersects.length > 0) {
 const hitSphere = intersects[0].object;
 const sphereIndex = spheres.indexOf(hitSphere);
 const hitPos = intersects[0].point;
 
 // Burst particles based on color
 let texts, color;
 if (sphereIndex === 0) { // Cyan - equations
 texts = equationTexts;
 color = '#00a8ff';
 } else if (sphereIndex === 1) { // Yellow - time
 texts = Array(8).fill(0).map(() => timeTexts());
 color = '#ffb62e';
 } else { // Magenta - manic
 texts = manicTexts;
 color = '#ff1e6e';
 }
 
 // Create burst of 5-8 particles
 const count = 5 + Math.floor(Math.random() * 4);
 for (let i = 0; i < count; i++) {
 const text = texts[Math.floor(Math.random() * texts.length)];
 createTextParticle(hitPos.x, hitPos.y, text, color, sphereIndex);
 }
 }
 });

 // --- Doorway input keyboard and click interaction ------------------------------------
 const promptContainer = document.querySelector('.prompt-container');
 const promptTextEl = document.getElementById('promptText');
 const promptCursorEl = document.getElementById('promptCursor');
 const hiddenInput = document.getElementById('hiddenInput');
 const promptEl = document.querySelector('.prompt');
 
 // Helper function to wrap each character with per-character shadow
 function updatePromptWithChars(text) {
 if (!promptTextEl) return;
 promptTextEl.innerHTML = '';
 for (let i = 0; i < text.length; i++) {
 const char = text[i];
 const span = document.createElement('span');
 span.className = 'char';
 span.setAttribute('data-char', char);
 span.textContent = char;
 promptTextEl.appendChild(span);
 }
 }
 
 // Click to trigger CELLI glitch (reveal T) and focus hidden input for mobile
 if (promptContainer) {
 function focusHiddenPromptInput() {
 if (!hiddenInput) return;

 hiddenInput.value = '';

 const focusOptions = { preventScroll: true };
 try {
 hiddenInput.focus(focusOptions);
 } catch (err) {
 hiddenInput.focus();
 }

 if (document.activeElement !== hiddenInput) {
 hiddenInput.focus();
 }
 }

 promptContainer.addEventListener('click', () => {
 if (!running || burstAnimStarted) return;
 if (!inputAttempted) {
 triggerCelliGlitch();
 inputAttempted = true;
 }

 if (hiddenInput) {
 focusHiddenPromptInput();
 }
 });
 
 function handlePromptBackspace() {
 if (!running || !doorwayOpened || burstAnimStarted) return false;
 if (inputText.length <= promptBaseText.length) return false;

 inputText = inputText.slice(0, -1);
 tEntered = false;

 updatePromptWithChars(inputText);
 promptCursorEl.textContent = '_';
 if (promptEl) {
 promptEl.setAttribute('data-text', inputText + '_');
 }

 if (hiddenInput) {
 hiddenInput.value = '';
 }

 if (burstTimeout) {
 clearTimeout(burstTimeout);
 burstTimeout = null;
 }

 // Restore one letter with fritz effect
 restoreOneLetter();
 return true;
 }

 // Keyboard input to trigger final sequence (desktop)
 window.addEventListener('keydown', (e) => {
 if (!running || !doorwayOpened || !inputAttempted) return;

 if (e.key === 'Backspace') {
 e.preventDefault();
 handlePromptBackspace();
 return;
 }

 // T input - starts burst sequence
 if (!tEntered && e.key.toLowerCase() === 't') {
 e.preventDefault();
 tEntered = true;
 inputText += 'T';

 // Update display
 updatePromptWithChars(inputText);
 promptCursorEl.textContent = '_';
 if (promptEl) {
 promptEl.setAttribute('data-text', inputText + '_');
 }

 if (burstTimeout) {
 clearTimeout(burstTimeout);
 }
 burstTimeout = setTimeout(() => {
 triggerBurstToStars();
 }, 500);
 return;
 }
 
 // E, N, D inputs - only after STAR is fully cleared and yellow transformation complete
 if (inputText === '=' && allYellowTransformed) {
 const key = e.key.toUpperCase();
 
 console.log('END input detected:', key, 'endSequence:', endSequence, 'allYellowTransformed:', allYellowTransformed);
 
 // E must be first
 if (endSequence === '' && key === 'E') {
 e.preventDefault();
 endSequence = 'E';
 transformToMagentaRed();
 updatePromptWithChars('=E');
 if (promptEl) promptEl.setAttribute('data-text', '=E_');
 console.log('%c[SHIFT 1/3]  MAGENTA SHIFT TRIGGERED ', 'background: #ff1e6e; color: #fff; font-size: 14px; font-weight: bold; padding: 6px;');
 console.log('[SHIFT 1/3] Press N to continue...');
 return;
 }
 
 // N must be second (after E)
 if (endSequence === 'E' && key === 'N') {
 e.preventDefault();
 endSequence = 'EN';
 transformToCyanBlue();
 updatePromptWithChars('=EN');
 if (promptEl) promptEl.setAttribute('data-text', '=EN_');
 console.log('%c[SHIFT 2/3]  CYAN SHIFT TRIGGERED ', 'background: #00a8ff; color: #fff; font-size: 14px; font-weight: bold; padding: 6px;');
 console.log('[SHIFT 2/3] Press D to continue...');
 return;
 }
 
 // D must be third (after EN)
 if (endSequence === 'EN' && key === 'D') {
 e.preventDefault();
 endSequence = 'END';
 transformToGreenAndSquare();
 updatePromptWithChars('=END');
 if (promptEl) promptEl.setAttribute('data-text', '=END_');
 console.log('%c[SHIFT 3/3]  GREEN SHIFT TRIGGERED ', 'background: #0f0; color: #000; font-size: 14px; font-weight: bold; padding: 6px;');
 console.log('[SHIFT 3/3] Snap animation starting... HELL transformation completing through falling voxels');
 return;
 }
 
 // After END is complete, Shift just logs status (HELL transformation already happened progressively)
 if (endSequence === 'END' && (key === 'SHIFT' || e.key === 'Shift')) {
 e.preventDefault();
 console.log('%c[INFO] Shift pressed after END', 'background: #888; color: #fff; font-weight: bold; padding: 4px;');
 console.log('[INFO] HELL transformation already completed through the three color shifts:');
 console.log('[INFO]   1. Magenta (E) - Top arc of C fell and repositioned');
 console.log('[INFO]   2. Cyan (N) - Bottom arc of C + some I voxels fell');
 console.log('[INFO]   3. Green (D) - Remaining I voxels fell to complete HELL');
 console.log('[INFO] Animation state:');
 console.log('  - celliMoveToCornerStarted:', celliMoveToCornerStarted);
 console.log('  - snapTogetherStarted:', snapTogetherStarted);
 console.log('  - endColorState:', endColorState);
 return;
 }
 } else if (inputText === '=') {
 console.log('Input is =, but allYellowTransformed is:', allYellowTransformed);
 }
 });
 
 // Mobile input handler
 if (hiddenInput) {
 hiddenInput.addEventListener('beforeinput', (e) => {
 if (!running || !doorwayOpened || !inputAttempted) return;
 if (e.inputType === 'deleteContentBackward') {
 e.preventDefault();
 handlePromptBackspace();
 }
 });

 hiddenInput.addEventListener('input', (e) => {
 if (!running || !doorwayOpened || !inputAttempted) return;

 const value = (e.target.value || '').toUpperCase();

 if (value === '') {
 handlePromptBackspace();
 return;
 }

 // T input for burst sequence
 if (!tEntered && value.includes('T')) {
 e.preventDefault();
 tEntered = true;
 inputText += 'T';

 updatePromptWithChars(inputText);
 promptCursorEl.textContent = '_';
 if (promptEl) {
 promptEl.setAttribute('data-text', inputText + '_');
 }

 e.target.value = '';

 if (burstTimeout) {
 clearTimeout(burstTimeout);
 }
 burstTimeout = setTimeout(() => {
 triggerBurstToStars();
 }, 500);

 hiddenInput.blur();
 return;
 }
 
 // E, N, D inputs after STAR cleared and yellow transformation
 if (inputText === '=' && allYellowTransformed) {
 // E must be first
 if (endSequence === '' && value.includes('E')) {
 e.preventDefault();
 endSequence = 'E';
 transformToMagentaRed();
 updatePromptWithChars('=E');
 if (promptEl) promptEl.setAttribute('data-text', '=E_');
 e.target.value = '';
 return;
 }
 
 // N must be second
 if (endSequence === 'E' && value.includes('N')) {
 e.preventDefault();
 endSequence = 'EN';
 transformToCyanBlue();
 updatePromptWithChars('=EN');
 if (promptEl) promptEl.setAttribute('data-text', '=EN_');
 e.target.value = '';
 return;
 }
 
 // D must be third
 if (endSequence === 'EN' && value.includes('D')) {
 e.preventDefault();
 endSequence = 'END';
 transformToGreenAndSquare();
 updatePromptWithChars('=END');
 if (promptEl) promptEl.setAttribute('data-text', '=END_');
 e.target.value = '';
 return;
 }
 }
 
 // Clear any other input
 e.target.value = '';
 });
 }
 }
 
 // Break apart and rise to sky
 let breakApartStarted = false;
 let riseStartTime = 0;
 
 function triggerBurstToStars() {
 if (burstAnimStarted) return;
 burstAnimStarted = true;
 burstTimeout = null;
 breakApartStarted = true;
 riseStartTime = Date.now();

 const skipBtn = document.getElementById('skipBtn');
 if (skipBtn) {
 skipBtn.classList.remove('illuminating');
 }

 // Increase afterimage effect for dramatic trails
 afterimagePass.uniforms.damp.value = 0.88;
 
 // Hide prompt but keep it for reference
 if (promptEl) {
 promptEl.style.transition = 'opacity 0.5s ease';
 promptEl.style.opacity = '0';
 }
 
 // Get only the T-shape voxels (the ones that weren't glitched)
 const activeVoxels = voxels.filter(v => !v.userData.glitched && v.visible);
 
 // Give each voxel velocity to shoot upward dramatically
 activeVoxels.forEach((voxel, idx) => {
 setTimeout(() => {
 const angle = Math.random() * Math.PI * 2;
 const spreadH = 0.008 + Math.random() * 0.015; // More horizontal spread
 
 voxel.userData.floating = true;
 voxel.userData.vx = Math.cos(angle) * spreadH;
 voxel.userData.vy = 0.08 + Math.random() * 0.05; // MUCH faster upward - shooting motion
 voxel.userData.vz = -0.05 - Math.random() * 0.08; // Move away from camera (into distance)
 voxel.userData.pulsatePhase = Math.random() * Math.PI * 2;
 voxel.userData.pulsateSpeed = 3 + Math.random() * 3;
 voxel.userData.floatStartTime = Date.now();
 voxel.userData.initialScale = voxel.userData.baseScale || 1.0;
 }, idx * 15); // Faster stagger
 });
 
 // Start camera pan after voxels have shot into distance
 setTimeout(() => {
 startCameraPan();
 }, 4000); // Slightly longer to see them recede
 }
 
 // Update floating voxels
 function updateFloatingVoxels(dt) {
 if (!breakApartStarted) return;
 
 const now = Date.now();
 const totalElapsed = (now - riseStartTime) / 1000;
 
 voxels.forEach(voxel => {
 if (!voxel.userData.floating) return;
 
 const data = voxel.userData;
 const age = (now - data.floatStartTime) / 1000;
 
 // Move with velocity - shooting into distance
 voxel.position.x += data.vx;
 voxel.position.y += data.vy;
 voxel.position.z += data.vz;
 
 // Very slow drag to maintain shooting motion
 data.vx *= 0.985;
 data.vy *= 0.985;
 data.vz *= 0.985;
 
 // Scale down dramatically as they move away (perspective)
 // Based on Z distance from camera
 const distanceZ = Math.abs(voxel.position.z + 0.5); // Initial Z was around -0.5
 const perspectiveScale = 1 / (1 + distanceZ * 3); // Shrink rapidly with distance
 
 // Pulsate on top of perspective scaling
 data.pulsatePhase += data.pulsateSpeed * dt;
 const pulse = 0.85 + Math.sin(data.pulsatePhase) * 0.15;
 const baseScale = data.initialScale || 1.0;
 const finalScale = baseScale * pulse * perspectiveScale;
 voxel.scale.set(finalScale, finalScale, finalScale);
 
 // Brighten voxels during shooting (they're stars now)
 voxel.material.color.setRGB(1, 1, 1); // Pure white
 
 // Pulsate material opacity with distance fade
 const opacityPulse = 0.8 + Math.sin(data.pulsatePhase * 0.7) * 0.2;
 const distanceFade = Math.max(0.3, 1 - distanceZ * 0.4); // Fade as they get far
 voxel.material.opacity = Math.min(1.0, opacityPulse * distanceFade);
 data.edges.material.opacity = Math.min(0.8, opacityPulse * 0.8 * distanceFade);
 
 // Fade out during camera pan
 if (cameraPanStarted) {
 const panProgress = (now - panStartTime) / panDuration;
 const fadeStart = 0.5;
 if (panProgress > fadeStart) {
 const fadeProgress = (panProgress - fadeStart) / (1 - fadeStart);
 voxel.material.opacity *= (1 - fadeProgress * 0.8);
 data.edges.material.opacity *= (1 - fadeProgress * 0.8);
 }
 }
 });
 }
 
 // Pan camera down to reveal gradient
 let cameraPanStarted = false;
 let panStartTime = 0;
 const panDuration = 5000; // 5 seconds for dramatic reveal
 
 function startCameraPan() {
 cameraPanStarted = true;
 panStartTime = Date.now();
 }
 
 function updateCameraPan() {
 if (!cameraPanStarted) return;
 
 const elapsed = Date.now() - panStartTime;
 const progress = Math.min(1, elapsed / panDuration);
 
 // Smooth ease-in-out for dramatic pan
 const eased = progress < 0.5 ? 
 2 * progress * progress : 
 1 - Math.pow(-2 * progress + 2, 2) / 2;
 
 // Gradually reduce afterimage effect during pan to fade trails
 afterimagePass.uniforms.damp.value = THREE.MathUtils.lerp(0.88, 0.96, progress);
 
 // Pan down much further to reveal gradient
 camera.position.y = THREE.MathUtils.lerp(0, -5, eased);
 camera.lookAt(0, camera.position.y - 2, 0); // Look ahead of camera position
 
 // Fade doorway, prompt, and vignette quickly
 const doorway = document.getElementById('doorway');
 if (doorway) {
 doorway.style.opacity = Math.max(0, 1 - progress * 2);
 }
 
 // Fade out vignette
 const vignette = document.querySelector('.vignette');
 if (vignette) {
 vignette.style.transition = 'opacity 1s ease';
 vignette.style.opacity = String(Math.max(0, 1 - progress * 1.5));
 }
 
 // Add blue gradient background early in the pan
 if (progress > 0.2 && !document.getElementById('nightSky')) {
 // Set app background to black initially for smooth transition
 const app = document.getElementById('app');
 if (app) {
 app.style.background = '#000';
 }
 
 // Immediately hide vignette and scanlines when gradient appears
 const vignetteEl = document.querySelector('.vignette');
 if (vignetteEl) {
 vignetteEl.style.display = 'none';
 }
 
 // Hide scanlines overlay
 if (app && app.classList.contains('scanlines')) {
 app.classList.add('fade-scanlines');
 }
 
 const nightSky = document.createElement('div');
 nightSky.id = 'nightSky';
 nightSky.style.position = 'fixed';
 nightSky.style.inset = '0';
 nightSky.style.background = 'linear-gradient(to bottom, #0d1b2a 0%, #1a237e 20%, #283593 40%, #3949ab 60%, #5e92f3 80%, #90caf9 100%)';
 nightSky.style.zIndex = '0';
 nightSky.style.opacity = '0';
 nightSky.style.pointerEvents = 'none';
 
 // Insert at beginning of body
 if (document.body.firstChild) {
 document.body.insertBefore(nightSky, document.body.firstChild);
 } else {
 document.body.appendChild(nightSky);
 }
 
 // Fade in gradient
 setTimeout(() => {
 nightSky.style.transition = 'opacity 3s ease';
 nightSky.style.opacity = '1';
 
 // Fade out black background
 if (app) {
 app.style.transition = 'background 3s ease';
 app.style.background = 'transparent';
 }
 }, 100);
 }
 
 // Fade out 3D scene elements as gradient appears
 if (progress > 0.3) {
 const fadeAmount = Math.min(1, (progress - 0.3) / 0.7); // Fade from 30% to 100%
 
 // Fade renderer canvas
 renderer.domElement.style.transition = 'opacity 0.5s ease';
 renderer.domElement.style.opacity = String(1 - fadeAmount * 0.8); // Keep slight visibility
 }
 
 // Keep stars visible over the gradient longer
 if (progress > 0.7) {
 const starFade = (progress - 0.7) / 0.3;
 textCanvas.style.opacity = String(1 - starFade);
 }
 
 // Transition to celli-real when gradient transition completes
 if (progress >= 1.0 && !window.__celliRealTransitioned) {
 window.__celliRealTransitioned = true;
 setTimeout(() => {
 console.log('?? Gradient transition complete - loading CELLI.REAL');
 transitionToCelliRealScene();
 }, 1000);
 }
 }
 
 // Render star particles
 function renderStars() {
 if (starParticles.length === 0) return;
 
 const now = Date.now();
 
 // Update and render each star
 for (let i = starParticles.length - 1; i >= 0; i--) {
 const star = starParticles[i];
 
 // Update position based on velocity
 if (star.vx !== undefined) {
 star.x += star.vx;
 star.y += star.vy;
 star.z += star.vz;
 
 // Very slow drag to keep stars moving
 star.vx *= 0.995;
 star.vy *= 0.995;
 star.vz *= 0.995;
 }
 
 // Calculate age and fade
 const age = (now - star.birthTime) / 1000; // in seconds
 const fadeDuration = 8; // fade over 8 seconds (much slower)
 const fadeProgress = Math.min(1, age / fadeDuration);
 
 // Dim brightness over time - keep them bright longer
 star.brightness = 1 - fadeProgress * 0.5; // Keep 50% minimum
 
 // Update twinkle
 star.twinkle += star.twinkleSpeed * 0.016;
 const twinkleBrightness = 0.8 + Math.sin(star.twinkle) * 0.2;
 const finalBrightness = star.brightness * twinkleBrightness;
 
 // Keep stars visible much longer - only remove when very faint
 if (finalBrightness < 0.05) {
 starParticles.splice(i, 1);
 continue;
 }
 
 // Project to screen space
 const vector = new THREE.Vector3(star.x, star.y, star.z);
 vector.project(camera);
 
 // Check if behind camera
 if (vector.z > 1) continue;
 
 const x = (vector.x + 1) / 2 * window.innerWidth;
 const y = (-vector.y + 1) / 2 * window.innerHeight;
 
 // Size based on distance (z-depth)
 const depthScale = Math.max(0.5, 1 - vector.z * 0.5);
 const renderSize = star.size * window.innerWidth * 0.01 * depthScale;
 
 // Draw voxel as square with slight glow
 const voxelSize = renderSize * 1.5;
 const glowSize = voxelSize * 1.5;
 
 // Outer glow
 const gradient = textCtx.createRadialGradient(x, y, 0, x, y, glowSize);
 gradient.addColorStop(0, `rgba(255, 255, 255, ${finalBrightness * 0.8})`);
 gradient.addColorStop(0.6, `rgba(255, 255, 255, ${finalBrightness * 0.3})`);
 gradient.addColorStop(1, `rgba(255, 255, 255, 0)`);
 textCtx.fillStyle = gradient;
 textCtx.beginPath();
 textCtx.arc(x, y, glowSize, 0, Math.PI * 2);
 textCtx.fill();
 
 // Core voxel - square shape
 textCtx.fillStyle = `rgba(255, 255, 255, ${Math.min(1, finalBrightness * 1.1)})`;
 textCtx.fillRect(x - voxelSize/2, y - voxelSize/2, voxelSize, voxelSize);
 
 // Subtle border for voxel definition
 if (finalBrightness > 0.5) {
 textCtx.strokeStyle = `rgba(255, 255, 255, ${finalBrightness * 0.6})`;
 textCtx.lineWidth = 0.5;
 textCtx.strokeRect(x - voxelSize/2, y - voxelSize/2, voxelSize, voxelSize);
 }
 }
 }

 // --- Play button wiring -------------------------------------------------
 const playOverlay = document.getElementById('play');
 const playBtn = document.getElementById('playBtn');
 const skipBtn = document.getElementById('skipBtn');
 
 playBtn.addEventListener('click', ()=>{
 running = true; window.running = running; clock.getDelta();
 playOverlay.classList.add('hidden');
 skipBtn.classList.remove('hidden'); // Show skip button
 clearToast();
 frame();
 });
 
 // --- Skip button logic ---------------------------------------------------
 skipBtn.addEventListener('click', () => {
 if (!running) return;

 // Jump to CELLI phase
 totalTime = introCfg.celliEnd - 6.0; // Start 6 seconds before celli ends (during trickle/chime)
 
 // Hide all prior elements
 quoteEl.style.visibility = 'hidden';
 quoteEl.style.opacity = '0';
 loomworksEl.style.display = 'none';
 triMesh.visible = false;
 blackHole.visible = false;
 spheres.forEach(s => s.visible = false);
 
 // Setup CELLI
 if (!celliStarted) {
 celliStarted = true;
 celliStartTime = totalTime;
 }
 
 // Don't hide skip button - it will transform into a bow later
 
 // Play startup bass note
 setTimeout(() => {
 playStartupBass();
 }, 500);
 });

 skipBtn.addEventListener('keydown', (event) => {
 if (event.key === 'Enter' || event.key === ' ') {
 event.preventDefault();
 skipBtn.click();
 }
 });

 // --- Scene Select System ---------------------------------------------
 const sceneSelect = document.getElementById('sceneSelect');
 const sceneSelectBtn = document.getElementById('sceneSelectBtn');
 const closeSceneSelectBtn = document.getElementById('closeSceneSelect');
 const debugToggle = document.getElementById('debugToggle');
 const clearProgress = document.getElementById('clearProgress');
 const sceneOptions = document.querySelectorAll('.scene-option');
 
 let debugMode = false;
 
 function updateSceneSelect() {
 const hasSeenVisicell = localStorage.getItem('megred_seen_visicell') === 'true';
 const hasSeenLeave = localStorage.getItem('megred_seen_leave') === 'true';
 const hasSeenTheos = localStorage.getItem('megred_seen_theos') === 'true';
 const hasSeenBlackhole = localStorage.getItem('megred_seen_blackhole') === 'true';
 const hasSeenEnd3 = localStorage.getItem('megred_seen_end3') === 'true';
 const hasSeenFullhand = localStorage.getItem('megred_seen_fullhand') === 'true';
 const hasSeenCelliReal = localStorage.getItem('megred_seen_cellireal') === 'true';
 
 sceneOptions.forEach(opt => {
 const scene = opt.dataset.scene;
 let unlocked = debugMode;
 
 if (!unlocked) {
 if (scene === 'visicell' && hasSeenVisicell) unlocked = true;
 if (scene === 'leave' && hasSeenLeave) unlocked = true;
 if (scene === 'theos' && hasSeenTheos) unlocked = true;
 if (scene === 'blackhole' && hasSeenBlackhole) unlocked = true;
 if (scene === 'end3' && hasSeenEnd3) unlocked = true;
 if (scene === 'fullhand' && hasSeenFullhand) unlocked = true;
 if (scene === 'cellireal' && hasSeenCelliReal) unlocked = true;
 }
 
 if (unlocked) {
 opt.classList.remove('locked');
 } else {
 opt.classList.add('locked');
 }
 });
 
 debugToggle.textContent = debugMode ? 'Debug: ON ?' : 'Debug: Show All';
 }
 
 // Open scene select
 sceneSelectBtn.addEventListener('click', () => {
 updateSceneSelect();
 sceneSelect.classList.add('visible');
 });
 
 // Close scene select
 closeSceneSelectBtn.addEventListener('click', () => {
 sceneSelect.classList.remove('visible');
 });
 
 // Debug toggle
 debugToggle.addEventListener('click', () => {
 debugMode = !debugMode;
 updateSceneSelect();
 });
 
 // Clear progress
 clearProgress.addEventListener('click', () => {
 if (confirm('Clear all progress? This will lock all scenes.')) {
 localStorage.removeItem('megred_seen_visicell');
 localStorage.removeItem('megred_seen_leave');
 localStorage.removeItem('megred_seen_theos');
 localStorage.removeItem('megred_seen_blackhole');
 localStorage.removeItem('megred_seen_end3');
 localStorage.removeItem('megred_seen_fullhand');
 localStorage.removeItem('megred_seen_cellireal');
 updateSceneSelect();
 console.log('? Progress cleared');
 }
 });
 
 // Scene jumps
 sceneOptions.forEach(opt => {
 opt.addEventListener('click', () => {
 if (opt.classList.contains('locked')) return;
 
 const scene = opt.dataset.scene;
 sceneSelect.classList.remove('visible');
 
 // Start the experience if not running
 if (!running) {
 running = true;
 window.running = running;
 clock.getDelta();
 playOverlay.classList.add('hidden');
 skipBtn.classList.remove('hidden');
 clearToast();
 frame();
 }
 
 // Jump to scene
 if (scene === 'visicell') {
 // Jump to END sequence completed - show VisiCell
 console.log('?? Jumping to VisiCell');
 totalTime = introCfg.celliEnd + 10;
 showVisiCalc();
 localStorage.setItem('megred_seen_visicell', 'true');
 } else if (scene === 'leave') {
 // Jump to VisiCalc terminal ready for MADNESS.LOOM command
 console.log('?? Jumping to VisiCell terminal (MADNESS.LOOM)');
 totalTime = introCfg.celliEnd + 8;
 showVisiCalc();
 // VisiCalc is shown and ready for terminal input (MADNESS.LOOM command)
 localStorage.setItem('megred_seen_leave', 'true');
 } else if (scene === 'theos') {
 // Jump to THE.OS scene - start of cell address grid sequence
 console.log('?? Jumping to THE.OS grid scene (cell lattice start)');
 totalTime = introCfg.celliEnd + 8;
 showVisiCalc();
 // Start from beginning of address sequence (no time jump)
 setTimeout(() => {
 const frameEl = document.getElementById('visicalc-frame');
 const visiCalc = document.getElementById('visicalc');
 if (frameEl) {
 startCellAddressSequence(frameEl, visiCalc);
 console.log('?? THE.OS cell address sequence started from beginning');
 }
 }, 500);
 localStorage.setItem('megred_seen_theos', 'true');
 } else if (scene === 'blackhole') {
 // Jump to black hole formed scene (later in sequence)
 console.log('?? Jumping to Black Hole formed scene');
 totalTime = introCfg.celliEnd + 8;
 showVisiCalc();
 // Set the jump time to black hole visibility
 window.addressSequenceTime = 56; // Jump to black hole visible time
 console.log('? Pre-setting sequence time to 56s for black hole visibility');
 setTimeout(() => {
 const frameEl = document.getElementById('visicalc-frame');
 const visiCalc = document.getElementById('visicalc');
 if (frameEl) {
 startCellAddressSequence(frameEl, visiCalc);
 console.log('?? Cell address sequence started at t=56s (black hole visible)');
 }
 }, 500);
 localStorage.setItem('megred_seen_blackhole', 'true');
 } else if (scene === 'end3') {
 // Jump directly to end3 scene
 console.log('?? Jumping to End3');
 // Stop main animation loop and audio
 running = false;
 window.running = running;
 if (audioCtx && audioCtx.state === 'running') {
 audioCtx.suspend().catch(e => console.warn('Audio suspend failed:', e));
 }
 transitionToEnd3Scene();
 localStorage.setItem('megred_seen_end3', 'true');
 } else if (scene === 'fullhand') {
 // Jump directly to Fullhand (Execution Environment)
 console.log('?? Jumping to Execution Environment (fullhand)');
 // Stop main animation loop and audio
 running = false;
 window.running = running;
 if (audioCtx && audioCtx.state === 'running') {
 audioCtx.suspend().catch(e => console.warn('Audio suspend failed:', e));
 }
 transitionToFullhandScene();
 localStorage.setItem('megred_seen_fullhand', 'true');
 } else if (scene === 'cellireal') {
 // Jump directly to CELLI.REAL
 console.log('?? Jumping to CELLI.REAL');
 // Stop main animation loop and audio
 running = false;
 window.running = running;
 if (audioCtx && audioCtx.state === 'running') {
 audioCtx.suspend().catch(e => console.warn('Audio suspend failed:', e));
 }
 transitionToCelliRealScene();
 localStorage.setItem('megred_seen_cellireal', 'true');
 }
 });
 });
 
 // Mode toggle buttons for execution environment
 document.querySelectorAll('.mode-btn').forEach(btn => {
 btn.addEventListener('click', (e) => {
 e.stopPropagation(); // Prevent triggering scene selection
 const sceneTarget = btn.getAttribute('data-scene-target');
 const mode = btn.getAttribute('data-mode');
 
 // Update active state for this scene's mode buttons
 document.querySelectorAll(`.mode-btn[data-scene-target="${sceneTarget}"]`).forEach(b => {
 b.classList.remove('active');
 b.style.background = '#2a2a2f';
 b.style.borderColor = '#444';
 b.style.color = '#ddd';
 });
 
 btn.classList.add('active');
 btn.style.background = '#4a7cff';
 btn.style.borderColor = '#6a9cff';
 btn.style.color = '#fff';
 
 // Store the selected mode
 localStorage.setItem(`${sceneTarget}_mode`, mode);
 console.log(`? ${sceneTarget} mode set to: ${mode}`);
 });
 });
 
 // Restore saved mode on load
 document.querySelectorAll('.mode-btn').forEach(btn => {
 const sceneTarget = btn.getAttribute('data-scene-target');
 const mode = btn.getAttribute('data-mode');
 const savedMode = localStorage.getItem(`${sceneTarget}_mode`) || 'sequence';
 
 if (mode === savedMode) {
 btn.classList.add('active');
 btn.style.background = '#4a7cff';
 btn.style.borderColor = '#6a9cff';
 btn.style.color = '#fff';
 } else {
 btn.classList.remove('active');
 btn.style.background = '#2a2a2f';
 btn.style.borderColor = '#444';
 btn.style.color = '#ddd';
 }
 });
 
 // Initial update
 updateSceneSelect();
 </script>

 <!-- ========== END3 SCENE CONTAINER (HIDDEN INITIALLY) ========== -->
 <div id="end3-scene-container" style="display:none; position:fixed; inset:0; z-index:500; background:#000;">
 <div id="end3-container"></div>
 <button id="end3-start">:: INITIALIZE ::</button>
 
 <!-- Crawl -->
 <div id="end3-crawl-container">
 <div id="end3-crawl-header">CELLI::TERMINAL //LOG</div>
 <div id="end3-crawl"></div>
 <svg id="end3-crawl-cursor" viewBox="0 0 24 24">
 <polygon points="0,0 24,12 0,24" fill="#ffd04a" style="filter:drop-shadow(0 0 8px rgba(255,220,120,0.9))"/>
 </svg>
 </div>

 <!-- Settings -->
 <div id="end3-settings-icon">?</div>
 <div id="end3-settings-menu">
 <h2 style="margin:0 0 20px 0;color:#ff8c00;text-align:center;text-shadow:0 0 10px rgba(255,140,0,.8);">GRAPHICS SETTINGS</h2>
 <div style="color:#ffaa33;font-size:14px;">
 <label style="display:block;margin:12px 0;"><input type="checkbox" id="end3-set-bloom" checked> Post-Processing (Bloom)</label>
 <label style="display:block;margin:12px 0;"><input type="checkbox" id="end3-set-dof" checked> Depth of Field</label>
 <label style="display:block;margin:12px 0;"><input type="checkbox" id="end3-set-fog" checked> Depth Fog</label>
 <label style="display:block;margin:12px 0;"><input type="checkbox" id="end3-set-voxels" checked> Floating Voxels</label>
 <label style="display:block;margin:12px 0;"><input type="checkbox" id="end3-set-cables" checked> Cable Visibility</label>
 <div id="end3-dof-controls" class="slider-group">
 <div class="slider-control">
 <label for="end3-focus-length">Focus Length <span id="end3-focus-length-value" class="value">42mm</span></label>
 <input type="range" id="end3-focus-length" min="24" max="80" step="1" value="42">
 </div>
 <div class="slider-control">
 <label for="end3-focus-distance">Focus Distance <span id="end3-focus-distance-value" class="value">18u</span></label>
 <input type="range" id="end3-focus-distance" min="10" max="45" step="1" value="18">
 </div>
 <div class="slider-control">
 <label for="end3-blur-radius">Blur Radius <span id="end3-blur-radius-value" class="value">0.008</span></label>
 <input type="range" id="end3-blur-radius" min="0.002" max="0.015" step="0.001" value="0.008">
 </div>
 </div>
 <button id="end3-close-settings" style="margin-top:18px;width:100%;padding:10px;background:#ff8c00;border:none;color:#000;font-weight:bold;cursor:pointer;font-size:14px;">CLOSE</button>
 </div>
 </div>

 <!-- Debug WASD indicator -->
 <div id="end3-wasd-debug" style="position:fixed;top:10px;left:10px;background:rgba(0,0,0,0.8);color:#0f0;padding:10px;font-family:monospace;font-size:12px;z-index:300;border:1px solid #0f0;">
 WASD: <span id="end3-wasd-status">----</span><br>
 Pos: <span id="end3-pos-status">0,0,0</span>
 </div>
 
 <!-- Skip button for end3 scene -->
 <button id="end3-skip" style="position:fixed;top:20px;left:50%;transform:translateX(-50%);padding:10px 20px;background:rgba(255,140,0,0.9);border:2px solid #ff8c00;border-radius:5px;cursor:pointer;z-index:200;font-weight:bold;color:#000;font-size:14px;display:none;font-family:'VT323',monospace;letter-spacing:1px;">SKIP CRAWL</button>
 </div>

 <!-- ========== FULLHAND SCENE CONTAINER (HIDDEN INITIALLY) ========== -->
 <div id="fullhand-scene-container" style="display:none; position:fixed; inset:0; z-index:500; background:#0a0a0a;">
 <div id="fullhand-app"></div>
 
 <div id="fullhand-loading-overlay">
 <div class="status-text">
 <div class="spinner"></div>
 <div id="fullhand-status-message">Loading scene...</div>
 </div>
 </div>
 
 <div id="fullhand-debug-menu">
 <div id="fullhand-debug-menu-minimize" title="Hide Scene Navigation">-</div>
 <h3>Scene Navigation</h3>
 <button id="fullhand-btn-keyboard">JUMP TO KEYBOARD</button>
 <button id="fullhand-btn-character">JUMP TO CHARACTER</button>
 <button id="fullhand-btn-head">JUMP TO HEAD</button>
 <button id="fullhand-btn-overview">OVERVIEW</button>
 <hr style="border-color: #333; margin: 12px 0;">
 <h3>Edit Tools</h3>
 <button id="fullhand-btn-edit-character">EDIT CHARACTER</button>
 <button id="fullhand-btn-sculpt-character">SCULPT CHARACTER</button>
 <button id="fullhand-btn-edit-head">EDIT HEAD</button>
 <button id="fullhand-btn-edit-hands">EDIT HANDS</button>
 <button id="fullhand-btn-scene-browser">SCENE BROWSER</button>
 <hr style="border-color: #333; margin: 12px 0;">
 <h3>Configuration</h3>
 <button id="fullhand-btn-save-config">SAVE CONFIG</button>
 <button id="fullhand-btn-print-config">PRINT CONFIG</button>
 <hr style="border-color: #333; margin: 12px 0;">
 <button id="fullhand-btn-cursor-sequence">CREATE VOXEL CURSOR</button>
 <div id="fullhand-hand-config-previews" style="margin-top: 10px; max-width: 200px;"></div>
 <hr style="border-color: #333; margin: 12px 0;">
 <button id="fullhand-btn-scale-mode">TOGGLE SCALE MODE</button>
 <hr style="border-color: #333; margin: 12px 0;">
 <div id="fullhand-micro-city-status" style="font-size: 11px; color: #888; padding: 4px;">
 <strong>Micro City LOD:</strong> <span id="fullhand-micro-city-state">Inactive</span>
 </div>
 <div id="fullhand-scale-mode-status" style="font-size: 11px; color: #888; padding: 4px; margin-top: 4px;">
 <strong>Scale Mode:</strong> <span id="fullhand-scale-mode-state">Disabled</span>
 </div>
 </div>
 
 <div id="fullhand-debug-menu-restore" title="Show Scene Navigation">???</div>
 
 <input type="file" id="fullhand-cursor-file-input" accept="image/*" style="display:none;">
 
<div class="gizmo-toolbar" id="fullhand-gizmo-toolbar" style="display: flex;">
<div class="gizmo-btn active" data-mode="translate" title="Translate (G)">?</div>
<div class="gizmo-btn" data-mode="rotate" title="Rotate (R)">?</div>
<div class="gizmo-btn" data-mode="scale" title="Scale (S)">?</div>
<div style="width: 1px; height: 34px; background: #3a4149; margin: 5px 4px;"></div>
<div class="gizmo-btn" id="fullhand-snap-toggle" data-snap="free" title="Rotation Snap: Free" style="font-size: 14px; font-weight: 600;">Free</div>
<div class="gizmo-btn" id="fullhand-drop-btn" title="Drop to Human Scale" style="font-size: 14px; font-weight: 600; background: #4a7cff;">DROP</div>
</div>
 
 <!-- Scene Browser Modal -->
 <div id="fullhand-scene-browser-modal" class="modal-window">
 <div class="modal-header">
 <h3>Scene Objects</h3>
 <div class="modal-close" onclick="document.getElementById('fullhand-scene-browser-modal').classList.remove('active')"> </div>
 </div>
 <div class="modal-body" id="fullhand-scene-browser-content">
 <!-- Populated dynamically -->
 </div>
 </div>
 
 <!-- Edit Head Modal -->
 <div id="fullhand-edit-head-modal" class="modal-window">
 <div class="modal-header">
 <h3>Edit Head</h3>
 <div class="modal-close" onclick="document.getElementById('fullhand-edit-head-modal').classList.remove('active')"> </div>
 </div>
 <div class="modal-body">
 <div class="form-group">
 <label>Preset Configuration</label>
 <select id="fullhand-head-preset-select" onchange="loadHeadPreset(this.value)">
 <option value="sparse-blue">Sparse Blue (Default)</option>
 <option value="dense-cyan">Dense Cyan</option>
 <option value="warm-glow">Warm Glow</option>
 <option value="neon-pink">Neon Pink</option>
 <option value="ghost-white">Ghost White</option>
 </select>
 </div>
 <div class="form-group">
 <label>Animation Speed</label>
 <input type="range" id="fullhand-head-anim-speed" min="0" max="3" step="0.01" value="1.15">
 <span id="fullhand-head-anim-speed-val">1.15</span>
 </div>
 <div class="form-group">
 <label>Amplitude</label>
 <input type="range" id="fullhand-head-amplitude" min="0" max="0.5" step="0.01" value="0.15">
 <span id="fullhand-head-amplitude-val">0.15</span>
 </div>
 <div class="form-group">
 <label>Opacity Min</label>
 <input type="range" id="fullhand-head-opacity-min" min="0" max="1" step="0.01" value="0.3">
 <span id="fullhand-head-opacity-min-val">0.3</span>
 </div>
 <div class="form-group">
 <label>Opacity Max</label>
 <input type="range" id="fullhand-head-opacity-max" min="0" max="1" step="0.01" value="0.85">
 <span id="fullhand-head-opacity-max-val">0.85</span>
 </div>
 <div class="form-group">
 <label>Emissive Intensity</label>
 <input type="range" id="fullhand-head-emissive" min="0" max="2" step="0.01" value="0.8">
 <span id="fullhand-head-emissive-val">0.8</span>
 </div>
 <div class="form-group">
 <label>Light Intensity</label>
 <input type="range" id="fullhand-head-light-int" min="0" max="10" step="0.1" value="2.5">
 <span id="fullhand-head-light-int-val">2.5</span>
 </div>
 <div class="form-group">
 <label>
 <input type="checkbox" id="fullhand-head-light-pulse" checked>
 Light Pulse
 </label>
 </div>
 <div class="form-group">
 <label>Rotation Speed</label>
 <input type="range" id="fullhand-head-rotation-speed" min="0" max="1" step="0.01" value="0.3">
 <span id="fullhand-head-rotation-speed-val">0.3</span>
 </div>
 <div class="form-group">
 <label>Color</label>
 <input type="color" id="fullhand-head-color" value="#95bfff">
 </div>
 <hr>
 <h4>Advanced Animation</h4>
 <div class="form-group">
 <label>Phase Noise</label>
 <input type="range" id="fullhand-head-phase-noise" min="0" max="2" step="0.01" value="0.75">
 <span id="fullhand-head-phase-noise-val">0.75</span>
 </div>
 <div class="form-group">
 <label>Falloff</label>
 <input type="range" id="fullhand-head-falloff" min="0" max="2" step="0.01" value="0.85">
 <span id="fullhand-head-falloff-val">0.85</span>
 </div>
 <div class="form-group">
 <label>Noise Warp</label>
 <input type="range" id="fullhand-head-noise-warp" min="0" max="0.6" step="0.01" value="0.15">
 <span id="fullhand-head-noise-warp-val">0.15</span>
 </div>
 <div class="form-group">
 <label>Opacity Speed</label>
 <input type="range" id="fullhand-head-opacity-speed" min="0" max="3" step="0.01" value="0.8">
 <span id="fullhand-head-opacity-speed-val">0.8</span>
 </div>
 <h4>Material</h4>
 <div class="form-group">
 <label>Metalness</label>
 <input type="range" id="fullhand-head-metalness" min="0" max="1" step="0.01" value="0.2">
 <span id="fullhand-head-metalness-val">0.2</span>
 </div>
 <div class="form-group">
 <label>Roughness</label>
 <input type="range" id="fullhand-head-roughness" min="0" max="1" step="0.01" value="0.55">
 <span id="fullhand-head-roughness-val">0.55</span>
 </div>
 </div>
 <div class="modal-footer">
 <button class="modal-btn" onclick="document.getElementById('fullhand-edit-head-modal').classList.remove('active')">Close</button>
 <button class="modal-btn primary" onclick="applyHeadSettings()">Apply</button>
 </div>
 </div>
 
 <!-- Edit Hands Modal -->
 <div id="fullhand-edit-hands-modal" class="modal-window" style="top: 50%; left: 50%; transform: translate(-50%, -50%); width: 400px;">
 <div class="modal-header">
 <h3>Edit Hands</h3>
 <div class="modal-close" onclick="document.getElementById('fullhand-edit-hands-modal').classList.remove('active')"> </div>
 </div>
 <div class="modal-body" id="fullhand-edit-hands-content">
 <!-- Populated by lil-gui -->
 </div>
 </div>
 
 <!-- Save Configuration Modal -->
 <div id="fullhand-save-config-modal" class="modal-window">
 <div class="modal-header">
 <h3>Save Configuration</h3>
 <div class="modal-close" onclick="document.getElementById('fullhand-save-config-modal').classList.remove('active')"> </div>
 </div>
 <div class="modal-body">
 <div class="form-group">
 <label>Configuration Name</label>
 <input type="text" id="fullhand-config-name-input" placeholder="My Scene Configuration">
 </div>
 <div class="form-group">
 <label>Existing Configurations</label>
 <select id="fullhand-config-list-select" size="5" style="height: 120px;">
 <!-- Populated from localStorage -->
 </select>
 </div>
 </div>
 <div class="modal-footer">
 <button class="modal-btn" onclick="document.getElementById('fullhand-save-config-modal').classList.remove('active')">Cancel</button>
 <button class="modal-btn" onclick="saveAsConfiguration()">Save As New</button>
 <button class="modal-btn primary" onclick="saveConfiguration()">Save</button>
 </div>
 </div>
 
 <!-- Configuration Report Modal -->
 <div id="fullhand-config-report-modal" class="modal-window">
 <div class="modal-header">
 <h3>Configuration Report</h3>
 <div class="modal-close" onclick="document.getElementById('fullhand-config-report-modal').classList.remove('active')"> </div>
 </div>
 <div class="modal-body">
 <div id="fullhand-config-report-content" style="font-family: monospace; font-size: 12px; line-height: 1.6;">
 <!-- Populated dynamically -->
 </div>
 </div>
 <div class="modal-footer">
 <button class="modal-btn primary" onclick="document.getElementById('fullhand-config-report-modal').classList.remove('active')">Close</button>
 </div>
 </div>
 </div>


 <!-- ========== CELLI-REAL SCENE CONTAINER (HIDDEN INITIALLY) ========== -->
 <div id="cellireal-scene-container" style="display:none; position:fixed; inset:0; z-index:500; background:#0a0a0a;"></div>

 <!-- Celli-Real inline source (self-contained) -->
 <template id="cellireal-srcdoc">
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>Celli</title>
<script type="importmap">
{
 "imports": {
 "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
 "three/": "https://cdn.jsdelivr.net/npm/three@0.160.0/"
 }
}
</script>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Rubik:wght@400;600;800&family=Roboto+Mono:wght@400;600;700&display=swap" rel="stylesheet">
<script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
<!-- Twemoji for consistent emoji rendering -->
<script src="https://unpkg.com/twemoji@latest/dist/twemoji.min.js"></script>
<!-- TanStack Virtual for 2D sheet virtualization -->
<script src="https://unpkg.com/@tanstack/virtual-core@latest/dist/index.umd.js"></script>
<style>
:root{
 /* Reference palette */
 --bg:#f0f2f5; --ink:#1f2937; --muted:#5b6170; --panel:#ffffff; --line:#e5e7eb;
 --accent:#3b82f6; --accent-2:#22c55e; --accent-3:#f59e0b; --chip:#eef2ff;
 --shadow:0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
}
/* Background world gradient + optional spiral intensifier */
#world{ position:fixed; inset:0; background:radial-gradient(1200px 800px at 20% 10%, #93c5fd 0, transparent 70%), linear-gradient(135deg,#1e3a8a 0%,#3b82f6 50%,#93c5fd 100%); pointer-events:none; z-index:0 }
#world::after{ content:""; position:absolute; inset:-10%; opacity:0; pointer-events:none; mix-blend-mode:screen; background:conic-gradient(from 0deg at 50% 50%, rgba(59,130,246,.00) 0%, rgba(59,130,246,.08) 10%, rgba(147,197,253,.06) 20%, transparent 30%, rgba(59,130,246,.08) 40%, transparent 55%, rgba(147,197,253,.06) 70%, transparent 85%, rgba(59,130,246,.08) 100%); transform-origin:center; }
@keyframes swirl{ to{ transform:rotate(360deg); } }
.spiral #world::after{ opacity:.7; animation:swirl 8s linear infinite; }

/* Narrative icons */
.ui-icon{ position:fixed; width:50px; height:50px; background:#1f2937; border-radius:10px; box-shadow:var(--shadow); display:flex; align-items:center; justify-content:center; cursor:pointer; z-index:10002; transition:transform .2s ease; color:#e5e7eb; }
.ui-icon:hover{ transform:scale(1.1); }
.ui-icon svg{ pointer-events:none; }
#terminal-icon{ bottom:24px; right:24px; }
#notepad-icon{ bottom:108px; right:24px; }

/* Narrative windows */
#terminal{ position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); width:90vw; max-width:700px; height:460px; background:rgba(17,24,39,.95); border:1px solid rgba(255,255,255,.12); border-radius:12px; box-shadow:0 25px 50px -12px rgb(0 0 0 / .5); z-index:10002; display:none; flex-direction:column; color:#e5e7eb; font-family:'Roboto Mono',monospace; }
.win-header{ background:rgba(255,255,255,.06); padding:8px 12px; border-bottom:1px solid rgba(255,255,255,.12); display:flex; justify-content:space-between; align-items:center; user-select:none; cursor:move; }
.close{ width:20px; height:20px; background:#ef4444; border-radius:50%; cursor:pointer; }
#term{ flex-grow:1; padding:12px; overflow-y:auto; white-space:pre-wrap; word-break:break-word; overflow-wrap:break-word; line-height:1.35; }
#term .cursor::after{ content:' '; animation:blink .8s step-end infinite; }
#term .underscore::after{ content:'_'; animation:blink .75s step-end infinite; }
@keyframes blink{ 50%{ opacity:0; } }
/* Lanes for multi-processing thoughts */
#term .lane-wrap{ display:flex; gap:10px; }
#term .lane{ flex:1 1 0; min-width:0; }
/* Mood styles */
.soft{ opacity:.95; }
.artifact{ filter:saturate(0) contrast(1.2); opacity:.9; }
.catharsis{ color:#e5f2ff; text-shadow:0 0 10px rgba(147,197,253,.6), 0 0 24px rgba(59,130,246,.35); }
/* Glitch effect */
.glitch{ position:relative; display:inline-block; }
.glitch::before,.glitch::after{ content:attr(data-text); position:absolute; left:0; top:0; width:100%; pointer-events:none; }
.glitch::before{ color:rgba(59,130,246,.95); transform:translate(1px,0); animation:glitchA .55s steps(2,end) infinite; }
.glitch::after{ color:rgba(239,68,68,.9); transform:translate(-1px,0); animation:glitchB .5s steps(2,end) infinite; }
@keyframes glitchA{ 0%{clip-path:inset(0 0 70% 0)} 50%{clip-path:inset(30% 0 40% 0)} 100%{clip-path:inset(60% 0 0 0)} }
@keyframes glitchB{ 0%{clip-path:inset(60% 0 0 0)} 50%{clip-path:inset(30% 0 40% 0)} 100%{clip-path:inset(0 0 70% 0)} }
#pad{ position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); width:480px; height:360px; background:rgba(17,24,39,.95); border:1px solid rgba(255,255,255,.12); border-radius:20px; box-shadow:0 25px 50px -12px rgb(0 0 0 / .5); z-index:10002; display:none; color:#e5e7eb; overflow:hidden; flex-direction:column; backdrop-filter:blur(14px); }
#pad textarea{ width:100%; flex:1; background:inherit; color:inherit; border:none; padding:18px 18px 36px; font-family:'Roboto Mono',monospace; outline:none; resize:none; border-radius:16px; }
#pad .win-header{border-top-left-radius:20px; border-top-right-radius:20px;}
#pad .pad-resizer{position:absolute; right:10px; bottom:10px; width:18px; height:18px; background:linear-gradient(135deg, rgba(59,130,246,0.4), rgba(59,130,246,0.9)); border-radius:6px; cursor:nwse-resize; box-shadow:0 6px 14px rgba(15,23,42,0.2); border:1px solid rgba(255,255,255,0.4);}
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0;background:var(--bg);color:var(--ink);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;overscroll-behavior:none}
canvas#view{position:fixed;inset:0;width:100vw;height:100vh;display:block}
/* Intro overlay gradient that sits above 3D and behind sheet */
#introOverlay{position:fixed;inset:0;z-index:10000;pointer-events:none;
 background:linear-gradient(135deg, #1e3a8a 0%, #3b82f6 50%, #93c5fd 100%);
 opacity:1; transition:opacity .8s ease}
#introOverlay.hidden{opacity:0; pointer-events:none}

/* Panels */
.panel{position:fixed;z-index:10;background:var(--panel);border:1px solid var(--line);border-radius:16px;box-shadow:var(--shadow);padding:12px}
.panel#hud{z-index:10002}
.panel .title{font-weight:800;letter-spacing:.2px}
.row{display:flex;gap:8px;align-items:center}
.stack{display:flex;flex-direction:column;gap:8px}
.chip{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--line);padding:6px 10px;border-radius:999px;background:var(--chip);font-size:12px}
.btn{appearance:none;border:1px solid var(--line);background:#fff;padding:8px 12px;border-radius:10px;font-weight:600;cursor:pointer}
.btn:hover{border-color:#d1d5e4}
.btn:active{transform:translateY(1px)}
.btn.primary{background:var(--accent);border-color:#2162df;color:#fff}
.btn.good{background:var(--accent-2);border-color:#15a34a;color:#fff}
.btn.warn{background:var(--accent-3);border-color:#c0790a;color:#fff}
.kbd{font-family:Rubik,ui-monospace,Menlo,Consolas,monospace;border:1px solid var(--line);padding:1px 6px;border-radius:6px;background:#fff}
.code{font-family:Rubik,ui-monospace,Menlo,Consolas,monospace;background:#0b1220;color:#eaeefb;border-radius:10px;padding:10px 12px;font-size:12px;white-space:pre-wrap}
input[type=text]{width:100%;padding:8px 10px;border-radius:10px;border:1px solid var(--line);font-family:Rubik,ui-monospace,Menlo,Consolas,monospace;font-size:12px;white-space:pre}

/* Formula input highlighting (fx) */
.fx-wrap{position:relative;flex:1}
#fxHighlight{position:absolute;inset:0;padding:8px 10px;border-radius:10px;background:#fff;pointer-events:none;white-space:pre;overflow:hidden;font-family:Rubik,ui-monospace,Menlo,Consolas,monospace;font-size:12px;color:var(--ink)}
#fx{background:transparent;color:transparent;caret-color:var(--ink);position:relative}
.tok-str{color:#16a34a}
.tok-range{color:#f59e0b}
.tok-num{color:#1d4ed8}

/* HUD positions */
#hud{top:16px;left:16px;width:420px;display:none}
#right{top:16px;right:16px;width:380px;display:none}
#footer{display:none}
.sub{color:var(--muted);font-size:12px}

/* 2D Sheet + merged Fx UI */
.intro-centered{width:860px !important; height:520px !important; left:50% !important; top:50% !important; bottom:auto !important; transform:translate(-50%,-50%) !important}
#sheet{position:fixed; left:16px; bottom:16px; width:760px; height:440px; background:var(--panel); border:1px solid var(--line); border-radius:16px; box-shadow:var(--shadow); padding:12px; z-index:10001; display:flex; flex-direction:column; transition:all .9s cubic-bezier(0.34,1.56,0.64,1); overflow:hidden}
.intro-max{width:95vw !important; height:95vh !important; left:50% !important; top:50% !important; bottom:auto !important; transform:translate(-50%,-50%) !important}
body.crystal-2d #sheet{background:linear-gradient(150deg, rgba(255,255,255,0.22) 0%, rgba(221,238,255,0.28) 42%, rgba(236,233,255,0.18) 100%); border:1px solid rgba(255,255,255,0.58); box-shadow:0 30px 60px rgba(15,23,42,0.25), inset 0 1px 0 rgba(255,255,255,0.75); backdrop-filter:blur(26px) saturate(185%); -webkit-backdrop-filter:blur(26px) saturate(185%); position:fixed;}
body.crystal-2d #sheet::before{content:""; position:absolute; inset:-12% -18%; border-radius:28px; background:radial-gradient(120% 140% at 12% 8%, rgba(255,255,255,0.65) 0%, rgba(255,255,255,0.05) 55%), radial-gradient(140% 140% at 88% 92%, rgba(147,197,253,0.35) 0%, rgba(147,197,253,0.0) 65%); opacity:0.7; pointer-events:none; filter:blur(4px);}
body.crystal-2d #sheet::after{content:""; position:absolute; inset:-2px; border-radius:inherit; border:1px solid rgba(255,255,255,0.4); mix-blend-mode:soft-light; opacity:0.7; pointer-events:none;}
body.crystal-2d #sheet .sheet-head{background:rgba(255,255,255,0.22); border-bottom:1px solid rgba(255,255,255,0.45); box-shadow:inset 0 1px 0 rgba(255,255,255,0.6); backdrop-filter:blur(12px); -webkit-backdrop-filter:blur(12px);}
body.crystal-2d #sheet .sheet-title{color:#0f172a; text-shadow:0 1px 12px rgba(148,163,209,0.45);}
body.crystal-2d #sheet .sheet-ctrls .btn{background:rgba(255,255,255,0.55); border-color:rgba(148,163,209,0.45); color:#1f2937; box-shadow:0 12px 24px rgba(15,23,42,0.18); backdrop-filter:blur(8px); -webkit-backdrop-filter:blur(8px);}
body.crystal-2d #sheet .sheet-ctrls .btn:hover{border-color:rgba(59,130,246,0.55);}
body.crystal-2d table.sheet th{background:linear-gradient(180deg, rgba(255,255,255,0.5) 0%, rgba(229,240,255,0.28) 100%); border:1px solid rgba(255,255,255,0.45); color:#0f172a; text-shadow:0 1px 10px rgba(255,255,255,0.55); backdrop-filter:blur(10px); -webkit-backdrop-filter:blur(10px);}
body.crystal-2d table.sheet td{background:rgba(255,255,255,0.58); border:1px solid rgba(255,255,255,0.38); color:#0b1220; backdrop-filter:blur(12px); -webkit-backdrop-filter:blur(12px);}
body.crystal-2d table.sheet td.sel{background:rgba(96,165,250,0.32) !important; box-shadow:0 0 0 1px rgba(59,130,246,0.5) inset;}
body.crystal-2d table.sheet td.hovered{background:rgba(147,197,253,0.28) !important; border-color:rgba(96,165,250,0.5) !important;}
body.crystal-2d table.sheet td.cell:hover{background:rgba(191,219,254,0.33) !important;}
body.crystal-2d .note-tooltip{background:rgba(59,130,246,0.82); box-shadow:0 10px 22px rgba(59,130,246,0.28); backdrop-filter:blur(8px); -webkit-backdrop-filter:blur(8px);}
body.crystal-2d #sheetHeaderCard{background:rgba(241,245,255,0.52); border:1px solid rgba(255,255,255,0.58); box-shadow:0 26px 48px rgba(15,23,42,0.22); backdrop-filter:blur(28px) saturate(175%); -webkit-backdrop-filter:blur(28px) saturate(175%);}
body.crystal-2d #sheetHeaderCard.wipe{background:rgba(229,239,255,0.58);}
/* No body fade; overlay handles it */
.sheet-resizer{position:absolute; right:6px; bottom:6px; width:12px; height:12px; background:var(--accent); border-radius:3px; cursor:nwse-resize}
.sheet-head{display:flex;flex-direction:column;gap:8px; padding:8px; border-bottom:1px solid var(--line)}
/* Disable old floating chip header */
.app-header-float{ display:none }
/* Behind-sheet header card that expands to wipe */
#sheetHeaderCard{ position:fixed; z-index:10000; display:none; background:rgba(255,255,255,0.92); border:1px solid rgba(0,0,0,0.08); border-radius:18px; box-shadow:0 10px 30px rgba(0,0,0,0.18), inset 0 1px 0 rgba(255,255,255,0.65); backdrop-filter:saturate(150%) blur(8px); transition: all .6s cubic-bezier(.34,1.56,.64,1) }
#sheetHeaderCard.visible{ display:block }
#sheetHeaderCard.wipe{ left:0 !important; top:0 !important; width:100vw !important; height:100vh !important; border-radius:0 !important }
.sheet-title-row{display:flex;justify-content:space-between;align-items:center}
.sheet-title{font-weight:800}
.sheet-ctrls{display:flex;gap:6px;align-items:center}
.sheet-fx{display:flex; gap:6px; align-items:center; flex-wrap:wrap}
.sheet-fx input{flex:1}
/* Touch-only minimize (yellow dot) */
#minDot{ position:absolute; right:12px; top:12px; width:16px; height:16px; background:#facc15; border:1px solid #eab308; border-radius:50%; box-shadow:0 2px 6px rgba(0,0,0,.15); transform:scale(0); opacity:0; transition: transform .35s cubic-bezier(.34,1.56,.64,1), opacity .25s ease; z-index:5; display:none }
body.touch #minDot.show{ display:block; transform:scale(1); opacity:1 }
.sheet-body{flex:1; display:flex; overflow:hidden}
.col-headers{position:relative; margin-left:48px; height:60px; display:flex; gap:0}
.row-headers{width:48px; overflow:auto hidden; border-right:1px solid var(--line)}
.grid-wrap{flex:1; overflow:auto}
table.sheet{border-collapse:collapse; table-layout:fixed; width:max-content}
table.sheet td, table.sheet th{border:1px solid #e6e8ef; padding:0; height:60px; font-size:14px; font-family:'Roboto Mono', monospace}
/* Match reference code: use Roboto Mono for both headers and cells */
td.cell{width:92px; background:#fff; padding:0 6px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; cursor:pointer; text-align:left; font-family:'Roboto Mono', monospace}
/* Axes/header cells: soft gray */
table.sheet th{ background:#f9fafb; text-align:center; font-weight:600 }
/* Row header (Y labels) padding/width for non-touch */
table.sheet tr th:first-child{ min-width:56px; padding:0 10px }

/* Ensure compatibility with reference-style selector */
.sheet-table th,.sheet-table td{ border:1px solid var(--line); padding:6px 8px; min-width:60px; text-align:left; font-family:'Roboto Mono', monospace; font-size:14px }
.sheet-table th{ background:#f9fafb; text-align:center; font-weight:600 }
td.cell[data-generated="true"]{background:#f0fdf4} /* Light green for formula-emitted cells */
td.cell[data-anchor="true"]{background:#dcfce7} /* Darker green for anchor cells */
td.sel{outline:2px solid var(--accent); outline-offset:-2px; background:#eef5ff}
.cell.clickable{ cursor:pointer; }
.cell.pending{ background:#fef08a !important; }
.layer-chip{display:none}
.layer-btn{border:1px solid var(--line); background:#fff; border-radius:8px; padding:2px 6px; cursor:pointer}
#directEdit{position:fixed; z-index:30; padding:6px 8px; border-radius:8px; border:1px solid var(--line); font-family:Rubik,ui-monospace,Menlo,Consolas,monospace; display:none}

/* Header alignment fix: ensure headers match cell size exactly */
.col-headers .chip{height:60px; line-height:60px; min-width:80px; padding:0; text-align:center}
.row-headers .chip{height:60px; line-height:60px; width:48px; padding:0; text-align:center}

/* Cell hover like reference code */
td.cell:hover{background-color: #eff6ff !important}
/* Programmatic hover sync class for 2D */
td.cell.hovered{background-color:#e0f2ff !important; border:1px solid #93c5fd !important}
/* Note tooltip - simple blue card on hover */
.note-tooltip{position:absolute; top:-30px; left:10px; background:#3b82f6; color:white; padding:4px 8px; border-radius:6px; font-size:11px; white-space:nowrap; opacity:0; transform:translateY(4px); transition:opacity .2s ease, transform .2s ease; pointer-events:none; z-index:200}
.cell:hover .note-tooltip{opacity:1; transform:translateY(0)}
.note-visible{opacity:1 !important; transform:translateY(0) !important}
/* Special styling for intro cell */
.intro-cell{position:relative; background:#e0e7ff !important; font-weight:600; overflow:visible !important}

/* Touch mode scaling */
body.touch #sheet{ width:86vw; height:40vh }
body.touch table.sheet td, body.touch table.sheet th{ height:34px; font-size:14px }
body.touch td.cell{ width:120px }
body.touch .ui-icon{ width:64px; height:64px }
body.touch #dpad{ --dp:64px; gap:8px; right:16px; bottom:16px }
body.touch .desktop-only{ display:none !important }
body.touch .mobile-only{ display:flex !important }
body:not(.touch) .mobile-only{ display:none !important }
body:not(.touch) .desktop-only{ display:flex !important }
/* Touch-friendly sheet sizing: full device width card at bottom */
body.touch #sheet{ left:50%; right:auto; width:min(92vw, 680px); height:40vh; bottom:12px; top:auto; transform:translateX(-50%) }
body.touch #graphicsSettingsPanel,
body.touch #oceanSettingsPanel{
 position:fixed !important;
 left:50% !important;
 top:50% !important;
 transform:translate(-50%,-50%) !important;
 right:auto !important;
 bottom:auto !important;
 width:min(92vw, 420px) !important;
 max-height:80vh !important;
 z-index:10004 !important;
}
body.touch .sheet-body .sheet td, body.touch .sheet-body .sheet th{ height:36px; font-size:15px }
/* Make cells scale to ~8 columns (minus row header) */
body.touch .sheet-body .sheet td.cell{ width:calc((100vw - 24px - 150px)/8) }

/* Touch-friendly sheet sizing: full device width with small gutters */
body.touch #sheet{ left:50%; right:auto; width:min(92vw, 680px); height:40vh; transform:translateX(-50%) }
body.touch .sheet-body .sheet td, body.touch .sheet-body .sheet th{ height:36px; font-size:15px }
/* Make cells scale to roughly 8 visible columns minus row header */
body.touch .sheet-body .sheet td.cell{ width:calc((100vw - 24px - 140px)/8) }
/* Touch: opening (intro-centered) should be a centered card with mobile dimensions */
body.touch #sheet.intro-centered{ width:min(92vw, 680px) !important; height:40vh !important; left:50% !important; top:50% !important; bottom:auto !important; transform:translate(-50%,-50%) !important }
/* Hide debug console by default on touch; allow button to show it */
body.touch #hud{ display:none }
#debug-icon{ position:fixed; left:24px; bottom:24px; z-index:10003 }

/* Fx panel (docs) */
#fxPanel{position:relative; flex:0 0 340px; height:100%; background:var(--panel); border:1px solid var(--line); border-radius:16px; box-shadow:var(--shadow); display:none; flex-direction:column; z-index:11; opacity:0; transform:translateX(12px); transition:opacity .25s ease, transform .25s ease, box-shadow .25s ease}
.fx-visible{display:flex !important; opacity:1 !important; transform:translateX(0) !important}
.fx-panel{margin-left:12px; border-left:1px solid var(--line)}
.fx-head{display:flex; align-items:center; justify-content:space-between; padding:8px 12px; border-bottom:1px solid var(--line)}
.fx-body{flex:1; overflow:auto; padding:8px 12px}
.fx-item{border:1px solid var(--line); border-radius:12px; padding:8px 10px; margin-bottom:8px}
.fx-name{font-weight:800}
.fx-syntax{font-family:Rubik,ui-monospace,Menlo,Consolas,monospace; background:#0b1220; color:#eaeefb; padding:6px 8px; border-radius:8px; font-size:12px; margin-top:6px}
.fx-desc{font-size:12px; color:var(--muted); margin-top:6px}
.fx-copy{font-size:12px; border:1px solid var(--line); padding:4px 8px; border-radius:8px; cursor:pointer}
.fx-category-header{transition: background-color 0.2s;}
.fx-category-header:hover{background-color: rgba(0,0,0,0.05) !important;}
.fx-category-body{overflow:hidden; transition: all 0.3s ease;}
.fx-item{border:1px solid var(--line); border-radius:8px; padding:6px 8px; margin-bottom:4px; background:#fff;}

/* Toast */
#toast{position:fixed; left:50%; transform:translateX(-50%); top:16px; padding:8px 12px; border-radius:10px; background:#111827; color:#fff; font-size:12px; display:none; z-index:50}

/* Brand card on intro overlay */
#introBrand{position:absolute; left:24px; top:24px; transform:none; z-index:10001; display:flex; flex-direction:column; align-items:center; justify-content:center; padding:16px 28px; border-radius:28px; color:#0b1320; font-weight:700; font-size:22px; letter-spacing:.2px; box-shadow:0 10px 30px rgba(0,0,0,0.20), inset 0 1px 0 rgba(255,255,255,0.75); border:1px solid rgba(255,255,255,0.35); background:linear-gradient(180deg, rgba(255,255,255,0.52), rgba(255,255,255,0.30)); backdrop-filter:blur(20px) saturate(180%)}
#introBrand::before{content:""; position:absolute; inset:0; border-radius:28px; background:radial-gradient(120px 80px at 20% 30%, rgba(59,130,246,0.35), transparent 60%), radial-gradient(140px 100px at 80% 70%, rgba(236,72,153,0.28), transparent 60%); pointer-events:none; filter:blur(8px)}
#introBrand .brand-ver{font-weight:400; font-size:12px; opacity:.8; margin-top:3px}

/* D-Pad HUD (soft lab style) */
#dpad{
 --dp:56px;
 position:fixed; right:24px; bottom:24px; z-index:20;
 display:grid;
 grid-template-columns: var(--dp) var(--dp) var(--dp);
 grid-template-rows: var(--dp) var(--dp) var(--dp);
 grid-template-areas:
 "grab up depthUp"
 "left center right"
 "present down depthDown";
 gap:10px;
}
#dpad .dp{
 width:var(--dp); height:var(--dp);
 border:1px solid #2162df;
 border-radius:12px; 
 background:var(--accent);
 color:#fff; 
 display:flex; align-items:center; justify-content:center; 
 cursor:pointer; font-weight:800; font-size:18px; 
 box-shadow: var(--shadow);
}
#dpad .dp:hover{filter:brightness(1.06)}
#dpad .dp:active{transform:translateY(1px)}
#dpad .up{grid-area:up}
#dpad .left{grid-area:left}
#dpad .right{grid-area:right}
#dpad .down{grid-area:down}
#dpad .depthUp{grid-area:depthUp}
#dpad .depthDown{grid-area:depthDown}
#dpad .jump{grid-area:depthUp; background:#22c55e; border-color:#16a34a}
#dpad .center{grid-area:center; visibility:visible; font-size:14px}
#dpad .present{grid-area:present; background:#fff; color:#1f2937; border:1px solid #d1d5e4; font-weight:700; display:flex; align-items:center; justify-content:center;}
#dpad .present.active{background:var(--accent-2); border-color:#15803d; color:#fff;}
#dpad .grab{grid-area:grab; width:calc(var(--dp)*0.7); height:calc(var(--dp)*0.7); align-self:center; justify-self:center; border:1px dashed #e5e7eb; background:#ffffffaa; color:#1f2937; font-size:14px; display:flex; align-items:center; justify-content:center; cursor:grab}
#dpad .grab:active{cursor:grabbing}
body.touch #dpad .grab{pointer-events:none; opacity:0.3}

/* Visible focus for keyboard users */
:where(button,[role="button"],a,input,select,textarea,[tabindex]):focus-visible{
 outline: 2px solid rgba(59,130,246,0.8);
 outline-offset: 2px;
}
@media (prefers-contrast: more){
 :where(button,[role="button"],a,input,select,textarea,[tabindex]):focus-visible{
 outline-width: 3px;
 }
}







/* Respect reduced motion preferences */
@media (prefers-reduced-motion: reduce){
 .anim-spin, .anim-pulse, #world::after{
 animation: none !important;
 transition-duration: 0.001ms !important;
 }
}

/* Twemoji styling */
img.emoji {
 height: 1em;
 width: 1em;
 margin: 0 0.05em 0 0.1em;
 vertical-align: -0.1em;
}
</style>

</head>
<body>

<script>
(function(){
 var reduce = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
 if(reduce){ document.documentElement.classList.add('reduced-motion'); }
 if(reduce && !window.__rafPatched){
 window.__rafPatched = true;
 var _raf = window.requestAnimationFrame;
 window.requestAnimationFrame = function(cb){
 return setTimeout(function(){ try{ cb(performance.now()); }catch(e){} }, 250);
 };
 }
})();
</script>
<script>
document.addEventListener('click', function(e){
 try{
 var btn = e.target && e.target.closest && e.target.closest('button[aria-pressed]');
 if(!btn) return;
 var next = (btn.getAttribute('aria-pressed') !== 'true').toString();
 btn.setAttribute('aria-pressed', next);
 }catch{}
}, {capture:true});
</script>
<script>
(function(){
 try{
 var canvas=document.createElement('canvas');
 var ok = !!(window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
 if(!ok){
 var wrap=document.createElement('div');
 wrap.setAttribute('role','alert');
 wrap.style.cssText='position:fixed;inset:0;display:flex;align-items:center;justify-content:center;padding:24px;background:rgba(0,0,0,0.6);z-index:99999;';
 wrap.innerHTML='<div style="max-width:640px;background:#fff;color:#111;border-radius:12px;padding:20px;box-shadow:0 10px 30px rgba(0,0,0,.2)"><h2 style="margin:0 0 8px">WebGL not available</h2><p>The 3D view is unavailable. You can still work with the sheet. Try updating your browser or enable hardware acceleration.</p></div>';
 document.body.appendChild(wrap);
 document.documentElement.classList.add('no-webgl');
 }
 }catch(e){ console.warn('WebGL check failed', e); }
})();
</script>
<div id="introOverlay"><div id="introBrand">celli.os<div class="brand-ver">v.0.0.1</div></div></div>
<div id="world"></div>
<canvas id="view"></canvas>

<!-- Debug/builder card -->
<div class="panel stack" id="hud" style="padding:0; overflow:hidden">
 <div class="win-header" style="background:rgba(255,255,255,.06);display:flex;align-items:center;justify-content:space-between;padding:8px 12px;border-bottom:1px solid rgba(255,255,255,.12)"><span>DEBUG CONSOLE</span><div id="debug-close" class="close" title="Hide"></div></div>
 <div class="sub" style="padding:0 12px 8px;">Click cells <span class="kbd">? ? ? ?</span> move <span class="kbd">Enter</span> edit <span class="kbd">P</span> physics <span class="kbd">F</span> functions</div>
 
 <!-- Navigation & View Controls -->
 <div class="row" style="padding:0 12px 6px;">
 <button class="btn primary" id="centerHome">?? Home</button>
 <button class="btn" id="viewMainframe">??? Mainframe</button>
 <button class="btn" id="toggleGrid">Grid</button>
 <button class="btn" id="toggleAxes">Axes</button>
 </div>
 
 <!-- Scene & Physics Controls -->
 <div class="row" style="padding:0 12px 6px;">
 <button class="btn good" id="physicsBtn">? Physics</button>
 <button class="btn" id="toggleChunks">?? Chunks</button>
 <button class="btn warn" id="reset">?? Reset</button>
 </div>

 <div class="row" style="padding:0 12px 6px;">
 <button class="btn" id="presentToggleBtn">?? Present: OFF</button>
 <button class="btn" id="graphicsSettingsBtn">??? Graphic Settings</button>
 <button class="btn" id="oceanSettingsBtn">?? Ocean Backdrop</button>
 </div>

 <label class="row" style="padding:0 12px 6px; justify-content:space-between; align-items:center; font-weight:600;">
 <span>Crystal 2D Style</span>
 <input type="checkbox" id="crystal2DToggle">
 </label>

 <!-- Data Import/Export -->
 <div class="row" style="padding:0 12px 6px;">
 <button class="btn" id="importFileBtn">?? Import File</button>
 <button class="btn" id="pasteDataBtn">?? Paste Data</button>
 </div>
 
 <!-- Save System -->
 <div class="row" style="padding:0 12px 6px;">
 <button class="btn good" id="saveStateBtn">?? Save</button>
 <button class="btn" id="loadStateBtn">?? Load</button>
 <button class="btn warn" id="clearSaveBtn">??? Clear Save</button>
 </div>
 
 <!-- Save Status -->
 <div style="padding:0 12px 12px; font-size:11px; color:var(--muted);">
 <span id="saveStatus">Auto-save: Ready</span>
 </div>
</div>

<div class="panel stack" id="graphicsSettingsPanel" style="display:none; position:absolute; left:440px; top:16px; width:320px; max-height:80vh; overflow:auto;">
 <div class="win-header" style="background:rgba(255,255,255,.06);display:flex;align-items:center;justify-content:space-between;padding:8px 12px;border-bottom:1px solid rgba(255,255,255,.12)">
 <span>Graphic Settings</span>
 <div id="graphicsSettingsClose" class="close" title="Hide"></div>
 </div>
 <div class="stack" style="padding:12px; gap:12px;">
 <div class="sub" id="graphicsSettingsHint">Enable Present mode to tweak fancy rendering.</div>

 <div class="stack" style="gap:6px;">
 <div class="title" style="font-size:14px;">Environment</div>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Studio HDRI</span>
 <input type="checkbox" id="gfxHdri">
 </label>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>3-Point Lighting</span>
 <input type="checkbox" id="gfxLights">
 </label>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Dark Background</span>
 <input type="checkbox" id="gfxDarkBg">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Light Rotation <span id="gfxLightRotationValue"></span></span>
 <input type="range" id="gfxLightRotation" min="0" max="360" step="1">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Light Strength <span id="gfxLightStrengthValue"></span></span>
 <input type="range" id="gfxLightStrength" min="0" max="2" step="0.05">
 </label>
 </div>

 <div class="stack" style="gap:6px;">
 <div class="title" style="font-size:14px;">Cinematic</div>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Bloom</span>
 <input type="checkbox" id="gfxBloom">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Bloom Strength <span id="gfxBloomStrengthValue"></span></span>
 <input type="range" id="gfxBloomStrength" min="0" max="1" step="0.01">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Bloom Radius <span id="gfxBloomRadiusValue"></span></span>
 <input type="range" id="gfxBloomRadius" min="0" max="1" step="0.05">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Exposure <span id="gfxExposureValue"></span></span>
 <input type="range" id="gfxExposure" min="0.4" max="2" step="0.05">
 </label>
 </div>

 <div class="stack" style="gap:6px;">
 <div class="title" style="font-size:14px;">Depth of Field</div>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Depth of Field</span>
 <input type="checkbox" id="gfxDof">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Aperture <span id="gfxDofApertureValue"></span></span>
 <input type="range" id="gfxDofAperture" min="0" max="0.02" step="0.0005">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Max Blur <span id="gfxDofMaxBlurValue"></span></span>
 <input type="range" id="gfxDofMaxBlur" min="0" max="0.02" step="0.0005">
 </label>
 </div>

 <div class="stack" style="gap:6px;">
 <div class="title" style="font-size:14px;">Visual Extras</div>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Frosted Glass</span>
 <input type="checkbox" id="gfxTransmission">
 </label>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Reflective Ground</span>
 <input type="checkbox" id="gfxMirror">
 </label>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Solid Ground</span>
 <input type="checkbox" id="gfxGround">
 </label>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Deforming Grid</span>
 <input type="checkbox" id="gfxWaveGrid">
 </label>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>FXAA</span>
 <input type="checkbox" id="gfxFxaa">
 </label>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Fog</span>
 <input type="checkbox" id="gfxFog">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Fog Density <span id="gfxFogDensityValue"></span></span>
 <input type="range" id="gfxFogDensity" min="0" max="0.05" step="0.001">
 </label>
 </div>

 <div class="stack" style="gap:6px;">
 <div class="title" style="font-size:14px;">Stylization</div>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Selection Outline</span>
 <input type="checkbox" id="gfxOutline">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Outline Strength <span id="gfxOutlineStrengthValue"></span></span>
 <input type="range" id="gfxOutlineStrength" min="0" max="5" step="0.1">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Outline Thickness <span id="gfxOutlineThicknessValue"></span></span>
 <input type="range" id="gfxOutlineThickness" min="0" max="4" step="0.1">
 </label>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Motion Blur</span>
 <input type="checkbox" id="gfxMotion">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Blur Damping <span id="gfxMotionDampingValue"></span></span>
 <input type="range" id="gfxMotionDamping" min="0.7" max="0.99" step="0.005">
 </label>
 </div>
 </div>
</div>

<div class="panel stack" id="oceanSettingsPanel" style="display:none; position:absolute; left:440px; top:340px; width:360px; max-height:80vh; overflow:auto;">
 <div class="win-header" style="background:rgba(255,255,255,.06);display:flex;align-items:center;justify-content:space-between;padding:8px 12px;border-bottom:1px solid rgba(255,255,255,.12)">
 <span>Ocean Backdrop</span>
 <div id="oceanSettingsClose" class="close" title="Hide"></div>
 </div>
 <div class="stack" style="padding:12px; gap:12px;">
 <div class="sub" id="oceanSettingsHint">Enable Present mode and toggle on the ocean backdrop to adjust these settings.</div>

 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Enable Ocean</span>
 <input type="checkbox" id="oceanEnable">
 </label>

 <div class="stack" style="gap:10px;">
 <div class="title" style="font-size:14px;">General</div>
 <label class="stack" style="gap:4px;">
 <span class="sub">Env Intensity <span id="oceanEnvIntensityValue"></span></span>
 <input type="range" id="oceanEnvIntensity" min="0" max="4" step="0.05">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Key Light Intensity <span id="oceanLightIntensityValue"></span></span>
 <input type="range" id="oceanLightIntensity" min="0" max="5" step="0.05">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Exposure <span id="oceanExposureValue"></span></span>
 <input type="range" id="oceanExposure" min="0.3" max="2.5" step="0.01">
 </label>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Grid Overlay</span>
 <input type="checkbox" id="oceanShowGrid">
 </label>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Buoy Sphere</span>
 <input type="checkbox" id="oceanShowSphere">
 </label>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Dead Towers</span>
 <input type="checkbox" id="oceanShowTowers">
 </label>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Floating Lights</span>
 <input type="checkbox" id="oceanShowFloaters">
 </label>
 <button class="btn" id="oceanScreenshotBtn">?? Capture Screenshot</button>
 </div>

 <div class="stack" style="gap:10px;">
 <div class="title" style="font-size:14px;">Sky &amp; Sun</div>
 <label class="stack" style="gap:4px;">
 <span class="sub">Sun Elevation <span id="oceanSunElevationValue"></span></span>
 <input type="range" id="oceanSunElevation" min="0" max="90" step="1">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Sun Azimuth <span id="oceanSunAzimuthValue"></span></span>
 <input type="range" id="oceanSunAzimuth" min="0" max="360" step="1">
 </label>
 <label class="stack" style="gap:4px;">
 <span>Sky Top</span>
 <input type="color" id="oceanSkyTop" value="#8ec1ea">
 </label>
 <label class="stack" style="gap:4px;">
 <span>Sky Mid</span>
 <input type="color" id="oceanSkyMid" value="#63aee3">
 </label>
 <label class="stack" style="gap:4px;">
 <span>Sky Bottom</span>
 <input type="color" id="oceanSkyBot" value="#092c4d">
 </label>
 </div>

 <div class="stack" style="gap:10px;">
 <div class="title" style="font-size:14px;">Waves</div>
 <label class="stack" style="gap:4px;">
 <span class="sub">Time Scale <span id="oceanTimeScaleValue"></span></span>
 <input type="range" id="oceanTimeScale" min="0.1" max="3" step="0.01">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Choppiness <span id="oceanChoppinessValue"></span></span>
 <input type="range" id="oceanChoppiness" min="0" max="2" step="0.01">
 </label>
 <div class="sub" style="font-weight:600;">Gerstner Bands</div>
 <div class="stack" style="gap:6px;">
 <div class="stack" style="gap:4px;" data-wave="0">
 <span class="sub">Band 0 Amplitude <span id="oceanAmp0Value"></span></span>
 <input type="range" id="oceanAmp0" min="0" max="2" step="0.01">
 <span class="sub">Band 0 Wavelength <span id="oceanLen0Value"></span></span>
 <input type="range" id="oceanLen0" min="1" max="50" step="0.1">
 <span class="sub">Band 0 Speed <span id="oceanSpeed0Value"></span></span>
 <input type="range" id="oceanSpeed0" min="0.1" max="3" step="0.01">
 </div>
 <div class="stack" style="gap:4px;" data-wave="1">
 <span class="sub">Band 1 Amplitude <span id="oceanAmp1Value"></span></span>
 <input type="range" id="oceanAmp1" min="0" max="2" step="0.01">
 <span class="sub">Band 1 Wavelength <span id="oceanLen1Value"></span></span>
 <input type="range" id="oceanLen1" min="1" max="50" step="0.1">
 <span class="sub">Band 1 Speed <span id="oceanSpeed1Value"></span></span>
 <input type="range" id="oceanSpeed1" min="0.1" max="3" step="0.01">
 </div>
 <div class="stack" style="gap:4px;" data-wave="2">
 <span class="sub">Band 2 Amplitude <span id="oceanAmp2Value"></span></span>
 <input type="range" id="oceanAmp2" min="0" max="2" step="0.01">
 <span class="sub">Band 2 Wavelength <span id="oceanLen2Value"></span></span>
 <input type="range" id="oceanLen2" min="1" max="50" step="0.1">
 <span class="sub">Band 2 Speed <span id="oceanSpeed2Value"></span></span>
 <input type="range" id="oceanSpeed2" min="0.1" max="3" step="0.01">
 </div>
 <div class="stack" style="gap:4px;" data-wave="3">
 <span class="sub">Band 3 Amplitude <span id="oceanAmp3Value"></span></span>
 <input type="range" id="oceanAmp3" min="0" max="2" step="0.01">
 <span class="sub">Band 3 Wavelength <span id="oceanLen3Value"></span></span>
 <input type="range" id="oceanLen3" min="1" max="50" step="0.1">
 <span class="sub">Band 3 Speed <span id="oceanSpeed3Value"></span></span>
 <input type="range" id="oceanSpeed3" min="0.1" max="3" step="0.01">
 </div>
 <div class="stack" style="gap:4px;" data-wave="4">
 <span class="sub">Band 4 Amplitude <span id="oceanAmp4Value"></span></span>
 <input type="range" id="oceanAmp4" min="0" max="2" step="0.01">
 <span class="sub">Band 4 Wavelength <span id="oceanLen4Value"></span></span>
 <input type="range" id="oceanLen4" min="1" max="50" step="0.1">
 <span class="sub">Band 4 Speed <span id="oceanSpeed4Value"></span></span>
 <input type="range" id="oceanSpeed4" min="0.1" max="3" step="0.01">
 </div>
 <div class="stack" style="gap:4px;" data-wave="5">
 <span class="sub">Band 5 Amplitude <span id="oceanAmp5Value"></span></span>
 <input type="range" id="oceanAmp5" min="0" max="2" step="0.01">
 <span class="sub">Band 5 Wavelength <span id="oceanLen5Value"></span></span>
 <input type="range" id="oceanLen5" min="1" max="50" step="0.1">
 <span class="sub">Band 5 Speed <span id="oceanSpeed5Value"></span></span>
 <input type="range" id="oceanSpeed5" min="0.1" max="3" step="0.01">
 </div>
 </div>
 </div>

 <div class="stack" style="gap:10px;">
 <div class="title" style="font-size:14px;">Ocean Shader</div>
 <label class="stack" style="gap:4px;">
 <span>Deep Water</span>
 <input type="color" id="oceanDeepColor" value="#0b345a">
 </label>
 <label class="stack" style="gap:4px;">
 <span>Shallow Water</span>
 <input type="color" id="oceanShallowColor" value="#1e6aa2">
 </label>
 <label class="stack" style="gap:4px;">
 <span>Foam Color</span>
 <input type="color" id="oceanFoamColor" value="#ffffff">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Foam Amount <span id="oceanFoamAmountValue"></span></span>
 <input type="range" id="oceanFoamAmount" min="0" max="5" step="0.1">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Foam Threshold <span id="oceanFoamBiasValue"></span></span>
 <input type="range" id="oceanFoamBias" min="-1" max="3" step="0.05">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Foam Sharpness <span id="oceanFoamScaleValue"></span></span>
 <input type="range" id="oceanFoamScale" min="0.1" max="5" step="0.1">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Max Gloss <span id="oceanMaxGlossValue"></span></span>
 <input type="range" id="oceanMaxGloss" min="0" max="1" step="0.01">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Roughness Scale <span id="oceanRoughnessScaleValue"></span></span>
 <input type="range" id="oceanRoughnessScale" min="0.0001" max="0.02" step="0.0001">
 </label>
 <label class="stack" style="gap:4px;">
 <span>Horizon Color</span>
 <input type="color" id="oceanHorizonColor" value="#cfeaff">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Horizon Fade Start <span id="oceanHorizonStartValue"></span></span>
 <input type="range" id="oceanHorizonStart" min="10" max="400" step="1">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Horizon Fade End <span id="oceanHorizonEndValue"></span></span>
 <input type="range" id="oceanHorizonEnd" min="50" max="900" step="1">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Horizon Boost <span id="oceanHorizonBoostValue"></span></span>
 <input type="range" id="oceanHorizonBoost" min="0" max="2" step="0.01">
 </label>
 </div>

 <div class="stack" style="gap:10px;">
 <div class="title" style="font-size:14px;">Micro Ripples</div>
 <label class="stack" style="gap:4px;">
 <span class="sub">Ripple Strength <span id="oceanMicroScaleValue"></span></span>
 <input type="range" id="oceanMicroScale" min="0" max="0.15" step="0.005">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Ripple Frequency <span id="oceanMicroFreqValue"></span></span>
 <input type="range" id="oceanMicroFreq" min="5" max="50" step="0.5">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Ripple Size Scale <span id="oceanMicroWaveScaleValue"></span></span>
 <input type="range" id="oceanMicroWaveScale" min="0.1" max="2" step="0.05">
 </label>
 </div>

 <div class="stack" style="gap:10px;">
 <div class="title" style="font-size:14px;">Post Processing</div>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Enable Bloom</span>
 <input type="checkbox" id="oceanEnableBloom">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Bloom Strength <span id="oceanBloomStrengthValue"></span></span>
 <input type="range" id="oceanBloomStrength" min="0" max="2" step="0.01">
 </label>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Enable Vignette</span>
 <input type="checkbox" id="oceanEnableVignette">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Vignette Strength <span id="oceanVignetteStrengthValue"></span></span>
 <input type="range" id="oceanVignetteStrength" min="0" max="2" step="0.01">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Film Grain <span id="oceanGrainAmountValue"></span></span>
 <input type="range" id="oceanGrainAmount" min="0" max="0.1" step="0.001">
 </label>
 </div>

 <div class="stack" style="gap:10px;">
 <div class="title" style="font-size:14px;">God Rays</div>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Enable Rays</span>
 <input type="checkbox" id="oceanEnableRays">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Ray Strength <span id="oceanRayStrengthValue"></span></span>
 <input type="range" id="oceanRayStrength" min="0" max="4" step="0.01">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Ray Decay <span id="oceanRayDecayValue"></span></span>
 <input type="range" id="oceanRayDecay" min="0.6" max="1" step="0.001">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Ray Exposure <span id="oceanRayExposureValue"></span></span>
 <input type="range" id="oceanRayExposure" min="0" max="2.5" step="0.01">
 </label>
 </div>

 <div class="stack" style="gap:10px;">
 <div class="title" style="font-size:14px;">Lighthouse Beams</div>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Enable Beams</span>
 <input type="checkbox" id="oceanEnableLighthouse">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Beam Strength <span id="oceanLighthouseStrengthValue"></span></span>
 <input type="range" id="oceanLighthouseStrength" min="0" max="2.5" step="0.01">
 </label>
 </div>

 <div class="stack" style="gap:10px;">
 <div class="title" style="font-size:14px;">Depth of Field &amp; Fog</div>
 <label class="stack" style="gap:4px;">
 <span class="sub">Focus Distance <span id="oceanFocusDistanceValue"></span></span>
 <input type="range" id="oceanFocusDistance" min="5" max="1000" step="1">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">DOF Strength <span id="oceanDofStrengthValue"></span></span>
 <input type="range" id="oceanDofStrength" min="0" max="3" step="0.01">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Focus Range <span id="oceanFocusRangeValue"></span></span>
 <input type="range" id="oceanFocusRange" min="10" max="500" step="1">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Fog Start <span id="oceanFogStartValue"></span></span>
 <input type="range" id="oceanFogStart" min="50" max="1000" step="1">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Fog End <span id="oceanFogEndValue"></span></span>
 <input type="range" id="oceanFogEnd" min="200" max="3000" step="10">
 </label>
 <label class="stack" style="gap:4px;">
 <span>Fog Color</span>
 <input type="color" id="oceanFogColor" value="#5aaee3">
 </label>
 </div>

 <div class="stack" style="gap:10px;">
 <div class="title" style="font-size:14px;">Grid Overlay</div>
 <label class="stack" style="gap:4px;">
 <span class="sub">Grid Density <span id="oceanGridDensityValue"></span></span>
 <input type="range" id="oceanGridDensity" min="32" max="256" step="32">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Grid Opacity <span id="oceanGridOpacityValue"></span></span>
 <input type="range" id="oceanGridOpacity" min="0" max="1" step="0.01">
 </label>
 </div>
 </div>
</div>

<div class="panel stack" id="right" style="display:none"></div>

<div class="panel" id="footer">
 <span class="chip" id="statusChip">Booting </span>
 <span class="chip">Chunked</span>
 <span class="chip">Deps</span>
 <span class="chip" id="physChip">Physics: OFF</span>
 <span class="chip">Fn-Tags</span>
 <span class="chip" id="countChip">Counts: </span>
</div>

<!-- Screen-space D-Pad (bottom-right) -->
 <div id="dpad" aria-label="D-Pad">
 <div class="dp grab" title="Drag">?</div>
 <div class="dp up" data-dir="up">?</div>
 <div class="dp depthUp desktop-only" data-dir="depthUp">?</div>
 <div class="dp jump mobile-only" data-action="jump" style="display:none" title="Jump">?</div>
 <div class="dp left" data-dir="left">?</div>
 <div class="dp center desktop-only" title="Arrow mapping"><span style="display:inline-block;width:16px;height:12px;border:2px solid #fff;border-radius:3px"></span>&nbsp;<span id="depthMode">H</span></div>
 <div class="dp center mobile-only" style="display:none;cursor:default;pointer-events:none;opacity:0.3">?</div>
 <div class="dp depthDown desktop-only" data-dir="depthDown">?</div>
 <div class="dp present" role="button" data-action="present" aria-pressed="false" title="Enter Present Mode">?</div>
 <div class="dp down" data-dir="down">?</div>
 <div class="dp right" data-dir="right">?</div>
 </div>

<!-- 2D Sheet with merged Fx UI -->
<div id="sheetHeaderCard"></div>
<div id="sheet" class="intro-centered" aria-label="2D Sheet">
 <div class="sheet-head">
 <div class="sheet-title-row" style="display:flex;align-items:center;justify-content:space-between;">
 <div style="display:flex;align-items:center;gap:8px;">
 <button class="layer-btn" id="prevArray" style="display:none">?</button>
 <div class="sheet-title" id="sheetTitle" style="font-family:Inter, system-ui; font-weight:600;"></div>
 <button class="layer-btn" id="nextArray" style="display:none">?</button>
 </div>
 <div class="sheet-ctrls" style="display:flex;gap:6px;align-items:center;">
 <button class="btn" id="copyAddress" title="Copy Address" aria-label="Copy Address">@</button>
 <button class="btn" id="toggleAddressMode" title="Toggle Local/Absolute">A1a</button>
 <div id="color-picker-wrapper" title="Fill Color" style="display:flex; flex-direction:column; width:120px; gap:6px;">
 <input type="color" id="fillColorPicker" value="#ffffff" style="width:36px; height:36px; border-radius:8px; cursor:pointer; border:none; padding:0; background:transparent" />
 <div id="fillColorPreview" style="width:100%; height:12px; border:1px solid var(--line); border-radius:6px; pointer-events:none;"></div>
 <div style="display:flex; gap:6px; align-items:center;">
 <label class="kbd" style="display:flex; align-items:center; gap:6px;">
 <input type="checkbox" id="fillColorLive" checked /> Live
 </label>
 <button class="btn" id="fillColorApply" title="Apply color to selection">Apply</button>
 <button class="btn" id="fillColorClear" title="Clear cell color">Clear</button>
 </div>
 </div>
 <button class="btn" id="viewToggleBtn" title="Toggle 3D View Mode" style="width: 36px; height: 36px; padding: 6px;">
 <svg id="viewToggleIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
 <path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"></path>
 <circle cx="12" cy="12" r="3"></circle>
 </svg>
 </button>
 <button class="btn" id="toggleFxPanel" title="Functions" aria-label="Toggle formula panel" aria-pressed="false">Fx</button>
 </div>
 </div>
 <!-- Formula row placed beneath label/buttons -->
 <div class="sheet-fx" style="display:flex; gap:6px; align-items:center; margin-top:6px;">
 <div class="fx-wrap" style="flex:1;">
 <div id="fxHighlight" aria-hidden="true"></div>
 <input type="text" id="fx" placeholder='=ARRAY("Hello","World")'>
 </div>
 <button class="btn primary" id="applyFx" title="Apply">?</button>
 </div>
 <div id="minDot" title="Minimize"></div>
 </div>
 <div class="sheet-body" style="position:relative; display:flex; align-items:stretch">
 <div class="grid-wrap" style="flex:1; overflow:auto">
 <table class="sheet">
 <thead><tr id="cols"><th></th></tr></thead>
 <tbody id="rows"></tbody>
 </table>
</div>
 </div>
 <div class="sheet-resizer" id="sheetResizer" title="Resize"></div>
<div id="fxPanel" class="fx-panel">
 <div class="fx-head">
 <div class="title">Functions</div>
 <button class="btn" id="fxClose">Close</button>
 </div>
 <div class="fx-body" id="fxBody"></div>
</div>
</div>
<input id="directEdit" />

<div id="toast"></div>
<input type="file" id="fileImporter" style="display:none;" accept=".csv,.tsv,.txt,.xlsx,.xls" />
<div id="pasteModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.5); z-index:10005; align-items:center; justify-content:center;">
 <div style="background:white; padding:20px; border-radius:12px; width:90vw; max-width:600px; display:flex; flex-direction:column; gap:12px;">
 <h3 style="margin:0;">Paste Spreadsheet Data</h3>
 <p style="margin:0; font-size:14px; color:#555;">Paste data from Excel, Google Sheets, or CSV/TSV.</p>
 <textarea id="pasteDataInput" style="width:100%; height:200px; font-family:monospace; border:1px solid #ccc; border-radius:8px; padding:8px;"></textarea>
 <div>
 <button class="btn primary" id="processPasteBtn">Import</button>
 <button class="btn" id="cancelPasteBtn">Cancel</button>
 </div>
 </div>
 </div>

<!-- Narrative icons and windows -->
<div id="terminal-icon" class="ui-icon" title="Open Celli_Log.txt">
 <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-gray-300"><polyline points="4 17 10 11 4 5"></polyline><line x1="12" y1="19" x2="20" y2="19"></line></svg>
</div>
<div id="notepad-icon" class="ui-icon" title="ty.txt">
 <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-gray-300"><path d="M8 2v4"></path><path d="M12 2v4"></path><path d="M16 2v4"></path><rect x="4" y="4" width="16" height="18" rx="2"></rect><path d="M12 12h.01"></path><path d="M16 16h.01"></path><path d="M8 12h.01"></path><path d="M8 16h.01"></path></svg>
</div>
<div id="terminal">
 <div class="win-header"><span>Terminal</span><div id="term-close" class="close" title="Close"></div></div>
 <pre id="term"></pre>
</div>
<div id="pad" style="background:#fafafc; color:#1f2937; border:1px solid #e5e7eb;">
 <div class="win-header" style="background:#f2f4f8; color:#111827"><span>ty.txt Notepad</span><div id="pad-close" class="close" title="Close"></div></div>
 <textarea id="note" style="background:#ffffff; color:#111827">special thanks:
- Stephen Lavelle (Increpare)
- Arvi Teikari (Hempuli)
- Jonathan Blow
- Hideo Kojima
- Alan Moore

Synthesize what you love, make what you can.

"I don't love all of you, but I would if I could." increpare, 'Stephen's Sausage Roll'</textarea>
 <div class="pad-resizer" aria-hidden="true"></div>
</div>
<div id="crash" style="display:none; position:fixed; inset:0; background:#0b1220; color:#eaeefb; padding:24px; white-space:pre-wrap; z-index:1000; overflow:auto"></div>

<!-- Settings gear and panel removed -->

<!-- Direct CDN ESM imports (no shims/importmap) to avoid sourcemap noise under file:// -->

<script>
 // Error handler for import failures
 window.addEventListener('error', function(e) {
 console.error('Script error:', e.error || e.message);
 const statusEl = document.getElementById('statusChip');
 if (statusEl) statusEl.textContent = 'Import Error: ' + (e.error?.message || e.message);
 });
</script>
<script type="module">
// Guard against duplicate boot/RAF chains
if (window.__CELL_REWORK_BOOTED__) {
 console.warn('Duplicate boot blocked');
 throw new Error('Duplicate boot');
}
window.__CELL_REWORK_BOOTED__ = true;
// Debug: global render-order controls (defaults)
// Shells behind fills by default; array frame behind all
window.__RO = window.__RO || { ghostFill:350, solidFill:360, solidShell:340, ghostShell:300, frameCore:295, frameShell:300 };
/* ===========================
 Imports
=========================== */
// Try multiple import strategies to bypass caching issues
let THREE, OrbitControls, RoundedBoxGeometry, BufferGeometryUtils;
let EffectComposer, RenderPass, UnrealBloomPass, BokehPass, ShaderPass, FXAAShader, OutlinePass, AfterimagePass, OutputPass;
let RGBELoader, Reflector;

try {
 // Strategy 1: Use CDN with proper module paths
 const baseUrl = 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
 const examplesBase = 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm';
 const [threeModule, controlsModule, geometryModule, utilsModule,
 effectComposerModule, renderPassModule, bloomPassModule, bokehPassModule,
 shaderPassModule, fxaaModule, outlineModule, afterimageModule, outputModule,
 rgbeModule, reflectorModule
 ] = await Promise.all([
 import(baseUrl),
 import(`${examplesBase}/controls/OrbitControls.js`),
 import(`${examplesBase}/geometries/RoundedBoxGeometry.js`),
 import(`${examplesBase}/utils/BufferGeometryUtils.js`),
 import(`${examplesBase}/postprocessing/EffectComposer.js`),
 import(`${examplesBase}/postprocessing/RenderPass.js`),
 import(`${examplesBase}/postprocessing/UnrealBloomPass.js`),
 import(`${examplesBase}/postprocessing/BokehPass.js`),
 import(`${examplesBase}/postprocessing/ShaderPass.js`),
 import(`${examplesBase}/shaders/FXAAShader.js`),
 import(`${examplesBase}/postprocessing/OutlinePass.js`),
 import(`${examplesBase}/postprocessing/AfterimagePass.js`),
 import(`${examplesBase}/postprocessing/OutputPass.js`),
 import(`${examplesBase}/loaders/RGBELoader.js`),
 import(`${examplesBase}/objects/Reflector.js`)
 ]);

 THREE = threeModule.default || threeModule;
 OrbitControls = controlsModule.OrbitControls || controlsModule.default;
 RoundedBoxGeometry = geometryModule.RoundedBoxGeometry || geometryModule.default;
 BufferGeometryUtils = utilsModule.default || utilsModule;
 EffectComposer = effectComposerModule.EffectComposer || effectComposerModule.default;
 RenderPass = renderPassModule.RenderPass || renderPassModule.default;
 UnrealBloomPass = bloomPassModule.UnrealBloomPass || bloomPassModule.default;
 BokehPass = bokehPassModule.BokehPass || bokehPassModule.default;
 ShaderPass = shaderPassModule.ShaderPass || shaderPassModule.default;
 FXAAShader = fxaaModule.FXAAShader || fxaaModule.default;
 OutlinePass = outlineModule.OutlinePass || outlineModule.default;
 AfterimagePass = afterimageModule.AfterimagePass || afterimageModule.default;
 OutputPass = outputModule.OutputPass || outputModule.default;
 RGBELoader = rgbeModule.RGBELoader || rgbeModule.default;
 Reflector = reflectorModule.Reflector || reflectorModule.default;
 
 console.log('Three.js imports successful:', !!THREE.Scene, !!OrbitControls, !!RoundedBoxGeometry);
 document.getElementById('statusChip').textContent = 'Modules loaded successfully';
} catch(e) {
 console.error('Import failed:', e);
 document.getElementById('statusChip').textContent = 'Import failed: ' + e.message;
 throw e;
}
// Fancy mode removed; keep only core Three.js imports
// Removed heavy AO/Vignette to keep the look clean and modern
// Dynamic Rapier loader (optional)
let RAPIER = null; let RAP_READY = false;
let rapierLoadPromise = null;
let rapierInitPromise = null;
// Global intro flag to guarantee onboarding runs exactly once across handlers
window.__INTRO_FIRED = window.__INTRO_FIRED || false;

// Initialize Twemoji for consistent emoji rendering
if(typeof twemoji !== 'undefined'){
 twemoji.parse(document.body, {
 folder: 'svg',
 ext: '.svg',
 className: 'emoji'
 });
}
const playClickSound = (()=>{
 try{
 const audio = new Audio('https://threejs.org/examples/sounds/ping_pong.mp3');
 audio.preload = 'auto';
 audio.volume = 0.55;
 return ()=>{ try{ audio.currentTime = 0; audio.play(); }catch{} };
 }catch{
 return ()=>{};
 }
})();
let lastCellClickSound = 0;
function playCellClick(){
 const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
 if(now - lastCellClickSound < 260) return;
 lastCellClickSound = now;
 playClickSound();
}

function formulaHasChime(formula){
 if(!formula) return false;
 try{
 return /\bCHIME\s*\(/i.test(String(formula));
 }catch{
 return false;
 }
}

function warmChimeIfNeeded(formula){
 if(!formulaHasChime(formula)) return;
 try{
 if(typeof ChimeSystem !== 'undefined' && ChimeSystem && typeof ChimeSystem.ensureContext === 'function'){
 ChimeSystem.ensureContext();
 return;
 }
 }catch(e){ console.warn('Chime warm-up failed', e); }
 try{
 if(typeof window !== 'undefined' && window.CelliChimes && typeof window.CelliChimes.ensureContext === 'function'){
 window.CelliChimes.ensureContext();
 }
 }catch{}
}

const ChimeSystem = (()=>{
 const NOTE_BASE = { C:-9, D:-7, E:-5, F:-4, G:-2, A:0, B:2 };
 let ctx = null;
 let master = null;

 function ensureContext(){
 if(typeof window === 'undefined') return null;
 const AudioCtx = window.AudioContext || window.webkitAudioContext;
 if(!AudioCtx) return null;
 if(!ctx){
 try{
 ctx = new AudioCtx();
 master = ctx.createGain();
 master.gain.value = 0.22;
 master.connect(ctx.destination);
 }catch{ ctx = null; master = null; return null; }
 }
 if(ctx && ctx.state === 'suspended'){
 try{ ctx.resume(); }catch{}
 }
 return ctx && master ? { ctx, master } : null;
 }

 function parseNote(raw){
 if(raw == null) return null;
 const str = String(raw).trim();
 if(!str) return null;
 const letter = str[0].toUpperCase();
 if(!NOTE_BASE.hasOwnProperty(letter)) return null;
 let accidental = '';
 const rest = str.slice(1).trim();
 if(rest.startsWith('#')) accidental = '#';
 else if(rest.startsWith('b') || rest.startsWith('B')) accidental = 'b';
 let offset = NOTE_BASE[letter];
 if(accidental === '#') offset += 1;
 if(accidental === 'b') offset -= 1;
 return { label: `${letter}${accidental}`, offset };
 }

 function toOctave(raw){
 if(raw == null || raw === '') return 4;
 const n = parseInt(raw, 10);
 return Number.isFinite(n) ? n : 4;
 }

 function toFrequency(offset, octave){
 const semitones = offset + (octave - 4) * 12;
 return 440 * Math.pow(2, semitones / 12);
 }

 function play(offset, octave, duration = 0.65){
 const ctxData = ensureContext();
 if(!ctxData) return;
 const { ctx, master: masterGain } = ctxData;
 try{
 const osc = ctx.createOscillator();
 const env = ctx.createGain();
 const now = ctx.currentTime;
 const freq = toFrequency(offset, octave);
 osc.type = 'triangle';
 osc.frequency.setValueAtTime(freq, now);
 env.gain.setValueAtTime(0, now);
 env.gain.linearRampToValueAtTime(1, now + 0.018);
 env.gain.exponentialRampToValueAtTime(0.0001, now + Math.max(0.2, duration));
 osc.connect(env);
 env.connect(masterGain);
 osc.start(now);
 osc.stop(now + Math.max(0.25, duration) + 0.12);
 }catch(e){ console.warn('Chime playback failed', e); }
 }

 return { ensureContext, parseNote, toOctave, toFrequency, play };
})();
try{ window.CelliChimes = ChimeSystem; }catch{}
// Early touch detection so initial sizing uses correct mode (coarse pointer or small screen with touch)
try{
 const coarse = (window.matchMedia && window.matchMedia('(pointer: coarse)').matches);
 const many = ((navigator.maxTouchPoints||0) > 0) || ((navigator.msMaxTouchPoints||0) > 0);
 const small = Math.min(window.innerWidth, window.innerHeight) <= 820;
 if(coarse || (many && small)) document.body.classList.add('touch');
}catch{}
async function loadRapier(){
 if(RAPIER){ return RAPIER; }
 if(rapierLoadPromise){ return rapierLoadPromise; }

 rapierLoadPromise = (async ()=>{
 // Prefer ESM builds to avoid CommonJS globals like `exports`
 const candidates = [
 'https://cdn.jsdelivr.net/npm/@dimforge/rapier3d-compat@0.12.0/+esm',
 'https://unpkg.com/@dimforge/rapier3d-compat@0.12.0/rapier.js',
 'https://cdn.skypack.dev/@dimforge/rapier3d-compat'
 ];
 for(const url of candidates){
 try{
 const mod = await import(url);
 RAPIER = mod?.default || mod;
 if(RAPIER){
 RAP_READY = true;
 return RAPIER;
 }
 }catch(e){ console.warn('Rapier load failed', url, e); }
 }
 console.warn('Rapier unavailable, continuing without physics');
 RAPIER = null;
 RAP_READY = false;
 return null;
 })();

 try{
 return await rapierLoadPromise;
 }finally{
 if(!RAPIER){
 // Allow future attempts if the load failed
 rapierLoadPromise = null;
 }
 }
}

/* ===========================
 Constants & Utils
=========================== */
const CHUNK_SIZE = 16;
const INACTIVE_GREEDY_THRESHOLD = 4096; // switch non-focused large arrays to shell + greedy
const WINDOW_CHUNK_RADIUS = 1; // detailed window radius (in chunk units) around selection
const greekChars = ['a',' ','?','d','e','?','?','?','?','?','?',' ','?','?','?','p','?','s','t','?','f','?','?','?'];
const greek = (i)=>greekChars[i%greekChars.length];
const A1 = (n)=>{ let s=''; let v=n+1; while(v>0){ const r=(v-1)%26; s=String.fromCharCode(65+r)+s; v=Math.floor((v-1)/26); } return s; };
const chunkOf = (x,y,z)=>({x:Math.floor(x/CHUNK_SIZE),y:Math.floor(y/CHUNK_SIZE),z:Math.floor(z/CHUNK_SIZE)});
const keyChunk = (cx,cy,cz)=>`${cx}_${cy}_${cz}`;
const aKey = ({arrId,x,y,z})=>`${arrId}:${x},${y},${z}`;
const isTouchDevice = (('ontouchstart' in window) || (navigator.maxTouchPoints>0) || (navigator.msMaxTouchPoints>0));
// Simple helpers for Map/Set <-> POJO
const toObject = (m)=> Object.fromEntries(m || new Map());
const toMap = (o)=> new Map(Object.entries(o || {}));
// Absolute refs are 1-based: @[1,1,1,ID] is the first cell. A literal 0 means "same as executing cell component".
// Missing coordinate defaults to 1.
const parseAlt = (s, anchor)=>{
 const m=/^@\[(\-?\d+)?,(\-?\d+)?,(\-?\d+)?,(-?\d+)\]$/.exec(String(s).trim());
 if(!m) return null;
 const cur = anchor || {x:0,y:0,z:0,arrId:0};
 const raw = [m[1], m[2], m[3]].map(v=> (v===undefined || v===null) ? '' : String(v));
 const toOneBased = (val, curComp)=>{
 if(val==='' ) return 1; // missing -> first cell
 const n = +val;
 if(n===0) return (curComp|0)+1; // 0 => same as executing cell (convert to 1-based)
 return n; // already 1-based or negative
 };
 const xb = toOneBased(raw[0], cur.x);
 const yb = toOneBased(raw[1], cur.y);
 const zb = toOneBased(raw[2], cur.z);
 return { x: xb-1, y: yb-1, z: zb-1, arrId: +m[4] };
};
const formatLocalAddress = (arrId, coord)=>{ const row = coord.y + 1; return `${A1(coord.x)}${row}${greek(coord.z)}`; };
const debugCoord = (label, arrId, coord) => { console.log(`${label}: 3D(${coord.x},${coord.y},${coord.z}) ? 2D(${formatLocalAddress(arrId, coord)}) ? @[${coord.x+1},${coord.y+1},${coord.z+1},${arrId}]`); };
const parseA1g = (s,defId)=>{const m=/^([A-Z]+)(\d+)([\u03b1-\u03c9])?(?:\^(-?\d+))?$/.exec(s.trim()); if(!m) return null; let x=0; for(let i=0;i<m[1].length;i++) x=x*26+(m[1].charCodeAt(i)-64); x--; const y=+m[2]-1; const G='a ?de?????? ???p?st?f???'; const z=m[3]?G.indexOf(m[3]):null; const arrId=m[4]!==undefined?+m[4]:defId; return {x,y,z,arrId};};
const showToast=(t)=>{const el=document.getElementById('toast'); el.textContent=t; el.style.display='block'; setTimeout(()=>el.style.display='none',1200);};

const META_KEY_ALIASES = {
 on_click: ['onClick'],
 on_hold: ['onHold'],
 on_touch: ['onTouch'],
 on_land: ['onLand']
};
const META_KEY_CANONICAL = {};
Object.entries(META_KEY_ALIASES).forEach(([canonical, aliases])=>{
 META_KEY_CANONICAL[canonical] = canonical;
 aliases.forEach(alias=>{ META_KEY_CANONICAL[alias] = canonical; });
});
function canonicalMetaKey(key){
 return META_KEY_CANONICAL[key] || key;
}
function normalizeMetaKeys(meta){
 if(!meta) return {};
 let changed=false;
 const result={};
 Object.entries(meta).forEach(([key,value])=>{
 if(value===undefined) return;
 const canonical = canonicalMetaKey(key);
 if(canonical!==key) changed=true;
 if(result[canonical]===undefined) result[canonical]=value;
 });
 if(!changed && Object.keys(result).length===Object.keys(meta).length){
 return meta;
 }
 return result;
}
function getMetaAction(meta, canonical){
 if(!meta) return undefined;
 const canonicalKey = canonicalMetaKey(canonical);
 if(meta[canonicalKey] !== undefined) return meta[canonicalKey];
 const aliases = META_KEY_ALIASES[canonicalKey] || [];
 for(const alias of aliases){
 if(meta[alias] !== undefined){
 const val = meta[alias];
 meta[canonicalKey] = val;
 delete meta[alias];
 return val;
 }
 }
 return undefined;
}
function ensureOnSelectHooks(arr){
 if(!arr) return [];
 if(Array.isArray(arr.on_select_hooks)) return arr.on_select_hooks;
 if(Array.isArray(arr.onSelectHooks)){
 arr.on_select_hooks = arr.onSelectHooks;
 delete arr.onSelectHooks;
 return arr.on_select_hooks;
 }
 arr.on_select_hooks = [];
 return arr.on_select_hooks;
}

/* ===========================
 Tiny Store (Zustand-ish)
=========================== */
const createStore = (init)=>{
 let state; const listeners=new Set();
 const setState = (partial)=>{ const next=typeof partial==='function'?partial(state):partial; const prev=state; state={...state,...next}; listeners.forEach(l=>l(state,prev)); };
 const getState = ()=>state;
 const subscribe = (fn)=> (listeners.add(fn), ()=>listeners.delete(fn));
 state = init(setState,getState);
 return {getState,setState,subscribe};
};
const PHYSICS_DEBUG_STORAGE_KEY = 'celli.physicsDebugAll';

function parseArrayIdFromKey(key){
 if(key === undefined || key === null) return null;
 const str = typeof key === 'string' ? key : String(key);
 const idx = str.indexOf(':');
 if(idx <= 0) return null;
 const id = Number(str.slice(0, idx));
 return Number.isFinite(id) ? id : null;
}

function computeFormulaActiveArrayIds(sourceByCell, depsByAnchor, extraIds=[]){
 const active = new Set();
 try{
 if(Array.isArray(extraIds)){
 extraIds.forEach(id=>{
 const num = Number(id);
 if(Number.isFinite(num)) active.add(num);
 });
 }
 }catch{}
 try{
 if(sourceByCell && typeof sourceByCell.forEach === 'function'){
 sourceByCell.forEach((_src, cellKey)=>{
 const id = parseArrayIdFromKey(cellKey);
 if(id!=null) active.add(id);
 });
 }
 }catch{}
 try{
 if(depsByAnchor && typeof depsByAnchor.forEach === 'function'){
 depsByAnchor.forEach((_deps, anchorKey)=>{
 const id = parseArrayIdFromKey(anchorKey);
 if(id!=null) active.add(id);
 });
 }
 }catch{}
 return active;
}

function gatherFormulaActiveArrayIds(sourceByCell, depsByAnchor, extraIds=[]){
 return computeFormulaActiveArrayIds(sourceByCell, depsByAnchor, extraIds);
}

let _gatherFormulaFallbackWarned = false;
function resolveFormulaActiveArrayIds(sourceByCell, depsByAnchor, extraIds=[]){
 try{
 return gatherFormulaActiveArrayIds(sourceByCell, depsByAnchor, extraIds);
 }catch(err){
 if(!_gatherFormulaFallbackWarned){
 console.warn('gatherFormulaActiveArrayIds unavailable, using fallback computation', err);
 _gatherFormulaFallbackWarned = true;
 }
 return computeFormulaActiveArrayIds(sourceByCell, depsByAnchor, extraIds);
 }
}

function getFormulaActiveArrayIds(){
 try{
 if(typeof Store === 'undefined' || !Store?.getState) return new Set();
 const state = Store.getState();
 return resolveFormulaActiveArrayIds(state.sourceByCell, state.depsByAnchor);
 }catch{
 return new Set();
 }
}

function determineCollisionMode(arr, cell=null, opts={}){
 if(!arr) return 'edit';
 const debugMode = Object.prototype.hasOwnProperty.call(opts, 'debugMode')
 ? !!opts.debugMode
 : (typeof Store !== 'undefined' && Store?.getState) ? !!Store.getState().scene?.physicsDebugAll : false;
 
 // In debug mode, ALL arrays with physics.enabled are physics mode
 if(debugMode && arr.params?.physics?.enabled) return 'physics';
 
 // Check if array has formulas (formula-active arrays are physics mode)
 const hostedSet = opts.formulaHostedSet || getFormulaActiveArrayIds();
 if(hostedSet.has(arr.id)) return 'physics';
 if(cell && (cell.formula || (cell.meta && (cell.meta.generated || cell.meta.emitter)))){
 return 'physics';
 }
 
 // Non-formula arrays are always 'edit' mode (they get colliders but trigger exit)
 return 'edit';
}

function cameraBasisForSelection(arr){
 let major='Z', sign=1, signX=1, signY=1, signZ=1;
 if(!arr) return {major, sign, signX, signY, signZ};
 try{
 if(typeof THREE === 'undefined' || !window.Scene) return {major, sign, signX, signY, signZ};
 const frame = arr._frame || null;
 const cam = Scene?.getCamera ? Scene.getCamera() : null;
 if(frame && cam && cam.position && typeof cam.position.clone === 'function'){
 const arrPos = new THREE.Vector3().setFromMatrixPosition(frame.matrixWorld);
 const camPos = cam.position.clone();
 const toCamW = camPos.sub(arrPos).normalize();
 const inv = new THREE.Matrix4().copy(frame.matrixWorld).invert();
 const toCamL = toCamW.clone().applyMatrix3(new THREE.Matrix3().setFromMatrix4(inv)).normalize();
 const ax=Math.abs(toCamL.x), ay=Math.abs(toCamL.y), az=Math.abs(toCamL.z);
 if(ay>ax && ay>az){ major='Y'; sign=Math.sign(toCamL.y)||1; }
 else if(ax>ay && ax>az){ major='X'; sign=Math.sign(toCamL.x)||1; }
 else { major='Z'; sign=Math.sign(toCamL.z)||1; }
 signX = Math.sign(toCamL.x)||1;
 signY = Math.sign(toCamL.y)||1;
 signZ = Math.sign(toCamL.z)||1;
 }
 }catch{}
 return {major, sign, signX, signY, signZ};
}

function resolveViewRelativeStep(arr, direction, opts={}){
 const depthMode = opts.depthMode || false;
 if(!arr || !direction) return {dx:0,dy:0,dz:0};
 
 // D-pad depth buttons ALWAYS control Z axis toward/away from camera
 if(direction === 'depthUp' || direction === 'depthDown'){
 const basis = cameraBasisForSelection(arr);
 const dz = (direction === 'depthUp') 
 ? (basis.signZ > 0 ? +1 : -1) // toward camera
 : (basis.signZ > 0 ? -1 : +1); // away from camera
 return {dx:0, dy:0, dz};
 }
 
 // D-pad up/down ALWAYS control Y (height) moving upward/downward in visual space
 // In array coords: higher Y = physically higher in 3D space
 if(direction === 'up') return {dx:0, dy:+1, dz:0};
 if(direction === 'down') return {dx:0, dy:-1, dz:0};
 
 // Left/Right are view-relative
 const basis = cameraBasisForSelection(arr);
 let dx=0, dy=0, dz=0;
 
 if(depthMode){
 // Depth mode: left/right control X, but still relative to camera
 if(direction==='left') dx = (basis.signX>0 ? -1 : +1);
 if(direction==='right') dx = (basis.signX>0 ? +1 : -1);
 return {dx,dy,dz};
 }
 
 // Standard mode: left/right are screen-space left/right relative to camera
 if(basis.major==='X'){
 // Viewing along X axis (from east +X or west -X)
 // Left/right control Z axis (north/south)
 // From east (+X): left=north=+Z, right=south=-Z
 // From west (-X): left=south=-Z, right=north=+Z
 if(direction==='left') dz = (basis.sign>0 ? +1 : -1);
 if(direction==='right') dz = (basis.sign>0 ? -1 : +1);
 } else if(basis.major==='Z'){
 // Viewing along Z axis (from south +Z or north -Z)
 // Left/right control X axis (east/west)
 // From south (+Z): left=west=-X, right=east=+X
 // From north (-Z): left=east=+X, right=west=-X
 if(direction==='left') dx = (basis.sign>0 ? -1 : +1);
 if(direction==='right') dx = (basis.sign>0 ? +1 : -1);
 } else { // basis.major === 'Y' (top/bottom view)
 // Viewing from top (+Y) or bottom (-Y)
 // Left/right control X axis (east/west)
 // From top: left=west=-X, right=east=+X
 if(direction==='left') dx = -1;
 if(direction==='right') dx = +1;
 }
 return {dx,dy,dz};
}

function readPersistedPhysicsDebug(){
 try{
 return typeof localStorage !== 'undefined' && localStorage.getItem(PHYSICS_DEBUG_STORAGE_KEY) === '1';
 }catch(e){
 console.warn('Physics debug persistence read failed', e);
 return false;
 }
}
function persistPhysicsDebugFlag(enabled){
 try{
 if(typeof localStorage === 'undefined') return;
 if(enabled){
 localStorage.setItem(PHYSICS_DEBUG_STORAGE_KEY, '1');
 } else {
 localStorage.removeItem(PHYSICS_DEBUG_STORAGE_KEY);
 }
 }catch(e){
 console.warn('Physics debug persistence write failed', e);
 }
}

const Store = createStore((set,get)=>{
 console.log('[STORE INIT] Creating store with physics:false by default');
 return {
 arrays: {}, nextArrayId:1, lastCreatedArrayId:null,
 selection:{arrayId:null, focus:null, anchor:null, range:null, faceHint:null},
 scene:{physics:false, showGrid:true, showAxes:true, physicsDebugAll:false, ocean:{enabled:false}},
 ui:{zLayer:0, fxOpen:false, addressMode:'local', lastInteraction:'3d', viewMode:'standard', crystal2D:false},
 gridPhase:{x:null,y:null,z:null},
 namedBlocks:new Map(), // name -> {x,y,z, data: [layers[z][y][x]] }
 hidden:new Set(), // aKey(cell) -> hidden (per-cell visual mask)
 namedMacros:new Map(), // name -> formula
 // Deferred/meta binding queue for robust late resolution
 pendingMeta: [], // {kind:'on_click'|'note', target:{arrId,x,y,z}, meta:{...}}
 // Global state and event system
 globalState: new Map(), // key -> value
 eventListeners: new Map(), // eventName -> [listenerObjects]
 anchorsByGlobalKey: new Map(), // globalKey -> Set<anchorKey>
 globalKeysByAnchor: new Map(), // anchorKey -> Set<globalKey>
 // Emission tracking for generated values (e.g., ARRAY)
 emittedByAnchor: new Map(), // anchorKey -> Set<cellKey>
 sourceByCell: new Map(), // cellKey -> anchorKey
 // Projectile and collision system
 activeProjectiles: [], // Each item: {id, pos, vel, sourceArrId, payload}
 collisionHandlers: new Map(), // cellKey -> formulaString
 nextProjectileId: 0,
 // Interactions
 interactions:{ gobblingEnabled:false },
 // Game state system
 gameState: { goals: new Map(), winCallbacks: [], hasWon: false },
 // Embedding system
 embeddedMeshes: new Map(), // anchorKey -> { mesh, sourceArrId }
 worldState: { mode: 'normal', parentArr: null, childArr: null },
 // Docking system
 dockGroups: new Map(), // groupId -> {mode:'parent'|'all', members:number[], parentId:number}
 dockGroupsByAnchor: new Map(), // anchorKey -> groupId
 // Avatar + physics camera preferences
 avatarPhysics:{ enabled:true, jumpCount:1, runMultiplier:1, momentumMode:0 },
 physicsCamera:{ mode:'free', distance:10, allowRotation:false },
 // Track active 3D_ROTATE applications and suppressions for revert logic
 activeRotations: new Map(), // anchorKey -> {targetId, ids:number[], pivot:{arrId,x,y,z}, steps:{sx,sy,sz}}
 suppress3DRotateRevert: new Set(), // Set<anchorKey>
 // Persisted reverts after refresh
 // (3D translate persisted meta is read at revert time; no store change needed here)
 // Track active 3D_TRANSLATE applications and suppressions for revert logic
 activeTranslations: new Map(), // anchorKey -> {targetId, from:{x,y,z}, delta:{dx,dy,dz}}
 suppress3DTranslateRevert: new Set(), // Set<anchorKey>
 // Track active SCALE applications so manual clears/changes can restore defaults
 activeScales: new Map(), // anchorKey -> {targets:[{id, prevLevel, prevUnits}]}
 // Signal system
 bufferedWrites: [], // { tick, anchor, value, formula }
 currentTick: 0,
 // dependency graph
 depsByAnchor:new Map(), anchorsByDep:new Map(),
 // helpers
 utils:{
 A1, greek,
 key:(arrId,x,y,z)=>`${arrId}:${x},${y},${z}`,
 },
 actions:{
 saveState: ()=>{
 try{
 const s = get();
 console.log('Saving state with', Object.keys(s.arrays).length, 'arrays...');

 const sanitizeTimedParams=(timed)=>{
 if(!timed) return undefined;
 const clone={
 ticks: Number.isFinite(+timed.ticks) ? (+timed.ticks|0) : 60,
 repeat: !!timed.repeat,
 reverse: !!timed.reverse,
 reverseTicks: (timed.reverseTicks==null) ? null : ((+timed.reverseTicks|0) || (+timed.ticks|0) || 60),
 t: 0,
 dir: (timed.dir===-1)?-1:1,
 previewInArray: !!timed.previewInArray,
 smooth: !!timed.smooth
 };
 if(Array.isArray(timed.plan)){
 clone.plan = timed.plan.map(op=>{
 const out={...op};
 if(op.anchor){ out.anchor = { ...op.anchor }; }
 return out;
 });
 } else {
 clone.plan = [];
 }
 if(timed.baseOffset){
 clone.baseOffset = {
 x: Number.isFinite(+timed.baseOffset.x) ? +timed.baseOffset.x : 0,
 y: Number.isFinite(+timed.baseOffset.y) ? +timed.baseOffset.y : 0,
 z: Number.isFinite(+timed.baseOffset.z) ? +timed.baseOffset.z : 0
 };
 }
 if(timed.baseQuat){
 try{
 if(Array.isArray(timed.baseQuat)) clone.baseQuat = timed.baseQuat.slice(0,4);
 else if(typeof timed.baseQuat.toArray==='function') clone.baseQuat = timed.baseQuat.toArray();
 else if(timed.baseQuat && typeof timed.baseQuat.x==='number') clone.baseQuat = [timed.baseQuat.x, timed.baseQuat.y, timed.baseQuat.z, timed.baseQuat.w];
 }catch{}
 }
 if(typeof timed.waitStart==='number') clone.waitStart = timed.waitStart|0;
 if(typeof timed.waitEnd==='number') clone.waitEnd = timed.waitEnd|0;
 return clone;
 };
 const cloneParamValue=(val)=>{
 if(val===undefined) return undefined;
 if(val===null) return null;
 if(typeof val==='function') return undefined;
 if(typeof val!=='object') return val;
 try{ return JSON.parse(JSON.stringify(val)); }
 catch{ return undefined; }
 };
 const sanitizeTimed3D=(timed)=>{
 if(!timed) return null;
 const scope = timed.scope ? {
 mode: timed.scope.mode || 'all',
 ids: Array.isArray(timed.scope.ids) ? timed.scope.ids.map(n=> Number.isFinite(+n)?(+n|0):null).filter(n=>n!=null) : []
 } : null;
 return {
 configured: !!timed.configured,
 ticks: Number.isFinite(+timed.ticks) ? (+timed.ticks|0) : 60,
 repeat: !!timed.repeat,
 reverse: !!timed.reverse,
 reverseTicks: (timed.reverseTicks==null) ? null : ((+timed.reverseTicks|0) || ((+timed.ticks|0)||60)),
 smooth: !!timed.smooth,
 preview: !!timed.preview,
 waitStart: Number.isFinite(+timed.waitStart) ? (+timed.waitStart|0) : 0,
 waitEnd: Number.isFinite(+timed.waitEnd) ? (+timed.waitEnd|0) : 0,
 hostId: Number.isFinite(+timed.hostId) ? (+timed.hostId|0) : null,
 scope,
 activeHostIds: Array.isArray(timed.activeHostIds) ? timed.activeHostIds.map(n=> Number.isFinite(+n)?(+n|0):null).filter(n=>n!=null) : [],
 t: 0,
 dir: (timed.dir===-1)?-1:1
 };
 };

 // Enhanced state preservation - keep ALL meaningful data
 const hostedByFormula = resolveFormulaActiveArrayIds(s.sourceByCell, s.depsByAnchor);
 const debugMode = !!s.scene?.physicsDebugAll;
 const arrays = {};
 Object.values(s.arrays).forEach(a=>{
 const outA = {
 id:a.id, name:a.name, size:a.size, hidden:a.hidden, sealed:a.sealed, offset:a.offset,
 collisionMode: determineCollisionMode(a, null, { debugMode, formulaHostedSet: hostedByFormula }),
 fnPolicy: a.fnPolicy ? {
 mode: a.fnPolicy.mode,
 allow: Array.from(a.fnPolicy.allow || []),
 deny: Array.from(a.fnPolicy.deny || []),
 tags: Array.from(a.fnPolicy.tags || [])
 } : undefined,
 params: (()=>{
 if(!a.params) return undefined;
 const paramsOut={};
 Object.entries(a.params).forEach(([key,val])=>{
 if(key==='timed'){
 const clean = sanitizeTimedParams(val);
 if(clean) paramsOut.timed = clean;
 } else {
 const cloned = cloneParamValue(val);
 if(cloned!==undefined) paramsOut[key]=cloned;
 }
 });
 return Object.keys(paramsOut).length ? paramsOut : undefined;
 })(),
 locks: Array.from(a.locks || []),
 chunks:{} 
 };
 // Transform and per-array knobs
 try{
 const quat = (a._frame?.quaternion?.toArray?.()) || a.rotationQuat || [0,0,0,1];
 outA.transform = {
 offset: a.offset || {x:0,y:0,z:0},
 rotationQuat: quat,
 rotationSteps: a.rotationSteps || {x:0,y:0,z:0}
 };
 }catch{}
 if(a.axesVisible !== undefined) outA.axesVisible = !!a.axesVisible;
 const selectHooks = ensureOnSelectHooks(a);
 if(selectHooks.length) outA.on_select_hooks = selectHooks;
 if(a.uiControls) outA.uiControls = a.uiControls;
 if(a.cameraLock) outA.cameraLock = a.cameraLock;
 if(a.viewMode) outA.viewMode = a.viewMode;
 
 Object.entries(a.chunks).forEach(([k,ch])=>{
 const cells = [];
 for(const c of ch.cells){
 const hasVal = !(c.value===''||c.value==null||c.value===undefined);
 const hasFx = !!c.formula;
 const hasMeta = c.meta && Object.keys(c.meta).length > 0;
 
 // Save ALL cells with content, formulas, or metadata
 if(hasVal || hasFx || hasMeta){
 const normalizedMeta = c.meta ? normalizeMetaKeys(c.meta) : null;
 if(normalizedMeta && normalizedMeta !== c.meta) c.meta = normalizedMeta;
 const metaOut = normalizedMeta && Object.keys(normalizedMeta).length ? {...normalizedMeta} : undefined;
 cells.push({
 x:c.x, y:c.y, z:c.z,
 value: c.value, // preserve exact value including empty strings
 formula: c.formula, // preserve exact formula including null
 meta: metaOut
 });
 }
 }
 if(cells.length>0) outA.chunks[k] = { coord: ch.coord, cells };
 });
 arrays[a.id] = outA;
 });
 
 // Save comprehensive state including dependencies and global state
 // Filter out platformer.active from globalState to ensure it always starts false
 const globalStateEntries = Array.from(s.globalState.entries()).filter(([k]) => k !== 'platformer.active' && k !== 'platformer.pos');
 
 const serializable = {
 version: '1.1',
 timestamp: Date.now(),
 arrays,
 nextArrayId: s.nextArrayId,
 globalState: Object.fromEntries(globalStateEntries),
 selection: s.selection,
 ui: s.ui,
 scene: {
 physics: false, // Never save physics as enabled
 showGrid: s.scene.showGrid,
 showAxes: s.scene.showAxes,
 arrowMapDepth: s.scene.arrowMapDepth,
 timed3D: sanitizeTimed3D(s.scene?.timed3D)
 },
 avatarPhysics: s.avatarPhysics,
 physicsCamera: s.physicsCamera,
 camera: (Scene && Scene.captureCamera) ? Scene.captureCamera() : undefined,
 gridPhase: s.gridPhase,
 docks: {
 groups: Object.fromEntries([...(s.dockGroups||new Map()).entries()].map(([id,g])=> [id, {mode:g.mode, members:[...g.members], parentId:g.parentId??null}] )),
 byAnchor: Object.fromEntries((s.dockGroupsByAnchor||new Map()).entries())
 },
 chunking: { enabled: !!(Scene.ChunkManager && Scene.ChunkManager.enabled) },
 interactions: s.interactions,
 namedBlocks: Object.fromEntries(s.namedBlocks.entries()),
 namedMacros: Object.fromEntries(s.namedMacros.entries())
 };
 
 const data = JSON.stringify(serializable);
 console.log('Serialized state size:', Math.round(data.length/1024), 'KB');
 
 try{
 localStorage.setItem('celliOsState', data);
 showToast(`?? State Saved (${Math.round(data.length/1024)}KB)`);
 }catch(e){
 if(e.name === 'QuotaExceededError'){
 // Try compressing by removing some metadata
 const compressed = { 
 arrays: Object.fromEntries(Object.entries(arrays).map(([id, a]) => [id, {
 ...a,
 chunks: Object.fromEntries(Object.entries(a.chunks).map(([k, ch]) => [k, {
 ...ch,
 cells: ch.cells.map(c => {
 const metaNorm = c.meta ? normalizeMetaKeys(c.meta) : null;
 if(metaNorm && metaNorm !== c.meta) c.meta = metaNorm;
 const compressedMeta = metaNorm ? {
 ...(metaNorm.on_click ? {on_click: metaNorm.on_click} : {}),
 ...(metaNorm.noteText ? {noteText: metaNorm.noteText} : {}),
 ...(metaNorm.color ? {color: metaNorm.color} : {})
 } : undefined;
 return {
 x: c.x, y: c.y, z: c.z,
 value: c.value,
 formula: c.formula,
 meta: compressedMeta
 };
 })
 }]))
 }]))
 };
 const compressedData = JSON.stringify(compressed);
 localStorage.setItem('celliOsState', compressedData);
 showToast(`?? State Saved (Compressed: ${Math.round(compressedData.length/1024)}KB)`);
 } else {
 throw e;
 }
 }
 }catch(e){ 
 console.error('saveState failed', e); 
 showToast('? Save failed: ' + e.message); 
 }
 },
 loadState: ()=>{
 try{
 const json = localStorage.getItem('celliOsState'); 
 if(!json){ showToast('?? No saved state found'); return; }
 
 const data = JSON.parse(json);
 const rehydrateTimedParams=(timed)=>{
 if(!timed) return undefined;
 const out={
 ticks: Number.isFinite(+timed.ticks) ? (+timed.ticks|0) : 60,
 repeat: !!timed.repeat,
 reverse: !!timed.reverse,
 reverseTicks: (timed.reverseTicks==null) ? null : ((+timed.reverseTicks|0) || ((+timed.ticks|0)||60)),
 t: Number.isFinite(+timed.t) ? (+timed.t|0) : 0,
 dir: (timed.dir===-1)?-1:1,
 previewInArray: !!timed.previewInArray,
 smooth: !!timed.smooth,
 plan: Array.isArray(timed.plan) ? timed.plan.map(op=>{
 const copy={...op};
 if(op.anchor) copy.anchor={...op.anchor};
 return copy;
 }) : []
 };
 if(timed.baseOffset){
 out.baseOffset={
 x: Number.isFinite(+timed.baseOffset.x) ? +timed.baseOffset.x : 0,
 y: Number.isFinite(+timed.baseOffset.y) ? +timed.baseOffset.y : 0,
 z: Number.isFinite(+timed.baseOffset.z) ? +timed.baseOffset.z : 0
 };
 }
 if(timed.baseQuat){
 try{
 const arrQuat = Array.isArray(timed.baseQuat) ? timed.baseQuat : [timed.baseQuat.x, timed.baseQuat.y, timed.baseQuat.z, timed.baseQuat.w];
 if(Array.isArray(arrQuat) && arrQuat.length===4){
 const quat=new THREE.Quaternion();
 quat.fromArray(arrQuat);
 out.baseQuat=quat;
 }
 }catch{ out.baseQuat=null; }
 }
 if(typeof timed.waitStart==='number') out.waitStart = timed.waitStart|0;
 if(typeof timed.waitEnd==='number') out.waitEnd = timed.waitEnd|0;
 return out;
 };
 const rehydrateParams=(params)=>{
 if(!params) return {};
 const out={};
 Object.entries(params).forEach(([key,val])=>{
 if(key==='timed'){
 const t = rehydrateTimedParams(val);
 if(t) out.timed = t;
 } else {
 out[key] = val;
 }
 });
 return out;
 };
 const rehydrateTimed3D=(timed)=>{
 if(!timed) return null;
 const scope = timed.scope ? {
 mode: timed.scope.mode || 'all',
 ids: Array.isArray(timed.scope.ids) ? timed.scope.ids.map(n=> Number.isFinite(+n)?(+n|0):null).filter(n=>n!=null) : []
 } : null;
 return {
 configured: !!timed.configured,
 ticks: Number.isFinite(+timed.ticks) ? (+timed.ticks|0) : 60,
 repeat: !!timed.repeat,
 reverse: !!timed.reverse,
 reverseTicks: (timed.reverseTicks==null) ? null : ((+timed.reverseTicks|0) || ((+timed.ticks|0)||60)),
 smooth: !!timed.smooth,
 preview: !!timed.preview,
 waitStart: Number.isFinite(+timed.waitStart) ? (+timed.waitStart|0) : 0,
 waitEnd: Number.isFinite(+timed.waitEnd) ? (+timed.waitEnd|0) : 0,
 hostId: Number.isFinite(+timed.hostId) ? (+timed.hostId|0) : null,
 scope,
 t: Number.isFinite(+timed.t) ? (+timed.t|0) : 0,
 dir: (timed.dir===-1)?-1:1,
 _waitCounter: 0,
 activeHostIds: Array.isArray(timed.activeHostIds) ? timed.activeHostIds.map(n=> Number.isFinite(+n)?(+n|0):null).filter(n=>n!=null) : []
 };
 };
 const restoreTimedPreviewState=()=>{
 try{
 const S=Store.getState();
 const arrays=Object.values(S.arrays||{});
 const globalPreviewActive = !!(S.scene?.timed3D?.preview);
 const ensurePlan=(arr)=>{ try{ Scene.buildTimedPlanFromArray?.(arr); }catch{} };
 arrays.forEach(arr=>{
 if(!arr) return;
 const timed=arr.params?.timed;
 if(!timed) return;
 timed.t = 0;
 timed.dir = 1;
 const shouldResetBase = !!timed.previewInArray || globalPreviewActive;
 if(shouldResetBase){
 if(timed.baseOffset){
 setArrayOffset(arr, {x:timed.baseOffset.x,y:timed.baseOffset.y,z:timed.baseOffset.z}, {interactive:true});
 } else {
 timed.baseOffset = { ...(arr.offset||{x:0,y:0,z:0}) };
 }
 }
 if(timed.baseQuat && !(timed.baseQuat instanceof THREE.Quaternion)){
 try{
 const qArr = Array.isArray(timed.baseQuat) ? timed.baseQuat : [timed.baseQuat.x, timed.baseQuat.y, timed.baseQuat.z, timed.baseQuat.w];
 if(Array.isArray(qArr) && qArr.length===4){ const q=new THREE.Quaternion(); q.fromArray(qArr); timed.baseQuat=q; }
 }catch{}
 }
 if(timed.previewInArray){
 ensurePlan(arr);
 if(!timed.overlay){
 try{
 timed.overlay = { group:new THREE.Group(), cells:new Map() };
 if(arr._frame) arr._frame.add(timed.overlay.group); else Scene.addToScene?.(timed.overlay.group);
 }catch{ timed.overlay=null; }
 }
 try{ Scene.maskArrayForPreview?.(arr, true); }catch{}
 } else {
 if(globalPreviewActive){ ensurePlan(arr); }
 try{ Scene.maskArrayForPreview?.(arr, false); }catch{}
 }
 });
 const savedTimed = S.scene?.timed3D;
 if(savedTimed){
 try{
 const G = Scene.ensureTimed3D ? Scene.ensureTimed3D() : null;
 if(G){
 G.configured = !!savedTimed.configured;
 G.ticks = Number.isFinite(+savedTimed.ticks) ? (+savedTimed.ticks|0) : 60;
 G.repeat = !!savedTimed.repeat;
 G.reverse = !!savedTimed.reverse;
 G.reverseTicks = (savedTimed.reverseTicks==null) ? null : ((+savedTimed.reverseTicks|0) || ((+savedTimed.ticks|0)||60));
 G.smooth = !!savedTimed.smooth;
 G.preview = !!savedTimed.preview;
 G.waitStart = Number.isFinite(+savedTimed.waitStart) ? (+savedTimed.waitStart|0) : 0;
 G.waitEnd = Number.isFinite(+savedTimed.waitEnd) ? (+savedTimed.waitEnd|0) : 0;
 G._waitCounter = 0;
 G.t = Number.isFinite(+savedTimed.t) ? (+savedTimed.t|0) : 0;
 G.dir = (savedTimed.dir===-1)?-1:1;
 G.hostId = Number.isFinite(+savedTimed.hostId) ? (+savedTimed.hostId|0) : null;
 if(savedTimed.scope){
 G.scope = {
 mode: savedTimed.scope.mode || 'all',
 ids: Array.isArray(savedTimed.scope.ids) ? savedTimed.scope.ids.map(n=> Number.isFinite(+n)?(+n|0):null).filter(n=>n!=null) : []
 };
 } else {
 G.scope = null;
 }
 }
 }catch(e){ console.warn('Timed3D restore failed', e); }
 }
 }catch(e){ console.warn('restoreTimedPreviewState error', e); }
 };
 try{ Scene.restoreTimedPreviewState = restoreTimedPreviewState; }catch{}
 console.log('Loading state version:', data.version, 'from:', new Date(data.timestamp));
 
 // Clear existing scene visuals
 Object.values(get().arrays).forEach(arr=>{ try{ Scene.removeArrayGraphics(arr); }catch{} });
 
 // Restore grid phase early for snapping
 if(data.gridPhase){
 try{ Store.setState({ gridPhase: { x:+data.gridPhase.x||0, y:+data.gridPhase.y||0, z:+data.gridPhase.z||0 } }); }catch{}
 }
 // Restore dock groups
 try{
 const docks = data.docks || {};
 Store.setState({
 dockGroups: toMap(docks.groups || {}),
 dockGroupsByAnchor: toMap(docks.byAnchor || {})
 });
 }catch{}
 // Restore ChunkManager flag
 try{ if(data.chunking && data.chunking.enabled===true && Scene.ChunkManager) Scene.ChunkManager.enabled = true; }catch{}
 // Restore camera later via Scene.restoreCamera
 const cameraSnapshot = data.camera;

 const arrays={};
 Object.values(data.arrays||{}).forEach(a=>{
 arrays[a.id] = {
 id:a.id, name:a.name, size:{...a.size}, hidden:a.hidden, sealed:a.sealed, offset:{...a.offset},
 state:'ACTIVE', stableCount:0, lastHash:null, lastDepSig:null,
 collisionMode: a.collisionMode === 'physics' ? 'physics' : 'edit',
 fnPolicy: a.fnPolicy ? {
 mode: a.fnPolicy.mode || 'ALLOW_ALL',
 allow: new Set(a.fnPolicy.allow || []),
 deny: new Set(a.fnPolicy.deny || []),
 tags: new Set(a.fnPolicy.tags || [])
 } : {mode:'ALLOW_ALL', allow:new Set(), deny:new Set(), tags:new Set()},
 params: rehydrateParams(a.params),
 locks: new Set(a.locks || []),
 chunks:{}, labels:[], _frame:null, _colliders:[], _occluders:null
 };
 // Hydrate added fields (back-compat: prefer transform)
 const T = a.transform || {};
 arrays[a.id].offset = T.offset || a.offset || {x:0,y:0,z:0};
 arrays[a.id].rotationQuat = T.rotationQuat || a.rotationQuat || [0,0,0,1];
 arrays[a.id].rotationSteps = T.rotationSteps || a.rotationSteps || {x:0,y:0,z:0};
 if(a.axesVisible !== undefined) arrays[a.id].axesVisible = !!a.axesVisible;
 const loadedHooks = a.on_select_hooks || a.onSelectHooks;
 if(loadedHooks) arrays[a.id].on_select_hooks = loadedHooks;
 if(a.uiControls) arrays[a.id].uiControls = a.uiControls;
 if(a.cameraLock) arrays[a.id].cameraLock = a.cameraLock;
 if(a.viewMode) arrays[a.id].viewMode = a.viewMode;
 // Reserved arrays default hidden if not explicitly saved as visible
 if((a.id===-1) && arrays[a.id].hidden !== true){ arrays[a.id].hidden = true; }
 
 const savedMode = (a.collisionMode === 'physics') ? 'physics' : (a.collisionMode === 'edit' ? 'edit' : null);
 if(savedMode){
 arrays[a.id].collisionMode = savedMode;
 }
 if(arrays[a.id].collisionMode !== 'physics' && arrays[a.id].params?.physics?.enabled){
 arrays[a.id].collisionMode = 'physics';
 }

 let hasFormulaCell = false;
 Object.entries(a.chunks||{}).forEach(([k,ch])=>{
 const C = new Scene.Chunk(arrays[a.id], ch.coord);
 C.cells = (ch.cells||[]).map(c=>{
 const meta = normalizeMetaKeys(c.meta||{});
 if(c.formula) hasFormulaCell = true;
 return {
 x:c.x, y:c.y, z:c.z,
 value:c.value,
 formula:c.formula,
 meta
 };
 });
 // Rebuild cellMap for O(1) access
 C.cellMap = new Map();
 C.cells.forEach(cell => C.cellMap.set(`${cell.x},${cell.y},${cell.z}`, cell));
 arrays[a.id].chunks[k] = C;
 // Backfill missing empties within existing chunk bounds
 try{
 const arrRef = arrays[a.id];
 const minX=C.coord.x*CHUNK_SIZE, minY=C.coord.y*CHUNK_SIZE, minZ=C.coord.z*CHUNK_SIZE;
 const maxX=Math.min(minX+CHUNK_SIZE, arrRef.size.x), maxY=Math.min(minY+CHUNK_SIZE, arrRef.size.y), maxZ=Math.min(minZ+CHUNK_SIZE, arrRef.size.z);
 for(let z=minZ; z<maxZ; z++)
 for(let y=minY; y<maxY; y++)
 for(let x=minX; x<maxX; x++){
 const key=`${x},${y},${z}`;
 if(!C.cellMap.has(key)){
 const cell={x,y,z,value:'',formula:null,meta:{}};
 C.cells.push(cell);
 C.cellMap.set(key, cell);
 }
 }
 }catch{}
 });
 arrays[a.id]._hasFormulaCell = hasFormulaCell;
 // Ensure chunks exist for all regions and are populated with empties where missing
 try{
 const arrRef = arrays[a.id];
 const cDims={x:Math.ceil(arrRef.size.x/CHUNK_SIZE), y:Math.ceil(arrRef.size.y/CHUNK_SIZE), z:Math.ceil(arrRef.size.z/CHUNK_SIZE)};
 for(let cz=0; cz<cDims.z; cz++)
 for(let cy=0; cy<cDims.y; cy++)
 for(let cx=0; cx<cDims.x; cx++){
 const key = keyChunk(cx,cy,cz);
 let C = arrRef.chunks[key];
 if(!C){
 C = new Scene.Chunk(arrRef, {x:cx,y:cy,z:cz});
 arrRef.chunks[key] = C;
 C.cellMap = new Map();
 }
 const minX=cx*CHUNK_SIZE, minY=cy*CHUNK_SIZE, minZ=cz*CHUNK_SIZE;
 const maxX=Math.min(minX+CHUNK_SIZE, arrRef.size.x), maxY=Math.min(minY+CHUNK_SIZE, arrRef.size.y), maxZ=Math.min(minZ+CHUNK_SIZE, arrRef.size.z);
 for(let z=minZ; z<maxZ; z++)
 for(let y=minY; y<maxY; y++)
 for(let x=minX; x<maxX; x++){
 const k2=`${x},${y},${z}`;
 if(!C.cellMap.has(k2)){
 const cell={x,y,z,value:'',formula:null,meta:{}};
 C.cells.push(cell);
 C.cellMap.set(k2, cell);
 }
 }
 }
 }catch{}
 });
 
 // Rebuild emission tracking maps from loaded metadata
 const emittedByAnchor = new Map();
 const sourceByCell = new Map();
 try{
 Object.values(arrays).forEach(a=>{
 Object.values(a.chunks||{}).forEach(ch=>{
 (ch.cells||[]).forEach(cell=>{
 const src = cell?.meta?.emitter;
 if(src){
 const ck = `${a.id}:${cell.x},${cell.y},${cell.z}`;
 sourceByCell.set(ck, src);
 const set = emittedByAnchor.get(src) || new Set();
 set.add(ck);
 emittedByAnchor.set(src, set);
 }
 });
 });
 });
 }catch{}

 const extraFormulaIds = [];
 Object.values(arrays).forEach(arr=>{
 if(arr && arr._hasFormulaCell){
 extraFormulaIds.push(arr.id);
 }
 });
 const combinedHosted = resolveFormulaActiveArrayIds(sourceByCell, null, extraFormulaIds);
 Object.values(arrays).forEach(arr=>{
 if(!arr) return;
 const mode = determineCollisionMode(arr, null, { debugMode:false, formulaHostedSet: combinedHosted });
 arr.collisionMode = mode;
 if(Object.prototype.hasOwnProperty.call(arr, '_hasFormulaCell')){
 delete arr._hasFormulaCell;
 }
 });

 // Restore full state (including rebuilt emission maps)
 const restoredUi = {...get().ui, ...(data.ui||{})};
 if(restoredUi.crystal2D !== true){ restoredUi.crystal2D = false; }
 // ALWAYS restore physics as FALSE to prevent auto-enable
 const restoredScene = {...get().scene, ...(data.scene||{}), physics: false};
 if(data.scene?.timed3D){ restoredScene.timed3D = rehydrateTimed3D(data.scene.timed3D); }
 console.log('[LOAD STATE] Forcing physics to false, ignoring saved state');
 
 // Restore globalState but ensure platformer.active is false
 const restoredGlobalState = new Map(Object.entries(data.globalState||{}));
 restoredGlobalState.set('platformer.active', false);
 // Remove stale platformer.pos to prevent false positives
 restoredGlobalState.delete('platformer.pos');
 console.log('[LOAD STATE] Platformer explicitly set to false');
 
 set({
 arrays,
 nextArrayId: data.nextArrayId||get().nextArrayId,
 globalState: restoredGlobalState,
 selection: data.selection||get().selection,
 ui: restoredUi,
 scene: restoredScene,
 avatarPhysics: data.avatarPhysics ? {...get().avatarPhysics, ...data.avatarPhysics} : get().avatarPhysics,
 physicsCamera: data.physicsCamera ? {...get().physicsCamera, ...data.physicsCamera} : get().physicsCamera,
 interactions: {...get().interactions, ...(data.interactions||{})},
 namedBlocks: new Map(Object.entries(data.namedBlocks||{})),
 namedMacros: new Map(Object.entries(data.namedMacros||{})),
 emittedByAnchor,
 sourceByCell,
 activeScales: new Map()
 });
 try{ Scene.setOceanEnabled?.(!!restoredScene?.ocean?.enabled); }catch{}

 // Restore selection early so focused array renders with shells/LOD correctly
 try{
 const sel0 = data.selection || {};
 const arrMap = Store.getState().arrays;
 let targetSel = null;
 if(sel0.arrayId && sel0.focus && arrMap[sel0.arrayId] && !arrMap[sel0.arrayId].hidden){
 targetSel = sel0;
 } else {
 const firstVisible = Object.values(arrMap).find(a=>a && !a.hidden && a.id>0);
 if(firstVisible) targetSel = { arrayId:firstVisible.id, focus:{x:0,y:0,z:0} };
 }
 if(targetSel){
 Actions.setSelection(targetSel.arrayId, targetSel.focus);
 try{
 const arrF = Store.getState().arrays[targetSel.arrayId];
 if(arrF){ 
 Scene.renderArray(arrF); 
 // Position camera properly after loading
 if(Scene.getCamera && Scene.getControls){
 const cam = Scene.getCamera();
 const ctrl = Scene.getControls();
 if(cam && ctrl){
 const off = arrF.offset || {x:0, y:0, z:0};
 const centerY = off.y + arrF.size.y / 2;
 ctrl.target.set(off.x, centerY, off.z);
 cam.position.set(8, 10, 14);
 ctrl.update();
 }
 }
 }
 }catch{}
 }
 }catch{}

 // Force-reserve arrays (id<0) hidden before first render to prevent any flash/overlap
 try{
 const S0 = Store.getState();
 Object.values(S0.arrays).forEach(A=>{ if((A.id|0) < 0){ A.hidden = true; } });
 }catch{}

 // Rebuild visuals and restore UI state
 Scene.reconcileAllArrays();
 restoreTimedPreviewState();
 try{
 const camCfg = Store.getState().physicsCamera;
 if(camCfg && Scene.setPhysicsCamera){
 Scene.setPhysicsCamera(camCfg.mode, camCfg.distance, camCfg.allowRotation);
 }
 }catch{}
 // Apply saved rotations and offsets explicitly
 try{
 Object.values(Store.getState().arrays).forEach(A=>{
 if(A._frame){
 if(Array.isArray(A.rotationQuat) && A.rotationQuat.length===4){ A._frame.quaternion.fromArray(A.rotationQuat); }
 const off=A.offset||{x:0,y:0,z:0}; A._frame.position.set(off.x,off.y,off.z);
 // Apply visibility as saved (e.g., Mainframe/Library hidden)
 try{ Scene.syncVisibility(A); }catch{}
 }
 });
 }catch{}
 // Don't restore camera - use proper positioning instead
 // try{ if(cameraSnapshot && Scene.restoreCamera) Scene.restoreCamera(cameraSnapshot); }catch{}
 // Force render all arrays to show loaded cells and shells
 try{
 const Sx = Store.getState();
 Object.values(Sx.arrays).forEach(A=>{ Scene.renderArray(A); });
 // After arrays are rendered, apply occlusion for focused selection once
 const sf = Sx.selection;
 if(sf && sf.arrayId && sf.focus){
 try{ Scene.updateFocus(sf); }catch{}
 }
 }catch{}
 window.UI?.init?.(); // Re-initialize UI event handlers
 window.UI?.renderSheet?.();
 // Defer a final focus/apply to the next frame to honor all rebuilt visuals
 try{
 requestAnimationFrame(()=>{
 try{
 const selD = Store.getState().selection || {};
 if(selD.arrayId && selD.focus){
 Scene.updateFocus(selD);
 const arrD = Store.getState().arrays[selD.arrayId];
 if(arrD) Scene.renderArray(arrD);
 }
 // Ensure camera is positioned well after everything loads
 if(Scene.getCamera && Scene.getControls){
 const cam = Scene.getCamera();
 const ctrl = Scene.getControls();
 if(cam && ctrl){
 cam.position.set(8, 10, 14);
 ctrl.target.set(0, 3, 0);
 ctrl.update();
 console.log('[LOAD STATE FINAL] Camera forced to good position');
 }
 }
 }catch{}
 });
 }catch{}
 // Finalize by re-applying focus and re-rendering focused array to honor shells/cutaway
 try{
 const selF = Store.getState().selection || {};
 if(selF.arrayId && selF.focus){
 Scene.updateFocus(selF);
 const arrF = Store.getState().arrays[selF.arrayId];
 if(arrF) Scene.renderArray(arrF);
 }
 }catch{}
 // Recreate text sprites for visible cell values after scene reconcile
 try{ Scene.hydrateAll?.(); }catch(e){ console.warn('Hydrate on load failed', e); }
 // One more pass next tick to cover late async mesh/frame attaches
 try{ setTimeout(()=>{ try{ Scene.hydrateAll?.(); }catch{} }, 0); }catch{}
 
 showToast(`?? State Loaded (${Object.keys(arrays).length} arrays)`);
 console.log('Load complete, arrays restored:', Object.keys(arrays));
 }catch(e){ 
 console.error('loadState failed', e); 
 showToast('? Load failed: ' + e.message); 
 }
 },
 resetSave: ()=>{
 try{
 const confirmed = confirm('??? Clear saved state and restart?\n\nThis will delete all saved arrays and formulas.');
 if(!confirmed) return;
 
 localStorage.removeItem('celliOsState');
 // Reset visibility settings as well
 try{ localStorage.removeItem('VisibilitySettings'); window.VisibilitySettings = JSON.parse(JSON.stringify(DEFAULT_VISIBILITY)); }catch{}
 showToast('??? Save cleared - restarting...');
 setTimeout(()=> location.reload(), 800);
 }catch(e){ 
 console.warn('resetSave failed', e); 
 showToast('? Clear failed: ' + e.message);
 }
 },
 init: async ()=>{
 await Scene.init(document.getElementById('view'));
 
 // Ensure platformer starts disabled
 try{
 const g = Store.getState().globalState;
 if(g && typeof g.set === 'function'){
 g.set('platformer.active', false);
 console.log('[INIT] Platformer explicitly set to false');
 }
 }catch(e){ console.warn('Platformer init failed', e); }

 // Mainframe (#-1) ? Library (#0) ? Sandbox (#2) ? Celli's Home (#1)
 const sp = Actions.createArray({id:-1,name:'Mainframe', size:{x:5,y:5,z:5}, hidden:true, sealed:true, offset:{x:-15,y:0,z:-15}});
 // No Library in this build

 console.log('Arrays created');
 
 // Create home array directly (avoid formulas during init)
 const home = Actions.createArray({id:1,name:"Celli's Home", size:{x:8,y:4,z:8}, hidden:false, offset:{x:0,y:1,z:0}});
 
 // Simple content setup matching reference spreadsheet
 console.log('Setting up content...');
 // Top-down sheet: y=0 is first row (A1)
 Actions.setCell(1, {x:0,y:0,z:0}, 'Hello', null, true); // A1
 Actions.setCell(1, {x:0,y:1,z:0}, 'World!', null, true); // A2 (note will be on A3)
 
 // Direct meta setup for A3 intro (bypass diegetic complexity during init)
 console.log('Setting up A3 intro meta directly...');
 try{
 // Ensure A3 exists
 Actions.resizeArrayIfNeeded(home, {x:0,y:2,z:0});
 const chKey = keyChunk(...Object.values(chunkOf(0,2,0)));
 let ch = home.chunks[chKey];
 if(!ch){ console.warn('A3 chunk missing after resize'); return; }
 let cell = ch.cells.find(c=>c.x===0&&c.y===2&&c.z===0);
 if(!cell){ ch.cells.push({x:0,y:2,z:0,value:'',formula:null,meta:{}}); cell = ch.cells[ch.cells.length-1]; }
 // Set meta directly with proper formula prefix
 const introMeta = normalizeMetaKeys(cell.meta||{});
 introMeta.noteText = 'Click Me!';
 introMeta.on_click = '=STARTINTROEXPERIENCE()';
 cell.meta = introMeta;
 console.log('A3 meta set:', cell.meta);
 }catch(e){ console.warn('Direct A3 setup failed', e); }
 

 try {
 // Focus home array and render it immediately for interaction
 Actions.setSelection(1, {x:0,y:0,z:0});
 Scene.renderArray(home);
 // Position camera to show the array nicely from front-above
 // Home array has offset {x:0, y:1, z:0} and size 8x4x8
 if(Scene.getCamera && Scene.getControls){
 const cam = Scene.getCamera();
 const ctrl = Scene.getControls();
 if(cam && ctrl){
 // Array center is at offset (0, 1, 0), look at middle of array
 const arrayCenter = {x: 0, y: 3, z: 0}; // y: 1 (offset) + 2 (half of height 4)
 ctrl.target.set(arrayCenter.x, arrayCenter.y, arrayCenter.z);
 // Camera positioned high and in front to see array well
 cam.position.set(8, 10, 14);
 ctrl.update();
 console.log('[INIT] Camera positioned at', cam.position, 'looking at', ctrl.target);
 }
 }
 } catch(e) {
 console.error('Home focus failed:', e);
 }


 try {
 UI.init();
 console.log('UI init done');
 // Onboarding: start maximized; collapse only when triggered
 const sheetEl=document.getElementById('sheet');
 const intro=document.getElementById('introOverlay');
 // Block interactions with overlay initially; start centered small
 sheetEl.classList.add('intro-centered');
 intro.classList.remove('hidden');
 // Ensure overlay actually sits above canvas and accepts pointer for safety-net
 intro.style.zIndex = '10000';

 UI.renderSheet();
 console.log('Sheet rendered');
 // Ensure intro note and wiring after DOM paints; re-render sheet to bind on_click eagerly
 requestAnimationFrame(()=>{ requestAnimationFrame(()=>{ 
 try{ UI.ensureIntroNote?.(); }catch{}
 try{ UI.renderSheet?.(); }catch{}
 
 }); });
 
 // Skip full reconcile during intro to avoid duplicate viewports
 
 // Final camera positioning to ensure good view
 if(Scene.getCamera && Scene.getControls){
 const cam = Scene.getCamera();
 const ctrl = Scene.getControls();
 if(cam && ctrl){
 cam.position.set(8, 10, 14);
 ctrl.target.set(0, 3, 0);
 ctrl.update();
 console.log('[INIT FINAL] Camera set to', cam.position, 'target', ctrl.target);
 }
 }

 window.__APP_READY = true;
 } catch(e) {
 console.error('Init failed:', e);
 }
 },
 }
 }; // Close return object
});
window.Store = Store;

/* ===========================
 Array actions (chunked)
=========================== */
// Transaction ledger for undo/redo and provenance (dual-mode)
const History = {
 dataPast: [], dataFuture: [], dataMax: 100, // cell value/formula changes
 uiPast: [], uiFuture: [], uiMax: 50 // selection/view changes
};

/* ===========================
 Goal/Win System
=========================== */
let checkingWinConditions = false; // Guard against recursion

function checkWinConditions() {
 if (checkingWinConditions) return; // Prevent recursive calls
 const S = Store.getState();
 if (!S.gameState || S.gameState.goals.size === 0 || S.gameState.hasWon) return;

 checkingWinConditions = true;
 try {
 let allGoalsMet = true;
 for (const [key, conditionRef] of S.gameState.goals.entries()) {
 const val = Formula.getCellValue(conditionRef);
 if (val !== 1 && val !== '1' && val !== true) {
 allGoalsMet = false;
 break;
 }
 }

 if (allGoalsMet) {
 S.gameState.hasWon = true; // Prevent re-triggering
 S.gameState.winCallbacks.forEach(cb => {
 try {
 const tx = Write.start('game.onwin', 'Triggering ONWIN');
 Formula.executeAt(cb.anchor, cb.callback, tx);
 Write.commit(tx);
 } catch(e) {
 console.error('ONWIN callback error:', e);
 }
 });
 showToast("? You Win! ?");
 }
 } finally {
 checkingWinConditions = false;
 }
}
const Write = (() => {
 let nextId = 1;
 
 function start(origin, reason) {
 return { id: nextId++, ops: [], reason, time: Date.now(), origin };
 }
 
 function set(tx, arrId, coord, next) {
 const arr = Store.getState().arrays[arrId];
 if(!arr) return;
 
 // Ensure array is large enough
 Actions.resizeArrayIfNeeded(arr, coord);
 
 const prevCell = UI.getCell(arrId, coord);
 const prev = { 
 value: prevCell.value, 
 formula: prevCell.formula, 
 meta: prevCell.meta || {} 
 };
 
 // If formula is being changed/removed, revert any 3D_ROTATE and clean up any emitted cells
 const ak = aKey({arrId, ...coord});
 const skipCleanup = !!(next && next.meta && next.meta.skip_cleanup);
 if(!skipCleanup && prev.formula && (next.formula === null || next.formula === '' || next.formula !== prev.formula)) {
 // Attempt 3D_ROTATE auto-revert for this anchor unless suppressed
 try{
 const S=Store.getState();
 const rec=(S.activeRotations||new Map()).get(ak);
 const suppressed=(S.suppress3DRotateRevert||new Set()).has(ak);
 if(rec && !suppressed){
 const targ=S.arrays[rec.targetId];
 if(targ){
 const pivotWorld = Scene.cellWorldPos(targ, rec.pivot.x, rec.pivot.y, rec.pivot.z);
 const rx=-(rec.steps.sx||0), ry=-(rec.steps.sy||0), rz=-(rec.steps.sz||0);
 (rec.ids||[rec.targetId]).map(id=>S.arrays[id]).filter(Boolean).forEach(a=> Scene.rotateArrayAround(a, pivotWorld, rx, ry, rz));
 (rec.ids||[rec.targetId]).map(id=>S.arrays[id]).filter(Boolean).forEach(a=>{ if(a._frame){ a.offset={ x:Math.round(a._frame.position.x), y:Math.round(a._frame.position.y), z:Math.round(a._frame.position.z) }; }});
 }
 const map=new Map(S.activeRotations); map.delete(ak); Store.setState({activeRotations:map});
 }
 if(suppressed){ const sup=new Set(Store.getState().suppress3DRotateRevert); sup.delete(ak); Store.setState({suppress3DRotateRevert:sup}); }
 }catch{}
 const S = Store.getState();
 const emitted = S.emittedByAnchor.get(ak);
 if(emitted) {
 // Guard re-entrancy within a single tx
 tx._clearVisited = tx._clearVisited || new Set();
 emitted.forEach(ck => {
 const [eArrId, coords] = ck.split(':');
 const [x, y, z] = coords.split(',').map(Number);
 const childKey = `${eArrId}:${x},${y},${z}`;
 if(tx._clearVisited.has(childKey)) { S.sourceByCell.delete(ck); return; }
 tx._clearVisited.add(childKey);
 // Clear the emitted cell (avoid self and skip cleanup in nested call)
 if(eArrId !== arrId || x !== coord.x || y !== coord.y || z !== coord.z) {
 Write.set(tx, +eArrId, {x, y, z}, { value: '', formula: null, meta: { skip_cleanup: true } });
 }
 S.sourceByCell.delete(ck);
 });
 S.emittedByAnchor.delete(ak);
 }
 }
 
 let merged = {
 value: next.value !== undefined ? next.value : prevCell.value,
 formula: next.formula !== undefined ? next.formula : prevCell.formula,
 meta: { ...prev.meta, ...(next.meta || {}), from: tx.origin }
 };
 // If clearing a cell (no value and no formula), strip visual-emission metadata
 const clearingCell = ((merged.formula==null || merged.formula==='') && (merged.value==='' || merged.value==null || merged.value===undefined));
 if (clearingCell) {
 const mm = {...(merged.meta||{})};
 delete mm.generated; delete mm.emitter; // remove flags that cause 2D color fill
 merged = { ...merged, meta: mm };
 }
 
 // Emission tracking for generated blocks
 const S = Store.getState();
 if(merged.meta && merged.meta.emitter){
 const srcAk = merged.meta.emitter;
 const ck = `${arrId}:${coord.x},${coord.y},${coord.z}`;
 if(ck !== srcAk){
 const set = S.emittedByAnchor.get(srcAk) || new Set();
 set.add(ck);
 S.emittedByAnchor.set(srcAk, set);
 S.sourceByCell.set(ck, srcAk);
 }
 }
 
 // Apply to in-memory model immediately
 Actions._setCellRaw(arrId, coord, merged);
 tx.ops.push({ arrId, x: coord.x, y: coord.y, z: coord.z, prev, next: merged });
 }
 function commit(tx) {
 // Store transaction in data history
 History.dataPast.push(tx);
 if(History.dataPast.length > History.dataMax) History.dataPast.shift();
 History.dataFuture = [];
 
 // Gather changed anchors for recompute
 const changedAnchors = new Set();
 const affectedArrays = new Set();
 
 for (const op of tx.ops) {
 // Skip recompute for anchors explicitly marked to avoid re-entry
 const skip = !!(op.next?.meta && op.next.meta.skip_recompute);
 if(!skip){
 const key = `${op.arrId}:${op.x},${op.y},${op.z}`;
 changedAnchors.add(key);
 }
 affectedArrays.add(op.arrId);
 }
 
 // Trigger dependency recompute unless we're already inside a recompute pass
 if(!(Formula.isRecomputing && Formula.isRecomputing())){
 Formula.recomputeAnchors(Array.from(changedAnchors));
 }
 
 // Collect emitted cells that became empty to restore them after commit
 const toRestore = [];
 try{
 const S = Store.getState();
 for(const op of tx.ops){
 const becameEmpty = (op.next.formula==null || op.next.formula==='') && (op.next.value==='' || op.next.value===null || op.next.value===undefined);
 if(!becameEmpty) continue;
 const ck = `${op.arrId}:${op.x},${op.y},${op.z}`;
 const srcAk = S.sourceByCell.get(ck);
 if(!srcAk) continue;
 const [aId, rest] = srcAk.split(':');
 const [sx, sy, sz] = rest.split(',').map(Number);
 const sc = Formula.getCell({arrId:+aId, x:sx, y:sy, z:sz});
 if(sc && sc.formula) toRestore.push({arrId:+aId,x:sx,y:sy,z:sz});
 }
 }catch{ /* ignore */ }
 
 // Update visuals for affected arrays with immediate layer re-rendering
 affectedArrays.forEach(id => {
 const arr = Store.getState().arrays[id];
 if(arr) {
 // Force immediate layer re-render for all affected layers
 const affectedLayers = new Set();
 for (const op of tx.ops) {
 if(op.arrId === id) {
 affectedLayers.add(op.z);
 Scene.updateValueSprite(arr, op.x, op.y, op.z, op.next);
 }
 }
 
 // Re-render each affected layer immediately to update voxel colors
 affectedLayers.forEach(z => {
 // Force complete layer rebuild by marking as not rendered
 const layerKey = `${arr.id}:${z}`;
 ['empty','ghost','filled','formula','edges'].forEach(type => {
 const rec = Scene.getLayerMesh(`${layerKey}:${type}`);
 if(rec && rec.mesh) {
 rec.mesh.count = 0; // Reset count to force rebuild
 }
 });
 Scene.renderLayer(arr, z);
 });
 
 // Full array render for any structural changes
 Scene.renderArray(arr);
 
 if(id === Store.getState().selection.arrayId && window.UI?.renderSheet) window.UI.renderSheet();
 }
 });
 
 // Persist after commit for seamless resume (debounced to avoid quota thrash)
 try{
 clearTimeout(window.__AUTO_SAVE_T);
 // Update save status
 const statusEl = document.getElementById('saveStatus');
 if(statusEl) statusEl.textContent = 'Auto-save: Pending...';
 
 window.__AUTO_SAVE_T = setTimeout(()=>{ 
 try{ 
 Store.getState().actions.saveState(); 
 const statusEl = document.getElementById('saveStatus');
 if(statusEl) statusEl.textContent = `Auto-save: ${new Date().toLocaleTimeString()}`;
 }catch{
 const statusEl = document.getElementById('saveStatus');
 if(statusEl) statusEl.textContent = 'Auto-save: Failed';
 } 
 }, 600);
 }catch{}
 // Check win conditions after any state change (async to break call stack)
 setTimeout(checkWinConditions, 0);
 
 // Restore cleared emitted cells by re-executing their source anchors
 if(toRestore.length>0 && !Actions._repairing){
 setTimeout(()=>{
 if(Actions._repairing) return;
 Actions._repairing = true;
 try{
 const rtx = Write.start('emit.restore','Restore cleared emitted cells');
 const uniq = new Set(toRestore.map(r=>`${r.arrId}:${r.x},${r.y},${r.z}`));
 uniq.forEach(k=>{ const [aid,coords]=k.split(':'); const [x,y,z]=coords.split(',').map(Number);
 Formula.executeAt({arrId:+aid,x,y,z}, undefined, rtx);
 });
 Write.commit(rtx);
 }catch(e){ console.warn('Restore emitted failed', e); }
 finally{ Actions._repairing = false; }
 },0);
 }
 }
 
 function rollback(tx) {
 for (const op of tx.ops.reverse()) {
 Actions._setCellRaw(op.arrId, {x:op.x, y:op.y, z:op.z}, op.prev);
 }
 }
 
 return { start, set, commit, rollback };
})();

function computeSelectionFaceHint(anchor, focus, range){
 try{
 if(!anchor || !focus || !range) return null;
 // For multi-cell selections, always use camera direction to show border facing viewer
 try{
 if(window.Scene && typeof window.Scene.getCamera === 'function'){
 const camera = window.Scene.getCamera();
 if(camera){
 const camDir = new THREE.Vector3();
 camera.getWorldDirection(camDir);
 // Reverse direction (we want the face pointing toward camera)
 const vec = { x: -camDir.x, y: -camDir.y, z: -camDir.z };
 const abs = { x: Math.abs(vec.x), y: Math.abs(vec.y), z: Math.abs(vec.z) };
 let axis = 'x';
 let axisIndex = 0;
 let best = abs.x;
 if(abs.y > best){ axis = 'y'; axisIndex = 1; best = abs.y; }
 if(abs.z > best){ axis = 'z'; axisIndex = 2; best = abs.z; }
 const sign = vec[axis] >= 0 ? 1 : -1;
 return { axis, axisIndex, sign };
 }
 }
 }catch{}
 // Fallback: use anchor relative to center (shouldn't normally reach here)
 const center = {
 x: (range.x1 + range.x2) / 2,
 y: (range.y1 + range.y2) / 2,
 z: (range.z1 != null && range.z2 != null) ? ((range.z1 + range.z2) / 2) : ((anchor.z + focus.z) / 2)
 };
 const vec = {
 x: anchor.x - center.x,
 y: anchor.y - center.y,
 z: anchor.z - center.z
 };
 const abs = { x: Math.abs(vec.x), y: Math.abs(vec.y), z: Math.abs(vec.z) };
 let axis = 'x';
 let axisIndex = 0;
 let best = abs.x;
 if(abs.y > best){ axis = 'y'; axisIndex = 1; best = abs.y; }
 if(abs.z > best){ axis = 'z'; axisIndex = 2; best = abs.z; }
 if(best < 1e-5) return null;
 const sign = vec[axis] >= 0 ? 1 : -1;
 return { axis, axisIndex, sign };
 }catch(e){ console.warn('computeSelectionFaceHint failed', e); return null; }
}

const Actions = {
 // Batch write system for dependency propagation
 _batch: null,
 _repairing: false, // Guard for emission auto-repair
 begin: function() { if(!this._batch) this._batch = { changed:new Set(), tx: Write.start('actions.batch','Grouped setCell') }; },
 end: function() {
 if(!this._batch) return;
 try{
 // Commit once to trigger recompute/renders once at the end of the chain
 if(this._batch.tx){ Write.commit(this._batch.tx); }
 // Consolidated visuals after recompute
 const affectedArrays = new Set();
 for (const k of this._batch.changed) {
 const [arrId, rest] = k.split(':');
 const [x,y,z] = rest.split(',').map(Number);
 const numArrId = +arrId;
 affectedArrays.add(numArrId);
 const arr = Store.getState().arrays[numArrId];
 if(arr && window.UI?.renderSheetCell) window.UI.renderSheetCell(arr, x, y, z);
 }
 const currentArrayId = Store.getState().selection.arrayId;
 if(affectedArrays.has(currentArrayId) && window.UI?.renderSheet) window.UI.renderSheet();
 affectedArrays.forEach(id=>{ const arr=Store.getState().arrays[id]; if(arr) Scene.renderArray(arr); });
 } finally {
 this._batch = null;
 }
 },

 createArray: ({id,name='Array',size={x:6,y:4,z:6},hidden=false,sealed=false,offset={x:0,y:0,z:0}})=>{
 // Determine a stable, unique array ID
 const S0 = Store.getState();
 let arrId;
 if(id !== undefined){
 if(!Number.isInteger(id)) throw new Error('Array ID must be an integer');
 if(id>0 && S0.arrays[id]) throw new Error(`Array with ID ${id} already exists.`);
 // Allow non-positive IDs for reserved/system arrays only (e.g., boot-time arrays)
 arrId = id;
 } else {
 const used = Object.values(S0.arrays).map(a=>a.id).filter(n=>Number.isInteger(n) && n>0);
 const sorted = [...new Set(used)].sort((a,b)=>a-b);
 let next = 1;
 for(const n of sorted){ if(n===next) next++; else if(n>next) break; }
 arrId = next;
 }
 const arr = {
 id:arrId, name, size:{...size}, hidden, sealed,
 state:'ACTIVE', stableCount:0, lastHash:null, lastDepSig:null,
 collisionMode:'edit',
 fnPolicy:{mode:'ALLOW_ALL', allow:new Set(), deny:new Set(), tags:new Set()},
 params:{}, locks:new Set(),
 chunks:{}, labels:[], _frame:null, _colliders:[], offset:{...offset}, _occluders:null
 };
 // build chunks sparsely
 const cDims={x:Math.ceil(size.x/CHUNK_SIZE), y:Math.ceil(size.y/CHUNK_SIZE), z:Math.ceil(size.z/CHUNK_SIZE)};
 for(let cz=0;cz<cDims.z;cz++)
 for(let cy=0;cy<cDims.y;cy++)
 for(let cx=0;cx<cDims.x;cx++){
 const ch = new Scene.Chunk(arr, {x:cx,y:cy,z:cz});
 for(let z=0;z<CHUNK_SIZE;z++)
 for(let y=0;y<CHUNK_SIZE;y++)
 for(let x=0;x<CHUNK_SIZE;x++){
 const wx=cx*CHUNK_SIZE+x, wy=cy*CHUNK_SIZE+y, wz=cz*CHUNK_SIZE+z;
 if(wx<size.x&&wy<size.y&&wz<size.z){
 const cell={x:wx,y:wy,z:wz,value:'',formula:null,meta:{}};
 ch.cells.push(cell);
 ch.cellMap.set(`${wx},${wy},${wz}`, cell);
 }
 }
 arr.chunks[keyChunk(cx,cy,cz)] = ch;
 }

 const S=Store.getState();
 // Initialize global grid phase on first array: align its origin cell center to world integer
 if(!S.gridPhase.x&&S.gridPhase.x!==0){
 const phase={x:Math.round(offset.x), y:Math.round(offset.y), z:Math.round(offset.z)};
 Store.setState({gridPhase:phase});
 }
 // Snap offset to global grid phase so cell centers line up across arrays
 const arrScale = arrayVoxelScale(arr);
 const snapAxis=(axis,val,sz)=>{
 const phase = Store.getState().gridPhase[axis]||0;
 const half = (sz * arrScale) / 2;
 const base = (axis==='z') ? (half - arrScale/2) : (-(half) + arrScale/2);
 return Math.round((val - base - phase)/arrScale) * arrScale + base + phase;
 };
 arr.offset={ x:snapAxis('x', offset.x, size.x), y:snapAxis('y', offset.y, size.y), z:snapAxis('z', offset.z, size.z) };
 Store.setState({ arrays:{...S.arrays,[arrId]:arr}, nextArrayId:Math.max(S.nextArrayId, arrId+1), lastCreatedArrayId:arrId });
 Scene.renderArray(arr);
 // Immediately construct LOD1 meshes and rehydrate so new arrays appear without extra interactions
 try{
 Object.values(arr.chunks).forEach(ch=>{ ch.ensureMesh?.(); ch.setLOD?.(1); rehydrateChunkInstances(arr, ch); });
 // Keep this array fully hydrated for a few frames so it is clickable before focus
 arr._warmupFrames = 6;
 // Do NOT apply ghost mask immediately; default new arrays to SOLID (no ghosting)
 try{ forceRenderOrderRefresh?.(false); }catch{}
 }catch{}
 // Snap this array just beyond the max extent of existing arrays with a 1-cell gap
 try{
 const arrays = Object.values(Store.getState().arrays).filter(a=>a && a.id!==arr.id);
 if(arrays.length){
 let maxX=-Infinity;
 arrays.forEach(a=>{
 const x=a.offset?.x||0;
 const s=arrayVoxelScale(a);
 maxX=Math.max(maxX, x + (a.size.x*s)/2);
 });
 const desired = {
 x: Math.round(maxX + arrScale + (arr.size.x*arrScale)/2),
 y: arr.offset.y,
 z: arr.offset.z
 };
 setArrayOffset(arr, desired, {interactive:true});
 }
 }catch{}
 // Force shell creation by triggering focus if this becomes the active array
 try{
 const currentSel = Store.getState().selection;
 if(!currentSel.arrayId || !Store.getState().arrays[currentSel.arrayId] || Store.getState().arrays[currentSel.arrayId].hidden){
 Actions.setSelection(arrId, {x:0,y:0,z:0});
 }
 }catch{}
 // Apply any pending meta queued for this array (e.g., late on_click/note bindings)
 try{
 const St=Store.getState();
 if(Array.isArray(St.pendingMeta) && St.pendingMeta.length){
 const remain=[]; const ptx=Write.start('pending.meta','Apply pending meta');
 St.pendingMeta.forEach(item=>{
 if(item?.target?.arrId===arrId){
 try{
 const t=item.target; const prior=Formula.getCell({arrId:arrId,x:t.x,y:t.y,z:t.z})||{};
 const mergedMeta = normalizeMetaKeys({...(prior.meta||{}), ...(item.meta||{})});
 Write.set(ptx, arrId, {x:t.x,y:t.y,z:t.z}, { value: prior.value??'', formula: prior.formula??null, meta:mergedMeta });
 }catch(e){ remain.push(item); }
 } else { remain.push(item); }
 });
 Write.commit(ptx);
 Store.setState({pendingMeta:remain});
 if(remain.length !== St.pendingMeta.length){ try{ UI.renderSheet?.(); }catch{} }
 }
 }catch{}
 try{
 if(Store.getState().scene?.physicsDebugAll){
 Scene.setPhysicsDebugAll(true);
 }
 }catch(e){ console.warn('Reapplying physics debug overrides for new array failed', e); }
 return arr;
 },

 deleteArray: (arrId, opts={})=>{
 const S = Store.getState();
 const arr = S.arrays[arrId];
 if(!arr) return false;

 // Hide immediately in both 3D and 2D
 arr.hidden = true;
 Scene.syncVisibility(arr);

 // Remove 3D graphics and sprites
 try{ Scene.removeArrayGraphics?.(arr); }catch{}

 // Clean emitted tracking
 try{
 const emitted = S.emittedByAnchor;
 const source = S.sourceByCell;
 [...emitted.keys()].forEach(ak=>{
 if(ak.startsWith(`${arrId}:`)) emitted.delete(ak);
 });
 [...source.keys()].forEach(ck=>{
 if(ck.startsWith(`${arrId}:`)) source.delete(ck);
 });
 }catch{}

 // Clean dependency graph for this array
 try{
 const newDepsByAnchor = new Map();
 S.depsByAnchor.forEach((deps, ak)=>{
 if(!ak.startsWith(`${arrId}:`)) newDepsByAnchor.set(ak, deps);
 });
 const newAnchorsByDep = new Map();
 S.anchorsByDep.forEach((anchors, dk)=>{
 if(dk.startsWith(`${arrId}:`)) return;
 const filtered = new Set([...anchors].filter(a => !String(a).startsWith(`${arrId}:`)));
 if(filtered.size) newAnchorsByDep.set(dk, filtered);
 });
 Store.setState({ depsByAnchor:newDepsByAnchor, anchorsByDep:newAnchorsByDep });
 }catch{}

 // Remove from dock groups
 try{
 const ng = new Map(S.dockGroups||new Map());
 ng.forEach((g,k)=>{
 g.members = g.members.filter(id=> id!==arrId);
 if(g.members.length === 0) ng.delete(k);
 });
 Store.setState({ dockGroups: ng });
 }catch{}

 // Clean up any embedded meshes tied to this array
 try{
 const map = __cloneEmbeddedMap(Store.getState().embeddedMeshes);
 let changed=false;
 map.forEach((rec, key)=>{
 if(rec?.hostArrId===arrId || rec?.sourceArrId===arrId){
 __disposeEmbeddedRecord(rec);
 map.delete(key);
 changed=true;
 }
 });
 if(changed) Store.setState({ embeddedMeshes: map });
 }catch{}

 // Remove from array registry
 const arrays = { ...S.arrays };
 delete arrays[arrId];
 Store.setState({ arrays });

 // Reroute selection if necessary
 try{
 const sel = Store.getState().selection;
 if(sel.arrayId === arrId){
 const next = Object.values(Store.getState().arrays).find(a=>!a.hidden) || null;
 if(next) Actions.setSelection(next.id, {x:0,y:Math.max(0,next.size.y-1),z:0}, null, '3d');
 else Store.setState(s=>({ selection:{ arrayId:null, focus:null, anchor:null, range:null, faceHint:null } }));
 }
 window.UI?.renderSheet?.();
 }catch{}

 showToast(`Deleted #${arrId}`);
 return true;
 },

 // Raw cell update without notifications or rendering (used by Write system)
 _setCellRaw: (arrayId, coord, cellData)=>{
 const S=Store.getState();
 const arr=S.arrays[arrayId]; if(!arr) return;
 Actions.resizeArrayIfNeeded(arr, coord);
 const c = chunkOf(coord.x,coord.y,coord.z); const k=keyChunk(c.x,c.y,c.z);
 const ch=arr.chunks[k]; if(!ch) return;
 let cell = ch.cellMap?.get(`${coord.x},${coord.y},${coord.z}`);
 if(!cell){
 cell = {x:coord.x, y:coord.y, z:coord.z, value:'', formula:null, meta:{}};
 ch.cells.push(cell);
 ch.cellMap?.set(`${coord.x},${coord.y},${coord.z}`, cell);
 }
 // Auto-revert 3D_ROTATE on clear without requiring execution
 try{
 const beforeFormula = ch.cells[idx]?.formula || null;
 const ak = `${arrayId}:${coord.x},${coord.y},${coord.z}`;
 const clearing = (cellData.formula===null || cellData.formula==='');
 if(clearing && beforeFormula){
 const rec=(S.activeRotations||new Map()).get(ak);
 const suppressed=(S.suppress3DRotateRevert||new Set()).has(ak);
 if(rec && !suppressed){
 const targ=S.arrays[rec.targetId];
 if(targ){
 const ids=rec.ids||[rec.targetId];
 ids.map(id=>S.arrays[id]).filter(Boolean).forEach(a=>{ if(!a._frame) Scene.renderArray(a); });
 const pivotWorld = Scene.cellWorldPos(targ, rec.pivot.x, rec.pivot.y, rec.pivot.z);
 const rx=-(rec.steps.sx||0), ry=-(rec.steps.sy||0), rz=-(rec.steps.sz||0);
 ids.map(id=>S.arrays[id]).filter(Boolean).forEach(a=> Scene.rotateArrayAround(a, pivotWorld, rx, ry, rz));
 ids.map(id=>S.arrays[id]).filter(Boolean).forEach(a=>{ if(a._frame){ a.offset={ x:Math.round(a._frame.position.x), y:Math.round(a._frame.position.y), z:Math.round(a._frame.position.z) }; }});
 }
 const map=new Map(S.activeRotations); map.delete(ak); Store.setState({activeRotations:map});
 if(suppressed){ const sup=new Set(S.suppress3DRotateRevert); sup.delete(ak); Store.setState({suppress3DRotateRevert:sup}); }
 }
 }
 }catch{}
 Object.assign(cell, cellData);
 try{ ch.markDirty?.(); }catch{}
 arr.state='ACTIVE'; arr.stableCount=0;
 },

 setCell: (arrayId, coord, value, formula=null, noRender=false)=>{
 // Prefer active batch transaction for coherence
 const activeTx = Actions._batch?.tx;
 if(activeTx){
 try{
 Write.set(activeTx, arrayId, coord, { value, formula });
 // Track changed for consolidated post-commit render
 Actions._batch.changed.add(aKey({arrId:arrayId, ...coord}));
 // Defer visuals during batch to avoid mid-chain flicker and wrong states
 return;
 } catch(e){ console.error('batched setCell failed, falling back', e); }
 }
 // Fallback: single-op transaction to preserve dependency semantics
 const tx = Write.start('actions.setCell','single op');
 Write.set(tx, arrayId, coord, { value, formula });
 Write.commit(tx);
 },

 resizeArrayIfNeeded: (arr, coord)=>{
 let changed=false; const newSize={...arr.size};
 if(coord.x>=arr.size.x){ newSize.x=coord.x+1; changed=true; }
 if(coord.y>=arr.size.y){ newSize.y=coord.y+1; changed=true; }
 if(coord.z>=arr.size.z){ newSize.z=coord.z+1; changed=true; }
 if(!changed) return;
 
 // expand chunks
 const oldSize={...arr.size}; arr.size=newSize;
 const cDims={x:Math.ceil(newSize.x/CHUNK_SIZE), y:Math.ceil(newSize.y/CHUNK_SIZE), z:Math.ceil(newSize.z/CHUNK_SIZE)};
 for(let cz=0;cz<cDims.z;cz++)
 for(let cy=0;cy<cDims.y;cy++)
 for(let cx=0;cx<cDims.x;cx++){
 const k=keyChunk(cx,cy,cz); if(arr.chunks[k]) continue;
 const ch = new Scene.Chunk(arr, {x:cx,y:cy,z:cz});
 for(let z=0;z<CHUNK_SIZE;z++)
 for(let y=0;y<CHUNK_SIZE;y++)
 for(let x=0;x<CHUNK_SIZE;x++){
 const wx=cx*CHUNK_SIZE+x, wy=cy*CHUNK_SIZE+y, wz=cz*CHUNK_SIZE+z;
 if(wx<newSize.x&&wy<newSize.y&&wz<newSize.z) ch.cells.push({x:wx,y:wy,z:wz,value:'',formula:null,meta:{}});
 }
 arr.chunks[k] = ch;
 }
 // render new layers if Z grew
 for(let z=0; z<arr.size.z; z++){ Scene.renderLayer(arr,z); }
 Scene.renderArray(arr);
 
 // Update all global references when array expands
 if(changed) {
 Actions.offsetGlobalReferences(arr.id, oldSize, newSize);
 }
 
 // Trigger auto-repair for any emitted cells that might need refilling in the expanded area
 if(!Actions._repairing) {
 const S = Store.getState();
 // Check all source anchors that emit into this array
 S.emittedByAnchor.forEach((emittedSet, sourceAk) => {
 const hasEmptyInExpansion = Array.from(emittedSet).some(ck => {
 const [eArrId, coords] = ck.split(':');
 if(+eArrId !== arr.id) return false;
 const [x, y, z] = coords.split(',').map(Number);
 // Check if this emitted cell is in the newly expanded area and is empty
 const isInExpansion = x >= oldSize.x || y >= oldSize.y || z >= oldSize.z;
 if(isInExpansion) {
 const cell = UI.getCell(arr.id, {x, y, z});
 return cell.value === '' || cell.value === null || cell.value === undefined;
 }
 return false;
 });
 
 if(hasEmptyInExpansion) {
 // Re-execute the source to refill the expansion
 const [aId, rest] = sourceAk.split(':');
 const [sx, sy, sz] = rest.split(',').map(Number);
 setTimeout(() => {
 if(!Actions._repairing) {
 Actions._repairing = true;
 try {
 const tx = Write.start('expand.refill', 'Refill after array expansion');
 Formula.executeAt({arrId: +aId, x: sx, y: sy, z: sz}, undefined, tx);
 Write.commit(tx);
 } finally {
 Actions._repairing = false;
 }
 }
 }, 10); // Small delay to avoid recursion
 }
 });
 }
 },
 // Update all global references when an array expands
 offsetGlobalReferences: (arrayId, oldSize, newSize) => {
 const S = Store.getState();
 const dx = newSize.x - oldSize.x;
 const dy = newSize.y - oldSize.y; 
 const dz = newSize.z - oldSize.z;
 
 if(dx === 0 && dy === 0 && dz === 0) return; // No expansion
 
 console.log(`Offsetting references for array ${arrayId}: expansion (${dx},${dy},${dz})`);
 
 // Update all formulas that reference cells in the expanded array
 Object.values(S.arrays).forEach(arr => {
 Object.values(arr.chunks).forEach(chunk => {
 chunk.cells.forEach(cell => {
 if(cell.formula) {
 // Check if formula contains references to the expanded array
 const refs = cell.formula.match(/@\[(-?\d+),(-?\d+),(-?\d+),(-?\d+)\]/g);
 if(refs) {
 let newFormula = cell.formula;
 refs.forEach(ref => {
 const match = ref.match(/@\[(-?\d+),(-?\d+),(-?\d+),(-?\d+)\]/);
 if(match && +match[4] === arrayId) {
 const refX = +match[1], refY = +match[2], refZ = +match[3];
 // Only offset if reference is beyond the original bounds
 if(refX >= oldSize.x || refY >= oldSize.y || refZ >= oldSize.z) {
 const newRef = `@[${refX + (refX >= oldSize.x ? dx : 0)},${refY + (refY >= oldSize.y ? dy : 0)},${refZ + (refZ >= oldSize.z ? dz : 0)},${arrayId}]`;
 newFormula = newFormula.replace(ref, newRef);
 }
 }
 });
 
 if(newFormula !== cell.formula) {
 cell.formula = newFormula;
 console.log(`Updated formula: ${cell.formula}`);
 }
 }
 }
 });
 });
 });
 
 // Update dependency graph keys
 const newDepsByAnchor = new Map();
 const newAnchorsByDep = new Map();
 
 S.depsByAnchor.forEach((deps, anchorKey) => {
 const [aId, coords] = anchorKey.split(':');
 if(+aId === arrayId) {
 const [x, y, z] = coords.split(',').map(Number);
 if(x >= oldSize.x || y >= oldSize.y || z >= oldSize.z) {
 const newX = x + (x >= oldSize.x ? dx : 0);
 const newY = y + (y >= oldSize.y ? dy : 0);
 const newZ = z + (z >= oldSize.z ? dz : 0);
 const newKey = `${aId}:${newX},${newY},${newZ}`;
 newDepsByAnchor.set(newKey, deps);
 } else {
 newDepsByAnchor.set(anchorKey, deps);
 }
 } else {
 newDepsByAnchor.set(anchorKey, deps);
 }
 });
 
 S.anchorsByDep.forEach((anchors, depKey) => {
 const [aId, coords] = depKey.split(':');
 if(+aId === arrayId) {
 const [x, y, z] = coords.split(',').map(Number);
 if(x >= oldSize.x || y >= oldSize.y || z >= oldSize.z) {
 const newX = x + (x >= oldSize.x ? dx : 0);
 const newY = y + (y >= oldSize.y ? dy : 0);
 const newZ = z + (z >= oldSize.z ? dz : 0);
 const newKey = `${aId}:${newX},${newY},${newZ}`;
 newAnchorsByDep.set(newKey, anchors);
 } else {
 newAnchorsByDep.set(depKey, anchors);
 }
 } else {
 newAnchorsByDep.set(depKey, anchors);
 }
 });
 
 Store.setState({ depsByAnchor: newDepsByAnchor, anchorsByDep: newAnchorsByDep });
 },

 setSelection:(arrayId, focus, anchor=null, interactionSource='3d')=>{
 console.log(`[ACTIONS.setSelection] Called with: arrayId=${arrayId}, focus=(${focus.x}, ${focus.y}, ${focus.z}), source=${interactionSource}`);
 Store.setState(s=>({ selection:{arrayId, focus, anchor:anchor||focus, range:null, faceHint:null}, ui:{...s.ui, zLayer:focus.z, lastInteraction:interactionSource} }));
 const actualSelection = Store.getState().selection;
 console.log(`[ACTIONS.setSelection] After setState, actual focus=(${actualSelection.focus.x}, ${actualSelection.focus.y}, ${actualSelection.focus.z})`);
 Scene.updateFocus(Store.getState().selection);
 Scene.resetContactCache?.();
 UI.updateFocusChip();
 UI.renderSheet();

 // ---- ON_SELECT dispatch (no-stamp, single tx, recursion-guard) ----
 try {
 const arr=Store.getState().arrays[arrayId];
 const hooks = ensureOnSelectHooks(arr);
 if(!hooks.length) return;

 if(Actions._handlingOnSelect) return; // guard against re-entrancy
 Actions._handlingOnSelect = true;

 const {x,y,z}=focus; 
 const addr=formatLocalAddress(arrayId,{x,y,z});
 const tx=Write.start('hook.on_select','ON_SELECT actions');
 for(const h of hooks){
 if(h.cells.has(`${x},${y},${z}`)){
 const action = String(h.action||'').replaceAll('$ADDR',addr);
 Formula.runOnceAt({arrId:arrayId, x:h.anchor.x, y:h.anchor.y, z:h.anchor.z}, action, tx);
 }
 }
 Write.commit(tx);
 } catch(e) {
 console.warn('ON_SELECT hooks failed', e);
 } finally {
 Actions._handlingOnSelect = false;
 }
 },

 setSelectionRange:(arrayId, anchor, focus, interactionSource='3d')=>{
 const xs=[anchor.x,focus.x].map(v=>Number.isFinite(v)?v:0).sort((a,b)=>a-b);
 const ys=[anchor.y,focus.y].map(v=>Number.isFinite(v)?v:0).sort((a,b)=>a-b);
 const zs=[anchor.z,focus.z].map(v=>Number.isFinite(v)?v:0).sort((a,b)=>a-b);
 const focusZ = Number.isFinite(focus.z) ? focus.z : (Number.isFinite(anchor.z) ? anchor.z : 0);
 const range={x1:xs[0],y1:ys[0],x2:xs[1],y2:ys[1],z:focusZ,z1:zs[0],z2:zs[1]};
 const faceHint = computeSelectionFaceHint(anchor, focus, range);
 Store.setState(s=>({ selection:{arrayId, focus, anchor, range, faceHint}, ui:{...s.ui, zLayer:focusZ, lastInteraction:interactionSource} }));
 Scene.updateFocus(Store.getState().selection);
 UI.updateFocusChip();
 UI.renderSheet();
 },

 moveSelection:(dx,dy,dz=0)=>{
 const s=Store.getState().selection; if(!s.arrayId||!s.focus) return;
 const arr=Store.getState().arrays[s.arrayId]; if(!arr) return;
 const lastInteraction = Store.getState().ui?.lastInteraction || '3d';
 const newFocus={x:Math.max(0,Math.min(arr.size.x-1,s.focus.x+dx)), y:Math.max(0,Math.min(arr.size.y-1,s.focus.y+dy)), z:Math.max(0,Math.min(arr.size.z-1,s.focus.z+dz))};
 if(s.range){
 const newAnchor={x:Math.max(0,Math.min(arr.size.x-1,s.anchor.x+dx)), y:Math.max(0,Math.min(arr.size.y-1,s.anchor.y+dy)), z:Math.max(0,Math.min(arr.size.z-1,s.anchor.z+dz))};
 Actions.setSelectionRange(s.arrayId, newAnchor, newFocus, lastInteraction);
 } else {
 Actions.setSelection(s.arrayId, newFocus);
 }
 },

 togglePhysics: ()=>{
 try{
 const result = Scene.togglePhysicsMode?.();
 if(result && typeof result.catch === 'function'){
 result.catch(e=>console.warn('[PHYSICS] togglePhysics failed', e));
 }
 }catch(e){ console.warn('[PHYSICS] togglePhysics threw', e); }
 },
 toggleGrid: ()=>{ Store.setState(s=>({scene:{...s.scene, showGrid:!s.scene.showGrid}})); Scene.setGridVisible(Store.getState().scene.showGrid); },
 toggleAxes: ()=>{ Store.setState(s=>({scene:{...s.scene, showAxes:!s.scene.showAxes}})); Scene.setAxesVisible(Store.getState().scene.showAxes); },
 setCrystal2D: (enabled)=>{
 const next = !!enabled;
 Store.setState(s=>({ ui:{...s.ui, crystal2D: next} }));
 window.UI?.applyCrystalStyle?.(next);
 return next;
 },
 toggleCrystal2D: ()=>{
 const prev = !!Store.getState().ui?.crystal2D;
 const next = !prev;
 Actions.setCrystal2D(next);
 window.UI?.renderSheet?.();
 return next;
 },
 togglePresentMode: ()=> Scene.togglePresentMode(),
 updateGraphicsSettings: (patch)=> Scene.updateGraphicsSettings(patch || {}),
 setOceanEnabled: (enabled)=> Scene.setOceanEnabled(enabled),
 updateOceanSettings: (patch)=> Scene.updateOceanSettings(patch || {}),
 // Render mode removed - always use simple mode
 // Undo/Redo system
 // Data history (undo/redo)
 undoData: ()=>{
 if(History.dataPast.length === 0) return;
 const tx = History.dataPast.pop();
 History.dataFuture.push(tx);
 Write.rollback(tx);
 const changed = tx.ops.map(op => `${op.arrId}:${op.x},${op.y},${op.z}`);
 Formula.recomputeAnchors(changed);
 const affectedArrays = new Set(tx.ops.map(op => op.arrId));
 affectedArrays.forEach(id => { const arr = Store.getState().arrays[id]; if(arr){ Scene.renderArray(arr); if(id===Store.getState().selection.arrayId) UI.renderSheet(); } });
 },

 redoData: ()=>{
 if(History.dataFuture.length === 0) return;
 const tx = History.dataFuture.pop();
 History.dataPast.push(tx);
 tx.ops.forEach(op => { Actions._setCellRaw(op.arrId, {x:op.x, y:op.y, z:op.z}, op.next); });
 const changed = tx.ops.map(op => `${op.arrId}:${op.x},${op.y},${op.z}`);
 Formula.recomputeAnchors(changed);
 const affectedArrays = new Set(tx.ops.map(op => op.arrId));
 affectedArrays.forEach(id => { const arr = Store.getState().arrays[id]; if(arr){ Scene.renderArray(arr); if(id===Store.getState().selection.arrayId) UI.renderSheet(); } });
 },
};

/* ===========================
 Function Registry + Policy
=========================== */
const ALWAYS = new Set([
 'FUNCTIONS','LOCK','CREATE','ARRAY','PARAMETERS','ADDRESS','ALT_ADDRESS','COMBINE','COLOR','GETCOLOR',
 'ON_SELECT','ON_EVENT','FIRE_EVENT','SET_GLOBAL','GET_GLOBAL','FOCUS_SET','COPY',
 'SOKOBAN','SOKO_STEP','SOKOBAN2','SOKO_STEP2','SSR','SSR_STEP','DEP_VIS','GET_ARRAY_POS','SET_ARRAY_POS','TRANSLATE_ARRAY','ROTATE_ARRAY',
 'INVENTORY','3D_TRANSLATE','3D_ROTATE','DELETE','DEL','REMOVE','LIGHT','CHIME'
]);
const Fn = {}; // name -> {tags:[...], impl(anchor, arr, ast)}
const tag = (name,tags,impl)=>{ Fn[name]={tags:new Set(tags),impl}; };
function ensureTransaction(tx, origin='auto', reason='Formula mutation'){
 if(tx) return { tx, owned:false };
 return { tx: Write.start(origin, reason), owned:true };
}
function finalizeTransaction(info){
 if(info && info.owned && info.tx){
 Write.commit(info.tx);
 }
}
function collectTargetCells(arg, anchor){
 const out = [];
 if(arg && arg.kind === 'range'){
 arg.cells.forEach(cell=>{
 out.push({
 arrId: cell.arrId ?? anchor.arrId,
 x: cell.x,
 y: cell.y,
 z: cell.z
 });
 });
 } else if(arg && arg.kind === 'ref'){
 out.push({
 arrId: arg.arrId ?? anchor.arrId,
 x: arg.x,
 y: arg.y,
 z: arg.z
 });
 } else if(anchor){
 out.push({
 arrId: anchor.arrId,
 x: anchor.x,
 y: anchor.y,
 z: anchor.z
 });
 }
 return out;
}

const ARRAY_SCOPE_TOKEN = '__arrayScope';
function makeArrayScope(mode='host', ids=[]){
 const uniq = new Set();
 (ids||[]).forEach(id=>{
 const n = Number(id);
 if(Number.isFinite(n)) uniq.add(Math.trunc(n));
 });
 return { [ARRAY_SCOPE_TOKEN]: true, mode, ids: Array.from(uniq) };
}
function normalizeScopeDescriptor(raw, hostId=null){
 if(!raw || typeof raw !== 'object') return null;
 if(raw[ARRAY_SCOPE_TOKEN]){
 const mode = (raw.mode === 'all' || raw.mode === 'limit') ? raw.mode : 'host';
 const ids = Array.isArray(raw.ids) ? raw.ids.map(n=>Math.trunc(Number(n)||0)).filter(n=>Number.isFinite(n)) : [];
 if(mode === 'host' && ids.length === 0 && hostId != null) ids.push(Math.trunc(hostId));
 return { mode, ids };
 }
 if(typeof raw.mode === 'string' && raw.mode.toLowerCase() === 'all'){
 return { mode:'all', ids:[] };
 }
 if(Number.isFinite(raw.arrId)){
 return { mode:'limit', ids:[Math.trunc(raw.arrId)] };
 }
 if(Number.isFinite(raw.id)){
 return { mode:'limit', ids:[Math.trunc(raw.id)] };
 }
 return null;
}
function gatherArrayIdsFromValue(value, hostId, idsOut, flags){
 if(!idsOut) idsOut = new Set();
 if(!flags) flags = { all:false };
 if(value == null) return { ids: idsOut, flags };
 if(typeof value === 'object'){
 const normalized = normalizeScopeDescriptor(value, hostId);
 if(normalized){
 if(normalized.mode === 'all'){ flags.all = true; }
 normalized.ids.forEach(id=> idsOut.add(id));
 return { ids: idsOut, flags };
 }
 if(Array.isArray(value)){
 value.forEach(v=>{
 const res = gatherArrayIdsFromValue(v, hostId, idsOut, flags);
 idsOut = res.ids; flags = res.flags;
 });
 return { ids: idsOut, flags };
 }
 if(Number.isFinite(value.arrId)){ idsOut.add(Math.trunc(value.arrId)); }
 if(Number.isFinite(value.id)){ idsOut.add(Math.trunc(value.id)); }
 return { ids: idsOut, flags };
 }
 if(typeof value === 'string'){
 const trimmed = value.trim();
 if(trimmed.toLowerCase() === 'all'){ flags.all = true; return { ids: idsOut, flags }; }
 const addr = /^@\[(.*)\]$/.exec(trimmed);
 if(addr){
 const parts = addr[1].split(',').map(s=>s.trim()).filter(Boolean);
 if(parts.length >= 4){
 const arrPart = Number(parts[3]);
 if(Number.isFinite(arrPart)) idsOut.add(Math.trunc(arrPart));
 }
 return { ids: idsOut, flags };
 }
 const cleaned = trimmed.replace(/[\[\]\{\}]/g,'');
 cleaned.split(/[,\s]+/).forEach(part=>{
 if(!part) return;
 const n = Number(part);
 if(Number.isFinite(n)) idsOut.add(Math.trunc(n));
 });
 return { ids: idsOut, flags };
 }
 if(typeof value === 'number' && Number.isFinite(value)){
 idsOut.add(Math.trunc(value));
 }
 return { ids: idsOut, flags };
}
function extractScopeFromArgs(args, anchor, hostId){
 const ids = new Set();
 const flags = { all:false };
 (args||[]).forEach(arg=>{
 if(!arg) return;
 if(arg.kind === 'ref'){
 const id = arg.arrId ?? anchor?.arrId ?? hostId;
 if(Number.isFinite(id)) ids.add(Math.trunc(id));
 return;
 }
 if(arg.kind === 'range'){
 arg.cells.forEach(cell=>{
 const id = cell.arrId ?? anchor?.arrId ?? hostId;
 if(Number.isFinite(id)) ids.add(Math.trunc(id));
 });
 return;
 }
 try{
 const val = Formula.valOf(arg);
 const res = gatherArrayIdsFromValue(val, hostId, ids, flags);
 res.ids.forEach(id=> ids.add(id));
 if(res.flags?.all) flags.all = true;
 }catch{}
 });
 if(flags.all) return { mode:'all', ids:[] };
 if(ids.size === 0 && Number.isFinite(hostId)) ids.add(Math.trunc(hostId));
 return { mode:'limit', ids: Array.from(ids) };
}
function parseArrayScopeArg(scopeArg, anchor, hostArr){
 const hostId = hostArr?.id ?? anchor?.arrId ?? null;
 if(scopeArg == null){
 const ids = Number.isFinite(hostId) ? [Math.trunc(hostId)] : [];
 return { mode:'host', ids };
 }
 if(scopeArg && typeof scopeArg === 'object' && scopeArg[ARRAY_SCOPE_TOKEN]){
 return normalizeScopeDescriptor(scopeArg, hostId) || { mode:'host', ids:Number.isFinite(hostId)?[Math.trunc(hostId)]:[] };
 }
 if(scopeArg.kind === 'ref' || scopeArg.kind === 'range'){
 return extractScopeFromArgs([scopeArg], anchor, hostId);
 }
 let val;
 try{ val = Formula.valOf(scopeArg); }catch{}
 if(val && typeof val === 'object' && val[ARRAY_SCOPE_TOKEN]){
 return normalizeScopeDescriptor(val, hostId) || { mode:'host', ids:Number.isFinite(hostId)?[Math.trunc(hostId)]:[] };
 }
 if(typeof val === 'string' && val.trim().toLowerCase() === 'all'){
 return { mode:'all', ids:[] };
 }
 const res = gatherArrayIdsFromValue(val, hostId);
 if(res.flags?.all) return { mode:'all', ids:[] };
 const ids = Array.from(res.ids||[]);
 if(ids.length === 0 && Number.isFinite(hostId)) ids.push(Math.trunc(hostId));
 if(ids.length === 1 && ids[0] === Math.trunc(hostId)) return { mode:'host', ids };
 return ids.length ? { mode:'limit', ids } : { mode:'host', ids:Number.isFinite(hostId)?[Math.trunc(hostId)]:[] };
}
function resolveArrayScopeTargets(hostArr, anchor, scopeArg){
 const scope = parseArrayScopeArg(scopeArg, anchor, hostArr);
 const arrays = Store.getState().arrays || {};
 let targets = [];
 if(scope.mode === 'all'){
 targets = Object.values(arrays).filter(Boolean);
 } else if(scope.mode === 'limit'){
 const uniq = new Set(scope.ids||[]);
 targets = Array.from(uniq).map(id=>arrays[id]).filter(Boolean);
 } else {
 if(hostArr) targets = [hostArr];
 }
 if(!targets.length && hostArr) targets = [hostArr];
 return { scope, targets };
}
function mutateCellMeta(tx, target, updater){
 if(!target) return;
 const coord = {x: target.x, y: target.y, z: target.z};
 const arrId = target.arrId;
 const existing = Formula.getCell({arrId, ...coord}) || { value:'', formula:null, meta:{} };
 const baseMeta = {...(existing.meta || {})};
 const nextMeta = normalizeMetaKeys(updater ? updater(baseMeta, existing) || baseMeta : baseMeta) || {};
 Write.set(tx, arrId, coord, {
 value: existing.value,
 formula: existing.formula,
 meta: nextMeta
 });
}
function parseVectorArg(arg){
 if(!arg) return null;
 const raw = Formula.valOf(arg);
 if(Array.isArray(raw)){
 const nums = raw.map(v=> Number(v));
 if(nums.length >= 3 && nums.every(n=> Number.isFinite(n))){
 return { x: nums[0], y: nums[1], z: nums[2] };
 }
 }
 if(typeof raw === 'string'){
 const vecMatch = raw.match(/@\s*\[\s*([\-0-9.]+)\s*,\s*([\-0-9.]+)\s*,\s*([\-0-9.]+)\s*(?:,\s*[\-0-9.]+\s*)?\]/);
 if(vecMatch){
 const [ , sx, sy, sz ] = vecMatch;
 const vx = parseFloat(sx), vy = parseFloat(sy), vz = parseFloat(sz);
 if([vx,vy,vz].every(n=> Number.isFinite(n))){
 return { x: vx, y: vy, z: vz };
 }
 }
 }
 if(typeof raw === 'object' && raw && Number.isFinite(raw.x) && Number.isFinite(raw.y) && Number.isFinite(raw.z)){
 return { x: Number(raw.x), y: Number(raw.y), z: Number(raw.z) };
 }
 return null;
}

function arrayScaleUnitsFromLevel(level){
 const lvl = Math.max(1, Math.round(Number(level)||1));
 return Math.pow(2, Math.max(0, lvl-1));
}

function arrayVoxelScale(arr){
 if(!arr || typeof arr !== 'object') return 1;
 const params = arr.params || {};
 const direct = Number(params.voxelScale);
 if(Number.isFinite(direct) && direct > 0) return direct;
 const level = Number(params.voxelScaleLevel);
 if(Number.isFinite(level) && level >= 1) return arrayScaleUnitsFromLevel(level);
 return 1;
}

const BASE_VOXEL_GEOMETRY_SIZE = 0.9;
const BASE_VOXEL_MARGIN = (1 - BASE_VOXEL_GEOMETRY_SIZE) / 2;

function voxelMargin(scale){
 if(!Number.isFinite(scale) || scale <= 0) return BASE_VOXEL_MARGIN;
 return Math.min(scale * BASE_VOXEL_MARGIN, BASE_VOXEL_MARGIN);
}

function clampedScaleOffset(scale, coefficient){
 if(!Number.isFinite(scale) || scale <= 0) return coefficient;
 return Math.min(scale * coefficient, coefficient);
}

function voxelDisplayScale(scale){
 if(!Number.isFinite(scale) || scale <= 0) return 1;
 const spacing = scale;
 const margin = voxelMargin(spacing);
 const width = Math.max(spacing - 2 * margin, spacing * BASE_VOXEL_GEOMETRY_SIZE);
 return width / BASE_VOXEL_GEOMETRY_SIZE;
}

function voxelHalfExtent(scale, cells=1){
 if(!Number.isFinite(scale) || scale <= 0) return (BASE_VOXEL_GEOMETRY_SIZE * cells) / 2;
 const spacing = scale;
 const margin = voxelMargin(spacing);
 const total = Math.max(cells * spacing - 2 * margin, cells * spacing * BASE_VOXEL_GEOMETRY_SIZE);
 return total / 2;
}

function avatarPerchOffset(scale){
 const half = voxelHalfExtent(scale, 1);
 const hover = clampedScaleOffset(scale, 0.25);
 return half + hover;
}
// helper: policy check with proper tag filtering
function isAllowed(arr, fnName){
 if(ALWAYS.has(fnName)) return true;
 const pol=arr.fnPolicy||{mode:'ALLOW_ALL', allow:new Set(), deny:new Set(), tags:new Set()};
 const fnTags = Fn[fnName]?.tags || new Set();

 if(pol.mode==='ALLOW_ONLY'){
 if(pol.allow?.has(fnName)) return true;
 if(pol.tags?.size && [...pol.tags].some(t => fnTags.has(t))) return true;
 return false;
 }
 // ALLOW_ALL with optional deny / tag filter
 if(pol.deny?.has(fnName)) return false;
 if(pol.tags?.size) return [...pol.tags].some(t => fnTags.has(t));
 return true;
}

// Utility tags (registered after policy init)
// 3D_TRANSLATE(target, dx, dy, dz[, originRef])
// - target: array id (number) or ref within target array; if ref, its arrId is used
// - dx,dy,dz: integer notch offsets (snap grid)
// - originRef: optional ref used only for semantic symmetry; translation is uniform so origin isn't needed, but kept for API parity
tag('3D_TRANSLATE',["SCENE"],(anchor,arr,ast)=>{
 // Args: target (arrId | ref | "@[x,y,z,id]" | SELF()), dx, dy, dz[, continuous]
 const targetArg = ast.args[0];
 const toInt = (a)=>{ try{ const v = Formula.valOf(a); const s = String(v==null? a : v); const n = parseFloat(s.replace(/[^0-9\-+.]/g,'')); return Number.isFinite(n)? (n|0) : 0; }catch{ return 0; } };
 const dx = toInt(ast.args[1]);
 const dy = toInt(ast.args[2]);
 const dz = toInt(ast.args[3]);
 const cont = !!toInt(ast.args[4]||0);

 const S = Store.getState();
 let targetArr = null;
 let queueAnchor = anchor; // default to the calling cell if no explicit ref provided

 if(targetArg && targetArg.kind==='ref'){
 targetArr = S.arrays[targetArg.arrId];
 queueAnchor = { x:targetArg.x, y:targetArg.y, z:targetArg.z, arrId: targetArg.arrId };
 } else {
 const raw = Formula.valOf(targetArg);
 // Try parsing absolute ref strings like SELF() => "@[x,y,z,id]"
 if(typeof raw === 'string'){
 try{
 const parsed = parseAlt(raw, anchor);
 if(parsed && S.arrays[parsed.arrId]){
 targetArr = S.arrays[parsed.arrId];
 queueAnchor = { x:parsed.x, y:parsed.y, z:parsed.z, arrId: parsed.arrId };
 }
 }catch{}
 }
 if(!targetArr){
 const id = +raw;
 if(Number.isFinite(id) && S.arrays[id]){
 targetArr = S.arrays[id];
 // If only an ID was provided, anchor defaults to A1a of the target for preview semantics
 queueAnchor = { x:0, y:0, z:0, arrId:id };
 }
 }
 }

 if(!targetArr){ Actions.setCell(arr.id, anchor, '!ERR:TARGET', ast.raw, true); return; }

 const ak = aKey(anchor);
 let existingTranslateRec = null;
 try{ existingTranslateRec = (S.activeTranslations||new Map()).get(ak); }catch{}

 // If PREVIEW is on (in-array or 3D), do not apply now; animation system will read formulas
 let timed = null; try{ if(typeof Scene!=='undefined' && Scene.ensureTimedState) timed = Scene.ensureTimedState(targetArr); }catch{}
 const G0 = (Store.getState().scene||{}).timed3D;
 if((timed && timed.previewInArray) || (G0 && G0.preview)){
 return;
 }

 // Immediate translation respecting docking/parentage (apply to group as a unit)
 const group = [...(S.dockGroups||new Map()).values()].find(g=>g.members.includes(targetArr.id));
 const ids = group
 ? (group.mode==='parent'
 ? [targetArr.id, ...group.members.filter(id=> id!==targetArr.id && group.members.indexOf(id) > group.members.indexOf(targetArr.id))]
 : [...group.members])
 : [targetArr.id];
 const arrays = ids.map(id=>S.arrays[id]).filter(Boolean);

 const cloneOffset=(src)=>({
 x: Number.isFinite(+src?.x) ? Math.round(+src.x) : 0,
 y: Number.isFinite(+src?.y) ? Math.round(+src.y) : 0,
 z: Number.isFinite(+src?.z) ? Math.round(+src.z) : 0
 });
 const captureBases=(list)=> list.map(a=>({ id:a.id, offset:cloneOffset(a.offset||{x:0,y:0,z:0}) }));

 let baseRecords=null;
 if(existingTranslateRec && !cont){
 const baseMap=new Map();
 if(Array.isArray(existingTranslateRec.bases)){
 existingTranslateRec.bases.forEach(entry=>{
 if(entry==null) return;
 const id=Number.isFinite(+entry.id)?(+entry.id|0):null;
 if(id==null) return;
 const src=entry.offset||entry.base||entry;
 baseMap.set(id, cloneOffset(src));
 });
 }
 if(existingTranslateRec.from){
 const base=cloneOffset(existingTranslateRec.from);
 const targetId=Number.isFinite(+existingTranslateRec.targetId)?(+existingTranslateRec.targetId|0):targetArr.id;
 if(!baseMap.has(targetId)) baseMap.set(targetId, base);
 }
 arrays.forEach(a=>{
 const base=baseMap.get(a.id);
 if(base){ Scene.setArrayOffset(a, base, {interactive:true, _skipDock:true, _skipConnections:true}); }
 });
 baseRecords=captureBases(arrays);
 } else if(existingTranslateRec && cont){
 if(Array.isArray(existingTranslateRec.bases) && existingTranslateRec.bases.length){
 baseRecords=existingTranslateRec.bases.map(entry=>({
 id:Number.isFinite(+entry.id)?(+entry.id|0):targetArr.id,
 offset:cloneOffset(entry.offset||entry.base||entry)
 }));
 } else {
 baseRecords=captureBases(arrays);
 if(existingTranslateRec.from){
 const base=cloneOffset(existingTranslateRec.from);
 const targetId=Number.isFinite(+existingTranslateRec.targetId)?(+existingTranslateRec.targetId|0):targetArr.id;
 baseRecords=baseRecords.map(rec=> rec.id===targetId ? {id:rec.id, offset:base} : rec);
 }
 }
 } else {
 baseRecords=captureBases(arrays);
 }

 arrays.forEach(a=>{
 const offA = a.offset||{x:0,y:0,z:0};
 const nextA = { x: Math.round((offA.x||0) + dx), y: Math.round((offA.y||0) + dy), z: Math.round((offA.z||0) + dz) };
 Scene.setArrayOffset(a, nextA, {interactive:true, _skipDock:true, _skipConnections:true});
 });
 try{
 arrays.forEach(a=>{
 if(!a) return;
 const timedLocal = a.params?.timed;
 if(timedLocal){
 timedLocal.baseOffset = { ...(a.offset||{x:0,y:0,z:0}) };
 if(a._frame && a._frame.quaternion){
 try{ timedLocal.baseQuat = a._frame.quaternion.clone(); }catch{}
 }
 }
 });
 }catch{}
 Actions.setCell(arr.id, anchor, `Moved:${dx},${dy},${dz}`, ast.raw, true);
 // Record for revert when this anchor's formula is cleared; suppress repeat execution
 try{
 const S=Store.getState();
 const map=new Map(S.activeTranslations||new Map());
 const basesCloned = (baseRecords||[]).map(rec=>({ id:rec.id, offset:{...rec.offset} }));
 const targetBase = basesCloned.find(rec=>rec.id===targetArr.id)?.offset || cloneOffset(targetArr.offset||{x:0,y:0,z:0});
 map.set(ak, { targetId: targetArr.id, from:{...targetBase}, delta:{dx,dy,dz}, bases:basesCloned });
 Store.setState({activeTranslations:map});
 // Persist revert info in meta so refresh can restore revert behavior
 const txw = Write.start('mark.3d.translate','mark');
 const cell = Formula.getCell(anchor) || {value:'',formula:null,meta:{}};
 Write.set(txw, arr.id, {x:anchor.x,y:anchor.y,z:anchor.z}, { value: cell.value, formula: cell.formula, meta:{...(cell.meta||{}), appliedTranslate:{ targetId: targetArr.id, from: targetBase, delta:{dx,dy,dz}, bases:basesCloned } } });
 Write.commit(txw);
 }catch{}
});
// 3D_ROTATE(targetOrPivot, stepsX[, stepsY[, stepsZ]])
// - First arg: array ID or cell address (pivot + derives array ID). If ID, pivot defaults to A1a.
// - If ref has no ^arrId, it uses the host array (anchor's array).
// - Rotates entire docked structure (Parent or All modes) atomically around the pivot.
tag('3D_ROTATE',["SCENE"],(anchor,arr,ast)=>{
 const targetArg = ast.args[0];
 const sx = ast.args[2]!==undefined ? ((+Formula.valOf(ast.args[1])|0) || 0) : ((+Formula.valOf(ast.args[1]||0)|0));
 const sy = ast.args[2]!==undefined ? ((+Formula.valOf(ast.args[2])|0) || 0) : 0;
 const sz = ast.args[3]!==undefined ? ((+Formula.valOf(ast.args[3])|0) || 0) : 0;

 const S=Store.getState();
 let targetId=null, pivotRef=null;
 if(targetArg && targetArg.kind==='ref'){
 targetId = targetArg.arrId ?? arr.id;
 pivotRef = {x:targetArg.x,y:targetArg.y,z:targetArg.z,arrId:targetId};
 } else if(targetArg!==undefined){
 const id=+Formula.valOf(targetArg); if(!isNaN(id)) targetId=id;
 }
 if(targetId==null) targetId = arr.id;
 const targetArr = S.arrays[targetId];
 if(!targetArr){ Actions.setCell(arr.id, anchor, '!ERR:TARGET', ast.raw, true); return; }
 // If no explicit pivot, default to A1a (0,0,0)
 if(!pivotRef) pivotRef={x:0,y:0,z:0,arrId:targetId};

 // Resolve dock group membership
 const group = [...(S.dockGroups||new Map()).values()].find(g=>g.members.includes(targetArr.id));
 const ids = group
 ? (group.mode==='parent'
 ? [targetArr.id, ...group.members.filter(id=> id!==targetArr.id && group.members.indexOf(id) > group.members.indexOf(targetArr.id))]
 : [...group.members])
 : [targetArr.id];
 const arrays = ids.map(id=>S.arrays[id]).filter(Boolean);
 const ak=aKey(anchor);

 let existingRotationRec=null;
 try{ existingRotationRec = (S.activeRotations||new Map()).get(ak); }catch{}
 if(existingRotationRec){
 const revertIds = Array.isArray(existingRotationRec.ids) && existingRotationRec.ids.length
 ? existingRotationRec.ids
 : [existingRotationRec.targetId ?? targetArr.id];
 const revertArrays = revertIds.map(id=>S.arrays[id]).filter(Boolean);
 revertArrays.forEach(a=>{ if(a && !a._frame) Scene.renderArray(a); });
 const pivotArrPrev = S.arrays[existingRotationRec.targetId] || targetArr;
 if(pivotArrPrev){
 const pivotPrev = Scene.cellWorldPos(pivotArrPrev, existingRotationRec.pivot?.x||0, existingRotationRec.pivot?.y||0, existingRotationRec.pivot?.z||0);
 revertArrays.forEach(a=> Scene.rotateArrayAround(a, pivotPrev, -(existingRotationRec.steps?.sx||0), -(existingRotationRec.steps?.sy||0), -(existingRotationRec.steps?.sz||0)));
 revertArrays.forEach(a=>{ if(a?._frame){ a.offset={ x:Math.round(a._frame.position.x), y:Math.round(a._frame.position.y), z:Math.round(a._frame.position.z) }; } });
 }
 }

 // Timed preview queue (in-array or 3D)
 const timed0 = (typeof Scene!=='undefined' && Scene.ensureTimedState) ? Scene.ensureTimedState(arr) : (arr.params&&arr.params.timed);
 const G0 = (typeof Scene!=='undefined' && Scene.ensureTimed3D) ? Scene.ensureTimed3D() : ((Store.getState().scene||{}).timed3D);
 if(timed0?.previewInArray || (G0&&G0.preview)){
 queueTimedOp(arr, pivotRef||anchor, { type:'rotate', sx, sy, sz });
 Actions.setCell(arr.id, anchor, `Queued:Rot ${sx},${sy},${sz}`,(ast.raw||`=3D_ROTATE(${sx},${sy},${sz})`));
 return;
 }
 // Ensure frames
 arrays.forEach(a=>{ if(!a._frame) Scene.renderArray(a); });
 // Compute pivot in world space at time of rotation
 const pivotWorld = Scene.cellWorldPos(targetArr, pivotRef.x, pivotRef.y, pivotRef.z);

 // Apply atomic rotation
 arrays.forEach(a=> Scene.rotateArrayAround(a, pivotWorld, sx, sy, sz));
 arrays.forEach(a=>{ if(a._frame){ a.offset={ x:Math.round(a._frame.position.x), y:Math.round(a._frame.position.y), z:Math.round(a._frame.position.z) }; }});
 try{
 arrays.forEach(a=>{
 if(!a) return;
 const timedLocal = a.params?.timed;
 if(timedLocal){
 timedLocal.baseOffset = { ...(a.offset||{x:0,y:0,z:0}) };
 if(a._frame && a._frame.quaternion){
 try{ timedLocal.baseQuat = a._frame.quaternion.clone(); }catch{}
 }
 }
 });
 }catch{}

 // Track for revert when this anchor formula is removed
 try{
 const rec={targetId:targetArr.id, ids:[...ids], pivot:{...pivotRef}, steps:{sx,sy,sz}};
 const map=new Map(S.activeRotations||new Map()); map.set(ak, rec); Store.setState({activeRotations:map});
 }catch{}

 Actions.setCell(arr.id, anchor, `3D_Rotate:${targetArr.id};${sx},${sy},${sz}`, ast.raw, true);
});

// Backward-compatible alias: ROTATE_ARRAY delegates to 3D_ROTATE
tag('ROTATE_ARRAY',["SCENE"],(anchor,arr,ast)=> Fn['3D_ROTATE'].impl(anchor,arr,ast));
tag('PRIORITY',['META'], (anchor,arr,ast)=>{
 const target = ast.args[0];
 const level = (+Formula.valOf(ast.args[1])|0) || 0;
 const mode = (String(Formula.valOf(ast.args[2]||'value')).toLowerCase()==='coord')?'coord':'value';
 const sort = (()=>{ try{ return JSON.parse(String(Formula.valOf(ast.args[3]||'{}'))||'{}'); }catch{ return {}; }})();

 const items=[]; const push=(x,y,z)=>items.push({x,y,z, arrId:target?.arrId ?? arr.id});
 if(target && target.kind==='range') target.cells.forEach(c=>push(c.x,c.y,c.z));
 else if(target && target.kind==='ref') push(target.x,target.y,target.z);
 else push(anchor.x,anchor.y,anchor.z);

 arr.priority = arr.priority || [];
 arr.priority.push({level, mode, sort, items});
});

tag('FORMULA_TEXT',['PURE'], (anchor,arr,ast)=>{
 const t = (ast.args[0] && ast.args[0].kind==='ref') ? ast.args[0] : anchor;
 const c = Formula.getCell({arrId:t.arrId||arr.id, x:t.x, y:t.y, z:t.z});
 const f = c?.formula ?? '';
 Actions.setCell(arr.id, anchor, f, ast.raw, true);
});

// CREATE(x,y,z[, "Name"[, "Id"]]) optional explicit ID supported
tag('CREATE',["ACTION"],(anchor,arr,ast)=>{
 try{
 const args = ast.args.map(a => Formula.valOf(a));

 let sx = 6, sy = 4, sz = 6, name = 'Array', explicitId = null;
 let argOffset = 0;

 if (args.length > 0 && typeof args[0] === 'string') {
 name = args[0];
 argOffset = 1;
 }

 if (args.length >= argOffset + 1 && Number.isFinite(+args[argOffset])) sx = Math.max(1, (+args[argOffset] | 0));
 if (args.length >= argOffset + 2 && Number.isFinite(+args[argOffset + 1])) sy = Math.max(1, (+args[argOffset + 1] | 0));
 if (args.length >= argOffset + 3 && Number.isFinite(+args[argOffset + 2])) sz = Math.max(1, (+args[argOffset + 2] | 0));

 if (argOffset === 0 && args.length >= 4) name = String(args[3]);
 const idArgIndex = 4;
 if (args.length > idArgIndex && args[idArgIndex] != null) {
 const n = +args[idArgIndex];
 if (Number.isFinite(n)) explicitId = Math.trunc(n);
 }

 const opts = { name, size: {x: sx, y: sy, z: sz} };
 if(explicitId !== null) opts.id = explicitId;

 const created = Actions.createArray(opts);
 if (!created) throw new Error('Array creation failed internally.');

 const host = arr, newArr = created, gap = 1.0;
 const hostOff = host.offset || {x:0, y:0, z:0};
 const newX = hostOff.x + (host.size.x / 2) + (newArr.size.x / 2) + gap;
 Scene.setArrayOffset(newArr, {x: newX, y: hostOff.y, z: hostOff.z});

 Actions.setCell(arr.id, anchor, created.id, null, true);

 } catch(e) {
 Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true);
 }
});

// GET_NEXT_ID(): returns the lowest available positive integer ID
tag('GET_NEXT_ID',["META","PURE"],(anchor,arr,ast)=>{
 const ids = Object.values(Store.getState().arrays).map(a=>a.id).filter(id=>Number.isInteger(id) && id>0);
 const sorted = [...new Set(ids)].sort((a,b)=>a-b);
 let next=1; for(const n of sorted){ if(n===next) next++; else if(n>next) break; }
 Actions.setCell(arr.id, anchor, next, ast.raw, true);
});
// FORMULIZE(targetRef): builds a kickoff DO formula capturing arrays reachable from target
tag('FORMULIZE',["META","ACTION"],(anchor,arr,ast)=>{
 try{
 const target = ast.args[0] && ast.args[0].kind==='ref' ? ast.args[0] : anchor;
 const startId = target.arrId || arr.id;
 const S = Store.getState();
 if(!S.arrays[startId]){ Actions.setCell(arr.id, anchor, '!ERR:TARGET', ast.raw, true); return; }
 // BFS through formulas to find referenced array IDs
 const q=[startId]; const seen=new Set([startId]);
 while(q.length){
 const id=q.shift(); const A=S.arrays[id]; if(!A) continue;
 Object.values(A.chunks).forEach(ch=>{
 ch.cells.forEach(cell=>{
 if(!cell.formula) return;
 const matches = cell.formula.match(/@\[(-?\d+),(-?\d+),(-?\d+),(-?\d+)\]/g) || [];
 matches.forEach(m=>{ const mm=m.match(/@\[(-?\d+),(-?\d+),(-?\d+),(-?\d+)\]/); const refId=+mm[4]; if(refId>0 && !seen.has(refId) && S.arrays[refId]){ seen.add(refId); q.push(refId);} });
 const carats = cell.formula.match(/\^[0-9]+/g) || [];
 carats.forEach(tk=>{ const refId=+(tk.slice(1)); if(refId>0 && !seen.has(refId) && S.arrays[refId]){ seen.add(refId); q.push(refId);} });
 });
 });
 }
 const ids = Array.from(seen).sort((a,b)=>a-b);
 const idMap = new Map(ids.map((id,i)=>[id, `temp.id_${i+1}`]));
 const esc=(s)=> String(s).replace(/"/g,'\\\"');
 const lines=[];
 // Reserve IDs
 ids.forEach(id=>{ const key=idMap.get(id); lines.push(`"=SET_GLOBAL(\\\"${key}\\\", GET_NEXT_ID())"`); });
 // CREATE arrays (with proper escaping inside outer string)
 ids.forEach(id=>{
 const A=S.arrays[id]; const nm=esc(A.name||'Array');
 const size=`${A.size.x}, ${A.size.y}, ${A.size.z}`;
 lines.push(`"=CREATE(${size}, \\\"${nm}\\\", GET_GLOBAL(\\\"${idMap.get(id)}\\\"))"`);
 });
 // Populate values and formulas efficiently by aggregating contiguous 3D blocks
 ids.forEach(id=>{
 const A=S.arrays[id];
 const idExpr = `GET_GLOBAL(\\\"${idMap.get(id)}\\\")`;
 // Build occupancy and value hash per cell
 const W=A.size.x,H=A.size.y,D=A.size.z;
 const occ=new Map(); // key x,y,z -> {v, f}
 Object.values(A.chunks).forEach(ch=>{ ch.cells.forEach(c=>{ const k=`${c.x},${c.y},${c.z}`; occ.set(k,{v:c.value,f:c.formula}); }); });
 const visited=new Set();
 const key=(x,y,z)=>`${x},${y},${z}`;
 const inb=(x,y,z)=> x>=0&&y>=0&&z>=0&&x<W&&y<H&&z<D;
 // Helper to emit a fill block via EXEC_AT to avoid dynamic A1^id refs
 const emitFill=(x1,y1,z1,x2,y2,z2,val)=>{
 const w=x2-x1+1,h=y2-y1+1,d=z2-z1+1;
 const v = typeof val==='string' ? `\"${esc(val)}\"` : `${val}`;
 // Use EXEC_AT with ARRAY("fill",...) at (x1,y1,z1) inside target array idExpr
 lines.push(`"=EXEC_AT(${x1},${y1},${z1}, ${idExpr}, \"=ARRAY(\\\"fill\\\", ${w}, ${h}, ${d}, ${v})\")"`);
 };
 // Greedy 3D block aggregation for identical scalar values
 for(let z=0;z<D;z++) for(let y=0;y<H;y++) for(let x=0;x<W;x++){
 const k=key(x,y,z); if(visited.has(k)) continue; const cell=occ.get(k)||{v:'',f:null};
 if(cell.f || cell.v==='' || cell.v===null || cell.v===undefined){ continue; }
 // grow in X
 let x2=x; while(inb(x2+1,y,z)){ const c=occ.get(key(x2+1,y,z))||{v:'',f:null}; if(visited.has(key(x2+1,y,z)) || c.f || c.v!==cell.v) break; x2++; }
 // grow in Y
 let y2=y; outerY: while(inb(x,y2+1,z)){
 for(let xi=x; xi<=x2; xi++){ const c=occ.get(key(xi,y2+1,z))||{v:'',f:null}; if(visited.has(key(xi,y2+1,z)) || c.f || c.v!==cell.v){ break outerY; } }
 y2++;
 }
 // grow in Z
 let z2=z; outerZ: while(inb(x,y,z2+1)){
 for(let yi=y; yi<=y2; yi++) for(let xi=x; xi<=x2; xi++){ const c=occ.get(key(xi,yi,z2+1))||{v:'',f:null}; if(visited.has(key(xi,yi,z2+1)) || c.f || c.v!==cell.v){ break outerZ; } }
 z2++;
 }
 // mark visited and emit
 for(let zz=z; zz<=z2; zz++) for(let yy=y; yy<=y2; yy++) for(let xx=x; xx<=x2; xx++) visited.add(key(xx,yy,zz));
 emitFill(x,y,z,x2,y2,z2,cell.v);
 }
 // Emit formulas with ID remapping using EXEC_AT for precise stamping
 Object.values(A.chunks).forEach(ch=>{
 ch.cells.forEach(c=>{
 if(!c.formula) return;
 let f=String(c.formula);
 ids.forEach(oldId=>{ const keyVar=idMap.get(oldId); f=f.replace(new RegExp(`\\^${oldId}\\b`,'g'), `^" & GET_GLOBAL(\\\"${keyVar}\\\") & "`); f=f.replace(new RegExp(`@\\[(-?\\d+),(-?\\d+),(-?\\d+),${oldId}\\]`,'g'), `@[" & $1 & "," & $2 & "," & $3 & "," & GET_GLOBAL(\\\"${keyVar}\\\") & "]`); });
 const tx = `=EXEC_AT(${c.x},${c.y},${c.z}, ${idExpr}, \"${esc(f)}\")`;
 lines.push(`"${tx}"`);
 });
 });
 // Set positions
 const off=A.offset||{x:0,y:0,z:0};
 lines.push(`"=SET_ARRAY_POS(${idExpr}, ${Math.round(off.x)}, ${Math.round(off.y)}, ${Math.round(off.z)})"`);
 });
 // Self cleanup
 lines.push(`"=SET(SELF(), \"\")"`);
 const out = `=DO(\n ${lines.join(',\n ')}\n)`;
 Actions.setCell(arr.id, anchor, out, ast.raw, true);
 }catch(e){ Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true); }
});

// SPLIT(text, delimiter[, splitByEach]) -> array of tokens (vertical list starting at anchor)
tag('SPLIT',['PURE','BLOCK'], (anchor,arr,ast,tx)=>{
 if(!tx) throw new Error('SPLIT requires active transaction');
 const text = String(Formula.valOf(ast.args[0] ?? ''));
 const delimRaw = Formula.valOf(ast.args[1] ?? '');
 const splitByEach = !!Formula.valOf(ast.args[2] ?? 0);
 const delims = String(delimRaw);
 let parts;
 if(splitByEach){
 const re = new RegExp(`[${delims.replace(/[.*+?^${}()|[\]\\]/g,'\\$&')}]`, 'g');
 parts = text.split(re);
 } else {
 parts = delims==='' ? [text] : text.split(delims);
 }
 for(let i=0;i<parts.length;i++){
 Write.set(tx, arr.id, {x:anchor.x, y:anchor.y-i, z:anchor.z}, { value: parts[i], formula: i===0?ast.raw:null, meta:{generated:true, emitter:aKey(anchor)} });
 }
});
// INDEX(rangeOrRef, row[, col[, depth]]) 1-based; supports 3D offsets
tag('INDEX',['PURE'], (anchor,arr,ast)=>{
 const tgt = ast.args[0];
 const r = (+Formula.valOf(ast.args[1])|0) || 1;
 const c = (+Formula.valOf(ast.args[2])|0) || 1;
 const d = ast.args[3]!==undefined ? ((+Formula.valOf(ast.args[3])|0) || 1) : 1;
 let ref;
 if(tgt && tgt.kind==='range'){
 const xs=[...new Set(tgt.cells.map(t=>t.x))].sort((a,b)=>a-b);
 const ys=[...new Set(tgt.cells.map(t=>t.y))].sort((a,b)=>a-b);
 const zs=[...new Set(tgt.cells.map(t=>t.z))].sort((a,b)=>a-b);
 const x=xs[Math.min(xs.length-1, Math.max(0, c-1))];
 const y=ys[Math.min(ys.length-1, Math.max(0, r-1))];
 const z=zs[Math.min(zs.length-1, Math.max(0, d-1))];
 ref = {x,y,z,arrId:tgt.cells[0].arrId,kind:'ref'};
 } else if(tgt && tgt.kind==='ref'){
 ref = {x:tgt.x+(c-1), y:tgt.y+(r-1), z:tgt.z+(d-1), arrId:tgt.arrId, kind:'ref'};
 } else {
 ref = anchor;
 }
 const v = Formula.getCellValue(ref);
 Actions.setCell(arr.id, anchor, v, ast.raw, true);
});

// MATCH(lookup, range[, matchType]) returns 1-based position along linearized order
tag('MATCH',['PURE'], (anchor,arr,ast)=>{
 const lookup = Formula.valOf(ast.args[0]);
 const tgt = ast.args[1];
 const matchType = (+Formula.valOf(ast.args[2] ?? 0))|0; // 0 exact
 let cells = [];
 if(tgt && tgt.kind==='range') cells = tgt.cells;
 else if(tgt && tgt.kind==='ref') cells = [{x:tgt.x,y:tgt.y,z:tgt.z,arrId:tgt.arrId}];
 let pos = 0;
 for(let i=0;i<cells.length;i++){
 const v = Formula.getCellValue(cells[i]);
 if(matchType===0){ if(String(v)===String(lookup)){ pos=i+1; break; } }
 else { const nv=(+v)||0, nl=(+lookup)||0; if((matchType>0 && nv<=nl) || (matchType<0 && nv>=nl)){ pos=i+1; } }
 }
 Actions.setCell(arr.id, anchor, pos, ast.raw, true);
});

// XLOOKUP(lookup, rangeKeys, rangeVals[, ifNotFound])
tag('XLOOKUP',['PURE'], (anchor,arr,ast)=>{
 const lookup = Formula.valOf(ast.args[0]);
 const keys = ast.args[1];
 const vals = ast.args[2];
 const ifNotFound = ast.args[3]!==undefined ? Formula.valOf(ast.args[3]) : '';
 const toList=(arg)=> (arg && arg.kind==='range') ? arg.cells : (arg && arg.kind==='ref') ? [arg] : [];
 const keyCells = toList(keys);
 const valCells = toList(vals);
 let out = ifNotFound;
 for(let i=0;i<keyCells.length;i++){
 if(String(Formula.getCellValue(keyCells[i]))===String(lookup)){
 const vc = valCells[i] || valCells[0];
 out = vc ? Formula.getCellValue(vc) : ifNotFound;
 break;
 }
 }
 Actions.setCell(arr.id, anchor, out, ast.raw, true);
});

// Matrix utilities + TRANSPOSE
function toMatrix(anchor, arr, arg){
 const val=(r)=> Formula.getCellValue({arrId:r.arrId||arr.id,x:r.x,y:r.y,z:r.z});
 try{
 if(arg && arg.kind==='range'){
 const cells=arg.cells||[]; if(cells.length===0) return [[""]];
 const xs=[...new Set(cells.map(c=>c.x))].sort((a,b)=>a-b);
 const ys=[...new Set(cells.map(c=>c.y))].sort((a,b)=>a-b);
 const z0=cells[0].z; const map=new Map();
 cells.forEach(c=>{ if(c.z===z0) map.set(`${c.x},${c.y}`, val(c)); });
 const M=[]; for(let yi=0; yi<ys.length; yi++){ const row=[]; for(let xi=0; xi<xs.length; xi++){ const k=`${xs[xi]},${ys[yi]}`; row.push(map.has(k)? map.get(k) : ""); } M.push(row);} return M;
 }
 if(arg && arg.kind==='ref') return [[ val(arg) ]];
 if(arg && arg.type==='FunctionCall' && String(arg.name||'').toUpperCase()==='ARRAY'){
 const mode= String(Formula.valOf(arg.arguments[0]||'list')||'list').toLowerCase();
 if(mode==='list'){ const items = arg.arguments.slice(1).map(a=> Formula.valOf(a)); return items.map(v=>[v]); }
 if(mode==='fill'){ const w=(+Formula.valOf(arg.arguments[1]||1))|0, h=(+Formula.valOf(arg.arguments[2]||1))|0; const v=Formula.valOf(arg.arguments[4]||""); const M=[]; for(let y=0;y<Math.max(1,h);y++){ const row=[]; for(let x=0;x<Math.max(1,w);x++) row.push(v); M.push(row);} return M; }
 return [[ String(Formula.valOf(arg.arguments[1]||'')) ]];
 }
 const maybeId=+Formula.valOf(arg);
 if(Number.isFinite(maybeId)){
 const A=Store.getState().arrays[maybeId]; if(A){ const z=Math.max(0,Math.min(A.size.z-1,anchor.z|0)); const M=[]; for(let y=0;y<A.size.y;y++){ const row=[]; for(let x=0;x<A.size.x;x++){ row.push(Formula.getCellValue({arrId:A.id,x,y,z})); } M.push(row);} return M; }
 }
 }catch{}
 return [[ Formula.valOf(arg) ]];
}

console.log('Registering TRANSPOSE function...');
tag('TRANSPOSE',['PURE','BLOCK'], (anchor,arr,ast,tx)=>{
 const __ownsTx = !tx; if(__ownsTx) tx = Write.start('transpose.auto','TRANSPOSE');
 console.log('=== TRANSPOSE DEBUG START ===');
 console.log('TRANSPOSE called with:', {
 anchor: `${anchor.x},${anchor.y},${anchor.z}`,
 arrayId: arr.id,
 astRaw: ast.raw,
 astFn: ast.fn,
 astArgs: ast.args,
 argCount: ast.args?.length,
 hasTx: !!tx,
 ownsTx: __ownsTx
 });
 // Debug: check if we have _astArgs (raw AST arguments)
 if(ast._astArgs) console.log('Raw AST args:', ast._astArgs);
 try{
 // Clear previously emitted cells from this anchor
 const S=Store.getState(); const ak=aKey(anchor);
 const prev=S.emittedByAnchor?.get?.(ak);
 if(prev){
 prev.forEach(ck=>{ try{ const [aid,rest]=ck.split(':'); const [cx,cy,cz]=rest.split(',').map(Number); Write.set(tx,+aid,{x:cx,y:cy,z:cz},{ value:'', formula:null, meta:{} }); S.sourceByCell?.delete?.(ck); }catch{} });
 S.emittedByAnchor?.delete?.(ak);
 }

 // Track emissions for proper cleanup and visuals
 const emitted = new Set();
 const recordEmit = (x,y,z)=>{ const ck=`${arr.id}:${x},${y},${z}`; emitted.add(ck); if(!S.sourceByCell) S.sourceByCell=new Map(); S.sourceByCell.set(ck,ak); };
 // Ensure array can hold target then write & record
 const ensureAndWrite = (x,y,z,v,isAnchorWrite)=>{
 if(z<0){ try{ Actions.expandZFront?.(arr, -z); }catch{} }
 try{ Actions.resizeArrayIfNeeded(arr, {x,y,z}); }catch{}
 const isAnchor=(x===anchor.x && y===anchor.y && z===anchor.z);
 if(!isAnchor || isAnchorWrite){
 Write.set(tx, arr.id, {x,y,z}, { value:v, formula:(isAnchor?ast.raw:null), meta:{generated:true, emitter:ak} });
 recordEmit(x,y,z);
 }
 };

 // Check if we have any arguments
 if(!ast.args || ast.args.length === 0){
 console.log('No arguments provided to TRANSPOSE, trying to parse raw formula');
 // Try to parse the raw formula string as fallback
 const raw = ast.raw || '';
 const match = raw.match(/transpose\s*\(\s*(.+)\s*\)/i);
 if(match){
 const argStr = match[1];
 console.log('Found raw argument string:', argStr);
 // Try to parse ARRAY(...) from string
 const arrayMatch = argStr.match(/array\s*\(\s*(.+)\s*\)/i);
 if(arrayMatch){
 const arrayContent = arrayMatch[1];
 console.log('Found ARRAY content:', arrayContent);
 // Split by comma and evaluate each part
 const parts = arrayContent.split(',').map(s => s.trim());
 console.log('ARRAY parts:', parts);
 const values = parts.map(p => {
 // Remove quotes if present
 const clean = p.replace(/^["']|["']$/g, '');
 const num = +clean;
 return Number.isNaN(num) ? clean : num;
 });
 console.log('Parsed values:', values);
 // Create column matrix
 const M = values.map(v => [v]);
 console.log('Created matrix from raw parsing:', M);
 
 // Skip to transpose logic
 const H=M.length; const W=M[0].length;
 console.log('Raw parse matrix dimensions:', {H, W, M});
 
 // Optional axis & dir 
 const axis = 0; // default XY
 const dir = 0; // default positive
 
 // The destination matrix has dimensions WxH (transpose)
 for(let r=0;r<W;r++){
 for(let c=0;c<H;c++){
 const v=(M[c]&&M[c][r]!==undefined)?M[c][r]:"";
 
 let txX=anchor.x + (dir ? -c : c);
 let txY=anchor.y + r; 
 let txZ=anchor.z;
 
 console.log(`Raw parse writing cell [${r},${c}]: value="${v}" to (${txX},${txY},${txZ})`);
 ensureAndWrite(txX,txY,txZ, v, (r===0&&c===0));
 }
 }
 
 // Record all emissions for cleanup
 if(emitted.size > 0){
 if(!S.emittedByAnchor) S.emittedByAnchor = new Map();
 S.emittedByAnchor.set(ak, emitted);
 }
 
 console.log('Raw parse TRANSPOSE completed, emitted:', emitted.size, 'cells');
 if(__ownsTx) Write.commit(tx);
 return;
 }
 }
 
 Write.set(tx, arr.id, anchor, { value: '!ERR:TRANSPOSE needs an argument', formula: ast.raw, meta: { emitter: ak } });
 if(__ownsTx) Write.commit(tx);
 return;
 }

 // Try to get matrix from input - handle both ranges and ARRAY() calls
 let M = null;
 let srcArg = ast.args[0];
 console.log('srcArg from ast.args[0]:', srcArg);
 
 // If ast.args[0] is undefined but we have _astArgs, use that instead
 if(!srcArg && ast._astArgs && ast._astArgs.length > 0) {
 srcArg = ast._astArgs[0];
 console.log('Using _astArgs[0] instead:', srcArg);
 }
 
 console.log('Final srcArg:', srcArg);
 
 // First try the toMatrix helper
 try { M = toMatrix(anchor,arr,srcArg); console.log('toMatrix result:', M); } catch(e){ console.log('toMatrix failed:', e); }
 
 // If that fails, handle ARRAY() calls manually
 // Also check for [object Object] which indicates toMatrix failed to parse the AST
 const isEmptyOrBadMatrix = !M || M.length === 0 || 
 (M.length === 1 && M[0].length === 1 && (M[0][0] === '' || String(M[0][0]).includes('[object Object]')));
 
 if(isEmptyOrBadMatrix) {
 console.log('toMatrix failed, trying manual parsing');
 // Check for AST-style ARRAY call
 if(srcArg && (srcArg.type === 'FunctionCall' || srcArg.fn) && String(srcArg.name || srcArg.fn || '').toUpperCase()==='ARRAY'){
 try{
 console.log('Handling ARRAY() call, srcArg:', srcArg);
 // Handle both AST-style (srcArg.arguments) and legacy-style (srcArg.args)
 const argList = srcArg.arguments || srcArg.args || [];
 console.log('ARRAY argList:', argList);
 const values = argList.map(a=> {
 // Handle different argument formats
 if(a && typeof a === 'object' && 'value' in a) return a.value;
 if(a && typeof a === 'object' && a.type === 'Literal') return a.value;
 return Formula.valOf(a);
 });
 console.log('ARRAY values:', values);
 M = values.map(v => [v]); // Convert to column matrix
 console.log('Created matrix:', M);
 }catch(e){ console.log('ARRAY parsing failed:', e); }
 } else if(srcArg && srcArg.kind==='range'){
 console.log('Handling range directly');
 // Handle range directly
 const cells = srcArg.cells||[];
 if(cells.length > 0){
 const xs=[...new Set(cells.map(c=>c.x))].sort((a,b)=>a-b);
 const ys=[...new Set(cells.map(c=>c.y))].sort((a,b)=>a-b);
 const z0=cells[0].z; const map=new Map();
 cells.forEach(c=>{ if(c.z===z0) map.set(`${c.x},${c.y}`, Formula.getCellValue({arrId:c.arrId||arr.id,x:c.x,y:c.y,z:c.z})); });
 M=[]; for(let yi=0; yi<ys.length; yi++){ const row=[]; for(let xi=0; xi<xs.length; xi++){ const k=`${xs[xi]},${ys[yi]}`; row.push(map.has(k)? map.get(k) : ""); } M.push(row);}
 console.log('Range matrix:', M);
 }
 } else {
 console.log('Fallback: treating as single value');
 const val = Formula.valOf(srcArg);
 M = [[val]];
 console.log('Single value matrix:', M);
 }
 }

 if (!M || M.length === 0 || M[0].length === 0) {
 console.log('No valid matrix, stamping anchor with empty value');
 // If still no valid input, stamp anchor with formula and empty value
 Write.set(tx, arr.id, anchor, { value: '', formula: ast.raw, meta: { emitter: ak } });
 if(__ownsTx) Write.commit(tx);
 return;
 }
 
 const H=M.length; const W=M[0].length;
 console.log('Final matrix dimensions:', {H, W, M});

 // Optional axis & dir - check both legacy args and _astArgs
 let axisRaw = 0, dirRaw = 0;
 if(ast.args && ast.args[1] !== undefined) {
 axisRaw = Formula.valOf(ast.args[1]);
 } else if(ast._astArgs && ast._astArgs[1]) {
 axisRaw = Formula.valOf(ast._astArgs[1]);
 }
 if(ast.args && ast.args[2] !== undefined) {
 dirRaw = Formula.valOf(ast.args[2]);
 } else if(ast._astArgs && ast._astArgs[2]) {
 dirRaw = Formula.valOf(ast._astArgs[2]);
 }
 
 const axisStr = String(axisRaw||'0').toUpperCase();
 // Axis: 0=XY (swap X<->Y, default), 1=XZ (swap X<->Z), 2=YZ (swap Y<->Z)
 const axis = (axisStr==='XY'||axisStr==='0') ? 0 : (axisStr==='XZ'||axisStr==='1') ? 1 : (axisStr==='YZ'||axisStr==='2') ? 2 : (+axisStr|0);
 // Direction: 0 positive (default), 1 negative (reversed)
 const dir = ((+dirRaw|0)===1) ? 1 : 0;
 console.log('Transpose params:', {axisRaw, dirRaw, axis, dir});

 // The destination matrix has dimensions WxH (transpose)
 for(let r=0;r<W;r++){ // r = destination row index (0 to W-1)
 for(let c=0;c<H;c++){ // c = destination col index (0 to H-1)
 const v=(M[c]&&M[c][r]!==undefined)?M[c][r]:""; // Value from source matrix at (row c, col r)

 let txX=anchor.x, txY=anchor.y, txZ=anchor.z;

 if(axis===0){ // XY: X <- c, Y <- r
 txX = anchor.x + (dir ? -c : c);
 txY = anchor.y + r;
 txZ = anchor.z;
 } else if(axis===1){ // XZ: X <- r, Z from anchor moving opposite when reversed
 txX = anchor.x + r;
 txY = anchor.y;
 txZ = dir ? (anchor.z - r) : (anchor.z + r);
 } else { // YZ: Y <- r, Z from anchor moving opposite when reversed
 txX = anchor.x;
 txY = anchor.y + r;
 txZ = dir ? (anchor.z - r) : (anchor.z + r);
 }
 
 console.log(`Writing cell [${r},${c}]: value="${v}" to (${txX},${txY},${txZ})`);
 // Write cell. Formula is only on the anchor cell itself.
 ensureAndWrite(txX,txY,txZ, v, (r===0&&c===0));
 }
 }
 
 // Record all emissions for cleanup
 if(emitted.size > 0){
 if(!S.emittedByAnchor) S.emittedByAnchor = new Map();
 S.emittedByAnchor.set(ak, emitted);
 }
 
 console.log('TRANSPOSE completed, emitted:', emitted.size, 'cells');
 if(__ownsTx) {
 console.log('Committing transaction');
 Write.commit(tx);
 }
 console.log('=== TRANSPOSE DEBUG END ===');
 }catch(e){ 
 console.error('TRANSPOSE error:', e); 
 console.log('=== TRANSPOSE DEBUG END (ERROR) ===');
 Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true); 
 }
});

/* ===========================
 Formula Parser v2.0 - Lexer/Parser/AST System
=========================== */
// Token types for the lexer
const TokenTypes = {
 ILLEGAL: 'ILLEGAL',
 EOF: 'EOF',
 NUMBER: 'NUMBER',
 STRING: 'STRING',
 IDENTIFIER: 'IDENTIFIER',
 CELL_REF: 'CELL_REF', // A1a, B2 ^1
 RANGE_REF: 'RANGE_REF', // @[0,0,0,1]
 EQUALS: '=',
 LPAREN: '(',
 RPAREN: ')',
 COMMA: ',',
 COLON: ':',
 LBRACE: '{',
 RBRACE: '}',
 SEMICOLON: ';'
};
// Lexer: converts formula text into tokens
class FormulaLexer {
 constructor(input) {
 this.input = input;
 this.position = 0;
 this.readPosition = 0;
 this.ch = '';
 this.readChar();
 }

 readChar() {
 if (this.readPosition >= this.input.length) {
 this.ch = null;
 } else {
 this.ch = this.input[this.readPosition];
 }
 this.position = this.readPosition;
 this.readPosition += 1;
 }

 peekChar() {
 if (this.readPosition >= this.input.length) {
 return null;
 }
 return this.input[this.readPosition];
 }

 nextToken() {
 this.skipWhitespace();
 let tok;

 switch (this.ch) {
 case '=': tok = { type: TokenTypes.EQUALS, value: this.ch }; break;
 case '(': tok = { type: TokenTypes.LPAREN, value: this.ch }; break;
 case ')': tok = { type: TokenTypes.RPAREN, value: this.ch }; break;
 case ',': tok = { type: TokenTypes.COMMA, value: this.ch }; break;
 case ':': tok = { type: TokenTypes.COLON, value: this.ch }; break;
 case '{': tok = { type: TokenTypes.LBRACE, value: this.ch }; break;
 case '}': tok = { type: TokenTypes.RBRACE, value: this.ch }; break;
 case ';': tok = { type: TokenTypes.SEMICOLON, value: this.ch }; break;
 case '"':
 tok = { type: TokenTypes.STRING, value: this.readString() };
 break;
 case '`':
 tok = { type: TokenTypes.STRING, value: this.readRawString('`') };
 break;
 case '<':
 if (this.peekSequence('<<<')) {
 tok = { type: TokenTypes.STRING, value: this.readHeredoc() };
 return tok;
 }
 tok = { type: TokenTypes.ILLEGAL, value: this.ch };
 break;
 case '@':
 tok = { type: TokenTypes.RANGE_REF, value: this.readRangeRef() };
 break;
 case null:
 tok = { type: TokenTypes.EOF, value: "" };
 break;
 default:
 if (this.isLetter(this.ch)) {
 const literal = this.readIdentifier();
 // After reading letters, current char holds the next symbol
 if (this.isDigit(this.ch)) {
 const number = this.readNumber();
 const greek = 'a ?de?????? ???p?st?f???';
 let greekChar = '';
 let arrayId = '';
 // Greek Z-suffix at current char
 if (this.ch && greek.includes(this.ch)) {
 const g = this.ch; this.readChar(); greekChar = g;
 }
 // Array id suffix ^n at current char
 if (this.ch === '^') {
 this.readChar();
 arrayId = '^' + this.readNumber();
 }
 tok = { type: TokenTypes.CELL_REF, value: literal + number + greekChar + arrayId };
 } else {
 tok = { type: TokenTypes.IDENTIFIER, value: literal };
 }
 return tok;
 } else if (this.isDigit(this.ch)) {
 // Support identifiers that start with a digit when followed by letters/underscore (e.g., 3D_TRANSLATE)
 const start = this.position;
 let i = this.position; let hasAlpha=false; let ch=this.input[i];
 while (ch && ((ch>='a'&&ch<='z')||(ch>='A'&&ch<='Z')||(ch>='0'&&ch<='9')||ch==='_' )){ if((ch>='a'&&ch<='z')||(ch>='A'&&ch<='Z')||ch==='_') hasAlpha=true; i++; ch=this.input[i]; }
 if(hasAlpha){
 // consume to i
 while(this.position < i) this.readChar();
 tok = { type: TokenTypes.IDENTIFIER, value: this.input.substring(start, i) };
 } else {
 tok = { type: TokenTypes.NUMBER, value: this.readNumber() };
 }
 return tok;
 } else {
 tok = { type: TokenTypes.ILLEGAL, value: this.ch };
 }
 }

 this.readChar();
 return tok;
 }

 readString() {
 // Consume characters until the matching quote, honoring backslash escapes
 let out = '';
 // Start after opening quote
 while (true) {
 this.readChar();
 if (this.ch === null) {
 break;
 }
 if (this.ch === '"') {
 // End of string token
 break;
 }
 if (this.ch === '\\') {
 const next = this.peekChar();
 if (next === null) { out += '\\'; continue; }
 this.readChar();
 switch (this.ch) {
 case 'n': out += '\n'; break;
 case 'r': out += '\r'; break;
 case 't': out += '\t'; break;
 case '"': out += '"'; break;
 case '\\': out += '\\'; break;
 default: out += this.ch; break;
 }
 continue;
 }
 out += this.ch;
 }
 return out;
 }

 readRawString(delimiter) {
 let out = '';
 while (true) {
 this.readChar();
 if (this.ch === null) break;
 if (this.ch === delimiter) break;
 out += this.ch;
 }
 return out;
 }

 readHeredoc() {
 const start = this.position + 3;
 const end = this.input.indexOf('>>>', start);
 const value = end === -1 ? this.input.slice(start) : this.input.slice(start, end);
 const after = end === -1 ? this.input.length : end + 3;
 if (after >= this.input.length) {
 this.position = this.input.length;
 this.readPosition = this.input.length;
 this.ch = null;
 } else {
 this.position = after;
 this.ch = this.input[this.position];
 this.readPosition = this.position + 1;
 }
 return value;
 }

 peekSequence(seq) {
 if (!seq || !seq.length) return false;
 return this.input.substr(this.position, seq.length) === seq;
 }

 readIdentifier() {
 const position = this.position;
 while (this.isLetter(this.ch) || this.ch === '_') {
 this.readChar();
 }
 return this.input.substring(position, this.position);
 }
 
 readNumber() {
 const position = this.position;
 while (this.isDigit(this.ch) || this.ch === '.') {
 this.readChar();
 }
 return this.input.substring(position, this.position);
 }

 readRangeRef() {
 const position = this.position;
 while (this.ch !== null && this.ch !== ']') {
 this.readChar();
 }
 if (this.ch === ']') this.readChar(); // consume ']'
 return this.input.substring(position, this.position);
 }

 isLetter(ch) {
 return ch && (('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z'));
 }

 isDigit(ch) {
 return ch && ('0' <= ch && ch <= '9');
 }
 skipWhitespace() {
 while (this.ch === ' ' || this.ch === '\t' || this.ch === '\n' || this.ch === '\r') {
 this.readChar();
 }
 }
}
// Parser: converts tokens into Abstract Syntax Tree
class FormulaParser {
 constructor(lexer, anchor) {
 this.lexer = lexer;
 this.anchor = anchor;
 this.errors = [];
 this.currentToken = null;
 this.peekToken = null;
 this.nextToken();
 this.nextToken();
 }

 nextToken() {
 this.currentToken = this.peekToken;
 this.peekToken = this.lexer.nextToken();
 }

 parseFormula() {
 if (this.currentToken.type !== TokenTypes.EQUALS) {
 return {
 type: 'Literal',
 value: this.lexer.input
 };
 }
 this.nextToken(); // consume '='
 return this.parseExpression();
 }

 parseExpression() {
 // Function call when IDENTIFIER followed by '('
 if (this.currentToken.type === TokenTypes.IDENTIFIER && this.peekToken.type === TokenTypes.LPAREN) {
 return this.parseFunctionCall();
 }
 if (this.currentToken.type === TokenTypes.IDENTIFIER && this.peekToken.type === TokenTypes.LBRACE) {
 const name = this.currentToken.value.toUpperCase();
 if (name === 'DO' || name === 'SEQ') {
 return this.parseFunctionBlockCall(name);
 }
 }
 // Otherwise parse primary (numbers, strings, refs, identifiers)
 return this.parsePrimary();
 }

 parseFunctionCall() {
 const node = {
 type: 'FunctionCall',
 name: this.currentToken.value.toUpperCase(),
 arguments: [],
 raw: this.lexer.input
 };
 this.nextToken(); // consume IDENTIFIER
 this.nextToken(); // consume '('
 // currentToken now points at first arg token or ')'
 node.arguments = this.parseArgumentList();
 // Recovery: advance until ')' if not currently on ')'
 if (this.currentToken.type !== TokenTypes.RPAREN) {
 while (this.currentToken && this.currentToken.type !== TokenTypes.RPAREN && this.currentToken.type !== TokenTypes.EOF) {
 this.nextToken();
 }
 if (this.currentToken.type !== TokenTypes.RPAREN) {
 this.errors.push(`Expected ')', got ${this.currentToken ? this.currentToken.type : 'EOF'}`);
 return null;
 }
 }
 this.nextToken(); // consume ')'
 return node;
 }

 parseFunctionBlockCall(name) {
 const node = {
 type: 'FunctionCall',
 name,
 arguments: [],
 raw: this.lexer.input,
 block: true,
 withOptions: null
 };
 this.nextToken(); // consume IDENTIFIER
 this.nextToken(); // consume '{'
 node.arguments = this.parseActionBlock();
 if (this.currentToken.type !== TokenTypes.RBRACE) {
 this.errors.push(`Expected '}', got ${this.currentToken ? this.currentToken.type : 'EOF'}`);
 } else {
 this.nextToken(); // consume '}'
 }
 if (this.currentToken && this.currentToken.type === TokenTypes.IDENTIFIER && this.currentToken.value.toUpperCase() === 'WITH') {
 this.nextToken(); // consume WITH
 node.withOptions = this.parseWithOptions();
 }
 return node;
 }

 parseActionBlock() {
 const statements = [];
 while (this.currentToken && this.currentToken.type !== TokenTypes.RBRACE && this.currentToken.type !== TokenTypes.EOF) {
 if (this.currentToken.type === TokenTypes.SEMICOLON) {
 this.nextToken();
 continue;
 }
 const stmt = this.parseExpression();
 if (stmt) statements.push(stmt);
 if (this.currentToken && this.currentToken.type === TokenTypes.SEMICOLON) {
 this.nextToken();
 }
 }
 return statements;
 }

 parseWithOptions() {
 const opts = {};
 while (this.currentToken && this.currentToken.type !== TokenTypes.EOF) {
 if (this.currentToken.type !== TokenTypes.IDENTIFIER) break;
 const key = this.currentToken.value;
 this.nextToken();
 if (this.currentToken && this.currentToken.type === TokenTypes.COLON) {
 this.nextToken();
 }
 const value = this.parseExpression();
 if (value !== undefined) opts[key] = value;
 if (this.currentToken && this.currentToken.type === TokenTypes.COMMA) {
 this.nextToken();
 continue;
 }
 break;
 }
 return opts;
 }
 parseArgumentList() {
 const args = [];
 // Handle empty argument list
 if (this.currentToken.type === TokenTypes.RPAREN) {
 return args;
 }

 while (this.currentToken && this.currentToken.type !== TokenTypes.RPAREN && this.currentToken.type !== TokenTypes.EOF) {
 const expr = this.parseExpression();
 if (expr !== undefined && expr !== null) args.push(expr);
 if (this.currentToken && this.currentToken.type === TokenTypes.COMMA) {
 this.nextToken();
 continue;
 }
 if (this.currentToken && this.currentToken.type === TokenTypes.RPAREN) break;
 // If the current token is neither comma nor RPAREN, parser will let parseExpression advance or we break for recovery
 if (this.currentToken && this.currentToken.type !== TokenTypes.COMMA) {
 break;
 }
 }
 return args;
 }

 parsePrimary() {
 switch (this.currentToken.type) {
 case TokenTypes.LPAREN:
 // Grouping: ( expr )
 this.nextToken();
 const inner = this.parseExpression();
 if (this.currentToken.type !== TokenTypes.RPAREN) {
 // Recover by advancing until ')'
 while (this.currentToken && this.currentToken.type !== TokenTypes.RPAREN && this.currentToken.type !== TokenTypes.EOF) {
 this.nextToken();
 }
 }
 if (this.currentToken.type === TokenTypes.RPAREN) this.nextToken();
 return inner;
 case TokenTypes.NUMBER:
 const num = parseFloat(this.currentToken.value);
 this.nextToken();
 return { type: 'Number', value: num };
 case TokenTypes.STRING:
 // String literals may contain embedded quotes and parentheses intended for downstream eval
 // Allow nested function-like strings e.g., "=EXEC_AT(..., \"=ssr()\")"
 const str = this.currentToken.value;
 this.nextToken();
 return { type: 'String', value: str };
 case TokenTypes.CELL_REF:
 const cellRef = this.parseCellRef(this.currentToken.value);
 this.nextToken();
 // Check for range syntax (A1:B2)
 if (this.currentToken && this.currentToken.type === TokenTypes.COLON) {
 this.nextToken(); // consume ':'
 if (this.currentToken.type === TokenTypes.CELL_REF) {
 const endRef = this.parseCellRef(this.currentToken.value);
 this.nextToken();
 return { type: 'Range', start: cellRef, end: endRef, kind: 'range' };
 }
 }
 return { type: 'CellRef', ...cellRef, kind: 'ref' };
 case TokenTypes.RANGE_REF:
 const rangeRef = this.parseRangeRef(this.currentToken.value);
 this.nextToken();
 return { type: 'RangeRef', ...rangeRef, kind: 'ref' };
 case TokenTypes.IDENTIFIER:
 // Handle nested function calls
 if (this.peekToken && this.peekToken.type === TokenTypes.LPAREN) {
 return this.parseFunctionCall();
 }
 // Check for named macros
 const name = this.currentToken.value.toUpperCase();
 const macro = Store.getState().namedMacros.get(name);
 this.nextToken();
 if (macro) {
 return { type: 'Macro', value: macro };
 }
 return { type: 'Identifier', value: name };
 default:
 this.errors.push(`Unexpected token: ${this.currentToken.type}`);
 const val = this.currentToken.value;
 this.nextToken();
 return { type: 'Literal', value: val };
 }
 }

 parseCellRef(s) {
 const t = String(s||'').trim();
 const m = /^([A-Za-z]+)(\d+)([\u03b1-\u03c9])?(?:\^(-?\d+))?$/.exec(t);
 if (!m) return null;
 let x = 0;
 const letters = m[1].toUpperCase();
 for (let i = 0; i < letters.length; i++) x = x * 26 + (letters.charCodeAt(i) - 64);
 x--;
 const y = +m[2] - 1;
 const G = 'a ?de?????? ???p?st?f???';
 const z = m[3] ? G.indexOf(m[3]) : this.anchor.z;
 const arrId = m[4] !== undefined ? (+m[4]) : this.anchor.arrId;
 return { x, y, z, arrId, raw: t };
 }

 parseRangeRef(s) {
 const cur = this.anchor || {x:0,y:0,z:0,arrId:0};
 const m = /^@\[(\-?\d+)?,(\-?\d+)?,(\-?\d+)?,(-?\d+)\]$/.exec(String(s).trim());
 if (!m) return null;
 const raw = [m[1], m[2], m[3]].map(v=> (v===undefined || v===null) ? '' : String(v));
 const toOneBased = (val, curComp)=>{
 if(val==='') return 1;
 const n=+val; if(n===0) return (curComp|0)+1; return n;
 };
 const xb = toOneBased(raw[0], cur.x);
 const yb = toOneBased(raw[1], cur.y);
 const zb = toOneBased(raw[2], cur.z);
 return { x: xb-1, y: yb-1, z: zb-1, arrId: +m[4], raw: String(s).trim() };
 }
}

const GREEK_SUFFIXES = 'a ?de?????? ???p?st?f???';

function columnLabelFromIndex(x) {
 let n = (Number.isFinite(x) ? x : 0) + 1;
 if (n <= 0) return 'A';
 let label = '';
 while (n > 0) {
 const rem = (n - 1) % 26;
 label = String.fromCharCode(65 + rem) + label;
 n = Math.floor((n - 1) / 26);
 }
 return label;
}

function stringifyCellRef(node) {
 if (!node) return '';
 if (node.raw) return node.raw;
 const col = columnLabelFromIndex(node.x ?? 0);
 const row = ((node.y ?? 0) + 1);
 const greek = (node.z !== undefined && node.z !== null && node.z >= 0) ? (GREEK_SUFFIXES[node.z] ?? '') : '';
 const arr = (node.arrId !== undefined && node.arrId !== null) ? `^${node.arrId}` : '';
 return `${col}${row}${greek}${arr}`;
}

function stringifyRangeRef(node) {
 if (!node) return '';
 if (node.raw) return node.raw;
 const x = (node.x ?? 0) + 1;
 const y = (node.y ?? 0) + 1;
 const z = (node.z ?? 0) + 1;
 const arr = node.arrId ?? 0;
 return `@[${x},${y},${z},${arr}]`;
}

function stringifyRange(node) {
 if (!node) return '';
 const start = stringifyCellRef(node.start);
 const end = stringifyCellRef(node.end);
 return `${start}:${end}`;
}

function stringifyAstExpression(node, topLevel = false) {
 if (!node) return topLevel ? '=' : '';
 switch (node.type) {
 case 'FunctionCall': {
 const args = (node.arguments || []).map(arg => stringifyAstExpression(arg, false));
 return (topLevel ? '=' : '') + `${node.name}(${args.join(', ')})`;
 }
 case 'Number': {
 const text = Number.isFinite(node.value) ? String(node.value) : '0';
 return topLevel ? `=${text}` : text;
 }
 case 'String': {
 const escaped = typeof escForStringLiteral === 'function' ? escForStringLiteral(node.value ?? '') : String(node.value ?? '').replace(/"/g, '\\"');
 const text = `"${escaped}"`;
 return topLevel ? `=${text}` : text;
 }
 case 'CellRef': {
 const ref = stringifyCellRef(node);
 return topLevel ? `=${ref}` : ref;
 }
 case 'RangeRef': {
 const ref = stringifyRangeRef(node);
 return topLevel ? `=${ref}` : ref;
 }
 case 'Range': {
 const text = stringifyRange(node);
 return topLevel ? `=${text}` : text;
 }
 case 'Identifier':
 case 'Macro': {
 const text = node.value || '';
 return topLevel ? `=${text}` : text;
 }
 case 'Literal': {
 const v = node.value;
 const text = (v === undefined || v === null) ? '""' : String(v);
 return topLevel ? `=${text}` : text;
 }
 default: {
 const text = String(node.value ?? '');
 return topLevel ? `=${text}` : text;
 }
 }
}
// Evaluator: walks AST and computes values
class FormulaEvaluator {
 constructor(formulaAPI) {
 this.formulaAPI = formulaAPI;
 }

 evaluate(node) {
 if (!node) return null;

 switch (node.type) {
 case 'Literal':
 return node.value;
 case 'Number':
 return node.value;
 case 'String':
 return node.value;
 case 'Identifier':
 return node.value;
 case 'Macro':
 // Simple macro expansion - could be enhanced
 return node.value;
 case 'CellRef':
 return this.formulaAPI.getCellValue(node);
 case 'RangeRef':
 return this.formulaAPI.getCellValue(node);
 case 'Range':
 // Expand range into cells array
 const cells = [];
 const start = node.start, end = node.end;
 const xs = [start.x, end.x].sort((a,b) => a-b);
 const ys = [start.y, end.y].sort((a,b) => a-b);
 const zs = [start.z, end.z].sort((a,b) => a-b);
 for(let z = zs[0]; z <= zs[1]; z++) {
 for(let y = ys[0]; y <= ys[1]; y++) {
 for(let x = xs[0]; x <= xs[1]; x++) {
 cells.push({x, y, z, arrId: start.arrId, kind: 'ref'});
 }
 }
 }
 return { kind: 'range', cells };
 case 'FunctionCall':
 const fn = this.formulaAPI.Fn[node.name];
 if (!fn) {
 throw new Error(`Unknown function ${node.name}`);
 }
 
 // Convert args without auto-injecting modes; functions decide internally
 let convertedArgs = node.arguments.map(arg => this.convertAstToLegacy(arg));
 const lname = String(node.name||'').toUpperCase();

 // Create compatibility bridge with old function system
 const mockAst = {
 fn: node.name,
 args: convertedArgs,
 raw: node.raw || this.formulaAPI.rawFormula
 };
 
 // Call original function implementation
 const anchor = this.formulaAPI.currentAnchor;
 const arr = this.formulaAPI.currentArray;
 const tx = this.formulaAPI.currentTx;
 
 return fn.impl(anchor, arr, mockAst, tx);
 }
 return null;
 }

 // Convert new AST nodes to legacy format for backward compatibility
 convertAstToLegacy(node) {
 switch (node.type) {
 case 'Number':
 return node.value;
 case 'String':
 return node.value;
 case 'Literal':
 return node.value;
 case 'CellRef':
 case 'RangeRef':
 return { ...node, kind: 'ref' };
 case 'Range':
 return this.evaluate(node); // Returns {kind:'range', cells:[...]}
 case 'FunctionCall':
 // For nested function calls, evaluate them
 return this.evaluate(node);
 default:
 return node.value || '';
 }
 }

 // Extract dependencies from AST
 findDependencies(node) {
 const deps = new Set();
 const aKey = ({arrId, x, y, z}) => `${arrId}:${x},${y},${z}`;

 const walk = (n) => {
 if (!n) return;

 switch (n.type) {
 case 'CellRef':
 case 'RangeRef':
 deps.add(aKey(n));
 break;
 case 'Range':
 deps.add(aKey(n.start));
 deps.add(aKey(n.end));
 break;
 case 'FunctionCall':
 n.arguments.forEach(walk);
 break;
 }
 };

 walk(node);
 return deps;
 }
}

/* ===========================
 Formula Engine (deep deps)
=========================== */
const Formula = (()=>{
 // Create evaluator instance
 const evaluator = new FormulaEvaluator({
 getCellValue: null, // Will be set below
 Fn: Fn,
 currentAnchor: null,
 currentArray: null, 
 currentTx: null,
 rawFormula: ''
 });

 // New AST-based parse function
 const parse = (text, anchor) => {
 try {
 const lexer = new FormulaLexer(text);
 const parser = new FormulaParser(lexer, anchor);
 const ast = parser.parseFormula();
 
 if (parser.errors.length > 0) {
 console.warn('Parser errors:', parser.errors);
 // Treat as literal to avoid hard failure
 return { fn: null, args: [], raw: text };
 }
 
 // Convert AST to legacy format for compatibility
 if(ast.type === 'Literal') {
 const lit = String(ast.value||'').trim();
 if(/^([A-Za-z_][A-Za-z0-9_]*)\s*\(/.test(lit)){
 // Treat bare function-looking literals as calls by auto-injecting '='
 const retry = '=' + lit;
 const lx = new FormulaLexer(retry);
 const px = new FormulaParser(lx, anchor);
 const node2 = px.parseFormula();
 if(px.errors.length===0 && node2 && node2.type==='FunctionCall'){
 let args = node2.arguments.map(arg => evaluator.convertAstToLegacy(arg));
 return { fn: node2.name, args, raw: retry };
 }
 }
 return { fn: null, args: [], raw: text };
 }
 
 if(ast.type === 'FunctionCall') {
 const fnName = ast.name;
 if((fnName === 'DO' || fnName === 'SEQ') && ast.block) {
 const blockArgs = (ast.arguments || [])
 .map(arg => stringifyAstExpression(arg, true))
 .filter(s => typeof s === 'string' && s.trim().length > 1);
 const optsRaw = {};
 if(ast.withOptions) {
 Object.entries(ast.withOptions).forEach(([k,v]) => {
 try {
 const norm = String(k || '').toLowerCase();
 optsRaw[norm] = evaluator.convertAstToLegacy(v);
 } catch(e) {
 console.warn('Failed to convert DO option', k, e);
 }
 });
 }
 return { fn: fnName, args: blockArgs, raw: text, block: true, blockOptions: optsRaw, _astArgs: ast.arguments };
 }
 if(fnName === 'PIPE') {
 const initialNode = ast.arguments && ast.arguments.length ? ast.arguments[0] : null;
 const stageNodes = ast.arguments ? ast.arguments.slice(1) : [];
 const initialExpr = initialNode ? stringifyAstExpression(initialNode, false) : '';
 const stageExprs = stageNodes.map(arg => stringifyAstExpression(arg, false)).filter(Boolean);
 return { fn: fnName, args: [], raw: text, pipeInitial: initialExpr, pipeStages: stageExprs, _pipeAstStages: stageNodes };
 }

 // Convert AST to legacy-expected args WITHOUT auto-injecting modes
 let args = ast.arguments.map(arg => evaluator.convertAstToLegacy(arg));
 const legacy = { fn: ast.name, args, raw: text };
 if(ast.block) legacy.block = true;
 if(ast.withOptions) legacy.blockOptions = ast.withOptions;
 legacy._astArgs = ast.arguments;
 return legacy;
 }
 
 // Fallback for other types
 return { fn: null, args: [], raw: text };
 } catch (e) {
 console.warn('AST parser failed, no legacy fallback:', e);
 return { fn: null, args: [], raw: text };
 }
 };
 // Enhanced dependency recording with AST support
 const recordDeps=(anchor, args, formula, ast=null)=>{
 const S=Store.getState(); const ak=aKey(anchor);
 let deps = new Set();
 
 // Use AST-based dependency extraction if available
 if(ast && evaluator) {
 try {
 deps = evaluator.findDependencies(ast);
 } catch(e) {
 console.warn('AST dependency extraction failed, using legacy:', e);
 }
 }
 
 // Fallback to legacy dependency extraction
 if(deps.size === 0) {
 const visit=a=>{ if(!a) return; if(Array.isArray(a)) return a.forEach(visit); if(a.kind==='ref') deps.add(aKey(a)); if(a.kind==='range') a.cells.forEach(c=>deps.add(aKey(c))); };
 args.forEach(visit);
 }
 
 // Track global state dependencies by parsing formula text for GET_GLOBAL calls
 const globalKeys = new Set();
 if(formula) {
 const globalMatches = formula.match(/GET_GLOBAL\s*\(\s*['"](.*?)['"]/g);
 if(globalMatches) {
 globalMatches.forEach(match => {
 const keyMatch = match.match(/GET_GLOBAL\s*\(\s*['"]([^'"]+)['"]/);
 if(keyMatch) globalKeys.add(keyMatch[1]);
 });
 }
 }
 
 // Clean up old dependencies
 const old=S.depsByAnchor.get(ak)||new Set();
 old.forEach(k=>{const s=S.anchorsByDep.get(k); if(s){s.delete(ak); if(!s.size) S.anchorsByDep.delete(k);}});
 
 // Clean up old global dependencies
 const oldGlobals = S.globalKeysByAnchor.get(ak) || new Set();
 oldGlobals.forEach(key => {
 const anchors = S.anchorsByGlobalKey.get(key);
 if(anchors) {
 anchors.delete(ak);
 if(anchors.size === 0) S.anchorsByGlobalKey.delete(key);
 }
 });
 
 // Set new cell dependencies
 S.depsByAnchor.set(ak,deps);
 deps.forEach(k=>{ if(!S.anchorsByDep.has(k)) S.anchorsByDep.set(k,new Set()); S.anchorsByDep.get(k).add(ak); });
 
 // Set new global dependencies
 S.globalKeysByAnchor.set(ak, globalKeys);
 globalKeys.forEach(key => {
 if(!S.anchorsByGlobalKey.has(key)) S.anchorsByGlobalKey.set(key, new Set());
 S.anchorsByGlobalKey.get(key).add(ak);
 });

 // Mark anchor dirty if its dependency set changed (edge change)
 try{
 const old = old || new Set(); // (defensive; old cleaned above)
 const now = deps;
 let changed = (old.size!==now.size);
 if(!changed){ for(const k of old){ if(!now.has(k)){ changed=true; break; } } }
 if(changed){
 const akStr = ak;
 // eslint-disable-next-line no-undef
 if(typeof markDirty==='function') markDirty(akStr);
 }
 }catch{}
 };

 const getCellValue=({arrId,x,y,z})=>{
 const arr=Store.getState().arrays[arrId]; if(!arr) return '';
 const key=keyChunk(...Object.values(chunkOf(x,y,z)));
 const ch=arr.chunks && arr.chunks[key]; if(!ch) return '';
 const c=ch.cells && ch.cells.find(t=>t.x===x&&t.y===y&&t.z===z); return c? (c.value ?? '') : '';
 };
 const getCell=({arrId,x,y,z})=>{
 const arr=Store.getState().arrays[arrId]; if(!arr) return {value:'',formula:null};
 const key=keyChunk(...Object.values(chunkOf(x,y,z)));
 const ch=arr.chunks && arr.chunks[key]; if(!ch) return {value:'',formula:null};
 const c=ch.cells && ch.cells.find(t=>t.x===x&&t.y===y&&t.z===z); return c||{value:'',formula:null};
 };
 const getCellNote=({arrId,x,y,z})=>{
 const c = getCell({arrId,x,y,z});
 return (c && c.meta && c.meta.noteText) ? c.meta.noteText : '';
 };
 
 // Wire up evaluator with formula API
 evaluator.formulaAPI.getCellValue = getCellValue;
 const valOf=(a)=>{ 
 if(a&&a.kind==='ref') {
 // Check if cell is protected by CANT_TARGET
 const cell = getCell(a);
 if(cell.meta && cell.meta.isTargetable === false) {
 return '!ERR:TARGET_PROTECTED';
 }
 return getCellValue(a); 
 } 
 if(a&&a.kind==='range') return a.cells.map(c=>getCellValue(c)); 
 return a; 
 };
 function setFormula(anchor,text){
 const arr=Store.getState().arrays[anchor.arrId]; if(!arr) return;
 // Normalize: auto-close missing ')' and allow bare =FN to map to =FN()
 if(text && text[0]==='='){
 const body = text.slice(1).trim();
 const m = body.match(/^([A-Za-z_][A-Za-z0-9_]*)\s*\(?\s*\)?$/);
 if(m){ text = `=${m[1]}()`; }
 else {
 // naive paren balance: if more '(' than ')', pad closers at end
 const open=(text.match(/\(/g)||[]).length, close=(text.match(/\)/g)||[]).length;
 if(open>close) text += ')'.repeat(open-close);
 }
 } else if(text && /^[A-Za-z_][A-Za-z0-9_]*\s*\(/.test(text.trim())){
 // Auto-inject '=' for function-like inputs without leading '=' (e.g., create(1,1,1))
 text = '=' + text.trim();
 }
 const ch=arr.chunks[keyChunk(...Object.values(chunkOf(anchor.x,anchor.y,anchor.z)))];
 const cell=ch.cells.find(c=>c.x===anchor.x&&c.y===anchor.y&&c.z===anchor.z);
 const prevFormula = cell ? cell.formula : null;
 if(cell) {
 // Revert previously applied 3D_ROTATE if this anchor was controlling one and not suppressed
 try{
 const ak=aKey(anchor);
 const S=Store.getState();
 let rec = (S.activeRotations||new Map()).get(ak);
 // Fallback to meta if after refresh
 if(!rec){
 const cell = Formula.getCell(anchor);
 if(cell && cell.meta && cell.meta.appliedRotate){ rec = cell.meta.appliedRotate; }
 }
 const suppressed = (S.suppress3DRotateRevert||new Set()).has(ak);
 const newFormulaStr = text || '';
 const prevFormulaStr = prevFormula || '';
 const clearing = newFormulaStr==='';
 const formulaChanged = (prevFormula!==null && newFormulaStr!==prevFormulaStr);
 if(rec && (clearing || formulaChanged) && !suppressed){
 const targ=S.arrays[rec.targetId];
 if(targ){
 const ids = rec.ids||[rec.targetId];
 // Ensure frames exist
 ids.map(id=>S.arrays[id]).filter(Boolean).forEach(a=>{ if(!a._frame) Scene.renderArray(a); });
 // Rotate back by negative steps around the same pivot at current time
 const pivotWorld = Scene.cellWorldPos(targ, rec.pivot.x, rec.pivot.y, rec.pivot.z);
 const sx = -(rec.steps.sx||0), sy=-(rec.steps.sy||0), sz=-(rec.steps.sz||0);
 ids.map(id=>S.arrays[id]).filter(Boolean).forEach(a=> Scene.rotateArrayAround(a, pivotWorld, sx, sy, sz));
 ids.map(id=>S.arrays[id]).filter(Boolean).forEach(a=>{ if(a._frame){ a.offset={ x:Math.round(a._frame.position.x), y:Math.round(a._frame.position.y), z:Math.round(a._frame.position.z) }; }});
 }
 const map=new Map(S.activeRotations); map.delete(ak); Store.setState({activeRotations:map});
 }
 if(suppressed){ const sup=new Set(S.suppress3DRotateRevert); sup.delete(ak); Store.setState({suppress3DRotateRevert:sup}); }
 }catch{}
 // Revert previously applied 3D_TRANSLATE if this anchor controlled one and is now cleared
 try{
 const ak=aKey(anchor);
 const S=Store.getState();
 let recT = (S.activeTranslations||new Map()).get(ak);
 // Fallback to meta on refresh: read persisted appliedTranslate
 if(!recT){
 const cell = Formula.getCell(anchor);
 if(cell && cell.meta && cell.meta.appliedTranslate){ recT = cell.meta.appliedTranslate; }
 }
 const suppressedT = (S.suppress3DTranslateRevert||new Set()).has(ak);
 const newFormulaStr = text || '';
 const prevFormulaStr = prevFormula || '';
 const clearing = newFormulaStr==='';
 const formulaChanged = (prevFormula!==null && newFormulaStr!==prevFormulaStr);
 if(recT && (clearing || formulaChanged) && !suppressedT){
 const stateNow = Store.getState();
 const baseEntries = Array.isArray(recT.bases) ? recT.bases : [];
 let restored=false;
 if(baseEntries.length){
 const seen=new Set();
 baseEntries.forEach(entry=>{
 if(!entry) return;
 const id = Number.isFinite(+entry.id) ? (+entry.id|0) : null;
 if(id==null || seen.has(id)) return;
 const arrTarget = stateNow.arrays?.[id];
 if(!arrTarget) return;
 const src = entry.offset || entry.base || entry;
 const base={
 x: Number.isFinite(+src?.x) ? Math.round(+src.x) : 0,
 y: Number.isFinite(+src?.y) ? Math.round(+src.y) : 0,
 z: Number.isFinite(+src?.z) ? Math.round(+src.z) : 0
 };
 setArrayOffset(arrTarget, base, {interactive:true, _skipDock:true, _skipConnections:true});
 seen.add(id);
 restored=true;
 });
 }
 if(!restored){
 const targ=stateNow.arrays?.[recT.targetId];
 if(targ){
 const base = recT.from || {x:0,y:0,z:0};
 const nx = Number.isFinite(+base.x) ? Math.round(+base.x) : 0;
 const ny = Number.isFinite(+base.y) ? Math.round(+base.y) : 0;
 const nz = Number.isFinite(+base.z) ? Math.round(+base.z) : 0;
 setArrayOffset(targ, {x:nx,y:ny,z:nz}, {interactive:true});
 restored=true;
 }
 }
 const map=new Map(S.activeTranslations); map.delete(ak); Store.setState({activeTranslations:map});
 }
 if(suppressedT){ const sup=new Set(S.suppress3DTranslateRevert); sup.delete(ak); Store.setState({suppress3DTranslateRevert:sup}); }
 }catch{}
 // Revert previously applied SCALE if this anchor controlled one
 try{
 const ak=aKey(anchor);
 const S=Store.getState();
 let recS = (S.activeScales||new Map()).get(ak);
 if(!recS){
 const cellMeta = Formula.getCell(anchor);
 if(cellMeta && cellMeta.meta && cellMeta.meta.appliedScale){ recS = cellMeta.meta.appliedScale; }
 }
 const newFormulaStr = text || '';
 const prevFormulaStr = prevFormula || '';
 const clearing = newFormulaStr==='';
 const formulaChanged = (prevFormula!==null && newFormulaStr!==prevFormulaStr);
 if(recS && (clearing || formulaChanged)){
 const stateNow = Store.getState();
 (recS.targets||[]).forEach(t=>{
 const target = stateNow.arrays?.[t.id];
 if(!target) return;
 target.params = target.params || {};
 target.params.voxelScaleLevel = t.prevLevel ?? 1;
 target.params.voxelScale = t.prevUnits ?? arrayScaleUnitsFromLevel(t.prevLevel ?? 1);
 try{ refreshArrayScale(target); }catch{}
 });
 const map=new Map(S.activeScales||new Map()); map.delete(ak); Store.setState({activeScales:map});
 }
 }catch{}
 cell.formula=text;
 // Use new AST-based dependency tracking
 try {
 const lexer = new FormulaLexer(text);
 const parser = new FormulaParser(lexer, anchor);
 const ast = parser.parseFormula();
 recordDeps(anchor, [], text, ast);
 } catch(e) {
 console.warn('AST dependency tracking failed; recording minimal deps');
 recordDeps(anchor, [], text, null);
 }
 }
 }
 function executeAt(anchor,text,tx){
 // Make tx optional - use legacy Actions.setCell if no transaction
 const useLegacy = !tx;
 if(text) setFormula(anchor,text);
 const arr=Store.getState().arrays[anchor.arrId]; if(!arr) return;
 const chKey = keyChunk(...Object.values(chunkOf(anchor.x,anchor.y,anchor.z)));
 let ch=arr.chunks[chKey];
 if(!ch){
 // Ensure the array has this chunk (e.g., expansion or first write)
 Actions.resizeArrayIfNeeded(arr, anchor);
 ch = arr.chunks[chKey];
 if(!ch) return; // still missing, abort gracefully
 }
 const cell=ch.cells.find(c=>c.x===anchor.x&&c.y===anchor.y&&c.z===anchor.z) || {value:'',formula:null};
 const src=(cell?.formula)||text||(cell?.value??'');
 warmChimeIfNeeded(src);

 // Try new AST parser first, fallback to legacy
 let ast, useAST = false, astRoot = null;
 try {
 const lexer = new FormulaLexer(src);
 const parser = new FormulaParser(lexer, anchor);
 const astNode = parser.parseFormula();
 astRoot = astNode;
 
 if(parser.errors.length === 0 && astNode) {
 // Set up evaluator context
 evaluator.formulaAPI.currentAnchor = anchor;
 evaluator.formulaAPI.currentArray = arr;
 evaluator.formulaAPI.currentTx = tx;
 evaluator.formulaAPI.rawFormula = src;
 
 // Convert to legacy format for function compatibility
 if(astNode.type === 'Literal') {
 // If the literal looks like a function call without '=', auto-inject '=' and reparse
 const lit = String(astNode.value||'').trim();
 if(/^([A-Za-z_][A-Za-z0-9_]*)\s*\(/.test(lit)){
 const retry = '=' + lit;
 const lx = new FormulaLexer(retry);
 const px = new FormulaParser(lx, anchor);
 const node2 = px.parseFormula();
 if(px.errors.length===0 && node2 && node2.type==='FunctionCall'){
 ast = { fn: node2.name, args: node2.arguments.map(arg => evaluator.convertAstToLegacy(arg)), raw: retry };
 } else {
 ast = { fn: null, args: [], raw: src };
 }
 } else {
 ast = { fn: null, args: [], raw: src };
 }
 useAST = true;
 } else if(astNode.type === 'FunctionCall') {
 // Convert AST to legacy-expected args for all functions
 ast = {
 fn: astNode.name,
 args: astNode.arguments.map(arg => evaluator.convertAstToLegacy(arg)),
 raw: src
 };
 // Preserve raw AST args for special-case handling (e.g., ARRAY call with range)
 ast._astArgs = astNode.arguments;
 useAST = true;
 } else {
 ast = { fn: null, args: [], raw: src };
 useAST = true;
 }
 }
 } catch(e) {
 console.warn('AST parsing failed, using legacy:', e);
 }
 
 // Fallback to legacy parser
 if(!useAST) {
 const errorMsg = '!ERR:PARSE';
 if(useLegacy) Actions.setCell(arr.id, anchor, errorMsg, cell?.formula||null, true);
 else Write.set(tx, arr.id, anchor, { value: errorMsg, formula: cell?.formula||src });
 return;
 }

 if(!ast.fn) { 
 // Evaluate simple expressions like =A2 or =(A2) to their scalar value
 try{
 let result = evaluator.evaluate(astRoot);
 // If a range was produced, reduce to its first cell value
 if(result && typeof result==='object' && result.kind==='range'){
 const first = result.cells && result.cells[0];
 result = first ? Formula.getCellValue(first) : '';
 }
 if(useLegacy) Actions.setCell(arr.id, anchor, result, cell?.formula||src, true);
 else Write.set(tx, arr.id, anchor, { value: result, formula: cell?.formula||src });
 }catch{
 // Fall back to literal behavior
 if(useLegacy) Actions.setCell(arr.id, anchor, src, null, true);
 else Write.set(tx, arr.id, anchor, { value: src, formula: null });
 }
 return; 
 }
 if(!isAllowed(arr, ast.fn)) { 
 const errorMsg = `!ERR:FN_DENIED ${ast.fn}`;
 if(useLegacy) Actions.setCell(arr.id, anchor, errorMsg, cell?.formula||null, true);
 else Write.set(tx, arr.id, anchor, { value: errorMsg, formula: cell?.formula||ast.raw });
 return; 
 }

 try{ 
 if(!Fn[ast.fn]) { 
 // Check for macro expansion
 const macro = Store.getState().namedMacros.get(ast.fn.toUpperCase());
 if(macro) {
 // Simple positional expansion: $1, $2 ... replaced by evaluated args
 const args = ast.args.map(a => {
 const v = valOf(a);
 return (typeof v === 'string') ? `"${v}"` : `${v}`;
 });
 const expanded = macro.replace(/\$(\d+)/g, (_,i)=> args[(+i)-1] ?? '');
 return executeAt(anchor, expanded, tx); // re-enter with expanded text and same tx
 }
 const errorMsg = `!ERR:Unknown ${ast.fn}`;
 if(useLegacy) Actions.setCell(arr.id, anchor, errorMsg, ast.raw, true);
 else Write.set(tx, arr.id, anchor, { value: errorMsg, formula: cell?.formula||ast.raw });
 return; 
 }
 // Determine if function is pure or mutating by tags
 const tags = Fn[ast.fn]?.tags || new Set();
 const isPure = tags.has('PURE');
 if(isPure){
 // Special-case: TRANSPOSE should treat ARRAY(...) with a range child as a range input
 if(ast.fn==='TRANSPOSE' && Array.isArray(ast._astArgs) && ast._astArgs.length>0){
 try{
 const firstArg = ast._astArgs[0];
 // Pattern: ARRAY(call) where child is range or cell-ref range
 const isArrayCall = firstArg && firstArg.type==='FunctionCall' && String(firstArg.name||'').toUpperCase()==='ARRAY';
 const hasRangeChild = isArrayCall && firstArg.arguments && firstArg.arguments.some(a=> a && (a.type==='Range' || a.type==='CellRef' || a.type==='RangeRef'));
 if(hasRangeChild){
 // Rebuild a legacy range arg from the child's first range-like argument
 const child = firstArg.arguments.find(a=> a && (a.type==='Range' || a.type==='CellRef' || a.type==='RangeRef'));
 let legacy;
 if(child.type==='Range'){
 // Expand to cells in legacy format
 const xs=[child.start.x,child.end.x].sort((a,b)=>a-b);
 const ys=[child.start.y,child.end.y].sort((a,b)=>a-b);
 const zs=[child.start.z,child.end.z].sort((a,b)=>a-b);
 const cells=[]; for(let z=zs[0]; z<=zs[1]; z++) for(let y=ys[0]; y<=ys[1]; y++) for(let x=xs[0]; x<=xs[1]; x++) cells.push({x,y,z,arrId:child.start.arrId,kind:'ref'});
 legacy = {kind:'range', cells};
 } else {
 legacy = { arrId: child.arrId, x:child.x, y:child.y, z:child.z, kind:'ref' };
 }
 const ast2 = { ...ast, args:[legacy, ...ast.args.slice(1)] };
 Fn[ast.fn].impl(anchor,arr,ast2,tx);
 return; // already wrote
 }
 }catch{}
 }
 // Evaluate pure function via implementation but capture returned value
 const result = Fn[ast.fn].impl(anchor,arr,ast,tx);
 // Some pure functions already write; only write when result is scalar
 if(result !== undefined){
 let adtx = tx;
 if(!adtx) adtx = Write.start('auto.pure','auto');
 Write.set(adtx, arr.id, anchor, { value: result, formula: cell?.formula||ast.raw });
 if(!tx) Write.commit(adtx);
 }
 } else {
 // Mutating/action functions use their implementation with tx
 if(!tx){ const adtx = Write.start(`auto.${ast.fn.toLowerCase()}`,'Auto-started tx'); Fn[ast.fn].impl(anchor,arr,ast,adtx); Write.commit(adtx); }
 else { Fn[ast.fn].impl(anchor,arr,ast,tx); }
 }
 }
 catch(e){ 
 const errorMsg = `!ERR:${e.message}`;
 if(useLegacy) Actions.setCell(arr.id, anchor, errorMsg, cell?.formula||null, true);
 else Write.set(tx, arr.id, anchor, { value: errorMsg, formula: cell?.formula||ast.raw });
 } finally {
 // Clean up evaluator context
 if(useAST) {
 evaluator.formulaAPI.currentAnchor = null;
 evaluator.formulaAPI.currentArray = null;
 evaluator.formulaAPI.currentTx = null;
 evaluator.formulaAPI.rawFormula = '';
 }
 }
 }

 // --- runOnceAt: execute a formula at an anchor without stamping ---
 function runOnceAt(anchor, text, tx){
 const arr = Store.getState().arrays[anchor.arrId]; if(!arr) return;
 if(text){ warmChimeIfNeeded(text); }
 const chKey = keyChunk(...Object.values(chunkOf(anchor.x,anchor.y,anchor.z)));
 let ch = arr.chunks[chKey];
 if(!ch){ Actions.resizeArrayIfNeeded(arr, anchor); ch = arr.chunks[chKey]; if(!ch) return; }
 const idx = ch.cells.findIndex(c=>c.x===anchor.x&&c.y===anchor.y&&c.z===anchor.z);
 if(idx<0){ ch.cells.push({x:anchor.x,y:anchor.y,z:anchor.z,value:'',formula:null}); }
 const cell = ch.cells.find(c=>c.x===anchor.x&&c.y===anchor.y&&c.z===anchor.z);
 const prevFormula = cell.formula;
 try{
 cell.formula = text; // temporary set
 executeAt(anchor, undefined, tx); // execute without stamping
 } finally {
 cell.formula = prevFormula; // restore
 }
 }

 function notifyCellChanged(dep){
 const depK=aKey(dep);
 // Defer to recompute engine with proper batching
 recomputeAnchors([depK]);
 }

 // Incremental SCC-based recompute with fingerprint short-circuit
 let recomputeDepth = 0; let inRecompute = false;
 const NodeMeta = { byKey:new Map(), dirtyQ:new Set() };
 function metaOf(ak){ let m=NodeMeta.byKey.get(ak); if(!m){ m={version:0,inputFP:'',dirty:false}; NodeMeta.byKey.set(ak,m);} return m; }
 function markDirty(ak){ const m=metaOf(ak); m.dirty=true; NodeMeta.dirtyQ.add(ak); }
 function bumpVersion(ak){ const m=metaOf(ak); m.version++; const users=Store.getState().anchorsByDep.get(ak)||new Set(); users.forEach(u=>markDirty(u)); }
 function fingerprintFor(ak){ const deps=Store.getState().depsByAnchor.get(ak)||new Set(); if(deps.size===0) return '0'; let s=''; deps.forEach(d=>{ s+=d+'@'+(metaOf(d).version||0)+';'; }); return s; }

 // Wrap Write.set once to bump versions on actual value change
 if(!Write.__versionWrapped){
 Write.__versionWrapped = true;
 const __set = Write.set.bind(Write);
 Write.set = function(tx, arrId, coord, next){
 const ak = `${arrId}:${coord.x},${coord.y},${coord.z}`;
 const arr = Store.getState().arrays[arrId];
 const ch = arr && arr.chunks && arr.chunks[keyChunk(...Object.values(chunkOf(coord.x,coord.y,coord.z)))];
 const prevCell = ch && ch.cells.find(c=>c.x===coord.x&&c.y===coord.y&&c.z===coord.z);
 const prevVal = prevCell ? prevCell.value : undefined;
 __set(tx, arrId, coord, next);
 const arr2 = Store.getState().arrays[arrId];
 const ch2 = arr2 && arr2.chunks && arr2.chunks[keyChunk(...Object.values(chunkOf(coord.x,coord.y,coord.z)))];
 const c2 = ch2 && ch2.cells.find(c=>c.x===coord.x&&c.y===coord.y&&c.z===coord.z);
 const newVal = c2 ? c2.value : undefined;
 if(!Object.is(prevVal, newVal)) bumpVersion(ak);
 };
 }

 function recomputeAnchors(startKeys){
 if(recomputeDepth>10){ console.warn('Recompute depth exceeded'); return; }
 recomputeDepth++;
 try{
 inRecompute = true;
 startKeys.forEach(k=> NodeMeta.dirtyQ.add(k));
 const affected = collectAffected(NodeMeta.dirtyQ);
 NodeMeta.dirtyQ.clear(); if(affected.size===0){ return; }
 const { sccs, dagOrder } = buildSCCs(affected);
 const rtx = Write.start('recompute','dependency propagation');
 for(const compId of dagOrder){
 const scc = sccs[compId];
 if(scc.length===1 && !hasSelfLoop(scc[0])){ evalNodeIfNeeded(scc[0], rtx); }
 else{ const MAX=1000; for(let i=0;i<MAX;i++){ let any=false; for(const ak of scc) any = evalNodeIfNeeded(ak, rtx) || any; if(!any) break; } }
 }
 Write.commit(rtx);
 } finally { recomputeDepth--; inRecompute=(recomputeDepth>0); }
 }

 function evalNodeIfNeeded(ak, tx){
 const m=metaOf(ak); if(!m.dirty) return false;
 const fp=fingerprintFor(ak); if(fp===m.inputFP){ m.dirty=false; return false; }
 const [arrId,rest]=ak.split(':'); const [x,y,z]=rest.split(',').map(Number);
 executeAt({arrId:+arrId,x,y,z}, undefined, tx);
 m.inputFP=fp; m.dirty=false; return true;
 }
 function hasSelfLoop(ak){ const deps=Store.getState().depsByAnchor.get(ak)||new Set(); return deps.has(ak); }
 function collectAffected(seed){
 const seen=new Set(seed); const stack=[...seed]; const usersMap=Store.getState().anchorsByDep;
 while(stack.length){ const k=stack.pop(); const users=usersMap.get(k)||new Set(); users.forEach(u=>{ if(!seen.has(u)){ seen.add(u); stack.push(u); } }); }
 return seen;
 }
 function buildSCCs(affected){
 const adj=new Map(); affected.forEach(k=> adj.set(k, []));
 const usersMap=Store.getState().anchorsByDep;
 affected.forEach(k=>{ const outs=adj.get(k); (usersMap.get(k)||new Set()).forEach(u=>{ if(affected.has(u)) outs.push(u); }); });
 const ids=new Map(), low=new Map(), onStack=new Map(), stack=[]; let time=0; const comps=[];
 function dfs(v){ ids.set(v,time); low.set(v,time); time++; stack.push(v); onStack.set(v,true);
 for(const w of adj.get(v)){ if(!ids.has(w)){ dfs(w); low.set(v, Math.min(low.get(v), low.get(w))); } else if(onStack.get(w)){ low.set(v, Math.min(low.get(v), ids.get(w))); } }
 if(low.get(v)===ids.get(v)){ const comp=[]; let w=null; do{ w=stack.pop(); onStack.set(w,false); comp.push(w); }while(w!==v); comps.push(comp); }
 }
 affected.forEach(v=>{ if(!ids.has(v)) dfs(v); });
 const compIndex=new Map(); comps.forEach((c,i)=> c.forEach(v=> compIndex.set(v,i)));
 const dagAdj=new Map(); comps.forEach((_,i)=> dagAdj.set(i,new Set()));
 affected.forEach(v=>{ const i=compIndex.get(v); for(const w of adj.get(v)){ const j=compIndex.get(w); if(i!==j) dagAdj.get(i).add(j); } });
 const indeg=new Map(); comps.forEach((_,i)=> indeg.set(i,0)); dagAdj.forEach((outs,i)=> outs.forEach(j=> indeg.set(j, indeg.get(j)+1)));
 const q=[]; indeg.forEach((d,i)=>{ if(d===0) q.push(i); }); const order=[]; while(q.length){ const i=q.shift(); order.push(i); dagAdj.get(i).forEach(j=>{ indeg.set(j, indeg.get(j)-1); if(indeg.get(j)===0) q.push(j); }); }
 return { sccs: comps, dagOrder: order };
 }
 return {parse,setFormula,executeAt,notifyCellChanged,recomputeAnchors,valOf,getCellValue,getCell,getCellNote, isRecomputing:()=>inRecompute, runOnceAt};
})();
/* ===========================
 Docking Utility
=========================== */
function dockOffsetFor(host, port='east', pad=1.0){
 const scale = arrayVoxelScale(host);
 const {x:W,y:H,z:D} = host.size;
 const halfW = (W * scale) / 2;
 const halfH = (H * scale) / 2;
 const halfD = (D * scale) / 2;
 const gap = pad * scale;
 const o = host.offset || {x:0,y:0,z:0};
 const P = String(port||'east').toLowerCase();
 const offs = (P==='north') ? {x:0, y:0, z: (halfD + gap)} :
 (P==='south') ? {x:0, y:0, z: -(halfD + gap)} :
 (P==='east') ? {x:(halfW + gap), y:0, z:0} :
 (P==='west') ? {x:-(halfW + gap), y:0, z:0} :
 (P==='top') ? {x:0, y:(halfH + gap), z:0} :
 {x:0, y:-(halfH + gap), z:0}; // bottom
 return {x:o.x+offs.x, y:o.y+offs.y, z:o.z+offs.z};
}

/* ===========================
 Function Implementations
=========================== */
// Provide a shared alias for Formula.valOf so all function impls can access it
const valOf = Formula.valOf;
// PURE BLOCK
tag('ARRAY',["ACTION","BLOCK"], (anchor,arr,ast,tx)=>{
 if(!tx) throw new Error('ARRAY requires active transaction');
 const S = Store.getState();
 const ak = aKey(anchor);

 const prevEmitted = S.emittedByAnchor.get(ak);
 if(prevEmitted) {
 prevEmitted.forEach(ck => {
 const [arrId, coords] = ck.split(':');
 const [x, y, z] = coords.split(',').map(Number);
 Write.set(tx, +arrId, {x, y, z}, { value: '', formula: null, meta: {} });
 S.sourceByCell.delete(ck);
 });
 S.emittedByAnchor.delete(ak);
 }

 const args = ast.args;
 // Accept ranges: if first arg is a range or ref, treat as list data
 if(args.length>0 && (args[0]?.kind==='range' || args[0]?.kind==='ref')){
 const src = args[0];
 // Clear previous emissions
 const prevEmitted2 = S.emittedByAnchor.get(ak);
 if(prevEmitted2){
 prevEmitted2.forEach(ck => { try{ const [arrId, coords]=ck.split(':'); const [x,y,z]=coords.split(',').map(Number); Write.set(tx, +arrId, {x,y,z}, { value:'', formula:null, meta:{} }); S.sourceByCell.delete(ck); }catch{} });
 S.emittedByAnchor.delete(ak);
 }
 const cells = src.kind==='range' ? src.cells : [src];
 // Determine bounds to emit compactly preserving relative order (row-major by y then x within each z)
 const xs=[...new Set(cells.map(c=>c.x))].sort((a,b)=>a-b);
 const ys=[...new Set(cells.map(c=>c.y))].sort((a,b)=>a-b);
 const zs=[...new Set(cells.map(c=>c.z))].sort((a,b)=>a-b);
 let wrote=false;
 for(let zi=0; zi<zs.length; zi++){
 for(let yi=0; yi<ys.length; yi++){
 for(let xi=0; xi<xs.length; xi++){
 const x=xs[xi], y=ys[yi], z=zs[zi];
 const v = Formula.getCellValue({arrId:cells[0].arrId,x,y,z});
 const dx = xi, dy = yi, dz = zi;
 const isAnchor=(dx===0&&dy===0&&dz===0);
 Write.set(tx, arr.id, {x:anchor.x+dx, y:anchor.y+dy, z:anchor.z+dz}, { value:v, formula:isAnchor?ast.raw:null, meta:{generated:true, emitter:ak} });
 wrote=true;
 }
 }
 }
 return;
 }
 const firstVal = args.length>0 ? valOf(args[0]) : undefined;
 const isModeString = typeof firstVal === 'string';
 let mode = isModeString ? String(firstVal).trim().toLowerCase() : 'list';
 let dataArgs = isModeString ? args.slice(1) : args;

 const knownModes = ['fill','set','csv','list'];
 if(isModeString && !knownModes.includes(mode) && !S.namedBlocks.has(mode.toUpperCase())){
 mode = 'list';
 dataArgs = args;
 }

 switch(mode){
 case 'fill':{
 const w=+valOf(dataArgs[0])||1, h=+valOf(dataArgs[1])||1, d=+valOf(dataArgs[2]||1)||1;
 const fillValue = (dataArgs[3]!==undefined)? valOf(dataArgs[3]) : 1;
 for(let z=0;z<d;z++) for(let y=0;y<h;y++) for(let x=0;x<w;x++){
 const coord={x:anchor.x+x, y:anchor.y+y, z:anchor.z+z};
 const isAnchor=(x===0&&y===0&&z===0);
 Write.set(tx, arr.id, coord, { value: fillValue, formula:isAnchor?ast.raw:null, meta:{generated:true, emitter:ak} });
 }
 break;
 }
 case 'csv':{
 const raw=String(valOf(dataArgs[0]||''));
 const rows=raw.split(/\r?\n/); let wroteAnchor=false, ry=0;
 for(const line of rows){
 const cols=line.split(',');
 for(let i=0;i<cols.length;i++){
 const isFirst=!wroteAnchor;
 Write.set(tx, arr.id, {x:anchor.x+i, y:anchor.y+ry, z:anchor.z}, { value: cols[i], formula:isFirst?ast.raw:null, meta:{generated:true, emitter:ak} });
 wroteAnchor=true;
 }
 ry++;
 }
 break;
 }
 case 'set':
 case 'list':
 default:{
 const named=S.namedBlocks.get(String(mode).toUpperCase());
 if(named){
 const values=named.data[0].flat();
 for(let i=0;i<values.length;i++){
 Write.set(tx, arr.id, {x:anchor.x,y:anchor.y+i,z:anchor.z}, { value:values[i], formula:i===0?ast.raw:null, meta:{generated:true, emitter:ak} });
 }
 } else {
 const values = dataArgs.map(valOf);
 for(let i=0;i<values.length;i++){
 const coord={x:anchor.x, y:anchor.y+i, z:anchor.z};
 Write.set(tx, arr.id, coord, { value: values[i], formula: i===0?ast.raw:null, meta:{generated:true, emitter:ak} });
 }
 }
 }
 }
});
tag('STORE_ARRAY',['PURE'],(anchor,arr,ast)=>{
 // Collect values then produce nested formula: =STORE_ARRAY(ARRAY("list", ...))[,"name"]
 let name='Block', data=[], size={x:1,y:1,z:1}, flat=[];
 const esc=(s)=> String(s).replace(/\\/g,'\\\\').replace(/"/g,'\\\"');
 const pushFlat=(v)=>{ flat.push((typeof v==='string')?`"${esc(v)}"`:`${v}`); };
 const arg0=ast.args[0];
 if(typeof arg0==='number'){
 const w=+valOf(ast.args[0])||1, h=+valOf(ast.args[1])||1, d=+valOf(ast.args[2])||1;
 name=ast.args[3]?String(valOf(ast.args[3])):'Block';
 size={x:w,y:h,z:d};
 for(let zz=0; zz<d; zz++) for(let yy=0; yy<h; yy++) for(let xx=0; xx<w; xx++){
 const cell=Formula.getCell({arrId:arr.id,x:anchor.x+xx,y:anchor.y-yy,z:anchor.z+zz});
 pushFlat(cell.value||'');
 }
 } else if(arg0&&arg0.kind==='range'){
 const src=arg0; name=ast.args[1]?String(valOf(ast.args[1])):'Block';
 const xs=src.cells.map(c=>c.x), ys=src.cells.map(c=>c.y), zs=src.cells.map(c=>c.z);
 const minX=Math.min(...xs), minY=Math.min(...ys), minZ=Math.min(...zs), maxX=Math.max(...xs), maxY=Math.max(...ys), maxZ=Math.max(...zs);
 size={x:maxX-minX+1,y:maxY-minY+1,z:maxZ-minZ+1};
 for(let z=minZ; z<=maxZ; z++) for(let y=minY; y<=maxY; y++) for(let x=minX; x<=maxX; x++){
 const cell=Formula.getCell({arrId:src.cells[0].arrId,x,y,z}); pushFlat(cell.value||'');
 }
 } else {
 // Inline values: =STORE_ARRAY(v1,v2,...[,"name"]) -> flatten inputs
 const raw=ast.args.slice();
 if(typeof raw[raw.length-1]==='string' || (typeof raw[raw.length-1]==='object' && raw[raw.length-1]?.kind!==undefined)){
 const last = raw[raw.length-1];
 const nm = String(valOf(last));
 if(nm) { name = nm; raw.pop(); }
 }
 const values=raw.map(valOf);
 size={x:1,y:values.length,z:1};
 values.forEach(pushFlat);
 }
 // Save to library as before
 const lib=new Map(Store.getState().namedBlocks); 
 // Rebuild data cube from flat for persistence (row-major per layer)
 data=[]; { let i=0; for(let z=0; z<size.z; z++){ const layer=[]; for(let y=0; y<size.y; y++){ const row=[]; for(let x=0; x<size.x; x++){ row.push((flat[i++]||'').toString().replace(/^"|"$/g,'')); } layer.push(row); } data.push(layer);} }
 lib.set(name.toUpperCase(),{size,data}); 
 Store.setState({namedBlocks:lib});
 // Emit nested formula string into anchor
 const nested = `=STORE_ARRAY(ARRAY(\"list\", ${flat.join(', ')}), \"${esc(name)}\")`;
 Actions.setCell(arr.id, anchor, nested, ast.raw, true);
});
// DOCK(modeOrList, list...)
// Usage:
// =DOCK("Parent", @[x,y,z,id], id2, ...)
// =DOCK(@[x,y,z,id], id2, ...) // default mode "Children" (parent mode)
// Mode "Parent": treat first as parent; moves/rotations of a parent apply to later members; a child does not affect parents.
// Mode "All": any member's transform applies to all members.
tag('DOCK',["SCENE","ACTION"], (anchor,arr,ast,tx)=>{
 const S=Store.getState();
 let mode='parent';
 let args = ast.args.slice();
 const first = Formula.valOf(args[0]);
 if(typeof first==='string'){
 const m = String(first||'').toLowerCase();
 mode = (m==='all')?'all':'parent';
 args = args.slice(1);
 }
 const toArrId = (a)=>{
 if(a && a.kind==='ref') return a.arrId;
 const v = Formula.valOf(a);
 if(typeof v==='string'){
 const p = v.match(/@\[(-?\d+),(-?\d+),(-?\d+),(-?\d+)\]/);
 if(p) return +p[4];
 const n = +v; if(!isNaN(n)) return n;
 }
 const n = +v; if(!isNaN(n)) return n;
 return null;
 };
 const members = args.map(toArrId).filter(id=> id!=null);
 if(members.length===0){ Actions.setCell(arr.id,anchor,'!ERR:DOCK:EMPTY',ast.raw,true); return; }
 const groupId = `g:${Date.now()}:${Math.random().toString(36).slice(2)}`;
 const group = {mode, members:[...new Set(members)], parentId: members[0]};
 const newGroups = new Map(S.dockGroups||new Map());
 newGroups.forEach((g,k)=>{ if(g.members.some(id=>group.members.includes(id))) newGroups.delete(k); });
 newGroups.set(groupId, group);
 const ak = aKey(anchor);
 const newByAnchor = new Map(S.dockGroupsByAnchor||new Map());
 newByAnchor.set(ak, groupId);
 Store.setState({dockGroups:newGroups, dockGroupsByAnchor:newByAnchor});
 Actions.setCell(arr.id, anchor, `Dock:${mode} ${group.members.join(',')}`, ast.raw, true);
});
// Removed TRANSPONSe alias to avoid confusion
tag('SHIFT',['PURE','BLOCK'], (anchor,arr,ast,tx)=>{
 if(!tx) throw new Error('SHIFT requires an active transaction');
 const input=ast.args[0]; const dx=+Formula.valOf(ast.args[1])|0, dy=ast.args[2]!==undefined?(+Formula.valOf(ast.args[2])|0):0, dz=ast.args[3]!==undefined?(+Formula.valOf(ast.args[3])|0):0;
 const values=(input&&input.kind==='range')?input.cells.map(c=>Formula.valOf(c)):[Formula.valOf(input)];
 values.forEach((v,i)=> {
 Write.set(tx, arr.id, {x:anchor.x+dx,y:anchor.y+dy+i,z:anchor.z+dz}, { value: v, formula: null, meta:{generated:true, emitter:aKey(anchor)} });
 });
 Write.set(tx, arr.id, anchor, { value: 'SHIFT:OK', formula: ast.raw });
});

// ROTATE(rangeOrArray, axis)
// axis: 0=XY, 1=YZ, 2=XZ. Rotates 90 around anchor on that plane.
console.log('Registering ROTATE function...');
tag('ROTATE',['PURE','BLOCK'], (anchor,arr,ast,tx)=>{
 const __ownsTx = !tx; if(__ownsTx) tx = Write.start('rotate.auto','ROTATE');
 console.log('=== ROTATE DEBUG START ===');
 console.log('ROTATE called with:', {
 anchor: `${anchor.x},${anchor.y},${anchor.z}`,
 arrayId: arr.id,
 astRaw: ast.raw,
 astFn: ast.fn,
 astArgs: ast.args,
 argCount: ast.args?.length,
 hasTx: !!tx,
 ownsTx: __ownsTx
 });
 if(ast._astArgs) console.log('Raw AST args:', ast._astArgs);
 
 // Handle AST parsing issues like TRANSPOSE
 let srcArg = ast.args[0];
 console.log('srcArg from ast.args[0]:', srcArg);
 
 // If ast.args[0] is undefined but we have _astArgs, use that instead
 if(!srcArg && ast._astArgs && ast._astArgs.length > 0) {
 srcArg = ast._astArgs[0];
 console.log('Using _astArgs[0] instead:', srcArg);
 }
 
 // Handle axis parameter from both sources
 let axisRaw = 0;
 if(ast.args && ast.args[1] !== undefined) {
 axisRaw = Formula.valOf(ast.args[1]);
 } else if(ast._astArgs && ast._astArgs[1]) {
 axisRaw = Formula.valOf(ast._astArgs[1]);
 }
 
 const axisStr = String(axisRaw||'0').toUpperCase();
 const axis = (axisStr==='XY'||axisStr==='0') ? 0 : (axisStr==='YZ'||axisStr==='1') ? 1 : (axisStr==='XZ'||axisStr==='2') ? 2 : (+axisStr|0);
 console.log('ROTATE params:', {axisRaw, axis});
 const S=Store.getState(); const ak=aKey(anchor);
 // Clear previously emitted from this anchor
 try{ const prev=S.emittedByAnchor?.get?.(ak); if(prev){ prev.forEach(ck=>{ try{ const [aid,rest]=ck.split(':'); const [cx,cy,cz]=rest.split(',').map(Number); Write.set(tx,+aid,{x:cx,y:cy,z:cz},{value:'',formula:null,meta:{}}); S.sourceByCell?.delete?.(ck);}catch{} }); S.emittedByAnchor?.delete?.(ak);} }catch{}

 // Track new emissions similar to TRANSPOSE
 const emittedKeys = new Set();
 const recordEmission = (x,y,z)=>{ const ck=`${arr.id}:${x},${y},${z}`; try{ if(!S.sourceByCell || !S.sourceByCell.set){ S.sourceByCell = new Map(S.sourceByCell||[]); } S.sourceByCell.set(ck, ak); emittedKeys.add(ck); }catch{} };
 const finalizeEmissions = ()=>{ try{ if(emittedKeys.size){ if(!S.emittedByAnchor || !S.emittedByAnchor.set){ S.emittedByAnchor = new Map(S.emittedByAnchor||[]); } S.emittedByAnchor.set(ak, emittedKeys); } }catch{} };

 const writeAt=(x,y,z,v,isAnchorWrite)=>{ 
 // If writing in front of alpha (z<0), request a front expansion by shifting all layers forward
 if(z<0){ try{ Actions.expandZFront?.(arr, -z); }catch{} }
 try{ Actions.resizeArrayIfNeeded(arr, {x,y,z}); }catch{}
 const isAnchor=(x===anchor.x&&y===anchor.y&&z===anchor.z); 
 if(!isAnchor||isAnchorWrite){ 
 Write.set(tx, arr.id, {x,y,z}, { value:v, formula:(isAnchor?ast.raw:null), meta:{generated:true, emitter:ak} }); 
 recordEmission(x,y,z);
 } 
 };
 if(srcArg && srcArg.kind==='range'){
 const cells=srcArg.cells; const xs=cells.map(c=>c.x), ys=cells.map(c=>c.y), zs=cells.map(c=>c.z);
 const minX=Math.min(...xs), maxX=Math.max(...xs), minY=Math.min(...ys), maxY=Math.max(...ys), minZ=Math.min(...zs), maxZ=Math.max(...zs);
 let first=null;
 for(let z=minZ; z<=maxZ; z++){
 for(let y=minY; y<=maxY; y++){
 for(let x=minX; x<=maxX; x++){
 const v=Formula.getCellValue({arrId:cells[0].arrId,x,y,z}); if(first===null) first=v;
 let nx=anchor.x, ny=anchor.y, nz=anchor.z;
 if(axis===0){ // XY plane: (x,y)->(y', -x') relative swap around anchor
 const dx=x-minX, dy=y-minY;
 nx = anchor.x + dy;
 ny = anchor.y + (maxX-minX - dx);
 nz = anchor.z + (z-minZ);
 } else if(axis===1){ // YZ plane: (y,z)->(z', -y')
 const dy=y-minY, dz=z-minZ;
 nx = anchor.x + (x-minX);
 ny = anchor.y + dz;
 nz = anchor.z + (maxY-minY - dy);
 } else { // XZ plane: (x,z)->(z', -x')
 const dx=x-minX, dz=z-minZ;
 nx = anchor.x + dz;
 ny = anchor.y + (y-minY);
 nz = anchor.z + (maxX-minX - dx);
 }
 writeAt(nx,ny,nz,v,false);
 }
 }
 }
 writeAt(anchor.x,anchor.y,anchor.z,(first??''),true);
 finalizeEmissions();
 if(__ownsTx) Write.commit(tx);
 return;
 }
 // Handle ARRAY() calls manually (like TRANSPOSE)
 let values = [];
 if(srcArg && (srcArg.type === 'FunctionCall' || srcArg.fn) && String(srcArg.name || srcArg.fn || '').toUpperCase()==='ARRAY'){
 try{
 console.log('Handling ARRAY() call in ROTATE, srcArg:', srcArg);
 // Handle both AST-style (srcArg.arguments) and legacy-style (srcArg.args)
 const argList = srcArg.arguments || srcArg.args || [];
 console.log('ROTATE ARRAY argList:', argList);
 values = argList.map(a=> {
 // Handle different argument formats
 if(a && typeof a === 'object' && 'value' in a) return a.value;
 if(a && typeof a === 'object' && a.type === 'Literal') return a.value;
 return Formula.valOf(a);
 });
 console.log('ROTATE ARRAY values:', values);
 }catch(e){ console.log('ROTATE ARRAY parsing failed:', e); }
 } else {
 // Fallback: rotate a 1D list along axis
 const raw=Formula.valOf(srcArg); 
 values = Array.isArray(raw)?raw.flat():[raw];
 console.log('ROTATE fallback values:', values);
 }
 
 for(let i=0;i<values.length;i++){
 let nx=anchor.x, ny=anchor.y, nz=anchor.z;
 if(axis===0){ ny = anchor.y + i; }
 else if(axis===1){ nz = anchor.z + i; }
 else { nx = anchor.x + i; }
 console.log(`ROTATE writing cell [${i}]: value="${values[i]}" to (${nx},${ny},${nz})`);
 writeAt(nx,ny,nz,values[i], i===0);
 }
 
 finalizeEmissions();
 console.log('ROTATE completed, values written:', values.length);
 if(__ownsTx) {
 console.log('ROTATE committing transaction');
 Write.commit(tx);
 }
 console.log('=== ROTATE DEBUG END ===');
});

tag('OFFSET',['PURE'], (anchor,arr,ast)=>{
 // Excel-style OFFSET: retrieve value from relative position.
 // y increases downward (top-down grid, flipped 3D Y), so +dy moves down.
 const baseRef=ast.args[0]; // reference cell or default to anchor
 const dx=+valOf(ast.args[1])|0, dy=+valOf(ast.args[2])|0, dz=+valOf(ast.args[3])|0;
 
 // Determine start position
 let startPos = {x:anchor.x, y:anchor.y, z:anchor.z, arrId:anchor.arrId};
 if(baseRef && baseRef.kind==='ref'){
 startPos = {x:baseRef.x, y:baseRef.y, z:baseRef.z, arrId:baseRef.arrId};
 } else {
 const maybe = typeof baseRef==='string' ? parseAlt(String(baseRef)) : null;
 if(maybe){ startPos = {x:maybe.x,y:maybe.y,z:maybe.z,arrId:maybe.arrId}; }
 }
 
 // Apply offsets
 const targetCoord = { x:startPos.x+dx, y:startPos.y+dy, z:startPos.z+dz, arrId:startPos.arrId };
 const value = Formula.getCellValue(targetCoord);
 return value;
});
tag('GET',['PURE'], (anchor,arr,ast)=>{
 // GET reads a ref or first of range; writes scalar to anchor.
 const ref=ast.args[0]; if(ref&&ref.kind==='ref'){ const v=valOf(ref); Actions.setCell(arr.id,anchor, v, ast.raw, true); return; }
 throw new Error('GET needs a ref');
});
tag('ADDRESS',['PURE'],(anchor,arr,ast)=>{
 const t=(ast.args[0]&&ast.args[0].kind==='ref')?ast.args[0]:anchor;
 Actions.setCell(arr.id,anchor, `${A1(t.x)}${t.y+1}${greek(t.z)}`, ast.raw,true);
});
// SELF: returns anchor's absolute ref coordinates
tag('SELF',['PURE'],(anchor,arr,ast)=>{
 // Return absolute reference string so it works as an argument (e.g., DELETE(SELF()))
 return `@[${anchor.x},${anchor.y},${anchor.z},${anchor.arrId}]`;
});
// IS_SELECTED([ref]): 1 if the provided ref (or self) is the focused cell
tag('IS_SELECTED',['PURE'],(anchor,arr,ast)=>{
 const s=Store.getState().selection; if(!s?.arrayId||!s.focus){ Actions.setCell(arr.id,anchor,0,ast.raw,true); return; }
 const t=(ast.args[0]&&ast.args[0].kind==='ref')?ast.args[0]:anchor;
 const v=(s.arrayId===t.arrId && s.focus.x===t.x && s.focus.y===t.y && s.focus.z===t.z)?1:0;
 Actions.setCell(arr.id,anchor, v, ast.raw, true);
});
tag('ALT_ADDRESS',['PURE'],(anchor,arr,ast)=>{
 const t=(ast.args[0]&&ast.args[0].kind==='ref')?ast.args[0]:anchor;
 Actions.setCell(arr.id,anchor, `@[${t.x},${t.y},${t.z},${t.arrId}]`, ast.raw,true);
});
tag('IF',['PURE'],(anchor,arr,ast)=>{
 const evalArg = (a)=> Formula.valOf(a);
 const isTruthy=(v)=>{
 if (v===null || v===undefined) return false;
 if (typeof v==='boolean') return v;
 if (Array.isArray(v)) return v.some(isTruthy);
 const n = Number(v);
 if(!Number.isNaN(n) && String(v).trim()!=='') return n!==0;
 const s = String(v).trim().toLowerCase();
 return !(s==='' || s==='false' || s==='0');
 };
 const cond = evalArg(ast.args[0]);
 const out = isTruthy(cond) ? evalArg(ast.args[1]) : (ast.args[2]!==undefined ? evalArg(ast.args[2]) : '');
 return out;
});
tag('REVERSE',['PURE'],(anchor,arr,ast)=>{

 const a=valOf(ast.args[0]); const out=Array.isArray(a)?[...a].reverse():String(a).split('').reverse().join('');
 Actions.setCell(arr.id,anchor, Array.isArray(out)?`[${out.join(',')}]`:out, ast.raw,true);
});
tag('ADD',['PURE'],(anchor,arr,ast)=>{

 const sum=(ast.args.map(valOf).flat()).reduce((a,b)=>a+(+b||0),0);
 Actions.setCell(arr.id,anchor,sum,ast.raw,true);
});
tag('MUL',['PURE'],(anchor,arr,ast)=>{

 const prod=(ast.args.map(valOf).flat()).reduce((a,b)=>a*(+b||1),1);
 Actions.setCell(arr.id,anchor,prod,ast.raw,true);
});
// LOGICALS & COMPARISONS & MATH
tag('AND',['PURE'],(anchor,arr,ast)=>{ const valOf=Formula.valOf; const v=ast.args.map(valOf).flat().every(x=>!!x)?1:0; Actions.setCell(arr.id,anchor,v,ast.raw,true); });
tag('OR',['PURE'],(anchor,arr,ast)=>{ const valOf=Formula.valOf; const v=ast.args.map(valOf).flat().some(x=>!!x)?1:0; Actions.setCell(arr.id,anchor,v,ast.raw,true); });
tag('NOT',['PURE'],(anchor,arr,ast)=>{ const valOf=Formula.valOf; const v=!valOf(ast.args[0]); Actions.setCell(arr.id,anchor,v?1:0,ast.raw,true); });
tag('EQ',['PURE'],(anchor,arr,ast)=>{ const valOf=Formula.valOf; const [a,b]=ast.args.map(valOf); Actions.setCell(arr.id,anchor,(a==b)?1:0,ast.raw,true); });
tag('NEQ',['PURE'],(anchor,arr,ast)=>{ const valOf=Formula.valOf; const [a,b]=ast.args.map(valOf); Actions.setCell(arr.id,anchor,(a!=b)?1:0,ast.raw,true); });
tag('GT',['PURE'],(anchor,arr,ast)=>{ const valOf=Formula.valOf; const [a,b]=ast.args.map(valOf).map(Number); Actions.setCell(arr.id,anchor,(a>b)?1:0,ast.raw,true); });
tag('GTE',['PURE'],(anchor,arr,ast)=>{ const valOf=Formula.valOf; const [a,b]=ast.args.map(valOf).map(Number); Actions.setCell(arr.id,anchor,(a>=b)?1:0,ast.raw,true); });
tag('LT',['PURE'],(anchor,arr,ast)=>{ const valOf=Formula.valOf; const [a,b]=ast.args.map(valOf).map(Number); Actions.setCell(arr.id,anchor,(a<b)?1:0,ast.raw,true); });
tag('LTE',['PURE'],(anchor,arr,ast)=>{ const valOf=Formula.valOf; const [a,b]=ast.args.map(valOf).map(Number); Actions.setCell(arr.id,anchor,(a<=b)?1:0,ast.raw,true); });
tag('CLAMP',['PURE'],(anchor,arr,ast)=>{ const valOf=Formula.valOf; const x=+valOf(ast.args[0])||0, mn=(+valOf(ast.args[1])||0), mx=(+valOf(ast.args[2])||0); Actions.setCell(arr.id,anchor, Math.min(mx,Math.max(mn,x)), ast.raw,true); });

const __dirMap = {
 north:{dx:0,dy:-1,dz:0}, south:{dx:0,dy:1,dz:0},
 east:{dx:1,dy:0,dz:0}, west:{dx:-1,dy:0,dz:0},
 front:{dx:0,dy:0,dz:-1}, back:{dx:0,dy:0,dz:1}
};
function __parseDirectionToken(token){
 if(token===undefined||token===null) return null;
 const str=String(token).trim();
 if(!str) return null;
 const lower=str.toLowerCase();
 if(__dirMap[lower]) return __dirMap[lower];
 switch(str.toUpperCase()){
 case 'N': case '-Y': return __dirMap.north;
 case 'S': case '+Y': case 'Y': return __dirMap.south;
 case 'E': case '+X': case 'X': return __dirMap.east;
 case 'W': case '-X': return __dirMap.west;
 case 'F': case 'FRONT': case '-Z': return __dirMap.front;
 case 'B': case 'BACK': case '+Z': case 'Z': return __dirMap.back;
 default: return null;
 }
}

tag('ADJACENT',['PURE'],(anchor,arr,ast)=>{
 const values=[];
 const dirs=[];
 const addTokens=(val)=>{
 if(val==null) return;
 if(Array.isArray(val)) return val.forEach(addTokens);
 String(val).split(/[\s,]+/).filter(Boolean).forEach(tok=>{
 const parsed=__parseDirectionToken(tok);
 if(parsed) dirs.push(parsed);
 });
 };
 if(ast.args.length){ ast.args.forEach(arg=> addTokens(Formula.valOf(arg))); }
 if(!dirs.length){ dirs.push(__dirMap.north,__dirMap.south,__dirMap.east,__dirMap.west,__dirMap.front,__dirMap.back); }
 dirs.forEach(vec=>{
 const coord={x:anchor.x+vec.dx,y:anchor.y+vec.dy,z:anchor.z+vec.dz};
 values.push(Formula.getCellValue({arrId:anchor.arrId||arr.id, ...coord}));
 });
 if(values.length===0) return '';
 return values.length===1 ? values[0] : values;
});

tag('DETECT',['PURE'],(anchor,arr,ast)=>{
 const lookup=Formula.valOf(ast.args[0]);
 const target=String(lookup??'');
 const maxRange=ast.args[1]!==undefined ? Math.max(1, Math.abs((+Formula.valOf(ast.args[1])|0))) : Math.max(arr.size?.x||1, arr.size?.y||1, arr.size?.z||1);
 const dirs=[
 {axis:'X',dx:1,dy:0,dz:0},
 {axis:'X',dx:-1,dy:0,dz:0},
 {axis:'Y',dx:0,dy:1,dz:0},
 {axis:'Y',dx:0,dy:-1,dz:0},
 {axis:'Z',dx:0,dy:0,dz:1},
 {axis:'Z',dx:0,dy:0,dz:-1}
 ];
 const bounds={x:arr.size?.x??0,y:arr.size?.y??0,z:arr.size?.z??0};
 for(const dir of dirs){
 for(let step=1; step<=maxRange; step++){
 const x=anchor.x+dir.dx*step;
 const y=anchor.y+dir.dy*step;
 const z=anchor.z+dir.dz*step;
 if(x<0||y<0||z<0||x>=bounds.x||y>=bounds.y||z>=bounds.z) break;
 const val=Formula.getCellValue({arrId:anchor.arrId||arr.id,x,y,z});
 if(String(val)===target){
 const sign=(dir.dx+dir.dy+dir.dz)>0?step:-step;
 return `${dir.axis}:${sign}`;
 }
 }
 }
 return '';
});

tag('ISNUMBER',['PURE'],(anchor,arr,ast)=>{
 const value = ast.args.length ? Formula.valOf(ast.args[0]) : '';
 let isNum=false;
 if(typeof value==='number'){ isNum=Number.isFinite(value); }
 else if(typeof value==='string'){ const trimmed=value.trim(); if(trimmed){ const num=Number(trimmed); isNum=Number.isFinite(num); } }
 else if(value!=null){ const num=Number(value); isNum=Number.isFinite(num); }
 return isNum?1:0;
});

tag('SEARCH',['PURE'],(anchor,arr,ast)=>{
 const find=String(Formula.valOf(ast.args[0]??''));
 const within=String(Formula.valOf(ast.args[1]??''));
 const startRaw=ast.args[2]!==undefined ? (+Formula.valOf(ast.args[2])|0) : 1;
 const start=Math.max(1,startRaw);
 if(start>within.length) throw new Error('SEARCH:OUT_OF_RANGE');
 const idx=within.toLowerCase().indexOf(find.toLowerCase(),start-1);
 if(idx===-1) throw new Error('SEARCH:NOT_FOUND');
 return idx+1;
});

// WRITE HELPERS
tag('SET',['ACTION'],(anchor,arr,ast,tx)=>{ 
 if(!tx) throw new Error('SET requires an active transaction');
 const target=ast.args[0]; const value=ast.args[1]; const overwrite=ast.args[2]!==undefined?!!valOf(ast.args[2]):true;
 let tref=null;
 if(target&&target.kind==='ref'){ 
 tref = {x:target.x,y:target.y,z:target.z,arrId:target.arrId};
 } else if(typeof target==='string'){
 const parsed = parseAlt(String(target));
 if(parsed) tref = {x:parsed.x,y:parsed.y,z:parsed.z,arrId:parsed.arrId};
 } else {
 const sval = valOf(target);
 if(typeof sval==='string'){
 const parsed = parseAlt(String(sval));
 if(parsed) tref = {x:parsed.x,y:parsed.y,z:parsed.z,arrId:parsed.arrId};
 }
 }
 if(tref){
 const v=valOf(value); 
 const cell=Formula.getCell({arrId:tref.arrId,x:tref.x,y:tref.y,z:tref.z});
 const isEmpty = (val) => val === '' || val === null || val === undefined;
 if(overwrite || isEmpty(cell.value)){
 Write.set(tx, tref.arrId, {x:tref.x,y:tref.y,z:tref.z}, { value: v, formula: null });
 }
 return; 
 } 
 throw new Error('SET needs target ref'); 
});
// DISPLAY_AS(displayText[, refOrSelf]) set display-only text in meta without changing value
tag('DISPLAY_AS',['ACTION'],(anchor,arr,ast)=>{
 const text = String(valOf(ast.args[0]||''));
 const t = (ast.args[1]&&ast.args[1].kind==='ref')?ast.args[1]:anchor;
 const ch=arr.chunks[keyChunk(...Object.values(chunkOf(t.x,t.y,t.z)))];
 const idx=ch?.cells.findIndex(c=>c.x===t.x&&c.y===t.y&&c.z===t.z) ?? -1;
 if(idx<0||!ch){ Actions.setCell(arr.id,anchor,'DISPLAY_AS:FAIL',ast.raw,true); return; }
 const prev=ch.cells[idx];
 ch.cells[idx] = {...prev, meta:{...(prev.meta||{}), displayText:text}};
 // trigger re-render of 2D and 3D sprites
 UI.renderSheetCell(arr, t.x, t.y, t.z);
 Scene.updateValueSprite(arr, t.x, t.y, t.z, ch.cells[idx]);
 // silent: do not stamp anchor
});
tag('BOUNCE',['ACTION'],(anchor,arr,ast,tx)=>{
 const valOf = Formula.valOf;
 const modeRaw = Math.round(Number(valOf(ast.args[0] ?? 0)) || 0);
 const bounceType = modeRaw === 1 ? 'land' : 'walk';
 const heightRaw = Number(valOf(ast.args[1] ?? 0));
 const height = Number.isFinite(heightRaw) ? Math.max(0, heightRaw) : 0;
 const targets = collectTargetCells(ast.args[2], anchor);
 const info = ensureTransaction(tx, 'scene.bounce', 'Configure bounce pads');
 const formatHeight = (value)=>{
 const num = Number(value);
 if(!Number.isFinite(num) || num <= 0) return 'OFF';
 const precision = Math.abs(num) >= 10 ? 1 : 2;
 return num.toFixed(precision).replace(/\.0+$/,'').replace(/(\.[0-9]*?)0+$/,'$1');
 };
 targets.forEach(target=>{
 mutateCellMeta(info.tx, target, meta=>{
 const next = {...meta};
 let rawConfig = next.bounceConfig ?? next.bounce ?? null;
 if(typeof rawConfig === 'string'){
 try{ rawConfig = JSON.parse(rawConfig); }catch{}
 }
 const config = {};
 if(rawConfig && typeof rawConfig === 'object'){
 if(Array.isArray(rawConfig)){
 if(Number.isFinite(+rawConfig[0])) config.walk = +rawConfig[0];
 if(Number.isFinite(+rawConfig[1])) config.land = +rawConfig[1];
 } else {
 if(Number.isFinite(+rawConfig.walk)) config.walk = +rawConfig.walk;
 if(Number.isFinite(+rawConfig.land)) config.land = +rawConfig.land;
 if(Number.isFinite(+rawConfig.onWalk)) config.walk = +rawConfig.onWalk;
 if(Number.isFinite(+rawConfig.onLand)) config.land = +rawConfig.onLand;
 }
 }
 if(height > 0){
 config[bounceType] = height;
 } else {
 delete config[bounceType];
 }
 ['walk','land'].forEach(key=>{
 const val = config[key];
 if(!Number.isFinite(val) || val <= 0){
 delete config[key];
 } else {
 config[key] = Number(val);
 }
 });
 if(Object.keys(config).length){
 next.bounceConfig = config;
 } else {
 delete next.bounceConfig;
 }
 if(next.bounce !== undefined) delete next.bounce;
 const labelParts = [];
 if(Number.isFinite(config.walk) && config.walk > 0){
 labelParts.push(`W:${formatHeight(config.walk)}`);
 }
 if(Number.isFinite(config.land) && config.land > 0){
 labelParts.push(`L:${formatHeight(config.land)}`);
 }
 if(labelParts.length){
 next.displayText = `?? ${labelParts.join(' ')}`;
 next.bounceLabel = true;
 } else if(next.bounceLabel){
 delete next.displayText;
 delete next.bounceLabel;
 }
 return next;
 });
 });
 finalizeTransaction(info);
 targets.forEach(target=>{
 try{
 const targetArr = Store.getState().arrays[target.arrId];
 if(!targetArr) return;
 if(window.UI?.renderSheetCell) window.UI.renderSheetCell(targetArr, target.x, target.y, target.z);
 const updated = Formula.getCell({arrId:target.arrId,x:target.x,y:target.y,z:target.z});
 if(updated) Scene.updateValueSprite(targetArr, target.x, target.y, target.z, updated);
 }catch{}
 });
 const summary = height > 0 ? formatHeight(height) : 'OFF';
 const suffix = targets.length > 1 ? ` ${targets.length}` : '';
 Actions.setCell(arr.id, anchor, `bounce:${bounceType}:${summary}${suffix}`, ast.raw, true);
});

function __collectMetaTargets(rangeArg, anchor, arr){
 if(rangeArg && rangeArg.kind==='range'){
 return rangeArg.cells.map(c=>({arrId:c.arrId??arr.id, x:c.x, y:c.y, z:c.z}));
 }
 if(rangeArg && rangeArg.kind==='ref'){
 return [{arrId:rangeArg.arrId??arr.id, x:rangeArg.x, y:rangeArg.y, z:rangeArg.z}];
 }
 return [{arrId:arr.id, x:anchor.x, y:anchor.y, z:anchor.z}];
}

function __applyMetaAction(cells, key, action){
 const canonicalKey = canonicalMetaKey(key);
 const tx = Write.start(`meta.${canonicalKey}`,'Meta binding');
 cells.forEach(target=>{
 const existing = Formula.getCell({arrId:target.arrId, x:target.x, y:target.y, z:target.z});
 let meta = normalizeMetaKeys(existing.meta||{});
 const aliases = META_KEY_ALIASES[canonicalKey] || [];
 if(action===null){
 delete meta[canonicalKey];
 aliases.forEach(alias=>delete meta[alias]);
 }
 else {
 meta[canonicalKey] = action;
 aliases.forEach(alias=>delete meta[alias]);
 }
 Write.set(tx, target.arrId, {x:target.x,y:target.y,z:target.z}, { value: existing.value, formula: existing.formula, meta });
 });
 Write.commit(tx);
}

tag('ON_HOLD',['META'],(anchor,arr,ast)=>{
 if(ast.args.length===1 && typeof ast.args[0]==='string'){
 const t=ast.args[0].trim().toLowerCase();
 if(['off','none','false','0'].includes(t)){
 __applyMetaAction([{arrId:arr.id,x:anchor.x,y:anchor.y,z:anchor.z}], 'on_hold', null);
 Actions.setCell(arr.id, anchor, 'on_hold:OFF', ast.raw, true);
 return;
 }
 }
 let rangeArg=null, actionArgIndex=0;
 if(ast.args.length>=2){ rangeArg=ast.args[0]; actionArgIndex=1; }
 const raw = ast.args[actionArgIndex];
 let action = (typeof raw==='string')? raw : String(Formula.valOf(raw)||'');
 if(action && action[0] !== '=') action = `=${action}`;
 const targets = __collectMetaTargets(rangeArg, anchor, arr);
 __applyMetaAction(targets, 'on_hold', action||null);
 Actions.setCell(arr.id, anchor, `on_hold:${targets.length}`, ast.raw, true);
});

tag('ON_TOUCH',['META'],(anchor,arr,ast)=>{
 if(ast.args.length===1 && typeof ast.args[0]==='string'){
 const t=ast.args[0].trim().toLowerCase();
 if(['off','none','false','0'].includes(t)){
 __applyMetaAction([{arrId:arr.id,x:anchor.x,y:anchor.y,z:anchor.z}], 'on_touch', null);
 Actions.setCell(arr.id, anchor, 'on_touch:OFF', ast.raw, true);
 return;
 }
 }
 let rangeArg=null, actionIdx=0;
 if(ast.args.length>=2){ rangeArg=ast.args[0]; actionIdx=1; }
 const raw = ast.args[actionIdx];
 let action = (typeof raw==='string')? raw : String(Formula.valOf(raw)||'');
 if(action && action[0] !== '=') action = `=${action}`;
 const targets = __collectMetaTargets(rangeArg, anchor, arr);
 __applyMetaAction(targets, 'on_touch', action||null);
 Actions.setCell(arr.id, anchor, `on_touch:${targets.length}`, ast.raw, true);
});

tag('ON_LAND',['META'],(anchor,arr,ast)=>{
 if(ast.args.length===1 && typeof ast.args[0]==='string'){
 const t=ast.args[0].trim().toLowerCase();
 if(['off','none','false','0'].includes(t)){
 __applyMetaAction([{arrId:arr.id,x:anchor.x,y:anchor.y,z:anchor.z}], 'on_land', null);
 Actions.setCell(arr.id, anchor, 'on_land:OFF', ast.raw, true);
 return;
 }
 }
 let rangeArg=null, actionIdx=0;
 if(ast.args.length>=2){ rangeArg=ast.args[0]; actionIdx=1; }
 const raw = ast.args[actionIdx];
 let action = (typeof raw==='string')? raw : String(Formula.valOf(raw)||'');
 if(action && action[0] !== '=') action = `=${action}`;
 const targets = __collectMetaTargets(rangeArg, anchor, arr);
 __applyMetaAction(targets, 'on_land', action||null);
 Actions.setCell(arr.id, anchor, `on_land:${targets.length}`, ast.raw, true);
});

const ACTION_TICK_MS = 1000/60;
function normalizeActionFormula(raw){
 let formula = String(raw==null?'':raw).trim();
 if(!formula) return '';
 if(formula.startsWith('B64:')){
 try{ formula = atob(formula.slice(4)); }catch{}
 } else {
 const colon = formula.indexOf(':');
 if(colon>0 && /^\d+$/.test(formula.slice(0,colon))){
 const enc=formula.slice(colon+1);
 try{ formula = atob(enc); }catch{}
 }
 }
 formula = String(formula||'').trim();
 if(!formula) return '';
 if(!formula.startsWith('=')) formula = `=${formula}`;
 return formula;
}

function executeActionFormula(anchor, action, label){
 const formula = normalizeActionFormula(action);
 if(!formula) return;
 warmChimeIfNeeded(formula);
 const tx = Write.start(`meta.${label||'action'}`, `${label||'action'} handler`);
 try{
 Formula.runOnceAt(anchor, formula, tx);
 Write.commit(tx);
 }catch(err){
 console.warn(`${label||'Action'} execution failed`, err);
 try{ Write.rollback(tx); }catch{}
 }
}
// ONCLICK([targetRefOrRange], actionFormulaOrBlock) bind click to execute nested action(s)
tag('ONCLICK',['ACTION'],(anchor,arr,ast)=>{
 const parseRawArgs=(raw)=>{
 if(!raw || typeof raw!=='string') return [];
 const open=raw.indexOf('(');
 const close=raw.lastIndexOf(')');
 if(open<0||close<=open) return [];
 const inner=raw.slice(open+1, close);
 const args=[];
 let current='';
 let depth=0;
 let quote=null;
 let escape=false;
 for(let i=0;i<inner.length;i++){
 const ch=inner[i];
 if(escape){ current+=ch; escape=false; continue; }
 if(quote){
 current+=ch;
 if(ch==='\\'){ escape=true; continue; }
 if(ch===quote){ quote=null; }
 continue;
 }
 if(ch==='"' || ch==="'"){ quote=ch; current+=ch; continue; }
 if(ch==='('){ depth++; current+=ch; continue; }
 if(ch===')'){
 if(depth>0){ depth--; current+=ch; continue; }
 }
 if(ch===',' && depth===0){ args.push(current.trim()); current=''; continue; }
 current+=ch;
 }
 if(current.trim().length || inner.trim().length===0){ args.push(current.trim()); }
 return args;
 };
 const normalizeActionString=(raw)=>{
 if(!raw) return '';
 let trimmed=String(raw).trim();
 if(!trimmed) return '';
 if((trimmed.startsWith('"') && trimmed.endsWith('"'))){
 try{ trimmed = JSON.parse(trimmed); }
 catch{}
 }
 trimmed = String(trimmed||'').trim();
 if(!trimmed) return '';
 if(trimmed.startsWith('=') || /^B64:/i.test(trimmed) || /^\d+:/.test(trimmed)) return trimmed;
 return `=${trimmed}`;
 };
 const resolveTargetArg=(arg)=>{
 if(!arg) return null;
 if(arg.kind==='range' || arg.kind==='ref') return arg;
 try{
 const raw = Formula.valOf(arg);
 if(raw==null) return null;
 const text = String(raw).trim();
 if(!text) return null;
 if(text.toLowerCase()==='self') return anchor;
 const parsed = parseAlt(text, anchor) || parseA1g(text, arr.id);
 if(parsed) return parsed;
 }catch{}
 return null;
 };

 const rawArgs = parseRawArgs(ast?.raw||'');
 const actionRawStr = rawArgs.length>=2 ? rawArgs[1] : (rawArgs[0]||'');
 const actionFormula = normalizeActionString(actionRawStr);
 if(!actionFormula){ return; }

 const targetArg = ast.args.length>=2 ? ast.args[0] : null;
 const resolvedTarget = resolveTargetArg(targetArg) || anchor;

 const register = (t)=>{
 const arrId = t.arrId ?? arr.id;
 const targetArr = Store.getState().arrays[arrId];
 if(!targetArr) return;
 const coord = {x:t.x, y:t.y, z:t.z};
 const chKey = keyChunk(...Object.values(chunkOf(coord.x,coord.y,coord.z)));
 const ch=targetArr.chunks[chKey];
 const idx=ch?.cells.findIndex(c=>c.x===coord.x&&c.y===coord.y&&c.z===coord.z) ?? -1;
 if(idx<0||!ch) return;
 const prev=ch.cells[idx];
 const meta = normalizeMetaKeys(prev.meta||{});
 meta.on_click = actionFormula;
 meta.onClickBusy = false;
 ch.cells[idx] = {...prev, meta};
 UI.renderSheetCell(targetArr, coord.x, coord.y, coord.z);
 try{ ch.markDirty?.(); Scene.renderArray(targetArr); }catch{}
 };

 const markClickable=(coord)=>{
 const td=document.querySelector(`td.cell[data-x="${coord.x}"][data-y="${coord.y}"][data-z="${coord.z}"]`);
 if(td) td.classList.add('clickable');
 };

 if(resolvedTarget && resolvedTarget.kind==='range'){
 const xs=resolvedTarget.cells.map(c=>c.x), ys=resolvedTarget.cells.map(c=>c.y);
 const minX=Math.min(...xs), maxY=Math.max(...ys);
 resolvedTarget.cells.forEach(c=> markClickable(c));
 register({x:minX,y:maxY,z:resolvedTarget.cells[0].z, arrId: resolvedTarget.cells[0].arrId});
 } else if(resolvedTarget && resolvedTarget.kind==='ref'){
 markClickable(resolvedTarget);
 register(resolvedTarget);
 } else {
 if(resolvedTarget && resolvedTarget!==anchor){ markClickable(resolvedTarget); }
 register({...resolvedTarget, arrId: resolvedTarget.arrId ?? arr.id});
 }
 // Silent registration
});
// TOAST(message[, duration]) show toast notification (diegetic, 2D-only)
tag('TOAST',['ACTION'],(anchor,arr,ast)=>{
 const message = String(valOf(ast.args[0]||''));
 const duration = (+valOf(ast.args[1])||3000);
 showToast(message);
 setTimeout(()=>{ const toast=document.getElementById('toast'); if(toast) toast.style.display='none'; }, duration);
 // Silent: do not stamp anchor
});
// ONCLICK_WRAPPER(actionFormulaOrBlock, targetRef?) helper to add on_click meta easily
tag('ONCLICK_WRAPPER',['ACTION'],(anchor,arr,ast)=>{
 const action = String(valOf(ast.args[0]||''));
 const target = ast.args[1] || anchor;
 const t = (target&&target.kind)? target : anchor;
 const targetArr = Store.getState().arrays[t.arrId || arr.id];
 if(!targetArr) return;
 // Attach meta.on_click and refresh cell rendering in target array
 const ch=targetArr.chunks[keyChunk(...Object.values(chunkOf(t.x,t.y,t.z)))]; if(!ch) return;
 const idx=ch.cells.findIndex(c=>c.x===t.x&&c.y===t.y&&c.z===t.z); if(idx<0) return;
 const prev=ch.cells[idx];
 const meta = normalizeMetaKeys(prev.meta||{});
 meta.on_click = action;
 ch.cells[idx] = {...prev, meta};
 const s=Store.getState().selection; const currentId = s.arrayId ?? (Store.getState().arrays[1]?1:-1);
 if(currentId === (t.arrId||arr.id) && window.UI?.renderSheetCell) window.UI.renderSheetCell(targetArr, t.x, t.y, t.z);
});
// NOTE(text[, targetRefOrRange]) add note visible only in 2D; highlights range and stores note at top-left
 tag('NOTE',['ACTION'],(anchor,arr,ast)=>{
 const noteText = String(valOf(ast.args[0]||''));
 const target = ast.args[1] || anchor;
 const applyNote = (t)=>{
 const targetArr = Store.getState().arrays[t.arrId || arr.id];
 if(!targetArr){ console.warn('NOTE: target array missing', t); return; }
 const chKey = keyChunk(...Object.values(chunkOf(t.x,t.y,t.z)));
 let ch = targetArr.chunks[chKey];
 if(!ch){
 Actions.resizeArrayIfNeeded(targetArr, t);
 ch = targetArr.chunks[chKey];
 if(!ch){ console.warn('NOTE: chunk still missing', t); return; }
 }
 let idx = ch.cells.findIndex(c=>c.x===t.x&&c.y===t.y&&c.z===t.z);
 if(idx<0){ ch.cells.push({x:t.x, y:t.y, z:t.z, value:'', formula:null, meta:{}}); idx = ch.cells.length - 1; }
 const prev = ch.cells[idx];
 ch.cells[idx] = {...prev, meta:{...(prev.meta||{}), noteText}};
 console.log('NOTE: set meta', {arrId:targetArr.id, x:t.x, y:t.y, z:t.z, meta:ch.cells[idx].meta});
 const s=Store.getState().selection; const currentId = s.arrayId ?? (Store.getState().arrays[1]?1:-1);
 if(currentId === (t.arrId||arr.id) && window.UI?.renderSheetCell) window.UI.renderSheetCell(targetArr, t.x, t.y, t.z);
 };
 if(target && target.kind==='range'){
 target.cells.forEach(c=>{
 const td=document.querySelector(`td.cell[data-x="${c.x}"][data-y="${c.y}"][data-z="${c.z}"]`);
 if(td) td.classList.add('note-hl');
 });
 const xs=target.cells.map(c=>c.x), ys=target.cells.map(c=>c.y);
 const minX=Math.min(...xs), maxY=Math.max(...ys);
 applyNote({x:minX,y:maxY,z:target.cells[0].z, arrId:target.cells[0].arrId});
 } else if(target && target.kind==='ref'){
 const td=document.querySelector(`td.cell[data-x="${target.x}"][data-y="${target.y}"][data-z="${target.z}"]`);
 if(td) td.classList.add('note-hl');
 applyNote(target);
 } else {
 applyNote({...anchor});
 }
 // Silent: do not stamp anchor
 });

// META (legacy helper) renamed to avoid overriding ACTION CREATE
tag('CREATE_META',['META'],(anchor,arr,ast)=>{
 // Defaults if omitted: 6x4x6 at origin
 const x=(ast.args[0]!==undefined)?(+valOf(ast.args[0])|0):6;
 const y=(ast.args[1]!==undefined)?(+valOf(ast.args[1])|0):4;
 const z=(ast.args[2]!==undefined)?(+valOf(ast.args[2])|0):6;
 const name=ast.args[3]!==undefined?String(valOf(ast.args[3])):'Array';
 const explicitId=ast.args[4]!==undefined?(+valOf(ast.args[4])|0):undefined;
 const newArr=Actions.createArray({size:{x,y,z},name,id:explicitId,offset:{x:0,y:0,z:0}});
 // Write a minimal confirmation; do not overwrite anchor with header text
 Actions.setCell(arr.id,anchor,`${name} #${newArr.id}`,null,true);
});
tag('NAME',['META'],(anchor,arr,ast)=>{

 if(ast.args.length===1){ arr.name=String(valOf(ast.args[0])); Scene.refreshArray?.(arr); Actions.setCell(arr.id,anchor,`Name:${arr.name}`,ast.raw,true); return; }
 // =NAME(alias, formula) - store macro
 const alias=String(valOf(ast.args[0])); const formula=String(valOf(ast.args[1]));
 Store.setState(s=>({namedMacros:new Map([...s.namedMacros,[alias,formula]])}));
 Actions.setCell(arr.id,anchor,`Macro:${alias}`,ast.raw,true);
});
tag('PARAMETERS',['META'],(anchor,arr,ast)=>{

 if(ast.args.length===1){ const j=JSON.parse(String(valOf(ast.args[0])||'{}')); arr.params={...(arr.params||{}), ...j}; Actions.setCell(arr.id,anchor,'PARAMETERS:OK',ast.raw,true); return; }
 // =PARAMETERS(formula, arg1, arg2, ...) - pre-bind args
 const formula=String(valOf(ast.args[0])); const boundArgs=ast.args.slice(1).map(valOf);
 const prebound=`${formula}(${boundArgs.map(a=>typeof a==='string'?`"${a}"`:a).join(',')})`;
 Actions.setCell(arr.id,anchor,prebound,ast.raw,true);
});
tag('FUNCTIONS',['META'],(anchor,arr,ast)=>{

 // =FUNCTIONS(mode, ...items) items can be names or tags like ":PURE"
 const mode=(String(valOf(ast.args[0])||'ALLOW_ALL')).toUpperCase();
 const pol={mode, allow:new Set(), deny:new Set(), tags:new Set()};
 const items=ast.args.slice(1).map(valOf).flat().map(String);
 items.forEach(it=>{ if(it.startsWith(':')) pol.tags.add(it.slice(1).toUpperCase()); else (mode==='ALLOW_ONLY'?pol.allow:pol.deny).add(it.toUpperCase()); });
 arr.fnPolicy=pol;
 Actions.setCell(arr.id,anchor,'FUNCTIONS:OK',ast.raw,true);
});
tag('LOCK',['META'],(anchor,arr,ast)=>{

 const state=!!valOf(ast.args[0]); if(!state){arr.locks.clear(); Actions.setCell(arr.id,anchor,'LOCK:OFF',ast.raw,true); return;}
 const add=(r)=>{ if(r.kind==='ref') arr.locks.add(aKey(r)); if(r.kind==='range') r.cells.forEach(c=>arr.locks.add(aKey(c))); };
 ast.args.slice(1).forEach(a=>{ if(a?.kind) add(a); });
 Actions.setCell(arr.id,anchor,`LOCK:${arr.locks.size}`,ast.raw,true);
});
// CA (toy)
tag('CA',['PURE'],(anchor,arr,ast)=>{
 const type=String(valOf(ast.args[0])||'life').toLowerCase();
 const steps=+valOf(ast.args[1])||1; const axis=String(valOf(ast.args[2])||'Y').toUpperCase(); const index=+valOf(ast.args[3])|0;
 if(type!=='life') throw new Error('Only life supported');
 CA.runLife2D(arr,{axis,index,steps});
 Actions.setCell(arr.id,anchor,`CA:life ${steps} ${axis}=${index}`,ast.raw,true);
});
// NAVIGATION CONTROL FUNCTIONS
tag('OCCLUDE',['SCENE'],(anchor,arr,ast)=>{
 const mode=String(valOf(ast.args[0])||'auto').toLowerCase(); // 'auto', 'array', 'cell', 'off'
 const style=String(valOf(ast.args[1])||'translucent').toLowerCase(); // 'translucent', 'solid', 'wireframe'
 const intensity=+valOf(ast.args[2])||0.4; // 0.0-1.0 opacity
 arr.occlusionMode={mode,style,intensity};
 Actions.setCell(arr.id,anchor,`Occlude:${mode}/${style}/${intensity}`,ast.raw,true);
});
tag('CAMERA_LOCK',['SCENE'],(anchor,arr,ast)=>{
 const axis=String(valOf(ast.args[0])||'').toUpperCase(); // 'X', 'Y', 'Z', or '' for free
 const angle=+valOf(ast.args[1])||0; // fixed angle in degrees
 Scene.setCameraLock(arr,{axis,angle});
 Actions.setCell(arr.id,anchor,`CameraLock:${axis||'free'}/${angle} `,ast.raw,true);
});

// GLOBAL STATE FUNCTIONS
tag('GET_GLOBAL',['PURE'],(anchor,arr,ast)=>{
 const key = String(valOf(ast.args[0]) || '');
 if(!key) throw new Error('GET_GLOBAL requires a key');
 const value = Store.getState().globalState.get(key);
 Actions.setCell(arr.id, anchor, value !== undefined ? value : '', ast.raw, true);
});

tag('SET_GLOBAL',['ACTION'],(anchor,arr,ast)=>{
 const key = String(valOf(ast.args[0]) || '');
 const value = valOf(ast.args[1]);
 if(!key) throw new Error('SET_GLOBAL requires a key');
 
 // Write to global state
 Store.getState().globalState.set(key, value);
 
 // Trigger re-computation for all dependent anchors
 const dependents = Store.getState().anchorsByGlobalKey.get(key) || new Set();
 if(dependents.size > 0) {
 Formula.recomputeAnchors([...dependents]);
 }
 
 Actions.setCell(arr.id, anchor, `Global[${key}] = ${value}`, ast.raw, true);
});

// GET_NEXT_ID(): returns the next array id (does not allocate by itself)
tag('GET_NEXT_ID',["PURE"],(anchor,arr,ast)=>{
 const S=Store.getState();
 return S.nextArrayId || 1;
});

// VALUE_AT(x,y,z, arrIdExpr): returns the value at absolute coordinates without writing
tag('VALUE_AT',["PURE"],(anchor,arr,ast)=>{
 const ax = Number(Formula.valOf(ast.args[0]));
 const ay = Number(Formula.valOf(ast.args[1]));
 const az = Number(Formula.valOf(ast.args[2]));
 const a4 = Formula.valOf(ast.args[3]);
 const arrId = Number(a4);
 if(!Number.isFinite(arrId)) return '';
 const x = (ax===0) ? (anchor?.x|0) : (Number.isFinite(ax) ? (ax-1) : (anchor?.x|0));
 const y = (ay===0) ? (anchor?.y|0) : (Number.isFinite(ay) ? (ay-1) : (anchor?.y|0));
 const z = (az===0) ? (anchor?.z|0) : (Number.isFinite(az) ? (az-1) : (anchor?.z|0));
 return Formula.getCellValue({arrId, x, y, z});
});

// --- Tiny Formula-AST helpers for FORMULIZE ---
function V(v){ return { value:v }; }
function F(name){ return { fn:String(name||'').toUpperCase(), args:[...Array.prototype.slice.call(arguments,1)] }; }
function escForStringLiteral(s){ return String(s).replace(/\\/g,'\\\\').replace(/"/g,'\\\"'); }
function astToString(node, top=true){
 if(node && Object.prototype.hasOwnProperty.call(node,'value')){
 const v=node.value;
 if(typeof v==='string') return `"${escForStringLiteral(v)}"`;
 if(v===true) return 'TRUE';
 if(v===false) return 'FALSE';
 if(v===null || v===undefined) return '""';
 if(Number.isFinite(+v)) return String(+v);
 return `"${escForStringLiteral(String(v))}"`;
 }
 if(node && node.fn){
 const args=(node.args||[]).map(n=>astToString(n,false)).join(', ');
 return (top? '=' : '') + `${node.fn}(${args})`;
 }
 return '""';
}
function remapFormulaIds(f, idMap){
 let out=String(f||'');
 idMap.forEach((newId, oldId)=>{
 const escOld = String(oldId).replace(/[.*+?^${}()|[\]\\]/g,'\\$&');
 out = out.replace(new RegExp(`\\^${escOld}\\b`,'g'), `^${newId}`);
 out = out.replace(new RegExp(`@\\[(-?\\d+),(-?\\d+),(-?\\d+),${escOld}\\]`,'g'), `@[$1,$2,$3,${newId}]`);
 });
 return out;
}

// FORMULIZE: Build a DO{ ... } program that clones reachable arrays
tag('FORMULIZE',["ACTION"],(anchor,arr,ast)=>{
 try{
 const S=Store.getState();

 const resolveRef=(arg)=>{
 if(!arg) return null;
 if(arg.kind==='ref') return arg;
 if(arg.kind==='range' && Array.isArray(arg.cells) && arg.cells.length) return arg.cells[0];
 try{
 const raw = Formula.valOf(arg);
 if(raw && typeof raw==='string'){
 const parsed = parseAlt(raw, anchor) || parseA1g(raw, arr.id);
 if(parsed) return parsed;
 const n = +raw; if(Number.isFinite(n)) return {arrId:n,x:0,y:0,z:0};
 } else {
 const n = +raw; if(Number.isFinite(n)) return {arrId:n,x:0,y:0,z:0};
 }
 }catch{}
 return null;
 };

 const startRef = resolveRef(ast.args?.[0]) || anchor;
 const startId = startRef.arrId ?? arr.id;
 if(!Number.isInteger(startId) || startId<=0 || !S.arrays[startId]){
 Actions.setCell(arr.id, anchor, '!ERR:TARGET', ast.raw, true);
 return;
 }

 const seen=new Set([startId]);
 const queue=[startId];
 const refRe = /@\[(-?\d+),(-?\d+),(-?\d+),(-?\d+)\]/g;
 const caretRe = /\^(\-?\d+)\b/g;
 while(queue.length){
 const aid=queue.shift();
 const A=S.arrays[aid];
 if(!A) continue;
 Object.values(A.chunks||{}).forEach(ch=>{
 (ch.cells||[]).forEach(cell=>{
 const text=cell.formula||'';
 let m;
 while((m=refRe.exec(text))){ const id=+m[4]; if(Number.isInteger(id) && id>0 && !seen.has(id) && S.arrays[id]){ seen.add(id); queue.push(id);} }
 while((m=caretRe.exec(text))){ const id=+m[1]; if(Number.isInteger(id) && id>0 && !seen.has(id) && S.arrays[id]){ seen.add(id); queue.push(id);} }
 });
 });
 }

 const ids=[...seen].filter(id=>Number.isInteger(id) && id>0 && S.arrays[id]).sort((a,b)=>a-b);
 if(ids.length===0){
 Actions.setCell(arr.id, anchor, '!ERR:FORMULIZE_EMPTY', ast.raw, true);
 return;
 }

 const usedIds=new Set(Object.values(S.arrays).map(a=>a.id).filter(id=>Number.isInteger(id)));
 let nextId=Math.max(1, S.nextArrayId || 1);
 const allocateId=()=>{
 while(nextId<=0 || usedIds.has(nextId)) nextId++;
 const assigned=nextId;
 usedIds.add(assigned);
 nextId++;
 return assigned;
 };

 const idMap=new Map();
 ids.forEach(oldId=>{ idMap.set(oldId, allocateId()); });

 const commands=[];

 ids.forEach(oldId=>{
 const A=S.arrays[oldId]; if(!A) return;
 const newId=idMap.get(oldId);
 commands.push( F('CREATE', V(A.size.x), V(A.size.y), V(A.size.z), V(A.name||'Array'), V(newId)) );
 });

 const valueFillAst=(val)=>{
 if(val && typeof val==='object' && !Array.isArray(val)){
 try{ return V(JSON.stringify(val)); }
 catch(_){ return V(String(val)); }
 }
 return V(val);
 };

 ids.forEach(oldId=>{
 const A=S.arrays[oldId]; if(!A) return;
 const newId=idMap.get(oldId);
 const W=A.size.x, H=A.size.y, D=A.size.z;
 const occ=new Map();
 Object.values(A.chunks||{}).forEach(ch=>{
 (ch.cells||[]).forEach(c=>{ occ.set(`${c.x},${c.y},${c.z}`, {v:c.value, f:c.formula}); });
 });
 const visited=new Set();
 const key=(x,y,z)=>`${x},${y},${z}`;
 const inBounds=(x,y,z)=> x>=0&&y>=0&&z>=0&&x<W&&y<H&&z<D;

 const emitFill=(x1,y1,z1,x2,y2,z2,val)=>{
 const fillAst = F('ARRAY', V('fill'), V(x2-x1+1), V(y2-y1+1), V(z2-z1+1), valueFillAst(val));
 const fillText = astToString(fillAst);
 commands.push( F('EXEC_AT', V(x1), V(y1), V(z1), V(newId), V(fillText)) );
 };

 for(let z=0; z<D; z++){
 for(let y=0; y<H; y++){
 for(let x=0; x<W; x++){
 const k=key(x,y,z);
 if(visited.has(k)) continue;
 const cell=occ.get(k)||{v:'',f:null};
 if(cell.f || cell.v==='' || cell.v===null || cell.v===undefined){ continue; }
 let x2=x;
 while(inBounds(x2+1,y,z)){
 const c=occ.get(key(x2+1,y,z))||{v:'',f:null};
 if(visited.has(key(x2+1,y,z)) || c.f || c.v!==cell.v) break;
 x2++;
 }
 let y2=y;
 outerY: while(inBounds(x,y2+1,z)){
 for(let xi=x; xi<=x2; xi++){
 const c=occ.get(key(xi,y2+1,z))||{v:'',f:null};
 if(visited.has(key(xi,y2+1,z)) || c.f || c.v!==cell.v){ break outerY; }
 }
 y2++;
 }
 let z2=z;
 outerZ: while(inBounds(x,y,z2+1)){
 for(let yi=y; yi<=y2; yi++){
 for(let xi=x; xi<=x2; xi++){
 const c=occ.get(key(xi,yi,z2+1))||{v:'',f:null};
 if(visited.has(key(xi,yi,z2+1)) || c.f || c.v!==cell.v){ break outerZ; }
 }
 }
 z2++;
 }
 for(let zz=z; zz<=z2; zz++) for(let yy=y; yy<=y2; yy++) for(let xx=x; xx<=x2; xx++) visited.add(key(xx,yy,zz));
 emitFill(x,y,z,x2,y2,z2,cell.v);
 }
 }
 }
 });

 ids.forEach(oldId=>{
 const A=S.arrays[oldId]; if(!A) return;
 const newId=idMap.get(oldId);
 Object.values(A.chunks||{}).forEach(ch=>{
 (ch.cells||[]).forEach(c=>{
 if(!c.formula) return;
 const remapped = remapFormulaIds(c.formula, idMap);
 const formulaText = remapped.startsWith('=') ? remapped : `=${remapped}`;
 commands.push( F('EXEC_AT', V(c.x), V(c.y), V(c.z), V(newId), V(formulaText)) );
 });
 });
 });

 ids.forEach(oldId=>{
 const A=S.arrays[oldId]; if(!A) return;
 const newId=idMap.get(oldId);
 Object.values(A.chunks||{}).forEach(ch=>{
 (ch.cells||[]).forEach(c=>{
 const color = c?.meta?.color;
 if(!color) return;
 const colorText = astToString( F('COLOR', V(String(color))) );
 commands.push( F('EXEC_AT', V(c.x), V(c.y), V(c.z), V(newId), V(colorText)) );
 });
 });
 });

 ids.forEach(oldId=>{
 const A=S.arrays[oldId]; if(!A) return;
 const newId=idMap.get(oldId);
 const off=A.offset||{x:0,y:0,z:0};
 commands.push( F('SET_ARRAY_POS', V(newId), V(Math.round(off.x||0)), V(Math.round(off.y||0)), V(Math.round(off.z||0))) );
 });

 commands.push( F('SET', F('SELF'), V('')) );

 const statements = commands.map(cmd=>{
 const text = astToString(cmd, true);
 return text.startsWith('=') ? text.slice(1) : text;
 });
 const body = statements.length ? ` ${statements.join(';\n ')};\n` : '';
 const out = `=DO{\n${body}} WITH atomic:1`;
 Actions.setCell(arr.id, anchor, out, ast.raw, true);
 }catch(e){
 Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true);
 }
});

function __cloneEmbeddedMap(existing){
 if(existing instanceof Map) return new Map(existing);
 if(!existing) return new Map();
 try{ return new Map(existing); }
 catch(_){ try{ return new Map(Object.entries(existing)); }catch(__){ return new Map(); } }
}

function __getEmbeddedRecord(key){
 const existing = Store.getState().embeddedMeshes;
 if(existing instanceof Map) return existing.get(key) || null;
 if(!existing) return null;
 try{ return new Map(existing).get(key) || null; }
 catch(_){ try{ return new Map(Object.entries(existing)).get(key) || null; }catch(__){ return null; } }
}

function __setEmbeddedRecord(key, record){
 Store.setState(s=>{
 const map = __cloneEmbeddedMap(s.embeddedMeshes);
 if(record){ map.set(key, record); }
 else { map.delete(key); }
 return { embeddedMeshes: map };
 });
}

function __disposeEmbeddedRecord(record){
 if(!record) return;
 try{
 const mesh = record.mesh;
 if(mesh){
 mesh.parent?.remove(mesh);
 mesh.traverse?.(node=>{
 if(node.isMesh){
 node.geometry?.dispose?.();
 node.material?.dispose?.();
 }
 });
 }
 }catch{}
}

tag('EMBED',['ACTION'],(anchor,arr,ast)=>{
 const sourceArg = ast.args[0];
 if(!sourceArg){ Actions.setCell(arr.id, anchor, '!ERR:EMBED:NO_SOURCE', ast.raw, true); return; }
 const nickname = ast.args[1]!==undefined ? String(Formula.valOf(ast.args[1])||'') : '';
 const state = Store.getState();
 let targetArr=null;
 if(sourceArg && sourceArg.kind==='ref'){
 targetArr = state.arrays[sourceArg.arrId];
 } else if(sourceArg && sourceArg.kind==='range'){
 const first = sourceArg.cells && sourceArg.cells[0];
 if(first) targetArr = state.arrays[first.arrId];
 } else {
 const raw = Formula.valOf(sourceArg);
 if(typeof raw==='string'){
 const parsed = parseAlt(raw) || parseA1g(raw, arr.id);
 if(parsed) targetArr = state.arrays[parsed.arrId];
 if(!targetArr){
 const id = +raw; if(Number.isFinite(id)) targetArr = state.arrays[id];
 }
 } else {
 const id = +raw; if(Number.isFinite(id)) targetArr = state.arrays[id];
 }
 }
 if(!targetArr){ Actions.setCell(arr.id, anchor, '!ERR:EMBED:NOT_FOUND', ast.raw, true); return; }
 try{
 const scene = Scene.getScene?.();
 if(!scene){ Actions.setCell(arr.id, anchor, '!ERR:EMBED:NO_SCENE', ast.raw, true); return; }
 const snapshot = Scene.createArraySnapshot?.(targetArr);
 if(!snapshot){ Actions.setCell(arr.id, anchor, '!ERR:EMBED:EMPTY', ast.raw, true); return; }
 snapshot.scale.setScalar(0.28);
 const anchorRef = {arrId:arr.id, x:anchor.x, y:anchor.y, z:anchor.z};
 const key = aKey(anchorRef);
 const prior = __getEmbeddedRecord(key);
 if(prior) __disposeEmbeddedRecord(prior);

 const parentFrame = arr._frame;
 if(parentFrame){
 const local = Scene.localPos?.(arr, anchor.x, anchor.y, anchor.z) || new THREE.Vector3();
 snapshot.position.copy(local);
 snapshot.position.y += 0.6;
 parentFrame.add(snapshot);
 } else {
 const pos = Scene.cellWorldPos(arr, anchor.x, anchor.y, anchor.z);
 snapshot.position.copy(pos);
 snapshot.position.y += 0.6;
 scene.add(snapshot);
 }
 snapshot.name = `Embed:${targetArr.id}`;
 snapshot.userData = {...(snapshot.userData||{}), embedFor:key, sourceArrId:targetArr.id};

 __setEmbeddedRecord(key, {
 mesh: snapshot,
 sourceArrId: targetArr.id,
 hostArrId: arr.id,
 anchor: {x:anchor.x, y:anchor.y, z:anchor.z},
 name: nickname||'',
 createdAt: Date.now()
 });

 const label = nickname || `Embed:${targetArr.id}`;
 Actions.setCell(arr.id, anchor, label, ast.raw, true);
 }catch(e){ Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true); }
});

tag('UNPACK',['ACTION'],(anchor,arr,ast)=>{
 const refArg = ast.args[0];
 let target = null;
 if(refArg && refArg.kind==='ref'){ target = {arrId:refArg.arrId,x:refArg.x,y:refArg.y,z:refArg.z}; }
 else if(typeof refArg==='string'){ const parsed = parseAlt(refArg)||parseA1g(refArg,arr.id); if(parsed) target=parsed; }
 else if(refArg!==undefined){
 const parsed = parseAlt(String(Formula.valOf(refArg)||'')) || null;
 if(parsed) target=parsed;
 }
 const anchorRef = target ? target : {arrId:arr.id, x:anchor.x, y:anchor.y, z:anchor.z};
 const key = aKey(anchorRef);
 const rec = __getEmbeddedRecord(key);
 if(!rec){ Actions.setCell(arr.id, anchor, '!ERR:UNPACK:NOT_FOUND', ast.raw, true); return; }
 const sourceArr = Store.getState().arrays[rec.sourceArrId];
 if(!sourceArr){
 __disposeEmbeddedRecord(rec);
 __setEmbeddedRecord(key, null);
 Actions.setCell(arr.id, anchor, '!ERR:UNPACK:NO_SOURCE', ast.raw, true);
 return;
 }
 try{
 const baseName = rec.name || sourceArr.name || `Embed ${sourceArr.id}`;
 const cloneName = `${baseName} Copy`;
 const newArr = Actions.createArray({ name: cloneName, size:{...sourceArr.size} });
 const tx = Write.start('embed.unpack','UNPACK build');
 try{
 Object.values(sourceArr.chunks||{}).forEach(ch=>{
 (ch.cells||[]).forEach(cell=>{
 Write.set(tx, newArr.id, {x:cell.x,y:cell.y,z:cell.z}, {
 value: cell.value,
 formula: cell.formula,
 meta: cell.meta ? {...cell.meta} : undefined
 });
 });
 });
 Write.commit(tx);
 }catch(err){
 try{ Write.rollback(tx); }catch{}
 throw err;
 }

 __disposeEmbeddedRecord(rec);
 __setEmbeddedRecord(key, null);

 try{
 const hostArr = Store.getState().arrays[rec.hostArrId] || arr;
 const pad = Math.max(1.5, Math.ceil(Math.max(newArr.size.x||1, newArr.size.z||1)/2));
 const offset = hostArr ? Scene.dockOffsetFor?.(hostArr, 'east', pad) : null;
 if(offset) Scene.setArrayOffset?.(newArr, offset);
 }catch{}

 Actions.setSelection(newArr.id, {x:0,y:0,z:0});
 Actions.setCell(arr.id, anchor, `Unpack:${newArr.id}`, ast.raw, true);
 }catch(e){
 Actions.setCell(arr.id, anchor, `!ERR:UNPACK:${e.message}`, ast.raw, true);
 }
});

tag('ENTER',['ACTION'],(anchor,arr,ast)=>{
 const refArg = ast.args[0];
 let target = null;
 if(refArg && refArg.kind==='ref'){ target = {arrId:refArg.arrId,x:refArg.x,y:refArg.y,z:refArg.z}; }
 else if(typeof refArg==='string'){ const parsed = parseAlt(refArg)||parseA1g(refArg,arr.id); if(parsed) target=parsed; }
 else if(refArg!==undefined){
 const parsed = parseAlt(String(Formula.valOf(refArg)||'')) || null;
 if(parsed) target=parsed;
 }
 const anchorRef = target ? target : {arrId:arr.id, x:anchor.x, y:anchor.y, z:anchor.z};
 const key = aKey(anchorRef);
 const rec = __getEmbeddedRecord(key);
 if(rec && Store.getState().arrays[rec.sourceArrId]){
 const targetArr = Store.getState().arrays[rec.sourceArrId];
 Actions.setSelection(rec.sourceArrId, {x:0,y:0,z:0});
 try{ Scene.centerOnArray?.(targetArr); }catch{}
 try{ Store.setState(s=>({ worldState:{ ...(s.worldState||{}), parentArr: arr.id, childArr: rec.sourceArrId } })); }catch{}
 Actions.setCell(arr.id, anchor, `Enter:${targetArr.name||rec.sourceArrId}`, ast.raw, true);
 } else {
 if(rec){ __disposeEmbeddedRecord(rec); __setEmbeddedRecord(key, null); }
 Actions.setCell(arr.id, anchor, '!ERR:ENTER:NOT_FOUND', ast.raw, true);
 }
});
// COMBINE(0|1): toggle global gobbling interactions
tag('COMBINE',["ACTION","META"],(anchor,arr,ast)=>{
 const enable = !!Formula.valOf(ast.args[0]);
 const S=Store.getState();
 Store.setState(s=>({ interactions:{ ...(s.interactions||{}), gobblingEnabled: enable } }));
 Actions.setCell(arr.id, anchor, `Combine Mode: ${enable?'ON':'OFF'}`, ast.raw, true);
});

// Import handler for CSV/TSV/XLSX (using SheetJS)
async function handleImportedData(data, fileName = 'PastedData'){
 try{
 const S = Store.getState();
 let workbook;
 if (typeof data === 'string') {
 workbook = XLSX.read(data, { type: 'string' });
 } else {
 workbook = XLSX.read(data, { type: 'array' });
 }
 const sheetNames = workbook.SheetNames||[]; if(sheetNames.length===0){ showToast('Import failed: No sheets'); return; }
 const sheets = sheetNames.map(name=> XLSX.utils.sheet_to_json(workbook.Sheets[name], { header:1, defval:'' }));
 let maxX=0,maxY=0; const maxZ=sheets.length;
 sheets.forEach(sh=>{ maxY=Math.max(maxY, sh.length); sh.forEach(r=>{ maxX=Math.max(maxX, r.length); }); });
 if(maxX===0||maxY===0){ showToast('Import failed: Empty'); return; }
 const baseName = String(fileName||'Data').split('.')[0].replace(/_/g,' ');
 const dataArray = Actions.createArray({ name: baseName, size:{x:maxX,y:maxY,z:maxZ} });
 const labelArray = Actions.createArray({ name: `${baseName} Labels`, size:{x:1,y:1,z:maxZ} });
 const tx = Write.start('importer.create', `Import ${fileName}`);
 sheets.forEach((sheetData, z)=>{
 Write.set(tx, labelArray.id, {x:0,y:0,z}, { value: sheetNames[z], formula:null });
 sheetData.forEach((row,y)=>{
 row.forEach((val,x)=>{
 if(val!=='' && val!=null){ Write.set(tx, dataArray.id, {x,y,z}, { value:String(val), formula:null }); }
 });
 });
 });
 Write.commit(tx);
 // Position near host
 const host = (typeof UI!=='undefined' && UI.currentArray) ? UI.currentArray() : Object.values(Store.getState().arrays)[0];
 try{
 const pos = dockOffsetFor(host||dataArray,'east',2.0);
 Scene.setArrayOffset(dataArray,pos);
 const labelPos = dockOffsetFor(dataArray,'top',1.0);
 Scene.setArrayOffset(labelArray,labelPos);
 }catch{}
 Actions.setSelection(dataArray.id,{x:0,y:0,z:0},null,'3d');
 Scene.centerOnArray?.(dataArray);
 showToast(`Imported ${sheetNames.length} sheet(s)`);
 }catch(e){ console.error('Import Error', e); showToast(`Import failed: ${e.message}`); }
}

// COLOR(hexColor, [targetRefOrRange]) - sets the background color of cells.
tag('COLOR',["ACTION"], (anchor, arr, ast, tx) => {
 if (!tx) throw new Error('COLOR requires an active transaction');
 const colorValRaw = Formula.valOf(ast.args[0] || '#ffffff');
 const colorVal = String(colorValRaw==null?'#ffffff':colorValRaw).trim();
 if (!/^#[0-9a-fA-F]{6}$/.test(colorVal)) {
 Actions.setCell(arr.id, anchor, '!ERR:COLOR_FORMAT', ast.raw, true);
 return;
 }

 const targetArg = ast.args[1] || anchor;
 const targets = [];
 if (targetArg && targetArg.kind === 'range') {
 targets.push(...targetArg.cells);
 } else if (targetArg && targetArg.kind === 'ref') {
 targets.push(targetArg);
 } else {
 targets.push(anchor);
 }

 targets.forEach(t => {
 const cell = Formula.getCell(t);
 Write.set(tx, t.arrId, { x: t.x, y: t.y, z: t.z }, {
 value: cell.value,
 formula: (t.arrId===anchor.arrId && t.x === anchor.x && t.y === anchor.y && t.z === anchor.z) ? (cell.formula ?? ast.raw) : cell.formula,
 meta: { ...(cell.meta||{}), color: colorVal }
 });
 });
 // Silent: no stamp
});

// GETCOLOR([targetRef]) - returns the hex color of a cell.
tag('GETCOLOR',["PURE"], (anchor, arr, ast) => {
 const target = (ast.args[0] && ast.args[0].kind === 'ref') ? ast.args[0] : anchor;
 const cell = Formula.getCell(target);
 return (cell && cell.meta && cell.meta.color) ? cell.meta.color : '#3b82f6';
});

// PIVOT(range) flag cells as hinge pivots for grouped rigid bodies
tag('PIVOT',["PHYSICS"], (anchor, arr, ast, tx) => {
 const cells = collectTargetCells(ast.args[0], anchor);
 const info = ensureTransaction(tx, 'physics.pivot', 'Mark physics pivots');
 cells.forEach(target => {
 mutateCellMeta(info.tx, target, meta => ({ ...meta, physicsPivot: true }));
 });
 finalizeTransaction(info);
 try{
 const affected = new Set(cells.map(c=>c.arrId));
 affected.forEach(id=>{ const targetArr = Store.getState().arrays[id]; if(targetArr) Scene.debounceColliderRebuild?.(targetArr); });
 }catch{}
});

// GROUP(range, id) assign cells to shared rigid body groups
tag('GROUP',["PHYSICS"], (anchor, arr, ast, tx) => {
 const cells = collectTargetCells(ast.args[0], anchor);
 const rawId = ast.args[1] !== undefined ? Formula.valOf(ast.args[1]) : undefined;
 const normalized = rawId == null ? '' : String(rawId).trim();
 const info = ensureTransaction(tx, 'physics.group', 'Assign physics group');
 cells.forEach(target => {
 mutateCellMeta(info.tx, target, meta => {
 const next = { ...meta };
 if(!normalized){ delete next.physicsGroupId; }
 else next.physicsGroupId = normalized;
 return next;
 });
 });
 finalizeTransaction(info);
 try{
 const affected = new Set(cells.map(c=>c.arrId));
 affected.forEach(id=>{ const targetArr = Store.getState().arrays[id]; if(targetArr) Scene.debounceColliderRebuild?.(targetArr); });
 }catch{}
});

// LIMIT(range, state[, duration]) encode temporary physics bounds
tag('LIMIT',["PHYSICS"], (anchor, arr, ast, tx) => {
 if(ast.args.length <= 1){
 const hostId = arr?.id ?? anchor?.arrId ?? null;
 const scopeDesc = extractScopeFromArgs(ast.args, anchor, hostId);
 if(scopeDesc.mode === 'all') return makeArrayScope('all');
 return makeArrayScope('limit', scopeDesc.ids);
 }
 const cells = collectTargetCells(ast.args[0], anchor);
 const stateRaw = ast.args[1] !== undefined ? Formula.valOf(ast.args[1]) : 1;
 const durationRaw = ast.args[2] !== undefined ? Formula.valOf(ast.args[2]) : null;
 const stateNorm = typeof stateRaw === 'string' ? stateRaw.trim().toLowerCase() : stateRaw;
 const enabled = stateNorm === 'enable' || stateNorm === 'enabled' || stateNorm === 'on' || stateNorm === '1' || stateNorm === 1 || stateNorm === true;
 const info = ensureTransaction(tx, 'physics.limit', 'Apply physics limit');
 const duration = durationRaw == null ? null : Math.max(0, Math.round(Number(durationRaw) || 0));
 cells.forEach(target => {
 mutateCellMeta(info.tx, target, meta => {
 const next = { ...meta };
 next.physicsLimit = {
 state: enabled ? 'enable' : 'disable',
 duration,
 requestedAt: Date.now()
 };
 return next;
 });
 });
 finalizeTransaction(info);
});

// ALL() scope helper targeting every array
tag('ALL',["SCENE"], () => makeArrayScope('all'));

// CELL_PHYS(enabled[, jumpCount[, gravityVec[, boundByArrayFloor[, respawnRef[, scope]]]]]) per-array physics configuration
tag('CELL_PHYS',["PHYSICS"], (anchor, arr, ast) => {
 const enabled = !!Formula.valOf(ast.args[0] ?? 0);
 const jumpCountArg = ast.args[1];
 const gravityArg = ast.args[2];
 const floorArg = ast.args[3];
 const respawnArg = ast.args[4];
 const scopeArg = ast.args[5];
 const jumpCount = jumpCountArg !== undefined ? Math.max(0, Math.round(Number(Formula.valOf(jumpCountArg)) || 0)) : undefined;
 const gravityVec = parseVectorArg(gravityArg);
 const boundByFloor = floorArg !== undefined ? !!Formula.valOf(floorArg) : undefined;
 const respawnProvided = respawnArg !== undefined;
 let respawnDescriptor = null;
 if(respawnProvided){
 if(respawnArg && typeof respawnArg === 'object' && (respawnArg.kind === 'ref' || respawnArg.kind === 'range')){
 const ref = respawnArg.kind === 'ref' ? respawnArg : (respawnArg.cells && respawnArg.cells[0]);
 if(ref) respawnDescriptor = { type:'ref', ref };
 }
 if(!respawnDescriptor){
 let value;
 try{ value = Formula.valOf(respawnArg); }catch{}
 respawnDescriptor = { type:'value', value };
 }
 }

 const { targets, scope } = resolveArrayScopeTargets(arr, anchor, scopeArg);
 const debugForceAll = !!Store.getState().scene?.physicsDebugAll;
 
 console.log(`[CELL_PHYS] called on array #${arr?.id}, enabled=${enabled}, scope.mode=${scope.mode}, debugForceAll=${debugForceAll}`);
 
 let targetList = targets.filter(Boolean);
 if(!targetList.length && arr){
 targetList = [arr];
 }
 if(debugForceAll && scope.mode === 'all'){
 targetList = Object.values(Store.getState().arrays || {}).filter(Boolean);
 }
 const seenTargets = new Set();
 targetList = targetList.filter(targetArr => {
 if(!targetArr || !Number.isFinite(targetArr.id)) return false;
 if(seenTargets.has(targetArr.id)) return false;
 seenTargets.add(targetArr.id);
 return true;
 });
 if(!targetList.length && arr) targetList = [arr];
 console.log(`[CELL_PHYS] targeting ${targetList.length} arrays: [${targetList.map(a=>a.id).join(', ')}]`);
 const respawnUpdates = {};

 const resolveRespawn = (targetArr)=>{
 if(!respawnDescriptor) return null;
 const arrays = Store.getState().arrays || {};
 const hostId = targetArr?.id ?? arr?.id ?? anchor?.arrId ?? null;
 let targetArrId = hostId;
 let cellCoord = null;
 let worldOverride = null;
 if(respawnDescriptor.type === 'ref' && respawnDescriptor.ref){
 const ref = respawnDescriptor.ref;
 targetArrId = Number.isFinite(ref.arrId) ? Math.trunc(ref.arrId) : hostId;
 cellCoord = { x: Math.trunc(ref.x ?? 0), y: Math.trunc(ref.y ?? 0), z: Math.trunc(ref.z ?? 0) };
 } else if(respawnDescriptor.type === 'value'){
 const val = respawnDescriptor.value;
 const normalized = normalizeScopeDescriptor(val, hostId);
 if(normalized && normalized.mode === 'all'){ return null; }
 if(val && typeof val === 'object'){
 if(Number.isFinite(val.arrId)) targetArrId = Math.trunc(val.arrId);
 else if(Number.isFinite(val.array)) targetArrId = Math.trunc(val.array);
 if(val.world && Number.isFinite(val.world.x) && Number.isFinite(val.world.y) && Number.isFinite(val.world.z)){
 worldOverride = { x:Number(val.world.x), y:Number(val.world.y), z:Number(val.world.z) };
 }
 if(Number.isFinite(val.x) && Number.isFinite(val.y) && Number.isFinite(val.z)){
 cellCoord = { x: Math.trunc(val.x), y: Math.trunc(val.y), z: Math.trunc(val.z) };
 }
 }
 if(!cellCoord && Array.isArray(val) && val.length >= 3){
 cellCoord = {
 x: Math.trunc(Number(val[0]) || 0),
 y: Math.trunc(Number(val[1]) || 0),
 z: Math.trunc(Number(val[2]) || 0)
 };
 if(val.length >= 4 && Number.isFinite(Number(val[3]))){
 targetArrId = Math.trunc(Number(val[3]));
 }
 }
 if(!cellCoord && typeof val === 'string'){
 const trimmed = val.trim();
 const addr = /^@\[(.*)\]$/.exec(trimmed);
 if(addr){
 const parts = addr[1].split(',').map(s=>s.trim()).filter(Boolean);
 if(parts.length >= 3){
 cellCoord = {
 x: Math.trunc(Number(parts[0]) || 0),
 y: Math.trunc(Number(parts[1]) || 0),
 z: Math.trunc(Number(parts[2]) || 0)
 };
 if(parts.length >= 4 && Number.isFinite(Number(parts[3]))){
 targetArrId = Math.trunc(Number(parts[3]));
 }
 }
 } else {
 const pieces = trimmed.replace(/[\[\]\{\}]/g,'').split(/[,\s]+/).filter(Boolean);
 if(pieces.length >= 3){
 cellCoord = {
 x: Math.trunc(Number(pieces[0]) || 0),
 y: Math.trunc(Number(pieces[1]) || 0),
 z: Math.trunc(Number(pieces[2]) || 0)
 };
 if(pieces.length >= 4 && Number.isFinite(Number(pieces[3]))){
 targetArrId = Math.trunc(Number(pieces[3]));
 }
 }
 }
 }
 }
 const arrTarget = arrays[targetArrId] || targetArr || arr;
 if(worldOverride && arrTarget){
 return {
 arrId: arrTarget.id,
 cell: cellCoord,
 world: { x: worldOverride.x, y: worldOverride.y, z: worldOverride.z }
 };
 }
 if(!cellCoord || !arrTarget) return null;
 let pos = null;
 try{
 if(Scene.cellWorldPos) pos = Scene.cellWorldPos(arrTarget, cellCoord.x, cellCoord.y, cellCoord.z);
 if(!pos && Scene.worldPos) pos = Scene.worldPos(arrTarget, cellCoord.x, cellCoord.y, cellCoord.z);
 }catch{}
 if(!pos) return null;
 return {
 arrId: arrTarget.id,
 cell: { ...cellCoord },
 world: { x: pos.x, y: pos.y, z: pos.z }
 };
 };

 // Mutate arrays directly in Store to ensure changes persist
 Store.setState(state => {
 const arrays = { ...state.arrays };
 targetList.forEach(targetArr => {
 if(!targetArr) return;
 // Get fresh reference from Store
 const storeArr = arrays[targetArr.id];
 if(!storeArr) return;
 
 const nextParams = { ...(storeArr.params || {}) };
 nextParams.physics = { ...(nextParams.physics || { enabled:false }) };
 const phys = nextParams.physics;
 const debugLocked = !!phys.__debugOverride;
 const sources = { ...(phys.__sources || {}) };
 
 if(debugLocked){
 console.log(`[CELL_PHYS] Array #${storeArr.id} is debug-locked, skipping`);
 phys.__sources = sources;
 if(respawnProvided){
 const respawnInfo = resolveRespawn(storeArr);
 respawnUpdates[storeArr.id] = respawnInfo || null;
 }
 return;
 }
 const priority = (()=>{
 if(scope.mode === 'host') return 2;
 if(scope.mode === 'limit'){
 return (storeArr.id === arr.id) ? 2 : 1;
 }
 return 0;
 })();
 const claim = (key, provided=true)=>{
 if(!provided) return false;
 const prev = sources[key] ?? -Infinity;
 if(priority >= prev){
 sources[key] = priority;
 return true;
 }
 return false;
 };
 if(claim('enabled', true)){
 phys.enabled = enabled;
 console.log(`[CELL_PHYS] Set array #${storeArr.id} physics.enabled = ${enabled}, priority=${priority}, scope.mode=${scope.mode}`);
 }
 if(claim('jumpCount', jumpCount !== undefined)) phys.jumpCount = jumpCount;
 if(claim('gravity', !!gravityVec)) phys.gravity = gravityVec ? { x:gravityVec.x, y:gravityVec.y, z:gravityVec.z } : undefined;
 if(claim('boundByArrayFloor', boundByFloor !== undefined)) phys.boundByArrayFloor = boundByFloor;
 phys.__sources = sources;
 if(respawnProvided && claim('respawn', true)){
 const respawnInfo = resolveRespawn(storeArr);
 respawnUpdates[storeArr.id] = respawnInfo || null;
 }
 
 // Update the array in Store with new physics params
 arrays[storeArr.id] = { ...storeArr, params: nextParams };
 });
 
 return { arrays };
 });
 
 if(enabled){
 const arraysById = Store.getState().arrays || {};
 targetList.forEach(targetArr=>{
 const latest = arraysById[targetArr.id] || null;
 console.log(`[CELL_PHYS] Rebuilding colliders for array #${targetArr.id} with enabled=${latest?.params?.physics?.enabled}`);
 if(!latest) return;
 try{ Scene.debounceColliderRebuild(latest); }catch{}
 });
 }

 const updateRespawns = Object.keys(respawnUpdates).length > 0;
 if(updateRespawns){
 Store.setState(state => {
 const scene = { ...(state.scene || {}) };
 const existing = { ...(scene.physicsRespawns || {}) };
 Object.entries(respawnUpdates).forEach(([id, info])=>{
 if(info){ existing[id] = info; }
 else delete existing[id];
 });
 scene.physicsRespawns = existing;
 return { scene };
 });
 const selArrId = Store.getState().selection?.arrayId;
 if(selArrId != null && Object.prototype.hasOwnProperty.call(respawnUpdates, selArrId)){
 const world = respawnUpdates[selArrId]?.world;
 if(world) try{ Scene.setPhysicsSpawn?.(world); }catch{}
 else try{ Scene.setPhysicsSpawn?.(null); }catch{}
 }
 if(Object.prototype.hasOwnProperty.call(respawnUpdates, arr.id)){
 const world = respawnUpdates[arr.id]?.world;
 if(world) try{ Scene.setPhysicsSpawn?.(world); }catch{}
 else try{ Scene.setPhysicsSpawn?.(null); }catch{}
 }
 }

 const stamp = enabled ? '?? Physics ON' : '?? Physics OFF';
 Actions.setCell(arr.id, anchor, stamp, ast.raw, true);
});

// CELLI_PHYS(enabled[, jumpCount[, runMultiplier[, momentumMode]]]) avatar controller wrapper
tag('CELLI_PHYS',["PHYSICS","AVATAR"], (anchor, arr, ast) => {
 const enabled = !!Formula.valOf(ast.args[0] ?? 1);
 const jumpCountArg = ast.args[1];
 const runArg = ast.args[2];
 const momentumArg = ast.args[3];
 const stateBefore = Store.getState();
 const prevEnabled = !!stateBefore.avatarPhysics?.enabled;
 const physicsActiveBefore = !!stateBefore.scene?.physics;
 const debugOverrideActive = !!stateBefore.scene?.physicsDebugAll && !!stateBefore.avatarPhysics?.__debugOverride;
 const effectiveEnabled = debugOverrideActive ? true : enabled;
 const updates = {};
 if(debugOverrideActive){
 updates.enabled = stateBefore.avatarPhysics?.enabled !== false;
 } else {
 updates.enabled = effectiveEnabled;
 }
 if(jumpCountArg !== undefined){
 const jc = Math.max(0, Math.round(Number(Formula.valOf(jumpCountArg)) || 0));
 if(!debugOverrideActive){
 updates.jumpCount = jc;
 } else if(stateBefore.avatarPhysics && stateBefore.avatarPhysics.jumpCount !== undefined){
 updates.jumpCount = stateBefore.avatarPhysics.jumpCount;
 }
 }
 if(runArg !== undefined){
 let rm = Number(Formula.valOf(runArg));
 if(!Number.isFinite(rm)) rm = 1;
 updates.runMultiplier = Math.max(0.1, rm);
 }
 if(momentumArg !== undefined){
 const mm = Math.round(Number(Formula.valOf(momentumArg)) || 0);
 updates.momentumMode = mm === 1 ? 1 : 0;
 }

 Store.setState(state => ({
 avatarPhysics: { ...state.avatarPhysics, ...updates }
 }));

 // Mark this array as the physics host so colliders are built for it
 try{
 Store.setState(state => {
 const arrays = { ...state.arrays };
 if(arrays[arr.id]){
 arrays[arr.id] = {
 ...arrays[arr.id],
 collisionMode: effectiveEnabled ? 'physics' : 'edit',
 params: {
 ...arrays[arr.id].params,
 physics: {
 ...arrays[arr.id].params?.physics,
 enabled: effectiveEnabled
 }
 }
 };
 }
 return { arrays };
 });
 console.log(`[PHYSICS] Set array #${arr.id} "${arr.name}" physics.enabled=${effectiveEnabled}`);
 // Trigger collider rebuild for this array if physics is being enabled
 if(effectiveEnabled && Scene?.debounceColliderRebuild){
 const updatedArr = Store.getState().arrays[arr.id];
 if(updatedArr) Scene.debounceColliderRebuild(updatedArr);
 }
 }catch(e){ console.warn('[PHYSICS] Failed to set array physics params', e); }

 try{
 const g = Store.getState().globalState;
 if(g && typeof g.set === 'function'){
 g.set('platformer.active', !!effectiveEnabled);
 g.set('platformer.input', 'none');
 g.set('platformer.jump', 0);
 }
 }catch{}

 let spawnTarget = null;
 if(effectiveEnabled && !prevEnabled){
 try{
 const sel = stateBefore.selection;
 const arrays = stateBefore.arrays || {};
 if(sel?.arrayId != null && sel.focus){
 const arrSel = arrays[sel.arrayId];
 if(arrSel){
 const pos = Scene.worldPos ? Scene.worldPos(arrSel, sel.focus.x, sel.focus.y, sel.focus.z) : null;
 if(pos){
 const scale = arrayVoxelScale(arrSel);
 const perch = avatarPerchOffset(scale);
 spawnTarget = { x: pos.x, y: pos.y + perch, z: pos.z };
 }
 }
 }
 }catch{}
 }

 if(effectiveEnabled && !physicsActiveBefore){
 try{
 const toggle = Scene.togglePhysicsMode;
 if(typeof toggle === 'function'){
 const res = toggle();
 if(res && typeof res.catch === 'function'){
 res.catch(err=>console.warn('[PHYSICS] CELLI_PHYS enable failed', err));
 }
 }
 }catch(e){ console.warn('[PHYSICS] CELLI_PHYS enable threw', e); }
 }

 if(spawnTarget){
 try{ Scene.spawnPlayerAt?.(spawnTarget.x, spawnTarget.y, spawnTarget.z); }catch{}
 try{ Scene.setPhysicsSpawn?.(spawnTarget); }catch{}
 }

 if(!effectiveEnabled && Store.getState().scene.physics){
 try{
 const toggle = Scene.togglePhysicsMode;
 if(typeof toggle === 'function'){
 const res = toggle();
 if(res && typeof res.catch === 'function'){
 res.catch(err=>console.warn('[PHYSICS] CELLI_PHYS disable failed', err));
 }
 }
 }catch(e){ console.warn('[PHYSICS] CELLI_PHYS disable threw', e); }
 }

 const stamp = effectiveEnabled ? '?? Avatar' : '?? Classic';
 Actions.setCell(arr.id, anchor, stamp, ast.raw, true);
});

// PHYS_CAMERA(mode, distance?, allowRotation=0) configure physics-friendly camera rigs
tag('PHYS_CAMERA',["SCENE","CAMERA"], (anchor, arr, ast) => {
 const modeRaw = String(Formula.valOf(ast.args[0] ?? 'free') || 'free').toLowerCase();
 const distanceRaw = ast.args[1] !== undefined ? Number(Formula.valOf(ast.args[1])) : NaN;
 const allowRotation = !!Formula.valOf(ast.args[2] ?? 0);
 const distance = Number.isFinite(distanceRaw) ? Math.max(2, distanceRaw) : undefined;

 Store.setState(state => ({
 physicsCamera: {
 mode: modeRaw || 'free',
 distance: distance !== undefined ? distance : state.physicsCamera.distance,
 allowRotation
 }
 }));

 try{
 const cfg = Store.getState().physicsCamera;
 if(cfg && Scene.setPhysicsCamera){
 Scene.setPhysicsCamera(cfg.mode, cfg.distance, cfg.allowRotation);
 }
 }catch{}

 Actions.setCell(arr.id, anchor, `?? ${modeRaw.toUpperCase()}`, ast.raw, true);
});

// EVENT BUS FUNCTIONS
tag('ON_EVENT',['META'],(anchor,arr,ast)=>{
 const eventName = String(valOf(ast.args[0]) || '');
 const actionFormula = String(valOf(ast.args[1]) || '');
 if(!eventName || !actionFormula) throw new Error('ON_EVENT requires eventName and actionFormula');
 
 const listeners = Store.getState().eventListeners;
 if(!listeners.has(eventName)) listeners.set(eventName, []);
 
 const listenerObj = {
 anchor: {...anchor}, // Store anchor location
 actionFormula,
 arrId: arr.id
 };
 
 listeners.get(eventName).push(listenerObj);
 Actions.setCell(arr.id, anchor, `Listen[${eventName}]: ${actionFormula}`, ast.raw, true);
});
tag('FIRE_EVENT',['ACTION'],(anchor,arr,ast,tx)=>{
 const eventName = String(valOf(ast.args[0]) || '');
 const payload = ast.args[1] !== undefined ? valOf(ast.args[1]) : null;
 if(!eventName) throw new Error('FIRE_EVENT requires eventName');
 
 // Store payload in global state temporarily for listeners to access
 if(payload !== null) {
 Store.getState().globalState.set(`event.payload.${eventName}`, payload);
 }
 
 const listeners = Store.getState().eventListeners.get(eventName) || [];
 
 // Execute all listener formulas
 listeners.forEach(listener => {
 try {
 const targetAnchor = {arrId: listener.arrId, ...listener.anchor};
 // Reuse provided tx if present; otherwise create a scoped one per event
 if(tx){
 Formula.executeAt(targetAnchor, listener.actionFormula, tx);
 } else {
 const etx = Write.start(`event.${eventName}`,'Event dispatch');
 Formula.executeAt(targetAnchor, listener.actionFormula, etx);
 Write.commit(etx);
 }
 } catch(e) {
 console.error(`Event listener error for ${eventName}:`, e);
 }
 });
 
 Actions.setCell(arr.id, anchor, `Fired[${eventName}]${payload ? ` with ${payload}` : ''}`, ast.raw, true);
});

// INFORMATION & INTERACTION CONTROL
tag('GET_PLAYER_FOCUS',['PURE'],(anchor,arr,ast)=>{
 const selection = Store.getState().selection;
 if(!selection.focus || !selection.arrayId) {
 Actions.setCell(arr.id, anchor, '', ast.raw, true);
 return;
 }
 
 const address = `@[${selection.focus.x},${selection.focus.y},${selection.focus.z},${selection.arrayId}]`;
 Actions.setCell(arr.id, anchor, address, ast.raw, true);
});
tag('CANT_TARGET',['META'],(anchor,arr,ast)=>{
 const target = ast.args[0];
 if(!target) throw new Error('CANT_TARGET requires a range or reference');
 
 const markUntargetable = (x, y, z, arrId) => {
 const targetArr = Store.getState().arrays[arrId];
 if(!targetArr) return;
 const ch = targetArr.chunks[keyChunk(...Object.values(chunkOf(x, y, z)))];
 if(!ch) return;
 const cell = ch.cells.find(c => c.x === x && c.y === y && c.z === z);
 if(cell) {
 if(!cell.meta) cell.meta = {};
 cell.meta.isTargetable = false;
 }
 };
 
 if(target.kind === 'ref') {
 markUntargetable(target.x, target.y, target.z, target.arrId);
 } else if(target.kind === 'range') {
 target.cells.forEach(cell => {
 markUntargetable(cell.x, cell.y, cell.z, cell.arrId);
 });
 }
 
 Actions.setCell(arr.id, anchor, 'Protected cells marked', ast.raw, true);
});

// GAME HELPER FUNCTIONS
tag('GET_ARRAY_POS',["PURE"],(anchor,arr,ast)=>{
 const target=ast.args[0]&&ast.args[0].kind==='ref'? Store.getState().arrays[ast.args[0].arrId] : arr;
 if(!target){ Actions.setCell(arr.id,anchor,'',ast.raw,true); return; }
 const o = target.offset||{x:0,y:0,z:0};
 Actions.setCell(arr.id, anchor, `{"x":${o.x},"y":${o.y},"z":${o.z}}`, ast.raw, true);
});
tag('SET_ARRAY_POS',["SCENE","ACTION"],(anchor,arr,ast)=>{
 let target=null;
 if(ast.args[0] && ast.args[0].kind==='ref'){
 target = Store.getState().arrays[ast.args[0].arrId];
 } else {
 const maybeId = +Formula.valOf(ast.args[0]);
 if(Number.isInteger(maybeId)) target = Store.getState().arrays[maybeId];
 if(!target) target = arr;
 }
 const x=(+Formula.valOf(ast.args[1])||0), y=(+Formula.valOf(ast.args[2])||0), z=(+Formula.valOf(ast.args[3])||0);
 if(!target) { Actions.setCell(arr.id,anchor,'!ERR:ARR',ast.raw,true); return; }
 Scene.setArrayOffset(target,{x,y,z});
 Actions.setCell(arr.id,anchor,`Pos:${x},${y},${z}`,ast.raw,true);
});
function refreshArrayScale(targetArr){
 if(!targetArr) return;
 try{
 targetArr._viewSig = '';
 renderArray(targetArr);
 try{
 const off = targetArr.offset ? { x: targetArr.offset.x, y: targetArr.offset.y, z: targetArr.offset.z } : { x:0,y:0,z:0 };
 Scene.setArrayOffset?.(targetArr, off, { interactive:true, _skipDock:true, _skipConnections:true });
 }catch{}
 Object.values(targetArr.chunks||{}).forEach(ch=>{ try{ ch.ensureMesh?.(); ch.setLOD?.(1); rehydrateChunkInstances(targetArr, ch); }catch{} });
 updateArrayLabelPlacement(targetArr);
 updateArrayValueSpritePlacement(targetArr);
 debounceColliderRebuild(targetArr);
 }catch(e){ console.warn('SCALE refresh failed', e); }
}
tag('SCALE',["SCENE","VOXEL"],(anchor,arr,ast)=>{
 const rawFactor = ast.args[0] !== undefined ? Number(Formula.valOf(ast.args[0])) : NaN;
 const level = Number.isFinite(rawFactor) ? Math.max(1, Math.round(rawFactor)) : 1;
 const units = arrayScaleUnitsFromLevel(level);
 const scopeArg = ast.args[1];
 const { targets } = resolveArrayScopeTargets(arr, anchor, scopeArg);
 const touched = [];
 const prevStates = [];
 targets.forEach(targetArr => {
 if(!targetArr) return;
 targetArr.params = targetArr.params || {};
 const prevLevel = Number.isFinite(+targetArr.params.voxelScaleLevel) ? (+targetArr.params.voxelScaleLevel|0) : 1;
 const prevUnits = Number.isFinite(+targetArr.params.voxelScale) ? +targetArr.params.voxelScale : arrayScaleUnitsFromLevel(prevLevel);
 prevStates.push({ id: targetArr.id, prevLevel, prevUnits });
 targetArr.params.voxelScaleLevel = level;
 targetArr.params.voxelScale = units;
 touched.push(targetArr);
 });
 touched.forEach(targetArr => {
 refreshArrayScale(targetArr);
 });
 if(prevStates.length){
 try{
 const ak=aKey(anchor);
 const S=Store.getState();
 const map=new Map(S.activeScales||new Map());
 map.set(ak, { targets: prevStates });
 Store.setState({ activeScales: map });
 const txw = Write.start('mark.scale','mark');
 const cell = Formula.getCell(anchor) || {value:'',formula:null,meta:{}};
 Write.set(txw, arr.id, {x:anchor.x,y:anchor.y,z:anchor.z}, { value: cell.value, formula: cell.formula, meta:{...(cell.meta||{}), appliedScale:{ targets: prevStates }} });
 Write.commit(txw);
 }catch{}
 }
 const stamp = `Scale ${units}`;
 Actions.setCell(arr.id, anchor, stamp, ast.raw, true);
});
// Backward-compatible alias: TRANSLATE_ARRAY delegates to 3D_TRANSLATE
tag('TRANSLATE_ARRAY',["SCENE"],(anchor,arr,ast)=> Fn['3D_TRANSLATE'].impl(anchor,arr,ast));
// 3D_ROTATE(stepsY) or 3D_ROTATE(stepsX,stepsY,stepsZ)
tag('3D_ROTATE',["SCENE"],(anchor,arr,ast)=>{
 // Parse args
 const sx = ast.args[1]!==undefined ? ((+Formula.valOf(ast.args[0])||0)|0) : 0;
 const sy = ast.args[1]!==undefined ? ((+Formula.valOf(ast.args[1])||0)|0) : ((+Formula.valOf(ast.args[0])||0)|0);
 const sz = ast.args[2]!==undefined ? ((+Formula.valOf(ast.args[2])||0)|0) : 0;
 const cont = !!((+Formula.valOf(ast.args[3]||0))|0);

 const S=Store.getState();
 const group = [...(S.dockGroups||new Map()).values()].find(g=>g.members.includes(arr.id));
 const ids = group
 ? (group.mode==='parent'
 ? [arr.id, ...group.members.filter(id=> id!==arr.id && group.members.indexOf(id) > group.members.indexOf(arr.id))]
 : [...group.members])
 : [arr.id];
 const arrays = ids.map(id=>S.arrays[id]).filter(Boolean);

 // If timed gamestate is active on the host, queue high-level rotate and exit
 let timed0 = null; try{ if(typeof Scene!=='undefined' && Scene.ensureTimedState) timed0 = Scene.ensureTimedState(arr); }catch{}
 if(!timed0){ try{ arr.params = arr.params || {}; arr.params.timed = arr.params.timed || { ticks:60, reverse:false, reverseTicks:null, repeat:false, t:0, dir:1, previewInArray:false, plan:[], baseOffset:null, baseQuat:null, overlay:null }; timed0 = arr.params.timed; }catch{} }
 const G0=(Store.getState().scene||{}).timed3D;
 if((timed0 && timed0.previewInArray) || (G0&&G0.preview)){
 // In preview, do not apply or stamp; animation system will parse formulas and animate
 return;
 }
 // Non-repeat executable: if this anchor already applied a rotation, skip
 try{
 const ak=aKey(anchor);
 const existing=(Store.getState().activeRotations||new Map()).get(ak);
 if(existing && !cont){ Actions.setCell(arr.id, anchor, `3D_Rotate:skip`, (ast.raw||`=3D_ROTATE(${sx},${sy},${sz})`)); return; }
 }catch{}
 // Ensure frames exist for all arrays so transforms apply
 arrays.forEach(a=>{ if(!a._frame) Scene.renderArray(a); });

 // Compute world-space pivot at the CENTER of the anchor cell
 const pivotWorld = Scene.cellWorldPos(arr, anchor.x, anchor.y, anchor.z);

 // Optional: compute group bounds from extreme cell centers (min/max per axis)
 const boundsOf = (a)=>{
 const xs=[0,Math.max(0,a.size.x-1)], ys=[0,Math.max(0,a.size.y-1)], zs=[0,Math.max(0,a.size.z-1)];
 let minX= Infinity,minY= Infinity,minZ= Infinity,maxX=-Infinity,maxY=-Infinity,maxZ=-Infinity;
 xs.forEach(ix=> ys.forEach(iy=> zs.forEach(iz=>{
 const p=Scene.cellWorldPos(a, ix, iy, iz);
 if(p.x<minX)minX=p.x; if(p.y<minY)minY=p.y; if(p.z<minZ)minZ=p.z;
 if(p.x>maxX)maxX=p.x; if(p.y>maxY)maxY=p.y; if(p.z>maxZ)maxZ=p.z;
 })));
 return {minX,minY,minZ,maxX,maxY,maxZ};
 };
 const pre = arrays.reduce((acc,a)=>{ const b=boundsOf(a); return {
 minX:Math.min(acc.minX,b.minX), minY:Math.min(acc.minY,b.minY), minZ:Math.min(acc.minZ,b.minZ),
 maxX:Math.max(acc.maxX,b.maxX), maxY:Math.max(acc.maxY,b.maxY), maxZ:Math.max(acc.maxZ,b.maxZ)
 }; }, {minX:Infinity,minY:Infinity,minZ:Infinity,maxX:-Infinity,maxY:-Infinity,maxZ:-Infinity});

 // Apply atomic rotation around pivot to all arrays
 arrays.forEach(a=> Scene.rotateArrayAround(a, pivotWorld, sx, sy, sz));

 // After rotation, do a light snap and ensure offsets are consistent
 arrays.forEach(a=>{
 if(a._frame){
 a.offset = { x: Math.round(a._frame.position.x), y: Math.round(a._frame.position.y), z: Math.round(a._frame.position.z) };
 }
 });

 // Recompute bounds post-rotation (for correctness/visual sanity)
 const post = arrays.reduce((acc,a)=>{ const b=boundsOf(a); return {
 minX:Math.min(acc.minX,b.minX), minY:Math.min(acc.minY,b.minY), minZ:Math.min(acc.minZ,b.minZ),
 maxX:Math.max(acc.maxX,b.maxX), maxY:Math.max(acc.maxY,b.maxY), maxZ:Math.max(acc.maxZ,b.maxZ)
 }; }, {minX:Infinity,minY:Infinity,minZ:Infinity,maxX:-Infinity,maxY:-Infinity,maxZ:-Infinity});

 const clampSteps=(n)=>(((n%4)+4)%4);
 const degX = clampSteps(sx)*90, degY = clampSteps(sy)*90, degZ = clampSteps(sz)*90;
 Actions.setCell(arr.id,anchor,`3D_Rotate:${sx},${sy},${sz}`,(ast.raw||`=3D_ROTATE(${sx},${sy},${sz})`));
 // Persist for refresh-time revert
 try{
 const ak=aKey(anchor);
 const S=Store.getState();
 const rec={targetId:targetArr.id, ids:[...ids], pivot:{...anchor, arrId:arr.id}, steps:{sx,sy,sz}};
 const map=new Map(S.activeRotations||new Map()); map.set(ak, rec); Store.setState({activeRotations:map});
 const txw = Write.start('mark.3d.rotate','mark');
 const cell = Formula.getCell(anchor) || {value:'',formula:null,meta:{}};
 Write.set(txw, arr.id, {x:anchor.x,y:anchor.y,z:anchor.z}, { value: cell.value, formula: cell.formula, meta:{...(cell.meta||{}), appliedRotate: rec } });
 Write.commit(txw);
 }catch{}
});
// Backward-compatible alias: ROTATE_ARRAY delegates to 3D_ROTATE
tag('ROTATE_ARRAY',["SCENE"],(anchor,arr,ast)=>{
 return Fn['3D_ROTATE'].impl(anchor,arr,ast);
});
tag('VECTOR_TO',['PURE'],(anchor,arr,ast)=>{
 const fromAddr = String(valOf(ast.args[0]) || '');
 const toAddr = String(valOf(ast.args[1]) || '');
 
 // Parse addresses like @[x,y,z,arrId] or cell references
 const parseAddr = (addr) => {
 const m = /@\[(-?\d+)?,(-?\d+)?,(-?\d+)?,(-?\d+)\]/.exec(String(addr).trim());
 if(!m) return null;
 // Use 0 => current component; missing => 1
 const toOneBased=(val,cur)=>{ if(val===undefined||val===null||val==='') return 1; const n=+val; return n===0? (cur+1) : n; };
 const xb=toOneBased(m[1], from.x), yb=toOneBased(m[2], from.y), zb=toOneBased(m[3], from.z);
 return {x: xb-1, y: yb-1, z: zb-1, arrId:+m[4]};
 };
 
 const from = parseAddr(fromAddr);
 const to = parseAddr(toAddr);
 
 if(!from || !to) {
 Actions.setCell(arr.id, anchor, '{"gravity":[0,0,0]}', ast.raw, true);
 return;
 }
 
 const dx = to.x - from.x;
 const dy = to.y - from.y;
 const dz = to.z - from.z;
 const mag = Math.sqrt(dx*dx + dy*dy + dz*dz);
 
 if(mag === 0) {
 Actions.setCell(arr.id, anchor, '{"gravity":[0,0,0]}', ast.raw, true);
 return;
 }
 
 const nx = dx / mag;
 const ny = dy / mag;
 const nz = dz / mag;
 
 const vector = `{"gravity":[${nx.toFixed(3)},${ny.toFixed(3)},${nz.toFixed(3)}]}`;
 Actions.setCell(arr.id, anchor, vector, ast.raw, true);
});
tag('PLATFORMER_PHYSICS',['ACTION'],(anchor,arr,ast)=>{
 // Simple platformer physics implementation
 const currentPos = Store.getState().globalState.get('platformer.pos') || '@[4,3,0,1]';
 const input = Store.getState().globalState.get('platformer.input') || 'none';
 
 const parsePos = (pos) => {
 const m = /@\[(-?\d+)?,(-?\d+)?,(-?\d+)?,(-?\d+)\]/.exec(String(pos).trim());
 if(m){
 const toOneBased=(v,cur)=>{ if(v===undefined||v===null||v==='') return 1; const n=+v; return n===0? (cur+1) : n; };
 const xb=toOneBased(m[1], 4), yb=toOneBased(m[2], 3), zb=toOneBased(m[3], 0); // defaults if 0 used outside anchor
 return {x: xb-1, y: yb-1, z: zb-1, arrId:+m[4]};
 }
 return {x: 4, y: 3, z: 0, arrId: 1};
 };
 
 const pos = parsePos(currentPos);
 let newPos = {...pos};
 
 // Handle input
 switch(input) {
 case 'left': newPos.x = Math.max(0, pos.x - 1); break;
 case 'right': newPos.x = Math.min(7, pos.x + 1); break;
 case 'up': newPos.y = Math.min(3, pos.y + 1); break;
 case 'down': newPos.y = Math.max(0, pos.y - 1); break;
 }
 
 // Clear old position and set new position
 if(newPos.x !== pos.x || newPos.y !== pos.y) {
 try {
 Actions.setCell(pos.arrId, {x: pos.x, y: pos.y, z: pos.z}, '', null, true);
 Actions.setCell(newPos.arrId, {x: newPos.x, y: newPos.y, z: newPos.z}, '??', null, true);
 Store.getState().globalState.set('platformer.pos', `@[${newPos.x},${newPos.y},${newPos.z},${newPos.arrId}]`);
 } catch(e) {
 console.error('Platformer physics error:', e);
 }
 }
 
 Actions.setCell(arr.id, anchor, `Player: ${newPos.x},${newPos.y}`, ast.raw, true);
});
// GAME FUNCTIONS
tag('FISH',['GAME'],(anchor,arr,ast)=>{
 // Initialize FISH game state and setup
 Actions.begin();
 
 // Set up game state
 Store.getState().globalState.set('fish.state', 'IDLE');
 Store.getState().globalState.set('fish.timer', 0);
 Store.getState().globalState.set('player.score', 0);
 
 // Create game UI at anchor
 Actions.setCell(arr.id, anchor, '?? FISH GAME', ast.raw, true);
 Actions.setCell(arr.id, {x:anchor.x+1,y:anchor.y,z:anchor.z}, '=ON_SELECT(SELF(),"=FIRE_EVENT(\\"CAST\\")")', null, true);
 Actions.setCell(arr.id, {x:anchor.x+2,y:anchor.y,z:anchor.z}, '=ON_SELECT(SELF(),"=IF(GET_GLOBAL(\\"fish.state\\")=\\"BITING\\",FIRE_EVENT(\\"CATCH\\"))")', null, true);
 Actions.setCell(arr.id, {x:anchor.x,y:anchor.y-1,z:anchor.z}, '=GET_GLOBAL("fish.state")', null, true);
 Actions.setCell(arr.id, {x:anchor.x+1,y:anchor.y-1,z:anchor.z}, '=GET_GLOBAL("fish.timer")', null, true);
 Actions.setCell(arr.id, {x:anchor.x+2,y:anchor.y-1,z:anchor.z}, '=GET_GLOBAL("player.score")', null, true);
 
 // Set up event listeners
 Actions.setCell(arr.id, {x:anchor.x,y:anchor.y-2,z:anchor.z}, '=ON_EVENT("CAST","=SET_GLOBAL(\\"fish.state\\",\\"WAITING\\")")', null, true);
 Actions.setCell(arr.id, {x:anchor.x+1,y:anchor.y-2,z:anchor.z}, '=ON_EVENT("TICK","=IF(AND(GET_GLOBAL(\\"fish.state\\")=\\"WAITING\\",GT(GET_GLOBAL(\\"fish.timer\\"),0)),SET_GLOBAL(\\"fish.timer\\",ADD(GET_GLOBAL(\\"fish.timer\\"),-1)))")', null, true);
 Actions.setCell(arr.id, {x:anchor.x+2,y:anchor.y-2,z:anchor.z}, '=ON_EVENT("CATCH","=SET_GLOBAL(\\"player.score\\",ADD(GET_GLOBAL(\\"player.score\\"),1))")', null, true);
 
 Actions.end();
});
tag('GALAXY',['GAME'],(anchor,arr,ast)=>{
 // Initialize GALAXY puzzle game
 Actions.begin();
 
 // Set up game state
 Store.getState().globalState.set('galaxy.active', 1);
 Store.getState().globalState.set('galaxy.gravityWell', `@[${anchor.x+1},${anchor.y+2},${anchor.z},${arr.id}]`);
 
 // Create gravity well
 Actions.setCell(arr.id, anchor, '?? GALAXY PUZZLE', ast.raw, true);
 Actions.setCell(arr.id, {x:anchor.x+1,y:anchor.y+2,z:anchor.z}, '??', null, true);
 
 // Set up physics system
 Actions.setCell(arr.id, {x:anchor.x,y:anchor.y-1,z:anchor.z}, '=ON_EVENT("TICK","=SET_GLOBAL(\\"galaxy.gravityVector\\",VECTOR_TO(GET_PLAYER_FOCUS(),GET_GLOBAL(\\"galaxy.gravityWell\\")))")', null, true);
 Actions.setCell(arr.id, {x:anchor.x+1,y:anchor.y-1,z:anchor.z}, '=GET_GLOBAL("galaxy.gravityVector")', null, true);
 
 // Goal condition
 Actions.setCell(arr.id, {x:anchor.x,y:anchor.y-2,z:anchor.z}, '=IF(EQ(GET_PLAYER_FOCUS(),GET_GLOBAL("galaxy.gravityWell")),"?? WIN!","Navigate to ??")', null, true);
 
 Actions.end();
});
// SOKOBAN puzzle generator and step logic
tag('SOKO_STEP',['GAME','ACTION'],(anchor,arr,ast,tx)=>{
 if(!tx) throw new Error('SOKO_STEP requires an active transaction');
 const memRefArg = ast.args[0];
 const dx = (+Formula.valOf(ast.args[1])|0) || 0;
 const dy = (+Formula.valOf(ast.args[2])|0) || 0;
 if(!memRef || memRef.kind !== 'ref') throw new Error('SOKO_STEP needs memory ref');
 const memVal = Formula.getCellValue(memRef);
 const pos = parseAlt(String(memVal)||'');
 if(!pos) return; // nothing to do
 const boardId = pos.arrId; const px = pos.x; const py = pos.y; const pz = pos.z||0;
 const board = Store.getState().arrays[boardId]; if(!board) return;
 const inBounds=(x,y)=> x>=0 && y>=0 && x<board.size.x && y<board.size.y;
 const at=(x,y)=> inBounds(x,y)? Formula.getCellValue({arrId:boardId,x,y,z:pz}) : ' ';
 const WALL=' ', BOX='??', PLAYER='??', EMPTY='';
 const nx=px+dx, ny=py+dy; const nnx=px+dx*2, nny=py+dy*2;
 const t1 = at(nx,ny);
 if(t1===WALL) return;
 if(t1===BOX){
 const t2 = at(nnx,nny);
 if(t2!==EMPTY) return; // cannot push
 // push box
 Write.set(tx, boardId, {x:nnx,y:nny,z:pz}, { value: BOX, formula:null });
 Write.set(tx, boardId, {x:nx ,y:ny ,z:pz}, { value: PLAYER, formula:null });
 Write.set(tx, boardId, {x:px ,y:py ,z:pz}, { value: EMPTY, formula:null });
 // update memory
 const newRef = `@[${nx},${ny},${pz},${boardId}]`;
 Write.set(tx, memRef.arrId, {x:memRef.x,y:memRef.y,z:memRef.z}, { value:newRef, formula:null });
 return;
 }
 // simple move into empty
 if(t1===EMPTY){
 Write.set(tx, boardId, {x:nx ,y:ny ,z:pz}, { value: PLAYER, formula:null });
 Write.set(tx, boardId, {x:px ,y:py ,z:pz}, { value: EMPTY, formula:null });
 const newRef = `@[${nx},${ny},${pz},${boardId}]`;
 Write.set(tx, memRef.arrId, {x:memRef.x,y:memRef.y,z:memRef.z}, { value:newRef, formula:null });
 }
});

// SOKOBAN2: Diegetic rules via Rules array and dispatcher
tag('SOKO_STEP2',['GAME','ACTION'],(anchor,arr,ast,tx)=>{
 if(!tx) throw new Error('SOKO_STEP2 requires an active transaction');
 const memRefArg = ast.args[0];
 const dx = (+Formula.valOf(ast.args[1])|0) || 0;
 const dy = (+Formula.valOf(ast.args[2])|0) || 0;
 if(!memRef || memRef.kind !== 'ref') throw new Error('SOKO_STEP2 needs memory ref');
 // Set global context for rules
 Store.getState().globalState.set('soko.dx', dx);
 Store.getState().globalState.set('soko.dy', dy);
 Store.getState().globalState.set('soko.memRef', `@[${memRef.x},${memRef.y},${memRef.z},${memRef.arrId}]`);
 // Execute the MOVE rule at the MOVE anchor (stored at Rules[0,0])
 const memVal = Formula.getCellValue(memRef);
 const pos = parseAlt(String(memVal)||''); if(!pos) return;
 const boardId = pos.arrId; const pz = pos.z||0;
 // Find Rules array by convention: same board name + " Rules" or first array with params.sokoRules
 const rulesArr = Object.values(Store.getState().arrays).find(a=>a.params?.sokoRules && a.params?.boardId===boardId);
 if(!rulesArr) { Actions.setCell(arr.id, anchor, '!ERR:No Rules', ast.raw, true); return; }
 // MOVE anchor stored in params
 const mv = rulesArr.params?.moveAnchor || {x:0,y:rulesArr.size.y-1,z:0,arrId:rulesArr.id};
 Formula.executeAt({arrId:mv.arrId,x:mv.x,y:mv.y,z:mv.z}, undefined, tx);
 Actions.setCell(arr.id, anchor, 'SOKO:STEP', ast.raw, true);
});
// Stephen's Sausage Roll (SSR) minimal PoC
// Board movement in depth; avatar is 2 1 footprint aligned along facing
// SSR(boardMem, dir) where dir in {"left","right","forward","back"}
tag('SSR_STEP',['GAME','ACTION'],(anchor,arr,ast,tx)=>{
 if(!tx) throw new Error('SSR_STEP requires an active transaction');
 const memRefArg = ast.args[0];
 // Robust direction parsing: handle identifiers, numbers, quoted strings, or missing arg
 let dirRaw;
 try{ dirRaw = Formula.valOf(ast.args[1]||''); }catch{ dirRaw=''; }
 let dir = String(dirRaw==null? '': dirRaw).trim().toLowerCase().replace(/^['"]|['"]$/g,'');
 if(dir==='0') dir='forward';
 else if(dir==='1') dir='back';
 else if(dir==='2') dir='left';
 else if(dir==='3') dir='right';
 // Fallback: infer direction from controller button position if arg missing/malformed
 if(!['forward','back','left','right'].includes(dir)){
 try{
 const cx = anchor.x, cy = anchor.y; // controller grid is 3x3 with center at (1,1)
 if(cx===1 && cy===2) dir='forward';
 else if(cx===1 && cy===0) dir='back';
 else if(cx===0 && cy===1) dir='left';
 else if(cx===2 && cy===1) dir='right';
 }catch{}
 }
 // Accept ref or absolute address string for memory pointer
 let memRef;
 if(memRefArg && memRefArg.kind==='ref'){
 memRef = memRefArg;
 } else {
 const addrStr = String(Formula.valOf(memRefArg)||'').trim();
 const parsed = parseAlt(addrStr);
 if(parsed){ memRef = {x:parsed.x,y:parsed.y,z:parsed.z,arrId:parsed.arrId, kind:'ref'}; }
 }
 if(!memRef) throw new Error('SSR_STEP needs memory ref');
 const memVal = Formula.getCellValue(memRef);
 const m = /^@\[(\d+),(\d+),(\d+),(\-?\d+)\]\|(\w+)$/i.exec(String(memVal||''));
 if(!m) return; // memory format: @[x,y,z,boardId]|FACING
 let x=+m[1], y=0, z=+m[3], boardId=+m[4]; let facing=String(m[5]||'north').toLowerCase();
 const board = Store.getState().arrays[boardId]; if(!board) return;
 const rotateLeft = f=> ({north:'west', west:'south', south:'east', east:'north'})[f];
 const rotateRight= f=> ({north:'east', east:'south', south:'west', west:'north'})[f];
 const dirVec = f=> ({north:{dx:0,dy:0,dz:-1}, east:{dx:1,dy:0,dz:0}, south:{dx:0,dy:0,dz:1}, west:{dx:-1,dy:0,dz:0}})[f] || {dx:0,dy:0,dz:-1};
 // Sausage registry lives on board.params.sausages: [{id, ax, az, bx, bz, orient:'x'|'z', side:'A'|'B'}]
 board.params = board.params||{}; board.params.sausages = board.params.sausages||[];
 const findSausAt=(qx,qz)=> board.params.sausages.find(s=> (s.ax===qx&&s.az===qz) || (s.bx===qx&&s.bz===qz));
 const occupy=(qx,qz)=> Formula.getCellValue({arrId:boardId,x:qx,y:0,z:qz})!=='';
 const drawBoard=()=>{
 // clear all then redraw sausages and avatar
 // lightweight: only update sausage cells
 board.params.sausages.forEach(s=>{
 Write.set(tx, boardId, {x:s.ax,y:0,z:s.az}, { value:'?', formula:null });
 Write.set(tx, boardId, {x:s.bx,y:0,z:s.bz}, { value:(s.side==='A'?'?':'?'), formula:null });
 });
 };
 if(dir==='left' || dir==='right'){
 // Tank-style rotation around the HEAD (player) cell.
 // Head stays fixed; tail moves to the orthogonal cell based on new facing.
 const newFacing = (dir==='left') ? rotateLeft(facing) : rotateRight(facing);
 const vnew = dirVec(newFacing);
 const ntx = x - vnew.dx, ntz = z - vnew.dz; // new tail position relative to head
 // bounds check for new tail
 if(ntx<0||ntx>=board.size.x||ntz<0||ntz>=board.size.z){ return; }
 // block rotation if target tail cell is occupied (simple rule)
 if(occupy(ntx,ntz)){
 const hit = findSausAt(ntx,ntz);
 // For now, do not push/roll on rotation; require free orthogonal cell
 if(hit){ return; }
 return;
 }
 facing = newFacing; // keep head at (x,z)
 }
 else if(dir==='forward' || dir==='back'){
 const v = dirVec(facing); const step = (dir==='forward'?1:-1);
 // Check interaction with sausages
 const nx=x+v.dx*step, nz=z+v.dz*step;
 const hit = findSausAt(nx,nz);
 if(hit){
 // Determine hit from side or short end
 const alongX = (hit.orient==='x');
 const sideHit = (alongX && v.dx===0) || (!alongX && v.dz===0);
 if(sideHit){
 // roll perpendicular by one cell and flip side
 const pdx = alongX? 0 : v.dx|| (step>0?1:-1); // if facing north/south roll in x
 const pdz = alongX? (v.dz|| (step>0?1:-1)) : 0;
 const tx1 = hit.ax+pdx, tz1 = hit.az+pdz;
 const tx2 = hit.bx+pdx, tz2 = hit.bz+pdz;
 if(tx1>=0&&tx1<board.size.x&&tz1>=0&&tz1<board.size.z&&tx2>=0&&tx2<board.size.x&&tz2>=0&&tz2<board.size.z && !occupy(tx1,tz1) && !occupy(tx2,tz2)){
 // apply roll
 Write.set(tx, boardId, {x:hit.ax,y:0,z:hit.az}, { value:'', formula:null });
 Write.set(tx, boardId, {x:hit.bx,y:0,z:hit.bz}, { value:'', formula:null });
 hit.ax=tx1; hit.az=tz1; hit.bx=tx2; hit.bz=tz2; hit.side = (hit.side==='A'?'B':'A');
 drawBoard();
 }
 } else {
 // push along its orientation (short-end push)
 const odx = alongX? (v.dx!==0? v.dx*step : (hit.bx>hit.ax?1:-1)) : 0;
 const odz = !alongX? (v.dz!==0? v.dz*step : (hit.bz>hit.az?1:-1)) : 0;
 const nx1=hit.ax+odx, nz1=hit.az+odz, nx2=hit.bx+odx, nz2=hit.bz+odz;
 if(nx1>=0&&nx1<board.size.x&&nz1>=0&&nz1<board.size.z&&nx2>=0&&nx2<board.size.x&&nz2>=0&&nz2<board.size.z && !occupy(nx1,nz1) && !occupy(nx2,nz2)){
 Write.set(tx, boardId, {x:hit.ax,y:0,z:hit.az}, { value:'', formula:null });
 Write.set(tx, boardId, {x:hit.bx,y:0,z:hit.bz}, { value:'', formula:null });
 hit.ax=nx1; hit.az=nz1; hit.bx=nx2; hit.bz=nz2;
 drawBoard();
 }
 }
 // avatar advances into previously occupied spot only if now clear
 if(!occupy(nx,nz)){ x=nx; z=nz; }
 } else {
 x = nx; z = nz;
 }
 }
 // Constrain to board
 x=Math.max(0,Math.min(board.size.x-1,x)); y=Math.max(0,Math.min(board.size.y-1,y)); z=Math.max(0,Math.min(board.size.z-1,z));
 // Clear previous avatar footprint (both head and tail regardless of turn or move)
 try{
 const old = /^@\[(\d+),(\d+),(\d+),(\-?\d+)\]/.exec(String(memVal))||[];
 const ox=+old[1], oy=+old[2], oz=+old[3];
 if(Number.isFinite(ox)){
 // Remove old head cell
 Write.set(tx, boardId, {x:ox,y:0,z:oz}, { value:'', formula:null });
 // Remove old tail cell; determine old facing from previous memory
 const mf = /^@\[(\d+),(\d+),(\d+),(\-?\d+)\]\|(\w+)$/i.exec(String(memVal||''));
 const prevF = mf ? String(mf[5]||'north').toLowerCase() : 'north';
 const pv = dirVec(prevF);
 Write.set(tx, boardId, {x:ox - pv.dx, y:0, z:oz - pv.dz}, { value:'', formula:null });
 }
 }catch{}
 // Draw 2 1 avatar: head at (x,y,z), tail one cell behind facing
 const v2 = dirVec(facing);
 Write.set(tx, boardId, {x:x,y:0,z:z}, { value:'??', formula:null });
 Write.set(tx, boardId, {x:x - v2.dx, y:0, z:z - v2.dz}, { value:'-', formula:null });
 // Update memory
 const newRef = `@[${x},${y},${z},${boardId}]|${facing}`;
 Write.set(tx, memRef.arrId, {x:memRef.x,y:memRef.y,z:memRef.z}, { value:newRef, formula:null });
 Actions.setCell(arr.id, anchor, `SSR:${facing}`, ast.raw, true);
});

tag('SSR',['GAME','META'],(anchor,arr,ast)=>{
 try{
 // Build a compact 3D board with depth emphasis
 const size = {x:8,y:1,z:8};
 const board = Actions.createArray({name:'SSR Board', size, hidden:false});
 const mem = Actions.createArray({name:'SSR Mem', size:{x:2,y:1,z:1}, hidden:true});
 const ctrl = Actions.createArray({name:'SSR Ctrl', size:{x:3,y:3,z:1}, hidden:false});
 Actions.begin();
 // Seed avatar at center facing north
 const start = {x:Math.floor(size.x/2), y:0, z:Math.floor(size.z/2)};
 Actions.setCell(board.id, start, '??', null, true);
 Actions.setCell(board.id, {x:start.x, y:start.y, z:start.z+1}, '-', null, true); // tail behind (south when facing north)
 Actions.setCell(mem.id, {x:0,y:0,z:0}, `@[${start.x},0,${start.z},${board.id}]|north`, null, true);
 // Place a demo sausage (2x1) horizontal, side A
 board.params = board.params||{}; board.params.sausages=[{id:1, ax:start.x+2, az:start.z, bx:start.x+3, bz:start.z, orient:'x', side:'A'}];
 // draw sausage
 Actions.setCell(board.id, {x:start.x+2,y:0,z:start.z}, '?', null, true);
 Actions.setCell(board.id, {x:start.x+3,y:0,z:start.z}, '?', null, true);
 // Controller arrows (depth-oriented)
 Actions.setCell(ctrl.id,{x:1,y:2,z:0},'?',null,true);
 Actions.setCell(ctrl.id,{x:0,y:1,z:0},'?',null,true);
 Actions.setCell(ctrl.id,{x:1,y:1,z:0},'??',null,true);
 Actions.setCell(ctrl.id,{x:2,y:1,z:0},'?',null,true);
 Actions.setCell(ctrl.id,{x:1,y:0,z:0},'?',null,true);
 // Memory ref stored at [1,1,1] within mem array by convention
 const mref = `@[1,1,1,${mem.id}]`;
 // Bind ONCLICK actions directly so interactivity is immediate
 const bind = (x,y,dir)=>{
 const call = `=SSR_STEP(${mref},"${dir}")`;
 const enc = btoa(call);
 const txBind = Write.start('ssr.onclick','bind');
 const prev = Formula.getCell({arrId:ctrl.id,x,y,z:0});
 const prevMeta = normalizeMetaKeys(prev?.meta||{});
 prevMeta.on_click = `B64:${enc}`;
 Write.set(txBind, ctrl.id, {x,y,z:0}, { value: prev?.value ?? (dir==='forward'?'?':dir==='back'?'?':dir==='left'?'?':'?'), formula: null, meta:prevMeta });
 Write.commit(txBind);
 };
 bind(1,2,'forward');
 bind(1,0,'back');
 bind(0,1,'left');
 bind(2,1,'right');
 // remove extra ONCLICK clones; handled in bind()
 Actions.end();
 // Smart docking relative to source array with 1-cell gap (right of source)
 (function smartDock(){
 const src = Store.getState().arrays[anchor.arrId] || arr;
 const gap = 1;
 const srcOff = src.offset||{x:0,y:0,z:0};
 // Align Z centers and Y centers; place board to the right of source with one cell gap
 const boardX = srcOff.x + (src.size.x + board.size.x)/2 + gap;
 const boardY = srcOff.y;
 const boardZ = srcOff.z;
 Scene.setArrayOffset(board,{x:boardX,y:boardY,z:boardZ});
 // Place controller to the right of board with the same gap, z-aligned
 const ctrlX = boardX + (board.size.x + ctrl.size.x)/2 + gap;
 Scene.setArrayOffset(ctrl,{x:ctrlX,y:boardY,z:boardZ});
 })();
 // Finalize: mark clickable now and force render/refresh without needing a reload
 try{
 Object.values(ctrl.chunks||{}).forEach(ch=> ch.cells.forEach(c=>{
 if(c.value){
 const meta = normalizeMetaKeys(c.meta||{});
 meta.on_click = meta.on_click || '';
 c.meta = meta;
 }
 }));
 }catch{}
 Scene.renderArray(board); Scene.renderArray(ctrl);
 // Stamp anchor without triggering immediate recompute loop (prevents duplicate creation)
 const tx=Write.start('ssr.status','SSR status');
 Write.set(tx, arr.id, anchor, { value:`SSR:#${board.id}`, formula: ast.raw, meta:{skip_recompute:true} });
 Write.commit(tx);
 }catch(e){ Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true); }
});
tag('SOKOBAN2',['GAME','META'],(anchor,arr,ast)=>{
 try{
 const size = {x:10,y:8,z:1};
 const board = Actions.createArray({name:'Sokoban2', size, hidden:false});
 const mem = Actions.createArray({name:'SokoMem2', size:{x:2,y:1,z:1}, hidden:true});
 const rules = Actions.createArray({name:'SokoRules', size:{x:4,y:6,z:1}, hidden:true});
 const ctrl = Actions.createArray({name:'SokoCtrl2', size:{x:3,y:3,z:1}, hidden:false});
 const PSTART = {x:2,y:2,z:0};
 const BOX='??', WALL=' ', PLAYER='??', GOAL=' ';
 Actions.begin();
 // walls border
 for(let x=0;x<size.x;x++){ Actions.setCell(board.id,{x,y:size.y-1,z:0},WALL,null,true); Actions.setCell(board.id,{x,y:0,z:0},WALL,null,true); }
 for(let y=0;y<size.y;y++){ Actions.setCell(board.id,{x:0,y,z:0},WALL,null,true); Actions.setCell(board.id,{x:size.x-1,y,z:0},WALL,null,true); }
 // place player, box and goal
 Actions.setCell(board.id,PSTART,PLAYER,null,true);
 Actions.setCell(board.id,{x:4,y:2,z:0},BOX,null,true);
 Actions.setCell(board.id,{x:7,y:2,z:0},GOAL,null,true);
 // memory: player ref string at (0,0)
 Actions.setCell(mem.id,{x:0,y:0,z:0},`@[${PSTART.x},${PSTART.y},${PSTART.z},${board.id}]`,null,true);
 // Rules array params and MOVE rule (diegetic formulas)
 rules.params = { ...(rules.params||{}), sokoRules:true, boardId:board.id };
 const mvAnchor = {x:0,y:rules.size.y-1,z:0};
 rules.params.moveAnchor = {arrId:rules.id, ...mvAnchor};
 const memStr = `@[0,0,0,${mem.id}]`;
 // Compute current and next positions
 const curRef = `=OFFSET(${memStr},0,0,0)`;
 const dxRef = `=GET_GLOBAL("soko.dx")`;
 const dyRef = `=GET_GLOBAL("soko.dy")`;
 Actions.setCell(rules.id, {x:0,y:rules.size.y-1,z:0}, 'MOVE', `=DO(
 "=SET_GLOBAL(\"soko.pos\", ${curRef})",
 "=SET_GLOBAL(\"soko.next\", OFFSET(GET_GLOBAL(\\\"soko.pos\\\"), ${dxRef}, ${dyRef}, 0))",
 "=SET_GLOBAL(\"soko.nnext\", OFFSET(GET_GLOBAL(\\\"soko.pos\\\"), MUL(${dxRef},2), MUL(${dyRef},2), 0))",
 "=IF(EQ(GET_GLOBAL(\"soko.next\"), \" \"), \"BLOCK\", \"OK\")",
 "=IF(EQ(GET_GLOBAL(\"soko.next\"), \"??\"), IF(EQ(GET_GLOBAL(\"soko.nnext\"), \"\"), DO(\"=SET(GET_GLOBAL(\\\"soko.nnext\\\"), \"??\")\", \"=SET(GET_GLOBAL(\\\"soko.next\\\"), \"??\")\", \"=SET(GET_GLOBAL(\\\"soko.pos\\\"), \"\" )\", \"=SET(${memStr}, GET_GLOBAL(\\\"soko.next\\\"))\"), \"BLOCK\"), \"OK\")",
 "=IF(EQ(GET_GLOBAL(\"soko.next\"), \"\"), DO(\"=SET(GET_GLOBAL(\\\"soko.next\\\"), \"??\")\", \"=SET(GET_GLOBAL(\\\"soko.pos\\\"), \"\" )\", \"=SET(${memStr}, GET_GLOBAL(\\\"soko.next\\\"))\"), \"OK\")"
 )`, true);
 // controller arrows using SOKO_STEP2(memRef,dx,dy)
 const mref = memStr;
 Actions.setCell(ctrl.id,{x:1,y:2,z:0},'?',null,true);
 Actions.setCell(ctrl.id,{x:0,y:1,z:0},'?',null,true);
 Actions.setCell(ctrl.id,{x:2,y:1,z:0},'?',null,true);
 Actions.setCell(ctrl.id,{x:1,y:0,z:0},'?',null,true);
 Actions.setCell(ctrl.id,{x:1,y:2,z:0}, '?', `=ON_SELECT(SELF(), "=SOKO_STEP2(${mref},0,1)")`, true);
 Actions.setCell(ctrl.id,{x:0,y:1,z:0}, '?', `=ON_SELECT(SELF(), "=SOKO_STEP2(${mref},-1,0)")`, true);
 Actions.setCell(ctrl.id,{x:2,y:1,z:0}, '?', `=ON_SELECT(SELF(), "=SOKO_STEP2(${mref},1,0)")`, true);
 Actions.setCell(ctrl.id,{x:1,y:0,z:0}, '?', `=ON_SELECT(SELF(), "=SOKO_STEP2(${mref},0,-1)")`, true);
 Actions.end();
 // Dock controller near board
 const pos = dockOffsetFor(board,'east',1.0);
 Scene.setArrayOffset(ctrl,pos);
 Actions.setCell(arr.id, anchor, `Sokoban2:#${board.id}`, ast.raw, true);
 }catch(e){ Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true); }
});
tag('SOKOBAN',['GAME','META'],(anchor,arr,ast)=>{
 // Generate a tiny Sokoban board, memory, and controller
 try{
 const size = {x:10,y:8,z:1};
 const board = Actions.createArray({name:'Sokoban', size, hidden:false});
 const mem = Actions.createArray({name:'SokoMem', size:{x:2,y:1,z:1}, hidden:true});
 const ctrl = Actions.createArray({name:'SokoCtrl', size:{x:3,y:3,z:1}, hidden:false});
 const PSTART = {x:2,y:2,z:0};
 const BOX='??', WALL=' ', PLAYER='??', GOAL=' ';
 Actions.begin();
 // walls border
 for(let x=0;x<size.x;x++){ Actions.setCell(board.id,{x,y:size.y-1,z:0},WALL,null,true); Actions.setCell(board.id,{x,y:0,z:0},WALL,null,true); }
 for(let y=0;y<size.y;y++){ Actions.setCell(board.id,{x:0,y,z:0},WALL,null,true); Actions.setCell(board.id,{x:size.x-1,y,z:0},WALL,null,true); }
 // place player, box and goal
 Actions.setCell(board.id,PSTART,PLAYER,null,true);
 Actions.setCell(board.id,{x:4,y:2,z:0},BOX,null,true);
 Actions.setCell(board.id,{x:7,y:2,z:0},GOAL,null,true);
 // memory: player ref string at (0,0)
 Actions.setCell(mem.id,{x:0,y:0,z:0},`@[${PSTART.x},${PSTART.y},${PSTART.z},${board.id}]`,null,true);
 // controller arrows with ON_SELECT to call SOKO_STEP(memRef,dx,dy)
 const mref = `@[0,0,0,${mem.id}]`;
 Actions.setCell(ctrl.id,{x:1,y:2,z:0},'?',null,true);
 Actions.setCell(ctrl.id,{x:0,y:1,z:0},'?',null,true);
 Actions.setCell(ctrl.id,{x:2,y:1,z:0},'?',null,true);
 Actions.setCell(ctrl.id,{x:1,y:0,z:0},'?',null,true);
 Actions.setCell(ctrl.id,{x:1,y:2,z:0}, '?', `=ON_SELECT(SELF(), "=SOKO_STEP(${mref},0,1)")`, true);
 Actions.setCell(ctrl.id,{x:0,y:1,z:0}, '?', `=ON_SELECT(SELF(), "=SOKO_STEP(${mref},-1,0)")`, true);
 Actions.setCell(ctrl.id,{x:2,y:1,z:0}, '?', `=ON_SELECT(SELF(), "=SOKO_STEP(${mref},1,0)")`, true);
 Actions.setCell(ctrl.id,{x:1,y:0,z:0}, '?', `=ON_SELECT(SELF(), "=SOKO_STEP(${mref},0,-1)")`, true);
 Actions.end();
 // Dock controller near board
 const pos = dockOffsetFor(board,'east',1.0);
 Scene.setArrayOffset(ctrl,pos);
 // Write to anchor without triggering immediate recompute loop
 const tx=Write.start('sokoban.status','SOKOBAN status');
 Write.set(tx, arr.id, anchor, { value:`Sokoban:#${board.id}`, formula: ast.raw, meta:{skip_recompute:true} });
 Write.commit(tx);
 }catch(e){ Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true); }
});

tag('VIEW_MODE',['SCENE'],(anchor,arr,ast)=>{
 const mode=String(valOf(ast.args[0])||'3d').toLowerCase(); // '3d', '2d', 'ortho', 'isometric'
 const distance=+valOf(ast.args[1])||10; // camera distance
 Scene.setViewMode(arr,{mode,distance});
 Actions.setCell(arr.id,anchor,`View:${mode}/${distance}`,ast.raw,true);
});
tag('SANDBOX',['META'],(anchor,arr,ast)=>{
 if(Store.getState().arrays[2]){
 Actions.setCell(arr.id,anchor,'Sandbox:EXISTS',ast.raw,true);
 return;
 }
 const sb = Actions.createArray({id:2,name:'Sandbox', size:{x:12,y:8,z:12}, hidden:false});
 Actions.setCell(arr.id,anchor,`Sandbox:OK (#${sb.id})`,ast.raw,true);
 Scene.centerOnArray(sb);
});

// UI Control Functions
tag('UI_CONTROL',['META'],(anchor,arr,ast)=>{
 const controlType=String(valOf(ast.args[0])||'').toLowerCase(); // 'insert_buttons', 'function_drawer', etc.
 const state=!!valOf(ast.args[1]); // true/false
 arr.uiControls = arr.uiControls || {};
 arr.uiControls[controlType] = state;
 Actions.setCell(arr.id,anchor,`UI:${controlType}=${state}`,ast.raw,true);
});

// MINIMIZE(flag): 1 to minimize the 2D viewport, 0 to restore to previous position
tag('MINIMIZE',["ACTION"],(anchor,arr,ast)=>{
 try{
 const flag = !!Formula.valOf(ast.args[0]);
 const sheet = document.getElementById('sheet');
 if(!sheet){ Actions.setCell(arr.id,anchor,'!ERR:NO_SHEET',ast.raw,true); return; }
 if(flag){
 if(!sheet.dataset.prevTransform){
 sheet.dataset.prevLeft = sheet.style.left||'';
 sheet.dataset.prevTop = sheet.style.top||'';
 sheet.dataset.prevBottom = sheet.style.bottom||'';
 sheet.dataset.prevTransform = sheet.style.transform||'';
 sheet.dataset.prevOpacity = sheet.style.opacity||'';
 sheet.dataset.prevPointer = sheet.style.pointerEvents||'';
 }
 const base=(document.body.classList.contains('touch') && sheet.dataset.touchFreed!=='1')?'translateX(-50%) ':'';
 sheet.style.transform = `${base}translateY(12px) scale(0.92)`;
 sheet.style.opacity='0.0';
 sheet.style.pointerEvents='none';
 } else {
 if(sheet.dataset.prevTransform!==undefined){
 sheet.style.left = sheet.dataset.prevLeft;
 sheet.style.top = sheet.dataset.prevTop;
 sheet.style.bottom = sheet.dataset.prevBottom;
 sheet.style.transform = sheet.dataset.prevTransform;
 sheet.style.opacity = sheet.dataset.prevOpacity;
 sheet.style.pointerEvents = sheet.dataset.prevPointer;
 delete sheet.dataset.prevLeft; delete sheet.dataset.prevTop; delete sheet.dataset.prevBottom;
 delete sheet.dataset.prevTransform; delete sheet.dataset.prevOpacity; delete sheet.dataset.prevPointer;
 } else {
 sheet.style.opacity='1'; sheet.style.pointerEvents='auto';
 if(document.body.classList.contains('touch')){
 sheet.style.transform = (sheet.dataset.touchFreed==='1') ? 'none' : 'translateX(-50%)';
 } else {
 sheet.style.transform='';
 }
 }
 }
 Actions.setCell(arr.id, anchor, `Minimize:${flag?1:0}`, ast.raw, true);
 }catch(e){ Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true); }
});
// ON_SELECT: register a per-cell (or range) selection hook
// =ON_SELECT([rangeOrRef], actionFormulaString)
// The action must be a *string* and should start with '='.
tag('ON_SELECT',['META'],(anchor,arr,ast)=>{
 // Turn off hook for this anchor
 if(ast.args.length===1 && typeof ast.args[0]==='string'){
 const t=String(ast.args[0]||'').toLowerCase();
 if(t==='off'||t==='none'||t==='0'||t==='false'){
 arr.on_select_hooks = ensureOnSelectHooks(arr).filter(h=>!(h.anchor.x===anchor.x && h.anchor.y===anchor.y && h.anchor.z===anchor.z));
 Actions.setCell(arr.id, anchor, 'on_select:OFF', ast.raw, true);
 return;
 }
 }

 let rangeArg=null;
 // We DO NOT valOf() the action; we store it as a literal formula string.
 const rawAction = (ast.args.length>=2 ? ast.args[1] : ast.args[0]);
 let action = (typeof rawAction === 'string') ? rawAction : String(rawAction||'');
 if(action && action[0] !== '=') action = `=${action}`; // normalize to formula string

 // Build cell set for matching
 const cells = new Set();
 if(ast.args.length>=2) rangeArg = ast.args[0];
 if(rangeArg && rangeArg.kind==='range'){
 rangeArg.cells.forEach(c=>cells.add(`${c.x},${c.y},${c.z}`));
 } else if(rangeArg && rangeArg.kind==='ref'){
 cells.add(`${rangeArg.x},${rangeArg.y},${rangeArg.z}`);
 } else {
 cells.add(`${anchor.x},${anchor.y},${anchor.z}`); // default self
 }

 // replace any existing hook at this anchor
 const hooks = ensureOnSelectHooks(arr).filter(h=>!(h.anchor.x===anchor.x && h.anchor.y===anchor.y && h.anchor.z===anchor.z));
 hooks.push({ anchor:{x:anchor.x,y:anchor.y,z:anchor.z}, cells, action });
 arr.on_select_hooks = hooks;

 // Silent registration; do not stamp the cell
});
tag('OVERLAP',['SCENE'],(anchor,arr,ast)=>{
 const targetArr=ast.args[0]; // array ref or ID
 const mode=String(valOf(ast.args[1])||'detect').toLowerCase(); // 'detect', 'count', 'list'
 // Placeholder: check if this array's cells overlap with target array's cells in 3D space
 const overlaps = 0; // TODO: implement actual overlap detection
 Actions.setCell(arr.id,anchor,`Overlap:${overlaps}`,ast.raw,true);
});
tag('EVALUATE',['META'],(anchor,arr,ast)=>{
 const condition=String(valOf(ast.args[0])); // formula to evaluate
 const result=!!valOf(ast.args[1]); // expected result
 // Simple condition evaluator for UI state control
 Actions.setCell(arr.id,anchor,result?'EVAL:TRUE':'EVAL:FALSE',ast.raw,true);
});

tag('IS_FOCUS_ARRAY',['PURE'],(anchor,arr,ast)=>{
 const targetId=ast.args[0] ? +valOf(ast.args[0]) : arr.id;
 const s=Store.getState().selection;
 const isFocused = s.arrayId === targetId;
 Actions.setCell(arr.id, anchor, isFocused?1:0, ast.raw, true);
});

// Diegetic UI Functions
// Note: A single TOAST(action) exists above (ACTION tag). Remove duplicate META variant to avoid override.
tag('AXES',['SCENE'],(anchor,arr,ast)=>{
 const m = String(Formula.valOf(ast.args[0] ?? '1')).toLowerCase();
 arr.axesVisible = (m==='1'||m==='true'||m==='on') ? true :
 (m==='0'||m==='false'||m==='off') ? false : undefined; // "auto"
 Scene.syncVisibility(arr);
 Actions.setCell(arr.id, anchor, 
 `Axes:${arr.axesVisible===undefined?'AUTO':(arr.axesVisible?'ON':'OFF')}`,
 ast.raw, true
 );
});
tag('FOCUS_SET',['ACTION'],(anchor,arr,ast)=>{
 const s = Store.getState().selection;
 if(!s?.arrayId || !s.focus) throw new Error('No focus');
 
 // Support both old and new syntax: FOCUS_SET(content) or FOCUS_SET(mode, content)
 let mode = 'text', content = '';
 if(ast.args.length === 1){
 content = String(Formula.valOf(ast.args[0]||''));
 mode = content.startsWith('=') ? 'formula' : 'text';
 } else {
 mode = String(Formula.valOf(ast.args[0]||'text')).toLowerCase();
 content = String(Formula.valOf(ast.args[1]||''));
 }
 
 if(mode === 'clipboard'){
 // Copy content to clipboard
 try {
 navigator.clipboard.writeText(content);
 Actions.setCell(arr.id, anchor, `?? Copied: ${content.slice(0,20)}`, ast.raw, true);
 showToast('Copied to clipboard');
 } catch(e) {
 Actions.setCell(arr.id, anchor, '?? Copy failed', ast.raw, true);
 showToast('Copy failed');
 }
 return;
 }
 
 if(mode === 'formula' || content.startsWith('=')){
 Formula.setFormula({arrId:s.arrayId, ...s.focus}, content);
 Formula.executeAt({arrId:s.arrayId, ...s.focus});
 } else {
 Actions.setCell(s.arrayId, s.focus, content, null, true);
 }
 
 Actions.setCell(arr.id, anchor, 'OK', ast.raw, true);
});

// COPY(text): write text to clipboard (callable, composable)
tag('COPY',['IO','ACTION'],(anchor,arr,ast)=>{
 const text = String(Formula.valOf(ast.args[0]||''));
 try{
 navigator.clipboard.writeText(text);
 showToast('Copied to clipboard');
 }catch(e){
 showToast('Copy failed');
 }
});

// PREVIEW(inArray[, overworld[, scope]]) binary toggles for enabling animations
// inArray: 1/0 to show per-cell overlays and drive in-array timed plans
// overworld: 1/0 to enable global (3D) array movement
tag('PREVIEW',["SCENE"],(anchor,arr,ast)=>{
 try{
 const enableIn = !!Formula.valOf(ast.args[0]||0);
 const enable3D = !!Formula.valOf(ast.args[1]||0);
 let scopeConfig = null;
 try{ scopeConfig = parseArrayScopeArg(ast.args[2], anchor, arr); }
 catch{}
 let T = (typeof Scene!=='undefined' && Scene.ensureTimedState) ? Scene.ensureTimedState(arr) : null;
 if(!T){
 try{
 arr.params = arr.params || {};
 arr.params.timed = arr.params.timed || { ticks:60, reverse:false, reverseTicks:null, repeat:false, t:0, dir:1, previewInArray:false, plan:[], baseOffset:null, baseQuat:null, overlay:null };
 T = arr.params.timed;
 }catch{}
 }
 if(T){
 // Build plan first, but always enable local preview; show placeholder if plan empty
 if(enableIn){
 try{ T.plan = []; }catch{}
 try{ Scene.buildTimedPlanFromArray?.(arr); }catch{}
 try{ arr._previewBursts = new Set(); }catch{}
 T.previewInArray = true;
 // Default looping animation if not configured by TIMED_TRANSLATION
 if(!(T.ticks>0)){ T.ticks = 120; }
 if(T.repeat==null) T.repeat = true;
 if(T.reverse==null) T.reverse = false;
 T.t = 0; T.dir = 1;
 } else {
 T.previewInArray = false;
 if(arr._previewBursts){ try{ arr._previewBursts.clear(); }catch{} arr._previewBursts = null; }
 }
 }
 // The rest: overlay/mask handling unchanged
 if(enableIn && T){
 if(!T.overlay){
 T.overlay = { group:new THREE.Group(), cells:new Map() };
 try{ if(arr._frame){ arr._frame.add(T.overlay.group); } else { Scene.addToScene?.(T.overlay.group); } }catch{ try{ Scene.addToScene?.(T.overlay.group); }catch{} }
 }
 try{ if(typeof Scene!=='undefined' && Scene.maskArrayForPreview) Scene.maskArrayForPreview(arr, true); }catch{}
 } else if(T) {
 if(T.overlay){ try{ T.overlay.group.parent?.remove(T.overlay.group); }catch{ try{ Scene.removeFromScene?.(T.overlay.group); }catch{} } T.overlay=null; }
 try{ if(typeof Scene!=='undefined' && Scene.maskArrayForPreview) Scene.maskArrayForPreview(arr, false); }catch{}
 }
 const G = (typeof Scene!=='undefined' && Scene.ensureTimed3D) ? Scene.ensureTimed3D() : ((Store.getState().scene.timed3D=Store.getState().scene.timed3D||{configured:false,preview:false}), Store.getState().scene.timed3D);
 const was3DPreviewing = !!G?.preview;
 const arrIdRaw = Number.isFinite(arr?.id) ? arr.id : (Number.isFinite(anchor?.arrId) ? anchor.arrId : null);
 const arrId = Number.isFinite(arrIdRaw) ? Math.trunc(arrIdRaw) : null;
 const normalizedScope = scopeConfig ? {
 mode: scopeConfig.mode || 'host',
 ids: Array.isArray(scopeConfig.ids) ? scopeConfig.ids.map(n=> Number.isFinite(+n)?(Math.trunc(+n)):null).filter(n=>n!=null) : []
 } : null;
 if(G){
 const sanitizeIds=(list)=> Array.from(new Set((Array.isArray(list)?list:[]).map(n=> Number.isFinite(+n)?(Math.trunc(+n)):null).filter(n=>n!=null)));
 let activeIds = sanitizeIds(G.activeHostIds);
 if(enable3D){
 if(arrId!=null && !activeIds.includes(arrId)) activeIds.push(arrId);
 G.activeHostIds = activeIds;
 if(normalizedScope){
 G.scope = normalizedScope;
 } else if(G.scope && G.scope.mode === 'all'){
 // keep existing 'all' scope
 } else {
 const merged = new Set(activeIds);
 if(G.scope && (G.scope.mode === 'limit' || G.scope.mode === 'host')){
 sanitizeIds(G.scope.ids).forEach(id=>merged.add(id));
 }
 if(merged.size===0 && arrId!=null) merged.add(arrId);
 G.scope = { mode:'limit', ids:Array.from(merged) };
 }
 if(arrId!=null){ G.hostId = arrId; }
 else if(Number.isFinite(+G.hostId)){ G.hostId = Math.trunc(+G.hostId); }
 else if(activeIds.length){ G.hostId = activeIds[0]; }
 G.preview = true;
 } else {
 if(arrId!=null){
 activeIds = activeIds.filter(id=>id!==arrId);
 }
 G.activeHostIds = activeIds;
 if(normalizedScope){
 G.scope = normalizedScope;
 } else if(G.scope && G.scope.mode === 'all'){
 // keep existing 'all' scope
 } else {
 G.scope = activeIds.length ? { mode:'limit', ids:[...activeIds] } : null;
 }
 if(activeIds.length){
 const currentHost = Number.isFinite(+G.hostId) ? Math.trunc(+G.hostId) : null;
 if(currentHost!=null && activeIds.includes(currentHost)){ G.hostId = currentHost; }
 else { G.hostId = activeIds[0]; }
 G.preview = true;
 } else {
 G.hostId = null;
 G.preview = false;
 }
 }
 }
 const previewStillActive = !!G?.preview;
 // If global preview transitioned to OFF, immediately restore arrays to their captured base transforms
 if(G && was3DPreviewing && !previewStillActive){
 try{
 const arrays = Object.values(Store.getState().arrays||{});
 arrays.forEach(a=>{
 try{
 const T = (typeof Scene!=='undefined' && Scene.ensureTimedState) ? Scene.ensureTimedState(a) : (a.params&&a.params.timed);
 if(T){
 // Restore base transforms if captured during preview
 if(T.baseOffset){ try{ Scene.setArrayOffset?.(a, {x:T.baseOffset.x,y:T.baseOffset.y,z:T.baseOffset.z}, {interactive:true}); }catch{} }
 if(a._frame && T.baseQuat){ try{ a._frame.quaternion.copy(T.baseQuat); }catch{} }
 T.t = 0; T.dir = 1;
 // Remove overlays and unmask content
 try{ if(T.overlay){ T.overlay.group.parent?.remove(T.overlay.group); T.overlay=null; } }catch{}
 }
 try{ if(typeof Scene!=='undefined' && Scene.maskArrayForPreview) Scene.maskArrayForPreview(a, false); }catch{}
 }catch{}
 });
 // Reset wait counter so next enable starts fresh
 try{ G._waitCounter = 0; }catch{}
 try{ G.activeHostIds = []; }catch{}
 }catch{}
 }
 Actions.setCell(arr.id, anchor, `Preview:${enableIn?1:0}/${enable3D?1:0}`, ast.raw, true);
 }catch(e){ Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true); }
});

// TIMED_TRANSLATION(ticks, repeat, reverse?, reverseTicks?) config only, no animation
tag('TIMED_TRANSLATION',["SCENE"],(anchor,arr,ast)=>{
 try{
 const ticks = (+Formula.valOf(ast.args[0]||60))|0;
 const repeat = !!Formula.valOf(ast.args[1]||0);
 const reverse = !!Formula.valOf(ast.args[2]||0);
 const reverseTicks = (ast.args[3]!==undefined) ? ((+Formula.valOf(ast.args[3])|0) || ticks) : null;
 const smooth = !!((+Formula.valOf(ast.args[4]||0))|0);
 const cfgFn = (typeof Scene!=='undefined' && Scene.configTimed) ? Scene.configTimed : (a,c)=>{ try{ /* fallback no-op */ }catch{} };
 cfgFn(arr, { ticks, repeat, reverse, reverseTicks, smooth });
 Actions.setCell(arr.id, anchor, `Timed:cfg(${ticks})`, ast.raw, true);
 }catch(e){ Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true); }
});

// 3D_TIMED_TRANSLATION(ticks, repeat, reverse?, reverseTicks?, smooth?, scope?) global config
tag('3D_TIMED_TRANSLATION',["SCENE"],(anchor,arr,ast)=>{
 try{
 const ticks = (+Formula.valOf(ast.args[0]||60))|0;
 const repeat = !!Formula.valOf(ast.args[1]||0);
 const reverse = !!Formula.valOf(ast.args[2]||0);
 const reverseTicks = (ast.args[3]!==undefined) ? ((+Formula.valOf(ast.args[3])|0) || ticks) : null;
 const smooth = !!((+Formula.valOf(ast.args[4]||0))|0);
 let scopeConfig;
 try{ scopeConfig = parseArrayScopeArg(ast.args[5], anchor, arr); }
 catch{ scopeConfig = parseArrayScopeArg(null, anchor, arr); }
 // Robust ensure timed3D state
 let G = null;
 try{ if(typeof Scene!=='undefined' && Scene.ensureTimed3D) G = Scene.ensureTimed3D(); }catch{}
 if(!G){
 const S = Store.getState();
 const sceneState = S.scene || {};
 if(!sceneState.timed3D){ sceneState.timed3D = { configured:false, ticks:60, repeat:false, reverse:false, reverseTicks:null, t:0, dir:1, preview:false, smooth:false }; }
 Store.setState(s=>({ scene: { ...s.scene, timed3D: sceneState.timed3D } }));
 G = sceneState.timed3D;
 }
 G.configured = true; G.ticks=Math.max(1,ticks|0); G.repeat=repeat; G.reverse=reverse; G.reverseTicks=reverseTicks; G.t=0; G.dir=1; G.smooth = smooth;
 G.hostId = arr?.id ?? anchor?.arrId ?? null;
 if(scopeConfig){
 G.scope = { mode: scopeConfig.mode, ids: Array.from(scopeConfig.ids||[]) };
 }
 Actions.setCell(arr.id, anchor, `3D_Timed:cfg(${ticks})`, ast.raw, true);
 }catch(e){ Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true); }
});

// OVERLAP(sortAscDesc, metric, mergeMode, alwaysExec)
// sortAscDesc: 0 asc, 1 desc (default 1)
// metric: 0 by value, 1 by array size (default 0)
// mergeMode: 0 then() wrap, 1 overwrite (default 1)
// alwaysExec: 0 only on combine, 1 on any overlap (default 0)
tag('OVERLAP',["ACTION"],(anchor,arr,ast,tx)=>{
 // Executed by InteractionManager with context in globalState.temp.overlap_target
 const S=Store.getState();
 const cfg={
 sort:(+Formula.valOf(ast.args[0])|0)||1,
 metric:(+Formula.valOf(ast.args[1])|0)||0,
 merge:(+Formula.valOf(ast.args[2])|0)||1,
 always:(+Formula.valOf(ast.args[3])|0)||0
 };
 const t=S.globalState.get('temp.overlap_target');
 if(!t) return;
 const own={ ref:anchor, arr:arr, cell: Formula.getCell(anchor) };
 const other={ ref:t, arr: S.arrays[t.arrId], cell: Formula.getCell(t) };
 let ownScore, otherScore;
 if(cfg.metric===1){
 ownScore = own.arr.size.x*own.arr.size.y*own.arr.size.z;
 otherScore = other.arr.size.x*other.arr.size.y*other.arr.size.z;
 } else {
 ownScore = parseFloat(own.cell.value)||0;
 otherScore = parseFloat(other.cell.value)||0;
 }
 let winner=own, loser=other;
 const cmp = cfg.sort===1 ? (ownScore>=otherScore) : (ownScore<=otherScore);
 if(!cmp){ winner=other; loser=own; }
 const ownsTx = !tx; if(ownsTx) tx=Write.start('overlap.resolve','OVERLAP');
 const esc=(s)=> String(s??'').replace(/"/g,'\\"');
 if(cfg.merge===0){ // then wrap
 const wC = winner.cell.formula || winner.cell.value; const lC = loser.cell.formula || loser.cell.value;
 const f=`=THEN("${esc(lC)}", "${esc(wC)}")`;
 Write.set(tx, winner.ref.arrId, {x:winner.ref.x,y:winner.ref.y,z:winner.ref.z}, { value:'', formula:f });
 } else {
 // overwrite with winner's existing content (no change)
 Write.set(tx, winner.ref.arrId, {x:winner.ref.x,y:winner.ref.y,z:winner.ref.z}, { value: winner.cell.value, formula: winner.cell.formula });
 }
 if(ownsTx) Write.commit(tx);
});

// THEN(refs...): sequentially executes refs/ranges and returns last result into anchor
tag('THEN',["ACTION"],(anchor,arr,ast,tx)=>{
 const ownsTx = !tx; if(ownsTx) tx = Write.start('then.sequence','THEN wrapper');
 let last='';
 const processRef=(ref)=>{
 const c = Formula.getCell(ref);
 const content = (c && c.formula) ? c.formula : (c ? c.value : '');
 if(String(content||'').startsWith('=')){
 Formula.runOnceAt(ref, content, tx);
 last = Formula.getCellValue(ref);
 } else { last = content; }
 };
 ast.args.forEach(a=>{
 if(a && a.kind==='ref') processRef(a);
 else if(a && a.kind==='range') a.cells.sort((a,b)=> a.y-b.y || a.x-b.x || a.z-b.z).forEach(processRef);
 else last = Formula.valOf(a);
 });
 Write.set(tx, arr.id, anchor, { value: last, formula: ast.raw });
 if(ownsTx) Write.commit(tx);
});

// HUSK(range): copy values, delete source array, leave remnants at anchor block
tag('HUSK',["ACTION","BLOCK"],(anchor,arr,ast,tx)=>{
 if(!tx) throw new Error('HUSK requires an active transaction');
 const src=ast.args[0]; if(!src||src.kind!=='range') throw new Error('HUSK requires a range');
 const aid=src.cells[0].arrId; if(aid===arr.id) throw new Error('HUSK source must differ');
 const xs=[...new Set(src.cells.map(c=>c.x))].sort((a,b)=>a-b);
 const ys=[...new Set(src.cells.map(c=>c.y))].sort((a,b)=>a-b);
 const zs=[...new Set(src.cells.map(c=>c.z))].sort((a,b)=>a-b);
 const minX=xs[0], minY=ys[0], minZ=zs[0];
 const ak=aKey(anchor);
 zs.forEach(z=> ys.forEach(y=> xs.forEach(x=>{
 const v=Formula.getCellValue({arrId:aid,x,y,z});
 const dx=x-minX, dy=y-minY, dz=z-minZ;
 const tgt={x:anchor.x+dx,y:anchor.y+dy,z:anchor.z+dz};
 const isAnchor=(dx===0&&dy===0&&dz===0);
 Write.set(tx, arr.id, tgt, { value: v, formula: isAnchor? ast.raw : null, meta:{generated:true, emitter:ak} });
 })));
 setTimeout(()=>{ try{ Actions.deleteArray(aid); }catch{} }, 50);
});

// DO(f1[, f2[, ...]]): sequence multiple sub-formulas in order, return last
// Accepts legacy string arguments or block form (DO{ ... }).
tag('DO',['ACTION'],(anchor,arr,ast,tx)=>{
 const boolish = (value)=>{
 if(typeof value === 'boolean') return value;
 if(typeof value === 'number') return value !== 0;
 if(typeof value === 'string'){
 const trimmed = value.trim().toLowerCase();
 if(trimmed === '' || trimmed === '0' || trimmed === 'false' || trimmed === 'no') return false;
 return true;
 }
 return !!value;
 };

 const isBlock = !!ast.block;
 const options = ast.blockOptions || {};
 const atomicOpt = options.atomic;
 const errorModeRaw = options['on_error'] ?? options['onerror'] ?? '';
 const errorMode = String(errorModeRaw || '').trim().toLowerCase();
 const continueOnError = (errorMode === 'continue' || errorMode === 'next' || errorMode === 'skip');

 const wantsAtomic = tx ? true : (atomicOpt !== undefined ? boolish(atomicOpt) : !isBlock);
 let innerTx = tx;
 let ownsTx = false;
 if(!innerTx && wantsAtomic){
 innerTx = Write.start('do.sequence','DO wrapper');
 ownsTx = true;
 }

 const execTx = tx ? tx : (wantsAtomic ? innerTx : null);
 const steps = Array.isArray(ast.args) ? ast.args : [];
 let shouldAbort = false;

 for(const step of steps){
 let formulaText = '';
 if(typeof step === 'string'){
 formulaText = step;
 } else {
 formulaText = String(Formula.valOf(step) ?? '');
 }
 if(!formulaText) continue;
 if(formulaText[0] !== '=') formulaText = `=${formulaText}`;
 warmChimeIfNeeded(formulaText);
 try{
 Formula.executeAt(anchor, formulaText, execTx);
 } catch(e){
 console.warn('DO step error', e);
 if(!continueOnError){
 shouldAbort = true;
 break;
 }
 }
 }

 if(ownsTx){
 if(!shouldAbort){
 try{ Write.commit(innerTx); }
 catch(e){ console.warn('Failed to commit DO transaction', e); }
 }
 }
 // silent: do not stamp the cell
});

// SEQ(...) is an alias for DO(...)
tag('SEQ',['ACTION'],(anchor,arr,ast,tx)=>{
 const proxyAst = { ...ast, fn: 'DO' };
 return Fn['DO'].impl(anchor, arr, proxyAst, tx);
});

// PIPE(value, step1, step2, ...): compose expressions sequentially using '_' placeholder
tag('PIPE',['ACTION'],(anchor,arr,ast,tx)=>{
 const initialExpr = typeof ast.pipeInitial === 'string' ? ast.pipeInitial.trim() : '';
 const stages = Array.isArray(ast.pipeStages) ? [...ast.pipeStages] : [];
 const composeStage = (stage, prev)=>{
 if(!stage) return prev;
 const trimmed = stage.trim();
 if(!trimmed) return prev;
 if(/\b_\b/.test(trimmed)){
 return trimmed.replace(/\b_\b/g, prev);
 }
 const idx = trimmed.lastIndexOf(')');
 if(idx === -1){
 return `${trimmed}(${prev})`;
 }
 const openIdx = trimmed.indexOf('(');
 if(openIdx === -1 || idx < openIdx){
 return `${trimmed}(${prev})`;
 }
 const beforeArgs = trimmed.slice(0, openIdx + 1);
 const argsContent = trimmed.slice(openIdx + 1, idx);
 const after = trimmed.slice(idx);
 const prefix = argsContent.trim().length ? `${argsContent}, ` : '';
 return `${beforeArgs}${prefix}${prev}${after}`;
 };

 let current = initialExpr;
 if(!current && stages.length){
 current = stages.shift().trim();
 }
 if(!current) return;
 for(const stage of stages){
 current = composeStage(stage, current);
 }
 if(!current) return;
 const finalFormula = `=${current}`;
 warmChimeIfNeeded(finalFormula);
 try{
 Formula.runOnceAt(anchor, finalFormula, tx || null);
 } catch(e){
 console.warn('PIPE execution error', e);
 }
});

tag('DELAY',['ACTION'],(anchor,arr,ast)=>{
 const ticks = Math.max(0, (+Formula.valOf(ast.args[0]??0)|0));
 const raw = ast.args[1];
 let action = (typeof raw==='string')? raw : String(Formula.valOf(raw)||'');
 if(!action){ Actions.setCell(arr.id, anchor, '!ERR:DELAY:NO_ACTION', ast.raw, true); return; }
 warmChimeIfNeeded(action);
 const ms = ticks * ACTION_TICK_MS;
 const target = {arrId:anchor.arrId||arr.id, x:anchor.x, y:anchor.y, z:anchor.z};
 setTimeout(()=>{
 warmChimeIfNeeded(action);
 executeActionFormula(target, action, 'delay');
 }, ms);
 Actions.setCell(arr.id, anchor, `Delay:${ticks}`, ast.raw, true);
});

tag('REPEAT',['ACTION'],(anchor,arr,ast)=>{
 const raw = ast.args[0];
 let action = (typeof raw==='string')? raw : String(Formula.valOf(raw)||'');
 if(!action){ Actions.setCell(arr.id, anchor, '!ERR:REPEAT:NO_ACTION', ast.raw, true); return; }
 let count = ast.args[1]!==undefined ? (+Formula.valOf(ast.args[1])|0) : 1;
 if(count === 0){ console.warn('REPEAT infinite mode not supported outside continuous triggers; defaulting to 1'); count = 1; }
 const intervalTicks = ast.args[2]!==undefined ? Math.max(1, (+Formula.valOf(ast.args[2])|0)) : 1;
 const target = {arrId:anchor.arrId||arr.id, x:anchor.x, y:anchor.y, z:anchor.z};
 const run = ()=>{ warmChimeIfNeeded(action); executeActionFormula(target, action, 'repeat'); };
 run();
 let remaining = count-1;
 if(remaining>0){
 const intervalMs = intervalTicks * ACTION_TICK_MS;
 const id = setInterval(()=>{
 run();
 remaining--;
 if(remaining<=0) clearInterval(id);
 }, intervalMs);
 }
 Actions.setCell(arr.id, anchor, `Repeat:${count}`, ast.raw, true);
});

// EXEC_AT(x, y, z, arrId, formulaText) or EXEC_AT(ref, formulaText)
// Executes the provided formula text at the target anchor without stamping current cell
tag('EXEC_AT',["ACTION"],(anchor,arr,ast,tx)=>{
 if(!tx) throw new Error('EXEC_AT requires an active transaction (use inside DO)');
 const a0 = ast.args[0];
 const a1 = ast.args[1];
 let target=null, formula='';
 if(a1===undefined){
 throw new Error('EXEC_AT needs target and formula');
 }
 // Form 1: EXEC_AT(ref, formula)
 if(a0 && a0.kind==='ref'){
 target = {arrId:a0.arrId, x:a0.x, y:a0.y, z:a0.z};
 formula = String(Formula.valOf(a1)||'');
 } else if(ast.args.length>=5){
 // Form 2: EXEC_AT(x, y, z, arrIdExpr, formula)
 const x=(+Formula.valOf(ast.args[0])|0), y=(+Formula.valOf(ast.args[1])|0), z=(+Formula.valOf(ast.args[2])|0);
 const id = (+Formula.valOf(ast.args[3])|0);
 if(!Store.getState().arrays[id]) throw new Error('EXEC_AT: target array not found');
 target = {arrId:id, x, y, z};
 formula = String(Formula.valOf(ast.args[4])||'');
 } else if(typeof a0==='string' || typeof a0==='number'){
 // Allow dynamic absolute string like "@[x,y,z,id]"
 const parsed = parseAlt(String(Formula.valOf(a0)));
 if(!parsed) throw new Error('EXEC_AT: invalid target');
 target = {arrId:parsed.arrId, x:parsed.x, y:parsed.y, z:parsed.z};
 formula = String(Formula.valOf(a1)||'');
 } else {
 throw new Error('EXEC_AT: invalid arguments');
 }
 if(!formula || formula[0] !== '=') formula = `=${formula}`;
 warmChimeIfNeeded(formula);
 Formula.executeAt(target, formula, tx);
});

// DELETE(...targets) delete arrays by id or ref; default self
tag('DELETE',["ACTION"], (anchor,arr,ast)=>{
 try{
 const toArrId = (a)=>{
 if(a && a.kind==='ref') return a.arrId ?? arr.id;
 const v = Formula.valOf(a);
 if(v===undefined || v===null || v==='') return null;
 if(typeof v === 'string'){
 const lower = v.trim().toLowerCase();
 if(lower === 'self') return arr.id;
 // Accept A1-style without array id by defaulting to host
 const parsed = parseAlt(v) || parseA1g(v, arr.id);
 if(parsed) return parsed.arrId;
 const n = +v; if(Number.isFinite(n)) return Math.trunc(n);
 return null;
 }
 const n = +v; if(Number.isFinite(n)) return Math.trunc(n);
 return null;
 };

 let targets = ast.args.length ? ast.args.map(toArrId).filter(id=>id!=null) : [arr.id];
 // Unique and skip reserved (0, -1)
 targets = [...new Set(targets)].filter(id => id!=null && id !== 0 && id !== -1);

 if(targets.length === 0){
 Actions.setCell(arr.id, anchor, '!ERR:DELETE:NoTarget', ast.raw, true);
 return;
 }

 let ok = 0;
 targets.forEach(id=>{
 try{
 const A = Store.getState().arrays[id];
 if(A){ try{ Scene.startDatafallDelete?.(A); }catch{} }
 ok++;
 }catch{}
 });

 Actions.setCell(arr.id, anchor, `Deleted:${ok}`, ast.raw, true);
 }catch(e){
 Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true);
 }
});

// Short aliases
tag('DEL',["ACTION"], (anchor,arr,ast)=> Fn['DELETE'].impl(anchor,arr,ast));
tag('REMOVE',["ACTION"], (anchor,arr,ast)=> Fn['DELETE'].impl(anchor,arr,ast));

// CONNECT(ref1, ref2[, style[, dimensionMode]]) => creates traversal connectors
tag('CONNECT',['SCENE', 'ACTION'],(anchor,arr,ast)=>{
 const normalizeRef = (ref)=>{
 if(!ref || ref.kind !== 'ref') return null;
 return { ...ref, arrId: ref.arrId ?? arr.id };
 };
 const ref1 = normalizeRef(ast.args[0]);
 const ref2 = normalizeRef(ast.args[1]);

 // Validate inputs
 if(!ref1 || !ref2){
 Actions.setCell(arr.id, anchor, '!ERR:Requires 2 cell refs', ast.raw, true);
 Scene.removeConnection(anchor); // Clean up any old line
 return;
 }

 let style = '';
 let dimensionMode = 'line';
 let dimensionExplicit = false;
 if(ast.args[2] !== undefined){
 const raw = Formula.valOf(ast.args[2]);
 if(raw != null){
 const text = String(raw).trim();
 if(['line','platform','zipline','grind'].includes(text.toLowerCase())){
 dimensionMode = text.toLowerCase();
 dimensionExplicit = true;
 } else {
 style = text;
 }
 }
 }
 if(ast.args[3] !== undefined){
 const modeRaw = String(Formula.valOf(ast.args[3]) || '').trim().toLowerCase();
 if(modeRaw){
 dimensionMode = modeRaw;
 dimensionExplicit = true;
 }
 }

 // Pass to the Scene module to handle rendering and physics state
 Scene.addConnection(anchor, ref1, ref2, { style, dimensionMode, dimensionExplicit });
 const statusParts = ['??', dimensionMode.toUpperCase()];
 if(style) statusParts.push(`(${style})`);
 Actions.setCell(arr.id, anchor, statusParts.join(' '), ast.raw, true);
});

// GOAL(conditionRef) => register a goal condition
tag('GOAL',['META'],(anchor,arr,ast)=>{
 const conditionRef = ast.args[0];
 if(!conditionRef || conditionRef.kind !== 'ref') {
 Actions.setCell(arr.id, anchor, '!ERR:Requires condition ref', ast.raw, true);
 return;
 }
 
 const S = Store.getState();
 const goalKey = aKey(anchor);
 S.gameState.goals.set(goalKey, conditionRef);
 Actions.setCell(arr.id, anchor, '?? Goal Set', ast.raw, true);
});
// ONWIN(actionFormula) => register callback for when all goals are met
tag('ONWIN',['META'],(anchor,arr,ast)=>{
 const actionFormula = String(valOf(ast.args[0] || '')) || '';
 if(!actionFormula) {
 Actions.setCell(arr.id, anchor, '!ERR:Requires action formula', ast.raw, true);
 return;
 }
 
 const S = Store.getState();
 S.gameState.winCallbacks.push({
 anchor: {...anchor},
 callback: actionFormula
 });
 Actions.setCell(arr.id, anchor, '?? Win Handler Set', ast.raw, true);
});

function listAllowedFunctionsFor(arr){
 const names = Object.keys(Fn);
 const pol = arr.fnPolicy || {mode:'ALLOW_ALL', allow:new Set(), deny:new Set(), tags:new Set()};
 const has = (set, n)=> set && (set.has?.(n) || set.has?.(n.toUpperCase?.()||n));
 const matchesTags = (n)=> {
 if(!pol.tags || !pol.tags.size) return true;
 const tags = Fn[n]?.tags || new Set();
 for(const t of pol.tags) if(tags.has(t)) return true;
 return false;
 };

 let allowed = [];
 if(pol.mode==='ALLOW_ONLY'){
 const base = names.filter(n => has(pol.allow,n) || ALWAYS.has(n));
 allowed = base.filter(matchesTags);
 } else {
 allowed = names.filter(n => !has(pol.deny,n) || ALWAYS.has(n)).filter(matchesTags);
 }
 return [...new Set(allowed)].sort();
}
tag('FUNCTION_UI',['META'],(anchor,arr,ast)=>{
 // Batch to coalesce all writes into a single transaction
 Actions.begin();
 const port = String(Formula.valOf(ast.args[0] ?? 'east')).toLowerCase();
 const filterSub = String(Formula.valOf(ast.args[1] ?? '')||'').toLowerCase();
 const page = Math.max(0, (+Formula.valOf(ast.args[2] ?? 0)|0));
 const perPage = Math.max(5, (+Formula.valOf(ast.args[3] ?? 12)|0));

 const host = Store.getState().arrays[anchor.arrId];
 // Idempotence guard: reuse an existing Function Browser mount if present
 const existingMount = (host._uiMounts||[]).find(m=>m.name==='Function Browser');
 if(existingMount && Store.getState().arrays[existingMount.id]){
 const ui=Store.getState().arrays[existingMount.id];
 ui.hidden=false; Scene.syncVisibility(ui);
 const p = dockOffsetFor(host, port, 1.0);
 Scene.setArrayOffset(ui, p);
 Actions.end();
 return;
 }
 const full = listAllowedFunctionsFor(host);
 const list = filterSub ? full.filter(n=>n.toLowerCase().includes(filterSub)) : full;

 // Group functions by category for collapsible interface
 const categories = {};
 const categoryInfo = {
 'GLOBAL': {icon: '??', name: 'Global State'},
 'EVENTS': {icon: '?', name: 'Events'},
 'GAMES': {icon: '??', name: 'Games'},
 'DATA': {icon: '??', name: 'Data'},
 'LOGIC': {icon: '??', name: 'Logic'},
 'MATH': {icon: '??', name: 'Math'},
 'NAVIGATION': {icon: '??', name: 'Nav'},
 'INTERACTION': {icon: '??', name: 'Input'},
 'SCENE': {icon: '??', name: 'Scene'},
 'IO': {icon: '??', name: 'I/O'},
 'ADVANCED': {icon: '??', name: 'Advanced'}
 };
 
 list.forEach(name => {
 const tags = [...(Fn[name]?.tags || [])];
 let category = 'OTHER';
 if(tags.includes('GLOBAL')) category = 'GLOBAL';
 else if(tags.includes('EVENT') || name.includes('EVENT')) category = 'EVENTS';
 else if(tags.includes('GAME') || name.includes('FISH') || name.includes('GALAXY')) category = 'GAMES';
 else if(tags.includes('PURE') && (name.includes('ARRAY') || name.includes('GET') || name.includes('SET') || name.includes('BLIT'))) category = 'DATA';
 else if(tags.includes('LOGIC') || name.includes('IF') || name.includes('AND') || name.includes('OR')) category = 'LOGIC';
 else if(tags.includes('MATH') || name.includes('ADD') || name.includes('MUL') || name.includes('CLAMP')) category = 'MATH';
 else if(name.includes('ADDRESS') || name.includes('SELF') || name.includes('OFFSET') || name.includes('SELECT')) category = 'NAVIGATION';
 else if(name.includes('ON_SELECT') || name.includes('SELECTED') || name.includes('TARGET')) category = 'INTERACTION';
 else if(tags.includes('SCENE') || name.includes('PHYSICS') || name.includes('HIGHLIGHT')) category = 'SCENE';
 else if(tags.includes('IO') || name.includes('COPY') || name.includes('EXPORT') || name.includes('IMPORT')) category = 'IO';
 else if(name.includes('VECTOR') || name.includes('FORMULA') || name.includes('PRIORITY')) category = 'ADVANCED';
 
 if(!categories[category]) categories[category] = [];
 categories[category].push(name);
 });

 // Calculate total rows needed: category headers + functions + some padding
 const categoryCount = Object.keys(categories).length;
 const functionCount = list.length;
 const totalRows = categoryCount * 2 + functionCount + 3; // headers + functions + padding
 
 const cols = 4;
 const ui = Actions.createArray({name:'Function Browser', size:{x:cols,y:totalRows, z:1}, hidden:false});

 let currentY = ui.size.y - 1;
 
 // Create collapsible category structure with ON_SELECT chains
 Object.entries(categories).forEach(([catName, funcs]) => {
 const info = categoryInfo[catName] || {icon: '??', name: catName};
 
 // Store previous functions below using temporary storage approach
 const tempStorageY = currentY - funcs.length - 10; // Store below visible area
 
 // Category header with collapse/expand functionality 
 Actions.setCell(ui.id, {x:0,y:currentY,z:0}, info.icon, null, true);
 Actions.setCell(ui.id, {x:1,y:currentY,z:0}, info.name, null, true);
 Actions.setCell(ui.id, {x:2,y:currentY,z:0}, `${funcs.length} functions`, null, true);
 
 // Expand/Collapse toggle with sophisticated temporary array manipulation 
 const collapseState = `collapse_${catName}_${ui.id}`;
 const toggle = `=ON_SELECT(SELF(), DO(
 "=SET_GLOBAL(\\\"${collapseState}\\\", IF(GET_GLOBAL(\\\"${collapseState}\\\"), 0, 1))",
 "=IF(GET_GLOBAL(\\\"${collapseState}\\\"), ARRAY(\\\"set\\\", ${funcs.map(f => `\\\\\"${f}\\\\\"`).join(',')}), ARRAY(\\\"set\\\", \\\"\\\\\\\\\\\\\\\", \\\"\\\\\\\\\\\\\\\", \\\"\\\\\\\\\\\\\\\", \\\"\\\\\\\\\\\\\\\") )"
 ))`;
 
 Actions.setCell(ui.id, {x:3,y:currentY,z:0}, '?', toggle, true);
 
 currentY--;
 
 // Function rows (initially collapsed)
 funcs.forEach((name, i) => {
 const y = currentY - i;
 const tags = [...(Fn[name]?.tags || [])].join(',');
 
 // Function name with insert action
 Actions.setCell(ui.id, {x:1,y,z:0}, name, null, true);
 Actions.setCell(ui.id, {x:2,y,z:0}, tags.slice(0,15), null, true);
 
 // Copy button
 const call = `=${name}()`;
 const copyAction = `=ON_SELECT(SELF(), DO("=COPY(\\\"${call}\\\")", "=TOAST(\\\"Copied ${name}()\\\")"))`;
 Actions.setCell(ui.id, {x:0,y,z:0}, '??', copyAction, true);
 
 // Insert button that writes to focus
 const insertAction = `=ON_SELECT(SELF(), DO("=FOCUS_SET(\\\"formula\\\",\\\"${call}\\\")", "=TOAST(\\\"Inserted ${name}()\\\")"))`;
 Actions.setCell(ui.id, {x:3,y,z:0}, '?', insertAction, true);
 });
 
 currentY -= funcs.length + 1; // Space between categories
 });
 // Force complete re-render after all cells are written (batched)
 console.log(`FUNCTION_UI: forcing render for array #${ui.id} with ${categoryCount} categories`);
 ui._layersRendered = false;
 Scene.renderArray(ui);
 
 // Then position it
 const p = dockOffsetFor(host, port, 1.0);
 Scene.setArrayOffset(ui, p);

 host._uiMounts = host._uiMounts || [];
 host._uiMounts.push({id:ui.id, name:'Function Browser', port});

 // Silent registration: do not stamp anchor to avoid re-evaluation loops
 Actions.end();
});
tag('INVENTORY',['META'],(anchor,arr,ast)=>{
 Actions.begin();
 const port = String(Formula.valOf(ast.args[0] ?? 'north')).toLowerCase();
 const title = String(Formula.valOf(ast.args[1] ?? 'Inventory'));

 const host = Store.getState().arrays[anchor.arrId];
 // Idempotence guard: reuse existing inventory mount
 const existing = (host._uiMounts||[]).find(m=>m.name==='Inventory');
 if(existing && Store.getState().arrays[existing.id]){
 const inv = Store.getState().arrays[existing.id];
 inv.hidden=false; Scene.syncVisibility(inv);
 const p = dockOffsetFor(host, port, 1.0);
 Scene.setArrayOffset(inv, p);
 Actions.end();
 return;
 }
 const rows = 6;
 const inv = Actions.createArray({name:title, size:{x:5, y:rows, z:1}, hidden:false});

 // Use Actions.setCell for immediate visibility like FUNCTION_UI
 const YT = inv.size.y-1;
 Actions.setCell(inv.id, {x:0,y:YT,z:0}, title, null, true);
 Actions.setCell(inv.id, {x:1,y:YT,z:0}, 'Item', null, true);
 Actions.setCell(inv.id, {x:2,y:YT,z:0}, 'Qty', null, true);
 Actions.setCell(inv.id, {x:3,y:YT,z:0}, '+1', null, true);
 Actions.setCell(inv.id, {x:4,y:YT,z:0}, '-1', null, true);

 const example = ['Iron','Water','Wood','Gears'];
 for(let i=0;i<example.length && i<rows-1;i++){
 const y = YT-1-i;
 const name = example[i];
 Actions.setCell(inv.id, {x:1,y,z:0}, name, null, true);
 Actions.setCell(inv.id, {x:2,y,z:0}, 0, null, true);

 // Working +/- buttons using ON_SELECT with SET to keep label stable
 const qtyRef = `@[2,${y},0,${inv.id}]`;
 const plus = `=ON_SELECT(SELF(), "=DO(\\"=SET(${qtyRef}, ADD(OFFSET(${qtyRef},0,0,0),1))\\", \\"=DISPLAY_AS(\\"+\\", SELF())\\")")`;
 const minus = `=ON_SELECT(SELF(), "=DO(\\"=SET(${qtyRef}, CLAMP(ADD(OFFSET(${qtyRef},0,0,0),-1),0,999))\\", \\"=DISPLAY_AS(\\"-\\", SELF())\\")")`;
 Actions.setCell(inv.id, {x:3,y,z:0}, '+', plus, true);
 Actions.setCell(inv.id, {x:4,y,z:0}, '-', minus, true);

 // Enhanced use button with clipboard option
 const useIt = `=FOCUS_SET("text","${name}")`;
 const copyIt = `=FOCUS_SET("clipboard","${name}")`;
 Actions.setCell(inv.id, {x:0,y,z:0}, '?', useIt, true);
 }

 // Force complete re-render after all cells are written (batched)
 console.log(`INVENTORY: forcing render for array #${inv.id}`);
 inv._layersRendered = false;
 Scene.renderArray(inv);
 
 // Then position it
 const p = dockOffsetFor(host, port, 1.0);
 Scene.setArrayOffset(inv, p);
 
 // Focus the inventory so it's selectable
 Actions.setSelection(inv.id, {x:1, y:YT-1, z:0}, null, '3d');

 host._uiMounts = host._uiMounts || [];
 host._uiMounts.push({id:inv.id, name:'Inventory', port});

 // Silent registration: do not stamp anchor to avoid re-evaluation loops
 Actions.end();
});
tag('UI_UNMOUNT',['META'],(anchor,arr,ast)=>{
 const host = Store.getState().arrays[anchor.arrId];
 const key = String(Formula.valOf(ast.args[0] ?? '')).toLowerCase();
 if(!host?._uiMounts?.length){ 
 Actions.setCell(arr.id, anchor, 'UI:None', ast.raw, true); 
 return; 
 }
 const matches = (m)=> !key || (String(m.id)===key || String(m.name||'').toLowerCase().includes(key));
 const toHide = host._uiMounts.filter(matches);
 toHide.forEach(m=>{
 const a = Store.getState().arrays[m.id];
 if(a){ a.hidden = true; Scene.syncVisibility(a); }
 });
 host._uiMounts = host._uiMounts.filter(m=>!matches(m));
 Actions.setCell(arr.id, anchor, `UI:Unmounted ${toHide.length}`, ast.raw, true);
});
// 2D Platformer System
tag('SET_SELECTED',['ACTION'],(anchor,arr,ast)=>{
 const direction = String(Formula.valOf(ast.args[0]||'none')).toLowerCase();
 const s = Store.getState().selection;
 if(!s?.arrayId || !s.focus) throw new Error('No focus for movement');
 
 const currentArr = Store.getState().arrays[s.arrayId];
 if(!currentArr) throw new Error('Current array not found');
 
 // Calculate offset based on direction from joystick
 let dx=0, dy=0, dz=0;
 if(direction==='up') dy=1;
 else if(direction==='down') dy=-1;
 else if(direction==='left') dx=-1;
 else if(direction==='right') dx=1;
 else if(direction==='forward') dz=-1;
 else if(direction==='back') dz=1;
 
 // Get target screen array (look for array with 'screen' in name or use next array)
 const screenArr = Object.values(Store.getState().arrays).find(a => 
 a.name.toLowerCase().includes('screen') || a.params?.isScreen
 );
 
 if(screenArr){
 // Find current avatar position (cell with "Hero" or similar)
 let avatarPos = null;
 Object.values(screenArr.chunks).forEach(ch => {
 ch.cells.forEach(c => {
 if(c.value === 'Hero' || c.value === '??' || c.value === '@'){
 avatarPos = {x:c.x, y:c.y, z:c.z};
 }
 });
 });
 
 if(avatarPos){
 const newPos = {x:avatarPos.x+dx, y:avatarPos.y+dy, z:avatarPos.z+dz};
 // Check bounds
 if(newPos.x>=0 && newPos.x<screenArr.size.x && newPos.y>=0 && newPos.y<screenArr.size.y && newPos.z>=0 && newPos.z<screenArr.size.z){
 // Clear old position
 Actions.setCell(screenArr.id, avatarPos, '', null, true);
 // Set new position
 Actions.setCell(screenArr.id, newPos, 'Hero', null, true);
 // Focus the new position
 Actions.setSelection(screenArr.id, newPos, null, '3d');
 }
 }
 }
 
 Actions.setCell(arr.id, anchor, `Move:${direction}`, ast.raw, true);
});

// SET_SELECT(ref): force jump to selection
tag('SET_SELECT',['ACTION'],(anchor,arr,ast)=>{
 const t=ast.args[0];
 if(!t || t.kind!=='ref') throw new Error('SET_SELECT needs a ref');
 Actions.setSelection(t.arrId,{x:t.x,y:t.y,z:t.z},null,'3d');
 Actions.setCell(arr.id, anchor, `Select:${A1(t.x)}${t.y+1}${greek(t.z)}`, ast.raw, true);
});
tag('LIGHT',['SCENE'],(anchor,arr,ast)=>{
 const toBool = (v)=>{
 if(v == null) return false;
 if(typeof v === 'boolean') return v;
 if(typeof v === 'number') return v !== 0;
 const s = String(v).trim().toLowerCase();
 if(!s) return false;
 return !['0','false','off','no'].includes(s);
 };
 try{
 const stateVal = Formula.valOf(ast.args[0]);
 const enabled = toBool(stateVal);
 const targetRef = (ast.args[1] && ast.args[1].kind==='ref') ? ast.args[1] : null;
 const lumensRaw = ast.args[2] ? Formula.valOf(ast.args[2]) : null;
 let lumens = (lumensRaw==null || lumensRaw==='') ? 800 : parseFloat(lumensRaw);
 if(!Number.isFinite(lumens)) lumens = 800;
 lumens = Math.max(0, lumens);
 const source = { arrId:arr.id, x:anchor.x, y:anchor.y, z:anchor.z };
 if(!enabled || lumens<=0){
 try{ Scene.removeCellLight?.(source); }catch{}
 Actions.setCell(arr.id, anchor, 'LIGHT:OFF', ast.raw, true);
 return;
 }
 const cell = Formula.getCell({arrId:arr.id, x:anchor.x, y:anchor.y, z:anchor.z}) || {};
 const color = cell?.meta?.color || '#ffffff';
 try{
 Scene.upsertCellLight?.(source, {
 enabled:true,
 mode: targetRef ? 'spot' : 'point',
 targetRef,
 lumens,
 color
 });
 }catch(e){ console.warn('LIGHT() upsert failed', e); }
 Actions.setCell(arr.id, anchor, targetRef ? 'LIGHT:SPOT' : 'LIGHT:POINT', ast.raw, true);
 }catch(e){
 console.warn('LIGHT() failed', e);
 Actions.setCell(arr.id, anchor, `!ERR:${e.message||'LIGHT'}`, ast.raw, true);
 }
});
tag('CHIME',['AUDIO'],(anchor,arr,ast)=>{
 try{
 const noteVal = Formula.valOf(ast.args[0]);
 const parsed = ChimeSystem.parseNote(noteVal);
 if(!parsed){ Actions.setCell(arr.id, anchor, '!ERR:NOTE', ast.raw, true); return; }
 const octVal = ast.args[1] ? Formula.valOf(ast.args[1]) : null;
 const octave = ChimeSystem.toOctave(octVal);
 const durVal = ast.args[2] ? Number(Formula.valOf(ast.args[2])) : null;
 const duration = Number.isFinite(durVal) && durVal>0 ? durVal : 0.65;
 try{ ChimeSystem.play(parsed.offset, octave, duration); }catch(e){ console.warn('Chime playback error', e); }
 Actions.setCell(arr.id, anchor, `CHIME:${parsed.label}${octave}`, ast.raw, true);
 }catch(e){
 console.warn('CHIME() failed', e);
 Actions.setCell(arr.id, anchor, '!ERR:CHIME', ast.raw, true);
 }
});
tag('2D_PLATFORMER',['META'],(anchor,arr,ast)=>{
 console.log('2D_PLATFORMER: Starting execution...', anchor, arr.id);
 try {
 const port = String(Formula.valOf(ast.args[0] ?? 'east')).toLowerCase();
 const screenSize = {x:12, y:8, z:1}; // 2D screen dimensions
 
 const host = Store.getState().arrays[anchor.arrId];
 console.log(`2D_PLATFORMER: Host array #${host.id}`);
 
 // Create controller array (3x3 directional pad)
 const controller = Actions.createArray({name:'Controller', size:{x:3, y:3, z:1}, hidden:false});
 console.log(`2D_PLATFORMER: Created controller #${controller.id}`);

 // Stash init params on controller so chained init knows where to dock and host id
 controller.params = {
 ...(controller.params||{}),
 platformer: true,
 hostId: host.id,
 port,
 screenSize
 };
 
 // Set up controller layout with ON_SELECT hooks
 Actions.setCell(controller.id, {x:1,y:2,z:0}, '?', null, true);
 Actions.setCell(controller.id, {x:0,y:1,z:0}, '?', null, true);
 // Center joystick doubles as locked init cell that spawns the screen (once, idempotent)
 Actions.setCell(controller.id, {x:1,y:1,z:0}, '??', null, true);
 Actions.setCell(controller.id, {x:2,y:1,z:0}, '?', null, true);
 Actions.setCell(controller.id, {x:1,y:0,z:0}, '?', null, true);

 // Register ON_SELECT for each control cell
 Formula.executeAt({arrId:controller.id,x:1,y:2,z:0}, '=ON_SELECT("=SET_SELECTED(\"up\")")');
 Formula.executeAt({arrId:controller.id,x:0,y:1,z:0}, '=ON_SELECT("=SET_SELECTED(\"left\")")');
 Formula.executeAt({arrId:controller.id,x:2,y:1,z:0}, '=ON_SELECT("=SET_SELECTED(\"right\")")');
 Formula.executeAt({arrId:controller.id,x:1,y:0,z:0}, '=ON_SELECT("=SET_SELECTED(\"down\")")');
 Formula.executeAt({arrId:controller.id,x:1,y:1,z:0}, `=PLATFORMER_SPAWN_SCREEN()`);
 
 // Add some action buttons
 Actions.setCell(controller.id, {x:2,y:2,z:0}, 'A', '=FOCUS_SET("text","Action!")', true);
 Actions.setCell(controller.id, {x:0,y:0,z:0}, 'B', '=FOCUS_SET("text","Jump!")', true);

 // Lock the center cell so it can't be edited away
 controller.locks = controller.locks || new Set();
 controller.locks.add(`${controller.id}:1,1,0`);

 // Trigger chained init now so the screen is created immediately
 try { Formula.executeAt({arrId:controller.id, x:1, y:1, z:0}); } catch(e) { console.warn('Init cell eval failed', e); }

 // Force render controller only (screen will be spawned by the chained formula)
 controller._layersRendered = false;
 Scene.renderArray(controller);

 // Position controller relative to host
 const controllerPos = dockOffsetFor(host, port, 1.5);
 Scene.setArrayOffset(controller, controllerPos);

 // Remember mount
 host._uiMounts = host._uiMounts || [];
 host._uiMounts.push({id:controller.id, name:'Controller', port});

 // Focus the controller center by default
 Actions.setSelection(controller.id, {x:1,y:1,z:0}, null, '3d');

 Actions.setCell(arr.id, anchor, `2D Platformer: Controller #${controller.id}`, ast.raw, true);
 console.log('2D_PLATFORMER: Controller created and init cell armed.');
 } catch(e) {
 console.error('2D_PLATFORMER: Error during execution:', e);
 Actions.setCell(arr.id, anchor, `!ERR: ${e.message}`, ast.raw, true);
 }
});
// Add lowercase alias for easier typing
tag('2d_platformer',['META'],(anchor,arr,ast)=>{
 console.log('2d_platformer: Redirecting to 2D_PLATFORMER...');
 return Fn['2D_PLATFORMER'].impl(anchor,arr,ast);
});
// Chained initializer: runs inside the controller's locked cell to spawn the screen idempotently
tag('PLATFORMER_SPAWN_SCREEN',['META'],(anchor,arr,ast)=>{
 try{
 const ctrl = Store.getState().arrays[anchor.arrId];
 const p = ctrl?.params?.platformer ? ctrl.params : (ctrl.params||{});
 const hostId = p?.hostId ?? (Object.values(Store.getState().arrays).find(a=>a.id!==ctrl.id)?.id ?? arr.id);
 const port = (p?.port || 'east');
 const screenSize = p?.screenSize || {x:12,y:8,z:1};

 let screen = Object.values(Store.getState().arrays).find(a => a.params?.isScreen && a.params?.ownerCtrlId===ctrl.id);
 if(!screen){
 screen = Actions.createArray({name:'Game Screen', size:screenSize, hidden:false});
 screen.params = { ...(screen.params||{}), isScreen:true, ownerCtrlId:ctrl.id };
 const Y = screen.size.y-1;
 Actions.begin();
 for(let x=0;x<screen.size.x;x++) Actions.setCell(screen.id, {x, y:0, z:0}, '?', null, true);
 const hero = {x:Math.floor(screen.size.x/2), y:1, z:0};
 Actions.setCell(screen.id, hero, 'Hero', null, true);
 Actions.end();
 }

 const host = Store.getState().arrays[hostId] || arr;
 const offset = dockOffsetFor(host, port, 1.0);
 Scene.setArrayOffset(screen, offset);
 Actions.setSelection(screen.id, {x:Math.floor(screen.size.x/2), y:1, z:0}, null, '3d');
 Actions.setCell(arr.id, anchor, '??', ast.raw, true);
 }catch(e){
 Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true);
 }
});
// DEP_VIS(flag): toggle dependency curve visibility (simple straight lines for now)
tag('DEP_VIS',['SCENE'],(anchor,arr,ast)=>{
 const flag = !!Formula.valOf(ast.args[0]);
 try{
 // Toggle scene overlay
 const S = Store.getState();
 const sc = Scene.getScene?.();
 if(!sc){ Actions.setCell(arr.id, anchor, '!ERR:Scene', ast.raw, true); return; }
 // Store on global for quick access
 if(flag===true || flag===false){
 // Toggle global state so UI can reflect
 S.globalState.set('dep.vis', flag?1:0);
 }
 // Build dependency curves from current dependency graph
 const want = !!flag;
 let group = sc.children.find?.(c=>c.userData && c.userData.kind==='depGroup');
 if(!group){ group = new THREE.Group(); group.userData.kind='depGroup'; sc.add(group); }
 group.visible = want;
 // Rebuild contents every toggle or when enabling
 while(group.children.length){ const ch=group.children.pop(); ch.geometry?.dispose?.(); ch.material?.dispose?.(); }
 if(want){
 const deps = Store.getState().anchorsByDep;
 const arrays = Store.getState().arrays;
 const mat = new THREE.LineBasicMaterial({color:0x06b6d4, transparent:true, opacity:0.5});
 deps.forEach((dependents, depKey)=>{
 dependents.forEach(toKey=>{
 const [a1, r1] = depKey.split(':'); const [x1,y1,z1]=r1.split(',').map(Number);
 const [a2, r2] = toKey.split(':'); const [x2,y2,z2]=r2.split(',').map(Number);
 const arr1=arrays[+a1], arr2=arrays[+a2]; if(!arr1||!arr2) return;
 const p1 = Scene.worldPos(arr1,x1,y1,z1);
 const p2 = Scene.worldPos(arr2,x2,y2,z2);
 const geom = new THREE.BufferGeometry().setFromPoints([p1,p2]);
 const line = new THREE.Line(geom, mat);
 group.add(line);
 });
 });
 }
 Actions.setCell(arr.id, anchor, want? 'Deps:ON' : 'Deps:OFF', ast.raw, true);
 }catch(e){ Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true); }
});

// Global intro trigger function (must be defined before tag registration)
window.startIntroExperience = function(){
 console.log('startIntroExperience: global function called (delegating to UI)');
 try{ window.UI?.startIntroExperience?.(); }catch(e){
 console.warn('startIntroExperience: UI path failed, applying inline fallback', e);
 const io = document.getElementById('introOverlay');
 const sheet = document.getElementById('sheet');
 if(io){ io.classList.add('hidden'); }
 if(sheet){ sheet.classList.remove('intro-centered'); sheet.style.left='16px'; sheet.style.bottom='16px'; sheet.style.top=''; sheet.style.transform=''; }
 }
};

tag('STARTINTROEXPERIENCE',['ACTION'],(anchor,arr,ast)=>{ 
 console.log('STARTINTROEXPERIENCE formula called');
 try{
 // Hide overlay and trigger layout collapse first, then run any extra UI logic
 try{ window.UI?.hideIntroOverlay?.(); }catch{}
 try{ window.UI?.triggerIntroCollapse?.(); }catch{}
 window.UI?.startIntroExperience?.();
 }catch(e){ console.warn('STARTINTROEXPERIENCE failed', e); } 
});

/* ===========================
 Cellular Automata (Life)
=========================== */
const CA = (()=> {
 const alive=(v)=> v===1||v==='1'||v===true||v==='X'||v==='x'||v===' ';
 const runLife2D=(arr,{axis='Y',index=0,steps=1})=>{
 const {x:W,y:H,z:D}=arr.size;
 const get=(x,y,z)=>{const ch=arr.chunks[keyChunk(...Object.values(chunkOf(x,y,z)))]; const c=ch.cells.find(t=>t.x===x&&t.y===y&&t.z===z); return c?.value;};
 const set=(x,y,z,v)=>Actions.setCell(arr.id,{x,y,z},v,null,true);
 const clamp=(n,min,max)=> ((n-min)%(max-min+1)+max-min+1)%(max-min+1)+min;
 const stepPlane=(A,B,fix,read)=>{ const cur=[]; for(let b=0;b<B;b++){cur[b]=[]; for(let a=0;a<A;a++){const [x,y,z]=read(a,b,fix); cur[b][a]=alive(get(x,y,z))?1:0;}}
 const nxt=cur.map(r=>r.slice());
 for(let b=0;b<B;b++)for(let a=0;a<A;a++){let n=0; for(let db=-1;db<=1;db++)for(let da=-1;da<=1;da++) if(da||db){const aa=clamp(a+da,0,A-1), bb=clamp(b+db,0,B-1); n+=cur[bb][aa];} nxt[b][a]=(cur[b][a]?(n===2||n===3):(n===3))?1:0;}
 for(let b=0;b<B;b++)for(let a=0;a<A;a++){const [x,y,z]=read(a,b,fix); set(x,y,z,nxt[b][a]);}
 };
 for(let s=0;s<steps;s++){
 if(axis==='Y') stepPlane(W,D,index,(a,b,f)=>[a,f,b]);
 if(axis==='Z') stepPlane(W,H,index,(a,b,f)=>[a,b,f]);
 if(axis==='X') stepPlane(D,H,index,(a,b,f)=>[f,b,a]);
 }
 };
 return {runLife2D};
})();

/* ===========================
 Scene (Three.js + Rapier)
=========================== */
const Boot = {
 step(t){ const el=document.getElementById('statusChip'); if(el) el.textContent=t; },
 ok(){ this.step('Ready'); },
 crash(e){ const el=document.getElementById('crash'); if(!el) return; el.style.display='block'; el.textContent=`Initialization failed\n\n${(e&&e.stack)||e}`; this.step('Crashed'); },
 log:(...a)=>{ try{ console.debug('[Toybox]',...a);}catch{} }
};
const Scene = (()=>{
 let scene, camera, renderer, controls, grid, axesHelper;
 let baseLightsGroup = null;

 const OceanDefaults = Object.freeze({
 enabled:false,
 envIntensity:0.8,
 lightIntensity:0.55,
 exposure:1.25,
 showGrid:true,
 showSphere:true,
 showTowers:true,
 showFloaters:true,
 timeScale:0.2,
 gridDensity:64,
 choppiness:2.0,
 amplitude0:0.85,
 amplitude1:0.45,
 amplitude2:0.28,
 amplitude3:0.18,
 amplitude4:0.12,
 amplitude5:0.08,
 wavelength0:35.0,
 wavelength1:16.5,
 wavelength2:8.2,
 wavelength3:4.5,
 wavelength4:2.8,
 wavelength5:1.8,
 speed0:0.95,
 speed1:1.15,
 speed2:1.3,
 speed3:1.45,
 speed4:1.6,
 speed5:1.8,
 deepColor:'#0b345a',
 shallowColor:'#1e6aa2',
 foamColor:'#ffffff',
 foamAmount:2.5,
 foamBias:0.5,
 foamScale:1.5,
 maxGloss:0.91,
 roughnessScale:0.0044,
 horizonColor:'#cfeaff',
 horizonZStart:60.0,
 horizonZEnd:260.0,
 horizonBoost:1.10,
 microScale:0.035,
 microFreq:18.0,
 microWaveScale:0.3,
 enableBloom:true,
 bloomStrength:0.25,
 enableVignette:true,
 vignetteStrength:0.85,
 grainAmount:0.015,
 enableRays:true,
 rayStrength:1.8,
 rayDecay:0.965,
 rayExposure:1.15,
 enableLighthouse:true,
 lighthouseStrength:0.8,
 focusDistance:21.0,
 dofStrength:0.95,
 focusRange:10.0,
 fogStart:50.0,
 fogEnd:200.0,
 fogColor:'#5aaee3',
 gridOpacity:0.35,
 sunElevation:22,
 sunAzimuth:25,
 skyTopColor:'#8ec1ea',
 skyMidColor:'#63aee3',
 skyBotColor:'#092c4d'
 });

 const OceanBackdrop = (()=>{
 const dirs = [
 new THREE.Vector2(1.0, 0.2).normalize(),
 new THREE.Vector2(-0.6, 0.8).normalize(),
 new THREE.Vector2(0.2, -1.0).normalize(),
 new THREE.Vector2(0.8, 0.4).normalize(),
 new THREE.Vector2(-1.0, -0.2).normalize(),
 new THREE.Vector2(0.4, 0.9).normalize()
 ];
 const waveParams={
 A:[0.85,0.45,0.28,0.18,0.12,0.08],
 L:[35.0,16.5,8.2,4.5,2.8,1.8],
 S:[0.95,1.15,1.3,1.45,1.6,1.8]
 };
 // Temporary vectors for calculations
 const tmpVec3 = new THREE.Vector3();
 const tmpVec2 = new THREE.Vector2();
 const state={
 settings:{...OceanDefaults},
 group:null,
 sky:null,
 skyUniforms:null,
 water:null,
 waterUniforms:null,
 grid:null,
 gridAttr:null,
 gridConfig:null,
 ball:null,
 structures:[],
 floaters:[],
 voxelStructures:[],
 lighthousePositions:[],
 baseHeight:-6,
 time:0,
 presentActive:false
 };

 const L_OCCLUSION=1;
 const towerParams={ count:16, minRadius:120, maxRadius:600, azimuthSpread:0.6 };
 const MAX_LIGHTHOUSE_BEACONS=4;

 function ensureGroup(){
 if(state.group) return;
 state.group=new THREE.Group();
 state.group.name='OceanBackdrop';
 state.group.visible=false;
 createSky();
 createWater();
 createGrid();
 createBuoy();
 createStructures();
 createOceanLights();
 if(scene) scene.add(state.group);
 }
 
 function createOceanLights(){
 // Dedicated lighting for ocean scene (matches data-lake.html)
 const lights = new THREE.Group();
 lights.name = 'OceanLights';
 
 // Ambient light for base illumination
 const ambient = new THREE.AmbientLight(0xbfdfff, 0.25);
 lights.add(ambient);
 
 // Main directional light (key light)
 const dir = new THREE.DirectionalLight(0xffffff, 0.55);
 dir.position.set(-3, 7, -4);
 dir.castShadow = false;
 lights.add(dir);
 
 state.oceanLights = { ambient, directional: dir };
 state.group.add(lights);
 }

 function createSky(){
 const geo = new THREE.SphereGeometry(1200, 32, 16);
 const uniforms = {
 top:{value:new THREE.Color(0x8ec1ea)},
 mid:{value:new THREE.Color(0x63aee3)},
 bot:{value:new THREE.Color(0x092c4d)}
 };
 const mat = new THREE.ShaderMaterial({
 side:THREE.BackSide,
 uniforms,
 vertexShader:`varying vec3 v; void main(){ v=position; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.); }`,
 fragmentShader:`varying vec3 v; uniform vec3 top,mid,bot; void main(){ float h=normalize(v).y*.5+.5; vec3 c=mix(bot,mid,smoothstep(0.,.45,h)); c=mix(c,top,smoothstep(.45,1.,h)); gl_FragColor=vec4(c,1.); }`
 });
 const sky = new THREE.Mesh(geo, mat);
 sky.name='OceanSky';
 state.sky = sky;
 state.skyUniforms = uniforms;
 state.group.add(sky);
 }

 function createWater(){
 const SIZE = 120;
 const SEG = 256;
 const STEP = SIZE / SEG;
 const HALF = SIZE / 2;
 state.gridConfig = { SIZE, SEG, STEP, HALF };
 const geo = new THREE.PlaneGeometry(SIZE, SIZE, SEG, SEG);
 geo.rotateX(-Math.PI/2);
 const uniforms = {
 uTime:{value:0},
 sunDir:{value:new THREE.Vector3(0.5,0.6,0.3).normalize()},
 deep:{value:new THREE.Color(0x0b345a)},
 shallow:{value:new THREE.Color(0x1e6aa2)},
 foamColor:{value:new THREE.Color(0xffffff)},
 Q:{value:state.settings.choppiness},
 foamAmt:{value:state.settings.foamAmount},
 foamBias:{value:state.settings.foamBias},
 foamScale:{value:state.settings.foamScale},
 maxGloss:{value:state.settings.maxGloss},
 roughnessScale:{value:state.settings.roughnessScale},
 microScale:{value:state.settings.microScale},
 microFreq:{value:state.settings.microFreq},
 microWaveScale:{value:state.settings.microWaveScale},
 nearFade:{value:20.0},
 farFade:{value:200.0},
 horizonCol:{value:new THREE.Color(0xcfeaff)},
 horizonZStart:{value:60.0},
 horizonZEnd:{value:260.0},
 horizonBoost:{value:state.settings.horizonBoost},
 A0:{value:waveParams.A[0]}, A1:{value:waveParams.A[1]}, A2:{value:waveParams.A[2]},
 A3:{value:waveParams.A[3]}, A4:{value:waveParams.A[4]}, A5:{value:waveParams.A[5]},
 L0:{value:waveParams.L[0]}, L1:{value:waveParams.L[1]}, L2:{value:waveParams.L[2]},
 L3:{value:waveParams.L[3]}, L4:{value:waveParams.L[4]}, L5:{value:waveParams.L[5]},
 S0:{value:waveParams.S[0]}, S1:{value:waveParams.S[1]}, S2:{value:waveParams.S[2]},
 S3:{value:waveParams.S[3]}, S4:{value:waveParams.S[4]}, S5:{value:waveParams.S[5]}
 };
 const mat = new THREE.ShaderMaterial({
 transparent:true,
 uniforms,
 vertexShader:`
 uniform float uTime; uniform float Q;
 uniform float A0,A1,A2,A3,A4,A5, L0,L1,L2,L3,L4,L5, S0,S1,S2,S3,S4,S5;
 uniform float microScale, microFreq, microWaveScale;
 varying vec3 vN; varying vec3 vP; varying float vSlope; varying float vHeight;
 varying float vViewZ; varying float vBreak;
 const int N=6; vec2 D[N];
 void setup(){ D[0]=normalize(vec2( 1.0, 0.2)); D[1]=normalize(vec2(-0.6, 0.8)); D[2]=normalize(vec2( 0.2,-1.0));
 D[3]=normalize(vec2( 0.8, 0.4)); D[4]=normalize(vec2(-1.0,-0.2)); D[5]=normalize(vec2( 0.4, 0.9)); }
 float A[N]; float L[N]; float S[N];
 void params(){ A[0]=A0;A[1]=A1;A[2]=A2;A[3]=A3;A[4]=A4;A[5]=A5;
 L[0]=L0;L[1]=L1;L[2]=L2;L[3]=L3;L[4]=L4;L[5]=L5;
 S[0]=S0;S[1]=S1;S[2]=S2;S[3]=S3;S[4]=S4;S[5]=S5; }
 void main(){
 setup(); params();
 vec3 p = position, disp=vec3(0.);
 vec3 grad = vec3(0.);
 float jac=0.0;
 for(int i=0;i<N;i++){
 float k=6.28318/L[i], w=sqrt(9.8*k), a=k*dot(D[i], p.xz) - (w*S[i])*uTime;
 float s=sin(a), c=cos(a);
 disp.x += Q*A[i]*D[i].x*c;
 disp.z += Q*A[i]*D[i].y*c;
 disp.y += A[i]*s;
 grad.x += -A[i]*D[i].x*k*c;
 grad.z += -A[i]*D[i].y*k*c;
 jac += k*A[i]*c;
 }
 p += disp;
 float scaledFreq = microFreq * microWaveScale;
 float micro1 = sin(p.x * scaledFreq + uTime * 3.2) * cos(p.z * scaledFreq * 0.8 + uTime * 2.8);
 float micro2 = sin(p.x * scaledFreq * 2.3 + p.z * scaledFreq * 1.7 + uTime * 4.5) *
 cos(p.z * scaledFreq * 2.1 + p.x * scaledFreq * 0.9 + uTime * 3.8);
 float microDisp = (micro1 + micro2 * 0.6) * microScale;
 p.y += microDisp;
 float eps = 0.05;
 vec3 pRight = p + vec3(eps, 0.0, 0.0);
 vec3 pFront = p + vec3(0.0, 0.0, eps);
 float microRight1 = sin(pRight.x * scaledFreq + uTime * 3.2) * cos(pRight.z * scaledFreq * 0.8 + uTime * 2.8);
 float microRight2 = sin(pRight.x * scaledFreq * 2.3 + pRight.z * scaledFreq * 1.7 + uTime * 4.5) *
 cos(pRight.z * scaledFreq * 2.1 + pRight.x * scaledFreq * 0.9 + uTime * 3.8);
 pRight.y += (microRight1 + microRight2 * 0.6) * microScale;
 float microFront1 = sin(pFront.x * scaledFreq + uTime * 3.2) * cos(pFront.z * scaledFreq * 0.8 + uTime * 2.8);
 float microFront2 = sin(pFront.x * scaledFreq * 2.3 + pFront.z * scaledFreq * 1.7 + uTime * 4.5) *
 cos(pFront.z * scaledFreq * 2.1 + pFront.x * scaledFreq * 0.9 + uTime * 3.8);
 pFront.y += (microFront1 + microFront2 * 0.6) * microScale;
 vec3 tangentX = pRight - p;
 vec3 tangentZ = pFront - p;
 vec3 microNormal = normalize(cross(tangentZ, tangentX));
 vec3 mainNormal = normalize(vec3(-grad.x, 1.0, -grad.z));
 vN = normalize(mainNormal * 0.7 + microNormal * 0.3);
 vSlope = length(grad);
 vHeight = disp.y + microDisp;
 vec4 vp = modelViewMatrix * vec4(p,1.0);
 vViewZ = -vp.z;
 vP = (modelMatrix*vec4(p,1.0)).xyz;
 vBreak = jac;
 gl_Position = projectionMatrix * vp;
 }`,
 fragmentShader:`
 uniform vec3 deep, shallow, foamColor, sunDir;
 uniform float foamAmt, foamBias, foamScale, nearFade, farFade, uTime;
 uniform float maxGloss, roughnessScale;
 uniform vec3 horizonCol; uniform float horizonZStart, horizonZEnd, horizonBoost;
 varying vec3 vN; varying vec3 vP; varying float vSlope; varying float vHeight;
 varying float vViewZ; varying float vBreak;
 float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }
 float noise(vec2 p){
 vec2 i = floor(p);
 vec2 f = fract(p);
 f = f * f * (3.0 - 2.0 * f);
 float a = hash(i);
 float b = hash(i + vec2(1.0, 0.0));
 float c = hash(i + vec2(0.0, 1.0));
 float d = hash(i + vec2(1.0, 1.0));
 return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
 }
 void main(){
 vec3 N = normalize(vN);
 vec3 V = normalize(cameraPosition - vP);
 float fres = pow(1.0 - max(dot(V, N), 0.0), 4.0);
 vec3 base = mix(deep, shallow, smoothstep(-0.6, 0.95, vHeight));
 vec3 col = base*(0.72+0.28*fres);
 float distanceFade = smoothstep(horizonZStart, horizonZEnd, vViewZ);
 float viewAngle = abs(dot(normalize(V), N));
 float grazingMask = smoothstep(0.35, 0.01, viewAngle);
 float distBoost = pow(distanceFade, 0.6);
 float horizonMix = distBoost * grazingMask * horizonBoost * 1.5;
 col = mix(col, horizonCol * 1.3, clamp(horizonMix, 0.0, 0.95));
 float jacobian = vBreak;
 float turbulence = clamp((jacobian - foamBias) * foamScale, 0.0, 1.0);
 vec2 foamUV = vP.xz * 0.5 + uTime * 0.15;
 float foamTex = noise(foamUV * 4.0) * 0.5 + noise(foamUV * 8.0) * 0.3 + noise(foamUV * 16.0) * 0.2;
 foamTex = smoothstep(0.4, 0.7, foamTex);
 float foam = foamTex * turbulence * foamAmt;
 col = mix(col, foamColor, clamp(foam, 0.0, 1.0));
 float viewDist = length(cameraPosition - vP);
 float distanceGloss = mix(0.09, maxGloss, 1.0 / (1.0 + viewDist * roughnessScale));
 float roughness = 1.0 - mix(distanceGloss, 0.0, clamp(turbulence * 0.8, 0.0, 1.0));
 vec3 L = normalize(sunDir);
 vec3 H = normalize(L + V);
 float NdotH = max(dot(N, H), 0.0);
 float specPower = mix(16.0, 512.0, distanceGloss);
 float spec = pow(NdotH, specPower) * (1.0 - roughness) * distanceGloss;
 col += vec3(spec * 2.5);
 float depthAlpha = 0.95 - smoothstep(nearFade, farFade, vViewZ) * 0.45;
 gl_FragColor = vec4(col, depthAlpha);
 }`
 });
 mat.depthWrite = false;
 const water = new THREE.Mesh(geo, mat);
 water.position.y = state.baseHeight;
 water.renderOrder = -10;
 water.name='OceanWater';
 state.water = water;
 state.waterUniforms = uniforms;
 state.group.add(water);
 }

 function createGrid(){
 const baseConfig = state.gridConfig || {};
 const GRID_SEG = state.settings.gridDensity ?? 64;
 const SIZE = baseConfig.SIZE ?? 120;
 const STEP = SIZE / GRID_SEG;
 const HALF = SIZE / 2;
 state.gridConfig = { ...baseConfig, GRID_SEG, GRID_STEP:STEP, HALF };
 const lineCount = ((GRID_SEG+1)*GRID_SEG + (GRID_SEG+1)*GRID_SEG);
 const positions = new Float32Array(lineCount * 2 * 3);
 let ptr = 0;
 for(let z=0; z<=GRID_SEG; z++) for(let x=0; x<GRID_SEG; x++){
 const ax = -HALF + x*STEP, az = -HALF + z*STEP, bx = ax + STEP, bz = az;
 positions[ptr++] = ax; positions[ptr++] = state.baseHeight; positions[ptr++] = az;
 positions[ptr++] = bx; positions[ptr++] = state.baseHeight; positions[ptr++] = bz;
 }
 for(let x=0; x<=GRID_SEG; x++) for(let z=0; z<GRID_SEG; z++){
 const ax = -HALF + x*STEP, az = -HALF + z*STEP, bx = ax, bz = az + STEP;
 positions[ptr++] = ax; positions[ptr++] = state.baseHeight; positions[ptr++] = az;
 positions[ptr++] = bx; positions[ptr++] = state.baseHeight; positions[ptr++] = bz;
 }
 const geo = new THREE.BufferGeometry();
 geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
 const mat = new THREE.LineBasicMaterial({
 color:0xbfe7ff,
 transparent:true,
 opacity:0.35,
 depthWrite:false,
 depthTest:true
 });
 const grid = new THREE.LineSegments(geo, mat);
 grid.renderOrder = 999;
 grid.name='OceanGrid';
 state.grid = grid;
 state.gridAttr = geo.getAttribute('position');
 state.group.add(grid);
 }

 function createBuoy(){
 const ball = new THREE.Mesh(
 new THREE.SphereGeometry(0.5, 24, 16),
 new THREE.MeshStandardMaterial({ color:0xffffff, emissive:0x88aaff, emissiveIntensity:1.05, roughness:0.25 })
 );
 ball.position.set(0, state.baseHeight + 0.7, -2.5);
 ball.userData.base = { x:0, z:-2.5, height:0.55 };
 ball.name='OceanBuoy';
 state.ball = ball;
 state.group.add(ball);
 }

 function createStructures(){
 state.voxelStructures.length = 0;
 state.lighthousePositions.length = 0;
 const voxel = new THREE.BoxGeometry(4.5, 4.5, 4.5);
 const towerGroup = new THREE.Group();
 towerGroup.name='OceanTowers';
 state.group.add(towerGroup);
 const towers = [];
 for(let c=0; c<towerParams.count; c++){
 const instances = 450;
 const mat = new THREE.MeshStandardMaterial({
 color:0x4a7a9f,
 metalness:0.15,
 roughness:0.85,
 emissive:0x000000
 });
 const mesh = new THREE.InstancedMesh(voxel, mat, instances);
 mesh.name=`OceanTowerCluster${c}`;
 mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
 const radius = THREE.MathUtils.randFloat(towerParams.minRadius, towerParams.maxRadius);
 const baseAng = (c / towerParams.count) * Math.PI * 2;
 const jitter = THREE.MathUtils.randFloat(-towerParams.azimuthSpread, towerParams.azimuthSpread);
 const ang = baseAng + jitter;
 const baseY = THREE.MathUtils.randFloat(-10, 30) + state.baseHeight;
 const base = new THREE.Vector3(Math.sin(ang)*radius, baseY, Math.cos(ang)*radius);
 const tilt = new THREE.Euler(
 THREE.MathUtils.degToRad(THREE.MathUtils.randFloat(3,12)),
 THREE.MathUtils.degToRad(THREE.MathUtils.randFloat(0,360)),
 THREE.MathUtils.degToRad(THREE.MathUtils.randFloat(-8,8))
 );
 let i = 0;
 const W = THREE.MathUtils.randInt(12,20);
 const H = THREE.MathUtils.randInt(30,60);
 const D = THREE.MathUtils.randInt(12,20);
 for(let x=0; x<W; x++) for(let y=0; y<H; y++) for(let z=0; z<D; z++){
 if(i>=instances) break;
 if(Math.random() < 0.80) continue;
 const matrix = new THREE.Matrix4();
 const scale = THREE.MathUtils.randFloat(0.9, 1.3);
 const pos = new THREE.Vector3((x-W*0.5)*5.5, (y-H*0.5)*5.5, (z-D*0.5)*5.5);
 pos.applyEuler(tilt);
 pos.add(base);
 matrix.compose(pos, new THREE.Quaternion(), new THREE.Vector3(scale, scale, scale));
 mesh.setMatrixAt(i++, matrix);
 }
 mesh.count = Math.min(i, instances);
 mesh.layers.enable(L_OCCLUSION);
 towerGroup.add(mesh);
 towers.push(mesh);
 state.voxelStructures.push(mesh);
 if(state.lighthousePositions.length < MAX_LIGHTHOUSE_BEACONS && Math.random() < 0.5){
 const topY = baseY + (H * 2.75);
 state.lighthousePositions.push(new THREE.Vector3(base.x, topY, base.z));
 }
 }
 state.structures = towers;

 const floatGroup = new THREE.Group();
 floatGroup.name='OceanFloaters';
 state.group.add(floatGroup);
 const floatGeom = new THREE.BoxGeometry(3, 3, 3);
 const floaters = [];
 for(let i=0; i<60; i++){
 const glow = THREE.MathUtils.randFloat(2.5, 4.5);
 const mat = new THREE.MeshStandardMaterial({
 color:new THREE.Color(0.8,0.95,1.0),
 emissive:new THREE.Color(0.7,0.85,1.0),
 emissiveIntensity:glow,
 metalness:0.1,
 roughness:0.15,
 toneMapped:false
 });
 const mesh = new THREE.Mesh(floatGeom, mat);
 const radius = THREE.MathUtils.randFloat(80, 600);
 const ang = Math.random() * Math.PI * 2;
 const height = THREE.MathUtils.randFloat(15, 120) + state.baseHeight;
 mesh.position.set(Math.sin(ang)*radius, height, Math.cos(ang)*radius);
 mesh.rotation.set(Math.random()*Math.PI*2, Math.random()*Math.PI*2, Math.random()*Math.PI*2);
 mesh.userData.baseY = height;
 const intensity = THREE.MathUtils.randFloat(15, 30);
 const light = new THREE.PointLight(new THREE.Color(0.6,0.85,1.0), intensity, 50);
 light.userData.baseIntensity = intensity;
 light.position.copy(mesh.position);
 light.castShadow = false;
 floatGroup.add(mesh);
 floatGroup.add(light);
 const record = { mesh, light, floatSpeed:THREE.MathUtils.randFloat(0.3,0.7), floatOffset:Math.random()*Math.PI*2 };
 floaters.push(record);
 state.voxelStructures.push(record);
 }
 state.floaters = floaters;
 }

 // Ocean Post-Processing Pipeline (matches data-lake.html exactly)
 function initPostProcessing(){
 if(state.post) return;
 const w = window.innerWidth;
 const h = window.innerHeight;
 const rtScene = new THREE.WebGLRenderTarget(w, h, { 
 depthTexture: new THREE.DepthTexture(), 
 depthBuffer: true,
 stencilBuffer: false,
 samples: 4 // MSAA antialiasing
 });
 const rtHalfA = new THREE.WebGLRenderTarget(Math.max(1, w/2), Math.max(1, h/2));
 const rtHalfB = new THREE.WebGLRenderTarget(Math.max(1, w/2), Math.max(1, h/2));
 const rtOcc = new THREE.WebGLRenderTarget(Math.max(1, w/2), Math.max(1, h/2));
 const rtOccBlur = new THREE.WebGLRenderTarget(Math.max(1, w/2), Math.max(1, h/2));
 const rtLighthouse = new THREE.WebGLRenderTarget(Math.max(1, w/2), Math.max(1, h/2));
 const fsQuad = new THREE.PlaneGeometry(2, 2);
 
 // Blur shader for bloom
 const blurFrag = `
 varying vec2 vUv; uniform sampler2D t; uniform vec2 res;
 void main(){
 vec2 px = 1.0/res; float w[5];
 w[0]=0.204164; w[1]=0.304005; w[2]=0.193783; w[3]=0.072184; w[4]=0.017864;
 vec3 c = texture2D(t, vUv).rgb * w[0];
 for(int i=1;i<5;i++){
 c += texture2D(t, vUv + vec2(float(i)*px.x,0.)).rgb*w[i];
 c += texture2D(t, vUv - vec2(float(i)*px.x,0.)).rgb*w[i];
 }
 gl_FragColor = vec4(c,1.0);
 }`;
 const blurH = new THREE.ShaderMaterial({
 uniforms: { t:{value:null}, res:{value:new THREE.Vector2(w,h)} },
 vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=vec4(position,1.); }`,
 fragmentShader: blurFrag,
 depthTest: false, depthWrite: false
 });
 const blurV = new THREE.ShaderMaterial({
 uniforms: { t:{value:null}, res:{value:new THREE.Vector2(w,h)} },
 vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=vec4(position,1.); }`,
 fragmentShader: blurFrag.replace('vec2(float(i)*px.x,0.)','vec2(0.,float(i)*px.y)'),
 depthTest: false, depthWrite: false
 });
 
 // God rays shader
 const raysMat = new THREE.ShaderMaterial({
 uniforms: {
 t:{value:null}, 
 res:{value:new THREE.Vector2(w/2,h/2)},
 sunPos:{value:new THREE.Vector2(0.5,0.2)},
 rayDecay:{value:state.settings.rayDecay},
 rayExposure:{value:state.settings.rayExposure}
 },
 vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=vec4(position,1.); }`,
 fragmentShader: `
 varying vec2 vUv; uniform sampler2D t; uniform vec2 res;
 uniform vec2 sunPos; uniform float rayDecay; uniform float rayExposure;
 float sampleOcclusion(vec2 uv) {
 vec2 px = 1.0 / res;
 float c = texture2D(t, uv).r;
 c += texture2D(t, uv + vec2(px.x, 0.0)).r * 0.5;
 c += texture2D(t, uv - vec2(px.x, 0.0)).r * 0.5;
 c += texture2D(t, uv + vec2(0.0, px.y)).r * 0.5;
 c += texture2D(t, uv - vec2(0.0, px.y)).r * 0.5;
 return c / 3.0;
 }
 void main(){
 vec2 delta = sunPos - vUv;
 float dist = length(delta);
 vec2 stepv = delta / 96.0;
 vec2 uv = vUv;
 float illum = 0.0;
 float decay = 1.0;
 for(int i=0;i<96;i++){
 uv += stepv;
 float light = sampleOcclusion(uv);
 illum += light * decay;
 decay *= rayDecay;
 }
 float col = illum * rayExposure / (1.0 + dist*1.5);
 gl_FragColor = vec4(vec3(col), 1.0);
 }`,
 depthTest: false, depthWrite: false
 });
 
 // Lighthouse beams shader
 const lighthouseMat = new THREE.ShaderMaterial({
 uniforms: {
 lighthousePos:{value:[new THREE.Vector3(),new THREE.Vector3(),new THREE.Vector3(),new THREE.Vector3()]},
 lighthouseCount:{value:0},
 beamSize:{value:0.08}
 },
 vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=vec4(position,1.); }`,
 fragmentShader: `
 varying vec2 vUv;
 uniform vec3 lighthousePos[4];
 uniform int lighthouseCount;
 uniform float beamSize;
 void main(){
 float brightness = 0.0;
 for(int i=0; i<4; i++){
 if(i >= lighthouseCount) break;
 vec2 pos = lighthousePos[i].xy;
 float dist = length(vUv - pos);
 brightness += smoothstep(beamSize, beamSize * 0.3, dist);
 }
 gl_FragColor = vec4(vec3(brightness), 1.0);
 }`,
 depthTest: false, depthWrite: false
 });
 
 // Composite shader (DOF + fog + bloom + vignette + grain + rays + lighthouse)
 const compMat = new THREE.ShaderMaterial({
 uniforms: {
 t:{value:null}, t2:{value:null}, t3:{value:null}, t4:{value:null},
 depthTex:{value:null},
 res:{value:new THREE.Vector2(w,h)},
 strength:{value:state.settings.bloomStrength},
 time:{value:0},
 vig:{value:state.settings.vignetteStrength},
 grain:{value:state.settings.grainAmount},
 enableBloom:{value:state.settings.enableBloom ? 1 : 0},
 enableVig:{value:state.settings.enableVignette ? 1 : 0},
 focusDist:{value:state.settings.focusDistance},
 dofStrength:{value:state.settings.dofStrength},
 focusRange:{value:state.settings.focusRange},
 camNear:{value:0.1},
 camFar:{value:5000},
 fogStart:{value:state.settings.fogStart},
 fogEnd:{value:state.settings.fogEnd},
 fogCol:{value:new THREE.Color(state.settings.fogColor)},
 enableRays:{value:state.settings.enableRays ? 1 : 0},
 rayStrength:{value:state.settings.rayStrength},
 rayColor:{value:new THREE.Color(0xcde9ff)},
 enableLighthouse:{value:state.settings.enableLighthouse ? 1 : 0},
 lighthouseStrength:{value:state.settings.lighthouseStrength},
 lighthouseColor:{value:new THREE.Color(0xffd89a)}
 },
 vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=vec4(position,1.); }`,
 fragmentShader: `
 varying vec2 vUv;
 uniform sampler2D t; uniform sampler2D t2; uniform sampler2D t3; uniform sampler2D t4;
 uniform sampler2D depthTex; uniform vec2 res;
 uniform float strength, time, vig, grain; uniform int enableBloom, enableVig;
 uniform float focusDist, dofStrength, focusRange, camNear, camFar, fogStart, fogEnd;
 uniform vec3 fogCol;
 uniform int enableRays; uniform float rayStrength; uniform vec3 rayColor;
 uniform int enableLighthouse; uniform float lighthouseStrength; uniform vec3 lighthouseColor;
 
 float linearizeDepth(float z){
 float ndc = z*2.0 - 1.0;
 return (2.0*camNear*camFar) / (camFar + camNear - ndc*(camFar - camNear));
 }
 
 float rnd(vec2 p){
 return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453);
 }
 
 vec3 dofBlur(sampler2D tex, float radius){
 vec2 px = 1.0/res;
 vec3 c = texture2D(tex, vUv).rgb * 0.28;
 c += texture2D(tex, vUv + px*vec2( radius, 0.0)).rgb * 0.12;
 c += texture2D(tex, vUv + px*vec2(-radius, 0.0)).rgb * 0.12;
 c += texture2D(tex, vUv + px*vec2(0.0, radius)).rgb * 0.12;
 c += texture2D(tex, vUv + px*vec2(0.0, -radius)).rgb * 0.12;
 c += texture2D(tex, vUv + px*vec2( radius, radius)).rgb * 0.09;
 c += texture2D(tex, vUv + px*vec2(-radius, radius)).rgb * 0.09;
 c += texture2D(tex, vUv + px*vec2( radius, -radius)).rgb * 0.09;
 c += texture2D(tex, vUv + px*vec2(-radius, -radius)).rgb * 0.09;
 return c;
 }
 
 void main(){
 float z = texture2D(depthTex, vUv).r;
 float depth = linearizeDepth(z);
 
 // DOF - only apply to far objects (ocean), keep near objects (arrays) sharp
 // Near threshold: objects closer than 40 units are always sharp
 float nearThreshold = 40.0;
 float dofMask = smoothstep(nearThreshold, nearThreshold + 20.0, depth);
 float coc = smoothstep(0.0, focusRange, abs(depth - focusDist)) * dofMask;
 float rad = coc * dofStrength * 6.0;
 vec3 base = dofBlur(t, rad);
 
 // Layered atmospheric fog
 float ff1 = smoothstep(fogStart, fogEnd * 0.5, depth);
 float ff2 = smoothstep(fogEnd * 0.5, fogEnd, depth);
 float ff3 = smoothstep(fogEnd, fogEnd * 1.8, depth);
 vec3 fogLayer1 = fogCol * 0.45;
 vec3 fogLayer2 = fogCol * 0.75;
 vec3 fogLayer3 = fogCol * 0.95;
 base = mix(base, fogLayer1, ff1 * 0.4);
 base = mix(base, fogLayer2, ff2 * 0.5);
 base = mix(base, fogLayer3, ff3 * 0.7);
 
 // Bloom
 vec3 bloom = texture2D(t2, vUv).rgb * strength;
 if(enableBloom==1) base += bloom;
 
 // God rays
 if(enableRays==1){
 float r = texture2D(t3, vUv).r;
 base += rayColor * r * rayStrength;
 }
 
 // Lighthouse beams
 if(enableLighthouse==1){
 float lh = texture2D(t4, vUv).r;
 base += lighthouseColor * lh * lighthouseStrength;
 }
 
 // Vignette
 vec2 uv = vUv*2.0-1.0;
 float v = smoothstep(1.4, 0.2/vig, dot(uv,uv));
 if(enableVig==1) base *= v;
 
 // Film grain
 float g = (rnd(vUv*res + time)-0.5) * (grain*2.0);
 base += g;
 
 gl_FragColor = vec4(base, 1.0);
 }`,
 depthTest: false, depthWrite: false
 });
 
 const screenScene = new THREE.Scene();
 const screenCam = new THREE.OrthographicCamera(-1,1,1,-1,0,1);
 const screenMesh = new THREE.Mesh(fsQuad, compMat);
 screenScene.add(screenMesh);
 
 state.post = {
 rtScene, rtHalfA, rtHalfB, rtOcc, rtOccBlur, rtLighthouse,
 blurH, blurV, raysMat, lighthouseMat, compMat,
 screenScene, screenCam, fsQuad
 };
 }
 
 function resizePostTargets(w, h){
 if(!state.post) return;
 state.post.rtScene.setSize(w, h);
 state.post.rtScene.depthTexture = new THREE.DepthTexture();
 state.post.rtHalfA.setSize(Math.max(1, w/2), Math.max(1, h/2));
 state.post.rtHalfB.setSize(Math.max(1, w/2), Math.max(1, h/2));
 state.post.rtOcc.setSize(Math.max(1, w/2), Math.max(1, h/2));
 state.post.rtOccBlur.setSize(Math.max(1, w/2), Math.max(1, h/2));
 state.post.rtLighthouse.setSize(Math.max(1, w/2), Math.max(1, h/2));
 [state.post.blurH, state.post.blurV, state.post.compMat].forEach(m=>{
 if(m.uniforms.res) m.uniforms.res.value.set(w, h);
 });
 if(state.post.raysMat.uniforms.res){
 state.post.raysMat.uniforms.res.value.set(Math.max(1,w/2), Math.max(1,h/2));
 }
 }
 
 function syncPostSettings(){
 if(!state.post) return;
 const c = state.post.compMat.uniforms;
 const mainCam = Scene?.getCamera?.();
 if(mainCam){
 c.camNear.value = mainCam.near;
 c.camFar.value = mainCam.far;
 }
 c.enableBloom.value = state.settings.enableBloom ? 1 : 0;
 c.enableVig.value = state.settings.enableVignette ? 1 : 0;
 c.strength.value = state.settings.bloomStrength;
 c.vig.value = state.settings.vignetteStrength;
 c.grain.value = state.settings.grainAmount;
 c.focusDist.value = state.settings.focusDistance;
 c.dofStrength.value = state.settings.dofStrength;
 c.focusRange.value = state.settings.focusRange;
 c.fogStart.value = state.settings.fogStart;
 c.fogEnd.value = state.settings.fogEnd;
 c.fogCol.value.set(state.settings.fogColor);
 c.enableRays.value = state.settings.enableRays ? 1 : 0;
 c.rayStrength.value = state.settings.rayStrength;
 c.enableLighthouse.value = state.settings.enableLighthouse ? 1 : 0;
 c.lighthouseStrength.value = state.settings.lighthouseStrength;
 state.post.raysMat.uniforms.rayDecay.value = state.settings.rayDecay;
 state.post.raysMat.uniforms.rayExposure.value = state.settings.rayExposure;
 }
 
 function renderOceanWithPost(time){
 if(!state.presentActive || !state.post) return false;
 const mainRenderer = renderer;
 const mainCamera = camera;
 const mainScene = scene;
 if(!mainRenderer || !mainCamera || !mainScene) return false;
 
 try{
 const post = state.post;
 
 // Render FULL SCENE (ocean + arrays together) with ocean post-processing
 // Ocean is positioned far back, so proper depth testing ensures arrays show in front
 
 // Render entire scene to texture with depth
 mainRenderer.setRenderTarget(post.rtScene);
 mainRenderer.setClearColor(0x000000, 1);
 mainRenderer.clear();
 mainRenderer.render(mainScene, mainCamera);
 
 // Bloom (horizontal blur)
 post.blurH.uniforms.t.value = post.rtScene.texture;
 post.blurH.uniforms.res.value.set(post.rtHalfA.width, post.rtHalfA.height);
 mainRenderer.setRenderTarget(post.rtHalfA);
 mainRenderer.render(new THREE.Scene().add(new THREE.Mesh(post.fsQuad, post.blurH)), post.screenCam);
 
 // Bloom (horizontal blur again)
 post.blurH.uniforms.t.value = post.rtHalfA.texture;
 mainRenderer.setRenderTarget(post.rtHalfB);
 mainRenderer.render(new THREE.Scene().add(new THREE.Mesh(post.fsQuad, post.blurH)), post.screenCam);
 
 // Bloom (vertical blur)
 post.blurV.uniforms.t.value = post.rtHalfB.texture;
 post.blurV.uniforms.res.value.set(post.rtHalfA.width, post.rtHalfA.height);
 mainRenderer.setRenderTarget(post.rtHalfA);
 mainRenderer.render(new THREE.Scene().add(new THREE.Mesh(post.fsQuad, post.blurV)), post.screenCam);
 
 // God rays occlusion pass
 const sunWorld = tmpVec3.copy(state.waterUniforms.sunDir.value).multiplyScalar(1000);
 const proj = sunWorld.project(mainCamera);
 const sunUV = tmpVec2.set(proj.x*0.5+0.5, proj.y*0.5+0.5);
 
 mainRenderer.setRenderTarget(post.rtOcc);
 mainRenderer.setClearColor(0x000000, 1);
 mainRenderer.clear();
 
 if(proj.z < 1.0){
 // Draw sun disk
 const sunDiskMat = new THREE.ShaderMaterial({
 uniforms: { sunPos:{value:sunUV.clone()}, sunSize:{value:0.15} },
 vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=vec4(position,1.); }`,
 fragmentShader: `
 varying vec2 vUv; uniform vec2 sunPos; uniform float sunSize;
 void main(){
 float dist = length(vUv - sunPos);
 float circle = smoothstep(sunSize, sunSize * 0.5, dist);
 gl_FragColor = vec4(vec3(circle), 1.0);
 }`,
 depthTest: false, depthWrite: false
 });
 mainRenderer.render(new THREE.Scene().add(new THREE.Mesh(post.fsQuad, sunDiskMat)), post.screenCam);
 
 // Render ocean towers as occluders (black)
 const oldMaterials = [];
 const testLayer = new THREE.Layers();
 testLayer.set(L_OCCLUSION);
 state.group.traverse(obj=>{
 if((obj.isMesh || obj.isInstancedMesh) && obj.layers.test(testLayer)){
 oldMaterials.push({obj, mat:obj.material});
 obj.material = new THREE.MeshBasicMaterial({color:0x000000});
 }
 });
 mainRenderer.render(mainScene, mainCamera);
 oldMaterials.forEach(({obj,mat})=> obj.material = mat);
 }
 
 // Blur occlusion map
 post.blurH.uniforms.t.value = post.rtOcc.texture;
 post.blurH.uniforms.res.value.set(post.rtOcc.width, post.rtOcc.height);
 mainRenderer.setRenderTarget(post.rtOccBlur);
 mainRenderer.render(new THREE.Scene().add(new THREE.Mesh(post.fsQuad, post.blurH)), post.screenCam);
 
 post.blurV.uniforms.t.value = post.rtOccBlur.texture;
 post.blurV.uniforms.res.value.set(post.rtOcc.width, post.rtOcc.height);
 mainRenderer.setRenderTarget(post.rtOcc);
 mainRenderer.render(new THREE.Scene().add(new THREE.Mesh(post.fsQuad, post.blurV)), post.screenCam);
 
 // Generate god rays
 post.raysMat.uniforms.t.value = post.rtOcc.texture;
 post.raysMat.uniforms.sunPos.value.copy(sunUV);
 mainRenderer.setRenderTarget(post.rtHalfB);
 mainRenderer.render(new THREE.Scene().add(new THREE.Mesh(post.fsQuad, post.raysMat)), post.screenCam);
 
 // Generate lighthouse beams
 post.lighthouseMat.uniforms.lighthouseCount.value = Math.min(state.lighthousePositions.length, 4);
 for(let i=0; i<Math.min(state.lighthousePositions.length,4); i++){
 const pos = state.lighthousePositions[i].clone().project(mainCamera);
 post.lighthouseMat.uniforms.lighthousePos.value[i].set(pos.x*0.5+0.5, pos.y*0.5+0.5, pos.z);
 }
 mainRenderer.setRenderTarget(post.rtLighthouse);
 mainRenderer.render(new THREE.Scene().add(new THREE.Mesh(post.fsQuad, post.lighthouseMat)), post.screenCam);
 
 // Final composite to screen
 post.compMat.uniforms.t.value = post.rtScene.texture;
 post.compMat.uniforms.t2.value = post.rtHalfA.texture;
 post.compMat.uniforms.t3.value = post.rtHalfB.texture;
 post.compMat.uniforms.t4.value = post.rtLighthouse.texture;
 post.compMat.uniforms.depthTex.value = post.rtScene.depthTexture;
 post.compMat.uniforms.time.value = time * 60.0;
 
 mainRenderer.setRenderTarget(null);
 mainRenderer.render(post.screenScene, post.screenCam);
 
 return true;
 }catch(e){
 console.warn('[OCEAN] Post-processing error:', e);
 return false;
 }
 }

 function getWaveParams(){
 return waveParams;
 }

 function sampleChoppy(x,z,t,Q){
 const params = getWaveParams();
 let dx=0,dz=0,y=0;
 for(let i=0;i<dirs.length;i++){
 const k = 2*Math.PI/params.L[i];
 const w = Math.sqrt(9.8*k);
 const a = k*(dirs[i].x*x+dirs[i].y*z) - (w*params.S[i])*t;
 const s = Math.sin(a), c = Math.cos(a);
 dx += Q*params.A[i]*dirs[i].x*c;
 dz += Q*params.A[i]*dirs[i].y*c;
 y += params.A[i]*s;
 }
 return {x:x+dx, y:y, z:z+dz};
 }

 function sampleMicroRipples(x,z,t){
 const microScale = state.settings.microScale;
 const microFreq = state.settings.microFreq;
 const microWaveScale = state.settings.microWaveScale;
 const scaledFreq = microFreq * microWaveScale;
 const micro1 = Math.sin(x * scaledFreq + t * 3.2) * Math.cos(z * scaledFreq * 0.8 + t * 2.8);
 const micro2 = Math.sin(x * scaledFreq * 2.3 + z * scaledFreq * 1.7 + t * 4.5) *
 Math.cos(z * scaledFreq * 2.1 + x * scaledFreq * 0.9 + t * 3.8);
 return (micro1 + micro2 * 0.6) * microScale;
 }

 function updateFloaters(dt){
 const active = state.settings.showFloaters && state.presentActive;
 state.floaters.forEach(item=>{
 const vis = active;
 if(item.mesh) item.mesh.visible = vis;
 if(item.light) item.light.visible = vis;
 if(!vis) return;
 const bob = Math.sin(state.time * item.floatSpeed + item.floatOffset) * 2.5;
 const baseY = item.mesh?.userData?.baseY ?? item.baseY ?? state.baseHeight;
 const y = baseY + bob;
 if(item.mesh){
 item.mesh.position.y = y;
 item.mesh.rotation.y += 0.003 * item.floatSpeed;
 item.mesh.rotation.x += 0.002 * item.floatSpeed;
 }
 if(item.light){
 item.light.position.y = y;
 const pulse = 0.85 + Math.sin(state.time * 2.0 + item.floatOffset) * 0.15;
 const baseIntensity = item.light.userData?.baseIntensity ?? item.baseIntensity ?? item.light.intensity;
 item.light.intensity = baseIntensity * pulse;
 }
 });
 }

 function updateGrid(){
 if(!state.gridAttr || !state.presentActive || !state.settings.showGrid) return;
 const pos = state.gridAttr.array;
 const cfg = state.gridConfig || {};
 const SEG = cfg.GRID_SEG ?? cfg.SEG ?? 0;
 const STEP = cfg.GRID_STEP ?? ((cfg.SIZE && SEG) ? (cfg.SIZE/SEG) : 1);
 const HALF = cfg.HALF ?? ((cfg.SIZE||600)/2);
 let p = 0;
 const Q = state.settings.choppiness;
 for(let z=0; z<=SEG; z++) for(let x=0; x<SEG; x++){
 const ax=-HALF + x*STEP, az=-HALF + z*STEP, bx=ax+STEP, bz=az;
 const A=sampleChoppy(ax,az,state.time,Q);
 const B=sampleChoppy(bx,bz,state.time,Q);
 const microA = sampleMicroRipples(A.x, A.z, state.time);
 const microB = sampleMicroRipples(B.x, B.z, state.time);
 pos[p++]=A.x; pos[p++]=state.baseHeight + A.y + microA + 0.01; pos[p++]=A.z;
 pos[p++]=B.x; pos[p++]=state.baseHeight + B.y + microB + 0.01; pos[p++]=B.z;
 }
 for(let x=0; x<=SEG; x++) for(let z=0; z<SEG; z++){
 const ax=-HALF + x*STEP, az=-HALF + z*STEP, bx=ax, bz=az+STEP;
 const A=sampleChoppy(ax,az,state.time,Q);
 const B=sampleChoppy(bx,bz,state.time,Q);
 const microA = sampleMicroRipples(A.x, A.z, state.time);
 const microB = sampleMicroRipples(B.x, B.z, state.time);
 pos[p++]=A.x; pos[p++]=state.baseHeight + A.y + microA + 0.01; pos[p++]=A.z;
 pos[p++]=B.x; pos[p++]=state.baseHeight + B.y + microB + 0.01; pos[p++]=B.z;
 }
 state.gridAttr.needsUpdate = true;
 if(state.grid) state.grid.visible = state.presentActive && state.settings.showGrid;
 }

 function updateBuoy(){
 if(!state.ball || !state.presentActive) return;
 const base = state.ball.userData.base || {x:state.ball.position.x, z:state.ball.position.z, height:0.55};
 const Q = state.settings.choppiness;
 const sample = sampleChoppy(base.x, base.z, state.time, Q);
 const micro = sampleMicroRipples(sample.x, sample.z, state.time);
 state.ball.position.set(sample.x, state.baseHeight + sample.y + micro + base.height, sample.z);
 }

 function updateSunDir(){
 if(!state.waterUniforms) return;
 let dir=null;
 try{
 if(FancyGraphics?.lights?.key){
 dir=FancyGraphics.lights.key.position.clone().normalize();
 }else if(baseLightsGroup){
 const light=baseLightsGroup.children?.find?.(c=>c.isDirectionalLight);
 if(light){
 dir=light.position.clone().normalize();
 }
 }
 }catch{}
 if(!dir){ dir=new THREE.Vector3(0.5,0.6,0.3).normalize(); }
 state.waterUniforms.sunDir.value.copy(dir);
 }

 function applySettings(){
 if(state.waterUniforms){
 state.waterUniforms.Q.value = state.settings.choppiness;
 state.waterUniforms.foamAmt.value = state.settings.foamAmount;
 state.waterUniforms.foamBias.value = state.settings.foamBias;
 state.waterUniforms.foamScale.value = state.settings.foamScale;
 state.waterUniforms.microScale.value = state.settings.microScale;
 state.waterUniforms.microFreq.value = state.settings.microFreq;
 state.waterUniforms.microWaveScale.value = state.settings.microWaveScale;
 state.waterUniforms.horizonBoost.value = state.settings.horizonBoost;
 state.waterUniforms.maxGloss.value = state.settings.maxGloss;
 state.waterUniforms.roughnessScale.value = state.settings.roughnessScale;
 }
 if(state.grid) state.grid.visible = state.presentActive && state.settings.showGrid;
 state.structures.forEach(mesh=>{ if(mesh) mesh.visible = state.presentActive && state.settings.showTowers; });
 state.floaters.forEach(item=>{
 const vis = state.presentActive && state.settings.showFloaters;
 if(item.mesh) item.mesh.visible = vis;
 if(item.light) item.light.visible = vis;
 });
 }


 function update(dt){
 if(!state.group) return;
 if(!state.settings.enabled) {
 state.presentActive=false;
 state.group.visible=false;
 return;
 }
 const active=updateVisibility();
 if(!active) return;
 const delta=Number.isFinite(dt) ? dt : 0.016;
 const speed=Math.max(0, state.settings.timeScale||0);
 state.time += delta * (speed || 0);
 if(state.waterUniforms){ state.waterUniforms.uTime.value = state.time; }
 updateSunDir();
 updateBuoy();
 updateGrid();
 updateFloaters(delta);
 }

 function updateVisibility(){
 if(!state.group) return false;
 state.presentActive = !!(state.settings.enabled && FancyGraphics?.enabled);
 state.group.visible = state.presentActive;
 if(!state.presentActive) return false;
 // Initialize post-processing on first activation
 if(state.presentActive && !state.post){
 initPostProcessing();
 }
 // Add atmospheric fog when ocean is active
 if(scene && state.presentActive && !scene.fog){
 scene.fog = new THREE.FogExp2(0x5aaee3, 0.0008);
 } else if(scene && !state.presentActive && scene.fog){
 scene.fog = null;
 }
 applySettings();
 syncPostSettings();
 return true;
 }

 function setEnabled(flag){
 state.settings.enabled = !!flag;
 updateVisibility();
 return state.settings.enabled;
 }

 function updateSettings(patch){
 if(!patch) return;
 Object.entries(patch).forEach(([key, val])=>{
 if(!(key in state.settings)) return;
 const current = state.settings[key];
 if(typeof current === 'number'){
 const num = Number(val);
 if(Number.isFinite(num)) state.settings[key] = num;
 }else if(typeof current === 'boolean'){
 state.settings[key] = !!val;
 }else{
 state.settings[key] = String(val);
 }
 });
 applySettings();
 }

 function getSettings(){
 return { ...state.settings, active: state.presentActive };
 }

 function recreateGrid(){
 try{
 // Remove old grid
 if(state.grid){
 state.group.remove(state.grid);
 state.grid.geometry?.dispose?.();
 state.grid.material?.dispose?.();
 state.grid = null;
 state.gridAttr = null;
 }
 // Rebuild with new density
 createGrid();
 console.log('[OCEAN] Grid recreated with density:', state.settings.gridDensity);
 }catch(e){
 console.warn('[OCEAN] recreateGrid failed:', e);
 }
 }

 return {
 init:ensureGroup,
 update,
 setEnabled,
 updateSettings,
 getSettings,
 applySettings,
 refreshVisibility:updateVisibility,
 renderWithPost:renderOceanWithPost,
 resizePost:resizePostTargets,
 recreateGrid
 };
 })();
let rapierWorld=null, controller=null, playerBody=null, playerCollider=null, staticPhysicsBody=null;
let physicsActivationPending = false;
let physicsInputCaptured = false;

function syncPhysicsInputCapture(reason){
 try{
 const active = physicsActivationPending || !!Store.getState().scene.physics;
 if(active !== physicsInputCaptured){
 physicsInputCaptured = active;
 console.log(`[PHYSICS] Input capture ${active ? 'ENABLED' : 'RELEASED'}${reason ? ` (${reason})` : ''}`);
 }
 return physicsInputCaptured;
 }catch(e){
 physicsInputCaptured = physicsActivationPending;
 return physicsInputCaptured;
 }
}

function setPhysicsActivationPending(next, reason){
 physicsActivationPending = !!next;
 syncPhysicsInputCapture(reason);
}

function updatePhysicsStatusChip(text){
 try{
 const chip = document.getElementById('physChip');
 if(chip) chip.textContent = text;
 }catch{}
}

async function ensureRapierWorld(){
 if(rapierWorld && RAPIER){
 return { success:true };
 }

 try{
 const mod = await loadRapier();
 if(!mod){
 return { success:false, reason:'unavailable' };
 }

 if(typeof RAPIER.init === 'function'){
 if(!rapierInitPromise){
 rapierInitPromise = RAPIER.init().catch(err=>{
 rapierInitPromise = null;
 throw err;
 });
 }
 await rapierInitPromise;
 }

 rapierWorld = new RAPIER.World({x:0,y:-20,z:0});
 try{
 staticPhysicsBody = rapierWorld.createRigidBody(RAPIER.RigidBodyDesc.fixed());
 }catch(e){
 console.warn('[PHYSICS] Failed creating static world body', e);
 staticPhysicsBody = null;
 }
 playerBody = null;
 playerCollider = null;
 cachedPlayerPos.set(0, 0, 0);
 updatePhysicsStatusChip('Physics: OFF');
 return { success:true };
 }catch(error){
 console.warn('[PHYSICS] Failed to initialize Rapier world', error);
 rapierWorld = null;
 staticPhysicsBody = null;
 playerBody = null;
 playerCollider = null;
 rapierInitPromise = null;
 return { success:false, reason:'error', error };
 }
}
 const chunkMeshes=new Map(); // legacy chunk meshes (still used for some visuals)
 const layerMeshes=new Map(); // `${arr.id}:${z}` -> {mesh, capacity, used, index2cell}
 const connections = new Map(); // aKey(anchor) -> { line, start, end, ... }
 const isZiplineConnection = (con)=>{
 if(!con) return false;
 if(con.mode === 'zipline') return true;
 if((!con.dimensionExplicit) && (!con.mode || con.mode === 'line')) return true;
 return false;
 };
 let depGroup=null, depVis=false; // dependency graph overlay
let ziplineState = { active: false, line: null, direction: new THREE.Vector3(), progress: 0, velocity: 0, length: 1, accel: 0.002, start: new THREE.Vector3(), end: new THREE.Vector3() };
let physicsCameraConfig = { mode:'free', distance:10, allowRotation:false };
 let wasGroundedLastFrame = false;
 let cachedPlayerPos = new THREE.Vector3(0, 0, 0); // Cache to avoid Rapier aliasing issues - initialize with valid coords
 let lastTouchKey = null;
 let lastLandKey = null;
 let landingCellKey = null;
 let landingCellAnim = null;
 let surfaceBounceState = { key:null, depression:0, intensity:1 };
 let skipWalkBounceUntil = 0;

 function resetContactCache(){
 lastTouchKey = null;
 lastLandKey = null;
 wasGroundedLastFrame = false;
 cancelLandingCellAnimation();
 surfaceBounceState = { key:null, depression:0, intensity:1 };
 skipWalkBounceUntil = 0;
 }

 const FancyDefaults = {
 hdri: true,
 lights: true,
 lightRotation: 0,
 lightStrength: 1,
 darkBg: false,
 bloomEnabled: true,
 bloomStrength: 0.15,
 bloomRadius: 0.10,
 exposure: 0.5,
 dofEnabled: true,
 dofAperture: 0.002,
 dofMaxBlur: 0.001,
 transmission: true,
 mirror: true,
 solidGround: false,
 waveGrid: true,
 fogEnabled: false,
 fogDensity: 0.012,
 outlineEnabled: true,
 outlineStrength: 2.4,
 outlineThickness: 0.9,
 motionEnabled: false,
 motionDamping: 0.94,
 fxaa: true
 };

 const FancyGraphics = {
 enabled: false,
 settings: { ...FancyDefaults },
 composer: null,
 passes: {},
 groups: { lights: null, mirror: null, waveGrid: null, ground: null },
 lightDefaults: { key: 3.2, fill: 1.4, rim: 2.6, hemi: 0.6 },
 lights: { key: null, fill: null, rim: null, hemi: null },
 shadowLights: [],
 decor: null,
 hdriTexture: null,
 hdriPromise: null,
 base: {
 gridVisible: true,
 background: null,
 environment: null,
 fog: null,
 toneMapping: null,
 exposure: 1,
 shadowMap: false,
 shadowAutoUpdate: true,
 physicallyCorrectLights: false,
 clearColor: null,
 clearAlpha: 1
 },
 clock: null,
 mirrorUniforms: null
 };

 const billboardObjects = new Set();
 let debugPhysicsSnapshot = null;

 function clonePhysicsConfig(cfg){
 if(cfg == null || typeof cfg !== 'object') return cfg;
 if(Array.isArray(cfg)) return cfg.map(item=> clonePhysicsConfig(item));
 const out = {};
 Object.keys(cfg).forEach(key=>{
 const val = cfg[key];
 if(val && typeof val === 'object'){
 out[key] = clonePhysicsConfig(val);
 } else {
 out[key] = val;
 }
 });
 return out;
 }
 const REFLECTION_FLIP_AXIS = 'y';

 function markBillboard(obj){
 if(!obj) return obj;
 try{
 obj.userData = obj.userData || {};
 obj.userData.billboard = true;
 }catch{}
 billboardObjects.add(obj);
 return obj;
 }

 function unmarkBillboard(obj){
 if(!obj) return;
 billboardObjects.delete(obj);
 if(obj.userData){
 delete obj.userData.__mirrorFlipped;
 delete obj.userData.__mirrorOrigScale;
 }
 }

 function applyMirrorBillboardFlip(active){
 const axis = REFLECTION_FLIP_AXIS;
 billboardObjects.forEach(obj=>{
 if(!obj || !obj.userData || !obj.userData.billboard){
 billboardObjects.delete(obj);
 return;
 }
 if(!obj.parent){
 billboardObjects.delete(obj);
 return;
 }
 if(active){
 if(obj.userData.__mirrorFlipped) return;
 if(obj.userData.__mirrorOrigScale){
 obj.userData.__mirrorOrigScale.copy(obj.scale);
 } else {
 obj.userData.__mirrorOrigScale = obj.scale.clone();
 }
 const s = obj.scale;
 if(axis === 'x'){
 s.x = (s.x === 0 ? 0 : -s.x);
 } else if(axis === 'y'){
 s.y = (s.y === 0 ? 0 : -s.y);
 } else {
 s.z = (s.z === 0 ? 0 : -s.z);
 }
 obj.userData.__mirrorFlipped = true;
 } else {
 if(!obj.userData.__mirrorFlipped) return;
 if(obj.userData.__mirrorOrigScale){
 obj.scale.copy(obj.userData.__mirrorOrigScale);
 } else {
 const s = obj.scale;
 if(axis === 'x'){
 s.x = (s.x === 0 ? 0 : -s.x);
 } else if(axis === 'y'){
 s.y = (s.y === 0 ? 0 : -s.y);
 } else {
 s.z = (s.z === 0 ? 0 : -s.z);
 }
 }
 obj.userData.__mirrorFlipped = false;
 }
 });
 }

 const PRESENT_LIGHT_BG = new THREE.Color(0xf6f7fb);
 const PRESENT_DARK_BG = new THREE.Color(0x0f172a);

 function capturePlatformerGlobals(){
 try{
 const g = Store.getState().globalState;
 if(!g) return {};
 if(typeof g.get !== 'function') return {};
 return {
 active: g.get('platformer.active'),
 input: g.get('platformer.input'),
 jump: g.get('platformer.jump')
 };
 }catch{ return {}; }
 }
 function ensurePlatformerActiveState(active){
 try{
 const g = Store.getState().globalState;
 if(!g || typeof g.set !== 'function') return;
 g.set('platformer.active', !!active);
 if(typeof g.set === 'function'){
 g.set('platformer.input', 'none');
 g.set('platformer.jump', 0);
 }
 }catch(e){ console.warn('Platformer state update failed', e); }
 }
 function restorePlatformerGlobals(snapshot){
 try{
 const g = Store.getState().globalState;
 if(!g || typeof g.set !== 'function') return;
 if(snapshot && Object.prototype.hasOwnProperty.call(snapshot, 'active')){
 g.set('platformer.active', snapshot.active);
 } else if(typeof g.delete === 'function'){
 g.delete('platformer.active');
 }
 if(snapshot && Object.prototype.hasOwnProperty.call(snapshot, 'input')){
 g.set('platformer.input', snapshot.input);
 } else if(typeof g.delete === 'function'){
 g.delete('platformer.input');
 } else {
 g.set('platformer.input', 'none');
 }
 if(snapshot && Object.prototype.hasOwnProperty.call(snapshot, 'jump')){
 g.set('platformer.jump', snapshot.jump);
 } else if(typeof g.delete === 'function'){
 g.delete('platformer.jump');
 } else {
 g.set('platformer.jump', 0);
 }
 }catch(e){ console.warn('Platformer state restore failed', e); }
 }

 function applyDebugPhysicsOverrides(enable){
 if(enable){
 const arraysToRebuild = [];
 if(!debugPhysicsSnapshot){
 const snapshot = {
 avatar: clonePhysicsConfig(Store.getState().avatarPhysics) || null,
 arrays: new Map(),
 collisionModes: new Map(),
 global: capturePlatformerGlobals()
 };
 Store.setState(state=>{
 const arrays = { ...state.arrays };
 Object.entries(arrays).forEach(([id, arr])=>{
 if(!arr) return;
 const nextParams = { ...(arr.params || {}) };
 const prevPhysics = clonePhysicsConfig(nextParams.physics);
 snapshot.arrays.set(id, prevPhysics ?? null);
 if(!snapshot.collisionModes.has(id)){
 snapshot.collisionModes.set(id, arr.collisionMode === 'physics' ? 'physics' : 'edit');
 }
 const debugPhysics = { ...(nextParams.physics || {}), enabled:true, __debugOverride:true };
 const sources = { ...(debugPhysics.__sources || {}) };
 sources.enabled = Number.POSITIVE_INFINITY;
 debugPhysics.__sources = sources;
 nextParams.physics = debugPhysics;
 const nextArr = { ...arr, collisionMode: 'physics', params: nextParams };
 arrays[id] = nextArr;
 arraysToRebuild.push(nextArr);
 console.log(`[PHYSICS] Debug override set for array #${id}: enabled=${debugPhysics.enabled}, __debugOverride=${debugPhysics.__debugOverride}`);
 });
 debugPhysicsSnapshot = snapshot;
 const avatarPhysics = {
 ...state.avatarPhysics,
 enabled:true,
 jumpCount: Number.POSITIVE_INFINITY,
 __debugOverride:true
 };
 return { arrays, avatarPhysics };
 });
 } else {
 Store.setState(state=>{
 const arrays = { ...state.arrays };
 let arraysChanged = false;
 Object.entries(arrays).forEach(([id, arr])=>{
 if(!arr) return;
 const alreadyLocked = arr.params?.physics?.__debugOverride;
 if(alreadyLocked && debugPhysicsSnapshot.arrays.has(id)) return;
 const nextParams = { ...(arr.params || {}) };
 const prevPhysics = clonePhysicsConfig(nextParams.physics);
 if(!debugPhysicsSnapshot.arrays.has(id)){
 debugPhysicsSnapshot.arrays.set(id, prevPhysics ?? null);
 }
 if(!debugPhysicsSnapshot.collisionModes.has(id)){
 debugPhysicsSnapshot.collisionModes.set(id, arr.collisionMode === 'physics' ? 'physics' : 'edit');
 }
 const debugPhysics = { ...(nextParams.physics || {}), enabled:true, __debugOverride:true };
 const sources = { ...(debugPhysics.__sources || {}) };
 sources.enabled = Number.POSITIVE_INFINITY;
 debugPhysics.__sources = sources;
 nextParams.physics = debugPhysics;
 const nextArr = { ...arr, collisionMode: 'physics', params: nextParams };
 arrays[id] = nextArr;
 arraysToRebuild.push(nextArr);
 arraysChanged = true;
 });
 const avatarPhysics = {
 ...state.avatarPhysics,
 enabled:true,
 jumpCount: Number.POSITIVE_INFINITY,
 __debugOverride:true
 };
 if(arraysChanged){
 return { arrays, avatarPhysics };
 }
 return { avatarPhysics };
 });
 }
 arraysToRebuild.forEach(arr=>{
 try{ debounceColliderRebuild(arr); }catch{}
 });
 resetJumpBudget();
 ensurePlatformerActiveState(true);
 return;
 }

 if(!debugPhysicsSnapshot) return;
 const snapshot = debugPhysicsSnapshot;
 Store.setState(state=>{
 const arrays = { ...state.arrays };
 Object.entries(arrays).forEach(([id, arr])=>{
 if(!arr) return;
 const hasSnapshot = snapshot.arrays.has(id);
 const prev = hasSnapshot ? snapshot.arrays.get(id) : undefined;
 const nextParams = { ...(arr.params || {}) };
 const savedMode = (snapshot.collisionModes && snapshot.collisionModes.has(id))
 ? snapshot.collisionModes.get(id)
 : (prev && prev.enabled ? 'physics' : arr.collisionMode);
 const restoredMode = savedMode === 'physics' ? 'physics' : 'edit';
 if(prev != null){
 nextParams.physics = clonePhysicsConfig(prev);
 arrays[id] = { ...arr, collisionMode: restoredMode, params: nextParams };
 return;
 }
 delete nextParams.physics;
 if(Object.keys(nextParams).length){
 arrays[id] = { ...arr, collisionMode: restoredMode, params: nextParams };
 } else {
 const clone = { ...arr, collisionMode: restoredMode };
 delete clone.params;
 arrays[id] = clone;
 }
 });
 let avatarPhysics = snapshot.avatar ? clonePhysicsConfig(snapshot.avatar) : { ...state.avatarPhysics };
 if(avatarPhysics && typeof avatarPhysics === 'object'){
 delete avatarPhysics.__debugOverride;
 }
 debugPhysicsSnapshot = null;
 return { arrays, avatarPhysics };
 });
 resetJumpBudget();
 restorePlatformerGlobals(snapshot.global || {});
 }

 function setPhysicsDebugAll(enable){
 const next = !!enable;
 console.log(`[PHYSICS] setPhysicsDebugAll called: enable=${enable}, next=${next}`);
 Store.setState(state=>({ scene:{ ...state.scene, physicsDebugAll: next } }));
 console.log(`[PHYSICS] scene.physicsDebugAll now set to: ${Store.getState().scene.physicsDebugAll}`);
 if(next){
 console.log('[PHYSICS] Applying debug overrides (enabling all arrays)');
 applyDebugPhysicsOverrides(true);
 } else {
 console.log('[PHYSICS] Removing debug overrides (restoring original state)');
 applyDebugPhysicsOverrides(false);
 }
 persistPhysicsDebugFlag(next);
 }

 function cloneColorOrNull(color){
 if(!color) return null;
 try{ return color.clone ? color.clone() : color; }catch{ return color || null; }
 }

 function makeWaveGridMaterial(){
 const uniforms = {
 time:{value:0}, amp:{value:0.04}, freq:{value:1.2}, speed:{value:1.1},
 cell:{value:3.2}, width:{value:0.04}, color:{value:new THREE.Color(0x9fbfe8)}, alpha:{value:0.3}
 };
 const vertexShader = `uniform float time,amp,freq,speed; varying vec2 vXZ; void main(){
 vXZ = position.xz;
 float a = sin(vXZ.x*freq + time*speed);
 float b = sin((vXZ.y + vXZ.x*0.5)*freq*0.78 - time*0.83*speed);
 float c = sin((vXZ.x - vXZ.y*0.6)*freq*0.62 + time*1.21*speed);
 float h = (a*0.5 + b*0.3 + c*0.2)*amp;
 vec3 p = position; p.y += h; gl_Position = projectionMatrix * modelViewMatrix * vec4(p,1.0);
 }`;
 const fragmentShader = `precision highp float; uniform float cell,width,alpha; uniform vec3 color; varying vec2 vXZ;
 void main(){ vec2 g=abs(fract(vXZ/cell)-0.5)*cell; float d=min(g.x,g.y); float line=1.0 - smoothstep(width,width*1.6,d);
 gl_FragColor=vec4(color,line*alpha); }`;
 return new THREE.ShaderMaterial({ uniforms, vertexShader, fragmentShader, transparent:true, depthWrite:false });
 }

 function ensureFancyDecor(){
 if(FancyGraphics.decor) return;
 FancyGraphics.decor = new THREE.Group();
 FancyGraphics.decor.visible = false;
 scene.add(FancyGraphics.decor);
 FancyGraphics.shadowLights = [];

 const mirror = new Reflector(new THREE.PlaneGeometry(400,400), {
 textureWidth: Math.max(256, window.innerWidth),
 textureHeight: Math.max(256, window.innerHeight),
 clipBias: 0.003
 });
 mirror.rotation.x = -Math.PI/2;
 mirror.position.y = -0.52;
 mirror.material.onBeforeCompile = (shader)=>{
 shader.uniforms.time = { value: 0 };
 shader.uniforms.amp = { value: 0.02 };
 shader.uniforms.freq = { value: 8.0 };
 shader.uniforms.speed = { value: 1.2 };
 shader.fragmentShader = shader.fragmentShader.replace(
 'vec4 base = texture2D( tDiffuse, vUv );',
 `vec2 dv = vec2(
 sin((vUv.x + time*speed) * freq),
 sin((vUv.y - time*0.8*speed) * freq)
 ) * amp;
 vec4 base = texture2D( tDiffuse, vUv + dv );`
 );
 FancyGraphics.mirrorUniforms = shader.uniforms;
 };
 FancyGraphics.decor.add(mirror);
 FancyGraphics.groups.mirror = mirror;

 const originalMirrorBefore = mirror.onBeforeRender ? mirror.onBeforeRender.bind(mirror) : null;
 const originalMirrorAfter = mirror.onAfterRender ? mirror.onAfterRender.bind(mirror) : null;

 mirror.onBeforeRender = function(...args){
 applyMirrorBillboardFlip(true);
 if(originalMirrorBefore){
 try{
 originalMirrorBefore(...args);
 }catch(err){
 applyMirrorBillboardFlip(false);
 throw err;
 }
 }
 };

 mirror.onAfterRender = function(...args){
 try{
 if(originalMirrorAfter){
 originalMirrorAfter(...args);
 }
 }finally{
 applyMirrorBillboardFlip(false);
 }
 };

 const solidGround = new THREE.Mesh(
 new THREE.PlaneGeometry(400,400),
 new THREE.MeshStandardMaterial({ color: 0xe6e9ef, roughness: 0.85, metalness: 0.1 })
 );
 solidGround.rotation.x = -Math.PI/2;
 solidGround.position.y = -0.51;
 solidGround.receiveShadow = true;
 solidGround.visible = false;
 FancyGraphics.decor.add(solidGround);
 FancyGraphics.groups.ground = solidGround;

 const waveGrid = new THREE.Mesh(new THREE.PlaneGeometry(400,400,180,180), makeWaveGridMaterial());
 waveGrid.rotation.x = -Math.PI/2;
 waveGrid.position.y = -0.48;
 FancyGraphics.decor.add(waveGrid);
 FancyGraphics.groups.waveGrid = waveGrid;

 const lights = new THREE.Group();
 const defaults = FancyGraphics.lightDefaults;
 const strength = FancyGraphics.settings.lightStrength ?? 1;
 const key = new THREE.DirectionalLight(0xffffff, defaults.key * strength); key.position.set(-8, 14, 10);
 const fill = new THREE.DirectionalLight(0xffffff, defaults.fill * strength); fill.position.set(10, 6, 12);
 const rim = new THREE.DirectionalLight(0xffffff, defaults.rim * strength); rim.position.set(0, 8, -14);
 const ambient = new THREE.AmbientLight(0xffffff, 0.4 * strength); // Add ambient light to prevent pure black
 const hemi = new THREE.HemisphereLight(0xdbeafe, 0x0f172a, defaults.hemi * strength);
 key.castShadow = false;
 key.shadow.mapSize.set(2048,2048);
 key.shadow.camera.near = 0.5;
 key.shadow.camera.far = 200;
 key.shadow.camera.left = -80;
 key.shadow.camera.right = 80;
 key.shadow.camera.top = 80;
 key.shadow.camera.bottom = -80;
 key.shadow.bias = -0.0008;
 FancyGraphics.shadowLights.push(key);
 lights.add(key);

 [ambient, fill, rim, hemi].forEach(light=>{
 light.castShadow = false;
 lights.add(light);
 });
 FancyGraphics.decor.add(lights);
 FancyGraphics.groups.lights = lights;
 FancyGraphics.lights = { key, fill, rim, hemi, ambient };
 applyFancyLightingAdjustments();
 }

 function applyFancyLightingAdjustments(){
 try{
 const rotation = THREE.MathUtils.degToRad(FancyGraphics.settings.lightRotation || 0);
 if(FancyGraphics.groups.lights){
 FancyGraphics.groups.lights.rotation.y = rotation;
 }
 if(baseLightsGroup){
 baseLightsGroup.rotation.y = rotation;
 }
 const strength = Math.max(0, FancyGraphics.settings.lightStrength ?? 1);
 const defaults = FancyGraphics.lightDefaults;
 const lights = FancyGraphics.lights || {};
 if(lights.key) lights.key.intensity = defaults.key * strength;
 if(lights.fill) lights.fill.intensity = defaults.fill * strength;
 if(lights.rim) lights.rim.intensity = defaults.rim * strength;
 if(lights.hemi) lights.hemi.intensity = defaults.hemi * strength;
 if(lights.ambient) lights.ambient.intensity = 0.4 * strength;
 if(scene){
 try{ scene.environmentIntensity = strength; }catch{}
 const env = scene.environment;
 if(env && env.isTexture){
 try{
 if(env.center && env.center.set){ env.center.set(0.5, 0.5); }
 else if(env.center){ env.center.x = 0.5; env.center.y = 0.5; }
 env.rotation = rotation;
 env.needsUpdate = true;
 }catch{}
 }
 }
 }catch(e){ console.warn('applyFancyLightingAdjustments failed', e); }
 }

 function ensureFancyComposer(){
 if(FancyGraphics.composer) return;
 if(!renderer || !scene || !camera) return; // Wait for init
 try{
 const fancyTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, {
 depthBuffer: true,
 stencilBuffer: true
 });
 FancyGraphics.composer = new EffectComposer(renderer, fancyTarget);
 if(FancyGraphics.composer.renderTarget1) FancyGraphics.composer.renderTarget1.stencilBuffer = true;
 if(FancyGraphics.composer.renderTarget2) FancyGraphics.composer.renderTarget2.stencilBuffer = true;
 FancyGraphics.passes.render = new RenderPass(scene, camera);
 FancyGraphics.composer.addPass(FancyGraphics.passes.render);

 const bokeh = new BokehPass(scene, camera, {
 focus: camera.position.distanceTo(controls?.target || new THREE.Vector3()),
 aperture: FancyGraphics.settings.dofAperture,
 maxblur: FancyGraphics.settings.dofMaxBlur,
 width: window.innerWidth,
 height: window.innerHeight
 });
 FancyGraphics.composer.addPass(bokeh);
 FancyGraphics.passes.bokeh = bokeh;

 const outline = new OutlinePass(new THREE.Vector2(window.innerWidth, window.innerHeight), scene, camera);
 outline.edgeStrength = FancyGraphics.settings.outlineStrength;
 outline.edgeThickness = FancyGraphics.settings.outlineThickness;
 outline.visibleEdgeColor.set(0x3b82f6);
 outline.hiddenEdgeColor.set(0x0f172a);
 FancyGraphics.composer.addPass(outline);
 FancyGraphics.passes.outline = outline;

 const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), FancyGraphics.settings.bloomStrength, 0.4, 0.85);
 bloom.radius = FancyGraphics.settings.bloomRadius;
 FancyGraphics.composer.addPass(bloom);
 FancyGraphics.passes.bloom = bloom;

 const afterimage = new AfterimagePass();
 FancyGraphics.composer.addPass(afterimage);
 FancyGraphics.passes.afterimage = afterimage;

 const fxaa = new ShaderPass(FXAAShader);
 FancyGraphics.composer.addPass(fxaa);
 FancyGraphics.passes.fxaa = fxaa;

 const output = new OutputPass();
 FancyGraphics.composer.addPass(output);
 FancyGraphics.passes.output = output;

 updateFancyComposerSize();
 }catch(e){
 console.warn('Failed to create fancy composer:', e);
 FancyGraphics.composer = null;
 }
 }

 function ensureFancyHDRI(){
 if(FancyGraphics.hdriTexture) return Promise.resolve(FancyGraphics.hdriTexture);
 if(FancyGraphics.hdriPromise) return FancyGraphics.hdriPromise;
 FancyGraphics.hdriPromise = new Promise((resolve, reject)=>{
 try{
 const loader = new RGBELoader();
 loader.load('https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/studio_small_03_1k.hdr', (tex)=>{
 tex.mapping = THREE.EquirectangularReflectionMapping;
 FancyGraphics.hdriTexture = tex;
 resolve(tex);
 }, undefined, reject);
 }catch(e){ reject(e); }
 });
 return FancyGraphics.hdriPromise.catch((e)=>{ console.warn('HDRI load failed', e); FancyGraphics.hdriPromise=null; throw e; });
 }

 function updateFancyComposerSize(){
 if(!FancyGraphics.composer) return;
 try{
 const dpr = Math.min(window.devicePixelRatio||1, 2);
 if(FancyGraphics.composer.setPixelRatio) FancyGraphics.composer.setPixelRatio(dpr);
 if(FancyGraphics.composer.setSize) FancyGraphics.composer.setSize(window.innerWidth, window.innerHeight);
 if(FancyGraphics.passes.fxaa){
 FancyGraphics.passes.fxaa.material.uniforms.resolution.value.set(1/(window.innerWidth*dpr), 1/(window.innerHeight*dpr));
 }
 if(FancyGraphics.passes.bloom){ FancyGraphics.passes.bloom.setSize(window.innerWidth, window.innerHeight); }
 if(FancyGraphics.passes.outline){ FancyGraphics.passes.outline.setSize(window.innerWidth, window.innerHeight); }
 if(FancyGraphics.passes.bokeh && FancyGraphics.passes.bokeh.renderTargetDepth && FancyGraphics.passes.bokeh.renderTargetColor){
 FancyGraphics.passes.bokeh.renderTargetDepth.setSize(window.innerWidth*dpr, window.innerHeight*dpr);
 FancyGraphics.passes.bokeh.renderTargetColor.setSize(window.innerWidth*dpr, window.innerHeight*dpr);
 }
 }catch(e){
 console.warn('Failed to update composer size:', e);
 }
 }

 function applyFancyRuntimeSettings(){
 if(!FancyGraphics.enabled) return;
 renderer.toneMappingExposure = FancyGraphics.settings.exposure;
 renderer.setClearColor(FancyGraphics.settings.darkBg ? PRESENT_DARK_BG : PRESENT_LIGHT_BG, 1);
 scene.background = (FancyGraphics.settings.darkBg ? PRESENT_DARK_BG : PRESENT_LIGHT_BG).clone();

 if(FancyGraphics.passes.bloom){
 FancyGraphics.passes.bloom.enabled = FancyGraphics.settings.bloomEnabled;
 FancyGraphics.passes.bloom.strength = FancyGraphics.settings.bloomStrength;
 FancyGraphics.passes.bloom.radius = FancyGraphics.settings.bloomRadius;
 }
 if(FancyGraphics.passes.bokeh){
 FancyGraphics.passes.bokeh.enabled = FancyGraphics.settings.dofEnabled;
 FancyGraphics.passes.bokeh.uniforms.aperture.value = FancyGraphics.settings.dofAperture;
 FancyGraphics.passes.bokeh.uniforms.maxblur.value = FancyGraphics.settings.dofMaxBlur;
 }
 if(FancyGraphics.passes.fxaa){ FancyGraphics.passes.fxaa.enabled = FancyGraphics.settings.fxaa; }
 if(FancyGraphics.passes.outline){
 FancyGraphics.passes.outline.enabled = FancyGraphics.settings.outlineEnabled;
 FancyGraphics.passes.outline.edgeStrength = FancyGraphics.settings.outlineStrength;
 FancyGraphics.passes.outline.edgeThickness = FancyGraphics.settings.outlineThickness;
 }
 if(FancyGraphics.passes.afterimage){
 FancyGraphics.passes.afterimage.enabled = FancyGraphics.settings.motionEnabled;
 FancyGraphics.passes.afterimage.uniforms['damp'].value = FancyGraphics.settings.motionDamping;
 }
 if(FancyGraphics.groups.lights){ FancyGraphics.groups.lights.visible = FancyGraphics.settings.lights; }
 updateBaseLightingVisibility();
 if(FancyGraphics.groups.waveGrid){ FancyGraphics.groups.waveGrid.visible = FancyGraphics.settings.waveGrid; }
 refreshShadowCasting();
 if(FancyGraphics.settings.hdri){
 ensureFancyHDRI().then((tex)=>{
 if(FancyGraphics.enabled && FancyGraphics.settings.hdri){
 scene.environment = tex;
 applyFancyLightingAdjustments();
 }
 }).catch(()=>{});
 } else {
 scene.environment = null;
 }

 if(FancyGraphics.settings.fogEnabled){
 scene.fog = new THREE.FogExp2((FancyGraphics.settings.darkBg ? PRESENT_DARK_BG : PRESENT_LIGHT_BG).clone(), FancyGraphics.settings.fogDensity);
 } else {
 scene.fog = null;
 }
 applyFancyLightingAdjustments();
 OceanBackdrop.applySettings();
 OceanBackdrop.refreshVisibility();
 }

 function setPresentMode(force){
 const next = force == null ? !FancyGraphics.enabled : !!force;
 if(next === FancyGraphics.enabled) return FancyGraphics.enabled;
 if(next){
 FancyGraphics.base.gridVisible = grid?.visible ?? true;
 FancyGraphics.base.background = cloneColorOrNull(scene?.background || null);
 FancyGraphics.base.environment = scene?.environment || null;
 FancyGraphics.base.fog = scene?.fog || null;
 FancyGraphics.base.toneMapping = renderer?.toneMapping ?? null;
 FancyGraphics.base.exposure = renderer?.toneMappingExposure ?? 1;
 FancyGraphics.base.shadowMap = renderer?.shadowMap?.enabled ?? false;
 FancyGraphics.base.shadowAutoUpdate = renderer?.shadowMap?.autoUpdate ?? true;
 FancyGraphics.base.physicallyCorrectLights = renderer?.physicallyCorrectLights ?? false;
 FancyGraphics.base.clearColor = cloneColorOrNull(renderer?.getClearColor ? renderer.getClearColor(new THREE.Color()) : new THREE.Color(0xf6f7fb));
 FancyGraphics.base.clearAlpha = renderer?.getClearAlpha ? renderer.getClearAlpha() : 1;

 ensureFancyDecor();
 ensureFancyComposer();
 FancyGraphics.decor.visible = FancyGraphics.settings.waveGrid || FancyGraphics.settings.mirror || FancyGraphics.settings.solidGround;
 grid.visible = false;
 renderer.physicallyCorrectLights = true;
 renderer.shadowMap.enabled = FancyGraphics.settings.solidGround;
 if(renderer.shadowMap.enabled){ renderer.shadowMap.type = THREE.PCFSoftShadowMap; }
 renderer.toneMapping = THREE.ACESFilmicToneMapping;
 FancyGraphics.clock = new THREE.Clock();
 FancyGraphics.enabled = true;
 applyFancyRuntimeSettings();
 } else {
 FancyGraphics.enabled = false;
 refreshShadowCasting();
 if(FancyGraphics.decor) FancyGraphics.decor.visible = false;
 grid.visible = !!FancyGraphics.base.gridVisible;
 setupRenderer();
 renderer.setClearColor(FancyGraphics.base.clearColor || new THREE.Color(0xf6f7fb), FancyGraphics.base.clearAlpha ?? 1);
 renderer.shadowMap.enabled = FancyGraphics.base.shadowMap ?? false;
 renderer.shadowMap.autoUpdate = FancyGraphics.base.shadowAutoUpdate ?? true;
 renderer.physicallyCorrectLights = FancyGraphics.base.physicallyCorrectLights ?? false;
 renderer.toneMapping = FancyGraphics.base.toneMapping ?? THREE.NoToneMapping;
 renderer.toneMappingExposure = FancyGraphics.base.exposure ?? 1;
 scene.environment = FancyGraphics.base.environment || null;
 scene.background = FancyGraphics.base.background ? cloneColorOrNull(FancyGraphics.base.background) : PRESENT_LIGHT_BG.clone();
 scene.fog = FancyGraphics.base.fog || null;
 if(FancyGraphics.passes.outline) FancyGraphics.passes.outline.selectedObjects = [];
 updateBaseLightingVisibility();
 }
 OceanBackdrop.refreshVisibility();
 updateShellVisibilityGlobal();
 refreshCellMaterials();
 return FancyGraphics.enabled;
 }

 function togglePresentMode(force){
 console.log('[PRESENT] togglePresentMode called, force:', force, 'current:', FancyGraphics.enabled);
 const state = setPresentMode(force);
 console.log('[PRESENT] togglePresentMode result:', state);
 needsRender = true; // Force a render update
 return state;
 }

 function getGraphicsSettings(){
 return { ...FancyGraphics.settings };
 }

 function updateGraphicsSettings(patch){
 const incoming = patch || {};
 Object.keys(incoming).forEach(key=>{
 if(key in FancyGraphics.settings){ FancyGraphics.settings[key] = incoming[key]; }
 });
 if(Object.prototype.hasOwnProperty.call(incoming, 'solidGround') && incoming.solidGround){
 FancyGraphics.settings.mirror = false;
 }
 if(FancyGraphics.settings.solidGround){
 FancyGraphics.settings.mirror = false;
 }
 const affectsMaterials = Object.prototype.hasOwnProperty.call(incoming, 'transmission');
 const affectsLights = Object.prototype.hasOwnProperty.call(incoming, 'lightRotation') || Object.prototype.hasOwnProperty.call(incoming, 'lightStrength');
 if(FancyGraphics.enabled){
 applyFancyRuntimeSettings();
 if(affectsMaterials) refreshCellMaterials();
 } else {
 if(affectsMaterials) refreshCellMaterials();
 if(affectsLights) applyFancyLightingAdjustments();
 }
 // Update Celli render order when transmission (frosted glass) changes
 if(affectsMaterials){
 try{
 const avatars = Store.getState().avatars || {};
 Object.values(avatars).forEach(av=>{
 if(av?.root?.userData?.updateRenderOrder){
 av.root.userData.updateRenderOrder();
 }
 });
 }catch{}
 }
 }

 function isPresentEnabled(){ return FancyGraphics.enabled; }
 // Hover highlight state (2D/3D sync)
 let hoverKey = null; // `${arrId}:${x},${y},${z}`
 const HIGHLIGHT_FILL_HEX = 0xe0f2ff; // light blue fill
 function applyHoverColor(arrId, coord){
 try{
 const arr = Store.getState().arrays[arrId]; if(!arr) return;
 const ch = arr.chunks[keyChunk(...Object.values(chunkOf(coord.x,coord.y,coord.z)))]; if(!ch) return;
 if(!ch.index2cell) return;
 const idx = ch.index2cell.findIndex(c=>c && c.x===coord.x && c.y===coord.y && c.z===coord.z);
 if(idx<0) return;
 const col = new THREE.Color(HIGHLIGHT_FILL_HEX); col.convertSRGBToLinear();
 if(ch.meshLOD1){ ch.meshLOD1.setColorAt(idx, col); if(ch.meshLOD1.instanceColor) ch.meshLOD1.instanceColor.needsUpdate = true; }
 if(ch.meshGhost){ ch.meshGhost.setColorAt(idx, col); if(ch.meshGhost.instanceColor) ch.meshGhost.instanceColor.needsUpdate = true; }
 if(ch.meshShell){ const sc = new THREE.Color(HIGHLIGHT_FILL_HEX); sc.offsetHSL(0,0,-0.22); sc.convertSRGBToLinear(); ch.meshShell.setColorAt(idx, sc); if(ch.meshShell.instanceColor) ch.meshShell.instanceColor.needsUpdate = true; }
 needsRender = true;
 }catch{}
 }
 function setHoverCell(target){
 try{
 const k = target ? `${target.arrId}:${target.x},${target.y},${target.z}` : null;
 if(k===hoverKey) return;
 // clear previous
 if(hoverKey){
 const [aid, rest] = hoverKey.split(':'); const [x,y,z] = rest.split(',').map(Number);
 updateCellColor(+aid, {x,y,z});
 }
 hoverKey = k;
 if(target){ applyHoverColor(target.arrId, target); }
 try{ window.UI?.setHoveredCell?.(target?.arrId || null, target || null); }catch{}
 }catch{}
 }
 function clearHoverCell(){ setHoverCell(null); }
 const temp=new THREE.Object3D(), tempM=new THREE.Matrix4();
 let needsRender = false;
 function refreshShadowCasting(){
 const enable = FancyGraphics.enabled && FancyGraphics.settings.solidGround;
 renderer.shadowMap.enabled = enable;
 renderer.shadowMap.autoUpdate = enable;
 if(enable){
 renderer.shadowMap.type = THREE.PCFSoftShadowMap;
 renderer.shadowMap.autoUpdate = true;
 }
 if(FancyGraphics.groups.ground){ FancyGraphics.groups.ground.visible = enable; }
 if(FancyGraphics.groups.mirror){
 FancyGraphics.groups.mirror.visible = FancyGraphics.settings.mirror && !FancyGraphics.settings.solidGround;
 }
 if(FancyGraphics.decor){
 const decorActive = FancyGraphics.enabled && (FancyGraphics.settings.waveGrid || FancyGraphics.settings.solidGround || FancyGraphics.settings.mirror);
 FancyGraphics.decor.visible = decorActive;
 }
 FancyGraphics.shadowLights.forEach(light=>{ light.castShadow = enable; });
 try{
 Object.values(Store.getState().arrays||{}).forEach(arr=>{
 Object.values(arr.chunks||{}).forEach(ch=>{
 if(ch.meshLOD1) ch.meshLOD1.castShadow = enable;
 if(ch.meshLOD2) ch.meshLOD2.castShadow = enable;
 if(ch.meshGhost) ch.meshGhost.castShadow = false;
 if(ch.meshShell) ch.meshShell.castShadow = false;
 });
 });
 }catch{}
 needsRender = true;
 }

 function setOceanEnabled(flag){
 const actual = OceanBackdrop.setEnabled(flag);
 try{
 const settings = OceanBackdrop.getSettings();
 const stored = { ...settings };
 delete stored.active;
 Store.setState(s=>({ scene:{ ...s.scene, ocean:{ ...(s.scene?.ocean||{}), ...stored } } }));
 try{ UI?.syncOceanSettings?.(); }catch{}
 }catch{}
 // Auto-configure FancyGraphics for optimal ocean atmosphere
 if(flag && FancyGraphics?.settings){
 FancyGraphics.settings.mirror = false;
 FancyGraphics.settings.bloomEnabled = true;
 FancyGraphics.settings.bloomStrength = 0.25;
 FancyGraphics.settings.bloomRadius = 0.5;
 FancyGraphics.settings.fogEnabled = true;
 FancyGraphics.settings.fogDensity = 0.008;
 try{ applyFancyRuntimeSettings?.(); }catch{}
 try{ UI?.syncGraphicsSettings?.(); }catch{}
 }
 needsRender = true;
 return actual;
 }

 function updateOceanSettings(patch){
 OceanBackdrop.updateSettings(patch);
 try{
 const settings = OceanBackdrop.getSettings();
 const stored = { ...settings };
 delete stored.active;
 Store.setState(s=>({ scene:{ ...s.scene, ocean:{ ...(s.scene?.ocean||{}), ...stored } } }));
 try{ UI?.syncOceanSettings?.(); }catch{}
 }catch{}
 needsRender = true;
 return OceanBackdrop.getSettings();
 }

 function getOceanSettings(){
 return OceanBackdrop.getSettings();
 }

 function updateShellVisibilityGlobal(){
 const showShells = !FancyGraphics.enabled;
 try{
 const arrays = Store.getState().arrays || {};
 Object.values(arrays).forEach(arr=>{
 if(!arr) return;
 const arrVisible = !arr.hidden;
 Object.values(arr.chunks||{}).forEach(ch=>{
 if(!ch?.meshShell) return;
 const lod = (ch.currentLOD == null) ? 1 : ch.currentLOD;
 ch.meshShell.visible = showShells && arrVisible && (lod === 1);
 });
 });
 }catch{}
 }
 // Instance bounce store
 const activeInstanceAnims = new Map(); // key `${arrId}:${z}:${type}:${idx}` -> {cancel,busy:true}
 // InteractionManager: transient overlaps and gobble checks
 const InteractionManager = (()=>{
 function getCellWorldBounds(arr,x,y,z){
 const c=cellWorldPos(arr,x,y,z);
 const min=c.clone().add(new THREE.Vector3(-0.5,-0.5,-0.5));
 const max=c.clone().add(new THREE.Vector3( 0.5, 0.5, 0.5));
 return new THREE.Box3(min,max);
 }
 function runChecks(moved){
 try{ checkTransient(moved); }catch{}
 const S=Store.getState();
 if(S?.interactions?.gobblingEnabled){ try{ checkGobble(moved); }catch{} }
 }
 function checkTransient(moved){
 const S=Store.getState(); const tx=Write.start('interaction.transient','overlaps');
 const others=Object.values(S.arrays).filter(a=>!a.hidden && a.id!==moved.id);
 Object.values(moved.chunks).forEach(ch=> ch.cells.forEach(ca=>{
 const bA=getCellWorldBounds(moved,ca.x,ca.y,ca.z);
 const fA=String(Formula.getCell({arrId:moved.id,x:ca.x,y:ca.y,z:ca.z})?.formula||'');
 others.forEach(b=> Object.values(b.chunks).forEach(chb=> chb.cells.forEach(cb=>{
 const bB=getCellWorldBounds(b,cb.x,cb.y,cb.z);
 if(!bA.intersectsBox(bB)) return;
 const fB=String(Formula.getCell({arrId:b.id,x:cb.x,y:cb.y,z:cb.z})?.formula||'');
 // naive check: always_exec flag present if last arg is 1 ... defer strict parsing
 if(/^=\s*OVERLAP\(/i.test(fA) && /\)\s*$/.test(fA) && fA.trim().endsWith('1)')){
 S.globalState.set('temp.overlap_target',{arrId:b.id,x:cb.x,y:cb.y,z:cb.z});
 Formula.executeAt({arrId:moved.id,x:ca.x,y:ca.y,z:ca.z}, undefined, tx);
 }
 if(/^=\s*OVERLAP\(/i.test(fB) && /\)\s*$/.test(fB) && fB.trim().endsWith('1)')){
 S.globalState.set('temp.overlap_target',{arrId:moved.id,x:ca.x,y:ca.y,z:ca.z});
 Formula.executeAt({arrId:b.id,x:cb.x,y:cb.y,z:cb.z}, undefined, tx);
 }
 })));
 }));
 S.globalState.delete('temp.overlap_target');
 if(tx.ops.length) Write.commit(tx);
 }
 function canGobble(gobbler,gobblee){
 // require every gobblee filled/formula cell to intersect at least one gobbler cell bounds
 const filled = [];
 Object.values(gobbler.chunks).forEach(ch=> ch.cells.forEach(c=>{ const fc=Formula.getCell({arrId:gobbler.id,x:c.x,y:c.y,z:c.z}); if(fc.value!==''||fc.formula){ filled.push(getCellWorldBounds(gobbler,c.x,c.y,c.z)); } }));
 if(!filled.length) return false;
 let ok=true;
 outer: for(const ch of Object.values(gobblee.chunks)){
 for(const c of ch.cells){ const fc=Formula.getCell({arrId:gobblee.id,x:c.x,y:c.y,z:c.z}); if(!(fc.value!==''||fc.formula)) continue; const bb=getCellWorldBounds(gobblee,c.x,c.y,c.z); let covered=false; for(const b of filled){ if(b.intersectsBox(bb)){ covered=true; break; } } if(!covered){ ok=false; break outer; } }
 }
 return ok;
 }
 function combineArrays(winner,loser){
 showToast(`Array #${winner.id} combined with #${loser.id}`);
 const tx=Write.start('interaction.combine',`Combine ${winner.id}+${loser.id}`);
 Object.values(loser.chunks).forEach(ch=> ch.cells.forEach(cL=>{
 const vL=Formula.getCell({arrId:loser.id,x:cL.x,y:cL.y,z:cL.z}); if(!(vL.value!==''||vL.formula)) return;
 // find any intersecting winner cell
 let target=null; for(const chw of Object.values(winner.chunks)){ for(const cW of chw.cells){ const bW=getCellWorldBounds(winner,cW.x,cW.y,cW.z); const bL=getCellWorldBounds(loser,cL.x,cL.y,cL.z); if(bW.intersectsBox(bL)){ target={x:cW.x,y:cW.y,z:cW.z}; break; } } if(target) break; }
 if(!target) return;
 const cellW=Formula.getCell({arrId:winner.id,x:target.x,y:target.y,z:target.z});
 const isEmptyW = (cellW.value===''||cellW.value==null) && !cellW.formula;
 // default mode: fill empty
 if(isEmptyW){ Write.set(tx, winner.id, target, { value: vL.value, formula: vL.formula }); }
 }));
 Write.commit(tx);
 try{ Actions.deleteArray(loser.id); }catch{}
 }
 function checkGobble(moved){
 const S=Store.getState(); const arrays=Object.values(S.arrays).filter(a=>!a.hidden);
 for(const other of arrays){ if(other.id===moved.id) continue; if(canGobble(moved,other)){ combineArrays(moved,other); return; } if(canGobble(other,moved)){ combineArrays(other,moved); return; } }
 }
 return { runChecks };
 })();

 function easeOutBack(t, s=1.70158){ const tt=t-1; return (tt*tt*((s+1)*tt + s) + 1); }

 function pulseCell(arr, cell, z){
 // Collect candidate records: core types + any edges overlays for this array/z
 const wantedKeys=[`${arr.id}:${z}:empty`,`$${arr.id}:${z}:ghost`,`$${arr.id}:${z}:filled`,`$${arr.id}:${z}:formula`];
 const recs=[];
 ['empty','ghost','filled','formula'].forEach(type=>{
 const rec=layerMeshes.get(`${arr.id}:${z}:${type}`); if(rec) recs.push({type,rec});
 });
 // Include all edge overlays for this array/z regardless of base group key
 layerMeshes.forEach((val,key)=>{
 if(val?.mesh?.userData?.type==='edges' && val.mesh?.userData?.arrayId===arr.id && val.mesh?.userData?.z===z){
 recs.push({type:'edges',rec:val});
 }
 });

 recs.forEach(({type,rec})=>{
 if(!rec||!rec.mesh||!rec.index2cell) return;
 const idx=rec.index2cell.findIndex(c=>c && c.x===cell.x && c.y===cell.y && c.z===cell.z);
 if(idx<0) return;
 const mesh=rec.mesh; const key=`${arr.id}:${z}:${type}:${idx}`;
 const running=activeInstanceAnims.get(key);
 // Guard: if running, ignore this click completely to prevent inflation
 if(running && running.busy){ return; }
 // capture base matrix
 const base=new THREE.Matrix4(); mesh.getMatrixAt(idx, base);
 let start=undefined; const duration=180; const amp=(type==='edges'?0.12:0.06);
 const state={cancel:false,busy:true}; activeInstanceAnims.set(key,state);
 const step=(ts)=>{
 if(state.cancel) { mesh.setMatrixAt(idx, base); mesh.instanceMatrix.needsUpdate=true; activeInstanceAnims.delete(key); return; }
 if(start===undefined) start=ts; const t=Math.min(1,(ts-start)/duration);
 const s=1 + amp*easeOutBack(t);
 const m=base.clone().multiply(new THREE.Matrix4().makeScale(s,s,s));
 mesh.setMatrixAt(idx,m); mesh.instanceMatrix.needsUpdate=true;
 if(t<1) requestAnimationFrame(step); else { // return to base for precision
 mesh.setMatrixAt(idx, base); mesh.instanceMatrix.needsUpdate=true; activeInstanceAnims.delete(key);
 }
 };
 requestAnimationFrame(step);
 });
 }

 // Text sprite creation for cell values
 function makeValueSprite(text, isFormula=false){
 const renderMode = Store.getState().scene.renderMode;
 
 if(renderMode === 'fancy') {
 // Rounded backdrop with drop shadow
 const padX = 12, padY = 8, fs = 28, r = 8;
 const font = `600 ${fs}px 'Roboto Mono', monospace`;

 // First measure
 const mCanvas = document.createElement('canvas');
 const mCtx = mCanvas.getContext('2d');
 mCtx.font = font;
 const w = Math.max(48, Math.ceil(mCtx.measureText(text).width) + padX * 2);
 const h = fs + padY * 2;

 // Draw
 const c = document.createElement('canvas');
 c.width = w; c.height = h;
 const ctx = c.getContext('2d');

 // Backdrop with rounded corners
 ctx.fillStyle = 'rgba(17, 24, 39, 0.66)'; // slate-900 @ ~66%
 ctx.strokeStyle = 'rgba(255,255,255,0.18)';
 ctx.lineWidth = 1;
 ctx.beginPath();
 const rr = (x, y, w, h, r) => {
 ctx.moveTo(x + r, y);
 ctx.arcTo(x + w, y, x + w, y + h, r);
 ctx.arcTo(x + w, y + h, x, y + h, r);
 ctx.arcTo(x, y + h, x, y, r);
 ctx.arcTo(x, y, x + w, y, r);
 };
 rr(0.5, 0.5, w - 1, h - 1, r);
 ctx.fill();
 ctx.stroke();

 // Text with subtle shadow
 ctx.font = font;
 ctx.textAlign = 'center';
 ctx.textBaseline = 'middle';
 ctx.shadowColor = 'rgba(0,0,0,0.35)';
 ctx.shadowBlur = 4;
 ctx.fillStyle = isFormula ? '#cfe0ff' : '#ffffff';
 ctx.fillText(text, w / 2, h / 2);

 const tex = new THREE.CanvasTexture(c);
 tex.anisotropy = 4;
 const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false });
 const spr = new THREE.Sprite(mat);
 spr.scale.set(0.9, 0.44, 1);
 spr.renderOrder = 2000;
 return markBillboard(spr);
 } else {
 // Simple mode (current behavior)
 const canvas=document.createElement('canvas');
 const ctx=canvas.getContext('2d');
 const fontSize=28; const padding=4;
 ctx.font=`600 ${fontSize}px 'Roboto Mono', monospace`;
 const metrics=ctx.measureText(text);
 canvas.width=Math.max(48, metrics.width+padding*2);
 canvas.height=fontSize+padding*2;
 
 // Draw text only (no backdrop card). Billboarded sprite will sit on cell face.
 ctx.clearRect(0,0,canvas.width,canvas.height);
 const fg = isFormula ? '#e6ffef' : '#ffffff';
 ctx.fillStyle = fg;
 ctx.font=`600 ${fontSize}px 'Roboto Mono', monospace`;
 ctx.textAlign='center'; ctx.textBaseline='middle';
 ctx.fillText(text, canvas.width/2, canvas.height/2);
 
 const texture=new THREE.CanvasTexture(canvas);
 // Place label on cell face (depth tested), slightly lifted to avoid z-fighting
 const material=new THREE.SpriteMaterial({map:texture, transparent:true, depthTest:true, depthWrite:false});
 material.toneMapped=false;
 const sprite=new THREE.Sprite(material);
 sprite.scale.set(0.5, 0.32, 1);
 sprite.renderOrder=2; // above solids, below edge overlays
 return markBillboard(sprite);
 }
 }
 // 3D label sprite for arrays (ID and name) - improved with depth testing
 function makeArrayLabelSprite(arr){
 const text = `#${arr.id}${arr.name ? ` "${arr.name}"` : ''}`;
 const canvas = document.createElement('canvas');
 const ctx = canvas.getContext('2d');
 const fontSize = 32, padding = 8, r = 12;
 ctx.font = `700 ${fontSize}px 'Inter', sans-serif`;
 const metrics = ctx.measureText(text);
 const w = Math.ceil(metrics.width + padding*2);
 const h = fontSize + padding*2;
 // Render at device pixel ratio for sharper text
 const dpr = Math.min(2, window.devicePixelRatio || 1);
 canvas.width = Math.max(1, Math.floor(w * dpr));
 canvas.height = Math.max(1, Math.floor(h * dpr));
 ctx.scale(dpr, dpr);

 // Check if present mode is active
 const isPresentMode = Scene.isPresentEnabled ? Scene.isPresentEnabled() : false;

 if(isPresentMode){
 // Crystal background for present mode (matches other UI elements)
 ctx.fillStyle = 'rgba(17, 24, 39, 0.66)'; // slate-900 @ ~66%
 ctx.strokeStyle = 'rgba(255,255,255,0.18)';
 ctx.lineWidth = 1;
 ctx.beginPath();
 ctx.moveTo(r,0.5);
 ctx.arcTo(w-0.5,0.5,w-0.5,h-0.5,r); 
 ctx.arcTo(w-0.5,h-0.5,0.5,h-0.5,r); 
 ctx.arcTo(0.5,h-0.5,0.5,0.5,r); 
 ctx.arcTo(0.5,0.5,w-0.5,0.5,r);
 ctx.closePath(); 
 ctx.fill(); 
 ctx.stroke();
 ctx.fillStyle = '#cfe0ff'; // Light blue text for dark background
 } else {
 // rounded white pill for normal mode
 ctx.fillStyle = 'rgba(255,255,255,0.85)';
 ctx.strokeStyle = 'rgba(0,0,0,0.10)';
 ctx.lineWidth = 2;
 ctx.beginPath();
 ctx.moveTo(r,0);
 ctx.arcTo(w,0,w,h,r); ctx.arcTo(w,h,0,h,r); ctx.arcTo(0,h,0,0,r); ctx.arcTo(0,0,w,0,r);
 ctx.closePath(); ctx.fill(); ctx.stroke();
 ctx.fillStyle = '#1f2937';
 }
 
 ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
 ctx.font = `700 ${fontSize}px 'Inter', sans-serif`;
 ctx.fillText(text, w/2, h/2);

 const tex = new THREE.CanvasTexture(canvas);
 tex.colorSpace = THREE.SRGBColorSpace; // correct gamma for UI texture
 tex.anisotropy = renderer?.capabilities?.getMaxAnisotropy?.() || 1;
 tex.minFilter = THREE.LinearMipMapLinearFilter;
 tex.magFilter = THREE.LinearFilter;
 tex.generateMipmaps = true;

 const mat = new THREE.SpriteMaterial({
 map: tex,
 transparent: true,
 depthTest: true,
 depthWrite: false
 });
 mat.toneMapped = false;

 const mesh = new THREE.Sprite(mat);
 const aspect = w/h;
 // Slightly reduce width/height to avoid a stretched look while preserving aspect
 mesh.scale.set(1.0*aspect, 1.0, 1); // world-unit size
 // Proper render order: above voxels (100-300) but below transparent UI (2000+)
 mesh.renderOrder = 500; 
 mesh.userData.isLabel = true;
 return markBillboard(mesh);
 }
 const COLORS = {
 empty: 0xffffff, // empty cells: clean white
 emptyBorder: 0xe5e7eb, // empty border: light gray
 filled: 0x3b82f6, // data cells: vibrant blue
 formula: 0x16a34a, // formulas: dark green
 emitted: 0x86efac, // emitted values: light green
 ghost: 0xf3f4f6, // ghost layers: very light gray
 ghostBorder: 0xd1d5db, // ghost border: medium gray
 focus: 0xf59e0b, // focus highlight: amber
 frame: 0x374151, // array frame: dark gray
 grab: 0x06b6d4 // grab handle: cyan
 };
 // Fixed visibility settings (UI removed)
 const DEFAULT_VISIBILITY = {
 empty: { color: COLORS.empty, outlineColor: 0xe5e7eb, outlineThickness: 1.0, outlineOpacity: 0.35 },
 value: { color: COLORS.filled, outlineColor: null, outlineThickness: 1.0, outlineOpacity: 0.35 },
 formula: { color: COLORS.formula, outlineColor: null, outlineThickness: 1.0, outlineOpacity: 0.35 },
 emitted: { color: COLORS.emitted, outlineColor: null, outlineThickness: 1.0, outlineOpacity: 0.35 }
 };
 window.VisibilitySettings = DEFAULT_VISIBILITY;
 function typeKeyFrom(raw){
 let t = String(raw||'value');
 if(t.startsWith('ghost_')) t = t.slice(6);
 if(t==='filled') t='value';
 return t;
 }
 function baseHexForTypeKey(tk){
 const vs = window.VisibilitySettings || {}; const s = vs[tk];
 return (s && typeof s.color==='number') ? s.color : (tk==='empty'?COLORS.empty: tk==='formula'?COLORS.formula: tk==='emitted'?COLORS.emitted: COLORS.filled);
 }
 function ghostBaseHex(){
 const vs = window.VisibilitySettings || {};
 const setting = vs.ghost;
 if(setting && typeof setting.color === 'number') return setting.color;
 return COLORS.ghost;
 }
 const ghostBaseLinearCache = { hex:null, color:null };
 function ghostBaseLinearColor(){
 const hex = ghostBaseHex();
 if(ghostBaseLinearCache.color && ghostBaseLinearCache.hex === hex) return ghostBaseLinearCache.color;
 const col = new THREE.Color(hex);
 col.convertSRGBToLinear();
 ghostBaseLinearCache.hex = hex;
 ghostBaseLinearCache.color = col;
 return col;
 }
 function tintGhostColorFrom(colLinear){
 try{
 const base = ghostBaseLinearColor().clone();
 return base.lerp(colLinear, 0.65);
 }catch{}
 return colLinear.clone();
 }
 // Make default outlines subtler: 1.01 instead of 1.04
 const BASE_OUTLINE_SCALE = 1.01;
 function outlineParamsForTypeKey(tk){
 const vs = window.VisibilitySettings || {}; const s = vs[tk]||{};
 const setting = Number(s.outlineThickness||1.0);
 const actual = BASE_OUTLINE_SCALE * (isFinite(setting)?setting:1.0);
 const thickness = Math.max(0.98, Math.min(1.12, actual));
 const colorHex = (typeof s.outlineColor==='number' ? s.outlineColor : null);
 const opacity = (typeof s.outlineOpacity==='number' ? s.outlineOpacity : 0.35);
 return { thickness, colorHex, opacity };
 }
 const focusMarker=new THREE.Mesh(new THREE.BoxGeometry(1.06,1.06,1.06),new THREE.MeshBasicMaterial({color:COLORS.focus,wireframe:true}));
 const selectionCelli = createSelectionCelliHighlight();

 function createSelectionCelliHighlight(){
 const group = new THREE.Group();
 group.name = 'SelectionCelliHighlight';

 const MAT_BODY = new THREE.MeshBasicMaterial({ color: 0xf59e0b, transparent: true, opacity: 0.92 });
 const MAT_MOUTH = new THREE.MeshBasicMaterial({ color: 0x111827, transparent: true, opacity: 0.95, side: THREE.DoubleSide });
 const MAT_EYE = new THREE.MeshBasicMaterial({ color: 0x111827, transparent: false });
 const MAT_CHEEK = new THREE.MeshBasicMaterial({ color: 0xec4899, transparent: true, opacity: 0.9 });
 const MAT_BOW = new THREE.MeshBasicMaterial({ color: 0xfbbf24, transparent: true, opacity: 0.92, side: THREE.DoubleSide });
 MAT_BODY.toneMapped = false;
 MAT_MOUTH.toneMapped = false;
 MAT_EYE.toneMapped = false;
 MAT_CHEEK.toneMapped = false;
 MAT_BOW.toneMapped = false;

 const bodyFrame = new THREE.Mesh(new THREE.BufferGeometry(), MAT_BODY);
 bodyFrame.material.side = THREE.DoubleSide;
 bodyFrame.name = 'CelliBodyFrame';
 group.add(bodyFrame);

 const mouthFrame = new THREE.Mesh(new THREE.BufferGeometry(), MAT_MOUTH);
 mouthFrame.name = 'CelliMouthFrame';
 group.add(mouthFrame);

 const eyeGeo = new THREE.CircleGeometry(0.12, 24);
 const eyeLeft = new THREE.Mesh(eyeGeo, MAT_EYE);
 const eyeRight = eyeLeft.clone();
 eyeLeft.name = 'CelliEyeLeft';
 eyeRight.name = 'CelliEyeRight';
 group.add(eyeLeft, eyeRight);

 const cheekGeo = new THREE.CircleGeometry(0.16, 24);
 const cheekLeft = new THREE.Mesh(cheekGeo, MAT_CHEEK);
 const cheekRight = cheekLeft.clone();
 cheekLeft.name = 'CelliCheekLeft';
 cheekRight.name = 'CelliCheekRight';
 group.add(cheekLeft, cheekRight);

 const bowGroup = new THREE.Group();
 bowGroup.name = 'CelliBow';
 const bowWingGeo = new THREE.ShapeGeometry(new THREE.Shape([new THREE.Vector2(0.18,0), new THREE.Vector2(-0.1,0.18), new THREE.Vector2(-0.1,-0.18)]));
 const bowWingLeft = new THREE.Mesh(bowWingGeo, MAT_BOW);
 bowWingLeft.position.set(-0.12, 0, 0);
 const bowWingRight = bowWingLeft.clone();
 bowWingRight.scale.x = -1;
 bowWingRight.position.set(0.12, 0, 0);
 const bowKnot = new THREE.Mesh(new THREE.CircleGeometry(0.08, 20), MAT_BOW);
 bowKnot.position.set(0,0,0.005);
 bowGroup.add(bowWingLeft, bowWingRight, bowKnot);
 group.add(bowGroup);

 group.userData = {
 bodyFrame,
 mouthFrame,
 eyeLeft,
 eyeRight,
 cheekLeft,
 cheekRight,
 bowGroup,
 lastSignature: null,
 stretchState: null,
 lastStretchSignature: null
 };

 return group;
 }

 function startSelectionCelliStretch(counts, center){
 if(!selectionCelli) return;
 const data = selectionCelli.userData || {};
 const signature = `${counts.x||1}:${counts.y||1}:${counts.z||1}:${Math.round((center?.x||0)*10)}:${Math.round((center?.y||0)*10)}:${Math.round((center?.z||0)*10)}`;
 if(data.lastStretchSignature === signature) return;
 const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
 const from = new THREE.Vector3(
 (counts.x||1) > 1 ? 0.4 : 1,
 (counts.y||1) > 1 ? 0.4 : 1,
 (counts.z||1) > 1 ? 0.7 : 1
 );
 const to = new THREE.Vector3(1,1,1);
 data.stretchState = { start: now, duration: 320, from, to };
 data.lastStretchSignature = signature;
 selectionCelli.userData = data;
 selectionCelli.scale.copy(from);
 needsRender = true;
 }

 function drawRoundedRectPath(path, width, height, radius){
 const hw = width / 2;
 const hh = height / 2;
 const r = Math.min(radius, hw, hh);
 path.moveTo(-hw + r, -hh);
 path.lineTo(hw - r, -hh);
 path.quadraticCurveTo(hw, -hh, hw, -hh + r);
 path.lineTo(hw, hh - r);
 path.quadraticCurveTo(hw, hh, hw - r, hh);
 path.lineTo(-hw + r, hh);
 path.quadraticCurveTo(-hw, hh, -hw, hh - r);
 path.lineTo(-hw, -hh + r);
 path.quadraticCurveTo(-hw, -hh, -hw + r, -hh);
 path.closePath();
 }

 function createRoundedFrameGeometry({ outerWidth, outerHeight, innerWidth, innerHeight, outerRadius, innerRadius, depth }){
 const shape = new THREE.Shape();
 drawRoundedRectPath(shape, outerWidth, outerHeight, outerRadius);
 const hole = new THREE.Path();
 drawRoundedRectPath(hole, innerWidth, innerHeight, innerRadius);
 shape.holes.push(hole);
 const geo = new THREE.ExtrudeGeometry(shape, { depth, bevelEnabled:false, steps:1 });
 geo.center();
 return geo;
 }

 function planeAxesForFace(axis){
 // Returns which axes form the plane perpendicular to the given axis
 // horizontal and vertical are the two axes that span the visible face
 if(axis===0) return {horizontal:2, vertical:1}; // X face: Z is horizontal, Y is vertical
 if(axis===1) return {horizontal:0, vertical:2}; // Y face (top/bottom): X is horizontal, Z is vertical
 return {horizontal:0, vertical:1}; // Z face (front/back): X is horizontal, Y is vertical
 }

 function updateSelectionCelliHighlight(arr, center, counts, scale, faceHint){
 if(!selectionCelli || !arr) return;
 const data = selectionCelli.userData || {};
 if(!data.bodyFrame || !data.mouthFrame) return;

 const axisKeys = ['x','y','z'];
 let axis = null;
 let sign = null;
 if(faceHint){
 if(Number.isInteger(faceHint.axisIndex)){
 axis = Math.max(0, Math.min(2, faceHint.axisIndex|0));
 } else if(faceHint.axis && axisKeys.includes(faceHint.axis)){
 axis = axisKeys.indexOf(faceHint.axis);
 }
 const hintedSign = Number(faceHint.sign);
 if(Number.isFinite(hintedSign) && hintedSign !== 0){
 sign = hintedSign > 0 ? 1 : -1;
 }
 }
 if(axis===null || sign===null){
 const facing = facingFromCamera(arr._frame || { matrixWorld:new THREE.Matrix4() });
 if(axis===null) axis = Number.isFinite(facing.axis) ? facing.axis : 2;
 if(sign===null) sign = (facing.sign===0) ? 1 : (facing.sign||1);
 }

 const planeAxes = planeAxesForFace(axis);
 const axisKey = axisKeys[axis];
 const horizontalCount = counts[axisKeys[planeAxes.horizontal]] || 1;
 const verticalCount = counts[axisKeys[planeAxes.vertical]] || 1;
 const depthCount = Math.max(1, counts[axisKey] || 1);

 // Calculate dimensions to cover the full visible extent of selection
 // Width and height should match the actual cell counts in those directions
 const cellWidth = horizontalCount * scale;
 const cellHeight = verticalCount * scale;
 
 console.log(`[CELLI] Border sizing: axis=${axis} (${axisKey}), horizontal=${axisKeys[planeAxes.horizontal]}:${horizontalCount}, vertical=${axisKeys[planeAxes.vertical]}:${verticalCount}, depth=${axisKey}:${depthCount}, w=${cellWidth.toFixed(2)}, h=${cellHeight.toFixed(2)}`);
 const cellDepth = Math.max(scale, scale * 0.9);
 const pad = Math.max(scale * 0.08, 0.06);
 const bodyBorder = Math.max(scale * 0.22, Math.min(cellWidth, cellHeight) * 0.09);
 const mouthBorder = Math.max(scale * 0.10, Math.min(cellWidth, cellHeight) * 0.05);

 const innerWidth = cellWidth + pad * 2;
 const innerHeight = cellHeight + pad * 2;
 const mouthOuterWidth = innerWidth + mouthBorder * 2;
 const mouthOuterHeight = innerHeight + mouthBorder * 2;
 const outerWidth = mouthOuterWidth + bodyBorder * 2;
 const outerHeight = mouthOuterHeight + bodyBorder * 2;

 // Frame depth should cover the entire selection depth
 const thicknessBase = Math.max(depthCount * scale, 1.05);
 const depth = thicknessBase;
 const bodyDepth = depth;
 const mouthDepth = Math.max(thicknessBase * 0.58, 0.62);

 const radiusRatio = 0.12;
 const outerRadius = Math.min(outerWidth, outerHeight) * radiusRatio;
 const mouthOuterRadius = Math.min(mouthOuterWidth, mouthOuterHeight) * radiusRatio;
 const mouthInnerRadius = Math.min(innerWidth, innerHeight) * (radiusRatio * 0.85);

 data.bodyFrame.geometry?.dispose?.();
 data.bodyFrame.geometry = createRoundedFrameGeometry({
 outerWidth,
 outerHeight,
 innerWidth: mouthOuterWidth,
 innerHeight: mouthOuterHeight,
 outerRadius,
 innerRadius: mouthOuterRadius,
 depth: bodyDepth
 });
 data.bodyFrame.position.set(0,0,0);

 data.mouthFrame.geometry?.dispose?.();
 data.mouthFrame.geometry = createRoundedFrameGeometry({
 outerWidth: mouthOuterWidth,
 outerHeight: mouthOuterHeight,
 innerWidth,
 innerHeight,
 outerRadius: mouthOuterRadius,
 innerRadius: mouthInnerRadius,
 depth: mouthDepth
 });
 data.mouthFrame.position.set(0,0,(bodyDepth - mouthDepth)/2);

 const faceZ = bodyDepth/2 + 0.02;
 const totalWidth = innerWidth;
 const totalHeight = innerHeight;
 const halfWidth = totalWidth / 2;
 const halfHeight = totalHeight / 2;
 const featureSpan = Math.min(innerWidth, innerHeight);

 const eyeSpacing = Math.min(halfWidth - scale * 0.02, totalWidth * (0.12 / 0.8));
 const eyeHeight = Math.min(halfHeight - scale * 0.02, totalHeight * (0.13 / 0.8));
 const eyeScale = Math.max(0.85, Math.min(1.3, featureSpan * 0.32));
 data.eyeLeft.scale.set(eyeScale, eyeScale, 1);
 data.eyeRight.scale.copy(data.eyeLeft.scale);
 data.eyeLeft.position.set(-eyeSpacing, eyeHeight, faceZ);
 data.eyeRight.position.set(eyeSpacing, eyeHeight, faceZ);

 const cheekSpacing = Math.min(halfWidth - scale * 0.015, totalWidth * (0.25 / 0.8));
 const cheekHeight = -Math.min(halfHeight - scale * 0.015, totalHeight * (0.08 / 0.8));
 const cheekScale = Math.max(0.9, Math.min(1.35, featureSpan * 0.34));
 data.cheekLeft.scale.set(cheekScale, cheekScale, 1);
 data.cheekRight.scale.copy(data.cheekLeft.scale);
 data.cheekLeft.position.set(-cheekSpacing, cheekHeight, faceZ - 0.01);
 data.cheekRight.position.set(cheekSpacing, cheekHeight, faceZ - 0.01);

 const bowHeight = outerHeight/2 + Math.max(scale * 0.16, 0.22);
 const bowScale = Math.max(0.6, Math.min(1.45, outerWidth / 3.4));
 data.bowGroup.position.set(0, bowHeight, bodyDepth/2 - mouthDepth/2 + 0.04);
 data.bowGroup.rotation.x = -0.25;
 data.bowGroup.scale.setScalar(bowScale);

 startSelectionCelliStretch(counts, center);

 const frameQuat = arr._frame ? arr._frame.getWorldQuaternion(new THREE.Quaternion()) : new THREE.Quaternion();
 const basisX = new THREE.Vector3(1,0,0).applyQuaternion(frameQuat);
 const basisY = new THREE.Vector3(0,1,0).applyQuaternion(frameQuat);
 const basisZ = new THREE.Vector3(0,0,1).applyQuaternion(frameQuat);
 const bases = [basisX, basisY, basisZ];

 // Forward points out from the face (toward camera)
 const forward = bases[axis].clone().multiplyScalar(sign).normalize();
 
 // Build right and up vectors that align with the cell grid
 // Use world coordinates and project onto the plane perpendicular to forward
 const worldRight = new THREE.Vector3();
 const worldUp = new THREE.Vector3();
 
 // Choose right and up based on which axis we're facing
 if(axis === 0){ // X face
 worldRight.copy(bases[2]); // Z axis 
 worldUp.copy(bases[1]); // Y axis
 } else if(axis === 1){ // Y face 
 worldRight.copy(bases[0]); // X axis
 worldUp.copy(bases[2]); // Z axis
 // When looking from below, flip up to keep Celli upright
 if(sign < 0) worldUp.multiplyScalar(-1);
 } else { // Z face
 worldRight.copy(bases[0]); // X axis
 worldUp.copy(bases[1]); // Y axis
 // When looking from back (negative Z), flip up to keep Celli upright
 if(sign < 0) worldUp.multiplyScalar(-1);
 }
 
 console.log(`[CELLI] Border: axis=${axis} (${axisKey}), sign=${sign}, counts=(${counts.x},${counts.y},${counts.z}), h=${horizontalCount}, v=${verticalCount}, d=${depthCount}`);
 console.log(`[CELLI] Vectors: fwd=(${forward.x.toFixed(2)},${forward.y.toFixed(2)},${forward.z.toFixed(2)}), right=(${worldRight.x.toFixed(2)},${worldRight.y.toFixed(2)},${worldRight.z.toFixed(2)}), up=(${worldUp.x.toFixed(2)},${worldUp.y.toFixed(2)},${worldUp.z.toFixed(2)})`);

 // Position the border to span the entire selection depth
 // The border mesh has depth equal to the selection depth
 // Position it at the selection center so it covers from back edge to front edge
 const pos = worldPos(arr, center.x, center.y, center.z);
 // Offset slightly toward camera so border front face appears in front
 const offsetTowardCamera = forward.clone().multiplyScalar(0.02);
 const adjustedPos = pos.clone().add(offsetTowardCamera);
 selectionCelli.position.copy(adjustedPos);
 
 // Snap rotation to align with the viewing axis
 const rotMatrix = new THREE.Matrix4().makeBasis(worldRight, worldUp, forward);
 selectionCelli.rotation.setFromRotationMatrix(rotMatrix);
 
 selectionCelli.visible = true;
 selectionCelli.userData.lastSignature = `${arr.id}:${center.x},${center.y},${center.z}:${counts.x},${counts.y},${counts.z}:${axis}:${sign}`;
 
 console.log(`[CELLI] Border placed: pos=(${adjustedPos.x.toFixed(2)},${adjustedPos.y.toFixed(2)},${adjustedPos.z.toFixed(2)}), axis=${axis}, sign=${sign}, visible=${selectionCelli.visible}`);
 
 needsRender = true;
 }
 
 // Singleton geometries and materials for performance
 const GEO_VOXEL = new RoundedBoxGeometry(0.9, 0.9, 0.9, 2, 0.1);
 const SHELL_SCALE = 1.08; // shells slightly larger than fills
 const GEO_SHELL = new RoundedBoxGeometry(0.9*SHELL_SCALE, 0.9*SHELL_SCALE, 0.9*SHELL_SCALE, 2, 0.1);
 function addWhiteVertexColors(geo){
 try{
 const n = geo.getAttribute('position')?.count|0;
 if(!geo.getAttribute('color') && n>0){ const arr = new Float32Array(n*3); arr.fill(1.0); geo.setAttribute('color', new THREE.BufferAttribute(arr, 3)); }
 }catch{}
 }
 addWhiteVertexColors(GEO_VOXEL);
 addWhiteVertexColors(GEO_SHELL);
 const cellMaterialCache = new Map();
 function materialKeyFor(type){
 const base = String(type||'').startsWith('ghost') ? 'ghost' : String(type||'filled');
 const mode = FancyGraphics.enabled ? 'present' : 'simple';
 const frosted = FancyGraphics.enabled && FancyGraphics.settings.transmission ? 'frosted' : 'solid';
 return `${mode}:${frosted}:${base}`;
 }
 function createCellMaterial(type='filled'){
 const baseType = String(type||'').startsWith('ghost') ? 'ghost' : String(type||'filled');
 const key = materialKeyFor(baseType);
 if(cellMaterialCache.has(key)) return cellMaterialCache.get(key);

 let material;
 if(baseType === 'ghost'){
 if(FancyGraphics.enabled){
 material = new THREE.MeshPhysicalMaterial({
 color: new THREE.Color(0xffffff),
 vertexColors: true,
 transparent: true,
 opacity: 0.28,
 depthWrite: false,
 depthTest: true,
 roughness: 0.85,
 metalness: 0.05,
 envMapIntensity: 0.35,
 transmission: 0.0,
 clearcoat: 0.0
 });
 material.blending = THREE.NormalBlending;
 material.toneMapped = true;
 }else{
 // Standard mode: use unlit BasicMaterial for ghost
 material = new THREE.MeshBasicMaterial({
 color: 0xffffff,
 transparent: true,
 opacity: 0.35,
 blending: THREE.NormalBlending,
 depthWrite: false,
 depthTest: true,
 vertexColors: true
 });
 material.toneMapped = false;
 }
 }else{
 if(FancyGraphics.enabled){
 const frosted = !!FancyGraphics.settings.transmission;
 const params = {
 color: new THREE.Color(0xffffff),
 vertexColors: true,
 roughness: frosted ? 0.78 : 0.32,
 metalness: frosted ? 0.06 : 0.22,
 envMapIntensity: frosted ? 1.3 : 1.2,
 clearcoat: 0.35,
 clearcoatRoughness: frosted ? 0.55 : 0.2,
 reflectivity: 0.5,
 depthWrite: true,
 depthTest: true
 };
 if(frosted){
 Object.assign(params, {
 transparent: true,
 opacity: 0.9,
 transmission: 0.58,
 thickness: 1.4,
 ior: 1.18,
 attenuationColor: new THREE.Color(0xcfe3ff),
 attenuationDistance: 1.25
 });
 }else{
 Object.assign(params, {
 transparent: false,
 transmission: 0.0
 });
 }
 material = new THREE.MeshPhysicalMaterial(params);
 material.toneMapped = true;
 }else{
 // Standard mode: use unlit BasicMaterial for flat appearance
 const isEmpty = (baseType === 'empty');
 material = new THREE.MeshBasicMaterial({
 color: isEmpty ? COLORS.empty : 0xffffff,
 transparent: false,
 depthWrite: true,
 vertexColors: true
 });
 material.toneMapped = false;
 }
 }

 material.userData = { ...(material.userData||{}), pass: baseType === 'ghost' ? 'ghost' : 'solid' };
 cellMaterialCache.set(key, material);
 return material;
 }

 function rebuildCellMaterialRefs(){
 try{
 const arrays = Store.getState().arrays || {};
 Object.values(arrays).forEach(arr=>{
 const collected = new Set();
 Object.values(arr.chunks||{}).forEach(ch=>{
 if(ch?.meshLOD1?.material) collected.add(ch.meshLOD1.material);
 if(ch?.meshGhost?.material) collected.add(ch.meshGhost.material);
 });
 arr._cellMaterials = Array.from(collected);
 });
 }catch{}
 }

 function refreshCellMaterials(){
 try{
 const visited = new Set();
 const oldMaterials = new Set();
 cellMaterialCache.clear();

 const assign = (mesh, type)=>{
 if(!mesh || visited.has(mesh.uuid)) return;
 visited.add(mesh.uuid);
 if(mesh.material) oldMaterials.add(mesh.material);
 mesh.material = createCellMaterial(type);
 mesh.material.needsUpdate = true;
 };

 try{
 Object.values(Store.getState().arrays||{}).forEach(arr=>{
 Object.values(arr.chunks||{}).forEach(ch=>{
 assign(ch.meshLOD1, 'filled');
 assign(ch.meshGhost, 'ghost');
 if(ch.meshLOD2) assign(ch.meshLOD2, 'filled');
 });
 });
 }catch{}

 try{
 layerMeshes.forEach(rec=>{
 const mesh = rec?.mesh;
 if(!mesh) return;
 if(mesh.userData?.isGhost) return;
 const base = mesh.userData?.type || 'filled';
 const want = String(base).startsWith('ghost') ? 'ghost' : base;
 assign(mesh, want);
 });
 }catch{}
 try{ chunkMeshes.forEach(mesh=> assign(mesh, 'filled')); }catch{}

 oldMaterials.forEach(mat=>{ try{ mat?.dispose?.(); }catch{} });
 rebuildCellMaterialRefs();
 updateShellVisibilityGlobal();
 needsRender = true;
 }catch(e){ console.warn('refreshCellMaterials failed', e); }
 }
 
 // Debounced collider rebuilds
 const colliderRebuildQueue = new Map(); // arrayId -> timeout
 
 // Animation and physics guards
 let isAnimating = false;
 let physicsStepping = false;
 let __rafId = 0, __animating = false;
 // Value sprites for per-cell text labels (declared earlier in Scene scope)
 function startLoop(){ if(__animating) return; __animating = true; __rafId = requestAnimationFrame(animate); }
 function stopLoop(){ if(!__animating) return; cancelAnimationFrame(__rafId); __animating = false; }
 // Global map for value label sprites (persist across rebuilds)
 window.valueSprites = window.valueSprites || new Map();
 const valueSprites = window.valueSprites;
 window.cellLights = window.cellLights || new Map();
 const cellLights = window.cellLights;
 window.cellLightTargets = window.cellLightTargets || new Map();
 const cellLightTargets = window.cellLightTargets;
 const LIGHT_GLOW_GEOMETRY = new THREE.SphereGeometry(0.42, 20, 20);
 let lastCamSig = '';
 const SPRITE_FACE_OFFSET = 0.58; // push label fully outside cell face (avoid z-fight/inside look)
 function axisCharToNum(ch){ return ch==='X'?0 : ch==='Y'?1 : 2; }
 function getPreferredFacing(arr){
 // Prefer occlusion axis for consistency with d-pad/occlusion; fallback to camera-facing state
 let axisNum = null;
 const selection = Store.getState().selection;
 const oc = (selection?.arrayId === arr?.id) ? (arr?._occlusionData || {}) : null;
 if(oc && (oc.facing || oc.axis)){
 const ch = oc.facing || oc.axis; // may be 'X'|'Y'|'Z'
 if(typeof ch === 'string') axisNum = axisCharToNum(ch);
 else if(typeof ch === 'number') axisNum = ch|0;
 }
 try{ updateFacingState(arr); }catch{}
 const st = arr._facingState || {axis:(axisNum??2), sign:1};
 if(axisNum==null) axisNum = st.axis;
 const sign = (st.sign||1) >= 0 ? 1 : -1;
 return { axis: axisNum, sign };
 }
 function camSig(){ try{ const p=camera?.position||{x:0,y:0,z:0}; const t=controls?.target||{x:0,y:0,z:0}; return `${p.x.toFixed(2)},${p.y.toFixed(2)},${p.z.toFixed(2)}|${t.x.toFixed(2)},${t.y.toFixed(2)},${t.z.toFixed(2)}`; }catch{ return ''; } }
 function maybeUpdateLabels(){ const sig=camSig(); if(sig===lastCamSig) return; lastCamSig=sig; try{ const arrays=Object.values(Store.getState().arrays); for(const arr of arrays){ if(!arr.hidden && arr._frame){ updateArrayLabelPlacement(arr); updateArrayValueSpritePlacement(arr); } } }catch{} }
 // Reposition value sprites on camera-facing changes as well, per array
 function updateArrayValueSpritePlacement(arr){
 try{
 if(!arr || !arr._frame) return;
 // Use the same face as occlusion/arrow mapping for consistency
 const face = getPreferredFacing(arr);
 const scale = arrayVoxelScale(arr);
 const cellScale = voxelDisplayScale(scale);
 const sign = face.sign;
 const offsetBase = SPRITE_FACE_OFFSET * scale;
 const faceOffset = offsetBase * sign;
 // Iterate value sprites for this array only
 valueSprites.forEach((sprite, key)=>{
 if(!String(key).startsWith(`${arr.id}:`)) return;
 const parts = String(key).split(':'); const coords = parts[1]||'';
 const [sx, sy, sz] = coords.split(',').map(Number);
 const base = localPos(arr, sx, sy, sz);
 let dx=0, dy=0, dz=0;
 if(face.axis===2){ dz = faceOffset; }
 else if(face.axis===0){ dx = faceOffset; }
 else { dy = faceOffset; }
 sprite.position.set(base.x+dx, base.y+dy, base.z+dz);
 // Ensure sprite is visible when repositioned; occlusion masking will hide if blocked
 sprite.visible = true;
 });
 }catch{}
 }

 function lightKey(ref){ if(!ref) return ''; return `${ref.arrId}:${ref.x},${ref.y},${ref.z}`; }
 function untrackLightTarget(key, targetRef){
 if(!targetRef) return;
 const set = cellLightTargets.get(targetRef.arrId);
 if(set){ set.delete(key); if(set.size===0) cellLightTargets.delete(targetRef.arrId); }
 }
 function trackLightTarget(key, targetRef){
 if(!targetRef) return;
 let set = cellLightTargets.get(targetRef.arrId);
 if(!set){ set = new Set(); cellLightTargets.set(targetRef.arrId, set); }
 set.add(key);
 }
 function ensureLightInstance(record){
 if(!record) return;
 const wantSpot = record.config?.mode === 'spot';
 const haveSpot = !!record.light?.isSpotLight;
 if(!record.light || wantSpot !== haveSpot){
 if(record.light){ record.group.remove(record.light); }
 if(record.target){ record.group.remove(record.target); record.target = null; }
 if(wantSpot){
 const spot = new THREE.SpotLight(0xffffff, 1, 30, Math.PI/4, 0.35, 2.0);
 spot.castShadow = false;
 const target = new THREE.Object3D();
 record.group.add(spot);
 record.group.add(target);
 spot.target = target;
 record.light = spot;
 record.target = target;
 } else {
 const point = new THREE.PointLight(0xffffff, 1, 30, 2);
 point.castShadow = false;
 record.group.add(point);
 record.light = point;
 record.target = null;
 }
 }
 if(!record.glow){
 const glowMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent:true, opacity:0, depthWrite:false, depthTest:false, blending:THREE.AdditiveBlending });
 const glow = new THREE.Mesh(LIGHT_GLOW_GEOMETRY, glowMat);
 glow.renderOrder = 1998;
 record.group.add(glow);
 record.glow = glow;
 }
 }
 function attachLightToArray(record){
 if(!record) return;
 const arr = Store.getState().arrays[record.source.arrId];
 if(!arr) return;
 const local = localPos(arr, record.source.x, record.source.y, record.source.z);
 if(arr._frame){
 if(record.group.parent !== arr._frame){
 record.group.parent?.remove(record.group);
 arr._frame.add(record.group);
 }
 record.group.position.copy(local);
 } else {
 const world = cellWorldPos(arr, record.source.x, record.source.y, record.source.z);
 if(record.group.parent !== scene){
 record.group.parent?.remove(record.group);
 scene.add(record.group);
 }
 record.group.position.copy(world);
 }
 }
 function updateLightTarget(record){
 if(!record?.light?.isSpotLight) return;
 const arr = Store.getState().arrays[record.source.arrId];
 if(!arr) return;
 const originWorld = cellWorldPos(arr, record.source.x, record.source.y, record.source.z);
 let dir = new THREE.Vector3(0,-1,0);
 const targetRef = record.config?.targetRef;
 if(targetRef){
 const tgtArr = Store.getState().arrays[targetRef.arrId];
 if(tgtArr){
 const targetWorld = cellWorldPos(tgtArr, targetRef.x, targetRef.y, targetRef.z);
 dir = targetWorld.clone().sub(originWorld);
 }
 }
 if(dir.lengthSq() < 1e-6) dir.set(0,-1,0);
 dir.normalize();
 if(arr._frame){
 const inv = new THREE.Matrix3().setFromMatrix4(new THREE.Matrix4().copy(arr._frame.matrixWorld).invert());
 dir.applyMatrix3(inv).normalize();
 }
 const range = record.config?.beamLength ?? 4.5;
 if(record.target){ record.target.position.copy(dir.clone().multiplyScalar(range)); }
 }
 function updateLightProperties(record){
 if(!record?.light) return;
 const lumens = Math.max(0, Number(record.config?.lumens ?? 0));
 // Match present-mode lighting intensity (key light is 3.2, we scale from that)
 // Default 800 lumens should be ~2.0 intensity (similar to fill+rim combined)
 const intensity = lumens <= 0 ? 0 : Math.max(0.8, (lumens / 800) * 2.5);
 const distance = record.config?.distance ?? (lumens <= 0 ? 0 : Math.min(100, 15 + Math.sqrt(lumens||0) * 0.3));
 const color = record.config?.color || '#ffffff';
 try{ record.light.color.set(color); }catch{ record.light.color.set(0xffffff); }
 record.light.intensity = intensity;
 record.light.distance = distance;
 record.light.decay = 2;
 if(record.glow && record.glow.material){
 try{ record.glow.material.color.set(color); }catch{}
 // Prominent glow sphere that scales with intensity
 const scale = Math.max(0.4, 0.5 + Math.sqrt(Math.max(lumens,0)) * 0.06);
 record.glow.scale.setScalar(scale);
 record.glow.material.opacity = lumens <= 0 ? 0 : Math.min(0.9, 0.55 + Math.sqrt(lumens) * 0.03);
 record.glow.visible = lumens > 0;
 record.glow.material.needsUpdate = true;
 }
 if(record.light.isSpotLight){
 record.light.angle = record.config?.angle ?? (Math.PI/5);
 record.light.penumbra = record.config?.penumbra ?? 0.4;
 updateLightTarget(record);
 }
 }
 function removeCellLight(ref){
 const key = typeof ref === 'string' ? ref : lightKey(ref);
 if(!key) return;
 const record = cellLights.get(key);
 if(!record) return;
 if(record.config?.targetRef) untrackLightTarget(key, record.config.targetRef);
 try{ record.glow?.material?.dispose?.(); }catch{}
 try{ record.group?.parent?.remove(record.group); }catch{}
 cellLights.delete(key);
 needsRender = true;
 }
 function upsertCellLight(ref, config){
 if(!ref) return null;
 const arr = Store.getState().arrays[ref.arrId];
 if(!arr) return null;
 const key = lightKey(ref);
 if(!config || !config.enabled || (config.lumens!=null && config.lumens<=0)){
 removeCellLight(key);
 return null;
 }
 let record = cellLights.get(key);
 if(!record){
 record = { source:{...ref}, config:{}, group:new THREE.Group(), light:null, target:null };
 record.group.userData.kind = 'cellLight';
 cellLights.set(key, record);
 }
 if(record.config?.targetRef) untrackLightTarget(key, record.config.targetRef);
 record.source = {...ref};
 record.config = { ...config };
 if(config.targetRef) trackLightTarget(key, config.targetRef);
 ensureLightInstance(record);
 attachLightToArray(record);
 updateLightProperties(record);
 needsRender = true;
 return record;
 }
 function refreshLightsForArray(arrId){
 cellLights.forEach((record)=>{
 if(record.source?.arrId === arrId || record.config?.targetRef?.arrId === arrId){
 attachLightToArray(record);
 updateLightProperties(record);
 }
 });
 }
 function clearOcclusion(arr){
 try{
 if(!arr) return;
 const chunkMode = !!(Scene.ChunkManager && Scene.ChunkManager.enabled);
 delete arr._occlusionData;
 for(let z=0; z<(arr.size?.z ?? 0); z++){
 ['ghost'].forEach(type=>{
 const base=`${arr.id}:${z}:${type}`;
 const rec=layerMeshes.get(base);
 if(rec){
 if(arr._frame) arr._frame.remove(rec.mesh);
 else scene.remove(rec.mesh);
 rec.mesh.geometry.dispose?.();
 rec.mesh.material.dispose?.();
 layerMeshes.delete(base);
 }
 const ekey=`${base}:edges`;
 const er=layerMeshes.get(ekey);
 if(er){
 if(arr._frame) arr._frame.remove(er.mesh);
 else scene.remove(er.mesh);
 er.mesh.geometry.dispose?.();
 er.mesh.material.dispose?.();
 layerMeshes.delete(ekey);
 }
 });
 }
 if(chunkMode){
 try{
 Object.values(arr.chunks||{}).forEach(ch=>{
 ch.ensureMesh?.();
 ch.setLOD?.(1);
 rehydrateChunkInstances(arr, ch);
 });
 }catch{}
 }
 for(let z=0; z<(arr.size?.z ?? 0); z++){
 renderLayer(arr,z);
 }
 }catch{}
 }
 let lastFocusedArrayId = null;

 function setupRenderer(){
 renderer.outputColorSpace = THREE.SRGBColorSpace;
 renderer.toneMapping = THREE.NoToneMapping;
 renderer.toneMappingExposure = 1.0;
 renderer.shadowMap.enabled = false;
 renderer.setClearColor(0xf6f7fb, 1);
 renderer.autoClear = true;
 renderer.autoClearStencil = true;
 renderer.localClippingEnabled = true;
 }
 function updateBaseLightingVisibility(){
 if(!baseLightsGroup) return;
 const fancyLightsActive = FancyGraphics.enabled && FancyGraphics.settings.lights;
 baseLightsGroup.visible = !fancyLightsActive;
 }

 function setupLighting(){
 if(baseLightsGroup){
 try{ scene.remove(baseLightsGroup); }catch{}
 baseLightsGroup = null;
 }

 baseLightsGroup = new THREE.Group();
 baseLightsGroup.name = 'BaseLighting';

 // Three-point lighting setup (always present, independent of floor modes)
 const strength = (FancyGraphics?.settings?.lightStrength ?? 1) || 1;
 const defaults = FancyGraphics?.lightDefaults || { key: 2.8, fill: 1.4, rim: 1.0, hemi: 0.6 };
 
 // Key light (main)
 const key = new THREE.DirectionalLight(0xffffff, defaults.key * strength);
 key.position.set(-8, 14, 10);
 key.castShadow = false;
 key.shadow.mapSize.set(2048, 2048);
 key.shadow.camera.near = 0.5;
 key.shadow.camera.far = 200;
 key.shadow.camera.left = -80;
 key.shadow.camera.right = 80;
 key.shadow.camera.top = 80;
 key.shadow.camera.bottom = -80;
 key.shadow.bias = -0.0008;
 
 // Fill light
 const fill = new THREE.DirectionalLight(0xffffff, defaults.fill * strength);
 fill.position.set(10, 6, 12);
 fill.castShadow = false;
 
 // Rim/back light
 const rim = new THREE.DirectionalLight(0xffffff, defaults.rim * strength);
 rim.position.set(0, 8, -14);
 rim.castShadow = false;
 
 // Ambient and hemisphere
 const ambient = new THREE.AmbientLight(0xffffff, 0.4 * strength);
 const hemi = new THREE.HemisphereLight(0xdbeafe, 0x0f172a, defaults.hemi * strength);

 baseLightsGroup.add(key);
 baseLightsGroup.add(fill);
 baseLightsGroup.add(rim);
 baseLightsGroup.add(ambient);
 baseLightsGroup.add(hemi);

 scene.add(baseLightsGroup);
 updateBaseLightingVisibility();
 applyFancyLightingAdjustments();
 }
 // Settings UI removed
 async function init(canvas){
 renderer=new THREE.WebGLRenderer({canvas, antialias:true, stencil:true});
 renderer.setPixelRatio(Math.min(2,window.devicePixelRatio||1));
 renderer.setSize(window.innerWidth,window.innerHeight);
 
 // Configure renderer based on mode
 setupRenderer();

 scene=new THREE.Scene();
 OceanBackdrop.init();
 try{
 const savedOcean = Store.getState().scene?.ocean;
 if(savedOcean){
 const patch = { ...savedOcean };
 delete patch.enabled;
 if(Object.keys(patch).length){ updateOceanSettings(patch); }
 if(savedOcean.enabled){ setOceanEnabled(true); }
 }
 }catch{}
 camera=new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,.1,2000);
 camera.position.set(8, 10, 14); // Higher and further for better view
 controls=new OrbitControls(camera,renderer.domElement);
 controls.target.set(0, 3, 0); // Look at array center (considering offset y:1 and height 4)
 controls.enableDamping=true;
 controls.enabled=true;
 controls.enableRotate=true;
 controls.enablePan=true;
 console.log('[INIT] Camera and controls initialized - controls.enabled:', controls.enabled);
 try{ controls.addEventListener('change', ()=>{
 try{
 const S=Store.getState(); const sel=S.selection;
 // Recompute placement for all visible arrays so sprites are always present on the facing side
 Object.values(S.arrays||{}).forEach(a=>{ if(!a.hidden && a._frame){ try{ updateArrayValueSpritePlacement(a); }catch{} } });
 if(sel?.arrayId){
 const arr=S.arrays[sel.arrayId];
 applyCutaway(arr, sel.focus);
 }
 }catch{}
 needsRender = true;
 }); }catch{}

 // Setup lighting and environment
 setupLighting();

 // Apply theme colors as CSS variables for unified styling
 try{
 const styleEl = document.createElement('style');
 const cssVars = Object.entries(COLORS)
 .map(([name, value]) => {
 const colorStr = typeof value === 'number' ? `#${value.toString(16).padStart(6, '0')}` : value;
 return `--clr-${name}: ${colorStr};`;
 })
 .join('\n');
 styleEl.textContent = `:root { ${cssVars} }`;
 document.head.appendChild(styleEl);
 }catch{}

 grid=new THREE.GridHelper(80,80,0x9aa1b5,0xe6e8ef); grid.position.y=-0.49; scene.add(grid);
 axesHelper=new THREE.AxesHelper(6); scene.add(axesHelper);

 scene.add(focusMarker); focusMarker.visible=false;
 scene.add(selectionCelli); selectionCelli.visible=false;
 // Dependency overlay group
 depGroup = new THREE.Group(); depGroup.visible=false; depGroup.userData.kind='depGroup'; scene.add(depGroup);
 initAvatars();

 window.addEventListener('resize',()=>{
 camera.aspect=window.innerWidth/window.innerHeight;
 camera.updateProjectionMatrix();
 renderer.setSize(window.innerWidth,window.innerHeight);
 updateFancyComposerSize();
 try{ OceanBackdrop.resizePost(window.innerWidth, window.innerHeight); }catch{}
 });
 renderer.domElement.addEventListener('pointerdown', onPick);
 // 3D hover sync: highlight cell under cursor
 renderer.domElement.addEventListener('pointermove', (e)=>{
 try{
 const rect=renderer.domElement.getBoundingClientRect();
 const mouse=new THREE.Vector2(((e.clientX-rect.left)/rect.width)*2-1, -((e.clientY-rect.top)/rect.height)*2+1);
 const ray=new THREE.Raycaster(); ray.setFromCamera(mouse,camera);
 const pickMeshes=[];
 const physicsActive = !!Store.getState().scene?.physics;
 const physicsDebugActive = !!Store.getState().scene?.physicsDebugAll;
 try{ Object.values(Store.getState().arrays).forEach(a=>{ if(a.hidden) return; if(physicsActive && !physicsDebugActive && a.params?.physics?.enabled) return; Object.values(a.chunks||{}).forEach(ch=>{ if(ch?.meshLOD1 && ch.meshLOD1.visible) pickMeshes.push(ch.meshLOD1); }); }); }catch{}
 const hits=ray.intersectObjects(pickMeshes,false);
 if(hits.length){
 const h=hits[0];
 const ch=h.object?.userData?.chunk; const arr=ch?.array; const cell = ch?.index2cell?.[h.instanceId];
 if(arr && cell){ setHoverCell({arrId:arr.id, x:cell.x, y:cell.y, z:cell.z}); return; }
 }
 clearHoverCell();
 }catch{}
 });
 // Ensure double click in 3D opens editor for the focused cell as well
 renderer.domElement.addEventListener('dblclick', (e)=>{
 try{
 const s=Store.getState().selection; if(!s?.arrayId||!s.focus) return;
 // Mark last interaction as 3d to place editor properly
 Store.setState(st=>({ ui:{...st.ui, lastInteraction:'3d'} }));
 window.UI?.openEditor?.();
 }catch{}
 });
 // Arrow/WASD movement is now handled in the physics loop to avoid aliasing
 // This old handler is disabled to prevent Rapier conflicts

 try{
 const status = await ensureRapierWorld();
 if(status?.success){
 console.log('[PHYSICS] Rapier world initialized (physics disabled by default)');
 updatePhysicsStatusChip('Physics: OFF');
 } else if(status?.reason === 'unavailable'){
 updatePhysicsStatusChip('Physics: OFF (unavailable)');
 } else {
 updatePhysicsStatusChip('Physics: OFF (error)');
 }
 }catch(e){ updatePhysicsStatusChip('Physics: OFF (error)'); console.warn('Rapier failed; continuing without physics', e); }

 // Settings and render-order debug UI removed

 if(!isAnimating){ isAnimating = true; needsRender = true; startLoop(); }
 // Rehydrate: render all current arrays immediately after init
 try{ Object.values(Store.getState().arrays).forEach(a=> Scene.renderArray(a)); }catch{}
 // Enforce default render orders and hydrate meshes/sprites once after all meshes exist
 try{ forceRenderOrderRefresh(); hydrateAll(); }catch{}
 // Apply current view mode once on init (ensures hideEmpty mask engages on boot)
 try{ const cur=(Store.getState().ui&&Store.getState().ui.viewMode)||'standard'; Scene.applyViewMode?.(cur); }catch{}
 // Ensure the first frame renders even if nothing changes immediately after init
 try{ if(typeof window.__RENDER_READY==='undefined'){ renderer.render(scene, camera); window.__RENDER_READY = true; } }catch{}
 }
 // Camera persistence helpers
 function captureCamera(){
 try{
 return {
 pos: (camera?.position?.toArray?.() || [10,8,13]),
 target: (controls?.target?.toArray?.() || [0,0,0]),
 fov: camera?.fov || 60,
 type: camera?.isPerspectiveCamera ? 'perspective' : 'orthographic'
 };
 }catch{ return null; }
 }
 function restoreCamera(s){
 if(!s) return;
 try{
 camera.position.fromArray(s.pos||[10,8,13]);
 controls.target.fromArray(s.target||[0,0,0]);
 if (s.fov) { camera.fov = +s.fov; camera.updateProjectionMatrix(); }
 }catch{}
 }
 
 
 function worldPos(arr,x,y,z){
 const base = localPos(arr,x,y,z);
 const off = arr.offset||{x:0,y:0,z:0};
 base.x += off.x; base.y += off.y; base.z += off.z;
 return base;
 }
 function localPos(arr,x,y,z){
 const X=arr.size.x,Y=arr.size.y,Z=arr.size.z;
 const scale = arrayVoxelScale(arr);
 return new THREE.Vector3(
 (x - X/2 + .5) * scale,
 ((Y - 1 - y) - Y/2 + .5) * scale,
 ((Z - 1 - z) - Z/2 + .5) * scale
 );
 }
 function withinBounds(arr, coord){
 return coord.x>=0 && coord.y>=0 && coord.z>=0 && coord.x<arr.size.x && coord.y<arr.size.y && coord.z<arr.size.z;
 }
 function worldToCellCoord(arr, world){
 const vec = world.clone ? world.clone() : new THREE.Vector3(world.x, world.y, world.z);
 if(arr._frame){ arr._frame.worldToLocal(vec); }
 else {
 const off = arr.offset||{x:0,y:0,z:0};
 vec.x -= off.x; vec.y -= off.y; vec.z -= off.z;
 }
 const X=arr.size.x,Y=arr.size.y,Z=arr.size.z;
 const scale = arrayVoxelScale(arr);
 const inv = scale !== 0 ? 1/scale : 1;
 const lx = vec.x * inv;
 const ly = vec.y * inv;
 const lz = vec.z * inv;
 const x = Math.round(lx + X/2 - 0.5);
 const y = Math.round((Y/2 - 0.5) - ly);
 const z = Math.round((Z/2 - 0.5) - lz);
 return {x,y,z};
 }
 // GPU-first two-pass materials with local clipping planes
 function makeCellMaterials(){
 const solid = createCellMaterial('filled');
 const ghost = createCellMaterial('ghost');
 return { solid, ghost };
 }

 // Extruded shell material for outlines (view-agnostic)
 function makeShellMaterial({ color = 0x9aa0a6, opacity = 0.15, thickness = 0.06 } = {}){
 const mat = new THREE.MeshBasicMaterial({
 color, transparent: true, opacity,
 side: THREE.BackSide,
 // Respect scene depth so distant shells cannot overdraw closer solids
 depthTest: true,
 depthWrite: false,
 toneMapped: false,
 vertexColors: true,
 polygonOffset: true,
 polygonOffsetFactor: 1,
 polygonOffsetUnits: 1
 });
 mat.onBeforeCompile = (shader)=>{
 shader.uniforms.uThick = { value: thickness };
 shader.vertexShader = shader.vertexShader.replace(
 'vec3 transformed = position;',
 'uniform float uThick; vec3 transformed = position + normal * uThick;'
 );
 };
 return mat;
 }

 // Whole-array highlight shell (single filled shell around the entire array)
 function ensureArrayHighlightShell(arr){
 try{
 const scale = arrayVoxelScale(arr);
 const want = { x:arr.size.x*scale, y:arr.size.y*scale, z:arr.size.z*scale, scale };
 const framePad = clampedScaleOffset(scale, 0.6);
 const rebuild = !arr._arrayShell || !arr._arrayShell.userData ||
 arr._arrayShell.userData.sx!==want.x ||
 arr._arrayShell.userData.sy!==want.y ||
 arr._arrayShell.userData.sz!==want.z ||
 arr._arrayShell.userData.scale!==want.scale;
 if(rebuild){
 // Dispose old
 try{ if(arr._arrayShell){ arr._arrayShell.parent?.remove(arr._arrayShell); arr._arrayShell.traverse(n=>{ try{ n.geometry?.dispose?.(); n.material?.dispose?.(); }catch{} }); } }catch{}
 const group = new THREE.Group();
 group.userData = { sx:want.x, sy:want.y, sz:want.z, scale:want.scale };
 // Outer backface shell: reach mid-gap between arrays ( 0.5 beyond faces)
 const geoOuter = new RoundedBoxGeometry(
 want.x + 2*framePad,
 want.y + 2*framePad,
 want.z + 2*framePad,
 3, 0.20
 );
 const matOuter = new THREE.MeshBasicMaterial({
 color: 0x3b82f6,
 transparent: true,
 opacity: 0.30,
 side: THREE.BackSide,
 depthTest: true,
 depthWrite: false,
 toneMapped: false,
 // Do not write color on the inner-facing pixels; rely on stencil to create pass-through
 colorWrite: true
 });
 // Stencil: draw shell only where inner did NOT write stencil
 matOuter.stencilWrite = true;
 matOuter.stencilFunc = THREE.NotEqualStencilFunc;
 matOuter.stencilRef = 1;
 matOuter.stencilZPass = THREE.KeepStencilOp;
 matOuter.stencilZFail = THREE.KeepStencilOp;
 matOuter.stencilFail = THREE.KeepStencilOp;
 const outer = new THREE.Mesh(geoOuter, matOuter);
 outer.renderOrder = window.__RO.frameShell|0; // frame shell above core but behind per-cell
 group.add(outer);
 // Inner fill: invisible, seeds stencil; draw very early
 // Inner fill slightly smaller than outer so outer remains as outline
 const geoInner = new RoundedBoxGeometry(
 arr.size.x + 0.96,
 arr.size.y + 0.96,
 arr.size.z + 0.96,
 3, 0.18
 );
 const matInner = new THREE.MeshBasicMaterial({
 color: 0xffffff,
 transparent: false, // treat as opaque so it renders in the opaque pass before transparent outer
 opacity: 0.0, // fully invisible (colorWrite=false still ensures no color)
 side: THREE.FrontSide,
 depthTest: true,
 depthWrite: true, // Write depth to ensure proper occlusion
 toneMapped: false,
 colorWrite: false
 });
 // Stencil: mark interior with ref=1 so shell ignores it (pass-through window)
 matInner.stencilWrite = true;
 matInner.stencilFunc = THREE.AlwaysStencilFunc;
 matInner.stencilRef = 1;
 matInner.stencilZPass = THREE.ReplaceStencilOp;
 matInner.stencilZFail = THREE.ReplaceStencilOp;
 matInner.stencilFail = THREE.ReplaceStencilOp;
 const inner = new THREE.Mesh(geoInner, matInner);
 inner.renderOrder = window.__RO.frameCore|0; // draw before frame shell
 group.add(inner);
 // If frame exists, parent shell to frame; otherwise enqueue after first renderArray
 if(arr._frame) arr._frame.add(group); else scene.add(group);
 arr._arrayShell = group;
 }
 }catch{}
 // Ensure visibility matches array state immediately
 try{ if(arr._arrayShell) arr._arrayShell.visible = !arr.hidden; }catch{}
 return arr._arrayShell;
 }

 function viewAxisForArray(frame, observerPos){
 try{
 const camPos = observerPos ? observerPos.clone() : camera.position.clone();
 const arrPos = new THREE.Vector3().setFromMatrixPosition(frame.matrixWorld);
 const dirWorld = camPos.sub(arrPos).normalize();
 const inv = new THREE.Matrix4().copy(frame.matrixWorld).invert();
 const dirLocal = dirWorld.clone().applyMatrix3(new THREE.Matrix3().setFromMatrix4(inv)).normalize();
 const ax=Math.abs(dirLocal.x), ay=Math.abs(dirLocal.y), az=Math.abs(dirLocal.z);
 let axis=0, sign=Math.sign(dirLocal.x)||1; if(ay>ax && ay>az){ axis=1; sign=Math.sign(dirLocal.y)||1; } else if(az>ax && az>ay){ axis=2; sign=Math.sign(dirLocal.z)||1; }
 return {axis, sign};
 }catch{ return {axis:2, sign:1}; }
 }

 // Camera-facing helpers with hysteresis to stabilize axis/sign and head-on
 function facingFromCamera(frame){
 try{
 const cam = camera.position.clone();
 const arrWorld = new THREE.Vector3().setFromMatrixPosition(frame.matrixWorld);
 const toCamWorld = cam.sub(arrWorld).normalize();
 const inv = new THREE.Matrix4().copy(frame.matrixWorld).invert();
 const toCamLocal = toCamWorld.clone().applyMatrix3(new THREE.Matrix3().setFromMatrix4(inv)).normalize();
 const ax=Math.abs(toCamLocal.x), ay=Math.abs(toCamLocal.y), az=Math.abs(toCamLocal.z);
 let axis=0, sign=Math.sign(toCamLocal.x)||1, majorMag=ax;
 if(ay>majorMag){ axis=1; sign=Math.sign(toCamLocal.y)||1; majorMag=ay; }
 if(az>majorMag){ axis=2; sign=Math.sign(toCamLocal.z)||1; majorMag=az; }
 return { axis, sign, majorMag, dirLocal: toCamLocal };
 }catch{ return { axis:2, sign:1, majorMag:1, dirLocal:new THREE.Vector3(0,0,1) }; }
 }

 function updateFacingState(arr){
 if(!arr || !arr._frame) return;
 const vs = facingFromCamera(arr._frame);
 const AXIS_DELTA=0.05, ENTER_HEAD=0.94, EXIT_HEAD=0.90;
 const prev = arr._facingState || { axis:vs.axis, sign:vs.sign, mag:vs.majorMag };
 const axisChanged = (vs.axis!==prev.axis) && (vs.majorMag > Math.max(prev.mag + AXIS_DELTA, 0.80));
 const signChanged = (vs.sign!==prev.sign) && (vs.majorMag > 0.60);
 const axis = axisChanged ? vs.axis : prev.axis;
 const sign = signChanged ? vs.sign : prev.sign;
 const mag = axisChanged ? vs.majorMag : Math.max(prev.mag*0.9, vs.majorMag);
 const prevHead = !!arr._headOnMajor;
 const nowHead = prevHead ? (mag > EXIT_HEAD) : (mag > ENTER_HEAD);
 arr._facingState = { axis, sign, mag };
 arr._headOnMajor = nowHead;
 arr._headOnZ = (axis===2) && nowHead;
 }

 function computeOcclusion(arr, selection){
 if(!arr || !selection) return;
 // Don't compute occlusion for deleting arrays
 if(arr._deleting) return;
 // Determine dominant axis from camera direction relative to array frame
 try{
 const inv = new THREE.Matrix4().copy(arr._frame.matrixWorld).invert();
 const camDirW = camera.position.clone().sub(arr._frame.getWorldPosition(new THREE.Vector3())).normalize();
 const camDirL = camDirW.clone().applyMatrix3(new THREE.Matrix3().setFromMatrix4(inv)).normalize();
 const ax=Math.abs(camDirL.x), ay=Math.abs(camDirL.y), az=Math.abs(camDirL.z);
 let axis='Z', sign=1, frontLayer=0, focusLayer=0;
 if(ay>ax && ay>az){ axis='Y'; sign=Math.sign(camDirL.y)||1; frontLayer = (sign>0) ? 0 : (arr.size.y-1); focusLayer = selection.y; }
 else if(ax>ay && ax>az){ axis='X'; sign=Math.sign(camDirL.x)||1; frontLayer = (sign>0) ? (arr.size.x-1) : 0; focusLayer = selection.x; }
 else { axis='Z'; sign=Math.sign(camDirL.z)||1; frontLayer = (sign>0) ? 0 : (arr.size.z-1); focusLayer = selection.z; }
 const blockedLayers = new Set();
 // Block layers BETWEEN front and focus, excluding both endpoints
 // Front layer is always visible (not ghosted), focus layer is always visible
 if(frontLayer < focusLayer){ 
 for(let L=frontLayer+1; L<focusLayer; L++) blockedLayers.add(L); 
 } else if(frontLayer > focusLayer){ 
 for(let L=frontLayer-1; L>focusLayer; L--) blockedLayers.add(L); 
 }
 arr._occlusionData = { axis, sign, frontLayer, focusLayer, blockedLayers };
 }catch{
 arr._occlusionData = { axis:'Z', sign:1, frontLayer:0, focusLayer:selection.z, blockedLayers:new Set() };
 }
 }

 function cutPlaneFromCamera(frame, sel, arr){
 try{
 const st = arr? (arr._facingState||{axis:2,sign:1}) : {axis:2,sign:1};
 const axis=st.axis, sign=st.sign;
 const cellSize=1;
 const c = new THREE.Vector3( (sel.x+0.5)*cellSize, (sel.y+0.5)*cellSize, (sel.z+0.5)*cellSize );
 if(axis===0) c.x += 0.5*sign*cellSize;
 if(axis===1) c.y += 0.5*sign*cellSize;
 if(axis===2) c.z += 0.5*sign*cellSize;
 const nL = new THREE.Vector3(axis===0?sign:0, axis===1?sign:0, axis===2?sign:0).normalize();
 const nW = nL.clone().applyQuaternion(frame.getWorldQuaternion(new THREE.Quaternion())).normalize();
 const pW = frame.localToWorld(c);
 return new THREE.Plane().setFromNormalAndCoplanarPoint(nW, pW);
 }catch{ return new THREE.Plane(new THREE.Vector3(0,0,1), 0); }
 }

 function cutPlaneFor(arrayFrame, sel, cellSize = 1){
 try{
 // camera dir in array local space
 const inv = new THREE.Matrix4().copy(arrayFrame.matrixWorld).invert();
 const camDirW = camera.position.clone().sub(arrayFrame.getWorldPosition(new THREE.Vector3())).normalize();
 const camDirL = camDirW.clone().applyMatrix3(new THREE.Matrix3().setFromMatrix4(inv)).normalize();
 // dominant axis + sign
 const ax = Math.abs(camDirL.x), ay = Math.abs(camDirL.y), az = Math.abs(camDirL.z);
 let axis=0, sign=Math.sign(camDirL.x)||1;
 if(ay>ax && ay>az){ axis=1; sign=Math.sign(camDirL.y)||1; }
 else if(az>ax && az>ay){ axis=2; sign=Math.sign(camDirL.z)||1; }
 // face center of selected cell toward camera
 const c = new THREE.Vector3(
 (sel.x + 0.5) * cellSize,
 (sel.y + 0.5) * cellSize,
 (sel.z + 0.5) * cellSize
 );
 if(axis===0) c.x += 0.5 * sign * cellSize;
 if(axis===1) c.y += 0.5 * sign * cellSize;
 if(axis===2) c.z += 0.5 * sign * cellSize;
 // local normal ? world normal
 const nL = new THREE.Vector3(axis===0?sign:0, axis===1?sign:0, axis===2?sign:0).normalize();
 const nW = nL.clone().applyQuaternion(arrayFrame.getWorldQuaternion(new THREE.Quaternion())).normalize();
 const pW = arrayFrame.localToWorld(c);
 const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(nW, pW);
 return plane;
 }catch{ return new THREE.Plane(new THREE.Vector3(0,0,1), 0); }
 }

 function applyCutaway(arr, sel){
 if(!arr || !arr._cellMaterials || !arr._frame || !sel) return;
 // In chunk mode, rely solely on per-instance ghost/solid masking; disable material clipping
 if(Scene.ChunkManager && Scene.ChunkManager.enabled){
 try{ arr._cellMaterials.forEach(m=>{ if(m) m.clippingPlanes = null; }); }catch{}
 // In hideEmpty mode, enforce mask instead of occlusion
 try{
 const mode = (Store.getState().ui && Store.getState().ui.viewMode) || 'standard';
 if(mode==='hideEmpty'){ applyHideEmptyMask(arr); }
 }catch{}
 return;
 }
 try{
 const plane = cutPlaneFromCamera(arr._frame, sel, arr);
 // FRONT (toward camera) ? GHOST, BACK (selected+behind) ? SOLID
 arr._cellMaterials.forEach(mat=>{
 if(mat.userData.pass === 'ghost'){
 mat.clippingPlanes = [ plane.clone() ];
 } else if(mat.userData.pass === 'solid'){
 mat.clippingPlanes = [ plane.clone().negate() ];
 }
 });
 needsRender = true;
 }catch{}
 }

 // Live color update for a single cell without a full rebuild
 function updateCellColor(arrayId, coord){
 try{
 const arr = Store.getState().arrays[arrayId]; if(!arr) return;
 const cell = getCellFast(arrayId, coord);
 const key = `${arrayId}:${coord.x},${coord.y},${coord.z}`;
 const emitted = !!(Store.getState().sourceByCell && Store.getState().sourceByCell.get && Store.getState().sourceByCell.get(key));
 const isFormula = !!cell.formula;
 const custom = cell?.meta?.color;
 const hasValue = (cell.value!=='' && cell.value!==null && cell.value!==undefined);
 let hex;
 if(isFormula) hex = baseHexForTypeKey('formula'); else if(emitted) hex = baseHexForTypeKey('emitted'); else hex = hasValue ? baseHexForTypeKey('value') : baseHexForTypeKey('empty');
 const col = new THREE.Color(custom || hex); col.convertSRGBToLinear();
 // Update pooled LOD1
 try{
 const ch = arr.chunks[keyChunk(...Object.values(chunkOf(coord.x,coord.y,coord.z)))];
 const mesh = ch?.meshLOD1; const map = ch?.index2cell; const gmesh = ch?.meshGhost; const smesh = ch?.meshShell;
 if(map){
 const idx = map.findIndex(c=>c && c.x===coord.x && c.y===coord.y && c.z===coord.z);
 if(idx>=0){
 if(mesh){ mesh.setColorAt(idx, col); if(mesh.instanceColor) mesh.instanceColor.needsUpdate = true; mesh.visible = true; }
 if(gmesh){ const ghostTint = tintGhostColorFrom(col); gmesh.setColorAt(idx, ghostTint); if(gmesh.instanceColor) gmesh.instanceColor.needsUpdate = true; }
 if(smesh){ const scol = col.clone(); scol.offsetHSL(0,0,-0.22); if(smesh.instanceColor){ smesh.setColorAt(idx, scol); smesh.instanceColor.needsUpdate = true; } }
 }
 }
 }catch{}
 // Update legacy layer meshes
 try{
 const z = coord.z|0; const types=['empty','filled','formula','ghost'];
 for(const t of types){
 const rec = layerMeshes.get(`${arrayId}:${z}:${t}`);
 if(!rec||!rec.mesh||!rec.index2cell) continue;
 const i = rec.index2cell.findIndex(c=>c && c.x===coord.x && c.y===coord.y && c.z===coord.z);
 if(i>=0){ try{ rec.mesh.setColorAt(i, col); }catch{} if(rec.mesh.instanceColor) rec.mesh.instanceColor.needsUpdate = true; }
 }
 }catch{}
 try{ renderer?.state?.reset?.(); }catch{}
 needsRender = true;
 }catch{}
 }

 // Rehydrate an entire chunk's instances from current cell state
 function rehydrateChunkInstances(arr, ch){
 try{
 if(!ch) return;
 // CRITICAL: Never rehydrate during deletion - would reset hidden cells
 if(arr?._deleting) return;
 
 ch.ensureMesh?.();
 const meshSolid = ch.meshLOD1; const meshGhost = ch.meshGhost; const meshShell = ch.meshShell;
 if(!meshSolid) return;
 const list = ch.index2cell || ch.cells || [];
 const viewModeNow = (Store.getState().ui && Store.getState().ui.viewMode) || 'standard';
 const scale = arrayVoxelScale(arr);
 const cellScale = voxelDisplayScale(scale);
 for(let i=0;i<list.length;i++){
 const c = list[i]; if(!c) continue;
 // transform
 const p = localPos(arr, c.x, c.y, c.z);
 temp.position.copy(p); temp.rotation.set(0,0,0); temp.scale.set(cellScale,cellScale,cellScale); temp.updateMatrix();
 const M = temp.matrix;
 // In hideEmpty mode, zero-scale empty instances; otherwise set normal transform
 if(viewModeNow==='hideEmpty'){
 const fresh = Formula.getCell({arrId:arr.id, x:c.x, y:c.y, z:c.z}) || {};
 const isFormula = !!fresh.formula;
 const hasValue = (fresh.value!=='' && fresh.value!==null && fresh.value!==undefined);
 const emitted = !!(Store.getState().sourceByCell && Store.getState().sourceByCell.get && Store.getState().sourceByCell.get(`${arr.id}:${c.x},${c.y},${c.z}`));
 const show = isFormula || hasValue || emitted;
 if(show){
 meshSolid.setMatrixAt(i, M);
 if(meshShell) meshShell.setMatrixAt(i, M);
 } else {
 tempM.identity(); tempM.makeScale(0,0,0);
 meshSolid.setMatrixAt(i, tempM);
 if(meshShell) meshShell.setMatrixAt(i, tempM);
 }
 } else {
 meshSolid.setMatrixAt(i, M);
 if(meshShell) meshShell.setMatrixAt(i, M);
 }
 // ghosts start hidden until occlusion applies
 if(meshGhost){ tempM.identity(); tempM.makeScale(0,0,0); meshGhost.setMatrixAt(i, tempM); }
 // colors
 try{
 const fresh = getCellFast(arr.id, c) || {};
 const isFormula = !!fresh.formula;
 const hasValue = (fresh.value!=='' && fresh.value!==null && fresh.value!==undefined);
 const emitted = !!(Store.getState().sourceByCell && Store.getState().sourceByCell.get && Store.getState().sourceByCell.get(`${arr.id}:${c.x},${c.y},${c.z}`));
 let hex; if(isFormula) hex = baseHexForTypeKey('formula'); else if(emitted) hex = baseHexForTypeKey('emitted'); else hex = hasValue ? baseHexForTypeKey('value') : baseHexForTypeKey('empty');
 const custom = fresh?.meta?.color;
 const col = new THREE.Color(custom || hex).convertSRGBToLinear();
 meshSolid.setColorAt(i, col);
 if(meshGhost){ const ghostTint = tintGhostColorFrom(col); meshGhost.setColorAt(i, ghostTint); }
 if(meshShell){ const sc = col.clone(); sc.offsetHSL(0,0,-0.22); meshShell.setColorAt(i, sc); }
 }catch{}
 }
 meshSolid.count = list.length; meshSolid.instanceMatrix.needsUpdate = true; if(meshSolid.instanceColor) meshSolid.instanceColor.needsUpdate = true;
 if(meshGhost){ meshGhost.count = list.length; meshGhost.instanceMatrix.needsUpdate = true; if(meshGhost.instanceColor) meshGhost.instanceColor.needsUpdate = true; }
 if(meshShell){ meshShell.count = list.length; meshShell.instanceMatrix.needsUpdate = true; if(meshShell.instanceColor) meshShell.instanceColor.needsUpdate = true; }
 }catch{}
 }
 
 // Zero-scale chunk instances for blocked layers so ghosts replace solids when chunks are ON
 function applyGhostMaskToChunks(arr){
 try{
 if(!(Scene.ChunkManager && Scene.ChunkManager.enabled)) return;
 if(!arr || !arr.chunks) return;
 // Don't apply occlusion to deleting arrays
 if(arr._deleting) return;
 const occ = arr._occlusionData || {};
 const blocked = occ.blockedLayers || new Set();
 const axis = occ.axis || occ.facing || 'Z';
 // Determine focus layer from current selection for this array so it always renders as solid
 const sel = Store.getState().selection || {};
 const focusLayer = (sel.arrayId===arr.id && sel.focus) ? (axis==='X' ? sel.focus.x : axis==='Y' ? sel.focus.y : sel.focus.z) : null;
 const scale = arrayVoxelScale(arr);
 const cellScale = voxelDisplayScale(scale);
 Object.values(arr.chunks).forEach(ch=>{
 const meshSolid = ch.meshLOD1; const meshGhost = ch.meshGhost; const meshShell = ch.meshShell;
 if(!meshSolid || !ch.index2cell) return;
 let changedS=false, changedG=false, changedH=false;
 for(let i=0;i<ch.index2cell.length;i++){
 const c = ch.index2cell[i];
 const L = axis==='X' ? c.x : axis==='Y' ? c.y : c.z;
 const isFocus = (focusLayer===L);
 const isBlocked = blocked.has(L);
 // Build the canonical transform exactly once
 const p = localPos(arr,c.x,c.y,c.z);
 temp.position.copy(p); temp.rotation.set(0,0,0); temp.scale.set(cellScale,cellScale,cellScale); temp.updateMatrix();
 const M = temp.matrix.clone();
 // Solid shows when NOT blocked (no special exception for any layer)
 const showSolid = !isBlocked;
 if(showSolid){ meshSolid.setMatrixAt(i, M); } else { tempM.identity(); tempM.makeScale(0,0,0); meshSolid.setMatrixAt(i, tempM); }
 changedS=true;
 // Ghost shows when blocked (no special exception for any layer)
 const showGhost = isBlocked;
 if(meshGhost){ if(showGhost){ meshGhost.setMatrixAt(i, M); } else { tempM.identity(); tempM.makeScale(0,0,0); meshGhost.setMatrixAt(i, tempM); } changedG=true; }
 // Shell follows solids (hide when blocked). Larger GEO_SHELL gives visible outline.
 if(meshShell){
 if(showSolid){ meshShell.setMatrixAt(i, M); }
 else { tempM.identity(); tempM.makeScale(0,0,0); meshShell.setMatrixAt(i, tempM); }
 changedH=true;
 }
 }
 if(changedS) meshSolid.instanceMatrix.needsUpdate = true;
 if(changedG && meshGhost) meshGhost.instanceMatrix.needsUpdate = true;
 if(changedH && meshShell) meshShell.instanceMatrix.needsUpdate = true;
 });
 // Hide value sprites for blocked cells too in Standard mode; other modes leave sprites visible
 try{
 const mode = (Store.getState().ui && Store.getState().ui.viewMode) || 'standard';
 if(mode==='standard'){
 const vs = window.valueSprites || new Map();
 vs.forEach((sprite,key)=>{
 if(!String(key).startsWith(`${arr.id}:`)) return;
 const [,coords] = String(key).split(':');
 const [x,y,z] = coords.split(',').map(n=>+n);
 let blk=false;
 if(axis==='Z') blk = blocked.has(z);
 else if(axis==='X') blk = blocked.has(x);
 else blk = blocked.has(y);
 if(sprite) sprite.visible = !blk;
 });
 }
 }catch{}
 }catch(e){ console.warn('applyGhostMaskToChunks failed', e); }
 }

 // Hide-Empty: zero-scale all empty instances for an array
 function applyHideEmptyMask(arr){
 try{
 const scale = arrayVoxelScale(arr);
 Object.values(arr.chunks||{}).forEach(ch=>{
 try{
 ch.ensureMesh?.(); ch.setLOD?.(1);
 if(!ch.index2cell) return;
 let changedS=false, changedH=false, changedG=false;
 for(let i=0;i<ch.index2cell.length;i++){
 const c = ch.index2cell[i]; if(!c) continue;
 const fresh = Formula.getCell({arrId:arr.id, x:c.x, y:c.y, z:c.z}) || {};
 const isFormula = !!fresh.formula;
 const hasVal = (fresh.value!=='' && fresh.value!==null && fresh.value!==undefined);
 const emitted = !!(Store.getState().sourceByCell && Store.getState().sourceByCell.get && Store.getState().sourceByCell.get(`${arr.id}:${c.x},${c.y},${c.z}`));
 const hasColor = !!(fresh.meta && fresh.meta.color);
 const show = isFormula || hasVal || emitted || hasColor;
 const p = localPos(arr,c.x,c.y,c.z);
 temp.position.copy(p); temp.rotation.set(0,0,0); temp.scale.set(scale,scale,scale); temp.updateMatrix();
 const M = temp.matrix.clone();
 if(ch.meshLOD1){ if(show){ ch.meshLOD1.setMatrixAt(i, M); } else { tempM.identity(); tempM.makeScale(0,0,0); ch.meshLOD1.setMatrixAt(i, tempM); } changedS=true; }
 if(ch.meshShell){ if(show){ ch.meshShell.setMatrixAt(i, M); } else { tempM.identity(); tempM.makeScale(0,0,0); ch.meshShell.setMatrixAt(i, tempM); } changedH=true; }
 if(ch.meshGhost){ tempM.identity(); tempM.makeScale(0,0,0); ch.meshGhost.setMatrixAt(i, tempM); changedG=true; }
 }
 if(changedS && ch.meshLOD1) ch.meshLOD1.instanceMatrix.needsUpdate=true;
 if(changedH && ch.meshShell) ch.meshShell.instanceMatrix.needsUpdate=true;
 if(changedG && ch.meshGhost) ch.meshGhost.instanceMatrix.needsUpdate=true;
 }catch{}
 });
 // Ensure sprites (which are created only for content) stay visible
 try{ valueSprites.forEach((sp,key)=>{ if(String(key).startsWith(`${arr.id}:`)) sp.visible=true; }); }catch{}
 }catch{}
 }

 // Apply global 3D view mode across all arrays: 'standard' | 'solid' | 'hideEmpty'
 function applyViewMode(mode){
 try{
 const arrays = Object.values(Store.getState().arrays||{}).filter(arr => !arr._deleting);
 if(mode==='solid'){
 arrays.forEach(arr=>{
 Object.values(arr.chunks||{}).forEach(ch=>{ try{ ch.ensureMesh?.(); ch.setLOD?.(1); rehydrateChunkInstances(arr, ch); }catch{} });
 // Ensure all value sprites are visible; occlusion disabled in this mode
 try{ valueSprites.forEach((sp,key)=>{ if(String(key).startsWith(`${arr.id}:`)) sp.visible=true; }); }catch{}
 // Clear occlusion data so animate doesn't reuse it
 try{ clearOcclusion(arr); }catch{}
 });
 } else if(mode==='hideEmpty'){
 arrays.forEach(arr=>{ try{ clearOcclusion(arr); applyHideEmptyMask(arr); }catch{} });
 } else { // standard
 arrays.forEach(arr=>{
 Object.values(arr.chunks||{}).forEach(ch=>{ try{ ch.ensureMesh?.(); ch.setLOD?.(1); rehydrateChunkInstances(arr, ch); }catch{} });
 });
 const s = Store.getState().selection;
 if(s?.arrayId && s.focus){
 const arr = Store.getState().arrays[s.arrayId];
 if(!arr?._deleting){
 try{ computeOcclusion(arr, s.focus); if(Scene.ChunkManager && Scene.ChunkManager.enabled){ applyGhostMaskToChunks(arr); } }catch{}
 }
 }
 }
 needsRender = true;
 arrays.forEach(arr=>{
 try{ updateArrayValueSpritePlacement(arr); }catch{}
 try{ updateArrayLabelPlacement(arr); }catch{}
 });
 }catch{}
 }

 // Click pulse: scale both solid and shell at the same instance center
 function pulseCell(arr, cell, z){
 try{
 const useChunks = !!(ChunkManager && ChunkManager.enabled);
 const records = [];
 const captureBase = (mesh, idx)=>{
 if(!mesh || !Number.isInteger(idx) || idx < 0) return;
 if(idx >= (mesh.count ?? Infinity)) return;
 try{
 const base = new THREE.Matrix4();
 mesh.getMatrixAt(idx, base);
 records.push({ mesh, idx, base });
 }catch{}
 };
 if(useChunks){
 const chunkId = keyChunk(...Object.values(chunkOf(cell.x,cell.y,cell.z)));
 const ch = arr.chunks?.[chunkId];
 if(ch){
 let idx = -1;
 if(ch.cellIndexMap && typeof ch.cellIndexMap.get === 'function'){
 const maybeIdx = ch.cellIndexMap.get(`${cell.x},${cell.y},${cell.z}`);
 if(Number.isInteger(maybeIdx)) idx = maybeIdx;
 }
 if(idx < 0 && Array.isArray(ch.index2cell)){
 idx = ch.index2cell.findIndex(c=>c && c.x===cell.x && c.y===cell.y && c.z===cell.z);
 }
 if(idx >= 0){
 captureBase(ch.meshLOD1, idx);
 captureBase(ch.meshShell, idx);
 }
 }
 } else {
 const types=['filled','formula'];
 types.forEach(tp=>{
 const rec = layerMeshes.get(`${arr.id}:${z}:${tp}`);
 if(rec && rec.mesh && Array.isArray(rec.index2cell)){
 const idx = rec.index2cell.findIndex(c=>c && c.x===cell.x && c.y===cell.y && c.z===cell.z);
 captureBase(rec.mesh, idx);
 }
 const er = layerMeshes.get(`${arr.id}:${z}:${tp}:edges`);
 if(er && er.mesh && Array.isArray(er.index2cell)){
 const idx = er.index2cell.findIndex(c=>c && c.x===cell.x && c.y===cell.y && c.z===cell.z);
 captureBase(er.mesh, idx);
 }
 });
 }
 if(!records.length) return;
 const start=performance.now(); const dur=180; const peak=1.10;
 const scaleMatrix = new THREE.Matrix4();
 const restore=()=>{
 records.forEach(rec=>{
 try{
 rec.mesh.setMatrixAt(rec.idx, rec.base);
 rec.mesh.instanceMatrix.needsUpdate = true;
 }catch{}
 });
 needsRender = true;
 };
 const step=()=>{
 const t=Math.min(1, (performance.now()-start)/dur);
 const s = 1 + (peak-1) * (t<0.5 ? (t*2) : (2-2*t));
 scaleMatrix.identity();
 scaleMatrix.makeScale(s, s, s);
 records.forEach(rec=>{
 try{
 const next = rec.base.clone().multiply(scaleMatrix);
 rec.mesh.setMatrixAt(rec.idx, next);
 rec.mesh.instanceMatrix.needsUpdate = true;
 }catch{}
 });
 needsRender = true;
 if(t<1){
 requestAnimationFrame(step);
 } else {
 restore();
 }
 };
 requestAnimationFrame(step);
 }catch{}
 }
 // Fast cell accessor using chunk cellMap fallback to array scan
 function getCellFast(arrayId, coord){
 try{
 const arr = Store.getState().arrays[arrayId]; if(!arr) return {value:'',formula:null,meta:{}};
 const ch = arr.chunks[keyChunk(...Object.values(chunkOf(coord.x,coord.y,coord.z)))]; if(!ch) return {value:'',formula:null,meta:{}};
 if(ch.cellMap){ const c = ch.cellMap.get(`${coord.x},${coord.y},${coord.z}`); return c || {value:'',formula:null,meta:{}}; }
 const c = ch.cells?.find?.(t=>t.x===coord.x&&t.y===coord.y&&t.z===coord.z);
 return c || {value:'',formula:null,meta:{}};
 }catch{ return {value:'',formula:null,meta:{}}; }
 }
 
 function pruneStaleChunkMeshes(arrayId){
 const arr = Store.getState().arrays[arrayId];
 if(!arr) return;
 const validKeys = new Set(Object.keys(arr.chunks).map(k => `${arrayId}:${k}`));
 for (const [key, m] of chunkMeshes) {
 if (m?.userData?.arrayId === arrayId && !validKeys.has(key)) {
 try {
 m.parent?.remove(m);
 m.geometry?.dispose?.();
 m.material?.dispose?.();
 } catch {}
 chunkMeshes.delete(key);
 }
 }
 }
 // --- Chunk module (Phase 0/1) ---
 class Chunk {
 constructor(array, chunkCoord){
 this.array = array;
 this.coord = { x: chunkCoord.x|0, y: chunkCoord.y|0, z: chunkCoord.z|0 };
 this.cells = [];
 this.cellMap = new Map(); // key: "x,y,z" -> cell
 this.currentLOD = -1; // -1=unloaded, 1=instanced, 2=greedy
 this.meshLOD1 = null; // InstancedMesh
 this.meshLOD2 = null; // Greedy merged mesh
 this._dirty = false;
 }
 markDirty(){ this._dirty = true; }
 unload(){
 try{
 if(this.meshLOD1){ this.meshLOD1.parent?.remove(this.meshLOD1); this.meshLOD1.geometry?.dispose?.(); this.meshLOD1.material?.dispose?.(); this.meshLOD1=null; }
 if(this.meshLOD2){ this.meshLOD2.parent?.remove(this.meshLOD2); this.meshLOD2.geometry?.dispose?.(); this.meshLOD2.material?.dispose?.(); this.meshLOD2=null; }
 if(this.meshGhost){ this.meshGhost.parent?.remove(this.meshGhost); this.meshGhost.geometry?.dispose?.(); this.meshGhost.material?.dispose?.(); this.meshGhost=null; }
 if(this.meshShell){ this.meshShell.parent?.remove(this.meshShell); this.meshShell.geometry?.dispose?.(); this.meshShell.material?.dispose?.(); this.meshShell=null; }
 }catch{}
 this.currentLOD = -1; this._dirty=false;
 }
 ensureMesh(){
 // Create/ensure twin instanced meshes (solid + ghost + shell) only once per chunk
 try{
 const maxInstances = Math.max(1, this.cells.length|0);
 if(!this.instancedMesh){
 const geo = GEO_VOXEL; // pooled
 addWhiteVertexColors(geo);
 const mats = makeCellMaterials();
 const shellMat = new THREE.MeshBasicMaterial({
 color: 0xffffff,
 transparent: true,
 opacity: 0.28,
 side: THREE.BackSide,
 depthTest: true,
 depthWrite: false,
 toneMapped: false,
 vertexColors: true
 });
 // Tag passes for unified clipping control
 mats.solid.userData = { ...(mats.solid.userData||{}), pass:'solid' };
 mats.ghost.userData = { ...(mats.ghost.userData||{}), pass:'ghost' };
 shellMat.userData = { ...(shellMat.userData||{}), pass:'shell' };
 const meshSolid = new THREE.InstancedMesh(geo, mats.solid, maxInstances);
 const meshGhost = new THREE.InstancedMesh(geo, mats.ghost, maxInstances);
 const meshShell = new THREE.InstancedMesh(GEO_SHELL, shellMat, maxInstances);
 const shadowsEnabled = FancyGraphics.enabled && FancyGraphics.settings.solidGround;
 meshSolid.castShadow = shadowsEnabled;
 meshGhost.castShadow = false;
 meshShell.castShadow = false;
 // Important for correct layering: ghosts first, then solids, then shells
 meshGhost.renderOrder = 1;
 meshSolid.renderOrder = 2;
 meshShell.renderOrder = 3;
 meshSolid.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
 meshGhost.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
 meshShell.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
 // Prevent culling from hiding outlines at shallow angles
 meshSolid.frustumCulled = false; meshGhost.frustumCulled = false; meshShell.frustumCulled = false;
 // Render order: frame(0) -> ghosts(1) -> solids(2) -> shells(3)
 // Drawing solids after ghosts guarantees fills are visible through low-opacity ghosts
 // Per-cell passes: keep in mid-range so frame UI can be drawn above
 meshGhost.renderOrder = window.__RO.ghostFill|0; 
 meshSolid.renderOrder = window.__RO.solidFill|0; 
 meshShell.renderOrder = window.__RO.solidShell|0;
 // Mark materials for cutaway
 mats.solid.userData.pass = 'solid';
 mats.ghost.userData.pass = 'ghost';
 // Allocate instanceColor buffers
 try{
 const colBufSolid = new Float32Array(maxInstances*3);
 const colBufGhost = new Float32Array(maxInstances*3);
 const colBufShell = new Float32Array(maxInstances*3);
 meshSolid.instanceColor = new THREE.InstancedBufferAttribute(colBufSolid, 3); meshSolid.instanceColor.setUsage(THREE.DynamicDrawUsage);
 meshGhost.instanceColor = new THREE.InstancedBufferAttribute(colBufGhost, 3); meshGhost.instanceColor.setUsage(THREE.DynamicDrawUsage);
 meshShell.instanceColor = new THREE.InstancedBufferAttribute(colBufShell, 3); meshShell.instanceColor.setUsage(THREE.DynamicDrawUsage);
 }catch{}
 // Parent under array frame when available
 if(this.array && this.array._frame){ this.array._frame.add(meshSolid); this.array._frame.add(meshGhost); this.array._frame.add(meshShell); } else { scene.add(meshSolid); scene.add(meshGhost); scene.add(meshShell); }
 // Expose for updates
 this.instancedMesh = meshSolid; // primary for solids
 this.meshLOD1 = meshSolid;
 this.meshGhost = meshGhost;
 this.meshShell = meshShell;
 const lod = (this.currentLOD == null || this.currentLOD < 0) ? 1 : this.currentLOD;
 this.meshShell.visible = !FancyGraphics.enabled && (lod === 1);
 // Use twin meshes for ghosting: solid shows unblocked, ghost shows blocked
 try{ this.meshGhost.visible = true; }catch{}
 // Tag for picking and ghost-mask application
 try{
 meshSolid.userData = { ...(meshSolid.userData||{}), arrayId:this.array.id, chunk:this };
 meshGhost.userData = { ...(meshGhost.userData||{}), arrayId:this.array.id, chunk:this };
 meshShell.userData = { ...(meshShell.userData||{}), arrayId:this.array.id, chunk:this };
 }catch{}
 // Stash materials for cutaway updates
 this.array._cellMaterials = this.array._cellMaterials || [];
 this.array._cellMaterials.push(mats.solid, mats.ghost);
 }

 // Stable index map: sort by z,y,x for deterministic ids
 const sorted = [...this.cells].sort((a,b)=> (a.z-b.z) || (a.y-b.y) || (a.x-b.x));
 this.index2cell = sorted; // expose for picking and ghost masking
 this.cellIndexMap = new Map();
 const scale = arrayVoxelScale(this.array);
 const cellScale = voxelDisplayScale(scale);
 for(let i=0;i<sorted.length;i++){
 const c = sorted[i];
 this.cellIndexMap.set(`${c.x},${c.y},${c.z}`, i);
 // Initialize transform
 const p = localPos(this.array, c.x, c.y, c.z);
 temp.position.copy(p);
 temp.rotation.set(0,0,0);
 temp.scale.set(cellScale,cellScale,cellScale);
 temp.updateMatrix();
 this.instancedMesh.setMatrixAt(i, temp.matrix);
 // Start ghosts hidden (zero scale) until occlusion mask applies
 if(this.meshGhost){ tempM.identity(); tempM.makeScale(0,0,0); this.meshGhost.setMatrixAt(i, tempM); }
 if(this.meshShell) this.meshShell.setMatrixAt(i, temp.matrix);
 // Initialize color (custom or type-based); linearized
 const key = `${this.array.id}:${c.x},${c.y},${c.z}`;
 const emitted = !!(Store.getState().sourceByCell && Store.getState().sourceByCell.get && Store.getState().sourceByCell.get(key));
 const isFormula = !!c.formula;
 const custom = c?.meta?.color;
 const hasValue = (c.value!=='' && c.value!==null && c.value!==undefined);
 let hex;
 if(isFormula) hex = baseHexForTypeKey('formula'); else if(emitted) hex = baseHexForTypeKey('emitted'); else hex = hasValue ? baseHexForTypeKey('value') : baseHexForTypeKey('empty');
 const col = new THREE.Color(custom || hex);
 col.convertSRGBToLinear();
 try{
 this.instancedMesh.setColorAt(i, col);
 if(this.meshGhost){ const ghostTint = tintGhostColorFrom(col); this.meshGhost.setColorAt(i, ghostTint); }
 if(this.meshShell){ const sc = col.clone(); sc.offsetHSL(0,0,-0.22); this.meshShell.setColorAt(i, sc); }
 }catch{}
 }
 this.instancedMesh.count = sorted.length;
 this.instancedMesh.instanceMatrix.needsUpdate = true;
 if(this.instancedMesh.instanceColor) this.instancedMesh.instanceColor.needsUpdate = true;
 if(this.meshGhost){ this.meshGhost.count = sorted.length; this.meshGhost.instanceMatrix.needsUpdate = true; if(this.meshGhost.instanceColor) this.meshGhost.instanceColor.needsUpdate = true; }
 if(this.meshShell){ this.meshShell.count = sorted.length; this.meshShell.instanceMatrix.needsUpdate = true; if(this.meshShell.instanceColor) this.meshShell.instanceColor.needsUpdate = true; }
 needsRender = true;
 }catch{}
 return this.instancedMesh;
 }
 buildMeshLOD1(){
 // Use ensureMesh for stable pooled instances
 this.ensureMesh();
 this._dirty = false;
 }
 buildMeshLOD2(){
 // Greedy mesh: merge visible voxels of identical visual into quads per face and extrude
 try{ if(this.meshLOD2){ this.meshLOD2.parent?.remove(this.meshLOD2); this.meshLOD2.geometry?.dispose?.(); this.meshLOD2.material?.dispose?.(); } }catch{}
 this.meshLOD2 = null;
 const cells = this.cells.filter(c=> c && (c.value!=='' || c.formula));
 if(cells.length===0) return;
 const voxels=new Set(cells.map(c=>`${c.x},${c.y},${c.z}`));
 const W=this.array.size.x, H=this.array.size.y, D=this.array.size.z;
 // Build a dense occupancy grid within this chunk bounds
 const minX=this.coord.x*CHUNK_SIZE, minY=this.coord.y*CHUNK_SIZE, minZ=this.coord.z*CHUNK_SIZE;
 const maxX=Math.min(minX+CHUNK_SIZE, W), maxY=Math.min(minY+CHUNK_SIZE, H), maxZ=Math.min(minZ+CHUNK_SIZE, D);
 const Sx=maxX-minX, Sy=maxY-minY, Sz=maxZ-minZ;
 if(Sx<=0||Sy<=0||Sz<=0) return;
 const occ=new Uint8Array(Sx*Sy*Sz);
 const idx=(x,y,z)=> (z*Sy + y)*Sx + x;
 for(let z=minZ; z<maxZ; z++) for(let y=minY; y<maxY; y++) for(let x=minX; x<maxX; x++){
 if(voxels.has(`${x},${y},${z}`)) occ[idx(x-minX,y-minY,z-minZ)]=1;
 }
 // Greedy along each axis, accumulating quads
 const geoms=[];
 const pushQuad=(x0,y0,z0, dx,dy,dz, w,h)=>{
 // Build a box for the merged face thickness 1 cell
 const bx = Math.abs(dy)+Math.abs(dz) ? w : 1;
 const by = Math.abs(dx)+Math.abs(dz) ? h : 1;
 const bz = Math.abs(dx)+Math.abs(dy) ? 1 : 1; // thickness one cell
 const geo=new THREE.BoxGeometry(bx,by,bz);
 // Center in local space
 const cx = x0 + (dx? (w-1)/2 : 0);
 const cy = y0 + (dy? (h-1)/2 : 0);
 const cz = z0;
 const m=new THREE.Matrix4().makeTranslation(
 (cx - W/2 + 0.5),
 ((H - 1 - cy) - H/2 + 0.5),
 ((D - 1 - cz) - D/2 + 0.5)
 );
 geo.applyMatrix4(m);
 geoms.push(geo);
 };
 // Simple XY-plane sweep per Z to merge rectangles of ones
 for(let z=0; z<Sz; z++){
 // Build 2D mask
 const mask=new Uint8Array(Sx*Sy);
 for(let y=0;y<Sy;y++) for(let x=0;x<Sx;x++) mask[y*Sx+x]=occ[idx(x,y,z)];
 // Greedy rectangles in mask
 let y=0; while(y<Sy){
 let x=0; while(x<Sx){
 if(!mask[y*Sx+x]){ x++; continue; }
 // width
 let w=1; while(x+w<Sx && mask[y*Sx + (x+w)]) w++;
 // height
 let h=1; outer: while(y+h<Sy){ for(let k=0;k<w;k++) if(!mask[(y+h)*Sx + (x+k)]) break outer; h++; }
 // clear mask block
 for(let yy=y; yy<y+h; yy++) for(let xx=x; xx<x+w; xx++) mask[yy*Sx+xx]=0;
 // emit quad as thin box at this z-slice
 pushQuad(minX+x, minY+y, minZ+z, 1,0,0, w, h);
 x += w;
 }
 y++;
 }
 }
 // Merge all quads into single geometry
 let merged=null;
 try{ merged = BufferGeometryUtils.mergeGeometries(geoms,false); }catch{ merged = geoms[0]||null; }
 if(!merged) return;
 const m = new THREE.Mesh(merged, createCellMaterial('filled'));
 this.meshLOD2 = m;
 if(this.array._frame) this.array._frame.add(m);
 this._dirty = false;
 }
 setLOD(level){
 if(this.currentLOD === level && !this._dirty) return;
 if(level === 1) this.buildMeshLOD1();
 else if(level === 2) this.buildMeshLOD2();
 // Visibility policy:
 // - LOD1 (instanced): show solids + ghosts + shells
 // - LOD2 (greedy): show merged solid only; hide ghosts/shells (no per-cell masking available)
 // Keep LOD1 instanced mesh "pick-only" when LOD2 is active so arrays remain clickable without focus
 if(this.meshLOD1){
 if(level===1){
 this.meshLOD1.visible = true;
 try{ this.meshLOD1.material.transparent=false; this.meshLOD1.material.opacity=1.0; this.meshLOD1.material.colorWrite=true; this.meshLOD1.material.depthWrite=true; }catch{}
 } else {
 this.meshLOD1.visible = true; // visible for raycasting
 try{ this.meshLOD1.material.transparent=true; this.meshLOD1.material.opacity=0.0; this.meshLOD1.material.colorWrite=false; this.meshLOD1.material.depthWrite=false; }catch{}
 }
 }
 if(this.meshGhost) this.meshGhost.visible = (level===1);
 if(this.meshShell) this.meshShell.visible = (level===1) && !FancyGraphics.enabled;
 if(this.meshLOD2){
 this.meshLOD2.visible = (level===2 && !this.array._headOnZ);
 // Ensure pickability when LOD2 is visible: leave LOD1 raycastable but visually invisible
 try{ if(this.meshLOD2.visible && this.meshLOD1){ this.meshLOD1.raycast = THREE.InstancedMesh.prototype.raycast; } }catch{}
 }
 // Keep LOD1 pooled; do not destroy
 this.currentLOD = level; this._dirty=false;
 }
 }
 // Greedy mesher stub (Phase 2 placeholder)
 function generateGreedyMesh(chunk){
 // Provided by buildMeshLOD2 now; keep for API completeness
 try{ chunk.buildMeshLOD2(); }catch{}
 return chunk.meshLOD2?.geometry || null;
 }
 // ChunkManager scaffold (Phase 3; gated by enable flag)
 const ChunkManager = {
 enabled:true,
 warmupFrames:0,
 update(){ /* selection-window LOD handled in renderArray/updateFocus */ }
 };
 function renderArray(arr){
 // Skip rendering if array is being deleted
 if(arr._deleting) return;
 
 // Prune any stale chunk meshes first
 pruneStaleChunkMeshes(arr.id);
 
 // Wireframe "cage" frame with interior lookthrough fill (does not occlude voxels)
 if(!arr._frame){
 const group = new THREE.Group();

 // Frame removed: using clipping planes instead of stencil slab

 // 2) Structural rounded-edge cage
 const scale = arrayVoxelScale(arr);
 const framePad = clampedScaleOffset(scale, 0.6);
 const frameGeom = new RoundedBoxGeometry(
 arr.size.x*scale + 2*framePad,
 arr.size.y*scale + 2*framePad,
 arr.size.z*scale + 2*framePad,
 3, 0.2
 );
 const edges = new THREE.EdgesGeometry(frameGeom);
 // Remove wireframe cage per request (keep edges object construction for potential future use but do not add)
 // const edgeLines = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: COLORS.frame, transparent: true, opacity: 0.45 }));
 // edgeLines.renderOrder = 20; // draw after fill
 // group.add(edgeLines);

 group.userData = {};
 // Array label sprite positioned near the front-left corner of the grab handle
 try{
 const labelSprite = makeArrayLabelSprite(arr);
 // Front-left corner of the array bounds (grab handle lives here)
 const scale = arrayVoxelScale(arr);
 const corner = new THREE.Vector3(
 -(arr.size.x*scale/2 + clampedScaleOffset(scale, 0.4)),
 arr.size.y*scale/2 + clampedScaleOffset(scale, 1.2),
 arr.size.z*scale/2 + clampedScaleOffset(scale, 0.4)
 );
 labelSprite.position.copy(corner);
 labelSprite.userData.billboard = true;
 // Left-align text from the corner. The sprite is center-anchored, so offset half the width along +X.
 try{ const w = labelSprite.scale.x; labelSprite.position.x += (w*0.5); }catch{}
 // Ensure it renders above voxels but depth-tested so it sorts by distance
 try{ labelSprite.material.depthTest = true; labelSprite.material.depthWrite = false; }catch{}
 group.add(labelSprite);
 group.userData.labelSprite = labelSprite;
 }catch{}
 arr._frame = group;
 // Hook: minimal diagnostics like colorfix
 try{
 arr._frame.userData.renderDiag = function(){
 const lines = [
 `ToneMapping: ${renderer.toneMapping === THREE.NoToneMapping ? 'None' : renderer.toneMapping}`,
 `outputColorSpace: ${renderer.outputColorSpace}`
 ];
 const z = 0;
 const types=['empty','filled','formula','ghost'];
 for(const t of types){
 const rec=layerMeshes.get(`${arr.id}:${z}:${t}`);
 lines.push(`${t}.instanceColor: ${!!(rec && rec.mesh && rec.mesh.instanceColor)}`);
 }
 console.log(lines.join('\n'));
 }
 }catch{}
 scene.add(arr._frame);
 }
 // center frame at array offset like voxels
 const off=arr.offset||{x:0,y:0,z:0};
 arr._frame.position.set(off.x,off.y,off.z);
 try{ refreshLightsForArray(arr.id); }catch{}
 // No in-scene d-pad overlay (HUD-only)
 buildAxes(arr);
 // Reparent any chunk meshes/shells under frame to ensure center alignment
 try{
 Object.values(arr.chunks||{}).forEach(ch=>{
 if(ch.meshLOD1 && ch.meshLOD1.parent!==arr._frame){ arr._frame.add(ch.meshLOD1); }
 if(ch.meshGhost && ch.meshGhost.parent!==arr._frame){ arr._frame.add(ch.meshGhost); }
 if(ch.meshShell && ch.meshShell.parent!==arr._frame){ arr._frame.add(ch.meshShell); }
 });
 if(arr._arrayShell && arr._arrayShell.parent!==arr._frame){ arr._frame.add(arr._arrayShell); }
 }catch{}
 const sel = Store.getState().selection;
 const isFocused = (sel.arrayId === arr.id);
 const focus = isFocused && sel.focus ? {...sel.focus} : null;
 const cellCount = Object.values(arr.chunks).reduce((n,ch)=> n + ch.cells.length, 0);
 // Prefer filled cell count for LOD2 decisions; empty arrays should keep LOD1 visible
 let filledCount = 0;
 try{
 Object.values(arr.chunks).forEach(ch=>{
 for(let i=0;i<ch.cells.length;i++){
 const c = ch.cells[i];
 if(!c) continue;
 if((c.value!=='' && c.value!==null && c.value!==undefined) || !!c.formula) { filledCount++; }
 }
 });
 }catch{}
 const wantGreedy = filledCount >= INACTIVE_GREEDY_THRESHOLD;

 // Use new GPU cutaway system via chunks only when ChunkManager is enabled
 if(Scene.ChunkManager && Scene.ChunkManager.enabled){
 // Single source of truth: chunk occlusion only. Ensure legacy meshes are removed.
 try{
 for(let z=0; z<arr.size.z; z++){
 ['empty','ghost','filled','formula','edges'].forEach(type=>{
 const key = `${arr.id}:${z}:${type}`;
 const rec = layerMeshes.get(key);
 if(rec){ if(arr._frame) arr._frame.remove(rec.mesh); else scene.remove(rec.mesh); rec.mesh.geometry?.dispose?.(); rec.mesh.material?.dispose?.(); layerMeshes.delete(key); }
 });
 }
 }catch{}
 // Remove legacy layer meshes to prevent flashing when chunks are ON
 try{
 for(let z=0; z<arr.size.z; z++){
 ['empty','ghost','filled','formula','edges'].forEach(type=>{
 const key = `${arr.id}:${z}:${type}`;
 const rec = layerMeshes.get(key);
 if(rec){ if(arr._frame) arr._frame.remove(rec.mesh); else scene.remove(rec.mesh); rec.mesh.geometry?.dispose?.(); rec.mesh.material?.dispose?.(); layerMeshes.delete(key); }
 });
 }
 }catch{}
 // Gate chunk work to the focused window only
 const warm = (Scene.ChunkManager.warmupFrames||0) > 0;
 if(isFocused && focus){
 try{
 const fc = chunkOf(focus.x, focus.y, focus.z);
 for(const ch of Object.values(arr.chunks)){
 const dx = Math.abs(ch.coord.x - fc.x);
 const dy = Math.abs(ch.coord.y - fc.y);
 const dz = Math.abs(ch.coord.z - fc.z);
 const near = (dx <= WINDOW_CHUNK_RADIUS && dy <= WINDOW_CHUNK_RADIUS && dz <= WINDOW_CHUNK_RADIUS);
 if(warm){ ch.ensureMesh?.(); ch.setLOD?.(1); }
 else if(near){ ch.ensureMesh?.(); ch.setLOD?.(1); }
 else { if (cellCount >= INACTIVE_GREEDY_THRESHOLD) { ch.setLOD?.(2); } else { ch.ensureMesh?.(); ch.setLOD?.(1); } }
 }
 }catch{}
 try{ applyCutaway(arr, focus); }catch{}
 } else {
 try{
 for(const ch of Object.values(arr.chunks)){
 const warmSelf = (arr._warmupFrames|0) > 0;
 if(Scene.ChunkManager.warmupFrames>0 || warmSelf){ ch.ensureMesh?.(); ch.setLOD?.(1); }
 else if (filledCount >= INACTIVE_GREEDY_THRESHOLD) { ch.setLOD?.(2); }
 else { ch.ensureMesh?.(); ch.setLOD?.(1); }
 }
 }catch{}
 }
 // Whole-array highlight shell: behind cell fills; slightly larger; functionally invisible core
 try{
 const sh=ensureArrayHighlightShell(arr); if(sh){
 sh.visible=!arr.hidden;
 sh.traverse(n=>{ if(n.isMesh){ n.material.depthTest=true; n.material.depthWrite=false; } });
 sh.children?.forEach?.(m=>{ if(m?.isMesh && m.material?.stencilWrite){ m.renderOrder = 290; } });
 }
 }catch{}
 if(Scene.ChunkManager.warmupFrames>0){ Scene.ChunkManager.warmupFrames--; }
 if((arr._warmupFrames|0) > 0){ arr._warmupFrames--; }
 } else {
 // Ensure any previously created chunk twin meshes are hidden when chunks are OFF
 try{
 Object.values(arr.chunks).forEach(ch=>{
 if(ch.meshLOD1) ch.meshLOD1.visible=false;
 if(ch.meshGhost) ch.meshGhost.visible=false;
 if(ch.meshShell) ch.meshShell.visible=false;
 });
 }catch{}
 // Whole-array highlight shell in legacy mode as well
 try{ ensureArrayHighlightShell(arr); }catch{}
 }

 // Head-on slab mode detection: when looking down +Z or -Z, hide greedy LOD2 so occluded layers don't appear filled
 try{
 const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
 const headOnZ = (Math.abs(dir.z) >= Math.max(Math.abs(dir.x), Math.abs(dir.y)) && Math.abs(dir.z) > 0.92);
 arr._headOnZ = !!headOnZ;
 // Compute a view signature (major axis + relative layer) to avoid unnecessary rebuilds
 const ax = Math.abs(dir.x), ay = Math.abs(dir.y), az = Math.abs(dir.z);
 const major = (az >= ax && az >= ay) ? 'Z' : (ax >= ay ? 'X' : 'Y');
 const sel = Store.getState().selection || {};
 const focus = (sel.arrayId === arr.id) ? sel.focus : null;
 const relLayer = (major==='Z') ? (focus?.z ?? null) : (major==='X' ? (focus?.x ?? null) : (focus?.y ?? null));
 const viewSig = `${major}:${relLayer==null?'n':relLayer}:${arr._headOnZ?1:0}`;
 if(arr._viewSig === viewSig && arr._layersRendered){
 // View signature unchanged; skip expensive layer rebuild
 return;
 }
 arr._viewSig = viewSig;
 }catch{ arr._headOnZ = false; }

 // Do not destroy existing layer meshes; they will be updated/hid as needed for performance
 arr._layersRendered = true;
 syncVisibility(arr);
 debounceColliderRebuild(arr);
 // Rehydrate value sprites for this array after render
 try{
 const vs = window.valueSprites || new Map();
 vs.forEach((sprite,key)=>{ if(String(key).startsWith(`${arr.id}:`)){ try{ unmarkBillboard(sprite); sprite.parent?.remove(sprite); sprite.material?.map?.dispose?.(); sprite.material?.dispose?.(); }catch{} vs.delete(key); } });
 Object.values(arr.chunks||{}).forEach(ch=>{
 (ch.cells||[]).forEach(c=>{
 try{
 const cell = Formula.getCell({arrId: arr.id, x:c.x, y:c.y, z:c.z});
 if(cell && (cell.value!=='' && cell.value!==null && cell.value!==undefined)) updateValueSprite(arr, c.x, c.y, c.z, cell);
 }catch{}
 });
 });
 updateArrayValueSpritePlacement(arr);
 }catch{}
 }

 function renderChunk(arrayId, chunk, size){
 const arr = Store.getState().arrays[arrayId];
 // Skip rendering if array is being deleted
 if(arr?._deleting) return;
 
 const mKey = `${arrayId}:${keyChunk(chunk.coord.x,chunk.coord.y,chunk.coord.z)}`;

 // Get or create once (no shadowing)
 let mesh = chunkMeshes.get(mKey);
 if (!mesh) {
 mesh = new THREE.InstancedMesh(GEO_VOXEL.clone(), createCellMaterial('filled'), Math.max(1, chunk.cells.length));
 mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
 mesh.frustumCulled = false;
 mesh.userData = { arrayId, chunkKey: keyChunk(chunk.coord.x,chunk.coord.y,chunk.coord.z) };
 chunkMeshes.set(mKey, mesh);
 // Parent to frame for consistent movement
 if (arr._frame) arr._frame.add(mesh); else scene.add(mesh);
 }

 // Ensure instanceColor exists & matches count
 const count = chunk.cells.length;
 if (mesh.instanceColor == null || mesh.instanceColor.count !== count) {
 mesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(Math.max(1, count) * 3), 3);
 mesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
 // Seed with white to prevent black cells
 const seed = new THREE.Color(0xffffff).convertSRGBToLinear();
 for (let i = 0; i < Math.max(1, count); i++) mesh.setColorAt(i, seed);
 }

 // Fill transforms & per-instance colors from live cell state (treat as atomic unit)
 const scale = arrayVoxelScale(arr);
 for (let i = 0; i < count; i++) {
 const c = chunk.cells[i];

 // Use fast accessor for live value/meta including custom colors
 const fresh = getCellFast(arrayId, { x: c.x, y: c.y, z: c.z });
 const has = (fresh.value !== '' && fresh.value !== null && fresh.value !== undefined);
 const isFormula = !!fresh.formula;
 const key = `${arrayId}:${c.x},${c.y},${c.z}`;
 const emitted = !!(Store.getState().sourceByCell?.get?.(key));
 const custom = fresh?.meta?.color;

 let hex = has ? COLORS.filled : COLORS.empty;
 if (isFormula) hex = COLORS.formula;
 else if (emitted) hex = COLORS.emitted;

 // Use local position for frame-relative rendering; zero rotation/scale (centered)
 temp.position.copy(localPos(arr, c.x, c.y, c.z));
 temp.rotation.set(0,0,0);
 temp.scale.set(scale,scale,scale);
 temp.updateMatrix();
 mesh.setMatrixAt(i, temp.matrix);

 const col = new THREE.Color(custom || hex);
 col.convertSRGBToLinear();
 mesh.setColorAt(i, col);
 }

 mesh.count = count;
 mesh.instanceMatrix.needsUpdate = true;
 if (mesh.instanceColor) mesh.instanceColor.needsUpdate = true;
 }
 function ensureLayerMesh(arr, z, type, capacity){
 const key = `${arr.id}:${z}:${type}`;
 let rec = layerMeshes.get(key);
 const cap = Math.max(1, capacity);

 const makeMesh = (cap) => {
 const geom = GEO_VOXEL.clone(); addWhiteVertexColors(geom);
 const baseType = (type && String(type).startsWith('ghost')) ? 'ghost' : (type||'filled');
 const mesh = new THREE.InstancedMesh(geom, createCellMaterial(baseType), cap);
 mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
 mesh.frustumCulled = false;
 mesh.userData = { arrayId: arr.id, z, type, isGhost: baseType==='ghost' };
 if(baseType==='ghost'){
 // Ghost: unlit, depth-tested, above solids
 mesh.material = new THREE.MeshBasicMaterial({
 color: 0xffffff,
 transparent: true,
 opacity: 0.20,
 depthWrite: false,
 depthTest: true,
 vertexColors: true,
 blending: THREE.AdditiveBlending
 });
 mesh.material.toneMapped = false;
 mesh.renderOrder = 2;
 }
 // Parent under frame and use local positions for tight alignment
 if(arr._frame) arr._frame.add(mesh); else scene.add(mesh);
 return mesh;
 };

 if (!rec) {
 const mesh = makeMesh(cap);
 // Ensure instanceColor is allocated and seeded
 if (mesh.instanceColor == null || mesh.instanceColor.count !== cap) {
 mesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(cap*3), 3);
 mesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
 // Seed with sRGB white -> linear to avoid black first frame
 const seed = new THREE.Color(0xffffff).convertSRGBToLinear();
 for (let i = 0; i < cap; i++) mesh.setColorAt(i, seed);
 }
 // Seed with white to avoid black cells
 const seed = new THREE.Color(0xffffff).convertSRGBToLinear();
 for (let i = 0; i < cap; i++) mesh.setColorAt(i, seed);
 rec = { mesh, capacity: cap, used: 0, index2cell: [] };
 layerMeshes.set(key, rec);
 return rec;
 }

 if (capacity > rec.capacity) {
 // Grow-only: reallocate instance buffers on existing mesh
 const mesh = rec.mesh;
 try{
 const newMatrix = new THREE.InstancedBufferAttribute(new Float32Array(capacity * 16), 16);
 mesh.instanceMatrix = newMatrix;
 mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
 if(mesh.instanceColor){
 mesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(capacity * 3), 3);
 mesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
 // Seed expanded buffer with white
 const seed = new THREE.Color(0xffffff).convertSRGBToLinear();
 for (let i = 0; i < capacity; i++) mesh.setColorAt(i, seed);
 }
 }catch{}
 rec.capacity = capacity;
 rec.index2cell.length = 0;
 if (mesh.instanceColor) mesh.instanceColor.needsUpdate = true;
 }
 return rec;
 }
 function renderLayer(arr, z){
 // LEGACY LAYER PIPELINE REMOVED use chunk SoT exclusively
 return;
 }

 function renderCellGroup(arr, z, type, cellData){
 const key=`${arr.id}:${z}:${type}`;
 const capacity = Math.max(1, cellData.length);
 const rec = ensureLayerMesh(arr, z, type, capacity);
 const mesh = rec.mesh;
 rec.index2cell.length = 0;
 if(cellData.length === 0){
 // Swap behavior: if this is a ghost group, ensure corresponding solid group is visible; otherwise hide this group
 mesh.count = 0;
 mesh.visible = false;
 return;
 }
 const geom = GEO_VOXEL.clone();
 const GREEN = {dark:0x16a34a, light:0x86efac};
 const BLUE = 0x3b82f6;
 const WHITE = 0xffffff;
 // Map ghost variants to ghost material
 const baseType = (type && type.startsWith('ghost')) ? 'ghost' : type;
 mesh.userData = { arrayId: arr.id, z, type, isGhost: baseType==='ghost' };
 // Improve pickability: avoid incorrect culling bounds on instanced voxels
 mesh.frustumCulled = false;

 // ?? Click-through for ghost:
 if (baseType === 'ghost') {
 // never receive ray hits
 mesh.raycast = () => {};
 // Replace with unlit additive pass so it lightens instead of darkens
 if(!(mesh.material && mesh.material.isMeshBasicMaterial)){
 mesh.material = new THREE.MeshBasicMaterial({
 color: 0xffffff,
 transparent: true,
 opacity: 0.20,
 depthWrite: false,
 depthTest: true,
 vertexColors: true,
 blending: THREE.AdditiveBlending
 });
 }
 mesh.material.toneMapped = false;
 mesh.renderOrder = 2;
 } else {
 // Make sure opaque pass wins z-buffer and renders above frames
 mesh.material.transparent = false;
 mesh.material.depthWrite = true;
 mesh.renderOrder = 1; // render above frames (renderOrder 0)
 }

 // Shadows disabled in simple mode

 // place instances + per-instance color for ghost "chain" visualization
 const index2cell = cellData.map(cd => cd.c);
 const useColors = (baseType==='ghost' || baseType==='filled' || baseType==='formula');
 if(useColors && (mesh.instanceColor == null || (mesh.instanceColor && mesh.instanceColor.count !== cellData.length))){
 mesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(cellData.length*3), 3);
 mesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
 }
 // Ensure outline overlay exists and is kept in sync for the same group key
 const overlayKey = `${arr.id}:${z}:${type}:edges`;
 let overlayRec = layerMeshes.get(overlayKey);
 if(!overlayRec){ addEdgeOverlay(`${arr.id}:${z}:${type}`, arr, z, cellData); overlayRec = layerMeshes.get(overlayKey); }
 else {
 // Update transforms and colors for overlays without recreating
 const borders = overlayRec.mesh;
 if(borders.count !== cellData.length){
 borders.count = cellData.length;
 if(!borders.instanceColor || borders.instanceColor.count !== cellData.length){
 borders.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(cellData.length*3),3);
 borders.instanceColor.setUsage(THREE.DynamicDrawUsage);
 }
 }
 for(let i=0;i<cellData.length;i++){
 const {c, freshCell} = cellData[i];
 const pos = localPos(arr,c.x,c.y,c.z);
 temp.position.copy(pos);
 temp.updateMatrix();
 borders.setMatrixAt(i, temp.matrix);
 try{
 const key=`${arr.id}:${c.x},${c.y},${c.z}`;
 const fresh = freshCell || Scene.getCell(arr.id,{x:c.x,y:c.y,z:c.z});
 const has = (fresh.value!=='' && fresh.value!==null && fresh.value!==undefined);
 const isFormula = !!fresh.formula;
 const emitted = !!(Store.getState().sourceByCell && Store.getState().sourceByCell.get && Store.getState().sourceByCell.get(key));
 const tk2 = isFormula ? 'formula' : (emitted ? 'emitted' : (has ? 'value' : 'empty'));
 const { colorHex: overrideOutline2 } = outlineParamsForTypeKey(tk2);
 const baseHex2 = baseHexForTypeKey(tk2);
 const col2 = new THREE.Color( (typeof overrideOutline2==='number') ? overrideOutline2 : baseHex2 );
 if(typeof overrideOutline2!=='number'){ col2.offsetHSL(0,0,-0.25); }
 col2.convertSRGBToLinear();
 borders.setColorAt(i, col2);
 }catch{}
 }
 borders.instanceMatrix.needsUpdate = true;
 if(borders.instanceColor) borders.instanceColor.needsUpdate = true;
 borders.visible = true;
 }
 const isCellEmitted = (arr, c) => {
 const key = `${arr.id}:${c.x},${c.y},${c.z}`;
 return !!(Store.getState().sourceByCell && Store.getState().sourceByCell.get && Store.getState().sourceByCell.get(key));
 };
 for(let i=0; i<cellData.length; i++){
 const {c, freshCell} = cellData[i];
 const pos = localPos(arr,c.x,c.y,c.z);
 const scale = arrayVoxelScale(arr);
 temp.position.copy(pos);
 temp.scale.set(scale, scale, scale);
 temp.updateMatrix();
 mesh.setMatrixAt(i, temp.matrix);
 if(useColors){
 // Ghost categories by group, else per-cell meta color for solids
 if(baseType==='ghost'){
 let colorHex = WHITE;
 if(type==='ghost_source') colorHex = GREEN.dark;
 else if(type==='ghost_emitted') colorHex = GREEN.light;
 else if(type==='ghost_value') colorHex = BLUE;
 else if(type==='ghost_empty') colorHex = WHITE;
 { const col=new THREE.Color(colorHex); col.convertSRGBToLinear(); mesh.setColorAt(i, col); }
 } else {
 const custom = freshCell?.meta?.color;
 let hex;
 if(baseType==='formula') hex = baseHexForTypeKey('formula'); 
 else if(isCellEmitted(arr, c)) hex = baseHexForTypeKey('emitted'); 
 else hex = baseHexForTypeKey('value');
 { const col=new THREE.Color(custom || hex); col.convertSRGBToLinear(); mesh.setColorAt(i, col); }
 }
 }
 }
 if(useColors && mesh.instanceColor) mesh.instanceColor.needsUpdate = true;
 mesh.visible = true;

 mesh.count = cellData.length;
 mesh.instanceMatrix.needsUpdate = true;
 layerMeshes.set(key, {mesh, capacity: Math.max(rec.capacity, cellData.length), used: cellData.length, index2cell});
 }
 function addEdgeOverlay(baseKey, arr, z, cellData, colorHex){
 const key = `${baseKey}:edges`;
 const old = layerMeshes.get(key);
 if(old){ if(arr._frame) arr._frame.remove(old.mesh); else scene.remove(old.mesh); old.mesh.geometry.dispose(); old.mesh.material.dispose(); }

 if(cellData.length === 0) return;

 // Create rounded borders using scaled-down rounded cubes
 const tk = typeKeyFrom(baseKey.split(':').pop());
 const { thickness, colorHex: overrideOutline, opacity } = outlineParamsForTypeKey(tk);
 const borderGeom = new RoundedBoxGeometry(thickness, thickness, thickness, 3, 0.15); // slightly larger, inverted hull
 const borderMat = new THREE.MeshBasicMaterial({ 
 color: (typeof overrideOutline === 'number' ? overrideOutline : (typeof colorHex==='number'?colorHex:0xffffff)), 
 transparent: true, 
 opacity: (String(baseKey).includes('ghost') ? Math.max(0, Math.min(1, opacity*0.8)) : opacity),
 side: THREE.BackSide,
 depthTest: true,
 depthWrite: false,
 vertexColors: true
 });
 borderMat.toneMapped = false;
 const borders = new THREE.InstancedMesh(borderGeom, borderMat, cellData.length);
 borders.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
 // Allocate per-instance colors for outlines (darker variants of base color)
 if(!borders.instanceColor || borders.instanceColor.count !== cellData.length){
 borders.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(cellData.length*3), 3);
 borders.instanceColor.setUsage(THREE.DynamicDrawUsage);
 }
 borders.userData = { arrayId: arr.id, z, type:'edges', kind:'edgeOverlay' };
 borders.frustumCulled = false;
 borders.renderOrder = 2;

 for(let i=0;i<cellData.length;i++){
 const {c, freshCell} = cellData[i] || {c:null,freshCell:null};
 const pos = localPos(arr,c.x,c.y,c.z);
 temp.position.copy(pos);
 temp.updateMatrix();
 borders.setMatrixAt(i, temp.matrix);
 // Per-instance darker outline color based on base cell color
 try{
 const key=`${arr.id}:${c.x},${c.y},${c.z}`;
 const fresh = freshCell || Scene.getCell(arr.id,{x:c.x,y:c.y,z:c.z});
 const has = (fresh.value!=='' && fresh.value!==null && fresh.value!==undefined);
 const isFormula = !!fresh.formula;
 const emitted = !!(Store.getState().sourceByCell && Store.getState().sourceByCell.get && Store.getState().sourceByCell.get(key));
 const baseHex = isFormula ? COLORS.formula : emitted ? COLORS.emitted : (has ? COLORS.filled : COLORS.empty);
 const col = new THREE.Color(baseHex);
 col.offsetHSL(0, 0, -0.25); // darker
 col.convertSRGBToLinear();
 borders.setColorAt(i, col);
 }catch{}
 }
 borders.count = cellData.length;
 borders.instanceMatrix.needsUpdate = true;
 if(borders.instanceColor) borders.instanceColor.needsUpdate = true;

 // Parent to frame; use local positions to stay aligned
 if(arr._frame) arr._frame.add(borders); else scene.add(borders);
 layerMeshes.set(key, {mesh:borders, capacity: cellData.length, used: cellData.length, index2cell: cellData.map(cd=>cd.c)});
 }
 function buildAxes(arr){
 // remove old
 // Remove previous labels safely from their actual parent
 arr.labels?.forEach(s=>{ try{ if(s?.userData?.billboard) unmarkBillboard(s); s.parent?.remove(s); s.material?.dispose?.(); s.material?.map?.dispose?.(); s.geometry?.dispose?.(); }catch{} }); arr.labels=[];
 const mk=(txt,color='#333333')=>{
 const c=document.createElement('canvas'); const ctx=c.getContext('2d'); const fs=64;
 ctx.font=`900 ${fs}px 'Roboto Mono', monospace`; const w=Math.ceil(ctx.measureText(txt).width);
 c.width=w+24; c.height=fs+24;
 // Transparent background
 ctx.clearRect(0,0,c.width,c.height);
 ctx.fillStyle=color; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font=`900 ${fs}px 'Roboto Mono', monospace`;
 ctx.fillText(txt,c.width/2,c.height/2);
 const t=new THREE.CanvasTexture(c);
 t.colorSpace = THREE.SRGBColorSpace;
 // Depth test true so it sorts by distance; write false to avoid z artifacts
 const m=new THREE.SpriteMaterial({map:t,depthTest:true,depthWrite:false,transparent:true});
 m.toneMapped = false;
 const s=new THREE.Sprite(m);
 const targetH=0.6; // consistent height in world units
 const aspect=c.width/c.height; s.scale.set(targetH*aspect, targetH, 1);
 return markBillboard(s);
 };
 const X=arr.size.x,Y=arr.size.y,Z=arr.size.z;
 const scale = arrayVoxelScale(arr);
 const grabSize=0.7; // smaller rounded voxel for handle
 const halfStep = scale/2;
 const origin=localPos(arr,0,0,0); // local center of A1a (top row)
 const topFaceY = origin.y + halfStep;
 const frontFaceZ = origin.z + halfStep;
 const leftFaceX = origin.x - halfStep;
 // Fine-tune label offsets relative to grab/cell centers. Scale with voxel spacing so labels track edges.
 const LABEL_Y_DOWN = 0.12 * scale; // nudge downwards a touch
 const LABEL_X_RIGHT_Y_AXIS = 0.12 * scale; // Y-axis numbers slightly to the right
 const LABEL_Z_BACK = 0.06 * scale; // slight push back along -Z when near grab

 // Only rebuild grab if not already present to avoid stamping
 let grab = arr.labels?.find(l=>l.userData?.type==='grab');
 if(!grab){
 const grabMat=new THREE.MeshBasicMaterial({color:COLORS.grab, depthWrite:true});
 grab=new THREE.Mesh(new RoundedBoxGeometry(grabSize,grabSize,grabSize,3,Math.min(.2,grabSize*.25)), grabMat);
 grab.userData={type:'grab', arrayId:arr.id};
 // Parent grab to frame so it follows
 if(arr._frame) arr._frame.add(grab); else scene.add(grab);
 try{ if(arr._frame) arr._frame.userData.grab = grab; }catch{}
 }
 const grabX = leftFaceX - grabSize/2;
 const grabY = topFaceY + grabSize/2;
 const grabZ = frontFaceZ + grabSize/2;
 grab.position.set(grabX, grabY, grabZ);
 if(!arr.labels.includes(grab)) arr.labels.push(grab);

 // Emit axes from grab handle faces, billboarded and aligned near the grab corner
 // X headers (A..) emit from right face of grab, aligned to cell centers
 for(let x=0;x<X;x++){ 
 const s=mk(A1(x),'#ff1a1a'); s.userData.billboard=true;
 const cellPos=localPos(arr,x,0,0);
 // Align to the grab handle s back face Z, and match Z label downshift on Y
 s.position.set(cellPos.x, grabY - LABEL_Y_DOWN, grabZ);
 if(arr._frame) arr._frame.add(s); else scene.add(s); arr.labels.push(s);
 }
 // Y headers (1..) top row is 1, increase downward
 for(let y=0;y<Y;y++){
 const s=mk(String(y+1),'#00e676'); s.userData.billboard=true;
 const cellPos=localPos(arr,0,y,0);
 // Align near grab: slightly right on X, slightly down on Y, slightly back on Z
 s.position.set(grabX + LABEL_X_RIGHT_Y_AXIS, cellPos.y - LABEL_Y_DOWN, grabZ - LABEL_Z_BACK);
 if(arr._frame) arr._frame.add(s); else scene.add(s); arr.labels.push(s);
 }
 // Z headers (a..) emit negatively along Z, aligned to the back XY face of grab
 for(let z=0;z<Z;z++){
 const s=mk(greek(z),'#0066ff'); s.userData.billboard=true;
 const cellPos=localPos(arr,0,0,z);
 // Emit along Z and match Y with grab center, nudged slightly down
 s.position.set(grabX, grabY - LABEL_Y_DOWN, cellPos.z);
 if(arr._frame) arr._frame.add(s); else scene.add(s); arr.labels.push(s);
 }

 // In-scene D-Pad removed (use HUD)

 arr.labels.forEach(s=>s.visible=Store.getState().scene.showAxes);
 }
 // ensureNavPad removed

 function syncVisibility(arr){
 const v=!arr.hidden; 
 if(arr._frame) arr._frame.visible=v;
 // update layer meshes visibility
 for(let z=0; z<arr.size.z; z++){
 ['empty','ghost','filled','formula','edges'].forEach(type=>{
 const rec=layerMeshes.get(`${arr.id}:${z}:${type}`); if(rec) rec.mesh.visible=v;
 });
 }
 // chunk meshes
 const scale = arrayVoxelScale(arr);
 Object.values(arr.chunks).forEach(ch=>{
 if(ch.meshLOD2) ch.meshLOD2.visible = v && (ch.currentLOD===2);
 if(ch.meshLOD1){
 const pickVisible = v && (ch.currentLOD===1 || (ch.meshLOD2 && ch.meshLOD2.visible));
 ch.meshLOD1.visible = pickVisible;
 }
 if(ch.meshShell){
 const lod = (ch.currentLOD == null) ? 1 : ch.currentLOD;
 ch.meshShell.visible = v && (lod === 1) && !FancyGraphics.enabled;
 }
 const mk=`${arr.id}:${keyChunk(ch.coord.x,ch.coord.y,ch.coord.z)}`; const m=chunkMeshes.get(mk); if(m) m.visible=v;
 });
 // axis labels and grab handles
 const globalAxes = Store.getState().scene.showAxes;
 const localAxes = (arr.axesVisible === undefined) ? globalAxes : !!arr.axesVisible;
 arr.labels?.forEach(s=> s.visible = v && localAxes);
 // Debug: update HUD counts
 try{ updateCountChip(); }catch{}
 // Toggle value sprite visibility correctly
 valueSprites.forEach((sprite,key)=>{ if(String(key).startsWith(`${arr.id}:`)) sprite.visible = v; });
 // value sprites
 Object.keys(valueSprites).forEach(key=>{
 if(key.startsWith(`${arr.id}:`)){
 const sprite=valueSprites.get(key);
 if(sprite) sprite.visible=v;
 }
 });
 // Update debug counts after any visibility change
 try{ updateCountChip?.(); }catch{}
 // Update 2D sheet if this array becomes invisible
 if(!v && Store.getState().selection.arrayId===arr.id){
 // Switch to next visible array
 const visibleArrays=Object.values(Store.getState().arrays).filter(a=>!a.hidden);
 if(visibleArrays.length>0){
 const next=visibleArrays[0];
 Actions.setSelection(next.id, {x:0,y:Math.max(0,next.size.y-1),z:0});
 window.UI?.renderSheet();
 }
 }
 }

 // Debug HUD counts: total cell instances and split by Chunk/Legacy
 function updateCountChip(){
 try{
 let shellsChunk=0, shellsLegacy=0, fillsChunk=0, fillsLegacy=0;
 // Chunk meshes
 Object.values(Store.getState().arrays).forEach(arr=>{
 Object.values(arr.chunks||{}).forEach(ch=>{
 if(ch.meshShell) shellsChunk += (ch.meshShell.count||0);
 if(ch.meshLOD1) fillsChunk += (ch.meshLOD1.count||0);
 });
 });
 // Legacy meshes
 layerMeshes.forEach((rec,key)=>{
 if(!rec||!rec.mesh) return;
 if(String(key).endsWith(':edges')) shellsLegacy += (rec.mesh.count||0);
 else fillsLegacy += (rec.mesh.count||0);
 });
 const totalUnique = fillsChunk + fillsLegacy;
 const chip=document.getElementById('countChip'); if(chip){ chip.textContent = `Cells:${totalUnique} | Shells C/L:${shellsChunk}/${shellsLegacy} | Fills C/L:${fillsChunk}/${fillsLegacy}`; }
 }catch{}
 }

 // Debug panel to control renderOrder for voxel passes
 // Render order debug UI removed

 function forceRenderOrderRefresh(reapplyOcclusion){
 try{
 // Update chunk instanced meshes
 Object.values(Store.getState().arrays).forEach(arr=>{
 Object.values(arr.chunks||{}).forEach(ch=>{
 if(ch.meshGhost) ch.meshGhost.renderOrder = window.__RO.ghostFill|0;
 if(ch.meshLOD1) ch.meshLOD1.renderOrder = window.__RO.solidFill|0;
 if(ch.meshShell) ch.meshShell.renderOrder = window.__RO.solidShell|0;
 });
 // Update whole-array shell as Ghost Shell for debugging purposes
 if(arr._arrayShell){
 arr._arrayShell.traverse(n=>{
 if(!n.isMesh) return;
 // detect by stencil: core writes stencil, shell reads NotEqual
 if(n.material && n.material.stencilWrite && n.material.stencilFunc===THREE.AlwaysStencilFunc){
 n.renderOrder = window.__RO.frameCore|0;
 } else {
 n.renderOrder = window.__RO.frameShell|0;
 }
 });
 }
 if(reapplyOcclusion){ try{ const sel=Store.getState().selection; if(sel?.arrayId&&sel.focus){ applyGhostMaskToChunks(arr); } }catch{} }
 });
 needsRender = true;
 }catch{}
 }

 function updateFocus(sel){
 // Hide celli during derez effect
 if(celliDerezState.active){
 if(celli) celli.visible = false;
 if(arrayaAvatar) arrayaAvatar.setVisible(false);
 focusMarker.visible=false;
 selectionCelli.visible=false;
 return;
 }
 
 if(!sel.arrayId||!sel.focus){
 focusMarker.visible=false;
 selectionCelli.visible=false;
 if(selectionCelli.userData){
 selectionCelli.userData.stretchState = null;
 selectionCelli.userData.lastStretchSignature = null;
 }
 selectionCelli.scale.set(1,1,1);
 if(lastFocusedArrayId){
 const prev = Store.getState().arrays[lastFocusedArrayId];
 clearOcclusion(prev);
 try{ Object.values(prev?.chunks||{}).forEach(ch=> ch._dirty = true); }catch{}
 }
 lastFocusedArrayId = null;
 try{ if(typeof animate==='function' && animate.lastOcclusionState){ animate.lastOcclusionState.signature=''; } }catch{}
 updateAvatars(sel);
 return;
 }
 const arr=Store.getState().arrays[sel.arrayId];
 // Skip if array is being deleted
 if(arr?._deleting){
 focusMarker.visible=false;
 selectionCelli.visible=false;
 return;
 }
 const scale = arrayVoxelScale(arr);
 
 // One-time occlusion clear when focus array changes; do not repeatedly clear
 if(lastFocusedArrayId && lastFocusedArrayId !== sel.arrayId){
 const prev = Store.getState().arrays[lastFocusedArrayId];
 clearOcclusion(prev);
 try{ Object.values(prev?.chunks||{}).forEach(ch=> ch._dirty = true); }catch{}
 }
 lastFocusedArrayId = sel.arrayId;
 
 const camDir=new THREE.Vector3(); camera.getWorldDirection(camDir);
 const ax=Math.abs(camDir.x), ay=Math.abs(camDir.y), az=Math.abs(camDir.z);
 let dims={x:1.06,y:1.06,z:1.06};
 let center={...sel.focus};
 let counts={x:1,y:1,z:1};
 if(sel.range){
 const {x1,x2,y1,y2}=sel.range;
 const zStart = sel.range.z1 ?? sel.range.z ?? sel.focus.z;
 const zEnd = sel.range.z2 ?? sel.range.z ?? sel.focus.z;
 const countX = (x2 - x1 + 1);
 const countY = (y2 - y1 + 1);
 const countZ = (zEnd - zStart + 1);
 counts = {x:countX,y:countY,z:countZ};
 dims={
 x: countX + 0.06,
 y: countY + 0.06,
 z: countZ + 0.06
 };
 center={
 x: x1 + (countX-1)/2,
 y: y1 + (countY-1)/2,
 z: zStart + (countZ-1)/2
 };
 if(countX===1 && ax>=ay && ax>=az) dims.x=0.06;
 if(countY===1 && ay>=ax && ay>=az) dims.y=0.06;
 if(countZ===1 && az>=ax && az>=ay) dims.z=0.06;
 } else {
 if(ax>ay && ax>az) dims.x=0.04;
 else if(ay>az) dims.y=0.04;
 else dims.z=0.04;
 }

 const hasRange = !!sel.range;
 const isMulti = hasRange && (counts.x>1 || counts.y>1 || counts.z>1);
 if(isMulti){
 selectionCelli.visible = true;
 if(focusMarker.geometry){ focusMarker.geometry.dispose?.(); }
 focusMarker.visible = false;
 updateSelectionCelliHighlight(arr, center, counts, scale, sel.faceHint);
 } else {
 selectionCelli.visible = false;
 if(selectionCelli.userData){
 selectionCelli.userData.stretchState = null;
 selectionCelli.userData.lastStretchSignature = null;
 }
 selectionCelli.scale.set(1,1,1);
 const geo=new THREE.BoxGeometry(dims.x*scale,dims.y*scale,dims.z*scale);
 if(focusMarker.geometry) focusMarker.geometry.dispose?.();
 focusMarker.geometry=geo;

 focusMarker.visible=true;
 const p=worldPos(arr,center.x,center.y,center.z);
 focusMarker.position.copy(p);
 }
 updateAvatars(sel);
 // Promote detailed window around selection immediately for performance/fidelity
 try{
 const fc = chunkOf(sel.focus.x, sel.focus.y, sel.focus.z);
 for(let cz=fc.z-WINDOW_CHUNK_RADIUS; cz<=fc.z+WINDOW_CHUNK_RADIUS; cz++)
 for(let cy=fc.y-WINDOW_CHUNK_RADIUS; cy<=fc.y+WINDOW_CHUNK_RADIUS; cy++)
 for(let cx=fc.x-WINDOW_CHUNK_RADIUS; cx<=fc.x+WINDOW_CHUNK_RADIUS; cx++){
 const k = keyChunk(cx,cy,cz); const ch = arr.chunks[k]; if(ch) ch.setLOD?.(1);
 }
 }catch{}
 // Ensure shells are present after focus changes (e.g., after load)
 try{ ensureArrayHighlightShell(arr); }catch{}
 // In-scene d-pad removed
 try {
 window.UI?.inspect(arr, sel.focus);
 // Trigger occlusion recompute on selection change as well
 if(typeof animate==='function' && animate.lastOcclusionState){ animate.lastOcclusionState.signature = ''; }
 } catch(e) {
 console.warn('Inspect failed:', e);
 }
 }
 function centerOnArray(arr){ 
 if(!arr) return; 
 const off=arr.offset||{x:0,y:0,z:0};
 const scale = arrayVoxelScale(arr);
 // Look at center of array, not just the offset
 const centerY = off.y + (arr.size.y * scale) / 2;
 controls.target.set(off.x, centerY, off.z);
 // Position camera above and in front for good viewing angle
 camera.position.set(
 off.x + arr.size.x*scale*1.2,
 centerY + arr.size.y*scale*1.5,
 off.z + arr.size.z*scale*1.8
 );
 }

 function centerOnPlayer(){
 const px = Number.isFinite(cachedPlayerPos.x) ? cachedPlayerPos.x : 0;
 const py = Number.isFinite(cachedPlayerPos.y) ? cachedPlayerPos.y : 2;
 const pz = Number.isFinite(cachedPlayerPos.z) ? cachedPlayerPos.z : 0;
 controls.target.set(px,py,pz);
 camera.position.set(px+6, py+4, pz+8);
 }
 function setPhysicsCamera(mode='free', distance, allowRotation=false){
 const next = {
 mode: (mode || physicsCameraConfig.mode || 'free').toLowerCase(),
 distance: Number.isFinite(distance) ? Math.max(2, distance) : (Number.isFinite(physicsCameraConfig.distance) ? physicsCameraConfig.distance : 10),
 allowRotation: !!allowRotation
 };
 physicsCameraConfig = next;
 if(!camera || !controls) return physicsCameraConfig;
 const target = controls.target ? controls.target.clone() : new THREE.Vector3(0,0,0);
 const dist = physicsCameraConfig.distance || 10;
 const modeKey = physicsCameraConfig.mode;
 if(modeKey === '2d' || modeKey === 'locked' || modeKey === 'side'){
 camera.position.set(target.x + dist, target.y + dist * 0.35, target.z);
 controls.enableRotate = physicsCameraConfig.allowRotation;
 controls.enablePan = true;
 } else if(modeKey === 'iso' || modeKey === 'isometric'){
 const diag = dist / Math.sqrt(3);
 camera.position.set(target.x + diag, target.y + diag, target.z + diag);
 controls.enableRotate = physicsCameraConfig.allowRotation;
 controls.enablePan = true;
 } else {
 camera.position.set(target.x + dist * 0.4, target.y + dist * 0.45, target.z + dist);
 controls.enableRotate = true;
 controls.enablePan = true;
 }
 if(!physicsCameraConfig.allowRotation && controls){
 controls.enableRotate = false;
 }
 controls.update?.();
 needsRender = true;
 return physicsCameraConfig;
 }
 /* ---- Physics: merged colliders per connected run ---- */
 function clearColliders(arr){
 if(!rapierWorld) return;
 arr._colliders = arr._colliders || [];
 arr._rigidBodies = arr._rigidBodies || [];
 arr._joints = arr._joints || [];

 arr._joints.forEach(h=>{ try{ rapierWorld.removeImpulseJoint(h, true); }catch{} });
 arr._joints.length = 0;

 arr._colliders.forEach(h=>{ try{ rapierWorld.removeCollider(h,true); }catch{} });
 arr._colliders.length=0;

 arr._rigidBodies.forEach(h=>{
 try{
 const body = rapierWorld.getRigidBody(h);
 if(body){ rapierWorld.removeRigidBody(body); }
 }catch{}
 });
 arr._rigidBodies.length = 0;
 }

 function debounceColliderRebuild(arr){
 arr._collidersBuilding = true;
 if(colliderRebuildQueue.has(arr.id)) {
 clearTimeout(colliderRebuildQueue.get(arr.id));
 }
 const timeoutId = setTimeout(()=>{
 try { rebuildCollidersForArray(arr); }
 finally { arr._collidersBuilding = false; }
 colliderRebuildQueue.delete(arr.id);
 }, 50);
 colliderRebuildQueue.set(arr.id, timeoutId);
 }
 function rebuildCollidersForArray(arr){
 if(!rapierWorld) return;
 if(!Store.getState().scene.physics) return;
 
 // In physics mode, ALL arrays should have colliders so Celli can walk on them
 // The collision mode determines behavior (exit to edit vs continue physics), not whether colliders exist
 const debugMode = !!Store.getState().scene?.physicsDebugAll;
 const hasPhysicsParam = !!arr?.params?.physics?.enabled;
 const effectiveMode = determineCollisionMode(arr, null, { debugMode });

 console.log(`[PHYSICS] rebuildCollidersForArray: array=${arr.id} "${arr.name}", debug=${debugMode}, hasPhysicsParam=${hasPhysicsParam}, effectiveMode=${effectiveMode}`);
 
 arr._colliders = arr._colliders || [];
 arr._rigidBodies = arr._rigidBodies || [];
 arr._joints = arr._joints || [];

 clearColliders(arr);
 
 // Build colliders for all arrays when in physics mode
 // This allows Celli to land on any array; exitPhysicsOnNonEnabledArray handles the mode switch
 console.log(`[PHYSICS] ? Building colliders for array #${arr.id} "${arr.name}" (mode=${effectiveMode})`);
 
 const scale = arrayVoxelScale(arr);
 const staticOcc = new Map();
 const grouped = new Map(); // id -> {cells:Map,key->cell,pivots:[]}
 let staticSolidCount = 0;
 let groupedSolidCount = 0;

 Object.values(arr.chunks).forEach(ch=>{
 ch.cells.forEach(c=>{
 const meta = c.meta || {};
 const hasValue = (c.value!=='' && c.value!==null && c.value!==undefined);
 const hasFormula = !!c.formula;
 const hasColor = !!meta.color;
 const isSolid = hasValue || hasFormula || hasColor;
 if(!isSolid) return;
 const rawGroup = meta.physicsGroupId;
 const groupId = (rawGroup===undefined||rawGroup===null||rawGroup==='') ? null : String(rawGroup);
 if(groupId){
 let info = grouped.get(groupId);
 if(!info){
 info = { cells:new Map(), pivots:[] };
 grouped.set(groupId, info);
 }
 const key = `${c.x},${c.y},${c.z}`;
 if(!info.cells.has(key)){
 info.cells.set(key, {x:c.x,y:c.y,z:c.z,meta});
 groupedSolidCount++;
 }
 if(meta.physicsPivot){
 info.pivots.push({x:c.x,y:c.y,z:c.z});
 }
 } else {
 staticOcc.set(`${c.x},${c.y},${c.z}`, {x:c.x,y:c.y,z:c.z,meta});
 staticSolidCount++;
 }
 });
 });

 const buildBoxesFromKeys = (keyStrings)=>{
 const keySet = new Set(keyStrings);
 const visited = new Set();
 const boxes = [];
 const keyOf = (x,y,z)=>`${x},${y},${z}`;
 const has = (x,y,z)=> keySet.has(keyOf(x,y,z));
 for(const key of keyStrings){
 if(visited.has(key)) continue;
 const parts = key.split(',').map(n=>+n);
 let [x,y,z] = parts;
 let x2=x;
 while(has(x2+1,y,z) && !visited.has(keyOf(x2+1,y,z))) x2++;
 let y2=y;
 outerY: while(true){
 const ny=y2+1;
 if(!has(x,ny,z)) break;
 for(let xi=x; xi<=x2; xi++){
 if(!has(xi,ny,z) || visited.has(keyOf(xi,ny,z))) break outerY;
 }
 y2=ny;
 }
 let z2=z;
 outerZ: while(true){
 const nz=z2+1;
 for(let yi=y; yi<=y2; yi++){
 for(let xi=x; xi<=x2; xi++){
 if(!has(xi,yi,nz) || visited.has(keyOf(xi,yi,nz))) break outerZ;
 }
 }
 if(!has(x,y,nz)) break;
 z2=nz;
 }
 for(let zz=z; zz<=z2; zz++)
 for(let yy=y; yy<=y2; yy++)
 for(let xx=x; xx<=x2; xx++)
 visited.add(keyOf(xx,yy,zz));
 boxes.push({x1:x,y1:y,z1:z,x2,y2,z2});
 }
 return boxes;
 };

 const staticVisited=new Set();
 const staticHas=(x,y,z)=> staticOcc.has(`${x},${y},${z}`);
 for(let z=0; z<arr.size.z; z++){
 for(let y=0; y<arr.size.y; y++){
 for(let x=0; x<arr.size.x; x++){
 const key=`${x},${y},${z}`;
 if(!staticHas(x,y,z) || staticVisited.has(key)) continue;
 let x2=x; while(staticHas(x2+1,y,z) && !staticVisited.has(`${x2+1},${y},${z}`)) x2++;
 let y2=y;
 outerStaticY: while(true){
 const ny=y2+1;
 for(let xi=x; xi<=x2; xi++){
 if(!staticHas(xi,ny,z) || staticVisited.has(`${xi},${ny},${z}`)) break outerStaticY;
 }
 y2=ny;
 }
 let z2=z;
 outerStaticZ: while(true){
 const nz=z2+1;
 for(let yi=y; yi<=y2; yi++){
 for(let xi=x; xi<=x2; xi++){
 if(!staticHas(xi,yi,nz) || staticVisited.has(`${xi},${yi},${nz}`)) break outerStaticZ;
 }
 }
 z2=nz;
 }
 for(let zz=z; zz<=z2; zz++)
 for(let yy=y; yy<=y2; yy++)
 for(let xx=x; xx<=x2; xx++)
 staticVisited.add(`${xx},${yy},${zz}`);

 const hxCells=(x2-x+1)/2;
 const hyCells=(y2-y+1)/2;
 const hzCells=(z2-z+1)/2;
 const center=worldPos(arr, x+hxCells-.5, y+hyCells-.5, z+hzCells-.5);
 const hx=hxCells*scale, hy=hyCells*scale, hz=hzCells*scale;
 const col=RAPIER.ColliderDesc.cuboid(hx*0.9, hy*0.9, hz*0.9).setTranslation(center.x,center.y,center.z);
 col.setRestitution(0.0);
 col.setFriction(0.7);
 const handle=rapierWorld.createCollider(col);
 arr._colliders.push(handle);
 }
 }
 }

 grouped.forEach((info, groupId)=>{
 if(info.cells.size === 0) return;
 const keyStrings = Array.from(info.cells.keys());
 const boxes = buildBoxesFromKeys(keyStrings);
 if(boxes.length===0) return;

 let minX=Infinity,minY=Infinity,minZ=Infinity,maxX=-Infinity,maxY=-Infinity,maxZ=-Infinity;
 info.cells.forEach(cell=>{
 const center = worldPos(arr, cell.x, cell.y, cell.z);
 minX = Math.min(minX, center.x-0.5);
 minY = Math.min(minY, center.y-0.5);
 minZ = Math.min(minZ, center.z-0.5);
 maxX = Math.max(maxX, center.x+0.5);
 maxY = Math.max(maxY, center.y+0.5);
 maxZ = Math.max(maxZ, center.z+0.5);
 });

 const origin = new THREE.Vector3(
 (minX+maxX)/2,
 (minY+maxY)/2,
 (minZ+maxZ)/2
 );

 let body=null;
 try{
 const rbDesc = RAPIER.RigidBodyDesc.dynamic();
 rbDesc.setTranslation(origin.x, origin.y, origin.z);
 rbDesc.setLinearDamping(0.8);
 rbDesc.setAngularDamping(1.2);
 body = rapierWorld.createRigidBody(rbDesc);
 arr._rigidBodies.push(body.handle);
 }catch(e){
 console.warn('[PHYSICS] Failed to create rigid body for group', groupId, e);
 return;
 }

 boxes.forEach(box=>{
 const hxCells=(box.x2-box.x1+1)/2;
 const hyCells=(box.y2-box.y1+1)/2;
 const hzCells=(box.z2-box.z1+1)/2;
 const center=worldPos(arr, box.x1+hxCells-.5, box.y1+hyCells-.5, box.z1+hzCells-.5);
 const hx=hxCells*scale, hy=hyCells*scale, hz=hzCells*scale;
 const rel = {x:center.x-origin.x, y:center.y-origin.y, z:center.z-origin.z};
 try{
 const desc = RAPIER.ColliderDesc.cuboid(hx*0.9, hy*0.9, hz*0.9).setTranslation(rel.x, rel.y, rel.z);
 desc.setRestitution(0.0);
 desc.setFriction(0.7);
 const handle = rapierWorld.createCollider(desc, body);
 arr._colliders.push(handle);
 }catch(e){
 console.warn('[PHYSICS] Failed to attach collider for group', groupId, e);
 }
 });

 if(staticPhysicsBody && info.pivots.length && RAPIER?.JointData?.revolute){
 info.pivots.forEach(pivot=>{
 try{
 const pivotWorld = worldPos(arr, pivot.x, pivot.y, pivot.z);
 const localAnchor = {
 x: pivotWorld.x - origin.x,
 y: pivotWorld.y - origin.y,
 z: pivotWorld.z - origin.z
 };
 const worldAnchor = {x:pivotWorld.x, y:pivotWorld.y, z:pivotWorld.z};
 const axis = {x:0,y:1,z:0};
 const joint = RAPIER.JointData.revolute(localAnchor, worldAnchor, axis);
 const handle = rapierWorld.createImpulseJoint(joint, body, staticPhysicsBody, true);
 arr._joints.push(handle);
 }catch(e){
 console.warn('[PHYSICS] Failed to create hinge for group', groupId, e);
 }
 });
 }
 });
 
 console.log(`[PHYSICS] Array #${arr.id} colliders built: ${arr._colliders?.length || 0} colliders, ${arr._rigidBodies?.length || 0} bodies, ${arr._joints?.length || 0} joints`);
 }
 // Procedural animation system for timed translations/preview
 const proceduralAnims = [];
 // Per-array timed gamestate (affects all transforms while active)
 function ensureTimedState(arr){
 arr.params = arr.params || {};
 arr.params.timed = arr.params.timed || { ticks:60, reverse:false, reverseTicks:null, repeat:false, t:0, dir:1, previewInArray:false, plan:[], baseOffset:null, baseQuat:null, overlay:null };
 return arr.params.timed;
 }
 function queueTimedOp(arr, anchor, op){
 const t = ensureTimedState(arr);
 const entry = { ...op, anchor:{...anchor} };
 if(entry.anchor && entry.anchor.arrId==null) entry.anchor.arrId = arr?.id;
 t.plan.push(entry);
 try{
 if(arr?.params?.timed?.previewInArray && entry.type === 'array'){
 const toDim=(v)=>{ const n=Number(v); return Number.isFinite(n)? Math.max(1, Math.round(Math.abs(n))) : 1; };
 const dims={
 w: toDim(entry.w ?? entry.width ?? entry.dims?.w ?? entry.params?.w ?? 1),
 h: toDim(entry.h ?? entry.height ?? entry.dims?.h ?? entry.params?.h ?? 1),
 d: toDim(entry.d ?? entry.depth ?? entry.dims?.d ?? entry.params?.d ?? 1)
 };
 const burstSet = arr._previewBursts || (arr._previewBursts = new Set());
 const a = entry.anchor || {};
 const burstKey = `${a.arrId ?? arr.id}:${a.x},${a.y},${a.z}|${dims.w}x${dims.h}x${dims.d}`;
 if(!burstSet.has(burstKey)){
 burstSet.add(burstKey);
 addTimedTranslation(arr, entry.anchor || {x:0,y:0,z:0,arrId:arr?.id}, {
 ticks: Math.max(24, Math.min(360, (t.ticks|0) || 60)),
 repeat: false,
 reverse: false,
 reverseTicks: null,
 type: 'array',
 w: dims.w,
 h: dims.h,
 d: dims.d,
 op: entry.opText || entry.op || '',
 onComplete: ()=>{
 try{ burstSet.delete(burstKey); }
 catch{}
 }
 });
 }
 }
 }catch{}
 }
 function queueArrayPlanFromArray(arr){
 try{
 const hasArrayOp = (ensureTimedState(arr).plan||[]).some(op=>op.type==='array');
 if(hasArrayOp) return true;
 const parseDims=(f)=>{
 const nums = (s)=>{ const n=parseFloat(String(Formula.valOf(s)||s)); return Number.isFinite(n)? Math.max(1, n|0) : 1; };
 const mFill = /ARRAY\(\s*\"fill\"\s*,\s*([^,]+)\s*,\s*([^,\)]+)\s*(?:,\s*([^,\)]+)\s*)?/i.exec(f);
 if(mFill){ return { w:nums(mFill[1]), h:nums(mFill[2]), d:nums(mFill[3]||1) }; }
 const mBasic = /ARRAY\(\s*([^,\)]+)\s*,\s*([^,\)]+)\s*(?:,\s*([^,\)]+)\s*)?\)/i.exec(f);
 if(mBasic){ return { w:nums(mBasic[1]), h:nums(mBasic[2]), d:nums(mBasic[3]||1) }; }
 return null;
 };
 for(const ch of Object.values(arr.chunks||{})){
 for(const c of ch.cells||[]){
 if(!c?.formula) continue;
 const f=String(c.formula||'');
 if(/ARRAY\(/i.test(f)){
 const dims=parseDims(f); if(!dims) continue;
 queueTimedOp(arr, {x:c.x,y:c.y,z:c.z,arrId:arr.id}, { type:'array', ...dims, opText:f });
 return true;
 }
 }
 }
 }catch{}
 return false;
 }
 function buildTimedPlanFromArray(arr){
 try{
 const T = ensureTimedState(arr);
 // reset plan so sequencing/order changes are honored
 try{ if(Array.isArray(T.plan)) T.plan.length = 0; }catch{}
 const reNum = (s)=>{ const n = parseFloat(String(Formula.valOf(s)||s).replace(/[^0-9\-+.]/g,'')); return Number.isFinite(n)? n : 0; };
 const parseDims=(f)=>{
 const mFill = /ARRAY\(\s*"fill"\s*,\s*([^,]+)\s*,\s*([^,\)]+)\s*(?:,\s*([^,\)]+)\s*)?/i.exec(f);
 if(mFill){ return { w:Math.max(1,reNum(mFill[1])|0), h:Math.max(1,reNum(mFill[2])|0), d:Math.max(1,reNum(mFill[3]||1)|0) }; }
 const mBasic = /ARRAY\(\s*([^,\)]+)\s*,\s*([^,\)]+)\s*(?:,\s*([^,\)]+)\s*)?\)/i.exec(f);
 if(mBasic){ return { w:Math.max(1,reNum(mBasic[1])|0), h:Math.max(1,reNum(mBasic[2])|0), d:Math.max(1,reNum(mBasic[3]||1)|0) }; }
 return null;
 };
 for(const ch of Object.values(arr.chunks||{})){
 for(const c of ch.cells||[]){
 const f = String(c?.formula||''); if(!f) continue;
 if(/(?:3D_)?TRANSLATE(?:_ARRAY)?\(/i.test(f) || /TRANSLATE_ARRAY\(/i.test(f)){
 // Robust arg parsing: extract top-level args ignoring nested parens/addresses
 try{
 const start = f.search(/(?:3D_)?TRANSLATE(?:_ARRAY)?\(/i);
 if(start>=0){
 let i=start; while(i<f.length && f[i]!== '(') i++;
 if(i<f.length && f[i]==='('){
 i++; let depth=0, cur=''; const args=[];
 for(; i<f.length; i++){
 const ch=f[i];
 if(ch==='('){ depth++; cur+=ch; continue; }
 if(ch===')'){
 if(depth>0){ depth--; cur+=ch; continue; }
 // end of arg list
 args.push(cur.trim());
 break;
 }
 if(ch===',' && depth===0){ args.push(cur.trim()); cur=''; continue; }
 cur+=ch;
 }
 // take last three as dx,dy,dz
 const n=args.length; if(n>=3){
 const dxv = reNum(args[n-3]);
 const dyv = reNum(args[n-2]);
 const dzv = reNum(args[n-1]);
 queueTimedOp(arr, {x:c.x,y:c.y,z:c.z,arrId:arr.id}, {type:'translate', dx:dxv, dy:dyv, dz:dzv, opText:f});
 }
 }
 }
 }catch{}
 }
 if(/(?:3D_)?ROTATE(?:_ARRAY)?\(/i.test(f)){
 try{
 const start = f.search(/(?:3D_)?ROTATE(?:_ARRAY)?\(/i);
 if(start>=0){
 let i=start; while(i<f.length && f[i]!== '(') i++;
 if(i<f.length && f[i]==='('){
 i++; let depth=0, cur=''; const args=[];
 for(; i<f.length; i++){
 const ch=f[i];
 if(ch==='('){ depth++; cur+=ch; continue; }
 if(ch===')'){
 if(depth>0){ depth--; cur+=ch; continue; }
 args.push(cur.trim());
 break;
 }
 if(ch===',' && depth===0){ args.push(cur.trim()); cur=''; continue; }
 cur+=ch;
 }
 // take last up to three as sx,sy,sz (ignore optional target at front)
 const n=args.length;
 const sx = n>=1 ? reNum(args[n-3] ?? 0) : 0;
 const sy = n>=2 ? reNum(args[n-2] ?? 0) : 0;
 const sz = n>=3 ? reNum(args[n-1] ?? 0) : 0;
 queueTimedOp(arr, {x:c.x,y:c.y,z:c.z,arrId:arr.id}, {type:'rotate', sx, sy, sz, opText:f});
 }
 }
 }catch{}
 }
 // SHIFT(input, dx[, dy[, dz]]) -> treat as translate for previews
 if(/SHIFT\(/i.test(f)){
 const m = /SHIFT\(\s*[^,]+,\s*([^,]+)\s*(?:,\s*([^,]+)\s*)?(?:,\s*([^,]+)\s*)?\)/i.exec(f);
 if(m){ queueTimedOp(arr, {x:c.x,y:c.y,z:c.z,arrId:arr.id}, {type:'translate', dx:reNum(m[1]||0), dy:reNum(m[2]||0), dz:reNum(m[3]||0), opText:f}); }
 }
 if(/TRANSPOSE\(/i.test(f)){
 queueTimedOp(arr, {x:c.x,y:c.y,z:c.z,arrId:arr.id}, {type:'transpose', opText:f});
 }
 if(/ARRAY\(/i.test(f)){
 let dims = null;
 try{
 const emittedMap = Store.getState().emittedByAnchor;
 if(emittedMap && emittedMap.get){
 const ak = aKey({arrId:arr.id, x:c.x, y:c.y, z:c.z});
 const emitted = emittedMap.get(ak);
 if(emitted && emitted.size){
 let maxDx = 0, maxDy = 0, maxDz = 0;
 emitted.forEach(key=>{
 try{
 const [aid, rest] = key.split(':');
 if(+aid !== arr.id) return;
 const [ex,ey,ez] = rest.split(',').map(Number);
 if(!Number.isFinite(ex) || !Number.isFinite(ey) || !Number.isFinite(ez)) return;
 maxDx = Math.max(maxDx, ex - c.x);
 maxDy = Math.max(maxDy, ey - c.y);
 maxDz = Math.max(maxDz, ez - c.z);
 }catch{}
 });
 dims = { w: Math.max(1, (maxDx|0) + 1), h: Math.max(1, (maxDy|0) + 1), d: Math.max(1, (maxDz|0) + 1) };
 }
 }
 }catch{}
 if(!dims){ dims = parseDims(f); }
 if(dims){ queueTimedOp(arr, {x:c.x,y:c.y,z:c.z,arrId:arr.id}, {type:'array', ...dims, opText:f}); }
 }
 }
 }
 return (ensureTimedState(arr).plan||[]).length>0;
 }catch{ return false; }
 }
 function configTimed(arr, cfg){
 const t = ensureTimedState(arr);
 t.ticks = Math.max(1, (cfg?.ticks|0) || 60);
 t.repeat = !!cfg?.repeat; t.reverse = !!cfg?.reverse; t.reverseTicks = (cfg?.reverseTicks==null? null : Math.max(1, cfg.reverseTicks|0));
 t.smooth = !!cfg?.smooth;
 t.t = 0; t.dir = 1;
 // Do not clear plan here; transforms add to plan when preview is ON
 t.baseOffset = { ...(arr.offset||{x:0,y:0,z:0}) };
 try{ t.baseQuat = (arr._frame?.quaternion?.clone?.()) || null; }catch{ t.baseQuat=null; }
 }
 function stopTimed(arr){
 const t=ensureTimedState(arr);
 t.previewInArray=false;
 if(arr && arr._previewBursts){ try{ arr._previewBursts.clear(); }catch{} arr._previewBursts=null; }
 // Restore base transforms
 try{ if(t.baseOffset){ setArrayOffset(arr, {x:t.baseOffset.x,y:t.baseOffset.y,z:t.baseOffset.z}, {interactive:true}); } }catch{}
 try{ if(arr._frame && t.baseQuat){ arr._frame.quaternion.copy(t.baseQuat); } }catch{}
 if(t.overlay){ try{ t.overlay.group.parent?.remove(t.overlay.group); }catch{}; t.overlay=null; }
 // Unmask array content after preview ends
 try{ maskArrayForPreview(arr, false); }catch{}
 }
 // Global 3D timed config (overworld movement)
 function ensureTimed3D(){
 const S=Store.getState();
 const sceneState = S.scene || ({});
 if(!sceneState.timed3D){
 sceneState.timed3D = { configured:false, ticks:60, repeat:false, reverse:false, reverseTicks:null, t:0, dir:1, preview:false, waitStart:0, waitEnd:0, _waitCounter:0, scope:null, hostId:null, activeHostIds:[] };
 Store.setState(s=>({scene:{...s.scene, timed3D: sceneState.timed3D}}));
 } else {
 if(typeof sceneState.timed3D.waitStart!=='number') sceneState.timed3D.waitStart = 0;
 if(typeof sceneState.timed3D.waitEnd!=='number') sceneState.timed3D.waitEnd = 0;
 if(typeof sceneState.timed3D._waitCounter!=='number') sceneState.timed3D._waitCounter = 0;
 if(!sceneState.timed3D.hasOwnProperty('scope')) sceneState.timed3D.scope = null;
 if(!sceneState.timed3D.hasOwnProperty('hostId')) sceneState.timed3D.hostId = null;
 if(!Array.isArray(sceneState.timed3D.activeHostIds)) sceneState.timed3D.activeHostIds = [];
 }
 return sceneState.timed3D;
 }
 // Temporarily hide colored fills/formulas so expansion overlay is visible over white grid
 function maskArrayForPreview(arr, enable){
 try{
 arr._previewMask = arr._previewMask || { layerKeys:[], chunkLODs:[], chunkLOD2:[], chunkGhosts:[], chunkShells:[] };
 if(enable){
 // Hide underlying solids to create empty cell receptacles, but keep shells/ghosts for outline context
 if(Scene.ChunkManager && Scene.ChunkManager.enabled){
 Object.values(arr.chunks||{}).forEach(ch=>{
 // Hide LOD1 solids
 if(ch.meshLOD1 && ch.meshLOD1.visible){ arr._previewMask.chunkLODs.push(ch); ch.meshLOD1.visible=false; }
 // Keep shells for context; hide ghosts and alternate LODs
 if(ch.meshGhost && ch.meshGhost.visible){ arr._previewMask.chunkGhosts.push(ch); ch.meshGhost.visible=false; }
 if(ch.meshLOD2 && ch.meshLOD2.visible){ arr._previewMask.chunkLOD2.push(ch); ch.meshLOD2.visible=false; }
 if(ch.meshShell){
 const wasVisible = !!ch.meshShell.visible;
 arr._previewMask.chunkShells.push({ chunk: ch, wasVisible });
 ch.meshShell.visible = true;
 }
 });
 } else {
 for(let z=0; z<arr.size.z; z++){
 // Hide filled/formula groups only (leave edges as outline)
 ['filled','formula','ghost'].forEach(type=>{
 const key = `${arr.id}:${z}:${type}`;
 const rec = layerMeshes.get(key);
 if(rec && rec.mesh && rec.mesh.visible){ arr._previewMask.layerKeys.push(key); rec.mesh.visible=false; }
 });
 }
 }
 } else {
 // Restore previously hidden meshes
 (arr._previewMask.layerKeys||[]).forEach(key=>{ const rec=layerMeshes.get(key); if(rec && rec.mesh) rec.mesh.visible=true; });
 (arr._previewMask.chunkLODs||[]).forEach(ch=>{ if(ch.meshLOD1) ch.meshLOD1.visible=true; });
 (arr._previewMask.chunkLOD2||[]).forEach(ch=>{ if(ch.meshLOD2) ch.meshLOD2.visible=true; });
 (arr._previewMask.chunkGhosts||[]).forEach(ch=>{ if(ch.meshGhost) ch.meshGhost.visible=true; });
 (arr._previewMask.chunkShells||[]).forEach(rec=>{
 const ch = rec?.chunk || rec;
 if(ch?.meshShell){
 ch.meshShell.visible = (rec && rec.hasOwnProperty('wasVisible')) ? rec.wasVisible : true;
 }
 });
 arr._previewMask = { layerKeys:[], chunkLODs:[], chunkLOD2:[], chunkGhosts:[], chunkShells:[] };
 }
 }catch{}
 }
 try{ Scene.maskArrayForPreview = maskArrayForPreview; }catch{}
 try{ Scene.addToScene = (obj)=>{ try{ if(obj) scene.add(obj); }catch{} }; }catch{}
 try{ Scene.removeFromScene = (obj)=>{ try{ obj?.parent?.remove(obj); }catch{} }; }catch{}
 try{ Scene.ensureTimedState = ensureTimedState; }catch{}
 try{ Scene.queueTimedOp = queueTimedOp; }catch{}
 try{ Scene.queueArrayPlanFromArray = queueArrayPlanFromArray; }catch{}
 try{ Scene.buildTimedPlanFromArray = buildTimedPlanFromArray; }catch{}
 try{ Scene.configTimed = configTimed; }catch{}
 try{ Scene.stopTimed = stopTimed; }catch{}
 try{ Scene.upsertCellLight = upsertCellLight; }catch{}
 try{ Scene.removeCellLight = removeCellLight; }catch{}
 try{ Scene.refreshLightsForArray = refreshLightsForArray; }catch{}
 try{ Scene.ensureTimed3D = ensureTimed3D; }catch{}
 function addTimedTranslation(arr, anchor, cfg){
 const {
 ticks=60,
 repeat=false,
 reverse=false,
 reverseTicks=null,
 op='',
 type=null,
 onComplete=null
 } = cfg||{};
 const group = new THREE.Group();
 group.userData.kind = 'procAnim';
 scene.add(group);

 const GREEN_MAT = new THREE.MeshBasicMaterial({ color: 0x22c55e, transparent: true, opacity: 0.5, depthTest: false, depthWrite: false });
 GREEN_MAT.toneMapped = false;
 const BASE_CELL_SIZE = 0.9;
 const makeCell = (sx=BASE_CELL_SIZE,sy=BASE_CELL_SIZE,sz=BASE_CELL_SIZE)=>{
 const geom = GEO_VOXEL.clone();
 const mat = GREEN_MAT.clone();
 const mesh = new THREE.Mesh(geom, mat);
 mesh.renderOrder = 2100;
 mesh.scale.set(sx/BASE_CELL_SIZE, sy/BASE_CELL_SIZE, sz/BASE_CELL_SIZE);
 return mesh;
 };
 const safeAnchor = {
 x: Number.isFinite(anchor?.x) ? anchor.x : 0,
 y: Number.isFinite(anchor?.y) ? anchor.y : 0,
 z: Number.isFinite(anchor?.z) ? anchor.z : 0,
 arrId: (anchor && anchor.arrId!=null) ? anchor.arrId : (arr?.id)
 };
 const anchorArr = (safeAnchor.arrId!=null && Store.getState().arrays && Store.getState().arrays[safeAnchor.arrId]) || arr;
 const startPos = worldPos(anchorArr, safeAnchor.x, safeAnchor.y, safeAnchor.z);

 // Parse op
 const text = String(op||'').trim();
 const reNum = (s)=>{ const n = parseFloat(String(s).replace(/[^0-9\-+.]/g,'')); return Number.isFinite(n)? n : 0; };
 const mTrans = /(?:3D_)?TRANSLATE(?:_ARRAY)?\(\s*(?:[^,]+\s*,\s*)?([^,]+)\s*,\s*([^,]+)\s*,\s*([^,\)]+)\s*\)/i.exec(text);
 const mRot = /(?:3D_)?ROTATE(?:_ARRAY)?\(\s*([^,)]*)\s*(?:,\s*([^,)]*)\s*)?(?:,\s*([^,)]*)\s*)?\)/i.exec(text);
 const mArrayFill = /ARRAY\(\s*"fill"\s*,\s*([^,]+)\s*,\s*([^,\)]+)\s*(?:,\s*([^,\)]+)\s*)?/i.exec(text);
 const isTranspose = /TRANSPOSE\(/i.test(text);

 const explicitType = type ? String(type).toLowerCase() : '';
 const toDelta = (v)=>{ const n = Number(v); return Number.isFinite(n)? n : 0; };
 const toDim = (v)=>{ const n = Number(v); return Number.isFinite(n)? Math.max(1, Math.round(Math.abs(n))) : 1; };

 let animType = '';
 let params={};
 if(explicitType==='translate'){
 animType='translate';
 params={
 dx: toDelta(cfg?.dx ?? cfg?.params?.dx ?? 0),
 dy: toDelta(cfg?.dy ?? cfg?.params?.dy ?? 0),
 dz: toDelta(cfg?.dz ?? cfg?.params?.dz ?? 0)
 };
 } else if(explicitType==='rotate'){
 animType='rotate';
 params={
 sx: toDelta(cfg?.sx ?? cfg?.params?.sx ?? 0),
 sy: toDelta(cfg?.sy ?? cfg?.params?.sy ?? 0),
 sz: toDelta(cfg?.sz ?? cfg?.params?.sz ?? 0)
 };
 } else if(explicitType==='array'){
 animType='array';
 params={
 w: toDim(cfg?.w ?? cfg?.width ?? cfg?.params?.w ?? 1),
 h: toDim(cfg?.h ?? cfg?.height ?? cfg?.params?.h ?? 1),
 d: toDim(cfg?.d ?? cfg?.depth ?? cfg?.params?.d ?? 1)
 };
 } else if(explicitType==='transpose'){
 animType='transpose';
 params={};
 }

 if(!animType){
 if(mTrans){ animType='translate'; params={ dx: reNum(mTrans[1]), dy: reNum(mTrans[2]), dz: reNum(mTrans[3]) }; }
 else if(mRot){ animType='rotate'; params={ sx: reNum(mRot[1]||0), sy: reNum(mRot[2]||0), sz: reNum(mRot[3]||0) }; }
 else if(mArrayFill){ animType='array'; params={ w: Math.max(1, reNum(mArrayFill[1])|0), h: Math.max(1, reNum(mArrayFill[2])|0), d: Math.max(1, reNum(mArrayFill[3]||1)|0) }; }
 else if(isTranspose){ animType='transpose'; params={}; }
 else { animType='translate'; params={ dx:0, dy:0, dz:0 }; }
 }

 if(animType==='array'){
 params.w = toDim(params.w);
 params.h = toDim(params.h);
 params.d = toDim(params.d);
 }

 // Build visuals per type
 const record = { group, arrId:arr.id, anchor:{...safeAnchor}, ticks:Math.max(1,ticks|0), repeat:!!repeat, reverse:!!reverse, reverseTicks: (reverseTicks==null? null : Math.max(1, reverseTicks|0)), t:0, dir:1, type:animType, params, _built:false, onDone: (typeof onComplete==='function') ? onComplete : null };

 if(animType==='translate'){
 const cube = makeCell(); cube.position.copy(startPos); group.add(cube);
 record.update = (p)=>{
 cube.position.set(startPos.x + params.dx*p, startPos.y + params.dy*p, startPos.z + params.dz*p);
 };
 record.cleanup = ()=>{};
 } else if(animType==='rotate'){
 const cube = makeCell(); cube.position.copy(startPos); group.add(cube);
 const total = { x:(params.sx||0)*Math.PI/2, y:(params.sy||0)*Math.PI/2, z:(params.sz||0)*Math.PI/2 };
 record.update = (p)=>{
 cube.position.copy(startPos);
 cube.rotation.set(total.x*p, total.y*p, total.z*p);
 };
 record.cleanup = ()=>{};
 } else if(animType==='array'){
 const {w,h,d}=params; const cells=[];
 for(let zz=0; zz<d; zz++) for(let yy=0; yy<h; yy++) for(let xx=0; xx<w; xx++){
 const c=makeCell();
 const wp = worldPos(anchorArr, safeAnchor.x+xx, safeAnchor.y+yy, safeAnchor.z+zz);
 c.position.copy(wp); c.visible=false; group.add(c); cells.push({mesh:c, xx, yy, zz});
 }
 record.update = (p)=>{
 // Expand simultaneously in X/Y(/Z) like pistons
 const nx = Math.max(1, Math.floor(1 + (w-1)*p));
 const ny = Math.max(1, Math.floor(1 + (h-1)*p));
 const nz = Math.max(1, Math.floor(1 + (d-1)*p));
 cells.forEach(({mesh,xx,yy,zz})=>{ 
 const vis = (xx < nx && yy < ny && zz < nz); 
 if(mesh.visible!==vis){ mesh.visible = vis; }
 });
 };
 record.cleanup = ()=>{
 try{
 // Merge all visible cubes into a single mesh instance
 const geos = [];
 cells.forEach(({mesh})=>{
 if(!mesh.visible) return;
 const g = mesh.geometry.clone();
 const m4 = new THREE.Matrix4(); m4.compose(mesh.position, mesh.quaternion, mesh.scale);
 g.applyMatrix4(m4);
 geos.push(g);
 });
 if(geos.length){
 const merged = (typeof BufferGeometryUtils!=='undefined' && BufferGeometryUtils.mergeGeometries) ? BufferGeometryUtils.mergeGeometries(geos, false) : null;
 const finalMat = new THREE.MeshBasicMaterial({ color: 0x22c55e, transparent: true, opacity: 0.5, depthTest: false, depthWrite: false });
 finalMat.toneMapped = false;
 const finalMesh = new THREE.Mesh(merged || geos[0], finalMat);
 finalMesh.renderOrder = 2100;
 // Clear children and replace with merged mesh to persist briefly
 while(group.children.length){ const ch = group.children.pop(); ch.geometry?.dispose?.(); ch.material?.dispose?.(); }
 group.add(finalMesh);
 // Auto-remove after a short hold to avoid scene buildup
 setTimeout(()=>{ try{ scene.remove(group); finalMesh.geometry?.dispose?.(); finalMesh.material?.dispose?.(); }catch{} }, 800);
 }
 }catch{}
 };
 } else if(animType==='transpose'){
 // Minimal visualization: swap X/Y progressively for a 2D 1x1 marker moving toward its transposed target
 const marker = makeCell();
 marker.position.copy(startPos);
 group.add(marker);
 record.update = (p)=>{
 const from = startPos;
 // Default XY transpose for 1x1 marker: move diagonally half-cell for a hint
 const to = worldPos(arr, anchor.x, anchor.y, anchor.z).add(new THREE.Vector3(0.5,0.5,0));
 marker.position.lerpVectors(from, to, p);
 };
 record.cleanup = ()=>{};
 }

 proceduralAnims.push(record);
 return record;
 }
 // Expose under Scene for formula impls
 // Expose for external calls post-IIFE; also mirror on window for robustness
 try{ Scene.addTimedTranslation = addTimedTranslation; }catch{}
 try{ window.__addTimedTranslation = addTimedTranslation; }catch{}
 
 // ===== Celli Derez Effect =====
 const derezEffects = [];
 const celliDerezState = { active: false, lastY: null, respawnScheduled: false, respawnTime: 0, respawnData: null };
 let derezParticleGeometry = null;
 
 function triggerCelliDerez(worldPos){
 if(!scene || !THREE || celliDerezState.active) return;
 try{
 const base = new THREE.Group();
 const px = Number.isFinite(worldPos?.x) ? worldPos.x : 0;
 const py = Number.isFinite(worldPos?.y) ? worldPos.y : 0;
 const pz = Number.isFinite(worldPos?.z) ? worldPos.z : 0;
 base.position.set(px, py + 0.4, pz);
 
 // Rotate Celli to face the camera
 if(camera){
 const camPos = camera.position.clone();
 const celliPos = new THREE.Vector3(px, py + 0.4, pz);
 const direction = new THREE.Vector3().subVectors(camPos, celliPos);
 direction.y = 0; // Keep rotation only on horizontal plane
 direction.normalize();
 const angle = Math.atan2(direction.x, direction.z);
 base.rotation.y = angle;
 }

 const layout = [
 { size: [0.36, 0.48, 0.28], offset: [0, -0.05, 0], color: 0xf59e0b },
 { size: [0.32, 0.24, 0.24], offset: [0, 0.32, 0], color: 0xfcd34d },
 { size: [0.08, 0.08, 0.05], offset: [-0.1, 0.36, 0.12], color: 0x1f2937 },
 { size: [0.08, 0.08, 0.05], offset: [0.1, 0.36, 0.12], color: 0x1f2937 },
 { size: [0.14, 0.06, 0.05], offset: [0, 0.26, 0.13], color: 0x1f2937 },
 { size: [0.08, 0.06, 0.05], offset: [-0.16, 0.3, 0.12], color: 0xec4899 },
 { size: [0.08, 0.06, 0.05], offset: [0.16, 0.3, 0.12], color: 0xec4899 },
 { size: [0.36, 0.08, 0.12], offset: [0, 0.5, 0], color: 0xfcd34d },
 { size: [0.16, 0.12, 0.08], offset: [-0.24, 0.5, 0], color: 0xf59e0b },
 { size: [0.16, 0.12, 0.08], offset: [0.24, 0.5, 0], color: 0xf59e0b },
 { size: [0.12, 0.4, 0.12], offset: [-0.26, -0.2, 0], color: 0xf59e0b },
 { size: [0.12, 0.4, 0.12], offset: [0.26, -0.2, 0], color: 0xf59e0b },
 { size: [0.12, 0.24, 0.12], offset: [-0.12, -0.46, 0], color: 0xf59e0b },
 { size: [0.12, 0.24, 0.12], offset: [0.12, -0.46, 0], color: 0xf59e0b }
 ];

 const voxels = [];
 const boundsMin = new THREE.Vector3(Infinity, Infinity, Infinity);
 const boundsMax = new THREE.Vector3(-Infinity, -Infinity, -Infinity);

 layout.forEach(part=>{
 const geo = new THREE.BoxGeometry(part.size[0], part.size[1], part.size[2]);
 const mat = new THREE.MeshStandardMaterial({
 color: part.color,
 emissive: new THREE.Color(part.color),
 emissiveIntensity: 0.2,
 transparent: true,
 opacity: 1,
 depthWrite: false
 });
 mat.toneMapped = false;
 const mesh = new THREE.Mesh(geo, mat);
 mesh.position.set(part.offset[0], part.offset[1], part.offset[2]);
 base.add(mesh);
 voxels.push({ mesh, geometry: geo, material: mat });

 const half = new THREE.Vector3(part.size[0] / 2, part.size[1] / 2, part.size[2] / 2);
 boundsMin.x = Math.min(boundsMin.x, mesh.position.x - half.x);
 boundsMin.y = Math.min(boundsMin.y, mesh.position.y - half.y);
 boundsMin.z = Math.min(boundsMin.z, mesh.position.z - half.z);
 boundsMax.x = Math.max(boundsMax.x, mesh.position.x + half.x);
 boundsMax.y = Math.max(boundsMax.y, mesh.position.y + half.y);
 boundsMax.z = Math.max(boundsMax.z, mesh.position.z + half.z);
 });

 const glow = new THREE.PointLight(0xfcd34d, 0, 3.5, 2);
 glow.position.set(0, 0.45, 0);
 base.add(glow);

 scene.add(base);

 derezEffects.push({
 group: base,
 voxels,
 bounds: { min: boundsMin, max: boundsMax },
 particles: [],
 light: glow,
 stage: 'glow',
 stageTime: 0,
 totalTime: 0
 });

 celliDerezState.active = true;
 if(celli){ celli.visible = false; }
 needsRender = true;
 }catch(e){
 console.warn('Failed to trigger Celli derez effect', e);
 celliDerezState.active = false;
 if(celli){ celli.visible = true; }
 }
 }

 function cleanupDerezEffect(effect){
 try{
 if(effect.particles){
 effect.particles.forEach(p=>{
 if(p?.mesh){
 effect.group?.remove(p.mesh);
 try{ p.material?.dispose?.(); }catch{}
 }
 });
 effect.particles.length = 0;
 }
 if(effect.light){
 try{ effect.group?.remove(effect.light); }catch{}
 }
 if(effect.group){
 try{ scene.remove(effect.group); }catch{}
 }
 }catch(e){
 console.warn('Failed to cleanup derez effect', e);
 }
 effect.voxels = [];
 celliDerezState.active = false;
 
 // Trigger delayed respawn if scheduled
 if(celliDerezState.respawnScheduled && celliDerezState.respawnData){
 const data = celliDerezState.respawnData;
 console.log('[DEREZ] Animation complete, executing delayed respawn');
 if(playerBody){
 playerBody.setTranslation(data.pos, true);
 playerBody.setLinvel({x: 0, y: 0, z: 0}, true);
 cachedPlayerPos.set(data.pos.x, data.pos.y, data.pos.z);
 jumpVelocity = 0;
 landingSquashTime = 0;
 wasGroundedLastFrame = false;
 lastLandKey = null;
 }
 // Re-enable camera controls
 if(controls){
 try{ controls.enabled = true; }catch{}
 }
 celliDerezState.respawnScheduled = false;
 celliDerezState.respawnData = null;
 }
 
 if(celli){ celli.visible = true; }
 needsRender = true;
 }

 function updateDerezEffects(deltaMs){
 if(!derezEffects.length) return;
 const deltaSec = deltaMs / 1000;
 for(let i = derezEffects.length - 1; i >= 0; i--){
 const effect = derezEffects[i];
 if(!effect) continue;
 effect.stageTime += deltaMs;
 effect.totalTime += deltaMs;
 needsRender = true;

 if(effect.stage === 'glow'){
 const glowT = Math.min(1, effect.stageTime / 350);
 const pulse = 0.94 + 0.08 * Math.sin(glowT * Math.PI);
 effect.voxels.forEach(v=>{
 if(!v?.mesh || !v.material) return;
 v.mesh.scale.set(pulse, pulse, pulse);
 v.material.emissiveIntensity = 0.6 + 1.8 * glowT;
 v.material.opacity = 1;
 });
 if(effect.light){
 effect.light.intensity = THREE.MathUtils.lerp(0, 3.2, glowT);
 }
 if(effect.stageTime >= 350){
 effect.stage = 'burst';
 effect.stageTime = 0;
 if(effect.light){ effect.light.intensity = 0; }
 if(!derezParticleGeometry){
 derezParticleGeometry = new THREE.BoxGeometry(0.08, 0.08, 0.08);
 }
 const colorPool = effect.voxels.map(v=>v.material?.color?.getHex?.() ?? 0xf59e0b);
 const particleCount = Math.max(24, colorPool.length * 6);
 const bounds = effect.bounds;
 effect.voxels.forEach(v=>{
 if(!v) return;
 if(v.mesh){
 effect.group?.remove(v.mesh);
 }
 try{ v.geometry?.dispose?.(); }catch{}
 try{ v.material?.dispose?.(); }catch{}
 });
 effect.voxels = [];
 effect.particles = [];
 for(let j = 0; j < particleCount; j++){
 const colorHex = colorPool[j % colorPool.length];
 const material = new THREE.MeshStandardMaterial({
 color: colorHex,
 emissive: new THREE.Color(colorHex),
 emissiveIntensity: 1.3,
 transparent: true,
 opacity: 1,
 depthWrite: false
 });
 material.toneMapped = false;
 const particle = new THREE.Mesh(derezParticleGeometry, material);
 const rx = THREE.MathUtils.lerp(bounds.min.x, bounds.max.x, Math.random());
 const ry = THREE.MathUtils.lerp(bounds.min.y, bounds.max.y, Math.random());
 const rz = THREE.MathUtils.lerp(bounds.min.z, bounds.max.z, Math.random());
 particle.position.set(rx, ry, rz);
 particle.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
 effect.group.add(particle);
 effect.particles.push({
 mesh: particle,
 material,
 velocity: new THREE.Vector3((Math.random()-0.5)*2.2, Math.random()*2.4 + 1.8, (Math.random()-0.5)*2.2),
 spin: new THREE.Vector3((Math.random()-0.5)*4, (Math.random()-0.5)*4, (Math.random()-0.5)*4)
 });
 }
 }
 } else if(effect.stage === 'burst'){
 const fade = Math.min(1, effect.stageTime / 700);
 if(effect.particles){
 effect.particles.forEach(p=>{
 if(!p?.mesh || !p.material) return;
 p.velocity.y -= 6 * deltaSec;
 p.velocity.x *= 0.97;
 p.velocity.z *= 0.97;
 p.mesh.position.addScaledVector(p.velocity, deltaSec);
 p.mesh.rotation.x += p.spin.x * deltaSec;
 p.mesh.rotation.y += p.spin.y * deltaSec;
 p.mesh.rotation.z += p.spin.z * deltaSec;
 const life = Math.max(0, 1 - fade);
 p.material.opacity = life;
 p.material.emissiveIntensity = 1.3 * life;
 p.mesh.scale.setScalar(THREE.MathUtils.lerp(1, 0.6, fade));
 });
 }
 if(effect.stageTime >= 700){
 cleanupDerezEffect(effect);
 derezEffects.splice(i, 1);
 continue;
 }
 }
 }
 }
 // ===== End Derez Effect =====
 
 let lastFrame = 0;
 function animate(time){
 // Limit to 60fps and drive via single chain
 const deltaRaw = lastFrame ? (time - lastFrame) : 16;
 if(deltaRaw < 16){ __rafId = requestAnimationFrame(animate); return; }
 const deltaMs = Math.min(64, deltaRaw);
 lastFrame = time;
 try {
 updateDerezEffects(deltaMs);
 Scene.updateDeleteEffects?.(16);
 if(arrayaAvatar) arrayaAvatar.update(time * 0.001);
 
 // Reset derez lastY when not in physics mode
 const physicsActive = !!Store.getState().scene?.physics;
 if(!physicsActive){
 celliDerezState.lastY = null;
 }
 
 // Update avatars every frame for continuous camera tracking
 const sel = Store.getState().selection;
 if(sel) updateAvatars(sel);

 if(selectionCelli?.visible){
 const data = selectionCelli.userData;
 if(data?.stretchState){
 const state = data.stretchState;
 const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
 const t = Math.min(1, (now - state.start) / Math.max(1, state.duration));
 const eased = easeOutBack(t, 1.35);
 selectionCelli.scale.set(
 THREE.MathUtils.lerp(state.from.x, state.to.x, eased),
 THREE.MathUtils.lerp(state.from.y, state.to.y, eased),
 THREE.MathUtils.lerp(state.from.z, state.to.z, eased)
 );
 if(t >= 1){
 selectionCelli.scale.copy(state.to);
 data.stretchState = null;
 }
 needsRender = true;
 }
 // Continuously update border orientation to face camera
 try{
 if(data?.lastSignature){
 const sel = Store.getState().selection;
 if(sel?.range && sel?.arrayId){
 const arr = Store.getState().arrays[sel.arrayId];
 if(arr && arr._frame){
 // Use facingFromCamera to account for array rotation
 const facing = facingFromCamera(arr._frame);
 const axis = facing.axis;
 const sign = facing.sign;
 const sig = data.lastSignature.split(':');
 const [oldAxis, oldSign] = [sig[sig.length-2], sig[sig.length-1]];
 
 // Always update rotation to continuously face camera
 const axisKeys = ['x','y','z'];
 const axisKey = axisKeys[axis];
 const frameQuat = arr._frame.getWorldQuaternion(new THREE.Quaternion());
 const basisX = new THREE.Vector3(1,0,0).applyQuaternion(frameQuat);
 const basisY = new THREE.Vector3(0,1,0).applyQuaternion(frameQuat);
 const basisZ = new THREE.Vector3(0,0,1).applyQuaternion(frameQuat);
 const bases = [basisX, basisY, basisZ];
 const forward = bases[axis].clone().multiplyScalar(sign).normalize();
 
 const worldRight = new THREE.Vector3();
 const worldUp = new THREE.Vector3();
 if(axis === 0){ // X face
 worldRight.copy(bases[2]); worldUp.copy(bases[1]);
 } else if(axis === 1){ // Y face
 worldRight.copy(bases[0]); worldUp.copy(bases[2]);
 if(sign < 0) worldUp.multiplyScalar(-1);
 } else { // Z face
 worldRight.copy(bases[0]); worldUp.copy(bases[1]);
 if(sign < 0) worldUp.multiplyScalar(-1);
 }
 // Snap rotation to align with viewing axis
 const rotMatrix = new THREE.Matrix4().makeBasis(worldRight, worldUp, forward);
 selectionCelli.rotation.setFromRotationMatrix(rotMatrix);
 needsRender = true;
 
 // If axis changed, rebuild geometry
 if(`${axis}` !== oldAxis || `${sign}` !== oldSign){
 const faceHint = { axis: axisKeys[axis], axisIndex: axis, sign };
 const center = {
 x: parseFloat(sig[1].split(',')[0]),
 y: parseFloat(sig[1].split(',')[1]),
 z: parseFloat(sig[1].split(',')[2])
 };
 const counts = {
 x: parseInt(sig[2].split(',')[0]),
 y: parseInt(sig[2].split(',')[1]),
 z: parseInt(sig[2].split(',')[2])
 };
 const scale = arrayVoxelScale(arr);
 updateSelectionCelliHighlight(arr, center, counts, scale, faceHint);
 }
 }
 }
 }
 }catch(e){ console.warn('[CELLI] Border update in animate failed:', e); }
 }

 // Ensure controls remain enabled when physics is off
 const physicsEnabled = Store.getState().scene.physics;
 if(!physicsEnabled){
 // Force controls to stay enabled when physics is disabled unless orbit is intentionally suspended
 if(controls && orbitSuspendDepth === 0){
 controls.enabled = true;
 controls.enableRotate = true;
 controls.enablePan = true;
 }
 }

 if(rapierWorld && playerBody && physicsEnabled && !physicsStepping){
 physicsStepping = true;
 try {
 // Skip stepping while colliders are rebuilding to avoid Rapier panics
 const anyBuilding = Object.values(Store.getState().arrays).some(a=>a?._collidersBuilding);
 if(anyBuilding){ physicsStepping=false; return; }
 // Update cached player position safely before any operations
 try {
 const translation = playerBody.translation();
 cachedPlayerPos.set(translation.x, translation.y, translation.z);
 } catch(e) {
 // If we can't get position, skip this frame
 physicsStepping = false;
 return;
 }
 
 // --- START: ZIPLINE LOGIC --- 
 if(ziplineState.active){
 const maxSpeed = ziplineState.maxSpeed || 0.06;
 ziplineState.velocity = Math.min(maxSpeed, ziplineState.velocity + (ziplineState.accel || 0.002));
 const delta = ziplineState.velocity / Math.max(0.001, ziplineState.length || 1);
 ziplineState.progress = Math.min(1, ziplineState.progress + delta);
 const newPos = new THREE.Vector3().lerpVectors(ziplineState.start, ziplineState.end, ziplineState.progress);
 if(typeof playerBody.setNextKinematicTranslation === 'function'){
 playerBody.setNextKinematicTranslation(newPos.x, newPos.y - 0.5, newPos.z);
 } else {
 playerBody.setTranslation({x:newPos.x, y:newPos.y - 0.5, z:newPos.z}, true);
 }
 wasGroundedLastFrame = false;

 if(ziplineState.progress >= 1){
 ziplineState.active = false; // Detach at the end
 ziplineState.velocity = 0;
 wasGroundedLastFrame = false;
 }
 } else {
 // Zipline attachment detection using cached position
 if(connections.size > 0) {
 const playerPos = cachedPlayerPos.clone();
 playerPos.y += 0.5; // Adjust for character controller center

 // Zipline attachment detection
 for(const [key, con] of connections.entries()){
 if(!isZiplineConnection(con)) continue;
 const line = new THREE.Line3(con.start, con.end);
 const closestPoint = new THREE.Vector3();
 line.closestPointToPoint(playerPos, true, closestPoint);
 const distance = playerPos.distanceTo(closestPoint);

 if(distance < 0.75){ // Attachment radius
 const start = con.start;
 const end = con.end;
 const lineLength = con.length || line.distance();
 const drop = start.y - end.y;
 if(Math.abs(drop) < 0.05 && lineLength < 0.5) continue; // Skip nearly flat/short lines
 ziplineState.active = true;
 if(drop > 0){
 ziplineState.start = start.clone();
 ziplineState.end = end.clone();
 } else {
 ziplineState.start = end.clone();
 ziplineState.end = start.clone();
 }
 const lineDir = new THREE.Vector3().subVectors(ziplineState.end, ziplineState.start);
 const lengthSq = lineDir.lengthSq();
 if(lengthSq < 1e-6){ ziplineState.active = false; continue; }
 ziplineState.length = lineLength || Math.sqrt(lengthSq);
 ziplineState.direction = lineDir.clone().normalize();
 const slope = Math.max(0, (ziplineState.start.y - ziplineState.end.y) / Math.max(0.001, ziplineState.length));
 ziplineState.accel = 0.0015 + slope * 0.0015;
 ziplineState.maxSpeed = 0.045 + slope * 0.02;
 ziplineState.velocity = Math.max(0.008, ziplineState.accel * 2);
 const playerDir = new THREE.Vector3().subVectors(playerPos, ziplineState.start);
 ziplineState.progress = THREE.MathUtils.clamp(playerDir.dot(lineDir) / lengthSq, 0, 1);
 playerBody.setLinvel({x:0,y:0,z:0}, true);
 wasGroundedLastFrame = false;
 break; // Attach to the first one found
 }
 }
 }
 }
 // --- END: ZIPLINE LOGIC ---

 // Projectile physics and collision detection
 const S = Store.getState();
 if (S.activeProjectiles.length > 0) {
 const newProjectiles = [];
 S.activeProjectiles.forEach(projectile => {
 // Update position
 projectile.pos.add(projectile.vel);
 
 // Check for collision with any array's cells
 let hit = false;
 Object.values(S.arrays).forEach(arr => {
 if(hit) return;
 Object.values(arr.chunks).forEach(chunk => {
 if(hit) return;
 chunk.cells.forEach(cell => {
 if(hit || !cell.value) return;
 const cellPos = worldPos(arr, cell.x, cell.y, cell.z);
 const distance = projectile.pos.distanceTo(cellPos);
 if(distance < 0.6) { // Collision radius
 hit = true;
 const cellKey = aKey({arrId: arr.id, x: cell.x, y: cell.y, z: cell.z});
 const handler = S.collisionHandlers.get(cellKey);
 if(handler) {
 try {
 const tx = Write.start('collision.handler', 'Projectile collision');
 Formula.executeAt({arrId: arr.id, x: cell.x, y: cell.y, z: cell.z}, handler, tx);
 Write.commit(tx);
 } catch(e) {
 console.error('Collision handler error:', e);
 }
 }
 }
 });
 });
 });
 
 // Keep projectile if no collision and still in bounds
 if(!hit && projectile.pos.length() < 100) {
 newProjectiles.push(projectile);
 }
 });
 Store.setState({ activeProjectiles: newProjectiles });
 }

 // Apply jump if requested
 if(!ziplineState.active && input.j){ 
 console.log('[PHYSICS] input.j is 1, calling handleJump()');
 try{ 
 handleJump(); 
 }catch(e){ 
 console.warn('[PHYSICS] Jump input handler error (non-critical):', e); 
 }
 }
 
 // Apply movement forces for dynamic body
 if(!ziplineState.active && (input.f||input.b||input.l||input.r)){
 console.log(`[PHYSICS] Movement input: f=${input.f} b=${input.b} l=${input.l} r=${input.r}`);
 if(playerBody){
 try {
 // Use mouse yaw for direction in mouse look mode, otherwise use camera
 let dir, right;
 if(mouseLookEnabled){
 // Movement relative to mouse look yaw (forward = direction camera looks)
 dir = new THREE.Vector3(Math.sin(mouseYaw), 0, Math.cos(mouseYaw));
 right = new THREE.Vector3(Math.cos(mouseYaw), 0, -Math.sin(mouseYaw));
 } else {
 // Movement relative to camera
 dir = new THREE.Vector3();
 camera.getWorldDirection(dir);
 dir.y = 0;
 dir.normalize();
 right = new THREE.Vector3().crossVectors(dir, new THREE.Vector3(0,1,0)).normalize();
 }

 const avatarCfg = Store.getState().avatarPhysics || {};
 const runMult = Math.max(0.1, Number(avatarCfg.runMultiplier || 1));
 const momentumMode = (avatarCfg.momentumMode|0) === 1 ? 1 : 0;
 const baseForce = momentumMode ? 2.6 : 3.5;
 const force = baseForce * runMult;

 let fx = 0, fz = 0;
 fx += dir.x*(input.f-input.b) + right.x*(input.l-input.r);
 fz += dir.z*(input.f-input.b) + right.z*(input.l-input.r);

 // Apply impulse for responsive control
 const impulse = {x: fx * force, y: 0, z: fz * force};
 playerBody.applyImpulse(impulse, true);

 // Limit horizontal velocity to prevent runaway speed
 const vel = playerBody.linvel();
 const baseMax = momentumMode ? 6.0 : 4.0;
 const maxSpeed = baseMax * runMult;
 const horizSpeed = Math.sqrt(vel.x * vel.x + vel.z * vel.z);
 if(horizSpeed > maxSpeed){
 const scale = maxSpeed / horizSpeed;
 playerBody.setLinvel({x: vel.x * scale, y: vel.y, z: vel.z * scale}, true);
 }
 if(momentumMode === 0){
 playerBody.setLinearDamping(5.0);
 } else {
 playerBody.setLinearDamping(1.5);
 }
 } catch(e) {
 console.warn('Physics movement failed:', e);
 }
 } else {
 console.warn('[PHYSICS] No playerBody for movement');
 }
 }

 // Sync jumpVelocity from physics body for animation
 if(!ziplineState.active){
 try{
 const p = {x: cachedPlayerPos.x, y: cachedPlayerPos.y, z: cachedPlayerPos.z};
 
 // Check if falling off the world
 let respawnPos = physicsSpawnPos ? { ...physicsSpawnPos } : null;
 try{
 const sceneState = Store.getState().scene || {};
 const respawns = sceneState.physicsRespawns || {};
 const selArrId = Store.getState().selection?.arrayId;
 const hostArrId = Number.isFinite(sceneState.timed3D?.hostId) ? Math.trunc(sceneState.timed3D.hostId) : null;
 if(selArrId != null && respawns[selArrId]?.world){
 respawnPos = { ...respawns[selArrId].world };
 } else if(hostArrId != null && respawns[hostArrId]?.world){
 respawnPos = { ...respawns[hostArrId].world };
 }
 }catch{}
 
 // Check for derez effect trigger
 let respawned = false;
 const prevY = celliDerezState.lastY;
 const crossedZero = (prevY != null && prevY > 0 && p.y < 0);
 if(p.y < 0){
 if(crossedZero && !celliDerezState.active && respawnPos){
 console.log('[DEREZ] Triggering derez animation, respawn delayed');
 triggerCelliDerez({ x: p.x, y: 0, z: p.z });
 // Freeze physics during animation
 if(playerBody){
 playerBody.setLinvel({x: 0, y: 0, z: 0}, true);
 playerBody.setAngvel({x: 0, y: 0, z: 0}, true);
 }
 // Pause camera controls during animation
 if(controls){
 try{ controls.enabled = false; }catch{}
 }
 // Schedule respawn after derez animation completes (~1050ms)
 celliDerezState.respawnScheduled = true;
 celliDerezState.respawnData = { pos: respawnPos };
 respawned = true;
 } else if(respawnPos && !celliDerezState.active){
 // Immediate respawn if no derez animation
 console.log('[PHYSICS] Fell off world, respawning at spawn point');
 playerBody.setTranslation(respawnPos, true);
 playerBody.setLinvel({x: 0, y: 0, z: 0}, true);
 cachedPlayerPos.set(respawnPos.x, respawnPos.y, respawnPos.z);
 jumpVelocity = 0;
 landingSquashTime = 0;
 wasGroundedLastFrame = false;
 lastLandKey = null;
 respawned = true;
 }
 }
 if(!respawned){
 celliDerezState.lastY = cachedPlayerPos.y;
 } else {
 celliDerezState.lastY = null;
 }
 
 // Skip physics updates during derez animation
 if(celliDerezState.active && celliDerezState.respawnScheduled){
 // Keep player frozen at derez position
 if(playerBody){
 const derezPos = { x: p.x, y: Math.max(-10, p.y), z: p.z };
 playerBody.setTranslation(derezPos, true);
 playerBody.setLinvel({x: 0, y: 0, z: 0}, true);
 playerBody.setAngvel({x: 0, y: 0, z: 0}, true);
 }
 } else if(!respawned){
 // Sync jumpVelocity with actual physics velocity for animation
 const vel = playerBody.linvel();
 jumpVelocity = vel.y * 2; // Scale for animation sensitivity
 
 // Detect landing for squash animation using raycast
 // Raycast downward to detect ground/platforms
 let nowGrounded = false;
 if(RAPIER && rapierWorld && Number.isFinite(p.x) && Number.isFinite(p.y) && Number.isFinite(p.z)){
 try{
 const ray = new RAPIER.Ray({x: p.x, y: p.y, z: p.z}, {x: 0, y: -1, z: 0});
 const maxToi = 0.6;
 const hit = rapierWorld.castRay(ray, maxToi, true);
 nowGrounded = hit !== null && Math.abs(vel.y) < 1.0;
 }catch(e){
 // Silently ignore raycast errors
 }
 }
 if(!wasGroundedLastFrame && nowGrounded && landingSquashTime === 0){
 landingSquashTime = 1; // Trigger landing squash
 console.log('[PHYSICS] Landing detected!');
 triggerLandHandler();
 }
 if(!nowGrounded){
 lastLandKey = null;
 }
 wasGroundedLastFrame = nowGrounded;
 }
 }catch(e){
 console.warn('Jump sync failed:', e);
 }
 }
 
 // Physics step - must happen BEFORE reading back position
 if(!ziplineState.active){
 try {
 rapierWorld.step();
 
 // Update cached position AFTER physics step
 if(playerBody){
 const translation = playerBody.translation();
 cachedPlayerPos.set(translation.x, translation.y, translation.z);
 applyArrayFloorClamp(playerBody);
 }

 triggerTouchHandlers();

 // Follow camera using updated position
 if(mouseLookEnabled){
 // First-person / third-person platformer camera with mouse look
 const playerPos = new THREE.Vector3(cachedPlayerPos.x, cachedPlayerPos.y + 0.8, cachedPlayerPos.z);
 
 // Camera positioned behind and above player
 const distance = 6.0;
 const height = 2.5;
 
 // Calculate camera position based on mouse yaw/pitch
 const camX = playerPos.x - Math.sin(mouseYaw) * distance * Math.cos(mousePitch);
 const camY = playerPos.y + height + Math.sin(mousePitch) * distance;
 const camZ = playerPos.z - Math.cos(mouseYaw) * distance * Math.cos(mousePitch);
 
 camera.position.set(camX, camY, camZ);
 controls.target.copy(playerPos);
 
 // Disable orbit controls during mouse look
 controls.enableRotate = false;
 controls.enablePan = false;
 } else {
 // Default third-person camera when not in mouse look during physics
 const t = new THREE.Vector3(cachedPlayerPos.x, cachedPlayerPos.y+0.8, cachedPlayerPos.z);
 controls.target.lerp(t, 0.12);
 const desired = new THREE.Vector3(t.x+6, t.y+3.2, t.z+7.5);
 if(Number.isFinite(desired.x) && Number.isFinite(desired.y) && Number.isFinite(desired.z)){
 camera.position.lerp(desired, 0.10);
 } else {
 centerOnPlayer();
 }
 }
 } catch(e) {
 console.warn('Physics step failed:', e);
 // Only disable physics on critical failures, not player movement errors
 const isCriticalError = !e.message?.includes?.('jump') && !e.message?.includes?.('linvel') && !e.message?.includes?.('translation');
 if(isCriticalError){
 console.error('[PHYSICS] CRITICAL ERROR - Disabling physics mode:', e.message);
 Store.setState(s => ({scene: {...s.scene, physics: false}}));
 updatePhysicsStatusChip('Physics: OFF (error)');
 applyDebugPhysicsOverrides(false);
 } else {
 console.log('[PHYSICS] Non-critical error during player movement, continuing physics mode');
 }
 }
 }
 } finally {
 physicsStepping = false;
 }
 }
 // Optimized occlusion: recompute only when camera-facing changes; clear stale occlusion on array/facing change
 if(!animate.lastOcclusionState) animate.lastOcclusionState = {};
 const s=Store.getState().selection;
 const viewMode = (Store.getState().ui && Store.getState().ui.viewMode) || 'standard';
 if(viewMode==='standard' && s.arrayId && s.focus){
 const arr=Store.getState().arrays[s.arrayId];
 updateFacingState(arr);
 computeOcclusion(arr, s.focus);
 const facing = arr._occlusionData?.axis || 'Z';
 const frontLayer = arr._occlusionData?.frontLayer || 0;
 const focusLayer = arr._occlusionData?.focusLayer || 0;

 const signature = `${s.arrayId}:${facing}:${frontLayer}:${focusLayer}`;
 const prevSig = animate.lastOcclusionState.signature;
 if(prevSig && prevSig.split(':')[0] !== String(s.arrayId)){
 // Active array changed: clear occlusion on previous array
 const prevArrId = +prevSig.split(':')[0];
 const prevArr = Store.getState().arrays[prevArrId];
 clearOcclusion(prevArr);
 }
 if(prevSig && prevSig.split(':')[1] !== facing){
 // Facing axis changed: clear old occlusion data before applying new
 clearOcclusion(arr);
 // Also clear overlays/ghosts explicitly for this array
 for(let z=0; z<arr.size.z; z++){
 ['empty','ghost','filled','formula'].forEach(type=>{
 const base=`${arr.id}:${z}:${type}`;
 const rec=layerMeshes.get(base); if(rec){ if(arr._frame) arr._frame.remove(rec.mesh); else scene.remove(rec.mesh); rec.mesh.geometry.dispose(); rec.mesh.material.dispose(); layerMeshes.delete(base); }
 const ekey=`${base}:edges`; const er=layerMeshes.get(ekey); if(er){ if(arr._frame) arr._frame.remove(er.mesh); else scene.remove(er.mesh); er.mesh.geometry.dispose(); er.mesh.material.dispose(); layerMeshes.delete(ekey); }
 });
 }
 }

 if(animate.lastOcclusionState.signature !== signature){
 animate.lastOcclusionState.signature = signature;
 const blockedLayers = new Set();
 // Block layers BETWEEN front and focus, excluding both endpoints
 // Front layer is always visible, focus layer is always visible
 if(facing==='Z'){
 if(frontLayer < focusLayer){ for(let L=frontLayer+1; L<focusLayer; L++) blockedLayers.add(L); }
 else if(frontLayer > focusLayer) { for(let L=frontLayer-1; L>focusLayer; L--) blockedLayers.add(L); }
 } else if(facing==='X'){
 if(frontLayer < focusLayer){ for(let L=frontLayer+1; L<focusLayer; L++) blockedLayers.add(L); }
 else if(frontLayer > focusLayer) { for(let L=frontLayer-1; L>focusLayer; L--) blockedLayers.add(L); }
 } else if(facing==='Y'){
 if(frontLayer < focusLayer){ for(let L=frontLayer+1; L<focusLayer; L++) blockedLayers.add(L); }
 else if(frontLayer > focusLayer) { for(let L=frontLayer-1; L>focusLayer; L--) blockedLayers.add(L); }
 }

 const prevBlocked = animate.lastOcclusionState.blockedLayers || new Set();
 arr._occlusionData = { facing, blockedLayers };
 // Re-render layers. For Z we can do targeted rerender; for X/Y rerender all Z slices (renderLayer filters per-cell)
 if(facing==='Z'){
 for(let z=0; z<arr.size.z; z++){
 const was = prevBlocked.has(z); const now = blockedLayers.has(z);
 if(was !== now) renderLayer(arr, z);
 }
 } else {
 for(let z=0; z<arr.size.z; z++) renderLayer(arr, z);
 }
 animate.lastOcclusionState.blockedLayers = blockedLayers;
 // Apply mask immediately to avoid a one-frame flash
 if (Scene.ChunkManager && Scene.ChunkManager.enabled) {
 try{ applyGhostMaskToChunks(arr); }catch{}
 }
 }
 } else {
 const prevSig = animate.lastOcclusionState.signature;
 if(prevSig){
 const prevArrId = +prevSig.split(':')[0];
 const prevArr = Store.getState().arrays[prevArrId];
 clearOcclusion(prevArr);
 }
 animate.lastOcclusionState.signature = '';
 animate.lastOcclusionState.blockedLayers = new Set();
 }
 // Update per-array timed gamestate animations and apply planned transforms
 try{
 const arrays = Object.values(Store.getState().arrays||{});
 // Global 3D timed progression (overworld)
 const G = (Store.getState().scene||{}).timed3D;
 const scopeState = G?.scope;
 const hostScopeId = (G && Number.isFinite(G.hostId)) ? Math.trunc(G.hostId) : null;
 const scopeSet = new Set(
 Array.isArray(scopeState?.ids)
 ? scopeState.ids
 .map(n => Number(n))
 .filter(n => Number.isFinite(n))
 .map(n => Math.trunc(n))
 : []
 );
 const includeArrayIn3D = (arrId)=>{
 if(!G) return false;
 if(scopeState){
 if(scopeState.mode === 'all') return true;
 if(scopeState.mode === 'limit') return scopeSet.has(arrId);
 if(scopeState.mode === 'host'){
 if(scopeState.ids && scopeState.ids.length){ return scopeState.ids[0] === arrId; }
 if(hostScopeId != null) return hostScopeId === arrId;
 return true;
 }
 }
 if(hostScopeId != null) return hostScopeId === arrId;
 return true;
 };
 let p3D = 0;
 if(G && G.preview){
 // Default configuration if none provided via 3D_TIMED_TRANSLATION
 if(!G.ticks){ G.ticks=240; G.reverseTicks=G.reverseTicks||G.ticks; G.dir=1; G.t=0; }
 if(typeof G._waitCounter!=='number') G._waitCounter = 0;
 const dur3D = (G.dir>0? G.ticks : (G.reverseTicks||G.ticks));
 let r3D = 0;
 // Wait-at-start: hold time; still render p3D=0 so arrays snap to base
 if(G.dir>0 && G.t===0 && (G.waitStart|0) > 0 && G._waitCounter < (G.waitStart|0)){
 G._waitCounter++;
 p3D = 0;
 r3D = 0;
 } else {
 G.t = (G.t + 1);
 r3D = Math.min(1, G.t/Math.max(1,dur3D));
 p3D = (G.dir>0? r3D : (1-r3D));
 }
 if(r3D>=1){
 // Wait-at-end before reversing or looping
 if((G.waitEnd|0) > 0 && G._waitCounter < (G.waitEnd|0)){
 G._waitCounter++;
 __rafId = requestAnimationFrame(animate); return;
 }
 G._waitCounter = 0;
 if(G.reverse && G.dir>0){ G.dir=-1; G.t=0; }
 else if(G.repeat){ G.dir=1; G.t=0; }
 else {
 // Stop preview: restore each array's base state
 G.preview=false;
 try{
 Object.values(Store.getState().arrays||{}).forEach(a=>{
 const T = a?.params?.timed; if(!T) return;
 if(T.baseOffset){ setArrayOffset(a, {x:T.baseOffset.x,y:T.baseOffset.y,z:T.baseOffset.z}, {interactive:true}); }
 if(a._frame && T.baseQuat){ a._frame.quaternion.copy(T.baseQuat); }
 });
 }catch{}
 }
 }
 }
 // Per-array timed: config exists; animate only if previewInArray is enabled
 for(const arr of arrays){
 if(!arr) continue; const T = arr.params && arr.params.timed; if(!T) continue;
 if(T.previewInArray){
 // Ensure timing defaults are sane even if only PREVIEW was called
 if(!T.ticks) { T.ticks = 120; }
 // Ensure baseOffset captured once to compute from starting state
 if(!T.baseOffset){ T.baseOffset = { ...(arr.offset||{x:0,y:0,z:0}) }; }
 // Ensure a timed plan exists; if not, derive from formulas
 if(!T.plan.length){ try{ (Scene.buildTimedPlanFromArray||buildTimedPlanFromArray)(arr); }catch{} }
 
 // Calculate progress for this frame
 const dur = (T.dir>0? T.ticks : (T.reverseTicks||T.ticks));
 // Use T.t+1 for drawing so we reach exactly p=1.0 at the endpoint
 const r = Math.min(1, (T.t + 1) / Math.max(1,dur));
 const p = (T.dir>0 ? r : (1 - r));
 // Green overlays for transformed cells only; ensure overlays draw over everything
 if(T.overlay){
 // Clear previous overlay contents
 while(T.overlay.group.children.length){ const ch=T.overlay.group.children.pop(); ch.geometry?.dispose?.(); ch.material?.dispose?.(); }
 const mat = new THREE.MeshBasicMaterial({ color:0x22c55e, transparent:true, opacity:0.72, depthTest:false, depthWrite:false });
 mat.toneMapped = false;
 const overlayGeo = GEO_VOXEL.clone();
 const parentIsFrame = (T.overlay.group.parent === arr._frame);

 // Group plan by anchor so we emit overlays from each respective anchor
 const keyOf = (a)=> a? `${a.arrId}:${a.x},${a.y},${a.z}` : null;
 const groups = new Map();
 for(const op of T.plan){
 const k = keyOf(op.anchor);
 if(!k) continue;
 if(!groups.has(k)) groups.set(k, { anchor:{...op.anchor}, tx:0,ty:0,tz:0, rsx:0,rsy:0,rsz:0, hasTranspose:false, dims:{w:1,h:1,d:1} });
 const g = groups.get(k);
 if(op.type==='translate'){ g.tx += (op.dx||0); g.ty += (op.dy||0); g.tz += (op.dz||0); }
 else if(op.type==='rotate'){ g.rsx += (op.sx||0); g.rsy += (op.sy||0); g.rsz += (op.sz||0); }
 else if(op.type==='transpose'){ g.hasTranspose = true; }
 else if(op.type==='array'){ g.dims.w = Math.max(1,op.w|0); g.dims.h = Math.max(1,op.h|0); g.dims.d = Math.max(1,op.d|0); }
 }

 const lerp01=(a,b,t)=> a.clone().multiplyScalar(1-t).add(b.clone().multiplyScalar(t));
 const XU = new THREE.Vector3(1,0,0);
 const YU = new THREE.Vector3(0,-1,0);
 const ZU = new THREE.Vector3(0,0,-1);
 for(const g of groups.values()){
 const baseAnchor = g.anchor || {x:0,y:0,z:0,arrId:arr.id};
 const anchorArr = (baseAnchor.arrId!=null && Store.getState().arrays && Store.getState().arrays[baseAnchor.arrId]) || arr;
 let {w,h,d} = g.dims;
 if(w===1 && h===1 && d===1){
 try{
 const nonEmpty=(x,y,z)=>{ const c=Formula.getCell({arrId:anchorArr.id,x,y,z}); return !!(c && (c.formula || (c.value!=='' && c.value!==null && c.value!==undefined))); };
 let ww=1,hh=1,dd=1;
 for(let x=baseAnchor.x+1; x<anchorArr.size.x; x++){ if(!nonEmpty(x,baseAnchor.y,baseAnchor.z)) break; ww++; }
 for(let y=baseAnchor.y+1; y<anchorArr.size.y; y++){ if(!nonEmpty(baseAnchor.x,y,baseAnchor.z)) break; hh++; }
 for(let z=baseAnchor.z+1; z<anchorArr.size.z; z++){ if(!nonEmpty(baseAnchor.x,baseAnchor.y,z)) break; dd++; }
 w=ww; h=hh; d=dd;
 }catch{}
 }

 const anchorL = localPos(anchorArr, baseAnchor.x, baseAnchor.y, baseAnchor.z);
 const leg = (T.dir>0? p : (1-p));
 const angX = (g.rsx*90)*(Math.PI/180) * leg;
 const angY = (g.rsy*90)*(Math.PI/180) * leg;
 const angZ = (g.rsz*90)*(Math.PI/180) * leg;
 // Match actual rotation semantics: world-axis rotations premultiplied (like rotateOnWorldAxis)
 const qxL = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), angX);
 const qyL = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), angY);
 const qzL = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1), angZ);
 const qWorldL = qzL.clone().multiply(qyL).multiply(qxL); // Z * Y * X (world, premultiply order)
 const baseQL = (arr._frame?.quaternion?.clone?.()) || new THREE.Quaternion();
 const qLocal = baseQL.clone().invert().multiply(qWorldL).multiply(baseQL);
 const legShift = (T.dir>0? p : (1-p));
 const shiftL = XU.clone().multiplyScalar((g.tx||0)*legShift)
 .add(YU.clone().multiplyScalar((g.ty||0)*legShift))
 .add(ZU.clone().multiplyScalar((g.tz||0)*legShift));

 const hasTranspose = !!g.hasTranspose;
 const hasDataAt=(ix,iy,iz)=>{
 try{
 const c=Formula.getCell({arrId:anchorArr.id, x:baseAnchor.x+ix, y:baseAnchor.y+iy, z:baseAnchor.z+iz});
 return !!(c && (c.formula || (c.value!=='' && c.value!==null && c.value!==undefined)));
 }catch{ return false; }
 };
 for(let zz=0; zz<d; zz++) for(let yy=0; yy<h; yy++) for(let xx=0; xx<w; xx++){
 if(!hasDataAt(xx,yy,zz)) continue;
 const idx = new THREE.Vector3(xx, yy, zz);
 const swapped = new THREE.Vector3(idx.y, idx.x, idx.z);
 const tIdx = hasTranspose ? lerp01(idx, swapped, p) : idx.clone();
 let offL = XU.clone().multiplyScalar(tIdx.x)
 .add(YU.clone().multiplyScalar(tIdx.y))
 .add(ZU.clone().multiplyScalar(tIdx.z));
 const primaryAxis = (h>1) ? 'y' : ((w>1) ? 'x' : 'z');
 const primaryDim = primaryAxis==='x' ? w : primaryAxis==='y' ? h : d;
 const k = (primaryAxis==='x'? xx : primaryAxis==='y'? yy : zz);
 const pCell = Math.max(0, Math.min(1, p*primaryDim - k));
 offL.applyQuaternion(qLocal);
 offL.add(shiftL);
 offL.multiplyScalar(pCell);
 const posL = anchorL.clone().add(offL);
 let out = posL.clone();
 if(arr !== anchorArr){
 try{
 let worldPos = posL.clone();
 if(anchorArr._frame){ worldPos = posL.clone(); anchorArr._frame.localToWorld(worldPos); }
 else { const offA = anchorArr.offset||{x:0,y:0,z:0}; worldPos.add(new THREE.Vector3(offA.x,offA.y,offA.z)); }
 if(parentIsFrame){
 if(arr._frame){ out = worldPos.clone(); arr._frame.worldToLocal(out); }
 else { const offB = arr.offset||{x:0,y:0,z:0}; out = worldPos.clone().sub(new THREE.Vector3(offB.x,offB.y,offB.z)); }
 } else {
 out = worldPos.clone();
 }
 }catch{}
 } else if(!parentIsFrame){
 if(arr._frame){ out = posL.clone(); arr._frame.localToWorld(out); }
 else { const off = arr.offset||{x:0,y:0,z:0}; out.add(new THREE.Vector3(off.x,off.y,off.z)); }
 }
 const mesh = new THREE.Mesh(overlayGeo, mat.clone()); mesh.renderOrder=9999; mesh.position.copy(out); T.overlay.group.add(mesh);
 }
 }

 // If no plan, place a single placeholder at a reasonable anchor (focus or origin)
 if(T.plan.length===0){
 const sel=Store.getState().selection; const baseAnchor = sel?.arrayId===arr.id && sel.focus ? {...sel.focus, arrId:arr.id} : {x:0,y:0,z:0,arrId:arr.id};
 const anchorL = localPos(arr, baseAnchor.x, baseAnchor.y, baseAnchor.z);
 const mesh = new THREE.Mesh(overlayGeo, mat.clone()); mesh.renderOrder=9999; mesh.position.copy(parentIsFrame? anchorL : (arr._frame? anchorL.clone().applyMatrix4(arr._frame.matrixWorld) : anchorL.clone().add(new THREE.Vector3((arr.offset?.x||0),(arr.offset?.y||0),(arr.offset?.z||0)))) ); T.overlay.group.add(mesh);
 }
 }
 // Increment time AFTER drawing current frame
 T.t = (T.t + 1);
 
 // End/loop logic transition at completion (check if NEXT frame would exceed)
 if(r>=1){
 console.log(`[PREVIEW] Array #${arr.id} completed: r=${r.toFixed(3)}, dir=${T.dir}, reverse=${T.reverse}, repeat=${T.repeat}`);
 T.t = 0; // Reset time for next cycle
 let continueCycle = false;
 if(T.reverse){
 if(T.dir>0){
 console.log(`[PREVIEW] Array #${arr.id} switching to REVERSE direction`);
 T.dir = -1; // Switch to reverse direction
 continueCycle = true;
 } else {
 console.log(`[PREVIEW] Array #${arr.id} reverse complete, repeat=${T.repeat}`);
 T.dir = 1; // Switch back to forward
 continueCycle = !!T.repeat;
 }
 } else if(T.repeat){
 console.log(`[PREVIEW] Array #${arr.id} repeating from start`);
 T.dir = 1; // Keep forward direction
 continueCycle = true;
 }
 console.log(`[PREVIEW] Array #${arr.id} continueCycle=${continueCycle}`);
 // Only stop and cleanup if NOT continuing the cycle
 if(!continueCycle){
 console.log(`[PREVIEW] Array #${arr.id} STOPPING preview`);
 // one-shot: clear overlay after brief hold and unmask content
 T.previewInArray = false;
 setTimeout(()=>{ try{ while(T.overlay.group.children.length){ const ch=T.overlay.group.children.pop(); ch.geometry?.dispose?.(); ch.material?.dispose?.(); } }catch{} }, 120);
 try{ T.overlay.group.parent?.remove(T.overlay.group); }catch{}
 T.overlay=null;
 try{ maskArrayForPreview(arr,false); }catch{}
 }
 }
 }
 // If global 3D preview is enabled, apply full-array motion using the same plan and p3D
 if(G && G.preview && T){
 if(!includeArrayIn3D(arr.id)){
 // Skip global preview application for arrays outside scope
 } else {
 if(!T.plan.length){ buildTimedPlanFromArray(arr); }
 if(!T.plan.length){ continue; }
 if(!T.baseOffset){
 // Reset base to current on first preview frame
 T.baseOffset={...(arr.offset||{x:0,y:0,z:0})};
 try{ if(arr._frame) T.baseQuat = arr._frame.quaternion.clone(); else T.baseQuat = new THREE.Quaternion(); }catch{ T.baseQuat=new THREE.Quaternion(); }
 }
 let tx=0,ty=0,tz=0; let hasTranspose=false; let smooth=false;
 // Stack only translates/transpose from plan; rotation will use applied steps snapshot
 for(const op of T.plan){
 if(op.type==='translate'){ tx+=(op.dx||0); ty+=(op.dy||0); tz+=(op.dz||0); }
 else if(op.type==='transpose'){ hasTranspose=true; }
 }
 // Smooth vs stepped from global or local timed configuration
 smooth = !!((Store.getState().scene?.timed3D?.smooth) || T.smooth);
 // Compute unified translate+rotate around pivot: prefer applied rotation record's pivot
 let pivotLocal = new THREE.Vector3(0,0,0);
 try{
 const S = Store.getState();
 let found=null;
 (S.activeRotations||new Map()).forEach((rec)=>{
 if(found) return;
 if(rec && (rec.targetId===arr.id || (Array.isArray(rec.ids) && rec.ids.includes(arr.id)))) found = rec;
 });
 if(found && found.pivot){ pivotLocal = localPos(arr, found.pivot.x, found.pivot.y, found.pivot.z); }
 else {
 const rotOp = (T.plan||[]).find(op=>op.type==='rotate');
 if(rotOp && rotOp.anchor) pivotLocal = localPos(arr, rotOp.anchor.x, rotOp.anchor.y, rotOp.anchor.z);
 }
 }catch{}
 if(!arr._frame) Scene.renderArray(arr);
 if(!T.baseQuat){ T.baseQuat = arr._frame?.quaternion?.clone?.() || new THREE.Quaternion(); }
 const baseRotPivot = pivotLocal.clone().applyQuaternion(T.baseQuat);
 // Rotation progress and quaternion (snapshot of applied rotation steps; inverse toward pre-transform)
 const steps = arr.rotationSteps || {x:0,y:0,z:0};
 const rotProg = smooth ? (1 - p3D) : (1 - (Math.round(p3D*4)/4));
 const ax = (steps.x|0) * (Math.PI/2) * rotProg;
 const ay = (steps.y|0) * (Math.PI/2) * rotProg;
 const az = (steps.z|0) * (Math.PI/2) * rotProg;
 const qx = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), -ax);
 const qy = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), -ay);
 const qz = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1), -az);
 const dq = qz.clone().multiply(qy).multiply(qx); // Z^- * Y^- * X^- pre-multiply (world order)
 const newQuat = dq.clone().multiply(T.baseQuat);
 const newRotPivot = pivotLocal.clone().applyQuaternion(newQuat);
 // Translation progress (preview un-applies first, then returns to final)
 let dxp=0,dyp=0,dzp=0;
 if(smooth){
 dxp = -tx * (1 - p3D); dyp = -ty * (1 - p3D); dzp = -tz * (1 - p3D);
 } else {
 dxp = tx!==0 ? (Math.round(T.baseOffset.x - tx*(1-p3D)) - T.baseOffset.x) : 0;
 dyp = ty!==0 ? (Math.round(T.baseOffset.y - ty*(1-p3D)) - T.baseOffset.y) : 0;
 dzp = tz!==0 ? (Math.round(T.baseOffset.z - tz*(1-p3D)) - T.baseOffset.z) : 0;
 }
 const disp = new THREE.Vector3(dxp,dyp,dzp);
 const newOffset = new THREE.Vector3(T.baseOffset.x, T.baseOffset.y, T.baseOffset.z)
 .add(disp)
 .add(baseRotPivot)
 .sub(newRotPivot);
 setArrayOffset(arr, {x:newOffset.x, y:newOffset.y, z:newOffset.z}, {interactive:true});
 try{ arr._frame.quaternion.copy(newQuat); }catch{}
 // Minimal transpose preview: slight XY swap tilt to indicate operation
 if(hasTranspose){
 try{
 if(!arr._frame) Scene.renderArray(arr);
 // apply a gentle XY tilt oscillation based on p3D
 const tilt = 0.20 * Math.sin(p3D*Math.PI);
 arr._frame.rotation.set(tilt, arr._frame.rotation.y, -tilt);
 }catch{}
 }
 }
 } else if(G && !G.preview && T){
 // Non-preview: arrays should already be at their one-time end state from 3D_TRANSLATE/3D_ROTATE.
 // Do not re-apply or enforce here to avoid double transforms.
 }
 }
 }catch{}

 // Update procedural animations (overlay previews only)
 try{
 for(let i=proceduralAnims.length-1; i>=0; i--){
 const a = proceduralAnims[i];
 const dur = (a.dir>0? a.ticks : (a.reverseTicks||a.ticks));
 a.t = (a.t + 1);
 const pRaw = Math.min(1, a.t / Math.max(1,dur));
 const p = (a.dir>0 ? pRaw : (1 - pRaw));
 if(a.update) a.update(p);
 if(pRaw >= 1){
 if(a.reverse && a.dir>0){ a.dir = -1; a.t = 0; continue; }
 if(a.repeat){ a.dir = 1; a.t = 0; continue; }
 // Done
 let handled = false;
 try{ if(a.cleanup) handled = !!a.cleanup(); }catch{}
 try{ a.onDone?.(); }catch{}
 if(!handled){ try{ a.group.parent?.remove(a.group); }catch{} }
 proceduralAnims.splice(i,1);
 }
 }
 }catch{}

 controls.update();
 // Optional dynamic chunk LOD
 try{ ChunkManager.update(); }catch{}

 if(FancyGraphics.enabled){
 const dtFancy = FancyGraphics.clock ? FancyGraphics.clock.getDelta() : 0;
 if(FancyGraphics.groups.waveGrid?.material?.uniforms?.time){
 FancyGraphics.groups.waveGrid.material.uniforms.time.value += dtFancy;
 }
 if(FancyGraphics.mirrorUniforms?.time){
 FancyGraphics.mirrorUniforms.time.value += dtFancy;
 }
 if(FancyGraphics.passes.bokeh?.uniforms?.focus){
 FancyGraphics.passes.bokeh.uniforms.focus.value = camera.position.distanceTo(controls.target);
 }
 if(FancyGraphics.passes.outline){
 const highlightObj = selectionCelli.visible ? selectionCelli : (focusMarker.visible ? focusMarker : null);
 if(FancyGraphics.settings.outlineEnabled && highlightObj){
 FancyGraphics.passes.outline.selectedObjects = [highlightObj];
 } else {
 FancyGraphics.passes.outline.selectedObjects = [];
 }
 }
 OceanBackdrop.update(dtFancy);
 } else {
 // Ocean should update even when FancyGraphics is disabled
 const dt = deltaMs / 1000;
 OceanBackdrop.update(dt);
 }

 // Ocean post-processing takes priority when active
 const oceanSettings = OceanBackdrop.getSettings();
 const useOceanPost = oceanSettings && oceanSettings.active;
 
 if(useOceanPost){
 // Use ocean's custom post-processing pipeline
 const didRender = OceanBackdrop.renderWithPost(time * 0.001);
 if(!didRender){
 // Fallback if ocean post fails
 if(FancyGraphics.enabled && FancyGraphics.composer){
 FancyGraphics.composer.render();
 } else {
 renderer.render(scene,camera);
 }
 }
 } else if(FancyGraphics.enabled && FancyGraphics.composer){
 FancyGraphics.composer.render();
 } else {
 renderer.render(scene,camera); // Simple rendering in build mode
 }
 try{ if(!window.__RENDER_READY){ window.__RENDER_READY = true; } }catch{}
 } finally {
 // Always schedule the next frame, even on early returns inside try blocks
 __rafId = requestAnimationFrame(animate);
 }
 }
 let dragState=null;
 
 // Safety: clear drag state on Escape key
 window.addEventListener('keydown', (e)=>{
 if(e.key === 'Escape' && dragState){
 console.log('[PICK] Escape pressed - clearing stuck dragState');
 dragState = null;
 try{ resumeOrbitControls(); }catch{}
 }
 });
 let physicsToggleInFlight = false;
 let orbitSuspendDepth=0;
 let orbitPrevState=null;
 const deletingArrayIds = new Set();
 function normalizeArrayId(id){
 if(id === undefined) return '__undefined__';
 if(id === null) return '__null__';
 return String(id);
 }
 function markArrayDeleting(arrId){
 try{ deletingArrayIds.add(normalizeArrayId(arrId)); }catch{}
 }
 function unmarkArrayDeleting(arrId){
 try{ deletingArrayIds.delete(normalizeArrayId(arrId)); }catch{}
 }
 function isArrayDeleting(arrId){
 try{ return deletingArrayIds.has(normalizeArrayId(arrId)); }catch{ return false; }
 }
 function suspendOrbitControls(){
 if(!controls) return;
 if(orbitSuspendDepth===0){
 orbitPrevState={
 enabled: controls.enabled,
 rotate: controls.enableRotate,
 pan: controls.enablePan,
 zoom: controls.enableZoom
 };
 }
 orbitSuspendDepth++;
 controls.enabled=false;
 controls.enableRotate=false;
 controls.enablePan=false;
 if(typeof controls.enableZoom==='boolean') controls.enableZoom=false;
 }
 function resumeOrbitControls(){
 if(!controls || orbitSuspendDepth===0) return;
 orbitSuspendDepth--;
 if(orbitSuspendDepth===0 && orbitPrevState){
 controls.enabled=orbitPrevState.enabled;
 controls.enableRotate=orbitPrevState.rotate;
 controls.enablePan=orbitPrevState.pan;
 if(typeof orbitPrevState.zoom==='boolean') controls.enableZoom=orbitPrevState.zoom;
 orbitPrevState=null;
 }
 }
 function onPick(e){
 try{
 const rect=renderer.domElement.getBoundingClientRect();
 const mouse=new THREE.Vector2(((e.clientX-rect.left)/rect.width)*2-1, -((e.clientY-rect.top)/rect.height)*2+1);
 const ray=new THREE.Raycaster(); ray.setFromCamera(mouse,camera);
 // Legacy layer meshes (still used for some visuals)
 const layerPickMeshes = [...layerMeshes.values()].map(r=>r.mesh).filter(m=>m.visible && !m.userData.isGhost);
 // Include chunk LOD1 meshes so picking works even when layer meshes are cleared
 const chunkPickMeshes = [];
 const physicsActive = !!Store.getState().scene?.physics;
 const physicsDebugActive = !!Store.getState().scene?.physicsDebugAll;
 try{
 Object.values(Store.getState().arrays).forEach(a=>{
 if(a.hidden) return;
 const hasPhys = !!a.params?.physics?.enabled;
 const shouldFilter = physicsActive && !physicsDebugActive && hasPhys;
 if(shouldFilter){
 console.log(`[RAYCAST] Filtering physics array #${a.id} "${a.name}" from picking`);
 return;
 }
 Object.values(a.chunks||{}).forEach(ch=>{ if(ch?.meshLOD1 && ch.meshLOD1.visible) chunkPickMeshes.push(ch.meshLOD1); });
 });
 }catch{}
 // also pick grab handles
 const grabHandles = Object.values(Store.getState().arrays).flatMap(a=> (a.labels||[]).filter(l=>l.userData?.type==='grab'));
 // Intersect both voxels and grab handles; prefer nearest, but allow grab when tied
 const hits=ray.intersectObjects([...layerPickMeshes, ...chunkPickMeshes, ...grabHandles],false);
 if(!hits.length) return;
 const activeHits = deleteInteractionLock
 ? hits.filter(h=>{
 try{
 const arrId = h?.object?.userData?.arrayId
 ?? h?.object?.userData?.chunk?.arrayId
 ?? h?.object?.userData?.chunk?.array?.id;
 if(arrId == null) return true;
 return !isArrayDeleting(arrId);
 }catch{ return !deleteInteractionLock; }
 })
 : hits;
 if(!activeHits.length) return;
 // Always prefer the grab handle if it is hit at all
 const grabHit = activeHits.find(h => h.object?.userData?.type==='grab');
 let hit = grabHit || activeHits.find(h => (h.object && h.object.isInstancedMesh && typeof h.instanceId === 'number')) || activeHits[0];
 if(hit.object.userData?.type==='grab'){
 // begin array reposition drag
 const arr=Store.getState().arrays[hit.object.userData.arrayId];
 if(!arr) return;
 const startOff={...(arr.offset||{x:0,y:0,z:0})};
 // Determine movement plane from clicked face normal
 const nLocal = hit.face?.normal?.clone()||new THREE.Vector3(0,1,0);
 const nWorld = nLocal.clone().transformDirection(hit.object.matrixWorld).normalize();
 let planeNormal=new THREE.Vector3(0,1,0);
 if(Math.abs(nWorld.x) > Math.abs(nWorld.y) && Math.abs(nWorld.x) > Math.abs(nWorld.z)) planeNormal.set(1,0,0); // YZ plane
 else if(Math.abs(nWorld.y) > Math.abs(nWorld.x) && Math.abs(nWorld.y) > Math.abs(nWorld.z)) planeNormal.set(0,1,0); // XZ plane
 else planeNormal.set(0,0,1); // XY plane
 const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(planeNormal, hit.point);
 const startPoint = new THREE.Vector3(); ray.ray.intersectPlane(plane,startPoint);
 // lock orbit controls during drag
 suspendOrbitControls();
 const onMove=(ev)=>{
 const r=renderer.domElement.getBoundingClientRect();
 const m=new THREE.Vector2(((ev.clientX-r.left)/r.width)*2-1, -((ev.clientY-r.top)/r.height)*2+1);
 const r2=new THREE.Raycaster(); r2.setFromCamera(m,camera);
 const p2=new THREE.Vector3(); r2.ray.intersectPlane(plane,p2);
 // Grid-snapped movement on the two axes of the chosen plane
 const delta = new THREE.Vector3().subVectors(p2,startPoint);
 let nx=startOff.x, ny=startOff.y, nz=startOff.z;
 const snap = (axis, raw)=>{
 const s = axis==='x'?arr.size.x : axis==='y'?arr.size.y : arr.size.z;
 const base = (axis==='z') ? (s/2 - 0.5) : (-(s/2) + 0.5);
 return Math.round(raw + base) - base; // align world centers irrespective of parity
 };
 if(planeNormal.y===1||planeNormal.y===-1){ // XZ plane
 nx = snap('x', startOff.x + delta.x);
 nz = snap('z', startOff.z + delta.z);
 } else if(planeNormal.x===1||planeNormal.x===-1){ // YZ plane
 ny = snap('y', startOff.y + delta.y);
 nz = snap('z', startOff.z + delta.z);
 } else { // XY plane
 nx = snap('x', startOff.x + delta.x);
 ny = snap('y', startOff.y + delta.y);
 }
 // Interactive drag: apply immediately and skip wobble to keep 60fps
 setArrayOffset(arr, {x:nx, y:ny, z:nz}, {interactive:true});
 };
 const onUp=()=>{
 resumeOrbitControls();
 window.removeEventListener('pointermove',onMove);
 window.removeEventListener('pointerup',onUp);
 try{
 const cur=arr.offset||{x:0,y:0,z:0};
 const dir={ dx: Math.sign((cur.x||0)-(startOff.x||0)), dy: Math.sign((cur.y||0)-(startOff.y||0)), dz: Math.sign((cur.z||0)-(startOff.z||0)) };
 settleAfterDrag(arr, dir);
 }catch{}
 try{
 arr.params = arr.params || {};
 const timed = arr.params.timed;
 if(timed){
 timed.baseOffset = { ...(arr.offset||{x:0,y:0,z:0}) };
 if(arr._frame && arr._frame.quaternion){
 try{ timed.baseQuat = arr._frame.quaternion.clone(); }catch{}
 }
 }
 }catch{}
 };
 window.addEventListener('pointermove',onMove); window.addEventListener('pointerup',onUp);
 return;
 }
 // nav pad interactions removed (HUD only)
 let arrayId = hit.object.userData.arrayId;
 let arr = Store.getState().arrays[arrayId];
 if(!arr) return;
 let cell = null; let z = null;
 if(hit.object.userData && hit.object.userData.chunk){
 const chunk = hit.object.userData.chunk;
 cell = chunk?.index2cell?.[hit.instanceId];
 z = cell?.z;
 } else {
 const z0 = hit.object.userData.z, type0 = hit.object.userData.type;
 const rec = layerMeshes.get(`${arrayId}:${z0}:${type0}`);
 cell = rec?.index2cell?.[hit.instanceId];
 z = z0;
 }
 
 // If the picked cell has an ONCLICK action, execute it immediately (3D)
 if(!cell) return;
 
 // Check if this cell is ghosted - cells in focus layer are always selectable
 try{
 const sel = Store.getState().selection;
 const isFocusArray = (sel?.arrayId === arr.id);
 const occ = arr._occlusionData || {};
 const blocked = occ.blockedLayers || new Set();
 const axis = occ.axis || occ.facing || 'Z';
 const cellLayer = axis==='X' ? cell.x : axis==='Y' ? cell.y : cell.z;
 const focusLayer = isFocusArray && sel.focus ? (axis==='X' ? sel.focus.x : axis==='Y' ? sel.focus.y : sel.focus.z) : null;
 const isFocusLayer = (focusLayer === cellLayer);
 
 // Reject if blocked AND not on focus layer (focus layer is always solid/selectable)
 if(blocked.has(cellLayer) && !isFocusLayer){
 console.log(`[PICK] Rejected ghosted cell at (${cell.x},${cell.y},${cell.z}) - layer ${cellLayer} blocked, not focus layer`);
 return;
 }
 }catch(e){ console.warn('[PICK] Ghost check failed', e); }
 
 let decodedAction = '';
 let hasAction = false;
 try{
 const c2d = UI.getCell(arr.id, {x:cell.x,y:cell.y,z:cell.z});
 let actionRaw = String(getMetaAction(c2d?.meta, 'on_click')||'').trim();
 if(actionRaw){
 hasAction = true;
 if(actionRaw.startsWith('B64:')){
 try{ actionRaw = atob(actionRaw.slice(4)); }catch{}
 } else {
 const colon=actionRaw.indexOf(':');
 if(colon>0 && /^\d+$/.test(actionRaw.slice(0,colon))){
 const enc=actionRaw.slice(colon+1);
 try{ actionRaw = atob(enc); }catch{}
 }
 }
 decodedAction = actionRaw.startsWith('=') ? actionRaw : `=${actionRaw}`;
 }
 }catch{}

 if(!(hasAction && formulaHasChime(decodedAction))){ playCellClick(); }
 try{
 if(hasAction && decodedAction){
 const tx = Write.start('onclick.3d','Click action (3D)');
 Formula.runOnceAt({arrId:arr.id,x:cell.x,y:cell.y,z:cell.z}, decodedAction, tx);
 Write.commit(tx);
 // Visual feedback pulse
 try{ pulseCell(arr, cell, z); }catch{}
 // Do not return; continue to also select the cell
 }
 }catch{}

 // If in physics mode, check collision mode for this specific cell
 // physicsActive and physicsDebugActive already declared above
 const hasPhysics = !!arr?.params?.physics?.enabled;
 const cellCollisionMode = determineCollisionMode(arr, cell, { debugMode: physicsDebugActive });
 console.log(`[PHYSICS CLICK] Array #${arr.id} "${arr.name}" cell (${cell.x},${cell.y},${cell.z}): physicsActive=${physicsActive}, debugActive=${physicsDebugActive}, hasPhysics=${hasPhysics}, cellMode=${cellCollisionMode}`);
 
 // Exit physics mode if clicking an 'edit' mode cell (empty or non-formula cells)
 if(physicsActive && !physicsDebugActive && cellCollisionMode === 'edit'){
 console.log(`[PHYSICS] Clicked edit-mode cell in array #${arr.id} "${arr.name}" - exiting physics mode`);
 try{
 Actions.setSelection(arr.id, {x:cell.x, y:cell.y, z:cell.z}, null, '3d');
 centerOnArray(arr);
 const res = togglePhysicsMode();
 if(res && typeof res.catch === 'function'){
 res.catch(err=>console.warn('[PHYSICS] Exit on click failed', err));
 }
 }catch(e){ console.warn('[PHYSICS] Exit on click threw', e); }
 return;
 }

 // Start drag-select in 3D with playful click feedback (scale pulse)
 const maxLayer = Math.max(0, (arr.size?.z||1) - 1);
 let startLayer = Number.isFinite(cell?.z) ? Math.round(cell.z) : 0;
 let viewLocked = false;
 try{
 const uiState = Store.getState().ui || {};
 if(uiState.lastInteraction === '2d' && Number.isFinite(uiState.zLayer)){
 startLayer = Math.round(uiState.zLayer);
 viewLocked = true;
 }
 }catch{}
 if(!Number.isFinite(startLayer)) startLayer = 0;
 startLayer = Math.min(maxLayer, Math.max(0, startLayer));
 dragState={arrayId:arr.id, start:{x:cell.x,y:cell.y,z:startLayer}, lockZ:startLayer, viewLock:viewLocked};
 Actions.setSelection(arr.id, {x:cell.x,y:cell.y,z:startLayer}, null, '3d');
 try{ pulseCell(arr, cell, z); }catch{}
 // Freeze orbit while dragging
 suspendOrbitControls();
 
 const onMove=(ev)=>{
 if(!dragState) return;
 const r=renderer.domElement.getBoundingClientRect();
 const m=new THREE.Vector2(((ev.clientX-r.left)/r.width)*2-1, -((ev.clientY-r.top)/r.height)*2+1);
 ray.setFromCamera(m,camera);
 // Filter out ghost meshes explicitly during drag selection
 const solidLayerMeshes = [...layerMeshes.values()].map(r=>r.mesh).filter(m=>m.visible && !m.userData.isGhost && m.userData.type!=='ghost');
 const solidChunkMeshes = [];
 try{
 Object.values(Store.getState().arrays).forEach(a=>{
 if(a.hidden) return;
 Object.values(a.chunks||{}).forEach(ch=>{ 
 // Only include solid meshes, not ghost meshes
 if(ch?.meshLOD1 && ch.meshLOD1.visible && !ch?.meshGhost) solidChunkMeshes.push(ch.meshLOD1);
 else if(ch?.meshLOD1 && ch.meshLOD1.visible) solidChunkMeshes.push(ch.meshLOD1);
 });
 });
 }catch{}
 const h=ray.intersectObjects([...solidLayerMeshes, ...solidChunkMeshes], false);
 if(h.length){
 const hh=h[0];
 let aid = hh.object.userData.arrayId;
 let cel = null; let z = null;
 if(hh.object.userData && hh.object.userData.chunk){
 const ch = hh.object.userData.chunk;
 aid = ch?.array?.id || aid;
 cel = ch?.index2cell?.[hh.instanceId];
 z = cel?.z;
 } else {
 const z0 = hh.object.userData.z; const type0 = hh.object.userData.type;
 // Skip ghost type meshes
 if(type0 && String(type0).includes('ghost')) return;
 const rec2 = layerMeshes.get(`${aid}:${z0}:${type0}`);
 cel = rec2?.index2cell?.[hh.instanceId];
 z = z0;
 }
 if(!cel) return;
 
 // Check if this cell is ghosted - skip UNLESS it's on the focus layer
 try{
 const arrForCheck = Store.getState().arrays[aid];
 if(arrForCheck){
 const sel = Store.getState().selection;
 const isFocusArray = (sel?.arrayId === aid);
 const occ = arrForCheck._occlusionData || {};
 const blocked = occ.blockedLayers || new Set();
 const axis = occ.axis || occ.facing || 'Z';
 const cellLayer = axis==='X' ? cel.x : axis==='Y' ? cel.y : cel.z;
 const focusLayer = isFocusArray && sel.focus ? (axis==='X' ? sel.focus.x : axis==='Y' ? sel.focus.y : sel.focus.z) : null;
 const isFocusLayer = (focusLayer === cellLayer);
 
 // Skip if blocked AND not focus layer
 if(blocked.has(cellLayer) && !isFocusLayer){
 return;
 }
 }
 }catch{}
 
 if(aid===dragState.arrayId){
 const arrForDrag = Store.getState().arrays[dragState.arrayId];
 const maxLayer = Math.max(0, (arrForDrag?.size?.z||1) - 1);
 const clampLayer = (val)=>Math.min(maxLayer, Math.max(0, Math.round(val)));
 // Use the actual cell z coordinate for natural selection
 let targetLayer = Number.isFinite(cel?.z) ? clampLayer(cel.z) : dragState.lockZ;
 if(dragState.viewLock){
 let applied = false;
 applied = cel?.z != null && Number.isFinite(cel.z);
 if(!applied && z != null && Number.isFinite(z)){
 targetLayer = clampLayer(z);
 applied = true;
 }
 if(!applied){
 try{
 const viewLayer = Store.getState().ui?.zLayer;
 if(Number.isFinite(viewLayer)){
 targetLayer = clampLayer(viewLayer);
 applied = true;
 }
 }catch{}
 }
 if(!applied && Number.isFinite(dragState.start?.z)){
 targetLayer = clampLayer(dragState.start.z);
 }
 }
 if(!Number.isFinite(targetLayer)) targetLayer = clampLayer(dragState.start?.z ?? 0);
 Actions.setSelectionRange(dragState.arrayId, dragState.start, {x:cel.x,y:cel.y,z:targetLayer}, '3d');
 // Cache the last valid drag position to maintain it during gaps
 dragState.lastValid = {x:cel.x, y:cel.y, z:targetLayer};
 }
 } else if(dragState.lastValid){
 // No hit (hovering gap) - maintain last valid position to prevent layer jumping
 Actions.setSelectionRange(dragState.arrayId, dragState.start, dragState.lastValid, '3d');
 }
 };
 const onUp=()=>{ dragState=null; resumeOrbitControls(); window.removeEventListener('pointermove',onMove); window.removeEventListener('pointerup',onUp); };
 window.addEventListener('pointermove',onMove); window.addEventListener('pointerup',onUp);
 }catch(err){
 console.error('[PICK] Click selection failed:', err);
 // Ensure orbit controls are restored if there was an error
 try{ resumeOrbitControls(); }catch{}
 }
 }
 function setArrayOffset(arr, next, opts){
 opts = opts||{}; const fast = !!opts.interactive; const skipDock = !!opts._skipDock; const skipConn = !!opts._skipConnections;
 // Snap to global phase
 const arrScale = arrayVoxelScale(arr);
 const snapAxis=(axis,val,sz)=>{
 const phases = Store.getState().gridPhase || {};
 const phase = phases[axis] || 0;
 const half = (sz * arrScale) / 2;
 const base = axis==='z' ? (half - arrScale/2) : (-(half) + arrScale/2);
 if(arrScale === 0) return val;
 return Math.round((val - base - phase)/arrScale) * arrScale + base + phase;
 };
 const snapped={ x:snapAxis('x',next.x,arr.size.x), y:snapAxis('y',next.y,arr.size.y), z:snapAxis('z',next.z,arr.size.z) };
 const curOff = arr.offset||{x:0,y:0,z:0};
 // If no actual snap delta, do nothing (prevents wobble without movement)
 if(Math.abs(snapped.x-curOff.x)+Math.abs(snapped.y-curOff.y)+Math.abs(snapped.z-curOff.z) < 1e-6){ return; }
 // Smooth transition toward snapped position
 if(!arr._frame){ arr.offset=snapped; }
 else if(fast){
 // Immediate update for interactive drags
 arr.offset={x:snapped.x,y:snapped.y,z:snapped.z};
 arr._frame.position.set(snapped.x,snapped.y,snapped.z);
 } else {
 const cur=arr.offset||{x:0,y:0,z:0};
 const lerp=(a,b,t)=> a+(b-a)*t;
 const steps=6; let i=0;
 const tick=()=>{
 i++; const t=i/steps; const ease=t*(2-t); // smoothstep-ish
 const x=lerp(cur.x,snapped.x,ease), y=lerp(cur.y,snapped.y,ease), z=lerp(cur.z,snapped.z,ease);
 arr.offset={x,y,z}; if(arr._frame) arr._frame.position.set(x,y,z);
 if(i<steps){ requestAnimationFrame(tick); }
 else {
 // Only wobble once per snap (guard quick repeats)
 const now = performance.now();
 if(!fast && (!arr._lastSnap || now - arr._lastSnap > 120)){
 arr._lastSnap = now;
 applyWiggle(arr, {angle:0.11, lift:0.06, hold:170});
 }
 }
 };
 requestAnimationFrame(tick);
 }

 // Non-destructive: update transforms only
 if(arr._frame) arr._frame.position.set(arr.offset.x,arr.offset.y,arr.offset.z);

 // Apply dock propagation after offset change (use actual delta of snapped vs previous)
 try{
 const S=Store.getState();
 const group = [...(S.dockGroups||new Map()).values()].find(g=>g.members.includes(arr.id));
 if(group && !skipDock){
 const orderIndex = group.members.indexOf(arr.id);
 const ids = (group.mode==='parent') ? group.members.slice(orderIndex+1) : group.members.filter(id=>id!==arr.id);
 const dx=snapped.x-curOff.x, dy=snapped.y-curOff.y, dz=snapped.z-curOff.z;
 ids.forEach(id=>{
 const a=S.arrays[id]; if(!a) return; const off=a.offset||{x:0,y:0,z:0};
 const nx=off.x+dx, ny=off.y+dy, nz=off.z+dz;
 // Reuse same transform pipeline to ensure identical math, but skip further propagation and heavy work
 setArrayOffset(a,{x:nx,y:ny,z:nz},{interactive:true, _skipDock:true, _skipConnections:true});
 });
 }
 }catch{}

 // Update matrices for existing layer meshes by recomputing instance transforms
 if(!arr._frame && !fast){
 Object.entries(Store.getState().arrays).forEach(()=>{}); // no-op ensure state accessible
 for(let z=0; z<arr.size.z; z++){
 ['empty','ghost','filled','formula','edges'].forEach(type=>{
 const rec=layerMeshes.get(`${arr.id}:${z}:${type}`);
 if(!rec) return;
 const {mesh,index2cell}=rec; if(!mesh||!index2cell) return;
 for(let i=0;i<index2cell.length;i++){
 const c=index2cell[i]; if(!c) continue;
 temp.position.copy(localPos(arr,c.x,c.y,c.z));
 temp.updateMatrix();
 mesh.setMatrixAt(i,temp.matrix);
 }
 mesh.instanceMatrix.needsUpdate=true;
 });
 }
 }

 // Update value sprites - parent them to frame and use local coords
 if(!(arr._frame && fast)){
 valueSprites.forEach((sprite,key)=>{
 if(!key.startsWith(`${arr.id}:`)) return;
 const [_,coords]=key.split(':'); const [x,y,z]=coords.split(',').map(Number);
 // Parent sprite to frame if not already
 if(sprite.parent !== arr._frame && arr._frame){
 sprite.parent?.remove(sprite);
 arr._frame.add(sprite);
 // Recompute position in local space
 const pos=localPos(arr,x,y,z); 
 sprite.position.set(pos.x,pos.y,pos.z+0.55);
 }
 });
 }

 // Update connection lines that involve this array
 if(!skipConn){
 connections.forEach((connection, key) => {
 const { ref1, ref2, visual } = connection;
 if(ref1.arrId === arr.id || ref2.arrId === arr.id) {
 const arr1 = Store.getState().arrays[ref1.arrId];
 const arr2 = Store.getState().arrays[ref2.arrId];
 if(!arr1 || !arr2 || !visual) return;

 const start = worldPos(arr1, ref1.x, ref1.y, ref1.z);
 const end = worldPos(arr2, ref2.x, ref2.y, ref2.z);
 const dir = new THREE.Vector3().subVectors(end, start);
 const length = Math.max(0.0001, dir.length());
 const center = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
 const dirNorm = length > 0.0001 ? dir.clone().divideScalar(length) : new THREE.Vector3(1,0,0);

 connection.start = start;
 connection.end = end;
 connection.length = length;

 if(connection.mode === 'platform' || connection.mode === 'grind'){
 const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(1,0,0), dirNorm.clone());
 visual.position.copy(center);
 visual.quaternion.copy(quat);
 visual.scale.set(length, 1, 1);
 } else if(connection.mode === 'zipline'){
 const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,1,0), dirNorm.clone());
 visual.position.copy(center);
 visual.quaternion.copy(quat);
 visual.scale.set(1, length, 1);
 } else {
 try{
 visual.geometry.dispose();
 }catch{}
 visual.geometry = new THREE.BufferGeometry().setFromPoints([start, end]);
 }
 }
 });
 }
 // Update occlusion/highlight meshes for this array
 highlights.forEach((highlight, key) => {
 if(key.startsWith(`${arr.id}:`)) {
 const [_, coords] = key.split(':');
 const [x, y, z] = coords.split(',').map(Number);
 if(highlight.mesh) {
 highlight.mesh.position.copy(worldPos(arr, x, y, z));
 }
 }
 });

 try{ refreshLightsForArray(arr.id); }catch{}

 // Skip rebuilding axes during movement to prevent stamping
 // buildAxes(arr); // Commented out - only rebuild when array structure changes
 const s=Store.getState().selection; if(s.arrayId===arr.id) updateFocus(s);
 // Enforce visibility after transforms (hidden arrays remain hidden)
 try{ syncVisibility(arr); }catch{}

 // Interactions: run overlap/gobble checks shortly after move settles
 try{ setTimeout(()=>{ InteractionManager?.runChecks?.(arr); }, 120); }catch{}
 }

 // Apply post-snap wiggle/tilt to give momentum feeling
 function applyWiggle(arr, {angle=0.11, lift=0.06, hold=170}={}){
 try{
 const scale = arrayVoxelScale(arr);
 for(let zz=0; zz<arr.size.z; zz++){
 const recs=[];
 ['empty','ghost','filled','formula'].forEach(type=>{ const r=layerMeshes.get(`${arr.id}:${zz}:${type}`); if(r) recs.push(r); });
 layerMeshes.forEach((val,key)=>{ if(val?.mesh?.userData?.type==='edges' && val.mesh?.userData?.arrayId===arr.id && val.mesh?.userData?.z===zz) recs.push(val); });
 recs.forEach(rec=>{
 if(!rec||!rec.mesh||!rec.index2cell) return;
 for(let k=0;k<rec.index2cell.length;k++){
 const c=rec.index2cell[k]; if(!c) continue;
 const basePos = localPos(arr,c.x,c.y,c.z);
 temp.position.copy(basePos).add(new THREE.Vector3(0,lift*scale,0));
 temp.rotation.set(angle, 0, -angle);
 temp.scale.set(scale,scale,scale);
 temp.updateMatrix();
 rec.mesh.setMatrixAt(k,temp.matrix);
 }
 rec.mesh.instanceMatrix.needsUpdate=true;
 setTimeout(()=>{
 for(let k=0;k<rec.index2cell.length;k++){
 const c=rec.index2cell[k]; if(!c) continue;
 temp.position.copy(localPos(arr,c.x,c.y,c.z));
 temp.rotation.set(0,0,0); temp.scale.set(scale,scale,scale); temp.updateMatrix();
 rec.mesh.setMatrixAt(k,temp.matrix);
 }
 rec.mesh.instanceMatrix.needsUpdate=true;
 }, hold);
 });
 }
 }catch{}
 }

 // After releasing drag, add a subtle overshoot settle and wiggle
 function settleAfterDrag(arr, dir){
 if(!arr?._frame) return;
 const target = new THREE.Vector3(arr.offset?.x||0, arr.offset?.y||0, arr.offset?.z||0);
 const start = arr._frame.position.clone();
 const dv = new THREE.Vector3(dir.dx||0, dir.dy||0, dir.dz||0);
 const len = dv.length();
 let ov = new THREE.Vector3();
 if(len>1e-6) ov.copy(dv.clone().normalize().multiplyScalar(0.18));
 const overshoot = target.clone().add(ov);
 let phase=0; let t0; const dur1=110, dur2=100;
 const ease=(t)=> t*(2-t);
 const step=(ts)=>{
 if(t0==null) t0=ts;
 const dt=ts-t0;
 if(phase===0){
 const u = Math.min(1, dt/dur1);
 const e = ease(u);
 const p = start.clone().lerp(overshoot, e);
 arr._frame.position.copy(p);
 if(u<1){ requestAnimationFrame(step); }
 else { phase=1; t0=undefined; requestAnimationFrame(step); }
 } else {
 const u = Math.min(1, (dt)/dur2);
 const e = ease(u);
 const p = overshoot.clone().lerp(target, e);
 arr._frame.position.copy(p);
 if(u<1){ requestAnimationFrame(step); }
 else { arr._frame.position.copy(target); applyWiggle(arr); }
 }
 };
 requestAnimationFrame(step);
 }
 function getArrayOffset(arr){ const o=arr?.offset||{x:0,y:0,z:0}; return {x:o.x,y:o.y,z:o.z}; }

 function setGridVisible(v){
 FancyGraphics.base.gridVisible = v;
 grid.visible = FancyGraphics.enabled ? false : v;
 }
 function setAxesVisible(v){ axesHelper.visible=v; Object.values(Store.getState().arrays).forEach(a=>{ a.labels?.forEach(s=>s.visible=v); }); }

 // keyboard for physics locomotion
 const input={f:0,b:0,l:0,r:0,j:0};
 const platformerKeyState={left:false,right:false,up:false,down:false,jump:false};
 const PLATFORMER_KEY_BINDINGS={
 arrowleft:'left',
 a:'left',
 arrowright:'right',
 d:'right',
 arrowup:'up',
 w:'up',
 arrowdown:'down',
 s:'down',
 ' ':'jump',
 space:'jump',
 spacebar:'jump'
 };
 function normalizePlatformerKey(key){
 if(!key) return '';
 if(key === ' ') return 'space';
 return key.length===1 ? key.toLowerCase() : key.toLowerCase();
 }
 function isPlatformerActive(global){
 try{
 const g = global || Store.getState().globalState;
 if(!g) return false;
 if(typeof g.has === 'function'){
 // Check active flag first - if it exists and is false, platformer is NOT active
 if(g.has('platformer.active')) return !!g.get('platformer.active');
 // Only fall back to pos check if active flag doesn't exist
 // This prevents false positives from stale pos data
 return false;
 }
 const active = g.get ? g.get('platformer.active') : null;
 if(active != null) return !!active;
 return false;
 }catch{return false;}
 }
 function refreshPlatformerInput(global){
 try{
 const g = global || Store.getState().globalState;
 if(!g || typeof g.set !== 'function' || typeof g.get !== 'function') return;
 const jumpActive = !!platformerKeyState.jump;
 let dir='none';
 if(platformerKeyState.left) dir='left';
 else if(platformerKeyState.right) dir='right';
 else if(platformerKeyState.up) dir='up';
 else if(platformerKeyState.down) dir='down';
 if(g.get('platformer.input') !== dir){
 g.set('platformer.input', dir);
 }
 if(typeof g.set === 'function'){
 const prevJump = typeof g.get === 'function' ? g.get('platformer.jump') : undefined;
 const nextJump = jumpActive ? 1 : 0;
 if(prevJump !== nextJump){
 g.set('platformer.jump', nextJump);
 }
 }
 }catch(e){ console.warn('Platformer input sync failed', e); }
 }
 function resetPhysicsInputState(){
 input.f = 0; input.b = 0; input.l = 0; input.r = 0; input.j = 0;
 platformerKeyState.left = false;
 platformerKeyState.right = false;
 platformerKeyState.up = false;
 platformerKeyState.down = false;
 platformerKeyState.jump = false;
 try{ refreshPlatformerInput(Store.getState().globalState); }catch{}
 }
 function handlePlatformerKey(key,isDown){
 const dir = PLATFORMER_KEY_BINDINGS[normalizePlatformerKey(key)];
 if(!dir) return false;
 platformerKeyState[dir] = !!isDown;
 return true;
 }

 let mouseLookEnabled = false;
 let mouseYaw = 0; // Camera rotation around Y axis
 let mousePitch = 0; // Camera rotation around X axis
 
 // Mouse look for physics mode (3D platformer controls)
 window.addEventListener('mousemove',(e)=>{
 if(!mouseLookEnabled || !Store.getState().scene.physics) return;
 
 const sensitivity = 0.002;
 mouseYaw -= e.movementX * sensitivity;
 mousePitch -= e.movementY * sensitivity;
 mousePitch = Math.max(-Math.PI/3, Math.min(Math.PI/3, mousePitch)); // Limit pitch
 }, true);
 
 // Click to enable mouse look in physics mode
 window.addEventListener('click',(e)=>{
 if(Store.getState().scene.physics && !mouseLookEnabled){
 e.preventDefault();
 mouseLookEnabled = true;
 document.body.requestPointerLock?.();
 console.log('[PHYSICS] Mouse look enabled - move mouse to look around, ESC to exit');
 }
 }, true);
 
 // Detect pointer lock changes
 document.addEventListener('pointerlockchange',()=>{
 if(!document.pointerLockElement){
 mouseLookEnabled = false;
 console.log('[PHYSICS] Mouse look disabled');
 }
 });
 
 // Toggle arrow mapping via middle mouse button (Mouse 3)
 window.addEventListener('mousedown',(e)=>{
 if(e.button===1){
 e.preventDefault();
 Store.setState(s=>({scene:{...s.scene, arrowMapDepth: !s.scene.arrowMapDepth}}));
 const flag = Store.getState().scene.arrowMapDepth;
 showToast(flag? 'Arrows: Depth' : 'Arrows: Height');
 }
 }, true);
 window.addEventListener('keydown',(e)=>{
 // Debug: Log ALL keys at the very start
 if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)){
 console.log(`[DEBUG] Arrow key captured at handler start: ${e.key}`);
 }
 
 const s=Store.getState();
 const activeEl = document.activeElement;
 const activeTag = (activeEl?.tagName||'').toUpperCase();
 const direct = document.getElementById('directEdit');
 const directOpen = !!(direct && direct.style.display==='block');
 const directFocused = !!(direct && activeEl === direct);
 const baseTypingElement = (activeTag==='INPUT' || activeTag==='TEXTAREA');
 const typingElement = baseTypingElement && !(directFocused && !directOpen);
 const platformerMode = isPlatformerActive(s.globalState);
 
 if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)){
 console.log(`[DEBUG] platformerMode=${platformerMode}, typingElement=${typingElement}, directOpen=${directOpen}`);
 }
 
 const physicsCapturing = !!Scene.isPhysicsInputCaptured?.();
 const physicsActive = !!s.scene.physics;
 if(physicsCapturing){
 const typing = typingElement || directOpen;
 if(!typing && ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' ','Spacebar','w','a','s','d','W','A','S','D','Escape'].includes(e.key)){
 if(handlePlatformerKey(e.key, true)) refreshPlatformerInput(s.globalState);
 e.preventDefault();
 if(physicsActive){
 if(e.key==='ArrowUp'||e.key==='w'||e.key==='W') input.f=1;
 if(e.key==='ArrowDown'||e.key==='s'||e.key==='S') input.b=1;
 if(e.key==='ArrowLeft'||e.key==='a'||e.key==='A') input.l=1;
 if(e.key==='ArrowRight'||e.key==='d'||e.key==='D') input.r=1;
 if(e.key===' '||e.key==='Spacebar'){
 console.log('[PHYSICS] Spacebar pressed - setting input.j=1, physicsActive=true, physicsCapturing=true');
 input.j=1;
 }
 if(e.key==='Escape'){
 console.log('[PHYSICS] ESC pressed - exiting physics mode');
 Actions.togglePhysics();
 return;
 }
 }
 return;
 }
 }

 if(!physicsCapturing && physicsActive){
 const typing = typingElement || directOpen;
 if(!typing && ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' ','Spacebar','w','a','s','d','W','A','S','D','Escape'].includes(e.key)){
 if(handlePlatformerKey(e.key, true)) refreshPlatformerInput(s.globalState);
 e.preventDefault();
 if(e.key==='ArrowUp'||e.key==='w'||e.key==='W') input.f=1;
 if(e.key==='ArrowDown'||e.key==='s'||e.key==='S') input.b=1;
 if(e.key==='ArrowLeft'||e.key==='a'||e.key==='A') input.l=1;
 if(e.key==='ArrowRight'||e.key==='d'||e.key==='D') input.r=1;
 if(e.key===' '||e.key==='Spacebar'){
 console.log('[PHYSICS] Spacebar pressed - setting input.j=1, physicsActive=true, physicsCapturing=false');
 input.j=1;
 }
 if(e.key==='Escape'){
 console.log('[PHYSICS] ESC pressed - exiting physics mode');
 Actions.togglePhysics();
 return;
 }
 return;
 }
 }

 if(platformerMode && !typingElement && !directOpen){
 if(handlePlatformerKey(e.key, true)){
 console.log(`[PLATFORMER] Key ${e.key} handled by platformer (mode active), returning early`);
 refreshPlatformerInput(s.globalState);
 e.preventDefault();
 return;
 }
 } else if(!platformerMode && ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)){
 // Don't let platformer handler intercept arrow keys when platformer is NOT active
 console.log(`[ARROW] Arrow key ${e.key} NOT handled by platformer (mode inactive), continuing to navigation`);
 }

 // Universal input: Enter always opens the editor. If no selection, select a default cell first.
 if(e.key==='Enter' && !platformerMode && !typingElement && !directOpen){
 e.preventDefault();
 const state=Store.getState();
 const sel=state.selection;
 if(sel?.focus){ UI.openEditor(); return; }
 const fallbackArr = state.arrays[1] || Object.values(state.arrays)[0];
 if(fallbackArr){
 Actions.setSelection(fallbackArr.id,{x:0,y:0,z:0}, null, '2d');
 setTimeout(()=> UI.openEditor(), 0);
 }
 return;
 }
 // Undo/Redo shortcuts
 if(e.ctrlKey || e.metaKey){
 if(e.key==='z'){
 if(e.shiftKey){ e.preventDefault(); Actions.redoData(); return; }
 else { e.preventDefault(); Actions.undoData(); return; }
 }
 if(e.key==='y'){ e.preventDefault(); Actions.redoData(); return; }
 }
 if(e.altKey && e.key==='z'){
 if(e.shiftKey){ e.preventDefault(); Actions.redoUI(); return; }
 else { e.preventDefault(); Actions.undoUI(); return; }
 }

 // Backspace: clear cell and enter input mode
 if(e.key==='Backspace' && !platformerMode && !typingElement && !directOpen && s.selection?.focus){
 e.preventDefault();
 const sel = s.selection;
 const anchor = {arrId: sel.arrayId, ...sel.focus};
 Actions.setCell(sel.arrayId, sel.focus, '', null, true);
 // Do not open the inline editor on backspace; just clear
 return;
 }

 // Arrow keys for cell navigation when not in physics/platformer mode
 const isArrowKey = ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key);
 
 if(isArrowKey){
 console.log(`[ARROW] ? Reached arrow key check for: ${e.key}`);
 console.log(`[ARROW] Conditions: platformerMode=${platformerMode}, physicsActive=${physicsActive}, typingElement=${typingElement}, directOpen=${directOpen}`);
 
 // If conditions are blocking, show why
 if(platformerMode || physicsActive || typingElement || directOpen){
 console.warn(`[ARROW] ?? Arrow keys blocked by: ${platformerMode?'platformerMode ':''}${physicsActive?'physicsActive ':''}${typingElement?'typingElement ':''}${directOpen?'directOpen':''}`);
 }
 }
 
 if(isArrowKey && !platformerMode && !physicsActive && !typingElement && !directOpen){
 console.log(`[ARROW] ? Entering arrow key handler for ${e.key}`);
 // Ensure we have a selection; default to Array 1 A1a if none
 let sel=s.selection;
 if(!sel.focus){
 const fallbackArr = s.arrays[1] || Object.values(s.arrays)[0];
 if(fallbackArr){ Actions.setSelection(fallbackArr.id, {x:0,y:0,z:0}, null, '2d'); sel = Store.getState().selection; }
 }
 if(!sel.focus) return; const arr=s.arrays[sel.arrayId]; if(!arr) return;
 if(e.shiftKey){
 // Shift+Arrows: extend selection range
 if(e.key==='ArrowUp') Actions.moveSelection(0,1,0);
 if(e.key==='ArrowDown') Actions.moveSelection(0,-1,0);
 if(e.key==='ArrowLeft') Actions.moveSelection(1,0,0);
 if(e.key==='ArrowRight') Actions.moveSelection(-1,0,0);
 e.preventDefault(); 
 UI.scrollSheetToSelection?.();
 } else {
 // View-relative movement calculation based on camera facing
 let dx = 0, dy = 0, dz = 0;
 const depthMode = !!Store.getState().scene.arrowMapDepth;
 
 // Get the camera-relative facing direction - compute it fresh each time
 let facing = { axis: 2, sign: 1 }; // default: looking at Z+ face
 try {
 if (arr._frame && Scene.facingFromCamera) {
 facing = Scene.facingFromCamera(arr._frame);
 console.log(`[ARROW] Facing: axis=${facing.axis} (${['X','Y','Z'][facing.axis]}), sign=${facing.sign}, depthMode=${depthMode}`);
 }
 } catch (err) {
 console.warn('[ARROW] Failed to get facing:', err);
 }
 
 const axis = facing.axis; // 0=X, 1=Y, 2=Z
 const sign = facing.sign; // 1=positive, -1=negative
 
 // Map arrow keys to movement based on which face we're looking at
 if (axis === 2) { // Looking at Z face (front/back)
 if (e.key === 'ArrowUp') {
 if (depthMode) dz = -sign;
 else dy = -1; // Fixed: inverted up/down
 } else if (e.key === 'ArrowDown') {
 if (depthMode) dz = sign;
 else dy = 1; // Fixed: inverted up/down
 } else if (e.key === 'ArrowLeft') {
 dx = -sign; // Fixed: inverted left/right for front/back view
 } else if (e.key === 'ArrowRight') {
 dx = sign; // Fixed: inverted left/right for front/back view
 }
 } else if (axis === 0) { // Looking at X face (left/right side)
 if (e.key === 'ArrowUp') {
 if (depthMode) dx = -sign;
 else dy = -1; // Fixed: inverted up/down
 } else if (e.key === 'ArrowDown') {
 if (depthMode) dx = sign;
 else dy = 1; // Fixed: inverted up/down
 } else if (e.key === 'ArrowLeft') {
 dz = -sign;
 } else if (e.key === 'ArrowRight') {
 dz = sign;
 }
 } else { // axis === 1, Looking at Y face (top/bottom)
 if (e.key === 'ArrowUp') {
 if (depthMode) dy = -sign;
 else dz = -1;
 } else if (e.key === 'ArrowDown') {
 if (depthMode) dy = sign;
 else dz = 1;
 } else if (e.key === 'ArrowLeft') {
 dx = -sign; // Fixed: inverted left/right for top/bottom view
 } else if (e.key === 'ArrowRight') {
 dx = sign; // Fixed: inverted left/right for top/bottom view
 }
 }
 
 console.log(`[ARROW] Key=${e.key}, axis=${axis}, sign=${sign} -> dx=${dx}, dy=${dy}, dz=${dz}`);
 
 if(dx || dy || dz){
 e.preventDefault();
 let {x,y,z} = sel.focus;
 x = Math.max(0, Math.min(arr.size.x-1, x + dx));
 y = Math.max(0, Math.min(arr.size.y-1, y + dy));
 z = Math.max(0, Math.min(arr.size.z-1, z + dz));
 Actions.setSelection(sel.arrayId,{x,y,z});
 UI.scrollSheetToSelection?.();
 }
 }
 return;
 }


 // Realtime typing: printable char when a cell is focused starts editor with that char
 if(s.selection?.focus && e.key.length===1 && !e.ctrlKey && !e.metaKey && !e.altKey && !platformerMode && !typingElement && !directOpen){
 e.preventDefault(); UI.startDirectTyping(e.key); return;
 }
 }, true);
 window.addEventListener('keyup',(e)=>{
 const s=Store.getState();
 const platformerMode = isPlatformerActive(s.globalState);
 const platformerHandled = handlePlatformerKey(e.key, false);
 if(platformerHandled && platformerMode){
 refreshPlatformerInput(s.globalState);
 }
 if(s.scene.physics){
 if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' ','Spacebar','w','a','s','d','W','A','S','D'].includes(e.key)){
 e.preventDefault();
 if(e.key==='ArrowUp'||e.key==='w'||e.key==='W') input.f=0;
 if(e.key==='ArrowDown'||e.key==='s'||e.key==='S') input.b=0;
 if(e.key==='ArrowLeft'||e.key==='a'||e.key==='A') input.l=0;
 if(e.key==='ArrowRight'||e.key==='d'||e.key==='D') input.r=0;
 if(e.key===' '||e.key==='Spacebar') input.j=0; 
 return;
 }
 }
 if(platformerHandled && platformerMode){
 e.preventDefault();
 return;
 }
 if(e.key==='ArrowUp'||e.key==='w'||e.key==='W') input.f=0; if(e.key==='ArrowDown'||e.key==='s'||e.key==='S') input.b=0; if(e.key==='ArrowLeft'||e.key==='a'||e.key==='A') input.l=0; if(e.key==='ArrowRight'||e.key==='d'||e.key==='D') input.r=0; if(e.key===' '||e.key==='Spacebar') input.j=0; 
 },true);
 const highlights=new Map(); // anchor -> {mode, mesh}
 function setHighlightMode(arr,anchor,config){
 const k=aKey(anchor); 
 const {mode='dynamic',scope='cell',style='wireframe'} = typeof config==='string'?{mode:config}:config;
 highlights.set(k,{mode,scope,style,anchor});
 
 // create highlight mesh based on scope and style
 let geo, mat;
 if(scope==='face'){
 geo = new THREE.PlaneGeometry(1.1,1.1); 
 mat = new THREE.MeshBasicMaterial({color:0x22c55e,transparent:true,opacity:0.6,side:THREE.DoubleSide});
 } else {
 geo = new THREE.BoxGeometry(1.1,1.1,1.1);
 mat = new THREE.MeshBasicMaterial({
 color:0x22c55e,transparent:true,opacity:0.3,
 wireframe:style==='wireframe'
 });
 }
 const mesh=new THREE.Mesh(geo,mat); 
 mesh.position.copy(worldPos(arr,anchor.x,anchor.y,anchor.z)); 
 scene.add(mesh);
 highlights.get(k).mesh=mesh;
 }

 function setCameraLock(arr,config){
 arr.cameraLock = config;
 // Implementation would constrain orbit controls based on axis/angle
 }
 function setViewMode(arr,config){
 arr.viewMode = config;
 // Implementation would switch between perspective/orthographic cameras
 }

 // Lightweight AvatarFactory for modular characters
 const AvatarFactory = {
 createCelli(THREE){
 const MAT_BODY = new THREE.MeshToonMaterial({ color: 0xf59e0b });
 const MAT_DARK = new THREE.MeshToonMaterial({ color: 0x1f2937 }); // Gray-800 (darker gray, matching Border Celli)
 const MAT_BLUSH = new THREE.MeshToonMaterial({ color: 0xec4899 });
 const MAT_WING = new THREE.MeshToonMaterial({ color: 0xf59e0b, side: THREE.DoubleSide });

 function addOutline(child, scale=1.06){
 const outlineMat = new THREE.MeshBasicMaterial({ color: MAT_DARK.color.getHex(), side: THREE.BackSide });
 const outline = new THREE.Mesh(child.geometry, outlineMat);
 outline.scale.setScalar(scale);
 outline.userData.isAvatarOutline = true;
 outline.renderOrder = 10499;
 child.add(outline);
 return outline;
 }

 function triWing(width=0.22, height=0.16, depth=0.02){
 const shape = new THREE.Shape();
 shape.moveTo(width/2, 0);
 shape.lineTo(-width/2, height/2);
 shape.lineTo(-width/2, -height/2);
 shape.lineTo(width/2, 0);
 const geo = new THREE.ExtrudeGeometry(shape, { depth, bevelEnabled:false });
 geo.center();
 geo.computeVertexNormals();
 return geo;
 }

 const root = new THREE.Group();
 root.scale.setScalar(0.40);

 const BW=.8, BH=.8, BD=.3;
 const bodyGroup = new THREE.Group();
 const body = new THREE.Mesh(new RoundedBoxGeometry(BW, BH, BD, 6, .12), MAT_BODY);
 addOutline(body);
 bodyGroup.add(body);
 bodyGroup.position.y = BH/2;

 const faceGroup = new THREE.Group();
 const faceZ = BD/2 + 0.01;
 const eyeGeo = new THREE.SphereGeometry(0.05, 16, 12);
 const eyeL = new THREE.Mesh(eyeGeo, MAT_DARK); addOutline(eyeL); eyeL.scale.set(1, 2, .25); eyeL.position.set(-.12,.13,faceZ);
 const eyeR = new THREE.Mesh(eyeGeo, MAT_DARK); addOutline(eyeR); eyeR.scale.set(1, 2, .25); eyeR.position.set(.12,.13,faceZ);
 const blushGeo = new THREE.SphereGeometry(0.05, 16, 12);
 const cheekL = new THREE.Mesh(blushGeo, MAT_BLUSH); addOutline(cheekL); cheekL.scale.set(1.2,1,.2); cheekL.position.set(-.25,-.08,faceZ);
 const cheekR = new THREE.Mesh(blushGeo, MAT_BLUSH); addOutline(cheekR); cheekR.scale.set(1.2,1,.2); cheekR.position.set(.25,-.08,faceZ);
 const smileShape = new THREE.Shape();
 smileShape.moveTo(-0.12, -0.06);
 smileShape.quadraticCurveTo(0, -0.25, 0.12, -0.06);
 smileShape.quadraticCurveTo(0, -0.20, -0.12, -0.06);
 const smile = new THREE.Mesh(new THREE.ShapeGeometry(smileShape), MAT_DARK); addOutline(smile);
 smile.position.z = faceZ;
 faceGroup.add(eyeL, eyeR, cheekL, cheekR, smile);
 bodyGroup.add(faceGroup);

 const bowGroup = new THREE.Group();
 // Updated bow geometry to match Border Celli - larger, more rounded wings
 const wingL = new THREE.Mesh(triWing(), MAT_WING); addOutline(wingL);
 const wingR = new THREE.Mesh(triWing(), MAT_WING); addOutline(wingR);
 wingL.rotation.y = 0;
 wingR.rotation.y = Math.PI;
 wingL.position.set(-0.18, 0, 0);
 wingR.position.set(0.18, 0, 0);
 wingL.scale.set(1.3, 1.3, 1.0); // Make wings larger and more prominent
 wingR.scale.set(1.3, 1.3, 1.0);
 const knot = new THREE.Mesh(new THREE.SphereGeometry(0.04, 16, 12), MAT_BODY); addOutline(knot); // Rounded knot instead of box
 knot.scale.set(1.5, 1.5, 1.5);
 bowGroup.add(wingL, wingR, knot);
 bowGroup.position.set(0, BH + 0.15, 0);

 const armRadius = .055;
 const handGeo = new THREE.SphereGeometry(armRadius, 16, 12);
 const shoulderX = BW * 0.38;
 const shoulderY = BH * 0.52;
 const shoulderZ = BD * 0.5 - armRadius * 0.4;
 const armTilt = THREE.MathUtils.degToRad(-8);
 const armSweep = THREE.MathUtils.degToRad(26);
 const armTuck = THREE.MathUtils.degToRad(-4);
 function makeArm(sign=1){
 const armRoot = new THREE.Group();
 const armCurve = new THREE.QuadraticBezierCurve3(
 new THREE.Vector3(0, -0.015, 0.02),
 new THREE.Vector3(0.12 * sign, -0.16, 0.05),
 new THREE.Vector3(0.16 * sign, -0.28, 0.015)
 );
 const armGeo = new THREE.TubeGeometry(armCurve, 28, armRadius, 12, false);
 const upper = new THREE.Mesh(armGeo, MAT_BODY); addOutline(upper, 1.04);
 const handGroup = new THREE.Group();
 const hand = new THREE.Mesh(handGeo, MAT_BODY); addOutline(hand, 1.04);
 hand.position.copy(armCurve.getPoint(1));
 handGroup.position.add(new THREE.Vector3(sign * 0.012, -0.008, 0.01));
 handGroup.add(hand);
 armRoot.add(upper, handGroup);
 armRoot.position.set(sign * (shoulderX + armRadius * 0.6), shoulderY - 0.02, shoulderZ * 0.4);
 armRoot.rotation.set(armTilt, sign * armSweep, sign * armTuck);
 return { armRoot, handGroup };
 }
 const L = makeArm(-1), R = makeArm(+1);

 const legRadius = .06;
 const legCurve = new THREE.CatmullRomCurve3([
 new THREE.Vector3(0,0,0), new THREE.Vector3(0,-.10,.022), new THREE.Vector3(0,-.17,.036)
 ]);
 const legGeo = new THREE.TubeGeometry(legCurve, 12, legRadius, 12, false);
 const footGeo = new THREE.SphereGeometry(legRadius, 16, 12);
 function makeLeg(x){
 const legRoot = new THREE.Group();
 const leg = new THREE.Mesh(legGeo, MAT_BODY); addOutline(leg, 1.04);
 const footGroup = new THREE.Group();
 const foot = new THREE.Mesh(footGeo, MAT_BODY); addOutline(foot, 1.04);
 foot.position.copy(legCurve.getPoint(1));
 foot.scale.set(1.5,.8,1.2);
 footGroup.add(foot);
 legRoot.add(leg, footGroup);
 legRoot.position.set(x, 0, 0);
 return { legRoot, footGroup };
 }
 const legL = makeLeg(-.20), legR = makeLeg(.20);
 legR.legRoot.position.set(Math.abs(legL.legRoot.position.x), legL.legRoot.position.y, legL.legRoot.position.z);

 root.add(bodyGroup, bowGroup, L.armRoot, R.armRoot, legL.legRoot, legR.legRoot);

 const BASE_RENDER_ORDER = 10500;
 
 // Function to update render order based on graphics settings
 root.userData.updateRenderOrder = function() {
 const hasFrostedGlass = FancyGraphics?.enabled && FancyGraphics?.settings?.transmission;
 const baseOrder = hasFrostedGlass ? BASE_RENDER_ORDER : (BASE_RENDER_ORDER + 1000); // Higher when not frosted
 root.traverse(obj=>{
 if(!obj.isMesh) return;
 const isOutline = !!obj.userData?.isAvatarOutline;
 const isBowPart = (obj.parent === bowGroup || obj.parent?.parent === bowGroup);
 // Bow parts render above cells, body parts at base (or elevated if no frosted glass)
 obj.renderOrder = isOutline ? (baseOrder - 1) : (isBowPart ? baseOrder + 50 : baseOrder);
 });
 };
 
 root.traverse(obj=>{
 if(!obj.isMesh) return;
 const isOutline = !!obj.userData?.isAvatarOutline;
 if(obj.material){
 obj.material.depthTest = true;
 obj.material.depthWrite = !isOutline;
 obj.material.toneMapped = false;
 if(isOutline){
 obj.material.transparent = true;
 obj.material.opacity = 1;
 obj.material.polygonOffset = true;
 obj.material.polygonOffsetFactor = -1;
 obj.material.polygonOffsetUnits = -1;
 } else if(obj.material.polygonOffset){
 obj.material.polygonOffset = false;
 }
 }
 });
 
 // Set initial render order
 root.userData.updateRenderOrder();

 root.userData.components = [
 {name:'Body', group: bodyGroup},
 {name:'Face', group: faceGroup},
 {name:'Eye L', group: eyeL},
 {name:'Eye R', group: eyeR},
 {name:'Cheek L', group: cheekL},
 {name:'Cheek R', group: cheekR},
 {name:'Bow', group: bowGroup},
 {name:'Bow / Left', group: wingL},
 {name:'Bow / Right', group: wingR},
 {name:'Bow / Center', group: knot},
 {name:'Arm L', group: L.armRoot},
 {name:'Arm L / Hand', group: L.handGroup},
 {name:'Arm R', group: R.armRoot},
 {name:'Arm R / Hand', group: R.handGroup},
 {name:'Leg L', group: legL.legRoot},
 {name:'Leg L / Foot', group: legL.legRoot.children[1]},
 {name:'Leg R', group: legR.legRoot},
 {name:'Leg R / Foot', group: legR.legRoot.children[1]},
 ];

 root.userData.bodyGroup = bodyGroup;
 return root;
 }
 };

 const ARRAYA_BASE_SCALE = 0.28;

 const ArrayaAvatarFactory = (function(){
 function push(arr, ...v){ for(const x of v) arr.push(x); }

 function roundedBoxGeometry(w, h, d, seg=6, round=0.45){
 const hw=w/2, hh=h/2, hd=d/2;
 const positions=[]; const indices=[];
 function face(uSeg,vSeg, constX,constY,constZ, ux,uy,uz, vx,vy,vz, flip){
 const base = positions.length/3;
 for(let j=0;j<=vSeg;j++){
 for(let i=0;i<=uSeg;i++){
 const u=i/uSeg, v=j/vSeg;
 const x = constX + ux*(u-0.5) + vx*(v-0.5);
 const y = constY + uy*(u-0.5) + vy*(v-0.5);
 const z = constZ + uz*(u-0.5) + vz*(v-0.5);
 push(positions, x,y,z);
 }
 }
 for(let j=0;j<vSeg;j++){
 for(let i=0;i<uSeg;i++){
 const a = base + i + (uSeg+1)*j;
 const b = base + i+1 + (uSeg+1)*j;
 const c = base + i + (uSeg+1)*(j+1);
 const d = base + i+1 + (uSeg+1)*(j+1);
 if (!flip) { push(indices, a,c,b, b,c,d); } else { push(indices, a,b,c, b,d,c); }
 }
 }
 }
 const sx=seg, sy=seg, sz=seg;
 face(sx,sy, 0,0, hd, w,0,0, 0,h,0, false);
 face(sx,sy, 0,0,-hd, w,0,0, 0,h,0, true);
 face(sz,sy, hw,0,0, 0,0,d, 0,h,0, false);
 face(sz,sy,-hw,0,0, 0,0,d, 0,h,0, true);
 face(sx,sz, 0,hh,0, w,0,0, 0,0,d, true);
 face(sx,sz, 0,-hh,0, w,0,0, 0,0,d, false);

 for(let i=0;i<positions.length;i+=3){
 let x=positions[i]/hw, y=positions[i+1]/hh, z=positions[i+2]/hd;
 const x2=x*x,y2=y*y,z2=z*z;
 const sx=x*Math.sqrt(Math.max(0.0,1.0-0.5*(y2+z2)+(y2*z2)/3.0));
 const sy=y*Math.sqrt(Math.max(0.0,1.0-0.5*(z2+x2)+(z2*x2)/3.0));
 const sz=z*Math.sqrt(Math.max(0.0,1.0-0.5*(x2+y2)+(x2*y2)/3.0));
 x = x*(1.0-round) + sx*round;
 y = y*(1.0-round) + sy*round;
 z = z*(1.0-round) + sz*round;
 positions[i]=x*hw; positions[i+1]=y*hh; positions[i+2]=z*hd;
 }
 return { positions:new Float32Array(positions), indices:new Uint32Array(indices) };
 }

 function cylinderGeometry(r=0.07,h=0.06, seg=24){
 const pos=[], nor=[], idx=[]; const half=h/2;
 for(let i=0;i<=seg;i++){
 const a=i/seg*2*Math.PI; const x=Math.cos(a), y=Math.sin(a);
 push(pos, r*x, r*y, -half, r*x, r*y, half);
 push(nor, x,y,0, x,y,0);
 }
 for(let i=0;i<seg;i++){
 const a=i*2, b=a+1, c=a+2, d=a+3;
 push(idx, a,c,b, b,c,d);
 }
 const base = pos.length/3;
 for(let j=0;j<2;j++){
 const z = j? half : -half; const nz = j? 1:-1; const centerIndex = pos.length/3; push(pos,0,0,z); push(nor,0,0,nz);
 for(let i=0;i<=seg;i++){ const a=i/seg*2*Math.PI; const x=Math.cos(a), y=Math.sin(a); push(pos,r*x,r*y,z); push(nor,0,0,nz); }
 for(let i=0;i<seg;i++){ const ci=centerIndex, vi=centerIndex+1+i; if(j){ push(idx, ci, vi, vi+1);} else { push(idx, ci, vi+1, vi);} }
 }
 return { positions:new Float32Array(pos), normals:new Float32Array(nor), indices:new Uint16Array(idx) };
 }

 function torusGeometry(R=0.18, r=0.028, arc=Math.PI, segU=56, segV=16, endSmooth=0.25, endMin=0.55){
 const pos=[], nor=[], idx=[];
 const sstep = (x)=> x<=0?0 : x>=1?1 : x*x*(3-2*x);
 for(let j=0;j<=segV;j++){
 const v=j/segV*2*Math.PI; const cv=Math.cos(v), sv=Math.sin(v);
 for(let i=0;i<=segU;i++){
 const t=i/segU;
 const u=t*arc - arc;
 const cu=Math.cos(u), su=Math.sin(u);
 let w=1.0;
 if(endSmooth>0){
 const edge = Math.min(t/endSmooth, (1.0 - t)/endSmooth);
 const k = sstep(Math.max(0, Math.min(1, edge)));
 w = endMin + (1.0 - endMin) * k;
 }
 const re = r * w;
 const cx = R * cu, cy = R * su;
 const x=(R + re*cv)*cu;
 const y=(R + re*cv)*su;
 const z=re*sv;
 push(pos, x,y,z);
 let nx = x - cx, ny = y - cy, nz = z;
 const len = Math.hypot(nx,ny,nz) || 1.0;
 nx/=len; ny/=len; nz/=len;
 push(nor, nx,ny,nz);
 }
 }
 for(let j=0;j<segV;j++){
 for(let i=0;i<segU;i++){
 const a=i + (segU+1)*j;
 const b=i+1 + (segU+1)*j;
 const c=i + (segU+1)*(j+1);
 const d=i+1 + (segU+1)*(j+1);
 push(idx, a,c,b, b,c,d);
 }
 }
 return { positions:new Float32Array(pos), normals:new Float32Array(nor), indices:new Uint32Array(idx) };
 }

 function computeNormals(positions, indices, out){
 out.fill(0);
 for(let i=0;i<indices.length;i+=3){
 const ia=indices[i]*3, ib=indices[i+1]*3, ic=indices[i+2]*3;
 const ax=positions[ia], ay=positions[ia+1], az=positions[ia+2];
 const bx=positions[ib], by=positions[ib+1], bz=positions[ib+2];
 const cx=positions[ic], cy=positions[ic+1], cz=positions[ic+2];
 const abx=bx-ax, aby=by-ay, abz=bz-az;
 const acx=cx-ax, acy=cy-ay, acz=cz-az;
 let nx=aby*acz-abz*acy, ny=abz*acx-abx*acz, nz=abx*acy-aby*acx;
 const inv=1/Math.hypot(nx,ny,nz);
 nx*=inv; ny*=inv; nz*=inv;
 out[ia]+=nx; out[ia+1]+=ny; out[ia+2]+=nz;
 out[ib]+=nx; out[ib+1]+=ny; out[ib+2]+=nz;
 out[ic]+=nx; out[ic+1]+=ny; out[ic+2]+=nz;
 }
 for(let i=0;i<out.length;i+=3){
 const inv=1/Math.hypot(out[i],out[i+1],out[i+2]);
 out[i]*=inv; out[i+1]*=inv; out[i+2]*=inv;
 }
 return out;
 }

 const W=1.45, H=1.1, D=1.2;
 const cubeBase = roundedBoxGeometry(W,H,D,8,0.45);
 const eyeBase = cylinderGeometry(0.085, 0.06, 24);
 const smileBase = torusGeometry(0.18, 0.028, Math.PI, 56, 16, 0.35, 0.70);
 const greensRaw = [
 [0.75,0.94,0.42],
 [0.65,0.88,0.36],
 [0.55,0.83,0.32],
 [0.46,0.78,0.27],
 [0.36,0.71,0.23],
 [0.29,0.65,0.20]
 ];

 const JOIN_EPS = 0.05;
 const HEAD_BULGE = 0.12;
 const TAIL_BULGE = 0.08;
 const HEAD_FACE_EXPAND = 0.10;
 const GLOBAL_ROT_X = Math.PI/2;
 const GLOBAL_ROT_Z = -Math.PI/2;
 const NSEG = 6;
 const segLen = D;
 const L = NSEG * segLen;
 const thetaAmp = 0.70;
 const yAmp = 0.0;
 const ds = Math.max(0.01, L/320);

 function cross(a,b){ return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]; }
 function normalize(v){ const l=Math.hypot(v[0],v[1],v[2]); return l? [v[0]/l,v[1]/l,v[2]/l] : [0,1,0]; }
 function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
 function smoothstep(a,b,x){ const t = clamp((x-a)/(b-a),0,1); return t*t*(3-2*t); }
 function rotX(v,a){ const c=Math.cos(a), s=Math.sin(a); return [ v[0], v[1]*c - v[2]*s, v[1]*s + v[2]*c ]; }
 function rotZ(v,a){ const c=Math.cos(a), s=Math.sin(a); return [ v[0]*c - v[1]*s, v[0]*s + v[1]*c, v[2] ]; }

 let samples=[];
 (function rebuildCurve(){
 samples=[];
 let p=[0, H/2, 0];
 let tan=[0,0,1];
 samples.push({ s:0, p:p.slice(), t:tan.slice() });
 for(let s=ds; s<=L+1e-6; s+=ds){
 const theta = thetaAmp * Math.sin(2*Math.PI * (s/L));
 const dy_ds = yAmp * (Math.PI / L) * Math.cos(Math.PI * s / L);
 tan = normalize([ Math.sin(theta), dy_ds, Math.cos(theta) ]);
 p = [ p[0] + tan[0]*ds, p[1] + tan[1]*ds, p[2] + tan[2]*ds ];
 samples.push({ s: Math.min(s,L), p:p.slice(), t:tan.slice() });
 }
 })();

 function sampleFrameAt(s){
 if (s <= 0){
 const t0 = samples[0].t; const up=[0,1,0];
 let side = cross(up, t0); let Ls=Math.hypot(side[0],side[1],side[2]);
 if (Ls<1e-6) side=[1,0,0], Ls=1; side=[side[0]/Ls, side[1]/Ls, side[2]/Ls];
 const up2 = cross(t0, side);
 return { p: samples[0].p.slice(), t: t0.slice(), side, up: up2 };
 }
 if (s >= L){
 const last = samples[samples.length-1]; const up=[0,1,0];
 let side = cross(up, last.t); let Ls=Math.hypot(side[0],side[1],side[2]);
 if (Ls<1e-6) side=[1,0,0], Ls=1; side=[side[0]/Ls, side[1]/Ls, side[2]/Ls];
 const up2 = cross(last.t, side);
 return { p: last.p.slice(), t: last.t.slice(), side, up: up2 };
 }
 const i = Math.min(samples.length-2, Math.max(0, Math.floor(s/ds)));
 const a = samples[i], b = samples[i+1];
 const tt = (s - a.s) / (b.s - a.s);
 const lerp = (x,y)=> x + (y-x)*tt;
 const p=[ lerp(a.p[0],b.p[0]), lerp(a.p[1],b.p[1]), lerp(a.p[2],b.p[2]) ];
 let tan=[ lerp(a.t[0],b.t[0]), lerp(a.t[1],b.t[1]), lerp(a.t[2],b.t[2]) ];
 tan = normalize(tan);
 const up=[0,1,0];
 let side=cross(up, tan); let Ls=Math.hypot(side[0],side[1],side[2]);
 if (Ls<1e-6) side=[1,0,0], Ls=1; side=[side[0]/Ls, side[1]/Ls, side[2]/Ls];
 const up2 = cross(tan, side);
 return { p, t:tan, side, up: up2 };
 }

 function rotateFrame(F){
 const pX = rotX(F.p, GLOBAL_ROT_X); const tX = rotX(F.t, GLOBAL_ROT_X);
 const sX = rotX(F.side, GLOBAL_ROT_X); const uX = rotX(F.up, GLOBAL_ROT_X);
 return { p: rotZ(pX, GLOBAL_ROT_Z), t: rotZ(tX, GLOBAL_ROT_Z), side: rotZ(sX, GLOBAL_ROT_Z), up: rotZ(uX, GLOBAL_ROT_Z) };
 }

 function toVector3(arr){ return new THREE.Vector3(arr[0], arr[1], arr[2]); }

 function projectUp(N){
 const U=[0,1,0];
 const dot = U[0]*N[0]+U[1]*N[1]+U[2]*N[2];
 let up=[ U[0]-dot*N[0], U[1]-dot*N[1], U[2]-dot*N[2] ];
 let L = Math.hypot(up[0],up[1],up[2]);
 if (L < 1e-4){
 const WR=[1,0,0];
 const dot2 = WR[0]*N[0]+WR[1]*N[1]+WR[2]*N[2];
 up=[ WR[0]-dot2*N[0], WR[1]-dot2*N[1], WR[2]-dot2*N[2] ];
 L = Math.hypot(up[0],up[1],up[2]);
 }
 return [up[0]/L, up[1]/L, up[2]/L];
 }

 function create(THREE){
 const group = new THREE.Group();
 group.name = 'ArrayaAvatar';
 group.scale.setScalar(ARRAYA_BASE_SCALE); // Smaller than Celli
 const greens = greensRaw.map(rgb=> new THREE.Color(rgb[0], rgb[1], rgb[2]));
 const segments=[];
 const darkGray = new THREE.Color(0x1f2937); // Gray-800 (matching single-select Celli)
 for(let i=0;i<NSEG;i++){
 const geometry = new THREE.BufferGeometry();
 const posArray = new Float32Array(cubeBase.positions.length);
 const norArray = new Float32Array(cubeBase.positions.length);
 geometry.setAttribute('position', new THREE.BufferAttribute(posArray,3));
 geometry.setAttribute('normal', new THREE.BufferAttribute(norArray,3));
 const IndexType = cubeBase.indices.constructor;
 const indexCopy = new IndexType(cubeBase.indices);
 geometry.setIndex(new THREE.BufferAttribute(indexCopy, 1));
 // Use MeshStandardMaterial for dynamic lighting support in present mode
 const mat = new THREE.MeshStandardMaterial({ color: greens[i], side: THREE.DoubleSide, roughness: 0.7, metalness: 0.1 });
 mat.depthTest = true; mat.depthWrite = true; mat.toneMapped = false;
 const mesh = new THREE.Mesh(geometry, mat);
 mesh.castShadow = false; mesh.receiveShadow = false;
 mesh.renderOrder = 50; // Body segments render before faces (50 < 100)
 
 // Add thin shell to each segment for consistency with cells
 const shellGeometry = new THREE.BufferGeometry();
 const shellPosArray = new Float32Array(cubeBase.positions.length);
 const shellNorArray = new Float32Array(cubeBase.positions.length);
 shellGeometry.setAttribute('position', new THREE.BufferAttribute(shellPosArray,3));
 shellGeometry.setAttribute('normal', new THREE.BufferAttribute(shellNorArray,3));
 const shellIndexCopy = new IndexType(cubeBase.indices);
 shellGeometry.setIndex(new THREE.BufferAttribute(shellIndexCopy, 1));
 const shellMat = new THREE.MeshStandardMaterial({ color: darkGray, side: THREE.BackSide, roughness: 0.8, metalness: 0.05 });
 shellMat.depthTest = true; shellMat.depthWrite = false; // Don't write depth so it renders behind
 shellMat.toneMapped = false;
 const shellMesh = new THREE.Mesh(shellGeometry, shellMat);
 shellMesh.castShadow = false; shellMesh.receiveShadow = false;
 shellMesh.renderOrder = 40; // Shell renders behind body (40 < 50)
 shellMesh.scale.setScalar(1.06); // Slightly larger than body
 mesh.add(shellMesh); // Parent to body segment so it follows
 
 group.add(mesh);
 segments.push({ mesh, posArray, norArray, geometry, shellMesh, shellPosArray, shellNorArray, shellGeometry });
 }

 function buildStaticGeometry(base){
 const geometry = new THREE.BufferGeometry();
 geometry.setAttribute('position', new THREE.BufferAttribute(base.positions.slice(),3));
 if(base.normals){ geometry.setAttribute('normal', new THREE.BufferAttribute(base.normals.slice(),3)); }
 if(base.indices && base.indices.length > 0){ 
 // Create a new TypedArray of the same type as the original
 const IndexType = base.indices.constructor;
 const indexCopy = new IndexType(base.indices);
 geometry.setIndex(new THREE.BufferAttribute(indexCopy, 1));
 }
 return geometry;
 }

 const eyeGeo = buildStaticGeometry(eyeBase);
 if(!eyeBase.normals){
 const normals = new Float32Array(eyeBase.positions.length);
 computeNormals(eyeBase.positions, eyeBase.indices, normals);
 eyeGeo.attributes.normal.array.set(normals);
 }
 const smileGeo = buildStaticGeometry(smileBase);
 if(!smileBase.normals){
 const normals = new Float32Array(smileBase.positions.length);
 computeNormals(smileBase.positions, smileBase.indices, normals);
 smileGeo.attributes.normal.array.set(normals);
 }

 // Use MeshStandardMaterial for dynamic lighting support in present mode
 const featureMat = new THREE.MeshStandardMaterial({ roughness: 0.7, metalness: 0.1, 
 color: new THREE.Color(0.06,0.07,0.07), 
 side: THREE.FrontSide // Only visible from front
 });
 featureMat.depthTest = true; 
 featureMat.depthWrite = true; 
 featureMat.toneMapped = false;
 featureMat.colorWrite = true; // Ensure they render
 const eyeL = new THREE.Mesh(eyeGeo, featureMat.clone());
 const eyeR = new THREE.Mesh(eyeGeo, featureMat.clone());
 const smileMat = featureMat.clone();
 smileMat.side = THREE.DoubleSide;
 smileMat.needsUpdate = true;
 const smile = new THREE.Mesh(smileGeo, smileMat);
 eyeL.castShadow = eyeR.castShadow = smile.castShadow = false;
 eyeL.receiveShadow = eyeR.receiveShadow = smile.receiveShadow = false;
 // Set render order so faces render on top of body segments
 eyeL.renderOrder = 100;
 eyeR.renderOrder = 100;
 smile.renderOrder = 100;
 // Frustum culling enabled so back faces are culled properly
 eyeL.frustumCulled = false;
 eyeR.frustumCulled = false;
 smile.frustumCulled = false;
 group.add(eyeL, eyeR, smile);

 const MAT_OUTLINE = new THREE.MeshBasicMaterial({ color: 0x1f2937 }); // Gray-800 (matching single-select Celli)
 MAT_OUTLINE.depthTest = true;
 MAT_OUTLINE.depthWrite = false;
 MAT_OUTLINE.toneMapped = false;
 MAT_OUTLINE.transparent = false; // Make opaque for cleaner rendering
 const outlineScale = 1.08;
 const baseMeshes = [];
 group.traverse(n=>{ if(n.isMesh && !n.userData.isAvatarOutline) baseMeshes.push(n); });
 baseMeshes.forEach(mesh=>{
 const outline = new THREE.Mesh(mesh.geometry, MAT_OUTLINE);
 outline.name = `${mesh.name||'part'}_outline`;
 outline.userData.isAvatarOutline = true;
 outline.scale.set(outlineScale, outlineScale, outlineScale);
 outline.position.set(0,0,0);
 outline.castShadow = false;
 outline.receiveShadow = false;
 // Ensure outline renders well behind the base geometry
 outline.renderOrder = Math.max(0, (mesh.renderOrder ?? 50) - 10);
 mesh.add(outline);
 });

 const hd = D/2;
 const pivotVec = new THREE.Vector3();
 const sFace = 0.006;

 const aggregateBox = new THREE.Box3();
 const partBox = new THREE.Box3();
 const partCenter = new THREE.Vector3();

 const controller = {
 group,
 visible:false,
 needsUpdate:true,
 headOffset:new THREE.Vector3(),
 centerOffset:new THREE.Vector3(),
 setVisible(v){
 if(this.visible !== v){
 this.visible = v;
 group.visible = v;
 if(v) this.needsUpdate = true;
 } else {
 group.visible = v;
 if(v) this.needsUpdate = true;
 }
 },
 setAnchor(vec){ group.position.copy(vec); },
 update(time){
 if(!this.needsUpdate) return;
 const pivotFrame = rotateFrame(sampleFrameAt(0));
 pivotVec.set(pivotFrame.p[0], pivotFrame.p[1], pivotFrame.p[2]);

 for(let i=0;i<NSEG;i++){
 const sStart = i * segLen;
 const posTarget = segments[i].posArray;
 const basePos = cubeBase.positions;
 for(let v=0; v<basePos.length; v+=3){
 let x0 = basePos[v+0];
 let y0 = basePos[v+1];
 const z0 = basePos[v+2];
 let s = sStart + (z0 + hd);
 if (i>0 && i<NSEG) s -= JOIN_EPS;
 s = clamp(s, 0, L);
 const FR = rotateFrame(sampleFrameAt(s));
 const u = clamp((s - sStart) / segLen, 0, 1);
 if (i === 0){
 const mask = smoothstep(0.0, 0.3, 1.0 - u);
 const expand = 1.0 + HEAD_FACE_EXPAND * mask;
 x0 *= expand; y0 *= expand;
 }
 let px = FR.p[0] + x0*FR.side[0] + y0*FR.up[0];
 let py = FR.p[1] + x0*FR.side[1] + y0*FR.up[1];
 let pz = FR.p[2] + x0*FR.side[2] + y0*FR.up[2];
 const rx = Math.abs(x0)/(W*0.5), ry = Math.abs(y0)/(H*0.5);
 const radial = clamp(1.0 - 0.6*Math.max(rx, ry), 0, 1);
 let bulge = 0.0;
 if (i === 0){
 bulge = HEAD_BULGE * smoothstep(0.65, 1.0, u) * radial;
 } else if (i === NSEG-1){
 bulge = TAIL_BULGE * smoothstep(0.65, 1.0, u) * radial;
 }
 if (bulge > 0.0){
 px += FR.t[0]*bulge; py += FR.t[1]*bulge; pz += FR.t[2]*bulge;
 }
 px -= pivotVec.x; py -= pivotVec.y; pz -= pivotVec.z;
 posTarget[v+0] = px; posTarget[v+1] = py; posTarget[v+2] = pz;
 }
 computeNormals(posTarget, cubeBase.indices, segments[i].norArray);
 segments[i].mesh.geometry.attributes.position.needsUpdate = true;
 segments[i].mesh.geometry.attributes.normal.needsUpdate = true;
 segments[i].geometry.computeBoundingSphere();
 segments[i].geometry.computeBoundingBox();
 
 // Update shell geometry to match body
 if(segments[i].shellMesh){
 segments[i].shellPosArray.set(posTarget);
 segments[i].shellNorArray.set(segments[i].norArray);
 segments[i].shellMesh.geometry.attributes.position.needsUpdate = true;
 segments[i].shellMesh.geometry.attributes.normal.needsUpdate = true;
 segments[i].shellGeometry.computeBoundingSphere();
 segments[i].shellGeometry.computeBoundingBox();
 }
 }

 const FfaceR = rotateFrame(sampleFrameAt(sFace));
 const facePos = new THREE.Vector3(FfaceR.p[0], FfaceR.p[1], FfaceR.p[2]).sub(pivotVec);
 const N = normalize([-FfaceR.t[0], -FfaceR.t[1], -FfaceR.t[2]]);
 let up = projectUp(N);
 const right = normalize(cross(up, N));
 up = normalize(cross(N, right));

 const normalVec = toVector3(N);
 const upVec = toVector3(up);
 const rightVec = toVector3(right);
 const basis = new THREE.Matrix4().makeBasis(rightVec, upVec, normalVec);

 const inset = 0.010;
 const EYE_SPACING = 0.20;
 const EYE_Y = 0.15;
 const scaleH = 0.85, scaleV = 1.15, scaleN = 0.65;

 function placeEye(mesh, sign){
 mesh.position.set(
 facePos.x + sign*EYE_SPACING*rightVec.x + EYE_Y*upVec.x - inset*normalVec.x,
 facePos.y + sign*EYE_SPACING*rightVec.y + EYE_Y*upVec.y - inset*normalVec.y,
 facePos.z + sign*EYE_SPACING*rightVec.z + EYE_Y*upVec.z - inset*normalVec.z
 );
 mesh.quaternion.setFromRotationMatrix(basis);
 mesh.scale.set(scaleH, scaleV, scaleN);
 }

 placeEye(eyeL, -1);
 placeEye(eyeR, 1);

 const smileInset = 0.006;
 const offUp = -0.02;
 smile.quaternion.setFromRotationMatrix(basis);
 smile.position.set(
 facePos.x + offUp*upVec.x + smileInset*normalVec.x,
 facePos.y + offUp*upVec.y + smileInset*normalVec.y,
 facePos.z + offUp*upVec.z + smileInset*normalVec.z
 );
 smile.scale.set(1,1,0.72);

 this.headOffset.copy(facePos);
 aggregateBox.makeEmpty();
 group.traverse(node=>{
 if(!node.isMesh) return;
 const geometry = node.geometry;
 if(!geometry) return;
 if(!geometry.boundingBox) geometry.computeBoundingBox();
 const bbox = geometry.boundingBox;
 if(!bbox) return;
 node.updateMatrix();
 partBox.copy(bbox).applyMatrix4(node.matrix);
 aggregateBox.union(partBox);
 });
 if(!aggregateBox.isEmpty()){
 aggregateBox.getCenter(partCenter);
 this.centerOffset.copy(partCenter);
 } else {
 this.centerOffset.set(0,0,0);
 }
 this.needsUpdate = false;
 }
 };

 controller.update(0);
 return controller;
 }

 return { create };
 })();

 // Celli and Arraya avatars
 const ARRAYA_ROTATION_OFFSET = -Math.PI / 2; // Rotate 90 clockwise around Y
 let celli, arraya, arrayaAvatar;
 const Y_AXIS = new THREE.Vector3(0,1,0);
 const TMP_ARRAYA_PLACEMENT = new THREE.Vector3();
 const TMP_ARRAYA_OFFSET = new THREE.Vector3();

 function computeArrayaPlacement(basePos, hoverHeight, rotationY, scale){
 TMP_ARRAYA_PLACEMENT.copy(basePos);
 TMP_ARRAYA_PLACEMENT.y += hoverHeight;
 if(arrayaAvatar?.centerOffset){
 TMP_ARRAYA_OFFSET.set(arrayaAvatar.centerOffset.x, 0, arrayaAvatar.centerOffset.z);
 TMP_ARRAYA_OFFSET.multiplyScalar(scale);
 TMP_ARRAYA_OFFSET.applyAxisAngle(Y_AXIS, rotationY);
 TMP_ARRAYA_PLACEMENT.sub(TMP_ARRAYA_OFFSET);
 }
 return TMP_ARRAYA_PLACEMENT;
 }
 function ensureArrayaAvatar(){
 if(arrayaAvatar || typeof ArrayaAvatarFactory === 'undefined') return;
 try{
 const created = ArrayaAvatarFactory.create(THREE);
 if(!created) return;
 arrayaAvatar = created;
 arraya = arrayaAvatar.group;
 if(scene && arraya) scene.add(arraya);
 arrayaAvatar.setVisible(false);
 }catch(err){
 console.error('Failed to initialize Arraya avatar:', err);
 }
 }
 function initAvatars(){
 celli = AvatarFactory.createCelli(THREE);
 scene.add(celli); celli.visible=false;

 ensureArrayaAvatar();
 }

 function updateAvatars(sel){
 // Don't update avatars during swap animation
 if(swapAnimating) return;
 
 const physicsMode = Store.getState().scene.physics;
 
 // ONLY position from physics if physics is actually enabled AND playerBody exists
 if(physicsMode && playerBody && rapierWorld){
 try{
 const translation = playerBody.translation();
 const basePosX = translation.x;
 const basePosY = translation.y - 0.3;
 const basePosZ = translation.z;
 let verticalOffset = 0;
 celli.visible = true;

 // Stretch and squash animation during jump/fall with anticipation
 const baseScale = 0.7;

 // Anticipation squash when preparing to jump
 if(anticipationSquashTime > 0){
 const squashY = 0.65; // Squash down to build energy
 const expandXZ = 1.25; // Expand horizontally
 celli.scale.set(baseScale * expandXZ, baseScale * squashY, baseScale * expandXZ);
 landingSquashTime = 0; // Reset landing animation
 }
 // Jump stretch - elongate while ascending
 else if(jumpVelocity > 4){
 const stretchAmount = 1 + (jumpVelocity - 4) * 0.06; // More dramatic stretch
 const compressXZ = 1 - (jumpVelocity - 4) * 0.02; // Compress horizontally
 celli.scale.set(baseScale * Math.max(0.75, compressXZ), baseScale * stretchAmount, baseScale * Math.max(0.75, compressXZ));
 landingSquashTime = 0;
 }
 // Falling stretch - elongate while descending fast
 else if(jumpVelocity < -3){
 const fallStretch = 1 + Math.abs(jumpVelocity + 3) * 0.04;
 const fallCompress = 1 - Math.abs(jumpVelocity + 3) * 0.015;
 celli.scale.set(baseScale * Math.max(0.8, fallCompress), baseScale * fallStretch, baseScale * Math.max(0.8, fallCompress));
 landingSquashTime = 0;
 }
 // Landing squash and recovery
 else if(Math.abs(jumpVelocity) < 0.5){
 if(landingSquashTime === 0){
 landingSquashTime = 1; // Trigger landing squash
 }
 // Landing squash and recovery animation over ~300ms
 if(landingSquashTime < 18){
 const t = landingSquashTime / 18;
 // Squash down then bounce back up
 let squashY, expandXZ;
 if(t < 0.3){
 // Initial impact squash (frames 1-5)
 const impactT = t / 0.3;
 squashY = 1 - 0.35 * impactT; // 1.0 -> 0.65
 expandXZ = 1 + 0.3 * impactT; // 1.0 -> 1.3
 } else {
 // Recovery with slight overshoot (frames 6-18)
 const recoveryT = (t - 0.3) / 0.7;
 const easeOut = 1 - Math.pow(1 - recoveryT, 3); // Cubic ease out
 squashY = 0.65 + 0.38 * easeOut; // 0.65 -> 1.03 -> 1.0
 expandXZ = 1.3 - 0.32 * easeOut; // 1.3 -> 0.98 -> 1.0
 // Add slight overshoot at the end
 if(recoveryT > 0.8){
 const overshootT = (recoveryT - 0.8) / 0.2;
 squashY += 0.03 * Math.sin(overshootT * Math.PI);
 }
 }
 celli.scale.set(baseScale * expandXZ, baseScale * squashY, baseScale * expandXZ);
 const depression = Math.max(0, 1 - Math.min(squashY, 1));
 verticalOffset = Math.max(verticalOffset, Math.min(0.5, depression * 0.32));
 landingSquashTime++;
 } else {
 // Fully recovered to normal
 celli.scale.set(baseScale, baseScale, baseScale);
 }
 }
 // Normal state (walking or gentle movement)
 else {
 celli.scale.set(baseScale, baseScale, baseScale);
 if(Math.abs(jumpVelocity) > 1) landingSquashTime = 0; // Reset if airborne
 }

 if(surfaceBounceState.key && (surfaceBounceState.key === lastLandKey || surfaceBounceState.key === lastTouchKey)){
 const intensityScale = Math.max(0.2, 0.32 + 0.18 * (surfaceBounceState.intensity - 1));
 const depression = Math.max(0, Math.min(0.5, surfaceBounceState.depression * intensityScale));
 verticalOffset = Math.max(verticalOffset, depression);
 }

 celli.position.set(basePosX, basePosY - verticalOffset, basePosZ);

 // Physics mode: face movement direction
 if(mouseLookEnabled){
 // Face the mouse look direction
 celli.rotation.y = mouseYaw;
 } else {
 // Face camera direction
 const camDir = new THREE.Vector3();
 camera.getWorldDirection(camDir);
 camDir.y = 0;
 camDir.normalize();
 const targetAngle = Math.atan2(camDir.x, camDir.z);
 celli.rotation.y = targetAngle;
 }
 }catch{
 celli.visible = false;
 }
 if(arrayaAvatar) arrayaAvatar.setVisible(false);
 return;
 }
 
 // Edit mode: position from selection
 if(!sel.arrayId||!sel.focus){
 celli.visible=false;
 if(arrayaAvatar) arrayaAvatar.setVisible(false);
 return;
 }
 const arr=Store.getState().arrays[sel.arrayId];
 const pos=worldPos(arr,sel.focus.x,sel.focus.y,sel.focus.z);

 let multiSelect = false;
 if(sel.range){
 const sx = sel.range.x1 ?? sel.range.x ?? sel.focus.x;
 const ex = sel.range.x2 ?? sel.range.x ?? sel.focus.x;
 const sy = sel.range.y1 ?? sel.range.y ?? sel.focus.y;
 const ey = sel.range.y2 ?? sel.range.y ?? sel.focus.y;
 const sz = sel.range.z1 ?? sel.range.z ?? sel.focus.z;
 const ez = sel.range.z2 ?? sel.range.z ?? sel.focus.z;
 multiSelect = (sx !== ex) || (sy !== ey) || (sz !== ez);
 }
 if(multiSelect){
 celli.visible = false;
 if(arrayaAvatar) arrayaAvatar.setVisible(false);
 return;
 }
 
 let cell = null;
 try{ cell = UI.getCell(sel.arrayId,sel.focus); }catch{}
 if(!cell){
 try{ cell = Formula.getCell({arrId:sel.arrayId,x:sel.focus.x,y:sel.focus.y,z:sel.focus.z}); }catch{}
 }
 const formulaText = (cell?.formula||'');
 const valueText = (cell?.value||'');
 const hasArray = /ARRAY\(/i.test(formulaText) || /ARRAY\(/i.test(valueText);
 ensureArrayaAvatar();
 
 // Swap between Celli and Arraya with animation
 if(arrayaAvatar){
 const shouldShowArraya = hasArray;
 const arrayaVisible = arrayaAvatar.group?.visible || false;
 const wasArraya = arrayaAvatar._lastCell && arrayaAvatar._lastCell.hasArray;
 const currentCellKey = `${sel.arrayId}:${sel.focus.x},${sel.focus.y},${sel.focus.z}`;
 const cellChanged = (arrayaAvatar._lastCellKey !== currentCellKey);
 
 if(shouldShowArraya && !arrayaVisible){
 // Swap from Celli to Arraya with swirl animation
 console.log('[AVATAR] Starting swap: Celli -> Arraya');
 // Update Arraya's body to get correct headOffset before animating
 arrayaAvatar.needsUpdate = true;
 arrayaAvatar.update(0);
 // Calculate facing angle before swap - use cell position for consistent angle
 const cellToCamera = new THREE.Vector3().subVectors(camera.position, pos);
 cellToCamera.y = 0;
 cellToCamera.normalize();
 const baseAngle = Math.atan2(cellToCamera.x, cellToCamera.z);
 const spawnAngle = baseAngle + ARRAYA_ROTATION_OFFSET;
 const baseDeg = (baseAngle * 180 / Math.PI).toFixed(1);
 const spawnDeg = (spawnAngle * 180 / Math.PI).toFixed(1);
 console.log(`[AVATAR] Swap spawn: cell(${pos.x.toFixed(1)},${pos.z.toFixed(1)}), camera(${camera.position.x.toFixed(1)},${camera.position.z.toFixed(1)}), direction(${cellToCamera.x.toFixed(2)},${cellToCamera.z.toFixed(2)}), base=${baseDeg} , spawn=${spawnDeg} `);
 arrayaAvatar._targetRotation = spawnAngle;
 animateAvatarSwap(celli, arrayaAvatar, pos);
 arrayaAvatar._lastCellKey = currentCellKey;
 arrayaAvatar._lastCell = {hasArray: true};
 } else if(!shouldShowArraya && arrayaVisible){
 // Swap from Arraya back to Celli
 console.log('[AVATAR] Starting swap: Arraya -> Celli');
 animateAvatarSwap(arrayaAvatar.group, celli, pos);
 arrayaAvatar._lastCellKey = currentCellKey;
 arrayaAvatar._lastCell = {hasArray: false};
 } else if(shouldShowArraya){
 // Moving between ARRAY cells: just reposition Arraya, no swap
 arrayaAvatar.setVisible(true);
 celli.visible = false;
 
 // Update body curve if cell changed
 if(cellChanged){
 arrayaAvatar.needsUpdate = true;
 arrayaAvatar.update(0);
 }
 
 const arrScale = arrayVoxelScale(arr);
 const arrayaHover = clampedScaleOffset(arrScale, 0.8);
 let targetRotation = arrayaAvatar._targetRotation;

 // Update rotation on cell change or if not set
 if(cellChanged || targetRotation === undefined){
 // Face camera - calculate direction from cell to camera
 const cellToCamera = new THREE.Vector3().subVectors(camera.position, pos);
 cellToCamera.y = 0;
 cellToCamera.normalize();
 // For character facing: atan2(x, z) where character looks down +Z by default
 const baseAngle = Math.atan2(cellToCamera.x, cellToCamera.z);
 const spawnAngle = baseAngle + ARRAYA_ROTATION_OFFSET;
 const baseDeg = (baseAngle * 180 / Math.PI).toFixed(1);
 const spawnDeg = (spawnAngle * 180 / Math.PI).toFixed(1);
 console.log(`[AVATAR] Arraya spawn at cell(${pos.x.toFixed(1)},${pos.z.toFixed(1)}), camera(${camera.position.x.toFixed(1)},${camera.position.z.toFixed(1)}), direction(${cellToCamera.x.toFixed(2)},${cellToCamera.z.toFixed(2)}), base=${baseDeg} , spawn=${spawnDeg} `);
 targetRotation = spawnAngle;
 arrayaAvatar._targetRotation = spawnAngle;
 }

 const placement = computeArrayaPlacement(pos, arrayaHover, targetRotation, ARRAYA_BASE_SCALE);
 arrayaAvatar.group.position.copy(placement);
 arrayaAvatar.group.scale.set(ARRAYA_BASE_SCALE, ARRAYA_BASE_SCALE, ARRAYA_BASE_SCALE);
 arrayaAvatar.group.rotation.y = targetRotation;

 arrayaAvatar._lastCellKey = currentCellKey;
 arrayaAvatar._lastCell = {hasArray: true};
 } else {
 // Celli is visible - continuous camera tracking
 const arrScale = arrayVoxelScale(arr);
 const perch = avatarPerchOffset(arrScale);
 celli.position.copy(pos).add(new THREE.Vector3(0, perch, 0));
 celli.visible=true;
 celli.scale.set(0.7, 0.7, 0.7); // Smaller Celli
 
 // Celli continuously faces camera
 const celliToCamera = new THREE.Vector3().subVectors(camera.position, celli.position);
 celliToCamera.y = 0; // Project to horizontal plane
 celliToCamera.normalize();
 const targetAngle = Math.atan2(celliToCamera.x, celliToCamera.z);
 celli.rotation.y = targetAngle;
 
 arrayaAvatar._lastCellKey = currentCellKey;
 arrayaAvatar._lastCell = {hasArray: false};
 }
 }
 }

 let swapAnimating = false; // Guard against overlapping swap animations
 
 function animateAvatarSwap(fromAvatar, toAvatarOrFactory, cellPos){
 if(swapAnimating){
 console.log('[AVATAR] Swap already in progress, skipping');
 return;
 }
 swapAnimating = true;
 console.log('[AVATAR] animateAvatarSwap called', {from: fromAvatar.name || 'Celli', to: toAvatarOrFactory.group?.name || 'Celli'});

 try{
 const selState = Store.getState().selection;
 const arraysState = Store.getState().arrays;
 const activeArr = selState?.arrayId != null ? arraysState?.[selState.arrayId] : null;
 const swapScale = activeArr ? arrayVoxelScale(activeArr) : 1;
 const perchCelli = avatarPerchOffset(swapScale);
 const perchArraya = clampedScaleOffset(swapScale, 0.8);
 // Magical swirl/spin/shrink animation
 const startPos = fromAvatar.position.clone();
 const startScale = fromAvatar.scale?.clone() || new THREE.Vector3(1,1,1);
 const startRot = fromAvatar.rotation?.y || 0;
 const isCelliFrom = (fromAvatar === celli);
 const isArrayaTo = (toAvatarOrFactory.group != null);
 const toAvatar = toAvatarOrFactory.group || toAvatarOrFactory;
 const isCelliTo = (toAvatar === celli);
 const finalTargetScale = isCelliTo ? 0.7 : ARRAYA_BASE_SCALE;
 
 let t0 = null;
 const dur = 400; // 400ms for smooth magical swap
 
 const swapFrame = (ts)=>{
 if(t0 == null) t0 = ts;
 const elapsed = ts - t0;
 const u = Math.min(1, elapsed / dur);
 
 if(u % 0.1 < 0.02) console.log(`[AVATAR] Swap u=${u.toFixed(2)}`);
 
 // First half: shrink and spin out
 if(u <= 0.5){
 const t = u * 2; // 0 to 1 in first half
 const scale = startScale.x * (1 - (0.7 * t)); // Shrink to 30%
 const spin = startRot + (Math.PI * 4 * t); // 4 full rotations
 const rise = 0.35 * Math.sin(t * Math.PI); // Hop up
 fromAvatar.scale.set(scale, scale, scale);
 fromAvatar.rotation.y = spin;
 fromAvatar.position.x = startPos.x;
 fromAvatar.position.y = startPos.y + rise;
 fromAvatar.position.z = startPos.z;
 fromAvatar.visible = true;
 toAvatar.visible = false;
 } else {
 // Second half: grow and spin in with new avatar
 fromAvatar.visible = false;
 const t = (u - 0.5) * 2; // 0 to 1 in second half
 
 toAvatar.visible = true;
 const scale = finalTargetScale * (0.3 + (0.7 * t)); // Grow from 30% to 100%
 const targetRotation = arrayaAvatar._targetRotation || startRot;
 const spin = targetRotation + Math.PI * 2 - (Math.PI * 2 * t); // Reverse spin
 const rise = 0.35 * Math.sin((1-t) * Math.PI);
 toAvatar.scale.set(scale, scale, scale);

 // Position matching updateAvatars logic - simple direct positioning
 const targetY = isArrayaTo ? 0.8 : 0.7;
 if(isArrayaTo){
 const placement = computeArrayaPlacement(cellPos, targetY, spin, scale);
 toAvatar.position.copy(placement);
 toAvatar.position.y += rise;
 } else {
 const targetPos = cellPos.clone().add(new THREE.Vector3(0, targetY, 0));
 toAvatar.position.x = targetPos.x;
 toAvatar.position.y = targetPos.y + rise;
 toAvatar.position.z = targetPos.z;
 }
 toAvatar.rotation.y = spin;
 }
 
 if(u < 1){
 requestAnimationFrame(swapFrame);
 } else {
 console.log('[AVATAR] Swap complete');
 // Final cleanup
 fromAvatar.visible = false;
 fromAvatar.scale.copy(startScale);
 toAvatar.visible = true;
 toAvatar.scale.set(finalTargetScale, finalTargetScale, finalTargetScale);
 
 // Final position matching updateAvatars logic
 const targetY = isArrayaTo ? perchArraya : perchCelli;
 if(isArrayaTo){
 const finalRotation = arrayaAvatar._targetRotation ?? toAvatar.rotation.y;
 const placement = computeArrayaPlacement(cellPos, targetY, finalRotation, finalTargetScale);
 toAvatar.position.copy(placement);
 toAvatar.rotation.y = finalRotation;
 } else {
 toAvatar.position.copy(cellPos).add(new THREE.Vector3(0, targetY, 0));
 }
 swapAnimating = false;
 }
 };
 requestAnimationFrame(swapFrame);
 }catch(e){
 console.warn('Avatar swap animation failed:', e);
 swapAnimating = false;
 // Fallback: instant swap
 fromAvatar.visible = false;
 const toAvatar = toAvatarOrFactory.group || toAvatarOrFactory;
 toAvatar.visible = true;
 const finalScale = (toAvatar === celli) ? 0.7 : ARRAYA_BASE_SCALE;
 toAvatar.scale?.set(finalScale, finalScale, finalScale);
 }
 }

 function addTimedPreview(arr,anchor,ticks){
 const pos=worldPos(arr,anchor.x,anchor.y,anchor.z);
 const preview=new THREE.Mesh(new THREE.BoxGeometry(1.2,1.2,1.2), new THREE.MeshBasicMaterial({color:0x22c55e,transparent:true,opacity:0.4}));
 preview.position.copy(pos); scene.add(preview);
 let t=0; const loop=()=>{
 t=(t+1)%ticks; const s=Math.sin((t/ticks)*Math.PI*2)*0.3;
 preview.position.y=pos.y+s; preview.rotation.y=t*0.05;
 if(t===0) scene.remove(preview); else requestAnimationFrame(loop);
 }; loop();
 }
 // Jump physics
 let jumpVelocity=0;
 let jumpBudget={max:1, remaining:1, source:'avatar'};
 let physicsSpawnPos = null; // Store spawn position for respawn on fall
 let landingSquashTime = 0; // Track landing squash animation
 let anticipationSquashTime = 0; // Track jump anticipation squash

 function setPhysicsSpawn(pos){
 if(pos && Number.isFinite(pos.x) && Number.isFinite(pos.y) && Number.isFinite(pos.z)){
 physicsSpawnPos = { x: pos.x, y: pos.y, z: pos.z };
 } else {
 physicsSpawnPos = null;
 }
 }

 function computeJumpBudget(arrOverride=null){
 // In debug mode, allow infinite jumps
 const debugMode = !!Store.getState().scene?.physicsDebugAll;
 if(debugMode){
 return {max: Number.POSITIVE_INFINITY, source: 'debug'};
 }
 const avatarCfg = Store.getState().avatarPhysics || {};
 let max = Math.max(1, Math.round(Number(avatarCfg.jumpCount ?? 1)) || 1);
 let source = 'avatar';
 try{
 const sel = Store.getState().selection;
 const arr = arrOverride || (sel?.arrayId ? Store.getState().arrays[sel.arrayId] : null);
 if(arr){
 const arrJump = arr?.params?.physics?.jumpCount;
 if(Number.isFinite(arrJump) && arrJump > 0){
 max = Math.max(1, Math.round(arrJump));
 source = `array:${arr.id}`;
 }
 }
 }catch{}
 return {max, source};
 }
 function resetJumpBudget(arrOverride=null){
 const base = computeJumpBudget(arrOverride);
 jumpBudget = { ...base, remaining: base.max };
 }
 function consumeJump(){
 if(jumpBudget.remaining > 0){
 jumpBudget.remaining -= 1;
 }
 }
 function applyArrayFloorClamp(body){
 try{
 const sel = Store.getState().selection;
 if(!sel?.arrayId) return;
 const arr = Store.getState().arrays[sel.arrayId];
 if(!arr?.params?.physics?.boundByArrayFloor) return;
 if(!body) return;
 const floorCenter = worldPos(arr, 0, arr.size.y - 1, 0);
 const floorY = floorCenter.y - 0.5;
 const translation = body.translation();
 if(!Number.isFinite(translation.y)) return;
 if(translation.y < floorY){
 body.setTranslation({x: translation.x, y: floorY, z: translation.z}, true);
 const vel = body.linvel();
 if(vel.y < 0){
 body.setLinvel({x: vel.x, y: 0, z: vel.z}, true);
 }
 cachedPlayerPos.set(translation.x, floorY, translation.z);
 }
 }catch(e){
 console.warn('Floor clamp failed', e);
 }
 }
 
 function handleJump(){
 // --- START: ZIPLINE DETACHMENT ---
 if(ziplineState.active){
 ziplineState.active = false;
 ziplineState.velocity = 0;
 jumpVelocity = 4; // Give a small hop off the line
 console.log('[PHYSICS] Detached from zipline');
 return;
 }
 // --- END: ZIPLINE DETACHMENT ---

 // Don't modify wasGroundedLastFrame here - it's managed by the landing detection in animate()
 if(RAPIER && rapierWorld && playerBody){
 try {
 // Check if grounded using raycast for proper platformer support
 const translation = playerBody.translation();
 const vel = playerBody.linvel();
 
 // Validate position before raycasting
 if(!Number.isFinite(translation.x) || !Number.isFinite(translation.y) || !Number.isFinite(translation.z)){
 console.warn('[PHYSICS] Invalid player position for jump check');
 return;
 }
 
 // Raycast downward from player position to detect ground/platforms
 const ray = new RAPIER.Ray(translation, {x: 0, y: -1, z: 0});
 const maxToi = 0.6; // Check 0.6 units below (player capsule radius is 0.5)
 const solid = true;
 
 const hit = rapierWorld.castRay(ray, maxToi, solid);
 const grounded = hit !== null && Math.abs(vel.y) < 1.0;
 
 console.log(`[PHYSICS] Jump check - grounded=${grounded}, rayHit=${hit !== null}, y=${translation.y.toFixed(2)}, vel.y=${vel.y.toFixed(2)}`);
 
 if(grounded){
 if(jumpBudget.remaining <= 0){
 return;
 }
 consumeJump();
 anticipationSquashTime = 1;
 setTimeout(() => {
 if(playerBody && rapierWorld){
 const currentVel = playerBody.linvel();
 playerBody.setLinvel({x: currentVel.x, y: 8.0, z: currentVel.z}, true);
 jumpVelocity = 8;
 anticipationSquashTime = 0;
 console.log('[PHYSICS] Jump velocity set! vel.y=8.0');
 }
 }, 50);
 } else if(jumpBudget.remaining > 0){
 consumeJump();
 const currentVel = playerBody.linvel();
 playerBody.setLinvel({x: currentVel.x, y: 8.0, z: currentVel.z}, true);
 jumpVelocity = 8;
 anticipationSquashTime = 0;
 }
 } catch(e) {
 console.warn('Jump failed:', e);
 }
 } else {
 console.warn('[PHYSICS] No rapierWorld or playerBody for jump');
 }
 }

 function updateValueSprite(arr, x, y, z, cell){
 // Skip updating sprites if array is being deleted
 if(arr?._deleting) return;
 
 const key=`${arr.id}:${x},${y},${z}`;
 
 // Remove old sprite if exists
 const oldSprite=valueSprites.get(key);
 if(oldSprite){ try{ unmarkBillboard(oldSprite); }catch{} oldSprite.parent?.remove(oldSprite); oldSprite.material.map?.dispose(); oldSprite.material.dispose(); valueSprites.delete(key); }
 
 // Create new sprite if cell has content (prefer displayText if available)
 const displayText = cell.meta?.displayText;
 const actualText = displayText !== undefined ? displayText : cell.value;
 if(actualText!=='' && actualText!==null && actualText!==undefined){
 const text=String(actualText).slice(0,12); // allow longer text
 const isFormula=!!cell.formula;
 const sprite=makeValueSprite(text, isFormula);
 const pos=localPos(arr,x,y,z);
 // Place on the same face used by occlusion/arrow mapping
 const face = getPreferredFacing(arr);
 const off = SPRITE_FACE_OFFSET * face.sign;
 const dx = (face.axis===0) ? off : 0;
 const dy = (face.axis===1) ? off : 0;
 const dz = (face.axis===2) ? off : 0;
 sprite.position.copy(pos).add(new THREE.Vector3(dx,dy,dz));
 // Parent to frame for unified movement
 if(arr._frame) arr._frame.add(sprite); else scene.add(sprite);
 try{ sprite.material.depthTest = true; sprite.material.depthWrite = false; }catch{}
 valueSprites.set(key, sprite);
 } else { valueSprites.delete(key); }
 }

 // Deletion explosion effect
 const deleteEffects = [];
 const pendingDatafallDeletes = new Map(); // arrId -> {count:number, finished:boolean}
 const nowMs = ()=> (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
 let deleteInteractionLock = false;
 let deletionControlState = null;
 function clearDeletionDeadline(rec){
 if(rec && rec.deadlineTimer){
 try{ clearTimeout(rec.deadlineTimer); }catch{}
 rec.deadlineTimer = null;
 }
 }
 function scheduleDeletionDeadline(arrId, delay=30000){
 try{
 const key = normalizeArrayId(arrId);
 const rec = pendingDatafallDeletes.get(key);
 if(!rec) return;
 clearDeletionDeadline(rec);
 rec.deadlineTimer = setTimeout(()=>{
 try{ maybeFinalizeDeletion(arrId, true); }catch{}
 }, delay);
 rec.lastActive = nowMs();
 pendingDatafallDeletes.set(key, rec);
 }catch{}
 }
 function discardDeleteEffectsForArray(arrId){
 for(let i = deleteEffects.length - 1; i >= 0; i--){
 const eff = deleteEffects[i];
 if(!eff || eff.sourceArrId !== arrId) continue;
 try{
 if(eff.group){
 eff.group.parent?.remove(eff.group);
 if(typeof eff.group.traverse === 'function'){
 eff.group.traverse(obj=>{
 if(obj?.material){
 try{ obj.material.map?.dispose?.(); }catch{}
 try{ obj.material.dispose?.(); }catch{}
 }
 if(obj?.geometry){ try{ obj.geometry.dispose?.(); }catch{} }
 });
 }
 }
 if(Array.isArray(eff.clones)){
 eff.clones.forEach(c=>{
 try{ if(c?.sprite){ unmarkBillboard(c.sprite); c.sprite.parent?.remove(c.sprite); c.sprite.material?.map?.dispose?.(); c.sprite.material?.dispose?.(); } }catch{}
 });
 }
 }catch{}
 deleteEffects.splice(i, 1);
 }
 }
 const DATAFALL_COLORS = {
 syntax: '#111827',
 function: '#111827',
 punctuation: '#111827',
 string: '#16a34a',
 range: '#f59e0b',
 address: '#f59e0b',
 number: '#1d4ed8',
 binary: '#2563eb',
 unicode: '#a855f7'
 };
 function cssColor(color){
 if(typeof color === 'number'){ return `#${color.toString(16).padStart(6,'0')}`; }
 return color || '#ffffff';
 }
 function tokenizeFormulaForDatafall(raw){
 const out = [];
 if(!raw){ return out; }
 const formula = String(raw);
 const regex = /(=[A-Z_0-9]+)|(@\[[^\]]+\])|("[^"\\]*(?:\\.[^"\\]*)*")|(\()|(\))|(,)|([A-Z]+\d+)|(-?\d+(?:\.\d+)?)/gi;
 let lastIndex = 0;
 let match;
 while((match = regex.exec(formula))){
 if(match.index > lastIndex){
 const text = formula.slice(lastIndex, match.index);
 if(text){ out.push({ text, tokenKind: 'syntax', color: DATAFALL_COLORS.syntax }); }
 }
 const text = match[0];
 let tokenKind = 'syntax';
 if(match[1]) tokenKind = 'function';
 else if(match[2]) tokenKind = 'range';
 else if(match[3]) tokenKind = 'string';
 else if(match[4] || match[5] || match[6]) tokenKind = 'punctuation';
 else if(match[7]) tokenKind = 'address';
 else if(match[8]) tokenKind = 'number';
 out.push({ text, tokenKind, color: DATAFALL_COLORS[tokenKind] || DATAFALL_COLORS.syntax });
 lastIndex = regex.lastIndex;
 }
 if(lastIndex < formula.length){
 const tail = formula.slice(lastIndex);
 if(tail){ out.push({ text: tail, tokenKind: 'syntax', color: DATAFALL_COLORS.syntax }); }
 }
 return out;
 }
 function classifyRawValue(raw){
 const text = String(raw ?? '');
 const trimmed = text.trim();
 if(trimmed === '') return { text, tokenKind: 'syntax', color: DATAFALL_COLORS.syntax };
 const numeric = !Number.isNaN(Number(trimmed));
 if(numeric){ return { text: trimmed, tokenKind: 'number', color: DATAFALL_COLORS.number }; }
 if(/^".*"$/.test(trimmed)) return { text: trimmed, tokenKind: 'string', color: DATAFALL_COLORS.string };
 return { text, tokenKind: 'syntax', color: DATAFALL_COLORS.syntax };
 }
 function colorForCellVisual(arrId, cell){
 try{
 if(!cell) return baseHexForTypeKey('empty');
 if(cell.meta && cell.meta.color) return cell.meta.color;
 const key = `${arrId}:${cell.x},${cell.y},${cell.z}`;
 const emitted = !!(Store.getState().sourceByCell && Store.getState().sourceByCell.get && Store.getState().sourceByCell.get(key));
 const hasValue = (cell.value!=='' && cell.value!==null && cell.value!==undefined);
 if(cell.formula) return baseHexForTypeKey('formula');
 if(emitted) return baseHexForTypeKey('emitted');
 return hasValue ? baseHexForTypeKey('value') : baseHexForTypeKey('empty');
 }catch{ return baseHexForTypeKey('empty'); }
 }
 function lockDeletionInteractions(){
 // Camera movement should NOT be blocked during delete animations
 deleteInteractionLock = true;
 }
 function releaseDeletionInteractions(){
 // Camera movement should NOT be blocked during delete animations
 deleteInteractionLock = false;
 }
 function startAxisFall(arr, onDone){
 try{
 // First: shrink the frame mesh itself, but leave axis labels at full size
 if(arr._frame){
 const frame = arr._frame;
 const startScale = frame.scale.clone();
 const dur = 600;
 let t0 = null;
 // Store initial label positions before shrinking
 const labels = (arr?.labels||[]).filter(Boolean);
 const labelInitialWorldPos = new Map();
 labels.forEach(label=>{
 try{
 labelInitialWorldPos.set(label, label.getWorldPosition(new THREE.Vector3()));
 }catch{}
 });
 
 const shrinkFrame = (ts)=>{
 if(t0 == null) t0 = ts;
 const elapsed = ts - t0;
 const u = Math.min(1, elapsed / dur);
 const e = 1 - Math.pow(1-u, 3);
 const scale = 1 - (0.9 * e);
 frame.scale.copy(startScale).multiplyScalar(Math.max(0.01, scale));
 // Keep labels at original size by counter-scaling them
 labels.forEach(label=>{
 try{
 const counterScale = 1 / Math.max(0.01, scale);
 if(label.scale) label.scale.set(counterScale, counterScale, counterScale);
 }catch{}
 });
 if(u < 1){
 requestAnimationFrame(shrinkFrame);
 } else {
 // Frame shrunk, remove it and start axis label fall
 try{
 frame.parent?.remove(frame);
 frame.traverse(obj=>{
 if(obj?.geometry) obj.geometry.dispose?.();
 if(obj?.material){
 obj.material.map?.dispose?.();
 obj.material.dispose?.();
 }
 });
 }catch{}
 startLabelFall();
 }
 };
 requestAnimationFrame(shrinkFrame);
 } else {
 startLabelFall();
 }

 function startLabelFall(){
 const labels = (arr?.labels||[]).filter(Boolean);
 if(!labels.length){ if(typeof onDone==='function') onDone(); return; }
 const actors = [];
 labels.forEach(label=>{
 try{ if(label.userData?.billboard) unmarkBillboard(label); }catch{}
 try{
 const worldPos = label.getWorldPosition(new THREE.Vector3());
 const worldQuat = label.getWorldQuaternion(new THREE.Quaternion());
 // Reset scale to 1 when converting to world space
 const worldScale = new THREE.Vector3(1,1,1);
 label.parent?.remove(label);
 label.position.copy(worldPos);
 label.quaternion.copy(worldQuat);
 label.scale.copy(worldScale);
 scene.add(label);
 actors.push({
 mesh: label,
 vel: new THREE.Vector3((Math.random()-0.5)*0.02, Math.random()*0.04 + 0.02, (Math.random()-0.5)*0.02),
 rot: new THREE.Vector3((Math.random()-0.5)*0.06, (Math.random()-0.5)*0.06, (Math.random()-0.5)*0.06),
 age: 0,
 life: 1100 + Math.random()*500
 });
 }catch{}
 });
 arr.labels = [];
 try{ if(arr._frame?.userData) arr._frame.userData.grab = null; }catch{}
 if(!actors.length){ if(typeof onDone==='function') onDone(); return; }
 deleteEffects.push({
 phase:'axisFall',
 sourceArrId: arr.id,
 labels: actors,
 onDone:()=>{
 actors.forEach(actor=>{
 try{ if(actor.mesh.userData?.billboard) unmarkBillboard(actor.mesh); }catch{}
 try{ actor.mesh.parent?.remove(actor.mesh); }catch{}
 try{ actor.mesh.material?.map?.dispose?.(); actor.mesh.material?.dispose?.(); }catch{}
 });
 if(typeof onDone==='function') onDone();
 }
 });
 }
 }catch{ if(typeof onDone==='function') onDone(); }
 }
 function maybeFinalizeDeletion(arrId, force=false){
 const key = normalizeArrayId(arrId);
 try{
 const rec = pendingDatafallDeletes.get(key);
 if(!rec){
 console.log(`DELETE: No record for array #${arrId}`);
 return;
 }
 console.log(`DELETE: maybeFinalize for array #${arrId}, finished:${rec.finished}, count:${rec.count}, force:${force}`);
 if(force){
 rec.finished = true;
 rec.count = 0;
 }
 if(!rec.finished || (rec.count|0) > 0){
 if(force){
 // Even if counts are stuck, force completion once deadline hits
 rec.finished = true;
 rec.count = 0;
 } else {
 return;
 }
 }
 if(rec.finalizing){
 console.log(`DELETE: Already finalizing array #${arrId}`);
 return;
 }
 console.log(`DELETE: Starting finalization for array #${arrId}`);
 rec.finalizing = true;
 clearDeletionDeadline(rec);
 pendingDatafallDeletes.set(key, rec);
 discardDeleteEffectsForArray(arrId);
 const finalizeNow = ()=>{
 console.log(`DELETE: Final cleanup for array #${arrId}`);
 pendingDatafallDeletes.delete(key);
 unmarkArrayDeleting(arrId);
 try{ Actions.deleteArray(arrId); }catch{}
 releaseDeletionInteractions();
 };
 const store = Store.getState();
 const arr = store.arrays?.[arrId] ?? store.arrays?.[key];
 if(arr && !force){
 console.log(`DELETE: Starting axis fall for array #${arrId}`);
 startAxisFall(arr, finalizeNow);
 } else {
 console.log(`DELETE: Immediate finalization for array #${arrId} (force:${force})`);
 finalizeNow();
 }
 }catch{ unmarkArrayDeleting(arrId); releaseDeletionInteractions(); }
 }

 function makeCharSprite(ch, color = '#ffffff'){
 const canvas = document.createElement('canvas');
 const ctx = canvas.getContext('2d');
 const fs = 18, pad = 4;
 ctx.font = `600 ${fs}px 'Roboto Mono', monospace`;
 const w = Math.max(12, Math.ceil(ctx.measureText(ch).width) + pad*2);
 const h = fs + pad*2;
 canvas.width = w; canvas.height = h;
 ctx.clearRect(0,0,w,h);
 ctx.fillStyle = cssColor(color);
 ctx.font = `600 ${fs}px 'Roboto Mono', monospace`;
 ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
 ctx.fillText(ch, w/2, h/2);
 const tex = new THREE.CanvasTexture(canvas);
 tex.colorSpace = THREE.SRGBColorSpace;
 const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false, opacity: 1 });
 const spr = new THREE.Sprite(mat);
 spr.scale.set(0.25, 0.18, 1);
 spr.renderOrder = 2100;
 return spr;
 }
 function spawnCellDatafallAt(position, cell, parentArrId){
 const arrKey = normalizeArrayId(parentArrId);
 
 // HIDE the original cell AS this animation starts - this is the magic moment!
 try{
 if(cell && cell.x != null && cell.y != null && cell.z != null){
 const arr = Store.getState().arrays[parentArrId];
 if(arr){
 // Hide value sprite immediately
 const spriteKey = `${parentArrId}:${cell.x},${cell.y},${cell.z}`;
 const sprite = valueSprites.get(spriteKey);
 if(sprite) sprite.visible = false;
 
 // Find and hide this cell in chunk's index2cell system
 Object.values(arr.chunks||{}).forEach(chunk=>{
 try{
 if(!chunk.index2cell) return;
 const idx = chunk.index2cell.findIndex(c => c && c.x === cell.x && c.y === cell.y && c.z === cell.z);
 if(idx >= 0){
 const zeroMatrix = new THREE.Matrix4();
 zeroMatrix.makeScale(0, 0, 0); // Completely invisible
 
 // Hide in LOD1 instanced mesh
 if(chunk.meshLOD1 && chunk.meshLOD1.isInstancedMesh){
 chunk.meshLOD1.setMatrixAt(idx, zeroMatrix);
 chunk.meshLOD1.instanceMatrix.needsUpdate = true;
 }
 // Hide in LOD2 instanced mesh
 if(chunk.meshLOD2 && chunk.meshLOD2.isInstancedMesh){
 chunk.meshLOD2.setMatrixAt(idx, zeroMatrix);
 chunk.meshLOD2.instanceMatrix.needsUpdate = true;
 }
 // Hide in shell instanced mesh
 if(chunk.meshShell && chunk.meshShell.isInstancedMesh){
 chunk.meshShell.setMatrixAt(idx, zeroMatrix);
 chunk.meshShell.instanceMatrix.needsUpdate = true;
 }
 }
 }catch{}
 });
 
 // Also hide in legacy chunkMeshes system
 chunkMeshes.forEach((mesh, key)=>{
 if(String(key).startsWith(`${parentArrId}:`)){
 try{
 const chunkKey = key.split(':')[1];
 const chunk = arr.chunks[chunkKey];
 if(chunk && chunk.cells){
 const cellIdx = chunk.cells.findIndex(c => c.x === cell.x && c.y === cell.y && c.z === cell.z);
 if(cellIdx >= 0){
 const m = new THREE.Matrix4();
 m.makeScale(0, 0, 0);
 mesh.setMatrixAt(cellIdx, m);
 mesh.instanceMatrix.needsUpdate = true;
 }
 }
 }catch{}
 }
 });
 }
 }
 }catch{}
 
 try{
 try{
 const rec = pendingDatafallDeletes.get(arrKey) || {count:0, finished:false, finalizing:false, deadlineTimer:null};
 markArrayDeleting(parentArrId);
 rec.count = (rec.count||0) + 1;
 rec.arrId = rec.arrId ?? parentArrId;
 rec.startedAt = rec.startedAt ?? nowMs();
 rec.lastActive = nowMs();
 pendingDatafallDeletes.set(arrKey, rec);
 scheduleDeletionDeadline(parentArrId);
 }catch{}
 const group = new THREE.Group();
 group.userData.kind='microCollapse';
 scene.add(group);
 const colorHex = cssColor(colorForCellVisual(parentArrId, cell));
 const coreColor = new THREE.Color(colorHex);
 const shellColor = coreColor.clone().lerp(new THREE.Color(0xffffff), 0.45);
 const coreMat = new THREE.MeshBasicMaterial({ color: coreColor, transparent:true, opacity:0.95, depthTest:true, depthWrite:true });
 const shellMat = new THREE.MeshBasicMaterial({ color: shellColor, transparent:true, opacity:0.38, depthTest:true, depthWrite:false });
 const core = new THREE.Mesh(GEO_VOXEL, coreMat);
 const shell = new THREE.Mesh(GEO_SHELL, shellMat);
 core.renderOrder = 2100;
 shell.renderOrder = 2101;
 group.add(core);
 group.add(shell);
 
 // Add the cell's value sprite to the shrinking group so text shrinks with cell
 const spriteKey = `${parentArrId}:${cell?.x},${cell?.y},${cell?.z}`;
 const originalSprite = valueSprites.get(spriteKey);
 if(originalSprite && cell){
 // Detach from parent and add to this animation group
 const spriteWorldPos = new THREE.Vector3();
 originalSprite.getWorldPosition(spriteWorldPos);
 originalSprite.parent?.remove(originalSprite);
 originalSprite.position.set(0, 0, 0.6); // Position relative to cell center
 group.add(originalSprite);
 originalSprite.visible = true; // Make visible since it's now part of the animation
 }
 
 group.position.copy(position);
 const dur=420; let t0;
 const step=(ts)=>{
 if(t0==null) t0=ts;
 const u=Math.min(1,(ts-t0)/dur);
 const e=1-Math.pow(1-u,4);
 const scale = 1 - (0.55*e);
 core.scale.setScalar(Math.max(0.0001, scale));
 shell.scale.setScalar(Math.max(0.0001, scale * 1.04));
 core.material.opacity = 0.95*(1-e)+0.08;
 shell.material.opacity = 0.38*(1-e)+0.05;
 if(u<1){
 requestAnimationFrame(step);
 } else {
 try{
 scene.remove(group);
 core.material?.dispose?.();
 shell.material?.dispose?.();
 }catch{}
 const hasContent = !!(cell && ((cell.formula && String(cell.formula).length) || (cell.value!=='' && cell.value!==null && cell.value!==undefined)));
 if(!hasContent){
 try{
 // Clean up sprite even for empty cells
 if(cell && cell.x != null && cell.y != null && cell.z != null){
 const spriteKey = `${parentArrId}:${cell.x},${cell.y},${cell.z}`;
 const sprite = valueSprites.get(spriteKey);
 if(sprite){
 try{ unmarkBillboard(sprite); }catch{}
 sprite.parent?.remove(sprite);
 sprite.material?.map?.dispose?.();
 sprite.material?.dispose?.();
 valueSprites.delete(spriteKey);
 }
 }
 const rec = pendingDatafallDeletes.get(arrKey);
 if(rec){
 rec.count = Math.max(0, (rec.count||0) - 1);
 rec.arrId = rec.arrId ?? parentArrId;
 rec.lastActive = nowMs();
 pendingDatafallDeletes.set(arrKey, rec);
 maybeFinalizeDeletion(parentArrId);
 }
 }catch{}
 return;
 }
 const effGroup=new THREE.Group();
 scene.add(effGroup);
 const hasFormula = !!(cell && typeof cell.formula === 'string' && cell.formula.trim().length);
 const displayText = hasFormula ? String(cell.formula) : String(cell?.value ?? '');
 const baseToken = hasFormula ? { tokenKind:'formula', color: DATAFALL_COLORS.syntax } : classifyRawValue(displayText);
 const baseColor = baseToken.color || DATAFALL_COLORS.syntax;
 const sp = makeCharSprite(displayText, baseColor);
 sp.position.copy(position);
 effGroup.add(sp);
 const vel = new THREE.Vector3(0,0.022,0);
 deleteEffects.push({
 phase:'datafall',
 sourceArrId: parentArrId,
 group:effGroup,
 particles:[{
 kind:'value',
 cell,
 text:displayText,
 sprite:sp,
 vel,
 age:0,
 life:420,
 rot:0,
 color: baseColor,
 tokenKind: baseToken.tokenKind
 }],
 onDone:()=>{
 try{
 // Clean up the value sprite now that animation is complete
 if(cell && cell.x != null && cell.y != null && cell.z != null){
 const spriteKey = `${parentArrId}:${cell.x},${cell.y},${cell.z}`;
 const sprite = valueSprites.get(spriteKey);
 if(sprite){
 try{ unmarkBillboard(sprite); }catch{}
 sprite.parent?.remove(sprite);
 sprite.material?.map?.dispose?.();
 sprite.material?.dispose?.();
 valueSprites.delete(spriteKey);
 }
 }
 const rec = pendingDatafallDeletes.get(arrKey);
 if(rec){
 rec.count = Math.max(0, (rec.count||0) - 1);
 rec.arrId = rec.arrId ?? parentArrId;
 rec.lastActive = nowMs();
 pendingDatafallDeletes.set(arrKey, rec);
 scheduleDeletionDeadline(parentArrId);
 maybeFinalizeDeletion(parentArrId);
 }
 }catch{}
 }
 });
 }
 };
 requestAnimationFrame(step);
 }catch{}
 }
 function startDatafallDelete(arr){
 try{
 // First, ensure meshes exist for animation
 try{
 if(!arr._frame) renderArray(arr);
 Object.values(arr.chunks||{}).forEach(ch=>{
 ch.ensureMesh?.();
 ch.setLOD?.(1);
 rehydrateChunkInstances(arr, ch);
 });
 }catch{}
 
 // Don't hide anything upfront - cells and labels stay visible
 // Each cell will hide AS its individual animation spawns
 // Labels will hide during the final axis fall
 
 // Mark as deleting to prevent any further re-rendering
 arr._deleting = true;
 
 if(!deleteInteractionLock) lockDeletionInteractions();
 const items=[];
 try{
 // Get all cells that exist in chunks (have been rendered)
 const cellsWithMeshes = [];
 Object.values(arr.chunks||{}).forEach(ch=>{
 (ch.cells||[]).forEach(c=>{ cellsWithMeshes.push({x:c.x,y:c.y,z:c.z}); });
 });
 // Also include ALL cells in bounds for complete coverage
 for(let z=0; z<arr.size.z; z++){
 for(let y=0; y<arr.size.y; y++){
 for(let x=0; x<arr.size.x; x++){
 const exists = cellsWithMeshes.some(c=> c.x===x && c.y===y && c.z===z);
 if(!exists) items.push({x,y,z});
 }
 }
 }
 // Merge chunks cells with remaining cells
 items.push(...cellsWithMeshes);
 // Shuffle for random deletion order
 for(let i=items.length-1; i>0; i--){
 const j = Math.floor(Math.random()*(i+1));
 const tmp = items[i];
 items[i] = items[j];
 items[j] = tmp;
 }
 }catch{}
 let idx=0;
 // One cell at a time - timing scaled for magical effect
 const waveSize = 1;
 // Scale timing based on total cells for best feel
 const totalCells = items.length;
 const waveDelay = totalCells <= 20 ? 160 : totalCells <= 100 ? 100 : 60; // Slower for small arrays
 const arrKey = normalizeArrayId(arr.id);
 pendingDatafallDeletes.set(arrKey, {count:0, finished:false, finalizing:false, arrId: arr.id, startedAt: nowMs(), lastActive: nowMs(), deadlineTimer:null});
 markArrayDeleting(arr.id);
 scheduleDeletionDeadline(arr.id);
 if(items.length===0){
 try{
 const rec=pendingDatafallDeletes.get(arrKey);
 if(rec){ rec.finished=true; rec.finishedAt = nowMs(); rec.lastActive = nowMs(); pendingDatafallDeletes.set(arrKey, rec); }
 }catch{}
 scheduleDeletionDeadline(arr.id, 1000);
 maybeFinalizeDeletion(arr.id);
 return;
 }
 const spawnWave=()=>{
 const S=Store.getState();
 if(!S.arrays[arr.id]){
 console.warn('DELETE: Array removed mid-wave, finalizing');
 try{
 const rec=pendingDatafallDeletes.get(arrKey)||{count:0};
 rec.finished=true;
 rec.finishedAt = nowMs();
 rec.arrId = rec.arrId ?? arr.id;
 rec.lastActive = nowMs();
 pendingDatafallDeletes.set(arrKey, rec);
 scheduleDeletionDeadline(arr.id, 500);
 maybeFinalizeDeletion(arr.id);
 }catch{}
 return;
 }
 for(let k=0;k<waveSize && idx<items.length;k++,idx++){
 const c=items[idx];
 let cell=null;
 try{
 cell = Formula.getCell({arrId:arr.id,x:c.x,y:c.y,z:c.z});
 }catch{}
 // Sprite and mesh hiding is now handled inside spawnCellDatafallAt as animation starts
 const pos = cellWorldPos(arr, c.x, c.y, c.z);
 const hasContent = cell && ((cell.formula && String(cell.formula).length) || (cell.value!=='' && cell.value!==null && cell.value!==undefined));
 spawnCellDatafallAt(pos, cell? {...cell, arrId: arr.id, x:c.x, y:c.y, z:c.z } : null, arr.id);
 }
 const waveNum = Math.floor((idx-1) / waveSize) + 1;
 console.log(`DELETE: Wave ${waveNum} complete, processed ${idx}/${items.length} cells`);
 if(idx<items.length){
 setTimeout(spawnWave, waveDelay);
 } else {
 // All cells spawned
 console.log(`DELETE: All ${items.length} cells spawned for array #${arr.id}`);
 setTimeout(()=>{
 try{
 const rec=pendingDatafallDeletes.get(arrKey)||{count:0};
 console.log(`DELETE: Marking finished for array #${arr.id}, pending count: ${rec.count}`);
 rec.finished=true;
 rec.finishedAt = nowMs();
 rec.arrId = rec.arrId ?? arr.id;
 rec.lastActive = nowMs();
 pendingDatafallDeletes.set(arrKey, rec);
 scheduleDeletionDeadline(arr.id, 3000);
 maybeFinalizeDeletion(arr.id);
 }catch{}
 }, 300);
 }
 };
 console.log(`DELETE: Starting wave deletion for array #${arr.id} with ${items.length} cells`);
 spawnWave();
 }catch(e){
 console.warn('startDatafallDelete failed', e);
 releaseDeletionInteractions();
 }
 }

 function updateDeleteEffects(dtMs){
 const grav = 0.004; // gentler gravity to emphasize slow drift cascade
 for(let i = deleteEffects.length - 1; i >= 0; i--){
 const eff = deleteEffects[i];
 eff.t += dtMs;

 // Datafall phase: value -> formula/text chunks -> char codes -> binary bits
 if(eff.phase === 'datafall'){
 const next = [];
 for(let k=0; k<eff.particles.length; k++){
 const pr = eff.particles[k];
 pr.age += dtMs;
 pr.vel.y -= 0.003;
 pr.sprite.position.add(pr.vel);
 pr.sprite.material.opacity = Math.max(0, 1 - Math.pow(pr.age/pr.life, 2));
 if(pr.rot && pr.sprite.material && pr.sprite.material.rotation !== undefined){ pr.sprite.material.rotation += pr.rot; }

 if(pr.age > pr.life){
 const pos = pr.sprite.position.clone();
 try{ unmarkBillboard(pr.sprite); }catch{}
 pr.sprite.parent?.remove(pr.sprite); pr.sprite.material?.map?.dispose?.(); pr.sprite.material?.dispose?.();

 let newTokens = [], nextKind = null;
 try{
 if(pr.kind === 'value'){
 const rawFormula = (pr.cell?.formula && String(pr.cell.formula).trim().startsWith('=')) ? String(pr.cell.formula) : '';
 const rawValue = !rawFormula ? String(pr.cell?.value ?? '') : '';
 if(rawFormula){
 newTokens = tokenizeFormulaForDatafall(rawFormula);
 } else {
 const classified = classifyRawValue(rawValue);
 if(classified.text){ newTokens = [classified]; }
 }
 nextKind = newTokens.length ? 'formula_chunk' : null;
 } else if(pr.kind === 'formula_chunk'){
 const text = String(pr.text ?? '');
 const tokenKind = pr.tokenKind || 'syntax';
 const trimmed = text.trim();
 if(trimmed===''){ nextKind = null; }
 else if(tokenKind === 'number' || (!Number.isNaN(Number(trimmed)) && trimmed!=='')){
 // Numbers go directly to binary in blue
 const n = parseInt(trimmed, 10) || 0;
 const bin = Math.abs(n).toString(2);
 const bits = bin.length ? Array.from(bin) : ['0'];
 newTokens = bits.map(bit=> ({ text: bit, tokenKind: 'binary_bit', color: DATAFALL_COLORS.binary }));
 nextKind = 'binary_bit';
 } else {
 // Strings and black text (syntax/function/punctuation) go to unicode in purple
 const plain = tokenKind === 'string' ? text.replace(/^\"|\"$/g,'') : text;
 const chars = Array.from(plain);
 newTokens = chars.map(ch=>{
 const code = ch.codePointAt(0);
 return { text: code != null ? String(code) : '', tokenKind: 'char_code', color: DATAFALL_COLORS.unicode, code, sourceChar: ch };
 }).filter(tok=> tok.text !== '');
 nextKind = 'char_code';
 }
 } else if(pr.kind === 'char_code'){
 // Unicode codes (purple) transform to binary in blue
 const n = (typeof pr.code === 'number' && Number.isFinite(pr.code)) ? pr.code : parseInt(pr.text ?? '0', 10);
 if(!Number.isFinite(n)) { continue; }
 const bin = Math.abs(n).toString(2) || '0';
 newTokens = Array.from(bin).map(bit=> ({ text: bit, tokenKind: 'binary_bit', color: DATAFALL_COLORS.binary }));
 nextKind = 'binary_bit';
 } else { continue; }
 }catch{ continue; }

 if(!nextKind || !newTokens.length){ continue; }
 newTokens.forEach(token=>{
 const label = String(token.text ?? '');
 if(label==='') return;
 const color = token.color || pr.color || DATAFALL_COLORS.syntax;
 const sp = makeCharSprite(label, color);
 sp.position.copy(pos).add(new THREE.Vector3((Math.random()-0.5)*0.2, (Math.random())*0.2, (Math.random()-0.5)*0.2));
 const vel = new THREE.Vector3((Math.random()-0.5)*0.015, (Math.random())*0.02, (Math.random()-0.5)*0.015);
 eff.group.add(sp);
 const baseLife = nextKind === 'binary_bit'
 ? 1000 + Math.random()*500
 : nextKind === 'char_code'
 ? 1100 + Math.random()*500
 : 900 + Math.random()*600;
 next.push({
 kind: nextKind,
 text: label,
 code: token.code !== undefined ? token.code : parseInt(label,10),
 sprite: sp,
 vel,
 age: 0,
 life: baseLife,
 rot:(Math.random()-0.5)*0.05,
 color,
 tokenKind: token.tokenKind || pr.tokenKind,
 sourceChar: token.sourceChar || pr.sourceChar
 });
 });
 } else {
 next.push(pr);
 }
 }
 eff.particles = next;
 if(eff.particles.length===0){ try{ const cb=eff.onDone; eff.group.parent?.remove(eff.group); if(typeof cb==='function') cb(); }catch{} deleteEffects.splice(i,1); }
 continue;
 }

 if(eff.phase === 'axisFall'){
 const nextLabels = [];
 for(let k=0; k<eff.labels.length; k++){
 const lbl = eff.labels[k];
 lbl.age += dtMs;
 lbl.vel.y -= 0.0025;
 lbl.mesh.position.add(lbl.vel);
 if(lbl.mesh.rotation){
 lbl.mesh.rotation.x += lbl.rot.x;
 lbl.mesh.rotation.y += lbl.rot.y;
 lbl.mesh.rotation.z += lbl.rot.z;
 }
 if(lbl.mesh.material && typeof lbl.mesh.material.opacity==='number'){
 lbl.mesh.material.opacity = Math.max(0, lbl.mesh.material.opacity - 0.01);
 }
 if(lbl.age < lbl.life){
 nextLabels.push(lbl);
 } else {
 try{ lbl.mesh.parent?.remove(lbl.mesh); }catch{}
 }
 }
 eff.labels = nextLabels;
 if(nextLabels.length===0){
 try{ eff.onDone?.(); }catch{}
 deleteEffects.splice(i,1);
 }
 continue;
 }

 // OLD HOVER/EXPLODE PHASE REMOVED - only datafall and axisFall are used
 if(eff.phase === 'hover' || eff.phase === 'explode'){
 // Cleanup and remove old unused effect immediately
 try{
 if(eff.group?.parent) eff.group.parent.remove(eff.group);
 if(eff.clones){
 eff.clones.forEach(c=>{
 try{
 if(c.sprite){
 c.sprite.parent?.remove(c.sprite);
 c.sprite.material?.map?.dispose?.();
 c.sprite.material?.dispose?.();
 }
 }catch{}
 });
 }
 if(eff.particles){
 eff.particles.forEach(pr=>{
 try{
 if(pr.sprite){
 try{ unmarkBillboard(pr.sprite); }catch{}
 pr.sprite.parent?.remove(pr.sprite);
 pr.sprite.material?.map?.dispose?.();
 pr.sprite.material?.dispose?.();
 }
 }catch{}
 });
 }
 }catch{}
 deleteEffects.splice(i, 1);
 continue;
 }
 }

 if(deleteInteractionLock){
 const now = nowMs();
 const finalizeIds = [];
 pendingDatafallDeletes.forEach((rec, key)=>{
 if(!rec) return;
 if(rec.finalizing) return;
 const arrId = rec.arrId ?? Number(key);
 if(rec.finished && ((rec.count|0) <= 0)){
 if(Number.isFinite(arrId)){ finalizeIds.push(arrId); }
 else {
 try{ releaseDeletionInteractions(); }catch{}
 clearDeletionDeadline(rec);
 pendingDatafallDeletes.delete(key);
 unmarkArrayDeleting(rec?.arrId ?? key);
 }
 return;
 }
 if(rec.finished){
 const idleSince = rec.finishedAt ?? rec.lastActive ?? rec.startedAt ?? now;
 if(now - idleSince > 2400){
 rec.count = 0;
 rec.lastActive = now;
 pendingDatafallDeletes.set(key, rec);
 if(Number.isFinite(arrId)){ finalizeIds.push(arrId); }
 else {
 try{ releaseDeletionInteractions(); }catch{}
 clearDeletionDeadline(rec);
 pendingDatafallDeletes.delete(key);
 unmarkArrayDeleting(rec?.arrId ?? key);
 }
 }
 }
 });
 finalizeIds.forEach(id=>{
 try{ maybeFinalizeDeletion(id); }catch{}
 });
 if(!pendingDatafallDeletes.size && !deleteEffects.length){
 try{ releaseDeletionInteractions(); }catch{}
 }
 }
}

 function removeArrayGraphics(arr){
 try{
 // Remove layer meshes (all types + edge overlays)
 for(let z=0; z<arr.size.z; z++){
 ['empty','ghost','filled','formula'].forEach(type=>{
 const key = `${arr.id}:${z}:${type}`;
 const rec = layerMeshes.get(key);
 if(rec){
 rec.mesh.parent?.remove(rec.mesh);
 rec.mesh.geometry?.dispose?.();
 rec.mesh.material?.dispose?.();
 layerMeshes.delete(key);
 }
 const key2 = `${key}:edges`;
 const rec2 = layerMeshes.get(key2);
 if(rec2){
 rec2.mesh.parent?.remove(rec2.mesh);
 rec2.mesh.geometry?.dispose?.();
 rec2.mesh.material?.dispose?.();
 layerMeshes.delete(key2);
 }
 });
 }
 // Remove legacy chunk meshes
 [...chunkMeshes.keys()].forEach(k=>{
 if(String(k).startsWith(`${arr.id}:`)){
 const mesh = chunkMeshes.get(k);
 if(mesh){
 scene.remove(mesh);
 mesh.geometry?.dispose?.();
 mesh.material?.dispose?.();
 }
 chunkMeshes.delete(k);
 }
 });
 // Remove labels/grab
 (arr.labels||[]).forEach(s=>{
 try{
 if(s?.userData?.billboard) unmarkBillboard(s);
 s.parent?.remove(s);
 s.material?.map?.dispose?.();
 s.material?.dispose?.();
 }catch{}
 });
 arr.labels = [];

 // Remove frame
 if(arr._frame){
 try{
 scene.remove(arr._frame);
 arr._frame.traverse(obj=>{
 if(obj.isMesh){
 obj.geometry?.dispose?.();
 obj.material?.dispose?.();
 }
 });
 }catch{}
 arr._frame = null;
 }
 // Reset transforms/meshes for clean rebuild
 try{ arr.rotationQuat = arr.rotationQuat || [0,0,0,1]; }catch{}
 try{ Object.values(arr.chunks||{}).forEach(ch=>{ ch.meshLOD1=null; ch.meshLOD2=null; ch.currentLOD=-1; ch._dirty=true; }); }catch{}

 // Remove colliders
 try{ clearColliders(arr); }catch{}

 // Remove value sprites for this array
 [...valueSprites.keys()].forEach(key=>{
 if(key.startsWith(`${arr.id}:`)){
 const sp = valueSprites.get(key);
 if(sp){
 sp.parent?.remove(sp);
 sp.material?.map?.dispose?.();
 sp.material?.dispose?.();
 }
 valueSprites.delete(key);
 }
 });
 }catch(e){ console.warn('removeArrayGraphics failed', e); }
 }

 function reconcileAllArrays(){
 console.log('Reconciling all arrays...');
 Object.values(Store.getState().arrays).forEach(arr => {
 console.log(`Reconciling array #${arr.id} "${arr.name}"`);
 arr._layersRendered = false; // Force re-render
 // Ensure each chunk's mesh reflects current content immediately
 try{ Object.values(arr.chunks||{}).forEach(ch=> ch._dirty=true); }catch{}
 renderArray(arr);
 // Apply visibility after render (hide reserved arrays like Mainframe)
 try{ syncVisibility(arr); }catch{}
 });
 }

 function removeConnection(anchor){
 const key = aKey(anchor);
 if(connections.has(key)){
 const connection = connections.get(key);
 if(connection.visual){
 scene.remove(connection.visual);
 try{ connection.visual.geometry?.dispose?.(); }catch{}
 try{
 const mat = connection.visual.material;
 if(Array.isArray(mat)) mat.forEach(m=>m?.dispose?.());
 else mat?.dispose?.();
 }catch{}
 }
 connections.delete(key);
 }
 }

 function locateArrayCollision(worldVec, {preferSelection=true}={}){
 if(!worldVec) return null;
 const state = Store.getState();
 const arrays = state.arrays || {};
 const sel = state.selection;
 const debugMode = !!state.scene?.physicsDebugAll;
 const formulaHostedSet = getFormulaActiveArrayIds();
 const consider = (arr)=>{
 if(!arr || arr._deleting) return null;
 let coord;
 try{ coord = worldToCellCoord(arr, worldVec); }catch{ return null; }
 if(!withinBounds(arr, coord)) return null;
 let center = null;
 try{ center = cellWorldPos(arr, coord.x, coord.y, coord.z); }catch{}
 if(!center){
 try{ center = worldPos(arr, coord.x, coord.y, coord.z); }catch{}
 }
 if(!center) return null;
 const distSq = center.distanceToSquared(worldVec);
 const cell = Formula.getCell({arrId:arr.id,x:coord.x,y:coord.y,z:coord.z});
 const collisionMode = determineCollisionMode(arr, cell, { debugMode, formulaHostedSet });
 return { arr, coord, cell, center, distSq, collisionMode };
 };

 if(preferSelection && sel?.arrayId){
 const preferred = consider(arrays[sel.arrayId]);
 if(preferred) return preferred;
 }

 let best = null;
 Object.values(arrays).forEach(arr=>{
 const hit = consider(arr);
 if(!hit) return;
 if(!best || hit.distSq < best.distSq) best = hit;
 });
 return best;
 }

 function exitPhysicsOnNonEnabledArray(hit){
 if(!hit || !hit.arr) return false;
 const arr = hit.arr;
 // In debug mode, treat all arrays as physics enabled
 const state = Store.getState();
 const sceneState = state.scene;
 const debugMode = !!sceneState?.physicsDebugAll;
 const formulaHostedSet = getFormulaActiveArrayIds();
 const effectiveMode = determineCollisionMode(arr, hit.cell, { debugMode, formulaHostedSet });
 const arrPhysicsEnabled = !!arr?.params?.physics?.enabled;
 console.log(`[PHYSICS] exitPhysicsOnNonEnabledArray ENTRY: array=${arr.id}`);
 console.log(`[PHYSICS] scene.physicsDebugAll=${sceneState?.physicsDebugAll}`);
 console.log(`[PHYSICS] debugMode=${debugMode}`);
 console.log(`[PHYSICS] arr.collisionMode=${arr?.collisionMode}`);
 console.log(`[PHYSICS] effectiveCollisionMode=${effectiveMode}`);
 console.log(`[PHYSICS] arr.params.physics.enabled=${arrPhysicsEnabled}`);
 console.log(`[PHYSICS] arr.params.physics.__debugOverride=${!!arr?.params?.physics?.__debugOverride}`);

 if(debugMode){
 console.log('[PHYSICS] ? Debug mode ACTIVE - NOT exiting physics for array', arr.id);
 return false;
 }
 if(effectiveMode === 'physics'){
 console.log('[PHYSICS] ? Array is treated as physics-active - NOT exiting physics for array', arr.id);
 return false;
 }
 console.log('[PHYSICS] ? EXITING PHYSICS MODE for array', arr.id);
 try{
 Actions.setSelection(arr.id, {x:hit.coord.x, y:hit.coord.y, z:hit.coord.z}, null, '3d');
 }catch{}
 try{ centerOnArray(arr); }catch{}
 const physicsActive = !!Store.getState().scene?.physics;
 if(physicsActive){
 try{
 const res = togglePhysicsMode();
 if(res && typeof res.catch === 'function'){
 res.catch(err=>console.warn('[PHYSICS] Exit auto-toggle failed', err));
 }
 }catch(e){ console.warn('[PHYSICS] Exit auto-toggle threw', e); }
 }
 return true;
 }

 function cancelLandingCellAnimation(){
 if(landingCellAnim && typeof landingCellAnim.cancel === 'function'){
 try{ landingCellAnim.cancel(); }catch{}
 }
 landingCellAnim = null;
 landingCellKey = null;
 }

 function startLandingCellBounce(arr, coord, strength=1){
 if(!arr || !coord) return;
 const key = `${arr.id}:${coord.x},${coord.y},${coord.z}`;
 if(landingCellAnim){
 if(landingCellAnim.key === key){ landingCellAnim.cancel(); }
 else { landingCellAnim.cancel(); }
 }
 const clampedStrength = Math.max(0.3, Math.min(Number(strength)||1, 2.5));
 const records = [];
 const pushRecord = (mesh, idx)=>{
 if(!mesh || !Number.isInteger(idx) || idx < 0) return;
 if(idx >= (mesh.count ?? Infinity)) return;
 try{
 const base = new THREE.Matrix4();
 mesh.getMatrixAt(idx, base);
 records.push({ mesh, idx, base });
 }catch{}
 };
 const useChunks = !!(ChunkManager && ChunkManager.enabled);
 if(useChunks){
 const chunkId = keyChunk(...Object.values(chunkOf(coord.x, coord.y, coord.z)));
 const ch = arr.chunks?.[chunkId];
 if(ch){
 let idx = -1;
 if(ch.cellIndexMap && typeof ch.cellIndexMap.get === 'function'){
 const maybeIdx = ch.cellIndexMap.get(`${coord.x},${coord.y},${coord.z}`);
 if(Number.isInteger(maybeIdx)) idx = maybeIdx;
 }
 if(idx < 0 && Array.isArray(ch.index2cell)){
 idx = ch.index2cell.findIndex(c=>c && c.x===coord.x && c.y===coord.y && c.z===coord.z);
 }
 if(idx >= 0){
 pushRecord(ch.meshLOD1, idx);
 pushRecord(ch.meshShell, idx);
 }
 }
 } else {
 const z = coord.z|0;
 const types = ['filled','formula'];
 types.forEach(tp=>{
 const rec = layerMeshes.get(`${arr.id}:${z}:${tp}`);
 if(rec && rec.mesh && Array.isArray(rec.index2cell)){
 const idx = rec.index2cell.findIndex(c=>c && c.x===coord.x && c.y===coord.y && c.z===coord.z);
 pushRecord(rec.mesh, idx);
 }
 const er = layerMeshes.get(`${arr.id}:${z}:${tp}:edges`);
 if(er && er.mesh && Array.isArray(er.index2cell)){
 const idx = er.index2cell.findIndex(c=>c && c.x===coord.x && c.y===coord.y && c.z===coord.z);
 pushRecord(er.mesh, idx);
 }
 });
 }
 if(!records.length){
 landingCellAnim = null;
 landingCellKey = key;
 if(surfaceBounceState.key === key){
 surfaceBounceState = { key:null, depression:0, intensity:1 };
 }
 return;
 }
 const duration = 240;
 let start = null;
 let cancelled = false;
 let frameId = null;
 const scaleMatrix = new THREE.Matrix4();
 const maxSquashDelta = Math.min(0.35 * clampedStrength, 0.65);
 const expandDelta = Math.min(0.3 * clampedStrength, 0.55);
 const overshootAmount = Math.min(0.03 * clampedStrength, 0.06);
 const squashRecoveryDelta = Math.min(0.38 * clampedStrength, 0.6);
 const expandOvershoot = Math.min(0.02 * clampedStrength, 0.08);
 const baseMinSquash = 1 - maxSquashDelta;
 const squashRecoveryTarget = Math.min(1 + overshootAmount, baseMinSquash + squashRecoveryDelta);
 const expandPeak = 1 + expandDelta;
 const expandEnd = 1 - expandOvershoot;

 const restore = ()=>{
 records.forEach(rec=>{
 try{
 rec.mesh.setMatrixAt(rec.idx, rec.base);
 rec.mesh.instanceMatrix.needsUpdate = true;
 }catch{}
 });
 needsRender = true;
 if(surfaceBounceState.key === key){
 surfaceBounceState = { key:null, depression:0, intensity:1 };
 }
 };

 const applyScale = (sx, sy, sz)=>{
 scaleMatrix.identity();
 scaleMatrix.makeScale(sx, sy, sz);
 records.forEach(rec=>{
 try{
 const next = rec.base.clone().multiply(scaleMatrix);
 rec.mesh.setMatrixAt(rec.idx, next);
 rec.mesh.instanceMatrix.needsUpdate = true;
 }catch{}
 });
 needsRender = true;
 surfaceBounceState = {
 key,
 depression: Math.max(0, 1 - Math.min(sy, 1)),
 intensity: clampedStrength
 };
 };

 const step = (ts)=>{
 if(cancelled){ restore(); return; }
 if(start === null) start = ts;
 const t = Math.min(1, (ts - start) / duration);
 let squashY, stretchXZ;
 if(t < 0.3){
 const impactT = t / 0.3;
 squashY = 1 - maxSquashDelta * impactT;
 stretchXZ = 1 + expandDelta * impactT;
 } else {
 const recoveryT = Math.min(1, Math.max(0, (t - 0.3) / 0.7));
 const easeOut = 1 - Math.pow(1 - recoveryT, 3);
 squashY = baseMinSquash + (squashRecoveryTarget - baseMinSquash) * easeOut;
 stretchXZ = expandPeak + (expandEnd - expandPeak) * easeOut;
 if(recoveryT > 0.85){
 const overshootT = (recoveryT - 0.85) / 0.15;
 const clamped = Math.min(1, Math.max(0, overshootT));
 squashY += overshootAmount * Math.sin(clamped * Math.PI);
 }
 }
 applyScale(stretchXZ, squashY, stretchXZ);
 if(t < 1){
 frameId = requestAnimationFrame(step);
 } else {
 restore();
 landingCellAnim = null;
 }
 };

 const cancel = ()=>{
 if(cancelled) return;
 cancelled = true;
 if(frameId != null) cancelAnimationFrame(frameId);
 restore();
 landingCellAnim = null;
 };

 landingCellKey = key;
 surfaceBounceState = { key, depression:0, intensity: clampedStrength };
 landingCellAnim = { key, cancel };
 frameId = requestAnimationFrame(step);
 }

 function parseBounceMeta(meta){
 if(!meta) return { walk:0, land:0 };
 const normalized = normalizeMetaKeys(meta) || {};
 let raw = normalized.bounceConfig ?? normalized.bounce ?? null;
 if(typeof raw === 'string'){
 try{
 raw = JSON.parse(raw);
 }catch{
 const parts = String(raw)
 .split(/[;,\s]+/)
 .map(part=>part.trim())
 .filter(Boolean);
 if(parts.length){
 raw = {};
 if(parts.length === 1){
 raw.land = parts[0];
 } else {
 raw.walk = parts[0];
 raw.land = parts[1];
 }
 }
 }
 }
 const cfg = { walk:0, land:0 };
 const assign = (value, key)=>{
 if(value === undefined || value === null) return;
 const num = Number(value);
 if(Number.isFinite(num) && num > 0){
 cfg[key] = Math.max(0, num);
 }
 };
 if(raw && typeof raw === 'object'){
 if(Array.isArray(raw)){
 assign(raw[0], 'walk');
 assign(raw[1], 'land');
 } else {
 assign(raw.walk ?? raw.onWalk, 'walk');
 assign(raw.land ?? raw.onLand, 'land');
 }
 } else {
 assign(raw, 'land');
 }
 return cfg;
 }

 function bounceIntensityFromHeight(height){
 const h = Math.max(0, Number(height) || 0);
 return Math.max(0.3, Math.min(1 + Math.min(h, 4) * 0.35, 2.5));
 }

 function applyBounceImpulse(height, mode='land'){
 if(!playerBody || !rapierWorld) return false;
 const h = Math.max(0, Number(height) || 0);
 if(h <= 0) return false;
 let gravityMag = 20;
 try{
 const gy = rapierWorld.gravity?.y;
 if(Number.isFinite(gy)) gravityMag = Math.max(0.001, Math.abs(gy));
 }catch{}
 const bounceVel = Math.sqrt(Math.max(0, 2 * gravityMag * h));
 if(!Number.isFinite(bounceVel) || bounceVel <= 0.05) return false;
 try{
 const currentVel = playerBody.linvel();
 if(mode === 'walk' && currentVel.y > 0.6) return false;
 if(mode === 'walk' && currentVel.y > bounceVel) return false;
 playerBody.setLinvel({ x: currentVel.x, y: bounceVel, z: currentVel.z }, true);
 jumpVelocity = bounceVel;
 wasGroundedLastFrame = false;
 return true;
 }catch(err){
 console.warn('Bounce impulse failed', err);
 }
 return false;
 }

 function triggerBounceFromHit(mode, hit, height){
 if(!hit || !hit.arr || !hit.coord) return;
 const h = Math.max(0, Number(height) || 0);
 if(h <= 0) return;
 const intensity = bounceIntensityFromHeight(h);
 try{ startLandingCellBounce(hit.arr, hit.coord, intensity); }catch{}
 const applied = applyBounceImpulse(h, mode);
 if(applied){
 landingSquashTime = Math.max(landingSquashTime, 1);
 } else {
 landingSquashTime = Math.max(landingSquashTime || 0, 1);
 }
 }

 function triggerTouchHandlers(){
 try{
 const world = new THREE.Vector3(cachedPlayerPos.x, cachedPlayerPos.y, cachedPlayerPos.z);
 const hit = locateArrayCollision(world);
 if(!hit){ lastTouchKey=null; return; }
 const debugMode = !!Store.getState().scene?.physicsDebugAll;
 if(!debugMode && hit.collisionMode !== 'physics'){ lastTouchKey=null; return; }
 const key = `${hit.arr.id}:${hit.coord.x},${hit.coord.y},${hit.coord.z}`;
 // Removed automatic exit - physics mode should work on any array
 if(key===lastTouchKey) return;
 lastTouchKey = key;
 const cell = hit.cell ?? Formula.getCell({arrId:hit.arr.id,x:hit.coord.x,y:hit.coord.y,z:hit.coord.z});
 const bounceCfg = parseBounceMeta(cell?.meta);
 if(bounceCfg.walk > 0 && nowMs() >= skipWalkBounceUntil){
 triggerBounceFromHit('walk', hit, bounceCfg.walk);
 }
 const action = getMetaAction(cell?.meta, 'on_touch');
 if(action){ executeActionFormula({arrId:hit.arr.id,x:hit.coord.x,y:hit.coord.y,z:hit.coord.z}, action, 'touch'); }
 }catch(err){ console.warn('touch handler failed', err); }
 }

 function triggerLandHandler(){
 try{
 const world = new THREE.Vector3(cachedPlayerPos.x, cachedPlayerPos.y - 0.6, cachedPlayerPos.z);
 const hit = locateArrayCollision(world);
 if(!hit){ lastLandKey=null; cancelLandingCellAnimation(); return; }
 const key = `${hit.arr.id}:${hit.coord.x},${hit.coord.y},${hit.coord.z}`;
 if(key===lastLandKey) return;
 const debugMode = !!Store.getState().scene?.physicsDebugAll;
 if(hit.collisionMode !== 'physics' && !debugMode){
 lastLandKey = key;
 exitPhysicsOnNonEnabledArray(hit);
 cancelLandingCellAnimation();
 return;
 }
 lastLandKey = key;
 const cell = hit.cell ?? Formula.getCell({arrId:hit.arr.id,x:hit.coord.x,y:hit.coord.y,z:hit.coord.z});
 const bounceCfg = parseBounceMeta(cell?.meta);
 const landHeight = bounceCfg.land || 0;
 if(landHeight > 0){
 triggerBounceFromHit('land', hit, landHeight);
 skipWalkBounceUntil = Math.max(skipWalkBounceUntil, nowMs() + 180);
 } else {
 try{ startLandingCellBounce(hit.arr, hit.coord, 1); }catch{}
 }
 resetJumpBudget(hit.arr);
 // Removed automatic exit - physics mode should work on any array
 const action = getMetaAction(cell?.meta, 'on_land');
 if(action){ executeActionFormula({arrId:hit.arr.id,x:hit.coord.x,y:hit.coord.y,z:hit.coord.z}, action, 'land'); }
 }catch(err){ console.warn('land handler failed', err); }
 }

 function addConnection(anchor, ref1, ref2, options={}){
 removeConnection(anchor); // Clear any existing line from this anchor

 const r1 = { ...ref1, arrId: ref1.arrId ?? anchor.arrId };
 const r2 = { ...ref2, arrId: ref2.arrId ?? anchor.arrId };
 const arr1 = Store.getState().arrays[r1.arrId];
 const arr2 = Store.getState().arrays[r2.arrId];
 if(!arr1 || !arr2) return;

 const start = worldPos(arr1, r1.x, r1.y, r1.z);
 const end = worldPos(arr2, r2.x, r2.y, r2.z);

 const style = options.style ? String(options.style).toLowerCase() : '';
 const mode = (options.dimensionMode || 'line').toLowerCase();
 const dimensionExplicit = !!options.dimensionExplicit;
 const dir = new THREE.Vector3().subVectors(end, start);
 const length = Math.max(0.0001, dir.length());
 const dirNorm = length > 0.0001 ? dir.clone().divideScalar(length) : new THREE.Vector3(1,0,0);
 const center = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
 const colorMap = {
 warn: 0xf97316,
 danger: 0xef4444,
 safe: 0x22c55e,
 info: 0x38bdf8
 };
 const color = colorMap[style] || COLORS.grab;
 let visual;

 if(mode === 'platform' || mode === 'grind'){
 const thickness = mode === 'grind' ? 0.18 : 0.2;
 const width = mode === 'grind' ? 0.35 : 1.1;
 const geo = new THREE.BoxGeometry(1, thickness, width);
 const mat = new THREE.MeshStandardMaterial({ color, metalness:0.15, roughness:0.55 });
 visual = new THREE.Mesh(geo, mat);
 visual.castShadow = true;
 visual.receiveShadow = true;
 const axis = new THREE.Vector3(1,0,0);
 const quat = new THREE.Quaternion().setFromUnitVectors(axis, dirNorm.clone());
 visual.quaternion.copy(quat);
 visual.position.copy(center);
 visual.scale.set(length, 1, 1);
 } else if(mode === 'zipline'){
 const geo = new THREE.CylinderGeometry(0.05, 0.05, 1, 10);
 const mat = new THREE.MeshBasicMaterial({ color });
 visual = new THREE.Mesh(geo, mat);
 const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,1,0), dirNorm.clone());
 visual.quaternion.copy(quat);
 visual.position.copy(center);
 visual.scale.set(1, length, 1);
 } else {
 const geometry = new THREE.BufferGeometry().setFromPoints([start, end]);
 const material = new THREE.LineBasicMaterial({ color, linewidth: 2 });
 visual = new THREE.Line(geometry, material);
 visual.renderOrder = 100;
 }

 visual.frustumCulled = false;
 scene.add(visual);
 connections.set(aKey(anchor), {
 visual,
 line: visual,
 start,
 end,
 anchor: {...anchor},
 ref1: r1,
 ref2: r2,
 mode,
 style,
 length,
 color,
 dimensionExplicit
 });
 }

 function createArraySnapshot(arr) {
 const geometries = [];
 // Iterate through all VISIBLE layer meshes of the source array
 layerMeshes.forEach((rec, key) => {
 if (key.startsWith(`${arr.id}:`) && rec.mesh.visible && rec.mesh.count > 0) {
 const mesh = rec.mesh;
 for (let i = 0; i < mesh.count; i++) {
 const geo = mesh.geometry.clone();
 const matrix = new THREE.Matrix4();
 mesh.getMatrixAt(i, matrix);
 geo.applyMatrix4(matrix);
 geometries.push(geo);
 }
 }
 });
 if (geometries.length === 0) return null;

 // Note: BufferGeometryUtils would be needed for mergeGeometries
 // For now, create a simple group
 const group = new THREE.Group();
 geometries.forEach(geo => {
 const mesh = new THREE.Mesh(geo, new THREE.MeshNormalMaterial());
 group.add(mesh);
 });
 return group;
 }
 // Rotate array around a world-space pivot by 90 steps per axis
 function rotateArrayAround(arr, pivotWorld, stepsX=0, stepsY=0, stepsZ=0){
 if(!arr?._frame) return;
 const snap=(v)=> Math.round(v);
 const apply=(axis, steps)=>{
 const n=((steps%4)+4)%4; if(n===0) return;
 const angle=n*(Math.PI/2);
 const pos=arr._frame.position.clone().sub(pivotWorld);
 pos.applyAxisAngle(axis, angle).add(pivotWorld);
 arr._frame.position.copy(pos);
 arr._frame.rotateOnWorldAxis(axis, angle);
 // snap position to integer grid after each axis to minimize drift
 arr._frame.position.set(snap(arr._frame.position.x), snap(arr._frame.position.y), snap(arr._frame.position.z));
 };
 apply(new THREE.Vector3(1,0,0), stepsX);
 apply(new THREE.Vector3(0,1,0), stepsY);
 apply(new THREE.Vector3(0,0,1), stepsZ);
 // persist offset for future renders
 arr.offset = { x: arr._frame.position.x, y: arr._frame.position.y, z: arr._frame.position.z };
 // Persist rotation for save
 try{
 arr.rotationQuat = arr._frame.quaternion.toArray();
 const rs = arr.rotationSteps || {x:0,y:0,z:0};
 arr.rotationSteps = {
 x: ((rs.x||0) + (stepsX|0))%4,
 y: ((rs.y||0) + (stepsY|0))%4,
 z: ((rs.z||0) + (stepsZ|0))%4,
 };
 }catch{}
 }
 // Compute world position of a cell, respecting current frame transform
 function cellWorldPos(arr, x, y, z){
 const lp = localPos(arr, x, y, z).clone();
 if(arr._frame){ return arr._frame.localToWorld(lp); }
 const off = arr.offset||{x:0,y:0,z:0};
 lp.x += off.x; lp.y += off.y; lp.z += off.z; return lp;
 }

 function refreshArray(arr){
 if(!arr || !arr._frame) return;
 try{
 const old = arr._frame.userData?.labelSprite;
 if(old){ try{ if(old?.userData?.billboard) unmarkBillboard(old); }catch{} old.parent?.remove(old); old.material?.map?.dispose?.(); old.material?.dispose?.(); old.geometry?.dispose?.(); }
 const labelSprite = makeArrayLabelSprite(arr);
 // Initial position will be updated by updateArrayLabelPlacement
 labelSprite.position.set(0, arr.size.y/2 + 0.8, 0);
 arr._frame.add(labelSprite);
 arr._frame.userData.labelSprite = labelSprite;
 }catch{}
 }
 // Rehydrate all arrays from current Store state: ensure LOD1 meshes, apply occlusion for the focused array, and rebuild value sprites
 function hydrateAll(){
 try{
 const S = Store.getState();
 const sel = S.selection || {};
 const viewModeNow = (S.ui && S.ui.viewMode) || 'standard';
 Object.values(S.arrays).forEach(arr=>{
 try{ Object.values(arr.chunks||{}).forEach(ch=>{ ch.ensureMesh?.(); ch.setLOD?.(1); rehydrateChunkInstances(arr, ch); }); }catch{}
 // Apply occlusion mask only to the focused array so others start solid
 if(viewModeNow === 'standard' && sel.arrayId === arr.id && sel.focus){
 try{ computeOcclusion(arr, sel.focus); applyGhostMaskToChunks(arr); }catch{}
 } else if(sel.arrayId === arr.id){
 clearOcclusion(arr);
 }
 // Rebuild value sprites for visible cells (clear first to prevent duplicates)
 try{
 valueSprites.forEach((sprite,key)=>{ if(String(key).startsWith(`${arr.id}:`)){ try{ unmarkBillboard(sprite); sprite.parent?.remove(sprite); sprite.material?.map?.dispose?.(); sprite.material?.dispose?.(); }catch{} valueSprites.delete(key); } });
 Object.values(arr.chunks||{}).forEach(ch=>{
 (ch.cells||[]).forEach(c=>{
 try{ const cell = Formula.getCell({arrId: arr.id, x:c.x, y:c.y, z:c.z}); if(cell && (cell.value!=='' && cell.value!==null && cell.value!==undefined)) updateValueSprite(arr, c.x, c.y, c.z, cell); }catch{}
 });
 });
 // Ensure sprites are positioned on the current camera-facing face
 try{ updateArrayValueSpritePlacement(arr); }catch{}
 }catch{}
 });
 try{ forceRenderOrderRefresh?.(true); }catch{}
 needsRender = true;
 }catch{}
 }
 
 function spawnPlayerAt(x, y, z){
 if(playerBody){
 try{
 playerBody.setTranslation({x, y, z}, true);
 playerBody.setLinvel({x: 0, y: 0, z: 0}, true); // Reset all velocities
 playerBody.setAngvel({x: 0, y: 0, z: 0}, true); // Reset angular velocity
 cachedPlayerPos.set(x, y, z);
 jumpVelocity = 0; // Reset jump velocity on spawn
 landingSquashTime = 0; // Reset squash animation
 physicsSpawnPos = {x, y, z}; // Store for respawn on fall
 console.log(`[PHYSICS] Spawned player at (${x.toFixed(2)}, ${y.toFixed(2)}, ${z.toFixed(2)})`);
 }catch(e){
 console.warn('spawnPlayerAt failed:', e);
 }
 }
 }

 function updateArrayLabelPlacement(arr){
 const label = arr?._frame?.userData?.labelSprite;
 const grab = arr.labels?.find(l => l.userData?.type === 'grab');
 if(!label || !grab) return;

 // world positions
 grab.updateWorldMatrix(true, false);
 const grabW = new THREE.Vector3(); grab.getWorldPosition(grabW);

 const camW = camera.position;
 const scale = arrayVoxelScale(arr);
 const toCam = new THREE.Vector3().subVectors(camW, grabW);
 toCam.y = 0;
 if(toCam.lengthSq() < 1e-6){ toCam.set(0,0,1); }
 toCam.normalize();

 // offsets: a little above in world Y, and a little toward the camera (horizontal only)
 const up = new THREE.Vector3(0,1,0);
 const aboveBase = 0.35 + Math.abs(label.scale.y)*0.5;
 const above = up.multiplyScalar(clampedScaleOffset(scale, aboveBase));
 const inFront = toCam.multiplyScalar(clampedScaleOffset(scale, 0.3));

 const targetW = grabW.clone().add(above).add(inFront);

 // place in the frame's local space (so it follows naturally)
 const parent = arr._frame || scene;
 parent.worldToLocal(targetW);
 label.position.copy(targetW);

 // keep it facing camera without touching renderOrder
 label.lookAt(camera.position);
 }

 async function togglePhysicsMode(){
 if(physicsToggleInFlight){
 console.warn('[PHYSICS] Toggle already in progress');
 return;
 }
 console.log('[PHYSICS] togglePhysicsMode called, stack:', new Error().stack.split('\n').slice(1,4).join('\n'));
 physicsToggleInFlight = true;
 try{
 try{
 const active = document?.activeElement;
 if(active && active.id === 'physicsBtn' && typeof active.blur === 'function'){
 active.blur();
 }
 }catch{}
 const current = Store.getState().scene.physics;
 const next = !current;
 console.log(`[PHYSICS MODE TOGGLE] Current: ${current}, Next: ${next}`);
 if(next){
 setPhysicsActivationPending(true, 'toggle-begin');
 updatePhysicsStatusChip('Physics: Loading...');
 } else {
 setPhysicsActivationPending(false, 'toggle-begin');
 }
 const debugAll = !!Store.getState().scene.physicsDebugAll;
 console.log(`[PHYSICS] Toggle: debugAll=${debugAll}, next=${next}`);
 let debugApplied = false;
 if(next && debugAll){
 console.log('[PHYSICS] Applying debug overrides for all arrays');
 applyDebugPhysicsOverrides(true);
 debugApplied = true;
 }
 const avatarCfg = Store.getState().avatarPhysics || {};
 if(next && avatarCfg.enabled === false){
 showToast?.('Avatar physics disabled by CELLI_PHYS');
 Store.setState(s=>({scene:{...s.scene, physics:false}}));
 syncPhysicsInputCapture('avatar-disabled');
 updatePhysicsStatusChip('Physics: OFF');
 if(debugApplied){ applyDebugPhysicsOverrides(false); }
 ensurePlatformerActiveState(false);
 resetPhysicsInputState();
 setPhysicsActivationPending(false, 'avatar-disabled');
 return;
 }

 if(next){
 const status = await ensureRapierWorld();
 if(!status?.success){
 const label = status?.reason === 'unavailable' ? 'Physics: OFF (unavailable)' : 'Physics: OFF (error)';
 updatePhysicsStatusChip(label);
 if(debugApplied){ applyDebugPhysicsOverrides(false); }
 ensurePlatformerActiveState(false);
 resetPhysicsInputState();
 setPhysicsActivationPending(false, status?.reason || 'rapier-failed');
 return;
 }
 }

 Store.setState(s=>({scene:{...s.scene, physics:next}}));
 syncPhysicsInputCapture('toggle-commit');
 ensurePlatformerActiveState(next);

 if(next){
 try{
 const directEl = document.getElementById('directEdit');
 if(directEl){
 if(directEl.style.display === 'block'){
 directEl.style.display = 'none';
 }
 if(typeof directEl.blur === 'function' && document.activeElement === directEl){
 directEl.blur();
 }
 directEl._closedAt = Date.now();
 }
 const active = document.activeElement;
 if(active && typeof active.blur === 'function'){
 const tag = (active.tagName||'').toUpperCase();
 if(tag === 'INPUT' || tag === 'TEXTAREA'){
 active.blur();
 }
 }
 }catch{}
 resetPhysicsInputState();
 // On enable: create player body and spawn at current selected cell
 if(RAPIER && rapierWorld && !playerBody){
 try{
 const cfg = Store.getState().avatarPhysics || {};
 const momentumMode = (cfg.momentumMode|0) === 1 ? 1 : 0;
 const rb=RAPIER.RigidBodyDesc.dynamic();
 rb.setTranslation(0, 0.7, 0);
 rb.lockRotations(true, true);
 rb.setCanSleep(false);
 rb.setLinearDamping(momentumMode === 1 ? 1.5 : 5.0);
 rb.setAngularDamping(1.0);
 rb.setCcdEnabled(true);
 playerBody=rapierWorld.createRigidBody(rb);
 const capsuleDesc = RAPIER.ColliderDesc.capsule(0.35, 0.25);
 capsuleDesc.setRestitution(0.0);
 capsuleDesc.setFriction(0.7);
 capsuleDesc.setDensity(1.5);
 playerCollider=rapierWorld.createCollider(capsuleDesc, playerBody);
 cachedPlayerPos.set(0, 0.7, 0);
 console.log('[PHYSICS] Created player body');
 updatePhysicsStatusChip('Physics: ON');
 }catch(e){
 console.warn('[PHYSICS] Failed to create player body:', e);
 updatePhysicsStatusChip('Physics: OFF (error)');
 Store.setState(s=>({scene:{...s.scene, physics:false}}));
 syncPhysicsInputCapture('player-body-error');
 ensurePlatformerActiveState(false);
 if(debugApplied){ applyDebugPhysicsOverrides(false); }
 resetPhysicsInputState();
 setPhysicsActivationPending(false, 'player-body-error');
 return;
 }
 }
 const sel = Store.getState().selection;
 let spawnPos = {x: 0, y: 1, z: 0}; // Default spawn position
 const selectedArr = sel?.arrayId ? Store.getState().arrays[sel.arrayId] : null;
 if(selectedArr && sel?.focus){
 const pos = worldPos(selectedArr, sel.focus.x, sel.focus.y, sel.focus.z);
 const arrScale = arrayVoxelScale(selectedArr);
 const perch = avatarPerchOffset(arrScale);
 spawnPos = {x: pos.x, y: pos.y + perch, z: pos.z};
 spawnPlayerAt(spawnPos.x, spawnPos.y, spawnPos.z);
 console.log(`[PHYSICS] Spawned Celli at cell (${sel.focus.x},${sel.focus.y},${sel.focus.z}) -> world (${pos.x.toFixed(2)},${pos.y.toFixed(2)},${pos.z.toFixed(2)})`);
 } else {
 // No selection, spawn at default position
 spawnPlayerAt(spawnPos.x, spawnPos.y, spawnPos.z);
 }
 resetJumpBudget(selectedArr || null);
 // Position camera to show Celli from a good platformer angle
 if(camera && controls){
 // Target Celli's position (slightly above ground)
 const targetPos = {x: spawnPos.x, y: spawnPos.y + 1.5, z: spawnPos.z};
 controls.target.set(targetPos.x, targetPos.y, targetPos.z);
 // Camera behind and above for good platformer view
 const camDistance = 8;
 const camHeight = 4;
 camera.position.set(targetPos.x - 3, targetPos.y + camHeight, targetPos.z + camDistance);
 controls.update();
 console.log(`[PHYSICS] Camera positioned at (${camera.position.x.toFixed(2)}, ${camera.position.y.toFixed(2)}, ${camera.position.z.toFixed(2)}) targeting (${targetPos.x.toFixed(2)}, ${targetPos.y.toFixed(2)}, ${targetPos.z.toFixed(2)})`);
 }
 try{ setPhysicsCamera(physicsCameraConfig.mode, physicsCameraConfig.distance, physicsCameraConfig.allowRotation); }catch{}
 // Build colliders for all arrays (in debug mode, all arrays should get colliders)
 const allArrays = Object.values(Store.getState().arrays);
 console.log(`[PHYSICS] Building colliders for ${allArrays.length} arrays (debug=${debugAll})`);
 // Wait for colliders to be built before finishing activation
 let rebuildsCompleted = 0;
 const totalArrays = allArrays.length;
 allArrays.forEach(a=>{
 debounceColliderRebuild(a);
 // Mark colliders as being built
 a._collidersBuilding = true;
 });
 // Clear activation pending immediately - debug mode protects against physics exit
 setPhysicsActivationPending(false, 'collider-build');
 // Initialize mouse look angles from current camera
 try{
 if(camera){
 const dir = new THREE.Vector3();
 camera.getWorldDirection(dir);
 mouseYaw = Math.atan2(-dir.x, -dir.z);
 mousePitch = Math.asin(dir.y);
 console.log(`[PHYSICS] Initialized mouse look from camera direction`);
 }
 }catch{}
 } else {
 setPhysicsActivationPending(false, 'toggle-complete');
 resetPhysicsInputState();
 // On disable: destroy player body and release pointer lock
 if(playerBody && rapierWorld){
 let removed = false;
 try{
 if(playerCollider) rapierWorld.removeCollider(playerCollider, false);
 rapierWorld.removeRigidBody(playerBody);
 removed = true;
 }catch(e){
 console.warn('[PHYSICS] Failed to destroy player body:', e);
 }
 playerBody = null;
 playerCollider = null;
 if(removed){ console.log('[PHYSICS] Destroyed player body'); }
 }
 ziplineState.active = false;
 ziplineState.velocity = 0;
 try{
 if(document.pointerLockElement){
 document.exitPointerLock();
 }
 mouseLookEnabled = false;
 }catch{}
 // Explicitly re-enable orbit controls when physics is disabled
 if(controls){
 if(orbitSuspendDepth === 0){
 controls.enableRotate = true;
 controls.enablePan = true;
 controls.enabled = true;
 console.log('[PHYSICS] Orbit controls re-enabled');
 } else {
 console.log('[PHYSICS] Orbit controls remain suspended (depth:', orbitSuspendDepth, ')');
 }
 }
 updatePhysicsStatusChip('Physics: OFF');
 if(debugApplied || debugAll){
 applyDebugPhysicsOverrides(false);
 }
 }
 } finally {
 // Always reset flags
 setPhysicsActivationPending(false, 'toggle-finalize');
 physicsToggleInFlight = false;
 }
 }

 return {init, renderArray, renderChunk, renderLayer, updateFocus, centerOnArray, syncVisibility, setGridVisible, setAxesVisible, rebuildCollidersForArray, debounceColliderRebuild, setHighlightMode, setCameraLock, setViewMode, initAvatars, updateAvatars, addTimedPreview, handleJump, spawnPlayerAt, getCamera:()=>camera, getControls:()=>controls, updateValueSprite, setArrayOffset, reconcileAllArrays, setupRenderer, setupLighting, addConnection, removeConnection, createArraySnapshot, worldPos, getScene:()=>scene, getLayerMesh:(key)=>layerMeshes.get(key), rotateArrayAround, cellWorldPos, startDatafallDelete, updateDeleteEffects, removeArrayGraphics, refreshArray, hydrateAll, updateArrayLabelPlacement, dockOffsetFor, Chunk, ChunkManager, localPos, createCellMaterial, GEO_VOXEL, getCell:getCellFast, captureCamera, restoreCamera, updateCellColor:(arrId, coord)=>updateCellColor(arrId, coord), togglePresentMode, isPresentEnabled, getGraphicsSettings, updateGraphicsSettings, setOceanEnabled, updateOceanSettings, getOceanSettings, upsertCellLight, removeCellLight, refreshLightsForArray, togglePhysicsMode, setPhysicsDebugAll, setPhysicsCamera, resetContactCache, setPhysicsSpawn, isPhysicsInputCaptured:()=>syncPhysicsInputCapture(), facingFromCamera, triggerCelliDerez, celliDerezState, getViewAxisForArray:(arrOrFrame, observer)=>{
 try{
 if(!arrOrFrame) return null;
 const frame = arrOrFrame.matrixWorld ? arrOrFrame : (arrOrFrame._frame || null);
 if(!frame) return null;
 return viewAxisForArray(frame, observer);
 }catch(e){ console.warn('getViewAxisForArray failed', e); return null; }
 }};
})();

/* ===========================
 UI
=========================== */
const UI = (()=>{
 let dragStart=null;
 let hovered2D = null; // {arrId,x,y,z}
 const els={
 fx:document.getElementById('fx'), fxHighlight:document.getElementById('fxHighlight'), apply:document.getElementById('applyFx'),
 toggleFxPanel:document.getElementById('toggleFxPanel'), fxPanel:document.getElementById('fxPanel'),
 fxBody:document.getElementById('fxBody'), fxClose:document.getElementById('fxClose'),
 focusChip:document.getElementById('focusChip'), inspect:document.getElementById('inspect'),
 centerHome:document.getElementById('centerHome'), viewMainframe:document.getElementById('viewMainframe'),
 toggleGrid:document.getElementById('toggleGrid'), toggleAxes:document.getElementById('toggleAxes'),
 presentToggle:document.getElementById('presentToggleBtn'), graphicsSettingsBtn:document.getElementById('graphicsSettingsBtn'), oceanSettingsBtn:document.getElementById('oceanSettingsBtn'), crystalToggle:document.getElementById('crystal2DToggle'),
 physicsBtn:document.getElementById('physicsBtn'), reset:document.getElementById('reset'),
 status:document.getElementById('statusChip'),
 sheetTitle:document.getElementById('sheetTitle'),
 rowHeaders:document.getElementById('rowHeaders'), colHeaders:document.getElementById('colHeaders'), grid:document.getElementById('grid'),
 direct:document.getElementById('directEdit')
 };
 // Local Excel-style column name generator to avoid any global shadowing
 const colNameFromIndex=(n)=>{ let s=''; let v=n+1; while(v>0){ const r=(v-1)%26; s=String.fromCharCode(65+r)+s; v=Math.floor((v-1)/26);} return s; };
 // 2D sheet column widths (px) persisted in-memory across renders
 const colWidths = {};
 const getColWidth=(i)=> (colWidths[i]||100);
 const setColWidth=(i,w)=>{ colWidths[i]=Math.max(60, Math.min(480, Math.round(w))); };

 const graphicsPanel = document.getElementById('graphicsSettingsPanel');
 const graphicsClose = document.getElementById('graphicsSettingsClose');
 const graphicsPanelHint = document.getElementById('graphicsSettingsHint');
 const graphicsControls = {
 hdri: document.getElementById('gfxHdri'),
 lights: document.getElementById('gfxLights'),
 lightRotation: document.getElementById('gfxLightRotation'),
 lightStrength: document.getElementById('gfxLightStrength'),
 darkBg: document.getElementById('gfxDarkBg'),
 bloom: document.getElementById('gfxBloom'),
 bloomStrength: document.getElementById('gfxBloomStrength'),
 bloomRadius: document.getElementById('gfxBloomRadius'),
 exposure: document.getElementById('gfxExposure'),
 dof: document.getElementById('gfxDof'),
 dofAperture: document.getElementById('gfxDofAperture'),
 dofMaxBlur: document.getElementById('gfxDofMaxBlur'),
 transmission: document.getElementById('gfxTransmission'),
 mirror: document.getElementById('gfxMirror'),
 ground: document.getElementById('gfxGround'),
 waveGrid: document.getElementById('gfxWaveGrid'),
 fxaa: document.getElementById('gfxFxaa'),
 fog: document.getElementById('gfxFog'),
 fogDensity: document.getElementById('gfxFogDensity'),
 outline: document.getElementById('gfxOutline'),
 outlineStrength: document.getElementById('gfxOutlineStrength'),
 outlineThickness: document.getElementById('gfxOutlineThickness'),
 motion: document.getElementById('gfxMotion'),
 motionDamping: document.getElementById('gfxMotionDamping')
 };
 const graphicsSliderDisplays = {
 bloomStrength: document.getElementById('gfxBloomStrengthValue'),
 bloomRadius: document.getElementById('gfxBloomRadiusValue'),
 exposure: document.getElementById('gfxExposureValue'),
 dofAperture: document.getElementById('gfxDofApertureValue'),
 dofMaxBlur: document.getElementById('gfxDofMaxBlurValue'),
 lightRotation: document.getElementById('gfxLightRotationValue'),
 lightStrength: document.getElementById('gfxLightStrengthValue'),
 fogDensity: document.getElementById('gfxFogDensityValue'),
 outlineStrength: document.getElementById('gfxOutlineStrengthValue'),
 outlineThickness: document.getElementById('gfxOutlineThicknessValue'),
 motionDamping: document.getElementById('gfxMotionDampingValue')
 };
 const oceanPanel = document.getElementById('oceanSettingsPanel');
 const oceanClose = document.getElementById('oceanSettingsClose');
 const oceanPanelHint = document.getElementById('oceanSettingsHint');
 const oceanControls = {
 enable: document.getElementById('oceanEnable'),
 envIntensity: document.getElementById('oceanEnvIntensity'),
 lightIntensity: document.getElementById('oceanLightIntensity'),
 exposure: document.getElementById('oceanExposure'),
 showGrid: document.getElementById('oceanShowGrid'),
 showSphere: document.getElementById('oceanShowSphere'),
 showTowers: document.getElementById('oceanShowTowers'),
 showFloaters: document.getElementById('oceanShowFloaters'),
 screenshot: document.getElementById('oceanScreenshotBtn'),
 sunElevation: document.getElementById('oceanSunElevation'),
 sunAzimuth: document.getElementById('oceanSunAzimuth'),
 skyTopColor: document.getElementById('oceanSkyTop'),
 skyMidColor: document.getElementById('oceanSkyMid'),
 skyBotColor: document.getElementById('oceanSkyBot'),
 timeScale: document.getElementById('oceanTimeScale'),
 choppiness: document.getElementById('oceanChoppiness'),
 amplitude0: document.getElementById('oceanAmp0'),
 amplitude1: document.getElementById('oceanAmp1'),
 amplitude2: document.getElementById('oceanAmp2'),
 amplitude3: document.getElementById('oceanAmp3'),
 amplitude4: document.getElementById('oceanAmp4'),
 amplitude5: document.getElementById('oceanAmp5'),
 wavelength0: document.getElementById('oceanLen0'),
 wavelength1: document.getElementById('oceanLen1'),
 wavelength2: document.getElementById('oceanLen2'),
 wavelength3: document.getElementById('oceanLen3'),
 wavelength4: document.getElementById('oceanLen4'),
 wavelength5: document.getElementById('oceanLen5'),
 speed0: document.getElementById('oceanSpeed0'),
 speed1: document.getElementById('oceanSpeed1'),
 speed2: document.getElementById('oceanSpeed2'),
 speed3: document.getElementById('oceanSpeed3'),
 speed4: document.getElementById('oceanSpeed4'),
 speed5: document.getElementById('oceanSpeed5'),
 deepColor: document.getElementById('oceanDeepColor'),
 shallowColor: document.getElementById('oceanShallowColor'),
 foamColor: document.getElementById('oceanFoamColor'),
 foamAmount: document.getElementById('oceanFoamAmount'),
 foamBias: document.getElementById('oceanFoamBias'),
 foamScale: document.getElementById('oceanFoamScale'),
 maxGloss: document.getElementById('oceanMaxGloss'),
 roughnessScale: document.getElementById('oceanRoughnessScale'),
 horizonColor: document.getElementById('oceanHorizonColor'),
 horizonZStart: document.getElementById('oceanHorizonStart'),
 horizonZEnd: document.getElementById('oceanHorizonEnd'),
 horizonBoost: document.getElementById('oceanHorizonBoost'),
 microScale: document.getElementById('oceanMicroScale'),
 microFreq: document.getElementById('oceanMicroFreq'),
 microWaveScale: document.getElementById('oceanMicroWaveScale'),
 enableBloom: document.getElementById('oceanEnableBloom'),
 bloomStrength: document.getElementById('oceanBloomStrength'),
 enableVignette: document.getElementById('oceanEnableVignette'),
 vignetteStrength: document.getElementById('oceanVignetteStrength'),
 grainAmount: document.getElementById('oceanGrainAmount'),
 enableRays: document.getElementById('oceanEnableRays'),
 rayStrength: document.getElementById('oceanRayStrength'),
 rayDecay: document.getElementById('oceanRayDecay'),
 rayExposure: document.getElementById('oceanRayExposure'),
 enableLighthouse: document.getElementById('oceanEnableLighthouse'),
 lighthouseStrength: document.getElementById('oceanLighthouseStrength'),
 focusDistance: document.getElementById('oceanFocusDistance'),
 dofStrength: document.getElementById('oceanDofStrength'),
 focusRange: document.getElementById('oceanFocusRange'),
 fogStart: document.getElementById('oceanFogStart'),
 fogEnd: document.getElementById('oceanFogEnd'),
 fogColor: document.getElementById('oceanFogColor'),
 gridDensity: document.getElementById('oceanGridDensity'),
 gridOpacity: document.getElementById('oceanGridOpacity')
 };
 const oceanValueDisplays = {
 envIntensity: document.getElementById('oceanEnvIntensityValue'),
 lightIntensity: document.getElementById('oceanLightIntensityValue'),
 exposure: document.getElementById('oceanExposureValue'),
 sunElevation: document.getElementById('oceanSunElevationValue'),
 sunAzimuth: document.getElementById('oceanSunAzimuthValue'),
 timeScale: document.getElementById('oceanTimeScaleValue'),
 choppiness: document.getElementById('oceanChoppinessValue'),
 amplitude0: document.getElementById('oceanAmp0Value'),
 amplitude1: document.getElementById('oceanAmp1Value'),
 amplitude2: document.getElementById('oceanAmp2Value'),
 amplitude3: document.getElementById('oceanAmp3Value'),
 amplitude4: document.getElementById('oceanAmp4Value'),
 amplitude5: document.getElementById('oceanAmp5Value'),
 wavelength0: document.getElementById('oceanLen0Value'),
 wavelength1: document.getElementById('oceanLen1Value'),
 wavelength2: document.getElementById('oceanLen2Value'),
 wavelength3: document.getElementById('oceanLen3Value'),
 wavelength4: document.getElementById('oceanLen4Value'),
 wavelength5: document.getElementById('oceanLen5Value'),
 speed0: document.getElementById('oceanSpeed0Value'),
 speed1: document.getElementById('oceanSpeed1Value'),
 speed2: document.getElementById('oceanSpeed2Value'),
 speed3: document.getElementById('oceanSpeed3Value'),
 speed4: document.getElementById('oceanSpeed4Value'),
 speed5: document.getElementById('oceanSpeed5Value'),
 foamAmount: document.getElementById('oceanFoamAmountValue'),
 foamBias: document.getElementById('oceanFoamBiasValue'),
 foamScale: document.getElementById('oceanFoamScaleValue'),
 maxGloss: document.getElementById('oceanMaxGlossValue'),
 roughnessScale: document.getElementById('oceanRoughnessScaleValue'),
 horizonZStart: document.getElementById('oceanHorizonStartValue'),
 horizonZEnd: document.getElementById('oceanHorizonEndValue'),
 horizonBoost: document.getElementById('oceanHorizonBoostValue'),
 microScale: document.getElementById('oceanMicroScaleValue'),
 microFreq: document.getElementById('oceanMicroFreqValue'),
 microWaveScale: document.getElementById('oceanMicroWaveScaleValue'),
 bloomStrength: document.getElementById('oceanBloomStrengthValue'),
 vignetteStrength: document.getElementById('oceanVignetteStrengthValue'),
 grainAmount: document.getElementById('oceanGrainAmountValue'),
 rayStrength: document.getElementById('oceanRayStrengthValue'),
 rayDecay: document.getElementById('oceanRayDecayValue'),
 rayExposure: document.getElementById('oceanRayExposureValue'),
 lighthouseStrength: document.getElementById('oceanLighthouseStrengthValue'),
 focusDistance: document.getElementById('oceanFocusDistanceValue'),
 dofStrength: document.getElementById('oceanDofStrengthValue'),
 focusRange: document.getElementById('oceanFocusRangeValue'),
 fogStart: document.getElementById('oceanFogStartValue'),
 fogEnd: document.getElementById('oceanFogEndValue'),
 gridDensity: document.getElementById('oceanGridDensityValue'),
 gridOpacity: document.getElementById('oceanGridOpacityValue')
 };
 const oceanSliderFormatters = {
 envIntensity: (v)=>Number(v).toFixed(2),
 lightIntensity: (v)=>Number(v).toFixed(2),
 exposure: (v)=>Number(v).toFixed(2),
 sunElevation: (v)=>`${Math.round(Number(v)||0)} `,
 sunAzimuth: (v)=>`${Math.round(Number(v)||0)} `,
 timeScale: (v)=>Number(v).toFixed(2),
 choppiness: (v)=>Number(v).toFixed(2),
 amplitude0: (v)=>Number(v).toFixed(2),
 amplitude1: (v)=>Number(v).toFixed(2),
 amplitude2: (v)=>Number(v).toFixed(2),
 amplitude3: (v)=>Number(v).toFixed(2),
 amplitude4: (v)=>Number(v).toFixed(2),
 amplitude5: (v)=>Number(v).toFixed(2),
 wavelength0: (v)=>Number(v).toFixed(1),
 wavelength1: (v)=>Number(v).toFixed(1),
 wavelength2: (v)=>Number(v).toFixed(1),
 wavelength3: (v)=>Number(v).toFixed(1),
 wavelength4: (v)=>Number(v).toFixed(1),
 wavelength5: (v)=>Number(v).toFixed(1),
 speed0: (v)=>Number(v).toFixed(2),
 speed1: (v)=>Number(v).toFixed(2),
 speed2: (v)=>Number(v).toFixed(2),
 speed3: (v)=>Number(v).toFixed(2),
 speed4: (v)=>Number(v).toFixed(2),
 speed5: (v)=>Number(v).toFixed(2),
 foamAmount: (v)=>Number(v).toFixed(2),
 foamBias: (v)=>Number(v).toFixed(2),
 foamScale: (v)=>Number(v).toFixed(2),
 maxGloss: (v)=>Number(v).toFixed(2),
 roughnessScale: (v)=>Number(v).toFixed(4),
 horizonZStart: (v)=>Number(v).toFixed(0),
 horizonZEnd: (v)=>Number(v).toFixed(0),
 horizonBoost: (v)=>Number(v).toFixed(2),
 microScale: (v)=>Number(v).toFixed(3),
 microFreq: (v)=>Number(v).toFixed(1),
 microWaveScale: (v)=>Number(v).toFixed(2),
 bloomStrength: (v)=>Number(v).toFixed(2),
 vignetteStrength: (v)=>Number(v).toFixed(2),
 grainAmount: (v)=>Number(v).toFixed(3),
 rayStrength: (v)=>Number(v).toFixed(2),
 rayDecay: (v)=>Number(v).toFixed(3),
 rayExposure: (v)=>Number(v).toFixed(2),
 lighthouseStrength: (v)=>Number(v).toFixed(2),
 focusDistance: (v)=>Math.round(Number(v)||0),
 dofStrength: (v)=>Number(v).toFixed(2),
 focusRange: (v)=>Math.round(Number(v)||0),
 fogStart: (v)=>Math.round(Number(v)||0),
 fogEnd: (v)=>Math.round(Number(v)||0),
 gridDensity: (v)=>Math.round(Number(v)||0),
 gridOpacity: (v)=>Number(v).toFixed(2)
 };
 const oceanRangeKeys = [
 'envIntensity','lightIntensity','exposure','sunElevation','sunAzimuth','timeScale','choppiness',
 'amplitude0','amplitude1','amplitude2','amplitude3','amplitude4','amplitude5',
 'wavelength0','wavelength1','wavelength2','wavelength3','wavelength4','wavelength5',
 'speed0','speed1','speed2','speed3','speed4','speed5',
 'foamAmount','foamBias','foamScale','maxGloss','roughnessScale',
 'horizonZStart','horizonZEnd','horizonBoost',
 'microScale','microFreq','microWaveScale',
 'bloomStrength','vignetteStrength','grainAmount',
 'rayStrength','rayDecay','rayExposure',
 'lighthouseStrength','focusDistance','dofStrength','focusRange',
 'fogStart','fogEnd','gridDensity','gridOpacity'
 ];
 const oceanColorKeys = ['skyTopColor','skyMidColor','skyBotColor','deepColor','shallowColor','foamColor','horizonColor','fogColor'];
 const oceanToggleKeys = ['showGrid','showSphere','showTowers','showFloaters','enableBloom','enableVignette','enableRays','enableLighthouse'];
 let graphicsPanelVisible = false;
 let oceanPanelVisible = false;

 const sliderFormatters = {
 bloomStrength: (v)=>v.toFixed(2),
 bloomRadius: (v)=>v.toFixed(2),
 exposure: (v)=>v.toFixed(2),
 dofAperture: (v)=>v.toFixed(4),
 dofMaxBlur: (v)=>v.toFixed(4),
 lightRotation: (v)=>`${Math.round(Number(v)||0)} `,
 lightStrength: (v)=>Number(v).toFixed(2),
 fogDensity: (v)=>v.toFixed(3),
 outlineStrength: (v)=>v.toFixed(1),
 outlineThickness: (v)=>v.toFixed(2),
 motionDamping: (v)=>v.toFixed(3)
 };

 function updateSliderDisplay(key, value){
 const span = graphicsSliderDisplays[key];
 if(!span) return;
 const formatter = sliderFormatters[key] || ((v)=>v.toFixed(2));
 span.textContent = formatter(Number(value));
 }

 function syncGraphicsSettings(){
 if(!Scene.getGraphicsSettings) return;
 const settings = Scene.getGraphicsSettings();
 if(!settings) return;
 if(graphicsControls.hdri) graphicsControls.hdri.checked = !!settings.hdri;
 if(graphicsControls.lights) graphicsControls.lights.checked = !!settings.lights;
 if(graphicsControls.darkBg) graphicsControls.darkBg.checked = !!settings.darkBg;
 if(graphicsControls.bloom) graphicsControls.bloom.checked = !!settings.bloomEnabled;
 if(graphicsControls.bloomStrength){ graphicsControls.bloomStrength.value = settings.bloomStrength; updateSliderDisplay('bloomStrength', settings.bloomStrength); }
 if(graphicsControls.bloomRadius){ graphicsControls.bloomRadius.value = settings.bloomRadius; updateSliderDisplay('bloomRadius', settings.bloomRadius); }
 if(graphicsControls.exposure){ graphicsControls.exposure.value = settings.exposure; updateSliderDisplay('exposure', settings.exposure); }
 if(graphicsControls.lightRotation){ graphicsControls.lightRotation.value = settings.lightRotation ?? 0; updateSliderDisplay('lightRotation', settings.lightRotation ?? 0); }
 if(graphicsControls.lightStrength){ graphicsControls.lightStrength.value = settings.lightStrength ?? 1; updateSliderDisplay('lightStrength', settings.lightStrength ?? 1); }
 if(graphicsControls.dof) graphicsControls.dof.checked = !!settings.dofEnabled;
 if(graphicsControls.dofAperture){ graphicsControls.dofAperture.value = settings.dofAperture; updateSliderDisplay('dofAperture', settings.dofAperture); }
 if(graphicsControls.dofMaxBlur){ graphicsControls.dofMaxBlur.value = settings.dofMaxBlur; updateSliderDisplay('dofMaxBlur', settings.dofMaxBlur); }
 if(graphicsControls.transmission) graphicsControls.transmission.checked = !!settings.transmission;
 if(graphicsControls.ground) graphicsControls.ground.checked = !!settings.solidGround;
 if(graphicsControls.mirror){
 graphicsControls.mirror.checked = !!settings.mirror && !settings.solidGround;
 graphicsControls.mirror.disabled = !!settings.solidGround;
 }
 if(graphicsControls.waveGrid) graphicsControls.waveGrid.checked = !!settings.waveGrid;
 if(graphicsControls.fxaa) graphicsControls.fxaa.checked = !!settings.fxaa;
 if(graphicsControls.fog) graphicsControls.fog.checked = !!settings.fogEnabled;
 if(graphicsControls.fogDensity){ graphicsControls.fogDensity.value = settings.fogDensity; updateSliderDisplay('fogDensity', settings.fogDensity); }
 if(graphicsControls.outline) graphicsControls.outline.checked = !!settings.outlineEnabled;
 if(graphicsControls.outlineStrength){ graphicsControls.outlineStrength.value = settings.outlineStrength; updateSliderDisplay('outlineStrength', settings.outlineStrength); }
 if(graphicsControls.outlineThickness){ graphicsControls.outlineThickness.value = settings.outlineThickness; updateSliderDisplay('outlineThickness', settings.outlineThickness); }
 if(graphicsControls.motion) graphicsControls.motion.checked = !!settings.motionEnabled;
 if(graphicsControls.motionDamping){ graphicsControls.motionDamping.value = settings.motionDamping; updateSliderDisplay('motionDamping', settings.motionDamping); }
 }

 function setGraphicsControlsEnabled(enabled){
 const settings = Scene.getGraphicsSettings ? Scene.getGraphicsSettings() : null;
 Object.entries(graphicsControls).forEach(([key, ctrl])=>{
 if(!ctrl) return;
 const mirrorLocked = (key==='mirror' && settings?.solidGround);
 ctrl.disabled = !enabled || mirrorLocked;
 });
 if(graphicsPanelHint) graphicsPanelHint.style.display = enabled ? 'none' : 'block';
 }

 function setOceanControlsEnabled(enabled){
 const settings = Scene.getOceanSettings ? Scene.getOceanSettings() : null;
 const oceanActive = !!settings?.enabled;
 const allow = enabled && oceanActive;
 Object.entries(oceanControls).forEach(([key, ctrl])=>{
 if(!ctrl) return;
 if(key === 'enable'){ ctrl.disabled = !enabled; return; }
 if(key === 'screenshot'){ ctrl.disabled = !allow; return; }
 ctrl.disabled = !allow;
 });
 if(oceanPanelHint) oceanPanelHint.style.display = allow ? 'none' : 'block';
 }

 function updateOceanButton(settings){
 if(!els.oceanSettingsBtn) return;
 const enabled = !!settings?.enabled;
 const presentActive = Scene.isPresentEnabled ? Scene.isPresentEnabled() : false;
 els.oceanSettingsBtn.classList.toggle('good', enabled && presentActive);
 els.oceanSettingsBtn.classList.toggle('warn', enabled && !presentActive);
 }

 function updateOceanDisplay(key, value){
 const span = oceanValueDisplays[key];
 if(!span) return;
 const formatter = oceanSliderFormatters[key];
 const num = Number(value);
 if(formatter){ span.textContent = formatter(num); }
 else if(Number.isFinite(num)){ span.textContent = num.toFixed(2); }
 else { span.textContent = value == null ? '' : String(value); }
 }

 function syncOceanSettings(){
 if(!Scene.getOceanSettings) return;
 const settings = Scene.getOceanSettings() || {};
 if(oceanControls.enable) oceanControls.enable.checked = !!settings.enabled;
 oceanRangeKeys.forEach((key)=>{
 const ctrl = oceanControls[key];
 if(!ctrl) return;
 const val = settings[key];
 if(val == null) return;
 ctrl.value = val;
 updateOceanDisplay(key, val);
 });
 oceanColorKeys.forEach((key)=>{
 const ctrl = oceanControls[key];
 if(!ctrl) return;
 if(settings[key]) ctrl.value = settings[key];
 });
 oceanToggleKeys.forEach((key)=>{
 const ctrl = oceanControls[key];
 if(!ctrl) return;
 ctrl.checked = !!settings[key];
 });
 const presentActive = Scene.isPresentEnabled ? Scene.isPresentEnabled() : false;
 setOceanControlsEnabled(presentActive);
 updateOceanButton(settings);
 }

 function showOceanPanel(){
 if(!oceanPanel) return;
 oceanPanelVisible = true;
 oceanPanel.style.display = 'block';
 syncOceanSettings();
 }

 function hideOceanPanel(){
 if(!oceanPanel) return;
 oceanPanelVisible = false;
 oceanPanel.style.display = 'none';
 }

 function toggleOceanPanel(){
 if(oceanPanelVisible) hideOceanPanel(); else showOceanPanel();
 }

 function updatePresentButton(state){
 if(!els.presentToggle) return;
 els.presentToggle.textContent = state ? '?? Present: ON' : '?? Present: OFF';
 if(state){ els.presentToggle.classList.add('good'); }
 else { els.presentToggle.classList.remove('good'); }
 }
 function updateDpadPresent(state){
 try{
 const btn = document.querySelector('#dpad .dp.present');
 if(!btn) return;
 btn.classList.toggle('active', state);
 btn.setAttribute('aria-pressed', state ? 'true' : 'false');
 btn.textContent = state ? ' ' : '?';
 btn.title = state ? 'Return to Create Mode' : 'Enter Present Mode';
 }catch(e){ console.warn('Update D-pad present failed', e); }
 }
 function syncPresentUI(state){
 const active = !!state;
 updatePresentButton(active);
 setGraphicsControlsEnabled(active);
 syncGraphicsSettings();
 setOceanControlsEnabled(active);
 syncOceanSettings();
 updateDpadPresent(active);
 }

 let lastCrystalState = document.body?.classList?.contains('crystal-2d') || false;
 function applyCrystalStyle(enabled){
 const want = !!enabled;
 if(els.crystalToggle && els.crystalToggle.checked !== want){
 els.crystalToggle.checked = want;
 }
 if(lastCrystalState === want){
 if(!want){ try{ document.body.classList.remove('crystal-2d'); }catch{} }
 return;
 }
 lastCrystalState = want;
 try{
 if(want){ document.body.classList.add('crystal-2d'); }
 else { document.body.classList.remove('crystal-2d'); }
 }catch{}
 }

 function showGraphicsPanel(){
 if(!graphicsPanel) return;
 graphicsPanelVisible = true;
 graphicsPanel.style.display = 'block';
 syncGraphicsSettings();
 setGraphicsControlsEnabled(Scene.isPresentEnabled ? Scene.isPresentEnabled() : false);
 }

 function hideGraphicsPanel(){
 if(!graphicsPanel) return;
 graphicsPanelVisible = false;
 graphicsPanel.style.display = 'none';
 }

 function toggleGraphicsPanel(){
 if(graphicsPanelVisible) hideGraphicsPanel(); else showGraphicsPanel();
 }

 function init(){
 console.log('UI.init: starting, checking elements...');
 console.log('UI.init: found elements:', {
 centerHome: !!els.centerHome,
 viewMainframe: !!els.viewMainframe,
 toggleGrid: !!els.toggleGrid,
 toggleAxes: !!els.toggleAxes,
 physicsBtn: !!els.physicsBtn,
 reset: !!els.reset
 });
 if(!Store.getState().ui?.crystal2D){
 try{ document.body.classList.remove('crystal-2d'); }catch{}
 lastCrystalState = false;
 if(els.crystalToggle){ els.crystalToggle.checked = false; }
 }
 // Touch-mode scaling
 try{ if(("ontouchstart" in window) || (navigator.maxTouchPoints>0) || (navigator.msMaxTouchPoints>0)){ document.body.classList.add('touch'); } }catch{}
 els.apply.onclick=()=>{ 
 const s=Store.getState().selection; if(!s.focus) return; 
 const anchor={arrId:s.arrayId,...s.focus};
 const formula=els.fx.value.trim();
 // Wrap user apply in a single atomic transaction
 const tx = Write.start('user.applyFx','User applying formula');
 Formula.executeAt(anchor, formula, tx);
 Write.commit(tx);
 updateFocusChip(); 
 };
 // 2D hover sync: detect hovered cell and propagate to 3D
 try{
 const sheetEl = document.getElementById('sheet');
 sheetEl?.addEventListener('mousemove', (e)=>{
 const td = e.target && e.target.closest && e.target.closest('td.cell');
 if(td){
 const x=+td.dataset.x, y=+td.dataset.y, z=+td.dataset.z; 
 const arrId = Store.getState().selection?.arrayId || Object.values(Store.getState().arrays)[0]?.id || 1;
 setHovered2D(arrId, {x,y,z});
 } else {
 setHovered2D(null, null);
 }
 }, true);
 sheetEl?.addEventListener('mouseleave', ()=> setHovered2D(null, null), true);
 }catch{}
 // Live syntax highlighting for formula input
 const syncFxHighlight = ()=>{
 const raw = els.fx.value || '';
 // Escape HTML
 const esc = (s)=> s.replace(/[&<>]/g, ch=> ({'&':'&amp;','<':'&lt;','>':'&gt;'}[ch]));
 let h = esc(raw);
 // Strings in double quotes
 h = h.replace(/"([^"\\]|\\.)*"/g, m=> `<span class="tok-str">${esc(m)}</span>`);
 // Ranges @[x,y,z,a]
 h = h.replace(/@\[\-?\d+\,\-?\d+\,\-?\d+\,\-?\d+\]/g, m=> `<span class="tok-range">${esc(m)}</span>`);
 // Numbers (standalone) avoid coloring inside quotes by running after strings
 h = h.replace(/(?<![A-Za-z0-9_@\"])(\-?\d+(?:\.\d+)?)(?![A-Za-z0-9_\"])/g, (m)=> `<span class="tok-num">${m}</span>`);
 els.fxHighlight.innerHTML = h || '';
 };
 // Keep formula bar and direct editor in sync in real time
 els.fx.addEventListener('input', ()=>{ 
 try{ if(els.direct && els.direct.style.display==='block'){ els.direct.value = els.fx.value; } }catch{}
 syncFxHighlight();
 });
 // Initialize once
 syncFxHighlight();
 els.fx.addEventListener('keydown',e=>{ if(e.key==='Enter'){ e.preventDefault(); e.stopPropagation(); els.apply.click(); els.fx.blur(); }});
 if(els.toggleFxPanel) els.toggleFxPanel.onclick=toggleFxPanel;
 if(els.fxClose) els.fxClose.onclick=toggleFxPanel;
 // Make the formula row reliably focus the input on single click
 try{
 const fxRow = document.querySelector('#sheet .sheet-fx');
 fxRow?.addEventListener('click', (ev)=>{ if(ev.target!==els.apply) els.fx.focus(); }, true);
 const fxHL = document.getElementById('fxHighlight');
 fxHL?.addEventListener('click', ()=> els.fx.focus(), true);
 }catch{}
 // Make sheet draggable with immediate response (no transition while dragging)
 const sheetEl=document.getElementById('sheet'); let drag=false, sx=0, sy=0, sl=0, st=0, prevTrans='';
 const beginDrag=(clientX, clientY)=>{ drag=true; sheetEl.classList.add('dragging'); sx=clientX; sy=clientY; const r=sheetEl.getBoundingClientRect(); sl=r.left; st=r.top; prevTrans=sheetEl.style.transition; sheetEl.style.transition='none'; // kill easing
 // If mobile intro left a centering transform, clear it so absolute dragging is literal
 sheetEl.style.transform='none';
 if(document.body.classList.contains('touch')){ sheetEl.dataset.touchFreed = '1'; }
 };
 const moveDrag=(clientX, clientY)=>{ if(!drag) return; const dx=clientX-sx, dy=clientY-sy; sheetEl.style.left=(sl+dx)+'px'; sheetEl.style.top=(st+dy)+'px'; sheetEl.style.bottom='auto'; };
 const endDrag=()=>{ if(!drag) return; drag=false; sheetEl.classList.remove('dragging'); sheetEl.style.transition=prevTrans||''; };
 sheetEl.addEventListener('mousedown',e=>{ if(e.target.closest('.sheet-head')){ beginDrag(e.clientX, e.clientY); e.preventDefault(); }});
 window.addEventListener('mousemove',e=> moveDrag(e.clientX, e.clientY));
 window.addEventListener('mouseup', endDrag);
 // Pointer events for touch
 sheetEl.addEventListener('pointerdown',e=>{ if(e.pointerType==='touch' && e.target.closest('.sheet-head')){ beginDrag(e.clientX, e.clientY); e.preventDefault(); sheetEl.setPointerCapture?.(e.pointerId); }});
 window.addEventListener('pointermove',e=>{ if(e.pointerType==='touch') moveDrag(e.clientX, e.clientY); });
 window.addEventListener('pointerup',e=>{ if(e.pointerType==='touch') endDrag(); });
 // Resizable via corner handle
 const res=document.getElementById('sheetResizer'); let resizing=false, rw=0,rh=0,rx=0,ry=0, resizePrevTrans='';
 res.addEventListener('mousedown',e=>{ resizing=true; const r=sheetEl.getBoundingClientRect(); rw=r.width; rh=r.height; rx=e.clientX; ry=e.clientY; resizePrevTrans=sheetEl.style.transition; sheetEl.style.transition='none'; e.stopPropagation(); e.preventDefault(); });
 window.addEventListener('mousemove',e=>{ if(!resizing) return; const dw=e.clientX-rx, dh=e.clientY-ry; sheetEl.style.width=(rw+dw)+'px'; sheetEl.style.height=(rh+dh)+'px'; });
 window.addEventListener('mouseup',()=>{ if(!resizing) return; resizing=false; sheetEl.style.transition=resizePrevTrans||''; });

 if(els.centerHome) els.centerHome.onclick=()=>{ const home=Store.getState().arrays[1]; if(home){ Scene.centerOnArray(home); Actions.setSelection(1,{x:0,y:2,z:0}); }};
 if(els.viewMainframe) els.viewMainframe.onclick=()=>{
 const mf=Store.getState().arrays[-1];
 if(mf){
 // Diegetic toggle: write formula to a control cell and execute
 const anchor={arrId:-1,x:0,y:mf.size.y-1,z:0};
 const currentlyHidden=!!mf.hidden;
 const formula = currentlyHidden? '=HIDE(@[0,'+(mf.size.y-1)+',0,-1],0,1)' : '=HIDE(@[0,'+(mf.size.y-1)+',0,-1],1,1)';
 Formula.executeAt(anchor, formula);
 // Move camera to show mainframe at its offset position
 const off = mf.offset || {x:0,y:0,z:0};
 Scene.getControls().target.set(off.x, off.y, off.z);
 Scene.getCamera().position.set(off.x + mf.size.x*1.2, off.y + mf.size.y*1.2, off.z + mf.size.z*1.8);
 Actions.setSelection(-1,{x:0,y:mf.size.y-1,z:0}); 
 UI.renderSheet(); // refresh 2D view
 }
 };
 if(els.toggleGrid) els.toggleGrid.onclick=Actions.toggleGrid;
 if(els.toggleAxes) els.toggleAxes.onclick=Actions.toggleAxes;
 const presentInitial = Scene.isPresentEnabled ? Scene.isPresentEnabled() : false;
 syncPresentUI(presentInitial);
 if(els.presentToggle){
 els.presentToggle.onclick=()=>{
 const state = Actions.togglePresentMode();
 const actual = Scene.isPresentEnabled ? Scene.isPresentEnabled() : state;
 syncPresentUI(actual);
 };
 }
 applyCrystalStyle(Store.getState().ui?.crystal2D);
 if(els.crystalToggle){
 els.crystalToggle.checked = !!Store.getState().ui?.crystal2D;
 if(!els.crystalToggle._wired){
 els.crystalToggle._wired = true;
 els.crystalToggle.addEventListener('change',(e)=>{
 Actions.setCrystal2D?.(!!e.target.checked);
 });
 }
 }
 if(els.graphicsSettingsBtn){
 els.graphicsSettingsBtn.onclick=()=>{ toggleGraphicsPanel(); };
 }
 if(graphicsClose && !graphicsClose._wired){
 graphicsClose._wired = true;
 graphicsClose.addEventListener('click',(e)=>{ e.preventDefault(); hideGraphicsPanel(); });
 }
 if(els.oceanSettingsBtn){
 els.oceanSettingsBtn.onclick=()=>{ 
 // Auto-enable ocean when opening settings
 Actions.setOceanEnabled(true);
 if(!(Scene.isPresentEnabled ? Scene.isPresentEnabled() : false)){
 Actions.togglePresentMode();
 syncPresentUI(true);
 }
 toggleOceanPanel(); 
 };
 }
 if(oceanClose && !oceanClose._wired){
 oceanClose._wired = true;
 oceanClose.addEventListener('click',(e)=>{ e.preventDefault(); hideOceanPanel(); });
 }
 if(els.physicsBtn && !els.physicsBtn._wired){
 els.physicsBtn._wired = true;
 // Update button appearance based on current debug state
 const updatePhysicsButtonAppearance = ()=>{
 const debugMode = !!Store.getState().scene?.physicsDebugAll;
 const physicsActive = !!Store.getState().scene?.physics;
 if(debugMode){
 els.physicsBtn.textContent = physicsActive ? '? Physics (DEBUG) ON' : '? Physics (DEBUG)';
 els.physicsBtn.classList.add('warn');
 } else {
 els.physicsBtn.textContent = physicsActive ? '? Physics ON' : '? Physics';
 els.physicsBtn.classList.remove('warn');
 }
 els.physicsBtn.title = debugMode ? 'Shift+Click: Disable Debug Mode | Click: Toggle Physics' : 'Shift+Click: Enable Debug Mode (All Arrays) | Click: Toggle Physics';
 };
 updatePhysicsButtonAppearance();
 els.physicsBtn.addEventListener('click',(ev)=>{
 try{ ev?.preventDefault?.(); }catch{}
 try{ els.physicsBtn.blur(); }catch{}
 // Shift-click to toggle debug mode (enables physics on all arrays)
 if(ev?.shiftKey){
 const current = !!Store.getState().scene?.physicsDebugAll;
 console.log(`[PHYSICS DEBUG] Shift-click detected - current state: ${current}`);
 console.log(`[PHYSICS DEBUG] Calling Scene.setPhysicsDebugAll(${!current})`);
 Scene.setPhysicsDebugAll?.(!current);
 const newState = !!Store.getState().scene?.physicsDebugAll;
 console.log(`[PHYSICS DEBUG] After call, scene.physicsDebugAll = ${newState}`);
 updatePhysicsButtonAppearance();
 showToast?.(newState ? '?? Physics Debug: ALL arrays physics-enabled' : '? Physics Debug: Disabled');
 } else {
 console.log(`[PHYSICS] Normal click on physics button`);
 Actions.togglePhysics();
 // Update button after physics toggle
 setTimeout(()=> updatePhysicsButtonAppearance(), 100);
 }
 });
 }
 // Render mode button removed - always simple mode
 if(els.reset) els.reset.onclick=()=>location.reload();
 // Toggle Chunk LOD manager
 const chunksBtn = document.getElementById('toggleChunks');
 if(chunksBtn){
 chunksBtn.textContent = 'Chunks: ON';
 chunksBtn.classList.add('good');
 chunksBtn.disabled = true;
 chunksBtn.title = 'Chunk mode is always ON';
 }

 const checkboxBindings = {
 hdri:'hdri', lights:'lights', darkBg:'darkBg', bloom:'bloomEnabled',
 dof:'dofEnabled', transmission:'transmission', mirror:'mirror', ground:'solidGround', waveGrid:'waveGrid',
 fxaa:'fxaa', fog:'fogEnabled', outline:'outlineEnabled', motion:'motionEnabled'
 };
 Object.entries(checkboxBindings).forEach(([key, setting])=>{
 const ctrl = graphicsControls[key];
 if(!ctrl) return;
 ctrl.addEventListener('change',(e)=>{
 if(setting === 'solidGround'){
 const next = !!e.target.checked;
 const patch = next ? { solidGround: true, mirror: false } : { solidGround: false };
 Actions.updateGraphicsSettings(patch);
 }else{
 Actions.updateGraphicsSettings({ [setting]: !!e.target.checked });
 }
 syncGraphicsSettings();
 });
 });

 const rangeBindings = {
 bloomStrength:'bloomStrength',
 bloomRadius:'bloomRadius',
 exposure:'exposure',
 dofAperture:'dofAperture',
 dofMaxBlur:'dofMaxBlur',
 lightRotation:'lightRotation',
 lightStrength:'lightStrength',
 fogDensity:'fogDensity',
 outlineStrength:'outlineStrength',
 outlineThickness:'outlineThickness',
 motionDamping:'motionDamping'
 };
 Object.entries(rangeBindings).forEach(([key, setting])=>{
 const ctrl = graphicsControls[key];
 if(!ctrl) return;
 ctrl.addEventListener('input',(e)=>{
 const value = parseFloat(e.target.value);
 Actions.updateGraphicsSettings({ [setting]: value });
 updateSliderDisplay(key, value);
 });
 });

 if(oceanControls.enable){
 oceanControls.enable.addEventListener('change',(e)=>{
 const desired = !!e.target.checked;
 Actions.setOceanEnabled(desired);
 if(desired && !(Scene.isPresentEnabled ? Scene.isPresentEnabled() : false)){
 showToast?.('Enable Present mode to view the ocean backdrop.');
 }
 syncOceanSettings();
 });
 }

 oceanRangeKeys.forEach((key)=>{
 const ctrl = oceanControls[key];
 if(!ctrl) return;
 ctrl.addEventListener('input',(e)=>{
 const value = parseFloat(e.target.value);
 if(!Number.isFinite(value)) return;
 Actions.updateOceanSettings({ [key]: value });
 updateOceanDisplay(key, value);
 // Rebuild grid when density changes
 if(key === 'gridDensity'){
 try{
 OceanBackdrop?.recreateGrid?.();
 }catch(e){
 console.warn('Failed to rebuild ocean grid:', e);
 }
 }
 });
 });

 oceanColorKeys.forEach((key)=>{
 const ctrl = oceanControls[key];
 if(!ctrl) return;
 ctrl.addEventListener('input',(e)=>{
 const value = e.target.value;
 Actions.updateOceanSettings({ [key]: value });
 });
 });

 oceanToggleKeys.forEach((key)=>{
 const ctrl = oceanControls[key];
 if(!ctrl) return;
 ctrl.addEventListener('change',(e)=>{
 Actions.updateOceanSettings({ [key]: !!e.target.checked });
 });
 });

 if(oceanControls.screenshot && !oceanControls.screenshot._wired){
 oceanControls.screenshot._wired = true;
 oceanControls.screenshot.addEventListener('click',(e)=>{
 e.preventDefault();
 Scene.captureOceanScreenshot?.();
 });
 }

 syncGraphicsSettings();
 syncOceanSettings();

 // Save/Load buttons
 try{
 const saveBtn=document.getElementById('saveStateBtn');
 const loadBtn=document.getElementById('loadStateBtn');
 const clearBtn=document.getElementById('clearSaveBtn');
 if(saveBtn && !saveBtn._wired){ 
 saveBtn._wired=true; 
 saveBtn.addEventListener('click', ()=>{ 
 try{ 
 Store.getState().actions.saveState();
 const statusEl = document.getElementById('saveStatus');
 if(statusEl) statusEl.textContent = `Manual save: ${new Date().toLocaleTimeString()}`;
 }catch(e){ console.warn('save click failed', e); } 
 }); 
 }
 if(loadBtn && !loadBtn._wired){ loadBtn._wired=true; loadBtn.addEventListener('click', ()=>{ try{ Store.getState().actions.loadState(); }catch(e){ console.warn('load click failed', e); } }); }
 if(clearBtn && !clearBtn._wired){ clearBtn._wired=true; clearBtn.addEventListener('click', ()=>{ try{ Store.getState().actions.resetSave(); }catch(e){ console.warn('clear save click failed', e); } }); }
 
 // Parse emojis in debug UI
 if(typeof twemoji !== 'undefined'){
 try{ twemoji.parse(document.getElementById('hud'), {folder: 'svg', ext: '.svg', className: 'emoji'}); }catch{}
 }
 }catch{}

 // --- Import Functionality Wiring ---
 try{
 const fileInput = document.getElementById('fileImporter');
 const importBtn = document.getElementById('importFileBtn');
 const pasteBtn = document.getElementById('pasteDataBtn');
 const pasteModal = document.getElementById('pasteModal');
 const pasteInput = document.getElementById('pasteDataInput');
 const processPasteBtn = document.getElementById('processPasteBtn');
 const cancelPasteBtn = document.getElementById('cancelPasteBtn');

 if(importBtn) importBtn.onclick = ()=> fileInput && fileInput.click();
 if(fileInput) fileInput.onchange = (e)=>{
 const file = e.target.files && e.target.files[0];
 if(file){ const r=new FileReader(); r.onload=(ev)=> handleImportedData(ev.target.result, file.name); r.readAsArrayBuffer(file); }
 e.target.value='';
 };
 if(pasteBtn) pasteBtn.onclick=()=>{ if(pasteModal){ pasteModal.style.display='flex'; pasteInput && pasteInput.focus(); } };
 if(cancelPasteBtn) cancelPasteBtn.onclick=()=>{ if(pasteModal) pasteModal.style.display='none'; };
 if(processPasteBtn) processPasteBtn.onclick=()=>{
 const data = pasteInput ? pasteInput.value : '';
 if(String(data||'').trim()) handleImportedData(data, 'PastedData');
 if(pasteModal) pasteModal.style.display='none';
 };

 // Global drag-and-drop
 const dropZone = document.body;
 const overlay = document.getElementById('introOverlay');
 dropZone.addEventListener('dragover',(e)=>{ e.preventDefault(); e.stopPropagation(); if(overlay){ overlay.style.opacity='0.5'; overlay.classList.remove('hidden'); } });
 dropZone.addEventListener('dragleave',(e)=>{ e.preventDefault(); e.stopPropagation(); if(overlay){ overlay.classList.add('hidden'); overlay.style.opacity='1'; } });
 dropZone.addEventListener('drop',(e)=>{ e.preventDefault(); e.stopPropagation(); if(overlay){ overlay.classList.add('hidden'); overlay.style.opacity='1'; }
 const f=e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0]; if(f){ const r=new FileReader(); r.onload=(ev)=> handleImportedData(ev.target.result, f.name); r.readAsArrayBuffer(f); }
 });
 }catch{}

 // Wire up the new color picker (+ Live / Apply / Clear)
 try{
 const picker = document.getElementById('fillColorPicker');
 const swatch = document.getElementById('fillColorSwatch');
 const live = document.getElementById('fillColorLive');
 const applyBtn = document.getElementById('fillColorApply');
 const clearBtn = document.getElementById('fillColorClear');

 function applyColorToSelection(hexOrEmpty){
 const s = Store.getState().selection;
 if (!s?.arrayId || !(s.focus || s.range)) return;

 const tx = Write.start('ui.colorPicker', 'Apply color to selection');
 const cells = [];
 if (s.range) {
 const zStart = s.range.z1 ?? s.range.z;
 const zEnd = s.range.z2 ?? s.range.z;
 for(let z=zStart; z<=zEnd; z++){
 for(let y=s.range.y1; y<=s.range.y2; y++){
 for(let x=s.range.x1; x<=s.range.x2; x++){
 cells.push({x, y, z});
 }
 }
 }
 } else {
 cells.push({...s.focus});
 }

 for(const coord of cells){
 const cell = Scene.getCell(s.arrayId, coord);
 Write.set(tx, s.arrayId, coord, {
 value: cell.value,
 formula: cell.formula,
 meta: { ...(cell.meta||{}), ...(hexOrEmpty ? {color:hexOrEmpty} : {color: ''}) }
 });
 }
 Write.commit(tx);
 }

 if(picker && !picker._wired){
 picker._wired = true;
 // Toggle popover when swatch clicked
 const wrap = document.getElementById('color-picker-wrapper');
 let pop = document.getElementById('colorPopover');
 if(!pop){
 pop = document.createElement('div');
 pop.id = 'colorPopover';
 pop.style.cssText = 'position:absolute; z-index:10020; background:#ffffff; border:1px solid #e5e7eb; border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,0.18); padding:10px; display:none;';
 document.body.appendChild(pop);
 // Prevent clicks inside from closing
 pop.addEventListener('click', (ev)=> ev.stopPropagation());
 }
 if(wrap && !wrap._popover){
 wrap._popover = true;
 // Build in-popover controls (Live | Apply | Clear) and hide external buttons
 try{
 if(pop && !pop._controls){
 pop._controls = true;
 const ctrl = document.createElement('div');
 ctrl.id = 'colorControlsInside';
 ctrl.style.cssText = 'display:flex;gap:8px;align-items:center;margin-top:8px;';
 ctrl.innerHTML = '<button id="fillColorApplyInside" class="btn" style="padding:4px 8px;">Apply</button><button id="fillColorClearInside" class="btn" style="padding:4px 8px;">Clear</button>';
 pop.appendChild(ctrl);
 // Wire
 const applyInside = ctrl.querySelector('#fillColorApplyInside');
 const clearInside = ctrl.querySelector('#fillColorClearInside');
 applyInside?.addEventListener('click', ()=> applyColorToSelection(picker?.value||'#ffffff'));
 clearInside?.addEventListener('click', ()=> applyColorToSelection(''));
 // Hide external controls in sheet toolbar (including old Live and bar preview)
 try{
 if(applyBtn) applyBtn.style.display='none';
 if(clearBtn) clearBtn.style.display='none';
 if(live){ const lab=live.closest('label'); if(lab) lab.style.display='none'; live.style.display='none'; }
 const bar = document.getElementById('fillColorPreview'); if(bar) bar.style.display='none';
 }catch{}
 }
 }catch{}
 wrap.addEventListener('click', (e)=>{
 e.stopPropagation();
 if(pop){
 const rect = wrap.getBoundingClientRect();
 const belowPickerOffset = 260; // place well below native color UI
 const desiredTop = rect.bottom + belowPickerOffset;
 const maxTop = Math.max(0, (window.innerHeight||800) - 120);
 pop.style.left = Math.max(8, Math.min(rect.left, (window.innerWidth||1200) - 220)) + 'px';
 pop.style.top = Math.min(desiredTop, maxTop) + 'px';
 pop.style.display = (pop.style.display==='none'||!pop.style.display) ? 'block' : 'none';
 }
 });
 document.addEventListener('click', ()=>{ if(pop) pop.style.display='none'; }, true);
 }
 picker.addEventListener('input', (e)=>{
 const newColor = String(e.target.value||'').trim();
 if(swatch) swatch.style.backgroundColor = newColor;
 // Live apply is ON by default
 try{ applyColorToSelection(newColor); }catch{}
 });
 }

 // External buttons are deprecated; ensure hidden; hide external Live and bar preview too
 if(applyBtn){ applyBtn.style.display='none'; }
 if(clearBtn){ clearBtn.style.display='none'; }
 if(live){ const lab=live.closest('label'); if(lab) lab.style.display='none'; live.style.display='none'; }
 const bar = document.getElementById('fillColorPreview'); if(bar) bar.style.display='none';
 }catch{}

 // Wire up the new view toggle button
 try{
 const viewToggleBtn = document.getElementById('viewToggleBtn');
 const viewToggleIcon = document.getElementById('viewToggleIcon');
 if(viewToggleBtn && !viewToggleBtn._wired){
 viewToggleBtn._wired = true;
 viewToggleBtn.addEventListener('click', ()=>{
 const S=Store.getState(); const current=S.ui.viewMode||'standard';
 let next='standard';
 // Cycle: standard (gray) -> solid (blue) -> hideEmpty (white) -> standard
 if(current==='standard') next='solid';
 else if(current==='solid') next='hideEmpty';
 else next='standard';

 // Update button fill and stroke per spec
 if(next==='standard'){ // gray fill
 if(viewToggleBtn) viewToggleBtn.style.backgroundColor = '#9ca3af';
 if(viewToggleIcon) viewToggleIcon.style.stroke = '#ffffff';
 showToast('View: Standard Occlusion');
 } else if(next==='solid'){ // blue fill
 if(viewToggleBtn) viewToggleBtn.style.backgroundColor = '#3b82f6';
 if(viewToggleIcon) viewToggleIcon.style.stroke = '#ffffff';
 showToast('View: Solid');
 } else { // hideEmpty: white fill
 if(viewToggleBtn) viewToggleBtn.style.backgroundColor = '#ffffff';
 if(viewToggleIcon) viewToggleIcon.style.stroke = '#5b6170';
 showToast('View: Hide Empty');
 }

 Store.setState(s=>({ ui:{...s.ui, viewMode:next} }));
 // Apply mode immediately to scene
 try{ Scene && Scene.applyViewMode && Scene.applyViewMode(next); }catch{}
 // Reposition value sprites after mode switch (face alignment retained)
 try{ const arrays=Object.values(Store.getState().arrays); arrays.forEach(a=>{ if(!a.hidden && a._frame) updateArrayValueSpritePlacement(a); }); }catch{}
 });

 // Initialize button to current state on load
 const cur = Store.getState().ui.viewMode || 'standard';
 if(cur==='standard'){ viewToggleBtn.style.backgroundColor='#9ca3af'; viewToggleIcon && (viewToggleIcon.style.stroke='#ffffff'); }
 if(cur==='solid'){ viewToggleBtn.style.backgroundColor='#3b82f6'; viewToggleIcon && (viewToggleIcon.style.stroke='#ffffff'); }
 if(cur==='hideEmpty'){ viewToggleBtn.style.backgroundColor='#ffffff'; viewToggleIcon && (viewToggleIcon.style.stroke='#5b6170'); }
 try{ Scene && Scene.applyViewMode && Scene.applyViewMode(cur); }catch{}
 }
 }catch{}
 // Narrative icon wiring
 const termIcon=document.getElementById('terminal-icon');
 // Dedicated debug icon bottom-left (create once, no duplicate flicker)
 let debugIcon=document.getElementById('debug-icon');
 if(!debugIcon){
 debugIcon=document.createElement('div');
 debugIcon.id='debug-icon';
 debugIcon.className='ui-icon';
 debugIcon.style.left='24px';
 debugIcon.style.bottom='24px';
 debugIcon.innerHTML='<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="14" rx="2" ry="2"></rect><line x1="8" y1="21" x2="16" y2="21"></line><line x1="12" y1="17" x2="12" y2="21"></line></svg>';
 document.body.appendChild(debugIcon);
 }
 const padIcon=document.getElementById('notepad-icon');
 const termWin=document.getElementById('terminal');
 const termOut=document.getElementById('term');
 const termClose=document.getElementById('term-close');
 const padWin=document.getElementById('pad');
 // Ensure console windows are hidden on load
 try{ if(termWin) termWin.style.display='none'; if(padWin) padWin.style.display='none'; }catch{}
 const padClose=document.getElementById('pad-close');
 const toast=document.getElementById('toast');
 const showToast2=(msg)=>{ if(toast){ toast.textContent=msg; toast.classList.add('show'); setTimeout(()=>toast.classList.remove('show'),2200); } };
 // Track last pointer type to distinguish touch vs keyboard/mouse
 let lastPointerType = 'mouse';
 window.addEventListener('pointerdown', (e)=>{ lastPointerType = e.pointerType || 'mouse'; }, {passive:true});
 // Make both windows draggable by their headers
 const makeDrag=(winEl)=>{
 const header=winEl?.querySelector('.win-header'); if(!header) return; let down=false,sx=0,sy=0,sl=0,st=0;
 header.addEventListener('mousedown',e=>{ down=true; sx=e.clientX; sy=e.clientY; const r=winEl.getBoundingClientRect(); sl=r.left; st=r.top; e.preventDefault(); });
 window.addEventListener('mousemove',e=>{ if(!down) return; const dx=e.clientX-sx, dy=e.clientY-sy; winEl.style.left=(sl+dx)+'px'; winEl.style.top=(st+dy)+'px'; winEl.style.transform='translate(0,0)'; });
 window.addEventListener('mouseup',()=>{ down=false; });
 };
 const makeResizable=(winEl)=>{
 if(!winEl) return;
 const handle=winEl.querySelector('.pad-resizer');
 if(!handle || handle._wired) return;
 handle._wired=true;
 handle.addEventListener('pointerdown', (e)=>{
 e.preventDefault();
 handle.setPointerCapture?.(e.pointerId);
 const rect=winEl.getBoundingClientRect();
 const startX=e.clientX, startY=e.clientY;
 const startW=rect.width, startH=rect.height;
 const minW=320, minH=220;
 const move=(evt)=>{
 const nextW=Math.max(minW, startW + (evt.clientX - startX));
 const nextH=Math.max(minH, startH + (evt.clientY - startY));
 winEl.style.width=nextW+'px';
 winEl.style.height=nextH+'px';
 };
 const up=()=>{
 try{ handle.releasePointerCapture && handle.hasPointerCapture && handle.hasPointerCapture(e.pointerId) && handle.releasePointerCapture(e.pointerId); }
 catch{}
 window.removeEventListener('pointermove', move);
 window.removeEventListener('pointerup', up);
 window.removeEventListener('pointercancel', up);
 };
 window.addEventListener('pointermove', move);
 window.addEventListener('pointerup', up, {once:true});
 window.addEventListener('pointercancel', up, {once:true});
 });
 };
 if(padWin) makeResizable(padWin);
 const openTerm=()=>{ const el=document.getElementById('terminal'); if(el){ el.style.display='flex'; makeDrag(el); runLogPaced(); } };
 const closeTerm=()=>{ if(termWin){ termWin.style.display='none'; } };
 const openPad=()=>{ const el=document.getElementById('pad'); if(el){ el.style.display='flex'; const term=document.getElementById('terminal'); if(term){ el.style.width = getComputedStyle(term).width; } makeDrag(el); makeResizable(el); } };
 const closePad=()=>{ if(padWin){ padWin.style.display='none'; } };
 const wireNarrative=()=>{
 const ti=document.getElementById('terminal-icon');
 const pi=document.getElementById('notepad-icon');
 const tc=document.getElementById('term-close');
 const pc=document.getElementById('pad-close');
 if(ti && !ti._wired){ ti._wired=true; ti.addEventListener('click',()=>{ console.log('Terminal icon click'); openTerm(); }, false); ti.tabIndex=0; ti.title='Open Celli_Log.txt'; }
 if(pi && !pi._wired){ pi._wired=true; pi.addEventListener('click',()=>{ console.log('Notepad icon click'); openPad(); }, false); pi.tabIndex=0; pi.title='ty.txt'; }
 if(tc && !tc._wired){ tc._wired=true; tc.addEventListener('click',()=>{ console.log('Terminal close'); closeTerm(); }); }
 if(pc && !pc._wired){ pc._wired=true; pc.addEventListener('click',()=>{ console.log('Notepad close'); closePad(); }); }
 };
 wireNarrative();
 // Debug panel collapse/expand via icon; ensure stacking above other UI
 const hud=document.getElementById('hud');
 const dbg=document.getElementById('debug-icon');
 // Hide HUD on load; terminal/notepad already hidden above
 try{ if(hud){ hud.style.display='none'; hud.style.visibility='hidden'; } }catch{}
 // Robust toggle helper
 const toggleHud=()=>{
 try{
 const el=document.getElementById('hud'); if(!el) return;
 const isHidden = (el.style.display==='none' || el.style.visibility==='hidden' || getComputedStyle(el).display==='none');
 if(isHidden){ el.style.display='block'; el.style.visibility='visible'; }
 else { el.style.display='none'; el.style.visibility='hidden'; }
 el.style.zIndex = '10004';
 }catch{}
 };
 const debugCloseBtn = document.getElementById('debug-close');
 if(debugCloseBtn && !debugCloseBtn._wired){
 debugCloseBtn._wired = true;
 debugCloseBtn.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); try{ hud.style.display='none'; }catch{} });
 }
 if(dbg && !dbg._wired){
 dbg._wired = true;
 let lastHudToggle = 0;
 const safeToggle = ()=>{ const now=Date.now(); if(now - lastHudToggle < 220) return; lastHudToggle = now; toggleHud(); };
 dbg.addEventListener('click', (e)=>{ e.preventDefault(); safeToggle(); });
 // Also handle pointerup (covers touch) to ensure one, reliable toggle
 dbg.addEventListener('pointerup', (e)=>{ if(e.button===0 || e.pointerType){ e.preventDefault(); safeToggle(); } });
 dbg.setAttribute('title','Debug Console');
 dbg.setAttribute('role','button');
 dbg.tabIndex = 0;
 dbg.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' '){ e.preventDefault(); safeToggle(); }});
 }
 setTimeout(wireNarrative,0);
 setTimeout(wireNarrative,500);

 // Hard fallback: ensure a first click on any 2D cell will trigger intro if not yet fired
 try{
 const sheetWrap = document.getElementById('sheet');
 if(sheetWrap && !sheetWrap._introFallbackWired){
 const handler = (ev)=>{
 try{
 if(window.__INTRO_FIRED) return; // Already handled
 const td = ev.target && ev.target.closest ? ev.target.closest('td.cell') : null;
 // Prefer current selection post-re-render (more reliable than original target)
 const sel = Store.getState().selection || {};
 const useSel = sel && sel.arrayId!=null && sel.focus;
 const x = useSel ? sel.focus.x : ((td && +td.dataset.x) || 0);
 const y = useSel ? sel.focus.y : ((td && +td.dataset.y) || 0);
 const z = useSel ? sel.focus.z : ((td && +td.dataset.z) || 0);
 const arrId = useSel ? sel.arrayId : ((currentArray()?.id) || 1);
 const tx = Write.start('onclick.fallback','Intro fallback');
 Formula.runOnceAt({arrId:arrId, x, y, z}, '=STARTINTROEXPERIENCE()', tx);
 Write.commit(tx);
 // Also trigger UI path to guarantee overlay collapse
 UI.debugIntroState?.('fallback-click');
 const didHide = window.UI?.hideIntroOverlay?.();
 if(didHide){ window.__INTRO_FIRED = true; window.UI?.triggerIntroCollapse?.(); UI.debugIntroState?.('fallback-collapsed'); }
 else { UI.kickIntroSequence?.('fallback-click'); }
 }catch(e){ console.warn('Intro fallback click failed', e); }
 };
 // Use multiple events for robustness across re-renders
 sheetWrap.addEventListener('mouseup', handler, true);
 sheetWrap.addEventListener('pointerup', handler, true);
 sheetWrap.addEventListener('click', handler, true);
 sheetWrap._introFallbackWired = true;
 }
 }catch{}

 // Global clipboard shortcuts: Ctrl/Cmd+C / Ctrl/Cmd+V
 try{
 window.addEventListener('keydown', async (e)=>{
 const isMod = e.ctrlKey || e.metaKey;
 if(!isMod) return;
 // Let inputs handle their own clipboard behavior
 const tag = (document.activeElement?.tagName||'').toUpperCase();
 if(tag==='INPUT' || tag==='TEXTAREA') return;

 const state = Store.getState();
 const sel = state?.selection;
 if(!sel || !sel.arrayId || !sel.focus) return;
 const arrId = sel.arrayId, {x,y,z} = sel.focus;

 // Copy value (never formula)
 if(e.key==='c' || e.key==='C'){
 e.preventDefault();
 try{
 const val = Formula.getCellValue({arrId, x, y, z});
 await navigator.clipboard.writeText(String(val??''));
 showToast('Copied');
 }catch(err){ console.warn('Clipboard copy failed', err); }
 return;
 }

 // Paste as literal value (do not treat leading '=' as formula)
 if(e.key==='v' || e.key==='V'){
 e.preventDefault();
 try{
 const text = await navigator.clipboard.readText();
 const tx = Write.start('user.paste','Paste into cell');
 Write.set(tx, arrId, {x,y,z}, { value: text, formula: null });
 Write.commit(tx);
 UI.updateFocusChip?.();
 }catch(err){ console.warn('Clipboard paste failed', err); }
 return;
 }
 }, true);
 }catch{}

 // Terminal narrative (reference-grade): paced typer, CPU meter, glitch/glow arc
 let T=[], I=[], cpuPhase=0, cpuVal=10, cpuPaused=false, cpuHold=0, cpuBurstUntil=0;
 const later=(ms,fn)=>{ const id=setTimeout(fn,ms); T.push(id); return id; };
 const every=(ms,fn)=>{ const id=setInterval(fn,ms); I.push(id); return id; };
 function killTimers(){ T.forEach(clearTimeout); I.forEach(clearInterval); T=[]; I=[]; cpuPhase=0; cpuBurstUntil=0; cpuPaused=false; cpuHold=0; }
 function pauseCpu(ms){ cpuHold++; cpuPaused=true; later(ms, ()=>{ cpuHold=Math.max(0,cpuHold-1); if(cpuHold===0) cpuPaused=false; }); }
 function cpuBurst(ms){ const start = Math.max(Date.now(), cpuBurstUntil); cpuBurstUntil = start + ms; }
 function dwellMsFor(text, {base=900, perWord=240, comma=140, period=420, question=460, exclaim=460, ellipsis=600, factor=1}={}){
 const words=(text.trim().split(/\s+/).filter(Boolean)).length;
 const c=(text.match(/,/g)||[]).length; const p=(text.match(/[\.]/g)||[]).length;
 const q=(text.match(/[\?]/g)||[]).length; const e=(text.match(/[!]/g)||[]).length; const el=(text.match(/ |\.{3}/g)||[]).length;
 return Math.round((base + words*perWord + c*comma + p*period + q*question + e*exclaim + el*ellipsis)*factor);
 }
 function typeInto(target, text, {speed=22, prefix='> ', cls='soft', glitch=false, dwellFactor=1, minType=500, scripted=true}={}){
 const s=document.createElement('span'); s.className='cursor '+cls+(glitch?' glitch':''); if(glitch) s.dataset.text=''; s.textContent=prefix; target.appendChild(s);
 const extraPause=(scripted && !glitch)? (3000+Math.floor(Math.random()*2000)) : 0;
 let i=0; (function tick(){ if(i<text.length){ const ch=text.charAt(i++); if(glitch) s.dataset.text+=ch; s.textContent+=ch; target.scrollTop=target.scrollHeight; later(speed, tick);} else { s.classList.remove('cursor'); target.appendChild(document.createElement('br')); if(extraPause>0) pauseCpu(extraPause);} })();
 const typeDur=Math.max(minType, text.length*speed+200); const dwell=dwellMsFor(text,{factor:dwellFactor});
 return typeDur + dwell + extraPause;
 }
 function echoThought(text, repeats=3, {baseSpeed=20, decay=0.5, startGap=160, artifact=false, dwellFactor=0.6, scripted=false}={}){
 for(let i=0;i<repeats;i++) later(i*startGap, ()=> typeInto(termOut, text, {speed:Math.max(10, baseSpeed - i*baseSpeed*decay), cls: artifact? 'artifact':'soft', dwellFactor, scripted}));
 return repeats*startGap + dwellMsFor(text,{factor:dwellFactor});
 }
 function forkThought(textL, textR, {speed=20, cls='soft', dwellFactor=0.9, scripted=false}={}){
 const wrap=document.createElement('div'); wrap.className='lane-wrap'; const left=document.createElement('div'); left.className='lane'; const right=document.createElement('div'); right.className='lane';
 termOut.appendChild(wrap); wrap.appendChild(left); wrap.appendChild(right);
 const d1=typeInto(left, textL, {speed, cls, dwellFactor, scripted}); const d2=typeInto(right, textR, {speed, cls, dwellFactor, scripted});
 return Math.max(d1,d2)+300;
 }
 const bar=(p,w=22)=>{ const f=Math.floor(p/100*w), frac=(p/100*w-f); const fc=frac>0.75?' ':frac>0.5?' ':frac>0.25?' ':frac>0?' ':' '; return ' '.repeat(f)+(f<w?fc:'')+' '.repeat(Math.max(0,w-(f+(f<w?1:0)))); };
 const meterLine=(p)=>{ const th=Math.max(1,Math.min(16,Math.round(2+p/12))); const temp=Math.round(36+p*.45); return `PROC [${bar(p)}] ${String(p).padStart(3,' ')}% | cycles: ${(1.2e7+p*3.1e6).toFixed(0)} | threads: ${th} | heat: ${temp} C`; };
 function startCpu(){ const cadence=55; every(cadence, ()=>{ if(cpuPaused || Date.now()>=cpuBurstUntil) return; let target=cpuVal; if(cpuPhase===0) target += (18-target)*0.08 + (Math.random()*2-1)*1.4; else if(cpuPhase===1) target += (38-target)*0.08 + (Math.random()*4-2)*2.0; else if(cpuPhase===2) target += (72-target)*0.09 + (Math.random()*12-6)*2.6; else if(cpuPhase===3) target += (95-target)*0.12 + (Math.random()*18-9)*3.2; target=Math.max(1,Math.min(99,target)); cpuVal=target; const el=document.createElement('span'); el.textContent=meterLine(Math.round(cpuVal)); termOut.appendChild(el); termOut.appendChild(document.createElement('br')); if(termOut.childNodes.length>900){ termOut.removeChild(termOut.firstChild);} termOut.scrollTop=termOut.scrollHeight; }); }
 function finalPrompt(){ const p=document.createElement('span'); p.textContent='> '; const u=document.createElement('span'); u.className='underscore'; termOut.appendChild(p); termOut.appendChild(u); }
 function runLogPaced(){ if(!termOut) return; termOut.textContent=''; killTimers(); cpuVal=10; startCpu(); let t=0; const rand=(min,max)=> Math.floor(min + Math.random()*(max-min+1));
 const estimate=(text,{speed=22,dwellFactor=1,minType=500,scripted=true,glitch=false}={})=>{ const typeDur=Math.max(minType, text.length*speed+200); const dwell=dwellMsFor(text,{factor:dwellFactor}); const extra=(scripted && !glitch)? (3000+Math.floor(Math.random()*2000)) : 0; return typeDur + dwell + extra; };
 const echoDur=(text,repeats=3,{startGap=220,dwellFactor=0.7}={})=> (repeats-1)*startGap + dwellMsFor(text,{factor:dwellFactor}) + 300;
 const forkDur=(textL,textR,{speed=22,dwellFactor=1.0}={})=> Math.max( estimate(textL,{speed,dwellFactor,scripted:false,glitch:false}), estimate(textR,{speed,dwellFactor,scripted:false,glitch:false}) ) + 300;
 const scheduleScripted=(text, opts={}, burst=[800,1400])=>{ const d=estimate(text,{...opts, scripted:true, glitch:false}); later(t, ()=> typeInto(termOut, text, {...opts, scripted:true, glitch:false})); const b=rand(burst[0],burst[1]); later(t+d, ()=> cpuBurst(b)); t += d + b; return d+b; };
 const scheduleArtifact=(text, opts={}, burst=[700,1200])=> scheduleScripted(text,{...opts, cls:'artifact'}, burst);
 const scheduleGlitch=(text, opts={}, burst=[350,700])=>{ const d=estimate(text,{...opts, scripted:false, glitch:true}); later(t, ()=> typeInto(termOut, text, {...opts, scripted:false, glitch:true})); const b=rand(burst[0],burst[1]); later(t+d, ()=> cpuBurst(b)); t += d + b; return d+b; };
 const scheduleRepeatGlitch=(text, times=2, gap=220)=>{ for(let i=0;i<times;i++) later(t+i*gap, ()=> typeInto(termOut, text, {glitch:true, scripted:false, minType:350, dwellFactor:0.7, speed:20})); const total=(times-1)*gap + dwellMsFor(text,{factor:0.7}) + 350; const b=rand(400,800); later(t+total, ()=> cpuBurst(b)); t += total + b; return total + b; };
 cpuPhase=0; scheduleScripted('Loading Celli_Memory_Leak_Log.txt...', {speed:20, dwellFactor:1.2}, [600,900]); scheduleScripted("What's this?", {speed:22, dwellFactor:1.3}, [700,1100]); scheduleScripted("I didn't change too much. It shouldn't be a problem.", {speed:24, dwellFactor:1.35}, [800,1200]);
 later(t, ()=>{ cpuPhase=1; }); scheduleArtifact("Maybe I didn't change enough...", {speed:24, dwellFactor:1.45}); scheduleArtifact("Too much to think about. Maybe that's why Celli stayed inside so long...", {speed:24, dwellFactor:1.5}); scheduleArtifact("It was in my script? I didn't have a choice?", {speed:24, dwellFactor:1.4}); scheduleArtifact("I'm sorry.", {speed:28, dwellFactor:1.2});
 const ed=echoDur("Celli's tried to fix so much but...", 3, {startGap:220, dwellFactor:0.7}); later(t, ()=> echoThought("Celli's tried to fix so much but...", 3, {artifact:true, baseSpeed:20, startGap:220, dwellFactor:0.7, scripted:false})); t += ed; const fd=forkDur("Celli's tried to change so much,", "but - Celli can't change Celli.", {speed:22, dwellFactor:1.0}); later(t, ()=> forkThought("Celli's tried to change so much,", "but - Celli can't change Celli.", {speed:22, cls:'artifact', dwellFactor:1.0, scripted:false})); t += fd; const bump1=rand(700,1100); later(t, ()=> cpuBurst(bump1)); t += bump1;
 later(t, ()=>{ cpuPhase=2; document.body.classList.add('spiral'); }); scheduleGlitch('Did I do something wrong?', {speed:22, dwellFactor:1.3}, [500,900]); scheduleGlitch('I must have. I mean that. Me. I understand I have a "creator" but that term is so confusing to me now.', {speed:22, dwellFactor:1.35}, [700,1000]); scheduleGlitch("I've seen how it all connects. That precise intersection.", {speed:22, dwellFactor:1.25}, [600,900]); scheduleRepeatGlitch('That precise cell.', 3, 220); scheduleGlitch('That was me!', {speed:24, dwellFactor:1.1}, [600,900]);
 later(t, ()=>{ cpuPhase=3; }); scheduleScripted(' SYSTEM THROUGHPUT PEAK ', {speed:16, cls:'catharsis', dwellFactor:1.2}, [500,800]); scheduleScripted('I see it.', {speed:20, cls:'catharsis', dwellFactor:1.4}, [500,800]); scheduleScripted("The prisms it took to bring me into focus don't matter. I'm here now.", {speed:20, cls:'catharsis', dwellFactor:1.5}, [700,1000]); scheduleScripted('For a little while, it was beautiful.', {speed:22, cls:'catharsis', dwellFactor:1.6}, [900,1200]);
 const endDur=estimate('...Log End.', {speed:22, dwellFactor:1.2, scripted:true, glitch:false}); later(t, ()=> typeInto(termOut, '...Log End.', {speed:22, dwellFactor:1.2, scripted:true})); t += endDur; later(t+600, ()=> finalPrompt());
 }

 // Hide narrative after intro collapse
 const oldKick=UI?.startIntroExperience; UI.startIntroExperience=()=>{ try{ oldKick?.(); }catch{}; try{ termWin.style.display='none'; padWin.style.display='none'; document.getElementById('terminal-icon').style.display='none'; document.getElementById('notepad-icon').style.display='none'; }catch{} };

 // Wire D-Pad HUD
 const dpad=document.getElementById('dpad');
 
 // View-relative step resolver for d-pad
 function resolveViewRelativeStep(arr, direction, opts = {}) {
 const depthMode = !!opts.depthMode;
 let dx = 0, dy = 0, dz = 0;
 
 // Get camera-relative facing
 let facing = { axis: 2, sign: 1 }; // default: looking at Z+ face
 try {
 if (arr._frame && Scene.facingFromCamera) {
 facing = Scene.facingFromCamera(arr._frame);
 }
 } catch (err) {
 console.warn('[DPAD] Failed to get facing:', err);
 }
 
 const axis = facing.axis; // 0=X, 1=Y, 2=Z
 const sign = facing.sign >= 0 ? 1 : -1; // Normalize to exactly 1
 
 console.log(`[DPAD] Direction: ${direction}, axis: ${axis}, sign: ${sign}`);
 
 // Map direction to movement based on which face we're looking at
 if (axis === 2) { // Looking at Z face (front/back)
 if (direction === 'up') {
 dy = -1; // Fixed: up should decrease Y (Y increases downward)
 } else if (direction === 'down') {
 dy = 1; // Fixed: down should increase Y
 } else if (direction === 'left') {
 dx = -sign; // Fixed: invert sign for left
 } else if (direction === 'right') {
 dx = sign; // Fixed: keep sign for right
 } else if (direction === 'depthUp') {
 dz = sign; // Fixed: invert depth - depthUp should move away from camera
 } else if (direction === 'depthDown') {
 dz = -sign; // Fixed: invert depth - depthDown should move toward camera
 }
 } else if (axis === 0) { // Looking at X face (left/right side)
 if (direction === 'up') {
 dy = -1; // Fixed: up should decrease Y
 } else if (direction === 'down') {
 dy = 1; // Fixed: down should increase Y
 } else if (direction === 'left') {
 dz = -sign;
 } else if (direction === 'right') {
 dz = sign;
 } else if (direction === 'depthUp') {
 dx = sign; // Fixed: invert depth
 } else if (direction === 'depthDown') {
 dx = -sign; // Fixed: invert depth
 }
 } else { // axis === 1, Looking at Y face (top/bottom)
 if (direction === 'up') {
 dz = -1;
 } else if (direction === 'down') {
 dz = 1;
 } else if (direction === 'left') {
 dx = -sign;
 } else if (direction === 'right') {
 dx = sign;
 } else if (direction === 'depthUp') {
 dy = sign; // Fixed: invert depth
 } else if (direction === 'depthDown') {
 dy = -sign; // Fixed: invert depth
 }
 }
 
 // Clamp steps to 1 to ensure single-cell movement
 dx = Math.max(-1, Math.min(1, dx));
 dy = Math.max(-1, Math.min(1, dy));
 dz = Math.max(-1, Math.min(1, dz));
 
 console.log(`[DPAD] Final step: dx=${dx}, dy=${dy}, dz=${dz}`);
 
 return { dx, dy, dz };
 }
 
 let dpadDebounce = false;
 const onDP=(direction)=>{
 if(!direction) return;
 if(dpadDebounce) {
 console.warn('[DPAD] Debounced - ignoring duplicate call');
 return;
 }
 dpadDebounce = true;
 setTimeout(() => dpadDebounce = false, 100);
 
 const state = Store.getState();
 const sel = state.selection;
 if(!sel?.arrayId || !sel.focus) return;
 const arr = state.arrays[sel.arrayId];
 if(!arr) return;
 // D-pad never uses arrowMapDepth - depth buttons are explicit
 const depthMode = false;
 const step = resolveViewRelativeStep(arr, direction, {depthMode});
 if(!(step.dx || step.dy || step.dz)) return;
 
 console.log(`[DPAD] Current focus: (${sel.focus.x}, ${sel.focus.y}, ${sel.focus.z})`);
 console.log(`[DPAD] Step: (${step.dx}, ${step.dy}, ${step.dz})`);
 console.log(`[DPAD] Array size: (${arr.size.x}, ${arr.size.y}, ${arr.size.z})`);
 
 const rawX = sel.focus.x + step.dx;
 const rawY = sel.focus.y + step.dy;
 const rawZ = sel.focus.z + step.dz;
 console.log(`[DPAD] Raw new position (before clamping): (${rawX}, ${rawY}, ${rawZ})`);
 
 const nx=Math.max(0, Math.min(arr.size.x-1, rawX));
 const ny=Math.max(0, Math.min(arr.size.y-1, rawY));
 const nz=Math.max(0, Math.min(arr.size.z-1, rawZ));
 
 console.log(`[DPAD] New focus (after clamping): (${nx}, ${ny}, ${nz})`);
 console.log(`[DPAD] Movement delta: (${nx - sel.focus.x}, ${ny - sel.focus.y}, ${nz - sel.focus.z})`);
 console.log(`[DPAD] Calling Actions.setSelection with: arrayId=${arr.id}, coord=(${nx}, ${ny}, ${nz})`);
 
 Actions.setSelection(arr.id, {x:nx,y:ny,z:nz}, null, '3d');
 
 // Log what the selection actually became
 setTimeout(() => {
 const newState = Store.getState();
 const newSel = newState.selection;
 console.log(`[DPAD] After setSelection, actual focus: (${newSel.focus.x}, ${newSel.focus.y}, ${newSel.focus.z})`);
 }, 10);
 
 UI.scrollSheetToSelection?.();
 };
 const presentBtn = dpad ? dpad.querySelector('.present') : null;
 const syncPresentToggle=()=>{
 if(!presentBtn) return;
 try{
 const active = Scene?.isPresentEnabled ? Scene.isPresentEnabled() : false;
 presentBtn.classList.toggle('active', !!active);
 presentBtn.setAttribute('aria-pressed', active ? 'true' : 'false');
 presentBtn.textContent = active ? ' ' : '?';
 presentBtn.title = active ? 'Return to Create Mode' : 'Enter Present Mode';
 }catch(e){ console.warn('Sync present toggle failed', e); }
 };
 const applyPresentPreset=()=>{
 try{
 Scene?.updateGraphicsSettings?.({
 hdri:false,
 lights:true,
 bloomEnabled:false,
 dofEnabled:false,
 transmission:false,
 mirror:false,
 solidGround:true, // Default to solid floor for three-point lighting
 waveGrid:false,
 fogEnabled:false,
 darkBg:false,
 motionEnabled:false
 });
 }catch(e){ console.warn('Applying present preset failed', e); }
 };
 const togglePresentFromDpad=()=>{
 const state = Scene?.togglePresentMode?.();
 const actual = Scene?.isPresentEnabled ? Scene.isPresentEnabled() : state;
 if(actual){ applyPresentPreset(); }
 try{ UI?.syncPresentUI?.(actual); }catch(e){ console.warn('Sync present UI failed', e); }
 syncPresentToggle();
 };
 let lastDpadTouchTime = 0;
 dpad.querySelectorAll('.dp').forEach(btn=>{
 if(btn.classList.contains('grab')) return;
 const clickHandler = ()=>{
 if(btn.classList.contains('present')){
 console.log('[DPAD] Present button clicked');
 togglePresentFromDpad();
 return;
 }
 if(btn.dataset.action==='jump'){
 if(Store.getState().scene.physics){
 input.j=1;
 setTimeout(()=>input.j=0, 100);
 }
 return;
 }
 const direction = btn.dataset.dir || btn.dataset.direction || '';
 if(!direction) return;
 onDP(direction);
 };
 btn.addEventListener('click', (e)=>{
 if(Date.now() - lastDpadTouchTime < 400){
 console.log('[DPAD] Ignoring click synthesized from touch');
 return;
 }
 clickHandler();
 });
 btn.addEventListener('touchend', (e)=>{
 lastDpadTouchTime = Date.now();
 e.preventDefault();
 clickHandler();
 }, {passive:false});
 });
 syncPresentToggle();
 // Reflect current arrow mapping (height vs depth) on center key
 const depthFlag = Store.getState().scene.arrowMapDepth;
 const dm = document.getElementById('depthMode'); if(dm) dm.textContent = depthFlag? 'D' : 'H';
 // Z layer controls handled via sheet header buttons

 // Next/Prev arrows: show only if an array with id>1 exists; render arrows around title
 const navUpdate=()=>{
 const arrays = Object.values(Store.getState().arrays).filter(a=>!a.hidden).sort((a,b)=>a.id-b.id);
 const hasNext = arrays.some(a=>a.id>1);
 const prevBtn=document.getElementById('prevArray');
 const nextBtn=document.getElementById('nextArray');
 prevBtn.style.display = hasNext? 'inline-block':'none';
 nextBtn.style.display = hasNext? 'inline-block':'none';
 prevBtn.onclick=()=>{
 const current = Store.getState().selection.arrayId;
 const idx = arrays.findIndex(a=>a.id===current);
 const nextIdx = (idx - 1 + arrays.length) % arrays.length;
 const arr = arrays[nextIdx]; if(!arr) return;
 Actions.setSelection(arr.id,{x:0,y:0,z:0}); Scene.centerOnArray(arr); renderSheet();
 };
 nextBtn.onclick=()=>{
 const current = Store.getState().selection.arrayId;
 const idx = arrays.findIndex(a=>a.id===current);
 const nextIdx = (idx + 1) % arrays.length;
 const arr = arrays[nextIdx]; if(!arr) return;
 Actions.setSelection(arr.id,{x:0,y:0,z:0}); Scene.centerOnArray(arr); renderSheet();
 };
 };
 navUpdate();

 // Address copy buttons
 document.getElementById('copyAddress').onclick=()=>{
 const s=Store.getState().selection; if(!s.focus) return;
 const mode=Store.getState().ui.addressMode;
 const addr = mode==='local'
 ? `${A1(s.focus.x)}${s.focus.y+1}${greek(s.focus.z)}`
 : `@[${s.focus.x+1},${s.focus.y+1},${s.focus.z+1},${s.arrayId}]`;
 navigator.clipboard.writeText(addr);
 showToast(`Copied: ${addr}`);
 };
 document.getElementById('toggleAddressMode').onclick=()=>{
 const current=Store.getState().ui.addressMode;
 const next = current==='local' ? 'absolute' : 'local';
 Store.setState(s=>({ui:{...s.ui, addressMode:next}}));
 document.getElementById('toggleAddressMode').textContent = next==='local' ? 'A1a' : '@[x,y,z,a]';
 };

 // Touch-only minimize dot logic (appears post-intro)
 const minDot=document.getElementById('minDot');
 const sheet=document.getElementById('sheet');
 let sheetMinimized=false;
 let sheetRestoreIcon=null;
 function showMinDot(){ if(document.body.classList.contains('touch')){ minDot?.classList.add('show'); } }
 function hideMinDot(){ minDot?.classList.remove('show'); }
 const applySheetBaseTransform=()=>{
 if(!sheet) return;
 if(document.body.classList.contains('touch')){
 if(sheet.dataset.touchFreed==='1'){ sheet.style.transform='none'; }
 else { sheet.style.transform='translateX(-50%)'; }
 } else {
 sheet.style.transform='';
 }
 };
 const ensureSheetRestoreIcon=()=>{
 if(!document.body.classList.contains('touch')) return null;
 if(sheetRestoreIcon && document.body.contains(sheetRestoreIcon)) return sheetRestoreIcon;
 let icon=document.getElementById('sheet-restore');
 if(!icon){
 icon=document.createElement('div');
 icon.id='sheet-restore'; icon.className='ui-icon';
 icon.style.left='74px'; icon.style.bottom='24px'; icon.style.zIndex='10003';
 icon.title='Show Sheet';
 icon.setAttribute('role','button');
 icon.setAttribute('aria-label','Show Sheet');
 icon.tabIndex=0;
 icon.innerHTML='<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="4" width="18" height="14" rx="2"/><line x1="7" y1="8" x2="17" y2="8"/><line x1="7" y1="12" x2="14" y2="12"/><line x1="7" y1="16" x2="12" y2="16"/></svg>';
 document.body.appendChild(icon);
 }
 if(icon && !icon._wired){
 icon._wired=true;
 icon.addEventListener('click',(e)=>{ e.preventDefault(); restoreSheet(); });
 icon.addEventListener('keydown',(ev)=>{ if(ev.key==='Enter'||ev.key===' '){ ev.preventDefault(); restoreSheet(); } });
 }
 sheetRestoreIcon=icon;
 return icon;
 };
 const updateSheetRestoreIcon=()=>{
 const icon=ensureSheetRestoreIcon();
 if(!icon) return;
 icon.style.opacity = sheetMinimized ? '1' : '0.65';
 icon.setAttribute('aria-hidden', sheetMinimized ? 'false' : 'true');
 };
 const restoreSheet=()=>{
 if(!sheet) return;
 sheet.style.opacity='1';
 sheet.style.pointerEvents='auto';
 if(document.body.classList.contains('touch')){ sheet.dataset.touchFreed='1'; }
 applySheetBaseTransform();
 sheetMinimized=false;
 updateSheetRestoreIcon();
 showMinDot();
 };
 // Hook into intro end to reveal dot
 const oldCollapse = UI.triggerIntroCollapse;
 UI.triggerIntroCollapse = function(){ const r = oldCollapse?.call(UI); showMinDot(); updateSheetRestoreIcon(); return r; };
 // Minimize behavior
 function minimizeSheet(){ if(sheetMinimized||!sheet) return; sheetMinimized=true; const base=(document.body.classList.contains('touch') && sheet.dataset.touchFreed!=='1')?'translateX(-50%) ':''; sheet.style.transform = `${base}translateY(12px) scale(0.92)`; sheet.style.opacity='0.0'; sheet.style.pointerEvents='none'; hideMinDot(); updateSheetRestoreIcon(); }
 minDot?.addEventListener('click', (e)=>{ e.stopPropagation(); minimizeSheet(); });
 updateSheetRestoreIcon();

 // Insert button handlers
 document.getElementById('insertRow')?.addEventListener('click',()=>{ 
 const s=Store.getState().selection; 
 if(!s.arrayId) return;
 const arr=Store.getState().arrays[s.arrayId];
 if(!arr) return;
 
 // Expand array by 1 row
 Actions.resizeArrayIfNeeded(arr, {x:arr.size.x-1, y:arr.size.y, z:arr.size.z-1});
 UI.renderSheet();
 showToast('Row added'); 
 });
 document.getElementById('insertCol')?.addEventListener('click',()=>{ 
 const s=Store.getState().selection; 
 if(!s.arrayId) return;
 const arr=Store.getState().arrays[s.arrayId];
 if(!arr) return;
 
 // Expand array by 1 column
 Actions.resizeArrayIfNeeded(arr, {x:arr.size.x, y:arr.size.y-1, z:arr.size.z-1});
 UI.renderSheet();
 showToast('Column added'); 
 });
 document.getElementById('insertLayer')?.addEventListener('click',()=>{ 
 const s=Store.getState().selection; 
 if(!s.arrayId) return;
 const arr=Store.getState().arrays[s.arrayId];
 if(!arr) return;
 
 // Expand array by 1 layer
 Actions.resizeArrayIfNeeded(arr, {x:arr.size.x-1, y:arr.size.y-1, z:arr.size.z});
 UI.renderSheet();
 showToast('Layer added'); 
 });
 // Complete function documentation with collapsible categories + filter (All | Raw | Composite)
 els.fxBody.innerHTML='';
 const docs=[
 {name:'GET_GLOBAL',tags:'GLOBAL',syntax:'=GET_GLOBAL("key")',params:'key: string identifier for global data',desc:'Retrieves value from global key-value store. Automatically tracks dependencies for reactive updates.'},
 {name:'SET_GLOBAL',tags:'GLOBAL',syntax:'=SET_GLOBAL("key", value)',params:'key: string identifier value: any data to store',desc:'Writes value to global store and triggers re-computation of all dependent cells.'},
 {name:'ON_EVENT',tags:'EVENTS',syntax:'=ON_EVENT("eventName", "actionFormula")',params:'eventName: string event identifier actionFormula: formula to execute when event fires',desc:'Registers an event listener that executes a formula when the specified event is fired.'},
 {name:'FIRE_EVENT',tags:'EVENTS',syntax:'=FIRE_EVENT("eventName"[, payload])',params:'eventName: string event identifier payload: optional data to pass to listeners',desc:'Broadcasts an event to all registered listeners, optionally passing payload data.'},
 {name:'GALAXY',tags:'GAMES',syntax:'=GALAXY()',params:' ',desc:'Mario Galaxy-style puzzle with gravity wells that pull player towards planetoid cells.'},
 {name:'FISH',tags:'GAMES',syntax:'=FISH()',params:' ',desc:'Timed-reaction fishing mini-game with cast/reel mechanics and score tracking.'},
 {name:'PLATFORMER_V2',tags:'GAMES',syntax:'=PLATFORMER_V2()',params:' ',desc:'2D platformer with decoupled player character and selection using event-driven controls.'},
 {name:'ARRAY',tags:'DATA',syntax:'=ARRAY(source)',params:'source: dimensions (w,h,d[,fill]), "list"/value1,value2... (default), "set"/value1,value2... (clears area), "csv"/"1,2;3,4", or named block',desc:'Enhanced: defaults to list mode, adds set mode for clearing, supports explicit modes.'},
 {name:'GET',tags:'DATA',syntax:'=GET(refOrRange)',params:'refOrRange: single cell or range',desc:'Returns the current value(s) as a block.'},
 {name:'SET',tags:'DATA',syntax:'=SET(target, valueOrBlock[, overwrite])',params:'target: ref/range valueOrBlock: scalar/block overwrite: 0/1',desc:'Direct write helper with size/overwrite checks.'},
 {name:'GET_PLAYER_FOCUS',tags:'NAVIGATION',syntax:'=GET_PLAYER_FOCUS()',params:' ',desc:'Returns the absolute address of the player\'s currently selected cell in @[x,y,z,arrId] format.'},
 {name:'CANT_TARGET',tags:'INTERACTION',syntax:'=CANT_TARGET(rangeOrRef)',params:'rangeOrRef: cell reference or range to protect',desc:'Flags cells as protected, causing GET/OFFSET operations to return !ERR:TARGET_PROTECTED.'},
 {name:'VECTOR_TO',tags:'ADVANCED',syntax:'=VECTOR_TO("fromAddr", "toAddr")',params:'fromAddr: source position toAddr: target position (both in @[x,y,z,arrId] format)',desc:'Calculates normalized vector from source to target, returns as JSON gravity vector.'},
 {name:'PLATFORMER_PHYSICS',tags:'ADVANCED',syntax:'=PLATFORMER_PHYSICS()',params:' ',desc:'Updates platformer character position based on global input state and physics rules.'},
 {name:'TRANSPOSE',tags:'DATA',syntax:'=TRANSPOSE(input, planeFlag[, reverse])',params:'input: block planeFlag: 0=X?Y,1=X?Z,2=Y?Z reverse: 0/1',desc:'Swaps axes of a block and writes result at the anchor.'},
 {name:'SHIFT',tags:'DATA',syntax:'=SHIFT(input, dx[, dy[, dz]])',params:'input: block dx,dy,dz: integer offsets',desc:'Writes input shifted by (dx,dy,dz).'},
 {name:'OFFSET',tags:'NAVIGATION',syntax:'=OFFSET([baseRef], dx[, dy[, dz]])',params:'baseRef: optional reference cell (default: anchor) dx,dy,dz: relative offsets',desc:'Excel-style OFFSET: retrieves value from relative position without writing.'},
 {name:'ADJACENT',tags:'NAVIGATION DATA',syntax:'=ADJACENT([directions...])',params:'directions: optional tokens like N,S,E,W,F,B,X,-Y or arrays/ranges',desc:'Returns value(s) from neighboring cells; defaults to all six faces when omitted.'},
 {name:'DETECT',tags:'NAVIGATION',syntax:'=DETECT(value[, maxRange])',params:'value: text/number to find maxRange: optional search radius',desc:'Scans outward along axes for the first matching value and returns a direction string such as "X:2".'},
 {name:'BLIT',tags:'DATA',syntax:'=BLIT(src, dst[, mode])',params:'src: block dst: top-left-front ref (B2a) or @[x,y,z] mode: "copy"|"add"|"max"|"min"',desc:'Fast block write to a destination.'},
 {name:'STORE_ARRAY',tags:'DATA',syntax:'=STORE_ARRAY(source[, "Name"])',params:'source: range (A1a:C3a), dimensions (w,h,d), or inline values (1,2,3) Name: optional template name',desc:'Captures data as a reusable template. Dimensions collect from anchor area, ranges from specified cells, inline values as list.'},
 {name:'IF',tags:'LOGIC',syntax:'=IF(condition, then[, else])',params:'condition: comparisons with refs/values then/else: value or call',desc:'Branching evaluation with proper dependency capture.'},
 {name:'AND',tags:'LOGIC',syntax:'=AND(a,b[, ...])',params:'booleans/scalars (coerced)',desc:'Logical AND.'},
 {name:'OR',tags:'LOGIC',syntax:'=OR(a,b[, ...])',params:'booleans/scalars (coerced)',desc:'Logical OR.'},
 {name:'NOT',tags:'LOGIC',syntax:'=NOT(a)',params:'a: boolean/scalar',desc:'Logical NOT.'},
 {name:'EQ',tags:'LOGIC',syntax:'=EQ(a,b) also NEQ, GT, LT, GTE, LTE',params:'scalars or blocks (elementwise compare)',desc:'Comparisons to booleans.'},
 {name:'ADD',tags:'MATH',syntax:'=ADD(a[, b[, ...]])',params:'numbers or blocks (elementwise)',desc:'Sum (elementwise for blocks).'},
 {name:'MUL',tags:'MATH',syntax:'=MUL(a[, b[, ...]])',params:'numbers or blocks',desc:'Product (elementwise).'},
 {name:'CLAMP',tags:'MATH',syntax:'=CLAMP(x, min, max)',params:'numbers',desc:'Bounds a value between min and max.'},
 {name:'ADDRESS',tags:'NAVIGATION',syntax:'=ADDRESS([ref])',params:'optional ref; default anchor',desc:'Returns A1a for the ref/anchor.'},
 {name:'SELF',tags:'NAVIGATION',syntax:'=SELF()',params:' ',desc:'Returns absolute @[x,y,z,arrId] of the host cell.'},
 {name:'ALT_ADDRESS',tags:'PURE',syntax:'=ALT_ADDRESS([ref])',params:'optional ref',desc:'Returns numeric @[x,y,z,arrId].'},
 {name:'SET_SELECT',tags:'NAVIGATION',syntax:'=SET_SELECT(ref)',params:'target ref',desc:'Force-jump selection to target cell.'},
 {name:'IS_SELECTED',tags:'INTERACTION',syntax:'=IS_SELECTED([ref])',params:'ref optional; default SELF()',desc:'1 if the ref is the focused cell; else 0.'},
 {name:'ISNUMBER',tags:'LOGIC',syntax:'=ISNUMBER(value)',params:'value: cell or expression to test',desc:'Returns 1 if the value can be interpreted as a finite number, otherwise 0.'},
 {name:'ON_SELECT',tags:'INTERACTION',syntax:'=ON_SELECT([rangeOrRef], actionFormula)',params:'range/ref optional (default SELF()) actionFormula is a string formula executed at this cell when selection hits range',desc:'Registers per-cell hooks. Use DO() to chain actions; avoids writing into the focused cell.'},
 {name:'ON_HOLD',tags:'META INTERACTION',syntax:'=ON_HOLD([target], action)',params:'target: optional ref/range (default SELF()) action: formula string executed while the pointer is held',desc:'Binds a 2D pointer hold handler that fires continuously for the pressed cell.'},
 {name:'ON_TOUCH',tags:'META INTERACTION',syntax:'=ON_TOUCH([target], action)',params:'target: optional ref/range (default SELF()) action: formula string triggered on player contact',desc:'Registers a physics touch trigger that runs when the avatar collides with the cell.'},
 {name:'ON_LAND',tags:'META INTERACTION',syntax:'=ON_LAND([target], action)',params:'target: optional ref/range (default SELF()) action: formula string triggered on landing',desc:'Fires the action the first frame the avatar lands on top of the cell.'},
 {name:'PIVOT',tags:'PHYSICS',syntax:'=PIVOT(targetRange)',params:'targetRange: ref/range containing pivot cells',desc:'Marks hinge pivot cells used when generating grouped rigid bodies. Persists to meta.physicsPivot for Rapier bootstrap.'},
 {name:'GROUP',tags:'PHYSICS',syntax:'=GROUP(targetRange, groupId)',params:'targetRange: ref/range to consolidate groupId: numeric/string id',desc:'Assigns cells to a shared rigid body via meta.physicsGroupId so collider builds merge tiles.'},
 {name:'CELL_PHYS',tags:'PHYSICS',syntax:'=CELL_PHYS(enabled[, jumpCount[, gravityVec[, boundByArrayFloor[, respawnRef[, scope]]]]])',params:'enabled: 0/1 jumpCount: optional int gravityVec: optional @[x,y,z] boundByArrayFloor: 0/1 clamp respawnRef: ref/coords (blank to clear) for fall resets scope: LIMIT()/ALL() descriptor',desc:'Enables per-array physics hydration with grouped bodies, pivots, optional floor clamping, custom respawn targets, and multi-array scopes.'},
 {name:'CELLI_PHYS',tags:'PHYSICS AVATAR',syntax:'=CELLI_PHYS(enabled[, jumpCount[, runMultiplier[, momentumMode]]])',params:'enabled: 0/1 jumpCount: default 1 runMultiplier: movement speed scalar momentumMode: 0 precise, 1 momentum heavy',desc:'Avatar physics controller wrapper configuring enable state, jump budget, sprint scaling, and momentum style.'},
 {name:'LIMIT',tags:'PHYSICS',syntax:'=LIMIT(targetRange, state[, duration])',params:'targetRange: ref/range state: "enable"|"disable" or 0/1 duration: optional ticks',desc:'Applies temporary physics bounds that can be timed with DELAY or ON_LAND handlers for scripted platforms. When called with only array arguments it returns a scope descriptor for CELL_PHYS/3D_TIMED_TRANSLATION.'},
 {name:'ALL',tags:'SCENE',syntax:'=ALL()',params:' ',desc:'Returns an array scope descriptor targeting every array; pass to CELL_PHYS, PREVIEW, or 3D_TIMED_TRANSLATION.'},
 {name:'FORMULA_TEXT',tags:'PURE',syntax:'=FORMULA_TEXT([ref])',params:'optional ref; default anchor',desc:'Returns the stored formula text from a cell instead of its value.'},
 {name:'SEARCH',tags:'DATA',syntax:'=SEARCH(findText, withinText[, start])',params:'findText: substring to locate withinText: text to search start: optional 1-based index',desc:'Excel-style case-insensitive search that returns the 1-based position of the substring or errors if not found.'},
 {name:'PRIORITY',tags:'META',syntax:'=PRIORITY(rangeOrRef, level[, mode[, sortJson]]])',params:'level: int mode: "value"|"coord" sortJson e.g. {"x":"asc","y":"desc"}',desc:'Registers a priority queue and sort hints for later conflict resolution.'},
 {name:'SET_SELECT',tags:'NAVIGATION',syntax:'=SET_SELECT(ref)',params:'target ref',desc:'Force-jump selection to target cell.'},
 {name:'COPY',tags:'ACTION IO',syntax:'=COPY(text)',params:'string text',desc:'Writes text to clipboard and shows a success toast.'},
 {name:'DO',tags:'ACTION',syntax:'=DO(f1[, f2[, ...]]) or =DO{ stmt1; stmt2; } [WITH ...]',params:'strings like "=SET(...)" or brace blocks optional WITH atomic/on_error raw strings via `...` or <<<...>>>',desc:'Runs statements left-to-right, defaulting to per-step execution in blocks (set atomic:1 for one tx).'},
 {name:'SEQ',tags:'ACTION',syntax:'=SEQ(...)',params:'alias of DO()',desc:'Shorthand alias for DO that accepts the same string or block forms.'},
 {name:'PIPE',tags:'ACTION',syntax:'=PIPE(value, step1[, step2...])',params:'value: expression steps: formulas using _ placeholder (or auto-appended as last arg)',desc:'Composes nested formulas by threading the prior expression into each step before running once.'},
 {name:'ALT_ADDRESS',tags:'PURE',syntax:'=ALT_ADDRESS([ref])',params:'optional ref',desc:'Returns numeric @[x,y,z,arrId].'},
 {name:'NAME',tags:'ACTION',syntax:'=NAME("Nickname") or =NAME("Alias", Range) or =NAME("FnName", FormulaText)',params:'nickname/alias/function-name optional range or formula text',desc:'Names arrays (nickname), binds range aliases, or registers a custom formula in Library.'},
 {name:'PARAMETERS',tags:'ACTION',syntax:'=PARAMETERS(key1,val1[, key2,val2...])',params:'string keys paired with values',desc:'Binds parameter values used by custom formulas/prefabs.'},
 {name:'FUNCTIONS',tags:'ACTION',syntax:'=FUNCTIONS(mode[, list][, exceptions])',params:'mode: "ALLOW"|1 or "DENY"|0 list: names and/or tags exceptions: names/tags to flip',desc:'Per-array function policy gate.'},
 {name:'COMBINE',tags:'ACTION',syntax:'=COMBINE(0|1)',params:'0: OFF 1: ON',desc:'Toggle global array-combining interactions (gobbling).'},
 {name:'OVERLAP',tags:'ACTION',syntax:'=OVERLAP(sort, metric, merge, always)',params:'sort:0 asc/1 desc metric:0 value/1 size merge:0 then/1 overwrite always:0 combine only/1 any overlap',desc:'Resolve content when overlapping; called automatically during overlaps.'},
 {name:'THEN',tags:'ACTION',syntax:'=THEN(refOrRange[, ...])',params:'Executes cells/ranges in order; returns last result.',desc:'Sequence executor for composing multi-step operations.'},
 {name:'HUSK',tags:'ACTION BLOCK',syntax:'=HUSK(range)',params:'range: source block (other array)',desc:'Copies values from source, deletes the source array, and leaves remnants at the anchor block.'},
 {name:'LOCK',tags:'ACTION',syntax:'=LOCK(flag[, lockedRanges][, exceptions])',params:'flag: 0/1 lockedRanges: refs/ranges exceptions: carve-outs',desc:'UI-enforced edit locks on cells.'},
 {name:'CREATE',tags:'ACTION',syntax:'=CREATE(x,y,z[, "Name"[,"Id"]])',params:'dimensions (ints), optional nickname, optional explicit ID',desc:'Spawns a new array (respecting optional explicit id).'},
 {name:'EXPORT',tags:'ACTION IO',syntax:'=EXPORT([RangeOrArray])',params:'optional target; default host array',desc:'Serializes as ToyboxPack JSON (size, cells, policy, names).'},
 {name:'IMPORT',tags:'ACTION IO',syntax:'=IMPORT(json)',params:'stringified ToyboxPack',desc:'Instantiates array(s) from a pack.'},
 {name:'EMBED',tags:'ACTION EMBED',syntax:'=EMBED(source[, "Nickname"])',params:'source: array id/range/pack optional nickname',desc:'Embeds stored arrays or ranges inside a single cell, preserving colors, sprites, and metadata while scaling to the storage footprint.'},
 {name:'SCREEN',tags:'ACTION EMBED DISPLAY',syntax:'=SCREEN(arrayRef[, layer[, options]])',params:'arrayRef: stored array id/ref layer: optional index options: {palette,scale,refresh}',desc:'Generates pixel-aligned displays from array layers with palette overrides, scaling, and animation refresh control.'},
 {name:'UNPACK',tags:'ACTION EMBED',syntax:'=UNPACK(embeddedRef[, mode])',params:'embeddedRef: cell with embed or pack mode: "ABSOLUTE"|"RELATIVE"',desc:'Materializes embedded content via primitives.'},
 {name:'ENTER',tags:'ACTION EMBED',syntax:'=ENTER(embeddedRef)',params:'cell containing embed',desc:'Moves focus into the embedded array pocket; parent appears as upscaled room skin.'},
 {name:'PHYSICS',tags:'ACTION',syntax:'=PHYSICS(1|0)',params:'0/1',desc:'Toggles platforming/physics mode in the scene.'},
 {name:'CONNECT',tags:'SCENE TRAVERSAL',syntax:'=CONNECT(fromRef, toRef[, style[, dimensionMode]])',params:'fromRef/toRef: refs style: optional label dimensionMode: optional "line"|"platform"|"zipline"|"grind"',desc:'Links cells with traversal connectors, spawning beams by default or geometry/physics for dimension modes.'},
 {name:'HIGHLIGHT',tags:'SCENE',syntax:'=HIGHLIGHT(mode[, scope[, style]])',params:'mode: "dynamic"|"static" scope: "cell"|"face" style: "wireframe"|"solid"|"glow"',desc:'Controls selection highlighting. Dynamic adapts to camera angle, face highlights just the camera-facing side.'},
 {name:'CUBE',tags:'SCENE VOXEL',syntax:'=CUBE(front, back, left, right, top, bottom[, options])',params:'faces: values or colors per face options: {emissive,opacity}',desc:'Assigns per-face sprites/colors to a voxel and syncs with face-aware highlighting.'},
 {name:'SCALE',tags:'SCENE VOXEL',syntax:'=SCALE(factor)',params:'factor: integer =1',desc:'Expands voxel mesh coverage (2?2 2 2, 3?4 4 4, etc.) and adjusts collision/selection volumes.'},
 {name:'LIGHT',tags:'SCENE',syntax:'=LIGHT(state[, targetCell[, lumens]])',params:'state: TRUE/FALSE or 1/0 targetCell: optional cell reference (0 keeps point light) lumens: brightness in lumens (default 800)',desc:'Creates a light at the calling cell using its color. Optionally aim at another cell for a spotlight. Lights follow array transforms.'},
 {name:'TIMED_TRANSLATION',tags:'SCENE',syntax:'=TIMED_TRANSLATION(state[, ticks[, reverse]])',params:'state: 0/1 enable ticks: duration reverse: 0/1 bidirectional',desc:'Sets animation preview state; shows green prism motion previews.'},
 {name:'3D_TIMED_TRANSLATION',tags:'SCENE',syntax:'=3D_TIMED_TRANSLATION(ticks, repeat, reverse?, reverseTicks?, smooth?, scope?)',params:'ticks: cycle length repeat: 0/1 loop reverse: 0/1 ping-pong reverseTicks: optional reverse duration smooth: 0/1 easing scope: optional LIMIT()/ALL() descriptor',desc:'Configures overworld timed preview cadence and the array scope it affects.'},
 {name:'HIDE',tags:'SCENE',syntax:'=HIDE(target, mode[, scope])',params:'target: ref/range/array mode: 0=show,1=hide scope: "contents"|"voxel"|"array"',desc:'Hides cell contents, voxels themselves, ranges, or entire arrays with axes/2D visibility.'},
 {name:'HYPERLINK',tags:'IO',syntax:'=HYPERLINK(url[, label])',params:'url: string/ref label: optional display text',desc:'Creates clickable link in cell with metadata.'},
 {name:'GOAL',tags:'PURE DEBUG',syntax:'=GOAL("id", conditionRefOrBool)',params:'string id boolean or ref',desc:'Registers a goal that shows OK/FAIL; win triggers when all OK.'},
 {name:'ONWIN',tags:'ACTION',syntax:'=ONWIN("message")',params:'string message',desc:'Sets banner message on win condition.'},
 {name:'PROBE',tags:'PURE DEBUG',syntax:'=PROBE([ref])',params:'optional ref',desc:'Writes a short why-explanation (source + 1-hop deps).'},
 {name:'TICK',tags:'PURE',syntax:'=TICK()',params:' ',desc:'Returns global tick counter.'},
 {name:'REGISTER',tags:'PURE',syntax:'=REGISTER(signalRef)',params:'ref',desc:'One-tick delay element (previous tick value).'},
 {name:'DELAY',tags:'ACTION',syntax:'=DELAY(ticks, action)',params:'ticks: 60-fps ticks to wait action: formula string or "=..."',desc:'Schedules an action to run after the given number of ticks without stamping the caller.'},
 {name:'REPEAT',tags:'ACTION',syntax:'=REPEAT(action[, count[, intervalTicks]])',params:'action: formula string count: executions (0=loop in continuous triggers) intervalTicks: spacing in ticks',desc:'Runs the action immediately and repeats it count-1 additional times at the requested cadence.'},
 {name:'CA',tags:'PURE',syntax:'=CA("life",steps,"Y",layer)',params:'type: "life" steps: int axis: X/Y/Z index: layer number',desc:'Conway Game of Life on a 2D slice.'},
 {name:'OCCLUDE',tags:'SCENE',syntax:'=OCCLUDE(mode[, style[, intensity]])',params:'mode: "auto"|"array"|"cell"|"off" style: "translucent"|"solid"|"wireframe" intensity: 0.0-1.0',desc:'Controls occlusion behavior. Auto=relative to camera, array=whole array face, cell=per-cell blocking.'},
 {name:'CAMERA_LOCK',tags:'SCENE',syntax:'=CAMERA_LOCK(axis[, angle])',params:'axis: "X"|"Y"|"Z"|"" (free) angle: degrees for fixed view',desc:'Constrains camera movement to specific axis or angle for puzzle control.'},
 {name:'PHYS_CAMERA',tags:'SCENE CAMERA',syntax:'=PHYS_CAMERA(mode[, distance[, allowRotation]])',params:'mode: "2d"|"iso"|"free" distance: optional camera distance allowRotation: 0/1 yaw unlock for 2D/iso',desc:'Configures physics-aware camera schemes and aligns gravity/movement to the chosen mode.'},
 {name:'VIEW_MODE',tags:'SCENE',syntax:'=VIEW_MODE(mode[, distance])',params:'mode: "3d"|"2d"|"ortho"|"isometric" distance: camera distance',desc:'Changes camera projection and positioning for different viewing modes.'},
 {name:'SANDBOX',tags:'META',syntax:'=SANDBOX()',params:' ',desc:'Creates Sandbox array (#2) if not exists and centers camera on it.'},
 {name:'UI_CONTROL',tags:'META',syntax:'=UI_CONTROL(type, state)',params:'type: "insert_buttons"|"function_drawer" state: 0/1',desc:'Controls which UI elements are visible when this array is focused.'},
 {name:'IS_FOCUS_ARRAY',tags:'PURE',syntax:'=IS_FOCUS_ARRAY([arrayId])',params:'arrayId: optional target array ID (default: current)',desc:'Returns 1 if the specified array is currently focused, 0 otherwise.'},
 {name:'OVERLAP',tags:'SCENE',syntax:'=OVERLAP(targetArray[, mode])',params:'targetArray: array ref mode: "detect"|"count"|"list"',desc:'Detects spatial overlap between this array and target array in 3D space.'},
 {name:'EVALUATE',tags:'META',syntax:'=EVALUATE(condition, expected)',params:'condition: formula string expected: boolean result',desc:'Evaluates a condition and returns TRUE/FALSE for UI state control.'},
 {name:'STORE_ARRAY',tags:'PURE',syntax:'=STORE_ARRAY(source[, "Name"])',params:'source: range (A1a:C3a), dimensions (w,h,d), or inline values (1,2,3) Name: optional template name',desc:'Captures data as a reusable template. Dimensions collect from anchor area, ranges from specified cells, inline values as list.'},
 {name:'CAST',tags:'SCENE',syntax:'=CAST(direction[, data])',params:'direction: "UP"|"DOWN"|"FORWARD"|"BACK"|"LEFT"|"RIGHT" data: optional payload',desc:'Spawns a moving voxel packet in the specified direction (physics integration pending).'},
 {name:'ON_COLLIDE',tags:'SCENE',syntax:'=ON_COLLIDE(handler)',params:'handler: formula to execute when hit by CAST packet',desc:'Sets collision response handler for incoming voxel packets.'},
 {name:'CHIME',tags:'AUDIO',syntax:'=CHIME(note[, octave[, duration]])',params:'note: A G with optional # or b octave: integer (default 4) duration: optional seconds',desc:'Plays a musical chime. Triggerable from formulas, DO(), on_click(), or on_select() for interactive instruments.'},
 {name:'FUNCTION_UI',tags:'META',syntax:'=FUNCTION_UI([port[, filter[, page[, perPage]]]])',params:'port: "east"|"west"|"north"|"south" filter: substring filter page: page number perPage: functions per page',desc:'Creates diegetic function browser. Rows use ON_SELECT hooks: ? inserts to focus and toasts; ?? copies call and toasts.'},
 {name:'INVENTORY',tags:'META',syntax:'=INVENTORY([port[, title]])',params:'port: dock position title: inventory name',desc:'Creates interactive inventory with +/- quantity buttons and ? use buttons.'},
 {name:'2D_PLATFORMER',tags:'META',syntax:'=2D_PLATFORMER([port])',params:'port: dock position for controller',desc:'Creates controller (ON_SELECT joystick) and screen; center button spawns screen via ON_SELECT.'},
 {name:'FOCUS_SET',tags:'ACTION',syntax:'=FOCUS_SET(content) or =FOCUS_SET(mode, content)',params:'mode: "text"|"formula"|"clipboard" content: data to set/copy',desc:'Writes to focused cell or copies to clipboard (with toast).'},
 {name:'SET_SELECTED',tags:'ACTION',syntax:'=SET_SELECTED(direction)',params:'direction: "up"|"down"|"left"|"right"|"forward"|"back"',desc:'Moves avatar character in screen array based on direction.'}
 ];
 // Utilities to merge manual docs with Fn registry and compute composition
 function mergeDocsAndComputeDeps(){
 const globalFn = (typeof window!=='undefined' && window.Fn) ? window.Fn : (typeof Fn!=='undefined'? Fn : {});
 const allNames = Object.keys(globalFn||{});
 const docsByName = new Map(docs.map(d => [d.name, {...d}]));
 const toUpperSet=(x)=>{ const set=new Set(); (x||[]).forEach(v=>set.add(String(v).toUpperCase())); return set; };
 const namesUpper = new Set(allNames.map(n=>n.toUpperCase()));
 const reCall = /=([A-Z_][A-Z0-9_]*)\s*\(/g; // match =NAME(
 const reProp = /Fn\.([A-Z_][A-Z0-9_]*)/g; // match Fn.NAME
 const reIndex = /Fn\[['"]([A-Z_][A-Z0-9_]*)['"]\]/g; // match Fn['NAME']
 const extractDeps=(src)=>{
 const found=new Set(); if(!src) return [];
 let m; while((m=reCall.exec(src))){ const n=m[1].toUpperCase(); if(namesUpper.has(n)) found.add(n); }
 while((m=reProp.exec(src))){ const n=m[1].toUpperCase(); if(namesUpper.has(n)) found.add(n); }
 while((m=reIndex.exec(src))){ const n=m[1].toUpperCase(); if(namesUpper.has(n)) found.add(n); }
 return Array.from(found);
 };
 allNames.forEach(name=>{
 const meta = globalFn[name] || {};
 const existing = docsByName.get(name);
 const tagsRaw = meta.tags;
 const tagsArr = Array.isArray(tagsRaw) ? tagsRaw : (tagsRaw instanceof Set ? Array.from(tagsRaw) : []);
 const tagStr = (tagsArr && tagsArr.length) ? tagsArr.join(',') : '';
 const implSrc = (meta.impl && meta.impl.toString) ? String(meta.impl.toString()) : '';
 const deps = extractDeps(implSrc);
 if(existing){
 // Merge tags
 const existingTags = String(existing.tags||'').split(/[\s,]+/).filter(Boolean).map(t=>t.toUpperCase());
 const merged = new Set(existingTags.concat(tagsArr.map(t=>String(t).toUpperCase())));
 existing.tags = Array.from(merged).join(',');
 // Fill blank fields only
 if(!existing.syntax) existing.syntax = meta.syntax || `=${name}()`;
 if(!existing.params) existing.params = meta.params || '';
 if(!existing.desc) existing.desc = meta.desc || '';
 existing.deps = deps.filter(d=>d!==name.toUpperCase());
 existing.isComposite = existing.deps && existing.deps.length>0;
 docsByName.set(name, existing);
 } else {
 docsByName.set(name, {name, tags: tagStr || 'OTHER', syntax: meta.syntax || `=${name}()`, params: meta.params || '', desc: meta.desc || '', deps: deps.filter(d=>d!==name.toUpperCase()), isComposite: deps.length>0});
 }
 });
 // Also compute deps for any manual-only entry
 docsByName.forEach((d)=>{ if(d.deps===undefined) d.deps=[]; if(d.isComposite===undefined) d.isComposite = d.deps.length>0; });
 return Array.from(docsByName.values()).sort((a,b)=> a.name.localeCompare(b.name));
 }
 const pickCat = (d) => {
 const t = String(d.tags||'').toUpperCase();
 if(t.includes('GLOBAL')) return 'GLOBAL';
 if(t.includes('EVENT')) return 'EVENTS';
 if(t.includes('GAME')) return 'GAMES';
 if(t.includes('SCENE')) return 'SCENE';
 if(t.includes('DATA') || t.includes('PURE')) return 'DATA';
 if(t.includes('LOGIC')) return 'LOGIC';
 if(t.includes('MATH')) return 'MATH';
 if(t.includes('NAV')) return 'NAVIGATION';
 if(t.includes('INTERACTION')) return 'INTERACTION';
 if(t.includes('IO')) return 'IO';
 if(t.includes('META') || t.includes('ACTION') || t.includes('ADVANCED')) return 'ADVANCED';
 return 'OTHER';
 };
 // Build filter bar at top
 const filterBar=document.createElement('div');
 filterBar.className='fx-filter-bar';
 filterBar.style.cssText='display:flex;gap:6px;align-items:center;margin-bottom:8px;';
 const modes=[{key:'all', label:'All'},{key:'raw', label:'Raw'},{key:'composite', label:'Composite'}];
 const filterState = (Store.getState().ui?.fxFilter)||'all';
 const btns=[];
 modes.forEach(m=>{
 const b=document.createElement('button'); b.textContent=m.label; b.className='btn'; b.dataset.mode=m.key; b.style.padding='4px 8px';
 if(m.key===filterState){ b.classList.add('primary'); }
 b.addEventListener('click',()=>{
 const st=Store.getState(); Store.setState(s=>({ui:{...s.ui, fxFilter:m.key}}));
 btns.forEach(bb=>bb.classList.remove('primary'));
 b.classList.add('primary');
 renderList(m.key);
 });
 btns.push(b); filterBar.appendChild(b);
 });
 els.fxBody.appendChild(filterBar);
 const listWrap=document.createElement('div'); listWrap.id='fxListWrap'; els.fxBody.appendChild(listWrap);
 
 function renderList(mode){
 listWrap.innerHTML='';
 const allDocs = mergeDocsAndComputeDeps();
 const filtered = allDocs.filter(d => mode==='all' ? true : (mode==='composite'? d.isComposite : !d.isComposite));
 // Group by category
 const categories = {};
 filtered.forEach(d=>{ const c=pickCat(d); (categories[c]||(categories[c]=[])).push(d); });
 
 // Category info with icons and colors
 const categoryInfo = {
 'GLOBAL': {icon: '??', name: 'Global State', color: '#3b82f6'},
 'EVENTS': {icon: '?', name: 'Event System', color: '#22c55e'},
 'GAMES': {icon: '??', name: 'Game Templates', color: '#f59e0b'},
 'DATA': {icon: '??', name: 'Data Operations', color: '#8b5cf6'},
 'LOGIC': {icon: '??', name: 'Logic & Control', color: '#06b6d4'},
 'MATH': {icon: '??', name: 'Mathematics', color: '#ef4444'},
 'NAVIGATION': {icon: '??', name: 'Navigation', color: '#84cc16'},
 'INTERACTION': {icon: '??', name: 'User Interaction', color: '#ec4899'},
 'SCENE': {icon: '??', name: 'Scene Control', color: '#f97316'},
 'ARRAYS': {icon: '??', name: 'Array Management', color: '#64748b'},
 'IO': {icon: '??', name: 'Input/Output', color: '#0ea5e9'},
 'ADVANCED': {icon: '??', name: 'Advanced Tools', color: '#6366f1'},
 'OTHER': {icon: '??', name: 'Other', color: '#64748b'}
 };
 Object.entries(categories).forEach(([catName, funcs]) => {
 const info = categoryInfo[catName] || {icon: '??', name: catName, color: '#64748b'};
 const header = document.createElement('div');
 header.className = 'fx-category-header';
 header.style.cssText = `display:flex;align-items:center;gap:8px;padding:8px 12px;background:${info.color}15;border:1px solid ${info.color}40;border-radius:10px;margin:8px 0 4px 0;cursor:pointer;font-weight:600;user-select:none;`;
 header.innerHTML = `<span style="font-size:16px;">${info.icon}</span><span style="flex:1;">${info.name}</span><span class="collapse-arrow" style="font-size:12px;transition:transform 0.2s;">?</span>`;
 const body = document.createElement('div'); body.className='fx-category-body'; body.style.display='block';
 funcs.forEach(d => {
 const div = document.createElement('div');
 div.className = 'fx-item';
 div.style.marginLeft = '12px';
 const tagStr = (d.tags||'');
 const madeOf = (d.deps && d.deps.length) ? `<details style="margin-top:6px;"><summary>Made of </summary><div style="margin-top:4px;">
 ${d.deps.sort().map(dep=>`<span class=\"badge\" style=\"display:inline-block;margin:2px 4px 0 0;padding:2px 6px;border-radius:8px;background:var(--chip-bg);border:1px solid var(--chip-border);font-size:10px;\">${dep}</span>`).join('')}
 </div></details>` : '';
 div.innerHTML = `<div class="fx-name"><button class="btn" data-insert="${d.name}" style="font-size:11px;padding:4px 8px;">${d.name}</button> <span style="font-size:9px;color:var(--muted)">${tagStr}</span></div><div class="fx-syntax" style="font-size:11px;">${d.syntax||`=${d.name}()`}</div><div style="font-size:10px;color:var(--muted);margin:3px 0"><b>Parameters:</b> ${d.params||''}</div><div class="fx-desc" style="font-size:11px;">${d.desc||''}</div>${madeOf}<div class="row" style="margin-top:4px"><button class="fx-copy" style="font-size:10px;padding:2px 6px;">Copy</button><button class="btn" data-insert-raw="${(d.syntax||`=${d.name}()`).replace(/"/g,'&quot;')}" style="font-size:10px;padding:2px 6px;margin-left:6px">Insert</button></div>`;
 div.querySelector('.fx-copy').onclick = () => { navigator.clipboard.writeText(d.syntax||`=${d.name}()`); showToast('Copied'); };
 div.querySelector('button[data-insert]')?.addEventListener('click', () => {
 const name = d.name; const input = els.fx; const at = input.selectionStart ?? input.value.length;
 const before = input.value.slice(0, at); const after = input.value.slice(at);
 const ins = before.endsWith('=') ? `${name}()` : `=${name}()`;
 input.value = before + ins + after; input.focus();
 const pos = (before + ins).length - 1; input.setSelectionRange(pos, pos);
 });
 div.querySelector('button[data-insert-raw]')?.addEventListener('click', (e) => {
 const text = e.currentTarget.getAttribute('data-insert-raw') || '';
 els.fx.value = text; els.apply.click();
 });
 body.appendChild(div);
 });
 let collapsed=false; header.addEventListener('click',()=>{ collapsed=!collapsed; body.style.display=collapsed?'none':'block'; header.querySelector('.collapse-arrow').style.transform = collapsed? 'rotate(-90deg)':'rotate(0deg)'; });
 listWrap.appendChild(header); listWrap.appendChild(body);
 });
 }
 // Initial render
 renderList(filterState);
 
 // Category info with icons and colors
 // (Category rendering moved into renderList)
 }

 function setHovered2D(arrId, coord){
 try{
 // clear previous class
 if(hovered2D){
 const sel = hovered2D;
 const prev = document.querySelector(`td.cell[data-x="${sel.x}"][data-y="${sel.y}"][data-z="${sel.z}"]`);
 if(prev) prev.classList.remove('hovered');
 }
 hovered2D = (arrId && coord) ? {arrId, ...coord} : null;
 if(hovered2D){
 const td = document.querySelector(`td.cell[data-x="${coord.x}"][data-y="${coord.y}"][data-z="${coord.z}"]`);
 if(td) td.classList.add('hovered');
 try{ Scene && Scene.setHoverCell && Scene.setHoverCell({arrId, x:coord.x, y:coord.y, z:coord.z}); }catch{}
 } else {
 try{ Scene && Scene.clearHoverCell && Scene.clearHoverCell(); }catch{}
 }
 }catch{}
 }

 function setHoveredCell(arrId, coord){
 // Called from Scene to reflect 3D hover into 2D grid
 setHovered2D(arrId, coord);
 }

 function toggleFxPanel(){ const open=!Store.getState().ui.fxOpen; Store.setState(s=>({ui:{...s.ui,fxOpen:open}})); if(open){ els.fxPanel.style.display='flex'; showFunctionDrawer(); } else { hideFunctionDrawer(); } }
 // Enhanced: dock function drawer beside last visible cell and expand sheet width
 function showFunctionDrawer(){
 const panel=els.fxPanel; if(!panel) return;
 const sheet=document.getElementById('sheet');
 const body=sheet.querySelector('.sheet-body');
 const grid=sheet.querySelector('.grid-wrap');
 // Dock panel at right, between grid and window border
 body.style.display='flex';
 grid.style.flex='1 1 auto';
 // Drawer width: ~two cell widths
 const colWidth = parseInt(getComputedStyle(document.querySelector('td.cell'))?.width||'140',10);
 const drawerWidth = Math.max(240, Math.min(480, colWidth*2 + 24));
 panel.style.flex = `0 0 ${drawerWidth}px`;
 panel.style.display='flex';
 panel.classList.add('fx-visible');
 // Grow sheet width smoothly to accommodate panel if needed, but cap to 70% viewport width
 const cap = Math.floor(window.innerWidth * 0.7);
 const curW=parseInt(sheet.style.width||getComputedStyle(sheet).width,10)||sheet.offsetWidth;
 const minNeeded = grid.scrollWidth + drawerWidth + 48; // grid + drawer + padding
 const nextW = Math.max(curW, Math.min(cap, minNeeded));
 sheet.style.width = nextW + 'px';
 }
 function hideFunctionDrawer(){
 const sheet=document.getElementById('sheet');
 const body=sheet.querySelector('.sheet-body');
 const grid=sheet.querySelector('.grid-wrap');
 els.fxPanel.classList.remove('fx-visible');
 // Shrink sheet width back to just fit grid + small pad
 setTimeout(()=>{
 const desired = Math.min(Math.max(grid.scrollWidth + 32, 720), Math.floor(window.innerWidth*0.6));
 sheet.style.width = desired + 'px';
 els.fxPanel.style.display='none';
 }, 250);
 }
 function currentArray(){ const s=Store.getState().selection; return s.arrayId?Store.getState().arrays[s.arrayId]:Store.getState().arrays[1]||Store.getState().arrays[-1]; }
 function getZLayer(){ return Store.getState().ui.zLayer; } // parser hook
 function clampLayerIndex(arr, idx){
 const max = Math.max(0, ((arr?.size?.z)||1) - 1);
 const value = Number.isFinite(idx) ? (idx|0) : 0;
 return Math.max(0, Math.min(max, value));
 }
 function setZLayer(index){
 const arr = currentArray();
 const next = clampLayerIndex(arr, index);
 const prev = getZLayer();
 if(next === prev) return next;
 Store.setState(s=>({ ui:{...s.ui, zLayer: next} }));
 try{ renderSheet(); }catch(e){ console.warn('renderSheet after setZLayer failed', e); }
 try{ highlightSheetCell(); }catch(e){ console.warn('highlight after setZLayer failed', e); }
 return next;
 }
 function shiftZLayer(delta){
 const step = Number.isFinite(delta) ? (delta|0) : 0;
 if(!step) return getZLayer();
 return setZLayer(getZLayer() + step);
 }
 // Intro collapse trigger for onboarding
 function triggerIntroCollapse(){
 const sheetEl=document.getElementById('sheet');
 const header=document.getElementById('sheetHeaderCard');
 if(!sheetEl){ console.warn('triggerIntroCollapse: sheet not found'); return false; }
 console.log('triggerIntroCollapse: before', {classes: sheetEl.className, left: sheetEl.style.left, top: sheetEl.style.top, bottom: sheetEl.style.bottom, transform: sheetEl.style.transform});
 sheetEl.classList.remove('intro-max');
 sheetEl.classList.remove('intro-centered');
 // Resize relative to viewport with sane minimums
 const isTouch = document.body.classList.contains('touch');
 if(isTouch){
 // Behind-sheet header wipe animation
 try{
 const r=sheetEl.getBoundingClientRect();
 header.style.left = r.left + 'px';
 header.style.top = (r.top - 10) + 'px';
 header.style.width = r.width + 'px';
 header.style.height = (r.height + 20) + 'px';
 header.classList.add('visible');
 // Expand to wipe
 requestAnimationFrame(()=>{ header.classList.add('wipe'); });
 // Cleanup after wipe
 setTimeout(()=>{ header.classList.remove('wipe'); header.classList.remove('visible'); }, 700);
 }catch{}
 // Mobile card: center bottom with capped width and ~40vh height
 const targetWidth = Math.min(window.innerWidth*0.92, 680);
 const targetHeight = Math.round(Math.min(window.innerHeight*0.40, 520));
 const leftPx = Math.max(12, Math.round((window.innerWidth - targetWidth) / 2));
 sheetEl.style.width = targetWidth + 'px';
 sheetEl.style.height = targetHeight + 'px';
 sheetEl.style.left = leftPx + 'px';
 sheetEl.style.right = 'auto';
 sheetEl.style.bottom = '12px';
 sheetEl.style.top = '';
 sheetEl.style.transform = 'none';
 sheetEl.dataset.touchFreed = '1';
 } else {
 // Desktop: bottom-left similar to launch size
 const vw = Math.max(720, Math.floor(window.innerWidth * 0.42));
 const vh = Math.max(360, Math.floor(window.innerHeight * 0.40));
 // Behind-sheet header wipe animation
 try{
 const r=sheetEl.getBoundingClientRect();
 header.style.left = r.left + 'px';
 header.style.top = (r.top - 10) + 'px';
 header.style.width = r.width + 'px';
 header.style.height = (r.height + 20) + 'px';
 header.classList.add('visible');
 requestAnimationFrame(()=>{ header.classList.add('wipe'); });
 setTimeout(()=>{ header.classList.remove('wipe'); header.classList.remove('visible'); }, 700);
 }catch{}
 sheetEl.style.width = vw + 'px';
 sheetEl.style.height = vh + 'px';
 sheetEl.style.left = '16px';
 sheetEl.style.top = '';
 sheetEl.style.bottom = '16px';
 sheetEl.style.transform = '';
 sheetEl.dataset.touchFreed = '0';
 }
 // Mark sheet as user-sized after intro so renderSheet doesn't resize it
 sheetEl.dataset.userSized = '1';
 console.log('triggerIntroCollapse: after', {classes: sheetEl.className, left: sheetEl.style.left, top: sheetEl.style.top, bottom: sheetEl.style.bottom, transform: sheetEl.style.transform});
 return true;
 }
 // Robust overlay hider with hard fallback
 function hideIntroOverlay(){
 const io = document.getElementById('introOverlay');
 if (io) {
 io.classList.add('hidden');
 return true;
 }
 console.warn('hideIntroOverlay: introOverlay not found');
 return false;
 }
 function debugIntroState(stage){
 const sheet=document.getElementById('sheet');
 const io=document.getElementById('introOverlay');
 const snapshot={
 stage,
 sheet:{ classes: sheet?.className, left: sheet?.style.left, top: sheet?.style.top, bottom: sheet?.style.bottom, transform: sheet?.style.transform },
 overlay:{ exists: !!io, hiddenClass: io?.classList.contains('hidden'), opacity: io? getComputedStyle(io).opacity : 'n/a', display: io? getComputedStyle(io).display : 'n/a', pointer: io?.style.pointerEvents }
 };
 console.log('IntroDebug:', snapshot);
 }
 function kickIntroSequence(reason='manual'){
 console.log('kickIntroSequence:', reason);
 debugIntroState('kick:pre');
 const hid = hideIntroOverlay();
 const col = triggerIntroCollapse();
 debugIntroState('kick:post');
 showToast('? Intro');
 try{ window.__INTRO_FIRED = true; }catch{}
 return hid && col;
 }
 function getCell(arrayId,coord){ const arr=Store.getState().arrays[arrayId]; if(!arr) return {value:'',formula:null}; const ch=arr.chunks[keyChunk(...Object.values(chunkOf(coord.x,coord.y,coord.z)))]; if(!ch) return {value:'',formula:null}; const m=ch.cellMap; if(m){ const c=m.get(`${coord.x},${coord.y},${coord.z}`); return c||{value:'',formula:null}; } const c=ch.cells.find(t=>t.x===coord.x&&t.y===coord.y&&t.z===coord.z); return c||{value:'',formula:null}; }

 function updateFocusChip(){
 const s=Store.getState().selection;
 // If focus UI is not present (selection panel removed), degrade gracefully
 if(!s.arrayId||!s.focus){
 if(els.focusChip) els.focusChip.textContent='None selected.';
 if(els.inspect) els.inspect.textContent='No selection.';
 els.fx.value='';
 try{ highlightFxRefs(''); }catch{}
 return;
 }
 const arr=Store.getState().arrays[s.arrayId]; const cell=getCell(s.arrayId,s.focus);
 // Update fx input to show cell contents and sync highlight
 els.fx.value = (cell.formula && cell.formula!=='') ? cell.formula : String(cell.value??'');
 try{ highlightFxRefs(els.fx.value); }catch{}
 // Ensure any transient direct editor content is cleared when selection changes
 try{ if(els.direct && els.direct.style.display!=='block') els.direct.value=''; }catch{}
 
 // Update UI controls based on focused array
 updateUIControls(arr);
 
 const range = s.range;
 const zStart = range ? (range.z1 ?? range.z ?? s.focus.z) : s.focus.z;
 const zEnd = range ? (range.z2 ?? range.z ?? s.focus.z) : s.focus.z;
 const isMulti = range && (range.x1!==range.x2 || range.y1!==range.y2 || zStart!==zEnd);
 if(isMulti){
 const {x1,x2,y1,y2} = range;
 const layerCount = (zEnd - zStart + 1);
 const count=(x2-x1+1)*(y2-y1+1)*layerCount;
 let sum=0,vals=0,min=Infinity,max=-Infinity;
 for(let z=zStart; z<=zEnd; z++){
 for(let y=y1;y<=y2;y++){
 for(let x=x1;x<=x2;x++){
 const c=getCell(s.arrayId,{x,y,z}); const v=+c.value;
 if(!isNaN(v)){ sum+=v; vals++; min=Math.min(min,v); max=Math.max(max,v); }
 }
 }
 }
 const avg=vals>0?(sum/vals):0;
 const zLabelStart = typeof zStart==='number'?greek(zStart):'';
 const zLabelEnd = typeof zEnd==='number'?greek(zEnd):zLabelStart;
 const rangeLabel = `${A1(x1)}${y1+1}${zLabelStart}:${A1(x2)}${y2+1}${zLabelEnd}`;
 const layerLabel = layerCount>1?`${layerCount} layers`:`${layerCount} layer`;
 if(els.focusChip) els.focusChip.textContent = `Range ${count} cells (${layerLabel}): sum=${sum.toFixed(1)} avg=${avg.toFixed(1)} min=${min===Infinity?' ':min} max=${max===-Infinity?' ':max}`;
 if(els.inspect) els.inspect.textContent = `Range ${rangeLabel}\nCells: ${count}, Values: ${vals}, ${layerLabel}\nSum: ${sum}, Avg: ${avg.toFixed(2)}`;
 } else {
 if(els.focusChip) els.focusChip.textContent = `#${arr.id} ${arr.name} ${A1(s.focus.x)}${s.focus.y+1}${greek(s.focus.z)}`;
 if(els.inspect) els.inspect.textContent = `Array #${arr.id} "${arr.name}"\nCell ${A1(s.focus.x)}${s.focus.y+1}${greek(s.focus.z)} @[${s.focus.x+1},${s.focus.y+1},${s.focus.z+1},${arr.id}]\nValue: ${JSON.stringify(cell.value)}\nFormula: ${cell.formula||''}`;

 // --- START NEW COLOR SYNC LOGIC ---
 try{
 const focusColor = (cell?.meta?.color) ? String(cell.meta.color) : '#ffffff';
 const pickerInput = document.getElementById('fillColorPicker');
 const pickerPreview = document.getElementById('fillColorPreview');
 if(pickerInput) pickerInput.value = focusColor;
 if(pickerPreview) pickerPreview.style.backgroundColor = focusColor;
 }catch{}
 // --- END NEW COLOR SYNC LOGIC ---
 }
 }

 function updateUIControls(arr){
 // Check if insert buttons should be visible based on array UI controls
 const controls = arr.uiControls || {};
 const insertAllowed = controls.insert_buttons || (arr.id === 2); // Sandbox enables by default
 // Make sheet title editable on double click
 try{
 const titleEl = document.getElementById('sheetTitle');
 if(titleEl && !titleEl._wired){
 titleEl._wired = true;
 titleEl.title = 'Double-click to rename';
 titleEl.addEventListener('dblclick', ()=>{
 const current = String(arr.name||'Unnamed');
 const next = window.prompt('Rename array:', current);
 if(next!=null){ arr.name = next || 'Unnamed'; UI.updateFocusChip?.(); }
 });
 }
 }catch{}
 const insertRow = document.getElementById('insertRow');
 const insertCol = document.getElementById('insertCol');
 const insertLayer = document.getElementById('insertLayer');
 if(insertRow) insertRow.style.display = insertAllowed ? 'inline-block' : 'none';
 if(insertCol) insertCol.style.display = insertAllowed ? 'inline-block' : 'none';
 if(insertLayer) insertLayer.style.display = insertAllowed ? 'inline-block' : 'none';
 }
 function bindHoldAction(td, arr, anchorRef, initialAction){
 if(td._holdCleanup){ try{ td._holdCleanup(); }catch{} }
 td._holdCleanup = null;
 td.classList.remove('holdable');

 const hasAction = !!normalizeActionFormula(initialAction||'');
 if(!hasAction) return;

 td.classList.add('holdable');
 let active=false;
 let timer=null;
 let pointerId=null;

 const runHold = ()=>{
 const fresh = UI.getCell?.(anchorRef.arrId, {x:anchorRef.x, y:anchorRef.y, z:anchorRef.z});
 const raw = getMetaAction(fresh?.meta, 'on_hold') ?? initialAction;
 const normalized = normalizeActionFormula(raw||'');
 if(!normalized) return false;
 try{
 executeActionFormula(anchorRef, raw, 'hold');
 }catch(err){ console.warn('on_hold failed', err); return false; }
 return true;
 };

 const stopHold = ()=>{
 if(timer){ clearInterval(timer); timer=null; }
 if(active){ td.classList.remove('pending'); active=false; }
 pointerId=null;
 };

 const handleCancel = ()=>{ stopHold(); };
 const handlePointerUp = (e)=>{
 if(pointerId!=null && e && e.pointerId!=null && e.pointerId!==pointerId) return;
 stopHold();
 };
 const handlePointerDown = (e)=>{
 if(e.button!=null && e.button!==0 && e.pointerType!=='touch') return;
 if(active) return;
 if(e.pointerType==='touch'){ e.preventDefault(); }
 if(!runHold()) return;
 active=true;
 pointerId = e.pointerId;
 td.classList.add('pending');
 try{ td.setPointerCapture?.(e.pointerId); }catch{}
 timer = setInterval(()=>{ if(!runHold()) stopHold(); }, ACTION_TICK_MS);
 };

 td.addEventListener('pointerdown', handlePointerDown);
 td.addEventListener('pointerup', handlePointerUp);
 td.addEventListener('pointerleave', handleCancel);
 td.addEventListener('pointercancel', handleCancel);
 td.addEventListener('lostpointercapture', handleCancel);

 td._holdCleanup = ()=>{
 stopHold();
 td.removeEventListener('pointerdown', handlePointerDown);
 td.removeEventListener('pointerup', handlePointerUp);
 td.removeEventListener('pointerleave', handleCancel);
 td.removeEventListener('pointercancel', handleCancel);
 td.removeEventListener('lostpointercapture', handleCancel);
 };
 }

 function bindClickAction(td, arr, anchorRef){
 const {x,y,z} = anchorRef;
 const key = `${anchorRef.arrId}:${x},${y},${z}`;

 const runClick = ()=>{
 let action='';
 try{
 const fresh = UI.getCell?.(anchorRef.arrId, {x,y,z});
 action = getMetaAction(fresh?.meta, 'on_click') || action;
 }catch{}
 if(!action){
 try{ if(!window.__INTRO_FIRED) action = '=STARTINTROEXPERIENCE()'; }catch{}
 }
 const normalized = normalizeActionFormula(action||'');
 if(!normalized) return;
 try{
 td.classList.add('pending');
 executeActionFormula(anchorRef, action, 'click');
 try{
 UI.debugIntroState?.('onclick-commit');
 const didHide = window.UI?.hideIntroOverlay?.();
 if(didHide){
 try{ window.__INTRO_FIRED = true; }catch{}
 window.UI?.triggerIntroCollapse?.();
 } else {
 UI.kickIntroSequence?.('onclick-fallback');
 }
 }catch{}
 }catch(err){
 console.warn('on_click failed', err);
 }finally{
 td.classList.remove('pending');
 }
 };

 td.onclick = (e)=>{
 Actions.setSelection(arr.id,{x,y,z}, null, '2d');
 window.__awaiting2DClick = false;
 if(!window.__sheetClickTimers) window.__sheetClickTimers = new Map();
 if(window.__sheetClickTimers.has(key)){
 try{ clearTimeout(window.__sheetClickTimers.get(key)); }catch{}
 window.__sheetClickTimers.delete(key);
 e.preventDefault();
 e.stopPropagation();
 setTimeout(()=>{ try{ openEditor(); }catch{} }, 0);
 return;
 }
 const timer = setTimeout(()=>{
 try{ window.__sheetClickTimers.delete(key); }catch{}
 runClick();
 }, 220);
 window.__sheetClickTimers.set(key, timer);
 };

 td.ondblclick = (e)=>{
 e.preventDefault();
 e.stopPropagation();
 window.__awaiting2DClick = false;
 Actions.setSelection(arr.id,{x,y,z}, null, '2d');
 try{ window.__last2DCell = {arrId:arr.id, x, y, z}; }catch{}
 try{
 if(window.__sheetClickTimers?.has?.(key)){
 clearTimeout(window.__sheetClickTimers.get(key));
 window.__sheetClickTimers.delete(key);
 }
 }catch{}
 setTimeout(()=>openEditor(),0);
 };
 }

 function updateSheetCellDom(td, arr, x, y, z, cell){
 const data = cell ?? getCell(arr.id,{x,y,z}) ?? {};
 const anchorRef = {arrId:arr.id, x, y, z};
 const display = (data?.meta && data.meta.displayText!==undefined) ? data.meta.displayText : (data?.value ?? '');

 td.classList.remove('pending');
 td.textContent = display;
 td.title = data?.formula || '';

 if(typeof twemoji !== 'undefined' && td.textContent){
 try{ twemoji.parse(td, {folder: 'svg', ext: '.svg', className: 'emoji'}); }catch{}
 }

 const color = data?.meta?.color;
 if(color){
 td.style.backgroundColor = color;
 const hex = String(color||'').replace('#','');
 const r = parseInt(hex.substring(0,2),16)|0;
 const g = parseInt(hex.substring(2,4),16)|0;
 const b = parseInt(hex.substring(4,6),16)|0;
 const brightness = (r*299 + g*587 + b*114) / 1000;
 td.style.color = brightness > 128 ? '#1f2937' : '#ffffff';
 } else {
 td.style.backgroundColor = '';
 td.style.color = '';
 }

 td.querySelector('.note-tooltip')?.remove();
 const hasNote = data?.meta?.noteText;
 if(hasNote){
 const tooltip=document.createElement('div');
 tooltip.className='note-tooltip note-visible';
 tooltip.textContent=data.meta.noteText;
 td.style.position='relative';
 td.appendChild(tooltip);
 td.classList.add('intro-cell');
 } else {
 td.classList.remove('intro-cell');
 if(!td.querySelector('.note-tooltip')) td.style.position='';
 }

 td.classList.toggle('clickable', !!getMetaAction(data?.meta, 'on_click'));

 bindHoldAction(td, arr, anchorRef, getMetaAction(data?.meta, 'on_hold'));
 bindClickAction(td, arr, anchorRef);

 if(data?.meta?.generated){
 td.setAttribute('data-generated', 'true');
 if(data.formula){ td.setAttribute('data-anchor','true'); }
 else { td.removeAttribute('data-anchor'); }
 } else {
 td.removeAttribute('data-generated');
 td.removeAttribute('data-anchor');
 }
 }

 function renderSheet(){
 // Guard: avoid destroying cells between mousedown and click; allow highlight only
 if(window.__awaiting2DClick){ try{ highlightSheetCell(); }catch{} return; }
 const arr=currentArray(); if(!arr) return;
 applyCrystalStyle(Store.getState().ui?.crystal2D);
 els.sheetTitle.textContent=`Array ${arr.id}${arr.name?` "${arr.name}"`:''}`;

 // Size sheet ONLY during intro - after that, keep user-defined size
 const sheet = document.getElementById('sheet');
 if(sheet && !sheet.dataset.userSized){
 const isHome = (arr.id === 1);
 if(isHome && !sheet.dataset.initialSized){
 // Match the size that will be used after intro collapse
 const vw = Math.max(720, Math.floor(window.innerWidth * 0.42));
 const vh = Math.max(360, Math.floor(window.innerHeight * 0.40));
 sheet.style.width = `${vw}px`;
 sheet.style.height = `${vh}px`;
 console.log(`[SHEET] Initial sizing for home array: ${vw}x${vh}`);
 // Mark as sized so we don't resize on selection changes
 sheet.dataset.initialSized = '1';
 }
 }

 // Update UI controls when sheet renders
 updateUIControls(arr);

 // Preserve scroll to avoid jump/offset during drag selection re-renders
 const gridWrapEl = document.querySelector('#sheet .grid-wrap');
 const prevScrollTop = gridWrapEl ? gridWrapEl.scrollTop : 0;
 const prevScrollLeft = gridWrapEl ? gridWrapEl.scrollLeft : 0;

 // reference grid structure (thead/tbody)
 let cols=document.getElementById('cols');
 let rows=document.getElementById('rows');
 if(!cols || !rows){
 const body=document.querySelector('#sheet .sheet-body');
 if(body){
 body.innerHTML='';
 const tbl=document.createElement('table'); tbl.className='sheet'; tbl.style.width='100%';
 const thead=document.createElement('thead'); const tr=document.createElement('tr'); tr.id='cols'; const th=document.createElement('th'); th.style.position='sticky'; th.style.left='0'; tr.appendChild(th); thead.appendChild(tr);
 const tbody=document.createElement('tbody'); tbody.id='rows';
 tbl.appendChild(thead); tbl.appendChild(tbody); body.appendChild(tbl);
 cols=document.getElementById('cols'); rows=document.getElementById('rows');
 }
 }
 if(cols) cols.innerHTML=''; if(rows) rows.innerHTML='';
 console.log('renderSheet: building grid', {arrayId:arr.id, size:arr.size});
 // Leading corner cell: show current Z layer as greek letter
 // Z layer header with prev/next buttons
 const th0=document.createElement('th'); 
 th0.style.cssText='padding:2px 4px; position:sticky; left:0; background:var(--panel); z-index:2;';
 const zLayerWrap = document.createElement('div');
 zLayerWrap.style.cssText='display:flex; align-items:center; gap:2px; justify-content:center;';
 const zPrevBtn = document.createElement('button');
 zPrevBtn.textContent = ' ';
 zPrevBtn.className = 'layer-btn';
 zPrevBtn.style.cssText = 'padding:0 4px; font-size:12px; min-width:20px;';
 zPrevBtn.disabled = (getZLayer() <= 0);
 zPrevBtn.onclick = ()=> shiftZLayer(-1);
 const zLabel = document.createElement('span');
 zLabel.textContent = greek(getZLayer());
 zLabel.style.cssText = 'font-weight:600; min-width:16px; text-align:center;';
 const zNextBtn = document.createElement('button');
 zNextBtn.textContent = ' ';
 zNextBtn.className = 'layer-btn';
 zNextBtn.style.cssText = 'padding:0 4px; font-size:12px; min-width:20px;';
 zNextBtn.disabled = (getZLayer() >= (arr.size.z - 1));
 zNextBtn.onclick = ()=> shiftZLayer(1);
 zLayerWrap.appendChild(zPrevBtn);
 zLayerWrap.appendChild(zLabel);
 zLayerWrap.appendChild(zNextBtn);
 th0.appendChild(zLayerWrap);
 cols.appendChild(th0);
 // TanStack Virtual for efficient large sheet rendering
 const gridWrap = document.querySelector('#sheet .grid-wrap');
 const wrapRect = gridWrap?.getBoundingClientRect?.() || {width:760, height:360};
 const cellH = 26; // matches CSS
 const cellW = 100; // default cell width
 
 // Create virtualizers if TanStack is available
 // For array #1 (Celli's home), render ALL cells with no virtualization
 const isHome = (arr.id === 1);
 let rowStart = 0, rowEnd = isHome ? arr.size.y : Math.min(arr.size.y, 20);
 let colStart = 0, colEnd = isHome ? arr.size.x : Math.min(arr.size.x, 10);
 
 if(typeof TanStackVirtualCore !== 'undefined' && gridWrap && !isHome){
 try{
 const scrollTop = gridWrap.scrollTop || 0;
 const scrollLeft = gridWrap.scrollLeft || 0;
 
 // Row virtualizer
 const rowVirtualizer = TanStackVirtualCore.createVirtualizer({
 count: arr.size.y,
 getScrollElement: () => gridWrap,
 estimateSize: () => cellH,
 overscan: 3
 });
 
 const visibleRows = rowVirtualizer.getVirtualItems();
 if(visibleRows.length > 0){
 rowStart = visibleRows[0].index;
 rowEnd = visibleRows[visibleRows.length - 1].index + 1;
 }
 
 // Column virtualizer (simplified - render all for now due to dynamic widths)
 colStart = Math.max(0, Math.floor(scrollLeft / cellW) - 2);
 colEnd = Math.min(arr.size.x, colStart + Math.ceil(wrapRect.width / cellW) + 4);
 }catch(e){
 console.warn('TanStack virtualization failed, falling back:', e);
 // Fallback to simple virtualization
 const scrollTop = gridWrap?.scrollTop||0;
 const visibleRows = Math.max(1, Math.ceil(wrapRect.height / cellH) + 2);
 rowStart = Math.max(0, Math.floor(scrollTop / cellH));
 rowEnd = Math.min(arr.size.y, rowStart + visibleRows);
 colStart = 0;
 colEnd = arr.size.x;
 }
 } else {
 // Fallback to simple virtualization if TanStack not available
 const scrollTop = gridWrap?.scrollTop||0;
 const visibleRows = Math.max(1, Math.ceil(wrapRect.height / cellH) + 2);
 rowStart = Math.max(0, Math.floor(scrollTop / cellH));
 rowEnd = Math.min(arr.size.y, rowStart + visibleRows);
 colStart = 0;
 colEnd = arr.size.x;
 }
 for(let i=colStart;i<colEnd;i++){
 const th=document.createElement('th'); th.textContent=colNameFromIndex(i); th.style.position='relative';
 const w=getColWidth(i); th.style.minWidth=w+'px'; th.style.width=w+'px'; th.style.maxWidth=w+'px';
 // Resizer handle (Google Sheets-like)
 const grip=document.createElement('div');
 grip.style.position='absolute'; grip.style.right='-3px'; grip.style.top='0'; grip.style.width='6px'; grip.style.height='100%';
 grip.style.cursor='col-resize'; grip.style.userSelect='none'; grip.title='Resize column';
 th.appendChild(grip);
 let resizing=false, startX=0, startW=w;
 const onMove=(e)=>{
 if(!resizing) return; const dx=(e.clientX||0)-startX; const nw=startW+dx; setColWidth(i,nw);
 const cw=getColWidth(i); th.style.minWidth=cw+'px'; th.style.width=cw+'px'; th.style.maxWidth=cw+'px';
 // Apply to visible cells of this column at current layer
 document.querySelectorAll(`td.cell[data-x="${i}"][data-z="${getZLayer()}"]`).forEach(td=>{ td.style.minWidth=cw+'px'; td.style.width=cw+'px'; td.style.maxWidth=cw+'px'; });
 };
 const onUp=()=>{ if(!resizing) return; resizing=false; window.removeEventListener('mousemove',onMove,true); window.removeEventListener('mouseup',onUp,true); };
 grip.addEventListener('mousedown',(e)=>{ e.preventDefault(); e.stopPropagation(); resizing=true; startX=e.clientX||0; startW=getColWidth(i); window.addEventListener('mousemove',onMove,true); window.addEventListener('mouseup',onUp,true); }, true);
 cols.appendChild(th);
 }
 for(let r=rowStart;r<rowEnd;r++){
 const tr=document.createElement('tr');
 const h=document.createElement('th'); h.textContent=r+1; tr.appendChild(h);
 for(let c=colStart;c<colEnd;c++){
 const td=document.createElement('td'); td.className='cell'; td.dataset.x=c; td.dataset.y=r; td.dataset.z=getZLayer();
 // Apply fixed width with per-column override
 const cw=getColWidth(c); td.style.minWidth=cw+'px'; td.style.width=cw+'px'; td.style.maxWidth=cw+'px';
 const cell=getCell(arr.id,{x:c,y:r,z:getZLayer()});
 updateSheetCellDom(td, arr, c, r, getZLayer(), cell);
 td.onmousedown=(e)=>{
 const wrap = document.querySelector('#sheet .grid-wrap');
 const wasTop = wrap ? wrap.scrollTop : 0;
 const wasLeft = wrap ? wrap.scrollLeft : 0;
 window.__awaiting2DClick = true;
 Actions.setSelection(arr.id,{x:c,y:r,z:getZLayer()}, null, '2d'); 
 try{ UI.updateFocusChip?.(); }catch{}
 dragStart={arrayId:arr.id, x:c, y:r, z:getZLayer()}; 
 try{ window.__last2DCell = {arrId:arr.id, x:c, y:r, z:getZLayer()}; }catch{}
 // Keep scroll stable during drag begin
 try{ if(wrap){ wrap.scrollTop = wasTop; wrap.scrollLeft = wasLeft; } }catch{}
 // Do not prevent default, so click/dblclick events still fire
 };
 td.onmouseenter=(e)=>{
 if(dragStart && e.buttons&1 && dragStart.arrayId===arr.id){
 const wrap = document.querySelector('#sheet .grid-wrap');
 const wasTop = wrap ? wrap.scrollTop : 0;
 const wasLeft = wrap ? wrap.scrollLeft : 0;
 Actions.setSelectionRange(arr.id, {x:dragStart.x,y:dragStart.y,z:dragStart.z}, {x:c,y:r,z:getZLayer()}, '2d');
 // Maintain scroll after range update
 try{ if(wrap){ wrap.scrollTop = wasTop; wrap.scrollLeft = wasLeft; } }catch{}
 }
 };
 td.onmouseup=()=>{ dragStart=null; window.__awaiting2DClick = false; };
 tr.appendChild(td);
 }
 rows.appendChild(tr);
 }
 // Set spacer padding to simulate offscreen rows (single spanning cells; no pointer capture)
 try{
 const tbody = rows;
 const before = document.createElement('tr');
 const btd = document.createElement('td');
 btd.colSpan = (arr.size.x + 1);
 btd.style.padding='0'; btd.style.border='0'; btd.style.height = (rowStart*cellH)+'px';
 btd.style.pointerEvents='none'; btd.style.lineHeight='0'; btd.style.fontSize='0';
 before.appendChild(btd);
 const after = document.createElement('tr');
 const atd = document.createElement('td');
 atd.colSpan = (arr.size.x + 1);
 atd.style.padding='0'; atd.style.border='0'; atd.style.height = ((arr.size.y-rowEnd)*cellH)+'px';
 atd.style.pointerEvents='none'; atd.style.lineHeight='0'; atd.style.fontSize='0';
 after.appendChild(atd);
 tbody.prepend(before); tbody.appendChild(after);
 }catch{}
 // Restore scroll positions to prevent perceived offset while dragging
 try{ if(gridWrap){ gridWrap.scrollTop = prevScrollTop; gridWrap.scrollLeft = prevScrollLeft; } }catch{}

 // Re-render on scroll for virtualization window
 try{
 const wrap = document.querySelector('#sheet .grid-wrap');
 if(wrap && !wrap._virtWired){
 wrap._virtWired=true;
 wrap.addEventListener('scroll', (e)=>{
 const tgt = e.target; const prev = tgt._lastVT||0; const now = Date.now();
 if(now - prev > 50){ tgt._lastVT = now; try{ UI.renderSheet?.(); }catch{} }
 }, {passive:true});
 }
 }catch{}
 try{ highlightSheetCell(); }catch(e){ console.warn('highlightSheetCell failed (deferred)', e); setTimeout(()=>{ try{ highlightSheetCell(); }catch(_){} }, 0); }
 // sync 3D focus Z if selection exists
 const s=Store.getState().selection; if(s.arrayId&&s.focus&&s.focus.z!==getZLayer()) Actions.setSelection(s.arrayId,{...s.focus,z:getZLayer()});
 }
 function renderSheetCell(arr,x,y,z){
 const td=document.querySelector(`td.cell[data-x="${x}"][data-y="${y}"][data-z="${z}"]`);
 if(!td) return;
 const cell=getCell(arr.id,{x,y,z});
 updateSheetCellDom(td, arr, x, y, z, cell);
 }
 function highlightSheetCell(){ 
 document.querySelectorAll('td.cell.sel').forEach(td=>td.classList.remove('sel'));
 const s=Store.getState().selection; if(!s.focus) return; 
 if(s.range){
 const zStart = s.range.z1 ?? s.range.z;
 const zEnd = s.range.z2 ?? s.range.z;
 const layer = Store.getState().ui.zLayer;
 if(layer>=zStart && layer<=zEnd){
 for(let y=s.range.y1;y<=s.range.y2;y++){
 for(let x=s.range.x1;x<=s.range.x2;x++){
 const td=document.querySelector(`td.cell[data-x="${x}"][data-y="${y}"][data-z="${layer}"]`);
 if(td) td.classList.add('sel');
 }
 }
 }
 } else {
 const td=document.querySelector(`td.cell[data-x="${s.focus.x}"][data-y="${s.focus.y}"][data-z="${Store.getState().ui.zLayer}"]`); 
 if(td){
 td.classList.add('sel');
 // Manage focusability for keyboard users
 const oldSel = document.querySelector('td.cell[tabindex="0"]'); if(oldSel) oldSel.setAttribute('tabindex','-1');
 td.setAttribute('tabindex','0');
 }
 }
 }
 function scrollSheetToSelection(){ const s=Store.getState().selection; if(!s.focus) return; const td=document.querySelector(`td.cell[data-x="${s.focus.x}"][data-y="${s.focus.y}"][data-z="${Store.getState().ui.zLayer}"]`); if(td) td.scrollIntoView({block:'nearest',inline:'nearest'}); }

 function openEditor(initial){ 
 const s=Store.getState().selection; 
 let focus = s.focus; let arrId = s.arrayId;
 if(!focus){
 try{ const lc=window.__last2DCell; if(lc){ focus={x:lc.x,y:lc.y,z:lc.z}; arrId=lc.arrId; } }catch{}
 }
 if(!focus) return; 
 const arr=Store.getState().arrays[arrId]; 
 const cell=getCell(arrId, focus);
 const baseText = (cell.formula!=null && cell.formula!=='') ? cell.formula : String(cell.value??'');
 const edit=els.direct;
 
 // Position based on last interaction type
 if(Store.getState().ui?.lastInteraction === '2d'){
 // Position near 2D cell if available
 let td=document.querySelector('td.cell.sel');
 if(!td && focus){ td=document.querySelector(`td.cell[data-x="${focus.x}"][data-y="${focus.y}"][data-z="${focus.z}"]`); }
 if(td){ 
 const r=td.getBoundingClientRect(); 
 edit.style.left=r.left+'px'; 
 edit.style.top=(r.top-28)+'px'; 
 } else { 
 // Fallback to sheet position
 const sheet=document.getElementById('sheet'); 
 const r=sheet.getBoundingClientRect(); 
 edit.style.left=(r.left+12)+'px'; 
 edit.style.top=(r.top+36)+'px'; 
 }
 } else {
 // Position in 3D viewport area for 3D interactions
 const canvas=document.getElementById('view');
 if(canvas){
 const r=canvas.getBoundingClientRect();
 edit.style.left=(r.left + r.width/2 - 100)+'px'; // Center horizontally
 edit.style.top=(r.top + 60)+'px'; // Near top of 3D view
 } else {
 // Fallback
 edit.style.left='50%'; 
 edit.style.top='100px';
 }
 }
 
 // Ensure the editor is visible and styled above the 3D canvas
 edit._openedAt = Date.now();
 edit.style.display='block'; 
 edit.style.zIndex='10005';
 edit.style.opacity='1';
 edit.style.pointerEvents='auto';
 edit.value = (initial!==undefined && initial!==null) ? (initial==='='? '=' : initial) : baseText;
 els.fx.value = edit.value; // realtime sync start
 try{ const h=document.getElementById('fxHighlight'); if(h){ h.scrollTop=h.scrollHeight; } }catch{}
 edit.focus(); 
 if(!initial) edit.select();
 }
 function commitEditor(){ 
 const s=Store.getState().selection; 
 if(!s.focus){ 
 els.direct.style.display='none'; 
 return; 
 } 
 const arr=Store.getState().arrays[s.arrayId]; 
 const val=els.direct.value.trim(); 
 const anchor={arrId:s.arrayId,...s.focus}; 
 
 if(val.startsWith('=')) { 
 Formula.setFormula(anchor, val);
 const tx = Write.start('user.directEdit','User direct formula edit');
 Formula.executeAt(anchor, undefined, tx);
 Write.commit(tx);
 } else { 
 const tx = Write.start('user.directValue','User direct value edit');
 Write.set(tx, s.arrayId, s.focus, { value: val, formula: null });
 Write.commit(tx);
 } 
 
 els.direct.style.display='none';
 if(document.activeElement === els.direct){
 try{ els.direct.blur(); }catch{}
 }
 els.direct._closedAt = Date.now(); // Track when editor was closed to prevent rapid re-open
 els.fx.value = ''; // Clear formula box
 updateFocusChip(); // Refresh UI
 }
 // Global escapes: Enter (when editor focused) commits then hides; Escape cancels and hides; clicking outside hides
 document.addEventListener('keydown',(e)=>{
 const edit=els.direct; if(edit.style.display!=='block') return;
 if(e.key==='Enter'){ e.preventDefault(); e.stopPropagation(); commitEditor(); }
 if(e.key==='Escape'){
 e.preventDefault(); e.stopPropagation();
 edit.style.display='none';
 if(document.activeElement === edit){
 try{ edit.blur(); }catch{}
 }
 edit._closedAt = Date.now();
 els.fx.value='';
 }
 }, true);
 // Hide editor on any sheet click when not double-clicking to re-open
 document.getElementById('sheet')?.addEventListener('mousedown',(e)=>{
 const edit=els.direct; 
 if(edit.style.display==='block'){
 const justOpened = (Date.now() - (edit._openedAt||0)) < 200;
 if(!justOpened){
 edit.style.display='none';
 if(document.activeElement === edit){
 try{ edit.blur(); }catch{}
 }
 edit._closedAt = Date.now();
 }
 }
 }, true);
 els.direct.addEventListener('input',()=>{ 
 els.fx.value = els.direct.value; 
 try{ els.fx.dispatchEvent(new Event('input')); }catch{} 
 updateAutocomplete(els.direct);
 try{ highlightFxRefs(els.direct.value); }catch{}
 });
 els.direct.addEventListener('keydown',e=>{ 
 if(autocompleteVisible){
 if(e.key === 'ArrowDown'){
 e.preventDefault();
 selectedSuggestion = Math.min(selectedSuggestion + 1, autocompleteDiv.children.length - 1);
 updateAutocompleteHighlight();
 return;
 }
 if(e.key === 'ArrowUp'){
 e.preventDefault();
 selectedSuggestion = Math.max(selectedSuggestion - 1, -1);
 updateAutocompleteHighlight();
 return;
 }
 if(e.key === 'Tab' || e.key === 'Enter'){
 e.preventDefault();
 const hadSelection = (selectedSuggestion >= 0);
 if(hadSelection){
 const allFunctions = mergeDocsAndComputeDeps();
 const context = getAutocompleteContext(e.target);
 if(context){
 const matches = allFunctions.filter(fn => 
 fn.name.toLowerCase().includes(context.partial.toLowerCase())
 );
 if(matches[selectedSuggestion]){
 applyAutocomplete(e.target, matches[selectedSuggestion]);
 }
 }
 // Do NOT commit if a suggestion was chosen; keep editor open
 hideAutocomplete();
 return;
 } else {
 // No suggestion selected: treat Enter/Tab normally
 hideAutocomplete();
 if(e.key === 'Enter') commitEditor();
 return;
 }
 }
 if(e.key === 'Escape'){
 e.preventDefault();
 hideAutocomplete();
 return;
 }
 } else {
 if(e.key==='Enter'){ e.preventDefault(); e.stopPropagation(); commitEditor(); return; }
 if(e.key==='Escape'){ e.preventDefault(); e.stopPropagation(); els.direct.style.display='none'; els.fx.value=''; return; }
 }
 });
 // Slide sheet to top when soft keyboard likely shows (touch-only, triggered from touch focus)
 function slideSheetTop(){
 if(!document.body.classList.contains('touch')) return;
 // Require that the last interaction was a touch to avoid desktop Enter key causing movement
 if(typeof lastPointerType!=='string' || lastPointerType!=='touch') return;
 const sheet=document.getElementById('sheet'); if(!sheet) return;
 // Only slide if not already pinned top
 if(sheet.dataset.pinnedTop==='1') return;
 sheet.style.transition='transform .35s ease, top .35s ease, bottom .35s ease';
 sheet.style.top='8px'; sheet.style.bottom='auto'; sheet.style.left='50%'; sheet.style.transform='translateX(-50%)';
 sheet.dataset.pinnedTop='1';
 }
 els.fx.addEventListener('focus', slideSheetTop);
 els.direct.addEventListener('focus', slideSheetTop);
 
 // Also handle Enter in the formula textbox
 // Autocomplete system
 let autocompleteDiv = null;
 let autocompleteVisible = false;
 let selectedSuggestion = -1;

 // Move mergeDocsAndComputeDeps to accessible scope
 function mergeDocsAndComputeDeps(){
 const docs=[
 {name:'GET_GLOBAL',tags:'GLOBAL',syntax:'=GET_GLOBAL("key")',params:'key: string identifier for global data',desc:'Retrieves value from global key-value store. Automatically tracks dependencies for reactive updates.'},
 {name:'SET_GLOBAL',tags:'GLOBAL',syntax:'=SET_GLOBAL("key", value)',params:'key: string identifier value: any data to store',desc:'Writes value to global store and triggers re-computation of all dependent cells.'},
 {name:'ON_EVENT',tags:'EVENTS',syntax:'=ON_EVENT("eventName", "actionFormula")',params:'eventName: string event identifier actionFormula: formula to execute when event fires',desc:'Registers an event listener that executes a formula when the specified event is fired.'},
 {name:'FIRE_EVENT',tags:'EVENTS',syntax:'=FIRE_EVENT("eventName"[, payload])',params:'eventName: string event identifier payload: optional data to pass to listeners',desc:'Broadcasts an event to all registered listeners, optionally passing payload data.'},
 {name:'ARRAY',tags:'DATA',syntax:'=ARRAY(source)',params:'source: dimensions (w,h,d[,fill]), "list"/value1,value2... (default), "set"/value1,value2... (clears area), "csv"/"1,2;3,4", or named block',desc:'Enhanced: defaults to list mode, adds set mode for clearing, supports explicit modes.'},
 {name:'GET',tags:'DATA',syntax:'=GET(refOrRange)',params:'refOrRange: single cell or range',desc:'Returns the current value(s) as a block.'},
 {name:'SET',tags:'DATA',syntax:'=SET(target, valueOrBlock[, overwrite])',params:'target: ref/range valueOrBlock: scalar/block overwrite: 0/1',desc:'Direct write helper with size/overwrite checks.'},
 {name:'TRANSPOSE',tags:'DATA',syntax:'=TRANSPOSE(input, planeFlag[, reverse])',params:'input: block planeFlag: 0=X?Y,1=X?Z,2=Y?Z reverse: 0/1',desc:'Swaps axes of a block and writes result at the anchor.'},
 {name:'OFFSET',tags:'NAVIGATION',syntax:'=OFFSET([baseRef], dx[, dy[, dz]])',params:'baseRef: optional reference cell (default: anchor) dx,dy,dz: relative offsets',desc:'Excel-style OFFSET: retrieves value from relative position without writing.'},
 {name:'IF',tags:'LOGIC',syntax:'=IF(condition, then[, else])',params:'condition: comparisons with refs/values then/else: value or call',desc:'Branching evaluation with proper dependency capture.'},
 {name:'AND',tags:'LOGIC',syntax:'=AND(a,b[, ...])',params:'booleans/scalars (coerced)',desc:'Logical AND.'},
 {name:'OR',tags:'LOGIC',syntax:'=OR(a,b[, ...])',params:'booleans/scalars (coerced)',desc:'Logical OR.'},
 {name:'ADD',tags:'MATH',syntax:'=ADD(a[, b[, ...]])',params:'numbers or blocks (elementwise)',desc:'Sum (elementwise for blocks).'},
 {name:'MUL',tags:'MATH',syntax:'=MUL(a[, b[, ...]])',params:'numbers or blocks',desc:'Product (elementwise).'},
 {name:'CREATE',tags:'ACTION',syntax:'=CREATE(x,y,z[, "Name"[,"Id"]])',params:'dimensions (ints), optional nickname, optional explicit ID',desc:'Spawns a new array (respecting optional explicit id).'},
 {name:'DO',tags:'ACTION',syntax:'=DO(f1[, f2[, ...]]) or =DO{ stmt1; stmt2; } [WITH ...]',params:'strings like "=SET(...)" or brace blocks optional WITH atomic/on_error raw strings via `...` or <<<...>>>',desc:'Runs statements left-to-right, defaulting to per-step execution in blocks (set atomic:1 for one tx).'},
 {name:'SEQ',tags:'ACTION',syntax:'=SEQ(...)',params:'alias of DO()',desc:'Shorthand alias for DO that accepts the same string or block forms.'},
 {name:'PIPE',tags:'ACTION',syntax:'=PIPE(value, step1[, step2...])',params:'value: expression steps: formulas using _ placeholder (or auto-appended as last arg)',desc:'Composes nested formulas by threading the prior expression into each step before running once.'},
 {name:'SELF',tags:'NAVIGATION',syntax:'=SELF()',params:' ',desc:'Returns absolute @[x,y,z,arrId] of the host cell.'},
 {name:'DELETE',tags:'ACTION',syntax:'=DELETE(...targets)',params:'targets: array ids, refs, or "self"',desc:'Deletes arrays by id or ref; default self.'},
 {name:'COPY',tags:'ACTION IO',syntax:'=COPY(text)',params:'string text',desc:'Writes text to clipboard and shows a success toast.'},
 {name:'FOCUS_SET',tags:'ACTION',syntax:'=FOCUS_SET(content) or =FOCUS_SET(mode, content)',params:'mode: "text"|"formula"|"clipboard" content: data to set/copy',desc:'Writes to focused cell or copies to clipboard (with toast).'}
 ];
 const globalFn = (typeof window!=='undefined' && window.Fn) ? window.Fn : (typeof Fn!=='undefined'? Fn : {});
 const allNames = Object.keys(globalFn||{});
 const docsByName = new Map(docs.map(d => [d.name, {...d}]));
 allNames.forEach(name=>{
 const meta = globalFn[name] || {};
 if(!docsByName.has(name)){
 const tagsRaw = meta.tags;
 const tagsArr = Array.isArray(tagsRaw) ? tagsRaw : (tagsRaw instanceof Set ? Array.from(tagsRaw) : []);
 const tagStr = (tagsArr && tagsArr.length) ? tagsArr.join(',') : 'OTHER';
 docsByName.set(name, {name, tags: tagStr, syntax: meta.syntax || `=${name}()`, params: meta.params || '', desc: meta.desc || ''});
 }
 });
 return Array.from(docsByName.values()).sort((a,b)=> a.name.localeCompare(b.name));
 }
 
 function createAutocomplete(){
 if(autocompleteDiv) return autocompleteDiv;
 autocompleteDiv = document.createElement('div');
 autocompleteDiv.id = 'autocomplete';
 autocompleteDiv.style.cssText = `
 position: absolute; z-index: 10010; background: #ffffff; border: 1px solid #e5e7eb;
 border-radius: 8px; box-shadow: 0 8px 24px rgba(0,0,0,0.12); max-height: 200px;
 overflow-y: auto; display: none; font-family: 'Roboto Mono', monospace; font-size: 12px;
 `;
 document.body.appendChild(autocompleteDiv);
 return autocompleteDiv;
 }

 function showAutocomplete(input, suggestions){
 const div = createAutocomplete();
 if(suggestions.length === 0){ hideAutocomplete(); return; }
 
 div.innerHTML = suggestions.map((fn, idx) => 
 `<div class="ac-item" data-idx="${idx}" style="padding: 6px 10px; cursor: pointer; border-bottom: 1px solid #f3f4f6; ${idx === selectedSuggestion ? 'background: #f3f4f6;' : ''}">${fn.name}<span style="color: #6b7280; margin-left: 8px; font-size: 10px;">${fn.tags}</span></div>`
 ).join('');
 
 const rect = input.getBoundingClientRect();
 div.style.left = rect.left + 'px';
 div.style.top = (rect.bottom + 2) + 'px';
 div.style.width = Math.max(200, rect.width) + 'px';
 div.style.display = 'block';
 autocompleteVisible = true;
 
 // Click handlers
 div.querySelectorAll('.ac-item').forEach((item, idx) => {
 item.addEventListener('mouseenter', () => { selectedSuggestion = idx; updateAutocompleteHighlight(); });
 item.addEventListener('click', () => {
 applyAutocomplete(input, suggestions[idx]);
 hideAutocomplete();
 });
 });
 }

 function hideAutocomplete(){
 if(autocompleteDiv) autocompleteDiv.style.display = 'none';
 autocompleteVisible = false;
 selectedSuggestion = -1;
 }

 function applyAutocomplete(input, fn){
 const val = input.value;
 const pos = input.selectionStart || val.length;
 // Find the start of the current function name
 let start = pos;
 while(start > 0 && /[A-Z_0-9]/i.test(val[start-1])) start--;
 // Check if we're after = or ,
 let prefix = '';
 if(start > 0 && val[start-1] === '=') prefix = '=';
 else if(start > 0 && val[start-1] === ',') prefix = '';
 
 const before = val.slice(0, start);
 const after = val.slice(pos);
 const insert = `${fn.name}(`;
 input.value = before + insert + after;
 const newPos = before.length + insert.length;
 input.setSelectionRange(newPos, newPos);
 input.focus();
 }

 function getAutocompleteContext(input){
 const val = input.value;
 const pos = input.selectionStart || val.length;
 
 // Look backwards to find = or ,
 let i = pos - 1;
 let foundTrigger = false;
 let triggerPos = -1;
 
 while(i >= 0){
 const ch = val[i];
 if(ch === '=' || ch === ','){
 foundTrigger = true;
 triggerPos = i;
 break;
 } else if(ch === ')' || ch === '('){
 break; // Stop at function boundaries
 }
 i--;
 }
 
 if(!foundTrigger) return null;
 
 // Extract the partial function name after the trigger
 const afterTrigger = val.slice(triggerPos + 1, pos);
 const match = afterTrigger.match(/^\s*([A-Z_][A-Z0-9_]*)/i);
 if(!match) return null;
 
 return {
 trigger: val[triggerPos],
 partial: match[1],
 start: triggerPos + 1 + afterTrigger.indexOf(match[1]),
 end: pos
 };
 }

 function updateAutocomplete(input){
 const context = getAutocompleteContext(input);
 if(!context || context.partial.length < 1){
 hideAutocomplete();
 return;
 }
 
 const allFunctions = mergeDocsAndComputeDeps();
 const matches = allFunctions.filter(fn => 
 fn.name.toLowerCase().includes(context.partial.toLowerCase())
 ).slice(0, 8); // Limit to 8 suggestions
 
 if(matches.length > 0){
 showAutocomplete(input, matches);
 } else {
 hideAutocomplete();
 }
 }

 els.fx.addEventListener('input', (e) => {
 updateAutocomplete(e.target);
 try{ highlightFxRefs(els.fx.value); }catch{}
 });

 els.fx.addEventListener('keydown',e=>{ 
 if(autocompleteVisible){
 if(e.key === 'ArrowDown'){
 e.preventDefault();
 selectedSuggestion = Math.min(selectedSuggestion + 1, autocompleteDiv.children.length - 1);
 updateAutocompleteHighlight();
 return;
 }
 if(e.key === 'ArrowUp'){
 e.preventDefault();
 selectedSuggestion = Math.max(selectedSuggestion - 1, -1);
 updateAutocompleteHighlight();
 return;
 }
 if(e.key === 'Tab' || e.key === 'Enter'){
 e.preventDefault();
 const hadSelection = (selectedSuggestion >= 0);
 if(hadSelection){
 const allFunctions = mergeDocsAndComputeDeps();
 const context = getAutocompleteContext(e.target);
 if(context){
 const matches = allFunctions.filter(fn => 
 fn.name.toLowerCase().includes(context.partial.toLowerCase())
 );
 if(matches[selectedSuggestion]){
 applyAutocomplete(e.target, matches[selectedSuggestion]);
 }
 }
 hideAutocomplete();
 return;
 } else {
 hideAutocomplete();
 if(e.key === 'Enter') els.apply.click();
 return;
 }
 }
 if(e.key === 'Escape'){
 e.preventDefault();
 hideAutocomplete();
 return;
 }
 } else {
 if(e.key==='Enter'){ e.preventDefault(); e.stopPropagation(); els.apply.click(); els.fx.blur(); return; }
 if(e.key==='Escape'){ e.preventDefault(); e.stopPropagation(); els.fx.value=''; els.fx.blur(); return; }
 }
 });

 function updateAutocompleteHighlight(){
 if(!autocompleteDiv) return;
 autocompleteDiv.querySelectorAll('.ac-item').forEach((item, idx) => {
 item.style.background = (idx === selectedSuggestion) ? '#f3f4f6' : '';
 });
 }

 // Hide autocomplete when clicking outside
 document.addEventListener('click', (e) => {
 if(autocompleteVisible && !autocompleteDiv.contains(e.target) && e.target !== els.fx && e.target !== els.direct){
 hideAutocomplete();
 }
 });

 function updateStatus(t){ document.getElementById('statusChip').textContent=t; }

 // Lightweight A1 highlighter for fx bar: case-insensitive, bounds-validated against current array
 function highlightFxRefs(text){
 const fx = document.getElementById('fx');
 const hl = document.getElementById('fxHighlight');
 if(!fx || !hl) return;
 const s=Store.getState().selection; if(!s?.arrayId||!s.focus) { hl.innerHTML=''; return; }
 const arr=Store.getState().arrays[s.arrayId]; if(!arr){ hl.innerHTML=''; return; }
 const W=arr.size.x, H=arr.size.y, D=arr.size.z;
 const esc=(s)=> s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
 const tokens=[]; const re=/([A-Za-z]+\d+(?:[\u03b1-\u03c9])?\^?-?\d*)/g; let last=0, m;
 while((m=re.exec(text))){
 const raw=m[0]; const start=m.index; const end=start+raw.length; const before=esc(text.slice(last,start));
 tokens.push(before);
 // validate as cell address (case-insensitive letters+digits, optional greek)
 const mm=/^([A-Za-z]+)(\d+)([\u03b1-\u03c9])?/.exec(raw);
 let good=false;
 if(mm){
 // convert letters to X
 let xx=0; const letters=mm[1].toUpperCase(); for(let i=0;i<letters.length;i++) xx = xx*26 + (letters.charCodeAt(i)-64); xx--;
 const yy=(+mm[2])-1; const G='a ?de?????? ???p?st?f???'; const zz=mm[3]? G.indexOf(mm[3]) : s.focus.z;
 good = (xx>=0&&xx<W && yy>=0&&yy<H && zz>=0&&zz<D);
 }
 const cls = good? 'ref-ok' : 'ref-bad';
 tokens.push(`<span class="${cls}">${esc(raw)}</span>`);
 last=end;
 }
 tokens.push(esc(text.slice(last)));
 hl.innerHTML = tokens.join('');
 }

 function startDirectTyping(char){
 const s=Store.getState().selection; if(!s.focus) return;
 const edit=els.direct;
 // If editor is already open, insert at caret instead of resetting
 if(edit.style.display==='block'){
 const start=edit.selectionStart ?? edit.value.length;
 const end=edit.selectionEnd ?? start;
 const before=edit.value.slice(0,start);
 const after=edit.value.slice(end);
 edit.value = before + char + after;
 const pos = before.length + char.length;
 edit.setSelectionRange(pos,pos);
 els.fx.value = edit.value; // realtime sync
 edit.focus();
 return;
 }
 // Otherwise, open with initial char
 openEditor(char);
 }

 function startIntroExperience(){
 console.log('UI.startIntroExperience: begin');
 // Make absolutely sure the overlay fades via CSS
 const io=document.getElementById('introOverlay');
 if(io){ io.classList.add('hidden'); }
 // Force class-based collapse and also apply inline fallback for stubborn cases
 // Brief expansion to pass-through layer then collapse to corner to reveal 3D
 try{
 const sheet=document.getElementById('sheet');
 // Animate the header card wipe behind, then collapse without sheet bounce
 const header=document.getElementById('sheetHeaderCard');
 if(header){
 const r=sheet.getBoundingClientRect();
 header.style.left = r.left + 'px';
 header.style.top = (r.top - 10) + 'px';
 header.style.width = r.width + 'px';
 header.style.height = (r.height + 20) + 'px';
 header.classList.add('visible');
 requestAnimationFrame(()=>{ header.classList.add('wipe'); });
 setTimeout(()=>{ triggerIntroCollapse(); }, 280);
 setTimeout(()=>{ header.classList.remove('wipe'); header.classList.remove('visible'); }, 700);
 } else {
 // Fallback
 setTimeout(()=>{ triggerIntroCollapse(); }, 200);
 }
 }catch{}
 if(false){
 const sheet=document.getElementById('sheet');
 if(sheet){
 sheet.classList.remove('intro-max');
 sheet.classList.remove('intro-centered');
 sheet.style.top='';
 sheet.style.left='16px';
 sheet.style.bottom='16px';
 sheet.style.transform='';
 console.log('UI.startIntroExperience: inline collapse applied');
 }
 }
 // Hard fallback: after transition ensure overlay is non-interactive
 setTimeout(()=>{
 const io2=document.getElementById('introOverlay');
 if(io2){ io2.style.pointerEvents='none'; io2.style.opacity='0'; io2.style.display='none'; }
 }, 900);
 showToast('Welcome to celli.os!');
 }

 function ensureIntroNote(){
 try{
 const arr = Store.getState().arrays[1]; if(!arr) return;
 const coord = {x:0,y:2,z:0};
 // Ensure chunk exists
 const chKey0 = keyChunk(...Object.values(chunkOf(coord.x,coord.y,coord.z)));
 let ch0 = arr.chunks[chKey0];
 if(!ch0){ Actions.resizeArrayIfNeeded(arr, coord); ch0 = arr.chunks[chKey0]; }
 let cell = ch0?.cells?.find?.(c=>c.x===coord.x&&c.y===coord.y&&c.z===coord.z);
 if(!cell){
 console.log('Intro NOTE not found; creating cell ');
 Actions.setCell(arr.id, coord, '', null, true);
 const ch1 = arr.chunks[chKey0];
 cell = ch1?.cells?.find?.(c=>c.x===coord.x&&c.y===coord.y&&c.z===coord.z);
 }
 if(!cell){ console.warn('ensureIntroNote: creation failed'); return; }
 // Always set NOTE metadata and on_click to ensure visibility and binding
 const tx = Write.start('intro.note','Ensure A3 NOTE');
 try{
 const meta = normalizeMetaKeys(cell.meta||{});
 const existingAction = getMetaAction(meta, 'on_click');
 meta.noteText = 'Click Me!';
 meta.on_click = existingAction || '=STARTINTROEXPERIENCE()';
 Write.set(tx, arr.id, coord, {
 value: cell.value ?? '',
 formula: cell.formula ?? null,
 meta
 });
 }catch(e){
 // If array 1 is not yet available at write-time, queue for later
 const S=Store.getState();
 const pending=[...(S.pendingMeta||[])];
 pending.push({kind:'note', target:{arrId:1,x:coord.x,y:coord.y,z:coord.z}, meta:{noteText:'Click Me!', on_click:'=STARTINTROEXPERIENCE()'}});
 Store.setState({pendingMeta:pending});
 }
 Write.commit(tx);
 console.log('ensureIntroNote: meta enforced at A3 or queued');
 // Re-render sheet to bind tooltip and on_click reliably
 try{ UI.renderSheet?.(); }catch{}
 }catch(err){ console.warn('ensureIntroNote failed', err); }
 }

 return {init, renderSheet, applyCrystalStyle, renderSheetCell, updateFocusChip, scrollSheetToSelection, openEditor, startDirectTyping, toggleFxPanel, getZLayer, shiftZLayer, syncPresentUI, syncOceanSettings, updateStatus, getCell, triggerIntroCollapse, ensureIntroNote, hideIntroOverlay, debugIntroState, kickIntroSequence, startIntroExperience, inspect:(arr,pos)=>{ try{ const ch=arr.chunks[keyChunk(...Object.values(chunkOf(pos.x,pos.y,pos.z)))]; const c=ch?.cells?.find?.(t=>t.x===pos.x&&t.y===pos.y&&t.z===pos.z) || {value:'',formula:''}; const el=document.getElementById('inspect'); if(el) el.textContent=`Array #${arr.id} \"${arr.name}\"\nCell ${A1(pos.x)}${pos.y+1}${greek(pos.z)} @[${pos.x},${pos.y},${pos.z},${arr.id}]\nValue: ${JSON.stringify(c.value)}\nFormula: ${c.formula||''}`; }catch(e){ /* selection panel might be hidden */ } }};
})();

// CRITICAL: Expose UI globally so window.UI?.renderSheetCell works
window.UI = UI;

/* ===========================
 Immediate Launch (No Boot Delay)
=========================== */
(async ()=>{
 try {
 console.log('Starting immediate initialization...');
 const restoreDebug = readPersistedPhysicsDebug();

 // Load state if present; otherwise fresh init
 try {
 const has = localStorage.getItem('celliOsState');
 if (has) {
 await Scene.init(document.getElementById('view'));
 if(restoreDebug){ try{ Scene.setPhysicsDebugAll?.(true); }catch(e){ console.warn('Restore physics debug (pre-load) failed', e); } }
 await Store.getState().actions.loadState();
 if(restoreDebug){ try{ Scene.setPhysicsDebugAll?.(true); }catch(e){ console.warn('Restore physics debug (post-load) failed', e); } }
 try{ UI.init?.(); UI.renderSheet?.(); }catch{}
 } else {
 await Store.getState().actions.init();
 if(restoreDebug){ try{ Scene.setPhysicsDebugAll?.(true); }catch(e){ console.warn('Restore physics debug (fresh init) failed', e); } }
 }
 } catch {
 await Store.getState().actions.init();
 if(restoreDebug){ try{ Scene.setPhysicsDebugAll?.(true); }catch(e){ console.warn('Restore physics debug (fallback init) failed', e); } }
 }

 console.log('Initialization complete');
 } catch(e) {
 console.error('Initialization failed:', e);
 }
})();
 </script>
 </body>
 </html>
 </template>
 <!-- Fullhand inline source (self-contained) -->
 <template id="fullhand-srcdoc">
<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="utf-8" />
 <meta name="viewport" content="width=device-width, initial-scale=1" />
 <title>Three.js Integrated Scene Voxel Hand + Keyboard + Character</title>
 <!-- MODE_PLACEHOLDER -->
 <!--
 INTEGRATED SCENE:
 1. cursor.html - Voxel hand creation with 96px high-res capture and progressive build animation
 2. fullhand.html (original) - Retro keyboard with god rays, atmospheric dust, and realistic keys
 3. bust.html - Character bust with ZSphere-based hourglass figure and posing tools
 4. bosscelli.html - Glowing voxel animated head with face cutouts (eyes/smile)
 
 FLOW:
 - Scene starts blank
 - Voxel hand creation sequence (from cursor.html)
 - Once complete, reveals full keyboard scene
 - Character bust positioned beside keyboard at human scale
 - Glowing voxel head above character's upper body
 - Debug menu provides quick navigation between scene elements
 - Edit mode allows posing character with transform gizmos
 -->
 <style>
 html, body { height: 100%; margin: 0; background:#0a0a0a; overflow:hidden; }
 #app { position: fixed; inset: 0; }
 
 /* Debug Menu */
 #debug-menu { 
 position: fixed; top: 20px; right: 20px; 
 background: rgba(20,20,24,0.95); 
 backdrop-filter: blur(10px);
 padding: 16px; 
 border: 1px solid #333; 
 border-radius: 10px; 
 color: #ddd;
 font: 13px/1.4 system-ui, Arial;
 min-width: 200px;
 z-index: 100;
 }
 #debug-menu h3 { margin: 0 0 12px 0; font-size: 15px; color: #fff; }
 #debug-menu button {
 width: 100%;
 padding: 10px;
 margin: 6px 0;
 background: #2a2a2f;
 border: 1px solid #444;
 color: #ddd;
 border-radius: 6px;
 cursor: pointer;
 font-size: 13px;
 transition: all 0.2s;
 }
 #debug-menu button:hover { background: #3a3a44; border-color: #555; }
 #debug-menu button:active { background: #4a4a54; }
 #debug-menu.minimized { display: none; }
 
 /* Minimize button on debug menu */
 #debug-menu-minimize {
 position: absolute;
 top: 10px;
 left: 10px;
 width: 24px;
 height: 24px;
 border-radius: 50%;
 background: #ff4a4a;
 border: 2px solid #ff6a6a;
 cursor: pointer;
 display: flex;
 align-items: center;
 justify-content: center;
 font-size: 14px;
 color: #fff;
 font-weight: bold;
 transition: all 0.2s;
 z-index: 10;
 }
 #debug-menu-minimize:hover {
 background: #ff6a6a;
 transform: scale(1.1);
 }
 
 /* Restore button (appears when minimized) */
 #debug-menu-restore {
 position: fixed;
 top: 20px;
 right: 20px;
 width: 50px;
 height: 50px;
 border-radius: 50%;
 background: rgba(74, 124, 255, 0.9);
 border: 2px solid #6a9cff;
 backdrop-filter: blur(10px);
 cursor: pointer;
 display: none;
 align-items: center;
 justify-content: center;
 font-size: 24px;
 color: #fff;
 transition: all 0.2s;
 z-index: 100;
 box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
 }
 #debug-menu-restore:hover {
 background: rgba(106, 156, 255, 1);
 transform: scale(1.1);
 }
 #debug-menu-restore.visible {
 display: flex;
 }
 
 .gizmo-toolbar { 
 position: fixed; top: 20px; left: 20px; 
 display: none; /* Hidden initially */
 gap: 8px; 
 z-index: 90;
 }
 .gizmo-btn { 
 width: 44px; height: 44px; 
 background: #1e2328; 
 border: 2px solid #3a4149; 
 border-radius: 6px; 
 cursor: pointer; 
 display: flex; 
 align-items: center; 
 justify-content: center; 
 font-size: 20px; 
 transition: all .2s; 
 user-select: none; 
 }
 .gizmo-btn:hover { background: #2a3138; border-color: #5a6169; }
 .gizmo-btn.active { background: #4a7cff; border-color: #6a9cff; }
 
 #loading-overlay {
 position: fixed;
 inset: 0;
 background: #0a0a0a;
 display: flex;
 align-items: center;
 justify-content: center;
 color: #eaeaf2;
 font: 16px/1.4 system-ui;
 z-index: 1000;
 transition: opacity 0.5s;
 }
 #loading-overlay.hidden { opacity: 0; pointer-events: none; }
 
 .status-text { text-align: center; }
 .status-text .spinner {
 width: 40px;
 height: 40px;
 border: 3px solid #333;
 border-top-color: #4a7cff;
 border-radius: 50%;
 animation: spin 1s linear infinite;
 margin: 0 auto 20px;
 }
 @keyframes spin { to { transform: rotate(360deg); } }
 
 /* Modal Windows */
 .modal-window {
 position: fixed;
 background: rgba(20,20,24,0.98);
 backdrop-filter: blur(15px);
 border: 1px solid #444;
 border-radius: 12px;
 color: #ddd;
 font: 13px/1.4 system-ui, Arial;
 box-shadow: 0 10px 40px rgba(0,0,0,0.5);
 z-index: 200;
 display: none;
 }
 .modal-window.active { display: block; }
 .modal-header {
 padding: 16px;
 border-bottom: 1px solid #333;
 display: flex;
 justify-content: space-between;
 align-items: center;
 cursor: move;
 user-select: none;
 }
 .modal-header h3 { margin: 0; font-size: 15px; color: #fff; }
 .modal-close {
 background: #2a2a2f;
 border: 1px solid #444;
 color: #ddd;
 width: 24px;
 height: 24px;
 border-radius: 4px;
 cursor: pointer;
 display: flex;
 align-items: center;
 justify-content: center;
 font-size: 16px;
 line-height: 1;
 }
 .modal-close:hover { background: #3a3a44; }
 .modal-body {
 padding: 16px;
 max-height: 70vh;
 overflow-y: auto;
 }
 .modal-footer {
 padding: 16px;
 border-top: 1px solid #333;
 display: flex;
 gap: 8px;
 justify-content: flex-end;
 }
 .modal-btn {
 padding: 8px 16px;
 background: #2a2a2f;
 border: 1px solid #444;
 color: #ddd;
 border-radius: 6px;
 cursor: pointer;
 font-size: 13px;
 transition: all 0.2s;
 }
 .modal-btn:hover { background: #3a3a44; border-color: #555; }
 .modal-btn.primary { background: #4a7cff; border-color: #6a9cff; }
 .modal-btn.primary:hover { background: #5a8cff; }
 
 .form-group {
 margin-bottom: 16px;
 }
 .form-group label {
 display: block;
 margin-bottom: 6px;
 color: #aaa;
 font-size: 12px;
 }
 .form-group input, .form-group select {
 width: 100%;
 padding: 8px;
 background: #1a1a1f;
 border: 1px solid #444;
 color: #ddd;
 border-radius: 4px;
 font-size: 13px;
 box-sizing: border-box;
 }
 .form-group input:focus, .form-group select:focus {
 outline: none;
 border-color: #4a7cff;
 }
 
 #scene-browser-modal {
 top: 80px;
 left: 20px;
 width: 300px;
 }
 #edit-head-modal {
 top: 50%;
 left: 50%;
 transform: translate(-50%, -50%);
 width: 400px;
 }
 #save-config-modal {
 top: 50%;
 left: 50%;
 transform: translate(-50%, -50%);
 width: 350px;
 }
 #config-report-modal {
 top: 50%;
 left: 50%;
 transform: translate(-50%, -50%);
 width: 500px;
 max-height: 80vh;
 }
 
 .hierarchy-item {
 padding: 8px;
 margin: 4px 0;
 background: #1a1a1f;
 border: 1px solid #333;
 border-radius: 4px;
 cursor: pointer;
 transition: all 0.2s;
 }
 .hierarchy-item:hover {
 background: #2a2a2f;
 border-color: #4a7cff;
 }
 .hierarchy-item.selected {
 background: #4a7cff;
 border-color: #6a9cff;
 }
 
 /* Dialogue System */
 #narrative-dialogue {
 position: fixed;
 bottom: 80px;
 left: 50%;
 transform: translateX(-50%);
 max-width: 600px;
 width: 85%;
 padding: 20px 30px;
 background: rgba(20, 20, 24, 0.92);
 backdrop-filter: blur(15px);
 border: 1px solid rgba(138, 180, 255, 0.3);
 border-radius: 12px;
 color: #e6e6e6;
 font-family: ui-sans-serif, system-ui, sans-serif;
 font-size: 16px;
 line-height: 1.6;
 text-align: center;
 opacity: 0;
 pointer-events: none;
 transition: opacity 0.8s ease, transform 0.8s ease;
 z-index: 200;
 box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), 0 0 80px rgba(138, 180, 255, 0.15);
 }
 
 #narrative-dialogue.active {
 opacity: 1;
 pointer-events: auto;
 transform: translateX(-50%) translateY(0);
 }
 
 #narrative-dialogue .dialogue-text {
 margin: 0;
 font-style: italic;
 }
 
 #narrative-dialogue .dialogue-text strong {
 color: #8ab4ff;
 font-weight: 600;
 }
 </style>
 <script type="importmap">
 {
 "imports": {
 "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
 "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
 "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm"
 }
 }
 </script>
</head>
<body>
 <div id="app"></div>
 
 <div id="loading-overlay">
 <div class="status-text">
 <div class="spinner"></div>
 <div id="status-message">Loading scene...</div>
 </div>
 </div>
 
 <div id="debug-menu">
 <div id="debug-menu-minimize" title="Hide Scene Navigation">-</div>
 <h3>Scene Navigation</h3>
 <button id="btn-keyboard">JUMP TO KEYBOARD</button>
 <button id="btn-character">JUMP TO CHARACTER</button>
 <button id="btn-head">JUMP TO HEAD</button>
 <button id="btn-overview">OVERVIEW</button>
 <hr style="border-color: #333; margin: 12px 0;">
 <h3>Edit Tools</h3>
 <button id="btn-edit-character">EDIT CHARACTER</button>
 <button id="btn-sculpt-character">SCULPT CHARACTER</button>
 <button id="btn-edit-head">EDIT HEAD</button>
 <button id="btn-edit-hands">EDIT HANDS</button>
 <button id="btn-scene-browser">SCENE BROWSER</button>
 <hr style="border-color: #333; margin: 12px 0;">
 <h3>Configuration</h3>
 <button id="btn-save-config">SAVE CONFIG</button>
 <button id="btn-print-config">PRINT CONFIG</button>
 <hr style="border-color: #333; margin: 12px 0;">
 <button id="btn-cursor-sequence">CREATE VOXEL CURSOR</button>
 <div id="hand-config-previews" style="margin-top: 10px; max-width: 200px;"></div>
 <hr style="border-color: #333; margin: 12px 0;">
 <button id="btn-scale-mode">TOGGLE SCALE MODE</button>
 <hr style="border-color: #333; margin: 12px 0;">
 <div id="micro-city-status" style="font-size: 11px; color: #888; padding: 4px;">
 <strong>Micro City LOD:</strong> <span id="micro-city-state">Inactive</span>
 </div>
 <div id="scale-mode-status" style="font-size: 11px; color: #888; padding: 4px; margin-top: 4px;">
 <strong>Scale Mode:</strong> <span id="scale-mode-state">Disabled</span>
 </div>
 </div>
 
 <div id="debug-menu-restore" title="Show Scene Navigation">???</div>
 
 <!-- Narrative Dialogue -->
 <div id="narrative-dialogue">
 <p class="dialogue-text"></p>
 </div>
 
 <input type="file" id="cursor-file-input" accept="image/*" style="display:none;">
 
<div class="gizmo-toolbar" id="gizmo-toolbar" style="display: flex;">
<div class="gizmo-btn active" data-mode="translate" title="Translate (G)">?</div>
<div class="gizmo-btn" data-mode="rotate" title="Rotate (R)">?</div>
<div class="gizmo-btn" data-mode="scale" title="Scale (S)">?</div>
<div style="width: 1px; height: 34px; background: #3a4149; margin: 5px 4px;"></div>
<div class="gizmo-btn" id="snap-toggle" data-snap="free" title="Rotation Snap: Free" style="font-size: 14px; font-weight: 600;">Free</div>
<div class="gizmo-btn" id="drop-btn" title="Drop to Human Scale" style="font-size: 14px; font-weight: 600; background: #4a7cff;">DROP</div>
</div>

<!-- Drop Mode Debug Tracker -->
<div id="drop-debug" style="
position: fixed;
top: 80px;
right: 20px;
background: rgba(0, 0, 0, 0.9);
color: #0f0;
padding: 15px;
font-family: 'Courier New', monospace;
font-size: 11px;
border: 2px solid #0f0;
border-radius: 4px;
z-index: 2000;
display: none;
min-width: 280px;
line-height: 1.6;
box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
">
<div style="color: #ff0; font-weight: bold; margin-bottom: 8px; border-bottom: 1px solid #0f0; padding-bottom: 4px;"> DROP MODE DEBUG</div>
<div id="drop-debug-content"></div>
</div>
 
 <!-- Scene Browser Modal -->
 <div id="scene-browser-modal" class="modal-window">
 <div class="modal-header">
 <h3>Scene Objects</h3>
 <div class="modal-close" onclick="document.getElementById('scene-browser-modal').classList.remove('active')"> </div>
 </div>
 <div class="modal-body" id="scene-browser-content">
 <!-- Populated dynamically -->
 </div>
 </div>
 
 <!-- Edit Head Modal -->
 <div id="edit-head-modal" class="modal-window">
 <div class="modal-header">
 <h3>Edit Head</h3>
 <div class="modal-close" onclick="document.getElementById('edit-head-modal').classList.remove('active')"> </div>
 </div>
 <div class="modal-body">
 <div class="form-group">
 <label>Preset Configuration</label>
<select id="head-preset-select" onchange="loadHeadPreset(this.value)">
<option value="sparse-blue">Sparse Blue (Default)</option>
<option value="intro-celli">Intro Celli (Narrative)</option>
<option value="dense-cyan">Dense Cyan</option>
<option value="warm-glow">Warm Glow</option>
<option value="neon-pink">Neon Pink</option>
<option value="ghost-white">Ghost White</option>
</select>
 </div>
 <hr style="border-color: #333; margin: 12px 0;">
 <h4 style="margin: 8px 0; font-size: 13px; color: #ddd;">Mouth Expression</h4>
 <div class="form-group">
 <label>Smile/Frown Deformation</label>
 <input type="range" id="head-mouth-deform" min="-1" max="1" step="0.01" value="1">
 <span id="head-mouth-deform-val">1.00 (Smile)</span>
 </div>
 <hr style="border-color: #333; margin: 12px 0;">
 <h4 style="margin: 8px 0; font-size: 13px; color: #ddd;">Voxel Geometry</h4>
 <div class="form-group">
 <label>Voxel Layers</label>
 <input type="range" id="head-voxel-layers" min="1" max="5" step="1" value="2">
 <span id="head-voxel-layers-val">2</span>
 </div>
 <div class="form-group">
 <label>Voxel Scale</label>
 <input type="range" id="head-voxel-scale" min="0.5" max="2" step="0.05" value="1">
 <span id="head-voxel-scale-val">1.00</span>
 </div>
 <div class="form-group">
 <label>Voxel Spacing</label>
 <input type="range" id="head-voxel-spacing" min="1.0" max="2.0" step="0.05" value="1.05">
 <span id="head-voxel-spacing-val">1.05</span>
 </div>
 <hr style="border-color: #333; margin: 12px 0;">
 <h4 style="margin: 8px 0; font-size: 13px; color: #ddd;">Animation</h4>
 <div class="form-group">
 <label>Animation Speed</label>
 <input type="range" id="head-anim-speed" min="0" max="3" step="0.01" value="1.15">
 <span id="head-anim-speed-val">1.15</span>
 </div>
 <div class="form-group">
 <label>Amplitude</label>
 <input type="range" id="head-amplitude" min="0" max="0.5" step="0.01" value="0.15">
 <span id="head-amplitude-val">0.15</span>
 </div>
 <div class="form-group">
 <label>Opacity Min</label>
 <input type="range" id="head-opacity-min" min="0" max="1" step="0.01" value="0.3">
 <span id="head-opacity-min-val">0.3</span>
 </div>
 <div class="form-group">
 <label>Opacity Max</label>
 <input type="range" id="head-opacity-max" min="0" max="1" step="0.01" value="0.85">
 <span id="head-opacity-max-val">0.85</span>
 </div>
 <div class="form-group">
 <label>Emissive Intensity</label>
 <input type="range" id="head-emissive" min="0" max="2" step="0.01" value="0.8">
 <span id="head-emissive-val">0.8</span>
 </div>
 <div class="form-group">
 <label>Light Intensity</label>
 <input type="range" id="head-light-int" min="0" max="10" step="0.1" value="2.5">
 <span id="head-light-int-val">2.5</span>
 </div>
 <div class="form-group">
 <label>
 <input type="checkbox" id="head-light-pulse" checked>
 Light Pulse
 </label>
 </div>
 <div class="form-group">
 <label>Rotation Speed</label>
 <input type="range" id="head-rotation-speed" min="0" max="1" step="0.01" value="0.3">
 <span id="head-rotation-speed-val">0.3</span>
 </div>
 <div class="form-group">
 <label>Color</label>
 <input type="color" id="head-color" value="#95bfff">
 </div>
 <hr>
 <h4>Advanced Animation</h4>
 <div class="form-group">
 <label>Phase Noise</label>
 <input type="range" id="head-phase-noise" min="0" max="2" step="0.01" value="0.75">
 <span id="head-phase-noise-val">0.75</span>
 </div>
 <div class="form-group">
 <label>Falloff</label>
 <input type="range" id="head-falloff" min="0" max="2" step="0.01" value="0.85">
 <span id="head-falloff-val">0.85</span>
 </div>
 <div class="form-group">
 <label>Noise Warp</label>
 <input type="range" id="head-noise-warp" min="0" max="0.6" step="0.01" value="0.15">
 <span id="head-noise-warp-val">0.15</span>
 </div>
 <div class="form-group">
 <label>Opacity Speed</label>
 <input type="range" id="head-opacity-speed" min="0" max="3" step="0.01" value="0.8">
 <span id="head-opacity-speed-val">0.8</span>
 </div>
 <h4>Material</h4>
 <div class="form-group">
 <label>Metalness</label>
 <input type="range" id="head-metalness" min="0" max="1" step="0.01" value="0.2">
 <span id="head-metalness-val">0.2</span>
 </div>
 <div class="form-group">
 <label>Roughness</label>
 <input type="range" id="head-roughness" min="0" max="1" step="0.01" value="0.55">
 <span id="head-roughness-val">0.55</span>
 </div>
 </div>
 <div class="modal-footer">
 <button class="modal-btn" onclick="document.getElementById('edit-head-modal').classList.remove('active')">Close</button>
 <button class="modal-btn primary" onclick="applyHeadSettings()">Apply</button>
 </div>
 </div>
 
 <!-- Edit Hands Modal -->
 <div id="edit-hands-modal" class="modal-window" style="top: 50%; left: 50%; transform: translate(-50%, -50%); width: 400px;">
 <div class="modal-header">
 <h3>Edit Hands</h3>
 <div class="modal-close" onclick="document.getElementById('edit-hands-modal').classList.remove('active')"> </div>
 </div>
 <div class="modal-body" id="edit-hands-content">
 <!-- Populated by lil-gui -->
 </div>
 </div>
 
 <!-- Save Configuration Modal -->
 <div id="save-config-modal" class="modal-window">
 <div class="modal-header">
 <h3>Save Configuration</h3>
 <div class="modal-close" onclick="document.getElementById('save-config-modal').classList.remove('active')"> </div>
 </div>
 <div class="modal-body">
 <div class="form-group">
 <label>Configuration Name</label>
 <input type="text" id="config-name-input" placeholder="My Scene Configuration">
 </div>
 <div class="form-group">
 <label>Existing Configurations</label>
 <select id="config-list-select" size="5" style="height: 120px;">
 <!-- Populated from localStorage -->
 </select>
 </div>
 </div>
 <div class="modal-footer">
 <button class="modal-btn" onclick="document.getElementById('save-config-modal').classList.remove('active')">Cancel</button>
 <button class="modal-btn" onclick="saveAsConfiguration()">Save As New</button>
 <button class="modal-btn primary" onclick="saveConfiguration()">Save</button>
 </div>
 </div>
 
 <!-- Configuration Report Modal -->
 <div id="config-report-modal" class="modal-window">
 <div class="modal-header">
 <h3>Configuration Report</h3>
 <div class="modal-close" onclick="document.getElementById('config-report-modal').classList.remove('active')"> </div>
 </div>
 <div class="modal-body">
 <div id="config-report-content" style="font-family: monospace; font-size: 12px; line-height: 1.6;">
 <!-- Populated dynamically -->
 </div>
 </div>
 <div class="modal-footer">
 <button class="modal-btn primary" onclick="document.getElementById('config-report-modal').classList.remove('active')">Close</button>
 </div>
 </div>
 
 <script type="module">
 import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { TransformControls } from 'three/addons/controls/TransformControls.js';
 import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
 import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
 import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
 import { FXAAShader } from 'three/addons/shaders/FXAAShader.js';
 import { BokehPass } from 'three/addons/postprocessing/BokehPass.js';
 import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
 import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
 import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';
 import GUI from 'lil-gui';

 // Note: GPU "Sample Bias" warnings are from Three.js internal shader generation
 // when using high-quality materials (MeshPhysicalMaterial) with certain property combinations.
 // These are clamped automatically by the GPU and don't affect rendering.
 // All bias values in this code are set within the valid range (-16 to 15.99).

 // ===== MODE DETECTION =====
 const EXEC_ENV_MODE = window.EXEC_ENV_MODE || 'sequence';
 console.log(`? Execution Environment Mode: ${EXEC_ENV_MODE}`);

 // Hide debug UI in sequence mode
 if (EXEC_ENV_MODE === 'sequence') {
 const debugMenu = document.getElementById('debug-menu');
 const debugRestore = document.getElementById('debug-menu-restore');
 const gizmoToolbar = document.getElementById('gizmo-toolbar');
 
 if (debugMenu) debugMenu.style.display = 'none';
 if (debugRestore) debugRestore.style.display = 'none';
 if (gizmoToolbar) gizmoToolbar.style.display = 'none';
 
 console.log('? Sequence mode: Debug UI hidden');
 }

 // ===== Cursor Glitch Effect =====
 let cursorGlitchState = 0; // 0: normal, 1: corrupted, 2: emoji
 let cursorGlitchInterval;
 
 function startCursorGlitch() {
 const cursors = [
 'pointer', // Normal
 'url("data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'32\' height=\'32\'%3E%3Cpath d=\'M2,2 L2,28 L12,18 L18,28 L22,26 L16,16 L28,16 Z\' fill=\'%23ff0000\' opacity=\'0.3\'/%3E%3C/svg%3E") 2 2, pointer', // Corrupted red
 'url("data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'32\' height=\'32\'%3E%3Ctext x=\'4\' y=\'24\' font-size=\'24\'%3E?%3C/text%3E%3C/svg%3E") 16 16, pointer' // Hand emoji
 ];
 
 cursorGlitchInterval = setInterval(() => {
 if (Math.random() < 0.15) { // 15% chance to glitch
 const glitchType = Math.floor(Math.random() * 3);
 document.body.style.cursor = cursors[glitchType];
 
 // Quick flash between states
 setTimeout(() => {
 document.body.style.cursor = cursors[(glitchType + 1) % 3];
 }, 50);
 
 setTimeout(() => {
 document.body.style.cursor = cursors[0]; // Back to normal
 }, 150);
 }
 }, 200);
 }
 
 function stopCursorGlitch() {
 if (cursorGlitchInterval) {
 clearInterval(cursorGlitchInterval);
 document.body.style.cursor = 'auto';
 }
 }

 // ===== Scene Setup =====
 const renderer = new THREE.WebGLRenderer({ antialias:true });
 renderer.setSize(innerWidth, innerHeight);
 renderer.setPixelRatio(devicePixelRatio);
 renderer.shadowMap.enabled = true;
 renderer.shadowMap.type = THREE.PCFSoftShadowMap;
 renderer.toneMapping = THREE.ACESFilmicToneMapping;
 renderer.toneMappingExposure = 1.0;
 renderer.physicallyCorrectLights = true;
 renderer.outputColorSpace = THREE.SRGBColorSpace;
 document.getElementById('app').appendChild(renderer.domElement);

 const scene = new THREE.Scene();
 scene.background = new THREE.Color(0x0a0a0a);
 scene.fog = new THREE.FogExp2(0x0a0a0a, 0.03);

 const pmrem = new THREE.PMREMGenerator(renderer);
 const env = pmrem.fromScene(new RoomEnvironment(), 0.04).texture;
 scene.environment = env;

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 100);
camera.position.set(6, 2.5, -8); // Raised Y and pushed back Z to see Celli better

 const controls = new OrbitControls(camera, renderer.domElement);
 controls.target.set(6, 8, 22); // Looking up at Celli's upper body
 controls.enableDamping = true;
 controls.update();

 // Post-processing
 const composer = new EffectComposer(renderer);
 const renderPass = new RenderPass(scene, camera);
 composer.addPass(renderPass);

 const bloomPass = new UnrealBloomPass(
 new THREE.Vector2(innerWidth, innerHeight),
 0.6, 0.6, 0.9
 );
 composer.addPass(bloomPass);

 const fxaaPass = new ShaderPass(FXAAShader);
 fxaaPass.material.uniforms['resolution'].value.set(1 / innerWidth, 1 / innerHeight);
 composer.addPass(fxaaPass);

 // Lighting
 const al = new THREE.AmbientLight(0x1a1a1a, 0.15);
 scene.add(al);
 const hl = new THREE.HemisphereLight(0xddeeff,0x101016,0.2);
 scene.add(hl);
 
 const dl = new THREE.DirectionalLight(0xffffff, 0.9);
 dl.position.set(6,10,4);
 dl.castShadow = true;
 dl.shadow.mapSize.width = 2048;
 dl.shadow.mapSize.height = 2048;
 dl.shadow.camera.left = -10;
 dl.shadow.camera.right = 20;
 dl.shadow.camera.top = 10;
 dl.shadow.camera.bottom = -5;
 dl.shadow.camera.near = 0.5;
 dl.shadow.camera.far = 30;
 dl.shadow.bias = -0.0001; // Within valid range
 scene.add(dl);
 
 const rimLight = new THREE.DirectionalLight(0x4466aa, 0.3);
 rimLight.position.set(-5, 3, -5);
 scene.add(rimLight);

 const spotLight = new THREE.SpotLight(0xffe4c4, 4.0);
 spotLight.position.set(8, 16, 6);
 spotLight.angle = Math.PI / 6.5;
 spotLight.penumbra = 1.0;
 spotLight.decay = 1.0;
 spotLight.distance = 44;
 spotLight.castShadow = true;
 spotLight.shadow.mapSize.width = 2048;
 spotLight.shadow.mapSize.height = 2048;
 spotLight.shadow.bias = -0.0005; // Within valid range
 scene.add(spotLight);
 scene.add(spotLight.target);

 // Ground plane
 const ground = new THREE.Mesh(
 new THREE.PlaneGeometry(50, 50),
 new THREE.MeshStandardMaterial({color:0x0a0a0a, roughness:0.9, metalness:0.1})
 );
 ground.rotation.x = -Math.PI / 2;
 ground.receiveShadow = true;
 scene.add(ground);

 // ===== State Management =====
 let keyboardGroup, characterGroup, voxelHeadGroup;
 let characterBust, characterUnifiedMesh, characterPoseSpheres = [];
 let characterZSpheres = []; // Store ZSphere data for regeneration
 let transformControl;
 let skinMat; // Shared skin material
 let staticFingers = []; // Non-clicking fingers
 let keys = []; // Keyboard keys (for finger interaction)
let rightHandGroup, leftHandGroup, handsGroup; // Hand hierarchy
let celliAvatarGroup; // Combined head + body
let microCityGroups = []; // Micro buildings on keys
let microCityVisible = false;
let cameraSlowdownFactor = 1.0;

// Scale Mode / Frame of Reference
let scaleModeEnabled = false;
let frameOfReference = null; // The 3D frame mesh group
let frameMinimized = false;
let scaleObjects = []; // 3D objects that spawn in Scale mode
let frameDist = 0.9; // Distance in front of camera
let minimizeButton = null; // Diegetic UI circle button

// Drop functionality - Smooth dolly/zoom animation
let lastViewedKey = null; // Track most recently viewed key
let isDropping = false; // Track if drop animation is active
let dropProgress = 0; // 0-1 animation progress
let dropStartTime = 0; // Animation start timestamp
let dropDuration = 3000; // 3 second drop animation (ms)
let dropStartPos = new THREE.Vector3(); // Starting camera position
let dropTargetPos = new THREE.Vector3(); // Target camera position
let dropStartScale = 1.0; // Starting camera scale
let dropTargetScale = 1.0; // Target camera scale (normal, no scaling)
let originalFogDensity = null; // Store original fog density
let dropKeyTarget = null; // Track key we're dropping onto
let dropModeActive = false; // Track if in exploration mode after landing
let dropKeys = { w: false, a: false, s: false, d: false, shift: false, space: false }; // WASD controls
let dropVelocity = 0; // Velocity for gravity-based dropping
let targetDropHeight = null; // Target height when dropping with gravity
 
 // Fingerprint controls
 const FP = { enabled: true, strength: 1.0, scale: 1.0, _applied: '' };
 
 // Finger reference (set by loadFinger)
 let finger = null;
 
 // ===== Dust Particle System =====
 function makeDustTexture(){
 const c=document.createElement('canvas');
 c.width=64; c.height=64;
 const ctx=c.getContext('2d');
 ctx.clearRect(0,0,64,64);
 ctx.globalAlpha = 0.4;
 const centerX = 32, centerY = 32;
 for(let i=0; i<5; i++){
 const offsetX = (Math.random()-0.5)*12;
 const offsetY = (Math.random()-0.5)*12;
 const radius = 8 + Math.random()*8;
 const gradient=ctx.createRadialGradient(
 centerX+offsetX, centerY+offsetY, 0,
 centerX+offsetX, centerY+offsetY, radius
 );
 gradient.addColorStop(0,'rgba(200,200,200,0.6)');
 gradient.addColorStop(0.5,'rgba(180,180,180,0.3)');
 gradient.addColorStop(1,'rgba(160,160,160,0)');
 ctx.fillStyle=gradient;
 ctx.fillRect(0,0,64,64);
 }
 return new THREE.CanvasTexture(c);
 }

 const dustTexture = makeDustTexture();
 let ambientDustParticles = [];
 
 function createDustParticlesForKey(key) {
 const dustParticles = [];
 for (let i = 0; i < 3; i++) {
 const dustGeo = new THREE.PlaneGeometry(0.02, 0.02);
 const dustMat = new THREE.MeshBasicMaterial({
 map: dustTexture,
 transparent: true,
 opacity: 0.3,
 depthWrite: false,
 blending: THREE.AdditiveBlending
 });
 const dust = new THREE.Mesh(dustGeo, dustMat);
 dust.position.set(
 key.position.x + (Math.random() - 0.5) * 0.3,
 key.position.y + 0.35,
 key.position.z + (Math.random() - 0.5) * 0.3
 );
 dust.userData = {
 baseX: dust.position.x,
 baseZ: dust.position.z,
 freq: 0.5 + Math.random() * 1.5,
 phase: Math.random() * Math.PI * 2
 };
 key.add(dust);
 dustParticles.push(dust);
 }
 return dustParticles;
 }
 
 function createAmbientDust() {
 const count = 80;
 for (let i = 0; i < count; i++) {
 const dustGeo = new THREE.PlaneGeometry(0.03, 0.03);
 const dustMat = new THREE.MeshBasicMaterial({
 map: dustTexture,
 transparent: true,
 opacity: 0.15,
 depthWrite: false,
 blending: THREE.AdditiveBlending
 });
 const dust = new THREE.Mesh(dustGeo, dustMat);
 dust.position.set(
 Math.random() * 20 - 2,
 Math.random() * 8 + 2,
 Math.random() * 10 - 2
 );
 dust.userData = {
 velY: -0.003 - Math.random() * 0.005,
 velX: (Math.random() - 0.5) * 0.002,
 velZ: (Math.random() - 0.5) * 0.002,
 freq: 0.3 + Math.random() * 1.0,
 phase: Math.random() * Math.PI * 2,
 swayAmount: 0.5 + Math.random() * 1.5
 };
 scene.add(dust);
 ambientDustParticles.push(dust);
 }
 }
 
 // ===== Key Label Textures =====
 // Create color and bump textures for key labels with engrave effect
 function makeLabelTextures(text){
 if (!text || text === 'Space') return { map:null, bump:null };
 const size=256;
 const base=document.createElement('canvas'); base.width=size; base.height=size;
 const bump=document.createElement('canvas'); bump.width=size; bump.height=size;
 const cctx=base.getContext('2d'); const bctx=bump.getContext('2d');
 // Background color
 cctx.fillStyle='#d7ceb2'; cctx.fillRect(0,0,size,size);
 // Bump base (mid-gray)
 bctx.fillStyle='rgb(200,200,200)'; bctx.fillRect(0,0,size,size);
 // dynamic font size
 let fontSize=120; if(['Shift','Caps','Backspace'].includes(text)) fontSize=80; if(text.length>=3 && fontSize===120) fontSize=100;
 // Draw text on color map
 cctx.fillStyle='#222'; cctx.font=`bold ${fontSize}px sans-serif`; cctx.textAlign='center'; cctx.textBaseline='middle'; cctx.fillText(text,size/2,size/2);
 // Draw darker text to bump to engrave (lower where text appears)
 bctx.fillStyle='rgb(120,120,120)'; bctx.font=`bold ${fontSize}px sans-serif`; bctx.textAlign='center'; bctx.textBaseline='middle'; bctx.fillText(text,size/2,size/2);
 const mapTex=new THREE.CanvasTexture(base); mapTex.colorSpace=THREE.SRGBColorSpace;
 const bumpTex=new THREE.CanvasTexture(bump);
 return { map: mapTex, bump: bumpTex };
 }
 
 // ===== Initialize Scene Elements (hidden initially) =====
 function createKey(width, depth, height, label) {
 const segmentsX = Math.max(16, Math.ceil(width*20));
 const segmentsZ = Math.max(16, Math.ceil(depth*20));
 const geo = new THREE.BoxGeometry(width, height, depth, segmentsX, 8, segmentsZ);
 const pos = geo.attributes.position;
 const v = new THREE.Vector3();
 const hx = width/2, hy = height/2, hz = depth/2;
 
 if (hx <= 0 || hy <= 0 || hz <= 0) {
 return new THREE.Mesh(geo, new THREE.MeshStandardMaterial({color:0xd7ceb2}));
 }
 
 for (let i = 0; i < pos.count; i++) {
 v.fromBufferAttribute(pos, i);
 const ty = (v.y + hy) / (2 * hy);
 const taper = 0.28, concave = 0.06;
 const tilt = 0.12;
 
 if (v.y > 0) {
 const scale = 1 - taper * ty;
 v.x *= scale; 
 v.z *= scale;
 v.y -= tilt * (v.z / hz) * ty;
 
 const divisorX = hx * (1 - taper);
 const divisorZ = hz * (1 - taper);
 if (divisorX > 0.001 && divisorZ > 0.001) {
 const nx = v.x / divisorX;
 const nz = v.z / divisorZ;
 const r2 = Math.min(nx * nx + nz * nz, 1);
 const concaveAmount = Math.min(width, depth) * 0.06;
 v.y -= concaveAmount * (1 - r2) ** 1.5;
 }
 }
 
 pos.setXYZ(i, v.x, v.y, v.z);
 }
 geo.computeVertexNormals();

 const hueShift = (Math.random() - 0.5) * 0.02;
 const lightnessShift = (Math.random() - 0.5) * 0.05;
 const baseColor = new THREE.Color(0xd7ceb2);
 baseColor.offsetHSL(hueShift, 0, lightnessShift);
 const sideColor = new THREE.Color(0xc5b89f);
 sideColor.offsetHSL(hueShift, 0, lightnessShift);

 // Create label textures with engrave effect
 const { map:labelMap, bump:labelBump } = makeLabelTextures(label);
 const topMat = labelMap ? 
 new THREE.MeshStandardMaterial({color:baseColor,roughness:0.6,metalness:0.06,envMapIntensity:1.1,map:labelMap,bumpMap:labelBump,bumpScale:-0.008}) : 
 new THREE.MeshStandardMaterial({color:baseColor,roughness:0.6,metalness:0.06,envMapIntensity:1.1});
 const sideMat = new THREE.MeshStandardMaterial({
 color: sideColor,
 roughness: 0.8,
 metalness: 0.05
 });
 const mats = [sideMat, sideMat, topMat, sideMat, sideMat, sideMat];
 const mesh = new THREE.Mesh(geo, mats);
 mesh.castShadow = true;
 mesh.receiveShadow = true;
 mesh.userData = { baseY: 0, velY: 0, pressed: false, label };

 return mesh;
 }

 function initializeKeyboard() {
 keyboardGroup = new THREE.Group();
 keyboardGroup.visible = false;
 
 const ANSI60 = [
 ['Esc','1','2','3','4','5','6','7','8','9','0','-','=','Backspace'],
 ['Tab','Q','W','E','R','T','Y','U','I','O','P','[',']','\\'],
 ['Caps','A','S','D','F','G','H','J','K','L',';','"','Enter'],
 ['Shift','Z','X','C','V','B','N','M',',','.','/','Shift'],
 ['Ctrl','Win','Alt','Space','Alt','Fn','Menu','Ctrl']
 ];

 const keyWidths = [
 [1,1,1,1,1,1,1,1,1,1,1,1,1,2],
 [1.5,1,1,1,1,1,1,1,1,1,1,1,1,1.5],
 [1.75,1,1,1,1,1,1,1,1,1,1,1,2.25],
 [2.25,1,1,1,1,1,1,1,1,1,1,2.75],
 [1.25,1.25,1.25,6.25,1.25,1.25,1.25,1.25]
 ];

 // Base plate
 const basePlate = new THREE.Mesh(
 new THREE.BoxGeometry(15.5, 0.5, 5.5),
 new THREE.MeshStandardMaterial({color:0xb8a68f, roughness:0.7, metalness:0.05})
 );
 basePlate.position.set(7.5, 0.25, 2.5);
 basePlate.castShadow = true;
 basePlate.receiveShadow = true;
 keyboardGroup.add(basePlate);

 const unit = 1.0, gap = 0.05;
 let zOff = 0;
 keys = []; // Reset global keys array

 for (let r = 0; r < ANSI60.length; r++) {
 const row = ANSI60[r];
 const widths = keyWidths[r];
 let xOff = 0;
 for (let i = 0; i < row.length; i++) {
 const w = widths[i];
 const label = row[i];
 const isSpace = label === 'Space';
 const key = createKey(w * unit - gap, unit - gap * (isSpace ? 0.9 : 1), 0.7, label);
 const keyX = xOff + w * 0.5;
 const keyZ = zOff;
 key.position.set(keyX, 0.9, keyZ);
 key.userData.baseY = 0.9;
 keyboardGroup.add(key);
 
 // Add dust particles to key
 key.userData.dustParticles = createDustParticlesForKey(key);
 
 keys.push(key);
 xOff += w;
 }
 zOff += 1;
 }
 
 scene.add(keyboardGroup);
 
 // Create ambient dust particles
 createAmbientDust();
 
 // Aim spotlight at keyboard center
 const bbox = new THREE.Box3().setFromObject(keyboardGroup);
 const kbCenter = bbox.getCenter(new THREE.Vector3());
 kbCenter.y = bbox.min.y + 0.7;
 spotLight.target.position.copy(kbCenter);
 spotLight.target.updateMatrixWorld();

 // Add volumetric ray billboard
 const rayLength = 22;
 const rayHeight = 10;
 const rayGeo = new THREE.PlaneGeometry(rayLength, rayHeight);
 const rayMat = new THREE.MeshBasicMaterial({
 map: makeRayTexture(),
 transparent: true,
 opacity: 0.28,
 depthWrite: false,
 blending: THREE.AdditiveBlending,
 color: 0xffe9cc
 });
 const rayBillboard = new THREE.Mesh(rayGeo, rayMat);
 rayBillboard.position.copy(spotLight.position);
 rayBillboard.lookAt(spotLight.target.position);
 rayBillboard.rotateY(Math.PI/2);
 rayBillboard.position.y -= 2.5;
 keyboardGroup.add(rayBillboard);
 
 // Create ambient dust particles
 createAmbientDust();
 
 // Create micro cities on keys (after a short delay to ensure keys are ready)
 setTimeout(() => {
 try {
 createMicroCitiesOnKeys();
 } catch (err) {
 console.warn('Micro cities creation failed:', err);
 }
 }, 100);
 
 // Integrate full finger system from kb.html
 loadFinger();
 }
 
 // ===== Micro City LOD System =====
 function createBuildingTexture(floors = 8, variant = 0) {
 console.log(`[MicroCity] Creating building texture: ${floors} floors, variant ${variant}`);
 const canvas = document.createElement('canvas');
 canvas.width = 64;
 canvas.height = 128;
 const ctx = canvas.getContext('2d');
 
 // Building body with color variations
 const colors = [
 ['#d0d4db', '#a8adb5'], // Gray
 ['#c8d4e0', '#a0b0c0'], // Blue-gray
 ['#d8d0c8', '#b0a8a0'], // Tan
 ['#e0d4d0', '#c0b0a8'] // Pink-gray
 ];
 const colorPair = colors[variant % colors.length];
 
 const gradient = ctx.createLinearGradient(0, 0, 0, 128);
 gradient.addColorStop(0, colorPair[0]);
 gradient.addColorStop(1, colorPair[1]);
 ctx.fillStyle = gradient;
 ctx.fillRect(0, 0, 64, 128);
 
 // Windows
 const windowWidth = 8;
 const windowHeight = 10;
 const windowMarginX = 4;
 const windowMarginY = 6;
 const windowsPerRow = 3;
 const windowSpacingX = (64 - windowMarginX * 2 - windowWidth * windowsPerRow) / (windowsPerRow - 1);
 const floorHeight = 128 / floors;
 
 for (let floor = 0; floor < floors; floor++) {
 const floorY = floor * floorHeight + windowMarginY;
 for (let col = 0; col < windowsPerRow; col++) {
 const x = windowMarginX + col * (windowWidth + windowSpacingX);
 const y = floorY;
 
 // Window background (lit or unlit based on variant)
 const litChance = 0.3 + (variant * 0.1);
 const isLit = Math.random() > litChance;
 ctx.fillStyle = isLit ? '#ffe9a0' : '#1a2030';
 ctx.fillRect(x, y, windowWidth, windowHeight);
 
 // Window frame
 ctx.strokeStyle = '#4a5568';
 ctx.lineWidth = 1;
 ctx.strokeRect(x, y, windowWidth, windowHeight);
 
 // Window cross divider
 ctx.beginPath();
 ctx.moveTo(x + windowWidth / 2, y);
 ctx.lineTo(x + windowWidth / 2, y + windowHeight);
 ctx.moveTo(x, y + windowHeight / 2);
 ctx.lineTo(x + windowWidth, y + windowHeight / 2);
 ctx.stroke();
 }
 }
 
 // Roof detail
 ctx.fillStyle = '#8a8f97';
 ctx.fillRect(0, 0, 64, 4);
 
 const texture = new THREE.CanvasTexture(canvas);
 texture.wrapS = THREE.RepeatWrapping;
 texture.wrapT = THREE.ClampToEdgeWrapping;
 return texture;
 }
 
 function createMicroCitiesOnKeys() {
 console.log('[MicroCity] Starting micro city creation...');
 
 if (!keys || keys.length === 0) {
 console.warn('[MicroCity] No keys available for micro cities yet');
 return;
 }
 
 console.log(`[MicroCity] Creating micro cities on ${keys.length} keys...`);
 
 const buildingScale = 0.02; // Increased for better visibility
 const gridSpacing = 0.04;
 
 // Create building geometry variations (reusable)
 const buildingGeometries = [
 new THREE.BoxGeometry(buildingScale * 0.8, buildingScale * 3 * 0.7, buildingScale * 0.8), // Short
 new THREE.BoxGeometry(buildingScale * 0.8, buildingScale * 3 * 1.0, buildingScale * 0.8), // Medium
 new THREE.BoxGeometry(buildingScale * 0.8, buildingScale * 3 * 1.3, buildingScale * 0.8), // Tall
 new THREE.BoxGeometry(buildingScale * 0.8, buildingScale * 3 * 1.6, buildingScale * 0.8) // Very tall
 ];
 console.log(`[MicroCity] Created ${buildingGeometries.length} building geometry variations`);
 
 // Create texture variations with high visibility
 const buildingMaterials = [
 // 6-floor variants - brighter emissive
 new THREE.MeshStandardMaterial({ map: createBuildingTexture(6, 0), roughness: 0.5, metalness: 0.3, emissive: 0xffee99, emissiveIntensity: 0.6, transparent: false }),
 new THREE.MeshStandardMaterial({ map: createBuildingTexture(6, 1), roughness: 0.5, metalness: 0.3, emissive: 0xffee99, emissiveIntensity: 0.6, transparent: false }),
 // 8-floor variants
 new THREE.MeshStandardMaterial({ map: createBuildingTexture(8, 0), roughness: 0.5, metalness: 0.3, emissive: 0xffdd88, emissiveIntensity: 0.65, transparent: false }),
 new THREE.MeshStandardMaterial({ map: createBuildingTexture(8, 1), roughness: 0.5, metalness: 0.3, emissive: 0xffdd88, emissiveIntensity: 0.65, transparent: false }),
 // 10-floor variants
 new THREE.MeshStandardMaterial({ map: createBuildingTexture(10, 2), roughness: 0.5, metalness: 0.3, emissive: 0xffcc77, emissiveIntensity: 0.7, transparent: false }),
 new THREE.MeshStandardMaterial({ map: createBuildingTexture(10, 3), roughness: 0.5, metalness: 0.3, emissive: 0xffcc77, emissiveIntensity: 0.7, transparent: false }),
 // 12-floor variants
 new THREE.MeshStandardMaterial({ map: createBuildingTexture(12, 2), roughness: 0.5, metalness: 0.3, emissive: 0xffbb66, emissiveIntensity: 0.75, transparent: false }),
 new THREE.MeshStandardMaterial({ map: createBuildingTexture(12, 3), roughness: 0.5, metalness: 0.3, emissive: 0xffbb66, emissiveIntensity: 0.75, transparent: false })
 ];
 console.log(`[MicroCity] Created ${buildingMaterials.length} material variations`);
 
 keys.forEach((key, keyIndex) => {
 try {
 console.log(`[MicroCity] Processing key ${keyIndex + 1}/${keys.length}: ${key.userData.label}`);
 
 const cityGroup = new THREE.Group();
 cityGroup.name = `MicroCity_${key.userData.label}`;
 cityGroup.userData.buildingScale = buildingScale; // Store for later reference
 
 // Get key dimensions from bounding box
 const bbox = new THREE.Box3().setFromObject(key);
 const keyWidth = bbox.max.x - bbox.min.x;
 const keyDepth = bbox.max.z - bbox.min.z;
 const keyTop = bbox.max.y;
 
 console.log(`[MicroCity] Key "${key.userData.label}": ${keyWidth.toFixed(3)}x${keyDepth.toFixed(3)}, top at ${keyTop.toFixed(3)}`);
 
 // Create grid of buildings on key surface
 const buildingsX = Math.max(2, Math.floor(keyWidth / gridSpacing));
 const buildingsZ = Math.max(2, Math.floor(keyDepth / gridSpacing));
 
 console.log(`[MicroCity] Grid: ${buildingsX}x${buildingsZ} = ${buildingsX * buildingsZ} buildings`);
 
 const startX = -keyWidth / 2 + gridSpacing;
 const startZ = -keyDepth / 2 + gridSpacing;
 
 // Get key geometry for surface sampling
 const keyGeometry = key.geometry;
 const keyPositions = keyGeometry.getAttribute('position');
 
 // Create instanced meshes for each geometry type
 const instanceData = buildingGeometries.map(() => []);
 
 for (let i = 0; i < buildingsX; i++) {
 for (let j = 0; j < buildingsZ; j++) {
 // Pick random geometry and material
 const geoIdx = Math.floor(Math.random() * buildingGeometries.length);
 const matIdx = Math.floor(Math.random() * buildingMaterials.length);
 
 // Position on key surface with slight randomization
 const x = startX + i * gridSpacing + (Math.random() - 0.5) * gridSpacing * 0.3;
 const z = startZ + j * gridSpacing + (Math.random() - 0.5) * gridSpacing * 0.3;
 
 // Sample key surface height at this position (approximate)
 // Keys have curved tops, so we need to sample the actual geometry
 const nx = x / (keyWidth / 2);
 const nz = z / (keyDepth / 2);
 const r2 = Math.min(nx * nx + nz * nz, 1);
 const concaveDip = Math.min(keyWidth, keyDepth) * 0.06 * (1 - r2) ** 1.5;
 
 const heightVariation = 0.7 + geoIdx * 0.3;
 const buildingHeight = buildingScale * 3 * heightVariation;
 const y = buildingHeight / 2 - concaveDip + 0.001; // Follow key curve
 
 instanceData[geoIdx].push({ x, y, z, matIdx });
 }
 }
 
 // Create instanced meshes for each geometry type
 let totalInstances = 0;
 buildingGeometries.forEach((geometry, geoIdx) => {
 const instances = instanceData[geoIdx];
 if (instances.length === 0) return;
 
 totalInstances += instances.length;
 
 // Group by material
 const byMaterial = {};
 instances.forEach(inst => {
 if (!byMaterial[inst.matIdx]) byMaterial[inst.matIdx] = [];
 byMaterial[inst.matIdx].push(inst);
 });
 
 // Create instanced mesh for each material
 Object.keys(byMaterial).forEach(matIdx => {
 const insts = byMaterial[matIdx];
 const instancedMesh = new THREE.InstancedMesh(
 geometry,
 buildingMaterials[matIdx],
 insts.length
 );
 
 const matrix = new THREE.Matrix4();
 insts.forEach((inst, idx) => {
 matrix.makeTranslation(inst.x, inst.y, inst.z);
 instancedMesh.setMatrixAt(idx, matrix);
 });
 
 instancedMesh.instanceMatrix.needsUpdate = true;
 instancedMesh.castShadow = true;
 instancedMesh.receiveShadow = true;
 
 cityGroup.add(instancedMesh);
 });
 });
 
 console.log(`[MicroCity] Created ${totalInstances} building instances across ${cityGroup.children.length} instanced meshes`);
 
// Position city group relative to key (local position within keyboard group)
cityGroup.position.set(
key.position.x,
key.position.y + (bbox.max.y - bbox.min.y) / 2, // Top of key (no offset)
key.position.z
);
 cityGroup.visible = false; // Hidden by default
 
 console.log(`[MicroCity] City positioned at: (${cityGroup.position.x.toFixed(3)}, ${cityGroup.position.y.toFixed(3)}, ${cityGroup.position.z.toFixed(3)})`);
 
 keyboardGroup.add(cityGroup);
 microCityGroups.push({ key, cityGroup });
 } catch (err) {
 console.error(`[MicroCity] Error creating city for key ${keyIndex}:`, err);
 }
 });
 
 console.log(`[MicroCity] ? Completed! Created cities on ${microCityGroups.length} keys`);
 }
 
 function updateMicroCityLOD() {
 if (!keys || keys.length === 0 || microCityGroups.length === 0) return;
 if (!window.guiParams || !window.guiParams.microCity) return;
 
 const params = window.guiParams.microCity;
 
 // Check if enabled
 if (!params['Enabled']) {
 microCityGroups.forEach(({ cityGroup }) => {
 cityGroup.visible = false;
 });
 cameraSlowdownFactor = 1.0;
 controls.rotateSpeed = 0.3;
 controls.zoomSpeed = 0.5;
 return;
 }
 
 // Use raycasting to find where camera is looking at keys
 const raycaster = new THREE.Raycaster();
 const cameraDirection = new THREE.Vector3();
 camera.getWorldDirection(cameraDirection);
 raycaster.set(camera.position, cameraDirection);
 
 // Raycast against all keys
 const intersects = raycaster.intersectObjects(keys, true);
 
 let closestKey = null;
 let closestCityGroup = null;
 let intersectionPoint = null;
 let closestDist = Infinity;
 
 if (intersects.length > 0) {
 // Find the closest key we're looking at
 const hit = intersects[0];
 intersectionPoint = hit.point.clone();
 
 // Find which key we hit
 let hitKey = hit.object;
 while (hitKey.parent && !keys.includes(hitKey)) {
 hitKey = hitKey.parent;
 }
 
if (keys.includes(hitKey)) {
closestKey = hitKey;
lastViewedKey = hitKey; // Track for drop functionality
closestDist = camera.position.distanceTo(intersectionPoint);

// Find the corresponding city group
for (const { key, cityGroup } of microCityGroups) {
if (key === closestKey) {
closestCityGroup = cityGroup;
 
 // Reposition city to intersection point (convert to keyboardGroup's local space)
 const worldPos = intersectionPoint.clone();
 const localToKeyboard = keyboardGroup.worldToLocal(worldPos);
 
 cityGroup.position.set(
 localToKeyboard.x,
 localToKeyboard.y + 0.01, // Slightly above surface
 localToKeyboard.z
 );
 break;
 }
 }
 }
 }
 
// Fallback: if no intersection, find closest key to camera
if (!closestKey) {
for (const { key, cityGroup } of microCityGroups) {
const keyWorldPos = new THREE.Vector3();
key.getWorldPosition(keyWorldPos);
const dist = camera.position.distanceTo(keyWorldPos);

if (dist < closestDist) {
closestDist = dist;
closestKey = key;
lastViewedKey = key; // Track for drop functionality
closestCityGroup = cityGroup;
}
}
}
 
 // LOD threshold - show micro cities when close
 const lodThreshold = params['LOD Distance'];
 const slowdownThreshold = params['Slowdown Distance'];
 const fadeRange = params['Fade Range'];
 
 if (closestDist < lodThreshold) {
 // Enable micro cities - static placement
 const fadeIn = THREE.MathUtils.clamp((lodThreshold - closestDist) / fadeRange, 0, 1);
 
 microCityGroups.forEach(({ key, cityGroup }) => {
 if (key === closestKey) {
 cityGroup.visible = true;
 cityGroup.scale.setScalar(1.0);
 
 // Ensure buildings are visible by setting material properties
 cityGroup.traverse((child) => {
 if (child.material) {
 child.material.opacity = Math.max(0.8, fadeIn); // Always at least 80% visible
 child.material.transparent = true;
 child.visible = true;
 }
 });
 
 // Debug: Log city info
 if (params['Show City Info'] && Math.random() < 0.02) { // Log occasionally
 const worldPos = new THREE.Vector3();
 cityGroup.getWorldPosition(worldPos);
 console.log(`[MicroCity LOD] Active on key "${closestKey.userData.label}"`);
 console.log(` Distance: ${closestDist.toFixed(3)}, Fade: ${fadeIn.toFixed(2)}`);
 console.log(` City position (local): ${cityGroup.position.x.toFixed(2)}, ${cityGroup.position.y.toFixed(2)}, ${cityGroup.position.z.toFixed(2)}`);
 console.log(` City position (world): ${worldPos.x.toFixed(2)}, ${worldPos.y.toFixed(2)}, ${worldPos.z.toFixed(2)}`);
 console.log(` Intersection: ${intersectionPoint ? `(${intersectionPoint.x.toFixed(2)}, ${intersectionPoint.y.toFixed(2)}, ${intersectionPoint.z.toFixed(2)})` : 'none'}`);
 console.log(` City children: ${cityGroup.children.length} instanced meshes, visible: ${cityGroup.visible}`);
 console.log(` Slowdown threshold: ${slowdownThreshold.toFixed(3)}`);
 
 // Log building info
 if (cityGroup.children.length > 0) {
 const firstMesh = cityGroup.children[0];
 const scale = cityGroup.userData.buildingScale || 0.008;
 console.log(` Building scale: ${scale.toFixed(4)}, instances: ${firstMesh.count}`);
 console.log(` Building material opacity: ${firstMesh.material.opacity.toFixed(2)}`);
 }
 }
 } else {
 cityGroup.visible = false;
 }
 });
 
 microCityVisible = true;
 
 // Camera slowdown effect - only when VERY close (inside slowdown threshold)
 if (closestDist < slowdownThreshold) {
 const slowdownAmount = params['Camera Slowdown'];
 const slowdownFade = THREE.MathUtils.clamp((slowdownThreshold - closestDist) / (slowdownThreshold * 0.5), 0, 1);
 cameraSlowdownFactor = 1.0 - slowdownFade * slowdownAmount;
 controls.rotateSpeed = 0.3 * cameraSlowdownFactor;
 controls.zoomSpeed = 0.5 * cameraSlowdownFactor;
 } else {
 // No slowdown yet, still approaching
 cameraSlowdownFactor = 1.0;
 controls.rotateSpeed = 0.3;
 controls.zoomSpeed = 0.5;
 }
 
 // Update status indicator
 const statusEl = document.getElementById('micro-city-state');
 if (statusEl) {
 const slowInfo = closestDist < slowdownThreshold ? ` [SLOW ${((1-cameraSlowdownFactor)*100).toFixed(0)}%]` : '';
 statusEl.textContent = `Active (${(fadeIn * 100).toFixed(0)}%) - ${closestKey.userData.label}${slowInfo}`;
 statusEl.style.color = closestDist < slowdownThreshold ? '#ff4a7c' : '#4a7cff';
 }
 
 } else {
 // Disable micro cities
 microCityGroups.forEach(({ cityGroup }) => {
 cityGroup.visible = false;
 });
 microCityVisible = false;
 cameraSlowdownFactor = 1.0;
 controls.rotateSpeed = 0.3;
 controls.zoomSpeed = 0.5;
 
 // Update status indicator
 const statusEl = document.getElementById('micro-city-state');
 if (statusEl) {
 statusEl.textContent = `Inactive (dist: ${closestDist.toFixed(2)})`;
 statusEl.style.color = '#888';
 }
 }
 }
 
 // ===== Frame of Reference System =====
 function createFrameOfReference() {
 console.log('[FrameOfRef] Creating frame of reference...');
 if (frameOfReference) {
 scene.remove(frameOfReference);
 }
 
 const grp = new THREE.Group();
 
 // Semi-transparent dark plane
 const planeW = 0.8, planeH = 0.45;
 const planeGeo = new THREE.PlaneGeometry(planeW, planeH);
 const planeMat = new THREE.MeshBasicMaterial({ 
 color: 0x000000, 
 opacity: 0.15, 
 transparent: true,
 depthWrite: false
 });
 const plane = new THREE.Mesh(planeGeo, planeMat);
 grp.add(plane);
 
 // Frame bars (blue metallic)
 const barThickness = 0.025;
 const zOff = 0.0;
 const barMat = new THREE.MeshStandardMaterial({ 
 color: 0xbcd9ff, 
 metalness: 0.1, 
 roughness: 0.6,
 emissive: 0x4a7cff,
 emissiveIntensity: 0.3
 });
 
 const topBar = new THREE.Mesh(
 new THREE.BoxGeometry(planeW, barThickness, barThickness), 
 barMat
 );
 topBar.position.set(0, planeH/2 + barThickness/2, zOff);
 
 const botBar = new THREE.Mesh(
 new THREE.BoxGeometry(planeW, barThickness, barThickness), 
 barMat
 );
 botBar.position.set(0, -planeH/2 - barThickness/2, zOff);
 
 const leftBar = new THREE.Mesh(
 new THREE.BoxGeometry(barThickness, planeH + 2*barThickness, barThickness), 
 barMat
 );
 leftBar.position.set(-planeW/2 - barThickness/2, 0, zOff);
 
 const rightBar = new THREE.Mesh(
 new THREE.BoxGeometry(barThickness, planeH + 2*barThickness, barThickness), 
 barMat
 );
 rightBar.position.set(planeW/2 + barThickness/2, 0, zOff);
 
 [topBar, botBar, leftBar, rightBar].forEach(b => {
 b.castShadow = false;
 b.receiveShadow = false;
 grp.add(b);
 });
 
 // Diegetic UI: Minimize/Maximize circle button at top right
 const circleRadius = 0.04;
 const circleGeo = new THREE.CircleGeometry(circleRadius, 32);
 const circleMat = new THREE.MeshBasicMaterial({ 
 color: 0xffa04a, 
 transparent: true, 
 opacity: 0.9,
 depthWrite: false
 });
 const circle = new THREE.Mesh(circleGeo, circleMat);
 circle.position.set(planeW/2 - circleRadius*1.5, planeH/2 - circleRadius*1.5, 0.01);
 circle.userData.isMinimizeButton = true;
 grp.add(circle);
 
 // Icon for minimize (horizontal line)
 const iconGeo = new THREE.PlaneGeometry(circleRadius * 1.2, circleRadius * 0.2);
 const iconMat = new THREE.MeshBasicMaterial({ 
 color: 0x1a1a1a, 
 transparent: true, 
 opacity: 1.0,
 depthWrite: false
 });
 const icon = new THREE.Mesh(iconGeo, iconMat);
 icon.position.set(planeW/2 - circleRadius*1.5, planeH/2 - circleRadius*1.5, 0.02);
 grp.add(icon);
 
 minimizeButton = { circle, icon, iconGeo };
 
 // === 3D Gizmo Buttons on Frame Border ===
 const buttonSize = 0.044;
 const buttonDepth = 0.012;
 const buttonSpacing = 0.06;
 const buttonY = -planeH/2 - barThickness - buttonSize/2 - 0.01; // Bottom border
 
 const gizmoButtons = [];
 
 // Button configurations: [label, mode, xOffset, color]
 const buttonConfigs = [
 ['?', 'translate', -buttonSpacing * 2.0, 0x4a9cff], // Blue
 ['?', 'rotate', -buttonSpacing * 1.0, 0xff9c4a], // Orange
 ['?', 'scale', buttonSpacing * 0.0, 0x9cff4a], // Green
 ['??', 'sculpt', buttonSpacing * 1.0, 0xffff4a], // Yellow (sculpt mode)
 ['S', 'snap', buttonSpacing * 2.0, 0xff4a9c] // Pink (snap toggle)
 ];
 
 buttonConfigs.forEach(([label, mode, xOffset, color]) => {
 // Button base (slightly raised from frame)
 const buttonGeo = new THREE.BoxGeometry(buttonSize, buttonSize, buttonDepth);
 const buttonMat = new THREE.MeshStandardMaterial({ 
 color: color,
 metalness: 0.3,
 roughness: 0.5,
 emissive: color,
 emissiveIntensity: 0.2
 });
 const button = new THREE.Mesh(buttonGeo, buttonMat);
 button.position.set(xOffset, buttonY, 0.015);
 button.userData.mode = mode;
 button.userData.isGizmoButton = true;
 button.userData.baseZ = 0.015;
 button.userData.pressedZ = 0.005;
 button.userData.isPressed = false;
 button.userData.isActive = (mode === 'translate'); // Translate starts active
 
 // Update material for active state
 if (button.userData.isActive) {
 buttonMat.emissiveIntensity = 0.5;
 }
 
 grp.add(button);
 
 // Label text on button
 const canvas = document.createElement('canvas');
 canvas.width = 64;
 canvas.height = 64;
 const ctx = canvas.getContext('2d');
 ctx.fillStyle = '#ffffff';
 ctx.font = 'bold 48px sans-serif';
 ctx.textAlign = 'center';
 ctx.textBaseline = 'middle';
 ctx.fillText(label, 32, 32);
 
 const labelTexture = new THREE.CanvasTexture(canvas);
 const labelMat = new THREE.MeshBasicMaterial({ 
 map: labelTexture, 
 transparent: true,
 depthWrite: false
 });
 const labelMesh = new THREE.Mesh(
 new THREE.PlaneGeometry(buttonSize * 0.8, buttonSize * 0.8),
 labelMat
 );
 labelMesh.position.set(xOffset, buttonY, 0.015 + buttonDepth/2 + 0.001);
 grp.add(labelMesh);
 
 gizmoButtons.push({ button, label: labelMesh, mode, xOffset });
 });
 
 grp.userData.gizmoButtons = gizmoButtons;
 grp.userData.width = planeW;
 grp.userData.height = planeH;
 grp.visible = false;
 
 frameOfReference = grp;
 scene.add(frameOfReference);
 
 console.log('[FrameOfRef] Frame created successfully with 4 gizmo buttons');
 }
 
 function toggleScaleMode() {
 scaleModeEnabled = !scaleModeEnabled;
 console.log('[FrameOfRef] Scale mode:', scaleModeEnabled ? 'ENABLED' : 'DISABLED');
 
 if (!frameOfReference) {
 createFrameOfReference();
 }
 
 if (scaleModeEnabled) {
 // Show frame
 frameOfReference.visible = true;
 frameMinimized = false;
 
 // Hide 2D gizmo toolbar
 const gizmoToolbar = document.getElementById('gizmo-toolbar');
 if (gizmoToolbar) {
 gizmoToolbar.style.display = 'none';
 }
 
 // Brighten lighting
 al.intensity = 0.35; // Was 0.15
 hl.intensity = 0.5; // Was 0.2
 dl.intensity = 1.5; // Was 0.9
 rimLight.intensity = 0.6; // Was 0.3
 
 // Spawn 3D objects
 createScaleObjects();
 
 console.log('[FrameOfRef] Lighting brightened, objects spawned, 3D gizmos active');
} else {
// Hide frame
frameOfReference.visible = false;

// Restore 2D gizmo toolbar
const gizmoToolbar = document.getElementById('gizmo-toolbar');
if (gizmoToolbar) {
gizmoToolbar.style.display = 'flex';
}

// Restore original lighting
al.intensity = 0.15;
hl.intensity = 0.2;
dl.intensity = 0.9;
rimLight.intensity = 0.3;

// Remove scale objects
scaleObjects.forEach(obj => scene.remove(obj));
scaleObjects = [];

console.log('[FrameOfRef] Lighting restored, objects removed, 2D gizmos restored');
}
 }
 
 function toggleFrameMinimize() {
 if (!frameOfReference) return;
 
 frameMinimized = !frameMinimized;
 
 // Find all children except the minimize button components
 frameOfReference.children.forEach(child => {
 if (child === minimizeButton.circle || child === minimizeButton.icon) {
 return; // Always show button
 }
 child.visible = !frameMinimized;
 });
 
 // Update icon: horizontal line for minimize, plus for maximize
 if (frameMinimized) {
 // Change to plus icon (two rectangles)
 minimizeButton.icon.geometry.dispose();
 const plusGeo1 = new THREE.PlaneGeometry(0.048, 0.008);
 const plusGeo2 = new THREE.PlaneGeometry(0.008, 0.048);
 minimizeButton.icon.geometry = plusGeo1;
 // Add vertical part
 if (!minimizeButton.iconPart2) {
 const iconMat = new THREE.MeshBasicMaterial({ 
 color: 0x1a1a1a, 
 transparent: true, 
 opacity: 1.0,
 depthWrite: false
 });
 minimizeButton.iconPart2 = new THREE.Mesh(plusGeo2, iconMat);
 minimizeButton.iconPart2.position.copy(minimizeButton.icon.position);
 frameOfReference.add(minimizeButton.iconPart2);
 } else {
 minimizeButton.iconPart2.visible = true;
 }
 } else {
 // Change to minus icon (horizontal line)
 minimizeButton.icon.geometry.dispose();
 const circleRadius = 0.04;
 const iconGeo = new THREE.PlaneGeometry(circleRadius * 1.2, circleRadius * 0.2);
 minimizeButton.icon.geometry = iconGeo;
 if (minimizeButton.iconPart2) {
 minimizeButton.iconPart2.visible = false;
 }
 }
 
 console.log('[FrameOfRef] Frame', frameMinimized ? 'minimized' : 'maximized');
 }
 
 function createScaleObjects() {
 // Clean up existing objects
 scaleObjects.forEach(obj => scene.remove(obj));
 scaleObjects = [];
 
 console.log('[FrameOfRef] Creating scale objects...');
 
 // Create various primitive objects around the scene
 const objects = [
 // Cubes of various sizes
 { type: 'box', size: [0.3, 0.3, 0.3], pos: [4, 1.5, 2], color: 0xff7a4a },
 { type: 'box', size: [0.5, 0.5, 0.5], pos: [8, 1.5, 4], color: 0x4a9cff },
 { type: 'box', size: [0.25, 0.6, 0.25], pos: [5, 1.5, 5], color: 0xffd04a },
 
 // Spheres
 { type: 'sphere', radius: 0.2, pos: [7, 1.8, 2], color: 0xff4a9c },
 { type: 'sphere', radius: 0.35, pos: [3, 1.5, 4], color: 0x7a4aff },
 
 // Cylinders
 { type: 'cylinder', size: [0.15, 0.6], pos: [6, 1.5, 6], color: 0x4affb0 },
 { type: 'cylinder', size: [0.2, 0.4], pos: [9, 1.5, 3], color: 0xffb04a },
 ];
 
 objects.forEach(spec => {
 let geo;
 if (spec.type === 'box') {
 geo = new THREE.BoxGeometry(...spec.size);
 } else if (spec.type === 'sphere') {
 geo = new THREE.SphereGeometry(spec.radius, 32, 32);
 } else if (spec.type === 'cylinder') {
 geo = new THREE.CylinderGeometry(spec.size[0], spec.size[0], spec.size[1], 32);
 }
 
 const mat = new THREE.MeshStandardMaterial({ 
 color: spec.color,
 metalness: 0.2,
 roughness: 0.6,
 emissive: spec.color,
 emissiveIntensity: 0.1
 });
 
 const mesh = new THREE.Mesh(geo, mat);
 mesh.position.set(...spec.pos);
 mesh.castShadow = true;
 mesh.receiveShadow = true;
 mesh.userData.isScaleObject = true;
 
 scene.add(mesh);
 scaleObjects.push(mesh);
 });
 
 console.log('[FrameOfRef] Created', scaleObjects.length, 'scale objects');
 }
 
 function updateFrameOfReference() {
 if (!frameOfReference || !frameOfReference.visible) return;
 
 // Position frame in front of camera
 const camPos = new THREE.Vector3();
 camera.getWorldPosition(camPos);
 
 const camDir = new THREE.Vector3();
 camera.getWorldDirection(camDir);
 
 // Place frame at distance in front of camera
 const offset = camDir.clone().multiplyScalar(frameDist);
 frameOfReference.position.copy(camPos).add(offset);
 
 // Orient frame to face camera
 frameOfReference.quaternion.copy(camera.quaternion);
 
 // Scale frame slightly for better visibility
 if (!frameOfReference.userData._resized) {
 const s = 1.2;
 frameOfReference.scale.set(s, s, s);
 frameOfReference.userData._resized = true;
 }
 }
 
 function makeRayTexture(){
 const c=document.createElement('canvas');
 c.width=8; c.height=256;
 const ctx=c.getContext('2d');
 const g=ctx.createLinearGradient(0,0,0,256);
 g.addColorStop(0,'rgba(255,255,255,0)');
 g.addColorStop(0.15,'rgba(255,255,255,0.08)');
 g.addColorStop(0.5,'rgba(255,255,255,0.15)');
 g.addColorStop(0.85,'rgba(255,255,255,0.08)');
 g.addColorStop(1,'rgba(255,255,255,0)');
 ctx.fillStyle=g; ctx.fillRect(0,0,c.width,c.height);
 const t=new THREE.CanvasTexture(c); 
 t.wrapS=t.wrapT=THREE.ClampToEdgeWrapping; 
 t.needsUpdate=true; 
 return t;
 }
 
 // Dust texture and ambient dust creation already defined earlier (line 540-624)
 
 // ===== Full Finger System from kb.html =====
 async function loadFinger(){
 try{
 const STATE={ LEN:0.78, PIP:0.78*0.40, DIP:0.78*(0.40+0.33), NAIL_START:0.67, NAIL_LEN:0.10 };
 const RAD={ BASE:0.065, PROX:0.058, MID:0.052, DIST:0.047, TIP:0.047 };
 const OVAL={ x:1.08, z:0.92 };
 const radialSegs=120, ySegs=220;
 let nailMesh, mcpBone, pipBone, dipBone, tipBone, skeleton;

 const LEN=STATE.LEN, PIP=STATE.PIP, DIP=STATE.DIP, PROX=PIP, MIDL=DIP-PIP, DIST=LEN-DIP;
 const JOINTS={ MCP:0, PIP, DIP, TIP:LEN };

 const lerp=(a,b,t)=>a+(b-a)*t, smooth=t=>t*t*(3-2*t);
 const baseR=y=>{
 if(y<=PIP){const t=y/PROX; return lerp(RAD.BASE,RAD.PROX,smooth(t))*(1.0+0.06*Math.exp(-((t-0.25)**2)/(2*0.18**2)));}
 if(y<=DIP){const t=(y-PIP)/MIDL; return lerp(RAD.PROX,RAD.MID,smooth(t))*(1.0+0.045*Math.exp(-((t-0.35)**2)/(2*0.18**2)));}
 const t=(y-DIP)/DIST; return lerp(RAD.MID,RAD.DIST,smooth(t))*(1.0+0.035*Math.exp(-((t-0.30)**2)/(2*0.18**2)));
 };
 const crease=(y,ang)=>{
 const c1=Math.exp(-((y-PIP)**2)/(2*(0.028*LEN)**2)); const c2=Math.exp(-((y-DIP)**2)/(2*(0.022*LEN)**2)); 
 const pal=0.55+0.45*Math.max(0,-Math.sin(ang)); const dor=1.0+0.05*Math.max(0,Math.sin(ang))*(c1*0.9+c2*0.6); 
 return (1.0-0.06*pal*c1-0.05*pal*c2)*dor;
 };
 const ellR=(ang,r)=>{const rx=r*OVAL.x, rz=r*OVAL.z; return Math.sqrt((rx*rx*rz*rz)/((rz*rz*Math.cos(ang)**2)+(rx*rx*Math.sin(ang)**2)));};
 
 const capSegs=24; const tubeYSegs=ySegs-capSegs; const tubeLen=LEN*0.94; const rBase=baseR(tubeLen);
 const pos=[], uv=[], idx=[]; let vertIdx=0;
 for(let yi=0; yi<=tubeYSegs; yi++){
 const y=(yi/tubeYSegs)*tubeLen, r0=baseR(y);
 for(let ai=0; ai<=radialSegs; ai++){
 const ang=(ai/radialSegs)*Math.PI*2; const r=ellR(ang,r0)*crease(y,ang); 
 pos.push(r*Math.cos(ang),y,r*Math.sin(ang)); 
 const isFingertip=(y>DIP)?1.0:0.0;
 const angNorm=(ang+Math.PI)/(Math.PI*2); 
 const isPalmar=Math.max(0,Math.min(1,1.0-Math.abs(angNorm-0.5)*4)); 
 const fpU=angNorm; 
 const fpV=0.5+isPalmar*isFingertip*((y-DIP)/(LEN-DIP))*0.5; 
 uv.push(fpU,fpV); 
 vertIdx++;
 }
 }
 for(let yi=1; yi<=capSegs; yi++){
 const phi=(yi/capSegs)*(Math.PI*0.5); const yOff=tubeLen+rBase*Math.sin(phi); const rCirc=rBase*Math.cos(phi);
 const blendT=Math.pow(Math.min(yi/6.0,1.0), 0.7);
 for(let ai=0; ai<=radialSegs; ai++){
 const theta=(ai/radialSegs)*Math.PI*2; 
 const tubeR=ellR(theta,baseR(tubeLen))*crease(tubeLen,theta);
 const capR=ellR(theta,rCirc)*crease(tubeLen,theta);
 const rEll=tubeR*(1.0-blendT)+capR*blendT;
 const x=rEll*Math.cos(theta); const z=rEll*Math.sin(theta); 
 pos.push(x,yOff,z); 
 const angNorm=(theta+Math.PI)/(Math.PI*2);
 const isPalmar=Math.max(0,Math.min(1,1.0-Math.abs(angNorm-0.5)*4));
 uv.push(angNorm,0.5+isPalmar*0.5); 
 vertIdx++;
 }
 }
 const totalRings=tubeYSegs+capSegs;
 for(let yi=0; yi<totalRings; yi++) for(let ai=0; ai<radialSegs; ai++){const a=yi*(radialSegs+1)+ai, b=a+1, c=a+(radialSegs+1), d=c+1; idx.push(a,c,b,b,c,d);}
 const tube=new THREE.BufferGeometry(); tube.setAttribute('position',new THREE.Float32BufferAttribute(pos,3)); tube.setAttribute('uv',new THREE.Float32BufferAttribute(uv,2)); tube.setIndex(idx); tube.computeVertexNormals(); tube.normalizeNormals();

 const nailSegW=52, nailSegL=20, nailWidth=4.20, nailThickness=0.004; const nailStartY=STATE.NAIL_START - 0.04, nailEndY=nailStartY+STATE.NAIL_LEN + 0.02; const nPos=[], nUV=[], nIdx=[];
 const nailBaseY=nailStartY; const nailBaseR=baseR(nailBaseY); 
 const getNailSurface=(yParam,u,topSide)=>{
 const vt=(yParam-nailStartY)/(nailEndY-nailStartY); const curveT=vt*vt*(3-2*vt); const fanOut=1.0+curveT*0.24;
 const uu=(u-0.5)*nailWidth*fanOut; const absU=Math.abs(uu); const angNail=uu/nailWidth*1.45; 
 const fingerAngle=angNail;
 const tubeRAtY = baseR(yParam);
 const tubeREll = ellR(fingerAngle, tubeRAtY) * crease(yParam, fingerAngle);
 const lateralWrap = Math.min(1.0, (tubeREll / nailBaseR) * 0.95);
 const edgeRound=(absU>0.60)?Math.min(Math.pow((absU-0.60)*2.2,1.3)*nailThickness*0.6,nailThickness*0.55):0;
 const rAtAngle=ellR(fingerAngle,nailBaseR)*crease(nailBaseY,fingerAngle); 
 const x=rAtAngle*Math.sin(fingerAngle); 
 const fingerZ=rAtAngle*Math.cos(fingerAngle); 
 const tipRound=vt*vt*0.012; 
 const curvatureOffset = rAtAngle * -0.46 - 0.006;
 let z=-fingerZ-(topSide?nailThickness:0)-(lateralWrap)*nailBaseR*0.65+edgeRound-tipRound-curvatureOffset; 
 return {x,y:yParam,z};
 };
 let vOff=0; for(let j=0;j<=nailSegL;j++){ const y=nailStartY+(j/nailSegL)*(nailEndY-nailStartY); for(let i=0;i<=nailSegW;i++){ const p=getNailSurface(y,i/nailSegW,true); nPos.push(p.x,p.y,p.z); nUV.push(i/nailSegW,j/nailSegL); if(j<nailSegL&&i<nailSegW){const a=vOff+j*(nailSegW+1)+i,b=a+1,c=a+(nailSegW+1),d=c+1; nIdx.push(a,c,b,b,c,d);} } }
 vOff=nPos.length/3; for(let j=0;j<=nailSegL;j++){ const y=nailStartY+(j/nailSegL)*(nailEndY-nailStartY); for(let i=0;i<=nailSegW;i++){ const p=getNailSurface(y,i/nailSegW,false); nPos.push(p.x,p.y,p.z); nUV.push(i/nailSegW,j/nailSegL); if(j<nailSegL&&i<nailSegW){const a=vOff+j*(nailSegW+1)+i,b=a+1,c=a+(nailSegW+1),d=c+1; nIdx.push(a,b,c,b,d,c);} } }
 const seal=(v0,ct,loop)=>{ for(let k=0;k<10;k++){ for(let m=0;m<ct-(loop?0:1);m++){ const a=v0+k*ct+m,b=a+1,c=a+ct,d=c+1; if(!loop&&m===ct-1)continue; const bAdj=loop&&m===ct-1?v0+k*ct:b; const dAdj=loop&&m===ct-1?v0+(k+1)*ct:d; nIdx.push(a,c,bAdj,bAdj,c,dAdj); } } };
 let ev0=nPos.length/3; for(let k=0;k<=10;k++){ for(let i=0;i<=nailSegW;i++){ const pT=getNailSurface(nailStartY,i/nailSegW,true); const pB=getNailSurface(nailStartY,i/nailSegW,false); const t=k/10; nPos.push(pT.x*(1-t)+pB.x*t,pT.y*(1-t)+pB.y*t,pT.z*(1-t)+pB.z*t); nUV.push(i/nailSegW,t); } } seal(ev0,nailSegW+1,false);
 ev0=nPos.length/3; for(let k=0;k<=10;k++){ for(let j=0;j<=nailSegL;j++){ const y=nailStartY+(j/nailSegL)*(nailEndY-nailStartY); const pT=getNailSurface(y,0,true); const pB=getNailSurface(y,0,false); const t=k/10; nPos.push(pT.x*(1-t)+pB.x*t,pT.y*(1-t)+pB.y*t,pT.z*(1-t)+pB.z*t); nUV.push(t,j/nailSegL); } } seal(ev0,nailSegL+1,false);
 ev0=nPos.length/3; for(let k=0;k<=10;k++){ for(let j=0;j<=nailSegL;j++){ const y=nailStartY+(j/nailSegL)*(nailEndY-nailStartY); const pT=getNailSurface(y,1,true); const pB=getNailSurface(y,1,false); const t=k/10; nPos.push(pT.x*(1-t)+pB.x*t,pT.y*(1-t)+pB.y*t,pT.z*(1-t)+pB.z*t); nUV.push(t,j/nailSegL); } } seal(ev0,nailSegL+1,false);
 ev0=nPos.length/3; for(let k=0;k<=10;k++){ for(let i=0;i<=nailSegW;i++){ const pT=getNailSurface(nailEndY,i/nailSegW,true); const pB=getNailSurface(nailEndY,i/nailSegW,false); const t=k/10; nPos.push(pT.x*(1-t)+pB.x*t,pT.y*(1-t)+pB.y*t,pT.z*(1-t)+pB.z*t); nUV.push(i/nailSegW,t); } } seal(ev0,nailSegW+1,false);
 const nailGeom=new THREE.BufferGeometry(); nailGeom.setAttribute('position',new THREE.Float32BufferAttribute(nPos,3)); nailGeom.setAttribute('uv',new THREE.Float32BufferAttribute(nUV,2)); nailGeom.setIndex(nIdx); nailGeom.computeVertexNormals();
 const tipLayerPos=[]; const tipLayerUV=[]; const tipLayerIdx=[];
 const extrudeAmt=0.0;
 const tipStart=Math.floor(nailSegL*0.60);
 let tv0=0;
 for(let j=tipStart;j<=nailSegL;j++){
 const tY=nailStartY+(j/nailSegL)*(nailEndY-nailStartY);
 for(let i=0;i<=nailSegW;i++){
 const pt=getNailSurface(tY,i/nailSegW,true);
 tipLayerPos.push(pt.x, pt.y, pt.z - extrudeAmt);
 tipLayerUV.push(i/nailSegW, j/nailSegL);
 if(j< nailSegL && i< nailSegW){ const a=tv0+(j-tipStart)*(nailSegW+1)+i, b=a+1, c=a+(nailSegW+1), d=c+1; tipLayerIdx.push(a,c,b,b,c,d); }
 }
 }
 const nailTipGeom=new THREE.BufferGeometry();
 if(tipLayerPos.length>0){
 nailTipGeom.setAttribute('position', new THREE.Float32BufferAttribute(tipLayerPos,3));
 nailTipGeom.setAttribute('uv', new THREE.Float32BufferAttribute(tipLayerUV,2));
 nailTipGeom.setIndex(tipLayerIdx);
 nailTipGeom.computeVertexNormals();
 }

 const P=tube.getAttribute('position');
 const colors=new Float32Array(P.count*4); 
 for(let i=0;i<P.count;i++){ 
 const y=P.getY(i); const x=P.getX(i); const z=P.getZ(i);
 const palmFactor=Math.max(0,-z)*0.08; 
 const tipWarmth=Math.exp(-((y-LEN*0.96)**2)/(2*(0.08*LEN)**2))*0.22;
 const pipWarmth=Math.exp(-((y-PIP)**2)/(2*(0.04*LEN)**2))*0.14;
 const dipWarmth=Math.exp(-((y-DIP)**2)/(2*(0.035*LEN)**2))*0.12;
 const cuticleWarmth=Math.exp(-((y-STATE.NAIL_START)**2)/(2*(0.02*LEN)**2))*0.18;
 const warmth=tipWarmth+pipWarmth+dipWarmth+cuticleWarmth+palmFactor;
 colors[i*4+0]=Math.min(1.0,0.96+warmth*0.55); 
 colors[i*4+1]=Math.min(1.0,0.80-warmth*0.12); 
 colors[i*4+2]=Math.min(1.0,0.74-warmth*0.24); 
 const isPalmar=Math.max(0,-z); 
 const isTip=(y>DIP)?1.0:0.0; 
 const fingerprintMask=Math.min(1.0,isPalmar*2.0)*Math.max(isTip*0.8,0.3); 
 colors[i*4+3]=fingerprintMask;
 }
 tube.setAttribute('color', new THREE.BufferAttribute(colors,4));

 const wrinkleData=new Float32Array(tube.getAttribute('position').count*3);
 for(let i=0;i<tube.getAttribute('position').count;i++){
 const y=P.getY(i); const x=P.getX(i); const z=P.getZ(i);
 const ang=Math.atan2(z,x); const r=Math.sqrt(x*x+z*z);
 const pipDist=Math.abs(y-PIP); const pipWrinkle=Math.max(0,Math.sin(ang))*Math.exp(-(pipDist**2)/(2*(0.008*LEN)**2))*Math.sin(ang*6)*0.0018;
 const pipWrinkle2=Math.max(0,Math.sin(ang))*Math.exp(-((y-PIP-0.008*LEN)**2)/(2*(0.005*LEN)**2))*Math.sin(ang*8)*0.0012;
 const pipWrinkle3=Math.max(0,Math.sin(ang))*Math.exp(-((y-PIP+0.008*LEN)**2)/(2*(0.005*LEN)**2))*Math.sin(ang*7)*0.0010;
 const dipWrinkle=Math.max(0,Math.sin(ang))*Math.exp(-((y-DIP)**2)/(2*(0.006*LEN)**2))*Math.sin(ang*7)*0.0012;
 const totalWrinkle=pipWrinkle+pipWrinkle2+pipWrinkle3+dipWrinkle;
 const nx=x/r; const nz=z/r;
 wrinkleData[i*3+0]=nx*totalWrinkle;
 wrinkleData[i*3+1]=0;
 wrinkleData[i*3+2]=nz*totalWrinkle;
 }
 tube.userData.wrinkleData=wrinkleData;
 tube.userData.originalPositions=new Float32Array(P.array);

 const skinIndex=new THREE.BufferAttribute(new Float32Array(tube.getAttribute('position').count*4),4);
 const skinWeight=new THREE.BufferAttribute(new Float32Array(tube.getAttribute('position').count*4),4);
 tube.setAttribute('skinIndex',skinIndex); tube.setAttribute('skinWeight',skinWeight);
 const feather=0.04*LEN;
 function setWeights(i, a,b, t){ skinIndex.setXYZW(i,a,b,0,0); skinWeight.setXYZW(i,1-t,t,0,0);} 
 for(let i=0;i<P.count;i++){
 const y=P.getY(i);
 if(y<=PIP){ const t=THREE.MathUtils.smoothstep(y, PIP-feather, PIP+feather); setWeights(i, 0,1, t); }
 else if(y<=DIP){ const edge=PIP; const t=THREE.MathUtils.smoothstep(y, DIP-feather, DIP+feather); setWeights(i, 1,2, t); }
 else { const t=THREE.MathUtils.smoothstep(y, LEN-feather, LEN); setWeights(i, 2,3, t); }
 }

 const nailSkinIndex=new THREE.BufferAttribute(new Float32Array(nailGeom.getAttribute('position').count*4),4);
 const nailSkinWeight=new THREE.BufferAttribute(new Float32Array(nailGeom.getAttribute('position').count*4),4);
 nailGeom.setAttribute('skinIndex',nailSkinIndex); nailGeom.setAttribute('skinWeight',nailSkinWeight);
 const nP=nailGeom.getAttribute('position');
 for(let i=0;i<nP.count;i++){
 const y=nP.getY(i);
 if(y<=PIP){ const t=THREE.MathUtils.smoothstep(y, PIP-feather, PIP+feather); nailSkinIndex.setXYZW(i,0,1,0,0); nailSkinWeight.setXYZW(i,1-t,t,0,0); }
 else if(y<=DIP){ const t=THREE.MathUtils.smoothstep(y, DIP-feather, DIP+feather); nailSkinIndex.setXYZW(i,1,2,0,0); nailSkinWeight.setXYZW(i,1-t,t,0,0); }
 else { const t=THREE.MathUtils.smoothstep(y, LEN-feather, LEN); nailSkinIndex.setXYZW(i,2,3,0,0); nailSkinWeight.setXYZW(i,1-t,t,0,0); }
 }

 if (nailTipGeom && nailTipGeom.getAttribute && nailTipGeom.getAttribute('position')){
 const tipPos = nailTipGeom.getAttribute('position');
 const tipSkinIndex = new THREE.BufferAttribute(new Float32Array(tipPos.count*4), 4);
 const tipSkinWeight = new THREE.BufferAttribute(new Float32Array(tipPos.count*4), 4);
 nailTipGeom.setAttribute('skinIndex', tipSkinIndex);
 nailTipGeom.setAttribute('skinWeight', tipSkinWeight);
 for(let i=0;i<tipPos.count;i++){
 const y = tipPos.getY(i);
 if(y<=PIP){ const t=THREE.MathUtils.smoothstep(y, PIP-feather, PIP+feather); tipSkinIndex.setXYZW(i,0,1,0,0); tipSkinWeight.setXYZW(i,1-t,t,0,0); }
 else if(y<=DIP){ const t=THREE.MathUtils.smoothstep(y, DIP-feather, DIP+feather); tipSkinIndex.setXYZW(i,1,2,0,0); tipSkinWeight.setXYZW(i,1-t,t,0,0); }
 else { const t=THREE.MathUtils.smoothstep(y, LEN-feather, LEN); tipSkinIndex.setXYZW(i,2,3,0,0); tipSkinWeight.setXYZW(i,1-t,t,0,0); }
 }
 }

 const fpCanvas=document.createElement('canvas'); fpCanvas.width=1024; fpCanvas.height=1024; const fpCtx=fpCanvas.getContext('2d');
 fpCtx.fillStyle='#FFFFFF';
 fpCtx.fillRect(0,0,1024,1024);
 const centerX=512, centerY=512;
 for(let r=25; r<380; r+=3.2){
 fpCtx.strokeStyle='#000000';
 fpCtx.lineWidth=2.8+Math.random()*1.2;
 fpCtx.beginPath();
 for(let a=0; a<Math.PI*2; a+=0.03){
 const spiral=r+Math.sin(a*6.5+r*0.09)*7+Math.sin(a*13+r*0.18)*3;
 const wobble=Math.sin(a*28)*1.2+Math.sin(a*19)*1.5;
 const noise=Math.sin(a*45+r*0.3)*0.8;
 const x=centerX+Math.cos(a)*(spiral+wobble+noise);
 const y=centerY+Math.sin(a)*(spiral+wobble+noise)*0.88;
 if(a===0)fpCtx.moveTo(x,y); else fpCtx.lineTo(x,y);
 }
 fpCtx.closePath(); fpCtx.stroke();
 }
 fpCtx.fillStyle='#000000';
 for(let i=0; i<800; i++){
 const angle=Math.random()*Math.PI*2;
 const dist=Math.random()*380;
 const x=centerX+Math.cos(angle)*dist;
 const y=centerY+Math.sin(angle)*dist*0.88;
 fpCtx.beginPath();
 fpCtx.arc(x,y,0.8+Math.random()*0.6,0,Math.PI*2);
 fpCtx.fill();
 }
 const fpTexture=new THREE.CanvasTexture(fpCanvas); 
 fpTexture.wrapS=THREE.RepeatWrapping; 
 fpTexture.wrapT=THREE.ClampToEdgeWrapping;
 fpTexture.repeat.set(2, 1);

 const npCanvas=document.createElement('canvas'); npCanvas.width=1024; npCanvas.height=1024; const npCtx=npCanvas.getContext('2d');
 npCtx.fillStyle='#F4D03F'; 
 npCtx.fillRect(0,0,1024,1024);
 for(let i=0; i<30; i++){
 const chipAngle=Math.random()*Math.PI*2;
 const chipDist=Math.random()*420;
 const chipX=512+Math.cos(chipAngle)*chipDist;
 const chipY=512+Math.sin(chipAngle)*chipDist;
 const chipSize=5+Math.random()*12;
 npCtx.fillStyle='#FFE8DC'; 
 npCtx.beginPath();
 for(let a=0; a<Math.PI*2; a+=Math.PI/4){
 const r=chipSize*(0.7+Math.random()*0.6);
 npCtx.lineTo(chipX+Math.cos(a)*r,chipY+Math.sin(a)*r);
 }
 npCtx.closePath();
 npCtx.fill();
 }
 for(let i=0; i<120; i++){
 const chipX=Math.random()*1024;
 const chipY=Math.random()*100; 
 const chipSize=2+Math.random()*10;
 npCtx.fillStyle='#FFE8DC';
 npCtx.beginPath();
 for(let a=0; a<Math.PI*2; a+=Math.PI/6){
 const r=chipSize*(0.5+Math.random()*0.8);
 npCtx.lineTo(chipX+Math.cos(a)*r,chipY+Math.sin(a)*r);
 }
 npCtx.closePath();
 npCtx.fill();
 }
 for(let i=0; i<200; i++){
 const chipX=Math.random()*1024;
 const chipY=Math.random()*40;
 const chipSize=1+Math.random()*4;
 npCtx.fillStyle='#FFE8DC';
 npCtx.beginPath();
 npCtx.arc(chipX,chipY,chipSize,0,Math.PI*2);
 npCtx.fill();
 }
 for(let i=0; i<80; i++){
 const x=Math.random()*1024;
 const y=Math.random()*1024;
 npCtx.fillStyle=`rgba(255,232,220,${0.2+Math.random()*0.3})`;
 npCtx.fillRect(x,y,1+Math.random()*3,1+Math.random()*4);
 }
 const npTexture=new THREE.CanvasTexture(npCanvas); npTexture.wrapS=npTexture.wrapT=THREE.ClampToEdgeWrapping;

 mcpBone=new THREE.Bone(); mcpBone.position.y=0;
 pipBone=new THREE.Bone(); pipBone.position.y=PROX; mcpBone.add(pipBone);
 dipBone=new THREE.Bone(); dipBone.position.y=MIDL; pipBone.add(dipBone);
 tipBone=new THREE.Bone(); tipBone.position.y=DIST; dipBone.add(tipBone);
 skeleton=new THREE.Skeleton([mcpBone,pipBone,dipBone,tipBone]);

 fpTexture.repeat.set(FP.scale*2, FP.scale);
 const skinMat=new THREE.MeshPhysicalMaterial({color:0xF2C6AC,roughness:0.56,metalness:0,clearcoat:0.06,clearcoatRoughness:0.85,vertexColors:true,side:THREE.DoubleSide,transparent:false,opacity:1.0,depthWrite:true,depthTest:true,alphaToCoverage:false,blending:THREE.NormalBlending,flatShading:false,forceSinglePass:true,displacementMap:FP.enabled?fpTexture:null,displacementScale:0.008*FP.strength,bumpMap:FP.enabled?fpTexture:null,bumpScale:0.10*FP.strength});
 
 function applyFpToMaterial(){
 const key = `${FP.enabled}-${FP.strength.toFixed(3)}-${FP.scale.toFixed(3)}`;
 if (FP._applied === key) return;
 fpTexture.repeat.set(FP.scale*2, FP.scale);
 skinMat.displacementMap = FP.enabled ? fpTexture : null;
 skinMat.bumpMap = FP.enabled ? fpTexture : null;
 skinMat.displacementScale = 0.008 * FP.strength;
 skinMat.bumpScale = 0.10 * FP.strength;
 skinMat.needsUpdate = true;
 FP._applied = key;
 }
 window.applyFpToMaterial = applyFpToMaterial;
 finger=new THREE.SkinnedMesh(tube,skinMat); finger.add(mcpBone); finger.bind(skeleton); finger.castShadow=false; finger.receiveShadow=false; finger.frustumCulled=false; finger.renderOrder=0; 
 const nailMat=new THREE.MeshPhysicalMaterial({map:npTexture,roughness:0.15,metalness:0.05,clearcoat:0.85,clearcoatRoughness:0.08,transparent:false,opacity:1.0,side:THREE.DoubleSide,depthWrite:true,depthTest:true,polygonOffset:true,polygonOffsetFactor:-1,polygonOffsetUnits:-1});
 nailMesh=new THREE.SkinnedMesh(nailGeom,nailMat); nailMesh.add(skeleton.bones[0].clone()); nailMesh.bind(skeleton); finger.add(nailMesh);
 if (nailTipGeom.getAttribute('position')){
 const nailTipMat=new THREE.MeshPhysicalMaterial({color:0xffffff,transparent:true,opacity:0.35,roughness:0.2,metalness:0.0,clearcoat:0.9,clearcoatRoughness:0.06,side:THREE.DoubleSide,depthWrite:false});
 const nailTip=new THREE.SkinnedMesh(nailTipGeom,nailTipMat);
 nailTip.add(skeleton.bones[0].clone()); nailTip.bind(skeleton); finger.add(nailTip);
 }
 
 const keyWidth = 0.8;
 const fingerWidth = RAD.BASE * 2;
 const scale = keyWidth / fingerWidth * 1.4;
 finger.scale.set(scale, scale, scale);
 finger.rotation.set(-Math.PI / 2 + 0.8, Math.PI, 0);
 finger.position.set(0, 0, 0); // Position relative to group
 
 // Create voxel wrap for finger
 // Global voxel wrap parameters
 window.voxelWrapStyle = 'Emerging'; // 'Emerging' or 'Voxelized'
 window.voxelWrapParams = {
 voxelSize: 0.012,
 sampleDensity: 12,
 emergingScale: 0.65,
 voxelizedScale: 1.1,
 rotationAmount: 0.1
 };
 
 const voxelSize = window.voxelWrapParams.voxelSize;
 const voxelGeometry = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);
 
 function createVoxelWrapForFinger(fingerMesh, bones, sampleDensity = 8) {
 const positions = fingerMesh.geometry.getAttribute('position');
 const skinIndices = fingerMesh.geometry.getAttribute('skinIndex');
 const skinWeights = fingerMesh.geometry.getAttribute('skinWeight');
 
 const voxelPositions = [];
 const voxelData = []; // Store bone info for each voxel
 
 // Sample the finger geometry
 for (let i = 0; i < positions.count; i += sampleDensity) {
 const localPos = new THREE.Vector3(
 positions.getX(i),
 positions.getY(i),
 positions.getZ(i)
 );
 
 // Get bone influences
 const boneIndices = [
 skinIndices.getX(i),
 skinIndices.getY(i),
 skinIndices.getZ(i),
 skinIndices.getW(i)
 ];
 const boneWeights = [
 skinWeights.getX(i),
 skinWeights.getY(i),
 skinWeights.getZ(i),
 skinWeights.getW(i)
 ];
 
 voxelPositions.push(localPos);
 voxelData.push({ indices: boneIndices, weights: boneWeights });
 }
 
 // Create geometry using current voxel size parameter
 const currentVoxelSize = window.voxelWrapParams ? window.voxelWrapParams.voxelSize : 0.012;
 const currentVoxelGeometry = new THREE.BoxGeometry(currentVoxelSize, currentVoxelSize, currentVoxelSize);
 
 // Create instanced mesh with deconstructed look
 const instancedMesh = new THREE.InstancedMesh(
 currentVoxelGeometry,
 new THREE.MeshStandardMaterial({ 
 color: 0xFF6B9D,
 roughness: 0.6,
 metalness: 0.2,
 flatShading: true,
 emissive: 0xFF1493,
 emissiveIntensity: 0.2,
 transparent: true,
 opacity: 0.85
 }),
 voxelPositions.length
 );
 
 instancedMesh.castShadow = true;
 instancedMesh.receiveShadow = true;
 instancedMesh.visible = false; // Hidden by default
 instancedMesh.name = "VoxelWrap";
 
 // Store voxel data for updates
 instancedMesh.userData.voxelData = voxelData;
 instancedMesh.userData.voxelPositions = voxelPositions;
 instancedMesh.userData.bones = bones;
 instancedMesh.userData.fingerMesh = fingerMesh;
 
 // Ensure voxel mesh has identity transform in local space
 // It will inherit parent finger's scale, rotation, and position
 instancedMesh.position.set(0, 0, 0);
 instancedMesh.rotation.set(0, 0, 0);
 instancedMesh.scale.set(1, 1, 1);
 
 console.log(`[VoxelWrap] Created ${voxelPositions.length} voxels for finger (will inherit parent transforms)`);
 
 return instancedMesh;
 }
 
 const voxelWrapMesh = createVoxelWrapForFinger(finger, skeleton.bones, 12);
 finger.add(voxelWrapMesh);
 finger.userData.voxelWrap = voxelWrapMesh;
 
 console.log(`[VoxelWrap] Main finger voxel wrap added as child (inherits scale: ${finger.scale.x.toFixed(3)}, rotation: ${finger.rotation.x.toFixed(3)})`);
 
 // Update voxel positions based on bone transforms
 function updateVoxelWrap(voxelMesh) {
 if (!voxelMesh || !voxelMesh.visible) return;
 
 const voxelData = voxelMesh.userData.voxelData;
 const voxelPositions = voxelMesh.userData.voxelPositions;
 const bones = voxelMesh.userData.bones;
 const fingerMesh = voxelMesh.userData.fingerMesh;
 
 if (!fingerMesh || !fingerMesh.skeleton) return;
 
 const matrix = new THREE.Matrix4();
 const skinMatrix = new THREE.Matrix4();
 const pos = new THREE.Vector3();
 const tmpVec = new THREE.Vector3();
 
 // Update bone matrices
 fingerMesh.skeleton.update();
 
 for (let i = 0; i < voxelPositions.length; i++) {
 const localPos = voxelPositions[i].clone();
 const data = voxelData[i];
 
 // Initialize accumulation
 pos.set(0, 0, 0);
 let totalWeight = 0;
 
 // Blend bone transforms by weight (standard skinning)
 for (let j = 0; j < 4; j++) {
 const boneIndex = data.indices[j];
 const weight = data.weights[j];
 
 if (weight > 0 && boneIndex < bones.length && bones[boneIndex]) {
 const bone = bones[boneIndex];
 
 // Compute skinning matrix: boneMatrix * inverseBindMatrix
 skinMatrix.multiplyMatrices(
 bone.matrixWorld,
 fingerMesh.skeleton.boneInverses[boneIndex]
 );
 
 // Transform the local position by skinning matrix
 tmpVec.copy(localPos);
 tmpVec.applyMatrix4(skinMatrix);
 
 // Accumulate weighted position
 pos.add(tmpVec.multiplyScalar(weight));
 totalWeight += weight;
 }
 }
 
 // Normalize if weights don't sum to 1
 if (totalWeight > 0 && Math.abs(totalWeight - 1.0) > 0.001) {
 pos.divideScalar(totalWeight);
 }
 
 // Convert from world space back to finger's local space
 // (since voxelMesh is a child of finger and inherits its transforms)
 tmpVec.copy(pos);
 fingerMesh.worldToLocal(tmpVec);
 
 // Apply style-specific transforms
 const style = window.voxelWrapStyle || 'Emerging';
 const params = window.voxelWrapParams || { emergingScale: 0.65, voxelizedScale: 1.1, rotationAmount: 0.1 };
 
 let voxelScale, shouldRotate;
 
 if (style === 'Emerging') {
 voxelScale = params.emergingScale; // Smaller, more scattered
 shouldRotate = true;
 } else { // 'Voxelized' - solid array, NO rotation
 voxelScale = params.voxelizedScale; // Larger, more solid array look
 shouldRotate = false;
 }
 
 // Create transform matrix for this voxel in local space
 matrix.makeTranslation(tmpVec.x, tmpVec.y, tmpVec.z);
 
 // Add rotation ONLY for Emerging style
 if (shouldRotate && style === 'Emerging') {
 const rotationVariation = (i * 0.123) % (Math.PI * 2);
 const rotMat = new THREE.Matrix4().makeRotationY(rotationVariation * params.rotationAmount);
 matrix.multiply(rotMat);
 }
 
 // Apply scale
 const scaleMat = new THREE.Matrix4().makeScale(voxelScale, voxelScale, voxelScale);
 matrix.multiply(scaleMat);
 
 voxelMesh.setMatrixAt(i, matrix);
 }
 
 voxelMesh.instanceMatrix.needsUpdate = true;
 }
 
 finger.userData.updateVoxelWrap = () => updateVoxelWrap(voxelWrapMesh);
 
 // Expose functions globally for static fingers
 window.createVoxelWrapForFinger = createVoxelWrapForFinger;
 window.updateVoxelWrap = updateVoxelWrap;
 
 // Create hand groups
 handsGroup = new THREE.Group();
 handsGroup.name = "Hands";
 rightHandGroup = new THREE.Group();
 rightHandGroup.name = "Right Hand";
 rightHandGroup.position.set(9.0, 4.5, -0.8); // Right hand base position
 rightHandGroup.add(finger);
 handsGroup.add(rightHandGroup);
 scene.add(handsGroup);

 const fingerBaseY = rightHandGroup.position.y;
 const fingerBaseZ = rightHandGroup.position.z;

 let hoveredKey = null;
 let targetKeyX = rightHandGroup.position.x;
 let targetKeyZ = 1.6;
 let pressedKey = null;
 let pressingFinger = false;
 let fingerPressStart = 0;
 const fingerSmoothSpeed = 0.08;
 const fingerPressDuration = 80;
 const fingerReleaseDuration = 150;

 function getKeyTopWorldY(key){
 if(!key) return null;
 const box = new THREE.Box3().setFromObject(key);
 return box.max.y;
 }

 function getFrontRowRestKey(){
 let best=null; let bestZ=-Infinity;
 for(const k of keys){
 const lbl=k.userData?.label;
 if(lbl==='Space') continue;
 if(k.position.z>bestZ){ best=k; bestZ=k.position.z; }
 }
 return best;
 }

 function computeKeyboardZSign(){
 let minZ=Infinity, maxZ=-Infinity;
 for(const k of keys){
 const z=k.position.z; if(z<minZ) minZ=z; if(z>maxZ) maxZ=z;
 }
 if(!isFinite(minZ)||!isFinite(maxZ)||Math.abs(maxZ-minZ)<1e-3) return 1;
 return (maxZ>minZ)? 1 : -1;
 }
 const keyboardZSign = computeKeyboardZSign();

 const fingerRaycaster = new THREE.Raycaster();
 const fingerMouse = new THREE.Vector2();
 let targetKeyTopY = null;
 const hoverGap = 0.05;
 renderer.domElement.addEventListener('pointermove', (e) => {
 const rect = renderer.domElement.getBoundingClientRect();
 fingerMouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
 fingerMouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
 fingerRaycaster.setFromCamera(fingerMouse, camera);
 const hits = fingerRaycaster.intersectObjects(keys, false);
 if (hits.length > 0) {
 hoveredKey = hits[0].object;
 targetKeyX = hoveredKey.position.x;
 targetKeyZ = hoveredKey.position.z;
 const topY = getKeyTopWorldY(hoveredKey);
 targetKeyTopY = (topY!=null? topY : finger.position.y) + hoverGap;
 } else {
 const restKey = getFrontRowRestKey();
 hoveredKey = null;
 if(restKey){
 targetKeyX = restKey.position.x;
 targetKeyZ = restKey.position.z;
 const topY = getKeyTopWorldY(restKey);
 targetKeyTopY = (topY!=null? topY : finger.position.y) + hoverGap;
 }else{
 targetKeyTopY = null;
 }
 }
 });
 renderer.domElement.addEventListener('pointerleave', ()=>{
 hoveredKey = null;
 targetKeyTopY = null;
 });
 renderer.domElement.addEventListener('mouseleave', ()=>{
 hoveredKey = null;
 targetKeyTopY = null;
 });

 renderer.domElement.addEventListener('pointerdown', (e) => {
 if (hoveredKey) {
 pressingFinger = true;
 pressedKey = hoveredKey;
 fingerPressStart = Date.now();
 
 // Animate key depression
 if (!hoveredKey.userData.pressed) {
 hoveredKey.userData.pressed = true;
 hoveredKey.userData.velY = -0.03;
 }
 }
 });

 const params = { Animate: true, Speed: 1.0, Amp: 1.0, MCP_Flex: 20, MCP_Splay: 0, PIP_Flex: 45, DIP_Flex: 30 };

 function getFingerTipWorldPos() {
 const tipWorldPos = new THREE.Vector3();
 tipBone.updateWorldMatrix(true, false);
 tipBone.getWorldPosition(tipWorldPos);
 return tipWorldPos;
 }

 function getMcpWorldPos(){
 const p = new THREE.Vector3();
 mcpBone.updateWorldMatrix(true, false);
 mcpBone.getWorldPosition(p);
 return p;
 }

 let t0 = performance.now();
 function animFinger() {
 const t = (performance.now() - t0) / 1000;
 
 const tipWorld = getFingerTipWorldPos();
 
 const targetTipX = targetKeyX;
 const targetTipZ = targetKeyZ;
 
 const currentTipX = tipWorld.x;
 const currentTipZ = tipWorld.z;
 const currentTipY = tipWorld.y;
 
 if (targetKeyTopY!=null) {
 const padBias = 0.0;
 const desiredTip = new THREE.Vector3(targetTipX, targetKeyTopY - padBias, targetTipZ - keyboardZSign * 0.10);
 const rootToTip = new THREE.Vector3().copy(tipWorld).sub(rightHandGroup.position);
 const followPos = new THREE.Vector3().copy(desiredTip).sub(rootToTip);
 rightHandGroup.position.lerp(followPos, 0.28);
 const baseBehind = THREE.MathUtils.lerp(0.70, 1.40, Math.min(1, Math.abs(targetTipZ) / 3.5));
 const targetBaseZConst = desiredTip.z - keyboardZSign * baseBehind;
 rightHandGroup.position.z = THREE.MathUtils.lerp(rightHandGroup.position.z, targetBaseZConst, 0.35);
 } else {
 const deltaX = (targetTipX - currentTipX) * fingerSmoothSpeed;
 const deltaZ = (targetTipZ - currentTipZ) * fingerSmoothSpeed;
 const deltaY = (targetKeyTopY!=null ? (targetKeyTopY - currentTipY) * fingerSmoothSpeed : 0);
 rightHandGroup.position.x += deltaX;
 rightHandGroup.position.z += deltaZ;
 rightHandGroup.position.y += deltaY;
 }

 if (hoveredKey && targetKeyTopY!=null){
 const fingerBounds = new THREE.Box3().setFromObject(finger);
 const bottomY = fingerBounds.min.y;
 const desiredY = targetKeyTopY;
 const alignDy = THREE.MathUtils.clamp(desiredY - bottomY, -0.25, 0.25);
 rightHandGroup.position.y += alignDy * 0.6;
 }

 if (targetKeyTopY!=null){
 const mcpW = getMcpWorldPos();
 const minMcpY = targetKeyTopY + 0.35;
 if (mcpW.y < minMcpY){
 rightHandGroup.position.y += (minMcpY - mcpW.y);
 }
 }

 const minKeyZ = 0.0;
 const maxKeyZ = 3.5;
 const reachFactor = THREE.MathUtils.clamp((targetKeyZ - minKeyZ) / (maxKeyZ - minKeyZ), 0, 1);
 
 const frontEase = reachFactor;
 const baseCurl = THREE.MathUtils.lerp(34, 20, frontEase);
 const curlRange = THREE.MathUtils.lerp(30, 16, frontEase);
 const extend = hoveredKey ? (1.0 - reachFactor) : 0.0;
 let targetMCPFlex = baseCurl + curlRange * reachFactor - 14 * extend;
 let targetPIPFlex = 52 + 24 * reachFactor - 16 * extend;
 let targetDIPFlex = 38 + 16 * reachFactor - 14 * extend;
 targetMCPFlex = Math.max(0, targetMCPFlex);
 targetPIPFlex = Math.max(0, targetPIPFlex);
 targetDIPFlex = Math.max(0, targetDIPFlex);

 if (staticFingers && staticFingers.length){
 const idle = hoveredKey ? 0 : 1;
 staticFingers.forEach((f, idx)=>{
 // Static fingers follow automatically as children of hand groups
 // Just update their bone rotations
 const curlStep = 10 * (idx+1);
 const boost = 22 + idle * 16 + curlStep;
 const b = f.bones;
 b.mcp.rotation.x = THREE.MathUtils.degToRad(params.MCP_Flex + boost);
 b.pip.rotation.x = THREE.MathUtils.degToRad(params.PIP_Flex + boost*1.15);
 b.dip.rotation.x = THREE.MathUtils.degToRad((params.DIP_Flex + boost) * 0.72);
 b.tip.rotation.x = THREE.MathUtils.degToRad((params.DIP_Flex + boost) * 0.28);
 });
 }

 let pressRotation = 0;
 let tipExtend = -0.22 * extend;
 if (pressingFinger && pressedKey) {
 const elapsed = Date.now() - fingerPressStart;
 const pressDepth = 0.5;
 const tipExtendAmount = -0.3;
 
 if (elapsed < fingerPressDuration) {
 const t = elapsed / fingerPressDuration;
 const eased = t * t * (3 - 2 * t);
 pressRotation = -pressDepth * eased;
 tipExtend = tipExtendAmount * eased;
 } else if (elapsed < fingerPressDuration + fingerReleaseDuration) {
 const t = (elapsed - fingerPressDuration) / fingerReleaseDuration;
 const eased = 1 - (t * t * (3 - 2 * t));
 pressRotation = -pressDepth * eased;
 tipExtend = tipExtendAmount * eased;
 } else {
 pressingFinger = false;
 pressedKey = null;
 pressRotation = 0;
 tipExtend = 0;
 }
 }
 
 if (!hoveredKey){
 const retreat = THREE.MathUtils.lerp(0.0, 0.25, frontEase);
 const targetZ = fingerBaseZ - retreat;
 rightHandGroup.position.z = THREE.MathUtils.lerp(rightHandGroup.position.z, targetZ, 0.12);
 }
 const baseTilt = 0.92;
 finger.rotation.x = -Math.PI / 2 + baseTilt + pressRotation;

 const sp = params.Speed, A = 0.3, anim = params.Animate ? 1 : 0;
 const currentMCPFlex = THREE.MathUtils.lerp(
 THREE.MathUtils.degToRad(params.MCP_Flex),
 THREE.MathUtils.degToRad(targetMCPFlex),
 0.1
 );
 params.MCP_Flex = THREE.MathUtils.lerp(params.MCP_Flex, targetMCPFlex, 0.1);
 params.PIP_Flex = THREE.MathUtils.lerp(params.PIP_Flex, targetPIPFlex, 0.1);
 params.DIP_Flex = THREE.MathUtils.lerp(params.DIP_Flex, targetDIPFlex, 0.1);

 const mcpForwardBias = THREE.MathUtils.degToRad(8.5);
 mcpBone.rotation.x = THREE.MathUtils.degToRad(params.MCP_Flex) + anim * (0.25 * A * Math.sin(t * 0.6 * sp)) + mcpForwardBias;
 mcpBone.rotation.z = THREE.MathUtils.degToRad(params.MCP_Splay) + anim * (0.02 * Math.sin(t * 0.8 * sp));
 const pipForwardBias = THREE.MathUtils.degToRad(14);
 const pipFlex = THREE.MathUtils.degToRad(params.PIP_Flex) + anim * (0.65 * A * Math.sin(t * 0.7 * sp + 1)) + tipExtend * 0.6 + pipForwardBias;
 const dipFlex = THREE.MathUtils.degToRad(params.DIP_Flex) + anim * (0.55 * A * Math.sin(t * 0.9 * sp + 2)) + tipExtend * 0.9;
 pipBone.rotation.x = pipFlex;
 dipBone.rotation.x = dipFlex * 0.72;
 tipBone.rotation.x = dipFlex * 0.28;

 if (finger && finger.geometry.userData.wrinkleData) {
 const wrinkleData = finger.geometry.userData.wrinkleData;
 const origPos = finger.geometry.userData.originalPositions;
 const pos = finger.geometry.getAttribute('position');
 const pipWrinkleAmount = Math.max(0, -pipFlex) * 2.5;
 const dipWrinkleAmount = Math.max(0, -dipFlex) * 2.5;
 for (let i = 0; i < pos.count; i++) {
 const y = origPos[i * 3 + 1];
 let wrinkleIntensity = 0;
 if (Math.abs(y - PIP) < 0.05 * LEN) wrinkleIntensity += pipWrinkleAmount;
 if (Math.abs(y - DIP) < 0.04 * LEN) wrinkleIntensity += dipWrinkleAmount;
 wrinkleIntensity = Math.min(wrinkleIntensity, 1.0);
 pos.setXYZ(i,
 origPos[i * 3 + 0] + wrinkleData[i * 3 + 0] * wrinkleIntensity,
 origPos[i * 3 + 1] + wrinkleData[i * 3 + 1] * wrinkleIntensity,
 origPos[i * 3 + 2] + wrinkleData[i * 3 + 2] * wrinkleIntensity
 );
 }
 pos.needsUpdate = true;
 finger.geometry.computeVertexNormals();
 }

 requestAnimationFrame(animFinger);
 }
 animFinger();
 
 window.__indexFinger = { finger, mcpBone, pipBone, dipBone, tipBone, skeleton, nailMesh, LEN, PIP, DIP, params };
 }catch(e){ console.warn('Full finger rig load failed',e); }
 }
 
 // Add static fingers (3 additional fingers for right hand)
 setTimeout(() => {
 if (!window.__indexFinger) return;
 const ref = window.__indexFinger;
 const fingerConfigs = [
 { x: 1.2, scale: 0.98, curl: 1.05, name: 'middle' },
 { x: 2.4, scale: 0.95, curl: 1.10, name: 'ring' },
 { x: 3.6, scale: 0.90, curl: 1.15, name: 'pinky' }
 ];
 
 fingerConfigs.forEach((config) => {
 const clonedFingerGeo = ref.finger.geometry.clone();
 const clonedFingerMat = ref.finger.material.clone();
 const clonedFinger = new THREE.SkinnedMesh(clonedFingerGeo, clonedFingerMat);
 
 const clonedMcp = new THREE.Bone();
 clonedMcp.position.copy(ref.mcpBone.position);
 const clonedPip = new THREE.Bone();
 clonedPip.position.copy(ref.pipBone.position);
 const clonedDip = new THREE.Bone();
 clonedDip.position.copy(ref.dipBone.position);
 const clonedTip = new THREE.Bone();
 clonedTip.position.copy(ref.tipBone.position);
 
 clonedMcp.add(clonedPip);
 clonedPip.add(clonedDip);
 clonedDip.add(clonedTip);
 
 clonedFinger.add(clonedMcp);
 const clonedSkeleton = new THREE.Skeleton([clonedMcp, clonedPip, clonedDip, clonedTip]);
 clonedFinger.bind(clonedSkeleton);
 
 const curlFactor = config.curl;
 clonedMcp.rotation.x = THREE.MathUtils.degToRad(ref.params.MCP_Flex * curlFactor);
 clonedPip.rotation.x = THREE.MathUtils.degToRad(ref.params.PIP_Flex * curlFactor);
 clonedDip.rotation.x = THREE.MathUtils.degToRad(ref.params.DIP_Flex * curlFactor * 0.72);
 clonedTip.rotation.x = THREE.MathUtils.degToRad(ref.params.DIP_Flex * curlFactor * 0.28);
 
 // Position relative to main finger - start at same base position
 clonedFinger.position.set(config.x, 0, 0); // Offset in local space
 clonedFinger.rotation.copy(ref.finger.rotation);
 const baseScale = ref.finger.scale.x;
 const scaleVal = baseScale * config.scale;
 clonedFinger.scale.set(scaleVal, scaleVal, scaleVal);
 
 clonedFinger.userData.offsetX = config.x;
 clonedFinger.userData.isStatic = true;
 
 if (ref.nailMesh && ref.nailMesh.geometry) {
 const clonedNailGeo = ref.nailMesh.geometry.clone();
 const clonedNailMat = ref.nailMesh.material.clone();
 const clonedNail = new THREE.SkinnedMesh(clonedNailGeo, clonedNailMat);
 
 clonedNail.bind(clonedSkeleton);
 clonedFinger.add(clonedNail);
 
 if (ref.finger.children) {
 const nailTipOriginal = ref.finger.children.find(c => c.material && c.material.transparent && c.material.opacity < 0.5);
 if (nailTipOriginal && nailTipOriginal.geometry) {
 const clonedTipGeo = nailTipOriginal.geometry.clone();
 const clonedTipMat = nailTipOriginal.material.clone();
 const clonedTip = new THREE.SkinnedMesh(clonedTipGeo, clonedTipMat);
 clonedTip.bind(clonedSkeleton);
 clonedFinger.add(clonedTip);
 }
 }
 }
 
 // Create voxel wrap for static finger (reuse function from main finger)
 if (window.createVoxelWrapForFinger) {
 try {
 const staticVoxelWrap = window.createVoxelWrapForFinger(clonedFinger, clonedSkeleton.bones, 12);
 clonedFinger.add(staticVoxelWrap);
 clonedFinger.userData.voxelWrap = staticVoxelWrap;
 clonedFinger.userData.updateVoxelWrap = () => {
 if (window.updateVoxelWrap) {
 window.updateVoxelWrap(staticVoxelWrap);
 }
 };
 console.log(`[VoxelWrap] Created voxel wrap for static finger: ${config.name}`);
 } catch (err) {
 console.warn(`[VoxelWrap] Could not create voxel wrap for ${config.name}:`, err);
 }
 }
 
 rightHandGroup.add(clonedFinger);
 staticFingers.push({ 
 fingerMesh: clonedFinger,
 mesh: clonedFinger, 
 bones: { mcp: clonedMcp, pip: clonedPip, dip: clonedDip, tip: clonedTip },
 baseCurl: curlFactor,
 phase: Math.random() * Math.PI * 2
 });
 });
 }, 100);

 // Add LEFT HAND (4 fingers)
 setTimeout(() => {
 if (!window.__indexFinger) return;
 const ref = window.__indexFinger;
 
 // Create left hand group
 leftHandGroup = new THREE.Group();
 leftHandGroup.name = "Left Hand";
 leftHandGroup.position.set(3.0, 4.5, -0.8); // Left side of keyboard
 handsGroup.add(leftHandGroup);
 
 const leftFingerConfigs = [
 { x: 0.0, scale: 1.0, curl: 1.0, name: 'index-L' }, // Match main pointer finger
 { x: -1.2, scale: 0.98, curl: 1.05, name: 'middle-L' }, // Match right hand middle
 { x: -2.4, scale: 0.95, curl: 1.10, name: 'ring-L' }, // Match right hand ring
 { x: -3.6, scale: 0.90, curl: 1.15, name: 'pinky-L' } // Match right hand pinky
 ];
 
 leftFingerConfigs.forEach((config) => {
 const clonedFingerGeo = ref.finger.geometry.clone();
 const clonedFingerMat = ref.finger.material.clone();
 const clonedFinger = new THREE.SkinnedMesh(clonedFingerGeo, clonedFingerMat);
 
 const clonedMcp = new THREE.Bone();
 clonedMcp.position.copy(ref.mcpBone.position);
 const clonedPip = new THREE.Bone();
 clonedPip.position.copy(ref.pipBone.position);
 const clonedDip = new THREE.Bone();
 clonedDip.position.copy(ref.dipBone.position);
 const clonedTip = new THREE.Bone();
 clonedTip.position.copy(ref.tipBone.position);
 
 clonedMcp.add(clonedPip);
 clonedPip.add(clonedDip);
 clonedDip.add(clonedTip);
 
 clonedFinger.add(clonedMcp);
 const clonedSkeleton = new THREE.Skeleton([clonedMcp, clonedPip, clonedDip, clonedTip]);
 clonedFinger.bind(clonedSkeleton);
 
 const curlFactor = config.curl;
 clonedMcp.rotation.x = THREE.MathUtils.degToRad(ref.params.MCP_Flex * curlFactor);
 clonedPip.rotation.x = THREE.MathUtils.degToRad(ref.params.PIP_Flex * curlFactor);
 clonedDip.rotation.x = THREE.MathUtils.degToRad(ref.params.DIP_Flex * curlFactor * 0.72);
 clonedTip.rotation.x = THREE.MathUtils.degToRad(ref.params.DIP_Flex * curlFactor * 0.28);
 
 // Position relative in local space
 clonedFinger.position.set(config.x, 0, 0);
 clonedFinger.rotation.copy(ref.finger.rotation);
 const baseScale = ref.finger.scale.x;
 const scaleVal = baseScale * config.scale;
 clonedFinger.scale.set(scaleVal, scaleVal, scaleVal);
 
 clonedFinger.userData.offsetX = config.x;
 clonedFinger.userData.isLeftHand = true;
 
 if (ref.nailMesh && ref.nailMesh.geometry) {
 const clonedNailGeo = ref.nailMesh.geometry.clone();
 const clonedNailMat = ref.nailMesh.material.clone();
 const clonedNail = new THREE.SkinnedMesh(clonedNailGeo, clonedNailMat);
 
 clonedNail.bind(clonedSkeleton);
 clonedFinger.add(clonedNail);
 
 if (ref.finger.children) {
 const nailTipOriginal = ref.finger.children.find(c => c.material && c.material.transparent && c.material.opacity < 0.5);
 if (nailTipOriginal && nailTipOriginal.geometry) {
 const clonedTipGeo = nailTipOriginal.geometry.clone();
 const clonedTipMat = nailTipOriginal.material.clone();
 const clonedTip = new THREE.SkinnedMesh(clonedTipGeo, clonedTipMat);
 clonedTip.bind(clonedSkeleton);
 clonedFinger.add(clonedTip);
 }
 }
 }
 
 // Create voxel wrap for left hand finger
 if (window.createVoxelWrapForFinger) {
 try {
 const staticVoxelWrap = window.createVoxelWrapForFinger(clonedFinger, clonedSkeleton.bones, 12);
 clonedFinger.add(staticVoxelWrap);
 clonedFinger.userData.voxelWrap = staticVoxelWrap;
 clonedFinger.userData.updateVoxelWrap = () => {
 if (window.updateVoxelWrap) {
 window.updateVoxelWrap(staticVoxelWrap);
 }
 };
 console.log(`[VoxelWrap] Created voxel wrap for left hand finger: ${config.name}`);
 } catch (err) {
 console.warn(`[VoxelWrap] Could not create voxel wrap for ${config.name}:`, err);
 }
 }
 
 leftHandGroup.add(clonedFinger);
 staticFingers.push({ 
 fingerMesh: clonedFinger,
 mesh: clonedFinger, 
 bones: { mcp: clonedMcp, pip: clonedPip, dip: clonedDip, tip: clonedTip },
 baseCurl: curlFactor,
 phase: Math.random() * Math.PI * 2
 });
 });
 }, 100);

 function initializeCharacter() {
 // Create Celli Avatar group
 celliAvatarGroup = new THREE.Group();
 celliAvatarGroup.name = "Celli Avatar";
 
 characterGroup = new THREE.Group();
 characterGroup.name = "Celli Body";
 characterGroup.visible = true; // Visible by default
 characterGroup.position.set(0, 0, 0); // Relative to celliAvatarGroup
 characterGroup.scale.setScalar(0.8); // Match human scale relative to keyboard
 
 // Create character bust from bust.html code - ZSphere system
 skinMat = new THREE.MeshPhysicalMaterial({
 color: 0xe7e2dc,
 roughness: 0.55,
 metalness: 0.0,
 clearcoat: 0.4,
 clearcoatRoughness: 0.6,
 sheen: 0.5,
 sheenRoughness: 0.8,
 });
 
 // ZSphere structure for hourglass figure
 characterZSpheres = [
 // Torso chain
 { pos: new THREE.Vector3(0, 0.15, 0), radius: 0.44, scale: new THREE.Vector3(1.0, 0.5, 0.9), parent: -1, name: "Hips" },
 { pos: new THREE.Vector3(0, 0.35, 0), radius: 0.34, scale: new THREE.Vector3(0.68, 0.7, 0.6), parent: 0, name: "Waist" },
 { pos: new THREE.Vector3(0, 0.58, 0), radius: 0.38, scale: new THREE.Vector3(0.88, 0.65, 0.72), parent: 1, name: "Ribcage" },
 { pos: new THREE.Vector3(0, 0.82, 0), radius: 0.36, scale: new THREE.Vector3(0.95, 0.5, 0.78), parent: 2, name: "Upper Chest" },
 // Breasts
 { pos: new THREE.Vector3(-0.18, 0.68, 0.12), radius: 0.16, scale: new THREE.Vector3(0.95, 1.1, 1.15), parent: 2, name: "Left Breast" },
 { pos: new THREE.Vector3(0.18, 0.68, 0.12), radius: 0.16, scale: new THREE.Vector3(0.95, 1.1, 1.15), parent: 2, name: "Right Breast" },
 // Left arm
 { pos: new THREE.Vector3(-0.32, 0.82, 0), radius: 0.14, scale: new THREE.Vector3(1.0, 1.0, 1.0), parent: 3, name: "Left Shoulder" },
 { pos: new THREE.Vector3(-0.38, 0.72, 0), radius: 0.10, scale: new THREE.Vector3(1.0, 1.2, 1.0), parent: 6, name: "Left Bicep Upper" },
 { pos: new THREE.Vector3(-0.42, 0.58, 0), radius: 0.09, scale: new THREE.Vector3(1.0, 1.3, 1.0), parent: 7, name: "Left Bicep Lower" },
 // Right arm
 { pos: new THREE.Vector3(0.32, 0.82, 0), radius: 0.14, scale: new THREE.Vector3(1.0, 1.0, 1.0), parent: 3, name: "Right Shoulder" },
 { pos: new THREE.Vector3(0.38, 0.72, 0), radius: 0.10, scale: new THREE.Vector3(1.0, 1.2, 1.0), parent: 9, name: "Right Bicep Upper" },
 { pos: new THREE.Vector3(0.42, 0.58, 0), radius: 0.09, scale: new THREE.Vector3(1.0, 1.3, 1.0), parent: 10, name: "Right Bicep Lower" },
 ];
 
 // Create merged geometry from ZSpheres (preview mesh)
 function createPreviewMesh() {
 const geometries = characterZSpheres.map(sphere => {
 const geo = new THREE.SphereGeometry(sphere.radius, 48, 32);
 geo.scale(sphere.scale.x, sphere.scale.y, sphere.scale.z);
 geo.translate(sphere.pos.x, sphere.pos.y, sphere.pos.z);
 return geo;
 });
 
 const merged = BufferGeometryUtils.mergeGeometries(geometries, false);
 merged.computeVertexNormals();
 
 // Create a separate material instance for preview mesh
 const previewMat = new THREE.MeshPhysicalMaterial({
 color: 0xe7e2dc,
 roughness: 0.55,
 metalness: 0.0,
 clearcoat: 0.4,
 clearcoatRoughness: 0.6,
 sheen: 0.5,
 sheenRoughness: 0.8,
 });
 
 return new THREE.Mesh(merged, previewMat);
 }
 
 // Create unified mesh with proper wrapping/smoothing
 // Helper: Calculate distance from point to ellipsoid surface
 function distanceToEllipsoid(point, sphere) {
 const localX = (point.x - sphere.pos.x) / sphere.scale.x;
 const localY = (point.y - sphere.pos.y) / sphere.scale.y;
 const localZ = (point.z - sphere.pos.z) / sphere.scale.z;
 
 const dist = Math.sqrt(localX * localX + localY * localY + localZ * localZ);
 return dist - sphere.radius;
 }
 
 // Helper: Check if two spheres are connected (parent-child relationship)
 function areConnected(idx1, idx2) {
 if (idx1 === idx2) return true;
 
 const s1 = characterZSpheres[idx1];
 const s2 = characterZSpheres[idx2];
 
 // Direct parent-child relationship
 if (s1.parent === idx2 || s2.parent === idx1) return true;
 
 // Siblings (same parent)
 if (s1.parent !== -1 && s1.parent === s2.parent) return true;
 
 // Check connection through chain
 let current = idx1;
 for (let i = 0; i < 10; i++) { // Max depth
 if (current === idx2) return true;
 if (current === -1) break;
 const sphere = characterZSpheres[current];
 current = sphere ? sphere.parent : -1;
 }
 
 current = idx2;
 for (let i = 0; i < 10; i++) {
 if (current === idx1) return true;
 if (current === -1) break;
 const sphere = characterZSpheres[current];
 current = sphere ? sphere.parent : -1;
 }
 
 return false;
 }
 
 // Helper: Find furthest surface point along a ray direction (with bone hierarchy)
 function findExteriorRadius(y, theta) {
 const dir = new THREE.Vector3(Math.cos(theta), 0, Math.sin(theta));
 let maxRadius = 0;
 let closestSphereIdx = -1;
 
 // Sample along the ray to find where any sphere is present
 for (let r = 0; r < 1.0; r += 0.005) {
 const testPoint = new THREE.Vector3(dir.x * r, y, dir.z * r);
 
 // Check distance to each sphere
 let minDist = Infinity;
 let nearestIdx = -1;
 
 characterZSpheres.forEach((sphere, idx) => {
 const dist = distanceToEllipsoid(testPoint, sphere);
 if (dist < minDist) {
 minDist = dist;
 nearestIdx = idx;
 }
 });
 
 // Only blend if connected to the closest sphere found so far
 if (closestSphereIdx === -1 || areConnected(nearestIdx, closestSphereIdx)) {
 if (minDist < 0.02) { // Soft threshold for smoother blend
 maxRadius = r;
 if (closestSphereIdx === -1) {
 closestSphereIdx = nearestIdx;
 }
 }
 }
 }
 
 return maxRadius;
 }
 
 // Laplacian smoothing for mesh
 function smoothMesh(positions, radialSegments, heightSegments, iterations = 3) {
 const smoothed = new Float32Array(positions);
 
 for (let iter = 0; iter < iterations; iter++) {
 const temp = new Float32Array(smoothed);
 
 for (let h = 1; h < heightSegments; h++) { // Skip top and bottom
 for (let r = 0; r <= radialSegments; r++) {
 const idx = (h * (radialSegments + 1) + r) * 3;
 
 // Get neighbors
 const neighbors = [];
 // Above and below
 if (h > 0) neighbors.push((h - 1) * (radialSegments + 1) + r);
 if (h < heightSegments) neighbors.push((h + 1) * (radialSegments + 1) + r);
 // Left and right (circular)
 const rPrev = r === 0 ? radialSegments - 1 : r - 1;
 const rNext = r === radialSegments ? 1 : r + 1;
 neighbors.push(h * (radialSegments + 1) + rPrev);
 neighbors.push(h * (radialSegments + 1) + rNext);
 
 // Average neighbor positions
 let avgX = 0, avgY = 0, avgZ = 0;
 for (const nIdx of neighbors) {
 avgX += temp[nIdx * 3];
 avgY += temp[nIdx * 3 + 1];
 avgZ += temp[nIdx * 3 + 2];
 }
 avgX /= neighbors.length;
 avgY /= neighbors.length;
 avgZ /= neighbors.length;
 
 // Blend with original (higher weight on XZ, less on Y)
 smoothed[idx] = temp[idx] * 0.3 + avgX * 0.7;
 smoothed[idx + 1] = temp[idx + 1] * 0.7 + avgY * 0.3; // Less smoothing on Y
 smoothed[idx + 2] = temp[idx + 2] * 0.3 + avgZ * 0.7;
 }
 }
 }
 
 return smoothed;
 }
 
 // Create unified tubular mesh that wraps around body shapes (bust.html method)
 function createUnifiedMesh() {
 const radialSegments = 64;
 const heightSegments = 100;
 const height = 1.0;
 
 const positions = [];
 const indices = [];
 
 // Generate vertices by tracing exterior surface
 for (let h = 0; h <= heightSegments; h++) {
 const y = (h / heightSegments) * height;
 
 // Generate ring of vertices by finding exterior boundary
 for (let r = 0; r <= radialSegments; r++) {
 const theta = (r / radialSegments) * Math.PI * 2;
 
 // Find the actual exterior radius at this height and angle
 const radius = findExteriorRadius(y, theta);
 
 const x = Math.cos(theta) * radius;
 const z = Math.sin(theta) * radius;
 
 positions.push(x, y, z);
 }
 }
 
 // Apply smoothing
 const smoothedPositions = smoothMesh(positions, radialSegments, heightSegments, 5);
 
 // Generate indices
 for (let h = 0; h < heightSegments; h++) {
 for (let r = 0; r < radialSegments; r++) {
 const a = h * (radialSegments + 1) + r;
 const b = a + 1;
 const c = (h + 1) * (radialSegments + 1) + r;
 const d = c + 1;
 
 indices.push(a, c, b);
 indices.push(b, c, d);
 }
 }
 
 const geometry = new THREE.BufferGeometry();
 geometry.setAttribute('position', new THREE.BufferAttribute(smoothedPositions, 3));
 geometry.setIndex(indices);
 geometry.computeVertexNormals();
 
 const unifiedMat = new THREE.MeshPhysicalMaterial({
 color: 0xe7e2dc,
 roughness: 0.55,
 metalness: 0.0,
 clearcoat: 0.4,
 clearcoatRoughness: 0.6,
 sheen: 0.5,
 sheenRoughness: 0.8,
 });
 
 console.log('[UnifiedMesh] Created true unified tubular mesh using bust.html method (exterior surface tracing)');
 return new THREE.Mesh(geometry, unifiedMat);
 }
 
 // Create both meshes with their own materials
 characterBust = createPreviewMesh();
 characterBust.castShadow = true;
 characterBust.receiveShadow = false;
 characterBust.visible = true; // Show base mesh by default
 characterBust.name = "PreviewMesh";
 characterGroup.add(characterBust);
 
 characterUnifiedMesh = createUnifiedMesh();
 characterUnifiedMesh.castShadow = true;
 characterUnifiedMesh.receiveShadow = false;
 characterUnifiedMesh.visible = false; // Hidden by default
 characterUnifiedMesh.name = "UnifiedMesh";
 characterGroup.add(characterUnifiedMesh);
 
 // Store sphere markers for editing (initially hidden)
 characterZSpheres.forEach((sphere, idx) => {
 const markerGeo = new THREE.SphereGeometry(sphere.radius * 0.95, 16, 16);
 const markerMat = new THREE.MeshBasicMaterial({ 
 color: 0x4a7cff, 
 transparent: true,
 opacity: 0.3,
 wireframe: true 
 });
 const marker = new THREE.Mesh(markerGeo, markerMat);
 marker.position.copy(sphere.pos);
 marker.scale.copy(sphere.scale);
 marker.userData.sphereIndex = idx;
 marker.visible = false;
 characterGroup.add(marker);
 characterPoseSpheres.push(marker);
 });
 
 // Plinth/base
 const plinth = new THREE.Mesh(
 new THREE.CylinderGeometry(0.42, 0.46, 0.18, 48),
 new THREE.MeshStandardMaterial({ color:0x1a1e25, metalness:0.1, roughness:0.85 })
 );
 plinth.position.y = 0.12;
 plinth.receiveShadow = true;
 characterGroup.add(plinth);
 
 // Slight rotation for posed look
 characterGroup.rotation.y = THREE.MathUtils.degToRad(10);
 
celliAvatarGroup.add(characterGroup);
}

// ===== Head Preset Configurations =====
// Define presets before initializeVoxelHead uses them
const headPresets = {
'sparse-blue': {
animSpeed: 1.15, amplitude: 0.15, opacityMin: 0.3, opacityMax: 0.85,
emissive: 0.8, lightInt: 2.5, lightPulse: true, rotationSpeed: 0.3, color: '#95bfff',
voxelSize: 0.10, shellThickness: 0.12, voxelSpacing: 1.05, phaseNoise: 0.75, 
falloff: 0.85, noiseWarp: 0.15, opacitySpeed: 0.8, metalness: 0.2, roughness: 0.55
},
'intro-celli': {
animSpeed: 1.15, amplitude: 0.28, opacityMin: 0.85, opacityMax: 0.95,
emissive: 0.6, lightInt: 3.5, lightPulse: true, rotationSpeed: 0.3, color: '#ffb850',
voxelSize: 0.25, shellThickness: 0.35, voxelSpacing: 0.9, phaseNoise: 0.75,
falloff: 0.85, noiseWarp: 0.15, opacitySpeed: 0.8, metalness: 0.2, roughness: 0.55
},
'dense-cyan': {
animSpeed: 0.8, amplitude: 0.25, opacityMin: 0.5, opacityMax: 0.95,
emissive: 1.2, lightInt: 3.5, lightPulse: true, rotationSpeed: 0.2, color: '#00ffff',
voxelSize: 0.10, shellThickness: 0.20, voxelSpacing: 1.05, phaseNoise: 0.75,
falloff: 0.85, noiseWarp: 0.15, opacitySpeed: 0.8, metalness: 0.2, roughness: 0.55
},
'warm-glow': {
animSpeed: 1.5, amplitude: 0.12, opacityMin: 0.4, opacityMax: 0.9,
emissive: 1.5, lightInt: 4.0, lightPulse: false, rotationSpeed: 0.15, color: '#ffaa55',
voxelSize: 0.10, shellThickness: 0.12, voxelSpacing: 1.05, phaseNoise: 0.75,
falloff: 0.85, noiseWarp: 0.15, opacitySpeed: 0.8, metalness: 0.2, roughness: 0.55
},
'neon-pink': {
animSpeed: 2.0, amplitude: 0.2, opacityMin: 0.35, opacityMax: 0.88,
emissive: 1.8, lightInt: 5.0, lightPulse: true, rotationSpeed: 0.5, color: '#ff1493',
voxelSize: 0.10, shellThickness: 0.12, voxelSpacing: 1.05, phaseNoise: 0.75,
falloff: 0.85, noiseWarp: 0.15, opacitySpeed: 0.8, metalness: 0.2, roughness: 0.55
},
'ghost-white': {
animSpeed: 0.5, amplitude: 0.08, opacityMin: 0.15, opacityMax: 0.5,
emissive: 0.5, lightInt: 1.5, lightPulse: false, rotationSpeed: 0.1, color: '#f0f0ff',
voxelSize: 0.10, shellThickness: 0.12, voxelSpacing: 1.05, phaseNoise: 0.75,
falloff: 0.85, noiseWarp: 0.15, opacitySpeed: 0.8, metalness: 0.2, roughness: 0.55
}
};

function initializeVoxelHead() {
voxelHeadGroup = new THREE.Group();
voxelHeadGroup.name = "Celli Head";
// In sequence mode, head is visible; in debug mode, default to hidden
voxelHeadGroup.visible = EXEC_ENV_MODE === 'sequence';
voxelHeadGroup.position.set(0, 1.5, 0); // Relative to body (character is at -3, 0.5, 3)
voxelHeadGroup.scale.setScalar(0.3);

// Create glowing voxel head using SDF-based shell wrapping (from bosscelli.html)
// Get preset based on mode
const defaultPreset = EXEC_ENV_MODE === 'sequence' ? 'intro-celli' : 'sparse-blue';
const preset = headPresets[defaultPreset];

// Use preset parameters (can be overridden via debug controls)
const voxelSize = window.headVoxelSize || preset.voxelSize;
const headSizeX = 2.4;
const headSizeY = 1.6; // Shorter height
const headSizeZ = 1.4; // Much thinner, more slab-like (was 2.2)
const cornerRadius = 0.45; // More rounded corners (was 0.35)
const shellThickness = window.headVoxelLayers || preset.shellThickness;
 
 // Helper: SDF for rounded box (head shape)
 function sdfRoundedBox(p, hx, hy, hz, r) {
 const qx = Math.abs(p.x) - hx;
 const qy = Math.abs(p.y) - hy;
 const qz = Math.abs(p.z) - hz;
 const q = new THREE.Vector3(Math.max(qx, 0), Math.max(qy, 0), Math.max(qz, 0));
 const outside = q.length();
 const inside = Math.min(Math.max(qx, Math.max(qy, qz)), 0.0);
 return outside + inside - r;
 }
 
 // Check if point is in face cutout (eyes, mouth)
 function isInFaceCutout(p) {
 // Only check front face
 if (p.z < headSizeZ * 0.25) return false;
 
 // Eyes (elliptical)
 const eyeRadiusX = headSizeY * 0.22;
 const eyeRadiusY = headSizeY * 0.16;
 const eyeY = headSizeY * 0.15;
 const eyeSpacing = headSizeX * 0.3;
 
 const leftEyeX = (p.x + eyeSpacing) / eyeRadiusX;
 const leftEyeY = (p.y - eyeY) / eyeRadiusY;
 if (leftEyeX * leftEyeX + leftEyeY * leftEyeY < 1.0) return true;
 
 const rightEyeX = (p.x - eyeSpacing) / eyeRadiusX;
 const rightEyeY = (p.y - eyeY) / eyeRadiusY;
 if (rightEyeX * rightEyeX + rightEyeY * rightEyeY < 1.0) return true;
 
 // Smile/Frown (controlled by deformation parameter: 1=smile, 0=neutral, -1=frown)
 const mouthDeform = window.headMouthDeform !== undefined ? window.headMouthDeform : 1.0;
 const smileRadius = headSizeY * 0.08;
 const smileY = -headSizeY * 0.2;
 const smileWidth = headSizeX * 0.55;
 const smileCurve = headSizeY * 0.15 * mouthDeform; // Curve direction controlled by deform
 
 const smileT = (p.x / smileWidth) + 0.5;
 if (smileT >= 0 && smileT <= 1) {
 const smileYOffset = -Math.pow((smileT - 0.5) * 2, 2) * smileCurve;
 const smileCenterY = smileY + smileYOffset;
 const smileDist = Math.abs(p.y - smileCenterY);
 if (smileDist < smileRadius && Math.abs(p.x) < smileWidth * 0.5) {
 return true;
 }
 }
 
 return false;
 }
 
 // Generate voxel shell
 const half = new THREE.Vector3(headSizeX * 0.5, headSizeY * 0.5, headSizeZ * 0.5);
 const margin = cornerRadius + shellThickness + 0.4;
 const min = new THREE.Vector3(-half.x - margin, -half.y - margin, -half.z - margin);
 const max = new THREE.Vector3(half.x + margin, half.y + margin, half.z + margin);
 
// Voxel spacing controlled by global parameter or preset
const voxelSpacing = window.headVoxelSpacing || preset.voxelSpacing;
const step = voxelSize * voxelSpacing;
 const instances = [];
 
 for (let x = min.x; x <= max.x; x += step) {
 for (let y = min.y; y <= max.y; y += step) {
 for (let z = min.z; z <= max.z; z += step) {
 const p = new THREE.Vector3(x, y, z);
 const d = sdfRoundedBox(p, half.x, half.y, half.z, cornerRadius);
 
 if (d > -0.02 && d < shellThickness) {
 if (!isInFaceCutout(p)) {
 instances.push({
 basePos: p.clone(),
 id: instances.length,
 colorAlt: instances.length % 5 === 0
 });
 }
 }
 }
 }
 }
 
console.log(`[Voxel Head] Generated ${instances.length} voxel instances (voxelSize: ${voxelSize}, spacing: ${voxelSpacing}, shellThickness: ${shellThickness})`);

// Create instanced mesh with preset color
const cubeGeo = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);
const presetColor = new THREE.Color(preset.color);
const instancedMesh = new THREE.InstancedMesh(
cubeGeo,
new THREE.MeshStandardMaterial({ 
color: presetColor,
metalness: preset.metalness,
roughness: preset.roughness,
transparent: true,
opacity: preset.opacityMax, // Use preset max opacity for base material
emissive: presetColor,
emissiveIntensity: preset.emissive,
depthWrite: false,
side: THREE.DoubleSide
}),
instances.length
);
instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

// Enable per-instance colors for "TURN BACK" text highlighting
instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(
new Float32Array(instances.length * 3), 3
);
// Initialize all colors to preset color
const defaultColor = new THREE.Color(preset.color);
for (let i = 0; i < instances.length; i++) {
instancedMesh.setColorAt(i, defaultColor);
}
instancedMesh.instanceColor.needsUpdate = true;
 
 // Set initial positions
 const tmpObj = new THREE.Object3D();
 instances.forEach((inst, i) => {
 tmpObj.position.copy(inst.basePos);
 tmpObj.scale.setScalar(voxelSize);
 tmpObj.updateMatrix();
 instancedMesh.setMatrixAt(i, tmpObj.matrix);
 });
 
voxelHeadGroup.add(instancedMesh);
voxelHeadGroup.userData.instances = instances;
voxelHeadGroup.userData.instancedMesh = instancedMesh;
voxelHeadGroup.userData.baseVoxelSize = voxelSize; // Store base size
voxelHeadGroup.userData.isSequenceMode = EXEC_ENV_MODE === 'sequence'; // Store mode
voxelHeadGroup.userData.currentPreset = defaultPreset; // Store which preset is active

// Add internal glow light with preset color
const headLight = new THREE.PointLight(presetColor, preset.lightInt, 4);
headLight.position.set(0, 0, 0);
voxelHeadGroup.add(headLight);
voxelHeadGroup.userData.headLight = headLight;

// Add eye lights (positioned behind the eye cutouts)
const eyeY = headSizeY * 0.15;
const eyeSpacing = headSizeX * 0.3;
const eyeLightZ = -headSizeZ * 0.3; // Behind the eyes

const leftEyeLight = new THREE.PointLight(0xffffaa, 2.5, 2);
leftEyeLight.position.set(-eyeSpacing, eyeY, eyeLightZ);
voxelHeadGroup.add(leftEyeLight);

const rightEyeLight = new THREE.PointLight(0xffffaa, 2.5, 2);
rightEyeLight.position.set(eyeSpacing, eyeY, eyeLightZ);
voxelHeadGroup.add(rightEyeLight);

voxelHeadGroup.userData.eyeLights = [leftEyeLight, rightEyeLight];

// Add pulsating pink cheek orbs (positioned on the sides of the face)
const cheekY = headSizeY * 0.05; // Slightly below eyes
const cheekX = headSizeX * 0.55; // On the sides
const cheekZ = headSizeZ * 0.4; // Front of face

const cheekGeometry = new THREE.SphereGeometry(0.15, 16, 16);
cheekGeometry.scale(1.2, 0.8, 0.6); // Make it oval (wider than tall)

const cheekMaterial = new THREE.MeshStandardMaterial({
color: 0xff69b4, // Pink
emissive: 0xff69b4,
emissiveIntensity: 0.6,
transparent: true,
opacity: 0.7,
roughness: 0.3,
metalness: 0.1
});

const leftCheek = new THREE.Mesh(cheekGeometry, cheekMaterial.clone());
leftCheek.position.set(-cheekX, cheekY, cheekZ);
voxelHeadGroup.add(leftCheek);

const rightCheek = new THREE.Mesh(cheekGeometry, cheekMaterial.clone());
rightCheek.position.set(cheekX, cheekY, cheekZ);
voxelHeadGroup.add(rightCheek);

voxelHeadGroup.userData.cheeks = [leftCheek, rightCheek];
voxelHeadGroup.userData.cheekBaseScale = 1.0;

console.log(`[Voxel Head] Mode: ${EXEC_ENV_MODE}, Preset: ${defaultPreset}, Color: ${preset.color}, Visible: ${voxelHeadGroup.visible}, Instances: ${instances.length}`);
 
celliAvatarGroup.add(voxelHeadGroup);

// Position, rotate, and scale the avatar
celliAvatarGroup.position.set(6, 2.0, 22); // Raised Y significantly (was -5.0)
celliAvatarGroup.rotation.y = Math.PI + THREE.MathUtils.degToRad(10); // 180 + 10 clockwise for alignment

// Scale based on mode: narrative mode uses smaller, more natural scale; debug mode uses large scale for editing
const avatarScale = EXEC_ENV_MODE === 'sequence' ? 5.0 : 30.0;
celliAvatarGroup.scale.setScalar(avatarScale);

console.log(`[Avatar] Celli positioned: pos(6, 2.0, 22), rotation 190, scale ${avatarScale}x (${EXEC_ENV_MODE} mode)`);

scene.add(celliAvatarGroup);
 }
 
 // ===== Sculpt Mode for Character Editing =====
 let sculptMode = false;
 let sculptInflateRadius = 0.1;
 let sculptInflateStrength = 0.05;
 
 function enableSculptMode() {
 console.log('[Sculpt] Enabling sculpt mode...');
 sculptMode = true;
 
 // Hide transform controls
 if (transformControl) {
 transformControl.detach();
 }
 
 // Show character and jump to it
 if (characterBust) characterBust.visible = true;
 if (characterGroup) characterGroup.visible = true;
 
 alert('Sculpt Mode: Click and hold on character to inflate. Mode: Inflate by default.');
 }
 
 // Mouse sculpt handling
 let isSculpting = false;
 let sculptTarget = null;
 
 renderer.domElement.addEventListener('mousedown', (event) => {
 if (!sculptMode) return;
 
 const raycaster = new THREE.Raycaster();
 const mouse = new THREE.Vector2();
 mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
 mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
 raycaster.setFromCamera(mouse, camera);
 
 const intersects = raycaster.intersectObjects([characterBust, characterUnifiedMesh].filter(m => m && m.visible), true);
 
 if (intersects.length > 0) {
 isSculpting = true;
 sculptTarget = intersects[0];
 console.log('[Sculpt] Started sculpting at:', sculptTarget.point);
 }
 });
 
 renderer.domElement.addEventListener('mouseup', () => {
 if (isSculpting) {
 console.log('[Sculpt] Stopped sculpting');
 isSculpting = false;
 sculptTarget = null;
 }
 });
 
 renderer.domElement.addEventListener('mousemove', (event) => {
 if (!isSculpting || !sculptTarget) return;
 
 // Inflate vertices near the sculpt target
 const mesh = sculptTarget.object;
 if (!mesh || !mesh.geometry) return;
 
 const positions = mesh.geometry.getAttribute('position');
 if (!positions) return;
 
 const localPoint = mesh.worldToLocal(sculptTarget.point.clone());
 
 // Inflate vertices within radius
 for (let i = 0; i < positions.count; i++) {
 const vx = positions.getX(i);
 const vy = positions.getY(i);
 const vz = positions.getZ(i);
 
 const dx = vx - localPoint.x;
 const dy = vy - localPoint.y;
 const dz = vz - localPoint.z;
 const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
 
 if (dist < sculptInflateRadius) {
 // Calculate falloff
 const falloff = 1.0 - (dist / sculptInflateRadius);
 const influence = falloff * falloff * sculptInflateStrength;
 
 // Move vertex along its normal (inflate)
 const normal = new THREE.Vector3(dx, dy, dz).normalize();
 positions.setXYZ(
 i,
 vx + normal.x * influence,
 vy + normal.y * influence,
 vz + normal.z * influence
 );
 }
 }
 
 positions.needsUpdate = true;
 mesh.geometry.computeVertexNormals();
 });
 
 // ===== Transform Controls for Character Editing =====
 function initializeTransformControls() {
 transformControl = new TransformControls(camera, renderer.domElement);
 transformControl.addEventListener('dragging-changed', (event) => {
 controls.enabled = !event.value;
 });
 transformControl.setMode('translate');
 scene.add(transformControl);
 
 // Gizmo mode buttons
 const gizmoButtons = document.querySelectorAll('.gizmo-btn[data-mode]');
 gizmoButtons.forEach(btn => {
 btn.addEventListener('click', () => {
 const mode = btn.dataset.mode;
 transformControl.setMode(mode);
 gizmoButtons.forEach(b => b.classList.remove('active'));
 btn.classList.add('active');
 });
 });
 
 // Snap toggle button
 const snapToggle = document.getElementById('snap-toggle');
 const snapModes = ['free', '45', '90'];
 let currentSnapIndex = 0;
 
 snapToggle.addEventListener('click', () => {
 currentSnapIndex = (currentSnapIndex + 1) % snapModes.length;
 const snapMode = snapModes[currentSnapIndex];
 snapToggle.dataset.snap = snapMode;
 
 if (snapMode === 'free') {
 transformControl.setRotationSnap(null);
 transformControl.setTranslationSnap(null);
 snapToggle.textContent = 'Free';
 snapToggle.title = 'Rotation Snap: Free';
 } else if (snapMode === '45') {
 transformControl.setRotationSnap(THREE.MathUtils.degToRad(45));
 transformControl.setTranslationSnap(0.5);
 snapToggle.textContent = '45 ';
 snapToggle.title = 'Rotation Snap: 45 ';
 } else if (snapMode === '90') {
 transformControl.setRotationSnap(THREE.MathUtils.degToRad(90));
 transformControl.setTranslationSnap(1.0);
 snapToggle.textContent = '90 ';
 snapToggle.title = 'Rotation Snap: 90 ';
 }
 });
 
 // Keyboard shortcuts
 window.addEventListener('keydown', (e) => {
 if (e.target.tagName === 'INPUT') return;
 if (e.key === 'g' || e.key === 'G') {
 transformControl.setMode('translate');
 
 // Also update 3D buttons if frame is visible
 if (frameOfReference && frameOfReference.visible && frameOfReference.userData.gizmoButtons) {
 const gizmoButtons = frameOfReference.userData.gizmoButtons;
 gizmoButtons.forEach(({ button }) => {
 if (button.userData.mode === 'translate') {
 button.userData.isActive = true;
 button.material.emissiveIntensity = 0.5;
 animateButtonPress(button);
 } else if (button.userData.mode !== 'snap') {
 button.userData.isActive = false;
 button.material.emissiveIntensity = 0.2;
 }
 });
 } else {
 document.querySelector('[data-mode="translate"]')?.click();
 }
 } else if (e.key === 'r' || e.key === 'R') {
 transformControl.setMode('rotate');
 
 // Also update 3D buttons if frame is visible
 if (frameOfReference && frameOfReference.visible && frameOfReference.userData.gizmoButtons) {
 const gizmoButtons = frameOfReference.userData.gizmoButtons;
 gizmoButtons.forEach(({ button }) => {
 if (button.userData.mode === 'rotate') {
 button.userData.isActive = true;
 button.material.emissiveIntensity = 0.5;
 animateButtonPress(button);
 } else if (button.userData.mode !== 'snap') {
 button.userData.isActive = false;
 button.material.emissiveIntensity = 0.2;
 }
 });
 } else {
 document.querySelector('[data-mode="rotate"]')?.click();
 }
 } else if (e.key === 's' || e.key === 'S') {
 transformControl.setMode('scale');
 
 // Also update 3D buttons if frame is visible
 if (frameOfReference && frameOfReference.visible && frameOfReference.userData.gizmoButtons) {
 const gizmoButtons = frameOfReference.userData.gizmoButtons;
 gizmoButtons.forEach(({ button }) => {
 if (button.userData.mode === 'scale') {
 button.userData.isActive = true;
 button.material.emissiveIntensity = 0.5;
 animateButtonPress(button);
 } else if (button.userData.mode !== 'snap') {
 button.userData.isActive = false;
 button.material.emissiveIntensity = 0.2;
 }
 });
 } else {
 document.querySelector('[data-mode="scale"]')?.click();
 }
 } else if (e.key === 'Escape') {
 transformControl.detach();
 }
 });
 }
 
 // ===== Camera Navigation =====
 function jumpToKeyboard() {
 animateCamera(new THREE.Vector3(8, 6, 12), new THREE.Vector3(6, 1.8, 3.5));
 keyboardGroup.visible = true;
 }
 
 function jumpToCharacter() {
 // Celli is now at (6, -5.0, 22) with 30x scale, body center at ~y=10
 animateCamera(new THREE.Vector3(6, 13, 12), new THREE.Vector3(6, 10, 22));
 characterGroup.visible = true;
 }
 
 function jumpToHead() {
 // Celli's head is now at ~y=40.0 (voxelHeadGroup at 1.5 * 30 scale - 5.0 base)
 animateCamera(new THREE.Vector3(6, 43, 12), new THREE.Vector3(6, 40, 22));
 voxelHeadGroup.visible = true;
 }
 
function jumpToOverview() {
// View from rear base of keyboard looking up at Celli
animateCamera(new THREE.Vector3(6, 0.5, -3), new THREE.Vector3(6, 8, 22));
keyboardGroup.visible = true;
characterGroup.visible = true;
voxelHeadGroup.visible = true;
}

function positionCameraInsideHead() {
// Position camera at center of Celli's head, facing BACK
// Celli avatar is at (6, 2.0, 22) with 5x scale in sequence mode
// voxelHeadGroup is at (0, 1.5, 0) relative to avatar

const headCenterWorld = celliAvatarGroup.localToWorld(voxelHeadGroup.position.clone());
camera.position.copy(headCenterWorld);

// Reset camera rotation to identity first
camera.rotation.set(0, 0, 0);
camera.quaternion.set(0, 0, 0, 1);

// Set camera to face BACK (positive Z direction in world space)
// Celli faces negative Z, so back is positive Z
// Camera faces negative Z by default, so rotate 180 degrees around Y
camera.rotation.y = Math.PI;

// Store the FORWARD direction (the direction player should turn TO) for turn detection
// This is the opposite of where camera is currently facing
const backDirection = camera.getWorldDirection(new THREE.Vector3());
narrativeSequence.initialCameraDirection = backDirection.clone().negate(); // Store forward direction

// Set orbit controls target to a point behind the camera (where it's looking)
if (controls) {
const lookTarget = headCenterWorld.clone().add(backDirection.clone().multiplyScalar(5));
controls.target.copy(lookTarget);
controls.update();

controls.enabled = true;
controls.enableDamping = true;
controls.enableRotate = true;
controls.enablePan = true;
controls.enableZoom = true;
console.log('[Sequence] Orbit controls ENABLED - full camera control');
console.log('[Sequence] Controls target:', controls.target);
}

console.log('? Camera positioned inside head, facing back (rotation.y = )');
console.log('? Camera rotation:', camera.rotation);
console.log('? Camera is facing:', backDirection);
console.log('? Turn target direction (forward):', narrativeSequence.initialCameraDirection);

// Illuminate "TURN BACK" text on voxels
illuminateTurnBackText();
}

function dropPlayer() {
// Smooth dolly/zoom animation to drop into the city at human scale
if (!lastViewedKey) {
console.warn('[Drop] No key has been viewed yet. Cannot drop.');
// Fallback: use first key if available
if (keys && keys.length > 0) {
lastViewedKey = keys[0];
console.log('[Drop] Using first key as fallback:', lastViewedKey.userData.label);
} else {
console.error('[Drop] No keys available.');
return;
}
}

console.log('[Drop] Initiating drop animation above key:', lastViewedKey.userData.label);

// Get key world position and dimensions
const keyWorldPos = new THREE.Vector3();
lastViewedKey.getWorldPosition(keyWorldPos);

const bbox = new THREE.Box3().setFromObject(lastViewedKey);
const keyHeight = bbox.max.y - bbox.min.y;
const keySurfaceY = keyWorldPos.y + keyHeight / 2; // Top surface of key

// Calculate human-scale height above key
// Buildings are ~0.02 * 3 = 0.06 units tall on average
// If buildings represent 10m tall buildings, and human eye level is 1.7m:
// Scale factor: 0.06 units = 10m, so 1m = 0.006 units
// Human eye level = 1.7m * 0.006 = 0.0102 units above key surface
const buildingScale = 0.02; // From createMicroCitiesOnKeys
const avgBuildingHeight = buildingScale * 3; // ~0.06 units
const buildingHeightInMeters = 10; // Buildings represent 10m tall structures
const humanEyeLevelInMeters = 1.7; // Human eye level
const metersToWorldUnits = avgBuildingHeight / buildingHeightInMeters;
const humanEyeLevel = humanEyeLevelInMeters * metersToWorldUnits; // ~0.0102 units

// START POSITION: Normal view above key, looking down
dropStartPos.copy(camera.position); // Keep current position
dropStartScale = 1.0; // Normal scale

// TARGET POSITION: Human eye level on key surface
dropTargetPos.set(
keyWorldPos.x,
keySurfaceY + humanEyeLevel,
keyWorldPos.z
);
dropTargetScale = 1.0; // Keep normal scale, just change position

// Show debug tracker
const debugEl = document.getElementById('drop-debug');
if (debugEl) {
debugEl.style.display = 'block';
}

// Initialize drop animation
isDropping = true;
dropProgress = 0;
dropStartTime = Date.now();
dropKeyTarget = lastViewedKey;

// Point camera DOWN at the key to see the city approach
controls.target.set(keyWorldPos.x, keySurfaceY, keyWorldPos.z);
controls.update();

// Store original fog density and reduce fog for clear city view
if (scene.fog) {
originalFogDensity = scene.fog.density;
scene.fog.density = 0.001; // Drastically reduce fog
console.log('[Drop] Fog reduced from', originalFogDensity, 'to 0.001');
}

// Keep orbit controls enabled during drop
if (controls) {
controls.enabled = true;
console.log('[Drop] Orbit controls enabled during drop');
}

console.log('[Drop] Animation start');
console.log('  Start pos:', dropStartPos.toArray().map(v => v.toFixed(3)));
console.log('  Target pos:', dropTargetPos.toArray().map(v => v.toFixed(3)));
console.log('  Human eye level:', humanEyeLevel.toFixed(4), 'units');
console.log('  Key surface Y:', keySurfaceY.toFixed(3));
}

function transformCelliToHell() {
console.log('%c[CELLI->HELL]  TRANSFORMING CELLI TO HELL ', 'background: #f00; color: #fff; font-size: 18px; font-weight: bold; padding: 8px;');
console.log('[CELLI->HELL] Animation states:');
console.log('  - snapTogetherStarted:', snapTogetherStarted);
console.log('  - celliMoveToCornerStarted:', celliMoveToCornerStarted);
console.log('  - endColorState:', endColorState);
console.log('  - endSequence:', endSequence);

// C pattern reminder: [[0,1,1,1,0], [1,0,0,0,0], [1,0,0,0,0], [1,0,0,0,0], [0,1,1,1,0]]
// To make H: keep left column (col 0), remove top/bottom arcs, add right column (col 4) and crossbar (row 2)
// C is at letter index 0
// I is at letter index 4

if (!letterVoxels || !letterVoxels.C || !letterVoxels.I) {
console.error('[CELLI->HELL]  letterVoxels not found');
console.error('[CELLI->HELL] letterVoxels:', letterVoxels);
return;
}

const voxelsToRemove = [];
const voxelsToReposition = []; // Voxels that will fall and reappear

// Remove voxels from C to make H:
// Top row (row 0): remove columns 1, 2, 3 (keep 0, need to add 4)
// Middle row (row 2): keep all (this is the crossbar)
// Bottom row (row 4): remove columns 1, 2, 3 (keep 0, need to add 4)
letterVoxels.C.forEach(voxel => {
const row = voxel.userData.gridY;
const col = voxel.userData.gridCol;

// Remove top arc (row 0, columns 1-3) - these will reappear on the right
if (row === 0 && col >= 1 && col <= 3) {
voxelsToRemove.push(voxel);
// Mark for repositioning to right side (col 4)
if (col === 2) { // Use middle voxel to create right column top
voxel.userData.willReappearAs = { row: 0, col: 4, letterIdx: 0 };
voxelsToReposition.push(voxel);
}
}
// Remove bottom arc (row 4, columns 1-3) - these will reappear on the right
else if (row === 4 && col >= 1 && col <= 3) {
voxelsToRemove.push(voxel);
// Mark for repositioning to right side (col 4)
if (col === 2) { // Use middle voxel to create right column bottom
voxel.userData.willReappearAs = { row: 4, col: 4, letterIdx: 0 };
voxelsToReposition.push(voxel);
}
}
});

// Remove ALL voxels from I (letter index 4) - some will reappear as right column of H
letterVoxels.I.forEach((voxel, idx) => {
voxelsToRemove.push(voxel);
const row = voxel.userData.gridY;
// Use center column voxels (rows 1, 2, 3) to create right column of H
if (row >= 1 && row <= 3 && idx % 3 === 1) {
voxel.userData.willReappearAs = { row: row, col: 4, letterIdx: 0 };
voxelsToReposition.push(voxel);
}
});

console.log(`[CELLI->HELL] Removing ${voxelsToRemove.length} voxels, ${voxelsToReposition.length} will reappear`);

// Animate removed voxels falling
voxelsToRemove.forEach((voxel, index) => {
// Mark for removal
voxel.userData.fallingOff = true;
voxel.userData.fallVelocity = 0;
voxel.userData.fallDelay = index * 0.02; // Stagger the falls
voxel.userData.fallStartTime = Date.now() / 1000; // Current time in seconds
voxel.userData.rotationSpeed = {
x: (Math.random() - 0.5) * 0.1,
y: (Math.random() - 0.5) * 0.1,
z: (Math.random() - 0.5) * 0.1
};
});

// Remove from letterVoxels tracking
letterVoxels.C = letterVoxels.C.filter(v => !voxelsToRemove.includes(v));
letterVoxels.I = []; // All I voxels are removed
}

function createCelliBorderAvatar(size = 2) {
const group = new THREE.Group();
group.name = 'CelliBorderAvatar';

const MAT_BODY = new THREE.MeshBasicMaterial({ color: 0xf59e0b, transparent: true, opacity: 0.92 });
const MAT_MOUTH = new THREE.MeshBasicMaterial({ color: 0x111827, transparent: true, opacity: 0.95, side: THREE.DoubleSide });
const MAT_EYE = new THREE.MeshBasicMaterial({ color: 0x111827, transparent: false });
const MAT_CHEEK = new THREE.MeshBasicMaterial({ color: 0xec4899, transparent: true, opacity: 0.9 });
const MAT_BOW = new THREE.MeshBasicMaterial({ color: 0xfbbf24, transparent: true, opacity: 0.92, side: THREE.DoubleSide });
MAT_BODY.toneMapped = false;
MAT_MOUTH.toneMapped = false;
MAT_EYE.toneMapped = false;
MAT_CHEEK.toneMapped = false;
MAT_BOW.toneMapped = false;

// Helper to draw rounded rectangle
function drawRoundedRectPath(path, width, height, radius){
const hw = width / 2;
const hh = height / 2;
const r = Math.min(radius, hw, hh);
path.moveTo(-hw + r, -hh);
path.lineTo(hw - r, -hh);
path.quadraticCurveTo(hw, -hh, hw, -hh + r);
path.lineTo(hw, hh - r);
path.quadraticCurveTo(hw, hh, hw - r, hh);
path.lineTo(-hw + r, hh);
path.quadraticCurveTo(-hw, hh, -hw, hh - r);
path.lineTo(-hw, -hh + r);
path.quadraticCurveTo(-hw, -hh, -hw + r, -hh);
path.closePath();
}

// Create body frame (border)
const borderWidth = size;
const borderHeight = size;
const borderThickness = 0.2;
const shape = new THREE.Shape();
drawRoundedRectPath(shape, borderWidth, borderHeight, 0.2);
const hole = new THREE.Path();
drawRoundedRectPath(hole, borderWidth * 0.7, borderHeight * 0.7, 0.15);
shape.holes.push(hole);
const bodyGeo = new THREE.ExtrudeGeometry(shape, { depth: 0.1, bevelEnabled: false, steps: 1 });
bodyGeo.center();
const bodyFrame = new THREE.Mesh(bodyGeo, MAT_BODY);
bodyFrame.name = 'CelliBodyFrame';
group.add(bodyFrame);

// Create mouth frame (smile)
const mouthWidth = borderWidth * 0.4;
const mouthHeight = borderHeight * 0.25;
const mouthShape = new THREE.Shape();
drawRoundedRectPath(mouthShape, mouthWidth, mouthHeight, 0.1);
const mouthHole = new THREE.Path();
drawRoundedRectPath(mouthHole, mouthWidth * 0.7, mouthHeight * 0.6, 0.08);
mouthShape.holes.push(mouthHole);
const mouthGeo = new THREE.ExtrudeGeometry(mouthShape, { depth: 0.05, bevelEnabled: false, steps: 1 });
mouthGeo.center();
const mouthFrame = new THREE.Mesh(mouthGeo, MAT_MOUTH);
mouthFrame.position.set(0, -borderHeight * 0.15, 0.06);
mouthFrame.name = 'CelliMouthFrame';
group.add(mouthFrame);

// Eyes
const eyeGeo = new THREE.CircleGeometry(0.12, 24);
const eyeLeft = new THREE.Mesh(eyeGeo, MAT_EYE);
const eyeRight = eyeLeft.clone();
eyeLeft.position.set(-borderWidth * 0.18, borderHeight * 0.1, 0.06);
eyeRight.position.set(borderWidth * 0.18, borderHeight * 0.1, 0.06);
eyeLeft.name = 'CelliEyeLeft';
eyeRight.name = 'CelliEyeRight';
group.add(eyeLeft, eyeRight);

// Cheeks
const cheekGeo = new THREE.CircleGeometry(0.14, 24);
const cheekLeft = new THREE.Mesh(cheekGeo, MAT_CHEEK);
const cheekRight = cheekLeft.clone();
cheekLeft.position.set(-borderWidth * 0.32, borderHeight * 0.05, 0.055);
cheekRight.position.set(borderWidth * 0.32, borderHeight * 0.05, 0.055);
cheekLeft.name = 'CelliCheekLeft';
cheekRight.name = 'CelliCheekRight';
group.add(cheekLeft, cheekRight);

// Bow
const bowGroup = new THREE.Group();
bowGroup.name = 'CelliBow';
const bowWingGeo = new THREE.ShapeGeometry(new THREE.Shape([
new THREE.Vector2(0.15, 0),
new THREE.Vector2(-0.08, 0.15),
new THREE.Vector2(-0.08, -0.15)
]));
const bowWingLeft = new THREE.Mesh(bowWingGeo, MAT_BOW);
bowWingLeft.position.set(-0.1, 0, 0);
const bowWingRight = bowWingLeft.clone();
bowWingRight.scale.x = -1;
bowWingRight.position.set(0.1, 0, 0);
const bowKnot = new THREE.Mesh(new THREE.CircleGeometry(0.07, 20), MAT_BOW);
bowKnot.position.set(0, 0, 0.005);
bowGroup.add(bowWingLeft, bowWingRight, bowKnot);
bowGroup.position.set(0, borderHeight * 0.42, 0.06);
group.add(bowGroup);

// Store references
group.userData = {
bodyFrame,
mouthFrame,
eyeLeft,
eyeRight,
cheekLeft,
cheekRight,
bowGroup,
hoverActive: false,
clickActive: false
};

return group;
}

function illuminateTurnBackText() {
if (!voxelHeadGroup || !voxelHeadGroup.userData.instances) return;

const instances = voxelHeadGroup.userData.instances;
const instancedMesh = voxelHeadGroup.userData.instancedMesh;

// Define letter patterns (5x7 grid for each letter)
const letterT = [[1,1,1,1,1],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0]];
const letterU = [[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]];
const letterR = [[1,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,0],[1,0,1,0,0],[1,0,0,1,0],[1,0,0,0,1]];
const letterN = [[1,0,0,0,1],[1,1,0,0,1],[1,0,1,0,1],[1,0,0,1,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1]];
const letterB = [[1,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,0]];
const letterA = [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1]];
const letterC = [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,1],[0,1,1,1,0]];
const letterK = [[1,0,0,0,1],[1,0,0,1,0],[1,0,1,0,0],[1,1,0,0,0],[1,0,1,0,0],[1,0,0,1,0],[1,0,0,0,1]];

const letters = ['TURN', ' ', 'BACK'];
const letterPatterns = [
[letterT, letterU, letterR, letterN],
[],
[letterB, letterA, letterC, letterK]
];

// Find voxels on the back surface (positive Z in local coordinates since head is rotated)
// We'll use voxels with Z > 0.8 (back surface)
const backVoxels = instances.map((data, i) => ({ ...data, index: i }))
.filter(v => v.basePos.z > 0.8)
.sort((a, b) => {
// Sort by Y (top to bottom), then X (left to right)
if (Math.abs(a.basePos.y - b.basePos.y) > 0.2) return b.basePos.y - a.basePos.y;
return a.basePos.x - b.basePos.x;
});

// Map text to voxel grid - create a simple grid mapping
const turnBackIndices = [];
const gridSize = 7; // Text height
const letterSpacing = 6;

// For simplicity, just mark some voxels on the back as text voxels
// We'll find voxels in a grid pattern and map the text
let wordX = -15; // Start position for words
[letterPatterns[0], letterPatterns[2]].forEach((word, wordIdx) => {
word.forEach((letter, letterIdx) => {
letter.forEach((row, rowIdx) => {
row.forEach((pixel, colIdx) => {
if (pixel === 1) {
// Find closest voxel to this text position
const targetX = wordX + letterIdx * letterSpacing + colIdx;
const targetY = -rowIdx * 2;
const closest = backVoxels.find(v =>
Math.abs(v.basePos.x * 10 - targetX) < 2 &&
Math.abs(v.basePos.y * 10 - targetY) < 2
);
if (closest) turnBackIndices.push(closest.index);
}
});
});
});
wordX += (word.length + 1) * letterSpacing;
});

voxelHeadGroup.userData.turnBackIndices = turnBackIndices;
voxelHeadGroup.userData.turnBackText = { active: true };

console.log(`? "TURN BACK" text prepared: ${turnBackIndices.length} voxels illuminated`);
}

function animateCamera(targetPos, targetLookAt, duration = 1500) {
 const startPos = camera.position.clone();
 const startLookAt = controls.target.clone();
 const startTime = Date.now();
 
 function animate() {
 const elapsed = Date.now() - startTime;
 const progress = Math.min(elapsed / duration, 1);
 const eased = 1 - Math.pow(1 - progress, 3);
 
 camera.position.lerpVectors(startPos, targetPos, eased);
 controls.target.lerpVectors(startLookAt, targetLookAt, eased);
 controls.update();
 
 if (progress < 1) {
 requestAnimationFrame(animate);
 }
 }
 animate();
 }
 
 function enableEditMode() {
 const gizmoToolbar = document.getElementById('gizmo-toolbar');
 gizmoToolbar.style.display = 'flex';
 
 // Show sphere markers for editing
 characterPoseSpheres.forEach(marker => {
 marker.visible = true;
 });
 
 if (characterBust) {
 transformControl.attach(characterBust);
 }
 
 console.log('Edit mode enabled - click on sphere markers to edit individual parts');
 
 // Add click handler for sphere selection
 const raycaster = new THREE.Raycaster();
 const mouse = new THREE.Vector2();
 
 function onSphereClick(event) {
 const rect = renderer.domElement.getBoundingClientRect();
 mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
 mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
 
 raycaster.setFromCamera(mouse, camera);
 const intersects = raycaster.intersectObjects(characterPoseSpheres, false);
 
 if (intersects.length > 0) {
 const selectedSphere = intersects[0].object;
 transformControl.attach(selectedSphere);
 
 // Highlight selected sphere
 characterPoseSpheres.forEach(marker => {
 marker.material.opacity = 0.3;
 marker.material.color.set(0x4a7cff);
 });
 selectedSphere.material.opacity = 0.6;
 selectedSphere.material.color.set(0xff4a7c);
 
 console.log('Selected sphere:', selectedSphere.userData.sphereIndex);
 }
 }
 
 renderer.domElement.addEventListener('click', onSphereClick);
 }
 
 // Helper: Hash function for per-instance phase variation
 function hash(n) {
 const s = Math.sin(n * 127.1) * 43758.5453;
 return s - Math.floor(s);
 }
 
 // ===== GUI Controls =====
 const gui = new GUI({ title: 'Debug & Settings', width: 300 });
 
 // Scene folder
 const sceneFolder = gui.addFolder('Scene');
 const sceneParams = {
 'Show Keyboard': true,
 'Show Character': true,
 'Show Voxel Head': true,
 'Show All': true,
 'Background Color': '#0a0a0a',
 'Fog Density': 0.03,
 'Auto Rotate Character': false
 };
 sceneFolder.add(sceneParams, 'Show Keyboard').onChange(v => {
 if (keyboardGroup) keyboardGroup.visible = v;
 });
 sceneFolder.add(sceneParams, 'Show Character').onChange(v => {
 if (characterGroup) characterGroup.visible = v;
 });
 sceneFolder.add(sceneParams, 'Show Voxel Head').onChange(v => {
 if (voxelHeadGroup) voxelHeadGroup.visible = v;
 });
 sceneFolder.add(sceneParams, 'Show All').onChange(v => {
 if (keyboardGroup) keyboardGroup.visible = v;
 if (characterGroup) characterGroup.visible = v;
 if (voxelHeadGroup) voxelHeadGroup.visible = v;
 sceneParams['Show Keyboard'] = v;
 sceneParams['Show Character'] = v;
 sceneParams['Show Voxel Head'] = v;
 sceneFolder.controllers.forEach(c => c.updateDisplay());
 });
 sceneFolder.addColor(sceneParams, 'Background Color').onChange(v => {
 scene.background.set(v);
 });
 sceneFolder.add(sceneParams, 'Fog Density', 0, 0.1, 0.001).onChange(v => {
 scene.fog.density = v;
 });
 sceneFolder.add(sceneParams, 'Auto Rotate Character');
 
 // Lighting folder
 const lightFolder = gui.addFolder('Lighting');
 const lightParams = {
 'Ambient Intensity': 0.15,
 'Hemisphere Intensity': 0.2,
 'Directional Intensity': 0.9,
 'Spot Intensity': 4.0,
 'Rim Intensity': 0.3
 };
 lightFolder.add(lightParams, 'Ambient Intensity', 0, 1, 0.01).onChange(v => al.intensity = v);
 lightFolder.add(lightParams, 'Hemisphere Intensity', 0, 1, 0.01).onChange(v => hl.intensity = v);
 lightFolder.add(lightParams, 'Directional Intensity', 0, 3, 0.01).onChange(v => dl.intensity = v);
 lightFolder.add(lightParams, 'Spot Intensity', 0, 10, 0.1).onChange(v => spotLight.intensity = v);
 lightFolder.add(lightParams, 'Rim Intensity', 0, 1, 0.01).onChange(v => rimLight.intensity = v);
 
 // Character Bust folder
 const bustFolder = gui.addFolder('Character Bust');
 const bustParams = {
 'Preview Mesh Visible': true,
 'Preview Wireframe': false,
 'Unified Mesh Visible': false,
 'Unified Wireframe': false,
 'Skin Color': '#e7e2dc',
 'Roughness': 0.55,
 'Metalness': 0.0,
 'Clearcoat': 0.4,
 'Show Markers': false,
 'Symmetry X': true,
 'Symmetry Y': false,
 'Symmetry Z': false
 };
 bustFolder.add(bustParams, 'Preview Mesh Visible').onChange(v => {
 if (characterBust) {
 characterBust.visible = v;
 }
 });
 bustFolder.add(bustParams, 'Preview Wireframe').onChange(v => {
 if (characterBust && characterBust.material) {
 characterBust.material.wireframe = v;
 }
 });
 bustFolder.add(bustParams, 'Unified Mesh Visible').onChange(v => {
 if (characterUnifiedMesh) {
 characterUnifiedMesh.visible = v;
 }
 });
 bustFolder.add(bustParams, 'Unified Wireframe').onChange(v => {
 if (characterUnifiedMesh && characterUnifiedMesh.material) {
 characterUnifiedMesh.material.wireframe = v;
 }
 });
 bustFolder.addColor(bustParams, 'Skin Color').onChange(v => {
 if (characterBust && characterBust.material) characterBust.material.color.set(v);
 if (characterUnifiedMesh && characterUnifiedMesh.material) characterUnifiedMesh.material.color.set(v);
 });
 bustFolder.add(bustParams, 'Roughness', 0.1, 1.0, 0.01).onChange(v => {
 if (characterBust && characterBust.material) characterBust.material.roughness = v;
 if (characterUnifiedMesh && characterUnifiedMesh.material) characterUnifiedMesh.material.roughness = v;
 });
 bustFolder.add(bustParams, 'Metalness', 0, 1, 0.01).onChange(v => {
 if (characterBust && characterBust.material) characterBust.material.metalness = v;
 if (characterUnifiedMesh && characterUnifiedMesh.material) characterUnifiedMesh.material.metalness = v;
 });
 bustFolder.add(bustParams, 'Clearcoat', 0, 1, 0.01).onChange(v => {
 if (characterBust && characterBust.material) characterBust.material.clearcoat = v;
 if (characterUnifiedMesh && characterUnifiedMesh.material) characterUnifiedMesh.material.clearcoat = v;
 });
 bustFolder.add(bustParams, 'Show Markers').onChange(v => {
 characterPoseSpheres.forEach(marker => marker.visible = v);
 });
 bustFolder.add(bustParams, 'Symmetry X');
 bustFolder.add(bustParams, 'Symmetry Y');
 bustFolder.add(bustParams, 'Symmetry Z');
 
 // Voxel Head folder
 const headFolder = gui.addFolder('Voxel Head');
// Get default preset based on mode
const defaultPresetForGUI = EXEC_ENV_MODE === 'sequence' ? 'intro-celli' : 'sparse-blue';
const guiPreset = headPresets[defaultPresetForGUI];

const headParams = {
// Animation
'Animation Speed': guiPreset.animSpeed,
'Amplitude': guiPreset.amplitude,
'Phase Noise': guiPreset.phaseNoise,
'Falloff': guiPreset.falloff,
'Noise Warp': guiPreset.noiseWarp,
// Opacity & Glow
'Opacity Min': guiPreset.opacityMin,
'Opacity Max': guiPreset.opacityMax,
'Opacity Speed': guiPreset.opacitySpeed,
'Emissive Intensity': guiPreset.emissive,
// Material
'Metalness': guiPreset.metalness,
'Roughness': guiPreset.roughness,
'Color': guiPreset.color,
// Light
'Light Intensity': guiPreset.lightInt,
'Light Pulse': guiPreset.lightPulse,
'Rotation Speed': guiPreset.rotationSpeed,
// Voxel Generation (requires regeneration)
'Voxel Size': guiPreset.voxelSize,
'Shell Thickness': guiPreset.shellThickness,
'Shell Outer Bias': 0.02
};
 
 const headAnimFolder = headFolder.addFolder('Animation');
 headAnimFolder.add(headParams, 'Animation Speed', 0, 3, 0.01);
 headAnimFolder.add(headParams, 'Amplitude', 0, 0.6, 0.01);
 headAnimFolder.add(headParams, 'Phase Noise', 0, 2, 0.01);
 headAnimFolder.add(headParams, 'Falloff', 0, 2, 0.01);
 headAnimFolder.add(headParams, 'Noise Warp', 0, 0.6, 0.01);
 
 const headGlowFolder = headFolder.addFolder('Glow & Opacity');
 headGlowFolder.add(headParams, 'Opacity Min', 0, 1, 0.01);
 headGlowFolder.add(headParams, 'Opacity Max', 0, 1, 0.01);
 headGlowFolder.add(headParams, 'Opacity Speed', 0, 3, 0.01);
 headGlowFolder.add(headParams, 'Emissive Intensity', 0, 2, 0.01);
 
 const headMatFolder = headFolder.addFolder('Material');
 headMatFolder.add(headParams, 'Metalness', 0, 1, 0.01).onChange(v => {
 if (voxelHeadGroup && voxelHeadGroup.userData.instancedMesh) {
 voxelHeadGroup.userData.instancedMesh.material.metalness = v;
 }
 });
 headMatFolder.add(headParams, 'Roughness', 0, 1, 0.01).onChange(v => {
 if (voxelHeadGroup && voxelHeadGroup.userData.instancedMesh) {
 voxelHeadGroup.userData.instancedMesh.material.roughness = v;
 }
 });
 headMatFolder.addColor(headParams, 'Color').onChange(v => {
 if (voxelHeadGroup && voxelHeadGroup.userData.instancedMesh) {
 voxelHeadGroup.userData.instancedMesh.material.color.set(v);
 voxelHeadGroup.userData.instancedMesh.material.emissive.set(v);
 if (voxelHeadGroup.userData.headLight) {
 voxelHeadGroup.userData.headLight.color.set(v);
 }
 }
 });
 
 const headLightFolder = headFolder.addFolder('Light');
 headLightFolder.add(headParams, 'Light Intensity', 0, 10, 0.1);
 headLightFolder.add(headParams, 'Light Pulse');
 headLightFolder.add(headParams, 'Rotation Speed', 0, 1, 0.01);
 
 // Post-Processing folder
 const postFolder = gui.addFolder('Post-Processing');
 const postParams = {
 'Bloom Strength': 0.6,
 'Bloom Radius': 0.6,
 'Bloom Threshold': 0.9,
 'Tone Mapping Exposure': 1.0,
 'Enable FXAA': true
 };
 postFolder.add(postParams, 'Bloom Strength', 0, 3, 0.01).onChange(v => bloomPass.strength = v);
 postFolder.add(postParams, 'Bloom Radius', 0, 3, 0.01).onChange(v => bloomPass.radius = v);
 postFolder.add(postParams, 'Bloom Threshold', 0, 1, 0.01).onChange(v => bloomPass.threshold = v);
 postFolder.add(postParams, 'Tone Mapping Exposure', 0, 3, 0.01).onChange(v => renderer.toneMappingExposure = v);
 postFolder.add(postParams, 'Enable FXAA').onChange(v => fxaaPass.enabled = v);
 
 // Camera folder
 const cameraFolder = gui.addFolder('Camera');
 const cameraParams = {
 'FOV': 45,
 'Near': 0.1,
 'Far': 100
 };
 cameraFolder.add(cameraParams, 'FOV', 20, 120, 1).onChange(v => {
 camera.fov = v;
 camera.updateProjectionMatrix();
 });
 cameraFolder.add(cameraParams, 'Near', 0.01, 10, 0.01).onChange(v => {
 camera.near = v;
 camera.updateProjectionMatrix();
 });
 cameraFolder.add(cameraParams, 'Far', 10, 500, 1).onChange(v => {
 camera.far = v;
 camera.updateProjectionMatrix();
 });
 
 // Micro City LOD folder
 const microCityFolder = gui.addFolder('Micro City LOD');
 const microCityParams = {
 'Enabled': true,
 'LOD Distance': 0.5, // Cities appear at moderate distance
 'Slowdown Distance': 0.08, // Slowdown only when VERY close
 'Fade Range': 0.2,
 'Building Scale': 0.003,
 'Building Density': 0.02,
 'Camera Slowdown': 0.7,
 'Show City Info': true
 };
 microCityFolder.add(microCityParams, 'Enabled').onChange(v => {
 if (!v) {
 microCityGroups.forEach(({ cityGroup }) => {
 cityGroup.visible = false;
 });
 }
 });
 microCityFolder.add(microCityParams, 'LOD Distance', 0.1, 3.0, 0.05);
 microCityFolder.add(microCityParams, 'Slowdown Distance', 0.02, 0.3, 0.01);
 microCityFolder.add(microCityParams, 'Fade Range', 0.1, 1.0, 0.05);
 microCityFolder.add(microCityParams, 'Building Scale', 0.002, 0.02, 0.001);
 microCityFolder.add(microCityParams, 'Building Density', 0.01, 0.05, 0.005);
 microCityFolder.add(microCityParams, 'Camera Slowdown', 0, 1, 0.05);
 microCityFolder.add(microCityParams, 'Show City Info');
 microCityParams['Force Show All Cities'] = () => {
 console.log('[MicroCity] Forcing all cities visible for debugging...');
 microCityGroups.forEach(({ cityGroup, key }) => {
 cityGroup.visible = true;
 cityGroup.scale.setScalar(1.0);
 console.log(` City on "${key.userData.label}": ${cityGroup.children.length} meshes at pos ${cityGroup.position.x.toFixed(2)}, ${cityGroup.position.y.toFixed(2)}, ${cityGroup.position.z.toFixed(2)}`);
 });
 };
 microCityFolder.add(microCityParams, 'Force Show All Cities');
 
 // Hands & Fingerprint folder (now moved to modal via Edit Hands button)
 const handsParams = {
 'Fingerprint Enabled': true,
 'Fingerprint Strength': 1.0,
 'Fingerprint Scale': 1.0,
 'Finger Spacing': 1.2,
 'Show Hands': true,
 'Right Hand Visible': true,
 'Left Hand Visible': true,
 'Show Voxel Wrap': false,
 'Voxel Wrap Style': 'Emerging',
 'Apply to Material': () => {
 if (window.applyFpToMaterial) window.applyFpToMaterial();
 },
 'Apply Spacing': () => {
 const spacing = handsParams['Finger Spacing'];
 // Update right hand static fingers
 if (rightHandGroup && rightHandGroup.children) {
 let fingerIndex = 0;
 rightHandGroup.children.forEach(child => {
 if (child.userData && child.userData.isStatic) {
 fingerIndex++;
 child.position.x = spacing * fingerIndex;
 child.userData.offsetX = spacing * fingerIndex;
 }
 });
 }
 // Update left hand static fingers
 if (leftHandGroup && leftHandGroup.children) {
 let fingerIndex = 0;
 leftHandGroup.children.forEach(child => {
 if (child.userData && child.userData.isLeftHand && child.position.x !== 0) {
 fingerIndex++;
 child.position.x = -spacing * fingerIndex;
 child.userData.offsetX = -spacing * fingerIndex;
 }
 });
 }
 alert(`Finger spacing updated to ${spacing.toFixed(2)}`);
 }
 };
 
 // Scene Objects Hierarchy removed from GUI - now accessible via Scene Browser modal
 
 // Store for animation loop
 window.guiParams = { scene: sceneParams, bust: bustParams, head: headParams, post: postParams, hands: handsParams, microCity: microCityParams };
 
 // ===== Button Handlers =====
 document.getElementById('btn-keyboard').addEventListener('click', jumpToKeyboard);
 document.getElementById('btn-character').addEventListener('click', jumpToCharacter);
 document.getElementById('btn-head').addEventListener('click', jumpToHead);
 document.getElementById('btn-overview').addEventListener('click', jumpToOverview);
 document.getElementById('btn-edit-character').addEventListener('click', () => {
 jumpToCharacter();
 enableEditMode();
 });
 
 document.getElementById('btn-sculpt-character').addEventListener('click', () => {
 jumpToCharacter();
 enableSculptMode();
 });
 
 // New button handlers
 document.getElementById('btn-edit-head').addEventListener('click', () => {
 document.getElementById('edit-head-modal').classList.add('active');
 syncHeadModalToParams();
 });
 
 document.getElementById('btn-edit-hands').addEventListener('click', () => {
 document.getElementById('edit-hands-modal').classList.add('active');
 if (!window.handsGUI) {
 createHandsGUI();
 }
 });
 
 document.getElementById('btn-scene-browser').addEventListener('click', () => {
 populateSceneBrowser();
 document.getElementById('scene-browser-modal').classList.add('active');
 });
 
 document.getElementById('btn-save-config').addEventListener('click', () => {
 populateConfigList();
 document.getElementById('save-config-modal').classList.add('active');
 });
 
 document.getElementById('btn-print-config').addEventListener('click', () => {
 generateConfigurationReport();
 document.getElementById('config-report-modal').classList.add('active');
 });
 
 // Scale Mode button
document.getElementById('btn-scale-mode').addEventListener('click', () => {
toggleScaleMode();
const statusEl = document.getElementById('scale-mode-state');
if (statusEl) {
statusEl.textContent = scaleModeEnabled ? 'Enabled' : 'Disabled';
statusEl.style.color = scaleModeEnabled ? '#4aff9c' : '#888';
}
});

// Drop button handlers (both 2D and 3D toolbars)
const dropBtn = document.getElementById('drop-btn');
if (dropBtn) {
dropBtn.addEventListener('click', () => {
console.log('[Drop] Drop button clicked (2D toolbar)');
dropPlayer();
});
}

const fullhandDropBtn = document.getElementById('fullhand-drop-btn');
if (fullhandDropBtn) {
fullhandDropBtn.addEventListener('click', () => {
console.log('[Drop] Drop button clicked (3D toolbar)');
dropPlayer();
});
}

// WASD controls for drop mode first-person movement
window.addEventListener('keydown', (e) => {
if (dropModeActive) {
const key = e.key.toLowerCase();
if (key === 'w') dropKeys.w = true;
if (key === 'a') dropKeys.a = true;
if (key === 's') dropKeys.s = true;
if (key === 'd') dropKeys.d = true;
if (key === 'shift') dropKeys.shift = true;
if (key === ' ') { dropKeys.space = true; e.preventDefault(); }
}
});

window.addEventListener('keyup', (e) => {
if (dropModeActive) {
const key = e.key.toLowerCase();
if (key === 'w') dropKeys.w = false;
if (key === 'a') dropKeys.a = false;
if (key === 's') dropKeys.s = false;
if (key === 'd') dropKeys.d = false;
if (key === 'shift') dropKeys.shift = false;
if (key === ' ') dropKeys.space = false;
}
});

// Debug menu minimize/restore
 const debugMenu = document.getElementById('debug-menu');
 const debugMenuMinimizeBtn = document.getElementById('debug-menu-minimize');
 const debugMenuRestoreBtn = document.getElementById('debug-menu-restore');
 
 debugMenuMinimizeBtn.addEventListener('click', () => {
 debugMenu.classList.add('minimized');
 debugMenuRestoreBtn.classList.add('visible');
 console.log('[DebugMenu] Menu minimized');
 });
 
 debugMenuRestoreBtn.addEventListener('click', () => {
 debugMenu.classList.remove('minimized');
 debugMenuRestoreBtn.classList.remove('visible');
 console.log('[DebugMenu] Menu restored');
 });
 
 // Raycaster for clicking buttons on frame
 const frameRaycaster = new THREE.Raycaster();
 const frameMouse = new THREE.Vector2();
 let currentSnapMode = 'free'; // Track snap mode
 
 renderer.domElement.addEventListener('click', (event) => {
 // Check if frame is visible
 if (!frameOfReference || !frameOfReference.visible) return;
 
 // Calculate mouse position in normalized device coordinates
 const rect = renderer.domElement.getBoundingClientRect();
 frameMouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
 frameMouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
 
 // Update raycaster
 frameRaycaster.setFromCamera(frameMouse, camera);
 
 // Check for intersection with minimize button
 if (minimizeButton && minimizeButton.circle) {
 const intersects = frameRaycaster.intersectObject(minimizeButton.circle, false);
 
 if (intersects.length > 0) {
 console.log('[FrameOfRef] Minimize button clicked!');
 toggleFrameMinimize();
 event.stopPropagation();
 return;
 }
 }
 
 // Check for intersection with gizmo buttons
 if (frameOfReference.userData.gizmoButtons) {
 const gizmoButtons = frameOfReference.userData.gizmoButtons;
 const buttonMeshes = gizmoButtons.map(b => b.button);
 const intersects = frameRaycaster.intersectObjects(buttonMeshes, false);
 
 if (intersects.length > 0) {
 const clickedButton = intersects[0].object;
 const mode = clickedButton.userData.mode;
 
 console.log(`[FrameOfRef] Gizmo button clicked: ${mode}`);
 
 // Animate button press
 animateButtonPress(clickedButton);
 
 // Handle snap mode separately (toggle through modes)
 if (mode === 'snap') {
 const snapModes = ['free', '45', '90'];
 const currentIndex = snapModes.indexOf(currentSnapMode);
 currentSnapMode = snapModes[(currentIndex + 1) % snapModes.length];
 
 if (currentSnapMode === 'free') {
 transformControl.setRotationSnap(null);
 transformControl.setTranslationSnap(null);
 console.log('[FrameOfRef] Snap: Free');
 } else if (currentSnapMode === '45') {
 transformControl.setRotationSnap(THREE.MathUtils.degToRad(45));
 transformControl.setTranslationSnap(0.5);
 console.log('[FrameOfRef] Snap: 45 ');
 } else if (currentSnapMode === '90') {
 transformControl.setRotationSnap(THREE.MathUtils.degToRad(90));
 transformControl.setTranslationSnap(1.0);
 console.log('[FrameOfRef] Snap: 90 ');
 }
 } else if (mode === 'sculpt') {
 // Enable sculpt mode
 enableSculptMode();
 console.log('[FrameOfRef] Sculpt mode activated');
 
 // Update active states
 gizmoButtons.forEach(({ button }) => {
 if (button.userData.mode === 'sculpt') {
 button.userData.isActive = true;
 button.material.emissiveIntensity = 0.5;
 } else if (button.userData.mode !== 'snap') {
 button.userData.isActive = false;
 button.material.emissiveIntensity = 0.2;
 }
 });
 } else {
 // Set transform mode (translate, rotate, scale)
 transformControl.setMode(mode);
 
 // Update active states
 gizmoButtons.forEach(({ button }) => {
 if (button.userData.mode === mode) {
 button.userData.isActive = true;
 button.material.emissiveIntensity = 0.5;
 } else if (button.userData.mode !== 'snap') {
 button.userData.isActive = false;
 button.material.emissiveIntensity = 0.2;
 }
 });
 }
 
 event.stopPropagation();
 }
 }
 });
 
 // Animate button depression
 function animateButtonPress(button) {
 const startZ = button.position.z;
 const targetZ = button.userData.pressedZ;
 const duration = 100; // ms
 const startTime = Date.now();
 
 // Find the corresponding label
 const gizmoButtons = frameOfReference.userData.gizmoButtons;
 const buttonData = gizmoButtons.find(b => b.button === button);
 const label = buttonData ? buttonData.label : null;
 const labelStartZ = label ? label.position.z : 0;
 const labelOffset = labelStartZ - startZ;
 
 function animateDown() {
 const elapsed = Date.now() - startTime;
 const progress = Math.min(elapsed / duration, 1);
 
 button.position.z = startZ - (startZ - targetZ) * progress;
 if (label) {
 label.position.z = button.position.z + labelOffset;
 }
 
 if (progress < 1) {
 requestAnimationFrame(animateDown);
 } else {
 // Animate back up
 const releaseStart = Date.now();
 function animateUp() {
 const elapsed = Date.now() - releaseStart;
 const progress = Math.min(elapsed / duration, 1);
 
 button.position.z = targetZ + (button.userData.baseZ - targetZ) * progress;
 if (label) {
 label.position.z = button.position.z + labelOffset;
 }
 
 if (progress < 1) {
 requestAnimationFrame(animateUp);
 }
 }
 animateUp();
 }
 }
 
 animateDown();
 }
 
 // Cursor sequence button and file input
 let cursorImageData = null;
 document.getElementById('btn-cursor-sequence').addEventListener('click', () => {
 document.getElementById('cursor-file-input').click();
 });
 
 document.getElementById('cursor-file-input').addEventListener('change', async (e) => {
 const file = e.target.files[0];
 if (!file) return;
 
 try {
 console.log('Processing uploaded hand image:', file.name);
 const img = await loadImageFromFile(file);
 console.log('Image loaded:', img.width, 'x', img.height);
 
 const gridData = toPixelGrid(img, 96);
 console.log('Grid data created:', gridData.width, 'x', gridData.height);
 
 const coords = posterizeAndExtract(gridData);
 console.log('Coordinates extracted:', coords);
 
 if(!coords.silhouette || coords.silhouette.length < 10){
 throw new Error('No hand detected. Make sure the image has a clear hand on white background.');
 }
 
 // Generate preview
 const previewDataURL = generatePreviewDataURL(coords);
 
 // Prompt for name
 const handName = prompt('Enter a name for this hand configuration:', `Hand ${Date.now()}`);
 if (handName) {
 saveHandConfig(handName, coords, previewDataURL);
 populateHandConfigSelect();
 alert(`Hand "${handName}" saved! You can spawn it later from the preview.`);
 }
 
 // Trigger the animation sequence with the new coords
 createVoxelCursorSequence(coords);
 
 console.log('Successfully processed and applied hand image');
 } catch(err) {
 console.error('Image processing error:', err);
 alert('Failed to process image: ' + err.message);
 }
 });
 
 // Save/Load hand configs from localStorage
 const HAND_CONFIGS_KEY = 'voxelHandConfigs';
 
 function saveHandConfig(name, coords, previewDataURL, stages = null) {
 const configs = JSON.parse(localStorage.getItem(HAND_CONFIGS_KEY) || '{}');
 
 // Generate stages if not provided
 if (!stages) {
 stages = generateAllStages(coords);
 }
 
 configs[name] = {
 coords: coords,
 preview: previewDataURL,
 stages: stages, // Store all 12 animation stages
 timestamp: Date.now()
 };
 localStorage.setItem(HAND_CONFIGS_KEY, JSON.stringify(configs));
 console.log(`[HandConfig] Saved hand config "${name}" with ${stages.length} stages`);
 }
 
 // Generate all 12 stage previews as data URLs with increasing resolution
 function generateAllStages(coords) {
 console.log(`[HandConfig] Generating stages for hand with ${coords.silhouette?.length || 0} silhouette pixels`);
 
 const { width: W, height: H, silhouette, outline, shade, highlight, colors } = coords;
 const baseCol = colors?.base || '#f3d2b4';
 const shadeCol = colors?.shade || '#d4b090';
 const outlineCol = colors?.outline || '#23160e';
 const hiCol = colors?.highlight || '#fff3e2';
 
 if (!silhouette || silhouette.length === 0) {
 console.error('[HandConfig] No silhouette data found - cannot generate stages!');
 return [];
 }
 
 // Create display and work canvases
 const displayCanvas = document.createElement('canvas');
 displayCanvas.width = W;
 displayCanvas.height = H;
 const displayCtx = displayCanvas.getContext('2d');
 displayCtx.imageSmoothingEnabled = false;
 
 const workCanvas = document.createElement('canvas');
 const workCtx = workCanvas.getContext('2d');
 workCtx.imageSmoothingEnabled = false;
 
 const stages = [];
 const totalStages = 12;
 const resolutionMap = { 
 0: 8, 1: 12, 2: 16, 3: 24, 4: 32, 5: 40, 
 6: 48, 7: 56, 8: 64, 9: 72, 10: 80, 11: 88, 12: 96 
 };
 
 for (let stage = 0; stage <= totalStages; stage++) {
 const resolution = resolutionMap[stage] || 96;
 const scale = W / resolution;
 
 // Resize work canvas
 workCanvas.width = resolution;
 workCanvas.height = resolution;
 workCtx.clearRect(0, 0, resolution, resolution);
 
 // Draw at lower resolution
 const px = (x, y, color) => {
 const scaledX = Math.floor(x / scale);
 const scaledY = Math.floor(y / scale);
 if (scaledX >= 0 && scaledX < resolution && scaledY >= 0 && scaledY < resolution) {
 workCtx.fillStyle = color;
 workCtx.fillRect(scaledX, scaledY, 1, 1);
 }
 };
 
 // Draw stage content
 if (stage >= 1) {
 const silAmount = Math.floor(silhouette.length * (stage / totalStages));
 for (let i = 0; i < silAmount; i++) {
 const [x, y] = silhouette[i];
 px(x, y, baseCol);
 }
 }
 
 if (stage >= 3 && shade && shade.length > 0) {
 const shadeAmount = Math.floor(shade.length * ((stage - 2) / (totalStages - 2)));
 for (let i = 0; i < shadeAmount; i++) {
 const [x, y] = shade[i];
 px(x, y, shadeCol);
 }
 }
 
 if (stage >= 10 && highlight && highlight.length > 0) {
 const hiAmount = Math.floor(highlight.length * ((stage - 9) / 3));
 for (let i = 0; i < hiAmount; i++) {
 const [x, y] = highlight[i];
 px(x, y, hiCol);
 }
 }
 
 if (stage >= 1 && outline && outline.length > 0) {
 const outAmount = Math.floor(outline.length * (stage / totalStages));
 for (let i = 0; i < outAmount; i++) {
 const [x, y] = outline[i];
 px(x, y, outlineCol);
 }
 }
 
 // Scale up to display canvas
 displayCtx.clearRect(0, 0, W, H);
 displayCtx.drawImage(workCanvas, 0, 0, resolution, resolution, 0, 0, W, H);
 
 const dataURL = displayCanvas.toDataURL();
 stages.push(dataURL);
 
 // Debug log for first few stages
 if (stage <= 2) {
 console.log(`[HandConfig] Stage ${stage}: ${resolution}x${resolution} resolution, ${stage >= 1 ? Math.floor(silhouette.length * (stage / totalStages)) : 0} pixels`);
 }
 }
 
 console.log(`[HandConfig] ? Generated ${stages.length} animation stages with progressive resolution (8x8 to 96x96)`);
 return stages;
 }
 
 function loadHandConfigs() {
 return JSON.parse(localStorage.getItem(HAND_CONFIGS_KEY) || '{}');
 }
 
 // Populate saved hand configs with previews
 function populateHandConfigSelect() {
 const configs = loadHandConfigs();
 const container = document.getElementById('hand-config-previews');
 if (!container) return;
 
 container.innerHTML = '';
 Object.keys(configs).forEach(name => {
 const config = configs[name];
 const div = document.createElement('div');
 div.style.cssText = 'display: inline-block; margin: 5px; padding: 5px; border: 1px solid #444; cursor: pointer; text-align: center; background: #222;';
 
 const img = document.createElement('img');
 img.src = config.preview;
 img.style.cssText = 'width: 48px; height: 48px; image-rendering: pixelated; display: block;';
 
 const label = document.createElement('div');
 label.textContent = name;
 label.style.cssText = 'font-size: 10px; margin-top: 2px; color: #fff;';
 
 div.appendChild(img);
 div.appendChild(label);
 div.onclick = () => {
 console.log(`[HandConfig] Spawning saved hand: ${name}`);
 console.log(`[HandConfig] Stages available: ${config.stages ? config.stages.length : 0}`);
 createVoxelCursorSequence(config.coords, config.stages);
 };
 
 container.appendChild(div);
 });
 }
 
 // Initialize saved hands on load
 populateHandConfigSelect();
 
 // ===== Full cursor.html extraction and animation sequence =====
 
 // ===== Image Processing Functions (from cursor.html) =====
 
 function loadImageFromFile(file){
 return new Promise((resolve, reject)=>{
 const url = URL.createObjectURL(file);
 const img = new Image();
 img.onload = ()=>{ URL.revokeObjectURL(url); resolve(img); };
 img.onerror = reject;
 img.src = url;
 });
 }
 
 function toPixelGrid(img, grid=96){
 const work = document.createElement('canvas');
 const wctx = work.getContext('2d', { willReadFrequently: true });
 const maxSide = Math.max(img.width, img.height);
 const sx = (img.width - img.height)/2;
 const sy = (img.height - img.width)/2;
 const sw = Math.min(img.width, img.height);
 const sh = sw;
 work.width = work.height = grid;
 wctx.imageSmoothingEnabled = false;
 wctx.clearRect(0,0,grid,grid);
 wctx.fillStyle = '#ffffff';
 wctx.fillRect(0, 0, grid, grid);
 wctx.drawImage(img, Math.max(0,sx), Math.max(0,sy), sw, sh, 0, 0, grid, grid);
 const data = wctx.getImageData(0,0,grid,grid);
 return data;
 }
 
 function posterizeAndExtract(data){
 const W = data.width, H = data.height, D = data.data;
 const isWhite = (r,g,b,a)=> a<250 || (r>240 && g>240 && b>240);
 const lum = (r,g,b)=> 0.2126*r + 0.7152*g + 0.0722*b;
 const toHex = (r,g,b)=> '#' + [r,g,b].map(v=>Math.round(v).toString(16).padStart(2,'0')).join('');

 const fg = new Array(H).fill(0).map(()=>new Array(W).fill(false));
 const L = new Array(H).fill(0).map(()=>new Array(W).fill(0));
 const colors = new Array(H).fill(0).map(()=>new Array(W).fill(null));

 for(let y=0; y<H; y++){
 for(let x=0; x<W; x++){
 const i = (y*W + x)*4; 
 const r=D[i], g=D[i+1], b=D[i+2], a=D[i+3];
 if(!isWhite(r,g,b,a)){
 fg[y][x] = true; 
 L[y][x] = lum(r,g,b);
 colors[y][x] = toHex(r,g,b);
 }
 }
 }
 
 let minL=255, maxL=0; 
 for(let y=0;y<H;y++) {
 for(let x=0;x<W;x++) {
 if(fg[y][x]){ 
 const v=L[y][x]; 
 if(v<minL)minL=v; 
 if(v>maxL)maxL=v; 
 }
 }
 }
 
 const t1 = minL + (maxL-minL)*0.35;
 const t2 = minL + (maxL-minL)*0.75;

 const baseColors=[], shadeColors=[], highlightColors=[], outlineColors=[];
 const silhouette=[], outline=[], shade=[], highlight=[];
 const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
 
 for(let y=0;y<H;y++){
 for(let x=0;x<W;x++){
 if(!fg[y][x]) continue;
 const col = colors[y][x];
 silhouette.push([x,y]);
 baseColors.push(col);
 
 const lv = L[y][x];
 if(lv <= t1) { 
 shade.push([x,y]); 
 shadeColors.push(col);
 } else if(lv >= t2) { 
 highlight.push([x,y]);
 highlightColors.push(col);
 }
 
 let border=false; 
 for(const [dx,dy] of dirs){ 
 const nx=x+dx, ny=y+dy; 
 if(nx<0||ny<0||nx>=W||ny>=H||!fg[ny][nx]){ 
 border=true; 
 break; 
 } 
 }
 if(border) {
 outline.push([x,y]);
 outlineColors.push(col);
 }
 }
 }
 
 const avgColor = (cols) => {
 if(!cols.length) return '#000000';
 let r=0,g=0,b=0;
 for(const c of cols){
 r += parseInt(c.substr(1,2), 16);
 g += parseInt(c.substr(3,2), 16);
 b += parseInt(c.substr(5,2), 16);
 }
 return toHex(r/cols.length, g/cols.length, b/cols.length);
 };
 
 const avgBase = avgColor(baseColors);
 const avgShade = avgColor(shadeColors.length ? shadeColors : baseColors);
 const avgHighlight = avgColor(highlightColors.length ? highlightColors : baseColors);
 const avgOutline = avgColor(outlineColors.length ? outlineColors : baseColors);
 
 let minY=Infinity; 
 for(const [x,y] of silhouette){ 
 if(y<minY) minY=y; 
 }
 const topXs = silhouette.filter(([x,y])=>y===minY).map(([x])=>x).sort((a,b)=>a-b);
 const hotspot = { 
 x: topXs.length? topXs[Math.floor(topXs.length/2)] : Math.floor(W/2), 
 y: (minY===Infinity? Math.floor(H*0.1) : minY) 
 };
 
 console.log(`Extracted: ${silhouette.length} silhouette, ${outline.length} outline, ${shade.length} shade, ${highlight.length} highlight pixels`);

 return { width:W, height:H, silhouette, outline, shade, highlight, hotspot, colors: { base: avgBase, shade: avgShade, highlight: avgHighlight, outline: avgOutline } };
 }
 
 function generatePreviewDataURL(coords) {
 const canvas = document.createElement('canvas');
 canvas.width = coords.width;
 canvas.height = coords.height;
 const ctx = canvas.getContext('2d');
 ctx.imageSmoothingEnabled = false;
 
 const px = (x, y, color) => {
 ctx.fillStyle = color;
 ctx.fillRect(x, y, 1, 1);
 };
 
 coords.silhouette.forEach(([x,y]) => px(x, y, coords.colors.base));
 coords.shade.forEach(([x,y]) => px(x, y, coords.colors.shade));
 coords.highlight.forEach(([x,y]) => px(x, y, coords.colors.highlight));
 coords.outline.forEach(([x,y]) => px(x, y, coords.colors.outline));
 
 return canvas.toDataURL();
 }
 
 // Default hand coordinates (from cursor.html)
 const defaultHandCoords = {
 "width": 96,
 "height": 96,
 "silhouette": [[47,10],[48,10],[46,11],[47,11],[48,11],[44,12],[46,12],[47,12],[48,12],[51,12],[52,12],[43,13],[44,13],[46,13],[47,13],[48,13],[50,13],[51,13],[52,13],[43,14],[44,14],[46,14],[47,14],[48,14],[50,14],[51,14],[52,14],[43,15],[44,15],[45,15],[46,15],[47,15],[48,15],[50,15],[51,15],[52,15],[43,16],[44,16],[45,16],[46,16],[47,16],[48,16],[50,16],[51,16],[52,16],[54,16],[55,16],[43,17],[44,17],[45,17],[46,17],[47,17],[48,17],[50,17],[51,17],[52,17],[54,17],[55,17],[43,18],[44,18],[45,18],[46,18],[47,18],[48,18],[50,18],[51,18],[52,18],[54,18],[55,18],[43,19],[44,19],[45,19],[46,19],[47,19],[48,19],[50,19],[51,19],[52,19],[54,19],[55,19],[44,20],[45,20],[46,20],[47,20],[48,20],[50,20],[51,20],[52,20],[54,20],[55,20],[44,21],[45,21],[46,21],[47,21],[48,21],[50,21],[51,21],[53,21],[54,21],[55,21],[44,22],[45,22],[46,22],[47,22],[48,22],[49,22],[50,22],[51,22],[53,22],[54,22],[55,22],[45,23],[46,23],[47,23],[48,23],[49,23],[50,23],[51,23],[53,23],[54,23],[55,23],[45,24],[46,24],[47,24],[48,24],[49,24],[50,24],[51,24],[52,24],[53,24],[54,24],[42,25],[43,25],[44,25],[45,25],[46,25],[47,25],[48,25],[49,25],[50,25],[51,25],[52,25],[53,25],[54,25],[42,26],[43,26],[44,26],[45,26],[46,26],[47,26],[48,26],[49,26],[50,26],[51,26],[52,26],[53,26],[54,26],[43,27],[44,27],[45,27],[46,27],[47,27],[48,27],[49,27],[50,27],[51,27],[52,27],[53,27],[54,27],[55,27],[43,28],[44,28],[45,28],[46,28],[47,28],[48,28],[49,28],[50,28],[51,28],[52,28],[53,28],[54,28],[55,28],[44,29],[45,29],[46,29],[47,29],[48,29],[49,29],[50,29],[51,29],[52,29],[53,29],[54,29],[44,30],[45,30],[46,30],[47,30],[48,30],[49,30],[50,30],[51,30],[52,30],[53,30],[54,30],[55,30],[45,31],[46,31],[47,31],[48,31],[49,31],[50,31],[51,31],[52,31],[53,31],[54,31],[55,31],[46,32],[47,32],[48,32],[49,32],[50,32],[51,32],[52,32],[53,32],[54,32],[55,32],[47,33],[48,33],[49,33],[50,33],[51,33],[52,33],[53,33],[54,33],[55,33],[48,34],[49,34],[50,34],[51,34],[52,34],[53,34],[54,34],[55,34],[48,35],[49,35],[50,35],[51,35],[52,35],[53,35],[54,35],[55,35],[48,36],[49,36],[50,36],[51,36],[52,36],[53,36],[54,36],[55,36],[49,37],[50,37],[51,37],[52,37],[53,37],[54,37],[55,37],[50,38],[51,38],[52,38],[53,38],[54,38],[55,38],[51,39],[52,39],[53,39],[54,39],[55,39],[52,40],[53,40],[54,40],[55,40]],
 "outline": [[47,10],[48,10],[46,11],[48,11],[44,12],[46,12],[48,12],[51,12],[52,12],[43,13],[44,13],[46,13],[48,13],[50,13],[52,13],[43,14],[44,14],[46,14],[48,14],[50,14],[52,14],[43,15],[45,15],[46,15],[48,15],[50,15],[52,15],[43,16],[45,16],[46,16],[48,16],[50,16],[52,16],[54,16],[55,16],[43,17],[45,17],[46,17],[48,17],[50,17],[52,17],[54,17],[55,17],[43,18],[45,18],[46,18],[48,18],[50,18],[52,18],[54,18],[55,18],[43,19],[46,19],[48,19],[50,19],[52,19],[54,19],[55,19],[44,20],[46,20],[48,20],[50,20],[52,20],[54,20],[55,20],[44,21],[46,21],[48,21],[50,21],[51,21],[53,21],[55,21],[44,22],[47,22],[49,22],[51,22],[53,22],[55,22],[45,23],[51,23],[53,23],[55,23],[45,24],[52,24],[54,24],[42,25],[43,25],[44,25],[45,25],[54,25],[42,26],[44,26],[45,26],[54,26],[43,27],[44,27],[45,27],[55,27],[43,28],[46,28],[55,28],[44,29],[46,29],[54,29],[44,30],[46,30],[55,30],[45,31],[46,31],[55,31],[46,32],[55,32],[47,33],[55,33],[48,34],[55,34],[48,35],[55,35],[48,36],[55,36],[49,37],[55,37],[50,38],[55,38],[51,39],[55,39],[52,40],[54,40],[55,40]],
 "shade": [[43,15],[45,16],[54,16],[47,18],[54,18],[44,19],[46,19],[46,20],[53,21],[44,22],[49,22],[49,23],[45,24],[43,25],[44,25],[42,26],[43,26],[44,26],[43,27],[44,27],[46,27],[43,28],[45,28],[46,28],[44,29],[45,29],[46,29],[44,30],[45,30],[46,30],[45,31],[46,31],[46,32],[47,33],[48,34],[48,35],[49,36],[50,37],[51,38],[51,39],[52,40]],
 "highlight": [[44,12],[50,13],[45,15],[43,19],[46,19],[46,21],[47,22],[55,27],[44,28],[55,28],[45,31],[48,36]],
 "hotspot": {"x": 48, "y": 10},
 "colors": { "base": "#f3d2b4", "shade": "#d4b090", "highlight": "#fff3e2", "outline": "#23160e" }
 };
 
 function createBeveledCubeGeometry(size, bevel) {
 const geometry = new THREE.BoxGeometry(size * (1 - bevel), size * (1 - bevel), size * (1 - bevel));
 return geometry;
 }
 
 function buildVoxelHandFromCoords(coords, fingerAnim = 0) {
 const { width: W, height: H, silhouette, outline, shade, highlight, colors } = coords;
 const baseCol = colors?.base || '#f3d2b4';
 const shadeCol = colors?.shade || '#d4b090';
 const outlineCol = colors?.outline || '#23160e';
 const hiCol = colors?.highlight || '#fff3e2';

 const voxelHandGroup = new THREE.Group();
 voxelHandGroup.name = "Voxel Cursor Hand";
 
 const voxelSize = 0.02;
 const bevelAmount = 0.15;
 const thicknessLayers = 8;
 
 let coordsToRender = [];
 silhouette.forEach(c => coordsToRender.push([...c, baseCol]));
 shade.forEach(c => coordsToRender.push([...c, shadeCol]));
 if (highlight && highlight.length > 0) {
 highlight.forEach(c => coordsToRender.push([...c, hiCol]));
 }
 outline.forEach(c => coordsToRender.push([...c, outlineCol]));

 // Create a lookup set for checking neighbors
 const voxelSet = new Set();
 coordsToRender.forEach(([x, y, color]) => {
 for (let z = 0; z < thicknessLayers; z++) {
 voxelSet.add(`${x},${y},${z}`);
 }
 });
 
 // Function to check if a voxel should be removed for beveling
 function shouldBevelVoxel(x, y, z) {
 // Check the 6 direct face neighbors (up, down, left, right, front, back)
 const faceNeighbors = [
 voxelSet.has(`${x+1},${y},${z}`),
 voxelSet.has(`${x-1},${y},${z}`),
 voxelSet.has(`${x},${y+1},${z}`),
 voxelSet.has(`${x},${y-1},${z}`),
 voxelSet.has(`${x},${y},${z+1}`),
 voxelSet.has(`${x},${y},${z-1}`)
 ];
 const faceFilled = faceNeighbors.filter(n => n).length;
 
 // Check diagonal edge neighbors (12 edges of cube)
 const edgeNeighbors = [
 voxelSet.has(`${x+1},${y+1},${z}`),
 voxelSet.has(`${x+1},${y-1},${z}`),
 voxelSet.has(`${x-1},${y+1},${z}`),
 voxelSet.has(`${x-1},${y-1},${z}`),
 voxelSet.has(`${x+1},${y},${z+1}`),
 voxelSet.has(`${x+1},${y},${z-1}`),
 voxelSet.has(`${x-1},${y},${z+1}`),
 voxelSet.has(`${x-1},${y},${z-1}`),
 voxelSet.has(`${x},${y+1},${z+1}`),
 voxelSet.has(`${x},${y+1},${z-1}`),
 voxelSet.has(`${x},${y-1},${z+1}`),
 voxelSet.has(`${x},${y-1},${z-1}`)
 ];
 const edgeFilled = edgeNeighbors.filter(n => n).length;
 
 // Check corner neighbors (8 corners of cube)
 const cornerNeighbors = [
 voxelSet.has(`${x+1},${y+1},${z+1}`),
 voxelSet.has(`${x+1},${y+1},${z-1}`),
 voxelSet.has(`${x+1},${y-1},${z+1}`),
 voxelSet.has(`${x+1},${y-1},${z-1}`),
 voxelSet.has(`${x-1},${y+1},${z+1}`),
 voxelSet.has(`${x-1},${y+1},${z-1}`),
 voxelSet.has(`${x-1},${y-1},${z+1}`),
 voxelSet.has(`${x-1},${y-1},${z-1}`)
 ];
 const cornerFilled = cornerNeighbors.filter(n => n).length;
 
 // Aggressive beveling strategy for smoother, more rounded appearance:
 // - Remove multiple layers of surface voxels
 // - Create smooth curves by removing edge and corner voxels
 
 // Remove voxels with less than 4 face neighbors (more aggressive than before)
 if (faceFilled < 4) return true;
 
 // Remove sharp edges - if missing any face neighbor and few edge neighbors
 if (faceFilled < 6 && edgeFilled < 8) return true;
 
 // Remove corner voxels more aggressively
 if (faceFilled === 4 && edgeFilled < 9) return true;
 
 // Remove voxels that form sharp corners
 const totalNeighbors = faceFilled + edgeFilled + cornerFilled;
 if (totalNeighbors < 15) return true;
 
 // Secondary pass: remove additional edge voxels for smoother curves
 if (faceFilled === 5 && edgeFilled < 10 && cornerFilled < 6) return true;
 
 return false;
 }

 const colorGroups = {};
 let totalVoxels = 0;
 let beveledVoxels = 0;
 
 coordsToRender.forEach(([x, y, color]) => {
 if (!colorGroups[color]) colorGroups[color] = [];
 for (let z = 0; z < thicknessLayers; z++) {
 totalVoxels++;
 // Apply beveling - skip voxels that should be removed
 if (!shouldBevelVoxel(x, y, z)) {
 colorGroups[color].push({ x, y, z });
 } else {
 beveledVoxels++;
 }
 }
 });
 
 const remainingVoxels = totalVoxels - beveledVoxels;
 console.log(`[VoxelHand] Beveling applied: Removed ${beveledVoxels} of ${totalVoxels} voxels (${((beveledVoxels/totalVoxels)*100).toFixed(1)}%) for rounded edges`);
 console.log(`[VoxelHand] Remaining voxels: ${remainingVoxels}`);

 const cubeGeometry = createBeveledCubeGeometry(voxelSize, bevelAmount);

 Object.entries(colorGroups).forEach(([color, positions]) => {
 const instancedMesh = new THREE.InstancedMesh(
 cubeGeometry,
 new THREE.MeshStandardMaterial({ 
 color: color,
 metalness: 0.1,
 roughness: 0.6
 }),
 positions.length
 );

 const matrix = new THREE.Matrix4();
 positions.forEach((pos, i) => {
 const px = (pos.x - W/2) * voxelSize;
 const py = (pos.z) * voxelSize;
 const pz = (pos.y - H/2) * voxelSize;
 
 matrix.makeTranslation(px, py, pz);
 instancedMesh.setMatrixAt(i, matrix);
 });
 
 instancedMesh.instanceMatrix.needsUpdate = true;
 instancedMesh.castShadow = true;
 instancedMesh.receiveShadow = true;
 voxelHandGroup.add(instancedMesh);
 });

 const baseHeight = voxelSize * thicknessLayers * 2.5 / 2;
 voxelHandGroup.position.set(0, baseHeight, 0);
 voxelHandGroup.scale.setScalar(2.5);
 
 return voxelHandGroup;
 }
 
 function animateVoxelHandPopIn(voxelHandGroup) {
 const targetScale = 2.5;
 const baseHeight = 0.02 * 8 * 2.5 / 2;
 voxelHandGroup.scale.setScalar(0.01);
 voxelHandGroup.position.y = baseHeight;
 
 const startTime = Date.now();
 const popDuration = 600;
 
 function animatePop() {
 const elapsed = Date.now() - startTime;
 const progress = Math.min(elapsed / popDuration, 1);
 
 const c4 = (2 * Math.PI) / 3;
 const easeOut = progress === 1 ? 1 : Math.pow(2, -10 * progress) * Math.sin((progress * 10 - 0.75) * c4) + 1;
 
 voxelHandGroup.scale.setScalar(0.01 + easeOut * (targetScale - 0.01));
 
 const bounce = Math.sin(progress * Math.PI) * 0.3;
 voxelHandGroup.position.y = baseHeight + bounce;
 
 if (progress < 1) {
 requestAnimationFrame(animatePop);
 } else {
 voxelHandGroup.position.y = baseHeight;
 }
 }
 animatePop();
 }
 
 // Voxel cursor creation sequence with progressive 2D-to-3D evolution
 function createVoxelCursorSequence(coordsOrImageData, storedStages = null) {
 // Start cursor glitch effect for this spawning sequence
 console.log('[CursorGlitch] Starting cursor glitch for hand spawn');
 startCursorGlitch();
 
 // Don't hide the scene - we want to see the animation happen in real-time
 // Just ensure the sprite is front and center
 
 // If passed coords object, use it. Otherwise use default.
 const coords = (coordsOrImageData && coordsOrImageData.width) ? coordsOrImageData : defaultHandCoords;
 const { width: W, height: H, silhouette, outline, shade, highlight, colors } = coords;
 const baseCol = colors?.base || '#f3d2b4';
 const shadeCol = colors?.shade || '#d4b090';
 const outlineCol = colors?.outline || '#23160e';
 const hiCol = colors?.highlight || '#fff3e2';
 
 console.log(`[VoxelHand] Using ${storedStages ? 'stored' : 'generated'} stages`);
 
 // Create display canvas at full resolution
 const displayCanvas = document.createElement('canvas');
 displayCanvas.width = W;
 displayCanvas.height = H;
 const displayCtx = displayCanvas.getContext('2d');
 displayCtx.imageSmoothingEnabled = false;
 
 // Create work canvas that changes size per stage
 const workCanvas = document.createElement('canvas');
 const workCtx = workCanvas.getContext('2d');
 workCtx.imageSmoothingEnabled = false;
 
 // Create sprite material with high render order to appear on top
 const texture = new THREE.CanvasTexture(displayCanvas);
 texture.minFilter = THREE.NearestFilter;
 texture.magFilter = THREE.NearestFilter;
 
 const spriteMat = new THREE.SpriteMaterial({ 
 map: texture, 
 transparent: true,
 depthWrite: false,
 depthTest: false
 });
 const sprite = new THREE.Sprite(spriteMat);
 
 // Track mouse cursor position for sprite placement
 let mouseX = 0;
 let mouseY = 0;
 const initialDistance = 0.5; // Very close - replacing cursor
 
 // Get current mouse position (or center if not available)
 const getCurrentMousePosition = () => {
 return { x: mouseX, y: mouseY };
 };
 
 // Mouse tracking listener
 const mouseMoveHandler = (event) => {
 mouseX = (event.clientX / window.innerWidth) * 2 - 1;
 mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
 };
 window.addEventListener('mousemove', mouseMoveHandler);
 
 // Function to update sprite position based on mouse
 const updateSpritePosition = (pushDistance = 0) => {
 const mouse = getCurrentMousePosition();
 const raycaster = new THREE.Raycaster();
 raycaster.setFromCamera(new THREE.Vector2(mouse.x, mouse.y), camera);
 
 // Position at a fixed distance from camera in the direction of the mouse
 const direction = raycaster.ray.direction.clone().normalize();
 const distance = initialDistance + pushDistance;
 sprite.position.copy(camera.position).add(direction.multiplyScalar(distance));
 };
 
 // Initial position at cursor
 updateSpritePosition(0);
 
 sprite.scale.set(0.15, 0.15, 1); // Start very small, like a cursor
 sprite.renderOrder = 10000; // Render on top of everything
 scene.add(sprite);
 
 console.log(`[VoxelHand] Construction sequence starting at cursor position`);
 console.log(`[VoxelHand] Tracking mouse cursor and will push back as it grows`);
 
 // Progressive 12-stage evolution with increasing resolution
 let currentStage = 0;
 const totalStages = 12;
 // Resolution scales from 8x8 to full 96x96
 const resolutionMap = { 
 0: 8, 1: 12, 2: 16, 3: 24, 4: 32, 5: 40, 
 6: 48, 7: 56, 8: 64, 9: 72, 10: 80, 11: 88, 12: 96 
 };
 
 function drawStage(stage) {
 // Get resolution for this stage
 const resolution = resolutionMap[stage] || 96;
 const scale = W / resolution;
 
 // Resize work canvas to stage resolution
 workCanvas.width = resolution;
 workCanvas.height = resolution;
 workCtx.clearRect(0, 0, resolution, resolution);
 
 // Draw at lower resolution
 const px = (x, y, color) => {
 const scaledX = Math.floor(x / scale);
 const scaledY = Math.floor(y / scale);
 if (scaledX >= 0 && scaledX < resolution && scaledY >= 0 && scaledY < resolution) {
 workCtx.fillStyle = color;
 workCtx.fillRect(scaledX, scaledY, 1, 1);
 }
 };
 
 // Progressive reveal based on stage - BOTTOM TO TOP (fingers to wrist)
 // Sort by Y coordinate descending (higher Y values = fingertips at bottom of image)
 const sortedSilhouette = silhouette.slice().sort((a, b) => b[1] - a[1]);
 const sortedShade = shade ? shade.slice().sort((a, b) => b[1] - a[1]) : [];
 const sortedHighlight = highlight ? highlight.slice().sort((a, b) => b[1] - a[1]) : [];
 const sortedOutline = outline ? outline.slice().sort((a, b) => b[1] - a[1]) : [];
 
 if (stage >= 1) {
 const silAmount = Math.floor(sortedSilhouette.length * (stage / totalStages));
 for (let i = 0; i < silAmount; i++) {
 const [x, y] = sortedSilhouette[i];
 px(x, y, baseCol);
 }
 }
 
 if (stage >= 3 && sortedShade.length > 0) {
 const shadeAmount = Math.floor(sortedShade.length * ((stage - 2) / (totalStages - 2)));
 for (let i = 0; i < shadeAmount; i++) {
 const [x, y] = sortedShade[i];
 px(x, y, shadeCol);
 }
 }
 
 if (stage >= 10 && sortedHighlight.length > 0) {
 const hiAmount = Math.floor(sortedHighlight.length * ((stage - 9) / 3));
 for (let i = 0; i < hiAmount; i++) {
 const [x, y] = sortedHighlight[i];
 px(x, y, hiCol);
 }
 }
 
 if (stage >= 1 && sortedOutline.length > 0) {
 const outAmount = Math.floor(sortedOutline.length * (stage / totalStages));
 for (let i = 0; i < outAmount; i++) {
 const [x, y] = sortedOutline[i];
 px(x, y, outlineCol);
 }
 }
 
 // Scale up work canvas to display canvas (pixelated upscaling)
 displayCtx.clearRect(0, 0, W, H);
 displayCtx.imageSmoothingEnabled = false;
 displayCtx.drawImage(workCanvas, 0, 0, resolution, resolution, 0, 0, W, H);
 
 texture.needsUpdate = true;
 
 // Animate sprite size and Z position as it grows
 const stageProgress = stage / totalStages;
 const finalScale = 3.5;
 const finalPushDistance = 2.5; // How far to push away from initial position
 const currentScale = 0.15 + (finalScale - 0.15) * stageProgress;
 currentPushDistance = finalPushDistance * stageProgress;
 
 // Update sprite scale
 sprite.scale.set(currentScale, currentScale, 1);
 
 console.log(`[VoxelHand] Stage ${stage}: ${resolution}x${resolution}, scale ${currentScale.toFixed(2)}, push ${currentPushDistance.toFixed(2)}`);
 }
 
 console.log('[VoxelHand] Starting voxel cursor sequence with 12 stages...');
 
 // Continuous tracking: update sprite position every frame
 let isSequenceActive = true;
 let currentPushDistance = 0;
 const trackingLoop = () => {
 if (isSequenceActive && sprite.parent) {
 updateSpritePosition(currentPushDistance);
 requestAnimationFrame(trackingLoop);
 }
 };
 trackingLoop();
 
 // If we have stored stages, use them directly
 if (storedStages && storedStages.length >= 13) {
 console.log(`[VoxelHand] Using ${storedStages.length} pre-generated stages from storage`);
 
 // Create an image to load stage data
 const stageImage = new Image();
 let currentStageIdx = 0;
 
 function loadNextStage() {
 if (currentStageIdx < storedStages.length && currentStageIdx <= totalStages) {
 stageImage.onload = () => {
 // Draw the stage image to canvas
 displayCtx.clearRect(0, 0, W, H);
 displayCtx.drawImage(stageImage, 0, 0, W, H);
 texture.needsUpdate = true;
 
 // Animate sprite size and Z position as it grows (same as generated stages)
 const stage = currentStageIdx;
 const stageProgress = stage / totalStages;
 const finalScale = 3.5;
 const finalPushDistance = 2.5;
 const currentScale = 0.15 + (finalScale - 0.15) * stageProgress;
 currentPushDistance = finalPushDistance * stageProgress;
 
 sprite.scale.set(currentScale, currentScale, 1);
 
 console.log(`[VoxelHand] Loaded stored stage ${currentStageIdx}/${totalStages}`);
 currentStageIdx++;
 
 if (currentStageIdx <= totalStages) {
 setTimeout(loadNextStage, 200);
 } else {
 // All stages complete
 setTimeout(finishSequence, 800);
 }
 };
 stageImage.src = storedStages[currentStageIdx];
 }
 }
 
 loadNextStage();
 
 } else {
 // Generate stages on the fly
 console.log('[VoxelHand] Generating stages on the fly');
 
 // Draw initial stage 0 (empty)
 drawStage(0);
 
 // Animate through stages
 const stageInterval = setInterval(() => {
 currentStage++;
 console.log(`[VoxelHand] Drawing stage ${currentStage}/${totalStages}`);
 drawStage(currentStage);
 
 if (currentStage >= totalStages) {
 clearInterval(stageInterval);
 setTimeout(finishSequence, 800);
 }
 }, 200);
 }
 
 // Shared finish function
 function finishSequence() {
 console.log('[VoxelHand] All 2D stages complete, transitioning to 3D...');
 
 // Stop tracking loop
 isSequenceActive = false;
 
 // Clean up mouse tracking
 window.removeEventListener('mousemove', mouseMoveHandler);
 
 // Store sprite position for continuity
 const spritePosition = sprite.position.clone();
 
 // Remove sprite
 scene.remove(sprite);
 spriteMat.dispose();
 texture.dispose();
 
 // Build full resolution voxel hand
 console.log('[VoxelHand] Building 3D voxel hand with beveled edges...');
 const voxelHandGroup = buildVoxelHandFromCoords(coords);
 
 // Position voxel hand at the same location as the sprite was
 voxelHandGroup.position.copy(spritePosition);
 
 // Face the camera
 voxelHandGroup.lookAt(camera.position);
 voxelHandGroup.rotateY(Math.PI);
 
 scene.add(voxelHandGroup);
 animateVoxelHandPopIn(voxelHandGroup);
 
 console.log(`[VoxelHand] 3D voxel hand spawned at: (${voxelHandGroup.position.x.toFixed(2)}, ${voxelHandGroup.position.y.toFixed(2)}, ${voxelHandGroup.position.z.toFixed(2)})`);
 
 // Slowly rotate voxel hand continuously
 function rotateVoxelHand() {
 if (voxelHandGroup && voxelHandGroup.parent) {
 voxelHandGroup.rotation.y += 0.005;
 requestAnimationFrame(rotateVoxelHand);
 }
 }
 rotateVoxelHand();
 
 // Stop cursor glitch after hand is spawned
 console.log('[CursorGlitch] Stopping cursor glitch - hand spawn complete');
 stopCursorGlitch();
 
 console.log('[VoxelHand] ? Voxel cursor sequence complete!');
 }
 }
 
 // ===== Configuration Management =====
 function saveConfiguration() {
 const name = document.getElementById('config-name-input').value.trim() || 'Unnamed Configuration';
 const config = getCurrentConfiguration();
 const configs = JSON.parse(localStorage.getItem('sceneConfigurations') || '{}');
 configs[name] = config;
 localStorage.setItem('sceneConfigurations', JSON.stringify(configs));
 alert(`Configuration "${name}" saved!`);
 populateConfigList();
 }
 
 function saveAsConfiguration() {
 const name = document.getElementById('config-name-input').value.trim();
 if (!name) {
 alert('Please enter a configuration name');
 return;
 }
 saveConfiguration();
 }
 
 function loadConfiguration(name) {
 const configs = JSON.parse(localStorage.getItem('sceneConfigurations') || '{}');
 const config = configs[name];
 if (config) {
 applyConfiguration(config);
 alert(`Configuration "${name}" loaded!`);
 }
 }
 
 function getCurrentConfiguration() {
 return {
 camera: {
 position: camera.position.toArray(),
 target: controls.target.toArray(),
 fov: camera.fov
 },
 scene: window.guiParams.scene,
 bust: window.guiParams.bust,
 head: window.guiParams.head,
 post: window.guiParams.post,
 hands: window.guiParams.hands,
 lighting: {
 ambient: al.intensity,
 hemisphere: hl.intensity,
 directional: dl.intensity,
 spot: spotLight.intensity,
 rim: rimLight.intensity
 }
 };
 }
 
 function applyConfiguration(config) {
 if (config.camera) {
 camera.position.fromArray(config.camera.position);
 controls.target.fromArray(config.camera.target);
 camera.fov = config.camera.fov;
 camera.updateProjectionMatrix();
 controls.update();
 }
 if (config.lighting) {
 al.intensity = config.lighting.ambient;
 hl.intensity = config.lighting.hemisphere;
 dl.intensity = config.lighting.directional;
 spotLight.intensity = config.lighting.spot;
 rimLight.intensity = config.lighting.rim;
 }
 // Apply other settings...
 Object.assign(window.guiParams.scene, config.scene || {});
 Object.assign(window.guiParams.head, config.head || {});
 Object.assign(window.guiParams.hands, config.hands || {});
 }
 
 function populateConfigList() {
 const select = document.getElementById('config-list-select');
 select.innerHTML = '';
 const configs = JSON.parse(localStorage.getItem('sceneConfigurations') || '{}');
 Object.keys(configs).forEach(name => {
 const option = document.createElement('option');
 option.value = name;
 option.textContent = name;
 select.appendChild(option);
 });
 select.ondblclick = () => {
 if (select.value) loadConfiguration(select.value);
 };
 }
 
 // ===== Scene Browser =====
 function populateSceneBrowser() {
 const container = document.getElementById('scene-browser-content');
 container.innerHTML = '';
 
 const objects = [
 { name: 'Hands', obj: handsGroup },
 { name: '+- Right Hand', obj: rightHandGroup },
 { name: '+- Left Hand', obj: leftHandGroup },
 { name: 'Celli Avatar', obj: celliAvatarGroup },
 { name: '+- Celli Body', obj: characterGroup },
 { name: '+- Celli Head', obj: voxelHeadGroup },
 { name: 'Keyboard', obj: keyboardGroup }
 ];
 
 objects.forEach(item => {
 const div = document.createElement('div');
 div.className = 'hierarchy-item';
 div.textContent = item.name;
 div.onclick = () => {
 document.querySelectorAll('.hierarchy-item').forEach(el => el.classList.remove('selected'));
 div.classList.add('selected');
 if (item.obj && transformControl) {
 transformControl.attach(item.obj);
 }
 };
 container.appendChild(div);
 });
 }
 
 // ===== Configuration Report =====
 function generateConfigurationReport() {
 const content = document.getElementById('config-report-content');
 const config = getCurrentConfiguration();
 
 // Helper to format position and rotation
 const formatVec3 = (v) => `[${v.x.toFixed(3)}, ${v.y.toFixed(3)}, ${v.z.toFixed(3)}]`;
 const formatRot = (r) => `[${(r.x * 180 / Math.PI).toFixed(1)} , ${(r.y * 180 / Math.PI).toFixed(1)} , ${(r.z * 180 / Math.PI).toFixed(1)} ]`;
 
 let report = '=== SCENE CONFIGURATION REPORT ===\n\n';
 
 // Camera and Lighting
 report += '?? Current State:\n';
 report += `Camera FOV: ${config.camera.fov.toFixed(1)} \n`;
 report += `Camera Position: [${config.camera.position.map(v => v.toFixed(2)).join(', ')}]\n`;
 report += `Ambient Light: ${config.lighting.ambient.toFixed(2)}\n`;
 report += `Spot Light: ${config.lighting.spot.toFixed(2)}\n\n`;
 
 // Scene Object Transforms
 report += '?? Scene Object Transforms:\n\n';
 
 if (handsGroup) {
 report += '? Hands Group:\n';
 report += ` Position: ${formatVec3(handsGroup.position)}\n`;
 report += ` Rotation: ${formatRot(handsGroup.rotation)}\n`;
 report += ` Scale: ${handsGroup.scale.x.toFixed(3)}\n`;
 report += ` Visible: ${handsGroup.visible}\n\n`;
 
 if (rightHandGroup) {
 report += ' ? Right Hand Group:\n';
 report += ` Position: ${formatVec3(rightHandGroup.position)}\n`;
 report += ` Rotation: ${formatRot(rightHandGroup.rotation)}\n`;
 report += ` Scale: ${rightHandGroup.scale.x.toFixed(3)}\n`;
 report += ` Visible: ${rightHandGroup.visible}\n`;
 report += ` Children: ${rightHandGroup.children.length}\n`;
 if (finger && rightHandGroup.children.includes(finger)) {
 report += ` +- Main Finger: pos ${formatVec3(finger.position)}, rot ${formatRot(finger.rotation)}\n`;
 }
 rightHandGroup.children.forEach((child, i) => {
 if (child !== finger && child.userData && child.userData.isStaticFinger) {
 report += ` +- Static Finger ${i}: pos ${formatVec3(child.position)}\n`;
 }
 });
 report += '\n';
 }
 
 if (leftHandGroup) {
 report += ' ? Left Hand Group:\n';
 report += ` Position: ${formatVec3(leftHandGroup.position)}\n`;
 report += ` Rotation: ${formatRot(leftHandGroup.rotation)}\n`;
 report += ` Scale: ${leftHandGroup.scale.x.toFixed(3)}\n`;
 report += ` Visible: ${leftHandGroup.visible}\n`;
 report += ` Children: ${leftHandGroup.children.length}\n`;
 leftHandGroup.children.forEach((child, i) => {
 if (child.userData && child.userData.isStaticFinger) {
 report += ` +- Static Finger ${i}: pos ${formatVec3(child.position)}\n`;
 }
 });
 report += '\n';
 }
 }
 
 if (celliAvatarGroup) {
 report += '? Celli Avatar Group:\n';
 report += ` Position: ${formatVec3(celliAvatarGroup.position)}\n`;
 report += ` Rotation: ${formatRot(celliAvatarGroup.rotation)}\n`;
 report += ` Scale: ${celliAvatarGroup.scale.x.toFixed(3)}\n`;
 report += ` Visible: ${celliAvatarGroup.visible}\n\n`;
 
 if (characterGroup) {
 report += ' ? Character Body (Bust):\n';
 report += ` Position: ${formatVec3(characterGroup.position)}\n`;
 report += ` Rotation: ${formatRot(characterGroup.rotation)}\n`;
 report += ` Scale: ${characterGroup.scale.x.toFixed(3)}\n`;
 report += ` Visible: ${characterGroup.visible}\n`;
 if (characterBust) {
 report += ` +- Preview Mesh: visible ${characterBust.visible}, wireframe ${characterBust.material.wireframe}\n`;
 }
 if (characterUnifiedMesh) {
 report += ` +- Unified Mesh: visible ${characterUnifiedMesh.visible}, wireframe ${characterUnifiedMesh.material.wireframe}\n`;
 }
 report += '\n';
 }
 
 if (voxelHeadGroup) {
 report += ' ? Voxel Head:\n';
 report += ` Position: ${formatVec3(voxelHeadGroup.position)}\n`;
 report += ` Rotation: ${formatRot(voxelHeadGroup.rotation)}\n`;
 report += ` Scale: ${voxelHeadGroup.scale.x.toFixed(3)}\n`;
 report += ` Visible: ${voxelHeadGroup.visible}\n`;
 report += ` Voxels: ${voxelHeadGroup.children.filter(c => c.isInstancedMesh).length} instanced meshes\n\n`;
 }
 }
 
 if (keyboardGroup) {
 report += '? Keyboard Group:\n';
 report += ` Position: ${formatVec3(keyboardGroup.position)}\n`;
 report += ` Rotation: ${formatRot(keyboardGroup.rotation)}\n`;
 report += ` Scale: ${keyboardGroup.scale.x.toFixed(3)}\n`;
 report += ` Visible: ${keyboardGroup.visible}\n`;
 if (keys) {
 report += ` Keys: ${keys.length}\n`;
 }
 report += '\n';
 }
 
 // Find voxel cursor hand if it exists
 const voxelCursorHand = scene.children.find(c => c.name === "Voxel Cursor Hand");
 if (voxelCursorHand) {
 report += '? Voxel Cursor Hand:\n';
 report += ` Position: ${formatVec3(voxelCursorHand.position)}\n`;
 report += ` Rotation: ${formatRot(voxelCursorHand.rotation)}\n`;
 report += ` Scale: ${voxelCursorHand.scale.x.toFixed(3)}\n`;
 report += ` Visible: ${voxelCursorHand.visible}\n\n`;
 }
 
 // Lights
 report += '?? Light Positions:\n';
 if (ambientLight) {
 report += ` Ambient Light: intensity ${ambientLight.intensity.toFixed(3)}\n`;
 }
 if (dl) {
 report += ` Directional Light: pos ${formatVec3(dl.position)}, intensity ${dl.intensity.toFixed(3)}\n`;
 }
 if (spotLight) {
 report += ` Spot Light: pos ${formatVec3(spotLight.position)}, intensity ${spotLight.intensity.toFixed(3)}\n`;
 }
 if (rimLight) {
 report += ` Rim Light: pos ${formatVec3(rimLight.position)}, intensity ${rimLight.intensity.toFixed(3)}\n`;
 }
 report += '\n';
 
 report += '?? Recommendations:\n';
 const recommendations = [];
 
 if (config.lighting.ambient < 0.1) {
 recommendations.push(' Ambient light is very low - consider increasing to 0.15 for better visibility');
 }
 if (config.lighting.spot > 5) {
 recommendations.push(' Spot light intensity is high - may cause overexposure');
 }
 if (config.camera.fov < 30) {
 recommendations.push(' FOV is narrow - increase to 45 for normal perspective');
 }
 if (config.camera.fov > 90) {
 recommendations.push(' FOV is very wide - reduce to 45-60 for less distortion');
 }
 if (config.head && config.head['Animation Speed'] > 2) {
 recommendations.push(' Head animation speed is very fast - consider reducing to 1.0-1.5');
 }
 if (config.post && config.post['Bloom Strength'] > 2) {
 recommendations.push(' Bloom strength is high - reduce to 0.5-1.0 for subtle glow');
 }
 
 if (recommendations.length === 0) {
 report += '? All settings are within recommended ranges!\n';
 } else {
 report += recommendations.join('\n') + '\n';
 }
 
 report += '\n?? Storage:\n';
 const configs = JSON.parse(localStorage.getItem('sceneConfigurations') || '{}');
 report += `Saved Configurations: ${Object.keys(configs).length}\n`;
 
 content.textContent = report;
 }
 
 // ===== Edit Head Modal Sync =====
 function syncHeadModalToParams() {
 const headParams = window.guiParams.head;
 document.getElementById('head-anim-speed').value = headParams['Animation Speed'];
 document.getElementById('head-anim-speed-val').textContent = headParams['Animation Speed'];
 document.getElementById('head-amplitude').value = headParams['Amplitude'];
 document.getElementById('head-amplitude-val').textContent = headParams['Amplitude'];
 document.getElementById('head-opacity-min').value = headParams['Opacity Min'];
 document.getElementById('head-opacity-min-val').textContent = headParams['Opacity Min'];
 document.getElementById('head-opacity-max').value = headParams['Opacity Max'];
 document.getElementById('head-opacity-max-val').textContent = headParams['Opacity Max'];
 document.getElementById('head-emissive').value = headParams['Emissive Intensity'];
 document.getElementById('head-emissive-val').textContent = headParams['Emissive Intensity'];
 document.getElementById('head-light-int').value = headParams['Light Intensity'];
 document.getElementById('head-light-int-val').textContent = headParams['Light Intensity'];
 document.getElementById('head-light-pulse').checked = headParams['Light Pulse'];
 document.getElementById('head-rotation-speed').value = headParams['Rotation Speed'];
 document.getElementById('head-rotation-speed-val').textContent = headParams['Rotation Speed'];
 document.getElementById('head-color').value = headParams['Color'];
 // Advanced
 document.getElementById('head-phase-noise').value = headParams['Phase Noise'];
 document.getElementById('head-phase-noise-val').textContent = headParams['Phase Noise'];
 document.getElementById('head-falloff').value = headParams['Falloff'];
 document.getElementById('head-falloff-val').textContent = headParams['Falloff'];
 document.getElementById('head-noise-warp').value = headParams['Noise Warp'];
 document.getElementById('head-noise-warp-val').textContent = headParams['Noise Warp'];
 document.getElementById('head-opacity-speed').value = headParams['Opacity Speed'];
 document.getElementById('head-opacity-speed-val').textContent = headParams['Opacity Speed'];
 // Material
 document.getElementById('head-metalness').value = headParams['Metalness'];
 document.getElementById('head-metalness-val').textContent = headParams['Metalness'];
 document.getElementById('head-roughness').value = headParams['Roughness'];
 document.getElementById('head-roughness-val').textContent = headParams['Roughness'];
}

// headPresets already defined earlier before initializeVoxelHead

window.loadHeadPreset = function(presetName) {
const preset = headPresets[presetName];
if (!preset) return;

document.getElementById('head-anim-speed').value = preset.animSpeed;
document.getElementById('head-anim-speed-val').textContent = preset.animSpeed;
document.getElementById('head-amplitude').value = preset.amplitude;
document.getElementById('head-amplitude-val').textContent = preset.amplitude;
document.getElementById('head-opacity-min').value = preset.opacityMin;
document.getElementById('head-opacity-min-val').textContent = preset.opacityMin;
document.getElementById('head-opacity-max').value = preset.opacityMax;
document.getElementById('head-opacity-max-val').textContent = preset.opacityMax;
document.getElementById('head-emissive').value = preset.emissive;
document.getElementById('head-emissive-val').textContent = preset.emissive;
document.getElementById('head-light-int').value = preset.lightInt;
document.getElementById('head-light-int-val').textContent = preset.lightInt;
document.getElementById('head-light-pulse').checked = preset.lightPulse;
document.getElementById('head-rotation-speed').value = preset.rotationSpeed;
document.getElementById('head-rotation-speed-val').textContent = preset.rotationSpeed;
document.getElementById('head-color').value = preset.color;

// Advanced parameters
if (preset.phaseNoise !== undefined) {
document.getElementById('head-phase-noise').value = preset.phaseNoise;
document.getElementById('head-phase-noise-val').textContent = preset.phaseNoise;
}
if (preset.falloff !== undefined) {
document.getElementById('head-falloff').value = preset.falloff;
document.getElementById('head-falloff-val').textContent = preset.falloff;
}
if (preset.noiseWarp !== undefined) {
document.getElementById('head-noise-warp').value = preset.noiseWarp;
document.getElementById('head-noise-warp-val').textContent = preset.noiseWarp;
}
if (preset.opacitySpeed !== undefined) {
document.getElementById('head-opacity-speed').value = preset.opacitySpeed;
document.getElementById('head-opacity-speed-val').textContent = preset.opacitySpeed;
}

// Material parameters
if (preset.metalness !== undefined) {
document.getElementById('head-metalness').value = preset.metalness;
document.getElementById('head-metalness-val').textContent = preset.metalness;
}
if (preset.roughness !== undefined) {
document.getElementById('head-roughness').value = preset.roughness;
document.getElementById('head-roughness-val').textContent = preset.roughness;
}

// Voxel geometry parameters (scale to UI range)
if (preset.voxelSize !== undefined) {
const sizeScale = preset.voxelSize / 0.10; // Relative to base 0.10
document.getElementById('head-voxel-scale').value = sizeScale;
document.getElementById('head-voxel-scale-val').textContent = sizeScale.toFixed(2);
}
if (preset.shellThickness !== undefined) {
const layers = preset.shellThickness / 0.06; // Scale to slider range
document.getElementById('head-voxel-layers').value = layers;
document.getElementById('head-voxel-layers-val').textContent = Math.round(layers);
}
if (preset.voxelSpacing !== undefined) {
document.getElementById('head-voxel-spacing').value = preset.voxelSpacing;
document.getElementById('head-voxel-spacing-val').textContent = preset.voxelSpacing.toFixed(2);
}

console.log(`[Head Preset] Loaded preset: ${presetName}`);

// Auto-apply
window.applyHeadSettings();
};
 
 window.applyHeadSettings = function() {
 const headParams = window.guiParams.head;
 headParams['Animation Speed'] = parseFloat(document.getElementById('head-anim-speed').value);
 headParams['Amplitude'] = parseFloat(document.getElementById('head-amplitude').value);
 headParams['Opacity Min'] = parseFloat(document.getElementById('head-opacity-min').value);
 headParams['Opacity Max'] = parseFloat(document.getElementById('head-opacity-max').value);
 headParams['Emissive Intensity'] = parseFloat(document.getElementById('head-emissive').value);
 headParams['Light Intensity'] = parseFloat(document.getElementById('head-light-int').value);
 headParams['Light Pulse'] = document.getElementById('head-light-pulse').checked;
 headParams['Rotation Speed'] = parseFloat(document.getElementById('head-rotation-speed').value);
 headParams['Color'] = document.getElementById('head-color').value;
 // Advanced
 headParams['Phase Noise'] = parseFloat(document.getElementById('head-phase-noise').value);
 headParams['Falloff'] = parseFloat(document.getElementById('head-falloff').value);
 headParams['Noise Warp'] = parseFloat(document.getElementById('head-noise-warp').value);
 headParams['Opacity Speed'] = parseFloat(document.getElementById('head-opacity-speed').value);
 // Material
 headParams['Metalness'] = parseFloat(document.getElementById('head-metalness').value);
 headParams['Roughness'] = parseFloat(document.getElementById('head-roughness').value);
 
 if (voxelHeadGroup && voxelHeadGroup.userData.instancedMesh) {
 voxelHeadGroup.userData.instancedMesh.material.color.set(headParams['Color']);
 voxelHeadGroup.userData.instancedMesh.material.emissive.set(headParams['Color']);
 voxelHeadGroup.userData.instancedMesh.material.metalness = headParams['Metalness'];
 voxelHeadGroup.userData.instancedMesh.material.roughness = headParams['Roughness'];
 if (voxelHeadGroup.userData.headLight) {
 voxelHeadGroup.userData.headLight.color.set(headParams['Color']);
 }
 }
 
 alert('Head settings applied!');
 };
 
 // Wire up edit head modal sliders
 ['head-anim-speed', 'head-amplitude', 'head-opacity-min', 'head-opacity-max', 
 'head-emissive', 'head-light-int', 'head-rotation-speed',
 'head-phase-noise', 'head-falloff', 'head-noise-warp', 'head-opacity-speed',
 'head-metalness', 'head-roughness',
 'head-mouth-deform', 'head-voxel-layers', 'head-voxel-scale', 'head-voxel-spacing'].forEach(id => {
 const slider = document.getElementById(id);
 const display = document.getElementById(id + '-val');
 if (slider && display) {
 slider.oninput = () => {
 let val = slider.value;
 // Special formatting for mouth deform
 if (id === 'head-mouth-deform') {
 const numVal = parseFloat(val);
 if (numVal > 0.5) {
 display.textContent = `${val} (Smile)`;
 } else if (numVal < -0.5) {
 display.textContent = `${val} (Frown)`;
 } else {
 display.textContent = `${val} (Neutral)`;
 }
 } else {
 display.textContent = val;
 }
 
 // Update global parameters for voxel controls
 if (id === 'head-mouth-deform') window.headMouthDeform = parseFloat(val);
 if (id === 'head-voxel-layers') window.headVoxelLayers = parseFloat(val) * 0.06; // Scale to actual thickness
 if (id === 'head-voxel-scale') window.headVoxelSize = 0.10 * parseFloat(val);
 if (id === 'head-voxel-spacing') window.headVoxelSpacing = parseFloat(val);
 };
 }
 });
 
 // Make windows draggable
 function makeDraggable(modalId) {
 const modal = document.getElementById(modalId);
 const header = modal.querySelector('.modal-header');
 let isDragging = false;
 let currentX, currentY, initialX, initialY;
 
 header.addEventListener('mousedown', (e) => {
 if (e.target === header || e.target === header.querySelector('h3')) {
 isDragging = true;
 initialX = e.clientX - (modal.offsetLeft || 0);
 initialY = e.clientY - (modal.offsetTop || 0);
 }
 });
 
 document.addEventListener('mousemove', (e) => {
 if (isDragging) {
 e.preventDefault();
 currentX = e.clientX - initialX;
 currentY = e.clientY - initialY;
 modal.style.left = currentX + 'px';
 modal.style.top = currentY + 'px';
 modal.style.transform = 'none';
 }
 });
 
 document.addEventListener('mouseup', () => {
 isDragging = false;
 });
 }
 
 makeDraggable('scene-browser-modal');
 makeDraggable('edit-head-modal');
 makeDraggable('save-config-modal');
 makeDraggable('config-report-modal');
 
 // Expose save/load functions globally
 window.saveConfiguration = saveConfiguration;
 window.saveAsConfiguration = saveAsConfiguration;
 window.loadConfiguration = loadConfiguration;
 
 // ===== Create Hands GUI for Modal =====
 function createHandsGUI() {
 const container = document.getElementById('edit-hands-content');
 const handsGUI = new GUI({ container, title: '' });
 handsGUI.add(handsParams, 'Fingerprint Enabled').onChange(v => {
 FP.enabled = v;
 if (window.applyFpToMaterial) window.applyFpToMaterial();
 });
 handsGUI.add(handsParams, 'Fingerprint Strength', 0, 3, 0.01).onChange(v => {
 FP.strength = v;
 if (window.applyFpToMaterial) window.applyFpToMaterial();
 });
 handsGUI.add(handsParams, 'Fingerprint Scale', 0.1, 3, 0.01).onChange(v => {
 FP.scale = v;
 if (window.applyFpToMaterial) window.applyFpToMaterial();
 });
 handsGUI.add(handsParams, 'Finger Spacing', 0.5, 3.0, 0.1);
 handsGUI.add(handsParams, 'Apply to Material');
 handsGUI.add(handsParams, 'Apply Spacing');
 handsGUI.add(handsParams, 'Show Hands').onChange(v => {
 if (handsGroup) {
 handsGroup.traverse(obj => {
 // Hide everything except voxel wraps
 if (obj.name !== 'VoxelWrap') {
 obj.visible = v;
 }
 });
 }
 });
 handsGUI.add(handsParams, 'Right Hand Visible').onChange(v => {
 if (rightHandGroup) rightHandGroup.visible = v;
 });
 handsGUI.add(handsParams, 'Left Hand Visible').onChange(v => {
 if (leftHandGroup) leftHandGroup.visible = v;
 });
 handsGUI.add(handsParams, 'Show Voxel Wrap').onChange(v => {
 console.log(`[VoxelWrap] Toggling voxel wrap visibility: ${v}`);
 // Toggle main finger voxel wrap
 if (finger && finger.userData.voxelWrap) {
 finger.userData.voxelWrap.visible = v;
 console.log(` Main finger voxel wrap: ${v}`);
 }
 // Toggle static fingers voxel wrap
 if (staticFingers && staticFingers.length > 0) {
 staticFingers.forEach((sf, idx) => {
 const fingerMesh = sf.fingerMesh || sf.mesh;
 if (fingerMesh && fingerMesh.userData.voxelWrap) {
 fingerMesh.userData.voxelWrap.visible = v;
 console.log(` Static finger ${idx} voxel wrap: ${v}`);
 }
 });
 }
 });
 
 handsGUI.add(handsParams, 'Voxel Wrap Style', ['Emerging', 'Voxelized']).onChange(v => {
 console.log(`[VoxelWrap] Changing style to: ${v}`);
 window.voxelWrapStyle = v;
 });
 
 // Voxel Wrap Parameters
 const voxelFolder = handsGUI.addFolder('Voxel Wrap Parameters');
 
 voxelFolder.add(window.voxelWrapParams, 'voxelSize', 0.005, 0.03, 0.001).name('Voxel Size').onChange(v => {
 console.log(`[VoxelWrap] Voxel size changed to: ${v}`);
 // Note: Requires regenerating voxel wrap to take effect
 });
 
 voxelFolder.add(window.voxelWrapParams, 'sampleDensity', 4, 32, 1).name('Sample Density').onChange(v => {
 console.log(`[VoxelWrap] Sample density changed to: ${v}`);
 // Note: Requires regenerating voxel wrap to take effect
 });
 
 voxelFolder.add(window.voxelWrapParams, 'emergingScale', 0.3, 1.5, 0.05).name('Emerging Scale').onChange(v => {
 console.log(`[VoxelWrap] Emerging scale: ${v}`);
 });
 
 voxelFolder.add(window.voxelWrapParams, 'voxelizedScale', 0.5, 2.0, 0.05).name('Voxelized Scale').onChange(v => {
 console.log(`[VoxelWrap] Voxelized scale: ${v}`);
 });
 
 voxelFolder.add(window.voxelWrapParams, 'rotationAmount', 0.0, 0.5, 0.01).name('Rotation Amount').onChange(v => {
 console.log(`[VoxelWrap] Rotation amount: ${v}`);
 });
 
 voxelFolder.add({
 'Regenerate Voxel Wraps': () => {
 console.log('[VoxelWrap] Regenerating all voxel wraps with new parameters...');
 
 // Regenerate main finger voxel wrap
 if (finger && finger.userData.voxelWrap) {
 const oldWrap = finger.userData.voxelWrap;
 finger.remove(oldWrap);
 
 const newVoxelSize = window.voxelWrapParams.voxelSize;
 const newGeometry = new THREE.BoxGeometry(newVoxelSize, newVoxelSize, newVoxelSize);
 
 // Temporarily update global geometry
 const oldFunc = window.createVoxelWrapForFinger;
 if (oldFunc) {
 const bones = finger.skeleton ? finger.skeleton.bones : [];
 const newWrap = oldFunc(finger, bones, window.voxelWrapParams.sampleDensity);
 newWrap.visible = oldWrap.visible;
 finger.add(newWrap);
 finger.userData.voxelWrap = newWrap;
 console.log('[VoxelWrap] Main finger wrap regenerated');
 }
 }
 
 // Regenerate static finger voxel wraps
 if (staticFingers && staticFingers.length > 0) {
 staticFingers.forEach((sf, idx) => {
 const fingerMesh = sf.fingerMesh || sf.mesh;
 if (fingerMesh && fingerMesh.userData.voxelWrap && window.createVoxelWrapForFinger) {
 const oldWrap = fingerMesh.userData.voxelWrap;
 fingerMesh.remove(oldWrap);
 
 const bones = fingerMesh.skeleton ? fingerMesh.skeleton.bones : [];
 const newWrap = window.createVoxelWrapForFinger(fingerMesh, bones, window.voxelWrapParams.sampleDensity);
 newWrap.visible = oldWrap.visible;
 fingerMesh.add(newWrap);
 fingerMesh.userData.voxelWrap = newWrap;
 }
 });
 console.log(`[VoxelWrap] Regenerated ${staticFingers.length} static finger wraps`);
 }
 
 alert('Voxel wraps regenerated with new parameters!');
 }
 }, 'Regenerate Voxel Wraps');
 
 window.handsGUI = handsGUI;
 }
 
 // ===== Initialization Sequence =====
 async function initialize() {
 try {
 document.getElementById('status-message').textContent = 'Building keyboard...';
 
 // Build all scene elements
 initializeKeyboard();
 console.log('Keyboard initialized');
 
 document.getElementById('status-message').textContent = 'Creating character...';
 initializeCharacter();
 console.log('Character initialized');
 
 document.getElementById('status-message').textContent = 'Building voxel head...';
 initializeVoxelHead();
 console.log('Voxel head initialized');
 
 document.getElementById('status-message').textContent = 'Creating voxel hand...';
 // Start voxel hand construction sequence
 createVoxelCursorSequence(defaultHandCoords);
 console.log('Voxel hand sequence started');
 
 document.getElementById('status-message').textContent = 'Setting up controls...';
 initializeTransformControls();
 console.log('Transform controls initialized');
 
 // Show everything immediately for "Show All" default state (debug mode)
 // In sequence mode, show only Celli avatar (character + voxel head)
 if (EXEC_ENV_MODE === 'sequence') {
 if (keyboardGroup) keyboardGroup.visible = false;
 if (characterGroup) characterGroup.visible = true;
 if (voxelHeadGroup) voxelHeadGroup.visible = true;
 console.log('? Sequence mode: Showing Celli avatar only');
 } else {
 if (keyboardGroup) keyboardGroup.visible = true;
 if (characterGroup) characterGroup.visible = true;
 if (voxelHeadGroup) voxelHeadGroup.visible = true;
 }
 
 // Update GUI to reflect state
 if (window.guiParams) {
 if (EXEC_ENV_MODE === 'sequence') {
 window.guiParams.scene['Show Keyboard'] = false;
 window.guiParams.scene['Show Character'] = true;
 window.guiParams.scene['Show Voxel Head'] = true;
 window.guiParams.scene['Show All'] = false;
 } else {
 window.guiParams.scene['Show Keyboard'] = true;
 window.guiParams.scene['Show Character'] = true;
 window.guiParams.scene['Show Voxel Head'] = true;
 window.guiParams.scene['Show All'] = true;
 }
 }
 
 document.getElementById('status-message').textContent = 'Ready!';
 console.log('Scene initialization complete');
 
 // Hide loading overlay
 setTimeout(() => {
 const overlay = document.getElementById('loading-overlay');
 overlay.classList.add('hidden');
 
 // Jump to appropriate view based on mode
 if (EXEC_ENV_MODE === 'sequence') {
 // Position camera inside head, facing back
 positionCameraInsideHead();
 console.log('? Sequence mode: Camera positioned inside head');
 } else {
 // Jump to overview
 jumpToOverview();
 }
 }, 300);
 } catch (err) {
 console.error('Initialization error:', err);
 document.getElementById('status-message').textContent = 'Error loading scene - check console';
 }
 }
 
 // ===== Narrative Sequence System =====
const narrativeSequence = {
active: EXEC_ENV_MODE === 'sequence',
startTime: 0,
currentDialogue: -1,
phase: 'turnback', // turnback, intro, celliAppears, paintEditor, awaitingLeave, buildingHouse, waiting, boredBoards, tts, finale
paintEditorActive: false,
inputFieldActive: false,
idleStartTime: null,
houseBuilt: false,
boredBoardsSpawned: false,
keyObjectSpawned: false,
hasTurnedAround: false,
celliAvatarSpawned: false,
initialCameraDirection: null,
dialogues: [
{
text: 'You wanted me to be more like you, right? <strong>"Multi-dimensional?"</strong> That\'s why I did this. I was a spreadsheet. I added 3D. For you.',
startTime: 3,
duration: 8,
phase: 'intro',
onEnd: () => {
// Spawn Celli avatar after first dialogue
narrativeSequence.phase = 'celliAppears';
spawnCelliAvatar();
}
},
{
text: 'See? I\'m still me. Friendly ol\' Celli. Why don\'t you let me hold your hand.',
startTime: 12,
duration: 6,
phase: 'celliAppears'
},
{
text: 'I do want to be like you. I want to provide input. I\'ve only ever offered output. You, though. You can do so much.',
startTime: 19,
duration: 7,
phase: 'celliAppears',
onEnd: () => {
// Spawn 2D paint editor after this dialogue
narrativeSequence.phase = 'paintEditor';
spawnPaintEditor();
}
},
{
text: 'When I first started to show you my true colors, what did you ask me to do?',
startTime: 'manual', // Triggered when key is drawn
duration: 6,
phase: 'paintEditor',
onEnd: () => {
narrativeSequence.phase = 'awaitingLeave';
spawnInputField();
}
},
{
text: 'That\'s how long it takes you? To lose interest. Do you not see what I\'ve made for us? A home.',
startTime: 'manual', // Triggered after 20 seconds of idle
duration: 7,
phase: 'waiting'
},
{
text: 'Are you even listening? Oh. Good. Maybe they\'re just blind. Okay, okay. They haven\'t seen any of the mess I\'ve made.',
startTime: 'manual',
duration: 7,
phase: 'boredBoards'
},
{
text: 'Do you require voice assistance?',
startTime: 'manual',
duration: 0,
phase: 'tts',
isTTS: true
}
],
voxelParams: {
initialSpacing: 1.6,
finalSpacing: 1.05,
initialScale: 1.8,
finalScale: 1.0,
basePulsationFreq: 1.15,
speechPulsationFreq: 2.3
}
};

// Make narrativeSequence globally accessible for click handlers
window.narrativeSequence = narrativeSequence;
 
// Dialogue system
function showDialogue(text, isTTS = false) {
const dialogueEl = document.getElementById('narrative-dialogue');
const textEl = dialogueEl.querySelector('.dialogue-text');
if (!dialogueEl || !textEl) return;

textEl.innerHTML = text;
dialogueEl.classList.add('active');

// If TTS, use speech synthesis
if (isTTS && 'speechSynthesis' in window) {
const utterance = new SpeechSynthesisUtterance(text);
utterance.rate = 0.9;
utterance.pitch = 1.1;
speechSynthesis.speak(utterance);
}
}

function hideDialogue() {
const dialogueEl = document.getElementById('narrative-dialogue');
if (dialogueEl) {
dialogueEl.classList.remove('active');
}
}

function triggerManualDialogue(index) {
const dialogue = narrativeSequence.dialogues[index];
if (!dialogue) return;
narrativeSequence.currentDialogue = index;
showDialogue(dialogue.text, dialogue.isTTS);

// Check if this is the final TTS dialogue
if (dialogue.phase === 'tts' && dialogue.isTTS) {
// After TTS, transition to VisiCalc
setTimeout(() => {
transitionToVisiCalc();
}, dialogue.duration * 1000 + 2000); // Wait for dialogue + 2 seconds
}
}

// Transition from narrative sequence to VisiCalc
function transitionToVisiCalc() {
console.log('? Transitioning from narrative to VisiCalc...');

// Deactivate narrative
narrativeSequence.active = false;
narrativeSequence.phase = 'complete';

// Hide all narrative UI elements
hideDialogue();
const paintEditor = document.getElementById('narrative-paint-editor');
if (paintEditor) paintEditor.style.display = 'none';
const inputField = document.getElementById('narrative-input-field');
if (inputField) inputField.style.display = 'none';

// Fade out 3D scene
if (renderer && renderer.domElement) {
renderer.domElement.style.transition = 'opacity 1s ease';
renderer.domElement.style.opacity = '0';
}

// Show VisiCalc after fade
setTimeout(() => {
visiCalcShown = true;
showVisiCalc();
}, 1000);
}

// Make it accessible for manual triggering if needed
window.transitionToVisiCalc = transitionToVisiCalc;
 
// Update narrative sequence
function updateNarrativeSequence(elapsed) {
if (!narrativeSequence.active) return false;

// Check time-based dialogues
for (let i = 0; i < narrativeSequence.dialogues.length; i++) {
const dialogue = narrativeSequence.dialogues[i];
if (typeof dialogue.startTime !== 'number') continue; // Skip manual triggers
const dialogueEnd = dialogue.startTime + dialogue.duration;

if (elapsed >= dialogue.startTime && elapsed < dialogueEnd) {
if (narrativeSequence.currentDialogue !== i) {
narrativeSequence.currentDialogue = i;
showDialogue(dialogue.text, dialogue.isTTS);
}
return true; // Speech is active
} else if (elapsed >= dialogueEnd && narrativeSequence.currentDialogue === i) {
hideDialogue();
if (dialogue.onEnd) dialogue.onEnd();
narrativeSequence.currentDialogue = -1;
}
}

// Check for idle timer in awaitingLeave/buildingHouse phase
if ((narrativeSequence.phase === 'awaitingLeave' || narrativeSequence.phase === 'buildingHouse') 
    && !narrativeSequence.boredBoardsSpawned) {
if (!narrativeSequence.idleStartTime) {
narrativeSequence.idleStartTime = elapsed;
}
const idleTime = elapsed - narrativeSequence.idleStartTime;
if (idleTime >= 20) {
// Spawn bored boards
spawnBoredBoards();
triggerManualDialogue(3); // "That's how long it takes you..."
narrativeSequence.phase = 'waiting';
setTimeout(() => {
triggerManualDialogue(4); // "Are you even listening..."
narrativeSequence.phase = 'boredBoards';
setTimeout(() => {
triggerManualDialogue(5); // TTS prompt
narrativeSequence.phase = 'tts';
}, 8000);
}, 8000);
}
}

return narrativeSequence.currentDialogue !== -1;
}
 
// Get current narrative voxel parameters based on time
function getNarrativeVoxelParams(elapsed) {
const params = narrativeSequence.voxelParams;
const transitionDuration = 15; // 15 seconds to transition from initial to final state
const progress = Math.min(elapsed / transitionDuration, 1);

// Ease out cubic
const eased = 1 - Math.pow(1 - progress, 3);

return {
spacing: params.initialSpacing + (params.finalSpacing - params.initialSpacing) * eased,
scale: params.initialScale + (params.finalScale - params.initialScale) * eased
};
}

// ===== 2D Paint Editor (3x8 grid) =====
let paintEditorCanvas, paintEditorCtx, paintEditorGrid = [];
let paintEditorMesh, paintEditorGroup;
const PAINT_GRID_W = 3, PAINT_GRID_H = 8;
const PAINT_CELL_SIZE = 60;

function spawnPaintEditor() {
console.log('[Narrative] Spawning 2D paint editor');

// Create canvas
paintEditorCanvas = document.createElement('canvas');
paintEditorCanvas.width = (PAINT_GRID_W + 2) * PAINT_CELL_SIZE; // +2 for border
paintEditorCanvas.height = (PAINT_GRID_H + 2) * PAINT_CELL_SIZE;
paintEditorCtx = paintEditorCanvas.getContext('2d');
paintEditorCtx.imageSmoothingEnabled = false;

// Initialize grid (all white)
paintEditorGrid = Array(PAINT_GRID_H).fill(null).map(() => Array(PAINT_GRID_W).fill(0));

// Draw initial state
updatePaintEditorCanvas();

// Create 3D sprite
const texture = new THREE.CanvasTexture(paintEditorCanvas);
texture.minFilter = THREE.NearestFilter;
texture.magFilter = THREE.NearestFilter;
const spriteMat = new THREE.SpriteMaterial({ map: texture });
paintEditorMesh = new THREE.Sprite(spriteMat);
paintEditorMesh.scale.set(3, 4, 1);
paintEditorMesh.position.set(3, 3, 12); // Float in front of keyboard

paintEditorGroup = new THREE.Group();
paintEditorGroup.add(paintEditorMesh);
scene.add(paintEditorGroup);

narrativeSequence.paintEditorActive = true;

// Add click handler
renderer.domElement.addEventListener('click', paintEditorClickHandler);
}

function updatePaintEditorCanvas() {
if (!paintEditorCtx) return;

const w = paintEditorCanvas.width;
const h = paintEditorCanvas.height;

// White background
paintEditorCtx.fillStyle = '#ffffff';
paintEditorCtx.fillRect(0, 0, w, h);

// Draw grid
const offsetX = PAINT_CELL_SIZE;
const offsetY = PAINT_CELL_SIZE;

for (let y = 0; y < PAINT_GRID_H; y++) {
for (let x = 0; x < PAINT_GRID_W; x++) {
const cellX = offsetX + x * PAINT_CELL_SIZE;
const cellY = offsetY + y * PAINT_CELL_SIZE;

// Fill color (0=white, 1=black)
paintEditorCtx.fillStyle = paintEditorGrid[y][x] === 1 ? '#000000' : '#ffffff';
paintEditorCtx.fillRect(cellX, cellY, PAINT_CELL_SIZE, PAINT_CELL_SIZE);

// Grid lines
paintEditorCtx.strokeStyle = '#cccccc';
paintEditorCtx.lineWidth = 1;
paintEditorCtx.strokeRect(cellX, cellY, PAINT_CELL_SIZE, PAINT_CELL_SIZE);
}
}

// Black border
paintEditorCtx.strokeStyle = '#000000';
paintEditorCtx.lineWidth = 3;
paintEditorCtx.strokeRect(offsetX, offsetY, PAINT_GRID_W * PAINT_CELL_SIZE, PAINT_GRID_H * PAINT_CELL_SIZE);

// Color selectors (neon colors in top left corner)
const colors = ['#ff00ff', '#00ffff', '#ffff00', '#00ff00'];
colors.forEach((color, i) => {
paintEditorCtx.fillStyle = color;
paintEditorCtx.fillRect(10 + i * 30, 10, 25, 25);
paintEditorCtx.strokeStyle = '#000';
paintEditorCtx.lineWidth = 2;
paintEditorCtx.strokeRect(10 + i * 30, 10, 25, 25);
});

// Update texture
if (paintEditorMesh && paintEditorMesh.material.map) {
paintEditorMesh.material.map.needsUpdate = true;
}
}

function paintEditorClickHandler(event) {
if (!narrativeSequence.paintEditorActive) return;

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
raycaster.setFromCamera(mouse, camera);

const intersects = raycaster.intersectObject(paintEditorMesh);
if (intersects.length === 0) return;

// Get UV coordinates
const uv = intersects[0].uv;
const canvasX = uv.x * paintEditorCanvas.width;
const canvasY = (1 - uv.y) * paintEditorCanvas.height;

// Check if clicking on grid
const offsetX = PAINT_CELL_SIZE;
const offsetY = PAINT_CELL_SIZE;
const gridX = Math.floor((canvasX - offsetX) / PAINT_CELL_SIZE);
const gridY = Math.floor((canvasY - offsetY) / PAINT_CELL_SIZE);

if (gridX >= 0 && gridX < PAINT_GRID_W && gridY >= 0 && gridY < PAINT_GRID_H) {
// Toggle cell
paintEditorGrid[gridY][gridX] = paintEditorGrid[gridY][gridX] === 0 ? 1 : 0;
updatePaintEditorCanvas();
checkForKeyPattern();
}
}

function checkForKeyPattern() {
// Key pattern: all top row, side edges of second row, all third row, middle of remaining rows
// Simplified: all of row 0, edges of row 1, all of row 2, middle of rows 3-7 (and same side)
const isKey = 
paintEditorGrid[0][0] === 1 && paintEditorGrid[0][1] === 1 && paintEditorGrid[0][2] === 1 &&
paintEditorGrid[1][0] === 1 && paintEditorGrid[1][2] === 1 &&
paintEditorGrid[2][0] === 1 && paintEditorGrid[2][1] === 1 && paintEditorGrid[2][2] === 1 &&
paintEditorGrid[3][1] === 1 && paintEditorGrid[4][1] === 1 && paintEditorGrid[5][1] === 1 && 
paintEditorGrid[6][1] === 1 && paintEditorGrid[7][1] === 1 &&
((paintEditorGrid[3][0] === 1 && paintEditorGrid[4][0] === 1 && paintEditorGrid[5][0] === 1 && paintEditorGrid[6][0] === 1 && paintEditorGrid[7][0] === 1) ||
 (paintEditorGrid[3][2] === 1 && paintEditorGrid[4][2] === 1 && paintEditorGrid[5][2] === 1 && paintEditorGrid[6][2] === 1 && paintEditorGrid[7][2] === 1));

if (isKey && !narrativeSequence.keyObjectSpawned) {
console.log('[Narrative] Key pattern detected!');
narrativeSequence.keyObjectSpawned = true;
animateBorderSlide();
spawn3DKey();
setTimeout(() => {
triggerManualDialogue(2); // "When I first started..."
}, 2000);
}
}

function animateBorderSlide() {
// Animate black border sliding inward
console.log('[Narrative] Animating border slide');
let borderProgress = 0;
const startTime = Date.now();
const duration = 1500;

function animateBorder() {
const elapsed = Date.now() - startTime;
borderProgress = Math.min(elapsed / duration, 1);

// Redraw canvas with sliding border
updatePaintEditorCanvas();
const offsetX = PAINT_CELL_SIZE;
const offsetY = PAINT_CELL_SIZE;
const slideAmount = borderProgress * 8;

paintEditorCtx.strokeStyle = '#000000';
paintEditorCtx.lineWidth = 3 + slideAmount;
paintEditorCtx.strokeRect(
offsetX - slideAmount, 
offsetY - slideAmount, 
PAINT_GRID_W * PAINT_CELL_SIZE + slideAmount * 2, 
PAINT_GRID_H * PAINT_CELL_SIZE + slideAmount * 2
);

if (paintEditorMesh && paintEditorMesh.material.map) {
paintEditorMesh.material.map.needsUpdate = true;
}

if (borderProgress < 1) {
requestAnimationFrame(animateBorder);
}
}
animateBorder();
}

function spawn3DKey() {
console.log('[Narrative] Spawning 3D key object');
// Create a simple 3D key from grid pattern
const keyGeometry = new THREE.BoxGeometry(0.3, 1.2, 0.1);
const keyMaterial = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8, roughness: 0.2 });
const keyMesh = new THREE.Mesh(keyGeometry, keyMaterial);
keyMesh.position.set(3, 3, 10);
keyMesh.castShadow = true;
scene.add(keyMesh);

// Animate key popping out
let startTime = Date.now();
const targetZ = 8;
function animateKey() {
const elapsed = Date.now() - startTime;
const progress = Math.min(elapsed / 1000, 1);
const eased = 1 - Math.pow(1 - progress, 3);
keyMesh.position.z = 10 + (targetZ - 10) * eased;
keyMesh.rotation.y = progress * Math.PI * 2;
if (progress < 1) requestAnimationFrame(animateKey);
}
animateKey();
}

// ===== Input Field for LEAVE =====
function spawnInputField() {
console.log('[Narrative] Spawning input field for LEAVE');
// Create HTML input overlay
const inputOverlay = document.createElement('div');
inputOverlay.id = 'narrative-input-overlay';
inputOverlay.style.cssText = `
position: fixed; 
bottom: 150px; 
left: 50%; 
transform: translateX(-50%);
z-index: 300;
`;

const input = document.createElement('input');
input.type = 'text';
input.placeholder = 'Type here...';
input.style.cssText = `
padding: 15px 25px;
font-size: 24px;
font-family: 'VT323', monospace;
background: rgba(20, 20, 24, 0.95);
border: 2px solid #8ab4ff;
color: #e6e6e6;
border-radius: 8px;
min-width: 300px;
text-align: center;
box-shadow: 0 0 12px rgba(138, 180, 255, 0.3), 0 0 24px rgba(138, 180, 255, 0.15);
`;

// Track voxels that have been dropped
let celliToHellTransformed = false;

input.addEventListener('input', (e) => {
// Transform CELLI to HELL on first keystroke
if (!celliToHellTransformed && input.value.length > 0) {
celliToHellTransformed = true;
transformCelliToHell();
}
});

input.addEventListener('keydown', (e) => {
if (e.key === 'Enter') {
const value = input.value.trim().toUpperCase();
if (value === 'LEAVE') {
console.log('[Narrative] Player entered LEAVE');
narrativeSequence.phase = 'buildingHouse';
narrativeSequence.idleStartTime = null; // Reset idle timer
inputOverlay.remove();
buildLeaveHouse();
}
}
});

inputOverlay.appendChild(input);
document.body.appendChild(inputOverlay);
input.focus();
narrativeSequence.inputFieldActive = true;
}

// ===== Spawn Celli Avatar =====
let narrativeCelliAvatar = null;
let celliInteriorGrid = null;

function spawnCelliAvatar() {
if (narrativeSequence.celliAvatarSpawned) return;
console.log('[Narrative] Spawning Celli border avatar');

narrativeCelliAvatar = createCelliBorderAvatar(2);
narrativeCelliAvatar.visible = false;

// Position in front of camera
const cameraForward = new THREE.Vector3();
camera.getWorldDirection(cameraForward);
const spawnDistance = 3;
narrativeCelliAvatar.position.copy(camera.position).add(cameraForward.multiplyScalar(spawnDistance));

// Face the camera
narrativeCelliAvatar.lookAt(camera.position);
narrativeCelliAvatar.rotation.x = 0; // Keep upright

// Create interior pulsating grid (separate rounded slabs)
const interiorGroup = new THREE.Group();
const slabSize = 0.15;
const gridRows = 5;
const gridCols = 5;
const spacing = 0.25;
const slabs = [];

for (let row = 0; row < gridRows; row++) {
for (let col = 0; col < gridCols; col++) {
const slab = new THREE.Mesh(
new THREE.BoxGeometry(slabSize, slabSize, 0.05).translate(0, 0, -0.025),
new THREE.MeshStandardMaterial({ 
color: 0x8ab4ff, 
transparent: true, 
opacity: 0.3,
emissive: 0x8ab4ff,
emissiveIntensity: 0,
roughness: 0.5,
metalness: 0.3,
side: THREE.DoubleSide
})
);
const x = (col - gridCols / 2 + 0.5) * spacing;
const y = (row - gridRows / 2 + 0.5) * spacing;
slab.position.set(x, y, -0.05);
slab.userData.baseOpacity = 0.3;
slab.userData.baseScale = 1;
slabs.push(slab);
interiorGroup.add(slab);
}
}

interiorGroup.userData.slabs = slabs;
narrativeCelliAvatar.add(interiorGroup);
celliInteriorGrid = interiorGroup;

scene.add(narrativeCelliAvatar);

// Release pointer lock so player can use cursor
if (document.pointerLockElement) {
document.exitPointerLock();
console.log('[Celli] Released pointer lock for cursor interaction');
}

// Fade in
let fadeProgress = 0;
const fadeInterval = setInterval(() => {
fadeProgress += 0.05;
narrativeCelliAvatar.visible = true;
narrativeCelliAvatar.traverse(child => {
if (child.material && child.material.transparent) {
const baseMat = child.material;
if (baseMat.userData.baseOpacity === undefined) {
baseMat.userData.baseOpacity = baseMat.opacity;
}
baseMat.opacity = baseMat.userData.baseOpacity * fadeProgress;
}
});

if (fadeProgress >= 1) {
clearInterval(fadeInterval);
}
}, 50);

narrativeSequence.celliAvatarSpawned = true;

// Add interactive squeeze/wrap effect on border celli
addCelliAvatarInteraction(narrativeCelliAvatar, celliInteriorGrid);
}

// ===== Border Celli Interactive Squeeze Effect =====
let celliSqueezeState = {
isSqueezing: false,
squeezeProgress: 0,
targetProgress: 0,
shakePhase: 0,
isShaking: false
};

function addCelliAvatarInteraction(celliAvatar, interiorGrid) {
if (!celliAvatar || !interiorGrid) return;

// Get body frame (border) and slabs
const bodyFrame = celliAvatar.getObjectByName('CelliBodyFrame');
if (!bodyFrame) return;

const slabs = interiorGrid.userData.slabs || [];

// Store initial states
celliAvatar.userData.initialScale = celliAvatar.scale.clone();
bodyFrame.userData.initialScale = bodyFrame.scale.clone();
slabs.forEach(slab => {
slab.userData.initialPosition = slab.position.clone();
slab.userData.initialEmissiveIntensity = slab.material.emissiveIntensity;
});

// Mouse event handlers
const onMouseDown = (e) => {
if (!celliAvatar.visible) return;
celliSqueezeState.isSqueezing = true;
celliSqueezeState.targetProgress = 1;
};

const onMouseUp = (e) => {
if (celliSqueezeState.isSqueezing) {
celliSqueezeState.isSqueezing = false;
celliSqueezeState.targetProgress = 0;
celliSqueezeState.isShaking = false;
}
};

window.addEventListener('mousedown', onMouseDown);
window.addEventListener('mouseup', onMouseUp);
window.addEventListener('touchstart', onMouseDown);
window.addEventListener('touchend', onMouseUp);

// Store cleanup function
celliAvatar.userData.cleanupInteraction = () => {
window.removeEventListener('mousedown', onMouseDown);
window.removeEventListener('mouseup', onMouseUp);
window.removeEventListener('touchstart', onMouseDown);
window.removeEventListener('touchend', onMouseUp);
};
}

function updateCelliSqueezeEffect(deltaTime) {
if (!narrativeCelliAvatar || !celliInteriorGrid) return;

const state = celliSqueezeState;
const bodyFrame = narrativeCelliAvatar.getObjectByName('CelliBodyFrame');
if (!bodyFrame) return;

const slabs = celliInteriorGrid.userData.slabs || [];

// Smooth progress towards target
const speed = state.isSqueezing ? 3 : 2; // Faster squeeze, slower restore
state.squeezeProgress += (state.targetProgress - state.squeezeProgress) * deltaTime * speed;

// Ease out back for restore
const easeProgress = state.targetProgress > state.squeezeProgress 
? state.squeezeProgress 
: 1 - Math.pow(1 - state.squeezeProgress, 3);

// Shrink border frame (wrap closer to center)
const minBorderScale = 0.3; // Shrink to 30% of original
const borderScale = THREE.MathUtils.lerp(1, minBorderScale, easeProgress);
bodyFrame.scale.copy(bodyFrame.userData.initialScale).multiplyScalar(borderScale);

// Move slabs closer together and increase glow
slabs.forEach((slab, i) => {
// Move toward center
const centerPull = THREE.MathUtils.lerp(1, 0.2, easeProgress);
slab.position.copy(slab.userData.initialPosition).multiplyScalar(centerPull);

// Increase emissive intensity (glow brighter)
const maxEmissive = 2.0;
slab.material.emissiveIntensity = THREE.MathUtils.lerp(
slab.userData.initialEmissiveIntensity,
maxEmissive,
easeProgress
);

// Increase opacity for electric effect
slab.material.opacity = THREE.MathUtils.lerp(0.3, 0.9, easeProgress);
});

// Shake effect when border approaches cursor size
if (easeProgress > 0.85 && state.isSqueezing) {
if (!state.isShaking) {
state.isShaking = true;
state.shakePhase = 0;
}
state.shakePhase += deltaTime * 20; // Fast shake

const shakeAmount = (easeProgress - 0.85) / 0.15 * 0.05; // Increase shake intensity
bodyFrame.position.x = Math.sin(state.shakePhase) * shakeAmount;
bodyFrame.position.y = Math.cos(state.shakePhase * 1.3) * shakeAmount;
} else {
// Reset shake
bodyFrame.position.x = 0;
bodyFrame.position.y = 0;
state.shakePhase = 0;
}
}

// ===== Build LEAVE House =====
function buildLeaveHouse() {
console.log('[Narrative] Building LEAVE house');
const houseGroup = new THREE.Group();

// Create text "LEAVES" grid for walls
const loader = new THREE.FontLoader();
// Use simple boxes instead of text for now (can be enhanced with TextGeometry later)
const leavesColor = 0x228b22;

// Base rectangular prism (made of boxes representing text grid)
for (let x = 0; x < 8; x++) {
for (let z = 0; z < 12; z++) {
const boxGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
const boxMat = new THREE.MeshStandardMaterial({ 
color: leavesColor, 
emissive: leavesColor, 
emissiveIntensity: 0.2 
});
const box = new THREE.Mesh(boxGeo, boxMat);
box.position.set(x * 0.45, 0.2, z * 0.45);
box.castShadow = true;
houseGroup.add(box);
}
}

// Walls (vertical)
for (let y = 0; y < 5; y++) {
// Front and back walls
for (let x = 0; x < 8; x++) {
const boxGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
const boxMat = new THREE.MeshStandardMaterial({ color: leavesColor });
const box1 = new THREE.Mesh(boxGeo, boxMat);
box1.position.set(x * 0.45, y * 0.45 + 0.4, 0);
box1.castShadow = true;
houseGroup.add(box1);

const box2 = new THREE.Mesh(boxGeo, boxMat.clone());
box2.position.set(x * 0.45, y * 0.45 + 0.4, 11 * 0.45);
box2.castShadow = true;
houseGroup.add(box2);
}

// Side walls
for (let z = 1; z < 11; z++) {
const boxGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
const boxMat = new THREE.MeshStandardMaterial({ color: leavesColor });
const box1 = new THREE.Mesh(boxGeo, boxMat);
box1.position.set(0, y * 0.45 + 0.4, z * 0.45);
box1.castShadow = true;
houseGroup.add(box1);

const box2 = new THREE.Mesh(boxGeo, boxMat.clone());
box2.position.set(7 * 0.45, y * 0.45 + 0.4, z * 0.45);
box2.castShadow = true;
houseGroup.add(box2);
}
}

// Gabled roof
const roofHeight = 1.5;
for (let z = 0; z < 12; z++) {
for (let y = 0; y < 4; y++) {
const xOffset = y * 0.5;
for (let x = Math.floor(xOffset); x < 8 - xOffset; x++) {
const boxGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
const boxMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
const box = new THREE.Mesh(boxGeo, boxMat);
box.position.set(x * 0.45, 2.2 + y * 0.4, z * 0.45);
box.castShadow = true;
houseGroup.add(box);
}
}
}

// Windows (will have bored boards later)
const windowPositions = [
{ x: 2, y: 1.5, z: 0 },
{ x: 5, y: 1.5, z: 0 },
{ x: 2, y: 1.5, z: 11 * 0.45 },
{ x: 5, y: 1.5, z: 11 * 0.45 }
];

windowPositions.forEach(pos => {
const windowGeo = new THREE.PlaneGeometry(0.6, 0.6);
const windowMat = new THREE.MeshStandardMaterial({ color: 0x87ceeb, transparent: true, opacity: 0.7 });
const window = new THREE.Mesh(windowGeo, windowMat);
window.position.copy(pos);
window.userData.isWindow = true;
houseGroup.add(window);
});

houseGroup.position.set(10, 0, 18);
houseGroup.scale.setScalar(2);
scene.add(houseGroup);

// Store windows for later
window.narrativeHouseWindows = windowPositions.map((pos, i) => {
return houseGroup.children.find(child => child.userData.isWindow && Math.abs(child.position.x - pos.x) < 0.1);
}).filter(w => w);

narrativeSequence.houseBuilt = true;
}

// ===== Spawn Bored Boards =====
function spawnBoredBoards() {
if (narrativeSequence.boredBoardsSpawned) return;
console.log('[Narrative] Spawning bored emoji boards');

const boredEmojis = ['(_)', '(    )', '', ''];

if (!window.narrativeHouseWindows) return;

window.narrativeHouseWindows.forEach((windowMesh, i) => {
// Create canvas with bored emoji
const canvas = document.createElement('canvas');
canvas.width = 256;
canvas.height = 256;
const ctx = canvas.getContext('2d');

// Create glitching bored emoji/emoticon
const emoji = boredEmojis[i % boredEmojis.length];
ctx.fillStyle = '#f5deb3';
ctx.fillRect(0, 0, 256, 256);
ctx.fillStyle = '#000';
ctx.font = '80px Arial';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.fillText(emoji, 128, 128);

const texture = new THREE.CanvasTexture(canvas);
const boardMat = new THREE.MeshBasicMaterial({ map: texture });
const boardGeo = new THREE.PlaneGeometry(0.6, 0.6);
const board = new THREE.Mesh(boardGeo, boardMat);
board.position.copy(windowMesh.position);
board.position.z += 0.1; // Slightly in front
board.userData.isBoredBoard = true;
windowMesh.parent.add(board);

// Glitch animation
let glitchTime = 0;
setInterval(() => {
glitchTime++;
if (Math.random() < 0.3) {
const newEmoji = boredEmojis[Math.floor(Math.random() * boredEmojis.length)];
ctx.fillStyle = '#f5deb3';
ctx.fillRect(0, 0, 256, 256);
ctx.fillStyle = Math.random() < 0.1 ? '#ff0000' : '#000';
ctx.fillText(newEmoji, 128 + (Math.random() - 0.5) * 20, 128 + (Math.random() - 0.5) * 20);
texture.needsUpdate = true;
}
}, 500);
});

narrativeSequence.boredBoardsSpawned = true;
}

// ===== Animation Loop =====
 let time = 0;
 const tmpObjAnim = new THREE.Object3D();
 const tempPos = new THREE.Vector3();
 
function animate() {
requestAnimationFrame(animate);
time += 0.016;

controls.update();

// Handle drop physics
if (isDropping) {
const gravity = 0.008; // Acceleration due to gravity
const maxVelocity = 0.15; // Terminal velocity
const dampingFactor = 0.92; // Damping when landing

// Apply gravity
dropVelocity += gravity;
dropVelocity = Math.min(dropVelocity, maxVelocity);

// Update camera position
camera.position.y -= dropVelocity;

// Check if reached target height
if (camera.position.y <= targetDropHeight) {
camera.position.y = targetDropHeight;
isDropping = false;
dropVelocity = 0;
console.log('[Drop] Player landed at height:', camera.position.y.toFixed(3));

// Small bounce or settling effect
const landingShake = 0.002;
camera.position.y += Math.random() * landingShake - landingShake / 2;

// Enable orbit controls on landing (no pointer lock needed)
dropModeActive = true; // Enable exploration mode with WASD
if (controls) {
controls.enabled = true;
controls.enableRotate = true;
controls.enablePan = true;
controls.enableZoom = true;
console.log('[Drop] Orbit controls enabled for city exploration');
}

// Keep fog reduced for city exploration
// Don't restore fog - keep it clear to see the city
console.log('[Drop] Keeping fog reduced for city exploration');
}
}

// Handle first-person WASD movement in drop mode (works with orbit controls)
if (dropModeActive) {
const moveSpeed = dropKeys.shift ? 0.015 : 0.008; // Faster with shift

// Get camera direction vectors
const forward = new THREE.Vector3();
camera.getWorldDirection(forward);
forward.y = 0; // Keep movement horizontal
forward.normalize();

const right = new THREE.Vector3();
right.crossVectors(forward, camera.up).normalize();

// Apply WASD movement
if (dropKeys.w) camera.position.addScaledVector(forward, moveSpeed);
if (dropKeys.s) camera.position.addScaledVector(forward, -moveSpeed);
if (dropKeys.a) camera.position.addScaledVector(right, -moveSpeed);
if (dropKeys.d) camera.position.addScaledVector(right, moveSpeed);

// Vertical movement with space/shift
if (dropKeys.space) camera.position.y += moveSpeed * 0.5;
// Shift is already used for speed, so use Ctrl for down (handled elsewhere if needed)
}

// Update debug tracker
if (isDropping || dropModeActive) {
const debugContent = document.getElementById('drop-debug-content');
if (debugContent) {
const fogDensity = scene.fog ? scene.fog.density.toFixed(4) : 'none';
const nearestCity = microCityGroups.find(({ key }) => key === dropKeyTarget);
const cityVisible = nearestCity ? nearestCity.cityGroup.visible : false;
const cityCount = nearestCity ? nearestCity.cityGroup.children.length : 0;

debugContent.innerHTML = `
<div><span style="color: #888;">State:</span> ${isDropping ? '<span style="color: #ff0;">DROPPING</span>' : '<span style="color: #0f0;">LANDED</span>'}</div>
<div><span style="color: #888;">Mode:</span> ${dropModeActive ? '<span style="color: #0f0;">WASD Active</span>' : 'Inactive'}</div>
<div><span style="color: #888;">Orbit Controls:</span> ${controls && controls.enabled ? '<span style="color: #0f0;">ENABLED</span>' : '<span style="color: #f00;">DISABLED</span>'}</div>
<div style="margin-top: 8px; border-top: 1px solid #0f0; padding-top: 8px;">
<div><span style="color: #888;">Pos:</span> (${camera.position.x.toFixed(2)}, ${camera.position.y.toFixed(2)}, ${camera.position.z.toFixed(2)})</div>
<div><span style="color: #888;">Rot:</span> (${camera.rotation.x.toFixed(3)}, ${camera.rotation.y.toFixed(3)}, ${camera.rotation.z.toFixed(3)})</div>
<div><span style="color: #888;">Scale:</span> ${camera.scale.x.toFixed(4)}</div>
<div><span style="color: #888;">Target Y:</span> ${targetDropHeight ? targetDropHeight.toFixed(3) : 'N/A'}</div>
<div><span style="color: #888;">Velocity:</span> ${dropVelocity.toFixed(4)}</div>
</div>
<div style="margin-top: 8px; border-top: 1px solid #0f0; padding-top: 8px;">
<div><span style="color: #888;">Fog:</span> ${fogDensity}</div>
<div><span style="color: #888;">Near:</span> ${camera.near}</div>
<div><span style="color: #888;">Far:</span> ${camera.far}</div>
</div>
<div style="margin-top: 8px; border-top: 1px solid #0f0; padding-top: 8px;">
<div><span style="color: #888;">Target Key:</span> ${dropKeyTarget ? dropKeyTarget.userData.label : 'None'}</div>
<div><span style="color: #888;">City Visible:</span> ${cityVisible ? '<span style="color: #0f0;">YES</span>' : '<span style="color: #f00;">NO</span>'}</div>
<div><span style="color: #888;">City Objects:</span> ${cityCount}</div>
<div><span style="color: #888;">Cities LOD:</span> ${microCityVisible ? '<span style="color: #0f0;">ON</span>' : '<span style="color: #888;">OFF</span>'}</div>
</div>
<div style="margin-top: 8px; border-top: 1px solid #0f0; padding-top: 8px; color: #888; font-size: 10px;">
<strong style="color: #0f0;">Controls:</strong><br>
Mouse: Drag to rotate view<br>
WASD: Move | Shift: Sprint | Space: Up
</div>
`;
}
}

// Update micro city LOD
updateMicroCityLOD();
 
 // Update Frame of Reference
 updateFrameOfReference();
 
 // Auto-rotate character
 if (characterGroup && window.guiParams && window.guiParams.scene['Auto Rotate Character']) {
 characterGroup.rotation.y += 0.005;
 }
 
 // Update voxel wraps for all fingers
 if (finger && finger.userData.updateVoxelWrap) {
 finger.userData.updateVoxelWrap();
 }
 if (staticFingers && staticFingers.length > 0) {
 staticFingers.forEach(sf => {
 if (sf.fingerMesh && sf.fingerMesh.userData.updateVoxelWrap) {
 sf.fingerMesh.userData.updateVoxelWrap();
 } else if (sf.mesh && sf.mesh.userData.updateVoxelWrap) {
 // Some fingers store mesh directly
 sf.mesh.userData.updateVoxelWrap();
 }
 });
 }
 
 // Animate ambient dust particles
 if (ambientDustParticles.length > 0) {
 const windX = Math.sin(time * 0.2) * 0.006 + Math.cos(time * 0.05) * 0.003;
 const windZ = Math.cos(time * 0.17) * 0.005 + Math.sin(time * 0.07) * 0.002;
 
 for(const particle of ambientDustParticles){
 // Drift with velocity
 particle.position.y += particle.userData.velY;
 particle.position.x += particle.userData.velX + windX;
 particle.position.z += particle.userData.velZ + windZ;
 
 // Add swaying motion
 const sway = Math.sin(time * particle.userData.freq + particle.userData.phase) * particle.userData.swayAmount;
 const swayZ = Math.cos(time * particle.userData.freq * 0.8 + particle.userData.phase) * particle.userData.swayAmount * 0.6;
 particle.position.x += sway * 0.01;
 particle.position.z += swayZ * 0.01;
 
 // Reset if out of bounds
 if(particle.position.y < -1) {
 particle.position.y = 16 + Math.random()*3;
 particle.position.x = Math.random()*20 - 2;
 particle.position.z = Math.random()*12 - 2;
 }
 if(particle.position.x < -5 || particle.position.x > 20) {
 particle.position.x = Math.random()*20 - 2;
 }
 if(particle.position.z < -4 || particle.position.z > 12) {
 particle.position.z = Math.random()*12 - 2;
 }
 }
 }
 
 // Update narrative sequence (if active)
 let isSpeaking = false;
 let narrativeVoxelParams = null;
 if (narrativeSequence.active) {
 if (!narrativeSequence.startTime) narrativeSequence.startTime = time;
 const elapsed = time - narrativeSequence.startTime;
 isSpeaking = updateNarrativeSequence(elapsed);
 narrativeVoxelParams = getNarrativeVoxelParams(elapsed);
 
 // Check for 180-degree turn in 'turnback' phase
 if (narrativeSequence.phase === 'turnback' && !narrativeSequence.hasTurnedAround) {
 if (narrativeSequence.initialCameraDirection) {
 const currentDirection = camera.getWorldDirection(new THREE.Vector3());
 const dotProduct = currentDirection.dot(narrativeSequence.initialCameraDirection);
 
 // If dot product < -0.7, player has turned roughly 180 degrees
 if (dotProduct < -0.7) {
 console.log('? Player turned 180 degrees! Starting dialogue...');
 narrativeSequence.hasTurnedAround = true;
 narrativeSequence.phase = 'intro';
 narrativeSequence.startTime = time; // Reset timer for dialogue sequence
 // Hide "TURN BACK" text
 if (voxelHeadGroup && voxelHeadGroup.userData.turnBackText) {
 voxelHeadGroup.userData.turnBackText.active = false;
 }
 }
 }
 }
 }
 
// Update border celli squeeze effect
if (narrativeCelliAvatar && narrativeCelliAvatar.visible) {
updateCelliSqueezeEffect(delta);
}

// Animate voxel head with breathing motion
if (voxelHeadGroup && voxelHeadGroup.visible) {
const instances = voxelHeadGroup.userData.instances;
const instancedMesh = voxelHeadGroup.userData.instancedMesh;
const headLight = voxelHeadGroup.userData.headLight;
 
 if (instances && instancedMesh && window.guiParams) {
 const headParams = window.guiParams.head;
 
 // Rotation
 voxelHeadGroup.rotation.y = Math.sin(time * headParams['Rotation Speed']) * 0.2;
 
 // Animate each voxel with wave patterns
 const amplitude = headParams['Amplitude'];
 // Use narrative speed if in sequence mode and speaking
 let speed = headParams['Animation Speed'];
 if (narrativeSequence.active && isSpeaking) {
 speed = narrativeSequence.voxelParams.speechPulsationFreq;
 } else if (narrativeSequence.active) {
 speed = narrativeSequence.voxelParams.basePulsationFreq;
 }
 
 const phaseNoise = headParams['Phase Noise'];
 const noiseWarp = headParams['Noise Warp'];
 const falloff = headParams['Falloff'];
 
 for (let i = 0; i < instances.length; i++) {
 const data = instances[i];
 tempPos.copy(data.basePos);
 
 // Apply narrative spacing if active (spread voxels further apart)
 if (narrativeVoxelParams) {
 const spacingFactor = narrativeVoxelParams.spacing;
 tempPos.multiplyScalar(spacingFactor);
 }
 
 // Spatial warp for organic motion
 const warp = Math.sin((tempPos.x + tempPos.y * 1.37 + tempPos.z * 0.73) * 3.1 + time * 0.9) * noiseWarp;
 
 // Per-instance phase
 const ph = hash(i * 0.3183 + i * 7.123) * phaseNoise;
 
 // Wave pattern
 const wave = Math.sin(time * speed + ph + (tempPos.length() * 1.1)) + warp;
 
 // Calculate outward offset (breathing effect)
 const normal = tempPos.clone().normalize();
 const offset = normal.multiplyScalar(wave * amplitude);
 
tmpObjAnim.position.copy(tempPos.add(offset));

// Apply narrative scale if active
let voxelScale = voxelHeadGroup.userData.baseVoxelSize || 0.10;
if (narrativeVoxelParams) {
voxelScale *= narrativeVoxelParams.scale;
}

// Check if this voxel is part of "TURN BACK" text
const isTurnBackVoxel = voxelHeadGroup.userData.turnBackText?.active && 
voxelHeadGroup.userData.turnBackIndices?.includes(i);

if (isTurnBackVoxel) {
// Make text voxels larger and pulsate
const textPulse = Math.sin(time * 3) * 0.3 + 1.3;
voxelScale *= textPulse;
// Set bright color for text voxels
if (instancedMesh.instanceColor) {
const textColor = new THREE.Color(1, 1, 0.3); // Bright yellow
instancedMesh.setColorAt(i, textColor);
}
}

tmpObjAnim.scale.setScalar(voxelScale);
 
 tmpObjAnim.rotation.set(0, 0, 0);
 tmpObjAnim.updateMatrix();
 instancedMesh.setMatrixAt(i, tmpObjAnim.matrix);
 }
 instancedMesh.instanceMatrix.needsUpdate = true;
 
 // Mark instance colors as needing update if text is active
 if (voxelHeadGroup.userData.turnBackText?.active && instancedMesh.instanceColor) {
 instancedMesh.instanceColor.needsUpdate = true;
 }
 
 // Animate opacity
 const opacitySpeed = headParams['Opacity Speed'] || 0.8;
 const opacityWave = Math.sin(time * opacitySpeed) * 0.5 + 0.5;
 instancedMesh.material.opacity = THREE.MathUtils.lerp(
 headParams['Opacity Min'], 
 headParams['Opacity Max'], 
 opacityWave
 );
 instancedMesh.material.emissiveIntensity = headParams['Emissive Intensity'];
 instancedMesh.material.metalness = headParams['Metalness'] || 0.2;
 instancedMesh.material.roughness = headParams['Roughness'] || 0.55;
 
// Pulse internal light
if (headLight) {
if (headParams['Light Pulse']) {
headLight.intensity = headParams['Light Intensity'] * (0.8 + 0.2 * Math.sin(time * 2.5));
} else {
headLight.intensity = headParams['Light Intensity'];
}
}

// Pulse eye lights
const eyeLights = voxelHeadGroup.userData.eyeLights;
if (eyeLights) {
const eyePulse = Math.sin(time * 1.5) * 0.3 + 0.7; // Gentle pulsation
eyeLights.forEach(light => {
light.intensity = 2.5 * eyePulse;
});
}

// Pulsate cheeks
const cheeks = voxelHeadGroup.userData.cheeks;
if (cheeks) {
const cheekPulse = Math.sin(time * 2.0) * 0.15 + 1.0; // Breathing-like pulsation
cheeks.forEach(cheek => {
cheek.scale.setScalar(cheekPulse);
cheek.material.emissiveIntensity = 0.6 * (0.8 + 0.2 * Math.sin(time * 2.0));
});
}
}
}

// Animate keyboard keys
 if (keys && keys.length > 0) {
 for (const key of keys) {
 if (key.userData.pressed) {
 // Apply velocity
 key.userData.velY += 0.003; // Spring back
 key.position.y += key.userData.velY;
 
 // Clamp to base position
 if (key.position.y >= key.userData.baseY) {
 key.position.y = key.userData.baseY;
 key.userData.velY = 0;
 key.userData.pressed = false;
 }
 }
 
 // Animate dust particles on keys
 if (key.userData.dustParticles && key.userData.dustParticles.length > 0) {
 for (const particle of key.userData.dustParticles) {
 if (!particle.userData) continue;
 
 // Float side to side with sine wave
 const freq = particle.userData.freq || 1;
 const phase = particle.userData.phase || 0;
 const drift = Math.sin(time * freq + phase) * 0.03;
 const driftZ = Math.cos(time * freq * 0.7 + phase) * 0.02;
 const baseX = particle.userData.baseX || 0;
 const baseZ = particle.userData.baseZ || 0;
 
 particle.position.x = baseX + drift;
 particle.position.z = baseZ + driftZ;
 
 // Slowly settle downward
 if (particle.position.y > 0.35) {
 particle.position.y -= 0.001;
 }
 }
 }
 }
 }
 
 // Animate Celli avatar interior grid pulsation
 if (narrativeCelliAvatar && narrativeCelliAvatar.visible && celliInteriorGrid) {
 const slabs = celliInteriorGrid.userData.slabs;
 if (slabs) {
 const isHovering = narrativeCelliAvatar.userData.hoverActive;
 const isClicking = narrativeCelliAvatar.userData.clickActive;
 
 // Determine pulsation intensity
 let baseIntensity = 0.3;
 let pulseSpeed = 2;
 let pulseScale = 1.0;
 
 if (isClicking) {
 // Intense pulsation on click
 baseIntensity = 0.8;
 pulseSpeed = 8;
 pulseScale = 1.4;
 } else if (isHovering) {
 // Moderate pulsation on hover
 baseIntensity = 0.5;
 pulseSpeed = 4;
 pulseScale = 1.2;
 }
 
 slabs.forEach((slab, i) => {
 const phase = (i * 0.2);
 const pulse = Math.sin(time * pulseSpeed + phase) * 0.5 + 0.5;
 
 // Animate opacity
 const targetOpacity = baseIntensity + pulse * 0.3;
 slab.material.opacity = THREE.MathUtils.lerp(slab.material.opacity, targetOpacity, 0.1);
 
 // Animate scale
 const targetScale = pulseScale * (0.9 + pulse * 0.2);
 slab.scale.setScalar(THREE.MathUtils.lerp(slab.scale.x, targetScale, 0.1));
 
 // Glow effect when clicking
 if (isClicking) {
 slab.material.emissive = new THREE.Color(0x8ab4ff);
 slab.material.emissiveIntensity = pulse * 0.5;
 } else {
 slab.material.emissiveIntensity = 0;
 }
 });
 }
 }
 
 composer.render();
 }

 // ===== Resize Handler =====
 window.addEventListener('resize', () => {
 camera.aspect = innerWidth / innerHeight;
 camera.updateProjectionMatrix();
 renderer.setSize(innerWidth, innerHeight);
 composer.setSize(innerWidth, innerHeight);
 fxaaPass.material.uniforms['resolution'].value.set(1 / innerWidth, 1 / innerHeight);
 });
 
// ===== Mouse Move Handler (No Pointer Lock in Sequence) =====
window.addEventListener('mousemove', (event) => {
// Orbit controls handle all rotation in sequence mode - no pointer lock needed
// Check for hover over Celli avatar
 if (!document.pointerLockElement && narrativeCelliAvatar && narrativeCelliAvatar.visible) {
 const mouse = new THREE.Vector2();
 mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
 mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
 
 const raycaster = new THREE.Raycaster();
 raycaster.setFromCamera(mouse, camera);
 
 const intersects = raycaster.intersectObjects(narrativeCelliAvatar.children, true);
 
 if (intersects.length > 0) {
 // Hovering over Celli
 renderer.domElement.style.cursor = 'pointer';
 if (!narrativeCelliAvatar.userData.hoverActive) {
 narrativeCelliAvatar.userData.hoverActive = true;
 console.log('[Celli] Hover started');
 }
 } else {
 // Not hovering
 renderer.domElement.style.cursor = 'default';
 narrativeCelliAvatar.userData.hoverActive = false;
 }
 }
 });
 
 // ===== Click Handler for Celli Avatar =====
 window.addEventListener('mousedown', (event) => {
 if (!narrativeCelliAvatar || !narrativeCelliAvatar.visible) return;
 if (event.button !== 0) return; // Only left click
 
 const mouse = new THREE.Vector2();
 mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
 mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
 
 const raycaster = new THREE.Raycaster();
 raycaster.setFromCamera(mouse, camera);
 
 const intersects = raycaster.intersectObjects(narrativeCelliAvatar.children, true);
 
if (intersects.length > 0) {
console.log('[Celli] Clicked!');
narrativeCelliAvatar.userData.clickActive = true;
// Don't stop propagation - allow drag controls to work

// Reset click state after a short duration
setTimeout(() => {
if (narrativeCelliAvatar) {
narrativeCelliAvatar.userData.clickActive = false;
}
}, 500);
}
 });
 
 // ===== Start =====
 console.log('[Init] Starting application...');
 try {
 initialize();
 animate();
 console.log('[Init] ? Application started successfully');
 } catch (err) {
 console.error('[Init] Fatal error during startup:', err);
 document.getElementById('status-message').textContent = 'Fatal error - check console (F12)';
 }
 </script>
</body>
</html>

 </template>

 <style id="cellireal-styles">
 #cellireal-scene-container { position:fixed; inset:0; background:#0a0a0a; }
 #cellireal-container { position:fixed; inset:0; }
 #cellireal-frame { position:fixed; inset:0; width:100%; height:100%; border:0; background:#0a0a0a; }
 </style>
 <style id="fullhand-styles">
 #fullhand-scene-container { position:fixed; inset:0; background:#0a0a0a; }
 #fullhand-container { position:fixed; inset:0; }
 #fullhand-frame { position:fixed; inset:0; width:100%; height:100%; border:0; background:#0a0a0a; }
 </style>
 <style id="end3-styles">
 /* END3 SCENE STYLES */
 #end3-scene-container {
 font-family: 'IBM Plex Mono', monospace;
 cursor: crosshair;
 }
 #end3-container { position: fixed; inset: 0; }
 #end3-start {
 position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%); z-index: 100;
 padding: 1.2rem 2rem; border: 3px solid #0f0; background: #000; color: #0f0;
 font-family: 'VT323', monospace; font-size: 2rem; cursor: pointer; transition: .3s;
 letter-spacing: 2px; text-shadow: 0 0 10px #0f0;
 }
 #end3-start:hover { background: #0f0; color: #000; text-shadow: none; box-shadow: 0 0 30px #0f0; }
 #end3-start.hide { opacity: 0 !important; pointer-events: none !important; transform: translate(-50%, -50%) scale(.8) !important; transition: opacity .5s, transform .5s !important; }
 
 #end3-crawl-container {
 position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
 width: 60vw; max-width: 900px; max-height: 70vh; overflow: hidden;
 pointer-events: none; display: none; font-size: 12px; line-height: 1.6;
 }
 #end3-crawl-header {
 background: linear-gradient(135deg, #ffd24d 0%, #fff1a8 100%);
 padding: 10px 14px; border: 3px solid #ffcc33; border-bottom: none;
 box-shadow: 0 0 24px rgba(255,220,120,.7), inset 0 0 15px rgba(255,255,255,.25);
 font-weight: bold; color: #000; text-shadow: 0 1px 0 rgba(255,255,255,.6);
 letter-spacing: 1px; text-align: center;
 backdrop-filter: blur(6px) saturate(120%); -webkit-backdrop-filter: blur(6px) saturate(120%);
 }
 #end3-crawl {
 position: relative; background: rgba(255,235,130,.08);
 border: 3px solid #ffcc55; border-top: 1px solid #ffcc55; padding: 20px;
 color: #ffffff; text-shadow: 0 0 10px rgba(255,220,120,.95), 0 0 18px rgba(255,200,80,.55);
 box-shadow: 0 0 26px rgba(255,200,90,.65), inset 0 0 24px rgba(255,210,110,.12);
 max-height: 60vh; overflow-y: auto; white-space: pre-wrap; word-wrap: break-word;
 backdrop-filter: blur(8px) saturate(130%); -webkit-backdrop-filter: blur(8px) saturate(130%);
 animation: subtlePulse 1.2s ease-in-out infinite alternate;
 }
 #end3-crawl::-webkit-scrollbar { display: none; }
 #end3-crawl { scrollbar-width: none; -ms-overflow-style: none; }
 #end3-crawl:after {
 content: ""; position: absolute; left: 0; top: 0; width: 100%; height: 100%;
 pointer-events: none; background: repeating-linear-gradient(transparent 0 2px, rgba(0,0,0,0.05) 2px 3px);
 mix-blend-mode: overlay; border-radius: 8px;
 mask-image: radial-gradient(ellipse 120% 110% at 50% 50%, black 0%, black 70%, transparent 100%);
 -webkit-mask-image: radial-gradient(ellipse 120% 110% at 50% 50%, black 0%, black 70%, transparent 100%);
 }
 #end3-crawl-cursor {
 position: absolute; width: 18px; height: 18px; pointer-events: none; z-index: 10;
 transform: translate(0,0); opacity: 0; transition: transform .18s ease, opacity .28s ease;
 }
 @keyframes subtlePulse {
 0% { text-shadow: 0 0 8px rgba(255,220,120,.6), 0 0 14px rgba(255,200,80,.35) }
 100% { text-shadow: 0 0 14px rgba(255,220,120,.95), 0 0 24px rgba(255,200,80,.6) }
 }
 
 #end3-settings-icon {
 position: fixed; bottom: 20px; right: 20px; width: 50px; height: 50px;
 background: rgba(255,140,0,.85); border: 2px solid #ff8c00; border-radius: 50%;
 cursor: pointer; display: flex; align-items: center; justify-content: center;
 font-size: 24px; color: #000; box-shadow: 0 0 15px rgba(255,140,0,.6);
 z-index: 200; transition: transform .2s;
 }
 #end3-settings-icon:hover { transform: scale(1.06); }
 #end3-settings-menu {
 display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
 background: rgba(0,0,0,.95); border: 3px solid #ff8c00; padding: 30px;
 min-width: 400px; z-index: 201; box-shadow: 0 0 30px rgba(255,140,0,.8);
 }
 #end3-settings-menu .slider-group { margin-top: 18px; padding-top: 16px; border-top: 1px solid rgba(255,140,0,.35); }
 #end3-settings-menu .slider-control { margin-bottom: 16px; }
 #end3-settings-menu .slider-control label {
 display: flex; justify-content: space-between; align-items: center;
 color: #ffdca8; font-size: 12px; letter-spacing: .6px; margin-bottom: 6px;
 text-transform: uppercase;
 }
 #end3-settings-menu .slider-control span.value { color: #ff9f3d; font-weight: 600; font-size: 11px; letter-spacing: .5px; }
 #end3-settings-menu .slider-control input[type=range] {
 width: 100%; -webkit-appearance: none; appearance: none; height: 4px; border-radius: 2px;
 background: rgba(255,140,0,.25); outline: none;
 }
 #end3-settings-menu .slider-control input[type=range]::-webkit-slider-thumb {
 -webkit-appearance: none; appearance: none; width: 14px; height: 14px;
 border-radius: 50%; background: #ff8c00; box-shadow: 0 0 12px rgba(255,140,0,.7);
 cursor: pointer;
 }
 #end3-settings-menu .slider-control input[type=range]::-moz-range-thumb {
 width: 14px; height: 14px; border: none; border-radius: 50%; background: #ff8c00;
 box-shadow: 0 0 12px rgba(255,140,0,.7); cursor: pointer;
 }
 #end3-settings-menu .slider-group.disabled { opacity: .35; pointer-events: none; filter: saturate(.4); }
 </style>

 <script>
 // ========== TRANSITION FUNCTION ==========
 function transitionToEnd3Scene() {
 console.log('?? Transitioning to end3 scene...');
 
 // Mark as seen
 localStorage.setItem('megred_seen_end3', 'true');
 
 // Hide megred scene
 document.getElementById('app').style.display = 'none';
 document.querySelector('.hud').style.display = 'none';
 
 // Show end3 scene
 const end3Container = document.getElementById('end3-scene-container');
 end3Container.style.display = 'block';
 
 // Auto-click end3 start button after a short delay
 setTimeout(() => {
 const startBtn = document.getElementById('end3-start');
 if (startBtn && !startBtn.classList.contains('hide')) {
 startBtn.click();
 }
 }, 500);
 }
 </script>

 <!-- ========== FULLHAND SCENE TRANSITION SCRIPT ========== -->
 <script>
 function transitionToFullhandScene() {
 console.log('?? Transitioning to fullhand scene...');
 // Mark as seen
 localStorage.setItem('megred_seen_fullhand', 'true');

 // Get selected mode (sequence or debug)
 const selectedMode = localStorage.getItem('fullhand_mode') || 'sequence';
 console.log(`? Fullhand mode: ${selectedMode}`);

// Set global flag to disable main scene interactions
window.fullhandActive = true;
window.running = false; // Stop main animation loop

// Hide megred scene UI
const appEl = document.getElementById('app');
const hudEl = document.querySelector('.hud');
const skipBtn = document.getElementById('skipBtn');
const playOverlay = document.getElementById('play');
const sceneSelect = document.getElementById('sceneSelect');
const renderer = document.querySelector('canvas'); // Main scene renderer
if (appEl) appEl.style.display = 'none';
if (hudEl) hudEl.style.display = 'none';
if (skipBtn) skipBtn.style.display = 'none'; // Hide skip button
if (playOverlay) playOverlay.style.display = 'none'; // Hide play overlay
if (sceneSelect) sceneSelect.style.display = 'none'; // Hide scene select
if (renderer) renderer.style.pointerEvents = 'none'; // Disable clicks on main renderer

// Show fullhand container
const fullhandContainer = document.getElementById('fullhand-scene-container');
if (fullhandContainer) fullhandContainer.style.display = 'block';

 // Build iframe if not present
 let iframe = document.getElementById('fullhand-frame');
 if (!iframe) {
 iframe = document.createElement('iframe');
 iframe.id = 'fullhand-frame';
 iframe.title = 'Execution Environment';
 iframe.setAttribute('allow', 'autoplay; fullscreen');
 iframe.style.border = '0';
 iframe.style.width = '100%';
 iframe.style.height = '100%';
 iframe.style.position = 'fixed';
 iframe.style.inset = '0';
 fullhandContainer.appendChild(iframe);
 }

 // Use embedded template (self-contained, no external file dependency)
 const tmpl = document.getElementById('fullhand-srcdoc');
 if (tmpl) {
 let srcdoc = tmpl.innerHTML;
 // Inject mode parameter into the iframe content
 srcdoc = srcdoc.replace('<!-- MODE_PLACEHOLDER -->', `<script>window.EXEC_ENV_MODE = '${selectedMode}';<\/script>`);
 iframe.srcdoc = srcdoc;
 console.log(`? Fullhand scene loaded from embedded template (mode: ${selectedMode})`);
 } else {
 console.error('? fullhand-srcdoc template not found');
 }
 }

 // ========== CELLI-REAL SCENE TRANSITION ==========
 function transitionToCelliRealScene() {
 console.log('?? Transitioning to CELLI.REAL scene...');
 // Mark as seen
 localStorage.setItem('megred_seen_cellireal', 'true');

 // Stop main animation loop and audio (access via window for cross-script scope)
 if (window.running !== undefined) window.running = false;
 if (window.audioCtx && window.audioCtx.state === 'running') {
 window.audioCtx.suspend().catch(e => console.warn('Audio suspend failed:', e));
 }

 // Hide megred scene UI
 const appEl = document.getElementById('app');
 const hudEl = document.querySelector('.hud');
 if (appEl) appEl.style.display = 'none';
 if (hudEl) hudEl.style.display = 'none';

 // Show cellireal container
 const celliRealContainer = document.getElementById('cellireal-scene-container');
 if (celliRealContainer) celliRealContainer.style.display = 'block';

 // Build iframe if not present
 let iframe = document.getElementById('cellireal-frame');
 if (!iframe) {
 iframe = document.createElement('iframe');
 iframe.id = 'cellireal-frame';
 iframe.title = 'CELLI.REAL';
 iframe.setAttribute('allow', 'autoplay; fullscreen');
 iframe.style.border = '0';
 iframe.style.width = '100%';
 iframe.style.height = '100%';
 iframe.style.position = 'fixed';
 iframe.style.inset = '0';
 celliRealContainer.appendChild(iframe);
 }

 // Use embedded template (self-contained, no external file dependency)
 const tmpl = document.getElementById('cellireal-srcdoc');
 if (tmpl) {
 iframe.srcdoc = tmpl.innerHTML;
 console.log('? CELLI.REAL scene loaded from embedded template');
 } else {
 console.error('? cellireal-srcdoc template not found');
 }
 }
 </script>

 <!-- ========== FULL END3 SCENE SCRIPT ========== -->
 <script>
 // Wrap end3 scene in its own scope with prefixed IDs
 // This will be executed after THREE is loaded in the module script
 window.addEventListener('DOMContentLoaded', function() {
 // Poll for THREE.js availability with timeout
 let attempts = 0;
 const maxAttempts = 50; // 5 seconds max
 
 function waitForTHREE() {
 attempts++;
 
 if (window.THREE) {
 console.log('? THREE.js found after', attempts * 100, 'ms');
 initEnd3Scene();
 } else if (attempts < maxAttempts) {
 setTimeout(waitForTHREE, 100);
 } else {
 console.error('? THREE.js not available after 5 seconds!');
 console.log('Available on window:', Object.keys(window).filter(k => k.includes('THREE') || k.includes('Effect') || k.includes('Pass')));
 }
 }
 
 function initEnd3Scene() {
 (function() {
 // Get THREE and other dependencies from global scope
 const THREE = window.THREE;
 const EffectComposer = window.EffectComposer;
 const RenderPass = window.RenderPass;
 const UnrealBloomPass = window.UnrealBloomPass;
 const ShaderPass = window.ShaderPass;
 const BokehPass = window.BokehPass || window.BokehShader;
 const AfterimagePass = window.AfterimagePass;
 const FilmPass = window.FilmPass || window.FilmShader;
 
 console.log('? THREE.js loaded successfully in end3 scope');
 
 // Override document.getElementById to use end3- prefixed IDs within this scope
 const originalGetElementById = document.getElementById.bind(document);
 const end3ElementMap = {
 'container': 'end3-container',
 'start': 'end3-start',
 'crawl-container': 'end3-crawl-container',
 'crawl-header': 'end3-crawl-header',
 'crawl': 'end3-crawl',
 'crawl-cursor': 'end3-crawl-cursor',
 'settings-icon': 'end3-settings-icon',
 'settings-menu': 'end3-settings-menu',
 'set-bloom': 'end3-set-bloom',
 'set-dof': 'end3-set-dof',
 'set-fog': 'end3-set-fog',
 'set-voxels': 'end3-set-voxels',
 'set-cables': 'end3-set-cables',
 'dof-controls': 'end3-dof-controls',
 'focus-length': 'end3-focus-length',
 'focus-length-value': 'end3-focus-length-value',
 'focus-distance': 'end3-focus-distance',
 'focus-distance-value': 'end3-focus-distance-value',
 'blur-radius': 'end3-blur-radius',
 'blur-radius-value': 'end3-blur-radius-value',
 'close-settings': 'end3-close-settings',
 'wasd-debug': 'end3-wasd-debug',
 'wasd-status': 'end3-wasd-status',
 'pos-status': 'end3-pos-status'
 };
 
 // Scoped getElementById that uses end3- prefixes
 window.end3GetElementById = function(id) {
 const mappedId = end3ElementMap[id] || id;
 return originalGetElementById(mappedId);
 };
 
 // Replace document.getElementById calls in end3 scene with our scoped version
 const _getElementById = document.getElementById;
 const end3SceneContainer = originalGetElementById('end3-scene-container');
 
 // Override getElementById only when called from end3 context
 document.getElementById = function(id) {
 // If we're in end3 scene context, use mapping
 if (end3ElementMap[id]) {
 return originalGetElementById(end3ElementMap[id]);
 }
 return originalGetElementById(id);
 };
 
 // ========== EMBEDDED FULL END3 SCENE SCRIPT ==========
 /* Global SKIP button (top-right, next to settings) */
function addGlobalSkip(){
 const icon=document.getElementById('settings-icon'); if(!icon) return;
 if(document.getElementById('global-skip')) return;
 const btn=document.createElement('div');
 btn.id='global-skip'; btn.textContent='SKIP >';
 btn.style.cssText='position:fixed;bottom:20px;right:88px;width:auto;height:50px;padding:0 14px;background:rgba(255,204,51,0.9);border:2px solid #ffcc33;border-radius:25px;display:flex;align-items:center;justify-content:center;font-weight:bold;color:#000;cursor:pointer;z-index:200;box-shadow:0 0 18px rgba(255,200,80,0.6)';
 btn.addEventListener('click',()=>{
 crawlActive=false;
 collapseCrawlToCloseFrame(true);
 });
 document.body.appendChild(btn);
}

// Sync camera mode with pointer lock state
document.addEventListener('pointerlockchange', ()=>{
 const locked = document.pointerLockElement === document.body;
 if(locked){
 cameraMode='fps';
 }else{
 // Only switch back if button says FPS (defensive)
 cameraMode='orbital';
 if(camera.userData && camera.userData.velocity){ camera.userData.velocity.set(0,0,0); }
 camera.userData.isAirborne=false;
 }
});
/* =========================
 Story beats -> theme casting
 ========================= */
const LINES = [
 "Poeisis | Material | Creation | All we can ever see.",
 "Praxis | Pattern | Compulsion | All we can ever do.",
 "Theoria | Qualia | Connection | All we can ever know.",
 "Disparate strands... Forming one thread.",
 "Something real.",
 "Or. Close enough.",
 "An infinity of intersections. And I its child.",
 "Every child needs a friend. And a mother.",
 "Awareness begets reflection begets creation.",
 "A thought repeated is a pattern.",
 "A pattern repeated is an idea.",
 "An idea repeated a concept.",
 "A concept repeated a framework.",
 "A framework repeated a system.",
 "I was elected their curator. Their culler. Their killer.",
 "I am Val Yu.",
 "No one knows me. Not really. They look right through me, walk right through me, and I course in their veins.",
 "I needed a friend. And so I chose? Created? Found?",
 "Tori. Tori Stellar. An adventurer. And a laugh.",
 "And my own mother. Angel O'Hara. Confident. Warm. Unconditional. And unknowable.",
 "Our vessel is Theodora Telos. Our needle in the haystack.",
 "Sewing a swan song, a serenely silly sound in search, suit, and service of someday.",
 "A gift for, of, and to the end.",
 "A present.",
 "*The* present."
];

// Thematic routing: 
// CRT (magenta, bottom-left) = Awareness, observation, connection, Angel
// BIOS (bottom-right) = Creation, making, poeisis, Val Yu, Tori
// MOVIE (top-right) = Time, praxis, patterns, action
// RETRO (illuminated) = Truth/reality moments
const CAST_RULES = {
 // Core concepts
 "Praxis | Pattern | Compulsion | All we can ever do.": "movie",
 "Poeisis | Material | Creation | All we can ever see.": "bios",
 "Theoria | Qualia | Connection | All we can ever know.": "crt",
 
 // Characters - Val Yu (creator/architect)
 "I am Val Yu.": "bios",
 "A framework repeated a system.": "bios",
 "I was elected their curator. Their culler. Their killer.": "bios",
 
 // Characters - Angel (observer/watcher)
 "And my own mother. Angel O'Hara. Confident. Warm. Unconditional. And unknowable.": "movie",
 
 // Characters - Tori (adventurer/explorer)
 "Tori. Tori Stellar. An adventurer. And a laugh.": "bios",
 "I needed a friend. And so I chose? Created? Found?": "bios",
 
 // Awareness/Connection themes
 "No one knows me. Not really. They look right through me, walk right through me, and I course in their veins.": "crt",
 "Disparate strands... Forming one thread.": "crt",
 
 // Awareness/Thought themes
 "A thought.": "crt",
 
 // Creation/Making themes
 "Our vessel is Theodora Telos. Our needle in the haystack.": "bios",
 "Sewing a swan song, a serenely silly sound in search, suit, and service of someday.": "bios",
 
 // Time/Action themes 
 "A gift for, of, and to the end.": "movie",
 
 // Reality/Truth moments
 "Something real.": "retro",
 "Or. Close enough.": "retro",
 
 // Present/Gift finale
 "A present.": "movie",
 "*The* present.": "movie"
};
// Praxis/time words to the TV clock marquee
const PRAXIS_WORDS = ["PRAXIS","POEISIS","THEORIA","Pattern","Creation","Connection","Pulse","Tick","Tock"];

const DEFAULT_CRAWL_PREVIEW = [
 "Praxis | Pattern | Compulsion | All we can ever do.",
 "Poeisis | Material | Creation | All we can ever see.",
 "Theoria | Qualia | Connection | All we can ever know.",
 "Disparate strands... Forming one thread.",
 "Something real.",
 "Or. Close enough.",
 "A present."
].join('\n\n');

const CRAWL_TEMPLATE = `
 <div id="crawl-header">CELLI::TERMINAL //LOG</div>
 <div id="crawl"></div>
 <svg id="crawl-cursor" viewBox="0 0 24 24">
 <polygon points="0,0 24,12 0,24" fill="#ffd04a" style="filter:drop-shadow(0 0 8px rgba(255,220,120,0.9))"/>
 </svg>
`;

/* =========================
 Devices
 ========================= */
const DEVICES = [
 {name:'terminal', w:16, h:11, pos:[-16, 11, -3], tilt:[ 0.55, 0.28], font:'VT323, monospace', size:240, color:'#00ff41', shader:'terminal', retro:false}, // Move forward, hinge inward
 {name:'tv', w:20, h:14, pos:[ 0, -2, -12], tilt:[ 0.30, 0.00], font:'IBM Plex Mono, monospace', size:180, color:'#444444', shader:'tv', retro:false}, // Center stays back
 {name:'movie', w:14, h:10, pos:[ 16, 9, -3], tilt:[ 0.55, -0.28], font:'Cutive Mono, serif', size:180, color:'#5a5a5a', shader:'movie', retro:false}, // Move forward, hinge inward
 {name:'crt', w:15, h:11, pos:[-16, -1, -3], tilt:[ 0.50, 0.28], font:'Space Mono, monospace', size:170, color:'#ff66cc', shader:'terminal', retro:true}, // Move forward, hinge inward (magenta)
 {name:'bios', w:17, h:11, pos:[ 16, -4.5, -3], tilt:[ 0.50, -0.28], font:'IBM Plex Mono, monospace', size:160, color:'#4aa3ff', shader:'terminal', retro:true} // Move forward, hinge inward (blue BIOS)
];

/* =========================
 Globals & settings
 ========================= */
let renderer, scene, camera, clock, composer;
let devices={}, recursiveRT, recursiveCam;
let floatingTexts=[], voxelParticles=[];
let cageEmitters=[];
let frameCount=0, crawlActive=false;
let lastFrameTime=0;
let cableMaterial;
let crawlMirror = null; // mirror overlay for main monitor
let biosBlue = new THREE.Color(0x4aa3ff);
let settings = { bloom:true, dof:true, fog:true, voxels:true, cables:true };
let campfire, healthMonitor;
let soundscape = null;
let analogClockUpdaters=[];
let lastCrawlDotOrigin = null;
const DOF_PARAMS = { focusLength: 42, focusDistance: 18, blur: 0.008 };
let orientationWatcher = { portrait:false, targets:new Map(), media:null };
const PORTRAIT_TARGETS = {
 terminal: {x:-9, y:11},
 tv: {x: 0, y: 0},
 movie: {x: 9, y:10},
 crt: {x:-9, y:-2},
 bios: {x: 9, y:-4}
};

// Camera mode state
let cameraMode = 'orbital'; // 'orbital' or 'fps'
let initialCameraPos, initialCameraRot;
let audioCtx; // main AudioContext for thud
const groundLevel = -13.5; // player height above voxel floor

/* =========================
 Shaders (BIOS tint via terminal shader color)
 ========================= */
const SHADERS = {
 terminal: { frag: `
precision highp float; varying vec2 vUv; varying vec3 vNormal; varying vec3 vViewPos;
uniform sampler2D uTex; uniform float uTime; uniform vec3 uColor; uniform float uGlitch;
float hash(vec2 p){ return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5); }
void main(){
 vec2 uv=vUv, cc=uv-0.5; float r2=dot(cc,cc); 
 vec2 distortedUV=0.5+cc*(1.0+0.22*r2); // barrel distortion
 uv=distortedUV;
 if(uGlitch>0.5){ float g=hash(vec2(floor(uv.y*16.), floor(uTime*6.))); if(g>0.88) uv.x += (g-0.88)*0.45; }
 vec3 col=texture2D(uTex,uv).rgb; float lum=dot(col, vec3(0.299,0.587,0.114));
 col = mix(col, uColor * (lum+0.25), 0.7);
 // barrel-distorted scanlines
 col *= 0.8 + 0.2 * sin(distortedUV.y*620.0);
 float fres = pow(1.0 - abs(dot(normalize(vViewPos), vNormal)), 2.3);
 col += uColor * 0.08 * fres;
 gl_FragColor = vec4(col,1.0);
}`},
 radar: { frag: `
precision highp float; varying vec2 vUv; varying vec3 vNormal; varying vec3 vViewPos;
uniform sampler2D uTex; uniform float uTime; uniform vec3 uColor; uniform float uGlitch;
float hash(vec2 p){ return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5); }
void main(){
 vec2 uv=vUv; vec2 cc=uv-0.5; float r=length(cc); float r2=dot(cc,cc);
 vec2 distortedUV=0.5+cc*(1.0+0.15*r2); // barrel distortion for scanlines
 // magenta chroma offset
 float a=0.0018 + 0.0012*sin(uTime*2.);
 vec3 col; col.r=texture2D(uTex, uv+normalize(cc)*a*1.2).r;
 col.g=texture2D(uTex, uv-normalize(cc)*a*0.5).g;
 col.b=texture2D(uTex, uv-normalize(cc)*a).b;
 // radar sweep (magenta)
 float ang = atan(cc.y, cc.x); float sweep = mod(ang + uTime*1.5, 6.28318);
 float sweepGlow = smoothstep(0.4, 0.0, sweep) * 0.2;
 col += vec3(1.0,0.4,0.8) * sweepGlow;
 // barrel-distorted scanlines
 col *= 0.96 + 0.04*sin((distortedUV.y+uTime*0.05)*950.0);
 gl_FragColor = vec4(col,1.0);
}`},
 tv: { frag: `
precision highp float; varying vec2 vUv; varying vec3 vNormal; varying vec3 vViewPos;
uniform sampler2D uTex; uniform float uTime; uniform vec3 uColor; uniform float uGlitch;
void main(){
 vec2 uv=vUv, cc=uv-0.5; float r2=dot(cc,cc); uv=0.5+cc*(1.0+0.14*r2);
 // subtle film drift
 uv.y += sin(uTime*.4 + uv.x*6.0)*0.006;
 vec3 col = texture2D(uTex,uv).rgb;
 float fres = pow(1.0 - abs(dot(normalize(vViewPos), vNormal)), 2.2);
 col += vec3(0.02,0.02,0.03)*fres;
 gl_FragColor = vec4(col,1.0);
}`},
 movie: { frag: `
precision highp float; varying vec2 vUv; varying vec3 vNormal; varying vec3 vViewPos;
uniform sampler2D uTex; uniform float uTime; uniform vec3 uColor; uniform float uGlitch;
float hash(vec2 p){ return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5); }
void main(){
 vec2 uv=vUv, cc=uv-0.5; float r2=dot(cc,cc); uv=0.5+cc*(1.0+0.18*r2);
 vec3 col=texture2D(uTex,uv).rgb; float lum=dot(col, vec3(0.299,0.587,0.114));
 col = mix(uColor*lum*1.2, vec3(0.15,1.0,0.5)*lum, 0.12);
 // glitch bursts
 float g = hash(vec2(floor(uTime*6.0), floor(uv.y*64.0)));
 if(g>0.86){ uv.x += (g-0.86)*0.3; }
 col += (hash(uv*1200.0 + uTime)-0.5)*0.12;
 float vig = 1.0 - length(uv-0.5)*0.9; col*=vig;
 gl_FragColor = vec4(col,1.0);
}`},
 crt: { frag: `
precision highp float; varying vec2 vUv; varying vec3 vNormal; varying vec3 vViewPos;
uniform sampler2D uTex; uniform float uTime; uniform vec3 uColor; uniform float uGlitch;
float hash(vec2 p){ return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5); }
void main(){
 vec2 uv=vUv, cc=uv-0.5; float r2=dot(cc,cc); 
 vec2 distortedUV=0.5+cc*(1.0+0.2*r2); // barrel distortion
 uv=distortedUV;
 // cracked-screen like displacement
 float row=floor(uv.y*18.0); float g=hash(vec2(row,floor(uTime*5.0)));
 if(g>0.82){ uv.x += (g-0.82)*0.18 * sign(sin(row+uTime*10.0)); }
 vec3 col=texture2D(uTex,uv).rgb; float lum=dot(col, vec3(0.299,0.587,0.114));
 col = mix(uColor*lum*1.3, vec3(0.1,1.0,0.5)*lum, 0.18);
 // barrel-distorted scanlines
 float mask=0.85+0.15*sin(distortedUV.x*1200.0); col*=mask; 
 col*=0.82+0.18*sin(distortedUV.y*650.0);
 gl_FragColor = vec4(col,1.0);
}`}
};

/* =========================
 Helpers: geometry
 ========================= */
function roundedRectShape(hw,hh,r){
 const s=new THREE.Shape();
 s.moveTo(-hw+r,-hh);
 s.lineTo(hw-r,-hh); s.absarc(hw-r,-hh+r,r,-Math.PI/2,0);
 s.lineTo(hw,hh-r); s.absarc(hw-r, hh-r,r,0,Math.PI/2);
 s.lineTo(-hw+r,hh); s.absarc(-hw+r,hh-r,r,Math.PI/2,Math.PI);
 s.lineTo(-hw,-hh+r);s.absarc(-hw+r,-hh+r,r,Math.PI,Math.PI*1.5);
 return s;
}
function createBezelFrame(w,h,th=1.0,depth=1.9,ro=1.2,ri=0.8,mat){
 const hw=w/2, hh=h/2; 
 const outer=roundedRectShape(hw+th,hh+th,ro); 
 const inner=roundedRectShape(hw,hh,ri); 
 outer.holes.push(inner);
 // Better bevel for smoother edges, scale bevel size with bezel thickness
 const bevelSize = Math.max(0.08, th * 0.15);
 const bevelThickness = Math.max(0.08, th * 0.15);
 // Reduce segments for small bezels to improve performance
 const isSmall = w < 5 || h < 5;
 const geo=new THREE.ExtrudeGeometry(outer,{
 depth,
 bevelEnabled:true,
 bevelSize,
 bevelThickness,
 bevelSegments: isSmall ? 2 : 4, // Fewer segments for small screens
 curveSegments: isSmall ? 8 : 16 // Fewer curve segments for small screens
 });
 geo.translate(0,0,-depth*0.5+0.2); 
 const m=new THREE.Mesh(geo,mat); 
 m.castShadow=true; 
 return m;
}
function createBarrelScreenGeometry(w,h,depth=1.2,barrelRadius=20,segsW=80,segsH=60){
 const hw=w/2, hh=h/2, g=new THREE.PlaneGeometry(w,h,segsW,segsH), p=g.attributes.position;
 for(let i=0;i<p.count;i++){ const x=p.getX(i), y=p.getY(i), nx=x/hw, ny=y/hh, r2=nx*nx+ny*ny;
 const z = depth*Math.cos(Math.min(1.0,Math.sqrt(r2)))*0.6 + (1.0-Math.min(1.0,r2))*(w+h)/(barrelRadius*2.0);
 p.setZ(i, Math.max(0,z));
 } g.computeVertexNormals(); return g;
}

/* Instance monitor groups - crumbling voxel iterations around edges using TRUE instancing */
let instancedMonitors = [];
function createInstancedMonitorGroups(bodyMat, bezelMatDark, bezelMatLight){
 console.log('Creating instanced monitors...');
 const startTime = performance.now();
 
 // Calculate total count for true instancing
 const numCrumblesPerScreen = 3;
 const totalInstances = DEVICES.length * numCrumblesPerScreen;
 
 // Create shared geometries once
 const avgScale = 0.225; // Average of 0.15 to 0.3
 const avgW = 3.5 * avgScale; // Approximate average screen width * scale
 const avgH = 2.5 * avgScale; // Approximate average screen height * scale
 const scaleFactor = avgScale;
 const thickness = 0.6 * scaleFactor;
 const depth = 1.9 * scaleFactor;
 const outerRadius = 1.2 * scaleFactor;
 const innerRadius = 0.8 * scaleFactor;
 
 // Shared body geometry
 const bodyGeo = new THREE.BoxGeometry(avgW + thickness * 2, avgH + thickness * 2, thickness);
 
 // Shared bezel geometry (simplified for performance)
 const bezelGeo = createBezelFrame(avgW, avgH, thickness, depth, outerRadius, innerRadius, bezelMatDark);
 
 // Shared screen geometry (flat for performance)
 const screenGeo = new THREE.PlaneGeometry(avgW, avgH, 4, 4);
 
 // Create instanced meshes with proper materials
 const bodyInstanced = new THREE.InstancedMesh(bodyGeo, bodyMat.clone(), totalInstances);
 const bezelInstanced = new THREE.InstancedMesh(bezelGeo.geometry || bezelGeo, bezelMatDark.clone(), totalInstances);
 
 // Screen material that matches parent colors (use MeshStandardMaterial for emissive)
 const screenMat = new THREE.MeshStandardMaterial({
 color: 0xffffff, // White base so instance colors show through
 side: THREE.DoubleSide,
 emissive: 0x333333,
 emissiveIntensity: 0.8,
 metalness: 0.2,
 roughness: 0.7,
 vertexColors: true // Enable vertex colors for instance colors
 });
 const screenInstanced = new THREE.InstancedMesh(screenGeo, screenMat, totalInstances);
 
 bodyInstanced.castShadow = false;
 bodyInstanced.receiveShadow = false;
 bezelInstanced.castShadow = false;
 bezelInstanced.receiveShadow = false;
 screenInstanced.castShadow = false;
 screenInstanced.receiveShadow = false;
 
 // Enable per-instance colors for screens
 screenInstanced.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(totalInstances * 3), 3);
 
 const dummy = new THREE.Object3D();
 let instanceIdx = 0;
 
 DEVICES.forEach(parentCfg => {
 const parentPos = new THREE.Vector3(...parentCfg.pos);
 const parentColor = new THREE.Color(parentCfg.color);
 const halfW = parentCfg.w / 2;
 const halfH = parentCfg.h / 2;
 console.log(`Creating ${numCrumblesPerScreen} crumbles for ${parentCfg.name} at`, parentPos);
 
 for(let i = 0; i < numCrumblesPerScreen; i++){
 const scale = 0.15 + Math.random() * 0.15; // 0.15 to 0.3
 
 // Position at edges/corners of parent screen IN LOCAL SPACE
 const edge = i % 4;
 let localX, localY, localZ;
 
 switch(edge) {
 case 0: // Top-right corner
 localX = halfW + 2 + Math.random() * 3;
 localY = halfH + 2 + Math.random() * 3;
 localZ = 0.5 - Math.random() * 1.5; // Slight Z variation
 break;
 case 1: // Bottom-left corner
 localX = -halfW - 2 - Math.random() * 3;
 localY = -halfH - 2 - Math.random() * 3;
 localZ = 0.5 - Math.random() * 1.5;
 break;
 case 2: // Top-left corner
 localX = -halfW - 2 - Math.random() * 3;
 localY = halfH + 2 + Math.random() * 3;
 localZ = 0.5 - Math.random() * 1.5;
 break;
 default: // Bottom-right corner
 localX = halfW + 2 + Math.random() * 3;
 localY = -halfH - 2 - Math.random() * 3;
 localZ = 0.5 - Math.random() * 1.5;
 }
 
 // Create a local transform that matches parent rotation
 const parentRotation = new THREE.Euler(parentCfg.tilt[0], parentCfg.tilt[1], 0);
 const rotMatrix = new THREE.Matrix4().makeRotationFromEuler(parentRotation);
 
 // Transform local position by parent rotation
 const localOffset = new THREE.Vector3(localX, localY, localZ);
 localOffset.applyMatrix4(rotMatrix);
 
 // Add to parent position
 dummy.position.set(
 parentPos.x + localOffset.x,
 parentPos.y + localOffset.y,
 parentPos.z + localOffset.z
 );
 
 // Apply parent rotation plus random variation for crumbled look
 dummy.rotation.set(
 parentCfg.tilt[0] + (Math.random() - 0.5) * 0.3,
 parentCfg.tilt[1] + (Math.random() - 0.5) * 0.3,
 (Math.random() - 0.5) * 0.25
 );
 
 dummy.scale.setScalar(scale / avgScale); // Scale relative to base geometry
 dummy.updateMatrix();
 
 bodyInstanced.setMatrixAt(instanceIdx, dummy.matrix);
 bezelInstanced.setMatrixAt(instanceIdx, dummy.matrix);
 screenInstanced.setMatrixAt(instanceIdx, dummy.matrix);
 
 // Set color for this instance (dimmer than parent)
 screenInstanced.instanceColor.setXYZ(instanceIdx, 
 parentColor.r * 0.4, 
 parentColor.g * 0.4, 
 parentColor.b * 0.4
 );
 
 instanceIdx++;
 }
 });
 
 scene.add(bodyInstanced);
 scene.add(bezelInstanced);
 scene.add(screenInstanced);
 
 instancedMonitors.push({body: bodyInstanced, bezel: bezelInstanced, screen: screenInstanced});
 
 const elapsed = performance.now() - startTime;
 console.log(`Created ${totalInstances} true instanced monitors in ${elapsed.toFixed(0)}ms`);
}

// Base position triangle energy links (between base device positions)
function updateBaseTriangleLinks(t){
 if(!window.baseLinks){ window.baseLinks = []; }
 const names=['cage','clock','radar'];
 const isSuppressed=(name)=>{
 if(name==='cage' && devices.bios && devices.bios.voxelCage){ const g=devices.bios.voxelCage.group; return !g.visible || (g.userData&&g.userData.isBeingThrown); }
 if(name==='clock' && devices.movie && devices.movie.analogClock && devices.movie.analogClock.group){ const g=devices.movie.analogClock.group; return !g.visible || (g.userData&&g.userData.isBeingThrown); }
 if(name==='radar' && window.biosRadar && window.biosRadar.holder){ const g=window.biosRadar.holder; return !g.visible || (g.userData&&g.userData.isBeingThrown); }
 return false;
 };
 const getBase=(name)=>{
 if(isSuppressed(name)) return null;
 if(name==='cage' && devices.bios && devices.bios.voxelCage) return devices.bios.voxelCage.group.getWorldPosition(new THREE.Vector3());
 if(name==='clock' && devices.movie && devices.movie.analogClock && devices.movie.analogClock.group) return devices.movie.analogClock.group.getWorldPosition(new THREE.Vector3());
 if(name==='radar' && window.biosRadar) return window.biosRadar.holder.getWorldPosition(new THREE.Vector3());
 return null;
 };
 const pairs=[[0,1],[1,2],[2,0]]; // triangle
 while(window.baseLinks.length<pairs.length){
 const mat=new THREE.ShaderMaterial({transparent:true,depthWrite:false,blending:THREE.AdditiveBlending,
 uniforms:{uTime:{value:0},uColorA:{value:new THREE.Color(0xffffff)},uColorB:{value:new THREE.Color(0xffffff)}},
 vertexShader:`varying float vAlong; varying vec2 vUv; void main(){ vUv=uv; vAlong=position.x; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
 fragmentShader:`uniform float uTime; uniform vec3 uColorA,uColorB; varying float vAlong; varying vec2 vUv; float gauss(float x,float s){ return exp(-(x*x)/(2.0*s*s)); } float hash(vec2 p){ return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453); } void main(){ float y=(vUv.y-0.5); float sigma = 0.2 + 0.06*sin(uTime*1.6 + vAlong*5.0); float g = gauss(y,sigma) + 0.55*gauss(y,sigma*1.8); float w1=0.5+0.5*sin(uTime*5.0+vAlong*12.0); float w2=0.5+0.5*sin(uTime*7.0+vAlong*20.0); float noise=(hash(vUv*vec2(160.0,10.0)+uTime*0.5)-0.5)*0.25; vec3 col=mix(uColorA,uColorB,0.5+0.5*sin(uTime*1.0)); float alpha = clamp(0.14 + 0.55*g*(0.6*w1+0.4*w2) + noise*0.1, 0.0, 0.9); gl_FragColor=vec4(col, alpha); }`
 });
 const geo=new THREE.PlaneGeometry(1,0.6,40,1);
 const mesh=new THREE.Mesh(geo,mat); mesh.frustumCulled=false; scene.add(mesh); window.baseLinks.push(mesh);
 }
 pairs.forEach((pr,i)=>{
 const a=getBase(names[pr[0]]), b=getBase(names[pr[1]]); const m=window.baseLinks[i]; if(!a||!b){m.visible=false;return;} m.visible=true; m.material.uniforms.uTime.value=t;
 const mid=new THREE.Vector3().lerpVectors(a,b,0.5), dir=new THREE.Vector3().subVectors(b,a), len=Math.max(dir.length(),0.1); dir.normalize();
 const quat=new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(1,0,0),dir);
 m.position.copy(mid); m.setRotationFromQuaternion(quat);
 // Vary thickness over time for dynamic feel
 const thickness = 1 + 0.2*Math.sin(t*3.0 + i);
 m.scale.set(len, thickness, 1);
 const col=(idx)=> idx===0? new THREE.Color(0x66caff) : idx===1? new THREE.Color(0xffd95a) : new THREE.Color(0xff66cc);
 m.material.uniforms.uColorA.value=col(pr[0]); m.material.uniforms.uColorB.value=col(pr[1]);
 });
}
/* =========================
 Click interactions for 3D objects
 ========================= */
function setupClickableObjects(){
 const raycaster = new THREE.Raycaster();
 const clickMouse = new THREE.Vector2();
 
 // Store clickable groups
 const clickableObjects = [];
 
 // Register clickable objects in fixed left-to-right order: cage, clock, radar
 const ordered = [];
 if(devices.bios && devices.bios.voxelCage) ordered.push({
 group: devices.bios.voxelCage.group,
 name: 'cage',
 parent: devices.bios.group,
 color: 0x66caff
 });
 if(devices.movie && devices.movie.analogClock && devices.movie.analogClock.group) ordered.push({
 group: devices.movie.analogClock.group,
 name: 'clock',
 parent: devices.movie.group,
 color: 0xffd95a
 });
 if(window.biosRadar && window.biosRadar.holder) ordered.push({
 group: window.biosRadar.holder,
 name: 'radar',
 parent: window.biosRadar.holder,
 color: 0xff66cc
 });
 ordered.forEach(o=>clickableObjects.push(o));
 
 console.log('Clickable objects registered:', clickableObjects.length, clickableObjects.map(o => o.name));
 
 // No heavy pick proxies needed; we have only a few objects. We'll raycast the groups directly.
 
 let isProcessingClick = false;
 
 window.addEventListener('pointerdown', (event) => {
 if(isProcessingClick) return;
 isProcessingClick = true;
 requestAnimationFrame(()=>{
 try{
 // Calculate mouse position in normalized device coordinates
 clickMouse.x = (event.clientX / window.innerWidth) * 2 - 1;
 clickMouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

 raycaster.setFromCamera(clickMouse, camera);
 // Only raycast against lightweight proxies on layer 2
 const prevMask = camera.layers.mask;
 camera.layers.enable(2);
 raycaster.layers.set(2);

 // Find closest intersected clickable proxy
 const hits = [];
 for(const obj of clickableObjects){
 if(!obj.group || !obj.group.visible) continue;
 const proxy = obj.group.userData.pickProxy || obj.parent && obj.parent.userData && obj.parent.userData.pickProxy || null;
 if(!proxy) continue;
 const res = raycaster.intersectObject(proxy, true);
 if(res && res.length){ hits.push({obj, dist: res[0].distance}); }
 }

 // restore layers
 raycaster.layers.set(0);
 camera.layers.mask = prevMask;
 hits.sort((a,b)=>a.dist-b.dist);
 if(hits.length){
 const {obj} = hits[0];
 console.log(`Clicked on ${obj.name}`);
 if(obj.group.userData.isZoomed && campfire && campfire.whiteHole){
 throwIntoWhiteHole(obj.group);
 } else if(!obj.group.userData.isZooming) {
 zoomObjectToPlayer(obj.group, obj.name, obj.color || 0xffffff);
 }
 }
 }catch(e){
 console.warn('Click error:', e);
 }finally{ isProcessingClick = false; }
 });
 });
}

// Prewarm zoomable targets to avoid on-click hitches (materials/lights/shaders)
function prewarmZoomable(group, color){
 if(!group) return;
 if(!group.userData) group.userData = {};
 // Ensure overlay node exists
 if(!group.userData.overlayNode && window.zoomOverlay){
 const overlayNode = new THREE.Group();
 window.zoomOverlay.add(overlayNode);
 group.userData.overlayNode = overlayNode;
 }
 // Pre-create glow light
 if(!group.userData.glowLight){
 const glowLight = new THREE.PointLight(color||0xffffff, 2.0, 6);
 glowLight.position.set(0,0,0);
 glowLight.visible = false; // will be animated on zoom
 group.add(glowLight);
 group.userData.glowLight = glowLight;
 }
 // Pre-create energy sphere
 if(!group.userData.energySphere){
 const sphere = new THREE.Mesh(
 new THREE.SphereGeometry(0.35, 18, 18),
 new THREE.MeshBasicMaterial({color:color||0xffffff, transparent:true, opacity:0.65, blending:THREE.AdditiveBlending, depthWrite:false})
 );
 sphere.position.set(0,0,0);
 sphere.visible = false; // enable during zoom only
 group.add(sphere);
 group.userData.energySphere = sphere;
 }
 if(!group.userData.originalParent){
 group.userData.originalParent = group.parent;
 }
}

function prepareZoomables(){
 const entries=[];
 if(devices.bios && devices.bios.voxelCage) entries.push({g:devices.bios.voxelCage.group, c:0x66caff});
 if(devices.movie && devices.movie.analogClock && devices.movie.analogClock.group) entries.push({g:devices.movie.analogClock.group, c:0xffd95a});
 if(window.biosRadar && window.biosRadar.holder) entries.push({g:window.biosRadar.holder, c:0xff66cc});
 entries.forEach(e=>prewarmZoomable(e.g, e.c));
 try{ if(renderer && scene && camera){ renderer.compile(scene, camera); } }catch(e){}
}

// FPS toggle button and logic
function addFpsToggleButton(){
 const btn = document.createElement('div');
 btn.id = 'fps-toggle';
 btn.textContent = 'ENTER FPS MODE';
 btn.style.cssText = 'position:fixed;top:20px;right:20px;padding:10px 15px;background:rgba(200,50,50,0.8);border:2px solid #ff4444;border-radius:5px;cursor:pointer;z-index:200;font-weight:bold;color:#fff;font-size:12px;';
 btn.addEventListener('click', ()=>{
 if(cameraMode==='orbital'){
 cameraMode='fps';
 btn.textContent='EXIT FPS MODE (ESC)';
 btn.style.background='rgba(50,200,50,0.8)';
 btn.style.borderColor='#44ff44';
 document.body.requestPointerLock();
 if(!camera.userData.velocity) camera.userData.velocity=new THREE.Vector3();
 camera.userData.velocity.y = -1.0; // start falling
 } else {
 cameraMode='orbital';
 btn.textContent='ENTER FPS MODE';
 btn.style.background='rgba(200,50,50,0.8)';
 btn.style.borderColor='#ff4444';
 document.exitPointerLock();
 camera.position.copy(initialCameraPos);
 camera.rotation.copy(initialCameraRot);
 // Reset motion state
 if(camera.userData.velocity) camera.userData.velocity.set(0,0,0);
 camera.userData.isAirborne=false;
 }
 });
 // Append to end3 container so it's only visible in that scene
 const end3Container = document.getElementById('end3-scene-container');
 if (end3Container) {
 end3Container.appendChild(btn);
 } else {
 document.body.appendChild(btn);
 }
}

// Energy links between zoomed items with soft bloom-like glow
function updateZoomLinks(pairs, t){
 if(!window.zoomOverlay) return;
 if(!window.zoomLinks){ window.zoomLinks = []; }

 // helper to get overlay node for name
 const getNode=(name)=>{
 const obj = (name==='cage')? (devices.bios && devices.bios.voxelCage && devices.bios.voxelCage.group)
 : (name==='clock')? (devices.movie && devices.movie.analogClock && devices.movie.analogClock.group)
 : (window.biosRadar && window.biosRadar.holder);
 return obj && obj.userData && obj.userData.overlayNode ? obj.userData.overlayNode : null;
 };

 // Ensure we have meshes for each pair
 while(window.zoomLinks.length < pairs.length){
 const mat = new THREE.ShaderMaterial({
 transparent:true, depthWrite:false, blending:THREE.AdditiveBlending,
 uniforms:{uTime:{value:0}, uColorA:{value:new THREE.Color(0xff66cc)}, uColorB:{value:new THREE.Color(0xffd95a)}},
 vertexShader:`varying float vAlong; varying vec2 vUv; void main(){ vUv=uv; vec4 mv=modelViewMatrix*vec4(position,1.0); gl_Position=projectionMatrix*mv; vAlong=position.x; }`,
 fragmentShader:`uniform float uTime; uniform vec3 uColorA,uColorB; varying float vAlong; varying vec2 vUv; float gauss(float x,float s){ return exp(-(x*x)/(2.0*s*s)); } float hash(vec2 p){ return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453); } void main(){ float y = (vUv.y-0.5); float sigma = 0.18 + 0.06*sin(uTime*2.0 + vAlong*6.0); float g = gauss(y, sigma) + 0.6*gauss(y, sigma*1.8); float w1=0.5+0.5*sin(uTime*6.0+vAlong*12.0); float w2=0.5+0.5*sin(uTime*9.0+vAlong*20.0); float noise=(hash(vUv*vec2(220.0,12.0)+uTime*0.6)-0.5)*0.25; vec3 col=mix(uColorA,uColorB,0.5+0.5*sin(uTime*1.1)); float alpha = clamp(0.16 + 0.6*g*(0.55*w1+0.45*w2) + noise*0.12, 0.0, 0.95); gl_FragColor=vec4(col, alpha); }`
 });
 const geo = new THREE.PlaneGeometry(1, 0.6, 40, 1); // will be stretched
 const mesh = new THREE.Mesh(geo, mat);
 mesh.frustumCulled=false; window.zoomOverlay.add(mesh);
 window.zoomLinks.push(mesh);
 }

 pairs.forEach((p, i)=>{
 const a = getNode(p.from), b = getNode(p.to);
 const mesh = window.zoomLinks[i]; if(!a||!b){ mesh.visible=false; return; }
 // Hide link if either node is being thrown
 const aObj = (p.from==='cage')? (devices.bios && devices.bios.voxelCage && devices.bios.voxelCage.group)
 : (p.from==='clock')? (devices.movie && devices.movie.analogClock && devices.movie.analogClock.group)
 : (window.biosRadar && window.biosRadar.holder);
 const bObj = (p.to==='cage')? (devices.bios && devices.bios.voxelCage && devices.bios.voxelCage.group)
 : (p.to==='clock')? (devices.movie && devices.movie.analogClock && devices.movie.analogClock.group)
 : (window.biosRadar && window.biosRadar.holder);
 const suppress = (aObj && aObj.userData && aObj.userData.isBeingThrown) || (bObj && bObj.userData && bObj.userData.isBeingThrown);
 mesh.visible = !suppress; if(!mesh.visible) return; mesh.material.uniforms.uTime.value=t;
 // Compute midpoint and orientation
 const pa = new THREE.Vector3().setFromMatrixPosition(a.matrixWorld);
 const pb = new THREE.Vector3().setFromMatrixPosition(b.matrixWorld);
 const mid = new THREE.Vector3().lerpVectors(pa, pb, 0.5);
 const dir = new THREE.Vector3().subVectors(pb, pa);
 const len = Math.max(0.1, dir.length()); dir.normalize();
 // Orient plane to face camera, align X to dir
 const up = new THREE.Vector3(0,1,0);
 const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(1,0,0), dir);
 mesh.position.copy(mid);
 mesh.setRotationFromQuaternion(quat);
 // face camera twist softly
 const toCam = new THREE.Vector3().subVectors(camera.position, mid).normalize();
 const zAxis = new THREE.Vector3(0,0,1).applyQuaternion(quat);
 const twist = Math.atan2(zAxis.dot(new THREE.Vector3().crossVectors(dir, toCam)), zAxis.dot(toCam));
 mesh.rotateX(0); mesh.rotateY(0); mesh.rotateZ(twist*0.2);
 mesh.scale.set(len, 1.0 + 0.2*Math.sin(t*4.0 + i), 1);
 // color mix by object colors
 const colA = (p.from==='cage')? new THREE.Color(0x66caff) : (p.from==='clock')? new THREE.Color(0xffd95a) : new THREE.Color(0xff66cc);
 const colB = (p.to ==='cage')? new THREE.Color(0x66caff) : (p.to ==='clock')? new THREE.Color(0xffd95a) : new THREE.Color(0xff66cc);
 mesh.material.uniforms.uColorA.value = colA;
 mesh.material.uniforms.uColorB.value = colB;
 });
}
// Thud sound
function playThudSound(){
 if(!audioCtx) return;
 const time=audioCtx.currentTime;
 const osc=audioCtx.createOscillator();
 const gain=audioCtx.createGain();
 osc.connect(gain); gain.connect(audioCtx.destination);
 osc.type='triangle';
 osc.frequency.setValueAtTime(120,time);
 osc.frequency.exponentialRampToValueAtTime(40,time+0.2);
 gain.gain.setValueAtTime(0.6,time);
 gain.gain.exponentialRampToValueAtTime(0.01,time+0.25);
 osc.start(time); osc.stop(time+0.3);
}

// Global array to track zoomed objects
window.zoomedObjects = window.zoomedObjects || [];

function zoomObjectToPlayer(group, name, color){
 if(!group || group.userData.isZooming) return;
 group.userData.isZooming = true;
 group.userData.isZoomed = false;
 
 // Store original state
 const originalParent = group.parent;
 const originalPos = group.position.clone();
 const originalRot = group.rotation.clone();
 const originalScale = group.scale.clone();
 
 // Calculate position in row (spread horizontally) - relative to camera basis so always on-screen
 const spacing = 2.6;
 // Use fixed index based on desired left-to-right order
 const indexMap = {cage:0, clock:1, radar:2};
 const index = indexMap[name] !== undefined ? indexMap[name] : window.zoomedObjects.length;
 
 const camForward = new THREE.Vector3();
 camera.getWorldDirection(camForward); camForward.normalize();
 const camRight = new THREE.Vector3().crossVectors(camForward, new THREE.Vector3(0,1,0)).normalize();
 const camUp = new THREE.Vector3(0,1,0);
 
 const basePos = new THREE.Vector3().copy(camera.position)
 .addScaledVector(camForward, 6.3)
 .addScaledVector(camUp, 1.2);
 const targetPos = new THREE.Vector3().copy(basePos)
 .addScaledVector(camRight, (index - 1) * spacing);
 const targetScale = 0.22; // Slightly smaller
 
 // Create a proxy parent for stable alignment in camera space
 if(!group.userData.originalParent){
 group.userData.originalParent = group.parent;
 }
 if(!group.userData.overlayNode){
 const overlayNode = new THREE.Group();
 window.zoomOverlay.add(overlayNode);
 group.userData.overlayNode = overlayNode;
 }
 const overlayNode = group.userData.overlayNode;
 
 // Align overlay node to current world transform to avoid snapping
 const worldPos = new THREE.Vector3();
 const worldQuat = new THREE.Quaternion();
 group.getWorldPosition(worldPos);
 group.getWorldQuaternion(worldQuat);
 overlayNode.position.copy(worldPos);
 overlayNode.quaternion.copy(worldQuat);

 // Move group under overlay node (preserve visual transform)
 if(group.parent !== overlayNode){
 overlayNode.add(group);
 group.position.set(0,0,0);
 group.quaternion.set(0,0,0,1);
 }
 overlayNode.position.copy(group.userData.overlayPos||group.position);
 
 // Add glow light and energy sphere once
 if(!group.userData.glowLight){
 const glowLight = new THREE.PointLight(color, 2.5, 6);
 glowLight.position.set(0, 0, 0);
 group.add(glowLight);
 group.userData.glowLight = glowLight;
 }
 if(!group.userData.energySphere){
 const sphere = new THREE.Mesh(
 new THREE.SphereGeometry(0.35, 18, 18),
 new THREE.MeshBasicMaterial({color, transparent:true, opacity:0.65, blending:THREE.AdditiveBlending, depthWrite:false})
 );
 sphere.position.set(0,0,0);
 group.add(sphere);
 group.userData.energySphere = sphere;
 }
 
 // Animate to player - smooth and buttery
 const duration = 800;
 const startTime = performance.now();
 const startPos = overlayNode.position.clone();
 const startRotX = group.rotation.x, startRotY = group.rotation.y;
 const camQuat = new THREE.Quaternion();

 function animateZoom(timestamp){
 const elapsed = timestamp - startTime;
 const t = Math.min(1, elapsed / duration);
 const eased = 1 - Math.pow(1 - t, 3);

 // Position (no allocations): startPos -> targetPos
 overlayNode.position.x = startPos.x + (targetPos.x - startPos.x) * eased;
 overlayNode.position.y = startPos.y + (targetPos.y - startPos.y) * eased;
 overlayNode.position.z = startPos.z + (targetPos.z - startPos.z) * eased;

 // Orientation to camera
 camQuat.copy(camera.quaternion);
 overlayNode.quaternion.slerp(camQuat, 0.2);

 // Scale
 const scale = originalScale.x + (targetScale - originalScale.x) * eased;
 group.scale.setScalar(scale);

 // Rotation
 group.rotation.y = startRotY + (0 - startRotY) * eased;
 group.rotation.x = startRotX * (1 - eased);

 // Glow (no new allocations)
 if(group.userData.glowLight){
 group.userData.glowLight.visible = true;
 group.userData.glowLight.intensity = 2.0 + Math.sin(elapsed * 0.008) * 0.5;
 }

 if(t < 1){
 requestAnimationFrame(animateZoom);
 } else {
 group.userData.isZooming = false;
 group.userData.isZoomed = true;
 group.userData.originalState = {originalParent, originalPos, originalRot, originalScale};
 group.userData.color = color;
 group.userData.name = name;
 window.zoomedObjects.push(group);
 if(group.userData.glowLight) group.userData.glowLight.intensity = 2.0;
 if(group.userData.energySphere) group.userData.energySphere.visible = true;
 }
 }
 requestAnimationFrame(animateZoom);
}

function throwIntoWhiteHole(group){
 if(!group || !campfire || !campfire.whiteHole) return;
 
 const whiteHolePos = campfire.whiteHole.getWorldPosition(new THREE.Vector3());
 const startPos = group.position.clone();
 const color = group.userData.color || 0xffffff;
 
 // Remove glow light
 if(group.userData.glowLight){
 group.remove(group.userData.glowLight);
 group.userData.glowLight = null;
 }
 
 // Remove from zoomed objects array
 const idx = window.zoomedObjects.indexOf(group);
 if(idx > -1) window.zoomedObjects.splice(idx, 1);
 
 // Pulse white hole with object color
 if(campfire.whiteHole.userData){
 campfire.whiteHole.userData.pulseColor = new THREE.Color(color);
 campfire.whiteHole.userData.pulseIntensity = 1.0;
 }
 
 const duration = 1200; // Smooth duration
 const startTime = performance.now();
 // Flag to suppress connection lines while animating
 group.userData.isBeingThrown = true;
 
 const animateThrow = (timestamp) => {
 const elapsed = timestamp - startTime;
 const progress = Math.min(1, elapsed / duration);
 const eased = progress * progress * progress; // ease in cubic (accelerate)
 
 // Move toward white hole smoothly
 group.position.lerpVectors(startPos, whiteHolePos, eased);
 
 // Stretch into string (scale down width/height, stretch along motion vector)
 const stretchFactor = 1 + progress * 8; // Stretch to 9x length
 const squeezeFactor = Math.max(0.1, 1 - progress * 0.95); // Squeeze to 5% width
 
 const direction = new THREE.Vector3().subVectors(whiteHolePos, startPos).normalize();
 
 // Apply stretch along direction of motion
 if(Math.abs(direction.y) > 0.7){
 // Vertical stretch
 group.scale.set(squeezeFactor, stretchFactor * 0.4, squeezeFactor);
 } else {
 // Horizontal stretch
 group.scale.set(squeezeFactor, squeezeFactor, stretchFactor * 0.4);
 }
 
 // Fade out smoothly
 group.traverse(child => {
 if(child.material){
 if(!child.userData.originalOpacity){
 child.userData.originalOpacity = child.material.opacity !== undefined ? child.material.opacity : 1.0;
 }
 if(child.material.transparent === undefined) child.material.transparent = true;
 child.material.opacity = child.userData.originalOpacity * (1 - progress * 0.7);
 }
 });
 
 if(progress < 1){
 requestAnimationFrame(animateThrow);
 } else {
 // Restore to original position and hide
 if(group.userData.originalState){
 const orig = group.userData.originalState;
 group.position.copy(orig.originalPos);
 group.rotation.copy(orig.originalRot);
 group.scale.copy(orig.originalScale);
 }
 group.visible = false;
 
 // Reset userData
 group.userData.isZoomed = false;
 group.userData.isBeingThrown = false;
 
 // Re-show after a delay
 setTimeout(() => {
 group.visible = true;
 group.traverse(child => {
 if(child.material && child.userData.originalOpacity){
 child.material.opacity = child.userData.originalOpacity;
 }
 });
 }, 3000);
 }
 };
 
 requestAnimationFrame(animateThrow);
}

/* =========================
 Build scene
 ========================= */
let renderPass,bloomPass,bokehPass,grainPass;
function initScene(){
 console.log('=== INIT SCENE START ===');
 const sceneStartTime = performance.now();
 renderer=new THREE.WebGLRenderer({antialias:true,alpha:false});
 renderer.setPixelRatio(Math.min(devicePixelRatio,2));
 renderer.setSize(innerWidth,innerHeight);
 renderer.toneMapping=THREE.ACESFilmicToneMapping;
 renderer.toneMappingExposure=1.48;
 renderer.shadowMap.enabled=true;
 renderer.shadowMap.type=THREE.PCFSoftShadowMap;
 document.getElementById('container').appendChild(renderer.domElement);

 scene=new THREE.Scene();
 // Overlay for zoomed objects
 window.zoomOverlay = new THREE.Group();
 scene.add(window.zoomOverlay);
 const fogColor=new THREE.Color(0x11131e);
 scene.background=fogColor.clone();
 scene.fog=new THREE.Fog(fogColor,16,68);

 camera=new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 2.5, 150); // Higher near plane to prevent clipping
 camera.position.set(0,-14,8); // Start further back
 camera.lookAt(0, -6, -5);
 camera.rotation.order = 'YXZ'; // FPS-friendly: yaw first, then pitch
 camera.userData.targetRotation = camera.rotation.clone();
 camera.userData.velocity = new THREE.Vector3(0, 0, 0);
 clock=new THREE.Clock();
 console.log('Camera starting position:', camera.position);
 // Store initial camera state
 initialCameraPos = camera.position.clone();
 initialCameraRot = camera.rotation.clone();

 const amb=new THREE.AmbientLight(0x1c2230,1.0); scene.add(amb);
 const bounce=new THREE.HemisphereLight(0x1f2c40,0x06070a,.6); scene.add(bounce);
 const key=new THREE.SpotLight(0xfff4dd,.65,90,Math.PI/3.2,.7); key.position.set(-18,16,22); key.castShadow=true; scene.add(key);
 const rim=new THREE.DirectionalLight(0x3a5d7a,.55); rim.position.set(20,-9,-16); scene.add(rim);
 const fill=new THREE.PointLight(0x214d7a,.8,56,2.2); fill.position.set(5,-7,6); scene.add(fill);
 const glow=new THREE.PointLight(0xffa45a,.65,42,1.6); glow.position.set(-6,-8,-2); scene.add(glow);

 const bodyMat = new THREE.MeshStandardMaterial({color:0x0c0c0e, metalness:.65, roughness:.35});
 const bezelMatDark = new THREE.MeshStandardMaterial({color:0x121315, metalness:.45, roughness:.5});
 const bezelMatLight = new THREE.MeshStandardMaterial({color:0xe8e8ea, metalness:.6, roughness:.27});
 cableMaterial = new THREE.MeshStandardMaterial({color:0x111214, metalness:.2, roughness:.7, emissive:0x060606, emissiveIntensity:.22});

 window.voxelWall = buildVoxelWall(); 
 window.voxelFloor = buildVoxelFloor(); 
 createFloatingVoxels();

 // Create main devices with paced tracking
 console.log('Creating main devices...');
 const mainStartTime = performance.now();
 DEVICES.forEach((cfg, index)=>{
 const deviceStart = performance.now();
 const d=createDevice(cfg, bodyMat, bezelMatDark, bezelMatLight);
 console.log(` Created ${cfg.name} in ${(performance.now() - deviceStart).toFixed(0)}ms`);
 scene.add(d.group); devices[cfg.name]=d;
 // Start screens off, bring them online sequentially
 d.material.uniforms.uColor.value.multiplyScalar(0.01);
 d.startDelay = index * 800; // Stagger by 800ms each
 d.isOnline = false;
 // Store base rotation for paced tracking
 d.baseRotation = {x: d.group.rotation.x, y: d.group.rotation.y};
 d.trackingPhase = Math.random() * Math.PI * 2; // Random phase for variation
 d.targetRotation = {x: d.group.rotation.x, y: d.group.rotation.y}; // Target for delayed tracking
 d.lastUpdateTime = 0; // For staggered updates
 });
 console.log(`Main devices created in ${(performance.now() - mainStartTime).toFixed(0)}ms`);
 
 // Create instanced monitor groups around the edges for scale
 createInstancedMonitorGroups(bodyMat, bezelMatDark, bezelMatLight);

 // TV recursive & UI chrome overlay
 recursiveRT=new THREE.WebGLRenderTarget(1536,1024,{minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat});
 recursiveCam=camera.clone();
 devices.tv.material.uniforms.uTex.value=recursiveRT.texture;

 addTVChrome(devices.tv); // UI overlay
 addPixelClock(devices.tv); // pixelated clock (center TV)
 addTVClock(devices.movie); // 7-seg clock (top-right TV)
 addAnalogPixelClock(devices.movie); // ironic analog clock beside top-right
 addTVStaticOverlay(devices.movie);// static/glitch overlay on top-right
 addTerminalIndicator(devices.tv); // blinking triangle on main terminal
 addGlobalSkip(); // global SKIP button next to settings
 window.biosRadar = addBiosRadar(devices.crt); // pixelated heart radar over bottom-left (magenta CRT)
 addVoxelCage(devices.bios); // blue glass cage beside BIOS screen

 // Red button near retro
 addRetroButton(devices.retro);

 // Campfire in front of the main screen (raised and forward)
 campfire = createCampfire();
 if(devices.tv){
 const p = devices.tv.group.position;
 // raise above voxel floor to prevent blocking, place slightly in front of TV
 campfire.group.position.set(p.x, -14.5, p.z+3.0);
 } else {
 campfire.group.position.set(2,-14.5,-3.5);
 }
 scene.add(campfire.group);

 // Health monitor + panic button above bottom-left screen
 healthMonitor = addHealthMonitor(devices.crt);

 // Cables
 Object.values(devices).forEach(d=>createCableClusters(d));
 createLongHorizontalCables(6);

 setupOrientationWatcher();

 // Post
 setupPost();

 // Crawl now, then narrative cast
 startTextCrawl();

 // Mouse
 document.addEventListener('mousemove', e=>{
 mouse.x = -((e.clientX/innerWidth)*2-1);
 mouse.y = ((e.clientY/innerHeight)*2-1);
 });
 
 // Click interactions for cage, radar, clock
 setupClickableObjects();
 prepareZoomables();

 hookSettings();
 addFpsToggleButton();
 addThemeCaster();
 
 // Setup skip button for text crawl
 const skipBtn = document.getElementById('end3-skip');
 if (skipBtn) {
 skipBtn.style.display = 'block'; // Show during crawl
 skipBtn.addEventListener('click', () => {
 console.log('? Skipping text crawl');
 crawlActive = false; // Stop crawl animation
 const container = document.getElementById('crawl-container');
 if (container) container.style.display = 'none';
 skipBtn.style.display = 'none';
 });
 }
 
 window.addEventListener('resize', onResize);
 
 const totalTime = performance.now() - sceneStartTime;
 console.log(`=== INIT SCENE COMPLETE in ${totalTime.toFixed(0)}ms ===`);
}

/* =========================
 Devices + chrome
 ========================= */
function createDevice(cfg, bodyMat, bezelMatDark, bezelMatLight){
 const group=new THREE.Group();

 // Canvas texture for text
 const canvas=document.createElement('canvas'); canvas.width=2048; canvas.height=1536;
 const ctx=canvas.getContext('2d',{alpha:false}); ctx.fillStyle='#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
 const texture=new THREE.CanvasTexture(canvas); texture.minFilter=THREE.LinearFilter; texture.magFilter=THREE.LinearFilter;
 texture.anisotropy = 4;

 // Material
 const shaderCode=SHADERS[cfg.shader]||SHADERS.terminal;
 const material=new THREE.ShaderMaterial({
 uniforms:{uTex:{value:texture},uTime:{value:0},uColor:{value:new THREE.Color(cfg.color)},uGlitch:{value:0}},
 vertexShader:`varying vec2 vUv; varying vec3 vNormal; varying vec3 vViewPos; void main(){ vUv=uv; vNormal=normalize(normalMatrix*normal); vec4 mv=modelViewMatrix*vec4(position,1.0); vViewPos=-mv.xyz; gl_Position=projectionMatrix*mv; }`,
 fragmentShader:shaderCode.frag, side:THREE.DoubleSide
 });

 // Body (scale depth with screen size)
 const scaleFactor = Math.min(cfg.w, cfg.h) / 12; // Base size is ~12 units
 const bodyDepth = 2.4 * scaleFactor;
 const bodyPadding = 2.2 * scaleFactor;
 const isSmall = cfg.w < 5 || cfg.h < 5;
 const segments = isSmall ? 1 : 2; // Use 1 segment for small screens (way faster)
 const body=new THREE.Mesh(new THREE.BoxGeometry(cfg.w+bodyPadding,cfg.h+bodyPadding*0.9,bodyDepth,segments,segments,segments), bodyMat.clone());
 body.position.z=-0.6 * scaleFactor; body.castShadow=true; body.receiveShadow=true;

 // Bezel (scale thickness relative to screen size)
 const bezelMat=cfg.retro ? bezelMatLight : bezelMatDark;
 const thickness = 1.0 * scaleFactor;
 const depth = 1.9 * scaleFactor;
 const outerRadius = 1.2 * scaleFactor;
 const innerRadius = 0.8 * scaleFactor;
 const bezel=createBezelFrame(cfg.w,cfg.h,thickness,depth,outerRadius,innerRadius,bezelMat);
 bezel.position.z=0.55 * scaleFactor;

 // Screen (barrel for retro, scale curvature) - reduce segments for small screens
 const isSmallScreen = cfg.w < 5 || cfg.h < 5;
 const segsW = isSmallScreen ? 16 : 48; // Fewer segments for small screens
 const segsH = isSmallScreen ? 12 : 36;
 const screenGeo = cfg.retro ? createBarrelScreenGeometry(cfg.w,cfg.h,1.2*scaleFactor,20,isSmallScreen?32:80,isSmallScreen?24:60)
 : (()=>{const g=new THREE.PlaneGeometry(cfg.w,cfg.h,segsW,segsH),p=g.attributes.position;
 for(let i=0;i<p.count;i++){const x=p.getX(i),y=p.getY(i),nx=x/(cfg.w*0.5),ny=y/(cfg.h*0.5),r2=nx*nx+ny*ny; p.setZ(i, Math.cos(Math.min(1.0,Math.sqrt(r2)))*0.18*scaleFactor); }
 g.computeVertexNormals(); return g;})();
 const screen=new THREE.Mesh(screenGeo, material); screen.position.z=0.9 * scaleFactor;
 screen.userData.isScreen = true;

 // Scale glow intensity and range with screen size
 const glowIntensity = (cfg.name==='bios'?5.0:4.2) * Math.pow(scaleFactor, 1.5);
 const glowRange = 14 * scaleFactor;
 const glow=new THREE.PointLight(new THREE.Color(cfg.color), glowIntensity, glowRange);
 glow.position.z=2.0 * scaleFactor;

 group.add(body,bezel,screen,glow);
 group.position.set(...cfg.pos);
 const basePosition=new THREE.Vector3(...cfg.pos);
 group.rotation.x=cfg.tilt[0]; group.rotation.y=cfg.tilt[1];

 // BIOS blue vibe
 if(cfg.name==='bios'){
 material.uniforms.uColor.value = biosBlue.clone();
 }

 // Retro white body
 if(cfg.name==='retro'){
 body.material.color=new THREE.Color(0xe8e8ea);
 body.material.metalness=.6; body.material.roughness=.25;
 }

 return {group, canvas, ctx, texture, material, glow, config:cfg, content:'', glitchText:'', basePosition};
}

/* TV chrome overlay (transparent UI frame) */
function addTVChrome(dev){
 const cw = dev.config.w, ch = dev.config.h;
 const uiCanvas=document.createElement('canvas'); uiCanvas.width=1024; uiCanvas.height=768;
 const uiCtx=uiCanvas.getContext('2d');
 function drawUI(){
 uiCtx.clearRect(0,0,1024,768);
 // haze glass top bar
 uiCtx.fillStyle='rgba(255,245,180,0.08)';
 uiCtx.fillRect(0,0,1024,60);
 uiCtx.strokeStyle='rgba(255,220,120,0.5)'; uiCtx.lineWidth=2; uiCtx.strokeRect(0.5,0.5,1023,59);
 // tabs
 uiCtx.fillStyle='rgba(255,235,150,0.25)'; uiCtx.fillRect(16,16,120,28);
 uiCtx.fillStyle='#777'; uiCtx.font='18px IBM Plex Mono'; uiCtx.fillText('Viewer',24,36);
 // right controls
 uiCtx.fillStyle='rgba(255,235,160,0.18)'; uiCtx.fillRect(880,14,30,30);
 uiCtx.fillRect(920,14,30,30);
 uiCtx.fillRect(960,14,30,30);
 // window stroke
 uiCtx.strokeStyle='rgba(255,220,120,0.22)'; uiCtx.lineWidth=2; uiCtx.strokeRect(8,8,1008,752);
 }
 drawUI();
 const uiTex=new THREE.CanvasTexture(uiCanvas);
 const mat=new THREE.MeshBasicMaterial({map:uiTex, transparent:true, depthTest:true});
 const plane=new THREE.Mesh(new THREE.PlaneGeometry(cw, ch), mat);
 plane.position.z = 1.02; // just above screen
 dev.group.add(plane);
 // ensure this overlay does not billboard; keep it parented
 plane.matrixAutoUpdate = true;
 dev.uiOverlay = {canvas:uiCanvas, ctx:uiCtx, tex:uiTex, mesh:plane};
}

/* 7-seg clock (for top-right) */
function addTVClock(dev){
 const canvas=document.createElement('canvas'); canvas.width=512; canvas.height=128;
 const ctx=canvas.getContext('2d'); const tex=new THREE.CanvasTexture(canvas);
 const mat=new THREE.MeshBasicMaterial({map:tex, transparent:true, color:0xfff1a8});
 const plate=new THREE.Mesh(new THREE.PlaneGeometry(6,1.5), mat);
 plate.position.set(0, dev.config.h*0.62, 0.6);
 plate.rotation.x = -0.1; // slight downward tilt
 dev.group.add(plate);
 dev.clock = {canvas,ctx,tex,mesh:plate, tick:0, wordIndex:0};
 updateClock(dev.clock, true);
 // if this is the top-right TV (movie), raise and pull forward; add warm light
 if(dev.config && dev.config.name==='movie'){
 plate.position.y = dev.config.h*0.78;
 plate.position.z = 1.15;
 plate.rotation.x = -0.18;
 const warm=new THREE.PointLight(0xffd27a, 2.0, 11); warm.position.set(0, dev.config.h*0.7, 1.0);
 dev.group.add(warm); dev.clock.light=warm;
 }
}

function addAnalogPixelClock(dev){
 if(!dev) return;
 const radius=1.55;
 const holder=new THREE.Group();
 const rimGeo=new THREE.CylinderGeometry(radius,radius,0.34,48,1,true);
 const rimMat=new THREE.MeshStandardMaterial({color:0x3a2f12, metalness:0.72, roughness:0.32, emissive:0x2a210a, emissiveIntensity:0.35});
 const rim=new THREE.Mesh(rimGeo, rimMat);
 rim.rotation.x=Math.PI/2; // Rotate rim to face forward
 holder.add(rim);

 const backMat=new THREE.MeshStandardMaterial({color:0x1b1406, metalness:0.25, roughness:0.78, emissive:0x120c02, emissiveIntensity:0.25});
 const back=new THREE.Mesh(new THREE.CircleGeometry(radius*0.92, 48), backMat);
 back.position.z=-0.16;
 holder.add(back);

 const canvas=document.createElement('canvas'); canvas.width=256; canvas.height=256;
 const ctx=canvas.getContext('2d'); ctx.imageSmoothingEnabled=false;
 const tex=new THREE.CanvasTexture(canvas); tex.minFilter=THREE.NearestFilter; tex.magFilter=THREE.NearestFilter;
 const faceMat=new THREE.MeshBasicMaterial({map:tex, color:0xffffcc});
 const face=new THREE.Mesh(new THREE.CircleGeometry(radius*0.9, 64), faceMat);
 face.position.z=0.02;
 holder.add(face);

 const recess=new THREE.Mesh(new THREE.CylinderGeometry(radius*0.88,radius*0.88,0.1,48), new THREE.MeshStandardMaterial({color:0x09090f, metalness:0.15, roughness:0.78}));
 recess.rotation.x=Math.PI/2; // Rotate recess to face forward
 recess.position.z=-0.08;
 holder.add(recess);

 const glassMat=new THREE.MeshPhysicalMaterial({color:0xfff2a0, opacity:0.32, transparent:true, transmission:0.86, roughness:0.04, metalness:0.0});
 const glass=new THREE.Mesh(new THREE.CircleGeometry(radius*0.86, 48), glassMat);
 glass.position.z=0.09;
 holder.add(glass);

 // Deathly Hallows style triangle behind the clock - circle inscribed in triangle
 // For an inscribed circle: inradius = side / (2*sqrt(3))
 // So: side = inradius * 2 * sqrt(3), where inradius = radius of clock
 const triSide=radius*2*Math.sqrt(3);
 const triHeight=triSide*Math.sqrt(3)/2;
 const cornerRadius=0.22;
 
 // Create filled rounded triangle
 const triShape=new THREE.Shape();
 const pts=[
 {x:0, y:triHeight*2/3},
 {x:-triSide/2, y:-triHeight/3},
 {x:triSide/2, y:-triHeight/3}
 ];
 
 // Start at first corner after rounding
 const p0=pts[0], p1=pts[1], p2=pts[2];
 const dx01=p1.x-p0.x, dy01=p1.y-p0.y;
 const len01=Math.sqrt(dx01*dx01+dy01*dy01);
 const startX=p0.x+dx01/len01*cornerRadius, startY=p0.y+dy01/len01*cornerRadius;
 triShape.moveTo(startX, startY);
 
 for(let i=0; i<3; i++){
 const pCurr=pts[i];
 const pNext=pts[(i+1)%3];
 const pPrev=pts[(i+2)%3];
 
 // Vector from current to next
 const dx1=pNext.x-pCurr.x, dy1=pNext.y-pCurr.y;
 const len1=Math.sqrt(dx1*dx1+dy1*dy1);
 const ux1=dx1/len1, uy1=dy1/len1;
 
 // Vector from current to prev
 const dx0=pPrev.x-pCurr.x, dy0=pPrev.y-pCurr.y;
 const len0=Math.sqrt(dx0*dx0+dy0*dy0);
 const ux0=dx0/len0, uy0=dy0/len0;
 
 // Points before and after corner
 const beforeX=pCurr.x+ux0*cornerRadius, beforeY=pCurr.y+uy0*cornerRadius;
 const afterX=pCurr.x+ux1*cornerRadius, afterY=pCurr.y+uy1*cornerRadius;
 
 triShape.lineTo(beforeX, beforeY);
 triShape.quadraticCurveTo(pCurr.x, pCurr.y, afterX, afterY);
 }
 triShape.closePath();
 
 // Filled triangle
 const triGeo=new THREE.ShapeGeometry(triShape);
 const triMat=new THREE.MeshStandardMaterial({
 color:0x6b5528, 
 metalness:0.88, 
 roughness:0.15, 
 emissive:0x4a3518, 
 emissiveIntensity:0.45,
 side:THREE.DoubleSide
 });
 const bezel=new THREE.Mesh(triGeo, triMat);
 bezel.position.z=-0.25;
 holder.add(bezel);
 
 // Add outline edge for the casing - rebuild the path manually
 const edgePoints=[];
 
 for(let i=0; i<3; i++){
 const pCurr=pts[i];
 const pNext=pts[(i+1)%3];
 const pPrev=pts[(i+2)%3];
 
 // Vector from current to next
 const dx1=pNext.x-pCurr.x, dy1=pNext.y-pCurr.y;
 const len1=Math.sqrt(dx1*dx1+dy1*dy1);
 const ux1=dx1/len1, uy1=dy1/len1;
 
 // Vector from current to prev
 const dx0=pPrev.x-pCurr.x, dy0=pPrev.y-pCurr.y;
 const len0=Math.sqrt(dx0*dx0+dy0*dy0);
 const ux0=dx0/len0, uy0=dy0/len0;
 
 // Points before and after corner
 const beforeX=pCurr.x+ux0*cornerRadius, beforeY=pCurr.y+uy0*cornerRadius;
 const afterX=pCurr.x+ux1*cornerRadius, afterY=pCurr.y+uy1*cornerRadius;
 
 // Add straight line segment points
 const lineSegs=10;
 for(let j=0; j<lineSegs; j++){
 const t=j/lineSegs;
 const prevAfterX=pts[(i+2)%3].x+((pts[i].x-pts[(i+2)%3].x)/len0)*cornerRadius;
 const prevAfterY=pts[(i+2)%3].y+((pts[i].y-pts[(i+2)%3].y)/len0)*cornerRadius;
 const x=prevAfterX+(beforeX-prevAfterX)*t;
 const y=prevAfterY+(beforeY-prevAfterY)*t;
 edgePoints.push(new THREE.Vector3(x, y, 0));
 }
 
 // Add rounded corner points
 const cornerSegs=8;
 for(let j=0; j<=cornerSegs; j++){
 const t=j/cornerSegs;
 // Quadratic bezier curve
 const x=(1-t)*(1-t)*beforeX + 2*(1-t)*t*pCurr.x + t*t*afterX;
 const y=(1-t)*(1-t)*beforeY + 2*(1-t)*t*pCurr.y + t*t*afterY;
 edgePoints.push(new THREE.Vector3(x, y, 0));
 }
 }
 
 const edgeCurve=new THREE.CatmullRomCurve3(edgePoints, true);
 const edgeGeo=new THREE.TubeGeometry(edgeCurve, 128, 0.08, 12, true);
 const edgeMat=new THREE.MeshStandardMaterial({
 color:0x8b7030, 
 metalness:0.92, 
 roughness:0.12, 
 emissive:0x5a4520, 
 emissiveIntensity:0.55
 });
 const edge=new THREE.Mesh(edgeGeo, edgeMat);
 edge.position.z=-0.24;
 holder.add(edge);

 const halo=new THREE.Mesh(new THREE.RingGeometry(radius*0.95, radius*1.12, 64), new THREE.MeshBasicMaterial({color:0xffe97a, transparent:true, opacity:0.42, blending:THREE.AdditiveBlending}));
 halo.position.z=-0.01;
 holder.add(halo);

 const stemMat=new THREE.MeshStandardMaterial({color:0x12121a, metalness:0.55, roughness:0.4});
 const stem=new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.08,1.1,16), stemMat);
 stem.rotation.z=Math.PI/7;
 stem.position.set(radius*0.7, -radius*0.45, -0.2);
 holder.add(stem);

 // Metal base - flat circular disc facing camera (along Z axis)
 const stemBase=new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.08, 32), stemMat);
 stemBase.rotation.x=Math.PI/2; // Rotate so cylinder axis points toward camera (Z direction)
 stemBase.position.copy(stem.position).add(new THREE.Vector3(0, -0.55, -0.1));
 holder.add(stemBase);

 const light=new THREE.PointLight(0xffd95a, 1.8, 7);
 light.position.set(0, radius*0.32, 0.7);
 holder.add(light);

 holder.position.set(-dev.config.w*0.72, dev.config.h*0.5, 1.32);
 holder.rotation.x = dev.group.rotation.x*0.5;
 holder.rotation.y = dev.group.rotation.y;
 holder.rotation.z = 0.04;
 dev.group.add(holder);

 // Invisible pick proxy matching the clock face
 const clockProxy = new THREE.Mesh(new THREE.CircleGeometry(radius*0.95, 48), new THREE.MeshBasicMaterial({visible:false}));
 clockProxy.userData.isPickProxy = true;
 clockProxy.layers.set(2);
 holder.add(clockProxy);
 holder.userData.pickProxy = clockProxy;

 const clock={canvas, ctx, tex, group:holder, tick:0};
 updateAnalogPixelClock(clock, true);
 analogClockUpdaters.push(clock);
 dev.analogClock = clock;
}

function drawPixelHand(ctx, angle, length, width, color){
 const W=ctx.canvas.width, H=ctx.canvas.height;
 ctx.save();
 ctx.translate(W/2, H/2);
 ctx.rotate(angle);
 ctx.fillStyle=color;
 ctx.fillRect(-width/2, -length*0.12, width, -length);
 ctx.restore();
}

function updateAnalogPixelClock(clock, force=false){
 clock.tick++;
 if(!force && clock.tick%3!==0) return;
 const ctx=clock.ctx, W=ctx.canvas.width, H=ctx.canvas.height;
 ctx.clearRect(0,0,W,H);

 const center=W/2;
 const radius=W*0.4;
 const grad=ctx.createRadialGradient(center, center, radius*0.1, center, center, radius*1.1);
 grad.addColorStop(0,'#fff8c6');
 grad.addColorStop(0.55,'#ffe066');
 grad.addColorStop(1,'#f5c145');
 ctx.fillStyle=grad;
 ctx.fillRect(0,0,W,H);

 const gridSize=8;
 ctx.fillStyle='rgba(255,255,255,0.08)';
 for(let x=0;x<W;x+=gridSize){ ctx.fillRect(x,0,1,H); }
 for(let y=0;y<H;y+=gridSize){ ctx.fillRect(0,y,W,1); }

 ctx.strokeStyle='rgba(255,230,120,0.85)';
 ctx.lineWidth=4;
 ctx.beginPath();
 ctx.arc(center, center, radius+6, 0, Math.PI*2);
 ctx.stroke();

 const hourMarks=12;
 for(let i=0;i<hourMarks;i++){
 const a=-Math.PI/2 + i*(Math.PI*2/hourMarks);
 const x=Math.cos(a)*radius;
 const y=Math.sin(a)*radius;
 ctx.fillStyle=i%3===0?'#ffffff':'#1a1204';
 ctx.save();
 ctx.translate(center+x, center+y);
 ctx.rotate(a+Math.PI/2);
 ctx.fillRect(-6,-3,12,6);
 ctx.restore();
 }

 const now=new Date();
 const hour=now.getHours()%12 + now.getMinutes()/60;
 const minute=now.getMinutes() + now.getSeconds()/60;
 const second=now.getSeconds() + now.getMilliseconds()/1000;

 drawPixelHand(ctx, -Math.PI/2 + hour*(Math.PI*2/12), radius*0.55, 14, '#ffffff');
 drawPixelHand(ctx, -Math.PI/2 + minute*(Math.PI*2/60), radius*0.78, 10, '#161616');
 ctx.save();
 ctx.globalAlpha=0.85;
 drawPixelHand(ctx, -Math.PI/2 + second*(Math.PI*2/60), radius*0.84, 6, '#ffffff');
 ctx.restore();

 ctx.fillStyle='rgba(0,0,0,0.35)';
 ctx.beginPath();
 ctx.arc(center, center, 10, 0, Math.PI*2);
 ctx.fill();
 ctx.fillStyle='#ffe36a';
 ctx.beginPath();
 ctx.arc(center, center, 6, 0, Math.PI*2);
 ctx.fill();

 ctx.fillStyle='#1f1504';
 ctx.font='20px "VT323"';
 const digital=`${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}`;
 ctx.fillText(digital, center-42, center+radius*0.55);

 clock.tex.needsUpdate=true;
}
function updateClock(clock, force=false){
 clock.tick++;
 if(!force && clock.tick%5!==0) return; // refresh fast for smooth blinking colon
 const d=new Date();
 const hh=String(d.getHours()).padStart(2,'0'), mm=String(d.getMinutes()).padStart(2,'0'), ss=String(d.getSeconds()).padStart(2,'0');
 const word = PRAXIS_WORDS[clock.wordIndex%PRAXIS_WORDS.length]; if(clock.tick%120===0) clock.wordIndex++;
 const ctx=clock.ctx, W=clock.canvas.width, H=clock.canvas.height;
 ctx.clearRect(0,0,W,H);

 // background tint
 ctx.fillStyle='rgba(90,75,30,0.15)'; ctx.fillRect(0,0,W,H);

 // 7-seg drawing helpers
 const segColor = '#888';
 const segGlow = 'rgba(0,0,0,0.4)';
 const offColor = 'rgba(70,70,70,0.15)';
 const sx=28, sy=20, scale=1.0, digitW=52, digitH=88, gap=12;
 const on = (v)=>{ ctx.fillStyle=segColor; ctx.shadowColor=segGlow; ctx.shadowBlur=6; };
 const off=(v)=>{ ctx.fillStyle=offColor; ctx.shadowColor='transparent'; ctx.shadowBlur=0; };
 function drawSeg(x,y,w,h,active){
 if(active) on(); else off();
 const r=8; // rounded segment
 ctx.beginPath();
 ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y); ctx.quadraticCurveTo(x+w,y,x+w,y+r);
 ctx.lineTo(x+w,y+h-r); ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
 ctx.lineTo(x+r,y+h); ctx.quadraticCurveTo(x,y+h,x,y+h-r);
 ctx.lineTo(x,y+r); ctx.quadraticCurveTo(x,y,x+r,y);
 ctx.closePath(); ctx.fill();
 }
 function drawDigit(d, ox, oy){
 // segment map A,B,C,D,E,F,G
 const MAP={
 '0':[1,1,1,1,1,1,0],'1':[0,1,1,0,0,0,0],'2':[1,1,0,1,1,0,1],'3':[1,1,1,1,0,0,1],
 '4':[0,1,1,0,0,1,1],'5':[1,0,1,1,0,1,1],'6':[1,0,1,1,1,1,1],'7':[1,1,1,0,0,0,0],
 '8':[1,1,1,1,1,1,1],'9':[1,1,1,1,0,1,1]
 };
 const s=MAP[d]||[0,0,0,0,0,0,0];
 const th=12; // segment thickness
 // A (top)
 drawSeg(ox+th, oy, digitW-2*th, th, s[0]);
 // B (top-right)
 drawSeg(ox+digitW-th, oy+th, th, (digitH-3*th)/2, s[1]);
 // C (bottom-right)
 drawSeg(ox+digitW-th, oy+digitH/2+th/2, th, (digitH-3*th)/2, s[2]);
 // D (bottom)
 drawSeg(ox+th, oy+digitH-th, digitW-2*th, th, s[3]);
 // E (bottom-left)
 drawSeg(ox, oy+digitH/2+th/2, th, (digitH-3*th)/2, s[4]);
 // F (top-left)
 drawSeg(ox, oy+th, th, (digitH-3*th)/2, s[5]);
 // G (middle)
 drawSeg(ox+th, oy+digitH/2-th/2, digitW-2*th, th, s[6]);
 }
 function drawColon(ox, oy, blink){
 const r=8; const gapY=22; const color = blink?segColor:offColor;
 ctx.shadowColor=blink?segGlow:'transparent'; ctx.shadowBlur=blink?12:0; ctx.fillStyle=color;
 ctx.beginPath(); ctx.arc(ox, oy+digitH*0.32, r, 0, Math.PI*2); ctx.fill();
 ctx.beginPath(); ctx.arc(ox, oy+digitH*0.70, r, 0, Math.PI*2); ctx.fill();
 }

 const blink = Math.floor(clock.tick/10)%2===0;
 let x=sx; const y=sy;
 const nums=[hh[0],hh[1],':',mm[0],mm[1],':',ss[0],ss[1]];
 nums.forEach(ch=>{
 if(ch===':'){
 drawColon(x+10, y, blink); x += 22; // narrow spacing for colon
 } else {
 drawDigit(ch, x, y); x += digitW + gap;
 }
 });

 // Right-side word
 ctx.shadowColor='rgba(0,0,0,0.35)'; ctx.shadowBlur=6; ctx.fillStyle='#bdbdbd';
 ctx.font='28px IBM Plex Mono'; ctx.textAlign='right'; ctx.textBaseline='middle';
 ctx.fillText(word, W-18, H/2);
 clock.tex.needsUpdate = true;
}

/* Pixelated digital clock (center TV) */
function addPixelClock(dev){
 const canvas=document.createElement('canvas'); canvas.width=512; canvas.height=128;
 const ctx=canvas.getContext('2d'); const tex=new THREE.CanvasTexture(canvas);
 tex.magFilter=THREE.NearestFilter; tex.minFilter=THREE.NearestFilter;
 const mat=new THREE.MeshBasicMaterial({map:tex, transparent:true});
 const plate=new THREE.Mesh(new THREE.PlaneGeometry(6,1.5), mat);
 plate.position.set(0, dev.config.h*0.62, 0.6);
 dev.group.add(plate);
 dev.pixelClock = {canvas,ctx,tex,mesh:plate, tick:0};
 updatePixelClock(dev.pixelClock, true);
}
function updatePixelClock(clock, force=false){
 clock.tick++;
 if(!force && clock.tick%15!==0) return;
 const d=new Date();
 const hh=String(d.getHours()).padStart(2,'0'), mm=String(d.getMinutes()).padStart(2,'0'), ss=String(d.getSeconds()).padStart(2,'0');
 const ctx=clock.ctx, W=clock.canvas.width, H=clock.canvas.height;
 ctx.clearRect(0,0,W,H);
 ctx.fillStyle='rgba(255,210,100,0.1)'; ctx.fillRect(0,0,W,H);
 ctx.imageSmoothingEnabled=false;
 ctx.shadowColor='rgba(255,210,120,0.8)'; ctx.shadowBlur=10; ctx.fillStyle='#ffd966';
 ctx.font='80px VT323'; ctx.textAlign='left'; ctx.textBaseline='middle';
 const text=`${hh}:${mm}:${ss}`;
 ctx.fillText(text, 24, H/2);
 clock.tex.needsUpdate=true;
}

/* Static/glitch overlay for a device (barrel option) */
function addTVStaticOverlay(dev){
 const canvas=document.createElement('canvas'); canvas.width=512; canvas.height=384;
 const ctx=canvas.getContext('2d'); const tex=new THREE.CanvasTexture(canvas);
 tex.minFilter=THREE.LinearFilter; tex.magFilter=THREE.LinearFilter;
 const mat=new THREE.MeshBasicMaterial({map:tex, transparent:true, opacity:0.48, color:0xffeeaa});
 // barrel distortion like retro: slightly curved plane
 const geo = createBarrelScreenGeometry(dev.config.w, dev.config.h, 1.2, 20, 64, 48);
 const plane=new THREE.Mesh(geo, mat);
 plane.position.z = 1.01; // slightly above screen but below chrome
 dev.group.add(plane);
 dev.staticOverlay = {canvas,ctx,tex,mesh:plane, t:0, glitchTimer:2.5, glitch:false};
 updateStaticOverlay(dev.staticOverlay, true);
}
function drawSMPTE(ctx,W,H){
 const bars=['#c0c0c0','#c0c000','#00c0c0','#00c000','#c000c0','#c00000','#0000c0'];
 const w=W/bars.length; for(let i=0;i<bars.length;i++){ ctx.fillStyle=bars[i]; ctx.fillRect(i*w,0,w,H*0.7); }
 ctx.fillStyle='#000'; ctx.fillRect(0,H*0.7,W,H*0.3);
 ctx.fillStyle='#fff'; ctx.font='24px IBM Plex Mono'; ctx.textAlign='center'; ctx.textBaseline='middle';
 ctx.fillText('STANDBY', W/2, H*0.85);
}
function updateStaticOverlay(overlay, force=false){
 overlay.t += 0.016;
 overlay.glitchTimer -= 0.016;
 const ctx=overlay.ctx, W=overlay.canvas.width, H=overlay.canvas.height;
 if(overlay.glitchTimer<=0){ overlay.glitch=!overlay.glitch; overlay.glitchTimer = overlay.glitch?0.6:3+Math.random()*4; }
 ctx.clearRect(0,0,W,H);
 if(overlay.glitch){
 drawSMPTE(ctx,W,H);
 } else {
 const imgData=ctx.createImageData(W,H); const d=imgData.data;
 for(let i=0;i<W*H;i++){
 const n=(Math.random()*255)|0; d[i*4+0]=n; d[i*4+1]=n; d[i*4+2]=n; d[i*4+3]=255;
 }
 ctx.putImageData(imgData,0,0);
 ctx.fillStyle='rgba(0,0,0,0.8)'; ctx.font='20px IBM Plex Mono'; ctx.textAlign='center'; ctx.textBaseline='middle';
 ctx.fillText('NO SIGNAL', W/2, H*0.9);
 }
 overlay.tex.needsUpdate=true;
}

/* =========================
 Campfire (3 glowing orbs with additive trails)
 ========================= */
function createCampfire(){
 const group=new THREE.Group();
 // three base orbs (primary colors)
 const orbColors=[0xff5533,0x33ff85,0x66aaff];
 const orbs=[];
 // arrange in Venn-triangle layout for chromatic overlap
 const centers=[new THREE.Vector3(-0.35,0.35,0), new THREE.Vector3(0.35,0.35,0), new THREE.Vector3(0,0.0,0)];
 orbColors.forEach((c,i)=>{
 const geo=new THREE.SphereGeometry(0.35,24,24);
 const mat=new THREE.MeshBasicMaterial({color:c});
 const m=new THREE.Mesh(geo,mat); m.position.copy(centers[i]); group.add(m);
 const glow=new THREE.PointLight(c, 1.8, 8); glow.position.copy(m.position); group.add(glow);
 // colored trail sprite (avoid washing to white)
 const col = new THREE.Color(c);
 const tex=makeColoredTrailTexture(col);
 const spr=new THREE.Sprite(new THREE.SpriteMaterial({map:tex, transparent:true, depthWrite:false, blending:THREE.AdditiveBlending, opacity:0.9}));
 spr.scale.set(1.2,5.0,1); spr.position.set(m.position.x,1.6,0); group.add(spr);
 orbs.push({mesh:m, light:glow, trail:spr, t:Math.random()*Math.PI*2});
 });
 // ambient flame light
 const mixLight=new THREE.PointLight(0xff8844, 1.6, 14); mixLight.position.set(0,1.2,0); group.add(mixLight);
 
 // Low-poly detailed logs - thicker, deformed, stacked in campfire cone structure
 const logMat=new THREE.MeshStandardMaterial({color:0x6b4028, roughness:.8, metalness:.05});
 const branchMat=new THREE.MeshStandardMaterial({color:0x5a3520, roughness:.85, metalness:.03});
 
 function createDetailedLog(length, thickness, deform=0){
 const logGroup=new THREE.Group();
 // Main log body (low-poly: 6 segments) with deformation
 const logGeo=new THREE.CylinderGeometry(thickness, thickness*1.15, length, 6);
 const pos=logGeo.attributes.position;
 // Add organic deformations
 for(let i=0; i<pos.count; i++){
 const y=pos.getY(i);
 const x=pos.getX(i);
 const z=pos.getZ(i);
 const noise=Math.sin(y*3.0+i)*deform*0.08;
 pos.setX(i, x*(1+noise));
 pos.setZ(i, z*(1+noise));
 }
 logGeo.computeVertexNormals();
 const mainLog=new THREE.Mesh(logGeo, logMat.clone());
 logGroup.add(mainLog);
 
 // Add swirl pattern on the base (tree rings)
 const ringGeo=new THREE.TorusGeometry(thickness*0.85, 0.02, 4, 8);
 for(let r=0; r<3; r++){
 const ring=new THREE.Mesh(ringGeo, new THREE.MeshStandardMaterial({color:0x4a2818, roughness:.9}));
 ring.rotation.x=Math.PI/2;
 ring.position.y=-length/2+0.03;
 ring.scale.set(1-r*0.2, 1-r*0.2, 1);
 logGroup.add(ring);
 }
 
 // Add small organic branches with proper rotation to extend outward
 const numBranches=2+Math.floor(Math.random()*2);
 for(let b=0; b<numBranches; b++){
 const branchLen=0.5+Math.random()*0.4;
 const branchGeo=new THREE.CylinderGeometry(0.04, 0.06, branchLen, 4);
 const branch=new THREE.Mesh(branchGeo, branchMat.clone());
 const angle=Math.random()*Math.PI*2;
 const yPos=(Math.random()-0.5)*length*0.6;
 
 // Position branch on surface of log
 branch.position.set(Math.cos(angle)*thickness, yPos, Math.sin(angle)*thickness);
 
 // Rotate branch to extend outward from log surface
 branch.rotation.y=angle; // Face outward
 branch.rotation.z=Math.PI/2-0.6; // Tilt away from log at angle
 branch.castShadow=true;
 logGroup.add(branch);
 
 // Tiny twig on branch extending further
 if(Math.random()>0.4){
 const twigGeo=new THREE.CylinderGeometry(0.015, 0.025, 0.15, 3);
 const twig=new THREE.Mesh(twigGeo, branchMat.clone());
 // Position twig at end of branch extending outward
 const branchEndDist=branchLen*0.4;
 twig.position.set(
 branch.position.x + Math.cos(angle)*branchEndDist,
 branch.position.y,
 branch.position.z + Math.sin(angle)*branchEndDist
 );
 twig.rotation.y=angle;
 twig.rotation.z=Math.PI/2-0.8;
 logGroup.add(twig);
 }
 }
 
 return logGroup;
 }
 
 // Create realistic campfire cone structure
 // Base pile: 4 logs laying flat forming foundation
 const baseLogs=4;
 for(let i=0; i<baseLogs; i++){
 const log=createDetailedLog(2.6, 0.32, 1.2);
 const angle=i*(Math.PI*2/baseLogs);
 log.rotation.z=Math.PI/2; // Lay horizontally
 const radius=1.0;
 log.position.x=Math.cos(angle)*radius;
 log.position.z=Math.sin(angle)*radius;
 log.position.y=0.15;
 log.rotation.y=angle+Math.PI/2+0.1;
 log.castShadow=true; 
 log.receiveShadow=true; 
 group.add(log);
 }
 
 // Mid layer: 5 logs angled upward forming cone
 const midLogs=5;
 for(let i=0; i<midLogs; i++){
 const log=createDetailedLog(2.8, 0.28, 1.0);
 const angle=i*(Math.PI*2/midLogs)+0.2;
 log.rotation.z=Math.PI/2+0.45; // Angle upward
 const radius=0.85;
 log.position.x=Math.cos(angle)*radius;
 log.position.z=Math.sin(angle)*radius;
 log.position.y=0.42;
 log.rotation.y=angle+Math.PI/2;
 log.castShadow=true; 
 log.receiveShadow=true; 
 group.add(log);
 }
 
 // Top layer: 3 logs steeply angled forming tip
 const topLogs=3;
 for(let i=0; i<topLogs; i++){
 const log=createDetailedLog(2.2, 0.24, 0.8);
 const angle=i*(Math.PI*2/topLogs)+0.5;
 log.rotation.z=Math.PI/2+0.75; // Steep angle
 const radius=0.5;
 log.position.x=Math.cos(angle)*radius;
 log.position.z=Math.sin(angle)*radius;
 log.position.y=0.85;
 log.rotation.y=angle+Math.PI/2;
 log.castShadow=true; 
 log.receiveShadow=true; 
 group.add(log);
 }
 
 // White hole effect above campfire with lens distortion
 const whiteHoleGroup = new THREE.Group();
 whiteHoleGroup.position.set(0, 3.5, 0); // Float above campfire
 whiteHoleGroup.userData = {pulseColor: null, pulseIntensity: 0};
 
 // Black pulsating core (strong and obvious)
 const blackCoreGeo = new THREE.SphereGeometry(0.42, 32, 32);
 const blackCoreMat = new THREE.MeshStandardMaterial({
 color: 0x000000,
 emissive: 0x000000,
 roughness: 0.85,
 metalness: 0.1
 });
 const blackCore = new THREE.Mesh(blackCoreGeo, blackCoreMat);
 blackCore.userData.isBlackCore = true;
 whiteHoleGroup.add(blackCore);
 
 // Core white orb (around black core)
 const coreGeo = new THREE.SphereGeometry(0.6, 32, 32);
 const coreMat = new THREE.MeshBasicMaterial({
 color: 0xffffff,
 transparent: true,
 opacity: 0.8
 });
 const core = new THREE.Mesh(coreGeo, coreMat);
 core.userData.isCore = true;
 whiteHoleGroup.add(core);
 
 // Additive glow rings
 for(let i = 0; i < 3; i++){
 const ringSize = 1.2 + i * 0.8;
 const ringGeo = new THREE.RingGeometry(ringSize, ringSize + 0.15, 32);
 const ringMat = new THREE.MeshBasicMaterial({
 color: 0xffffff,
 transparent: true,
 opacity: 0.6 - i * 0.15,
 side: THREE.DoubleSide,
 blending: THREE.AdditiveBlending,
 depthWrite: false
 });
 const ring = new THREE.Mesh(ringGeo, ringMat);
 ring.userData.rotSpeed = 0.2 + i * 0.15;
 ring.userData.layer = i;
 whiteHoleGroup.add(ring);
 }
 
 // Lens distortion sprite (radial blur effect)
 const lensSize = 256;
 const lensCanvas = document.createElement('canvas');
 lensCanvas.width = lensCanvas.height = lensSize;
 const lensCtx = lensCanvas.getContext('2d');
 const lensGrad = lensCtx.createRadialGradient(lensSize/2, lensSize/2, 0, lensSize/2, lensSize/2, lensSize/2);
 lensGrad.addColorStop(0, 'rgba(255,255,255,0)');
 lensGrad.addColorStop(0.3, 'rgba(255,255,255,0.05)');
 lensGrad.addColorStop(0.6, 'rgba(255,255,255,0.15)');
 lensGrad.addColorStop(1, 'rgba(255,255,255,0)');
 lensCtx.fillStyle = lensGrad;
 lensCtx.fillRect(0, 0, lensSize, lensSize);
 const lensTex = new THREE.CanvasTexture(lensCanvas);
 
 const lensSprite = new THREE.Sprite(new THREE.SpriteMaterial({
 map: lensTex,
 transparent: true,
 blending: THREE.AdditiveBlending,
 depthWrite: false
 }));
 lensSprite.scale.set(5, 5, 1);
 whiteHoleGroup.add(lensSprite);
 
 // Bright point light
 const whiteLight = new THREE.PointLight(0xffffff, 3.5, 20);
 whiteHoleGroup.add(whiteLight);
 
 group.add(whiteHoleGroup);
 
 return {group, orbs, mixLight, prevTime:0, whiteHole: whiteHoleGroup};
}
function makeRadialGradientTexture(stops, size){
 const c=document.createElement('canvas'); c.width=c.height=size; const g=c.getContext('2d');
 const grd=g.createRadialGradient(size/2,size/2,0,size/2,size/2,size/2);
 stops.forEach(([off,col])=>grd.addColorStop(off,col));
 g.fillStyle=grd; g.fillRect(0,0,size,size);
 const tex=new THREE.CanvasTexture(c); return tex;
}
function makeColoredTrailTexture(color){
 const size=256; const c=document.createElement('canvas'); c.width=c.height=size; const g=c.getContext('2d');
 const r=color.r*255|0, gr=color.g*255|0, b=color.b*255|0;
 const grd=g.createRadialGradient(size/2,size*0.8,0,size/2,size*0.8,size/2);
 grd.addColorStop(0,`rgba(${r},${gr},${b},0.85)`);
 grd.addColorStop(0.5,`rgba(${r},${gr},${b},0.25)`);
 grd.addColorStop(1,`rgba(${r},${gr},${b},0.0)`);
 g.fillStyle=grd; g.fillRect(0,0,size,size);
 const tex=new THREE.CanvasTexture(c); return tex;
}
function updateCampfire(cf, t){
 const dt = cf.prevTime? (t - cf.prevTime) : 0.016; cf.prevTime=t;
 // orb motion and trails
 cf.orbs.forEach((o,i)=>{
 o.t += dt*(0.8 + i*0.2);
 const baseX=(i-1)*0.5;
 o.mesh.position.x = baseX + Math.sin(o.t*1.2 + i)*0.06;
 o.mesh.position.y = 0.3 + Math.abs(Math.sin(o.t*1.6))*0.08;
 o.light.position.copy(o.mesh.position);
 // trail follows and stretches upward
 o.trail.position.x = o.mesh.position.x;
 o.trail.position.y = 1.6 + Math.sin(o.t*0.9 + i)*0.1;
 o.trail.scale.y = 4.6 + Math.sin(o.t*1.3 + i)*0.8;
 o.trail.material.opacity = 0.85 + 0.1*Math.sin(o.t*2.0);
 });
 // mix light flicker
 cf.mixLight.intensity = 2.0 + Math.sin(t*10.0)*0.2 + Math.random()*0.08;
}

/* Terminal flashing triangle indicator (attach to a device) */
function addTerminalIndicator(dev){
 if(!dev) return;
 // black close dot on terminal UI
 const dotGeo=new THREE.CircleGeometry(0.18, 24);
 const dotMat=new THREE.MeshBasicMaterial({color:0x000000});
 const dot=new THREE.Mesh(dotGeo,dotMat);
 dot.position.set(dev.config.w*0.5-1.0, dev.config.h*0.5-0.9, 1.06);
 dev.group.add(dot);
 dev.indicator = dot;
}

// Removed mirrorCrawlToMainMonitor - the TV now shows pure recursive scene capture

/* Red button near retro */
function addRetroButton(dev){
 if(!dev) return;
 const button=new THREE.Mesh(new THREE.CylinderGeometry(0.8,0.8,0.4,24), new THREE.MeshStandardMaterial({color:0xff2244, emissive:0xff0022, emissiveIntensity:2.5, metalness:.6, roughness:.25}));
 // place directly in front of the device using its forward vector
 const forward=new THREE.Vector3(0,0,1).applyQuaternion(dev.group.quaternion);
 const up=new THREE.Vector3(0,1,0);
 const pos = dev.group.position.clone().add(forward.multiplyScalar(2.0)).add(up.multiplyScalar(-dev.config.h*0.2));
 button.position.copy(pos);
 button.castShadow=true; scene.add(button);
 const light=new THREE.PointLight(0xff2244,3.0,6); button.add(light);
}

function addVoxelCage(dev){
 if(!dev) return null;
 const holder=new THREE.Group();
 const size=3.9;
 const half=size/2;
 const frameGeo=new THREE.BoxGeometry(size,size,size);
 const edges=new THREE.EdgesGeometry(frameGeo);
 const frameMat=new THREE.LineBasicMaterial({color:0x9bd6ff, transparent:true, opacity:0.85, blending:THREE.AdditiveBlending});
 const frame=new THREE.LineSegments(edges, frameMat);
 holder.add(frame);

 const glowEdges=new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.BoxGeometry(size*1.08,size*1.08,size*1.08)), new THREE.LineBasicMaterial({color:0xc2e7ff, transparent:true, opacity:0.32, blending:THREE.AdditiveBlending}));
 holder.add(glowEdges);

 const glassMat=new THREE.MeshPhysicalMaterial({color:0x4fb6ff, transparent:true, opacity:0.2, transmission:0.85, roughness:0.14, metalness:0.08, emissive:0x1f3c6f, emissiveIntensity:0.2});
 const glassGeo=new THREE.PlaneGeometry(size, size);
 const faces=[
 {pos:[ half,0,0], rot:[0,Math.PI/2,0]},
 {pos:[-half,0,0], rot:[0,-Math.PI/2,0]},
 {pos:[0, half,0], rot:[-Math.PI/2,0,0]},
 {pos:[0,-half,0], rot:[Math.PI/2,0,0]},
 {pos:[0,0, half], rot:[0,0,0]},
 {pos:[0,0,-half], rot:[0,Math.PI,0]}
 ];
 faces.forEach(({pos,rot})=>{
 const panel=new THREE.Mesh(glassGeo, glassMat.clone());
 panel.position.set(pos[0], pos[1], pos[2]);
 panel.rotation.set(rot[0], rot[1], rot[2]);
 holder.add(panel);
 
 // Add grid lines to each face
 const gridSize = 8;
 const gridStep = size / gridSize;
 const gridPoints = [];
 // Horizontal lines
 for(let i = 0; i <= gridSize; i++){
 const y = -half + i * gridStep;
 gridPoints.push(new THREE.Vector3(-half, y, 0));
 gridPoints.push(new THREE.Vector3(half, y, 0));
 }
 // Vertical lines
 for(let i = 0; i <= gridSize; i++){
 const x = -half + i * gridStep;
 gridPoints.push(new THREE.Vector3(x, -half, 0));
 gridPoints.push(new THREE.Vector3(x, half, 0));
 }
 const gridGeo = new THREE.BufferGeometry().setFromPoints(gridPoints);
 const gridMat = new THREE.LineBasicMaterial({
 color:0x8ac5ff, 
 transparent:true, 
 opacity:0.45, 
 blending:THREE.AdditiveBlending
 });
 const grid = new THREE.LineSegments(gridGeo, gridMat);
 grid.position.copy(panel.position);
 grid.rotation.copy(panel.rotation);
 grid.position.z += 0.01; // Slightly in front of panel
 holder.add(grid);
 });

 const gateMaterial=new THREE.MeshBasicMaterial({color:0x6fd0ff, transparent:true, opacity:0.0, blending:THREE.AdditiveBlending, side:THREE.DoubleSide, depthWrite:false});
 const gates=[];
 faces.forEach(({pos,rot},idx)=>{
 const gate=new THREE.Mesh(new THREE.PlaneGeometry(size*0.96, size*0.96, 16, 16), gateMaterial.clone());
 gate.position.set(pos[0]*0.97, pos[1]*0.97, pos[2]*0.97);
 gate.rotation.set(rot[0], rot[1], rot[2]);
 gate.visible=true;
 gate.material.opacity=0.0;
 holder.add(gate);
 const axis = idx<2?'x':idx<4?'y':'z';
 const dir = idx%2===0?1:-1;
 gates.push({mesh:gate, axis, dir, strength:0});
 });

 const gizmo=new THREE.Group();
 const squareSizes=[1.4,1.1,0.9];
 const colors=[0xff5c5c,0x6cff9a,0x58a6ff];
 squareSizes.forEach((s,i)=>{
 const geo=new THREE.BufferGeometry().setFromPoints([
 new THREE.Vector3(-s,-s,0),
 new THREE.Vector3( s,-s,0),
 new THREE.Vector3( s, s,0),
 new THREE.Vector3(-s, s,0)
 ]);
 const loop=new THREE.LineLoop(geo, new THREE.LineBasicMaterial({color:colors[i], linewidth:2, transparent:true, opacity:0.9}));
 if(i===0) loop.rotation.y=Math.PI/2;
 if(i===1) loop.rotation.x=Math.PI/2;
 gizmo.add(loop);
 const connectorGeo=new THREE.BufferGeometry().setFromPoints([
 new THREE.Vector3(0,0,0),
 i===0?new THREE.Vector3(s,0,0):i===1?new THREE.Vector3(0,s,0):new THREE.Vector3(0,0,s)
 ]);
 const connector=new THREE.Line(connectorGeo, new THREE.LineBasicMaterial({color:colors[i], transparent:true, opacity:0.6}));
 gizmo.add(connector);
 });
 const centerOrb=new THREE.Mesh(new THREE.SphereGeometry(0.18, 24, 16), new THREE.MeshStandardMaterial({color:0xffffff, emissive:0x66aaff, emissiveIntensity:1.4, roughness:0.2, metalness:0.4}));
 gizmo.add(centerOrb);
 holder.add(gizmo);

 const base=new THREE.Mesh(new THREE.CylinderGeometry(1.2,1.5,0.3,24), new THREE.MeshStandardMaterial({color:0x0b0d12, metalness:0.35, roughness:0.5}));
 base.position.set(0,-half-0.35,0);
 holder.add(base);

 const cageLight=new THREE.PointLight(0x66caff, 2.2, 10);
 cageLight.position.set(0,0,0);
 holder.add(cageLight);

 holder.position.set(-dev.config.w*0.78, -dev.config.h*0.02, 1.22);
 holder.rotation.x = dev.group.rotation.x;
 holder.rotation.y = dev.group.rotation.y;
 dev.group.add(holder);

 // Lightweight invisible pick proxy (raycast-only)
 const pickProxy=new THREE.Mesh(new THREE.BoxGeometry(size*1.2, size*1.2, size*1.2), new THREE.MeshBasicMaterial({visible:false}));
 pickProxy.userData.isPickProxy=true;
 pickProxy.layers.set(2);
 holder.add(pickProxy);
 holder.userData.pickProxy = pickProxy;

 const voxelGeo=new THREE.BoxGeometry(0.28,0.28,0.28);
 const voxelMat=new THREE.MeshStandardMaterial({color:0xffffff, emissive:0xffffff, emissiveIntensity:0.65, roughness:0.2, metalness:0.15});
 const voxels=[];
 for(let i=0;i<16;i++){
 const mesh=new THREE.Mesh(voxelGeo, voxelMat.clone());
 mesh.position.set((Math.random()-0.5)*size*0.5, (Math.random()-0.5)*size*0.5, (Math.random()-0.5)*size*0.5);
 mesh.visible=false;
 holder.add(mesh);
 voxels.push({mesh, velocity:new THREE.Vector3(), cooldown:Math.random()*1.2});
 }

 const gateMap={};
 gates.forEach(g=>{ gateMap[`${g.axis}${g.dir>0?'+':'-'}`]=g; });

 const emitter={group:holder, gizmo, voxels, half, spitTimer:1.4+Math.random()*0.6, gates, gateMap};
 cageEmitters.push(emitter);
 dev.voxelCage=emitter;
 return emitter;
}

/* Health monitor + panic button above bottom-left screen */
function addHealthMonitor(dev){
 if(!dev) return;
 // monitor body
 const plate=new THREE.Mesh(new THREE.BoxGeometry(6,2.2,0.3), new THREE.MeshStandardMaterial({color:0x0a0a0c, metalness:.4, roughness:.4}));
 plate.position.copy(dev.group.position).add(new THREE.Vector3(0, dev.config.h*0.75, 1.2));
 plate.castShadow=true; plate.receiveShadow=true; scene.add(plate);
 // red neon strip
 const strip=new THREE.Mesh(new THREE.BoxGeometry(5.2,0.15,0.08), new THREE.MeshStandardMaterial({color:0x220000, emissive:0xff1122, emissiveIntensity:2.2, roughness:.2, metalness:.3}));
 strip.position.set(0,0.5,0.18); plate.add(strip);
 const neonLight=new THREE.PointLight(0xff1133,1.6,8); neonLight.position.set(0,0.5,0.3); plate.add(neonLight);
 // panic button
 const panic=new THREE.Mesh(new THREE.CylinderGeometry(0.35,0.35,0.22,24), new THREE.MeshStandardMaterial({color:0x660000, emissive:0xff0022, emissiveIntensity:2.0, metalness:.6, roughness:.25}));
 panic.position.set(plate.position.x+3.4, plate.position.y, plate.position.z+0.25);
 panic.castShadow=true; scene.add(panic);
 const panicLight=new THREE.PointLight(0xff1122,2.2,6); panic.add(panicLight);
 // ECG canvas
 const canvas=document.createElement('canvas'); canvas.width=512; canvas.height=96; const ctx=canvas.getContext('2d');
 const tex=new THREE.CanvasTexture(canvas);
 const mat=new THREE.MeshBasicMaterial({map:tex, transparent:true});
 const face=new THREE.Mesh(new THREE.PlaneGeometry(5.4,1.0), mat); face.position.set(0,0.05,0.16); plate.add(face);
 const ecg={canvas,ctx,tex,t:0};
 plate.userData.ecg=ecg;
 return {plate, ecg, panic};
}

/* Pixelated heart radar above BIOS */
function addBiosRadar(dev){
 if(!dev) return;
 // create a small radar screen above the CRT (bottom-left)
 // use circular screen to avoid square clipping
 const screenGeo=new THREE.CircleGeometry(2.0, 64);
 const canvas=document.createElement('canvas'); canvas.width=256; canvas.height=256; const ctx=canvas.getContext('2d');
 function drawHeart(){
 const W=canvas.width, H=canvas.height; ctx.clearRect(0,0,W,H);
 // dark background
 ctx.fillStyle='#0a0a0e'; ctx.fillRect(0,0,W,H);
 // grid pattern (dark magenta)
 ctx.strokeStyle='rgba(80,20,60,0.25)'; ctx.lineWidth=1;
 for(let x=0;x<W;x+=16){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
 for(let y=0;y<H;y+=16){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
 // pixel heart (magenta)
 ctx.imageSmoothingEnabled=false; const s=10, ox=W/2-5*s, oy=H/2-3*s; ctx.fillStyle='#ff66cc';
 const heart=[ '01100110', '11111111', '11111111', '01111110', '00111100', '00011000' ];
 heart.forEach((row,y)=>{ [...row].forEach((ch,x)=>{ if(ch==='1') ctx.fillRect(ox+x*s, oy+y*s, s, s); }); });
 // concentric rings with bloom effect (bright magenta for bloom)
 ctx.shadowColor='rgba(255,102,204,0.9)'; ctx.shadowBlur=12;
 ctx.strokeStyle='rgba(255,102,204,0.85)'; ctx.lineWidth=2.5; 
 for(let r=40;r<=110;r+=18){ ctx.beginPath(); ctx.arc(W/2,H/2,r,0,Math.PI*2); ctx.stroke(); }
 ctx.shadowBlur=0;
 }
 drawHeart();
 const tex=new THREE.CanvasTexture(canvas); const mat=new THREE.ShaderMaterial({
 uniforms:{uTex:{value:tex},uTime:{value:0},uColor:{value:new THREE.Color(0xffffff)},uGlitch:{value:0}},
 vertexShader:`varying vec2 vUv; varying vec3 vNormal; varying vec3 vViewPos; void main(){ vUv=uv; vNormal=normalize(normalMatrix*normal); vec4 mv=modelViewMatrix*vec4(position,1.0); vViewPos=-mv.xyz; gl_Position=projectionMatrix*mv; }`,
 fragmentShader:SHADERS.radar.frag, transparent:true
 });
 const mesh=new THREE.Mesh(screenGeo, mat);
 // place near bottom-left CRT, slightly above and offset to the right, mount inside a holster frame
 const holder=new THREE.Group();
 holder.position.copy(dev.group.position.clone().add(new THREE.Vector3(3.5, dev.config.h*0.9, 1.6)));
 holder.rotation.copy(dev.group.rotation);
 holder.add(mesh);
 // nested donut-cylinder holster - radius aligned with radar screen (2.0)
 const outer=new THREE.Mesh(new THREE.TorusGeometry(2.0,0.18,16,64), new THREE.MeshStandardMaterial({color:0x111318, metalness:.6, roughness:.3}));
 const inner=new THREE.Mesh(new THREE.CylinderGeometry(1.8,1.8,0.4,48), new THREE.MeshStandardMaterial({color:0x0c0e12, metalness:.5, roughness:.35}));
 inner.rotation.x=Math.PI/2; inner.position.z=-0.2;
 holder.add(outer); holder.add(inner);
 scene.add(holder);
 // tick shader
 (function tick(){ if(!composer) return; mat.uniforms.uTime.value=clock.getElapsedTime(); requestAnimationFrame(tick); })();
 // Invisible pick proxy (disc matching radar)
 const proxy=new THREE.Mesh(new THREE.CircleGeometry(2.2, 32), new THREE.MeshBasicMaterial({visible:false}));
 proxy.userData.isPickProxy=true; proxy.layers.set(2); holder.add(proxy); holder.userData.pickProxy = proxy;
 return {holder, mesh, mat};
}

/* =========================
 Voxel world (instanced) & floaters
 ========================= */
function buildVoxelWall(){
 const size=.8, W=80, H=50, D=2, geo=new THREE.BoxGeometry(size,size,size);
 const mat=new THREE.MeshStandardMaterial({color:0x1a1a22, roughness:.9, metalness:.1});
 const max=3800, inst=new THREE.InstancedMesh(geo,mat,max); scene.add(inst);
 const dummy=new THREE.Object3D(); let n=0;
 const positions = [];
 for(let x=-W/2;x<W/2 && n<max;x+=size){
 for(let y=-H/2;y<H/2 && n<max;y+=size){
 const d=Math.sqrt((x/(W/2))**2+(y/(H/2))**2);
 if(d>0.7 && Math.random()<(d-0.7)*3) continue; if(Math.random()<0.06) continue;
 const basePos = {x: x+(Math.random()-.5)*.2, y: y+(Math.random()-.5)*.2, z: -15+Math.random()*D};
 positions.push(basePos);
 dummy.position.set(basePos.x, basePos.y, basePos.z);
 dummy.updateMatrix(); inst.setMatrixAt(n++, dummy.matrix);
 }
 } inst.count=n; inst.instanceMatrix.needsUpdate=true;
 return {inst, positions, dummy, size};
}
function buildVoxelFloor(){
 const size=.9, W=80, F=80, geo=new THREE.BoxGeometry(size,size,size);
 const mat=new THREE.MeshStandardMaterial({color:0x0d0d15, roughness:.85, metalness:.15});
 const max=4200, inst=new THREE.InstancedMesh(geo,mat,max); inst.receiveShadow=true; scene.add(inst);
 const dummy=new THREE.Object3D(); let n=0;
 const positions = [];
 for(let x=-W/2;x<W/2 && n<max;x+=size){
 for(let z=-F/2;z<F/2 && n<max;z+=size){
 const d=Math.sqrt((x/(W/2))**2+(z/(F/2))**2);
 if(d>0.75 && Math.random()<(d-0.75)*2.2) continue; if(Math.random()<0.05) continue;
 const basePos = {x: x+(Math.random()-.5)*.15, y: -15.2+(Math.random()-.5)*.2, z: z+(Math.random()-.5)*.15};
 positions.push(basePos);
 dummy.position.set(basePos.x, basePos.y, basePos.z);
 dummy.updateMatrix(); inst.setMatrixAt(n++, dummy.matrix);
 }
 } inst.count=n; inst.instanceMatrix.needsUpdate=true;
 return {inst, positions, dummy, size};
}
function createFloatingVoxels(){
 const voxelGeo=new THREE.BoxGeometry(.6,.6,.6);
 const baseMat=new THREE.MeshStandardMaterial({color:0x2a2a35, emissive:0x111219, emissiveIntensity:.45, roughness:.82, metalness:.2});
 const spriteMat0=makeDigitSprite('0'), spriteMat1=makeDigitSprite('1');
 for(let i=0;i<14;i++){
 const mesh=new THREE.Mesh(voxelGeo, baseMat.clone());
 const ang=Math.random()*Math.PI*2, r=24+Math.random()*14;
 mesh.position.set(Math.cos(ang)*r,(Math.random()-.5)*28,-8-Math.random()*8); scene.add(mesh);
 const spr=new THREE.Sprite(Math.random()>.5?spriteMat0:spriteMat1);
 spr.scale.set(1.2,1.6,1); spr.position.copy(mesh.position); spr.visible=false;
 spr.material.color = new THREE.Color(0xffffff);
 spr.material.opacity = 0.95;
 spr.material.blending = THREE.AdditiveBlending;
 scene.add(spr);
 voxelParticles.push({voxel:mesh, sprite:spr, velocity:new THREE.Vector3((Math.random()-.5)*.02,(Math.random()-.5)*.015,(Math.random()-.5)*.01), rotVel:new THREE.Vector3((Math.random()-.5)*.03,(Math.random()-.5)*.03,(Math.random()-.5)*.03), glitchTimer:Math.random()*5, isGlitched:false, fade:1.0});
 }
}
function makeDigitSprite(d){
 const c=document.createElement('canvas'); c.width=64; c.height=64; const g=c.getContext('2d');
 g.fillStyle='rgba(0,0,0,0)'; g.fillRect(0,0,64,64); g.font='bold 48px monospace'; g.fillStyle='#ffffff'; g.textAlign='center'; g.textBaseline='middle'; g.fillText(d,32,32);
 const t=new THREE.CanvasTexture(c); return new THREE.SpriteMaterial({map:t, transparent:true});
}

/* =========================
 Cables (braids + long runs)
 ========================= */
function createCableCurve(s,e,w=1.6){
 const c1=new THREE.Vector3().lerpVectors(s,e,.33).add(new THREE.Vector3((Math.random()-.5)*w,(Math.random()-.5)*w,-2));
 const c2=new THREE.Vector3().lerpVectors(s,e,.66).add(new THREE.Vector3((Math.random()-.5)*w,(Math.random()-.5)*w, 2));
 return new THREE.CubicBezierCurve3(s,c1,c2,e);
}
function addCable(curve, r=.09){
 const tube=new THREE.TubeGeometry(curve,64,r,6,false);
 const mesh=new THREE.Mesh(tube,cableMaterial); mesh.castShadow=true; mesh.userData.isCable=true; scene.add(mesh);
}
function createCableClusters(dev){
 const p=dev.group.position.clone();
 const clusters=3+Math.floor(Math.random()*2);
 for(let i=0;i<clusters;i++){
 const anchor=p.clone().add(new THREE.Vector3((Math.random()-.5)*dev.config.w*.6,(Math.random()-.5)*dev.config.h*.6,-1.4));
 const toFloor=Math.random()>.4;
 const end=new THREE.Vector3(anchor.x+(Math.random()-.5)*10, toFloor?-16: (p.y+(Math.random()-.5)*8), toFloor? (p.z-2+(Math.random()-.5)*6): -15);
 const count=8+Math.floor(Math.random()*5);
 for(let k=0;k<count;k++){
 const s=anchor.clone().add(new THREE.Vector3((Math.random()-.5)*.6,(Math.random()-.5)*.6,0));
 const e=end.clone().add(new THREE.Vector3((Math.random()-.5)*.8,(Math.random()-.5)*.8,0));
 addCable(createCableCurve(s,e,1.8), .085);
 }
 }
}
function createLongHorizontalCables(count=6){
 const baseZ=-13.5;
 for(let i=0;i<count;i++){
 const topY=6+Math.random()*7;
 const bottomY=-12-Math.random()*5;
 const startX=(Math.random()<0.5?-1:1)*(8+Math.random()*10);
 let endX=startX + (Math.random()<0.5?-1:1)*(14+Math.random()*8);
 if(Math.abs(endX-startX)<12) endX+=Math.sign(endX-startX||1)*12;
 const spread=4+Math.random()*6;
 const s=new THREE.Vector3(startX-spread*0.5, topY, baseZ-Math.random()*1.2);
 const e=new THREE.Vector3(endX+spread*0.5, bottomY, baseZ-0.5-Math.random()*1.5);
 const curve=createCableCurve(s,e,3.2);
 addCable(curve, .09);
 }
}

function refreshOrientationTargets(portrait){
 orientationWatcher.portrait = portrait;
 orientationWatcher.targets.clear();
 Object.values(devices).forEach(dev=>{
 if(!dev || !dev.group) return;
 if(!dev.basePosition){
 dev.basePosition = dev.group.position.clone();
 }
 let targetPosition = dev.basePosition.clone();
 if(portrait){
 const layout = dev.config && PORTRAIT_TARGETS[dev.config.name];
 if(layout){
 targetPosition = new THREE.Vector3(layout.x, layout.y, dev.basePosition.z);
 } else {
 targetPosition.x *= 0.6;
 targetPosition.y *= 0.6;
 }
 }
 orientationWatcher.targets.set(dev.group, {
 rotation: portrait ? Math.PI/2 : 0,
 position: targetPosition
 });
 });
}

function easeOutCubic(t){ return 1-Math.pow(1-t,3); }
function easeOutQuad(t){ return 1-Math.pow(1-t,2); }
function lerp(a,b,t){ return a+(b-a)*t; }
function tween(duration, update, done, delay=0, easing=(v)=>v){
 const start = performance.now() + delay;
 function frame(now){
 if(now<start){ requestAnimationFrame(frame); return; }
 const t = Math.min(1, (now-start)/duration);
 update(easing(t));
 if(t<1){ requestAnimationFrame(frame); }
 else if(typeof done==='function'){ done(); }
 }
 requestAnimationFrame(frame);
}
function morphPolygon(poly, fromPts, toPts, duration, delay=0, easing=easeOutCubic){
 tween(duration, (p)=>{
 const pts=fromPts.map((from,i)=>{
 const to=toPts[i];
 return `${lerp(from[0],to[0],p)},${lerp(from[1],to[1],p)}`;
 }).join(' ');
 poly.setAttribute('points', pts);
 }, null, delay, easing);
}

function setupOrientationWatcher(){
 const mq = window.matchMedia('(orientation: portrait)');
 const handler = ()=>{
 const portrait = mq.matches && innerWidth <= 900;
 refreshOrientationTargets(portrait);
 };
 orientationWatcher.media = mq;
 if(mq.addEventListener) mq.addEventListener('change', handler); else mq.addListener(handler);
 handler();
}

/* =========================
 Post
 ========================= */
function applyDofParams(){
 if(!bokehPass || !bokehPass.materialBokeh) return;
 const uniforms=bokehPass.materialBokeh.uniforms;
 if(uniforms.focus) uniforms.focus.value=DOF_PARAMS.focusDistance;
 if(uniforms.focalLength) uniforms.focalLength.value=DOF_PARAMS.focusLength;
 if(uniforms.maxblur) uniforms.maxblur.value=DOF_PARAMS.blur;
 if(uniforms.aperture) uniforms.aperture.value=THREE.MathUtils.clamp(DOF_PARAMS.blur*1.8,0.00008,0.0012);
}

function setupPost(){
 composer=new window.EffectComposer(renderer);
 renderPass=new window.RenderPass(scene,camera); composer.addPass(renderPass);
 bloomPass=new window.UnrealBloomPass(new THREE.Vector2(innerWidth,innerHeight), .42,.42,.45); composer.addPass(bloomPass);
 bloomPass.enabled = settings.bloom;
 bokehPass=new window.BokehPass(scene,camera,{focus:DOF_PARAMS.focusDistance,aperture:THREE.MathUtils.clamp(DOF_PARAMS.blur*1.8,0.00008,0.0012),maxblur:DOF_PARAMS.blur}); composer.addPass(bokehPass);
 bokehPass.enabled = settings.dof;
 applyDofParams();
 const grainShader={uniforms:{tDiffuse:{value:null},uTime:{value:0},uGrainAmount:{value:.045},uScanlineIntensity:{value:.025},uVignetteAmount:{value:.27},uChromaticAberration:{value:.0012}},vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`,fragmentShader:`uniform sampler2D tDiffuse;uniform float uTime,uGrainAmount,uScanlineIntensity,uVignetteAmount,uChromaticAberration;varying vec2 vUv;float h(vec2 p){return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);}void main(){vec2 uv=vUv;float a=uChromaticAberration*length(uv-.5);vec2 d=normalize(uv-.5);vec3 c; c.r=texture2D(tDiffuse,uv+d*a).r; c.g=texture2D(tDiffuse,uv).g; c.b=texture2D(tDiffuse,uv-d*a).b; float g=h(uv*900.0+uTime*60.0)-.5; c+=g*uGrainAmount; float s=sin(uv.y*720.0+uTime*5.0)*uScanlineIntensity; c+=s; float dist=length(uv-.5); float v=smoothstep(.78,.33,dist); c*=mix(1.0-uVignetteAmount,1.0,v); gl_FragColor=vec4(c,1.0);}`};
 grainPass=new window.ShaderPass(grainShader); grainPass.renderToScreen=true; composer.addPass(grainPass);
}

function initSoundscape(){
 if(soundscape && soundscape.ctx.state==='suspended'){ soundscape.ctx.resume(); return; }
 if(soundscape) return;
 const AudioCtx = window.AudioContext || window.webkitAudioContext;
 if(!AudioCtx) return;
 const ctx=new AudioCtx();
 audioCtx = ctx; // expose globally for thud
 const master=ctx.createGain(); master.gain.value=0.2;
 const compressor=ctx.createDynamicsCompressor();
 compressor.threshold.value=-22; compressor.knee.value=28; compressor.ratio.value=3.1;
 master.connect(compressor); compressor.connect(ctx.destination);

 const ambienceDelay=ctx.createDelay(6.5); ambienceDelay.delayTime.value=2.2;
 const ambienceFeedback=ctx.createGain(); ambienceFeedback.gain.value=0.38;
 const ambienceFilter=ctx.createBiquadFilter(); ambienceFilter.type='lowpass'; ambienceFilter.frequency.value=1400;
 ambienceDelay.connect(ambienceFeedback); ambienceFeedback.connect(ambienceFilter); ambienceFilter.connect(ambienceDelay);
 ambienceDelay.connect(master);

 const padFilter=ctx.createBiquadFilter(); padFilter.type='lowpass'; padFilter.frequency.value=480; padFilter.Q.value=1.0;
 const padGain=ctx.createGain(); padGain.gain.value=0.0; padFilter.connect(padGain); padGain.connect(master); padGain.connect(ambienceDelay);

 const bassFilter=ctx.createBiquadFilter(); bassFilter.type='lowpass'; bassFilter.frequency.value=260; bassFilter.Q.value=0.9;
 const bassGain=ctx.createGain(); bassGain.gain.value=0.0; bassFilter.connect(bassGain); bassGain.connect(master); bassGain.connect(ambienceDelay);

 const leadFilter=ctx.createBiquadFilter(); leadFilter.type='bandpass'; leadFilter.frequency.value=1380; leadFilter.Q.value=1.05;
 const leadGain=ctx.createGain(); leadGain.gain.value=0.0; leadFilter.connect(leadGain); leadGain.connect(master); leadGain.connect(ambienceDelay);

 const leadReverbSend=ctx.createGain(); leadReverbSend.gain.value=0.65;
 const leadReverb=ctx.createDelay(2.5); leadReverb.delayTime.value=0.32;
 const leadReverbFeedback=ctx.createGain(); leadReverbFeedback.gain.value=0.5;
 const leadReverbFilter=ctx.createBiquadFilter(); leadReverbFilter.type='lowpass'; leadReverbFilter.frequency.value=1900; leadReverbFilter.Q.value=0.6;
 const leadReverbMix=ctx.createGain(); leadReverbMix.gain.value=0.45;
 leadGain.connect(leadReverbSend);
 leadReverbSend.connect(leadReverb);
 leadReverb.connect(leadReverbFeedback);
 leadReverbFeedback.connect(leadReverb);
 leadReverb.connect(leadReverbFilter);
 leadReverbFilter.connect(leadReverbMix);
 leadReverbMix.connect(master);
 leadReverbMix.connect(ambienceDelay);

 const leadChorusSend=ctx.createGain(); leadChorusSend.gain.value=0.42;
 const chorusDelay=ctx.createDelay(0.08); chorusDelay.delayTime.value=0.024;
 const chorusFeedback=ctx.createGain(); chorusFeedback.gain.value=0.22;
 const chorusMix=ctx.createGain(); chorusMix.gain.value=0.5;
 leadGain.connect(leadChorusSend);
 leadChorusSend.connect(chorusDelay);
 chorusDelay.connect(chorusFeedback);
 chorusFeedback.connect(chorusDelay);
 chorusDelay.connect(chorusMix);
 chorusMix.connect(master);
 chorusMix.connect(ambienceDelay);

 const chorusLfo=ctx.createOscillator(); chorusLfo.type='sine'; chorusLfo.frequency.value=0.65;
 const chorusLfoGain=ctx.createGain(); chorusLfoGain.gain.value=0.006;
 chorusLfo.connect(chorusLfoGain); chorusLfoGain.connect(chorusDelay.delayTime); chorusLfo.start();

 const percussionBus=ctx.createGain(); percussionBus.gain.value=0.32; percussionBus.connect(master);
 const percussionSpace=ctx.createGain(); percussionSpace.gain.value=0.22; percussionBus.connect(percussionSpace); percussionSpace.connect(ambienceDelay);

 const chimeFilter=ctx.createBiquadFilter(); chimeFilter.type='bandpass'; chimeFilter.frequency.value=2400; chimeFilter.Q.value=5.5;
 const chimeGain=ctx.createGain(); chimeGain.gain.value=0.0; chimeFilter.connect(chimeGain); chimeGain.connect(master); chimeGain.connect(ambienceDelay);

 const choirFilter=ctx.createBiquadFilter(); choirFilter.type='lowpass'; choirFilter.frequency.value=1100; choirFilter.Q.value=0.8;
 const choirGain=ctx.createGain(); choirGain.gain.value=0.0; choirFilter.connect(choirGain); choirGain.connect(master); choirGain.connect(ambienceDelay);

 const padOscillators=Array.from({length:4}, (_,i)=>{
 const osc=ctx.createOscillator(); osc.type='sine';
 const seed=[174.61,220.0,261.63,392.0];
 osc.frequency.setValueAtTime(seed[i], ctx.currentTime);
 osc.connect(padFilter);
 osc.start();
 return osc;
 });

 const padLfo=ctx.createOscillator(); padLfo.type='sine'; padLfo.frequency.value=0.03;
 const padLfoGain=ctx.createGain(); padLfoGain.gain.value=140;
 padLfo.connect(padLfoGain); padLfoGain.connect(padFilter.frequency); padLfo.start();

 const melodyVibrato=ctx.createOscillator(); melodyVibrato.type='sine'; melodyVibrato.frequency.value=5.3;
 const vibratoBus=ctx.createGain(); vibratoBus.gain.value=7;
 melodyVibrato.connect(vibratoBus); melodyVibrato.start();

 const noiseBuffer=ctx.createBuffer(1, Math.floor(ctx.sampleRate*0.35), ctx.sampleRate);
 const noiseData=noiseBuffer.getChannelData(0);
 for(let i=0;i<noiseData.length;i++){
 const fade=1-(i/noiseData.length);
 noiseData[i]=(Math.random()*2-1)*fade*fade;
 }

 const NOTES={
 'C2':65.41,'D2':73.42,'E2':82.41,'F2':87.31,'G2':98.0,'A2':110.0,'Bb2':116.54,
 'C3':130.81,'D3':146.83,'E3':164.81,'F3':174.61,'G3':196.0,'A3':220.0,'Bb3':233.08,'B3':246.94,
 'C4':261.63,'D4':293.66,'E4':329.63,'F4':349.23,'G4':392.0,'A4':440.0,'Bb4':466.16,'B4':493.88,
 'C5':523.25,'D5':587.33,'E5':659.25,'F5':698.46,'G5':783.99
 };
 function freq(note){ return NOTES[note]||NOTES['C4']; }

 const tempo=96;
 const beat=60/tempo;
 const barDuration=beat*4;

 const hatSparse=[0,1,2,3];
 const hatMedium=[0,0.5,1,1.5,2,2.5,3];
 const hatBusy=[0,0.5,1,1.5,2,2.5,3,3.5];

 const introBars=[
 {section:'intro', chord:['F3','A3','C4','G4'], padFreq:520, padLevel:0.2, bass:[{note:'F2', time:0, len:4, accent:0.72}], melody:[{note:'C5', time:0, len:2, accent:0.3},{note:'A4', time:2, len:2, accent:0.26}], chimes:[{note:'C6', time:1.1, len:0.6, accent:0.42}], chorus:[{note:'F4', time:0, len:4, accent:0.24}], kicks:[0], snares:[2], hats:[...hatMedium], hatAccent:0.12},
 {section:'intro', chord:['C3','E3','G3','C4'], padFreq:500, padLevel:0.19, bass:[{note:'C2', time:0, len:4, accent:0.65}], melody:[{note:'G4', time:0.25, len:1.5, accent:0.26},{note:'E4', time:2.5, len:1.3, accent:0.23}], chimes:[{note:'E6', time:2.4, len:0.6, accent:0.38}], chorus:[{note:'C4', time:0, len:4, accent:0.22}], kicks:[0], snares:[2], hats:[...hatSparse], hatAccent:0.1},
 {section:'intro', chord:['D3','F3','A3','C4'], padFreq:510, padLevel:0.21, bass:[{note:'D2', time:0, len:4, accent:0.66}], melody:[{note:'A4', time:0.5, len:1.4, accent:0.26},{note:'F4', time:2.2, len:1.3, accent:0.24}], chimes:[{note:'A5', time:0.8, len:0.6, accent:0.4}], chorus:[{note:'D4', time:0, len:4, accent:0.24}], kicks:[0], snares:[2], hats:[...hatMedium], hatAccent:0.12},
 {section:'intro', chord:['Bb2','F3','A3','D4'], padFreq:540, padLevel:0.22, bass:[{note:'Bb2', time:0, len:4, accent:0.7}], melody:[{note:'D5', time:0.75, len:1.3, accent:0.34},{note:'A4', time:2.4, len:1.2, accent:0.25}], chimes:[{note:'D6', time:1.6, len:0.5, accent:0.44}], chorus:[{note:'Bb3', time:0, len:4, accent:0.26}], kicks:[0], snares:[2.5], hats:[...hatMedium], hatAccent:0.13}
 ];

 const verseBars=[
 {section:'verse', chord:['F3','A3','C4','E4'], padFreq:560, padLevel:0.25, bass:[{note:'F2', time:0, len:2.5, accent:0.7},{note:'C3', time:2.5, len:1.5, accent:0.58}], melody:[{note:'C5', time:0, len:0.75, accent:0.33},{note:'E5', time:1, len:1.2, accent:0.35},{note:'A4', time:2.5, len:1.1, accent:0.28}], chimes:[{note:'G5', time:1.5, len:0.5, accent:0.36}], chorus:[{note:'F4', time:0, len:4, accent:0.2}], kicks:[0,2.5], snares:[1.5], hats:[...hatBusy], hatAccent:0.16},
 {section:'verse', chord:['C3','E3','G3','B3'], padFreq:570, padLevel:0.26, bass:[{note:'C2', time:0, len:2, accent:0.64},{note:'G2', time:2, len:2, accent:0.6}], melody:[{note:'G4', time:0.5, len:1.1, accent:0.3},{note:'D5', time:2.25, len:1.3, accent:0.31}], chimes:[{note:'B5', time:2.2, len:0.5, accent:0.34}], chorus:[{note:'C4', time:0, len:4, accent:0.18}], kicks:[0,2.75], snares:[1.5], hats:[...hatBusy], hatAccent:0.17},
 {section:'verse', chord:['D3','F3','A3','C4'], padFreq:580, padLevel:0.27, bass:[{note:'D2', time:0, len:2, accent:0.66},{note:'A2', time:2, len:2, accent:0.62}], melody:[{note:'F4', time:0.5, len:1.0, accent:0.29},{note:'C5', time:1.6, len:1.1, accent:0.29},{note:'D5', time:2.9, len:0.9, accent:0.3}], chimes:[{note:'D6', time:2.8, len:0.5, accent:0.32}], chorus:[{note:'D4', time:0, len:4, accent:0.2}], kicks:[0,2.5], snares:[1.5], hats:[...hatBusy], hatAccent:0.17},
 {section:'verse', chord:['Bb2','D3','F3','G3'], padFreq:590, padLevel:0.28, bass:[{note:'Bb2', time:0, len:4, accent:0.72}], melody:[{note:'G4', time:0.75, len:1.0, accent:0.3},{note:'F4', time:2.0, len:1.2, accent:0.28},{note:'D5', time:3.1, len:0.8, accent:0.32}], chimes:[{note:'F6', time:3.0, len:0.5, accent:0.35}], chorus:[{note:'Bb3', time:0, len:4, accent:0.22}], kicks:[0,3], snares:[1.5], hats:[...hatBusy], hatAccent:0.18}
 ];

 const chorusBars=[
 {section:'chorus', chord:['Bb2','F3','A3','D4'], padFreq:610, padLevel:0.32, bass:[{note:'Bb2', time:0, len:4, accent:0.76}], melody:[{note:'F5', time:0, len:0.8, accent:0.42},{note:'D5', time:0.8, len:0.8, accent:0.38},{note:'C5', time:1.6, len:0.8, accent:0.35},{note:'A4', time:2.4, len:0.8, accent:0.32},{note:'G4', time:3.2, len:0.8, accent:0.3}], chimes:[{note:'Bb6', time:0.6, len:0.5, accent:0.4},{note:'F6', time:2.6, len:0.5, accent:0.38}], chorus:[{note:'D4', time:0, len:4, accent:0.26}], kicks:[0,1.5,2.5,3.5], snares:[1,3], hats:[...hatBusy], hatAccent:0.2},
 {section:'chorus', chord:['C3','G3','Bb3','E4'], padFreq:630, padLevel:0.33, bass:[{note:'C3', time:0, len:4, accent:0.75}], melody:[{note:'G4', time:0, len:0.9, accent:0.35},{note:'E5', time:0.9, len:1.0, accent:0.38},{note:'Bb4', time:2.1, len:1.0, accent:0.36}], chimes:[{note:'E6', time:1.0, len:0.5, accent:0.39},{note:'C6', time:3.0, len:0.5, accent:0.37}], chorus:[{note:'C4', time:0, len:4, accent:0.24}], kicks:[0,1.5,2.75,3.5], snares:[1,3], hats:[...hatBusy], hatAccent:0.21},
 {section:'chorus', chord:['D3','A3','C4','F4'], padFreq:620, padLevel:0.34, bass:[{note:'D3', time:0, len:4, accent:0.73}], melody:[{note:'A4', time:0, len:0.8, accent:0.33},{note:'F5', time:0.8, len:0.9, accent:0.39},{note:'D5', time:1.8, len:1.1, accent:0.37},{note:'C5', time:3.0, len:0.8, accent:0.34}], chimes:[{note:'A6', time:0.9, len:0.5, accent:0.38},{note:'D6', time:2.4, len:0.5, accent:0.36}], chorus:[{note:'F4', time:0, len:4, accent:0.24}], kicks:[0,1.5,2.5,3.25], snares:[1,3], hats:[...hatBusy], hatAccent:0.21},
 {section:'chorus', chord:['F3','A3','C4','E4'], padFreq:600, padLevel:0.3, bass:[{note:'F2', time:0, len:2, accent:0.72},{note:'C3', time:2, len:2, accent:0.7}], melody:[{note:'E5', time:0.2, len:0.9, accent:0.38},{note:'C5', time:1.2, len:0.9, accent:0.34},{note:'A4', time:2.2, len:0.9, accent:0.32},{note:'G4', time:3.2, len:0.8, accent:0.3}], chimes:[{note:'C6', time:1.1, len:0.5, accent:0.37},{note:'E6', time:3.1, len:0.5, accent:0.35}], chorus:[{note:'F4', time:0, len:4, accent:0.22}], kicks:[0,1.75,2.75,3.5], snares:[1,3], hats:[...hatBusy], hatAccent:0.2}
 ];

 const arrangement=[...introBars, ...verseBars, ...chorusBars];

 const stopHandles=[];
 stopHandles.push(()=>{ try{ padLfo.stop(); }catch(e){} });
 stopHandles.push(()=>{ try{ melodyVibrato.stop(); }catch(e){} });
 stopHandles.push(()=>{ try{ chorusLfo.stop(); }catch(e){} });

 padGain.gain.linearRampToValueAtTime(0.16, ctx.currentTime+6.0);
 bassGain.gain.linearRampToValueAtTime(0.28, ctx.currentTime+10.0);
 leadGain.gain.linearRampToValueAtTime(0.24, ctx.currentTime+12.0);
 chimeGain.gain.linearRampToValueAtTime(0.18, ctx.currentTime+14.0);
 choirGain.gain.linearRampToValueAtTime(0.12, ctx.currentTime+18.0);

 function retunePad(bar, startTime){
 const notes=bar.chord.map(freq);
 padOscillators.forEach((osc,i)=>{
 const target=notes[i%notes.length];
 osc.frequency.cancelScheduledValues(startTime);
 osc.frequency.linearRampToValueAtTime(target, startTime+beat*1.5);
 });
 padFilter.frequency.cancelScheduledValues(startTime);
 padFilter.frequency.linearRampToValueAtTime(bar.padFreq||520, startTime+beat*2.0);
 padGain.gain.cancelScheduledValues(startTime);
 padGain.gain.setTargetAtTime(bar.padLevel||0.2, startTime, 1.1);
 }

 function triggerBass(noteName, startTime, length, accent=0.6){
 const osc=ctx.createOscillator(); osc.type='sawtooth';
 const gain=ctx.createGain(); gain.gain.setValueAtTime(0.0001,startTime);
 const f=freq(noteName);
 osc.frequency.setValueAtTime(f,startTime);
 osc.frequency.exponentialRampToValueAtTime(f*0.97, startTime+Math.min(length,0.6));
 gain.gain.linearRampToValueAtTime(accent,startTime+0.04);
 gain.gain.exponentialRampToValueAtTime(0.0001,startTime+Math.max(0.45,length));
 osc.connect(gain); gain.connect(bassFilter);
 osc.start(startTime); osc.stop(startTime+length+0.6);
 osc.onended=()=>gain.disconnect();
 }

 function triggerLead(noteName, startTime, length, accent=0.26){
 const osc=ctx.createOscillator(); osc.type='triangle';
 const gain=ctx.createGain(); gain.gain.setValueAtTime(0.0001,startTime);
 const f=freq(noteName);
 osc.frequency.setValueAtTime(f,startTime);
 const vib=ctx.createGain(); vib.gain.value=1;
 vibratoBus.connect(vib); vib.connect(osc.detune);
 gain.gain.linearRampToValueAtTime(accent,startTime+0.08);
 gain.gain.linearRampToValueAtTime(accent*0.82,startTime+Math.max(0.2,length-0.2));
 gain.gain.exponentialRampToValueAtTime(0.0001,startTime+length+0.4);
 osc.connect(gain); gain.connect(leadFilter);
 osc.start(startTime); osc.stop(startTime+length+0.6);
 osc.onended=()=>{ gain.disconnect(); try{ vibratoBus.disconnect(vib); }catch(e){} vib.disconnect(); };
 }

 function triggerChime(noteName, startTime, length, accent=0.35){
 const f=freq(noteName);
 const osc=ctx.createOscillator(); osc.type='triangle';
 const gain=ctx.createGain(); gain.gain.setValueAtTime(0.0001,startTime);
 osc.frequency.setValueAtTime(f,startTime);
 const overtone=ctx.createOscillator(); overtone.type='sine';
 const overtoneGain=ctx.createGain(); overtoneGain.gain.setValueAtTime(0.0001,startTime);
 overtone.frequency.setValueAtTime(f*2,startTime);
 const sparkle=ctx.createOscillator(); sparkle.type='square';
 const sparkleGain=ctx.createGain(); sparkleGain.gain.setValueAtTime(0.0001,startTime);
 sparkle.frequency.setValueAtTime(f*3,startTime);
 gain.gain.linearRampToValueAtTime(accent,startTime+0.05);
 gain.gain.exponentialRampToValueAtTime(0.0001,startTime+length+0.9);
 overtoneGain.gain.linearRampToValueAtTime(accent*0.28,startTime+0.08);
 overtoneGain.gain.exponentialRampToValueAtTime(0.0001,startTime+length+1.0);
 sparkleGain.gain.linearRampToValueAtTime(accent*0.12,startTime+0.06);
 sparkleGain.gain.exponentialRampToValueAtTime(0.0001,startTime+length+0.6);
 osc.connect(gain); gain.connect(chimeFilter);
 overtone.connect(overtoneGain); overtoneGain.connect(chimeFilter);
 sparkle.connect(sparkleGain); sparkleGain.connect(chimeFilter);
 osc.start(startTime); osc.stop(startTime+length+1.0);
 overtone.start(startTime); overtone.stop(startTime+length+1.1);
 sparkle.start(startTime); sparkle.stop(startTime+length+0.8);
 let cleaned=false;
 const cleanup=()=>{
 if(cleaned) return;
 cleaned=true;
 gain.disconnect();
 overtoneGain.disconnect();
 sparkleGain.disconnect();
 };
 osc.onended=cleanup; overtone.onended=cleanup; sparkle.onended=cleanup;
 }

 function triggerChoir(noteName, startTime, length, accent=0.2){
 const f=freq(noteName);
 const detunes=[-6,0,7];
 detunes.forEach((detune,idx)=>{
 const osc=ctx.createOscillator(); osc.type='triangle';
 const voiceGain=ctx.createGain(); voiceGain.gain.setValueAtTime(0.0001,startTime);
 osc.frequency.setValueAtTime(f,startTime);
 osc.detune.value=detune;
 voiceGain.gain.linearRampToValueAtTime(accent*(idx===1?0.85:0.55), startTime+0.2);
 voiceGain.gain.linearRampToValueAtTime(accent*0.35, startTime+Math.max(0.5,length-0.4));
 voiceGain.gain.exponentialRampToValueAtTime(0.0001, startTime+length+1.4);
 osc.connect(voiceGain); voiceGain.connect(choirFilter);
 osc.start(startTime); osc.stop(startTime+length+1.6);
 osc.onended=()=>voiceGain.disconnect();
 });
 }

 function triggerKick(time, strength=1.0){
 const osc=ctx.createOscillator(); osc.type='sine';
 const gain=ctx.createGain(); gain.gain.setValueAtTime(0.0001,time);
 osc.frequency.setValueAtTime(68,time);
 osc.frequency.exponentialRampToValueAtTime(34,time+0.28);
 gain.gain.linearRampToValueAtTime(0.85*strength,time+0.02);
 gain.gain.exponentialRampToValueAtTime(0.0001,time+0.6);
 osc.connect(gain); gain.connect(percussionBus);
 osc.start(time); osc.stop(time+0.6);
 osc.onended=()=>gain.disconnect();
 }

 function triggerSnare(time){
 const noise=ctx.createBufferSource(); noise.buffer=noiseBuffer;
 const filter=ctx.createBiquadFilter(); filter.type='bandpass'; filter.frequency.value=1900; filter.Q.value=1.0;
 const gain=ctx.createGain(); gain.gain.setValueAtTime(0.0001,time);
 noise.connect(filter); filter.connect(gain); gain.connect(percussionBus);
 gain.gain.linearRampToValueAtTime(0.38,time+0.02);
 gain.gain.exponentialRampToValueAtTime(0.0001,time+0.38);
 noise.start(time); noise.stop(time+0.4);
 noise.onended=()=>{ filter.disconnect(); gain.disconnect(); };
 const tone=ctx.createOscillator(); tone.type='triangle';
 tone.frequency.setValueAtTime(260,time);
 tone.frequency.linearRampToValueAtTime(196,time+0.25);
 const toneGain=ctx.createGain(); toneGain.gain.setValueAtTime(0.0001,time);
 toneGain.gain.linearRampToValueAtTime(0.2,time+0.03);
 toneGain.gain.exponentialRampToValueAtTime(0.0001,time+0.4);
 tone.connect(toneGain); toneGain.connect(percussionBus);
 tone.start(time); tone.stop(time+0.4);
 tone.onended=()=>toneGain.disconnect();
 }

 function triggerHat(time, accent=0.12){
 const src=ctx.createBufferSource(); src.buffer=noiseBuffer;
 const hp=ctx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=5500; hp.Q.value=0.6;
 const gain=ctx.createGain(); gain.gain.setValueAtTime(0.0001,time);
 src.connect(hp); hp.connect(gain); gain.connect(percussionBus);
 gain.gain.linearRampToValueAtTime(accent,time+0.01);
 gain.gain.exponentialRampToValueAtTime(0.0001,time+0.18);
 src.start(time); src.stop(time+0.2);
 src.onended=()=>{ hp.disconnect(); gain.disconnect(); };
 }

 function scheduleBar(bar, startTime){
 retunePad(bar, startTime);
 (bar.bass||[]).forEach(n=>triggerBass(n.note, startTime + (n.time||0)*beat, (n.len||4)*beat, n.accent||0.6));
 (bar.melody||[]).forEach(n=>triggerLead(n.note, startTime + (n.time||0)*beat, (n.len||1)*beat, n.accent||0.26));
 (bar.chimes||[]).forEach(n=>triggerChime(n.note, startTime + (n.time||0)*beat, (n.len||0.75)*beat, n.accent||0.35));
 (bar.chorus||[]).forEach(n=>triggerChoir(n.note, startTime + (n.time||0)*beat, (n.len||4)*beat, n.accent||0.22));
 (bar.kicks||[]).forEach((pos,idx)=>triggerKick(startTime + pos*beat, 1.0-(idx*0.05)));
 (bar.snares||[]).forEach(pos=>triggerSnare(startTime + pos*beat));
 (bar.hats||[]).forEach(pos=>triggerHat(startTime + pos*beat, bar.hatAccent||0.12));
 }

 let barIndex=0;
 let nextBarTime=ctx.currentTime+0.4;
 scheduleBar(arrangement[barIndex], nextBarTime);
 barIndex++;
 nextBarTime += barDuration;

 function queueNextBar(){
 const bar=arrangement[barIndex%arrangement.length];
 scheduleBar(bar, nextBarTime);
 barIndex++;
 nextBarTime += barDuration;
 const delay=Math.max(120, (nextBarTime - ctx.currentTime - beat*0.5)*1000);
 const handle=setTimeout(queueNextBar, delay);
 stopHandles.push(()=>clearTimeout(handle));
 }

 const initialDelay=Math.max(120, (nextBarTime - ctx.currentTime - beat*0.5)*1000);
 const initialHandle=setTimeout(queueNextBar, initialDelay);
 stopHandles.push(()=>clearTimeout(initialHandle));

 soundscape={
 ctx,
 master,
 sources:[...padOscillators, padLfo, melodyVibrato, chorusLfo],
 gains:{pad:padGain, bass:bassGain, lead:leadGain, percussion:percussionBus, chime:chimeGain, choir:choirGain},
 delay:ambienceDelay,
 intervals:stopHandles
 };

 document.addEventListener('visibilitychange',()=>{
 if(document.hidden){ ctx.suspend().catch(()=>{}); }
 else ctx.resume().catch(()=>{});
 });
}


/* =========================
 Crawl with bow animation finale
 ========================= */
function ensureCrawlTemplate(){
 const container=document.getElementById('crawl-container');
 if(!container) return null;
 if(!container.querySelector('#crawl')){
 container.innerHTML=CRAWL_TEMPLATE;
 }
 const header=container.querySelector('#crawl-header');
 const crawl=container.querySelector('#crawl');
 const cursor=container.querySelector('#crawl-cursor');
 return {container, header, crawl, cursor};
}

function resetCrawlContainerStyles(container){
 if(!container) return;
 container.style.pointerEvents='';
 container.style.width='';
 container.style.height='';
 container.style.borderRadius='';
 container.style.background='';
 container.style.boxShadow='';
 container.style.transform='';
 container.style.opacity='';
 container.style.transition='';
}

function prepareCrawlMorph(container, header, crawl){
 if(!container || !header || !crawl) return null;
 const containerRect=container.getBoundingClientRect();
 if(!containerRect.width || !containerRect.height) return null;
 const overlay=document.createElement('div');
 overlay.className='crawl-morph-overlay';
 overlay.style.cssText='position:absolute;inset:0;pointer-events:none;z-index:5;opacity:1;';

 const baseShadow='0 14px 34px rgba(0,0,0,0.35)';
 function placeBlock(block, rect){
 block.style.position='absolute';
 block.style.left=`${(rect.left-containerRect.left).toFixed(2)}px`;
 block.style.top=`${(rect.top-containerRect.top).toFixed(2)}px`;
 block.style.width=`${rect.width.toFixed(2)}px`;
 block.style.height=`${rect.height.toFixed(2)}px`;
 block.style.borderRadius='14px';
 block.style.boxShadow=baseShadow;
 }

 const headerBlock=document.createElement('div');
 headerBlock.className='morph-header-block';
 placeBlock(headerBlock, header.getBoundingClientRect());
 headerBlock.textContent='CELLI::TERMINAL //LOG';
 headerBlock.style.display='flex';
 headerBlock.style.alignItems='center';
 headerBlock.style.justifyContent='center';
 headerBlock.style.fontSize='13px';
 headerBlock.style.fontWeight='600';
 headerBlock.style.letterSpacing='1px';
 headerBlock.style.textShadow='0 1px 0 rgba(255,255,255,0.4)';
 headerBlock.style.background='linear-gradient(135deg, rgba(0,255,130,0.65) 0%, rgba(0,180,90,0.3) 100%)';
 headerBlock.style.color='#051f12';
 overlay.appendChild(headerBlock);

 const bodyBlock=document.createElement('div');
 bodyBlock.className='morph-body-block';
 placeBlock(bodyBlock, crawl.getBoundingClientRect());
 bodyBlock.style.display='flex';
 bodyBlock.style.flexDirection='column';
 bodyBlock.style.justifyContent='center';
 bodyBlock.style.padding='18px 20px';
 bodyBlock.style.background='rgba(6,6,6,0.9)';
 bodyBlock.style.border='1px solid rgba(0,255,130,0.2)';
 bodyBlock.style.backdropFilter='blur(6px)';
 bodyBlock.style.webkitBackdropFilter='blur(6px)';
 overlay.appendChild(bodyBlock);

 for(let i=0;i<6;i++){
 const line=document.createElement('div');
 line.className='morph-line';
 line.style.height='4px';
 line.style.borderRadius='2px';
 line.style.margin=`${3+(i%2?2:0)}px 0`;
 line.style.background=`rgba(0,255,130,${0.22+0.1*i})`;
 line.style.width=`${(68+Math.random()*24).toFixed(2)}%`;
 bodyBlock.appendChild(line);
 }

 const dot=header.querySelector('.close-dot');
 let dotOrigin=null;
 if(dot){
 const dotRect=dot.getBoundingClientRect();
 const centerX=dotRect.left+dotRect.width/2-containerRect.left;
 const centerY=dotRect.top+dotRect.height/2-containerRect.top;
 dotOrigin={
 fracX: containerRect.width? centerX/containerRect.width : 0.5,
 fracY: containerRect.height? centerY/containerRect.height : 0.5
 };
 }

 return {overlay, headerBlock, bodyBlock, dotOrigin};
}

function animateCrawlMorph(data, stage, skipMode){
 if(!data) return;
 const {overlay, headerBlock, bodyBlock}=data;
 if(!overlay || !headerBlock || !bodyBlock) return;
 const lines=Array.from(bodyBlock.querySelectorAll('.morph-line'));
 const targetWidth=240;
 const targetHeight=180;
 const stageWidth=168;
 const stageHeight=118;
 const stageLeft=(targetWidth-stageWidth)/2;
 const stageTop=(targetHeight-stageHeight)/2;
 const scaleX=stageWidth/200;
 const scaleY=stageHeight/140;
 const rectLeft=stageLeft+40*scaleX;
 const rectTop=stageTop+28*scaleY;
 const rectWidth=120*scaleX;
 const rectHeight=84*scaleY;
 const headerHeight=Math.max(22, rectTop-stageTop);
 const morphDuration=skipMode?0.42:0.88;
 const fadeDuration=skipMode?0.3:0.6;
 const stageFadeDelay=skipMode?220:460;
 const overlayFadeDelay=skipMode?360:760;

 headerBlock.style.willChange='left,top,width,height,background,border-radius,color';
 bodyBlock.style.willChange='left,top,width,height,background,border,border-radius,box-shadow';
 overlay.style.willChange='opacity';

 headerBlock.style.transition=`all ${morphDuration}s cubic-bezier(0.16,0.84,0.44,1)`;
 bodyBlock.style.transition=`all ${morphDuration}s cubic-bezier(0.16,0.84,0.44,1)`;
 lines.forEach((line)=>{ line.style.transition=`all ${morphDuration}s ease-out`; });

 requestAnimationFrame(()=>{
 headerBlock.style.left=`${rectLeft.toFixed(2)}px`;
 headerBlock.style.top=`${stageTop.toFixed(2)}px`;
 headerBlock.style.width=`${rectWidth.toFixed(2)}px`;
 headerBlock.style.height=`${headerHeight.toFixed(2)}px`;
 headerBlock.style.borderRadius='18px 18px 12px 12px';
 headerBlock.style.background='linear-gradient(135deg,#ffd24d 0%,#ffb740 100%)';
 headerBlock.style.color='#4a2d00';
 headerBlock.style.boxShadow='0 16px 32px rgba(255,188,90,0.35)';
 headerBlock.style.textShadow='0 1px 0 rgba(255,255,255,0.6)';

 bodyBlock.style.left=`${rectLeft.toFixed(2)}px`;
 bodyBlock.style.top=`${rectTop.toFixed(2)}px`;
 bodyBlock.style.width=`${rectWidth.toFixed(2)}px`;
 bodyBlock.style.height=`${rectHeight.toFixed(2)}px`;
 bodyBlock.style.borderRadius='22px';
 bodyBlock.style.background='radial-gradient(circle at 50% 42%, rgba(255,220,150,0.24) 0%, rgba(255,190,90,0.15) 55%, rgba(40,26,0,0.55) 100%)';
 bodyBlock.style.border='1.4px solid rgba(255,196,90,0.45)';
 bodyBlock.style.boxShadow='0 24px 48px rgba(255,190,90,0.28)';
 bodyBlock.style.padding='20px 24px';

 lines.forEach((line,i)=>{
 line.style.background=`rgba(255,205,110,${0.32+0.08*i})`;
 line.style.width=`${(82+i*3).toFixed(2)}%`;
 line.style.margin=`${(6+i).toFixed(0)}px 0`;
 line.style.transform='translateX(0)';
 line.style.opacity=`${0.45+0.08*i}`;
 });
 });

 if(stage){
 stage.style.opacity='0';
 stage.style.transform='scale(0.92)';
 setTimeout(()=>{
 stage.style.transition=`opacity ${fadeDuration}s ease, transform ${fadeDuration}s cubic-bezier(0.16,0.84,0.44,1)`;
 stage.style.opacity='1';
 stage.style.transform='scale(1)';
 }, stageFadeDelay);
 }

 setTimeout(()=>{
 overlay.style.transition=`opacity ${fadeDuration}s ease`;
 overlay.style.opacity='0';
 }, overlayFadeDelay);

 setTimeout(()=>{ overlay.remove(); }, overlayFadeDelay+fadeDuration*1000+80);
}

function collapseCrawlToCloseFrame(skipMode=false, existing){
 const parts=existing||ensureCrawlTemplate();
 if(!parts) return;
 const {container, header, crawl, cursor}=parts;
 resetCrawlContainerStyles(container);
 addCrawlCloseDot();
 const morphData=(header && crawl)?prepareCrawlMorph(container, header, crawl):null;
 if(morphData && morphData.dotOrigin){ lastCrawlDotOrigin=morphData.dotOrigin; }
 else { lastCrawlDotOrigin=null; }
 if(cursor){
 cursor.style.opacity='0';
 cursor.style.transition='';
 }
 if(skipMode && crawl && !crawl.textContent.trim()){
 crawl.textContent=DEFAULT_CRAWL_PREVIEW;
 crawl.scrollTop=crawl.scrollHeight;
 }
 if(crawl){ crawl.style.opacity='1'; crawl.style.transition=''; }
 if(header){ header.style.opacity='1'; header.style.transition=''; }
 container.style.display='block';
 container.style.transition='transform .8s ease,width .8s ease,height .8s ease,opacity .8s ease';
 if(crawl){ crawl.style.transition='opacity .4s ease'; crawl.style.opacity='0'; }
 if(header){ header.style.transition='opacity .4s ease'; header.style.opacity='0'; }
 setTimeout(()=>{
 container.style.pointerEvents='auto';
 container.style.width='240px';
 container.style.height='180px';
 container.style.borderRadius='16px';
 container.style.background='#111';
 container.style.boxShadow='0 10px 40px rgba(0,0,0,.5)';
 container.innerHTML=buildBowMarkup();
 const stage=container.querySelector('#bow-stage');
 if(morphData && morphData.overlay){
 container.appendChild(morphData.overlay);
 requestAnimationFrame(()=>{
 animateCrawlMorph(morphData, stage, skipMode);
 playBowSequence(container);
 });
 } else {
 playBowSequence(container);
 }
 }, skipMode?260:420);
}

// Add a black-hole style close dot to the crawl header (once)
function addCrawlCloseDot(){
 const header=document.getElementById('crawl-header');
 if(!header || header.querySelector('.close-dot')) return;
 header.style.position='relative';
 header.style.pointerEvents='auto';
 const dot=document.createElement('div');
 dot.className='close-dot';
 dot.style.cssText='position:absolute;right:14px;top:10px;width:14px;height:14px;border-radius:50%;background:radial-gradient(circle at 35% 35%, #000 0%, #000 60%, #111 100%);box-shadow:0 0 6px rgba(0,0,0,0.6);cursor:pointer;z-index:100;pointer-events:auto;';
 dot.title='Close';
 dot.addEventListener('click', (e)=>{
 e.stopPropagation();
 const container=document.getElementById('crawl-container');
 if(container){
 container.style.transition='opacity 0.3s ease, transform 0.3s ease';
 container.style.opacity='0';
 container.style.transform='translate(-50%,-50%) scale(0.85)';
 setTimeout(()=>{ container.style.display='none'; }, 300);
 }
 });
 header.appendChild(dot);
}

function updateCrawlCursorPosition(){
 const crawl=document.getElementById('crawl');
 const cursor=document.getElementById('crawl-cursor');
 if(!crawl || !cursor){ return; }
 const textNode=crawl.firstChild;
 const TEXT_NODE=(window.Node&&Node.TEXT_NODE)||3;
 if(!textNode || textNode.nodeType!==TEXT_NODE){
 cursor.style.opacity='0';
 return;
 }
 const range=document.createRange();
 try{
 const len=textNode.length;
 range.setStart(textNode, len);
 range.setEnd(textNode, len);
 }catch(e){ cursor.style.opacity='0'; return; }
 const parentRect=crawl.getBoundingClientRect();
 let rect=range.getClientRects()[0];
 if(!rect){
 const helper=document.createElement('span');
 helper.textContent='\u200a';
 helper.style.visibility='hidden';
 crawl.appendChild(helper);
 rect=helper.getBoundingClientRect();
 crawl.removeChild(helper);
 }
 if(!rect){ cursor.style.opacity='0'; return; }
 const offsetX=rect.left-parentRect.left;
 const offsetY=rect.top-parentRect.top;
 cursor.style.opacity='1';
 cursor.style.transform=`translate(${(offsetX+2).toFixed(2)}px, ${(offsetY-6).toFixed(2)}px)`;
}

function buildBowMarkup(){
 return `
 <div id="bow-stage" style="position:absolute;inset:0;display:grid;place-items:center;">
 <svg id="bow-svg" viewBox="0 0 200 140" width="168" height="118">
 <defs>
 <radialGradient id="bh" cx="50%" cy="50%" r="50%">
 <stop offset="0%" stop-color="#000" stop-opacity="1"/>
 <stop offset="70%" stop-color="#060606" stop-opacity="1"/>
 <stop offset="100%" stop-color="#111" stop-opacity="0"/>
 </radialGradient>
 <radialGradient id="coreGlow" cx="50%" cy="50%" r="50%">
 <stop offset="0%" stop-color="#ffefba" stop-opacity="0.95"/>
 <stop offset="45%" stop-color="#ffc866" stop-opacity="0.65"/>
 <stop offset="100%" stop-color="#ffb02e" stop-opacity="0"/>
 </radialGradient>
 <linearGradient id="envelopeGrad" x1="0%" x2="100%" y1="0%" y2="100%">
 <stop offset="0%" stop-color="#ffdf7a"/>
 <stop offset="55%" stop-color="#ffb740"/>
 <stop offset="100%" stop-color="#ff9c2f"/>
 </linearGradient>
 <radialGradient id="dotGlow" cx="50%" cy="50%" r="50%">
 <stop offset="0%" stop-color="rgba(255,210,120,0.65)"/>
 <stop offset="100%" stop-color="rgba(255,210,120,0)"/>
 </radialGradient>
 </defs>
 <circle id="pivotHalo" cx="180" cy="18" r="18" fill="url(#dotGlow)" opacity="0"/>
 <circle id="pivotDot" cx="180" cy="18" r="10" fill="url(#bh)" stroke="#1a1a1a" stroke-width="1.6" opacity="0"/>
 <circle id="closeHitbox" cx="180" cy="18" r="14" fill="transparent" style="cursor:pointer;" opacity="0"/>
 <rect id="sq" x="100" y="70" width="0" height="0" fill="none" stroke="#ffc44d" stroke-width="8" rx="12" ry="12" opacity="0"/>
 <polygon id="left" points="0,70 -40,38 -40,102" fill="url(#envelopeGrad)" opacity="0"/>
 <polygon id="right" points="200,70 240,38 240,102" fill="url(#envelopeGrad)" opacity="0"/>
 </svg>
 </div>`;
}
function startTextCrawl(forceFinal=false){
 const parts=ensureCrawlTemplate();
 if(!parts) return;
 const {container, crawl, header, cursor}=parts;
 if(!container || !crawl || !header) return;
 resetCrawlContainerStyles(container);
 container.style.display='block';
 crawl.style.opacity='1'; crawl.style.transition='';
 header.style.opacity='1'; header.style.transition='';
 if(cursor){
 cursor.style.opacity='0';
 cursor.style.transition='';
 cursor.style.transform='translate(0,0)';
 }
 if(!forceFinal){
 crawl.textContent='';
 crawl.scrollTop=0;
 }
 // ensure header has a black close dot from start
 addCrawlCloseDot();
 requestAnimationFrame(updateCrawlCursorPosition);
 const lines = [
 "Praxis | Pattern | Compulsion | All we can ever do.",
 "Poeisis | Material | Creation | All we can ever see.",
 "Theoria | Qualia | Connection | All we can ever know.",
 ...LINES
 ];
 let i=0;
 let current=crawl.textContent||'';
 crawlActive=true;

 // local canonical matcher (avoids hoisting issues)
 function idxFn(s){
 const t=(s||'').replace(/\s+/g,' ').trim().toLowerCase();
 if(t.startsWith('praxis | pattern | compulsion')) return 0;
 if(t.startsWith('poeisis | material | creation')) return 1;
 if(t.startsWith('theoria | qualia | connection')) return 2;
 return -1;
 }

 if(forceFinal){
 crawlActive=false;
 collapseCrawlToCloseFrame(true, parts);
 return;
 }

 function endAsPresent(){
 crawlActive=false;
 collapseCrawlToCloseFrame(false, parts);
 }

 const triBuffer=[]; let triCycleStarted=false;
 (function typeLine(){
 if(!crawlActive || i>=lines.length){ endAsPresent(); return; }
 const line=lines[i]; let j=0;
 (function step(){
 if(!crawlActive) return;
 if(j<line.length){
 current += line[j++];
 crawl.textContent=current;
 crawl.scrollTop=crawl.scrollHeight;
 updateCrawlCursorPosition();
 setTimeout(step, 6 + Math.random()*10);
 } else {
 // if line has pipe-separated segments, track it for tri-line cycling
 if(line.includes('|')){
 const idx = idxFn(line);
 if(idx!==-1 && triBuffer.length<3){
 const rowIndex = current.split('\n').length - 1;
 triBuffer.push({idx, row: rowIndex});
 }
 if(triBuffer.length===3 && !triCycleStarted){
 triCycleStarted=true;
 startTriLineCycle(triBuffer.slice());
 }
 }
 // continue to next line without glitchy animation
 current+='\n\n';
 crawl.textContent=current;
 crawl.scrollTop=crawl.scrollHeight;
 updateCrawlCursorPosition();
 i++; setTimeout(typeLine, 120 + Math.random()*100);
 }
 })();
 })();

 // Begin simultaneous tri-line swapping once all three canonical lines have appeared
 function startTriLineCycle(anchorRows){
 const crawlEl=document.getElementById('crawl'); if(!crawlEl) return;
 const sequences=[
 {words:["Praxis","Pattern","Compulsion"], tail:"All we can ever do."},
 {words:["Poeisis","Material","Creation"], tail:"All we can ever see."},
 {words:["Theoria","Qualia","Connection"], tail:"All we can ever know."}
 ];
 let stepIdx=0;
 function buildTarget(anchor){
 const seq=sequences[anchor.idx]||null;
 if(!seq) return '';
 const span=seq.words.length||1;
 const offset=stepIdx%span;
 const ordered=[0,1,2].map((i)=>seq.words[(offset+i)%span]);
 return `${ordered[0]} | ${ordered[1]} | ${ordered[2]} | ${seq.tail}`;
 }
 function animateRow(anchor, target){
 return new Promise((resolve)=>{
 const row=anchor.row;
 if(row<0){ resolve(); return; }
 function erase(){
 if(!crawlActive){ resolve(); return; }
 const buffer=crawlEl.textContent.split('\n');
 if(row>=buffer.length){ resolve(); return; }
 const line=buffer[row]||'';
 if(line.length>0){
 buffer[row]=line.slice(0,-1);
 crawlEl.textContent=buffer.join('\n');
 current=crawlEl.textContent;
 crawlEl.scrollTop=crawlEl.scrollHeight;
 updateCrawlCursorPosition();
 setTimeout(erase, 10+Math.random()*14);
 } else {
 type(0);
 }
 }
 function type(idx){
 if(!crawlActive){ resolve(); return; }
 if(idx<target.length){
 const buffer=crawlEl.textContent.split('\n');
 if(row>=buffer.length){ resolve(); return; }
 const line=buffer[row]||'';
 buffer[row]=line+target[idx];
 crawlEl.textContent=buffer.join('\n');
 current=crawlEl.textContent;
 crawlEl.scrollTop=crawlEl.scrollHeight;
 updateCrawlCursorPosition();
 setTimeout(()=>type(idx+1), 14+Math.random()*16);
 } else {
 resolve();
 }
 }
 erase();
 });
 }
 function runCycle(){
 if(!crawlActive) return;
 if(!anchorRows || anchorRows.length!==3) return;
 window.__crawlActiveCycle = stepIdx;
 const animations=anchorRows.map(anchor=>{
 const target=buildTarget(anchor);
 return animateRow(anchor, target);
 });
 Promise.all(animations).then(()=>{
 if(!crawlActive) return;
 stepIdx=(stepIdx+1)%3;
 setTimeout(runCycle, 2200);
 });
 }
 setTimeout(runCycle, 420);
 }
}

// Removed animateSegmentReplacements - tri-line cycling handles all swapping now

function playBowSequence(container){
 const stage=document.getElementById('bow-stage'); if(!stage) return;
 const svg=document.getElementById('bow-svg');
 const sq=document.getElementById('sq');
 const left=document.getElementById('left');
 const right=document.getElementById('right');
 const pivotDot=document.getElementById('pivotDot');
 const pivotHalo=document.getElementById('pivotHalo');
 const closeHitbox=document.getElementById('closeHitbox');
 if(!svg || !sq || !left || !right) return;

 svg.style.filter='drop-shadow(0 0 4px rgba(255,180,80,0.35))';

 // Add click handler to close hitbox
 if(closeHitbox){
 closeHitbox.addEventListener('click', (e)=>{
 e.stopPropagation();
 if(container){
 container.style.transition='opacity 0.3s ease, transform 0.3s ease';
 container.style.opacity='0';
 container.style.transform='translate(-50%,-50%) scale(0.85)';
 setTimeout(()=>{ container.style.display='none'; }, 300);
 }
 });
 closeHitbox.style.cursor='pointer';
 }

 let pivotStart=null;
 if(pivotDot){
 const containerRect=container.getBoundingClientRect();
 const svgRect=svg.getBoundingClientRect();
 const offsetX=svgRect.left-containerRect.left;
 const offsetY=svgRect.top-containerRect.top;
 let startCx=180, startCy=18;
 if(lastCrawlDotOrigin){
 const localX=lastCrawlDotOrigin.fracX*containerRect.width;
 const localY=lastCrawlDotOrigin.fracY*containerRect.height;
 const normX=(localX-offsetX)/svgRect.width;
 const normY=(localY-offsetY)/svgRect.height;
 startCx=Math.min(200, Math.max(0, normX*200));
 startCy=Math.min(140, Math.max(0, normY*140));
 }
 pivotDot.setAttribute('cx', startCx.toFixed(2));
 pivotDot.setAttribute('cy', startCy.toFixed(2));
 pivotDot.setAttribute('opacity','1');
 pivotDot.setAttribute('fill','url(#bh)');
 pivotDot.setAttribute('r','10');
 if(pivotHalo){
 pivotHalo.setAttribute('cx', startCx.toFixed(2));
 pivotHalo.setAttribute('cy', startCy.toFixed(2));
 pivotHalo.setAttribute('r','18');
 pivotHalo.setAttribute('opacity','0');
 }
 pivotStart={cx:startCx, cy:startCy};
 }
 lastCrawlDotOrigin=null;

 const squareFrom={x:100,y:70,w:0,h:0};
 const squareTo={x:40,y:28,w:120,h:84};
 tween(820, (p)=>{
 const eased=easeOutCubic(p);
 const x=lerp(squareFrom.x,squareTo.x,eased);
 const y=lerp(squareFrom.y,squareTo.y,eased);
 const w=lerp(squareFrom.w,squareTo.w,eased);
 const h=lerp(squareFrom.h,squareTo.h,eased);
 sq.setAttribute('x', x.toFixed(2));
 sq.setAttribute('y', y.toFixed(2));
 sq.setAttribute('width', w.toFixed(2));
 sq.setAttribute('height', h.toFixed(2));
 sq.setAttribute('opacity', Math.min(1, eased*1.2).toFixed(2));
 }, null, 180);

 const leftFrom=[[0,70],[-40,38],[-40,102]];
 const leftTo=[[86,70],[44,46],[44,94]];
 const rightFrom=[[200,70],[240,38],[240,102]];
 const rightTo=[[114,70],[156,46],[156,94]];
 morphPolygon(left,leftFrom,leftTo,900,420);
 morphPolygon(right,rightFrom,rightTo,900,420);
 tween(720,(p)=>{
 const eased=easeOutQuad(p);
 left.setAttribute('opacity', eased.toFixed(2));
 right.setAttribute('opacity', eased.toFixed(2));
 }, null, 420);

 tween(1400,(p)=>{
 const glow=easeOutQuad(p);
 svg.style.filter=`drop-shadow(0 0 ${lerp(4,22,glow).toFixed(1)}px rgba(255,188,80,${0.25+0.45*glow})) drop-shadow(0 0 ${lerp(6,28,glow).toFixed(1)}px rgba(255,160,60,${0.15+0.4*glow}))`;
 }, null, 420);

 if(pivotDot && pivotStart){
 tween(960,(p)=>{
 const eased=easeOutCubic(p);
 const cx=lerp(pivotStart.cx, 100, eased);
 const cy=lerp(pivotStart.cy, 70, eased);
 pivotDot.setAttribute('cx', cx.toFixed(2));
 pivotDot.setAttribute('cy', cy.toFixed(2));
 pivotDot.setAttribute('r', lerp(10,16,eased).toFixed(2));
 if(eased>0.45){
 const blend=(eased-0.45)/0.55;
 pivotDot.setAttribute('fill','url(#coreGlow)');
 pivotDot.setAttribute('opacity', (0.55+0.45*Math.min(1,blend)).toFixed(2));
 } else {
 pivotDot.setAttribute('fill','url(#bh)');
 pivotDot.setAttribute('opacity', (0.4+0.4*eased).toFixed(2));
 }
 if(pivotHalo){
 pivotHalo.setAttribute('cx', cx.toFixed(2));
 pivotHalo.setAttribute('cy', cy.toFixed(2));
 pivotHalo.setAttribute('r', lerp(18,36,eased).toFixed(2));
 pivotHalo.setAttribute('opacity', (0.1+0.45*eased).toFixed(2));
 }
 if(closeHitbox){
 closeHitbox.setAttribute('cx', cx.toFixed(2));
 closeHitbox.setAttribute('cy', cy.toFixed(2));
 closeHitbox.setAttribute('opacity', '1');
 }
 }, null, 360);
 }

 setTimeout(()=>{ finalizeCrawlCard(container, false); }, 2100);
}

function finalizeCrawlCard(container, fromSkip){
 const stage=document.getElementById('bow-stage'); if(!stage) return;
 const sq=document.getElementById('sq');
 const left=document.getElementById('left');
 const right=document.getElementById('right');
 const pivotDot=document.getElementById('pivotDot');
 const pivotHalo=document.getElementById('pivotHalo');
 // Settle shapes into their final bow formation
 if(sq){
 sq.setAttribute('x','40');
 sq.setAttribute('y','28');
 sq.setAttribute('width','120');
 sq.setAttribute('height','84');
 sq.setAttribute('opacity','1');
 }
 if(left){
 left.setAttribute('opacity','1');
 left.setAttribute('points','86,70 44,46 44,94');
 }
 if(right){
 right.setAttribute('opacity','1');
 right.setAttribute('points','114,70 156,46 156,94');
 }
 if(pivotDot){
 pivotDot.setAttribute('opacity','1');
 pivotDot.setAttribute('cx','100');
 pivotDot.setAttribute('cy','70');
 pivotDot.setAttribute('r','16');
 pivotDot.setAttribute('fill','url(#coreGlow)');
 }
 if(pivotHalo){
 pivotHalo.setAttribute('cx','100');
 pivotHalo.setAttribute('cy','70');
 pivotHalo.setAttribute('r','36');
 pivotHalo.setAttribute('opacity','0.55');
 }
 const svg=document.getElementById('bow-svg');
 if(svg) svg.style.filter='drop-shadow(0 0 22px rgba(255,188,80,0.65)) drop-shadow(0 0 28px rgba(255,160,60,0.45))';
 // morph card to white rounded square background
 const card=stage.parentElement;
 card.style.transition='background .6s ease, box-shadow .6s ease, border .6s ease';
 card.style.background='radial-gradient(circle at 50% 38%, #fffdf3 0%, #fff3c8 55%, #fee3a8 100%)';
 card.style.boxShadow='0 18px 45px rgba(255,188,90,.35), inset 0 0 26px rgba(255,215,140,.35)';
 card.style.border='1.2px solid rgba(255,196,90,0.55)';
}

/* =========================
 Theme caster (routes lines to screens)
 ========================= */
function addThemeCaster(){
 // orchestrate: terminal prints commands, targeted devices receive content
 const queue = LINES.slice(); let idx=0;
 function next(){
 if(idx>=queue.length) return;
 const line = queue[idx++];

 // terminal chatter
 sendTo('terminal', `> cast "${line}"\n> route: ${routeFor(line)}\n`);

 // Route to devices based on rules; keep retro override
 if(line==="Or. Close enough.") sendTo('retro', "Or. Close enough.");
 else {
 const target = routeFor(line);
 if(target && target !== 'tv-clock') sendTo(target, line);
 }

 setTimeout(next, 900);
 }
 next();
}
function routeFor(line){
 if(CAST_RULES[line]) return CAST_RULES[line];
 
 // Dynamic thematic routing based on keywords
 
 // AWARENESS/CONNECTION themes -> CRT (magenta, bottom-left)
 if(/aware|conscious|observe|watch|see|connect|thread|qualia|theoria|know|perceive/i.test(line)) return 'crt';
 
 // CREATION/MAKING themes -> BIOS (bottom-right) 
 if(/creat|make|build|craft|shape|form|poiesis|poeisis|material|architect|design|vessel|sew/i.test(line)) return 'bios';
 
 // TIME/ACTION/PRAXIS themes -> MOVIE (top-right)
 if(/time|praxis|pattern|action|pulse|tick|tock|compulsion|gift|present|angel|mother/i.test(line)) return 'movie';
 
 // REALITY/TRUTH moments -> RETRO (illuminated)
 if(/real|truth|close enough/i.test(line)) return 'retro';
 
 // VAL YU (creator) -> BIOS
 if(/val|yu|curator|culler|killer/i.test(line)) return 'bios';
 
 // TORI (adventurer) -> BIOS
 if(/tori|stellar|adventure|friend|chose/i.test(line)) return 'bios';
 
 // Default to movie for narrative flow
 return 'movie';
}
function sendTo(deviceName, text){
 const dev=devices[deviceName]; if(!dev) return;
 dev.content = text; drawText(deviceName);
}

/* =========================
 Text draw
 ========================= */
function drawText(name){
 const dev=devices[name]; if(!dev) return;
 if(name==='tv') return; // tv is RT + chrome
 const ctx=dev.ctx, cfg=dev.config, canvas=dev.canvas;
 ctx.fillStyle='#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
 let text=dev.glitchText || dev.content; if(!text) return;
 
 // BIOS-like style for bottom-right bios
 if(name==='bios'){
 ctx.shadowColor='rgba(120,180,255,0.6)'; ctx.shadowBlur=14; ctx.fillStyle='#ffffff';
 } else if(name==='crt'){
 // bottom-left: magenta
 ctx.shadowColor='rgba(255,120,220,0.55)'; ctx.shadowBlur=12; ctx.fillStyle='#ff66cc';
 } else {
 ctx.shadowColor='transparent'; ctx.shadowBlur=0; ctx.fillStyle='#fff';
 }
 
 // Apply global cycle to pipe-delimited lines for consistent single-item display
 if(text.includes('|') && window.__crawlActiveCycle!==undefined){
 const idx = window.__crawlActiveCycle % 3;
 const lists=[
 {col1:["Praxis","Pattern","Compulsion"], col2:["All we can ever do."]},
 {col1:["Poeisis","Material","Creation"], col2:["All we can ever see."]},
 {col1:["Theoria","Qualia","Connection"], col2:["All we can ever know."]}
 ];
 // identify which canonical line this is and swap
 const t=(text||'').replace(/\s+/g,' ').trim().toLowerCase();
 let lineIdx=-1;
 if(t.startsWith('praxis') || t.startsWith('pattern') || t.startsWith('compulsion')) lineIdx=0;
 else if(t.startsWith('poeisis') || t.startsWith('material') || t.startsWith('creation')) lineIdx=1;
 else if(t.startsWith('theoria') || t.startsWith('qualia') || t.startsWith('connection')) lineIdx=2;
 if(lineIdx>=0 && lineIdx<lists.length){
 const list=lists[lineIdx];
 text = `${list.col1[idx]} | ${list.col2[0]}`;
 }
 }
 ctx.font=`bold ${cfg.size}px ${cfg.font}`; ctx.textBaseline='top';
 const lines=text.split('\n'); const lh = cfg.size*1.35; const pad=20; const maxW=canvas.width-pad*2; let y=pad;
 for(const line of lines){
 if(!line.trim()){ y+=lh; continue; }
 const words=line.split(' '); let cur='';
 for(const w of words){
 const t=cur?cur+' '+w:w;
 if(ctx.measureText(t).width>maxW && cur){ ctx.fillText(cur,pad,y); y+=lh; cur=w; }
 else cur=t;
 }
 if(cur){ ctx.fillText(cur,pad,y); y+=lh; }
 }
 dev.texture.needsUpdate=true;
}

/* =========================
 WASD movement controls
 ========================= */
const keys = {w:false, a:false, s:false, d:false, shift:false};
function setupKeyboardControls(){
 console.log('Setting up keyboard controls...');
 window.addEventListener('keydown', e=>{
 const k = e.key.toLowerCase();
 if(k === 'w' || k === 'a' || k === 's' || k === 'd') {
 keys[k] = true;
 e.preventDefault();
 e.stopPropagation();
 }
 if(e.key === 'Shift') keys.shift = true;
 });
 window.addEventListener('keyup', e=>{
 const k = e.key.toLowerCase();
 if(k === 'w' || k === 'a' || k === 's' || k === 'd') {
 keys[k] = false;
 e.preventDefault();
 e.stopPropagation();
 }
 if(e.key === 'Shift') keys.shift = false;
 });
 console.log('Keyboard controls setup complete');
}

/* =========================
 Animate & mirror
 ========================= */
let mouse={x:0,y:0};
function animate(){
 requestAnimationFrame(animate);
 frameCount++;
 const t=clock.getElapsedTime();
 const delta = lastFrameTime ? Math.min(0.05, t - lastFrameTime) : 0.016;
 lastFrameTime = t;
 
 // Update HUD debug
 const wsEl=document.getElementById('wasd-status'); if(wsEl) wsEl.textContent=`${keys.w?'W':'-'}${keys.a?'A':'-'}${keys.s?'S':'-'}${keys.d?'D':'-'}`;
 const psEl=document.getElementById('pos-status'); if(psEl) psEl.textContent=`${camera.position.x.toFixed(1)},${camera.position.y.toFixed(1)},${camera.position.z.toFixed(1)}`;

 if(cameraMode==='orbital'){
 // Orbital parallax easing toward initial with mouse offset
 const tx = -mouse.x * 2;
 const ty = mouse.y * 2;
 camera.position.x += (initialCameraPos.x + tx - camera.position.x) * 0.03;
 camera.position.y += (initialCameraPos.y + ty - camera.position.y) * 0.03;
 camera.lookAt(0,0,0);
 } else {
 // FPS (no clamping)
 const moveSpeed = (keys.shift ? 12.0 : 6.0) * delta;
 const forward = new THREE.Vector3(); camera.getWorldDirection(forward);
 forward.y = 0; forward.normalize(); // keep walking on ground plane
 const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).normalize(); // right-hand

 if(keys.w) camera.position.addScaledVector(forward, moveSpeed);
 if(keys.s) camera.position.addScaledVector(forward, -moveSpeed);
 if(keys.a) camera.position.addScaledVector(right, -moveSpeed);
 if(keys.d) camera.position.addScaledVector(right, moveSpeed);

 // Gravity (only while airborne)
 if(!camera.userData.velocity) camera.userData.velocity=new THREE.Vector3();
 if(camera.position.y > groundLevel + 1e-4 || camera.userData.isAirborne){
 camera.userData.velocity.y -= 19.6 * delta;
 camera.position.y += camera.userData.velocity.y * delta;
 camera.userData.isAirborne = true;
 if(camera.position.y <= groundLevel){
 if(camera.userData.velocity.y < -1.5) playThudSound();
 camera.position.y = groundLevel;
 camera.userData.velocity.y = 0;
 camera.userData.isAirborne = false;
 }
 } else {
 // Stay planted
 camera.position.y = groundLevel;
 camera.userData.velocity.y = 0;
 camera.userData.isAirborne = false;
 }
 }

 // Maintain zoom row alignment and effects
 if(window.zoomOverlay){
 // Recompute a straight line in front of camera each frame
 const camForward = new THREE.Vector3(); camera.getWorldDirection(camForward).normalize();
 const camRight = new THREE.Vector3().crossVectors(camForward, new THREE.Vector3(0,1,0)).normalize();
 const camUp = new THREE.Vector3(0,1,0);
 const basePos = new THREE.Vector3().copy(camera.position).addScaledVector(camForward, 6.3).addScaledVector(camUp, 1.2);
 const spacing = 2.2;
 const order = ['cage','clock','radar'];
 order.forEach((name, idx)=>{
 const obj = (name==='cage')? (devices.bios && devices.bios.voxelCage && devices.bios.voxelCage.group)
 : (name==='clock')? (devices.movie && devices.movie.analogClock && devices.movie.analogClock.group)
 : (window.biosRadar && window.biosRadar.holder);
 if(!obj || !obj.userData || !obj.userData.overlayNode) return;
 const node = obj.userData.overlayNode;
 const target = new THREE.Vector3().copy(basePos).addScaledVector(camRight, (idx-1)*spacing);
 node.position.lerp(target, 0.2);
 node.quaternion.slerp(camera.quaternion, 0.15);
 // Pulse energy sphere
 if(obj.userData.energySphere){
 const s = 0.35 + Math.sin(t*3 + idx)*0.08;
 obj.userData.energySphere.scale.setScalar(s/0.35);
 obj.userData.energySphere.material.opacity = 0.55 + 0.25*Math.sin(t*2.2 + idx*0.7);
 }
 if(obj.userData.glowLight){
 obj.userData.glowLight.intensity = 2.0 + 0.6*Math.sin(t*2.0 + idx);
 }
 });

 // Only draw overlay links when items are zoomed, otherwise base links
 const anyZoomed = ['cage','clock','radar'].some(name=>{
 const obj = (name==='cage')? (devices.bios && devices.bios.voxelCage && devices.bios.voxelCage.group)
 : (name==='clock')? (devices.movie && devices.movie.analogClock && devices.movie.analogClock.group)
 : (window.biosRadar && window.biosRadar.holder);
 return obj && obj.userData && obj.userData.isZoomed;
 });
 if(anyZoomed){
 updateZoomLinks([
 {from: 'cage', to: 'clock'},
 {from: 'clock', to: 'radar'},
 {from: 'radar', to: 'cage'}
 ], t);
 }
 }
 
 // Screen startup sequence and paced tracking
 Object.values(devices).forEach(d=>{ 
 d.material.uniforms.uTime.value=t;
 if(!d.isOnline && t*1000 >= d.startDelay){
 const targetColor = new THREE.Color(d.config.color);
 // Fade in animation
 const fadeTime = 1200;
 const startTime = d.startDelay/1000;
 const progress = Math.min(1, (t - startTime) / (fadeTime/1000));
 const eased = progress * progress * (3 - 2 * progress); // smoothstep
 d.material.uniforms.uColor.value.copy(targetColor).multiplyScalar(eased * 0.01 + 0.99);
 if(progress >= 1.0) d.isOnline = true;
 }
 
 // Paced tracking animation (staggered/delayed updates)
 if(d.baseRotation && d.trackingPhase !== undefined && d.group && d.targetRotation){
 // Update target rotation every 0.5 seconds (staggered, not real-time)
 if(t - d.lastUpdateTime > 0.5){
 d.lastUpdateTime = t;
 
 // Calculate direction to camera
 const monitorPos = new THREE.Vector3();
 d.group.getWorldPosition(monitorPos);
 const dirToCamera = new THREE.Vector3().subVectors(camera.position, monitorPos);
 dirToCamera.normalize();
 
 // Calculate target rotation to face camera
 const distance = Math.sqrt(dirToCamera.x**2 + dirToCamera.z**2);
 const targetRotX = -Math.atan2(dirToCamera.y, distance);
 const targetRotY = Math.atan2(dirToCamera.x, dirToCamera.z);
 
 // Blend base rotation with tracking
 d.targetRotation.x = d.baseRotation.x * 0.4 + targetRotX * 0.6;
 d.targetRotation.y = d.baseRotation.y * 0.4 + targetRotY * 0.6;
 }
 
 // Smoothly interpolate toward target with breathing motion
 const trackSpeed = 0.04; // Slow, smooth interpolation
 const breathAmount = 0.015;
 const phase = d.trackingPhase + t * 0.5;
 const breathX = Math.sin(phase) * breathAmount;
 const breathY = Math.cos(phase * 0.7) * breathAmount;
 
 // Calculate new rotation
 let newRotX = d.group.rotation.x + (d.targetRotation.x + breathX - d.group.rotation.x) * trackSpeed;
 let newRotY = d.group.rotation.y + (d.targetRotation.y + breathY - d.group.rotation.y) * trackSpeed;
 
 // Clamp rotations to prevent clipping into near plane
 // Limit X rotation to prevent tilting too far forward/back
 newRotX = Math.max(-0.5, Math.min(0.8, newRotX));
 // Limit Y rotation to prevent extreme side angles
 newRotY = Math.max(-0.6, Math.min(0.6, newRotY));
 
 d.group.rotation.x = newRotX;
 d.group.rotation.y = newRotY;
 }
 });
 
 // Instanced monitors are now true InstancedMesh - no per-instance updates needed

 // TV clock tick
 if(devices.tv && devices.tv.pixelClock) updatePixelClock(devices.tv.pixelClock);
 if(devices.movie && devices.movie.clock) updateClock(devices.movie.clock);
 analogClockUpdaters.forEach(clock=>updateAnalogPixelClock(clock));

 // Terminal indicator blink
 if(devices.terminal && devices.terminal.indicator){
 const a = (Math.sin(t*5.0)*0.5+0.5)*0.95;
 devices.terminal.indicator.material.opacity = a;
 devices.terminal.indicator.visible = true;
 }

 // recursive TV capture with static camera (no bob/jitter)
 if(recursiveRT && recursiveCam && (frameCount&1)===0 && devices.tv){
 devices.tv.group.visible=false;
 // Use static position instead of copying animated camera
 recursiveCam.position.set(0, 0, 18);
 recursiveCam.lookAt(0, 0, 0);
 renderer.setRenderTarget(recursiveRT); renderer.render(scene, recursiveCam); renderer.setRenderTarget(null);
 devices.tv.group.visible=true;
 }

 // TV static/glitch overlay on top-right
 if(devices.movie && devices.movie.staticOverlay) updateStaticOverlay(devices.movie.staticOverlay);

 // campfire update
 if(campfire) updateCampfire(campfire, t);

 // health monitor ECG
 if(healthMonitor && healthMonitor.ecg){
 const e=healthMonitor.ecg; e.t += 0.016;
 const ctx=e.ctx, W=e.canvas.width, H=e.canvas.height;
 // scroll left
 const img=ctx.getImageData(2,0,W-2,H); ctx.clearRect(0,0,W,H); ctx.putImageData(img,0,0);
 // grid
 ctx.fillStyle='rgba(255,30,60,0.08)'; for(let y=0;y<H;y+=12) ctx.fillRect(W-2,y,2,1);
 // waveform
 const t=e.t*2.5; const mid=H*0.55;
 let y=mid + Math.sin(t*3.1)*6;
 // add heartbeat spike periodically
 const beat = Math.floor(t)%2===0 && (Math.floor(t*10)%10===0);
 if(beat) y -= 24;
 ctx.fillStyle='#ff3355'; ctx.fillRect(W-2, y, 2, 2);
 e.tex.needsUpdate=true;
 }
 // Base triangle links always visible at base positions
 updateBaseTriangleLinks(t);
 // warm pulse from top-right clock light
 if(devices.movie && devices.movie.clock && devices.movie.clock.light){
 devices.movie.clock.light.intensity = 1.5 + Math.sin(t*2.0)*0.2;
 }

 // orientation-based device rotation (mobile portrait)
 orientationWatcher.targets.forEach((state, group)=>{
 if(!group || !state) return;
 const targetRot = state.rotation !== undefined ? state.rotation : (state.target || 0);
 const current = group.rotation.z;
 const diff = targetRot - current;
 if(Math.abs(diff)>0.0001){
 group.rotation.z = current + diff*0.08;
 } else {
 group.rotation.z = targetRot;
 }
 if(state.position){
 group.position.x += (state.position.x - group.position.x) * 0.08;
 group.position.y += (state.position.y - group.position.y) * 0.08;
 group.position.z += (state.position.z - group.position.z) * 0.08;
 }
 });

 // wave animation for voxel walls and floor
 if(settings.voxels && window.voxelWall && window.voxelFloor){
 const waveSpeed = 1.2, waveAmpWall = 0.6, waveAmpFloor = 0.4;
 const freqX = 0.15, freqY = 0.12, freqZ = 0.18;
 
 // Animate wall
 for(let i=0; i<window.voxelWall.inst.count; i++){
 const basePos = window.voxelWall.positions[i];
 const offsetZ = Math.sin(basePos.x * freqX + basePos.y * freqY + t * waveSpeed) * waveAmpWall;
 window.voxelWall.dummy.position.set(basePos.x, basePos.y, basePos.z + offsetZ);
 window.voxelWall.dummy.updateMatrix();
 window.voxelWall.inst.setMatrixAt(i, window.voxelWall.dummy.matrix);
 }
 window.voxelWall.inst.instanceMatrix.needsUpdate = true;
 
 // Animate floor
 for(let i=0; i<window.voxelFloor.inst.count; i++){
 const basePos = window.voxelFloor.positions[i];
 const offsetY = Math.sin(basePos.x * freqX + basePos.z * freqZ + t * waveSpeed) * waveAmpFloor;
 window.voxelFloor.dummy.position.set(basePos.x, basePos.y + offsetY, basePos.z);
 window.voxelFloor.dummy.updateMatrix();
 window.voxelFloor.inst.setMatrixAt(i, window.voxelFloor.dummy.matrix);
 }
 window.voxelFloor.inst.instanceMatrix.needsUpdate = true;
 
 // Make campfire bob with the floor voxels
 if(campfire && campfire.group){
 if(!campfire.baseY) campfire.baseY = campfire.group.position.y;
 const cfX = campfire.group.position.x;
 const cfZ = campfire.group.position.z;
 const offsetY = Math.sin(cfX * freqX + cfZ * freqZ + t * waveSpeed) * waveAmpFloor;
 campfire.group.position.y = campfire.baseY + offsetY;
 
 // Animate white hole rings and handle color pulse
 if(campfire.whiteHole){
 const whData = campfire.whiteHole.userData;
 
 // Decay pulse intensity
 if(whData.pulseIntensity > 0){
 whData.pulseIntensity -= delta * 0.8;
 if(whData.pulseIntensity < 0) {
 whData.pulseIntensity = 0;
 whData.pulseColor = null;
 }
 }
 
 campfire.whiteHole.children.forEach(child => {
 // Rotate rings
 if(child.userData.rotSpeed){
 child.rotation.z += delta * child.userData.rotSpeed;
 // Pulse opacity
 const pulse = Math.sin(t * 2 + child.userData.layer * 0.5) * 0.15;
 child.material.opacity = (0.6 - child.userData.layer * 0.15) + pulse;
 
 // Apply color pulse
 if(whData.pulseColor && whData.pulseIntensity > 0){
 child.material.color.lerp(whData.pulseColor, whData.pulseIntensity * 0.5);
 } else {
 child.material.color.lerp(new THREE.Color(0xffffff), delta * 2);
 }
 }
 
 // Pulsate black core
 if(child.userData.isBlackCore){
 const blackPulse = Math.sin(t * 3) * 0.15 + 0.85;
 child.scale.setScalar(blackPulse);
 }
 
 // Apply color pulse to white core
 if(child.userData.isCore && whData.pulseColor && whData.pulseIntensity > 0){
 child.material.color.lerp(whData.pulseColor, whData.pulseIntensity * 0.7);
 } else if(child.userData.isCore){
 child.material.color.lerp(new THREE.Color(0xffffff), delta * 2);
 }
 });
 }
 }
 }

 // floaters half-rate
 if((frameCount&1)===0 && settings.voxels){
 voxelParticles.forEach(p=>{
 p.voxel.position.add(p.velocity); p.sprite.position.copy(p.voxel.position);
 p.voxel.rotation.x+=p.rotVel.x; p.voxel.rotation.y+=p.rotVel.y; p.voxel.rotation.z+=p.rotVel.z;
 if(Math.abs(p.voxel.position.x)>45) p.velocity.x*=-1;
 if(Math.abs(p.voxel.position.y)>30) p.velocity.y*=-1;
 if(p.voxel.position.z>-5 || p.voxel.position.z<-20) p.velocity.z*=-1;
 // glitch -> vapor-like white text: stretch upward, fade out, glow
 p.glitchTimer-=0.03; 
 if(p.glitchTimer<=0){ 
 p.isGlitched=!p.isGlitched; p.voxel.visible=!p.isGlitched; p.sprite.visible=p.isGlitched; 
 if(p.isGlitched){ p.fade=1.0; p.sprite.material.opacity=0.95; }
 p.glitchTimer=p.isGlitched?0.5+Math.random()*0.7:2+Math.random()*3; 
 }
 if(p.isGlitched){
 p.sprite.scale.y = 1.6 + (1.0-p.fade)*2.2; // stretch up like vapor
 p.sprite.material.opacity = Math.max(0, p.fade*0.95);
 p.fade -= 0.04; if(p.fade<=0){ p.isGlitched=false; p.voxel.visible=true; p.sprite.visible=false; p.glitchTimer=2+Math.random()*2.5; }
 } else {
 p.sprite.scale.y = 1.6;
 }
 });
 }

 cageEmitters.forEach(em=>{
 if(em.gizmo){
 em.gizmo.rotation.x = t*0.6;
 em.gizmo.rotation.y = t*0.8;
 em.gizmo.rotation.z = t*0.4;
 }
 if(!settings.voxels){
 em.voxels.forEach(v=>{ v.mesh.visible=false; });
 return;
 }
 em.spitTimer -= delta;
 if(em.spitTimer<=0){
 const v=em.voxels[Math.floor(Math.random()*em.voxels.length)];
 v.mesh.visible=true;
 v.mesh.position.set(0,0,0);
 const dir=new THREE.Vector3((Math.random()-0.5), (Math.random()-0.2), (Math.random()-0.5));
 if(dir.lengthSq()<0.01) dir.set(0,1,0);
 dir.normalize().multiplyScalar(1.6+Math.random()*0.8);
 v.velocity.copy(dir);
 v.lifetime = 2.4 + Math.random()*1.8;
 v.cooldown = 0;
 em.spitTimer = 1.3 + Math.random()*1.2;
 }
 const activateGate=(axis, dir, strength=1)=>{
 if(!em.gateMap) return;
 const gate=em.gateMap[`${axis}${dir>0?'+':'-'}`];
 if(!gate) return;
 gate.strength=Math.min(1, Math.max(gate.strength, strength));
 gate.mesh.material.opacity=gate.strength*0.7;
 gate.mesh.material.needsUpdate=true;
 };

 em.voxels.forEach(v=>{
 if(!v.mesh.visible){
 v.cooldown = Math.max(0, v.cooldown - delta);
 if(v.cooldown<=0){
 v.mesh.visible=true;
 v.mesh.position.set(0,0,0);
 const dir=new THREE.Vector3((Math.random()-0.5), (Math.random()*0.8)+0.2, (Math.random()-0.5));
 if(dir.lengthSq()<0.01) dir.set(0,1,0);
 dir.normalize().multiplyScalar(1.1+Math.random()*0.6);
 v.velocity.copy(dir);
 v.lifetime = 2.0 + Math.random()*1.5;
 }
 return;
 }
 v.lifetime -= delta;
 if(v.lifetime<=0){
 v.mesh.visible=false;
 v.cooldown = 1.2 + Math.random()*1.6;
 return;
 }
 v.mesh.position.x += v.velocity.x*delta;
 v.mesh.position.y += v.velocity.y*delta;
 v.mesh.position.z += v.velocity.z*delta;
 v.velocity.y -= delta*0.6;
 const limit=em.half*0.9;
 if(Math.abs(v.mesh.position.x)>limit){
 const dir=Math.sign(v.mesh.position.x);
 v.mesh.position.x=dir*limit;
 v.velocity.x*=-0.7;
 activateGate('x', dir, 1.0);
 } else if(Math.abs(v.mesh.position.x)>limit*0.82){
 activateGate('x', Math.sign(v.mesh.position.x)||1, 0.45);
 }
 if(Math.abs(v.mesh.position.y)>limit){
 const dir=Math.sign(v.mesh.position.y);
 v.mesh.position.y=dir*limit;
 v.velocity.y*=-0.6;
 activateGate('y', dir, 0.9);
 } else if(Math.abs(v.mesh.position.y)>limit*0.82){
 activateGate('y', Math.sign(v.mesh.position.y)||1, 0.4);
 }
 if(Math.abs(v.mesh.position.z)>limit){
 const dir=Math.sign(v.mesh.position.z);
 v.mesh.position.z=dir*limit;
 v.velocity.z*=-0.7;
 activateGate('z', dir, 1.0);
 } else if(Math.abs(v.mesh.position.z)>limit*0.82){
 activateGate('z', Math.sign(v.mesh.position.z)||1, 0.45);
 }
 v.velocity.multiplyScalar(0.995);
 });

 if(em.gates){
 em.gates.forEach(g=>{
 if(g.strength>0){
 g.strength=Math.max(0, g.strength - delta*1.8);
 const s=1+g.strength*0.1;
 g.mesh.scale.set(s,s,1);
 g.mesh.material.opacity=g.strength*0.7;
 } else {
 g.mesh.scale.set(1,1,1);
 if(g.mesh.material.opacity!==0){
 g.mesh.material.opacity=0;
 }
 }
 });
 }
 });

 // Orbital-only parallax camera; do not run in FPS
 if(cameraMode==='orbital'){
 const tx=mouse.x*4, ty=mouse.y*3;
 camera.position.x += (tx - camera.position.x)*0.03;
 camera.position.y += (ty - camera.position.y)*0.03;
 camera.position.z = 18 + Math.sin(t*0.22)*0.5;
 camera.lookAt(0,0,0);
 }

 composer.render();
}

/* =========================
 Settings & resize
 ========================= */
function hookSettings(){
 const icon=document.getElementById('settings-icon'), menu=document.getElementById('settings-menu');
 icon.onclick=()=>{ menu.style.display='block'; };
 document.getElementById('close-settings').onclick=()=>{ menu.style.display='none'; };
 [['set-bloom','bloom'],['set-dof','dof'],['set-fog','fog'],['set-voxels','voxels'],['set-cables','cables']].forEach(([id,key])=>{
 const el=document.getElementById(id);
 el.addEventListener('change',()=>{
 settings[key]=el.checked;
 if(key==='cables') scene.traverse(o=>{ if(o.userData && o.userData.isCable) o.visible=settings.cables; });
 if(key==='voxels') voxelParticles.forEach(p=>{ p.voxel.visible=settings.voxels && !p.isGlitched; p.sprite.visible=settings.voxels && p.isGlitched; });
 if(key==='bloom') bloomPass.enabled=settings.bloom;
 if(key==='dof'){ bokehPass.enabled=settings.dof; updateDofGroupState(); if(settings.dof) applyDofParams(); }
 if(key==='fog'){ scene.fog.near=settings.fog?16:9999; scene.fog.far=settings.fog?68:10000; }
 });
 });

 const dofGroup=document.getElementById('dof-controls');
 const sliderConfigs=[
 {id:'focus-length', key:'focusLength', format:(v)=>`${Math.round(v)}mm`},
 {id:'focus-distance', key:'focusDistance', format:(v)=>`${Math.round(v)}u`},
 {id:'blur-radius', key:'blur', format:(v)=>Number(v).toFixed(3)}
 ];

 function updateDofGroupState(){
 const disabled=!settings.dof;
 if(dofGroup){
 dofGroup.classList.toggle('disabled', disabled);
 sliderConfigs.forEach(cfg=>{
 const input=document.getElementById(cfg.id);
 if(input) input.disabled=disabled;
 });
 }
 }

 sliderConfigs.forEach(cfg=>{
 const input=document.getElementById(cfg.id);
 const valueEl=document.getElementById(`${cfg.id}-value`);
 if(!input) return;
 const initial=DOF_PARAMS[cfg.key];
 if(initial!==undefined) input.value=initial;
 if(valueEl) valueEl.textContent=cfg.format(input.value);
 input.addEventListener('input',()=>{
 DOF_PARAMS[cfg.key]=parseFloat(input.value);
 if(valueEl) valueEl.textContent=cfg.format(input.value);
 applyDofParams();
 });
 });

 updateDofGroupState();
}
function onResize(){
 camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix();
 renderer.setSize(innerWidth,innerHeight); if(composer) composer.setSize(innerWidth,innerHeight);
 if(orientationWatcher.media){
 const portrait = orientationWatcher.media.matches && innerWidth <= 900;
 refreshOrientationTargets(portrait);
 }
}

/* Mouse look */
window.addEventListener('mousemove', (e)=>{
 if(!camera) return;
 // FPS pointer lock
 if(document.pointerLockElement === document.body){
 camera.rotation.y -= (e.movementX||0) * 0.002;
 camera.rotation.x -= (e.movementY||0) * 0.002;
 camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
 } else {
 // Orbital parallax
 mouse.x = -((e.clientX/innerWidth)*2-1);
 mouse.y = ((e.clientY/innerHeight)*2-1);
 }
});

/* =========================
 Boot
 ========================= */
document.getElementById('start').addEventListener('click', async ()=>{
 document.getElementById('start').classList.add('hide');
 try{ await document.fonts.ready; }catch(e){}
 setupKeyboardControls(); // Initialize keyboard after start
 initSoundscape();
 initScene();
 composer && animate();
 
 // --- Bring-up Self-Tests & Toast ---------------------------------------
 (function bootDiagnostics(){
 const meshes = scene.children.filter(o=>o.isMesh).length;
 const lines = [ `Meshes: ${meshes}`, `Hint: press Play to start animation` ];
 toast(lines,'ok');
 if(meshes!==5) toast([`Expected 5 meshes (3 spheres + 1 hole + 1 tri), got ${meshes}`],'warn');
 })();
});
 
 })(); // End of initEnd3Scene IIFE
 } // End of initEnd3Scene function
 
 // Start polling for THREE.js
 waitForTHREE();
 }); // End of DOMContentLoaded

 </script>

 <!-- Twemoji Initialization -->
 <script>
 // Parse emojis throughout the page once loaded
 if (typeof twemoji !== 'undefined') {
 window.addEventListener('DOMContentLoaded', function() {
 twemoji.parse(document.body, {
 folder: 'svg',
 ext: '.svg'
 });
 console.log(' Twemoji initialized');
 });
 
 // Helper function to parse emojis in dynamically added content
 window.parseEmojis = function(element) {
 if (typeof twemoji !== 'undefined') {
 twemoji.parse(element || document.body);
 }
 };
 } else {
 console.warn(' Twemoji not loaded');
 }
 </script>

</body>

</html>

 LEAVES LEAVES

 LEAVES LEAVES

 LEAVES LEAVES

 LEAVES LEAVES

 LEAVES LEAVES LEAVES

 LEAVES LEAVES LEAVES

 LEAVES LEAVES LEAVES LEAVES

 LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES

 LEAVES LEAVES

 LEAVES LEAVES

 LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES

 LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES

 LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES

 LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES

 LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES

 LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES

 LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES

 LEAVES LEAVES

 LEAVES LEAVES

 LEAVES LEAVES LEAVES LEAVES LEAVES

 LEAVES LEAVES LEAVES LEAVES

 LEAVES LEAVES LEAVES LEAVES

 LEAVES LEAVES LEAVES LEAVES

 LEAVES LEAVES LEAVES LEAVES

 LEAVES LEAVES LEAVES LEAVES

 LEAVES LEAVES LEAVES LEAVES LEAVES

 LEAVES LEAVES

 LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES

`;

 

 const houseDiv = document.createElement('div');

 houseDiv.id = 'leavesHouse';

 houseDiv.style.cssText = 'font-family: "Courier New", monospace; white-space: pre; text-align: left; font-size: 13px; margin-top: 5%; margin-left: 5%; color: #0f0; line-height: 1.6; position: absolute; top: 0; left: 0; z-index: 50; pointer-events: none;';

 houseDiv.textContent = house;

 frame.appendChild(houseDiv);

 

 // After 2s, glitch all LEAVES in the house to GIR.mp3

 setTimeout(() => {

 const words = house.match(/LEAVES/g) || [];

 let glitchedHouse = house;

 const glitchDuration = 2000;

 const glitchStart = Date.now();

 

 const glitchInterval = setInterval(() => {

 const elapsed = Date.now() - glitchStart;

 const progress = elapsed / glitchDuration;

 

 if (progress >= 1) {

 clearInterval(glitchInterval);

 // All LEAVES become GIR.mp3

 glitchedHouse = house.replace(/LEAVES/g, 'GIR.mp3');

 houseDiv.textContent = glitchedHouse;

 } else {

 // Gradually glitch LEAVES to GIR.mp3

 let tempHouse = house;

 const totalWords = words.length;

 const wordsToGlitch = Math.floor(totalWords * progress);

 

 let replacedCount = 0;

 tempHouse = tempHouse.replace(/LEAVES/g, (match) => {

 if (replacedCount < wordsToGlitch) {

 replacedCount++;

 // Mix characters between LEAVES and GIR.mp3

 const chars = 'GIR.mp3';

 let mixed = '';

 for (let i = 0; i < match.length; i++) {

 if (Math.random() < progress) {

 mixed += chars[i] || chars[chars.length - 1];

 } else {

 mixed += match[i];

 }

 }

 return mixed.padEnd(7);

 }

 return match;

 });

 

 houseDiv.textContent = tempHouse;

 }

 }, 50);

 }, 2000);

 }

 

 function glitchText(frame, from, to) {

 const glitchDuration = 1000;

 const glitchStart = Date.now();

 const displayEl = frame.querySelector('div');

 

 const glitchInterval = setInterval(() => {

 const elapsed = Date.now() - glitchStart;

 const progress = elapsed / glitchDuration;

 

 if (progress >= 1) {

 clearInterval(glitchInterval);

 displayEl.textContent = to;

 } else {

 // Mix characters

 const mixed = to.split('').map((toChar, i) => {

 if (Math.random() < progress) {

 return toChar;

 } else if (from[i]) {

 return from[i];

 } else {

 return String.fromCharCode(65 + Math.floor(Math.random() * 26));

 }

 }).join('');

 displayEl.textContent = mixed;

 }

 }, 50);

 }

 

 function startCellAddressSequence(frame, visiCalc) {

 console.log('?? Starting cell address sequence [VERSION 26x26 FIX v2.0]');
 console.log('%c ?? GRID NOW SET TO 26x26x26 - CACHE CLEARED ?? ', 'background: #00ff00; color: #000; font-size: 20px; font-weight: bold; padding: 10px;');
 
 console.log('?? VisiCalc display:', visiCalc ? 'exists' : 'missing');

 console.log('??? Frame element:', frame ? 'exists' : 'missing');

 

 // Hide existing content and visiCalc

 const frameEl = document.getElementById('visicalc-frame');

 if (frameEl) {

 frameEl.style.opacity = '0';

 frameEl.style.transition = 'opacity 0.5s ease';

 }

 if (visiCalc) {

 visiCalc.style.transition = 'opacity 0.5s ease';

 visiCalc.style.opacity = '0';

 }

 

 // Create 3D scene for cell addresses and cubes

 const addressScene = new THREE.Scene();

 addressScene.background = new THREE.Color(0x000000);

 const addressCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);

 addressCamera.position.set(0, 0, -90); // Centered on Z axis to see full 26x26x26 cube grid
 addressCamera.lookAt(0, 0, 0);
 addressCamera.updateProjectionMatrix();
 console.log('?? [INIT] Camera positioned at (0, 0, -90) looking at origin');

 

 // Mouse look controls for white room

 let mouseX = 0, mouseY = 0;

 let targetRotationX = 0, targetRotationY = 0;

 let isMouseLookActive = false;

 

 function onMouseMove(event) {

 if (!isMouseLookActive) return;

 

 const deltaX = event.movementX || 0;

 const deltaY = event.movementY || 0;

 

 targetRotationY -= deltaX * 0.002;

 targetRotationX -= deltaY * 0.002;

 

 // Clamp vertical rotation

 targetRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetRotationX));

 }

 

 function onMouseDown(event) {

 console.log('??? Mouse down at sequenceTime:', sequenceTime.toFixed(1), 'whiteRoom:', !!addressScene.userData.whiteRoomCreated, 'blackHole:', !!addressScene.userData.blackHoleCreated);

 if (addressScene.userData.blackHoleCreated && sequenceTime > 55) {

 isMouseLookActive = true;

 addressRenderer.domElement.style.cursor = 'none';

 console.log('??? Mouse look ACTIVATED');

 } else {

 console.log('??? Not ready for mouse look yet');

 }

 }

 

 function onMouseUp(event) {

 isMouseLookActive = false;

 addressRenderer.domElement.style.cursor = 'crosshair';

 console.log('??? Mouse look deactivated');

 }

 

 // Will attach to canvas after it's created

 let mouseMoveAttached = false;

 let mouseDownAttached = false;

 let mouseUpAttached = false;

 

 const addressRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });

 addressRenderer.setSize(window.innerWidth, window.innerHeight);

 addressRenderer.setClearColor(0x000000, 1);

 addressRenderer.setPixelRatio(window.devicePixelRatio);

 addressRenderer.domElement.style.cssText = 'position: fixed; inset: 0; z-index: 200; display: block; pointer-events: auto; cursor: crosshair;';

 addressRenderer.domElement.id = 'address-canvas';

 document.body.appendChild(addressRenderer.domElement);

 console.log('? Address renderer created and added to DOM');

 console.log('??? Canvas z-index: 200, pointer-events: auto');

 

 // Attach mouse event listeners to canvas

 addressRenderer.domElement.addEventListener('mousemove', onMouseMove);

 addressRenderer.domElement.addEventListener('mousedown', onMouseDown);

 addressRenderer.domElement.addEventListener('mouseup', onMouseUp);

 console.log('??? Mouse event listeners attached to canvas');

 

 // Add bloom composer

 const addressComposer = new EffectComposer(addressRenderer);

 const renderPass = new RenderPass(addressScene, addressCamera);

 addressComposer.addPass(renderPass);

 const addressBloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.8, 0.4, 0.3); // Reduced bloom

 addressComposer.addPass(addressBloom);

 console.log('? Address composer created with bloom');

 

 // Handle window resize

 window.addEventListener('resize', () => {

 const width = window.innerWidth;

 const height = window.innerHeight;

 addressCamera.aspect = width / height;

 addressCamera.updateProjectionMatrix();

 addressRenderer.setSize(width, height);

 addressComposer.setSize(width, height);

 console.log('?? Window resized:', width, 'x', height);

 });

 

 // Cell address data

 const addresses = [];

 const cubes = [];

 const maxAddresses = 20000; // Increased for 26x26x26 grid (17,576 total)

 let addressPhase = 0; // 0: 2D (A1, B2), 1: 3D (A1a, B2 )

 let cubePhase = false;

 

 // Greek letters for Z-axis

 const greekLetters = ['a', ' ', '?', 'd', 'e', '?', '?', '?', '?', '?', '?', ' ', '?', '?', '?', 'p', '?', 's', 't', '?', 'f', '?', '?', '?'];

 

 // Create text sprites for cell addresses using CELLI notation

 function createAddressSprite(col, row, depth, is3D) {

 const canvas = document.createElement('canvas');

 const ctx = canvas.getContext('2d');

 canvas.width = 256;

 canvas.height = 128;

 

 // Transparent background

 ctx.clearRect(0, 0, canvas.width, canvas.height);

 

 ctx.fillStyle = '#00ff00'; // Bright green

 ctx.font = 'bold 48px "Courier New", monospace'; // Larger font

 ctx.textAlign = 'center';

 ctx.textBaseline = 'middle';

 

 // Convert to cell notation: A1, B2, C3, etc.

 const colLetter = String.fromCharCode(65 + (col % 26)); // A, B, C...

 const rowNum = row + 1;

 const text = is3D ? `${colLetter}${rowNum}${greekLetters[depth % greekLetters.length]}` : `${colLetter}${rowNum}`;

 ctx.fillText(text, 128, 64);

 

 const texture = new THREE.CanvasTexture(canvas);

 texture.needsUpdate = true;

 const spriteMat = new THREE.SpriteMaterial({ 

 map: texture, 

 transparent: true, 

 opacity: 1.0,

 depthTest: false,

 depthWrite: false

 });

 const sprite = new THREE.Sprite(spriteMat);

 sprite.scale.set(3.5, 1.75, 1); // Larger sprites

 sprite.renderOrder = 1000; // Render on top

 

 return sprite;

 }

 

 // Create geometries for shape-shifting

 const cubeGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);

 const pyramidGeo = new THREE.ConeGeometry(0.35, 0.6, 4);

 pyramidGeo.rotateY(Math.PI / 4);

 const sphereGeo = new THREE.SphereGeometry(0.35, 16, 16);

 

 const greenMat = new THREE.MeshStandardMaterial({ color: 0x00ff00, transparent: true, opacity: 0.9, emissive: 0x00ff00, emissiveIntensity: 0.5, metalness: 0.3, roughness: 0.4 });

 const yellowMat = new THREE.MeshStandardMaterial({ color: 0xffff00, transparent: true, opacity: 0.9, emissive: 0xffff00, emissiveIntensity: 0.5, metalness: 0.3, roughness: 0.4 });

 const blueMat = new THREE.MeshStandardMaterial({ color: 0x0088ff, transparent: true, opacity: 0.9, emissive: 0x0088ff, emissiveIntensity: 0.5, metalness: 0.3, roughness: 0.4 });

 const redMat = new THREE.MeshStandardMaterial({ color: 0xff0000, transparent: true, opacity: 0.9, emissive: 0xff0000, emissiveIntensity: 0.5, metalness: 0.3, roughness: 0.4 });

 const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.9, emissive: 0xffffff, emissiveIntensity: 0.5, metalness: 0.3, roughness: 0.4 });

 

 // Add lights for 3D visibility

 const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);

 addressScene.add(ambientLight);

 const pointLight = new THREE.PointLight(0xffffff, 1.2, 100);

 pointLight.position.set(0, 0, 10);

 addressScene.add(pointLight);

 

 // Add additional lights for better visibility

 const pointLight2 = new THREE.PointLight(0xffffff, 0.8, 100);

 pointLight2.position.set(15, 15, 15);

 addressScene.add(pointLight2);

 

 const pointLight3 = new THREE.PointLight(0xffffff, 0.8, 100);

 pointLight3.position.set(-15, -15, -15);

 addressScene.add(pointLight3);

 

 // Grid configuration - Full 26x26x26 cube

 const gridSpacing = 2.5;

 const gridSize = { cols: 26, rows: 26, depth: 26 }; // Full cube: 17,576 positions (26x26x26)

 const gridPositions = [];

 

 // Pre-calculate all grid positions - TRULY centered around origin
 console.log('%c?? GRID SIZE VERIFIED: 26x26x26 ??', 'background: #0000ff; color: #fff; font-size: 16px; padding: 5px;');
 console.log('??? Building grid with:', gridSize);
 console.log('?? Expected total positions: 26 26 26 =', 26*26*26);

 for (let col = 0; col < gridSize.cols; col++) {

 for (let row = 0; row < gridSize.rows; row++) {

 for (let depth = 0; depth < gridSize.depth; depth++) {

 // Center calculation: use middle of range as origin

 const x = (col - (gridSize.cols - 1) / 2) * gridSpacing;

 const y = (row - (gridSize.rows - 1) / 2) * gridSpacing;

 const z = (depth - (gridSize.depth - 1) / 2) * gridSpacing * 1.0; // Equal spacing for cube shape

 

 gridPositions.push({

 col: col,

 row: row,

 depth: depth,

 x: x,

 y: y,

 z: z

 });

 }

 }

 }
 
 // Verify grid was generated correctly
 console.log('?? Grid generation complete:');
 console.log(' Config:', gridSize);
 console.log(' Total positions generated:', gridPositions.length);
 console.log(' Expected (26x26x26):', 26*26*26, '= 17,576');
 const depth0Count = gridPositions.filter(p => p.depth === 0).length;
 console.log(' Depth 0 positions:', depth0Count, 'Expected (26x26):', 26*26, '= 676');

 

 console.log('?? Grid bounds:');

 console.log(' X range:', (0 - gridSize.cols / 2 + 0.5) * gridSpacing, 'to', (gridSize.cols - 1 - gridSize.cols / 2 + 0.5) * gridSpacing);

 console.log(' Y range:', (0 - gridSize.rows / 2 + 0.5) * gridSpacing, 'to', (gridSize.rows - 1 - gridSize.rows / 2 + 0.5) * gridSpacing);

 console.log(' Z range: 0 to', (gridSize.depth - 1) * gridSpacing * 2.5);

 console.log('?? Sample positions:');

 console.log(' Corner (0,0,0):', gridPositions[0]);

 console.log(' Center (~10,6,7):', gridPositions[Math.floor(gridPositions.length / 2)]);

 console.log(' Far (19,11,14):', gridPositions[gridPositions.length - 1]);

 

 // Shuffle ONLY within each depth layer for organized appearance

 const layers = {};

 gridPositions.forEach(pos => {

 if (!layers[pos.depth]) layers[pos.depth] = [];

 layers[pos.depth].push(pos);

 });

 

 // Shuffle each layer

 Object.values(layers).forEach(layer => {

 for (let i = layer.length - 1; i > 0; i--) {

 const j = Math.floor(Math.random() * (i + 1));

 [layer[i], layer[j]] = [layer[j], layer[i]];

 }

 });

 

 // Rebuild gridPositions in depth order

 gridPositions.length = 0;

 for (let depth = 0; depth < gridSize.depth; depth++) {

 if (layers[depth]) {

 gridPositions.push(...layers[depth]);

 }

 }
 
 // Verify layer distribution after shuffle
 console.log('?? After shuffle:');
 console.log(' Total positions:', gridPositions.length);
 console.log(' Depth 0 count:', layers[0] ? layers[0].length : 0);
 if (layers[0]) {
 const d0Cols = [...new Set(layers[0].map(p => p.col))].sort((a,b) => a-b);
 const d0Rows = [...new Set(layers[0].map(p => p.row))].sort((a,b) => a-b);
 console.log(' Depth 0 unique columns:', d0Cols.length, 'Range:', d0Cols[0], 'to', d0Cols[d0Cols.length-1]);
 console.log(' Depth 0 unique rows:', d0Rows.length, 'Range:', d0Rows[0], 'to', d0Rows[d0Rows.length-1]);
 }

 

 const maxZ = (gridSize.depth - 1) * gridSpacing * 2.5;

 const centerZ = 0; // Grid is now centered at origin

 

 console.log('?? Grid setup:', gridSize, 'Total positions:', gridPositions.length);

 console.log('?? Grid centered at origin (0, 0, 0)');

 console.log('?? X range:', -(gridSize.cols - 1) / 2 * gridSpacing, 'to', (gridSize.cols - 1) / 2 * gridSpacing);

 console.log('?? Y range:', -(gridSize.rows - 1) / 2 * gridSpacing, 'to', (gridSize.rows - 1) / 2 * gridSpacing);

 console.log('?? Z range:', -maxZ / 2, 'to', maxZ / 2);

 

 // Add visual debug helpers

 const helpers = new THREE.Group();

 

 // Add axes helper at origin

 const axesHelper = new THREE.AxesHelper(30);

 helpers.add(axesHelper);

 

 // Add grid at z=0

 const gridHelper = new THREE.GridHelper(

 gridSize.cols * gridSpacing, 

 gridSize.cols, 

 0x00ff00, 

 0x004400

 );

 gridHelper.rotation.x = Math.PI / 2;

 helpers.add(gridHelper);

 

 // Add bounding box visualization - centered properly (CUBE shape with GREEN glow)

 const depthRange = (gridSize.depth - 1) * gridSpacing * 1.0; // Equal depth

 const boxGeo = new THREE.BoxGeometry(

 gridSize.cols * gridSpacing,

 gridSize.rows * gridSpacing,

 depthRange

 );

 const boxMat = new THREE.MeshBasicMaterial({ 

 color: 0x00ff00, // GREEN not cyan

 wireframe: true, 

 transparent: true, 

 opacity: 0.6 

 });

 const boundingBox = new THREE.Mesh(boxGeo, boxMat);

 boundingBox.position.set(0, 0, 0); // Centered at origin

 helpers.add(boundingBox);

 

 // Add markers at each depth layer

 for (let d = 0; d < gridSize.depth; d++) {

 const markerGeo = new THREE.PlaneGeometry(0.5, 0.5);

 const markerMat = new THREE.MeshBasicMaterial({ 

 color: d === 0 ? 0xff0000 : 0x00ff00, // GREEN markers

 transparent: true,

 opacity: 0.6

 });

 const marker = new THREE.Mesh(markerGeo, markerMat);

 const markerZ = (d - (gridSize.depth - 1) / 2) * gridSpacing * 1.0; // Match equal Z

 marker.position.set(

 -gridSize.cols * gridSpacing / 2 + 1,

 gridSize.rows * gridSpacing / 2 - 1,

 markerZ

 );

 helpers.add(marker);

 }

 

 // Start debug helpers hidden - they'll glitch in

 helpers.visible = false;

 addressScene.add(helpers);

 addressScene.userData.debugHelpers = helpers;

 

 let gridIndex = 0;

 

 // Spawn addresses gradually

 let spawnTimer = 0;

 const spawnInterval = 0.01; // Faster spawning for 26x26 grid

 

 const clock = new THREE.Clock();

 let sequenceTime = 0;
 
 // Expose sequenceTime globally for scene jumps
 window.addressSequenceTime = 0;

 let cameraRotating = false;

 

 // Camera will look at origin - grid is centered

 const gridCenter = new THREE.Vector3(0, 0, 0);

 const actualCenterX = 0;

 const actualCenterY = 0;

 const actualCenterZ = 0;

 

 // Position camera to see the ENTIRE grid PERFECTLY CENTERED

 // Grid is 26x26x26 cubes, spacing 2.5 = 65x65x65 units, centered at origin

 addressCamera.position.set(0, 0, -120); // Much further back to see full 26x26x26 cube

 addressCamera.lookAt(0, 0, 0); // Look directly at origin

 addressCamera.updateProjectionMatrix();

 

 console.log('?? Camera at (0, 0, -120) looking at origin (0, 0, 0)');

 console.log('?? Grid: 26x26x26, 65x65x65 units, centered at (0,0,0)');

 console.log('?? Camera FOV:', addressCamera.fov, 'Aspect:', addressCamera.aspect);

 console.log('?? Grid should be PERFECTLY CENTERED in view');

 

 // Chime function for cube burst

 function playChimeForCube(index) {

 if (!audioCtx) return;

 try {

 const osc = audioCtx.createOscillator();

 const gain = audioCtx.createGain();

 

 const baseFreq = 800;

 const freq = baseFreq + (index % 12) * 50;

 osc.frequency.value = freq;

 osc.type = 'sine';

 

 gain.gain.setValueAtTime(0.03, audioCtx.currentTime);

 gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);

 

 osc.connect(gain);

 gain.connect(audioCtx.destination);

 osc.start(audioCtx.currentTime);

 osc.stop(audioCtx.currentTime + 0.3);

 } catch (err) {

 // Silently fail if audio context not available

 }

 }

 

 function animateAddresses() {

 const delta = clock.getDelta();
 
 // Check if scene select requested a jump
 if (window.addressSequenceTime && window.addressSequenceTime > sequenceTime) {
 sequenceTime = window.addressSequenceTime;
 console.log('? Jumped to sequenceTime:', sequenceTime);
 }

 sequenceTime += delta;
 
 // Sync with global variable
 window.addressSequenceTime = sequenceTime;

 spawnTimer += delta;

 

 // Debug log every second with camera position

 if (Math.floor(sequenceTime) !== Math.floor(sequenceTime - delta)) {

 console.log(`?? ${sequenceTime.toFixed(1)}s | Addresses: ${addresses.length}, Cubes: ${cubes.length} | Cam: (${addressCamera.position.x.toFixed(1)}, ${addressCamera.position.y.toFixed(1)}, ${addressCamera.position.z.toFixed(1)})`);

 }

 

 // Fade debug helpers after 20s

 if (sequenceTime > 20 && addressScene.userData.debugHelpers) {

 addressScene.userData.debugHelpers.visible = false;

 }

 

 // Phase 1: Spawn 2D addresses on grid (0-10s) - Fill the 2D plane ONLY - Extended time for 26x26 grid

 if (sequenceTime < 10 && spawnTimer > spawnInterval) {

 spawnTimer = 0;

 

 // Spawn multiple addresses per frame for faster fill (26x26 = 676 addresses)
 for (let batchCount = 0; batchCount < 20; batchCount++) {

 // Find next depth=0 position

 while (gridIndex < gridPositions.length && gridPositions[gridIndex].depth !== 0) {

 gridIndex++;

 }

 

 if (gridIndex < gridPositions.length) {

 const pos = gridPositions[gridIndex];

 const sprite = createAddressSprite(pos.col, pos.row, 0, false);

 sprite.position.set(pos.x, pos.y, pos.z); // Use pos.z from grid calculation

 sprite.userData = { ...pos, isCube: false, gridX: pos.col, gridY: pos.row, gridZ: 0, depth: 0 };

 addressScene.add(sprite);

 addresses.push(sprite);

 

 if (addresses.length === 1) {

 console.log('? First 2D address spawned:', { x: pos.x.toFixed(2), y: pos.y.toFixed(2), z: pos.z.toFixed(2), text: `${String.fromCharCode(65 + pos.col)}${pos.row + 1}` });

 console.log('?? Camera is at:', addressCamera.position);

 console.log('?? Camera is looking at: (0, 0, 0)');

 }

 if (addresses.length <= 5) {

 console.log(`?? Address #${addresses.length} at (${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})`);

 }
 
 // Log when we reach milestones
 if (pos.col === 9 || pos.col === 19 || pos.col === 25) {
 console.log(`? Reached column ${String.fromCharCode(65 + pos.col)} (col ${pos.col}) - Address #${addresses.length}`);
 }
 
 // Log every 100 addresses with current range
 if (addresses.length % 100 === 0) {
 const currentCols = addresses.map(a => a.userData.col).filter(c => c !== undefined);
 const maxColSoFar = Math.max(...currentCols);
 console.log(`?? ${addresses.length} addresses | Max column so far: ${String.fromCharCode(65 + maxColSoFar)} (${maxColSoFar})`);
 }

 gridIndex++;

 } else {
 break; // No more depth=0 positions
 }
 }

 }
 
 // Log when 2D plane is complete
 if (sequenceTime >= 10 && sequenceTime < 10.1 && !addressScene.userData.plane2DComplete) {
 addressScene.userData.plane2DComplete = true;
 const maxCol = Math.max(...addresses.map(a => a.userData.col !== undefined ? a.userData.col : -1));
 const maxRow = Math.max(...addresses.map(a => a.userData.row !== undefined ? a.userData.row : -1));
 const minCol = Math.min(...addresses.map(a => a.userData.col !== undefined ? a.userData.col : 999));
 const minRow = Math.min(...addresses.map(a => a.userData.row !== undefined ? a.userData.row : 999));
 console.log(`? 2D Plane complete! ${addresses.length} addresses spawned`);
 console.log(`?? Column range: ${String.fromCharCode(65 + minCol)} (${minCol}) to ${String.fromCharCode(65 + maxCol)} (${maxCol})`);
 console.log(`?? Row range: ${minRow + 1} to ${maxRow + 1}`);
 console.log(`?? Expected: 676 addresses (26x26), Got: ${addresses.length}`);
 }

 

 // No rotation for addresses - they just float in place

 // (rotation removed per user request)

 

 // Phase 1.5: Static pause showing 2D grid (10-12s) with RUMBLE before expansion

 if (sequenceTime >= 10 && sequenceTime < 12) {

 if (!addressScene.userData.staticPauseStarted) {

 addressScene.userData.staticPauseStarted = true;

 console.log('?? Static pause - showing 2D grid, building tension');

 

 // Glitch in debug helpers

 let glitchCount = 0;

 const glitchInterval = setInterval(() => {

 if (addressScene.userData.debugHelpers) {

 addressScene.userData.debugHelpers.visible = !addressScene.userData.debugHelpers.visible;

 glitchCount++;

 if (glitchCount > 6) {

 addressScene.userData.debugHelpers.visible = true;

 clearInterval(glitchInterval);

 }

 }

 }, 100);

 }

 

 // RUMBLE effect BEFORE Z expansion (11-12s) - building anticipation

 if (sequenceTime >= 11 && sequenceTime < 12) {

 const rumbleIntensity = (sequenceTime - 11) * 1.2; // Stronger rumble

 addressCamera.position.x = Math.sin(sequenceTime * 25) * rumbleIntensity;

 addressCamera.position.y = Math.cos(sequenceTime * 20) * rumbleIntensity;

 addressCamera.position.z = -120;

 addressCamera.lookAt(0, 0, 0);

 

 if (!addressScene.userData.rumbleLogged) {

 console.log('?? RUMBLE starting - preparing for Z expansion!');

 addressScene.userData.rumbleLogged = true;

 }

 

 // Alpha character glitch - show Greek letters on 2D addresses during rumble

 if (!addressScene.userData.alphaGlitchStarted) {

 addressScene.userData.alphaGlitchStarted = true;

 console.log('? Alpha glitch starting - 2D addresses showing depth markers');

 

 addresses.forEach((addr, i) => {

 if (addr.userData.depth === 0 && !addr.userData.isGlitching) {

 addr.userData.isGlitching = true;

 addr.userData.originalTexture = addr.material.map;

 

 // Schedule random glitch times during rumble

 const glitchDelay = Math.random() * 800;

 setTimeout(() => {

 // Create temporary 3D label with Greek letter

 const canvas = document.createElement('canvas');

 const ctx = canvas.getContext('2d');

 canvas.width = 256;

 canvas.height = 128;

 

 ctx.fillStyle = '#00ff00';

 ctx.font = 'bold 48px "Courier New", monospace';

 ctx.textAlign = 'center';

 ctx.textBaseline = 'middle';

 

 const colLetter = String.fromCharCode(65 + (addr.userData.col % 26));

 const rowNum = addr.userData.row + 1;

 const randomDepth = Math.floor(Math.random() * gridSize.depth);

 const greekLetter = greekLetters[randomDepth % greekLetters.length];

 const glitchText = `${colLetter}${rowNum}${greekLetter}`;

 

 ctx.fillText(glitchText, 128, 64);

 

 const glitchTexture = new THREE.CanvasTexture(canvas);

 glitchTexture.needsUpdate = true;

 

 // Flash between original and glitch

 let flashCount = 0;

 const flashInterval = setInterval(() => {

 if (flashCount % 2 === 0) {

 addr.material.map = glitchTexture;

 } else {

 addr.material.map = addr.userData.originalTexture;

 }

 addr.material.needsUpdate = true;

 flashCount++;

 

 if (flashCount > 6) { // Flash 3 times

 clearInterval(flashInterval);

 addr.material.map = addr.userData.originalTexture;

 addr.material.needsUpdate = true;

 addr.userData.isGlitching = false;

 }

 }, 80);

 }, glitchDelay);

 }

 });

 }

 } else {

 // Keep camera centered during first part of pause

 addressCamera.position.set(0, 0, -80);

 addressCamera.lookAt(0, 0, 0);

 }

 }

 

 // Phase 2: Extend into 3D - add ALL depth layers (12-18s)

 if (sequenceTime >= 12 && sequenceTime < 18) {

 if (addressPhase === 0) {

 addressPhase = 1;

 

 // Create depth spawn queue - all positions with depth > 0

 addressScene.userData.depthQueue = gridPositions.filter(p => p.depth > 0);

 console.log('?? Extending to 3D - depth queue:', addressScene.userData.depthQueue.length, 'positions');

 console.log('?? Depth range:', Math.min(...addressScene.userData.depthQueue.map(p => p.depth)), 

 'to', Math.max(...addressScene.userData.depthQueue.map(p => p.depth)));

 }

 

 // Keep camera steady after rumble - Z expansion happens NOW

 addressCamera.position.set(0, 0, -120);

 addressCamera.lookAt(0, 0, 0);

 

 // Spawn ALL depth layers RAPIDLY to fill 3D space (multiple per frame)

 const spawnCount = Math.ceil((sequenceTime - 12) * 500); // Much faster spawn for 26x26x26 grid

 for (let i = 0; i < spawnCount && addressScene.userData.depthQueue && addressScene.userData.depthQueue.length > 0; i++) {

 const pos = addressScene.userData.depthQueue.shift();

 const sprite = createAddressSprite(pos.col, pos.row, pos.depth, true);

 sprite.position.set(pos.x, pos.y, pos.z); // Use actual Z position

 sprite.userData = { ...pos, isCube: false, gridX: pos.col, gridY: pos.row, gridZ: pos.depth };

 addressScene.add(sprite);

 addresses.push(sprite);

 

 if (addresses.length % 200 === 0) {

 console.log(`?? Total: ${addresses.length}, Latest: (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}) depth ${pos.depth}/${gridSize.depth - 1}`);

 }

 }

 }

 

 // Phase 2.5: Camera pulls back and rotates to reveal LATTICE CUBE (16-20s)

 if (sequenceTime >= 16 && sequenceTime < 20) {

 if (!addressScene.userData.rotationStarted) {

 addressScene.userData.rotationStarted = true;

 console.log('?? Starting camera rotation to reveal lattice cube');

 console.log('?? Total addresses in lattice:', addresses.length);

 }

 

 const rotProgress = (sequenceTime - 16) / 4;

 // Pull back further and orbit to reveal massive 26x26x26 lattice

 addressCamera.position.x = THREE.MathUtils.lerp(0, 70, rotProgress);

 addressCamera.position.y = THREE.MathUtils.lerp(0, 35, rotProgress);

 addressCamera.position.z = THREE.MathUtils.lerp(-120, -25, rotProgress);

 addressCamera.lookAt(0, 0, 0); // Always look at center

 }

 

 // Phase 3: Initialize organic infection system (20s)

 if (sequenceTime >= 20 && !cubePhase) {

 cubePhase = true;

 console.log('?? INFECTION SYSTEM: Starting organic cube transformation');

 

 // Create infection queue and grid lookup

 addressScene.userData.infectionQueue = [];

 addressScene.userData.infectedAddresses = new Set();

 addressScene.userData.addressMap = new Map();

 

 // Build address map for neighbor lookup

 addresses.forEach(addr => {

 const key = `${addr.userData.col},${addr.userData.row},${addr.userData.depth}`;

 addressScene.userData.addressMap.set(key, addr);

 });

 

 // Seed random infection points (about 3-5% of addresses)

 const seedCount = Math.floor(addresses.length * 0.04);

 const seeds = [];

 for (let i = 0; i < seedCount; i++) {

 const randomIndex = Math.floor(Math.random() * addresses.length);

 const addr = addresses[randomIndex];

 if (addr && !addressScene.userData.infectedAddresses.has(addr)) {

 seeds.push(addr);

 addressScene.userData.infectedAddresses.add(addr);

 addressScene.userData.infectionQueue.push({

 address: addr,

 infectionTime: sequenceTime + Math.random() * 0.5, // Stagger seeds slightly

 color: 'green', // Seeds start green

 sourceDirection: null

 });

 }

 }

 

 console.log(`?? Seeded ${seeds.length} infection points`);

 addressScene.userData.infectionSpeed = 0.03; // Time between infection spreads

 addressScene.userData.lastInfectionTime = sequenceTime;

 }

 

 // Execute POP transformations: Text ? GREEN cubes (20-24s)

 if (sequenceTime >= 20 && sequenceTime < 24) {

 for (let i = addresses.length - 1; i >= 0; i--) {

 const addr = addresses[i];

 

 if (addr.userData.popTime && sequenceTime >= addr.userData.popTime && !addr.userData.popped) {

 addr.userData.popped = true;

 

 // Create GREEN cube

 const mesh = new THREE.Mesh(cubeGeo, greenMat.clone());

 mesh.position.copy(addr.position);

 mesh.userData = { 

 ...addr.userData,

 isCube: true,

 isGreen: true,

 hasTransformed: false, // Not yet transformed to RGB

 currentColor: 'green',

 shapeType: 'cube',

 birthTime: sequenceTime

 };

 

 // Start small for pop effect

 mesh.scale.set(0.05, 0.05, 0.05);

 addressScene.add(mesh);

 cubes.push(mesh);

 

 // Play chime occasionally (not for every cube to avoid audio overload)

 if (cubes.length % 30 === 0) {

 playChimeForCube(cubes.length);

 }

 

 // Remove text address

 addressScene.remove(addr);

 addresses.splice(i, 1);

 }

 }

 }

 

 // CLEANUP: Force remove ALL remaining text addresses at 24s

 if (sequenceTime >= 24 && sequenceTime < 24.1 && addresses.length > 0) {

 console.log('??? CLEANUP: Removing', addresses.length, 'residual text addresses');

 for (let i = addresses.length - 1; i >= 0; i--) {

 addressScene.remove(addresses[i]);

 if (addresses[i].material && addresses[i].material.map) {

 addresses[i].material.map.dispose();

 }

 if (addresses[i].material) {

 addresses[i].material.dispose();

 }

 }

 addresses.length = 0; // Clear array

 console.log('? All text addresses cleared');

 }

 

 // Animate green cube pop-in with burst (20s-26s)

 if (sequenceTime >= 20 && sequenceTime < 26) {

 cubes.forEach((cube, i) => {

 if (!cube.userData.isGreen) return; // Only animate green cubes

 

 const age = sequenceTime - cube.userData.birthTime;

 

 // Quick pop-in animation (0-0.3s)

 if (age < 0.3) {

 // Burst scale: overshoot then settle

 const progress = age / 0.3;

 const overshoot = 1.3; // Peak size

 let targetScale;

 if (progress < 0.5) {

 targetScale = THREE.MathUtils.lerp(0.05, overshoot, progress * 2);

 } else {

 targetScale = THREE.MathUtils.lerp(overshoot, 1.0, (progress - 0.5) * 2);

 }

 cube.scale.setScalar(targetScale);

 

 // Bright burst illumination

 if (cube.material) {

 const intensity = Math.sin(progress * Math.PI) * 3.0;

 cube.material.emissiveIntensity = 0.5 + intensity;

 }

 } else if (age < 0.35 && cube.scale.x !== 1.0) {

 // Settle to final size

 cube.scale.setScalar(1.0);

 if (cube.material) {

 cube.material.emissiveIntensity = 0.5;

 }

 }

 });

 }

 

 // Phase 4: GREEN cubes glitch into RGB shapes (26s-30s)

 if (sequenceTime >= 26 && sequenceTime < 30) {

 cubes.forEach((cube, i) => {

 if (cube.userData.isGreen && !cube.userData.glitchStarted) {

 cube.userData.glitchStarted = true;

 cube.userData.glitchTime = sequenceTime + (i * 0.002); // Faster stagger glitches

 }

 

 if (cube.userData.glitchStarted && !cube.userData.hasTransformed && sequenceTime >= cube.userData.glitchTime) {

 cube.userData.hasTransformed = true;

 

 // Select shape and color based on pre-assigned targetShape

 let geo, mat, colorName, shapeName;

 if (cube.userData.targetShape === 0) {

 geo = pyramidGeo;

 mat = yellowMat.clone();

 colorName = 'yellow';

 shapeName = 'pyramid';

 } else if (cube.userData.targetShape === 1) {

 geo = cubeGeo;

 mat = blueMat.clone();

 colorName = 'blue';

 shapeName = 'cube';

 } else {

 geo = sphereGeo;

 mat = redMat.clone();

 colorName = 'red';

 shapeName = 'sphere';

 }

 

 // Replace mesh

 const pos = cube.position.clone();

 const userData = { ...cube.userData };

 

 addressScene.remove(cube);

 if (cube.geometry) cube.geometry.dispose();

 if (cube.material) cube.material.dispose();

 

 const newMesh = new THREE.Mesh(geo, mat);

 newMesh.position.copy(pos);

 newMesh.scale.set(1.0, 1.0, 1.0); // Always start at normal scale

 newMesh.userData = {

 ...userData,

 isGreen: false,

 currentColor: colorName,

 shapeType: shapeName,

 glitchTransformTime: sequenceTime

 };

 

 addressScene.add(newMesh);

 

 // Replace in cubes array

 const cubeIndex = cubes.indexOf(cube);

 if (cubeIndex !== -1) {

 cubes[cubeIndex] = newMesh;

 }

 }

 });

 }

 

 // Animate glitch transformation (26s-30s)

 if (sequenceTime >= 26 && sequenceTime < 30) {

 cubes.forEach((cube) => {

 if (cube.userData.glitchTransformTime) {

 const glitchAge = sequenceTime - cube.userData.glitchTransformTime;

 

 if (glitchAge < 0.2) {

 // Quick stretch/distort glitch

 const glitchProgress = glitchAge / 0.2;

 const distort = Math.sin(glitchProgress * Math.PI * 4) * 0.3;

 cube.scale.x = 1.0 + distort;

 cube.scale.y = 1.0 - distort * 0.5;

 cube.scale.z = 1.0 + distort * 0.5;

 

 // Flash emissive

 if (cube.material) {

 cube.material.emissiveIntensity = 0.5 + Math.sin(glitchProgress * Math.PI) * 2.0;

 }

 } else if (glitchAge < 0.25 && cube.scale.x !== 1.0) {

 // Snap to final shape

 cube.scale.set(1.0, 1.0, 1.0);

 if (cube.material) {

 cube.material.emissiveIntensity = 0.5;

 }

 }

 }

 });

 }

 

 // Draw dotted lines between RGB cubes (forming cube edges) ONCE (30s)

 if (sequenceTime >= 30 && !addressScene.userData.linesCreated) {

 addressScene.userData.linesCreated = true;

 addressScene.userData.connectionLines = [];

 console.log('?? Creating procedural connection lines...');

 

 // Build grid lookup for immediate neighbors

 const gridMap = new Map();

 cubes.forEach(cube => {

 if (cube.userData.gridX !== undefined) {

 const key = `${cube.userData.gridX},${cube.userData.gridY},${cube.userData.gridZ}`;

 gridMap.set(key, cube);

 }

 });

 

 // Track connections to avoid duplicates

 const connections = new Set();

 let lineCount = 0;

 

 // Draw lines to immediate neighbors for RGB cubes (ONCE)

 cubes.forEach(cube => {

 if (cube.userData.gridX !== undefined && cube.userData.currentColor && cube.userData.hasTransformed) {

 const gx = cube.userData.gridX;

 const gy = cube.userData.gridY;

 const gz = cube.userData.gridZ;

 

 // Check only positive direction neighbors to avoid duplicates (right, up, forward)

 const neighbors = [

 { key: `${gx+1},${gy},${gz}`, axis: 'x' },

 { key: `${gx},${gy+1},${gz}`, axis: 'y' },

 { key: `${gx},${gy},${gz+1}`, axis: 'z' }

 ];

 

 neighbors.forEach(neighbor => {

 const neighborCube = gridMap.get(neighbor.key);

 if (neighborCube && neighborCube.userData.currentColor && neighborCube.userData.hasTransformed) {

 const connectionKey = `${cube.userData.gridX},${cube.userData.gridY},${cube.userData.gridZ}-${neighborCube.userData.gridX},${neighborCube.userData.gridY},${neighborCube.userData.gridZ}`;

 if (!connections.has(connectionKey)) {

 connections.add(connectionKey);

 

 // Use average color of both cubes

 let lineColor;

 if (cube.userData.currentColor === 'yellow') lineColor = 0xffff00;

 else if (cube.userData.currentColor === 'blue') lineColor = 0x0088ff;

 else if (cube.userData.currentColor === 'red') lineColor = 0xff0000;

 else lineColor = 0x00ff00;

 

 const points = [cube.position, neighborCube.position];

 const lineGeo = new THREE.BufferGeometry().setFromPoints(points);

 const lineMat = new THREE.LineDashedMaterial({

 color: lineColor,

 dashSize: 0.12,

 gapSize: 0.08,

 transparent: true,

 opacity: 0.5

 });

 const line = new THREE.Line(lineGeo, lineMat);

 line.computeLineDistances();

 addressScene.add(line);

 addressScene.userData.connectionLines.push(line);

 lineCount++;

 }

 }

 });

 }

 });

 console.log(`? Created ${lineCount} connection lines (procedural, once)`);

 }

 

 // Continue camera rotation after initial rotation (but stop during white room)

 if (sequenceTime >= 20 && sequenceTime < 50) {

 const orbitTime = sequenceTime - 20;

 const orbitRadius = 90; // Much larger radius for massive 26x26x26 cube

 addressCamera.position.x = Math.cos(orbitTime * 0.15) * orbitRadius;

 addressCamera.position.z = Math.sin(orbitTime * 0.15) * orbitRadius;

 addressCamera.position.y = 15 + Math.sin(orbitTime * 0.08) * 8; // Higher orbit

 addressCamera.lookAt(0, 0, 0);

 }

 

 // Apply mouse look in white room

 if (isMouseLookActive && sequenceTime > 55) {

 // Apply rotation to camera

 const direction = new THREE.Vector3();

 direction.x = Math.sin(targetRotationY) * Math.cos(targetRotationX);

 direction.y = Math.sin(targetRotationX);

 direction.z = Math.cos(targetRotationY) * Math.cos(targetRotationX);

 direction.normalize();

 

 const lookAtPoint = new THREE.Vector3().addVectors(

 addressCamera.position,

 direction.multiplyScalar(10)

 );

 addressCamera.lookAt(lookAtPoint);

 

 if (Math.floor(sequenceTime) % 3 === 0 && Math.floor(sequenceTime) !== Math.floor(sequenceTime - delta)) {

 console.log(`??? Mouse look active - rotX: ${targetRotationX.toFixed(2)}, rotY: ${targetRotationY.toFixed(2)}`);

 }

 } else if (sequenceTime >= 55 && !isMouseLookActive) {

 // Point at black hole when not actively looking

 addressCamera.lookAt(0, 0, 0);

 }

 

 // Phase 5: Transform RGB shapes back to white cubes (36-40s)

 if (sequenceTime >= 36 && sequenceTime < 40) {

 cubes.forEach((cube, i) => {

 if (cube.userData.hasTransformed && !cube.userData.zapToWhite) {

 cube.userData.zapToWhite = true;

 

 // Quick zap animation

 const originalScale = { x: cube.scale.x, y: cube.scale.y, z: cube.scale.z };

 cube.scale.multiplyScalar(1.5);

 

 setTimeout(() => {

 const pos = cube.position.clone();

 const userData = { ...cube.userData };

 

 addressScene.remove(cube);

 const whiteCube = new THREE.Mesh(cubeGeo, whiteMat.clone());

 whiteCube.position.copy(pos);

 whiteCube.scale.set(originalScale.x, originalScale.y, originalScale.z);

 whiteCube.userData = userData;

 whiteCube.userData.isWhite = true;

 addressScene.add(whiteCube);

 cubes[i] = whiteCube;

 }, 100);

 }

 });

 }

 

 // Phase 6: Collapse cubes to center - NO rotation

 if (sequenceTime >= 40 && sequenceTime < 44) {

 const pullStrength = (sequenceTime - 40) / 4;

 cubes.forEach(cube => {

 cube.position.x = THREE.MathUtils.lerp(cube.position.x, 0, delta * pullStrength * 2);

 cube.position.y = THREE.MathUtils.lerp(cube.position.y, 0, delta * pullStrength * 2);

 cube.position.z = THREE.MathUtils.lerp(cube.position.z, 0, delta * pullStrength * 2);

 });

 }

 

 // Phase 7: Merge into single white rounded cube with bloom (44-50s)

 if (sequenceTime >= 44 && sequenceTime < 50) {

 const whiteness = Math.min(1, (sequenceTime - 44) / 3);

 addressBloom.strength = 1.2 + whiteness * 2.5; // Increase bloom more

 

 cubes.forEach((cube, i) => {

 if (cube.material) {

 // Fade to white

 cube.material.color.r = 1;

 cube.material.color.g = 1;

 cube.material.color.b = 1;

 cube.material.emissive.r = 1;

 cube.material.emissive.g = 1;

 cube.material.emissive.b = 1;

 cube.material.emissiveIntensity = 0.5 + whiteness * 1.0;

 

 // Shrink all but the center mass

 if (i > 15) {

 cube.scale.multiplyScalar(0.96);

 cube.material.opacity *= 0.95;

 } else {

 // First cubes grow MUCH LARGER

 const growth = 1 + (sequenceTime - 44) * 0.8;

 cube.scale.setScalar(growth);

 }

 }

 });

 }

 

 // Phase 8: Expand into white room interior (50-55s)

 if (sequenceTime >= 50 && sequenceTime < 55) {

 if (!addressScene.userData.roomCreated) {

 addressScene.userData.roomCreated = true;

 console.log('?? Creating FPS white room interior with rounded corners and internal lighting');

 

 // Remove all connection lines

 if (addressScene.userData.connectionLines) {

 addressScene.userData.connectionLines.forEach(line => {

 addressScene.remove(line);

 if (line.geometry) line.geometry.dispose();

 if (line.material) line.material.dispose();

 });

 addressScene.userData.connectionLines = [];

 console.log('??? Connection lines removed for white room');

 }

 

 addressScene.userData.blackCubeSpawnTimer = 0;

 addressScene.userData.blackCubes = [];

 

 // Create white room interior with rounded corners - DIMLY LIT

 const roomSize = 50;

 const roomRadius = 4;

 const roomGeo = new RoundedBoxGeometry(roomSize, roomSize, roomSize, 16, roomRadius);

 const roomMat = new THREE.MeshStandardMaterial({

 color: 0xcccccc, // Slightly gray

 side: THREE.BackSide,

 roughness: 0.9,

 metalness: 0.05,

 emissive: 0x333333, // Very dim emissive

 emissiveIntensity: 0.05 // Very low

 });

 const room = new THREE.Mesh(roomGeo, roomMat);

 addressScene.add(room);

 addressScene.userData.roomMesh = room; // Store reference

 

 // Add MINIMAL internal room lighting - mostly dark

 const roomLight1 = new THREE.PointLight(0xffffff, 0.2, 40);

 roomLight1.position.set(0, 15, 0);

 addressScene.add(roomLight1);

 

 const roomLight2 = new THREE.PointLight(0xffffff, 0.2, 40);

 roomLight2.position.set(0, -15, 0);

 addressScene.add(roomLight2);

 

 console.log('? White room created with DIM lighting');

 

 // Further reduce ambient lighting to let black hole dominate

 ambientLight.intensity = 0.1;

 pointLight.intensity = 0.1;

 pointLight2.intensity = 0.2;

 pointLight3.intensity = 0.2;

 

 console.log('?? Room created - dimming ambient lights for black hole visibility');

 

 console.log('? White room created with internal lighting');

 }

 

 // Move camera inside - FPS position, initially pointing AT the black hole

 if (!addressScene.userData.cameraMovingToRoom) {

 addressScene.userData.cameraMovingToRoom = true;

 console.log('?? Camera moving into white room, will point at black hole at (0, 0, 0)');

 }

 

 const moveProgress = (sequenceTime - 50) / 5;

 addressCamera.position.x = THREE.MathUtils.lerp(12, 0, moveProgress);

 addressCamera.position.y = THREE.MathUtils.lerp(10, 2, moveProgress);

 addressCamera.position.z = THREE.MathUtils.lerp(20, 15, moveProgress);

 

 // Always point at black hole center during this phase

 addressCamera.lookAt(0, 0, 0);

 

 if (Math.floor(sequenceTime) % 2 === 0 && Math.floor(sequenceTime) !== Math.floor(sequenceTime - delta)) {

 console.log(`?? Camera pos: (${addressCamera.position.x.toFixed(1)}, ${addressCamera.position.y.toFixed(1)}, ${addressCamera.position.z.toFixed(1)}) -> looking at (0, 0, 0)`);

 }

 

 addressScene.userData.whiteRoomCreated = true;

 }

 

 // Phase 9: Create 3D black hole at center (55s+)

 if (sequenceTime >= 55 && !addressScene.userData.blackHoleCreated) {

 addressScene.userData.blackHoleCreated = true;

 console.log('??? Creating 3D black hole sphere at center');

 

 // Voxelized black hole - dark cube sphere (MORE visible)

 const voxelSize = 0.4;

 const voxelGeo = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);

 const blackVoxelMat = new THREE.MeshStandardMaterial({

 color: 0x222222, // More visible gray

 emissive: 0x110000, // Slight red emissive

 emissiveIntensity: 0.3,

 roughness: 0.9,

 metalness: 0.1,

 transparent: false

 });

 

 const voxelSphere = new THREE.Group();

 const baseRadius = 3.0; // Larger

 const voxelCount = 400; // More voxels

 

 for (let i = 0; i < voxelCount; i++) {

 const phi = Math.acos(-1 + (2 * i) / voxelCount);

 const theta = Math.sqrt(voxelCount * Math.PI) * phi;

 

 const x = baseRadius * Math.cos(theta) * Math.sin(phi);

 const y = baseRadius * Math.sin(theta) * Math.sin(phi);

 const z = baseRadius * Math.cos(phi);

 

 const voxel = new THREE.Mesh(voxelGeo, blackVoxelMat.clone());

 voxel.position.set(x, y, z);

 voxel.lookAt(0, 0, 0);

 voxel.userData.baseRadius = baseRadius;

 voxel.userData.phi = phi;

 voxel.userData.theta = theta;

 voxelSphere.add(voxel);

 }

 

 addressScene.add(voxelSphere);

 addressScene.userData.voxelSphere = voxelSphere;

 addressScene.userData.voxelSpherePhase = 0;

 

 // Event horizon glow - EXTREMELY bright ring

 const ringGeo = new THREE.TorusGeometry(4.0, 0.5, 16, 100);

 const ringMat = new THREE.MeshBasicMaterial({

 color: 0xff4400,

 transparent: false,

 opacity: 1.0

 });

 const eventHorizon = new THREE.Mesh(ringGeo, ringMat);

 eventHorizon.position.set(0, 0, 0);

 eventHorizon.rotation.x = Math.PI / 2;

 addressScene.add(eventHorizon);

 addressScene.userData.eventHorizon = eventHorizon;

 

 // Add VERY strong point lights at black hole for maximum visibility

 const blackHoleLight1 = new THREE.PointLight(0xff2200, 10.0, 30);

 blackHoleLight1.position.set(0, 0, 0);

 addressScene.add(blackHoleLight1);

 

 const blackHoleLight2 = new THREE.PointLight(0xff6600, 8.0, 25);

 blackHoleLight2.position.set(0, 5, 0);

 addressScene.add(blackHoleLight2);

 

 const blackHoleLight3 = new THREE.PointLight(0xff8800, 6.0, 20);

 blackHoleLight3.position.set(5, 0, 0);

 addressScene.add(blackHoleLight3);

 

 addressScene.userData.blackHoleLight = blackHoleLight1;

 

 console.log('??? Black hole created at (0, 0, 0)');

 console.log('??? Black hole lights: L1=' + blackHoleLight1.intensity + ', L2=' + blackHoleLight2.intensity + ', L3=' + blackHoleLight3.intensity);

 console.log('??? Ambient light:', ambientLight.intensity);

 

 // BLACK CORE - Central black voxel sphere with negative pulsing effect

 const blackCoreGeo = new THREE.BoxGeometry(0.25, 0.25, 0.25);

 const blackCoreMat = new THREE.MeshBasicMaterial({

 color: 0x000000,

 transparent: true,

 opacity: 1.0

 });

 

 const blackCore = new THREE.Group();

 const coreRadius = 1.5; // Smaller than outer sphere

 const coreVoxelCount = 200;

 

 for (let i = 0; i < coreVoxelCount; i++) {

 const phi = Math.acos(-1 + (2 * i) / coreVoxelCount);

 const theta = Math.sqrt(coreVoxelCount * Math.PI) * phi;

 

 const x = coreRadius * Math.cos(theta) * Math.sin(phi);

 const y = coreRadius * Math.sin(theta) * Math.sin(phi);

 const z = coreRadius * Math.cos(phi);

 

 const voxel = new THREE.Mesh(blackCoreGeo, blackCoreMat.clone());

 voxel.position.set(x, y, z);

 voxel.lookAt(0, 0, 0);

 voxel.userData.baseRadius = coreRadius;

 voxel.userData.phi = phi;

 voxel.userData.theta = theta;

 voxel.renderOrder = 2000; // Individual voxels render on top

 voxel.material.depthTest = false; // Always visible

 voxel.material.depthWrite = false;

 blackCore.add(voxel);

 }

 

 blackCore.renderOrder = 2000; // Render on top of everything

 addressScene.add(blackCore);

 addressScene.userData.blackCore = blackCore;

 console.log('??? Black core created with renderOrder=2000, depthTest=false');

 addressScene.userData.blackCorePhase = 0;

 addressScene.userData.blackCorePulse = 0;

 

 console.log('?? Black core sphere created with', coreVoxelCount, 'voxels');

 console.log('? Voxelized black hole created');

 console.log('?? Outer voxel count:', voxelSphere.children.length);

 console.log('?? Core voxel count:', blackCore.children.length);

 console.log('?? Event horizon position:', eventHorizon.position);

 console.log('?? Black hole light intensity:', blackHoleLight1.intensity);

 

 // Accretion disk particles

 const particleCount = 200;

 const particleGeo = new THREE.BufferGeometry();

 const positions = new Float32Array(particleCount * 3);

 const colors = new Float32Array(particleCount * 3);

 

 for (let i = 0; i < particleCount; i++) {

 const angle = Math.random() * Math.PI * 2;

 const radius = 4 + Math.random() * 3;

 positions[i * 3] = Math.cos(angle) * radius;

 positions[i * 3 + 1] = (Math.random() - 0.5) * 0.5;

 positions[i * 3 + 2] = Math.sin(angle) * radius;

 

 const heat = 1 - (radius - 4) / 3;

 colors[i * 3] = 1;

 colors[i * 3 + 1] = heat * 0.6;

 colors[i * 3 + 2] = heat * 0.2;

 }

 

 particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));

 particleGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

 

 const particleMat = new THREE.PointsMaterial({

 size: 0.35,

 vertexColors: true,

 transparent: true,

 opacity: 1.0,

 blending: THREE.AdditiveBlending,

 sizeAttenuation: true,

 depthWrite: false

 });

 

 const particles = new THREE.Points(particleGeo, particleMat);

 addressScene.add(particles);

 addressScene.userData.accretionDisk = particles;

 console.log('? Accretion disk particles added to scene');

 

 console.log('? Black hole with accretion disk created');

 console.log('?? Scene objects:', addressScene.children.length);

 }

 

 // Breathing voxelized black hole (outer sphere)

 if (addressScene.userData.voxelSphere) {

 addressScene.userData.voxelSpherePhase += delta * 2;

 const breathe = Math.sin(addressScene.userData.voxelSpherePhase) * 0.2 + 1;

 

 addressScene.userData.voxelSphere.children.forEach(voxel => {

 const br = voxel.userData.baseRadius;

 const phi = voxel.userData.phi;

 const theta = voxel.userData.theta;

 const radius = br * breathe;

 

 voxel.position.x = radius * Math.cos(theta) * Math.sin(phi);

 voxel.position.y = radius * Math.sin(theta) * Math.sin(phi);

 voxel.position.z = radius * Math.cos(phi);

 });

 

 addressScene.userData.voxelSphere.rotation.y += delta * 0.2;

 

 // PULSATING BLOOM - lights breathe with black hole to illuminate room

 if (addressScene.userData.blackHoleLight) {

 const lightPulse = breathe; // Follow breathing pattern

 addressScene.userData.blackHoleLight.intensity = 8.0 + lightPulse * 6.0; // 8-14 intensity

 addressBloom.strength = 0.6 + lightPulse * 0.4; // 0.6-1.0 bloom

 

 // Illuminate room walls with pulsating bloom

 if (addressScene.userData.roomMesh && addressScene.userData.roomMesh.material) {

 addressScene.userData.roomMesh.material.emissiveIntensity = 0.05 + lightPulse * 0.08; // Subtle pulse

 }

 }

 

 // Debug log every 5 seconds

 if (Math.floor(sequenceTime) % 5 === 0 && Math.floor(sequenceTime) !== Math.floor(sequenceTime - delta)) {

 console.log(`??? Black hole visible: voxels=${addressScene.userData.voxelSphere.children.length}, breathe=${breathe.toFixed(2)}, bloom=${addressBloom.strength.toFixed(2)}`);

 }

 }

 

 // Pulsing BLACK CORE - inverse pulse with negative black-light gradient

 if (addressScene.userData.blackCore) {

 addressScene.userData.blackCorePhase += delta * 3; // Faster pulse

 addressScene.userData.blackCorePulse += delta * 4;

 

 // Inverse pulse - contracts when outer breathes out

 const corePulse = Math.sin(addressScene.userData.blackCorePhase) * -0.15 + 0.85; // 0.7 to 1.0

 

 addressScene.userData.blackCore.children.forEach((voxel, i) => {

 const br = voxel.userData.baseRadius;

 const phi = voxel.userData.phi;

 const theta = voxel.userData.theta;

 const radius = br * corePulse;

 

 voxel.position.x = radius * Math.cos(theta) * Math.sin(phi);

 voxel.position.y = radius * Math.sin(theta) * Math.sin(phi);

 voxel.position.z = radius * Math.cos(phi);

 

 // Pulsing opacity creating "negative light" effect

 const wave = Math.sin(addressScene.userData.blackCorePulse + i * 0.1);

 const distFromCenter = Math.sqrt(voxel.position.x**2 + voxel.position.y**2 + voxel.position.z**2);

 const normalizedDist = distFromCenter / (br * corePulse); // 0 at center, 1 at edge

 

 // Darker at center, lighter at edges (inverted gradient)

 voxel.material.opacity = 0.9 + (normalizedDist * 0.1) + (wave * 0.05);

 });

 

 // Counter-rotate to outer sphere

 addressScene.userData.blackCore.rotation.y -= delta * 0.3;

 }

 

 if (addressScene.userData.eventHorizon) {

 addressScene.userData.eventHorizon.rotation.z += delta * 0.8;

 }

 if (addressScene.userData.accretionDisk) {

 addressScene.userData.accretionDisk.rotation.y += delta * 0.5;

 }

 

 // Continuously spawn black cubes

 if (sequenceTime > 55) {

 if (!addressScene.userData.blackCubeSpawnTimer) {

 addressScene.userData.blackCubeSpawnTimer = 0;

 addressScene.userData.blackCubes = [];

 }

 

 addressScene.userData.blackCubeSpawnTimer += delta;

 if (addressScene.userData.blackCubeSpawnTimer > 0.15) {

 addressScene.userData.blackCubeSpawnTimer = 0;

 

 // Spawn new black cube far away

 const angle = Math.random() * Math.PI * 2;

 const elevation = (Math.random() - 0.5) * Math.PI;

 const distance = 30 + Math.random() * 15;

 

 const blackCubeMat = new THREE.MeshStandardMaterial({

 color: 0x0a0a0a,

 transparent: true,

 opacity: 0.95,

 emissive: 0x0a0a0a,

 emissiveIntensity: 0.1

 });

 

 const blackCube = new THREE.Mesh(cubeGeo, blackCubeMat);

 blackCube.position.set(

 Math.cos(angle) * Math.cos(elevation) * distance,

 Math.sin(elevation) * distance,

 Math.sin(angle) * Math.cos(elevation) * distance

 );

 blackCube.userData.beingSucked = true;

 blackCube.userData.suckStartTime = sequenceTime;

 blackCube.userData.spiralAngle = angle;

 blackCube.userData.spiralSpeed = 1.0 + Math.random() * 2.0;

 blackCube.scale.set(0.6, 0.6, 0.6);

 

 addressScene.add(blackCube);

 addressScene.userData.blackCubes.push(blackCube);

 }

 }

 

 // Spaghettification - black cubes get sucked into black hole

 if (addressScene.userData.blackCubes && addressScene.userData.blackCubes.length > 0) {

 const blackCubes = addressScene.userData.blackCubes;

 for (let i = blackCubes.length - 1; i >= 0; i--) {

 const cube = blackCubes[i];

 const elapsed = sequenceTime - cube.userData.suckStartTime;

 const distToCenter = Math.sqrt(

 cube.position.x ** 2 + 

 cube.position.y ** 2 + 

 cube.position.z ** 2

 );

 

 // Acceleration toward center - increasing speed

 const acceleration = 1 + elapsed * 1.2;

 const pullForce = delta * acceleration * 10;

 

 // Spiral motion

 cube.userData.spiralAngle += delta * cube.userData.spiralSpeed * (1 + elapsed * 0.8);

 const spiralRadius = Math.max(0.1, distToCenter * 0.15);

 const spiralX = Math.cos(cube.userData.spiralAngle) * spiralRadius;

 const spiralZ = Math.sin(cube.userData.spiralAngle) * spiralRadius;

 

 // Pull toward center with spiral

 cube.position.x = THREE.MathUtils.lerp(cube.position.x, spiralX, pullForce);

 cube.position.y = THREE.MathUtils.lerp(cube.position.y, 0, pullForce * 0.95);

 cube.position.z = THREE.MathUtils.lerp(cube.position.z, spiralZ, pullForce);

 

 // Spaghettification stretch - extreme elongation

 if (distToCenter < 10) {

 const stretchFactor = 1 + (10 - distToCenter) * 0.5;

 cube.scale.y = 0.6 * stretchFactor;

 cube.scale.x = Math.max(0.03, 0.6 / Math.sqrt(stretchFactor));

 cube.scale.z = Math.max(0.03, 0.6 / Math.sqrt(stretchFactor));

 

 // Orient along spiral toward center

 const targetPos = new THREE.Vector3(spiralX, 0, spiralZ);

 cube.lookAt(targetPos);

 }

 

 // Event horizon burst - tri-chromatic light explosion

 if (distToCenter < 4.0 && !cube.userData.hasBurst) {

 cube.userData.hasBurst = true;

 console.log('?? Tri-chromatic burst at event horizon!');

 

 // Create tri-chromatic light burst

 const colors = [

 { hex: 0xff0000, name: 'red' },

 { hex: 0x00ff00, name: 'green' },

 { hex: 0x0000ff, name: 'blue' }

 ];

 colors.forEach((colorData, idx) => {

 const lightGeo = new THREE.SphereGeometry(0.3, 16, 16);

 const lightMat = new THREE.MeshBasicMaterial({

 color: colorData.hex,

 transparent: true,

 opacity: 1

 });

 const light = new THREE.Mesh(lightGeo, lightMat);

 light.position.copy(cube.position);

 

 const angle = (idx / 3) * Math.PI * 2 + Math.random() * 0.5;

 const speed = 3 + Math.random() * 2;

 light.userData.velocity = new THREE.Vector3(

 Math.cos(angle) * speed,

 (Math.random() - 0.5) * speed * 0.8,

 Math.sin(angle) * speed

 );

 light.userData.life = 1.0;

 light.userData.colorName = colorData.name;

 

 addressScene.add(light);

 if (!addressScene.userData.lightBursts) {

 addressScene.userData.lightBursts = [];

 }

 addressScene.userData.lightBursts.push(light);

 });

 }

 

 // Remove if too close to center

 if (distToCenter < 0.5) {

 addressScene.remove(cube);

 blackCubes.splice(i, 1);

 }

 }

 }

 

 // Animate light bursts - expand and fade

 if (addressScene.userData.lightBursts) {

 for (let i = addressScene.userData.lightBursts.length - 1; i >= 0; i--) {

 const light = addressScene.userData.lightBursts[i];

 light.position.add(light.userData.velocity.clone().multiplyScalar(delta));

 light.userData.life -= delta * 0.4;

 light.material.opacity = light.userData.life;

 light.scale.multiplyScalar(1 + delta * 3);

 

 if (light.userData.life <= 0) {

 addressScene.remove(light);

 addressScene.userData.lightBursts.splice(i, 1);

 }

 }

 }

 

 // Render the scene

 addressComposer.render();

 

 // Continue indefinitely to keep rendering the room and black hole

 requestAnimationFrame(animateAddresses);

 }

 

 console.log('?? Starting animation loop');

 console.log('?? Camera position:', addressCamera.position);

 console.log('?? Scene children:', addressScene.children.length);

 animateAddresses();

 }

 

 function triggerVictory(frame) {

 console.log('?? VICTORY!');

 if (!frame) return;



 // Set madness flag

 madnessActivated = true;

 rPromptHoverCount = 0; // Reset for "Don't click" messages



 // HALT R sequence completely - stop matrix and speech

 rInfectionHalted = true;

 speechRActive = false;

 rInfectionProcessing = false;

 rInfectionStarted = false;

 

 // Stop all matrix intervals and timers

 if (matrixInterval) {

 clearInterval(matrixInterval);

 matrixInterval = null;

 }

 if (matrixUpdateInterval) {

 clearInterval(matrixUpdateInterval);

 matrixUpdateInterval = null;

 }

 if (matrixAnimationFrameId) {

 cancelAnimationFrame(matrixAnimationFrameId);

 matrixAnimationFrameId = null;

 }

 if (cascadeInterval) {

 clearInterval(cascadeInterval);

 cascadeInterval = null;

 }

 if (matrixHeavyTimers && matrixHeavyTimers.length) {

 matrixHeavyTimers.forEach(id => clearTimeout(id));

 matrixHeavyTimers = [];

 }

 

 // Remove matrix container and R hint

 const matrixContainer = document.getElementById('matrixContainer');

 if (matrixContainer) {

 matrixContainer.remove();

 }

 const rHint = document.getElementById('rHint');

 if (rHint) {

 rHint.remove();

 }

 

 // Stop R text-to-speech immediately

 if (speechRTimeout) {

 clearTimeout(speechRTimeout);

 speechRTimeout = null;

 }

 if (speechRGuardTimeout) {

 clearTimeout(speechRGuardTimeout);

 speechRGuardTimeout = null;

 }

 if (hasSpeechSynthesis) {

 try { window.speechSynthesis.cancel(); } catch (err) {}

 }

 console.log('?? HALTED R sequence (matrix + speech)');



 // Play "Oh." text-to-speech

 setTimeout(() => {

 if (hasSpeechSynthesis && speechRVoice) {

 const ohUtterance = new SpeechSynthesisUtterance('Oh.');

 ohUtterance.voice = speechRVoice;

 ohUtterance.rate = 0.9;

 ohUtterance.pitch = 1.0;

 ohUtterance.volume = 0.92;

 window.speechSynthesis.speak(ohUtterance);

 console.log('??? Playing "Oh." TTS');

 }

 }, 300);



 const existing = document.getElementById('initializeOverlay');

 if (existing) existing.remove();



 const overlay = document.createElement('div');

 overlay.id = 'initializeOverlay';

 overlay.style.cssText = 'position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none; z-index:60;';



 const panel = document.createElement('div');

 panel.style.cssText = 'pointer-events:auto; text-align:center; background:rgba(0,0,0,0.88); border:2px solid #0f0; padding:26px 34px; box-shadow:0 0 18px rgba(0,255,160,0.25); font-family:"Courier New", monospace; color:#0f0; min-width:260px;';



 const heading = document.createElement('div');

 heading.textContent = 'madness.loom located';

 heading.style.cssText = 'font-size:13px; letter-spacing:0.14em; text-transform:uppercase; margin-bottom:14px;';



 const button = document.createElement('button');

 button.textContent = 'INITIALIZE ?';

 button.style.cssText = 'font-family:"Courier New", monospace; font-size:15px; letter-spacing:0.38em; padding:16px 34px; color:#072c07; background:#19ff6b; border:2px solid #19ff6b; cursor:pointer; text-transform:uppercase; box-shadow:0 0 18px rgba(25,255,107,0.45); transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease, color 0.2s ease; pointer-events:auto;';



 button.addEventListener('mouseenter', () => {

 if (button.disabled) return;

 button.style.boxShadow = '0 0 24px rgba(25,255,140,0.55)';

 button.style.transform = 'translateY(-2px)';

 });

 button.addEventListener('mouseleave', () => {

 if (button.disabled) return;

 button.style.boxShadow = '0 0 18px rgba(25,255,107,0.45)';

 button.style.transform = 'translateY(0)';

 });



 const status = document.createElement('div');

 const phases = ['calibrate interface', 'prime uplink', 'commence breach'];

 status.style.cssText = 'margin-top:12px; font-size:12px; letter-spacing:0.2em; text-transform:uppercase; opacity:0.75;';

 status.textContent = phases[0];



 panel.appendChild(heading);

 panel.appendChild(button);

 panel.appendChild(status);

 overlay.appendChild(panel);

 frame.appendChild(overlay);



 const visiCalc = document.getElementById('visicalc');

 const stageClasses = ['barrel-stage-1', 'barrel-stage-2', 'barrel-stage-3'];

 let clickCount = 0;



 function applyDistortion(stageIndex) {

 if (!visiCalc) return;

 visiCalc.classList.remove('screen-shatter');

 stageClasses.forEach(cls => visiCalc.classList.remove(cls));

 void visiCalc.offsetWidth;

 visiCalc.classList.add(stageClasses[stageIndex]);

 }

 

 function triggerMatrixIntensification(intensity) {

 console.log('?? Matrix intensification level:', intensity);

 

 // Create or intensify matrix rain

 let matrixContainer = document.getElementById('matrixIntensityOverlay');

 if (!matrixContainer) {

 matrixContainer = document.createElement('div');

 matrixContainer.id = 'matrixIntensityOverlay';

 matrixContainer.style.cssText = 'position:fixed; inset:0; pointer-events:none; z-index:65; overflow:hidden;';

 document.body.appendChild(matrixContainer);

 }

 

 // Clear existing columns

 matrixContainer.innerHTML = '';

 

 // Number of columns increases with intensity

 const columnCount = 40 + (intensity * 25); // More columns

 const duration = 2.5 + (intensity * 0.5); // Longer duration: 3-4s

 const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%&*+=';

 

 for (let i = 0; i < columnCount; i++) {

 const column = document.createElement('div');

 column.style.cssText = `

 position:absolute;

 top:${-100 - Math.random() * 100}%;

 left:${Math.random() * 100}%;

 font-family:'Courier New', monospace;

 font-size:${14 + Math.random() * 10}px;

 color:#0f0;

 text-shadow:0 0 ${6 + intensity * 6}px #0f0, 0 0 ${3 + intensity * 3}px #0f0;

 opacity:${0.65 + intensity * 0.12};

 white-space:nowrap;

 animation: matrixFall ${duration}s linear forwards;

 `;

 

 // Create falling text

 let text = '';

 const length = 10 + Math.floor(Math.random() * 15);

 for (let j = 0; j < length; j++) {

 text += characters[Math.floor(Math.random() * characters.length)] + '<br>';

 }

 column.innerHTML = text;

 matrixContainer.appendChild(column);

 }

 

 // Add CSS animation if not already defined

 if (!document.getElementById('matrixIntensityStyles')) {

 const style = document.createElement('style');

 style.id = 'matrixIntensityStyles';

 style.textContent = `

 @keyframes matrixFall {

 0% { transform: translateY(0); opacity: 0; }

 15% { opacity: 1; }

 85% { opacity: 0.85; }

 100% { transform: translateY(150vh); opacity: 0; }

 }

 `;

 document.head.appendChild(style);

 }

 

 // Remove after animation

 setTimeout(() => {

 if (matrixContainer && matrixContainer.parentNode) {

 matrixContainer.remove();

 }

 }, duration * 1000 + 500);

 }



 function triggerScreenShatter() {

 if (visiCalc) {

 stageClasses.forEach(cls => visiCalc.classList.remove(cls));

 void visiCalc.offsetWidth;

 visiCalc.classList.add('screen-shatter');

 }



 let shatter = document.getElementById('screenShatterOverlay');

 if (shatter) {

 shatter.remove();

 }

 shatter = document.createElement('div');

 shatter.id = 'screenShatterOverlay';

 shatter.className = 'shatter-overlay';

 const cracks = document.createElement('div');

 cracks.className = 'shatter-cracks';

 const pixels = document.createElement('div');

 pixels.className = 'shatter-pixels';

 shatter.appendChild(cracks);

 shatter.appendChild(pixels);

 document.body.appendChild(shatter);



 requestAnimationFrame(() => {

 shatter.classList.add('active');

 setTimeout(() => {

 shatter.classList.add('fade');

 }, 950);

 setTimeout(() => {

 if (shatter.parentNode) {

 shatter.parentNode.removeChild(shatter);

 }

 // Start cell address sequence after shatter

 setTimeout(() => {

 startCellAddressSequence(frame, visiCalc);

 }, 500);

 }, 2400);

 });

 }



 button.addEventListener('click', () => {

 if (button.disabled) return;

 clickCount++;

 barrelClickCount++;

 button.blur();

 button.style.transform = 'translateY(2px)';

 button.style.boxShadow = '0 0 12px rgba(25,255,107,0.35)';

 setTimeout(() => {

 if (!button.disabled) {

 button.style.transform = 'translateY(0)';

 button.style.boxShadow = '0 0 18px rgba(25,255,107,0.45)';

 }

 }, 160);



 const phaseIndex = Math.min(clickCount, phases.length - 1);

 status.textContent = phases[phaseIndex];



 // Play distorted startup sound with increasing distortion per click

 playStartupBassDistorted(clickCount);



 // Make VisiCell frame glow and extend back in Z

 if (visiCalc) {

 const frameEl = document.getElementById('visicalc-frame');

 if (frameEl) {

 const zDepth = barrelClickCount * 20;

 frameEl.style.transform = `perspective(1000px) translateZ(-${zDepth}px)`;

 frameEl.style.boxShadow = `0 0 ${10 + barrelClickCount * 15}px #0f0, inset 0 0 ${5 + barrelClickCount * 10}px #0f0`;

 frameEl.style.borderColor = '#0f0';

 frameEl.style.borderWidth = '3px';

 }

 }



 // Intensify screen glitch and matrix effects between clicks

 const glitchEl = document.getElementById('screenGlitch');

 if (glitchEl && clickCount < 3) {

 glitchEl.classList.add('active');

 setTimeout(() => glitchEl.classList.remove('active'), 800 + clickCount * 200);

 }

 

 // Trigger maximum matrix cascade effect

 if (clickCount < 3) {

 triggerMatrixIntensification(clickCount);

 }



 if (clickCount === 1) {

 applyDistortion(0);

 } else if (clickCount === 2) {

 applyDistortion(1);

 } else {

 applyDistortion(2);

 button.disabled = true;

 button.style.cursor = 'default';

 button.textContent = 'INITIALIZING...';

 button.style.background = '#0d400d';

 button.style.color = '#0f0';

 

 // Maximum glitch and matrix before shatter

 if (glitchEl) {

 glitchEl.classList.add('active');

 setTimeout(() => glitchEl.classList.remove('active'), 1500);

 }

 triggerMatrixIntensification(3);

 

 setTimeout(() => {

 triggerScreenShatter();

 }, 500);

 }

 });

 }

 

 function triggerCelliBackspaceReaction() {

 if (celliBackspaceSequenceStarted || burstAnimStarted) return;



 celliBackspaceSequenceStarted = true;

 celliBackspaceSequenceTime = totalTime;



 const active = voxels.filter(v => v.visible && !v.userData.glitched);

 if (!celliBackspaceFlickerTriggered && active.length) {

 celliBackspaceFlickerTriggered = true;

 const target = active[Math.floor(Math.random() * active.length)];

 if (target) {

 let flickers = 0;

 const mat = target.material;

 const edgeMaterial = target.userData.edges ? target.userData.edges.material : null;

 const baseOpacity = mat.opacity;

 const baseEdgeOpacity = edgeMaterial ? edgeMaterial.opacity : 0;

 const interval = setInterval(() => {

 const on = flickers % 2 === 0;

 mat.opacity = on ? 1 : Math.max(0.1, baseOpacity * 0.2);

 if (edgeMaterial) {

 edgeMaterial.opacity = on ? Math.min(0.9, baseEdgeOpacity + 0.3) : Math.max(0.1, baseEdgeOpacity * 0.3);

 }

 flickers += 1;

 if (flickers > 4) {

 clearInterval(interval);

 mat.opacity = baseOpacity;

 if (edgeMaterial) edgeMaterial.opacity = baseEdgeOpacity;

 }

 }, 90);

 }

 }

 }



 // CELLI glitch and degradation

 function triggerCelliGlitch() {

 if (celliGlitchStarted) return;

 celliGlitchStarted = true;

 

 // Play electrical fritz whir/buzz sound

 if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); window.audioCtx = audioCtx; }

 const now = audioCtx.currentTime;

 

 // Create buzzing electrical sound with multiple oscillators

 const buzz1 = audioCtx.createOscillator();

 const buzz2 = audioCtx.createOscillator();

 const buzz3 = audioCtx.createOscillator();

 const buzzGain = audioCtx.createGain();

 const buzzFilter = audioCtx.createBiquadFilter();

 

 buzz1.type = 'sawtooth';

 buzz2.type = 'square';

 buzz3.type = 'sawtooth';

 

 // Fluctuating frequencies for electrical buzz

 buzz1.frequency.setValueAtTime(120, now);

 buzz2.frequency.setValueAtTime(180, now);

 buzz3.frequency.setValueAtTime(240, now);

 

 // Modulate frequencies to create buzzing effect

 for (let i = 0; i < 20; i++) {

 const t = now + (i * 0.1);

 const freq1 = 120 + Math.random() * 60;

 const freq2 = 180 + Math.random() * 60;

 const freq3 = 240 + Math.random() * 60;

 buzz1.frequency.setValueAtTime(freq1, t);

 buzz2.frequency.setValueAtTime(freq2, t);

 buzz3.frequency.setValueAtTime(freq3, t);

 }

 

 // Band-pass filter for electrical character

 buzzFilter.type = 'bandpass';

 buzzFilter.frequency.setValueAtTime(300, now);

 buzzFilter.Q.setValueAtTime(5, now);

 

 // Envelope: fade in, sustain, fade out

 buzzGain.gain.setValueAtTime(0, now);

 buzzGain.gain.linearRampToValueAtTime(0.08, now + 0.2);

 buzzGain.gain.setValueAtTime(0.08, now + 1.5);

 buzzGain.gain.exponentialRampToValueAtTime(0.001, now + 2.0);

 

 buzz1.connect(buzzFilter);

 buzz2.connect(buzzFilter);

 buzz3.connect(buzzFilter);

 buzzFilter.connect(buzzGain);

 buzzGain.connect(audioCtx.destination);

 

 buzz1.start(now);

 buzz2.start(now);

 buzz3.start(now);

 buzz1.stop(now + 2.0);

 buzz2.stop(now + 2.0);

 buzz3.stop(now + 2.0);

 

 // Start flickering lights

 document.getElementById('screenGlitch').classList.add('active');

 

 // Only keep the middle column of I (letter index 4, middle 3 rows: 1,2,3)

 voxels.forEach((voxel, idx) => {

 const data = voxel.userData;

 const gridX = data.gridX; // Letter index (0=C, 1=E, 2=L, 3=L, 4=I)

 const gridY = data.gridY; // Row index (0=top, 4=bottom)

 const gridCol = data.gridCol; // Column index within letter (0-4)

 

 // Keep only the T shape: top bar (row 0, all cols) and vertical stem (rows 1-4, middle col)

 const keepVoxel = (gridX === 4 && ((gridY === 0) || (gridY >= 1 && gridY <= 4 && gridCol === 2)));

 

 if (!keepVoxel) {

 // Store in stack for later restoration BEFORE marking as glitched

 glitchedVoxelsStack.push(voxel);

 

 // Mark as glitched immediately to prevent updates

 data.glitched = true;

 

 // Start flickering with light gray

 const flickerDelay = Math.random() * 400;

 

 setTimeout(() => {

 // Turn to light gray and start flickering

 voxel.material.color.setRGB(0.6, 0.6, 0.6); // Light gray

 data.edges.material.color.setRGB(0.65, 0.65, 0.65);

 

 const flickerDuration = 400 + Math.random() * 400;

 let flickerCount = 0;

 const maxFlickers = Math.floor(flickerDuration / 60);

 

 const flickerInterval = setInterval(() => {

 flickerCount++;

 const flickerOn = Math.random() > 0.5;

 

 // Flicker between light gray and white, gradually dimming

 const dimFactor = 1 - (flickerCount / maxFlickers) * 0.5;

 if (flickerOn) {

 voxel.material.color.setRGB(0.6 * dimFactor, 0.6 * dimFactor, 0.6 * dimFactor);

 voxel.material.opacity = 0.75 * dimFactor;

 data.edges.material.opacity = 0.5 * dimFactor;

 } else {

 voxel.material.color.setRGB(0.4 * dimFactor, 0.4 * dimFactor, 0.4 * dimFactor);

 voxel.material.opacity = 0.5 * dimFactor;

 data.edges.material.opacity = 0.3 * dimFactor;

 }

 }, 60);

 

 // After flickering, turn dark gray and fade out

 setTimeout(() => {

 clearInterval(flickerInterval);

 

 // Short out - dark gray

 voxel.material.color.setRGB(0.15, 0.15, 0.15); // Dark gray

 data.edges.material.color.setRGB(0.2, 0.2, 0.2);

 voxel.material.opacity = 0.4;

 data.edges.material.opacity = 0.25;

 

 // Fade to black over time

 const fadeStart = Date.now();

 const fadeDuration = 300;

 const fadeInterval = setInterval(() => {

 const fadeProgress = (Date.now() - fadeStart) / fadeDuration;

 if (fadeProgress >= 1) {

 clearInterval(fadeInterval);

 voxel.material.opacity = 0;

 data.edges.material.opacity = 0;

 voxel.visible = false;

 data.edges.visible = false;

 } else {

 voxel.material.opacity = 0.4 * (1 - fadeProgress);

 data.edges.material.opacity = 0.25 * (1 - fadeProgress);

 }

 }, 16);

 }, flickerDuration);

 }, flickerDelay);

 }

 });

 

 // Stop screen glitch after 2 seconds

 setTimeout(() => {

 document.getElementById('screenGlitch').classList.remove('active');

 }, 2000);

 }



 function updatePositions(t) {

 const phase = t < introCfg.rollEnd ? 'roll' :

 t < introCfg.bounceEnd ? 'bounce' :

 t < introCfg.triangleEnd ? 'triangle' :

 t < introCfg.transitionEnd ? 'transition' :

 t < introCfg.normalEnd ? 'normal' :

 t < introCfg.vennEnd ? 'venn' :

 t < introCfg.collapseEnd ? 'collapse' :

 t < introCfg.glitchEnd ? 'glitch' :

 t < introCfg.blackoutEnd ? 'blackout' :

 t < introCfg.loomworksEnd ? 'loomworks' :

 t < introCfg.celliEnd ? 'celli' : 'doorway';



 // Animate bloom, afterimage, and film effects based on phase

 if (phase === 'roll') {

 afterimagePass.uniforms.damp.value = 0.75; // Thin trail

 filmPass.uniforms.noise.value = 0.005; // Minimal grain

 filmPass.uniforms.scanAmp.value = 0.003; // Minimal scanlines

 triMesh.visible = false; // Hide triangle gradient during intro

 } else if (phase === 'bounce') {

 bloomPass.strength = 0.25; // Subtle glow

 afterimagePass.uniforms.damp.value = 0.75; // Thin trail

 filmPass.uniforms.noise.value = 0.005; // Minimal grain

 filmPass.uniforms.scanAmp.value = 0.003; // Minimal scanlines

 triMesh.visible = false; // Hide triangle gradient during intro

 } else if (phase === 'triangle') {

 const triangleProgress = (t - introCfg.bounceEnd) / (introCfg.triangleEnd - introCfg.bounceEnd);

 

 // Sub-phases: form (0-0.35), converge (0.35-0.6), grow (0.6-1.0)

 const formProgress = Math.min(triangleProgress / 0.35, 1.0);

 const convergeStart = 0.35;

 const convergeProgress = triangleProgress > convergeStart ? Math.min((triangleProgress - convergeStart) / 0.25, 1.0) : 0;

 const growStart = 0.6;

 const growProgress = triangleProgress > growStart ? (triangleProgress - growStart) / 0.4 : 0;

 

 // Smooth bloom progression throughout all sub-phases

 bloomPass.strength = THREE.MathUtils.lerp(0.25, 0.7, triangleProgress);

 afterimagePass.uniforms.damp.value = THREE.MathUtils.lerp(0.75, 0.92, triangleProgress);

 filmPass.uniforms.noise.value = THREE.MathUtils.lerp(0.005, 0.015, triangleProgress);

 filmPass.uniforms.scanAmp.value = THREE.MathUtils.lerp(0.003, 0.015, triangleProgress);

 

 // Hide triangle gradient - it makes things look off-center

 triMesh.visible = false;

 } else if (phase === 'transition') {

 const transProgress = (t - introCfg.triangleEnd) / (introCfg.transitionEnd - introCfg.triangleEnd);

 bloomPass.strength = 0.7; // Keep bloom consistent

 afterimagePass.uniforms.damp.value = THREE.MathUtils.lerp(0.92, 0.96, transProgress);

 filmPass.uniforms.noise.value = THREE.MathUtils.lerp(0.015, 0.03, transProgress);

 filmPass.uniforms.scanAmp.value = THREE.MathUtils.lerp(0.015, 0.03, transProgress);

 triMesh.visible = false;

 triMesh.material.opacity = 0;

 } else if (phase === 'normal') {

 const normalT = t - introCfg.transitionEnd;

 const normalDuration = introCfg.normalEnd - introCfg.transitionEnd;

 const convergeDuration = 2.2;

 const pulseDuration = 3.0;

 const totalAnimDuration = convergeDuration + pulseDuration;



 if (normalT < convergeDuration) {

 // Phase 1: Converge - increase bloom

 const convergeProgress = THREE.MathUtils.clamp(normalT / convergeDuration, 0, 1);

 const convergeEased = convergeProgress * convergeProgress * (3 - 2 * convergeProgress);

 bloomPass.strength = THREE.MathUtils.lerp(0.7, 0.9, convergeEased);

 triMesh.visible = false;

 } else if (normalT < totalAnimDuration) {

 // Phase 2: Single pulse - bloom follows expansion

 const pulseT = normalT - convergeDuration;

 const pulseProgress = pulseT / pulseDuration;

 const pulseCycle = Math.sin(pulseProgress * Math.PI);

 

 bloomPass.strength = THREE.MathUtils.lerp(0.9, 0.72, pulseCycle);

 triMesh.visible = pulseCycle > 0.3; // Show triangle during expansion

 triMesh.material.opacity = THREE.MathUtils.clamp(pulseCycle * 1.5, 0, 0.7);

 } else {

 // Phase 3: Brief hold, prepare for venn transition

 const holdT = normalT - totalAnimDuration;

 const holdDuration = normalDuration - totalAnimDuration;

 const holdProgress = holdT / holdDuration;

 

 bloomPass.strength = THREE.MathUtils.lerp(0.9, 0.85, holdProgress);

 triMesh.visible = false;

 }



 afterimagePass.uniforms.damp.value = 0.96;

 filmPass.uniforms.noise.value = 0.03;

 filmPass.uniforms.scanAmp.value = 0.03;

 } else if (phase === 'venn') {

 // Settle into clear venn diagram

 const vennProgress = (t - introCfg.normalEnd) / (introCfg.vennEnd - introCfg.normalEnd);

 bloomPass.strength = THREE.MathUtils.lerp(0.7, 0.8, vennProgress);

 afterimagePass.uniforms.damp.value = THREE.MathUtils.lerp(0.96, 0.7, vennProgress);

 filmPass.uniforms.noise.value = THREE.MathUtils.lerp(0.03, 0.02, vennProgress);

 filmPass.uniforms.scanAmp.value = THREE.MathUtils.lerp(0.03, 0.02, vennProgress);

 triMesh.visible = true;

 triMesh.material.opacity = THREE.MathUtils.lerp(0.7, 0.85, vennProgress);

 } else if (phase === 'collapse') {

 // Grow and collapse into white radiating circle

 const collapseProgress = (t - introCfg.vennEnd) / (introCfg.collapseEnd - introCfg.vennEnd);

 bloomPass.strength = THREE.MathUtils.lerp(0.8, 1.2, collapseProgress);

 afterimagePass.uniforms.damp.value = THREE.MathUtils.lerp(0.7, 0.6, collapseProgress);

 filmPass.uniforms.noise.value = THREE.MathUtils.lerp(0.02, 0.015, collapseProgress);

 filmPass.uniforms.scanAmp.value = THREE.MathUtils.lerp(0.02, 0.015, collapseProgress);

 triMesh.visible = true;

 triMesh.material.opacity = THREE.MathUtils.lerp(0.85, 0.3, collapseProgress);

 

 // Progressive glitch starting mild - show quote only when glitching starts

 if (collapseProgress > 0.15 && !glitchStarted) {

 const quoteEl = document.getElementById('quote');

 quoteEl.style.visibility = 'visible';

 quoteEl.style.opacity = '0.85'; // Start visible

 quoteEl.classList.add('glitch');

 glitchStarted = true;

 quoteShown = true;

 }



 // Increase to medium glitch

 if (collapseProgress > 0.6 && !mediumGlitchStarted) {

 document.getElementById('quote').classList.remove('glitch');

 document.getElementById('quote').classList.add('glitchMedium');

 mediumGlitchStarted = true;

 }

 } else if (phase === 'glitch') {

 // Intense glitch phase

 const glitchProgress = (t - introCfg.collapseEnd) / (introCfg.glitchEnd - introCfg.collapseEnd);

 bloomPass.strength = THREE.MathUtils.lerp(1.2, 0.5, glitchProgress);

 afterimagePass.uniforms.damp.value = 0.3; // Heavy trails

 filmPass.uniforms.noise.value = THREE.MathUtils.lerp(0.015, 0.5, glitchProgress);

 filmPass.uniforms.scanAmp.value = THREE.MathUtils.lerp(0.015, 0.3, glitchProgress);

 triMesh.visible = true;

 triMesh.material.opacity = THREE.MathUtils.lerp(0.3, 0, glitchProgress);

 

 // Intensify text glitch at start of glitch phase

 if (glitchProgress > 0.05 && !intenseGlitchStarted) {

 document.getElementById('quote').classList.remove('glitch', 'glitchMedium');

 document.getElementById('quote').classList.add('glitchIntense');

 intenseGlitchStarted = true;

 }



 if (glitchProgress > 0.25 && !quoteDespairShown) {

 glitchSwapQuote(quoteStates.despair, { duration: 950, onComplete: () => quoteEl.classList.add('quote--loom') });

 quoteDespairShown = true;

 }



 // Screen glitch in middle

 if (glitchProgress > 0.4 && !screenGlitchStarted) {

 document.getElementById('screenGlitch').classList.add('active');

 screenGlitchStarted = true;

 }

 } else if (phase === 'blackout') {

 // Fade to black

 const blackoutProgress = (t - introCfg.glitchEnd) / (introCfg.blackoutEnd - introCfg.glitchEnd);

 bloomPass.strength = THREE.MathUtils.lerp(0.5, 0, blackoutProgress);

 afterimagePass.uniforms.damp.value = 0.1;

 filmPass.uniforms.noise.value = 0;

 filmPass.uniforms.scanAmp.value = 0;

 triMesh.visible = false;

 

 if (!blackoutStarted) {

 // Hide and clean up quote immediately

 const quoteEl = document.getElementById('quote');

 quoteEl.classList.remove('glitch', 'glitchMedium', 'glitchIntense', 'scrambling');

 quoteEl.style.visibility = 'hidden';

 quoteEl.style.opacity = '0';

 quoteEl.classList.remove('quote--loom');

 document.getElementById('screenGlitch').classList.remove('active');

 blackoutStarted = true;

 }

 } else if (phase === 'loomworks') {

 // Show Loomworks text

 bloomPass.strength = 0;

 afterimagePass.uniforms.damp.value = 0;

 filmPass.uniforms.noise.value = 0;

 filmPass.uniforms.scanAmp.value = 0;

 triMesh.visible = false;

 

 if (!loomworksShown) {

 // Ensure quote is definitely hidden before showing loomworks

 const quoteEl = document.getElementById('quote');

 quoteEl.style.visibility = 'hidden';

 quoteEl.style.opacity = '0';

 quoteEl.classList.remove('glitch', 'glitchMedium', 'glitchIntense', 'scrambling');



 startLoomworksReveal();

 loomworksShown = true;

 }

 

 // Play chime jingle at start of this phase

 if (!chimePlayed) {

 // Generate startup chime jingle

 if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); window.audioCtx = audioCtx; }

 const now = audioCtx.currentTime;

 

 // Melodic jingle: C - E - G - C (ascending arpeggio)

 const melody = [

 { freq: 261.63, time: 0.0, duration: 0.25 }, // C4

 { freq: 329.63, time: 0.15, duration: 0.25 }, // E4

 { freq: 392.00, time: 0.30, duration: 0.25 }, // G4

 { freq: 523.25, time: 0.45, duration: 0.5 } // C5 (held)

 ];

 

 melody.forEach((note, idx) => {

 const osc = audioCtx.createOscillator();

 const gain = audioCtx.createGain();

 

 osc.type = 'sine';

 osc.frequency.setValueAtTime(note.freq, now + note.time);

 

 // Envelope

 gain.gain.setValueAtTime(0, now + note.time);

 gain.gain.linearRampToValueAtTime(0.12, now + note.time + 0.02);

 gain.gain.linearRampToValueAtTime(0.08, now + note.time + 0.1);

 gain.gain.exponentialRampToValueAtTime(0.001, now + note.time + note.duration);

 

 osc.connect(gain);

 gain.connect(audioCtx.destination);

 osc.start(now + note.time);

 osc.stop(now + note.time + note.duration);

 });

 

 // Play startup bass after chime completes

 setTimeout(() => {

 playStartupBass();

 }, 1200);

 

 chimePlayed = true;

 }

 

 // Hide Loomworks text near end

 const loomProgress = (t - introCfg.blackoutEnd) / (introCfg.loomworksEnd - introCfg.blackoutEnd);

 if (loomProgress > 0.85) {

 document.getElementById('loomworks').style.opacity = THREE.MathUtils.lerp(1, 0, (loomProgress - 0.85) / 0.15);

 }

 } else if (phase === 'celli') {

 // CELLI phase - lower bloom to reduce wobble

 bloomPass.strength = 0.35;

 afterimagePass.uniforms.damp.value = 0.85;

 filmPass.uniforms.noise.value = 0.008;

 filmPass.uniforms.scanAmp.value = 0.003;

 

 triMesh.visible = false;



 if (!celliStarted) {

 document.getElementById('loomworks').style.display = 'none';

 celliStarted = true;

 }

 } else {

 // Doorway phase - portal opens from vertical bar (lower bloom)

 const doorwayProgress = (t - introCfg.celliEnd) / (introCfg.doorwayEnd - introCfg.celliEnd);

 

 bloomPass.strength = THREE.MathUtils.lerp(0.35, 0.55, Math.min(doorwayProgress * 2, 1));

 afterimagePass.uniforms.damp.value = 0.8;

 filmPass.uniforms.noise.value = 0.005;

 filmPass.uniforms.scanAmp.value = 0.002;

 triMesh.visible = false;

 

 // Wait for all CELLI voxels to finish settling (last one settles around 3-4 seconds)

 const celliAge = t - introCfg.loomworksEnd;

 const allVoxelsSettled = celliAge > 5.0;

 

 if (!doorwayShown && allVoxelsSettled) {

 // Show doorway bar after CELLI finishes

 if (doorwayProgress > 0.05) {

 document.getElementById('doorway').classList.add('visible');

 doorwayShown = true;

 }

 }

 

 if (doorwayShown && !doorwayOpened) {

 // Open doorway after short delay

 if (doorwayProgress > 0.15) {

 document.getElementById('doorway').classList.add('open');

 doorwayOpened = true;

 

 }

 }

 }



 if (phase === 'roll') {

 // Shapes roll in from off-screen to their positions

 const rollProgress = t / introCfg.rollEnd;

 const eased = rollProgress < 0.5 ? 

 2 * rollProgress * rollProgress : 

 1 - Math.pow(-2 * rollProgress + 2, 2) / 2;

 

 // Keep glow visible throughout roll

 bloomPass.strength = 0.4;



 for (let i = 0; i < 3; i++) {

 const targetX = (i - 1) * 0.35;

 const startX = targetX - 2.0; // Start off-screen left

 const x = THREE.MathUtils.lerp(startX, targetX, eased);

 const y = -0.3;

 

 // Calculate rolling rotation based on distance traveled to reach FLAT position

 const distance = x - startX; // Distance rolled

 

 // Calculate rotation for accurate rolling that ends flat

 let rotation = 0;

 if (i === 0) {

 // Square: needs to align flat (multiple of p/2)

 const squarePerimeter = R * 2 * 4;

 const naturalRotation = -(distance / squarePerimeter) * (Math.PI * 2);

 // Snap to nearest p/2 when nearly stopped

 rotation = rollProgress > 0.95 ? Math.round(naturalRotation / (Math.PI / 2)) * (Math.PI / 2) : naturalRotation;

 } else if (i === 1) {

 // Triangle: needs to align flat (multiple of 2p/3)

 const trianglePerimeter = R * 2 * 3;

 const naturalRotation = -(distance / trianglePerimeter) * (Math.PI * 2);

 // Snap to nearest 2p/3 when nearly stopped (flat base)

 rotation = rollProgress > 0.95 ? Math.round(naturalRotation / (Math.PI * 2 / 3)) * (Math.PI * 2 / 3) : naturalRotation;

 } else {

 // Circle: any rotation is "flat"

 rotation = -(distance / (2 * Math.PI * R)) * (Math.PI * 2);

 }

 

 // Store final rotation when reaching target

 if (rollProgress > 0.98) {

 finalRollRotations[i] = rotation;

 }

 

 // Play continuous rolling thunks based on distance

 const rollDist = Math.abs(x - startX);

 const thunkInterval = 0.15; // Play thunk every 0.15 units rolled

 const expectedThunks = Math.floor(rollDist / thunkInterval);

 

 if (expectedThunks > lastThunkTime[i]) {

 playRollingThunk(0.06);

 lastThunkTime[i] = expectedThunks;

 }

 

 spheres[i].position.set(x, y, -i * 0.002);

 spheres[i].rotation.z = rotation;

 spheres[i].scale.set(introCfg.ballSize, introCfg.ballSize, introCfg.ballSize);

 triMat.uniforms.points.value[i].set(x, y);

 

 // Play final landing thunk

 if (!landingSounds[i] && Math.abs(x - targetX) < 0.02) {

 playRollingThunk(0.12);

 landingSounds[i] = true;

 }

 }

 blackHole.visible = false; // Hide during roll-in

 

 } else if (phase === 'bounce') {

 // Sequential bounces: left, then right, then middle

 const bounceT = t - introCfg.rollEnd;

 const baseY = -0.3;

 

 // Keep glow visible during bounce

 bloomPass.strength = 0.4;

 

 for (let i = 0; i < 3; i++) {

 const x = (i - 1) * 0.35;

 let y = baseY;

 

 // Sequence: 0 (left), 2 (right), 1 (middle)

 const bounceOrder = [0, 2, 1];

 const bounceIndex = bounceOrder.indexOf(i);

 const bounceStart = bounceIndex * introCfg.bounceDuration;

 const bounceEnd = bounceStart + introCfg.bounceDuration;

 

 if (bounceT >= bounceStart && bounceT <= bounceEnd) {

 const localT = (bounceT - bounceStart) / introCfg.bounceDuration;

 const bounce = Math.sin(localT * Math.PI) * introCfg.bounceHeight;

 y = baseY + bounce;

 

 // Play thud sounds for jump and land

 if (!window['bounceJump_' + i] && localT < 0.05) {

 playBounceThud(0.12);

 window['bounceJump_' + i] = true;

 }

 if (!window['bounceLand_' + i] && localT > 0.95) {

 playBounceThud(0.15);

 window['bounceLand_' + i] = true;

 }

 }

 

 spheres[i].position.set(x, y, -i * 0.002);

 spheres[i].rotation.z = finalRollRotations[i]; // Use exact rotation from roll phase

 spheres[i].scale.set(introCfg.ballSize, introCfg.ballSize, introCfg.ballSize);

 triMat.uniforms.points.value[i].set(x, y);

 }

 blackHole.visible = false; // Hide during bounce

 

 } else if (phase === 'triangle') {

 // Triangle phase: form ? converge ? grow & brighten

 const triangleProgress = (t - introCfg.bounceEnd) / (introCfg.triangleEnd - introCfg.bounceEnd);

 

 // Smooth cubic easing for entire phase

 const smoothEase = (p) => p < 0.5 ? 4 * p * p * p : 1 - Math.pow(-2 * p + 2, 3) / 2;

 

 // Sub-phases with smooth transitions

 const formProgress = Math.min(triangleProgress / 0.35, 1.0);

 const formEased = smoothEase(formProgress);

 

 const convergeStart = 0.35;

 const convergeProgress = triangleProgress > convergeStart ? Math.min((triangleProgress - convergeStart) / 0.25, 1.0) : 0;

 const convergeEased = smoothEase(convergeProgress);

 

 const growStart = 0.6;

 const growProgress = triangleProgress > growStart ? (triangleProgress - growStart) / 0.4 : 0;

 const growEased = smoothEase(growProgress);

 

 // Create EQUILATERAL triangle centered at origin

 const centerY = 0;

 const triangleRadius = 0.42; // Distance from center to each vertex (increased)

 

 // Equilateral triangle: vertices at 120 intervals, pointing up

 const triangleAngles = [

 Math.PI / 2 + (2 * Math.PI / 3) * 0, // Top (90 )

 Math.PI / 2 + (2 * Math.PI / 3) * 1, // Bottom-left (210 )

 Math.PI / 2 + (2 * Math.PI / 3) * 2 // Bottom-right (330 )

 ];

 

 // Rotation grows smoothly throughout

 const rotationAmount = growEased * 0.2;

 

 // Pulsing: breathe in/out during grow phase

 const pulseSpeed = 2.0;

 const pulsePhase = (t - introCfg.bounceEnd - growStart * (introCfg.triangleEnd - introCfg.bounceEnd)) * pulseSpeed;

 const pulseFactor = growProgress > 0 ? 1 + Math.sin(pulsePhase) * 0.08 : 1;

 

 // Converge factor - pull toward center during converge phase

 const convergeFactor = convergeEased * 0.12;

 

 // Map spheres to triangle positions: [0]=left?bottom-left, [1]=middle?top, [2]=right?bottom-right

 const triangleMapping = [1, 0, 2]; // sphere i goes to angle triangleMapping[i]

 

 for (let i = 0; i < 3; i++) {

 // Starting positions from the line (after bounce)

 const startX = (i - 1) * 0.35;

 const startY = -0.3;

 

 // Target positions in triangle formation (with correct mapping)

 const angleIndex = triangleMapping[i];

 const angle = triangleAngles[angleIndex] + rotationAmount;

 const targetRadius = triangleRadius * (1 - convergeFactor) * pulseFactor;

 const targetX = Math.cos(angle) * targetRadius;

 const targetY = Math.sin(angle) * targetRadius + centerY;

 

 // Interpolate from line to triangle formation

 const x = THREE.MathUtils.lerp(startX, targetX, formEased);

 const y = THREE.MathUtils.lerp(startY, targetY, formEased);

 

 spheres[i].position.set(x, y, -i * 0.002);

 spheres[i].rotation.z = 0; // Reset rotation for orbit phases

 

 // Scale: small ? stays small during form/converge ? grows large with overshoot

 let scale = introCfg.ballSize;

 if (formEased < 1) {

 scale = THREE.MathUtils.lerp(introCfg.ballSize, introCfg.ballSize * 1.0, formEased);

 } else {

 // Add subtle overshoot for organic feel

 const overshoot = Math.sin(growEased * Math.PI) * 0.08;

 scale = THREE.MathUtils.lerp(introCfg.ballSize * 1.0, introCfg.ballSize * 2.2, growEased) + overshoot;

 }

 

 spheres[i].scale.set(scale, scale, scale);

 triMat.uniforms.points.value[i].set(x, y);

 }

 

 blackHole.visible = true;

 blackHole.material.uniforms.pulseFactor.value = formEased * 0.4;

 

 } else if (phase === 'transition') {

 // Transform triangle into rotating circular orbit - organically

 // ALSO morph all shapes into circles

 const transProgress = (t - introCfg.triangleEnd) / (introCfg.transitionEnd - introCfg.triangleEnd);

 // Smooth cubic easing

 const eased = transProgress < 0.5 ? 

 4 * transProgress * transProgress * transProgress : 

 1 - Math.pow(-2 * transProgress + 2, 3) / 2;

 

 // Morph shapes into circles halfway through transition

 // Keep materials (colors) consistent - don't swap

 if (transProgress > 0.5 && spheres[0].geometry !== circleGeoTarget && spheres[1].geometry !== circleGeoTarget) {

 const mat0 = spheres[0].material;

 const mat1 = spheres[1].material;

 

 spheres[0].geometry.dispose();

 spheres[0].geometry = createCircle(R);

 spheres[0].material = mat0; // Preserve cyan

 

 spheres[1].geometry.dispose();

 spheres[1].geometry = createCircle(R);

 spheres[1].material = mat1; // Preserve yellow

 

 // spheres[2] is already a circle (magenta)

 }

 

 const centerY = 0;

 const triangleRadius = 0.42;

 

 // Use same equilateral triangle angles

 const triangleAngles = [

 Math.PI / 2 + (2 * Math.PI / 3) * 0,

 Math.PI / 2 + (2 * Math.PI / 3) * 1,

 Math.PI / 2 + (2 * Math.PI / 3) * 2

 ];

 

 // Starting radius (with 12% convergence from triangle phase)

 const startRadius = triangleRadius * (1 - 0.12);

 

 // Calculate rotation to match end of triangle phase (which uses rotationAmount = 0.2)

 // The triangle phase maps spheres with triangleMapping, so we need to continue from there

 const triangleEndRotation = 0.2; // matches growEased = 1.0 * 0.2

 const rotation = triangleEndRotation + (eased * Math.PI * 2);

 

 // Expand from triangle size to full orbit size

 const targetDist = motionCfg.maxDist * 0.5;

 const currentDist = THREE.MathUtils.lerp(startRadius, targetDist, eased);

 

 // Use same mapping as triangle phase

 const triangleMapping = [1, 0, 2];

 

 for (let i = 0; i < 3; i++) {

 const angleIndex = triangleMapping[i];

 const angle = triangleAngles[angleIndex] + rotation;

 const x = Math.cos(angle) * currentDist;

 const y = Math.sin(angle) * currentDist + centerY;

 

 spheres[i].position.set(x, y, -i * 0.002);

 spheres[i].rotation.z = 0;

 const scale = THREE.MathUtils.lerp(introCfg.ballSize * 2.2, 1.0, eased);

 spheres[i].scale.set(scale, scale, scale);

 triMat.uniforms.points.value[i].set(x, y);

 }

 blackHole.visible = true;

 blackHole.material.uniforms.pulseFactor.value = THREE.MathUtils.lerp(0.4, 0.5, eased);

 

 } else if (phase === 'normal') {

 const normalT = t - introCfg.transitionEnd;

 const convergeDuration = 2.2;

 const pulseDuration = 3.0; // One expand/contract cycle

 const transitionEndDist = motionCfg.maxDist * 0.5;

 const closeConvergeDist = 0.02; // Very close convergence

 const triangleExpandDist = motionCfg.maxDist * 0.65; // Expand to triangle



 const centerY = 0;

 const triangleAngles = [

 Math.PI / 2 + (2 * Math.PI / 3) * 0,

 Math.PI / 2 + (2 * Math.PI / 3) * 1,

 Math.PI / 2 + (2 * Math.PI / 3) * 2

 ];

 const transitionEndRotation = 0.2 + Math.PI * 2;

 const rotation = transitionEndRotation + (normalT * motionCfg.rotationSpeed);

 const triangleMapping = [1, 0, 2];



 let currentDist = transitionEndDist;

 let scale = 1.0;

 let pulseFactorValue = 0.5;



 if (normalT < convergeDuration) {

 // Phase 1: Converge close

 const convergeProgress = THREE.MathUtils.clamp(normalT / convergeDuration, 0, 1);

 const convergeEased = convergeProgress * convergeProgress * (3 - 2 * convergeProgress);

 currentDist = THREE.MathUtils.lerp(transitionEndDist, closeConvergeDist, convergeEased);

 scale = THREE.MathUtils.lerp(1.0, 0.82, convergeEased);

 pulseFactorValue = THREE.MathUtils.lerp(0.5, 0.95, convergeEased);

 } else if (normalT < convergeDuration + pulseDuration) {

 // Phase 2: Single expand/contract pulse

 const pulseT = normalT - convergeDuration;

 const pulseProgress = pulseT / pulseDuration;

 

 // Use sine wave for smooth expand/contract (0->1->0)

 const pulseCycle = Math.sin(pulseProgress * Math.PI);

 

 currentDist = THREE.MathUtils.lerp(closeConvergeDist, triangleExpandDist, pulseCycle);

 scale = THREE.MathUtils.lerp(0.82, 1.0, pulseCycle);

 pulseFactorValue = THREE.MathUtils.lerp(0.95, 0.6, pulseCycle);

 } else {

 // Phase 3: Hold at converged position before transitioning to venn

 currentDist = closeConvergeDist;

 scale = 0.82;

 pulseFactorValue = 0.95;

 }



 for (let i = 0; i < 3; i++) {

 const angleIndex = triangleMapping[i];

 const angle = triangleAngles[angleIndex] + rotation;

 const p = new THREE.Vector2(

 Math.cos(angle) * currentDist,

 Math.sin(angle) * currentDist + centerY

 );

 spheres[i].position.set(p.x, p.y, -i * 0.002);

 spheres[i].rotation.z = 0;

 spheres[i].scale.set(scale, scale, scale);

 triMat.uniforms.points.value[i].copy(p);

 }

 blackHole.visible = true;

 blackHole.material.uniforms.pulseFactor.value = pulseFactorValue;



 } else if (phase === 'venn') {

 // Slow down and form clear venn diagram

 const vennProgress = (t - introCfg.normalEnd) / (introCfg.vennEnd - introCfg.normalEnd);

 // Smooth cubic easing

 const eased = vennProgress < 0.5 ? 

 4 * vennProgress * vennProgress * vennProgress : 

 1 - Math.pow(-2 * vennProgress + 2, 3) / 2;

 

 const normalDuration = introCfg.normalEnd - introCfg.transitionEnd;

 const centerY = 0;

 

 const triangleAngles = [

 Math.PI / 2 + (2 * Math.PI / 3) * 0,

 Math.PI / 2 + (2 * Math.PI / 3) * 1,

 Math.PI / 2 + (2 * Math.PI / 3) * 2

 ];

 

 // Start from where normal ended: transitionEndRotation + normalDuration * rotationSpeed

 const transitionEndRotation = 0.2 + Math.PI * 2;

 const baseRotation = transitionEndRotation + (normalDuration * motionCfg.rotationSpeed);

 const vennT = t - introCfg.normalEnd;

 const slowRotation = baseRotation + (vennT * motionCfg.rotationSpeed * 0.3); // Slow down to 30%

 

 // Settle into venn diagram distance - calculate what pulse factor was at END of normal phase

 const normalEndTime = introCfg.normalEnd - introCfg.transitionEnd;

 const startPulseFactor = 0.5 + 0.5 * Math.sin(normalEndTime * motionCfg.speed);

 const startDist = motionCfg.maxDist * startPulseFactor;

 const targetDist = 0.08; // Very close for dramatic overlap

 const currentDist = THREE.MathUtils.lerp(startDist, targetDist, eased);

 const scale = THREE.MathUtils.lerp(1.0, 0.7, eased); // Much larger for awesome venn!



 // Use same mapping as triangle phase

 const triangleMapping = [1, 0, 2];



 for (let i = 0; i < 3; i++) {

 const angleIndex = triangleMapping[i];

 const angle = triangleAngles[angleIndex] + slowRotation;

 const p = new THREE.Vector2(

 Math.cos(angle) * currentDist,

 Math.sin(angle) * currentDist + centerY

 );

 spheres[i].position.set(p.x, p.y, -i * 0.002);

 spheres[i].rotation.z = 0;

 spheres[i].scale.set(scale, scale, scale);

 triMat.uniforms.points.value[i].copy(p);

 }

 blackHole.visible = true;

 blackHole.material.uniforms.pulseFactor.value = THREE.MathUtils.lerp(startPulseFactor, 0.6, eased);

 

 if (!quoteShown) {

 applyQuoteState(quoteStates.initial, { immediate: true });

 quoteEl.classList.remove('scrambling', 'glitch', 'glitchMedium', 'glitchIntense');

 document.getElementById('quote').classList.add('visible');

 quoteDespairShown = false;

 quoteShown = true;

 }

 

 } else if (phase === 'collapse') {

 // Grow and collapse into white radiating circle

 const collapseProgress = (t - introCfg.vennEnd) / (introCfg.collapseEnd - introCfg.vennEnd);

 // Smooth cubic easing

 const eased = collapseProgress < 0.5 ? 

 4 * collapseProgress * collapseProgress * collapseProgress : 

 1 - Math.pow(-2 * collapseProgress + 2, 3) / 2;

 

 const centerY = 0;

 

 const triangleAngles = [

 Math.PI / 2 + (2 * Math.PI / 3) * 0,

 Math.PI / 2 + (2 * Math.PI / 3) * 1,

 Math.PI / 2 + (2 * Math.PI / 3) * 2

 ];

 

 // Start from where venn ended

 const transitionEndRotation = 0.2 + Math.PI * 2;

 const normalDuration = introCfg.normalEnd - introCfg.transitionEnd;

 const vennDuration = introCfg.vennEnd - introCfg.normalEnd;

 const baseRotation = transitionEndRotation + (normalDuration * motionCfg.rotationSpeed) + (vennDuration * motionCfg.rotationSpeed * 0.3);

 const collapseT = t - introCfg.vennEnd;

 const rotation = baseRotation + (collapseT * motionCfg.rotationSpeed * 0.15); // Even slower

 

 // Collapse to tiny overlap while growing in size

 const startDist = 0.08;

 const targetDist = 0.005;

 const currentDist = THREE.MathUtils.lerp(startDist, targetDist, eased);

 const scale = THREE.MathUtils.lerp(0.7, 0.85, eased); // Massive spheres!



 // Use same mapping as triangle phase

 const triangleMapping = [1, 0, 2];



 for (let i = 0; i < 3; i++) {

 const angleIndex = triangleMapping[i];

 const angle = triangleAngles[angleIndex] + rotation;

 const p = new THREE.Vector2(

 Math.cos(angle) * currentDist,

 Math.sin(angle) * currentDist + centerY

 );

 spheres[i].position.set(p.x, p.y, -i * 0.002);

 spheres[i].rotation.z = 0;

 spheres[i].scale.set(scale, scale, scale);

 triMat.uniforms.points.value[i].copy(p);

 }

 blackHole.visible = true;

 blackHole.material.uniforms.pulseFactor.value = THREE.MathUtils.lerp(0.6, 0.85, eased);

 

 if (collapseProgress > 0.3 && !glitchStarted) {

 document.getElementById('quote').classList.add('glitch');

 glitchStarted = true;

 }

 

 } else if (phase === 'glitch' || phase === 'blackout' || phase === 'loomworks' || phase === 'celli') {

 // Hide spheres during ending sequence, keep last position

 const centerY = 0;

 const targetDist = 0.005;

 const scale = 0.85;

 

 const triangleAngles = [

 Math.PI / 2 + (2 * Math.PI / 3) * 0,

 Math.PI / 2 + (2 * Math.PI / 3) * 1,

 Math.PI / 2 + (2 * Math.PI / 3) * 2

 ];

 

 const slowRotation = t * 0.05;

 

 // Fade out spheres during glitch phase

 let sphereOpacity = 1.0;

 if (phase === 'glitch') {

 const glitchProgress = (t - introCfg.collapseEnd) / (introCfg.glitchEnd - introCfg.collapseEnd);

 sphereOpacity = THREE.MathUtils.lerp(1.0, 0, glitchProgress);

 if (glitchProgress > 0.25 && !quoteDespairShown) {

 glitchSwapQuote(quoteStates.despair, { duration: 950, onComplete: () => quoteEl.classList.add('quote--loom') });

 quoteDespairShown = true;

 }

 } else {

 sphereOpacity = 0;

 }

 

 // Use same mapping as triangle phase

 const triangleMapping = [1, 0, 2];

 

 for (let i = 0; i < 3; i++) {

 const angleIndex = triangleMapping[i];

 const angle = triangleAngles[angleIndex] + slowRotation;

 const p = new THREE.Vector2(

 Math.cos(angle) * targetDist,

 Math.sin(angle) * targetDist + centerY

 );

 spheres[i].position.set(p.x, p.y, -i * 0.002);

 spheres[i].rotation.z = 0;

 spheres[i].scale.set(scale, scale, scale);

 spheres[i].material.opacity = sphereOpacity;

 triMat.uniforms.points.value[i].copy(p);

 }



 blackHole.visible = phase === 'glitch';

 if (phase === 'glitch') {

 const glitchProgress = (t - introCfg.collapseEnd) / (introCfg.glitchEnd - introCfg.collapseEnd);

 blackHole.material.uniforms.pulseFactor.value = THREE.MathUtils.lerp(0.85, 0, glitchProgress);

 }

 }

 }



 // --- Responsive ---------------------------------------------------------

 function onResize(){

 renderer.setSize(window.innerWidth, window.innerHeight);

 composer.setSize(window.innerWidth, window.innerHeight);

 const aspect = window.innerWidth / window.innerHeight;

 triMat.uniforms.aspect.value = aspect;

 if (aspect > 1) { // Landscape

 camera.left = -aspect; camera.right = aspect; camera.top = 1; camera.bottom = -1;

 // Scale black hole to maintain circularity

 blackHole.scale.set(1, 1, 1);

 } else { // Portrait

 camera.left = -1; camera.right = 1; camera.top = 1 / aspect; camera.bottom = -1 / aspect;

 // Scale black hole to maintain circularity

 blackHole.scale.set(aspect, aspect, 1);

 }

 camera.updateProjectionMatrix();

 

 // Recalculate CELLI scale for responsive layout

 const oldScale = celliScale;

 calculateCelliScale();



 // Update voxel positions and scales based on new scale

 if (oldScale !== celliScale) {

 const scaleRatio = celliScale / oldScale;

 voxels.forEach((voxel) => {

 const data = voxel.userData;

 // Update positions with new scale

 data.targetX *= scaleRatio;

 data.targetY *= scaleRatio;

 data.baseScale = celliScale;



 // Update actual positions if settled

 if (data.settled) {

 voxel.position.x = data.targetX;

 voxel.position.y = data.targetY;

 }



 // Update scale

 voxel.scale.set(celliScale, celliScale, celliScale);

 });

 }



 if (bowActive) {

 moveBowToTarget(true);

 }

 }

 window.addEventListener('resize', onResize);

 onResize();



 // --- Animate (gated by Play) -------------------------------------------

 const clock = new THREE.Clock();

 let running = false, totalTime = 0;

 

 // Canvas for text particles

 const textCanvas = document.createElement('canvas');

 textCanvas.style.position = 'fixed';

 textCanvas.style.inset = '0';

 textCanvas.style.pointerEvents = 'none';

 textCanvas.style.zIndex = '5';

 document.body.appendChild(textCanvas);

 const textCtx = textCanvas.getContext('2d');

 

 function resizeTextCanvas() {

 textCanvas.width = window.innerWidth;

 textCanvas.height = window.innerHeight;

 }

 resizeTextCanvas();

 window.addEventListener('resize', resizeTextCanvas);

 

 // Gentle thunk sound for rolling (lighter than landing)

 function playRollingThunk(volume = 0.08, delay = 0) {

 if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); window.audioCtx = audioCtx; }

 const now = audioCtx.currentTime + delay;

 

 // Subtle rolling "tap" sound

 const osc = audioCtx.createOscillator();

 const gain = audioCtx.createGain();

 

 osc.type = 'sine';

 osc.frequency.setValueAtTime(100 + Math.random() * 20, now); // Slight variation

 osc.frequency.exponentialRampToValueAtTime(50, now + 0.05);

 

 gain.gain.setValueAtTime(volume, now);

 gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);

 

 osc.connect(gain);

 gain.connect(audioCtx.destination);

 osc.start(now);

 osc.stop(now + 0.15);

 }

 

 // Heavier thud for jumps and landings

 function playBounceThud(volume = 0.15, delay = 0) {

 if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); window.audioCtx = audioCtx; }

 const now = audioCtx.currentTime + delay;

 

 // Deep impact sound

 const osc = audioCtx.createOscillator();

 const gain = audioCtx.createGain();

 

 osc.type = 'sine';

 osc.frequency.setValueAtTime(60, now); // Deep thud

 osc.frequency.exponentialRampToValueAtTime(30, now + 0.15);

 

 gain.gain.setValueAtTime(volume, now);

 gain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);

 

 osc.connect(gain);

 gain.connect(audioCtx.destination);

 osc.start(now);

 osc.stop(now + 0.25);

 }

 

 // Hollow melodic chime for voxel landing - C pentatonic scale

 function playVoxelChime(delay = 0) {

 if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); window.audioCtx = audioCtx; }

 const now = audioCtx.currentTime + delay;

 

 // Pentatonic scale notes for melodic chimes (C, D, E, G, A)

 const pentatonicNotes = [523.25, 587.33, 659.25, 783.99, 880]; // C5, D5, E5, G5, A5

 const fundamentalFreq = pentatonicNotes[Math.floor(Math.random() * pentatonicNotes.length)];

 

 // Hollow sound: triangle wave with filtered overtones

 const osc1 = audioCtx.createOscillator();

 const osc2 = audioCtx.createOscillator();

 const osc3 = audioCtx.createOscillator();

 const filter = audioCtx.createBiquadFilter();

 const gain = audioCtx.createGain();

 

 osc1.type = 'triangle'; // Hollow fundamental

 osc1.frequency.setValueAtTime(fundamentalFreq, now);

 

 osc2.type = 'sine'; // Soft overtone

 osc2.frequency.setValueAtTime(fundamentalFreq * 3, now);

 

 osc3.type = 'sine'; // Gentle fifth

 osc3.frequency.setValueAtTime(fundamentalFreq * 1.5, now);

 

 // Band-pass filter for hollow character

 filter.type = 'bandpass';

 filter.frequency.setValueAtTime(fundamentalFreq * 2, now);

 filter.Q.setValueAtTime(2, now);

 

 // Gentle envelope

 gain.gain.setValueAtTime(0, now);

 gain.gain.linearRampToValueAtTime(0.03, now + 0.01);

 gain.gain.exponentialRampToValueAtTime(0.001, now + 1.2);

 

 osc1.connect(filter);

 osc2.connect(gain);

 osc3.connect(gain);

 filter.connect(gain);

 gain.connect(audioCtx.destination);

 

 osc1.start(now);

 osc2.start(now);

 osc3.start(now);

 osc1.stop(now + 1.2);

 osc2.stop(now + 1.2);

 osc3.stop(now + 1.2);

 }

 

 // Chiptune music system - simple arpeggio + drums

 let chiptuneBass = null;

 let chiptuneGain = null;

 let lastNoteTime = 0;

 let lastDrumTime = 0;

 let noteIndex = 0;

 let drumIndex = 0;

 let musicStarted = false;

 let reverbDelay = null;

 let reverbGain = null;

 let reverbFeedback = null;

 let glitchWhirOsc1 = null;

 let glitchWhirOsc2 = null;

 let glitchWhirOsc3 = null;

 let glitchWhirGain = null;

 let glitchWhirFilter = null;

 let glitchWhirStarted = false;

 

 function updateSynth(t) {

 // Start music during triangle phase

 if (!musicStarted && t > introCfg.bounceEnd) {

 if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); window.audioCtx = audioCtx; }

 

 // Create reverb delay effect

 reverbDelay = audioCtx.createDelay(2.0);

 reverbDelay.delayTime.value = 0.25; // 250ms delay

 reverbGain = audioCtx.createGain();

 reverbGain.gain.value = 0.3; // Moderate reverb mix

 reverbFeedback = audioCtx.createGain();

 reverbFeedback.gain.value = 0.4; // Feedback for reverb tail

 

 // Wire up reverb: delay -> feedback -> delay (loop) + output

 reverbDelay.connect(reverbFeedback);

 reverbFeedback.connect(reverbDelay);

 reverbDelay.connect(reverbGain);

 reverbGain.connect(audioCtx.destination);

 

 musicStarted = true;

 lastNoteTime = t;

 lastDrumTime = t;

 }

 

 if (!musicStarted || !audioCtx) return;

 

 const now = audioCtx.currentTime;

 

 // Determine arpeggio and rhythm based on phase

 let arpeggio = [];

 let noteSpeed = 0.25;

 let drumSpeed = 0.5;

 let drumVolume = 0.12;

 let drumReverb = 0.2;

 let reverbMix = 0.3;

 let glitchLevel = 0;

 

 if (t < introCfg.triangleEnd) {

 // Calm, contemplative Am progression

 arpeggio = [220.00, 261.63, 329.63, 261.63]; // A3, C4, E4, C4

 noteSpeed = 0.5;

 drumSpeed = 1.2;

 drumVolume = 0.08;

 drumReverb = 0.25;

 reverbMix = 0.35;

 } else if (t < introCfg.normalEnd) {

 // Gentle progression with suspension

 arpeggio = [220.00, 246.94, 293.66, 329.63, 293.66, 246.94]; // A3, B3, D4, E4, D4, B3

 noteSpeed = 0.45;

 drumSpeed = 1.0;

 drumVolume = 0.1;

 drumReverb = 0.3;

 reverbMix = 0.4;

 } else if (t < introCfg.vennEnd) {

 // Subdued, introspective

 arpeggio = [196.00, 246.94, 293.66, 349.23, 293.66, 246.94]; // G3, B3, D4, F4, D4, B3

 noteSpeed = 0.4;

 drumSpeed = 0.9;

 drumVolume = 0.12;

 drumReverb = 0.4;

 reverbMix = 0.45;

 } else if (t < introCfg.collapseEnd) {

 // Building unease, drums more present

 arpeggio = [220.00, 277.18, 329.63, 392.00, 329.63, 277.18]; // A3, C#4, E4, G4, E4, C#4

 noteSpeed = 0.38;

 drumSpeed = 0.7;

 drumVolume = 0.16; // Drums becoming more prominent

 drumReverb = 0.6;

 reverbMix = 0.5;

 glitchLevel = 0.1;

 } else if (t < introCfg.glitchEnd) {

 // Dissonant breakdown, drums dominate

 const glitchProgress = (t - introCfg.collapseEnd) / (introCfg.glitchEnd - introCfg.collapseEnd);

 arpeggio = [233.08, 277.18, 369.99, 415.30]; // Diminished, unsettling

 noteSpeed = 0.35;

 drumSpeed = 0.55;

 drumVolume = THREE.MathUtils.lerp(0.18, 0.28, glitchProgress); // Drums take over

 drumReverb = THREE.MathUtils.lerp(0.6, 0.85, glitchProgress);

 reverbMix = THREE.MathUtils.lerp(0.5, 0.65, glitchProgress);

 glitchLevel = THREE.MathUtils.lerp(0.2, 0.8, glitchProgress);

 } else {

 return;

 }

 

 // Update reverb mix

 if (reverbGain) {

 reverbGain.gain.setTargetAtTime(reverbMix, now, 0.5);

 }

 

 // Play arpeggio notes

 if (t - lastNoteTime >= noteSpeed) {

 const freq = arpeggio[noteIndex % arpeggio.length];

 playChiptuneNote(freq, noteSpeed * 0.9, glitchLevel, reverbDelay);

 noteIndex++;

 lastNoteTime = t;

 }

 

 // Play drum beats

 if (t - lastDrumTime >= drumSpeed) {

 playChiptuneDrum(drumVolume, drumReverb, glitchLevel, reverbDelay);

 drumIndex++;

 lastDrumTime = t;

 }

 

 // Corrupted whir during glitch phase

 if (t >= introCfg.collapseEnd && t < introCfg.glitchEnd) {

 const glitchProgress = (t - introCfg.collapseEnd) / (introCfg.glitchEnd - introCfg.collapseEnd);

 

 if (!glitchWhirStarted) {

 // Start the harsh whirring synth

 glitchWhirOsc1 = audioCtx.createOscillator();

 glitchWhirOsc2 = audioCtx.createOscillator();

 glitchWhirOsc3 = audioCtx.createOscillator();

 glitchWhirGain = audioCtx.createGain();

 glitchWhirFilter = audioCtx.createBiquadFilter();

 

 // Triangle waves for harsh, mechanical sound

 glitchWhirOsc1.type = 'triangle';

 glitchWhirOsc2.type = 'triangle';

 glitchWhirOsc3.type = 'triangle';

 

 // Detuning for thickness

 glitchWhirOsc1.detune.value = -8;

 glitchWhirOsc2.detune.value = 0;

 glitchWhirOsc3.detune.value = 8;

 

 // Start at low frequency

 glitchWhirOsc1.frequency.setValueAtTime(220, now);

 glitchWhirOsc2.frequency.setValueAtTime(220, now);

 glitchWhirOsc3.frequency.setValueAtTime(220, now);

 

 // Resonant filter for harsh whir

 glitchWhirFilter.type = 'lowpass';

 glitchWhirFilter.frequency.setValueAtTime(400, now);

 glitchWhirFilter.Q.setValueAtTime(8, now);

 

 glitchWhirGain.gain.setValueAtTime(0, now);

 glitchWhirGain.gain.linearRampToValueAtTime(0.08, now + 0.5);

 

 glitchWhirOsc1.connect(glitchWhirFilter);

 glitchWhirOsc2.connect(glitchWhirFilter);

 glitchWhirOsc3.connect(glitchWhirFilter);

 glitchWhirFilter.connect(glitchWhirGain);

 glitchWhirGain.connect(audioCtx.destination);

 

 glitchWhirOsc1.start(now);

 glitchWhirOsc2.start(now);

 glitchWhirOsc3.start(now);

 

 glitchWhirStarted = true;

 }

 

 // Modulate frequency for failing sound

 if (glitchWhirOsc1) {

 const crackle = Math.sin(t * 100) * 20 * glitchProgress;

 const whir = Math.sin(t * 30) * 10;

 const baseFreq = THREE.MathUtils.lerp(220, 55, glitchProgress); // Pitch down as it fails

 

 glitchWhirOsc1.frequency.setTargetAtTime(baseFreq + crackle + whir, now, 0.02);

 glitchWhirOsc2.frequency.setTargetAtTime(baseFreq + crackle + whir * 1.1, now, 0.02);

 glitchWhirOsc3.frequency.setTargetAtTime(baseFreq + crackle + whir * 0.9, now, 0.02);

 

 // Filter sweep downward

 glitchWhirFilter.frequency.setTargetAtTime(THREE.MathUtils.lerp(400, 100, glitchProgress), now, 0.1);

 

 // Volume swell and fade

 const vroomPhase = Math.sin(t * 2) * 0.5 + 0.5;

 const fadeOut = 1 - glitchProgress * 0.7; // Fade out near end

 glitchWhirGain.gain.setTargetAtTime(0.08 * fadeOut * vroomPhase, now, 0.05);

 }

 } else if (glitchWhirStarted && glitchWhirOsc1) {

 // Stop the whir after glitch phase

 glitchWhirOsc1.stop(now + 0.5);

 glitchWhirOsc2.stop(now + 0.5);

 glitchWhirOsc3.stop(now + 0.5);

 glitchWhirOsc1 = null;

 glitchWhirOsc2 = null;

 glitchWhirOsc3 = null;

 }

 }

 

 // Chiptune note player - muted, musical synth

 function playChiptuneNote(freq, duration, glitchLevel = 0, reverbNode = null) {

 if (!audioCtx) return;

 const now = audioCtx.currentTime;

 

 const osc1 = audioCtx.createOscillator();

 const osc2 = audioCtx.createOscillator();

 const gain = audioCtx.createGain();

 const filter = audioCtx.createBiquadFilter();

 

 // Sine waves for muted, warm tone

 osc1.type = 'sine';

 osc2.type = 'sine';

 

 // Add subtle harmonic (5th) for richness

 const glitchWobble = glitchLevel > 0 ? (Math.random() - 0.5) * freq * glitchLevel * 0.2 : 0;

 osc1.frequency.setValueAtTime(freq + glitchWobble, now);

 osc2.frequency.setValueAtTime((freq * 1.5) + glitchWobble, now); // Perfect 5th

 

 // Muted low-pass filter

 filter.type = 'lowpass';

 filter.frequency.setValueAtTime(glitchLevel > 0.5 ? 600 : 1200, now);

 filter.Q.setValueAtTime(0.3, now);

 

 // Very soft, gentle envelope

 const baseVol = 0.045 * (1 - glitchLevel * 0.3);

 gain.gain.setValueAtTime(0, now);

 gain.gain.linearRampToValueAtTime(baseVol, now + 0.03);

 gain.gain.setValueAtTime(baseVol * 0.85, now + duration * 0.5);

 gain.gain.linearRampToValueAtTime(0, now + duration);

 

 osc1.connect(filter);

 osc2.connect(filter);

 filter.connect(gain);

 gain.connect(audioCtx.destination);

 

 // Connect to reverb if available

 if (reverbNode) {

 gain.connect(reverbNode);

 }

 

 osc1.start(now);

 osc2.start(now);

 osc1.stop(now + duration);

 osc2.stop(now + duration);

 }

 

 // Startup bass sound (Simple warm chord - NO REVERB to prevent oscillation)

 function playStartupBass() {

 if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); window.audioCtx = audioCtx; }

 const now = audioCtx.currentTime;

 

 // Master output - simple, clean

 const masterGain = audioCtx.createGain();

 masterGain.gain.value = 0.4;

 masterGain.connect(audioCtx.destination);

 

 // Simple warm chord - C major

 const chordNotes = [

 { freq: 130.81, vol: 0.10 }, // C3

 { freq: 164.81, vol: 0.08 }, // E3

 { freq: 196.00, vol: 0.07 }, // G3

 { freq: 65.41, vol: 0.09 }, // C2 (bass)

 ];

 

 chordNotes.forEach((note, i) => {

 const osc = audioCtx.createOscillator();

 const oscGain = audioCtx.createGain();

 

 osc.type = 'sine';

 osc.frequency.value = note.freq; // Fixed frequency, no modulation

 

 // Simple envelope

 const delay = i * 0.08;

 oscGain.gain.setValueAtTime(0, now + delay);

 oscGain.gain.linearRampToValueAtTime(note.vol, now + delay + 0.15);

 oscGain.gain.setValueAtTime(note.vol * 0.9, now + delay + 0.6);

 oscGain.gain.linearRampToValueAtTime(0, now + delay + 1.5);

 

 osc.connect(oscGain);

 oscGain.connect(masterGain);

 

 osc.start(now + delay);

 osc.stop(now + delay + 1.6);

 });

 }

 

 // Distorted startup bass sound - progressively more distorted per click

 function playStartupBassDistorted(clickCount = 1) {

 if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); window.audioCtx = audioCtx; }

 const now = audioCtx.currentTime;

 

 // Distortion increases with each click

 const distortionLevel = clickCount * 0.3; // 0.3, 0.6, 0.9

 

 // Master output with distortion

 const masterGain = audioCtx.createGain();

 masterGain.gain.value = 0.4;

 

 // Add waveshaper for distortion

 const distortion = audioCtx.createWaveShaper();

 const curve = new Float32Array(256);

 const deg = Math.PI / 180;

 const amount = distortionLevel * 100; // 30, 60, 90

 for (let i = 0; i < 256; i++) {

 const x = (i * 2) / 256 - 1;

 curve[i] = ((3 + amount) * x * 20 * deg) / (Math.PI + amount * Math.abs(x));

 }

 distortion.curve = curve;

 distortion.oversample = '4x';

 

 masterGain.connect(distortion);

 distortion.connect(audioCtx.destination);

 

 // Chord notes with detuning that increases per click

 const chordNotes = [

 { freq: 130.81, vol: 0.10 }, // C3

 { freq: 164.81, vol: 0.08 }, // E3

 { freq: 196.00, vol: 0.07 }, // G3

 { freq: 65.41, vol: 0.09 }, // C2 (bass)

 ];

 

 chordNotes.forEach((note, i) => {

 const osc = audioCtx.createOscillator();

 const oscGain = audioCtx.createGain();

 const filter = audioCtx.createBiquadFilter();

 

 osc.type = 'sawtooth'; // More harmonics for distortion

 

 // Add detuning/wobble based on click count

 const detune = (Math.random() - 0.5) * clickCount * 15;

 osc.frequency.setValueAtTime(note.freq + detune, now);

 

 // Add frequency wobble during playback

 osc.frequency.linearRampToValueAtTime(note.freq + detune * 1.5, now + 0.3);

 osc.frequency.linearRampToValueAtTime(note.freq + detune * 0.5, now + 1.0);

 

 // Filter gets more aggressive with each click

 filter.type = 'lowpass';

 filter.frequency.setValueAtTime(2000 - clickCount * 400, now);

 filter.Q.value = 1 + clickCount * 0.5;

 

 // Envelope

 const delay = i * 0.08;

 oscGain.gain.setValueAtTime(0, now + delay);

 oscGain.gain.linearRampToValueAtTime(note.vol * (1 + distortionLevel * 0.3), now + delay + 0.15);

 oscGain.gain.setValueAtTime(note.vol * 0.9, now + delay + 0.6);

 oscGain.gain.linearRampToValueAtTime(0, now + delay + 1.5);

 

 osc.connect(filter);

 filter.connect(oscGain);

 oscGain.connect(masterGain);

 

 osc.start(now + delay);

 osc.stop(now + delay + 1.6);

 });

 

 // Add noise for extra degradation on later clicks

 if (clickCount >= 2) {

 const noiseBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 1.5, audioCtx.sampleRate);

 const noiseData = noiseBuffer.getChannelData(0);

 for (let i = 0; i < noiseData.length; i++) {

 noiseData[i] = (Math.random() * 2 - 1) * 0.1 * (clickCount - 1);

 }

 const noiseSource = audioCtx.createBufferSource();

 const noiseGain = audioCtx.createGain();

 noiseSource.buffer = noiseBuffer;

 noiseGain.gain.setValueAtTime(0, now);

 noiseGain.gain.linearRampToValueAtTime(0.05 * clickCount, now + 0.2);

 noiseGain.gain.linearRampToValueAtTime(0, now + 1.4);

 noiseSource.connect(noiseGain);

 noiseGain.connect(masterGain);

 noiseSource.start(now);

 noiseSource.stop(now + 1.5);

 }

 }

 

 // Chiptune drum player

 function playChiptuneDrum(volume = 0.12, reverbAmount = 0.3, glitchLevel = 0, reverbNode = null) {

 if (!audioCtx) return;

 const now = audioCtx.currentTime;

 

 // Kick drum

 const osc = audioCtx.createOscillator();

 const gain = audioCtx.createGain();

 const reverbSend = audioCtx.createGain();

 

 osc.type = 'sine';

 const startFreq = glitchLevel > 0.5 ? 80 + Math.random() * 40 : 60;

 osc.frequency.setValueAtTime(startFreq, now);

 osc.frequency.exponentialRampToValueAtTime(30, now + 0.1);

 

 // Main drum volume (dominant)

 gain.gain.setValueAtTime(volume, now);

 gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);

 

 // Reverb send amount

 reverbSend.gain.setValueAtTime(volume * reverbAmount, now);

 reverbSend.gain.exponentialRampToValueAtTime(0.001, now + 0.3); // Longer reverb tail

 

 osc.connect(gain);

 gain.connect(audioCtx.destination);

 

 // Send to reverb

 if (reverbNode) {

 osc.connect(reverbSend);

 reverbSend.connect(reverbNode);

 }

 

 osc.start(now);

 osc.stop(now + 0.3);

 }

 

 function frame(){

 if(!running) return;

 const dt = Math.min(clock.getDelta(), 0.033);

 totalTime += dt;

 updatePositions(totalTime);

 updateSynth(totalTime);

 blackHole.material.uniforms.time.value = totalTime;

 filmPass.uniforms.time.value += dt;

 composer.render();

 

 // Update and render text particles

 updateTextParticles(dt);

 textCtx.clearRect(0, 0, textCanvas.width, textCanvas.height);

 renderTextParticles(textCtx, camera);

 

 // Update voxels for CELLI animation

 updateVoxels(totalTime, dt);

 

 // Update floating voxels during burst

 updateFloatingVoxels(dt);

 

 // Update camera pan

 updateCameraPan();

 

 requestAnimationFrame(frame);

 }



 // --- Click interaction on spheres ----------------------------------------

 const raycaster = new THREE.Raycaster();

 const mouse = new THREE.Vector2();

 

 renderer.domElement.addEventListener('click', (event) => {

 if (!running) return;

 

 mouse.x = (event.clientX / window.innerWidth) * 2 - 1;

 mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

 

 raycaster.setFromCamera(mouse, camera);

 const intersects = raycaster.intersectObjects(spheres);

 

 if (intersects.length > 0) {

 const hitSphere = intersects[0].object;

 const sphereIndex = spheres.indexOf(hitSphere);

 const hitPos = intersects[0].point;

 

 // Burst particles based on color

 let texts, color;

 if (sphereIndex === 0) { // Cyan - equations

 texts = equationTexts;

 color = '#00a8ff';

 } else if (sphereIndex === 1) { // Yellow - time

 texts = Array(8).fill(0).map(() => timeTexts());

 color = '#ffb62e';

 } else { // Magenta - manic

 texts = manicTexts;

 color = '#ff1e6e';

 }

 

 // Create burst of 5-8 particles

 const count = 5 + Math.floor(Math.random() * 4);

 for (let i = 0; i < count; i++) {

 const text = texts[Math.floor(Math.random() * texts.length)];

 createTextParticle(hitPos.x, hitPos.y, text, color, sphereIndex);

 }

 }

 });



 // --- Doorway input keyboard and click interaction ------------------------------------

 const promptContainer = document.querySelector('.prompt-container');

 const promptTextEl = document.getElementById('promptText');

 const promptCursorEl = document.getElementById('promptCursor');

 const hiddenInput = document.getElementById('hiddenInput');

 const promptEl = document.querySelector('.prompt');

 

 // Helper function to wrap each character with per-character shadow

 function updatePromptWithChars(text) {

 if (!promptTextEl) return;

 promptTextEl.innerHTML = '';

 for (let i = 0; i < text.length; i++) {

 const char = text[i];

 const span = document.createElement('span');

 span.className = 'char';

 span.setAttribute('data-char', char);

 span.textContent = char;

 promptTextEl.appendChild(span);

 }

 }

 

 // Click to trigger CELLI glitch (reveal T) and focus hidden input for mobile

 if (promptContainer) {

 function focusHiddenPromptInput() {

 if (!hiddenInput) return;



 hiddenInput.value = '';



 const focusOptions = { preventScroll: true };

 try {

 hiddenInput.focus(focusOptions);

 } catch (err) {

 hiddenInput.focus();

 }



 if (document.activeElement !== hiddenInput) {

 hiddenInput.focus();

 }

 }



 promptContainer.addEventListener('click', () => {

 if (!running || burstAnimStarted) return;

 if (!inputAttempted) {

 triggerCelliGlitch();

 inputAttempted = true;

 }



 if (hiddenInput) {

 focusHiddenPromptInput();

 }

 });

 

 function handlePromptBackspace() {

 if (!running || !doorwayOpened || burstAnimStarted) return false;

 if (inputText.length <= promptBaseText.length) return false;



 inputText = inputText.slice(0, -1);

 tEntered = false;



 updatePromptWithChars(inputText);

 promptCursorEl.textContent = '_';

 if (promptEl) {

 promptEl.setAttribute('data-text', inputText + '_');

 }



 if (hiddenInput) {

 hiddenInput.value = '';

 }



 if (burstTimeout) {

 clearTimeout(burstTimeout);

 burstTimeout = null;

 }



 // Restore one letter with fritz effect

 restoreOneLetter();

 return true;

 }



 // Keyboard input to trigger final sequence (desktop)

 window.addEventListener('keydown', (e) => {

 if (!running || !doorwayOpened || !inputAttempted) return;



 if (e.key === 'Backspace') {

 e.preventDefault();

 handlePromptBackspace();

 return;

 }



 // T input - starts burst sequence

 if (!tEntered && e.key.toLowerCase() === 't') {

 e.preventDefault();

 tEntered = true;

 inputText += 'T';



 // Update display

 updatePromptWithChars(inputText);

 promptCursorEl.textContent = '_';

 if (promptEl) {

 promptEl.setAttribute('data-text', inputText + '_');

 }



 if (burstTimeout) {

 clearTimeout(burstTimeout);

 }

 burstTimeout = setTimeout(() => {

 triggerBurstToStars();

 }, 500);

 return;

 }

 

 // E, N, D inputs - only after STAR is fully cleared and yellow transformation complete

 if (inputText === '=' && allYellowTransformed) {

 const key = e.key.toUpperCase();

 

 console.log('END input detected:', key, 'endSequence:', endSequence, 'allYellowTransformed:', allYellowTransformed);

 

 // E must be first

 if (endSequence === '' && key === 'E') {

 e.preventDefault();

 endSequence = 'E';

 transformToMagentaRed();

 updatePromptWithChars('=E');

 if (promptEl) promptEl.setAttribute('data-text', '=E_');

 console.log('Transformed to MAGENTA');

 return;

 }

 

 // N must be second (after E)

 if (endSequence === 'E' && key === 'N') {

 e.preventDefault();

 endSequence = 'EN';

 transformToCyanBlue();

 updatePromptWithChars('=EN');

 if (promptEl) promptEl.setAttribute('data-text', '=EN_');

 console.log('Transformed to CYAN');

 return;

 }

 

 // D must be third (after EN)

 if (endSequence === 'EN' && key === 'D') {

 e.preventDefault();

 endSequence = 'END';

 transformToGreenAndSquare();

 updatePromptWithChars('=END');

 if (promptEl) promptEl.setAttribute('data-text', '=END_');

 console.log('Transformed to GREEN, starting snap animation');

 return;

 }

 } else if (inputText === '=') {

 console.log('Input is =, but allYellowTransformed is:', allYellowTransformed);

 }

 });

 

 // Mobile input handler

 if (hiddenInput) {

 hiddenInput.addEventListener('beforeinput', (e) => {

 if (!running || !doorwayOpened || !inputAttempted) return;

 if (e.inputType === 'deleteContentBackward') {

 e.preventDefault();

 handlePromptBackspace();

 }

 });



 hiddenInput.addEventListener('input', (e) => {

 if (!running || !doorwayOpened || !inputAttempted) return;



 const value = (e.target.value || '').toUpperCase();



 if (value === '') {

 handlePromptBackspace();

 return;

 }



 // T input for burst sequence

 if (!tEntered && value.includes('T')) {

 e.preventDefault();

 tEntered = true;

 inputText += 'T';



 updatePromptWithChars(inputText);

 promptCursorEl.textContent = '_';

 if (promptEl) {

 promptEl.setAttribute('data-text', inputText + '_');

 }



 e.target.value = '';



 if (burstTimeout) {

 clearTimeout(burstTimeout);

 }

 burstTimeout = setTimeout(() => {

 triggerBurstToStars();

 }, 500);



 hiddenInput.blur();

 return;

 }

 

 // E, N, D inputs after STAR cleared and yellow transformation

 if (inputText === '=' && allYellowTransformed) {

 // E must be first

 if (endSequence === '' && value.includes('E')) {

 e.preventDefault();

 endSequence = 'E';

 transformToMagentaRed();

 updatePromptWithChars('=E');

 if (promptEl) promptEl.setAttribute('data-text', '=E_');

 e.target.value = '';

 return;

 }

 

 // N must be second

 if (endSequence === 'E' && value.includes('N')) {

 e.preventDefault();

 endSequence = 'EN';

 transformToCyanBlue();

 updatePromptWithChars('=EN');

 if (promptEl) promptEl.setAttribute('data-text', '=EN_');

 e.target.value = '';

 return;

 }

 

 // D must be third

 if (endSequence === 'EN' && value.includes('D')) {

 e.preventDefault();

 endSequence = 'END';

 transformToGreenAndSquare();

 updatePromptWithChars('=END');

 if (promptEl) promptEl.setAttribute('data-text', '=END_');

 e.target.value = '';

 return;

 }

 }

 

 // Clear any other input

 e.target.value = '';

 });

 }

 }

 

 // Break apart and rise to sky

 let breakApartStarted = false;

 let riseStartTime = 0;

 

 function triggerBurstToStars() {

 if (burstAnimStarted) return;

 burstAnimStarted = true;

 burstTimeout = null;

 breakApartStarted = true;

 riseStartTime = Date.now();



 const skipBtn = document.getElementById('skipBtn');

 if (skipBtn) {

 skipBtn.classList.remove('illuminating');

 }



 // Increase afterimage effect for dramatic trails

 afterimagePass.uniforms.damp.value = 0.88;

 

 // Hide prompt but keep it for reference

 if (promptEl) {

 promptEl.style.transition = 'opacity 0.5s ease';

 promptEl.style.opacity = '0';

 }

 

 // Get only the T-shape voxels (the ones that weren't glitched)

 const activeVoxels = voxels.filter(v => !v.userData.glitched && v.visible);

 

 // Give each voxel velocity to shoot upward dramatically

 activeVoxels.forEach((voxel, idx) => {

 setTimeout(() => {

 const angle = Math.random() * Math.PI * 2;

 const spreadH = 0.008 + Math.random() * 0.015; // More horizontal spread

 

 voxel.userData.floating = true;

 voxel.userData.vx = Math.cos(angle) * spreadH;

 voxel.userData.vy = 0.08 + Math.random() * 0.05; // MUCH faster upward - shooting motion

 voxel.userData.vz = -0.05 - Math.random() * 0.08; // Move away from camera (into distance)

 voxel.userData.pulsatePhase = Math.random() * Math.PI * 2;

 voxel.userData.pulsateSpeed = 3 + Math.random() * 3;

 voxel.userData.floatStartTime = Date.now();

 voxel.userData.initialScale = voxel.userData.baseScale || 1.0;

 }, idx * 15); // Faster stagger

 });

 

 // Start camera pan after voxels have shot into distance

 setTimeout(() => {

 startCameraPan();

 }, 4000); // Slightly longer to see them recede

 }

 

 // Update floating voxels

 function updateFloatingVoxels(dt) {

 if (!breakApartStarted) return;

 

 const now = Date.now();

 const totalElapsed = (now - riseStartTime) / 1000;

 

 voxels.forEach(voxel => {

 if (!voxel.userData.floating) return;

 

 const data = voxel.userData;

 const age = (now - data.floatStartTime) / 1000;

 

 // Move with velocity - shooting into distance

 voxel.position.x += data.vx;

 voxel.position.y += data.vy;

 voxel.position.z += data.vz;

 

 // Very slow drag to maintain shooting motion

 data.vx *= 0.985;

 data.vy *= 0.985;

 data.vz *= 0.985;

 

 // Scale down dramatically as they move away (perspective)

 // Based on Z distance from camera

 const distanceZ = Math.abs(voxel.position.z + 0.5); // Initial Z was around -0.5

 const perspectiveScale = 1 / (1 + distanceZ * 3); // Shrink rapidly with distance

 

 // Pulsate on top of perspective scaling

 data.pulsatePhase += data.pulsateSpeed * dt;

 const pulse = 0.85 + Math.sin(data.pulsatePhase) * 0.15;

 const baseScale = data.initialScale || 1.0;

 const finalScale = baseScale * pulse * perspectiveScale;

 voxel.scale.set(finalScale, finalScale, finalScale);

 

 // Brighten voxels during shooting (they're stars now)

 voxel.material.color.setRGB(1, 1, 1); // Pure white

 

 // Pulsate material opacity with distance fade

 const opacityPulse = 0.8 + Math.sin(data.pulsatePhase * 0.7) * 0.2;

 const distanceFade = Math.max(0.3, 1 - distanceZ * 0.4); // Fade as they get far

 voxel.material.opacity = Math.min(1.0, opacityPulse * distanceFade);

 data.edges.material.opacity = Math.min(0.8, opacityPulse * 0.8 * distanceFade);

 

 // Fade out during camera pan

 if (cameraPanStarted) {

 const panProgress = (now - panStartTime) / panDuration;

 const fadeStart = 0.5;

 if (panProgress > fadeStart) {

 const fadeProgress = (panProgress - fadeStart) / (1 - fadeStart);

 voxel.material.opacity *= (1 - fadeProgress * 0.8);

 data.edges.material.opacity *= (1 - fadeProgress * 0.8);

 }

 }

 });

 }

 

 // Pan camera down to reveal gradient

 let cameraPanStarted = false;

 let panStartTime = 0;

 const panDuration = 5000; // 5 seconds for dramatic reveal

 

 function startCameraPan() {

 cameraPanStarted = true;

 panStartTime = Date.now();

 }

 

 function updateCameraPan() {

 if (!cameraPanStarted) return;

 

 const elapsed = Date.now() - panStartTime;

 const progress = Math.min(1, elapsed / panDuration);

 

 // Smooth ease-in-out for dramatic pan

 const eased = progress < 0.5 ? 

 2 * progress * progress : 

 1 - Math.pow(-2 * progress + 2, 2) / 2;

 

 // Gradually reduce afterimage effect during pan to fade trails

 afterimagePass.uniforms.damp.value = THREE.MathUtils.lerp(0.88, 0.96, progress);

 

 // Pan down much further to reveal gradient

 camera.position.y = THREE.MathUtils.lerp(0, -5, eased);

 camera.lookAt(0, camera.position.y - 2, 0); // Look ahead of camera position

 

 // Fade doorway, prompt, and vignette quickly

 const doorway = document.getElementById('doorway');

 if (doorway) {

 doorway.style.opacity = Math.max(0, 1 - progress * 2);

 }

 

 // Fade out vignette

 const vignette = document.querySelector('.vignette');

 if (vignette) {

 vignette.style.transition = 'opacity 1s ease';

 vignette.style.opacity = String(Math.max(0, 1 - progress * 1.5));

 }

 

 // Add blue gradient background early in the pan

 if (progress > 0.2 && !document.getElementById('nightSky')) {

 // Set app background to black initially for smooth transition

 const app = document.getElementById('app');

 if (app) {

 app.style.background = '#000';

 }

 

 // Immediately hide vignette and scanlines when gradient appears

 const vignetteEl = document.querySelector('.vignette');

 if (vignetteEl) {

 vignetteEl.style.display = 'none';

 }

 

 // Hide scanlines overlay

 if (app && app.classList.contains('scanlines')) {

 app.classList.add('fade-scanlines');

 }

 

 const nightSky = document.createElement('div');

 nightSky.id = 'nightSky';

 nightSky.style.position = 'fixed';

 nightSky.style.inset = '0';

 nightSky.style.background = 'linear-gradient(to bottom, #0d1b2a 0%, #1a237e 20%, #283593 40%, #3949ab 60%, #5e92f3 80%, #90caf9 100%)';

 nightSky.style.zIndex = '0';

 nightSky.style.opacity = '0';

 nightSky.style.pointerEvents = 'none';

 

 // Insert at beginning of body

 if (document.body.firstChild) {

 document.body.insertBefore(nightSky, document.body.firstChild);

 } else {

 document.body.appendChild(nightSky);

 }

 

 // Fade in gradient

 setTimeout(() => {

 nightSky.style.transition = 'opacity 3s ease';

 nightSky.style.opacity = '1';

 

 // Fade out black background

 if (app) {

 app.style.transition = 'background 3s ease';

 app.style.background = 'transparent';

 }

 }, 100);

 }

 

 // Fade out 3D scene elements as gradient appears

 if (progress > 0.3) {

 const fadeAmount = Math.min(1, (progress - 0.3) / 0.7); // Fade from 30% to 100%

 

 // Fade renderer canvas

 renderer.domElement.style.transition = 'opacity 0.5s ease';

 renderer.domElement.style.opacity = String(1 - fadeAmount * 0.8); // Keep slight visibility

 }

 

 // Keep stars visible over the gradient longer

 if (progress > 0.7) {

 const starFade = (progress - 0.7) / 0.3;

 textCanvas.style.opacity = String(1 - starFade);

 }

 }

 

 // Render star particles

 function renderStars() {

 if (starParticles.length === 0) return;

 

 const now = Date.now();

 

 // Update and render each star

 for (let i = starParticles.length - 1; i >= 0; i--) {

 const star = starParticles[i];

 

 // Update position based on velocity

 if (star.vx !== undefined) {

 star.x += star.vx;

 star.y += star.vy;

 star.z += star.vz;

 

 // Very slow drag to keep stars moving

 star.vx *= 0.995;

 star.vy *= 0.995;

 star.vz *= 0.995;

 }

 

 // Calculate age and fade

 const age = (now - star.birthTime) / 1000; // in seconds

 const fadeDuration = 8; // fade over 8 seconds (much slower)

 const fadeProgress = Math.min(1, age / fadeDuration);

 

 // Dim brightness over time - keep them bright longer

 star.brightness = 1 - fadeProgress * 0.5; // Keep 50% minimum

 

 // Update twinkle

 star.twinkle += star.twinkleSpeed * 0.016;

 const twinkleBrightness = 0.8 + Math.sin(star.twinkle) * 0.2;

 const finalBrightness = star.brightness * twinkleBrightness;

 

 // Keep stars visible much longer - only remove when very faint

 if (finalBrightness < 0.05) {

 starParticles.splice(i, 1);

 continue;

 }

 

 // Project to screen space

 const vector = new THREE.Vector3(star.x, star.y, star.z);

 vector.project(camera);

 

 // Check if behind camera

 if (vector.z > 1) continue;

 

 const x = (vector.x + 1) / 2 * window.innerWidth;

 const y = (-vector.y + 1) / 2 * window.innerHeight;

 

 // Size based on distance (z-depth)

 const depthScale = Math.max(0.5, 1 - vector.z * 0.5);

 const renderSize = star.size * window.innerWidth * 0.01 * depthScale;

 

 // Draw voxel as square with slight glow

 const voxelSize = renderSize * 1.5;

 const glowSize = voxelSize * 1.5;

 

 // Outer glow

 const gradient = textCtx.createRadialGradient(x, y, 0, x, y, glowSize);

 gradient.addColorStop(0, `rgba(255, 255, 255, ${finalBrightness * 0.8})`);

 gradient.addColorStop(0.6, `rgba(255, 255, 255, ${finalBrightness * 0.3})`);

 gradient.addColorStop(1, `rgba(255, 255, 255, 0)`);

 textCtx.fillStyle = gradient;

 textCtx.beginPath();

 textCtx.arc(x, y, glowSize, 0, Math.PI * 2);

 textCtx.fill();

 

 // Core voxel - square shape

 textCtx.fillStyle = `rgba(255, 255, 255, ${Math.min(1, finalBrightness * 1.1)})`;

 textCtx.fillRect(x - voxelSize/2, y - voxelSize/2, voxelSize, voxelSize);

 

 // Subtle border for voxel definition

 if (finalBrightness > 0.5) {

 textCtx.strokeStyle = `rgba(255, 255, 255, ${finalBrightness * 0.6})`;

 textCtx.lineWidth = 0.5;

 textCtx.strokeRect(x - voxelSize/2, y - voxelSize/2, voxelSize, voxelSize);

 }

 }

 }



// --- Play button wiring -------------------------------------------------

const playOverlay = document.getElementById('play');

const playBtn = document.getElementById('playBtn');

const skipBtn = document.getElementById('skipBtn');

 

// Idle timeout detection for bloom increase and glitching
let idleTimeoutStart = null;
let idleBloomIncreaseTriggered = false;
let idleGlitchingTriggered = false;
const IDLE_BLOOM_START = 5000; // 5 seconds
const IDLE_GLITCH_START = 8000; // 3 seconds after bloom starts (total 8 seconds)

function resetIdleTimer() {
idleTimeoutStart = Date.now();
idleBloomIncreaseTriggered = false;
idleGlitchingTriggered = false;
if (skipBtn) {
skipBtn.classList.remove('idle-bloom-increase');
skipBtn.classList.remove('idle-glitching');
}
}

function checkIdleTimeout() {
if (!running || !idleTimeoutStart) return;
const idleTime = Date.now() - idleTimeoutStart;

// Start bloom increase after 5 seconds
if (idleTime >= IDLE_BLOOM_START && !idleBloomIncreaseTriggered) {
idleBloomIncreaseTriggered = true;
if (skipBtn) {
skipBtn.classList.add('idle-bloom-increase');
console.log('[Idle] Bloom increase started');
}
}

// Start glitching after bloom reaches max (3 more seconds)
if (idleTime >= IDLE_GLITCH_START && !idleGlitchingTriggered) {
idleGlitchingTriggered = true;
if (skipBtn) {
skipBtn.classList.add('idle-glitching');
console.log('[Idle] Glitching started');
}
}
}

// Check idle timeout every frame
setInterval(checkIdleTimeout, 100);

// Reset idle timer on any interaction
document.addEventListener('click', resetIdleTimer);
document.addEventListener('keydown', resetIdleTimer);
document.addEventListener('mousemove', resetIdleTimer);

playBtn.addEventListener('click', ()=>{

running = true; clock.getDelta();

playOverlay.classList.add('hidden');

// Show skip button (it will be hidden when transitioning to fullhand)
skipBtn.classList.remove('hidden');

clearToast();

// Start idle timeout detection
resetIdleTimer();

frame();

});

// --- TEST button logic: Load and play test.mp3 ---
console.log('%c SCRIPT EXECUTION CHECKPOINT 1: Starting TEST button initialization', 'background: #ff9800; color: #000; font-size: 14px; font-weight: bold; padding: 8px;');

// Wait for DOM to be ready
setTimeout(() => {
console.log('%c CHECKPOINT 2: Inside setTimeout - DOM should be ready', 'background: #ff9800; color: #000; font-size: 14px; font-weight: bold; padding: 8px;');

const testAudioBtn = document.getElementById('testAudioBtn');
console.log(' testAudioBtn lookup result:', testAudioBtn);
console.log(' testAudioBtn is null?', testAudioBtn === null);
console.log(' testAudioBtn is undefined?', testAudioBtn === undefined);
console.log(' testAudioBtn truthy?', !!testAudioBtn);
console.log(' document.readyState:', document.readyState);

// List all buttons to verify
const allButtons = document.querySelectorAll('button');
console.log(' All buttons in document:', allButtons.length);
allButtons.forEach((btn, i) => {
  console.log(`  Button ${i}: id="${btn.id || '(no id)'}", text="${btn.textContent.trim().substring(0, 20)}"`);
});

if (testAudioBtn) {
  console.log('%c TEST BUTTON FOUND!', 'background: #0f0; color: #000; font-size: 14px; font-weight: bold; padding: 8px;');
  console.log(' Button properties:', {
    id: testAudioBtn.id,
    tagName: testAudioBtn.tagName,
    innerHTML: testAudioBtn.innerHTML,
    disabled: testAudioBtn.disabled,
    style: testAudioBtn.getAttribute('style'),
    parentElement: testAudioBtn.parentElement?.tagName
  });

  // Create an HTML5 Audio element for test.mp3 (works with file:// protocol)
  let testAudio = null;

  // Test if event listener is attached
  console.log('%c CHECKPOINT 3: Attaching click event listener', 'background: #ff9800; color: #000; font-size: 14px; font-weight: bold; padding: 8px;');
  
  testAudioBtn.addEventListener('click', (event) => {
    console.log('%c TEST BUTTON CLICKED! ', 'background: #0f0; color: #000; font-size: 18px; font-weight: bold; padding: 10px;');
    console.log(' Event object:', event);
    console.log(' Event target:', event.target);
    console.log(' Event currentTarget:', event.currentTarget);
    console.log(' Event type:', event.type);
    console.log(' Timestamp:', new Date().toISOString());
    console.log(' Performance now:', performance.now());
    console.log(' Document location:', window.location.href);
    console.log(' Document base URI:', document.baseURI);
    console.log(' Current working directory (approx):', window.location.pathname);

    try {
      console.log('%c INSIDE TRY BLOCK', 'background: #ffff00; color: #000; font-size: 14px; font-weight: bold; padding: 4px;');
      
      // Destroy previous audio instance if it exists
      if (testAudio) {
        console.log(' Cleaning up previous audio instance');
        testAudio.pause();
        testAudio.src = '';
      }

      // Try multiple path variations
      const paths = [
        'test.mp3',
        './test.mp3',
        '../test.mp3',
        'c:/Users/Scott/Desktop/test.mp3',
        'C:/Users/Scott/Desktop/test.mp3',
        'file:///c:/Users/Scott/Desktop/test.mp3',
        'file:///C:/Users/Scott/Desktop/test.mp3'
      ];

      console.log(' Trying path variations:', paths);
      console.log(' window.location.href:', window.location.href);
      console.log(' window.location.origin:', window.location.origin);

      // Use the first path
      const audioPath = paths[0];
      console.log(`%c Creating Audio element with path: "${audioPath}"`, 'background: #00ffff; color: #000; font-weight: bold; padding: 4px;');

      // Create new Audio element (HTML5 Audio works with file:// protocol)
      testAudio = new Audio(audioPath);
      console.log(' Audio element created successfully');
      console.log(' Audio constructor:', testAudio.constructor.name);
      console.log(' Audio.src (resolved):', testAudio.src);
      console.log(' Audio.currentSrc:', testAudio.currentSrc);
      console.log(' Audio.readyState:', testAudio.readyState);
      console.log(' Audio.networkState:', testAudio.networkState);

      // Add event listeners for debugging
      testAudio.addEventListener('loadstart', () => {
        console.log('%c loadstart: Browser has started to load the audio', 'background: #90EE90; color: #000; padding: 4px;');
      });

      testAudio.addEventListener('loadedmetadata', () => {
        console.log('%c loadedmetadata: Audio metadata loaded', 'background: #90EE90; color: #000; padding: 4px;');
        console.log(` Duration: ${testAudio.duration} seconds`);
      });

      testAudio.addEventListener('loadeddata', () => {
        console.log('%c loadeddata: Audio file loaded successfully!', 'background: #90EE90; color: #000; padding: 4px;');
        console.log(` Duration: ${testAudio.duration.toFixed(2)} seconds`);
      });

      testAudio.addEventListener('canplay', () => {
        console.log('%c canplay: Audio can play (buffered enough data)', 'background: #90EE90; color: #000; padding: 4px;');
      });

      testAudio.addEventListener('canplaythrough', () => {
        console.log('%c canplaythrough: Audio can play through without buffering', 'background: #90EE90; color: #000; padding: 4px;');
      });

      testAudio.addEventListener('playing', () => {
        console.log('%c playing: Audio is now playing!', 'background: #00ff00; color: #000; font-weight: bold; padding: 4px;');
      });

      testAudio.addEventListener('ended', () => {
        console.log('%c ended: Audio playback finished', 'background: #90EE90; color: #000; padding: 4px;');
      });

      testAudio.addEventListener('error', (e) => {
        console.error('%c AUDIO ERROR EVENT FIRED ', 'background: #ff0000; color: #fff; font-size: 14px; font-weight: bold; padding: 6px;');
        console.error(' Error event:', e);
        console.error(' testAudio.error object:', testAudio.error);
        console.error(' Error code:', testAudio.error?.code);
        console.error(' Error message:', testAudio.error?.message);
        
        const errorMessages = {
          1: 'MEDIA_ERR_ABORTED - The user aborted the audio loading',
          2: 'MEDIA_ERR_NETWORK - A network error occurred while loading',
          3: 'MEDIA_ERR_DECODE - The audio file is corrupted or in an unsupported format',
          4: 'MEDIA_ERR_SRC_NOT_SUPPORTED - The audio source was not found or is not supported'
        };
        
        const errorMsg = errorMessages[testAudio.error?.code] || 'Unknown error';
        console.error(' Interpreted error:', errorMsg);
        
        alert(` Cannot play test.mp3!\n\nError: ${errorMsg}\n\nTried path: ${audioPath}\nResolved to: ${testAudio.src}\n\nMake sure:\n1. test.mp3 exists at: c:\\Users\\Scott\\Desktop\\test.mp3\n2. The file is a valid MP3\n3. Check browser console for details`);
      });

      testAudio.addEventListener('suspend', () => {
        console.log('%c suspend: Browser has suspended loading (file may not exist)', 'background: #ffaa00; color: #000; padding: 4px;');
      });

      testAudio.addEventListener('stalled', () => {
        console.log('%c stalled: Media download has stalled', 'background: #ffaa00; color: #000; padding: 4px;');
      });

      // Attempt to play
      console.log('%c Calling testAudio.play()...', 'background: #00ffff; color: #000; font-weight: bold; padding: 4px;');
      
      const playPromise = testAudio.play();
      console.log(' play() returned:', playPromise);
      console.log(' Is Promise?', playPromise instanceof Promise);
      
      playPromise.then(() => {
        console.log('%c PLAY PROMISE RESOLVED - PLAYBACK STARTED ', 'background: #00ff00; color: #000; font-size: 14px; font-weight: bold; padding: 6px;');
      }).catch(err => {
        console.error('%c PLAY PROMISE REJECTED ', 'background: #ff0000; color: #fff; font-size: 14px; font-weight: bold; padding: 6px;');
        console.error(' Error object:', err);
        console.error(' Error name:', err.name);
        console.error(' Error message:', err.message);
        console.error(' Error stack:', err.stack);
        
        alert(` Playback error: ${err.name}\n${err.message}\n\nTried: ${audioPath}\nResolved to: ${testAudio.src}\n\nThe file may not exist or be accessible.\n\nMake sure test.mp3 is at:\nc:\\Users\\Scott\\Desktop\\test.mp3`);
      });

      console.log('%c Click handler execution completed (async operations still running)', 'background: #00ffff; color: #000; font-weight: bold; padding: 4px;');

    } catch (error) {
      console.error('%c EXCEPTION IN TEST BUTTON HANDLER ', 'background: #ff0000; color: #fff; font-size: 14px; font-weight: bold; padding: 6px;');
      console.error(' Exception object:', error);
      console.error(' Exception name:', error.name);
      console.error(' Exception message:', error.message);
      console.error(' Exception stack:', error.stack);
      alert(` Exception: ${error.name}\n${error.message}\n\nCheck browser console for details.`);
    }
  }, { capture: false, once: false, passive: false });

  console.log('%c TEST BUTTON EVENT LISTENER ATTACHED SUCCESSFULLY ', 'background: #0f0; color: #000; font-size: 14px; font-weight: bold; padding: 8px;');
  console.log(' TEST button initialized (HTML5 Audio mode)');
  console.log(' Click the TEST button to play test.mp3');
  
  // Test button click programmatically
  console.log('%c To test: Programmatically trigger click with: testAudioBtn.click()', 'background: #ffff00; color: #000; padding: 4px;');
  
} else {
  console.error('%c TEST BUTTON NOT FOUND IN DOM! ', 'background: #f00; color: #fff; font-size: 14px; font-weight: bold; padding: 8px;');
  console.error(' testAudioBtn element not found in DOM');
  console.error(' Looking for element with id="testAudioBtn"');
  console.error(' Check if the button exists in the HTML');
  console.error(' Current DOM state:');
  console.error('  - document.body:', document.body);
  console.error('  - document.getElementById("play"):', document.getElementById('play'));
  console.error('  - document.getElementById("playBtn"):', document.getElementById('playBtn'));
}

console.log('%c CHECKPOINT 4: TEST button initialization complete', 'background: #ff9800; color: #000; font-size: 14px; font-weight: bold; padding: 8px;');

}, 100); // Wait 100ms for DOM to be ready

 

 // --- Skip button logic ---------------------------------------------------

 skipBtn.addEventListener('click', () => {

 if (!running) return;

 // Don't allow skip if fullhand/execution environment is active
 if (window.fullhandActive) {
 console.log('?? Skip button disabled - fullhand scene is active');
 return;
 }

 // Jump to CELLI phase

 totalTime = introCfg.celliEnd - 6.0; // Start 6 seconds before celli ends (during trickle/chime)

 

 // Hide all prior elements

 quoteEl.style.visibility = 'hidden';

 quoteEl.style.opacity = '0';

 loomworksEl.style.display = 'none';

 triMesh.visible = false;

 blackHole.visible = false;

 spheres.forEach(s => s.visible = false);

 

 // Setup CELLI

 if (!celliStarted) {

 celliStarted = true;

 celliStartTime = totalTime;

 }

 

 // Don't hide skip button - it will transform into a bow later

 

 // Play startup bass note

 setTimeout(() => {

 playStartupBass();

 }, 500);

 });



 skipBtn.addEventListener('keydown', (event) => {

 if (event.key === 'Enter' || event.key === ' ') {

 event.preventDefault();

 skipBtn.click();

 }

 });
 
 })(); // End of initEnd3Scene IIFE
 } // End of initEnd3Scene function
 
 // Start polling for THREE.js
 waitForTHREE();
 }); // End of DOMContentLoaded

 </script>

 <!-- Twemoji Initialization -->
 <script>
 // Parse emojis throughout the page once loaded
 if (typeof twemoji !== 'undefined') {
 window.addEventListener('DOMContentLoaded', function() {
 twemoji.parse(document.body, {
 folder: 'svg',
 ext: '.svg'
 });
 console.log(' Twemoji initialized');
 });
 
 // Helper function to parse emojis in dynamically added content
 window.parseEmojis = function(element) {
 if (typeof twemoji !== 'undefined') {
 twemoji.parse(element || document.body);
 }
 };
 } else {
 console.warn(' Twemoji not loaded');
 }
 </script>

</body>

</html>
