<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Release Train - Task Intake Visualization</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;700;900&family=Pacifico&display=swap');
    
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      font-family: 'Orbitron', sans-serif;
      background: #000000;
      color: #fff;
      overflow: hidden;
      height: 100vh;
      width: 100vw;
    }
    
    #titleOverlay {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: rgba(0, 0, 0, 0.9);
      z-index: 500;
      opacity: 1;
      transition: opacity 1s;
      pointer-events: none;
    }
    
    #titleOverlay.hidden { opacity: 0; }
    
    .main-title {
      font-size: clamp(3rem, 10vw, 7rem);
      font-weight: 900;
      letter-spacing: 0.1em;
      color: #ffff00;
      text-shadow: 0 0 30px rgba(255, 255, 0, 0.8);
      margin-bottom: 1rem;
      animation: pulse 2s ease-in-out infinite;
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    
    .sub-title {
      font-family: 'Pacifico', cursive;
      font-size: clamp(1.5rem, 5vw, 3rem);
      color: #ff9d1c;
      text-shadow: 0 2px 12px rgba(255, 157, 28, 0.9);
    }
    
    #viewport {
      position: fixed;
      inset: 0;
      overflow: hidden;
      background: #000000;
    }
    
    #scene {
      position: absolute;
      width: 5000px;
      height: 5000px;
      transform-origin: 0 0;
      perspective: 1000px; /* Enable 3D perspective for flip animation */
      z-index: 90; /* Above fx/grain overlays (80, 85) so particles remain visible */
    }
    
    canvas {
      position: absolute;
      top: 0;
      left: 0;
    }
    
    #trackCanvas {
      z-index: 1;
    }
    
    /* Particle canvas now matches fx/grain overlay structure for consistent layering */
    #particleCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 5000px;
      height: 5000px;
      z-index: 100; /* Above track, below fixed overlays - transforms with scene */
      pointer-events: none;
    }

    /* Fixed FX overlay for fire/snow independent of scene transforms */
    #fxOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 80; /* Below particles */
      pointer-events: none;
    }
    /* Film grain overlay slightly above fx overlay, still under particles */
    #grainOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 85; /* Below particles */
      pointer-events: none;
      mix-blend-mode: overlay;
      opacity: 0.25;
    }

    /* Bloom for Assigna tiles */
    #assignaCanvas.bloom {
      filter: drop-shadow(0 0 16px rgba(255,255,255,0.45)) drop-shadow(0 0 28px rgba(255,200,80,0.35)) brightness(1.2) saturate(1.2);
      animation: bloomPulse 2.2s ease-in-out infinite;
    }
    @keyframes bloomPulse {
      0%, 100% { filter: drop-shadow(0 0 12px rgba(255,255,255,0.35)) drop-shadow(0 0 22px rgba(255,200,80,0.28)) brightness(1.12) saturate(1.1); }
      50% { filter: drop-shadow(0 0 24px rgba(255,255,255,0.6)) drop-shadow(0 0 42px rgba(255,200,80,0.5)) brightness(1.3) saturate(1.25); }
    }
    
    #bonusButton {
      position: fixed;
      top: 60%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 1.2rem 2.5rem;
      font-size: clamp(0.9rem, 2vw, 1.4rem);
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      background: linear-gradient(135deg, #ff9d1c, #ff5263);
      color: #fff;
      border: 3px solid #fff;
      border-radius: 12px;
      box-shadow: 0 0 30px rgba(255, 157, 28, 0.6), 0 6px 24px rgba(0, 0, 0, 0.5);
      cursor: pointer;
      z-index: 2000;
      opacity: 0;
      pointer-events: none;
      transition: all 0.3s;
      text-align: center;
      line-height: 1.4;
    }
    
    #bonusButton.visible {
      opacity: 1;
      pointer-events: auto;
    }
    
    #bonusButton:hover {
      transform: translate(-50%, -50%) scale(1.05);
      box-shadow: 0 0 60px rgba(255, 157, 28, 1), 0 12px 48px rgba(0, 0, 0, 0.8);
    }
    
    #bonusButton:active {
      transform: translate(-50%, -50%) scale(0.98);
    }
    
    #bonusButtonSubtext {
      font-size: 0.5em;
      font-weight: 400;
      letter-spacing: 0.05em;
      margin-top: 0.4rem;
      opacity: 0.85;
      text-transform: none;
    }
    
    #bonusCountdown {
      position: absolute;
      top: -40px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.8rem;
      color: #fff;
      opacity: 0.7;
      text-transform: none;
      letter-spacing: 0.05em;
    }

    #segwayButton {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 1.5rem 3rem;
      font-size: clamp(1rem, 2.5vw, 1.6rem);
      font-weight: 800;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      background: linear-gradient(135deg, #6a11cb, #2575fc);
      color: #fff;
      border: 3px solid #fff;
      border-radius: 12px;
      box-shadow: 0 0 30px rgba(42, 117, 252, 0.6), 0 6px 24px rgba(0, 0, 0, 0.5);
      cursor: pointer;
      z-index: 2000;
      opacity: 0;
      pointer-events: none;
      transition: all 0.3s;
    }

    #segwayButton.visible {
      opacity: 1;
      pointer-events: auto;
    }

    #segwayButton:hover {
      transform: translate(-50%, -50%) scale(1.05);
      box-shadow: 0 0 50px rgba(42, 117, 252, 0.9), 0 10px 40px rgba(0, 0, 0, 0.7);
    }

    #segwayButton.glowing {
      animation: segwayGlow 0.8s ease-in-out infinite;
    }

    @keyframes segwayGlow {
      0%, 100% { 
        box-shadow: 0 0 40px rgba(42, 117, 252, 1), 0 0 80px rgba(106, 17, 203, 0.8);
        transform: translate(-50%, -50%) scale(1.05);
      }
      50% { 
        box-shadow: 0 0 80px rgba(42, 117, 252, 1), 0 0 120px rgba(106, 17, 203, 1);
        transform: translate(-50%, -50%) scale(1.1);
      }
    }

    #segwayBall {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 200px;
      height: 200px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.4rem;
      font-weight: 700;
      color: #fff;
      text-align: center;
      padding: 2rem;
      line-height: 1.6;
      box-shadow: 0 0 60px rgba(102, 126, 234, 0.8), inset 0 0 40px rgba(255, 255, 255, 0.2);
      z-index: 3000;
      opacity: 0;
      pointer-events: none;
      transition: all 0.5s ease;
    }

    #segwayBall.visible {
      opacity: 1;
    }

    #segwayBall.expanding {
      width: 300vw;
      height: 300vh;
      font-size: 3rem;
      transition: all 2.5s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 0 200px rgba(102, 126, 234, 1), 0 0 400px rgba(118, 75, 162, 1), inset 0 0 100px rgba(255, 255, 255, 0.4);
    }

    #segwayBall.blackout {
      color: #000;
      transition: color 1.5s ease;
    }

    #segwayCard {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 400px;
      max-width: calc(100vw - 40px);
      background: rgba(255, 255, 255, 0.98);
      border: 2px solid #667eea;
      border-radius: 12px;
      padding: 1.5rem;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3), 0 0 40px rgba(102, 126, 234, 0.4);
      z-index: 3001;
      opacity: 0;
      transform: translateY(-20px);
      pointer-events: none;
      transition: all 0.5s ease;
    }

    #segwayCard.visible {
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
    }

    #segwayCardTitle {
      font-size: 1.3rem;
      font-weight: 800;
      color: #667eea;
      margin-bottom: 1rem;
      font-style: italic;
    }

    #segwayCardContent {
      font-size: 0.95rem;
      line-height: 1.6;
      color: #333;
    }
    
    .train-car {
      position: absolute;
      padding: 0.75rem 1.5rem;
      border: 2px solid;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.15em;
      font-weight: 700;
      white-space: nowrap;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
      z-index: 10;
      transition: filter 0.1s;
    }
    
    .train-car.speed-blur {
      filter: blur(1px);
      box-shadow: 0 4px 16px rgba(255, 255, 255, 0.3), 0 0 20px rgba(255, 255, 255, 0.2);
    }
    
    .priority-badge {
      position: absolute;
      top: -8px;
      right: -8px;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 900;
      border: 2px solid;
    }
    
    #intakeSystem {
      position: absolute;
      width: 700px;
      z-index: 50;
      opacity: 0;
      transition: opacity 0.8s;
      perspective: 1200px; /* Enable 3D perspective for hinge effect */
      transform-style: preserve-3d; /* Preserve 3D for children */
    }
    
    #intakeSystem.visible { opacity: 1; }
    
    #intakeBox {
      width: 100%;
      min-height: 300px;
      border: 3px solid rgba(255, 255, 255, 0.7);
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.08) 0%, rgba(255, 255, 255, 0.02) 100%);
      border-radius: 12px 12px 0 0;
      padding: 3.5rem 1.5rem 1rem 1.5rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-content: flex-start;
      position: relative;
      transform-style: preserve-3d; /* Enable 3D transforms */
    }
    
    #intakeLabel {
      position: absolute;
      top: 1rem;
      left: 50%;
      transform: translateX(-50%);
      font-size: 1.1rem;
      font-weight: 700;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 0 2px 8px rgba(255, 255, 255, 0.5);
    }
    
    #filterFunnel {
      width: 100%;
      height: 150px;
      position: relative;
      overflow: hidden;
      transform-style: preserve-3d; /* Enable 3D transforms */
    }
    
    .collected-item {
      padding: 0.6rem 1.2rem;
      border: 2px solid;
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      font-weight: 600;
      border-radius: 6px;
      position: relative;
      animation: item-drop 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
    }
    
    @keyframes item-drop {
      from {
        opacity: 0;
        transform: translateY(-40px) scale(0.6) rotate(-8deg);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1) rotate(0deg);
      }
    }
    
    /* Childhood site tile visual styles */
    .site-header {
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 6px;
      font-size: 9px;
      font-weight: 700;
      border-bottom: 2px solid;
    }
    
    .site-nav {
      height: 18px;
      display: flex;
      gap: 4px;
      align-items: center;
      padding: 0 4px;
      font-size: 7px;
      border-bottom: 1px solid;
    }
    
    .site-content {
      flex: 1;
      display: grid;
      grid-template-columns: 1fr 2fr;
      gap: 4px;
      padding: 4px;
      overflow: hidden;
    }
    
    .site-sidebar {
      border-right: 1px solid;
      padding: 2px;
      font-size: 6px;
    }
    
    .site-main {
      padding: 2px;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    
    .site-box {
      border: 1px solid;
      padding: 3px;
      font-size: 7px;
      border-radius: 2px;
    }
    
    .site-btn {
      display: inline-block;
      padding: 2px 4px;
      font-size: 6px;
      border-radius: 2px;
      border: 1px solid;
    }
    
    .site-icon {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      display: inline-block;
    }
    
    /* SaaS/Productivity glitch animation */
    .saas-glitch {
      animation: glitch-distort 3s infinite;
    }
    
    @keyframes glitch-distort {
      0%, 90%, 100% {
        transform: translate(0, 0) skew(0deg);
        filter: none;
      }
      91% {
        transform: translate(-3px, 2px) skew(-2deg);
        filter: hue-rotate(90deg) saturate(3);
      }
      92% {
        transform: translate(4px, -1px) skew(3deg);
        filter: hue-rotate(-90deg) invert(0.3);
      }
      93% {
        transform: translate(-2px, -3px) skew(1deg);
        filter: brightness(0.3);
      }
      94% {
        transform: translate(3px, 1px) skew(-1deg);
        filter: contrast(3) saturate(0);
      }
      95% {
        transform: translate(-1px, 2px) skew(2deg);
        filter: hue-rotate(180deg);
      }
    }
    
    @keyframes shake {
      0%, 100% { transform: translate(0, 0) rotate(0deg); }
      10% { transform: translate(-4px, 3px) rotate(-2deg); }
      20% { transform: translate(4px, -3px) rotate(2deg); }
      30% { transform: translate(-3px, -4px) rotate(-1deg); }
      40% { transform: translate(3px, 4px) rotate(1deg); }
      50% { transform: translate(-4px, 2px) rotate(-2deg); }
      60% { transform: translate(4px, -2px) rotate(2deg); }
      70% { transform: translate(-2px, -3px) rotate(-1deg); }
      80% { transform: translate(2px, 3px) rotate(1deg); }
      90% { transform: translate(-3px, 2px) rotate(-1deg); }
    }
    
    @keyframes hingeRotate {
      0% { transform: rotateX(0deg); transform-origin: top center; }
      20% { transform: rotateX(5deg); }
      40% { transform: rotateX(-3deg); }
      60% { transform: rotateX(10deg); }
      80% { transform: rotateX(25deg); }
      100% { transform: rotateX(35deg); opacity: 0.8; }
    }
    
    .intake-shake {
      animation: shake 0.4s ease-in-out;
    }
    
    .intake-hinge {
      animation: hingeRotate 1.5s cubic-bezier(0.6, -0.28, 0.735, 0.045) forwards;
      transform-style: preserve-3d;
    }
    
    .intake-collapse {
      animation: intakeCollapse 1.8s cubic-bezier(0.6, 0.04, 0.98, 0.335) forwards;
    }
    
    @keyframes intakeCollapse {
      0% {
        transform: translateY(0) scaleY(1);
        opacity: 1;
      }
      20% {
        transform: translateY(20px) scaleY(0.95);
        opacity: 1;
      }
      40% {
        transform: translateY(100px) scaleY(0.8);
        opacity: 0.9;
      }
      60% {
        transform: translateY(300px) scaleY(0.5);
        opacity: 0.7;
      }
      80% {
        transform: translateY(600px) scaleY(0.2);
        opacity: 0.4;
      }
      100% {
        transform: translateY(1200px) scaleY(0);
        opacity: 0;
      }
    }
    
    .particle {
      position: absolute;
      width: 5px;
      height: 5px;
      border-radius: 50%;
      pointer-events: none;
      z-index: 60;
      box-shadow: 0 0 4px rgba(255, 255, 255, 0.6);
    }
    
    @keyframes flap {
      0%, 100% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.2); }
    }
    
    @keyframes flapButterfly {
      0%, 100% { transform: scale(1) rotate(0deg); }
      25% { transform: scale(1.1) rotate(-5deg); }
      75% { transform: scale(1.1) rotate(5deg); }
    }
    
    @keyframes shake {
      0%, 100% { transform: translate(-50%, -50%) rotate(0deg); }
      25% { transform: translate(-50%, -50%) rotate(-3deg) scale(1.05); }
      75% { transform: translate(-50%, -50%) rotate(3deg) scale(1.05); }
    }
    
    #assignaBoard {
      position: absolute;
      width: 1200px;
      z-index: 40;
      opacity: 0;
      transition: opacity 1s;
    }
    
    #assignaBoard.visible { opacity: 1; }
    
    #assignaBoard.glitch {
      animation: boardGlitch 0.3s infinite;
    }
    
    #assignaBoard.glitch-lines::before {
      content: '';
      position: absolute;
      inset: 0;
      background: repeating-linear-gradient(
        0deg,
        transparent,
        transparent 2px,
        rgba(255, 0, 0, 0.8) 2px,
        rgba(255, 0, 0, 0.8) 4px,
        transparent 4px,
        transparent 6px,
        rgba(0, 255, 0, 0.8) 6px,
        rgba(0, 255, 0, 0.8) 8px
      );
      animation: glitchLines 0.5s linear infinite;
      z-index: 50;
      pointer-events: none;
    }
    
    @keyframes glitchLines {
      0% { transform: translateX(0); opacity: 0.8; }
      25% { transform: translateX(-10px); opacity: 0.6; }
      50% { transform: translateX(10px); opacity: 0.9; }
      75% { transform: translateX(-5px); opacity: 0.7; }
      100% { transform: translateX(0); opacity: 0.8; }
    }
    
    #assignaBoard.collapse {
      animation: boardCollapse 1.5s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;
    }
    
    @keyframes boardCollapse {
      0% {
        transform: scale(1) rotate(0deg);
        opacity: 1;
        filter: brightness(1);
      }
      10% {
        transform: scale(1.05) rotate(0deg);
        filter: brightness(1.3);
      }
      20% {
        transform: scale(0.95) rotate(0deg);
        filter: brightness(1);
      }
      30% {
        transform: scale(1.08) rotate(0deg);
        filter: brightness(1.5);
      }
      40% {
        transform: scale(1) rotate(0deg);
        filter: brightness(1.2);
      }
      50% {
        transform: scale(1.15) rotate(5deg);
        opacity: 0.9;
        filter: brightness(1.8) saturate(1.5);
      }
      70% {
        transform: scale(0.7) rotate(-10deg);
        opacity: 0.6;
        filter: brightness(1.3);
      }
      90% {
        transform: scale(0.3) rotate(180deg);
        opacity: 0.3;
        filter: brightness(0.8);
      }
      100% {
        transform: scale(0) rotate(360deg);
        opacity: 0;
        filter: brightness(0);
      }
    }
    
    @keyframes boardGlitch {
      0%, 100% {
        transform: translate(0, 0) skew(0deg);
        filter: hue-rotate(0deg);
      }
      10% {
        transform: translate(-5px, 2px) skew(-2deg);
        filter: hue-rotate(90deg) saturate(3);
      }
      20% {
        transform: translate(3px, -4px) skew(1deg);
        filter: hue-rotate(180deg) saturate(2);
      }
      30% {
        transform: translate(-2px, 3px) skew(-1deg);
        filter: hue-rotate(270deg) saturate(4);
      }
      40% {
        transform: translate(4px, -2px) skew(2deg);
        filter: hue-rotate(0deg) invert(0.1);
      }
      50% {
        transform: translate(-3px, 4px) skew(-3deg);
        filter: hue-rotate(90deg) saturate(5) brightness(1.2);
      }
      60% {
        transform: translate(2px, -3px) skew(1deg);
        filter: hue-rotate(180deg) saturate(3) contrast(1.5);
      }
      70% {
        transform: translate(-4px, 2px) skew(-2deg);
        filter: hue-rotate(270deg) saturate(2);
      }
      80% {
        transform: translate(3px, -1px) skew(2deg);
        filter: hue-rotate(0deg) invert(0.2);
      }
      90% {
        transform: translate(-1px, 3px) skew(-1deg);
        filter: hue-rotate(45deg) saturate(4);
      }
    }
    
    #assignaCanvas {
      width: 100%;
      height: auto;
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
    }
    
    .materializing-card {
      position: absolute;
      background: #333;
      border-radius: 8px;
      padding: 12px;
      min-width: 170px;
      max-width: 170px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      z-index: 45;
      opacity: 0;
      transform: scale(0.5);
      animation: materialize 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
    }
    
    @keyframes materialize {
      to {
        opacity: 1;
        transform: scale(1);
      }
    }
    
    .materializing-card .title {
      color: #fff;
      font-size: 13px;
      font-weight: 700;
      margin-bottom: 8px;
    }
    
    .materializing-card .priority {
      display: inline-block;
      padding: 3px 8px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: 700;
      color: #fff;
    }
    
    .butterfly-container {
      position: absolute;
      z-index: 200;
      pointer-events: none;
    }
    
    .butterfly {
      position: absolute;
      animation: fly 4s ease-in-out infinite;
    }
    
    @keyframes fly {
      0%, 100% { transform: translate(0, 0); }
      25% { transform: translate(50px, -30px); }
      50% { transform: translate(100px, 0); }
      75% { transform: translate(50px, 30px); }
    }
    
    .butterfly-wing {
      position: absolute;
      width: 70px;
      height: 90px;
      background: var(--wing-bg);
      border: 2px solid rgba(255, 255, 255, 0.6);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      transform-origin: center center;
      transition: background 1.5s ease, border-radius 1.5s ease, width 1.5s ease, height 1.5s ease,
                  top 1.5s ease, bottom 1.5s ease, left 1.5s ease, right 1.5s ease;
    }
    
    /* Butterfly wing pattern: positioned like actual wings */
    .butterfly-wing.top-left {
      top: -45px;
      left: -35px;
      border-radius: 8px; /* Start rectangular */
      animation: none; /* No flapping initially */
      transform-origin: bottom right;
    }
    
    .butterfly-wing.top-right {
      top: -45px;
      right: -35px;
      border-radius: 8px;
      animation: none;
      transform-origin: bottom left;
    }
    
    .butterfly-wing.bottom-left {
      bottom: -45px;
      left: -35px;
      border-radius: 8px;
      animation: none;
      transform-origin: top right;
    }
    
    .butterfly-wing.bottom-right {
      bottom: -45px;
      right: -35px;
      border-radius: 8px;
      animation: none;
      transform-origin: top left;
    }
    
    /* Morphed state - organic butterfly wings */
    .butterfly-wing.morphed.top-left {
      border-radius: 70% 30% 50% 40%;
      animation: flapTopLeft 0.3s ease-in-out infinite;
      top: -50px;
      left: -10px;
    }
    
    .butterfly-wing.morphed.top-right {
      border-radius: 30% 70% 40% 50%;
      animation: flapTopRight 0.3s ease-in-out infinite;
      top: -50px;
      right: -10px;
    }
    
    .butterfly-wing.morphed.bottom-left {
      border-radius: 40% 50% 70% 30%;
      animation: flapBottomLeft 0.3s ease-in-out infinite;
      bottom: -50px;
      left: -10px;
    }
    
    .butterfly-wing.morphed.bottom-right {
      border-radius: 50% 40% 30% 70%;
      animation: flapBottomRight 0.3s ease-in-out infinite;
      bottom: -50px;
      right: -10px;
    }
    
    @keyframes flapTopLeft {
      0%, 100% { transform: rotate(-10deg) scaleY(1); }
      50% { transform: rotate(-25deg) scaleY(0.8); }
    }
    
    @keyframes flapTopRight {
      0%, 100% { transform: rotate(10deg) scaleY(1); }
      50% { transform: rotate(25deg) scaleY(0.8); }
    }
    
    @keyframes flapBottomLeft {
      0%, 100% { transform: rotate(10deg) scaleY(1); }
      50% { transform: rotate(25deg) scaleY(0.8); }
    }
    
    @keyframes flapBottomRight {
      0%, 100% { transform: rotate(-10deg) scaleY(1); }
      50% { transform: rotate(-25deg) scaleY(0.8); }
    }
    
    .butterfly-label {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 11px;
      font-weight: 700;
      text-align: center;
      white-space: nowrap;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
      z-index: 2;
    }
  </style>
</head>
<body>
  <div id="titleOverlay">
    <div id="dynamicTitle" class="sub-title" style="font-size: clamp(2rem, 6vw, 4rem); margin-top: 2rem;"></div>
  </div>
  
  <script>
    // Set title based on mode
    const titleEl = document.getElementById('dynamicTitle');
    const bonusMode = sessionStorage.getItem('celli:bonusTrainMode') === 'true';
    if (bonusMode) {
      // Minimal, thin, sad intro
      titleEl.textContent = "Thomas, I don't think I can.";
      titleEl.style.fontFamily = 'monospace';
      titleEl.style.fontWeight = '300';
      titleEl.style.letterSpacing = '0.02em';
      titleEl.style.color = '#d0d0d0';
      titleEl.style.textShadow = 'none';
    } else {
      titleEl.textContent = 'All a-board the kanban! Sprint\'s about to start!';
    }
  </script>
  
  <audio id="trainAudio" preload="auto"></audio>
  
  <div id="viewport">
    <div id="scene">
      <canvas id="trackCanvas" width="5000" height="5000"></canvas>
      <canvas id="particleCanvas" width="5000" height="5000"></canvas>
      
      <!-- Intake System with Filter -->
      <div id="intakeSystem">
        <div id="intakeBox">
          <div id="intakeLabel">Intake Integration</div>
        </div>
        <svg id="filterFunnel" viewBox="0 0 700 150">
          <!-- Funnel shape -->
          <defs>
            <linearGradient id="funnelGrad" x1="0%" y1="0%" x2="0%" y2="100%">
              <stop offset="0%" style="stop-color:rgba(255,255,255,0.1)" />
              <stop offset="100%" style="stop-color:rgba(255,255,255,0.02)" />
            </linearGradient>
          </defs>
          <path d="M 0,0 L 700,0 L 400,130 L 300,130 Z" 
                fill="url(#funnelGrad)" 
                stroke="rgba(255,255,255,0.5)" 
                stroke-width="2"/>
          <!-- Filter lines -->
          <line x1="100" y1="30" x2="250" y2="100" stroke="rgba(255,255,255,0.3)" stroke-width="1"/>
          <line x1="200" y1="30" x2="300" y2="100" stroke="rgba(255,255,255,0.3)" stroke-width="1"/>
          <line x1="300" y1="30" x2="350" y2="100" stroke="rgba(255,255,255,0.3)" stroke-width="1"/>
          <line x1="400" y1="30" x2="380" y2="100" stroke="rgba(255,255,255,0.3)" stroke-width="1"/>
          <line x1="500" y1="30" x2="400" y2="100" stroke="rgba(255,255,255,0.3)" stroke-width="1"/>
          <line x1="600" y1="30" x2="420" y2="100" stroke="rgba(255,255,255,0.3)" stroke-width="1"/>
        </svg>
      </div>
      
      <!-- Assigna Board -->
      <div id="assignaBoard">
        <canvas id="assignaCanvas" width="1200" height="900"></canvas>
      </div>
    </div>
    <!-- Fixed overlay canvas for global FX (fire/snow) -->
    <canvas id="fxOverlay"></canvas>
    <!-- Film grain overlay -->
    <canvas id="grainOverlay"></canvas>
  </div>
  
  <!-- Standup and Deliver Button -->
  <button id="segwayButton">
    <div id="bonusCountdown"></div>
    Standup and Deliver!<br>
    <span style="font-size: 0.6em; font-weight: 400; opacity: 0.9;">Continue on....</span>
  </button>

  <button id="bonusButton">
    Extra Story Points
    <div id="bonusButtonSubtext">Click here to take on some of the spill-over, pile on those enhancements.</div>
  </button>

  <!-- Segway Reveal Elements -->
  <div id="segwayBall"></div>
  <div id="segwayCard">
    <div id="segwayCardTitle">*Reference Details:</div>
    <div id="segwayCardContent">
      The Segway PT was famously kept under extreme secrecy before its December 2001 unveiling. 
      Code-named "Ginger" and "IT," the project generated massive hype with predictions it would 
      "revolutionize transportation" and be "bigger than the Internet." Inventor Dean Kamen and 
      investors like Steve Jobs kept details hidden, leading to wild speculation about what this 
      world-changing innovation could be. The actual reveal‚Äîa two-wheeled personal transporter‚Äî
      was met with a mixture of amazement and anticlimax, though the pre-launch secrecy campaign 
      remains one of tech history's most memorable marketing moments.
      <br><br>
      The one-person vehicle may not have changed the world in the way it imagined, but it did us one better. It gave us Paul Blart.
      <br><br>
      <em>A "segue" (pronounced the same way) is a smooth transition from one thing to another.</em>
    </div>
  </div>

  <!-- Debug: Jump to final descent before compartmentalizer -->
  <button id="debugJump" style="position:fixed;bottom:16px;left:16px;z-index:1000;padding:8px 12px;font-weight:700;background:#222;color:#fff;border:1px solid #555;border-radius:6px;cursor:pointer;opacity:0.8">Debug: Jump to Final Descent</button>
  <button id="debugGraveyard" style="position:fixed;bottom:16px;left:220px;z-index:1000;padding:8px 12px;font-weight:700;background:#222;color:#fff;border:1px solid #555;border-radius:6px;cursor:pointer;opacity:0.8">Debug: Start Graveyard</button>
  
  <script>
    // Check for bonus mode
    const isBonusMode = sessionStorage.getItem('celli:bonusTrainMode') === 'true';
    console.log(isBonusMode ? 'üíÄü¶¥ BONUS MODE: Bone Track!' : 'üöÇ Release Train - High Fidelity Task Intake');
    
    // Clear bonus flag immediately after reading so refresh/back button always starts in normal mode
    // It will be set again when user clicks the bonus button
    if (isBonusMode) {
      sessionStorage.removeItem('celli:bonusTrainMode');
      
      // Replace intake label for bonus mode
      document.getElementById('intakeLabel').textContent = 'COMPARTMENTALIZER';
    }
    
    // Helper: Check if term is SaaS/Productivity related
    function isSaaSorProductivity(name) {
      const saasTerms = ['PRODUCTIVITY', 'EFFICIENCY', 'SYNERGY', 'OPTIMIZATION', 'LEVERAGE', 
                        'AGILE', 'SCRUM', 'METRICS', 'KPI', 'ROI', 'SCALE', 'GROWTH',
                        'WISDOM', 'AMBITIONS', 'ANXIETIES'];
      return saasTerms.includes(name.toUpperCase());
    }
    
    // Helper: Generate childhood website layout representations
    function generateChildhoodSiteLayout(name) {
      const siteConfigs = {
        'PASSIONS': { // Newgrounds (accurate layout)
          layout: `
            <div style="background:#191919; height:100%; display:flex; flex-direction:column; font-family:Arial,sans-serif; color:#fff;">
              <!-- Top header with logo and search -->
              <div style="background:#000; height:18px; display:flex; align-items:center; padding:0 3px; border-bottom:1px solid #333;">
                <div style="display:flex; align-items:center; gap:2px;">
                  <div style="width:10px; height:10px; background:linear-gradient(#666, #333); border:1px solid #999; position:relative;">
                    <div style="position:absolute; top:2px; left:2px; width:4px; height:4px; background:#FF6600; border-radius:50%;"></div>
                  </div>
                  <span style="font-weight:900; font-size:7px; letter-spacing:-0.5px;">NEWGROUNDS</span>
                </div>
                <div style="flex:1; margin-left:4px;">
                  <div style="background:#222; border:1px solid #444; height:8px; border-radius:2px; display:flex; align-items:center; padding:0 2px;">
                    <span style="font-size:4px; color:#666;">SEARCH NG!</span>
                  </div>
                </div>
              </div>
              <!-- Navigation bar -->
              <div style="background:#FF6600; height:10px; display:flex; align-items:center; gap:3px; padding:0 3px; font-size:5px; font-weight:bold; border-bottom:2px solid #CC5200;">
                <span style="color:#000;">FLASH</span>
                <span style="color:#000;">AUDIO</span>
                <span style="color:#000;">GAMES</span>
                <span style="color:#000;">TOONS</span>
                <span style="color:#000;">COLLECTIONS</span>
              </div>
              <!-- Content area -->
              <div style="flex:1; background:#000; padding:3px; overflow:hidden;">
                <div style="border:1px solid #333; background:#1a1a1a; padding:2px;">
                  <div style="font-size:6px; color:#FDB813; font-weight:bold; margin-bottom:2px;">LATEST 5 SUBMISSIONS</div>
                  <div style="display:grid; grid-template-columns:1fr 1fr; gap:2px;">
                    <div style="background:#2a2a2a; border:1px solid #444; height:14px; display:flex; align-items:center; justify-content:center;">
                      <div style="width:10px; height:10px; background:linear-gradient(#4169E1, #1E3A8A);"></div>
                    </div>
                    <div style="background:#2a2a2a; border:1px solid #444; height:14px; display:flex; align-items:center; justify-content:center;">
                      <div style="width:10px; height:10px; background:linear-gradient(#DC143C, #8B0000);"></div>
                    </div>
                  </div>
                  <div style="margin-top:2px; display:grid; grid-template-columns:1fr 1fr; gap:2px;">
                    <div style="background:#2a2a2a; border:1px solid #444; height:14px;"></div>
                    <div style="background:#2a2a2a; border:1px solid #444; height:14px;"></div>
                  </div>
                </div>
              </div>
            </div>`
        },
        'HOPES': { // Neopets (accurate layout)
          layout: `
            <div style="background:#fff; height:100%; display:flex; font-family:Arial,sans-serif; font-size:6px;">
              <!-- Yellow sidebar -->
              <div style="background:linear-gradient(#FFD700, #FFA500); width:35px; padding:2px; border-right:2px solid #333;">
                <div style="background:#fff; border:1px solid #000; padding:1px; margin-bottom:2px;">
                  <img style="width:100%; height:8px; background:#4169E1;" />
                </div>
                <div style="color:#8B4513; font-size:5px; margin:1px 0; font-weight:bold;">create</div>
                <div style="color:#8B4513; font-size:5px; margin:1px 0;">pet central</div>
                <div style="color:#8B4513; font-size:5px; margin:1px 0;">explore</div>
                <div style="color:#8B4513; font-size:5px; margin:1px 0;">games</div>
                <div style="color:#8B4513; font-size:5px; margin:1px 0;">shops</div>
                <div style="background:#fff; border:1px solid #000; padding:1px; margin-top:2px; text-align:center; font-size:4px;">login!</div>
              </div>
              <!-- Main content -->
              <div style="flex:1; display:flex; flex-direction:column;">
                <!-- Top banner -->
                <div style="background:linear-gradient(#87CEEB, #B0E0E6); height:16px; display:flex; align-items:center; justify-content:center; border-bottom:2px solid #4682B4;">
                  <div style="background:#90EE90; border:2px solid #228B22; border-radius:8px; padding:1px 4px; font-weight:bold; color:#006400; font-size:5px;">
                    neopets.stuff
                  </div>
                </div>
                <!-- Scroll banner with items -->
                <div style="background:linear-gradient(#D2B48C, #F5DEB3); height:12px; border-bottom:1px solid #8B7355; display:flex; align-items:center; gap:2px; padding:0 2px; overflow:hidden;">
                  <div style="width:8px; height:8px; background:#FF69B4; border-radius:50%; border:1px solid #C71585;"></div>
                  <div style="width:8px; height:8px; background:#FFD700; border:1px solid #DAA520;"></div>
                  <div style="width:8px; height:8px; background:#87CEEB; border:1px solid #4682B4;"></div>
                  <div style="width:8px; height:8px; background:#98FB98; border:1px solid #228B22;"></div>
                </div>
                <!-- Content area -->
                <div style="flex:1; background:#FFF8DC; padding:3px;">
                  <div style="background:#FFE4B5; border:2px dashed #D2B48C; padding:2px; margin-bottom:2px; border-radius:2px;">
                    <div style="font-weight:bold; color:#8B4513; font-size:5px;">‚ú® NEW STUFF</div>
                  </div>
                  <div style="display:grid; grid-template-columns:1fr 1fr; gap:2px;">
                    <div style="background:#E0F0FF; border:1px solid #B0C4DE; height:16px;"></div>
                    <div style="background:#FFE4E1; border:1px solid #FFB6C1; height:16px;"></div>
                  </div>
                </div>
              </div>
            </div>`
        },
        'GRATITUDE': { // Club Penguin
          bg: '#6FBAFF',
          layout: `
            <div style="background:linear-gradient(#6FBAFF, #4A9BE8); height:100%; display:flex; flex-direction:column; color:#fff; font-family:Arial,sans-serif;">
              <div class="site-header" style="background:#0066CC; color:#fff; border-color:#004499;">
                <span>‚ùÑÔ∏è Club Penguin</span>
                <span style="background:#FFD700; color:#000; padding:1px 3px; border-radius:2px; font-size:6px;">MEMBER</span>
              </div>
              <div class="site-nav" style="background:#0080FF; color:#fff; border-color:#0066CC;">
                <span>PLAY</span><span>NEWS</span><span>SHOP</span>
              </div>
              <div class="site-content" style="background:#E3F2FD;">
                <div class="site-sidebar" style="border-color:#90CAF9; color:#1565C0;">
                  <div style="background:#BBDEFB; padding:2px; margin-bottom:2px; border:1px solid #64B5F6; border-radius:2px; font-size:6px;">
                    FRIENDS (12)
                  </div>
                  <div style="background:#90CAF9; width:100%; height:15px; border-radius:50%; margin:2px 0;"></div>
                </div>
                <div class="site-main">
                  <div class="site-box" style="background:#fff; color:#0066CC; border-color:#64B5F6;">
                    <div style="font-size:7px; font-weight:bold;">üéÆ MINI-GAMES</div>
                  </div>
                  <div style="background:#81C784; height:22px; border:2px solid #66BB6A; border-radius:4px; margin-top:2px;"></div>
                </div>
              </div>
            </div>`
        },
        'MEMORIES': { // DeviantArt
          bg: '#05CC47',
          layout: `
            <div style="background:#1E2D24; height:100%; display:flex; flex-direction:column; color:#fff; font-family:Arial,sans-serif;">
              <div class="site-header" style="background:#05CC47; color:#000; border-color:#04AA3A;">
                <span style="font-weight:900;">deviantART</span>
                <span>‚óè‚óã‚óã</span>
              </div>
              <div class="site-nav" style="background:#2E3D34; color:#05CC47; border-color:#1E2D24;">
                <span>BROWSE</span><span>SUBMIT</span><span>WATCH</span>
              </div>
              <div class="site-content" style="background:#1A1A1A;">
                <div class="site-sidebar" style="border-color:#333; color:#aaa;">
                  <div style="background:#2E3D34; padding:2px; border:1px solid #05CC47; border-radius:2px; font-size:6px; margin-bottom:2px;">
                    DAILY DEVIATIONS
                  </div>
                  <div style="background:#444; width:100%; height:12px; border:1px solid #666;"></div>
                </div>
                <div class="site-main">
                  <div style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:2px;">
                    <div style="background:#333; height:15px; border:1px solid #05CC47;"></div>
                    <div style="background:#333; height:15px; border:1px solid #05CC47;"></div>
                    <div style="background:#333; height:15px; border:1px solid #05CC47;"></div>
                  </div>
                  <div class="site-box" style="background:#2E3D34; color:#05CC47; border-color:#04AA3A; margin-top:2px;">
                    <span style="font-size:6px;">‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ</span>
                  </div>
                </div>
              </div>
            </div>`
        },
        'AMBITIONS': { // LinkedIn (SaaS glitch)
          bg: '#0077B5',
          layout: `
            <div style="background:#fff; height:100%; display:flex; flex-direction:column; font-family:Arial,sans-serif;">
              <div class="site-header" style="background:#0077B5; color:#fff; border-color:#005885;">
                <span style="font-weight:700;">in</span>
                <span style="font-size:6px;">üîç Search</span>
              </div>
              <div class="site-nav" style="background:#F3F6F8; color:#666; border-color:#ddd;">
                <span>HOME</span><span>NETWORK</span><span>JOBS</span>
              </div>
              <div class="site-content" style="background:#F3F6F8;">
                <div class="site-sidebar" style="border-color:#ddd; color:#333;">
                  <div style="background:#fff; padding:3px; border:1px solid #ddd; border-radius:2px;">
                    <div class="site-icon" style="background:#0077B5;"></div>
                    <div style="font-size:6px; margin-top:2px;">John Doe</div>
                    <div style="font-size:5px; color:#666;">500+ connections</div>
                  </div>
                </div>
                <div class="site-main">
                  <div class="site-box" style="background:#fff; color:#333; border-color:#ddd;">
                    <div style="font-size:6px; color:#0077B5; font-weight:bold;">RECOMMENDED FOR YOU</div>
                  </div>
                  <div style="background:#fff; padding:3px; border:1px solid #ddd; margin-top:2px;">
                    <div style="font-size:6px;">üìä Productivity +25%</div>
                  </div>
                </div>
              </div>
            </div>`
        },
        'DREAMS': { // Habbo Hotel
          bg: '#D4AF37',
          layout: `
            <div style="background:#000; height:100%; display:flex; flex-direction:column; color:#fff; font-family:Arial,sans-serif;">
              <div class="site-header" style="background:linear-gradient(#D4AF37, #B8960F); color:#000; border-color:#A0850D;">
                <span style="font-weight:900; font-style:italic;">HABBO</span>
                <span>HOTEL</span>
              </div>
              <div class="site-nav" style="background:#1a1a1a; color:#D4AF37; border-color:#333;">
                <span>HOME</span><span>SHOP</span><span>ROOMS</span>
              </div>
              <div class="site-content" style="background:#2a2a2a;">
                <div class="site-sidebar" style="border-color:#444; color:#aaa;">
                  <div style="background:#333; padding:2px; border:1px solid #D4AF37;">
                    <div style="width:14px; height:14px; background:#FF6B6B; border:1px solid #fff; margin:auto;"></div>
                  </div>
                </div>
                <div class="site-main">
                  <div style="background:#444; padding:3px; border:2px solid #666;">
                    <div style="display:grid; grid-template-columns:repeat(4, 1fr); gap:1px;">
                      <div style="background:#8B4513; height:8px;"></div>
                      <div style="background:#8B4513; height:8px;"></div>
                      <div style="background:#8B4513; height:8px;"></div>
                      <div style="background:#FFD700; height:8px;"></div>
                    </div>
                  </div>
                </div>
              </div>
            </div>`
        },
        'CURIOSITIES': { // Wikipedia
          bg: '#fff',
          layout: `
            <div style="background:#fff; height:100%; display:flex; flex-direction:column; font-family:Georgia,serif;">
              <div class="site-header" style="background:#f8f9fa; color:#000; border-color:#a2a9b1;">
                <span style="font-weight:bold; font-style:italic;">W</span>
                <span style="font-size:7px;">WIKIPEDIA</span>
              </div>
              <div class="site-nav" style="background:#f8f9fa; color:#202122; border-color:#a2a9b1; font-size:6px;">
                <span>Article</span><span>Talk</span><span>Edit</span>
              </div>
              <div class="site-content" style="background:#fff;">
                <div class="site-sidebar" style="border-color:#a2a9b1; color:#202122;">
                  <div style="background:#f8f9fa; padding:2px; border:1px solid #a2a9b1; font-size:6px; margin-bottom:2px;">
                    Contents
                  </div>
                  <div style="font-size:5px; line-height:1.4;">
                    ‚Ä¢ Introduction<br>‚Ä¢ History<br>‚Ä¢ See also
                  </div>
                </div>
                <div class="site-main">
                  <div style="background:#f8f9fa; padding:2px; border:1px solid #a2a9b1; font-size:6px; line-height:1.3;">
                    Lorem ipsum dolor sit amet, consectetur adipiscing elit...
                  </div>
                  <div style="background:#e7f0ff; border:1px solid #7cb8ff; padding:2px; margin-top:2px; font-size:5px;">
                    ‚ÑπÔ∏è This article needs citations
                  </div>
                </div>
              </div>
            </div>`
        },
        'STORIES': { // FanFiction.Net
          bg: '#E6F4F1',
          layout: `
            <div style="background:#fff; height:100%; display:flex; flex-direction:column; font-family:Verdana,sans-serif;">
              <div class="site-header" style="background:#3A5795; color:#fff; border-color:#2A4785;">
                <span style="font-weight:bold;">FanFiction</span>
                <span style="font-size:6px;">.Net</span>
              </div>
              <div class="site-nav" style="background:#E6F4F1; color:#333; border-color:#B0C4DE;">
                <span>Browse</span><span>Search</span><span>Forums</span>
              </div>
              <div class="site-content" style="background:#fff;">
                <div class="site-sidebar" style="border-color:#ccc; color:#555;">
                  <div style="background:#f0f0f0; padding:2px; border:1px solid #ccc; font-size:6px;">
                    Categories
                  </div>
                  <div style="font-size:5px; line-height:1.5; margin-top:2px;">
                    ‚Ä¢ Anime<br>‚Ä¢ Books<br>‚Ä¢ Movies
                  </div>
                </div>
                <div class="site-main">
                  <div class="site-box" style="background:#f9f9f9; color:#333; border-color:#ddd;">
                    <div style="font-size:7px; font-weight:bold; color:#3A5795;">Story Title</div>
                    <div style="font-size:5px; color:#666; margin-top:1px;">by Author ‚Ä¢ Reviews: 42</div>
                  </div>
                  <div style="font-size:5px; line-height:1.3; margin-top:2px; color:#444;">
                    Chapter 1: The Beginning...
                  </div>
                </div>
              </div>
            </div>`
        },
        'WISDOM': { // Stack Overflow (SaaS glitch)
          bg: '#F48024',
          layout: `
            <div style="background:#fff; height:100%; display:flex; flex-direction:column; font-family:Arial,sans-serif;">
              <div class="site-header" style="background:#222; color:#fff; border-color:#000;">
                <span style="color:#F48024; font-weight:bold;">stack</span>
                <span style="font-weight:bold;">overflow</span>
              </div>
              <div class="site-nav" style="background:#f8f8f8; color:#666; border-color:#ddd;">
                <span>Questions</span><span>Tags</span><span>Users</span>
              </div>
              <div class="site-content" style="background:#fff;">
                <div class="site-sidebar" style="border-color:#ddd; color:#333;">
                  <div style="background:#FFF8DC; padding:2px; border:1px solid #F48024; border-radius:2px; font-size:5px;">
                    ‚≠ê TOP QUESTIONS
                  </div>
                  <div style="font-size:5px; margin-top:2px; color:#666;">
                    javascript<br>python<br>html
                  </div>
                </div>
                <div class="site-main">
                  <div class="site-box" style="background:#f8f8f8; color:#333; border-color:#ccc;">
                    <div style="font-size:6px; font-weight:bold;">How to center a div?</div>
                    <div style="font-size:5px; color:#666; margin-top:1px;">‚Üë 42 votes ‚Ä¢ 12 answers</div>
                  </div>
                  <div style="background:#5eba7d; color:#fff; padding:2px; font-size:5px; margin-top:2px; border-radius:2px;">
                    ‚úì Accepted Answer</div>
                </div>
              </div>
            </div>`
        },
        'LOVE': { // MySpace
          bg: '#fff',
          layout: `
            <div style="background:#fff; height:100%; display:flex; flex-direction:column; font-family:Arial,sans-serif;">
              <div class="site-header" style="background:linear-gradient(#0054A6, #003D7A); color:#fff; border-color:#002654;">
                <span style="font-weight:bold;">myspace</span>
                <span style="font-size:6px;">Home | Browse | Search</span>
              </div>
              <div style="background:#F0F8FF; flex:1; padding:4px; display:grid; grid-template-columns:1fr 2fr; gap:4px;">
                <div style="border:1px solid #ccc; background:#fff; padding:2px;">
                  <div style="width:100%; height:24px; background:linear-gradient(#ff1493, #ff69b4); border:2px solid #fff;"></div>
                  <div style="font-size:6px; margin-top:2px; text-align:center; font-weight:bold;">Tom</div>
                  <div style="font-size:5px; color:#666; text-align:center;">24 | Male</div>
                </div>
                <div>
                  <div style="background:#FFE4E1; border:2px dashed #ff69b4; padding:3px; font-size:6px; margin-bottom:2px;">
                    ‚ô´ Now Playing: Dashboard Confessional
                  </div>
                  <div style="background:#fff; border:1px solid #ccc; padding:2px; font-size:5px;">
                    <b>About Me:</b> Thanks for the add! ‚ù§Ô∏è
                  </div>
                </div>
              </div>
            </div>`
        },
        'FEARS': { // SCP Foundation
          bg: '#222',
          layout: `
            <div style="background:#fff; height:100%; display:flex; flex-direction:column; font-family:Courier New,monospace;">
              <div class="site-header" style="background:#222; color:#fff; border-color:#000;">
                <span style="font-weight:bold;">SCP FOUNDATION</span>
                <span style="font-size:5px; color:#f00;">TOP SECRET</span>
              </div>
              <div class="site-nav" style="background:#333; color:#ccc; border-color:#111; font-size:6px;">
                <span>DATABASE</span><span>TALES</span><span>GUIDE</span>
              </div>
              <div style="background:#f5f5f5; flex:1; padding:4px;">
                <div style="background:#fff; border:2px solid #000; padding:3px; margin-bottom:2px;">
                  <div style="font-size:7px; font-weight:bold;">ITEM #: SCP-‚ñà‚ñà‚ñà‚ñà</div>
                  <div style="font-size:6px; margin-top:2px;">
                    <span style="background:#000; color:#fff; padding:1px 2px;">KETER</span>
                  </div>
                </div>
                <div style="background:#fff; border:1px solid #999; padding:2px;">
                  <div style="font-size:5px; line-height:1.3;">
                    <b>Special Containment:</b><br>
                    [DATA EXPUNGED]
                  </div>
                </div>
              </div>
            </div>`
        },
        'JOYS': { // Miniclip
          bg: '#FF6B00',
          layout: `
            <div style="background:#fff; height:100%; display:flex; flex-direction:column; font-family:Arial,sans-serif;">
              <div class="site-header" style="background:linear-gradient(#FF6B00, #FF4500); color:#fff; border-color:#CC3300;">
                <span style="font-weight:900; text-shadow:1px 1px #000;">Miniclip</span>
                <span style="font-size:6px;">üéÆ FREE GAMES</span>
              </div>
              <div class="site-nav" style="background:#FFE4B5; color:#8B4513; border-color:#DEB887;">
                <span>ACTION</span><span>SPORTS</span><span>PUZZLE</span>
              </div>
              <div style="background:#FFF8DC; flex:1; padding:4px;">
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:3px;">
                  <div style="background:#FF6347; height:24px; border:2px solid #FF4500; border-radius:3px; display:flex; align-items:center; justify-content:center; color:#fff; font-size:6px; font-weight:bold;">
                    8 Ball Pool
                  </div>
                  <div style="background:#4169E1; height:24px; border:2px solid #1E90FF; border-radius:3px; display:flex; align-items:center; justify-content:center; color:#fff; font-size:6px; font-weight:bold;">
                    Agar.io
                  </div>
                </div>
                <div style="background:#FFD700; border:2px solid #FFA500; margin-top:3px; padding:2px; font-size:5px; text-align:center; font-weight:bold;">
                  ‚≠ê PLAY NOW ‚≠ê
                </div>
              </div>
            </div>`
        },
        'ANXIETIES': { // Trello (SaaS glitch)
          bg: '#0079BF',
          layout: `
            <div style="background:#F4F5F7; height:100%; display:flex; flex-direction:column; font-family:Arial,sans-serif;">
              <div class="site-header" style="background:#0079BF; color:#fff; border-color:#026AA7;">
                <span style="font-weight:bold;">Trello</span>
                <span style="font-size:6px;">‚öôÔ∏è Boards</span>
              </div>
              <div style="background:#F4F5F7; flex:1; padding:3px; display:flex; gap:3px;">
                <div style="background:#E2E4E6; flex:1; border-radius:3px; padding:2px;">
                  <div style="background:#fff; padding:2px; font-size:6px; font-weight:bold; margin-bottom:2px;">
                    TO DO (99+)
                  </div>
                  <div style="background:#fff; border:1px solid #ccc; padding:2px; font-size:5px; margin-bottom:2px;">
                    Task 1
                  </div>
                  <div style="background:#fff; border:1px solid #ccc; padding:2px; font-size:5px;">
                    Task 2
                  </div>
                </div>
                <div style="background:#E2E4E6; flex:1; border-radius:3px; padding:2px;">
                  <div style="background:#fff; padding:2px; font-size:6px; font-weight:bold;">
                    DOING (42)
                  </div>
                </div>
                <div style="background:#E2E4E6; flex:1; border-radius:3px; padding:2px;">
                  <div style="background:#fff; padding:2px; font-size:6px; font-weight:bold;">
                    DONE (0)
                  </div>
                </div>
              </div>
            </div>`
        },
        'ART': { // Newgrounds Alt (Flash Portal)
          bg: '#000',
          layout: `
            <div style="background:#000; height:100%; display:flex; flex-direction:column; color:#fff; font-family:Arial,sans-serif;">
              <div class="site-header" style="background:#cc0000; color:#fff; border-color:#990000;">
                <span style="font-weight:bold;">‚òÖ FLASH PORTAL</span>
                <span style="font-size:6px;">‚óèSUBMIT‚óè</span>
              </div>
              <div style="background:#1a1a1a; flex:1; padding:4px;">
                <div style="background:#333; border:2px solid #cc0000; padding:3px; margin-bottom:3px;">
                  <div style="font-size:7px; color:#ff6600; font-weight:bold;">‚ö° FEATURED</div>
                  <div style="background:#000; height:20px; border:1px solid #666; margin-top:2px;"></div>
                </div>
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:2px;">
                  <div style="background:#222; border:1px solid #555; padding:2px; font-size:5px;">
                    <div style="background:#444; height:12px; margin-bottom:1px;"></div>
                    ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ 4.5
                  </div>
                  <div style="background:#222; border:1px solid #555; padding:2px; font-size:5px;">
                    <div style="background:#444; height:12px; margin-bottom:1px;"></div>
                    ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ 5.0
                  </div>
                </div>
              </div>
            </div>`
        },
        'LAUGHS': { // Homestar Runner
          bg: '#0A3B5C',
          layout: `
            <div style="background:linear-gradient(#0A3B5C, #1A4B6C); height:100%; display:flex; flex-direction:column; font-family:Arial,sans-serif;">
              <div class="site-header" style="background:#FFD700; color:#000; border-color:#FFA500;">
                <span style="font-weight:900;">Homestar Runner</span>
                <span style="font-size:6px;">üèÉ TOONS!</span>
              </div>
              <div style="background:#0A3B5C; flex:1; padding:4px; display:flex; gap:2px;">
                <div style="flex:1; background:#1A4B6C; border:2px solid #FFD700; border-radius:3px; padding:2px;">
                  <div style="background:#FFD700; color:#000; padding:2px; font-size:6px; font-weight:bold; text-align:center; margin-bottom:2px;">
                    STRONG BAD EMAIL
                  </div>
                  <div style="background:#000; height:24px; border:1px solid #FFD700;"></div>
                </div>
                <div style="width:28px; display:flex; flex-direction:column; gap:2px;">
                  <div style="background:#FF6B35; border:2px solid #C73E1D; padding:1px; font-size:5px; text-align:center; color:#fff; font-weight:bold;">
                    PLAY
                  </div>
                  <div style="background:#4ECDC4; border:2px solid:#2AA198; padding:1px; font-size:5px; text-align:center; color:#000; font-weight:bold;">
                    GAMES
                  </div>
                </div>
              </div>
            </div>`
        },
        'COURAGE': { // Addicting Games
          bg: '#8B0000',
          layout: `
            <div style="background:#1a1a1a; height:100%; display:flex; flex-direction:column; font-family:Arial,sans-serif;">
              <div class="site-header" style="background:linear-gradient(#8B0000, #6B0000); color:#FFD700; border-color:#5B0000;">
                <span style="font-weight:900;">Addicting Games</span>
                <span style="font-size:6px;">üéØ PLAY FREE</span>
              </div>
              <div class="site-nav" style="background:#FFD700; color:#8B0000; border-color:#FFA500;">
                <span>ACTION</span><span>PUZZLE</span><span>STRATEGY</span>
              </div>
              <div style="background:#2a2a2a; flex:1; padding:4px;">
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:3px;">
                  <div style="background:#DC143C; height:24px; border:2px solid:#B01030; border-radius:3px; display:flex; align-items:center; justify-content:center; color:#fff; font-size:6px; font-weight:bold;">
                    ‚öîÔ∏è FIGHT
                  </div>
                  <div style="background:#FF6347; height:24px; border:2px solid:#E5533D; border-radius:3px; display:flex; align-items:center; justify-content:center; color:#fff; font-size:6px; font-weight:bold;">
                    üèÉ RUN
                  </div>
                </div>
              </div>
            </div>`
        },
        'DREAMS': { // Cartoon Network
          bg: '#000',
          layout: `
            <div style="background:#000; height:100%; display:flex; flex-direction:column; font-family:Arial,sans-serif;">
              <div class="site-header" style="background:#FF1493; color:#fff; border-color:#C71585;">
                <span style="font-weight:900;">CARTOON NETWORK</span>
                <span style="font-size:6px;">üì∫ SHOWS</span>
              </div>
              <div style="background:#FFD700; height:10px; border-bottom:2px solid #FFA500;"></div>
              <div style="background:#1a1a1a; flex:1; padding:4px;">
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:3px;">
                  <div style="background:#00CED1; height:22px; border:3px solid #008B8B; border-radius:4px;"></div>
                  <div style="background:#FF69B4; height:22px; border:3px solid #C71585; border-radius:4px;"></div>
                </div>
                <div style="background:#FF8C00; margin-top:3px; padding:2px; border:2px solid #FF4500; font-size:6px; text-align:center; font-weight:bold; color:#000;">
                  ‚ñ∂ WATCH NOW
                </div>
              </div>
            </div>`
        },
        'TRIUMPHS': { // Kongregate
          bg: '#FF0000',
          layout: `
            <div style="background:#1a1a1a; height:100%; display:flex; flex-direction:column; font-family:Arial,sans-serif;">
              <div class="site-header" style="background:linear-gradient(#FF0000, #CC0000); color:#fff; border-color:#990000;">
                <span style="font-weight:900;">Kongregate</span>
                <span style="font-size:6px;">üèÜ BADGES</span>
              </div>
              <div class="site-nav" style="background:#2a2a2a; color:#FF6347; border-color:#1a1a1a;">
                <span>GAMES</span><span>HIGHSCORES</span><span>CHAT</span>
              </div>
              <div style="background:#0a0a0a; flex:1; padding:4px;">
                <div style="background:#2a2a2a; border:2px solid #FF0000; padding:2px; margin-bottom:2px;">
                  <div style="font-size:6px; color:#FFD700; font-weight:bold;">‚≠ê FEATURED GAME</div>
                  <div style="background:#000; height:18px; border:1px solid #444; margin-top:2px;"></div>
                </div>
                <div style="display:flex; gap:2px; justify-content:space-around;">
                  <div style="background:#FFD700; width:14px; height:14px; border:2px solid #FFA500; border-radius:50%; display:flex; align-items:center; justify-content:center; font-size:8px;">üèÜ</div>
                  <div style="background:#C0C0C0; width:14px; height:14px; border:2px solid #A0A0A0; border-radius:50%; display:flex; align-items:center; justify-content:center; font-size:8px;">ü•à</div>
                  <div style="background:#CD7F32; width:14px; height:14px; border:2px solid:#A0522D; border-radius:50%; display:flex; align-items:center; justify-content:center; font-size:8px;">ü•â</div>
                </div>
              </div>
            </div>`
        },
        'WISDOM': { // Wikipedia (2000s style)
          bg: '#fff',
          layout: `
            <div style="background:#fff; height:100%; display:flex; flex-direction:column; font-family:Georgia,serif;">
              <div class="site-header" style="background:#f6f6f6; color:#000; border-color:#a7d7f9;">
                <span style="font-weight:bold; font-style:italic;">Wikipedia</span>
                <span style="font-size:6px;">üìñ The Free Encyclopedia</span>
              </div>
              <div style="background:#fff; flex:1; padding:4px; font-size:6px; line-height:1.4;">
                <div style="border:1px solid #a7d7f9; background:#f9f9f9; padding:3px; margin-bottom:2px;">
                  <div style="font-weight:bold; font-size:7px; border-bottom:1px solid #a7d7f9; padding-bottom:1px; margin-bottom:2px;">
                    Article Title
                  </div>
                  <div style="color:#666;">
                    From Wikipedia, the free encyclopedia
                  </div>
                </div>
                <div style="color:#000; line-height:1.3;">
                  <p style="margin:0 0 2px 0;">This is an article about something interesting...</p>
                  <div style="background:#f9f9f9; border:1px solid #ccc; padding:2px; margin-top:2px;">
                    <div style="font-weight:bold; font-size:5px; margin-bottom:1px;">Contents</div>
                    <div style="font-size:5px; color:#0645ad;">1. Section One<br>2. Section Two</div>
                  </div>
                </div>
              </div>
            </div>`
        }
      };
      
      return siteConfigs[name]?.layout || null;
    }
    
    // Load features with priorities
    let features = [];
    try {
      const sessionFeatures = sessionStorage.getItem('celli:betaFormSelections');
      if (sessionFeatures) features = JSON.parse(sessionFeatures);
    } catch (e) {}
    
    if (features.length === 0) {
      features = ['Level Editor', 'Story Mode', 'Musical Numbers', 'Boss Fights', 'Puzzles'];
    }
    
    // In bonus mode, replace features with "components of life"
    if (isBonusMode) {
      const componentsOfLife = [
        'LAUGHS', 'TEARS', 'FEARS', 'JOYS', 'SMILES', 'SNEERS',
        'DREAMS', 'DESIRES', 'AMBITIONS', 'ANXIETIES', 'LOVE', 'HATRED',
        'ART', 'BEAUTY', 'STORIES', 'MEMORIES', 'CURIOSITIES',
        'HOPES', 'SORROWS', 'PASSIONS', 'REGRETS', 'TRIUMPHS',
        'FAILURES', 'WISDOM', 'FOLLY', 'COURAGE', 'DOUBT',
        'FAITH', 'WONDER', 'GRATITUDE'
      ];
      
      // Shuffle the array
      const shuffled = componentsOfLife.sort(() => Math.random() - 0.5);
      
      // Ensure we have enough (repeat if needed)
      while (shuffled.length < features.length) {
        shuffled.push(...componentsOfLife.sort(() => Math.random() - 0.5));
      }
      
      // Replace feature names
      features = features.map((f, i) => shuffled[i]);
      console.log('üíÄ Replaced features with components of life:', features);
    }
    
    // Assign priorities (1-5, from session or random)
    features = features.map((f, i) => ({
      name: f,
      priority: Math.floor(Math.random() * 3) + 1  // 1=High, 2=Med, 3=Low
    }));
    
    const TOTAL_FEATURES = features.length;
    console.log(`üì¶ ${TOTAL_FEATURES} features with priorities`);
    
    // Tracking for completion
    let tilesConvertedToParticles = 0;
    let cardsFullyMaterialized = 0;
    
    const toneColors = [
      { bg: '#fff', fg: '#000', border: '#fff' },
      { bg: '#2846ff', fg: '#f5f7ff', border: '#9ab3ff' },
      { bg: '#ff9d1c', fg: '#2a1400', border: '#ffd28a' },
      { bg: '#ff185f', fg: '#fff3f8', border: '#ff7aa5' }
    ];
    
    const priorityColors = {
      1: { bg: '#ff5263', label: 'High' },
      2: { bg: '#F39C12', label: 'Med' },
      3: { bg: '#888', label: 'Low' }
    };
    
    // === AUDIO ANALYSIS FOR BONUS MODE ===
    let audioContext = null;
    let audioAnalyser = null;
    let audioDataArray = null;
    let audioBufferLength = 0;
    
    if (isBonusMode) {
      // Set up Web Audio API for frequency analysis
      try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        audioAnalyser = audioContext.createAnalyser();
        audioAnalyser.fftSize = 256;
        audioBufferLength = audioAnalyser.frequencyBinCount;
        audioDataArray = new Uint8Array(audioBufferLength);
        console.log('üéµ Audio analyzer initialized for reactive track');
      } catch (e) {
        console.warn('Could not initialize audio analysis:', e);
      }
    }

    // === GLOBAL SKULL TOWER STATE (shared by tomb rise and finale) ===
    window.skullTowers = [];
    window.skullsBuilt = false;
    window.skullsCollapse = false;
    window.buildSkullTowers = function buildSkullTowers(vw, vh, floorYFinale, riseProgress = 0) {
      if (window.skullsBuilt) return;
      window.skullsBuilt = true;
      const towerXs = [vw * 0.12, vw * 0.26, vw * 0.5, vw * 0.74, vw * 0.88];
      const rows = 12; // taller towers
      const spacing = 26;
      const jitter = 6;
      const skullSize = 22;
      towerXs.forEach((tx) => {
        for (let r = 0; r < rows; r++) {
          const count = rows - r; // pyramid shape
          const totalWidth = (count - 1) * spacing;
          const baseX = tx - totalWidth / 2;
          const baseY = floorYFinale - r * spacing - 10;
          const y = baseY + (1 - riseProgress) * 140; // lifted into place as tomb rises
          const rowOffset = ((r % 2 === 0) ? -1 : 1) * (jitter * 0.6) + (Math.random() - 0.5) * jitter;
          for (let c = 0; c < count; c++) {
            window.skullTowers.push({
              x: baseX + c * spacing + rowOffset,
              y,
              vx: 0,
              vy: 0,
              size: skullSize,
              state: 'stack'
            });
          }
        }
      });
    };
    
    // === LENGTHIER ROLLERCOASTER WITH CONTINUOUS ACCELERATION ===
    const trackCanvas = document.getElementById('trackCanvas');
    const trackCtx = trackCanvas.getContext('2d');
    
    // Smooth path focused on LONG acceleration zones
    let trackPath = [];
    const segments = 70;
    
    // Base control points (will be modulated by audio in bonus mode)
    // Track calculation: 84 seconds * ~40 px/sec average = ~3360px horizontal length
    const baseControlPoints = isBonusMode ? [
      // BONUS MODE: EPIC DOUBLE-LENGTH ROLLERCOASTER - 84 seconds of maximum variety!
      // === MIRROR INITIAL CLIMB ===
      { x: 0, y: 600 },       // Entry (mirrors normal)
      { x: 250, y: 600 },     // Flat (mirrors normal)
      { x: 500, y: 580 },     // Start curve (mirrors normal)
      { x: 700, y: 520 },     // Curve up (mirrors normal)
      { x: 900, y: 400 },     // Climbing (mirrors normal)
      { x: 1100, y: 280 },    // Steeper (mirrors normal)
      { x: 1300, y: 200 },    // Peak (mirrors normal)
      // === LENGTHY HILL - Extended climb and dramatic descent ===
      { x: 1450, y: 180 },    // Continue climb
      { x: 1600, y: 150 },    // Higher
      { x: 1750, y: 120 },    // Even higher
      { x: 1900, y: 100 },    // HIGHEST PEAK!
      { x: 2050, y: 200 },    // Start descent
      { x: 2200, y: 400 },    // STEEP!
      { x: 2350, y: 700 },    // STEEPER!
      { x: 2500, y: 1100 },   // PLUMMETING!
      { x: 2650, y: 1500 },   // DEEP!
      // === WAVE SECTION 1 ===
      { x: 2900, y: 1300 },   // Up!
      { x: 3150, y: 1000 },   // Peak!
      { x: 3400, y: 1500 },   // Down!
      { x: 3650, y: 1900 },   // Valley!
      // === MINI HILL CLUSTER ===
      { x: 3800, y: 1700 },   // Mini up
      { x: 3950, y: 1900 },   // Mini down
      { x: 4100, y: 1750 },   // Mini up
      { x: 4250, y: 2000 },   // Mini down
      // === STEEP DESCENT ===
      { x: 4400, y: 2500 },   // STEEP!
      { x: 4550, y: 3000 },   // STEEPER!
      { x: 4700, y: 3500 },   // PLUMMETING!
      // === FLAT SPEED ZONE ===
      { x: 5000, y: 3550 },   // Flatten
      { x: 5300, y: 3600 },   // Flat cruise
      { x: 5600, y: 3650 },   // Still flat
      // === WAVE SECTION 2 - BIG WAVES ===
      { x: 5900, y: 3400 },   // Up!
      { x: 6200, y: 3000 },   // High peak!
      { x: 6500, y: 3500 },   // Down!
      { x: 6800, y: 4000 },   // Deep valley!
      // === QUICK CLIMB TO SECOND PEAK ===
      { x: 7100, y: 3700 },   // Climbing
      { x: 7400, y: 3200 },   // Peak!
      // === VERY LENGTHY STEEP DESCENT ‚Üí RAMP (FIRE ZONE) ===
      { x: 7700, y: 3600 },   // Start steep
      { x: 8000, y: 4100 },   // STEEP!
      { x: 8300, y: 4700 },   // STEEPER!
      { x: 8600, y: 5400 },   // PLUMMETING!
      { x: 8900, y: 6200 },   // MASSIVE DESCENT!
      { x: 9200, y: 7100 },   // DEEPEST POINT! (FIRE HERE)
      { x: 9500, y: 7200 },   // Still deep
      { x: 9800, y: 6900 },   // RAMP UP!
      { x: 10100, y: 6500 },  // RAMP CONTINUES!
      { x: 10400, y: 6000 },  // RAMP END!
      // === LOOP-DE-LOOP! ===
      { x: 10700, y: 5700 },  // Approach loop
      { x: 11000, y: 5300 },  // Up!
      { x: 11200, y: 4900 },  // LOOP TOP!
      { x: 11400, y: 5300 },  // Down!
      { x: 11700, y: 5700 },  // Exit loop
      // === WAVE SECTION 3 - TRIPLE WAVE (SNOW ZONE) ===
      { x: 12000, y: 5800 },  // Wave 1 up
      { x: 12300, y: 5500 },  // Wave 1 peak
      { x: 12600, y: 5900 },  // Wave 1 down (SNOW HERE)
      { x: 12900, y: 5700 },  // Wave 2 up
      { x: 13200, y: 5400 },  // Wave 2 peak
      { x: 13500, y: 5800 },  // Wave 2 down
      { x: 13800, y: 5600 },  // Wave 3 up
      { x: 14100, y: 5300 },  // Wave 3 peak
      { x: 14400, y: 5700 },  // Wave 3 down
      // === BUNNY HOPS SECTION ===
      { x: 14600, y: 5500 },  // Hop 1
      { x: 14800, y: 5700 },  // Dip 1
      { x: 15000, y: 5550 },  // Hop 2
      { x: 15200, y: 5750 },  // Dip 2
      { x: 15400, y: 5600 },  // Hop 3
      { x: 15600, y: 5800 },  // Final dip
      // === PRE-JUMP WAVE ===
      { x: 15900, y: 5600 },  // Build up
      { x: 16200, y: 5300 },  // Peak
      { x: 16500, y: 5700 },  // Valley
      // === JUMP SECTION - GAP IN TRACK! ===
      { x: 16800, y: 6000 },  // Pre-jump ramp up!
      { x: 17000, y: 5900 },  // LAUNCH! (bones hidden from here)
      { x: 17300, y: 5800 },  // MID-AIR! (no bones)
      { x: 17600, y: 5950 },  // LANDING! (bones resume)
      // === FINAL WAVE CASCADE ===
      { x: 17900, y: 5750 },  // Up
      { x: 18200, y: 6000 },  // Down
      { x: 18500, y: 5850 },  // Up
      { x: 18800, y: 6100 },  // Down
      // === FINAL RUN ===
      { x: 19100, y: 6200 },  // Level out
      { x: 19400, y: 6250 },  // Slow approach
      { x: 19700, y: 6300 }   // End
    ] : [
      // NORMAL MODE: Original fast track
      { x: 0, y: 600 },       // Entry from left edge (straight line)
      { x: 250, y: 600 },     // Continue straight
      { x: 500, y: 580 },     // Start curving
      { x: 700, y: 520 },     // Smooth curve up
      { x: 900, y: 400 },     // Continue climbing
      { x: 1100, y: 280 },    // Steeper climb
      { x: 1300, y: 200 },    // Peak
      { x: 1500, y: 250 },    // Start descent
      { x: 1700, y: 450 },    // Descending
      { x: 1900, y: 700 },    // LONG STEEP DROP
      { x: 2100, y: 1000 },   // Continue steep drop
      { x: 2400, y: 1300 },   // Still dropping
      { x: 2700, y: 1500 },   // Bottom out (max speed)
      { x: 3000, y: 1550 },   // Level fast section
      { x: 3300, y: 1570 },   // Continue fast
      { x: 3600, y: 1585 },   // Still fast
      { x: 3900, y: 1595 },   // Approaching brake
      { x: 4200, y: 1605 },   // At intake (brake here)
      { x: 4500, y: 1615 }    // End after intake
    ];
    
    // Copy base points to working array
    let controlPoints = baseControlPoints.map(p => ({...p}));
    
    // Function to rebuild track path from control points
    function rebuildTrackPath(points) {
      const newPath = [];
      for (let i = 0; i < points.length - 1; i++) {
        const p0 = points[Math.max(0, i - 1)];
        const p1 = points[i];
        const p2 = points[i + 1];
        const p3 = points[Math.min(points.length - 1, i + 2)];
      
        for (let t = 0; t < segments; t++) {
          const u = t / segments;
          const tt = u * u;
          const ttt = tt * u;
          
          // Catmull-Rom spline
          const x = 0.5 * (
            (2 * p1.x) +
            (-p0.x + p2.x) * u +
            (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * tt +
            (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * ttt
          );
          const y = 0.5 * (
            (2 * p1.y) +
            (-p0.y + p2.y) * u +
            (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * tt +
            (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * ttt
          );
          
          newPath.push({ x, y });
        }
      }
      return newPath;
    }
    
    // Build initial track path
    trackPath = rebuildTrackPath(controlPoints);
    
    // Function to draw track (can be called repeatedly for audio reactivity)
    // cameraX: the current camera X position (train position)
    function drawTrack(points, cameraX = 0) {
      // Fill with black background
      trackCtx.fillStyle = '#000000';
      trackCtx.fillRect(0, 0, trackCanvas.width, trackCanvas.height);
      
      if (isBonusMode) {
        // BONUS MODE: Draw SMALL bone segments - dynamically based on camera position
        const boneLength = 50;      // SHORTER bones
        const boneWidth = 10;       // SMALLER width
        const boneSpacing = 30;     // SPACED OUT more
        const knobRadius = 6;       // TINY knobs
        const knobSpacing = 11;     // Distance between the two knobs
        
        // Get smooth path from control points
        const smoothPath = rebuildTrackPath(points);
        
        trackCtx.fillStyle = '#fff';
        trackCtx.shadowBlur = 0;
        
        // Calculate total path length
        let totalLength = 0;
        const pathSegments = [];
        for (let i = 0; i < smoothPath.length - 1; i++) {
          const dx = smoothPath[i + 1].x - smoothPath[i].x;
          const dy = smoothPath[i + 1].y - smoothPath[i].y;
          const len = Math.sqrt(dx * dx + dy * dy);
          pathSegments.push({ start: totalLength, end: totalLength + len, idx: i });
          totalLength += len;
        }
        
        // Draw bones far ahead and behind camera position
        const viewportBuffer = 3000; // Draw 3000px behind
        const aheadBuffer = 8000; // Draw 8000px ahead (procedurally builds track)
        const minX = cameraX - viewportBuffer;
        const maxX = cameraX + aheadBuffer;
        
        // Draw bones at regular intervals along the path
        const boneInterval = boneLength + boneSpacing;
        let currentDist = 0;
        
        // Jump zone where bones are hidden (x: 17000-17600)
        const jumpZoneStart = 17000;
        const jumpZoneEnd = 17600;
        
        // Helper to get point at distance
        const getPointAtDist = (dist) => {
          for (const seg of pathSegments) {
            if (dist >= seg.start && dist <= seg.end) {
              const t = (dist - seg.start) / (seg.end - seg.start);
              const p1 = smoothPath[seg.idx];
              const p2 = smoothPath[seg.idx + 1];
              return {
                x: p1.x + (p2.x - p1.x) * t,
                y: p1.y + (p2.y - p1.y) * t
              };
            }
          }
          return smoothPath[smoothPath.length - 1];
        };
        
        while (currentDist < totalLength - boneLength) {
          const startPoint = getPointAtDist(currentDist);
          const endPoint = getPointAtDist(currentDist + boneLength);
          
          // Skip if outside visible range
          if (startPoint.x < minX || startPoint.x > maxX) {
            currentDist += boneInterval;
            continue;
          }
          
          // Skip drawing bones in the jump zone
          if (startPoint.x >= jumpZoneStart && startPoint.x <= jumpZoneEnd) {
            currentDist += boneInterval;
            continue;
          }
          
          const dx = endPoint.x - startPoint.x;
          const dy = endPoint.y - startPoint.y;
          const angle = Math.atan2(dy, dx);
          
          const centerX = (startPoint.x + endPoint.x) / 2;
          const centerY = (startPoint.y + endPoint.y) / 2;
          
          trackCtx.save();
          trackCtx.translate(centerX, centerY);
          trackCtx.rotate(angle);
          
          // Draw bone shaft - THICKER (no outline)
          trackCtx.fillStyle = '#fff';
          trackCtx.fillRect(-boneLength / 2, -boneWidth / 2, boneLength, boneWidth);
          
          // Draw knobs at left end (no outlines)
          trackCtx.fillStyle = '#fff';
          trackCtx.beginPath();
          trackCtx.arc(-boneLength / 2, -knobSpacing / 2, knobRadius, 0, Math.PI * 2);
          trackCtx.fill();
          trackCtx.beginPath();
          trackCtx.arc(-boneLength / 2, knobSpacing / 2, knobRadius, 0, Math.PI * 2);
          trackCtx.fill();
          
          // Draw knobs at right end (no outlines)
          trackCtx.beginPath();
          trackCtx.arc(boneLength / 2, -knobSpacing / 2, knobRadius, 0, Math.PI * 2);
          trackCtx.fill();
          trackCtx.beginPath();
          trackCtx.arc(boneLength / 2, knobSpacing / 2, knobRadius, 0, Math.PI * 2);
          trackCtx.fill();
          
          trackCtx.restore();
          
          currentDist += boneInterval;
        }
      } else {
        // NORMAL MODE: Regular track
        trackCtx.strokeStyle = '#fff';
        trackCtx.lineWidth = 5;
        trackCtx.lineCap = 'round';
        trackCtx.lineJoin = 'round';
        trackCtx.shadowColor = 'rgba(255, 255, 255, 0.6)';
        trackCtx.shadowBlur = 12;
        
        const path = rebuildTrackPath(points);
        trackCtx.beginPath();
        path.forEach((p, i) => {
          if (i === 0) trackCtx.moveTo(p.x, p.y);
          else trackCtx.lineTo(p.x, p.y);
        });
        trackCtx.stroke();
        
        trackCtx.fillStyle = '#fff';
        trackCtx.shadowBlur = 15;
        points.forEach(cp => {
          trackCtx.beginPath();
          trackCtx.arc(cp.x, cp.y, 6, 0, Math.PI * 2);
          trackCtx.fill();
        });
        
        trackCtx.shadowBlur = 0;
      }
    }
    
    // Draw initial track
    drawTrack(controlPoints);
    console.log(`üé¢ Line Rider track: ${trackPath.length} points, acceleration zones built`);
    
    // === POSITIONING ===
    const intakeSystem = document.getElementById('intakeSystem');
    // Position intake near the end of the track (at brake zone)
    const intakeTrackPoint = trackPath[Math.floor(trackPath.length * 0.82)]; // Near end
    const intakeCenterX = intakeTrackPoint.x;
    const intakeCenterY = intakeTrackPoint.y + 300;
    intakeSystem.style.left = `${intakeCenterX - 350}px`; // Center the 700px wide box
    intakeSystem.style.top = `${intakeCenterY}px`;
    
    console.log(`üì¶ Intake positioned at (${intakeCenterX}, ${intakeCenterY})`);
    
    const assignaBoard = document.getElementById('assignaBoard');
    assignaBoard.style.left = `${intakeCenterX - 600}px`;
    assignaBoard.style.top = `${intakeCenterY + 250}px`;
    
    // === DRAW ASSIGNA BOARD ===
    const assignaCanvas = document.getElementById('assignaCanvas');
    const boardCtx = assignaCanvas.getContext('2d');
    
    function roundRect(ctx, x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.arcTo(x + w, y, x + w, y + h, r);
      ctx.arcTo(x + w, y + h, x, y + h, r);
      ctx.arcTo(x, y + h, x, y, r);
      ctx.arcTo(x, y, x + w, y, r);
      ctx.closePath();
      ctx.fill();
    }
    
    function drawBoard() {
      boardCtx.fillStyle = '#1a1a1a';
      roundRect(boardCtx, 0, 0, 1200, 900, 30);
      
      // Sidebar
      boardCtx.fillStyle = '#252525';
      boardCtx.fillRect(0, 0, 240, 900);
      
      // Header
      boardCtx.fillStyle = '#2a2a2a';
      boardCtx.fillRect(240, 0, 960, 70);
      
      // Logo - Three red circles in triangle formation
      boardCtx.fillStyle = '#ff5263';
      // Top circle
      boardCtx.beginPath();
      boardCtx.arc(42, 28, 8, 0, Math.PI * 2);
      boardCtx.fill();
      // Bottom left circle
      boardCtx.beginPath();
      boardCtx.arc(32, 48, 8, 0, Math.PI * 2);
      boardCtx.fill();
      // Bottom right circle
      boardCtx.beginPath();
      boardCtx.arc(52, 48, 8, 0, Math.PI * 2);
      boardCtx.fill();
      
      boardCtx.fillStyle = '#fff';
      boardCtx.font = 'bold 32px Arial';
      boardCtx.fillText('Assigna', 75, 48);
      
      // Search
      boardCtx.fillStyle = '#333';
      roundRect(boardCtx, 500, 22, 300, 36, 18);
      boardCtx.fillStyle = '#888';
      boardCtx.font = '15px Arial';
      boardCtx.fillText('Search tasks...', 520, 44);
      
      // Sidebar nav
      const navItems = [
        { name: 'Home', icon: 'üè†' },
        { name: 'My Tasks', icon: '‚úì', active: true },
        { name: 'Inbox', icon: 'üì•' },
        { name: 'Projects', icon: 'üìä' }
      ];
      
      navItems.forEach((item, i) => {
        const y = 100 + i * 60;
        if (item.active) {
          boardCtx.fillStyle = 'rgba(66, 133, 244, 0.2)';
          roundRect(boardCtx, 12, y, 216, 48, 10);
        }
        boardCtx.fillStyle = item.active ? '#fff' : '#aaa';
        boardCtx.font = '18px Arial';
        boardCtx.fillText(item.name, 60, y + 30);
        boardCtx.font = '24px Arial';
        boardCtx.fillText(item.icon, 20, y + 32);
      });
      
      // Kanban columns
      const columnTitles = window.glitchingColumnTitles || [
        { title: 'TO DO', color: '#E85D75' },
        { title: 'IN PROGRESS', color: '#F39C12' },
        { title: 'REVIEW', color: '#9B59B6' },
        { title: 'DONE', color: '#27AE60' }
      ];
      // Fit all 4 columns fully inside 1200px (content area starts at x=240)
      const columnWidth = 210;
      const columnStep = 230; // spacing between column x origins
      const columns = columnTitles.map((col, idx) => ({
        ...col,
        x: 270 + idx * columnStep,
        w: columnWidth
      }));
      
      columns.forEach((col, idx) => {
        // Column header
        boardCtx.fillStyle = col.color;
        roundRect(boardCtx, col.x, 100, col.w, 48, 10);
        boardCtx.fillStyle = '#fff';
        boardCtx.font = 'bold 16px Arial';
        boardCtx.fillText(col.title, col.x + 16, 100 + 28);
        
        // Placeholder cards
        for (let c = 0; c < 2; c++) {
          const cardY = 160 + c * 100;
          boardCtx.fillStyle = '#2a2a2a';
          roundRect(boardCtx, col.x, cardY, col.w, 85, 10);
          
          boardCtx.fillStyle = '#999';
          boardCtx.font = '13px Arial';
          boardCtx.fillText('Existing task...', col.x + 14, cardY + 28);
        }
      });
      
      // Store column positions for materialization
      window.kanbanColumns = columns;
    }
    
    drawBoard();
    
    // === CREATE TRAIN CARS ===
    const scene = document.getElementById('scene');
    const trainCars = [];
    
    // Submit button as engine (FIRST/FRONT of train)
    const submitEngine = document.createElement('div');
    submitEngine.className = 'train-car';
    // In bonus mode, show SOBMIT with rotating crying emojis
    if (isBonusMode) {
      const crying = ['üò≠','üò¢','ü•≤','üòø'];
      let cryIdx = 0;
      const label = document.createElement('div');
      label.style.display = 'flex';
      label.style.gap = '6px';
      label.style.alignItems = 'center';
      label.style.justifyContent = 'center';
      const textSpan = document.createElement('span');
      textSpan.textContent = 'SOBMIT';
      const emojiSpan = document.createElement('span');
      emojiSpan.textContent = crying[0];
      label.appendChild(textSpan);
      label.appendChild(emojiSpan);
      submitEngine.appendChild(label);
      setInterval(() => {
        cryIdx = (cryIdx + 1) % crying.length;
        emojiSpan.textContent = crying[cryIdx];
      }, 300);
    } else {
      submitEngine.textContent = 'SUBMIT';
    }
    submitEngine.style.background = '#fff';
    submitEngine.style.color = '#000';
    submitEngine.style.borderColor = '#fff';
    submitEngine.style.fontWeight = '900';
    submitEngine.style.fontSize = '1.1rem';
    submitEngine.style.zIndex = '100';  // Above all other cars
    scene.appendChild(submitEngine);
    
    // Feature cars in NORMAL ORDER (Submit leads, features follow behind)
    features.forEach((feature, i) => {
      const car = document.createElement('div');
      car.className = 'train-car';
      car.textContent = isBonusMode ? feature.name : String(feature.name).toUpperCase();
      
      const color = toneColors[(i + 1) % toneColors.length];
      car.style.background = color.bg;
      car.style.color = color.fg;
      car.style.borderColor = color.border;
      car.style.zIndex = `${99 - i}`;  // Stack order descending
      
      // Priority badge
      const badge = document.createElement('div');
      badge.className = 'priority-badge';
      badge.textContent = feature.priority;
      badge.style.background = priorityColors[feature.priority].bg;
      badge.style.borderColor = color.border;
      badge.style.color = '#fff';
      car.appendChild(badge);
      
      scene.appendChild(car);
      trainCars.push({ el: car, feature, color, collected: false });
    });
    
    console.log(`üöÇ Submit LEADING + ${trainCars.length} feature cars following`);
    
    // === PATH PHYSICS ===
    let pathLength = 0;
    const pathSegments = [];
    
    for (let i = 0; i < trackPath.length - 1; i++) {
      const dx = trackPath[i + 1].x - trackPath[i].x;
      const dy = trackPath[i + 1].y - trackPath[i].y;
      const len = Math.sqrt(dx * dx + dy * dy);
      pathSegments.push({ start: pathLength, end: pathLength + len, idx: i });
      pathLength += len;
    }
    
    function getPathPosAndTangent(dist) {
      dist = Math.max(0, Math.min(dist, pathLength));
      
      for (let seg of pathSegments) {
        if (dist >= seg.start && dist <= seg.end) {
          const t = (dist - seg.start) / (seg.end - seg.start);
          const i = seg.idx;
          const p1 = trackPath[i];
          const p2 = trackPath[i + 1];
          
          const x = p1.x + (p2.x - p1.x) * t;
          const y = p1.y + (p2.y - p1.y) * t;
          const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
          
          // Calculate slope for momentum
          const slope = (p2.y - p1.y) / (p2.x - p1.x);
          
          return { x, y, angle, slope };
        }
      }
      
      return { x: trackPath[0].x, y: trackPath[0].y, angle: 0, slope: 0 };
    }
    
    // === ANIMATION STATE ===
    // Dynamic velocity system for bonus mode
    let velocity = isBonusMode ? 3.0 : 6.0;  // Start moderate
    const baseSpeed = isBonusMode ? 3.0 : 6.0;
    const maxSpeed = isBonusMode ? 35.0 : 25.0;  // HIGHER max for dramatic moments
    const gravityAccel = isBonusMode ? 5.0 : 3.5;  // STRONGER acceleration for dynamic feel
    let engineDistance = 0;
    let collectedCount = 0;
    let allCollected = false;
    let zapPhase = 0; // 0: collecting, 1: tiles-falling, 2: particles, 3: materializing
    let submitLaunched = false;
    let haltingPhase = false;
    let launchPhase = 0; // For spring launch animation
    let launchTimer = 0;
    let speedTrail = [];  // For motion blur effect
    let downhillTime = 0; // Track how long we've been going downhill for progressive acceleration
    
    const intakeBox = document.getElementById('intakeBox');
    const particleCanvas = document.getElementById('particleCanvas');
    const particleCtx = particleCanvas.getContext('2d');
    
    let particles = [];
    let materializingCards = [];
    
    function positionCar(el, pos, extraRotation = 0) {
      el.style.left = `${pos.x}px`;
      el.style.top = `${pos.y}px`;
      el.style.transform = `translate(-50%, -50%) rotate(${pos.angle + extraRotation}rad)`;
    }
    
    // Track if we're in jump zone for flip animation
    let inJumpZone = false;
    let jumpFlipRotation = 0;
    const jumpZoneStartX = 17000;
    const jumpZoneEndX = 17600;
    
    let fallingTiles = [];
    
    function collectItem(car, index) {
      if (car.collected) return;
      car.collected = true;
      collectedCount++;
      
      console.log(`üì¶ #${collectedCount}: ${car.feature.name} (P${car.feature.priority})`);
      
      // Get car position for tile launch
      const scene = document.getElementById('scene');
      const carRect = car.el.getBoundingClientRect();
      const sceneRect = scene.getBoundingClientRect();
      
      const startX = carRect.left - sceneRect.left;
      const startY = carRect.top - sceneRect.top;
      
      // Create tile that will fall (with childhood site visual representation)
      const tile = document.createElement('div');
      tile.className = 'collected-item';
      
      // Map component names to childhood websites and create visual representations
      const featureName = car.feature.name;
      const siteLayout = generateChildhoodSiteLayout(featureName);
      
      if (siteLayout) {
        tile.innerHTML = siteLayout;
        tile.style.overflow = 'hidden';
        tile.style.padding = '0';
      } else {
        tile.textContent = featureName;
        tile.style.background = car.color.bg;
        tile.style.color = car.color.fg;
      }
      
      tile.style.borderColor = car.color.border;
      tile.style.position = 'absolute';
      tile.style.left = `${startX}px`;
      tile.style.top = `${startY}px`;
      tile.style.animation = 'none';
      tile.style.width = '160px';
      tile.style.height = '120px';
      tile.style.zIndex = '150'; // Above FX overlays (fire/snow at 80, grain at 85) but below particles (300)
      
      // Store data
      tile.dataset.featureName = featureName;
      tile.dataset.priority = car.feature.priority;
      tile.dataset.color = car.color.border;
      
      // Apply glitch effect for SaaS/productivity terms
      if (isSaaSorProductivity(featureName)) {
        tile.classList.add('saas-glitch');
      }
      
      scene.appendChild(tile);
      
      // Calculate intake position
      const intakeSystem = document.getElementById('intakeSystem');
      const intakeRect = intakeSystem.getBoundingClientRect();
      const targetIntakeCenterX = intakeRect.left - sceneRect.left + 350;
      
      // Launch towards intake with arc
      const toIntakeX = targetIntakeCenterX - startX;
      const lateralVx = toIntakeX * 0.6 + (Math.random() - 0.5) * 80; // More direct aim
      
      console.log(`üéØ Launching ${car.feature.name} from (${startX.toFixed(0)}, ${startY.toFixed(0)}) towards intake at X:${targetIntakeCenterX.toFixed(0)}`);
      
      // Add to falling tiles array with DRAMATIC launch physics
      const newTile = {
        el: tile,
        x: startX,
        y: startY,
        vx: lateralVx,  // Launch towards intake
        vy: -150 - Math.random() * 150,   // Strong upward launch
        rotation: 0,
        rotationSpeed: (Math.random() - 0.5) * 15,  // Faster spin
        feature: car.feature,
        color: car.color,
        inFunnel: false,
        hasBurst: false,
        startTime: performance.now(),  // Set immediately
        updateCount: 0,
        index: collectedCount - 1  // Store index for particle creation
      };
      
      fallingTiles.push(newTile);
      
      console.log(`üìä Added tile #${collectedCount}: ${car.feature.name} | Total: ${fallingTiles.length} | StartTime: ${newTile.startTime}`);
      
      // Hide car
      car.el.style.opacity = '0';
      
      if (collectedCount === trainCars.length) {
        allCollected = true;
        haltingPhase = true;
        console.log('‚úÖ ALL COLLECTED - DRAMATIC HALT!');
        setTimeout(() => {
          zapPhase = 1;
          console.log('üé¢ Tiles falling into filter...');
        }, 500);
      }
    }
    
    function updateFallingTiles(dt) {
      if (fallingTiles.length === 0) return;
      
      const scene = document.getElementById('scene');
      const intakeRect = intakeSystem.getBoundingClientRect();
      const sceneRect = scene.getBoundingClientRect();
      const funnelCenterX = intakeRect.left - sceneRect.left + 350;
      const funnelTopY = intakeRect.top - sceneRect.top - 200; // Even higher threshold
      const funnelWidth = 2000; // MASSIVE detection area
      
      const now = performance.now();
      
      fallingTiles.forEach((tile) => {
        if (tile.inFunnel || tile.hasBurst) return; // Skip if already processed
        
        tile.updateCount++;
        
        // Physics with MUCH STRONGER gravity
        tile.vy += 2200 * dt;
        tile.x += tile.vx * dt;
        tile.y += tile.vy * dt;
        tile.rotation += tile.rotationSpeed * dt * 3;
        tile.vx *= 0.96;
        
        // STRONG attraction towards funnel
        const distX = funnelCenterX - tile.x;
        tile.vx += distX * 0.008; // Even stronger pull
        
        // Update DOM
        tile.el.style.left = `${tile.x}px`;
        tile.el.style.top = `${tile.y}px`;
        tile.el.style.transform = `translate(-50%, -50%) rotate(${tile.rotation}rad)`;
        
        const timeElapsed = now - tile.startTime;
        const distFromCenter = Math.abs(tile.x - funnelCenterX);
        
        // EXTREMELY aggressive detection - burst immediately if ANY condition is true
        const shouldBurst = (
          (tile.y > funnelTopY) ||  // Simply reached Y threshold
          (timeElapsed > 1500) ||  // 1.5 second timeout
          (tile.updateCount > 90) ||  // 90 frames
          (distFromCenter < funnelWidth && tile.y > funnelTopY - 300)  // Near funnel
        );
        
        if (shouldBurst) {
          tile.inFunnel = true;
          const reason = timeElapsed > 1500 ? 'TIMEOUT_1.5s' : 
                        tile.updateCount > 90 ? 'FRAME_LIMIT' :
                        tile.y > funnelTopY ? 'Y_THRESHOLD' : 'NEAR_FUNNEL';
          console.log(`üí• ${tile.feature.name} BURST [${reason}] at (${tile.x.toFixed(0)}, ${tile.y.toFixed(0)}) after ${(timeElapsed/1000).toFixed(1)}s`);
          burstTileIntoParticles(tile, tile.index);
        } else if (tile.updateCount % 30 === 0) {
          console.log(`‚è≥ ${tile.feature.name} waiting: Y:${tile.y.toFixed(0)} (need>${funnelTopY}) | ${(timeElapsed/1000).toFixed(1)}s`);
        }
      });
    }
    
    function burstTileIntoParticles(tile, itemIdx) {
      // Prevent double-bursting
      if (tile.hasBurst) {
        console.log(`‚ö†Ô∏è ${tile.feature.name} already burst, skipping`);
        return;
      }
      tile.hasBurst = true;
      
      const scene = document.getElementById('scene');
      const sceneRect = scene.getBoundingClientRect();
      
      const featureName = tile.feature.name;
      const priority = tile.feature.priority;
      const color = tile.color.border;
      
      tilesConvertedToParticles++;
      console.log(`üí•üí•üí• BURSTING ${featureName} into 50 particles (${tilesConvertedToParticles}/${TOTAL_FEATURES} converted)`);
      
      // Log when ALL tiles have converted
      if (tilesConvertedToParticles === TOTAL_FEATURES) {
        console.log(`üéâüéâüéâ ALL ${TOTAL_FEATURES} TILES CONVERTED TO PARTICLES!`);
      }
      
      // Burst into particles
      const particleCount = 50;
      for (let i = 0; i < particleCount; i++) {
        const angle = (i / particleCount) * Math.PI * 2;
        const speed = 40 + Math.random() * 60;
        
        particles.push({
          x: tile.x,
          y: tile.y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed - 100, // Upward burst
          color: color,
          life: 1.0,
          featureName: featureName,
          priority: priority,
          itemIndex: itemIdx,
          phase: 'burst'
        });
      }
      
      console.log(`üé® Total particles now: ${particles.length}`);
      
      // Hide tile
      tile.el.style.opacity = '0';
      setTimeout(() => {
        if (tile.el && tile.el.parentNode) {
          tile.el.remove();
        }
      }, 100);
      
      // Start pan to board if this is first tile (but keep updating other tiles!)
      if (!window.boardPanStarted) {
        window.boardPanStarted = true;
        zapPhase = 2; // Transition to particle phase, but tiles continue updating
        console.log(`üìπ PANNING TO BOARD AS PARTICLES MATERIALIZE! (${tilesConvertedToParticles}/${TOTAL_FEATURES} tiles converted so far)`);
        startBoardPan();
      }
    }
    
    function updateParticles(dt) {
      // Get canvases - use fxCanvas for sandfall particles like fire/snow
      const fxCanvas = document.getElementById('fxOverlay');
      if (!fxCanvas) return;
      const fxCtx = fxCanvas.getContext('2d');
      
      // Clear fxCanvas at START (before drawing sandfall particles)
      // Environmental particles (fire/snow) will be drawn on top without clearing
      fxCanvas.width = window.innerWidth;
      fxCanvas.height = window.innerHeight;
      fxCtx.clearRect(0, 0, fxCanvas.width, fxCanvas.height);
      
      // DEBUG: Confirm canvas is being drawn to
      if (Math.random() < 0.01) {
        console.log(`üñåÔ∏è updateParticles START: Cleared fxCanvas, about to draw ${particles.length} sandfall particles, zapPhase=${zapPhase}`);
      }
      
      if (particles.length === 0) return;
      
      const scene = document.getElementById('scene');
      const intakeRect = intakeSystem.getBoundingClientRect();
      const sceneRect = scene.getBoundingClientRect();
      const funnelCenterX = intakeRect.left - sceneRect.left + 350;
      const funnelTopY = intakeRect.top - sceneRect.top + 300;
      const funnelBottomY = funnelTopY + 130;
      
      const boardRect = assignaBoard.getBoundingClientRect();
      const boardCenterX = boardRect.left - sceneRect.left + 600;
      const boardTopY = boardRect.top - sceneRect.top;
      
      // Debug particle phases occasionally
      if (Math.random() < 0.05) {
        const phaseCounts = {};
        particles.forEach(p => {
          phaseCounts[p.phase] = (phaseCounts[p.phase] || 0) + 1;
        });
        const phaseStr = Object.entries(phaseCounts).map(([k,v]) => `${k}:${v}`).join(', ');
        console.log(`üé® Particles: ${particles.length} total | ${phaseStr} | zapPhase: ${zapPhase}`);
        console.log(`   üìç Scene rect: left=${sceneRect.left.toFixed(0)}, top=${sceneRect.top.toFixed(0)}`);
        console.log(`   üìç Rendering to fxOverlay (fixed viewport overlay) like fire/snow particles`);
        
        // Log if sand fall is happening
        if (phaseCounts['fall'] > 0) {
          console.log(`   ‚è¨‚è¨‚è¨ SANDFALL ACTIVE: ${phaseCounts['fall']} particles falling like sand!`);
          // Log sample particle position
          const fallParticle = particles.find(p => p.phase === 'fall');
          if (fallParticle) {
            const vpX = fallParticle.x + sceneRect.left;
            const vpY = fallParticle.y + sceneRect.top;
            console.log(`   üìå Sample fall particle at scene(${fallParticle.x.toFixed(0)}, ${fallParticle.y.toFixed(0)}) -> viewport(${vpX.toFixed(0)}, ${vpY.toFixed(0)}) - color: ${fallParticle.color}, life: ${fallParticle.life.toFixed(2)}`);
          }
        }
      }
      
      particles.forEach((p, idx) => {
        if (p.life <= 0) return;
        
        if (p.phase === 'burst') {
          // Burst outward
          p.x += p.vx * dt * 0.6;
          p.y += p.vy * dt * 0.6;
          p.vy += 300 * dt; // gravity
          p.vx *= 0.97;
          p.vy *= 0.97;
          
          // Transition to funnel after 0.5s
          if (performance.now() - (window.burstStartTime || 0) > 500) {
            p.phase = 'funnel';
            console.log(`üå™Ô∏è ${p.featureName} particle entering funnel phase`);
          }
        } else if (p.phase === 'funnel') {
          // Attract to funnel - SANDSPIEL EFFECT
          const dx = funnelCenterX - p.x;
          const dy = funnelTopY - p.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist > 5) {
            p.vx = dx * 0.08;
            p.vy = dy * 0.08;
            p.x += p.vx;
            p.y += p.vy;
          } else {
            p.phase = 'fall';
            if (!p.fallStartLogged) {
              p.fallStartLogged = true;
              console.log(`‚è¨ ${p.featureName} particle starting sandfall`);
            }
          }
        } else if (p.phase === 'fall') {
          // SANDSPIEL FALL - like sand through hourglass
          p.vy = 3 + Math.random() * 2; // Consistent downward fall
          p.y += p.vy;
          p.x += (Math.random() - 0.5) * 3; // Horizontal drift like sand
          
          // Once past funnel, transition to materialize
          if (p.y > funnelBottomY + 150) {
            p.phase = 'materialize';
            // Target column based on item index - distribute features across columns
            const colIdx = p.itemIndex % 4;
            const rowIdx = Math.floor(p.itemIndex / 4);
            
            // Column positions come from drawBoard
            const targetCol = (window.kanbanColumns && window.kanbanColumns[colIdx]) ? window.kanbanColumns[colIdx] : { x: 270 + colIdx * 230, w: 210 };
            
            // Center 190px card inside column width
            p.targetX = boardRect.left - sceneRect.left + targetCol.x + (targetCol.w - 190) / 2;
            // Start at y:360 (below 2 placeholder cards at 160 and 260), add 110px per row
            p.targetY = boardTopY + 360 + rowIdx * 110;
            
            if (!p.targetSet) {
              p.targetSet = true;
              console.log(`üéØ ${p.featureName} particle #${idx} targeting column ${colIdx}, row ${rowIdx} at (${p.targetX.toFixed(0)}, ${p.targetY.toFixed(0)})`);
            }
          }
        } else if (p.phase === 'materialize') {
          // Move to target position on board
          const dx = p.targetX - p.x;
          const dy = p.targetY - p.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist > 2) {
            p.x += dx * 0.15;
            p.y += dy * 0.15;
          } else {
            // Particle reached target - materialize card ONCE
            if (!p.materialized) {
              p.materialized = true;
              materializeCard(p);
            }
            // Keep particles alive longer so card stays visible
            p.life -= dt * 0.5; // Much slower decay
          }
        }
        
        // Draw particle - CONVERT SCENE COORDS TO VIEWPORT COORDS like fire/snow particles
        if (p.life > 0) {
          // Convert scene coordinates to viewport coordinates
          const viewportX = p.x + sceneRect.left;
          const viewportY = p.y + sceneRect.top;
          
          fxCtx.fillStyle = p.color;
          fxCtx.globalAlpha = Math.min(1, p.life);
          
          // Larger particles during fall phase for visibility
          const radius = p.phase === 'fall' ? 4 : 3;
          
          // DEBUG: Log particle drawing with more detail
          if (p.phase === 'fall' && Math.random() < 0.01) {
            console.log(`üé® Drawing FALL particle at scene(${p.x.toFixed(0)}, ${p.y.toFixed(0)}) -> viewport(${viewportX.toFixed(0)}, ${viewportY.toFixed(0)}) radius=${radius}px, color=${p.color}, alpha=${fxCtx.globalAlpha.toFixed(2)}, zapPhase=${zapPhase}`);
            console.log(`   Scene offset: ${sceneRect.left.toFixed(0)}, ${sceneRect.top.toFixed(0)}`);
          }
          
          fxCtx.beginPath();
          fxCtx.arc(viewportX, viewportY, radius, 0, Math.PI * 2);
          fxCtx.fill();
          
          // Add glow during fall
          if (p.phase === 'fall') {
            fxCtx.shadowBlur = 8;
            fxCtx.shadowColor = p.color;
            fxCtx.beginPath();
            fxCtx.arc(viewportX, viewportY, radius, 0, Math.PI * 2);
            fxCtx.fill();
            fxCtx.shadowBlur = 0;
          }
        }
      });
      
      fxCtx.globalAlpha = 1;
      
      // DEBUG: Confirm we finished drawing
      if (Math.random() < 0.01) {
        const fallCount = particles.filter(p => p.phase === 'fall').length;
        console.log(`‚úÖ updateParticles END: Drew ${particles.length} particles (${fallCount} in fall phase) to fxOverlay, zapPhase=${zapPhase}`);
      }
      
      // Remove dead particles
      particles = particles.filter(p => p.life > 0);
      
      // Only end when ALL tiles have converted AND all cards have materialized
      if (zapPhase === 2 && tilesConvertedToParticles === TOTAL_FEATURES && cardsFullyMaterialized === TOTAL_FEATURES) {
        if (particles.length === 0) {
          zapPhase = 3;
          console.log(`‚úÖ SEQUENCE COMPLETE: ${tilesConvertedToParticles}/${TOTAL_FEATURES} tiles converted, ${cardsFullyMaterialized}/${TOTAL_FEATURES} cards materialized`);
          setTimeout(() => {
            // In bonus mode, the glitch collapse will handle the end sequence
            // In normal mode, reveal the final board
            if (!isBonusMode) {
              revealFinalBoard();
            } else {
              console.log('üíÄ Bonus mode: Glitch collapse sequence in progress...');
            }
          }, 1000);
        }
      }
    }
    
    function materializeCard(particle) {
      // Check if card already created for this feature
      const existing = materializingCards.find(c => c.feature === particle.featureName);
      if (existing) {
        console.log(`‚ö†Ô∏è Card for ${particle.featureName} already exists, skipping`);
        return;
      }
      
      cardsFullyMaterialized++;
      console.log(`‚ú®‚ú®‚ú® MATERIALIZING CARD ${cardsFullyMaterialized}/${TOTAL_FEATURES}: ${particle.featureName} (Priority ${particle.priority})`);
      
      // In bonus mode, apply glitch effect to board when materializing
      if (isBonusMode && cardsFullyMaterialized === 1) {
        const assignaBoard = document.getElementById('assignaBoard');
        assignaBoard.classList.add('glitch');
        console.log('üíÄ GLITCH ACTIVATED!');
        
        // Start glitch sequence after all cards are materialized (reduced delay)
        const glitchDuration = TOTAL_FEATURES * 200; // Reduced from 600ms to 200ms per feature
        setTimeout(() => {
          if (cardsFullyMaterialized === TOTAL_FEATURES) {
            startGlitchCollapse();
          }
        }, glitchDuration);
      }
      
      const scene = document.getElementById('scene');
      const card = document.createElement('div');
      card.className = 'materializing-card';
      card.style.position = 'absolute';
      card.style.borderRadius = '10px';
      card.style.width = '190px';  // Fit within 220px column (with margins)
      card.style.minHeight = '140px';  // Increased for site layout
      card.style.boxShadow = '0 4px 12px rgba(0,0,0,0.3)';
      card.style.zIndex = '100'; // Above everything
      card.style.overflow = 'hidden';
      
      // Animation that stays visible
      card.style.opacity = '0';
      card.style.transform = 'scale(0.5)';
      card.style.transition = 'opacity 0.6s ease-out, transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1)';
      
      // Try to use childhood site layout
      const siteLayout = generateChildhoodSiteLayout(particle.featureName);
      
      if (siteLayout) {
        // Use childhood site visual
        card.innerHTML = siteLayout;
        card.style.padding = '0';
        card.style.border = '2px solid rgba(255,255,255,0.3)';
        
        // Add priority badge overlay
        const priorityBadge = document.createElement('div');
        priorityBadge.textContent = priorityColors[particle.priority].label;
        priorityBadge.style.position = 'absolute';
        priorityBadge.style.top = '4px';
        priorityBadge.style.right = '4px';
        priorityBadge.style.background = priorityColors[particle.priority].bg;
        priorityBadge.style.color = '#fff';
        priorityBadge.style.padding = '3px 6px';
        priorityBadge.style.borderRadius = '4px';
        priorityBadge.style.fontSize = '9px';
        priorityBadge.style.fontWeight = 'bold';
        priorityBadge.style.zIndex = '10';
        priorityBadge.style.boxShadow = '0 2px 4px rgba(0,0,0,0.3)';
        card.appendChild(priorityBadge);
        
        // Apply SaaS glitch if applicable
        if (isSaaSorProductivity(particle.featureName)) {
          card.classList.add('saas-glitch');
        }
      } else {
        // Fallback to text-based card
        card.style.background = '#2a2a2a';
        card.style.border = '2px solid #444';
        card.style.padding = '12px';
        
        const title = document.createElement('div');
        title.className = 'title';
        title.textContent = isBonusMode ? particle.featureName : String(particle.featureName).toUpperCase();
        title.style.color = '#fff';
        title.style.fontSize = '13px';
        title.style.fontWeight = 'bold';
        title.style.marginBottom = '8px';
        title.style.wordWrap = 'break-word';
        card.appendChild(title);
        
        const priority = document.createElement('div');
        priority.className = 'priority';
        priority.textContent = priorityColors[particle.priority].label;
        priority.style.background = priorityColors[particle.priority].bg;
        priority.style.color = '#fff';
        priority.style.padding = '4px 8px';
        priority.style.borderRadius = '4px';
        priority.style.fontSize = '11px';
        priority.style.display = 'inline-block';
        card.appendChild(priority);
      }
      
      card.style.left = `${particle.targetX}px`;
      card.style.top = `${particle.targetY}px`;
      
      scene.appendChild(card);
      
      // Trigger animation after a frame
      requestAnimationFrame(() => {
        card.style.opacity = '1';
        card.style.transform = 'scale(1)';
      });
      
      materializingCards.push({ el: card, feature: particle.featureName });
      
      console.log(`üìã Materialized: ${cardsFullyMaterialized}/${TOTAL_FEATURES} cards | Card stays at (${particle.targetX}, ${particle.targetY})`);
    }
    
    function startBoardPan() {
      const scene = document.getElementById('scene');
      const viewport = document.getElementById('viewport');
      const vw = viewport.clientWidth;
      const vh = viewport.clientHeight;
      
      // Make board visible
      assignaBoard.classList.add('visible');
      
      // Pan to show both intake and board
      const boardCenterX = intakeCenterX;
      const boardCenterY = intakeCenterY + 400;
      
      const targetX = vw / 2 - boardCenterX;
      const targetY = vh / 2 - boardCenterY;
      
      scene.style.transition = 'transform 2.0s cubic-bezier(0.23, 1, 0.32, 1)';
      scene.style.transform = `translate(${targetX}px, ${targetY}px)`;
      
      console.log(`üìπ Panning to board at (${boardCenterX}, ${boardCenterY})`);
    }
    
    function startGlitchCollapse() {
      console.log('üí• STARTING GLITCH COLLAPSE SEQUENCE');
      const assignaBoard = document.getElementById('assignaBoard');
      
      // Phase 1: Remove basic glitch, add glitch lines
      assignaBoard.classList.remove('glitch');
      assignaBoard.classList.add('glitch-lines');
      
      // Phase 2: Update board with new column titles (all caps)
      window.glitchingColumnTitles = [
        { title: 'YOU KNOW WHAT TO DO', color: '#E85D75' },
        { title: 'ALWAYS IN PROGRESS', color: '#F39C12' },
        { title: 'RENEW', color: '#9B59B6' },
        { title: 'NEVER DONE', color: '#27AE60' }
      ];
      drawBoard(); // Redraw with new titles
      console.log('üìù Column titles glitched!');
      
      // Phase 3: After 2 seconds, collapse and free butterflies
      setTimeout(() => {
        assignaBoard.classList.remove('glitch-lines');
        assignaBoard.classList.add('collapse');
        console.log('üí´ BOARD COLLAPSING!');
        
        // Free all concepts as butterflies!
        setTimeout(() => {
          freeButterflies();
        }, 500); // Start freeing as collapse begins
      }, 2000);
    }
    
    // Track butterflies with camera
    let butterflyTrackingActive = false;
    let butterflyContainers = [];
    
    function freeButterflies() {
      console.log('ü¶ãü¶ãü¶ã FREEING CONCEPTS AS BUTTERFLIES!');
      const scene = document.getElementById('scene');
      
      if (!materializingCards || materializingCards.length === 0) {
        console.error('‚ùå No materializing cards found!');
        setTimeout(() => window.location.href = '../../speed.html', 2000);
        return;
      }
      
      const totalButterflies = materializingCards.length;
      console.log(`Creating ${totalButterflies} butterflies`);
      
      // Group cards into clusters of 4
      const clusters = [];
      for (let i = 0; i < materializingCards.length; i += 4) {
        clusters.push(materializingCards.slice(i, i + 4));
      }
      
      console.log(`üì¶ Created ${clusters.length} butterfly clusters`);
      
      // Enable butterfly tracking
      butterflyTrackingActive = true;
      butterflyContainers = [];
      
      // Create clustered butterflies
      clusters.forEach((cluster, clusterIdx) => {
        const clusterCards = cluster.filter(c => c.el && c.el.parentNode);
        if (clusterCards.length === 0) return;
        
        // Calculate cluster center
        const sceneRect = scene.getBoundingClientRect();
        let centerX = 0, centerY = 0;
        clusterCards.forEach(card => {
          const cardRect = card.el.getBoundingClientRect();
          centerX += cardRect.left - sceneRect.left + cardRect.width / 2;
          centerY += cardRect.top - sceneRect.top + cardRect.height / 2;
        });
        centerX /= clusterCards.length;
        centerY /= clusterCards.length;
        
        console.log(`ü¶ã Cluster ${clusterIdx + 1}: ${clusterCards.length} cards at (${centerX.toFixed(0)}, ${centerY.toFixed(0)})`);
        
        // Create butterfly for this cluster
        const butterfly = createClusteredButterfly(scene, centerX, centerY, clusterCards, clusterIdx);
        butterflyContainers.push(butterfly);
        
        // Hide original cards without transform (to prevent snapping)
        clusterCards.forEach(card => {
          setTimeout(() => {
            if (card.el && card.el.parentNode) {
              card.el.style.transition = 'opacity 0.5s';
              card.el.style.opacity = '0';
              setTimeout(() => {
                if (card.el && card.el.parentNode) {
                  card.el.remove();
                }
              }, 500);
            }
          }, clusterIdx * 200);
        });
      });
      
      console.log(`‚úÖ Created ${butterflyContainers.length} butterfly clusters`);
      
      // Clear the array
      setTimeout(() => {
        materializingCards.length = 0;
      }, 2000);

      // Do not move the canvas; butterflies animate in place
      // Start graveyard sequence shortly after butterflies launch
      setTimeout(() => {
        try {
          showGraveyard();
        } catch (e) {
          console.error('Failed to start graveyard sequence:', e);
        }
      }, 3000);
    }
    
    function createClusteredButterfly(parent, startX, startY, cards, clusterIdx) {
      // Create container for butterfly cluster
      const container = document.createElement('div');
      container.className = 'butterfly-cluster';
      container.style.position = 'absolute';
      container.style.left = `${startX}px`;
      container.style.top = `${startY}px`;
      container.style.zIndex = '200';
      container.style.transformOrigin = 'center center';
      
      // Create 4 cards forming a clover (wings)
      const wings = [];
      const positions = [
        {x: -25, y: -25, rotation: 0},   // top-left
        {x: 25, y: -25, rotation: 0},    // top-right
        {x: -25, y: 25, rotation: 0},    // bottom-left
        {x: 25, y: 25, rotation: 0}      // bottom-right
      ];
      
      cards.slice(0, 4).forEach((card, i) => {
        const wing = document.createElement('div');
        wing.className = 'butterfly-wing-card';
        wing.style.position = 'absolute';
        wing.style.width = '50px';
        wing.style.height = '50px';
        wing.style.background = card.el ? getComputedStyle(card.el).background : '#2a2a2a';
        wing.style.border = '2px solid #444';
        wing.style.borderRadius = '8px';
        wing.style.left = `${positions[i].x}px`;
        wing.style.top = `${positions[i].y}px`;
        wing.style.transform = `translate(-50%, -50%) rotate(${positions[i].rotation}deg)`;
        wing.style.transition = 'all 0.5s ease-out';
        wing.textContent = card.feature ? card.feature.name : '';
        wing.style.fontSize = '10px';
        wing.style.color = '#fff';
        wing.style.display = 'flex';
        wing.style.alignItems = 'center';
        wing.style.justifyContent = 'center';
        wing.style.textAlign = 'center';
        wing.style.padding = '4px';
        wing.style.overflow = 'hidden';
        wing.style.wordBreak = 'break-word';
        container.appendChild(wing);
        wings.push(wing);
      });
      
      parent.appendChild(container);
      
      // Phase 1: Shake (after delay)
      setTimeout(() => {
        wings.forEach((wing, i) => {
          wing.style.animation = `shake 0.5s ease-in-out infinite`;
        });
      }, 500 + clusterIdx * 200);
      
      // Phase 2: Morph into butterfly emoji
      setTimeout(() => {
        // Clear wings
        wings.forEach(wing => wing.remove());
        
        // Replace with butterfly emoji
        container.innerHTML = '';
        container.style.fontSize = '4rem';
        container.textContent = 'ü¶ã';
        container.dataset.flying = 'true';
        
        // Fly away animation
        setTimeout(() => {
          const randomX = (Math.random() - 0.5) * 800;
          const randomY = -500 - Math.random() * 300;
          container.style.transition = 'all 3s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
          container.style.transform = `translate(${randomX}px, ${randomY}px) scale(0.5)`;
          container.style.opacity = '0';
        }, 100);
      }, 2000 + clusterIdx * 200);
      
      return container;
    }
    
    function trackButterfliesUpward() {
      console.log('üìπ Tracking butterflies upward...');
      const scene = document.getElementById('scene');
      const viewport = document.getElementById('viewport');
      const vw = viewport.clientWidth;
      const vh = viewport.clientHeight;
      
      // Calculate average butterfly position
      let avgY = 0;
      let count = 0;
      butterflyContainers.forEach(b => {
        if (b.parentNode && b.dataset.flying === 'true') {
          const rect = b.getBoundingClientRect();
          avgY += rect.top;
          count++;
        }
      });
      
      if (count === 0) {
        showGraveyard();
        return;
      }
      
      avgY /= count;
      const sceneRect = scene.getBoundingClientRect();
      
      // Pan camera upward to follow butterflies
      const targetY = vh / 2 - (-sceneRect.top + avgY) - 500; // Follow upward
      
      scene.style.transition = 'transform 3s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
      scene.style.transform = `translate(0px, ${targetY}px)`;
      
      // After following up, plummet down to graveyard
      setTimeout(() => {
        plummetToGraveyard();
      }, 3500);
    }
    
    function plummetToGraveyard() {
      console.log('üíÄ Plummeting to graveyard...');
      const scene = document.getElementById('scene');
      const viewport = document.getElementById('viewport');
      const vw = viewport.clientWidth;
      const vh = viewport.clientHeight;
      
      // Rapid descent to graveyard (far below)
      scene.style.transition = 'transform 1.5s cubic-bezier(0.6, 0.04, 0.98, 0.335)';
      scene.style.transform = `translate(0px, ${-8000}px)`; // Plummet way down
      
      setTimeout(() => {
        showGraveyard();
      }, 1500);
    }
    
    function startTypingAnimation() {
      const phrase = "AT LEAST DREAMS ALWAYS DIE IN THEIR SLEEP. ";
      
      function typeNextChar() {
        if (window.typingCharIndex < phrase.length) {
          window.typingText += phrase[window.typingCharIndex];
          window.typingCharIndex++;
        } else {
          // Restart phrase
          window.typingCharIndex = 0;
        }
        
        // Continue typing
        const typingSpeed = 30 + Math.random() * 50;
        setTimeout(typeNextChar, typingSpeed);
      }
      
      // Start typing immediately
      typeNextChar();
    }
    
    function drawTypingText(ctx, vw, vh, plummetY) {
      if (!window.typingText) return;
      
      // Text styling
      ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
      ctx.font = '14px monospace';
      ctx.textBaseline = 'top';
      
      // Word wrap the text with height constraint AND submit button avoidance
      const padding = 20;
      const maxWidth = vw - padding * 2;
      const lineHeight = 21;
      const maxHeight = vh - padding * 2; // Prevent going off-screen
      const words = window.typingText.split(' ');
      let line = '';
      let y = padding;
      const lines = [];
      
      // Build all lines first
      for (let i = 0; i < words.length; i++) {
        const testLine = line + words[i] + ' ';
        const metrics = ctx.measureText(testLine);
        
        if (metrics.width > maxWidth && line !== '') {
          lines.push({ text: line, y });
          line = words[i] + ' ';
          y += lineHeight;
        } else {
          line = testLine;
        }
      }
      // Add the last line
      if (line.trim()) {
        lines.push({ text: line, y });
      }
      
      // Draw only lines that fit on screen AND avoid submit button area
      const submitButtonTop = plummetY ? plummetY - 30 : -1000; // 30px buffer above button
      const submitButtonBottom = plummetY ? plummetY + 60 : -1000; // 60px buffer below button
      
      lines.forEach(lineObj => {
        const lineBottom = lineObj.y + lineHeight;
        const lineClearOfButton = (lineBottom < submitButtonTop) || (lineObj.y > submitButtonBottom);
        const lineInScreen = lineObj.y + lineHeight <= maxHeight && lineObj.y >= 0;
        
        if (lineInScreen && lineClearOfButton) {
          ctx.fillText(lineObj.text, padding, lineObj.y);
        }
      });
      
      // Add continuation indicator if text is cut off (but not covered by button)
      if (lines.length > 0) {
        const lastLine = lines[lines.length - 1];
        if (lastLine.y + lineHeight > maxHeight) {
          const indicatorY = maxHeight - lineHeight;
          if (indicatorY < submitButtonTop || indicatorY > submitButtonBottom) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.fillText('...', padding, indicatorY);
          }
        }
      }
    }
    
    function showGraveyard() {
      console.log('ü™¶ Showing pixelated graveyard...');
      const scene = document.getElementById('scene');
      const viewport = document.getElementById('viewport');
      const vw = viewport.clientWidth;
      const vh = viewport.clientHeight;
      
      // Do not clear the scene; overlay the graveyard on the viewport so
      // its position remains centered regardless of scene transforms
      
      graveyardActive = true;

      // Create a fixed overlay attached to viewport to ignore scene transforms
      let overlay = document.getElementById('graveyardOverlay');
      if (!overlay) {
        overlay = document.createElement('div');
        overlay.id = 'graveyardOverlay';
        overlay.style.position = 'fixed';
        overlay.style.inset = '0';
        overlay.style.zIndex = '2100'; // Above bonusButton (z-index: 2000) and all other elements
        overlay.style.pointerEvents = 'none';
        viewport.appendChild(overlay);
      }

      // Create graveyard canvas inside overlay
      const graveyardCanvas = document.createElement('canvas');
      graveyardCanvas.width = vw;
      graveyardCanvas.height = vh;
      graveyardCanvas.setAttribute('willReadFrequently', 'true');
      graveyardCanvas.style.position = 'absolute';
      graveyardCanvas.style.left = '0';
      graveyardCanvas.style.top = '0';
      graveyardCanvas.style.pointerEvents = 'none'; // Don't block interactions
      overlay.appendChild(graveyardCanvas);
      
      const ctx = graveyardCanvas.getContext('2d', { alpha: true }); // Enable transparency
      
      // Draw pixelated grass/ground (full black background)
      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, vw, vh);
      
      // Draw random grass pixels
      for (let i = 0; i < 200; i++) {
        ctx.fillStyle = Math.random() > 0.5 ? '#2a2a2a' : '#3a3a3a';
        const size = 8 + Math.random() * 8;
        ctx.fillRect(Math.random() * vw, vh - 200 + Math.random() * 200, size, size);
      }
      
      // Animate tombstone rising from ground with 3D effect
      const tombX = vw / 2 - 150;
      const safeTop = 40; // avoid clipping at top
      const tombY = Math.max(safeTop + 80, vh / 2 - 200);
      const tombWidth = 300;
      const tombHeight = 400;
      
      let riseFrame = 0;
      const maxRiseFrames = 30; // 0.5 second rise - faster!
      
      // Rose emoji falling
      let roseY = -120;
      let roseVY = 0;
      const roseX = tombX + tombWidth / 2;
      const groundYGlobal = vh / 2 + 200;
      const roseHoverY = Math.max(120, vh * 0.35);
      const roseTargetY = groundYGlobal + 20; // Land just above the floor line

      // Intro: let the rose fall to center and hover before tombstone starts
      function animateRoseIntro() {
        // Clear BG
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, vw, vh);
        // Draw grass FIRST
        for (let i = 0; i < 200; i++) {
          ctx.fillStyle = Math.random() > 0.5 ? '#2a2a2a' : '#3a3a3a';
          const size = 8 + Math.random() * 8;
          ctx.fillRect(Math.random() * vw, vh - 200 + Math.random() * 200, size, size);
        }
        // Draw typing text ON TOP of grass
        if (isBonusMode) drawTypingText(ctx, vw, vh, roseY);

        // Fall towards hover height
        if (roseY < roseHoverY - 2) {
          roseVY += 0.9;
          roseY += roseVY;
        } else {
          // Hover for 2 seconds, then start tombstone and exit intro
          let hoverCount = 0;
          const hover = () => {
            // Subtle float
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, vw, vh);
            // Draw grass FIRST
            for (let i = 0; i < 200; i++) {
              ctx.fillStyle = Math.random() > 0.5 ? '#2a2a2a' : '#3a3a3a';
              const size = 8 + Math.random() * 8;
              ctx.fillRect(Math.random() * vw, vh - 200 + Math.random() * 200, size, size);
            }
            // Draw typing text ON TOP
            if (isBonusMode) drawTypingText(ctx, vw, vh, roseY);
            drawRose(ctx);
            hoverCount++;
            if (hoverCount < 120) {
              requestAnimationFrame(hover);
            } else {
              // Start tombstone sequence
              animateTombstoneRise();
            }
          };
          drawRose(ctx);
          requestAnimationFrame(hover);
          return;
        }

        drawRose(ctx);
        requestAnimationFrame(animateRoseIntro);
      }
      
      function animateTombstoneRise() {
        riseFrame++;
        const progress = riseFrame / maxRiseFrames;
        const easeProgress = 1 - Math.pow(1 - progress, 3); // Ease out cubic
        
        // Clear and redraw ground
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, vw, vh);
        
        // Draw grass FIRST
        for (let i = 0; i < 200; i++) {
          ctx.fillStyle = Math.random() > 0.5 ? '#2a2a2a' : '#3a3a3a';
          const size = 8 + Math.random() * 8;
          ctx.fillRect(Math.random() * vw, vh - 200 + Math.random() * 200, size, size);
        }
        
        // Calculate 3D rise effect
        const currentHeight = tombHeight * easeProgress;
        const groundY = groundYGlobal; // Ground level aligned with rose target
        const currentY = groundY - currentHeight;
        
        // 3D perspective scaling (larger as it rises)
        const scale = 0.7 + (easeProgress * 0.3); // Scale from 0.7 to 1.0
        const scaledWidth = tombWidth * scale;
        const scaledX = tombX + (tombWidth - scaledWidth) / 2;
        
        // Draw tombstone shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
        ctx.fillRect(scaledX - 10, groundY, scaledWidth + 20, 20);
        
        // Draw tombstone with depth layers
        const depthLayers = 3;
        for (let d = 0; d < depthLayers; d++) {
          const layerOffset = d * 4;
          const brightness = 50 + d * 10;
          ctx.fillStyle = `rgb(${brightness}, ${brightness}, ${brightness})`;
          ctx.fillRect(scaledX + layerOffset, currentY + layerOffset, scaledWidth, currentHeight);
        }
        
        // Front face
        ctx.fillStyle = '#4a4a4a';
        ctx.fillRect(scaledX, currentY, scaledWidth, currentHeight);
        
        // Rounded top (pixelated) - only if risen enough, ensure not clipped
        if (currentHeight > 60) {
          ctx.fillStyle = '#4a4a4a';
          const arcRadius = scaledWidth / 2;
          for (let x = 0; x <= scaledWidth; x += 4 * scale) {
            const relX = x - scaledWidth / 2;
            const arcY = Math.sqrt(Math.max(0, Math.pow(arcRadius, 2) - Math.pow(relX, 2)));
            if (!isNaN(arcY) && arcY > 0) {
              // Draw a column of pixels to fill the arc
              for (let py = 0; py < arcY * scale; py += 4 * scale) {
                const yPix = currentY - py + 60;
                if (yPix > safeTop) ctx.fillRect(scaledX + x, yPix, 4 * scale, 4 * scale);
              }
            }
          }
        }
        
        // Build skull towers as tomb rises (first time only), with rise progress
        if (!window.skullsBuilt) window.buildSkullTowers(vw, vh, groundYGlobal + 200, easeProgress);

        // Gradually lift pre-built skulls to match rise
        if (window.skullsBuilt) {
          window.skullTowers.forEach(s => {
            // target y without offset
            const targetY = s.y - (1 - easeProgress) * 140;
            s.y = targetY;
          });
        }

        // Text appears as it rises - draw from bottom of tombstone upward to avoid clipping
        if (progress > 0.5) {
          const textOpacity = (progress - 0.5) * 2;
          ctx.globalAlpha = textOpacity;
          ctx.fillStyle = '#aaa';
          ctx.font = `bold ${24 * scale}px monospace`;
          ctx.textAlign = 'center';
          // Position text in the middle section of the tombstone, well below the rounded top
          const textStartY = currentY + currentHeight * 0.35; // Start at 35% down from top
          const lineHeight = 40 * scale;
          // Only draw text if it's safely below the top boundary
          if (textStartY > safeTop + 30) {
            ctx.fillText('HERE LIES', scaledX + scaledWidth / 2, textStartY);
            ctx.fillText('SQUIDWARDS', scaledX + scaledWidth / 2, textStartY + lineHeight);
            ctx.fillText('HOPES AND', scaledX + scaledWidth / 2, textStartY + lineHeight * 2);
            ctx.fillText('DREAMS', scaledX + scaledWidth / 2, textStartY + lineHeight * 3);
          }
          ctx.globalAlpha = 1;
        }
        
        // Rose emoji falling with proper settling
        if (roseY < roseTargetY || Math.abs(roseVY) > 0.1) {
          roseVY += 0.8; // Gravity
          roseY += roseVY;
          
          // Bounce and settle on ground
          if (roseY >= roseTargetY) {
            roseY = roseTargetY;
            roseVY *= -0.3; // Bounce
            // Stop if bounce is too small
            if (Math.abs(roseVY) < 0.5) {
              roseVY = 0;
              roseY = roseTargetY; // Force to ground level
            }
          }
        } else {
          // Ensure settled flowers stay on ground
          roseY = roseTargetY;
          roseVY = 0;
        }
        
        // Draw bouquet of flowers (always draw once settled)
        ctx.font = '60px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Main rose (center)
        ctx.fillText('üåπ', roseX, roseY);
        
        // Additional flowers at angles for bouquet effect
        ctx.font = '50px Arial';
        ctx.save();
        ctx.translate(roseX - 40, roseY + 15);
        ctx.rotate(-0.3);
        ctx.fillText('üå∏', 0, 0);
        ctx.restore();
        
        ctx.font = '48px Arial';
        ctx.save();
        ctx.translate(roseX + 45, roseY + 10);
        ctx.rotate(0.25);
        ctx.fillText('üå∫', 0, 0);
        ctx.restore();
        
        ctx.font = '52px Arial';
        ctx.save();
        ctx.translate(roseX - 15, roseY - 35);
        ctx.rotate(-0.15);
        ctx.fillText('üå∑', 0, 0);
        ctx.restore();
        
        ctx.font = '46px Arial';
        ctx.save();
        ctx.translate(roseX + 30, roseY - 30);
        ctx.rotate(0.2);
        ctx.fillText('üåº', 0, 0);
        ctx.restore();
        
        // Draw typing text ON TOP of everything
        if (isBonusMode) {
          drawTypingText(ctx, vw, vh);
        }
        
        if (riseFrame < maxRiseFrames) {
          requestAnimationFrame(animateTombstoneRise);
        } else {
          // Store final tombstone and rose positions
          window.graveyardTombstone = {
            x: tombX,
            y: tombY,
            width: tombWidth,
            height: tombHeight
          };
          
          window.graveyardRose = {
            x: roseX,
            y: roseY
          };
          
          // Capture pixels for burst
          captureTombstonePixels(ctx, tombX, tombY, tombWidth, tombHeight);
          
          // Pause before burst
          setTimeout(() => {
            burstTombstoneToCloud(ctx, vw, vh);
          }, 1500);
        }
      }
      
      // Start with rose-only intro, then the tombstone rise will begin
      animateRoseIntro();
    }
    
    function drawRose(ctx) {
      if (window.graveyardRose) {
        const roseX = window.graveyardRose.x;
        const roseY = window.graveyardRose.y;
        
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Main rose (center)
        ctx.font = '60px Arial';
        ctx.fillText('üåπ', roseX, roseY);
        
        // Additional flowers at angles for bouquet effect
        ctx.font = '50px Arial';
        ctx.save();
        ctx.translate(roseX - 40, roseY + 15);
        ctx.rotate(-0.3);
        ctx.fillText('üå∏', 0, 0);
        ctx.restore();
        
        ctx.font = '48px Arial';
        ctx.save();
        ctx.translate(roseX + 45, roseY + 10);
        ctx.rotate(0.25);
        ctx.fillText('üå∫', 0, 0);
        ctx.restore();
        
        ctx.font = '52px Arial';
        ctx.save();
        ctx.translate(roseX - 15, roseY - 35);
        ctx.rotate(-0.15);
        ctx.fillText('üå∑', 0, 0);
        ctx.restore();
        
        ctx.font = '46px Arial';
        ctx.save();
        ctx.translate(roseX + 30, roseY - 30);
        ctx.rotate(0.2);
        ctx.fillText('üåº', 0, 0);
        ctx.restore();
      }
    }
    
    function captureTombstonePixels(ctx, tombX, tombY, tombWidth, tombHeight) {
      window.graveyardPixels = [];
      const pixelSize = 8;
      for (let y = tombY - 60; y < tombY + tombHeight; y += pixelSize) {
        for (let x = tombX; x < tombX + tombWidth; x += pixelSize) {
          const imgData = ctx.getImageData(x, y, 1, 1).data;
          if (imgData[3] > 0) { // Non-transparent
            window.graveyardPixels.push({
              x: x,
              y: y,
              vx: 0,
              vy: 0,
              color: `rgb(${imgData[0]}, ${imgData[1]}, ${imgData[2]})`,
              size: pixelSize,
              phase: 'burst'
            });
          }
        }
      }
      console.log(`ü™¶ Captured ${window.graveyardPixels.length} tombstone pixels`);
    }
    
    function burstTombstoneToCloud(ctx, vw, vh) {
      console.log('üí• Bursting tombstone into cloud...');
      
      // Give all pixels explosive velocity
      const centerX = vw / 2;
      const centerY = vh / 2;
      window.graveyardPixels.forEach(p => {
        const angle = Math.atan2(p.y - centerY, p.x - centerX);
        const speed = 5 + Math.random() * 10;
        p.vx = Math.cos(angle) * speed;
        p.vy = Math.sin(angle) * speed - 3; // Slight upward bias
        p.phase = 'cloud';
      });
      
      let animationFrame = 0;
      const maxCloudFrames = 60; // 1 second cloud expansion
      
      function animateCloud() {
        animationFrame++;
        
        // Clear canvas
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, vw, vh);
        
        // Redraw grass FIRST
        for (let i = 0; i < 200; i++) {
          ctx.fillStyle = Math.random() > 0.5 ? '#2a2a2a' : '#3a3a3a';
          const size = 8 + Math.random() * 8;
          ctx.fillRect(Math.random() * vw, vh - 200 + Math.random() * 200, size, size);
        }
        
        // Update and draw pixels in cloud
        window.graveyardPixels.forEach(p => {
          p.x += p.vx;
          p.y += p.vy;
          p.vx *= 0.98; // Friction
          p.vy *= 0.98;
          
          // Draw pixel with slight glow
          ctx.fillStyle = p.color;
          ctx.fillRect(p.x, p.y, p.size, p.size);
          ctx.globalAlpha = 0.3;
          ctx.fillRect(p.x - 2, p.y - 2, p.size + 4, p.size + 4);
          ctx.globalAlpha = 1;
        });
        
        // Draw rose on top
        drawRose(ctx);
        
        // Draw typing text ON TOP of everything
        if (isBonusMode) {
          drawTypingText(ctx, vw, vh);
        }
        
        if (animationFrame < maxCloudFrames) {
          requestAnimationFrame(animateCloud);
        } else {
          // Transition to keyboard clustering
          setTimeout(() => {
            clusterIntoKeyboard(ctx, vw, vh);
          }, 300);
        }
      }
      
      animateCloud();
    }
    
    function clusterIntoKeyboard(ctx, vw, vh) {
      console.log('‚å®Ô∏è Clustering pixels into keyboard...');
      
      // Define keyboard layout (60% layout with spacebar)
      const keyRows = [
        ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'],
        ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L'],
        ['Z', 'X', 'C', 'V', 'B', 'N', 'M']
      ];
      
      const keyWidth = 60;
      const keyHeight = 60;
      const keySpacing = 10;
      const startX = vw / 2 - (keyRows[0].length * (keyWidth + keySpacing)) / 2;
      const startY = vh / 2 - 100;
      
      // Calculate keyboard plate dimensions
      const platePadding = 20;
      const plateWidth = keyRows[0].length * (keyWidth + keySpacing) + platePadding * 2;
      const plateHeight = keyRows.length * (keyHeight + keySpacing) + 90 + platePadding * 2; // Extra for spacebar
      const plateX = startX - platePadding;
      const plateY = startY - platePadding;
      
      // Calculate key positions and centers
      const keyPositions = [];
      keyRows.forEach((row, rowIdx) => {
        const rowOffset = rowIdx * 30; // Stagger rows
        row.forEach((key, colIdx) => {
          keyPositions.push({
            x: startX + rowOffset + colIdx * (keyWidth + keySpacing),
            y: startY + rowIdx * (keyHeight + keySpacing),
            centerX: startX + rowOffset + colIdx * (keyWidth + keySpacing) + keyWidth / 2,
            centerY: startY + rowIdx * (keyHeight + keySpacing) + keyHeight / 2,
            width: keyWidth,
            height: keyHeight,
            label: key,
            pixels: []
          });
        });
      });
      
      // Add spacebar
      const spacebarWidth = keyWidth * 5;
      const spacebarY = startY + keyRows.length * (keyHeight + keySpacing) + 10;
      const spacebarX = vw / 2 - spacebarWidth / 2;
      keyPositions.push({
        x: spacebarX,
        y: spacebarY,
        centerX: vw / 2,
        centerY: spacebarY + keyHeight / 2,
        width: spacebarWidth,
        height: keyHeight,
        label: 'SPACE',
        pixels: []
      });
      
      // Evenly distribute pixels to keys
      window.graveyardPixels.forEach((pixel, i) => {
        const keyIdx = i % keyPositions.length;
        keyPositions[keyIdx].pixels.push(pixel);
      });
      
      // Assign target positions within each key
      keyPositions.forEach(key => {
        const pixelsPerRow = Math.ceil(Math.sqrt(key.pixels.length));
        const pixelSize = Math.min(6, Math.floor(key.width / pixelsPerRow));
        
        key.pixels.forEach((pixel, i) => {
          const col = i % pixelsPerRow;
          const row = Math.floor(i / pixelsPerRow);
          pixel.targetX = key.x + col * pixelSize + pixelSize / 2;
          pixel.targetY = key.y + row * pixelSize + pixelSize / 2;
          pixel.keyLabel = key.label;
          pixel.keyCenterX = key.centerX;
          pixel.keyCenterY = key.centerY;
          pixel.phase = 'clustering';
        });
      });
      
      console.log(`‚å®Ô∏è Distributed ${window.graveyardPixels.length} pixels across ${keyPositions.length} keys`);
      
      let animationFrame = 0;
      const maxClusterFrames = 90; // 1.5 seconds to cluster
      
      function animateKeyboardCluster() {
        animationFrame++;
        
        // Clear canvas
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, vw, vh);
        
        // Redraw grass FIRST
        for (let i = 0; i < 200; i++) {
          ctx.fillStyle = Math.random() > 0.5 ? '#2a2a2a' : '#3a3a3a';
          const size = 8 + Math.random() * 8;
          ctx.fillRect(Math.random() * vw, vh - 200 + Math.random() * 200, size, size);
        }
        
        // Update and draw pixels clustering
        window.graveyardPixels.forEach(p => {
          if (p.targetX !== undefined) {
            // Smooth magnetic pull to target
            const dx = p.targetX - p.x;
            const dy = p.targetY - p.y;
            p.x += dx * 0.12;
            p.y += dy * 0.12;
          }
          
          ctx.fillStyle = p.color;
          ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
        });
        
        // Draw rose on top
        drawRose(ctx);
        
        // Draw keyboard plate (darker gray background)
        if (animationFrame > 40) {
          const plateOpacity = Math.min(1, (animationFrame - 40) / 20);
          ctx.globalAlpha = plateOpacity;
          ctx.fillStyle = '#3a3a3a';
          ctx.fillRect(plateX, plateY, plateWidth, plateHeight);
          ctx.globalAlpha = 1;
        }
        
        // Draw key labels and backgrounds
        if (animationFrame > 50) {
          const labelOpacity = Math.min(1, (animationFrame - 50) / 20);
          ctx.globalAlpha = labelOpacity;
          
          keyPositions.forEach(key => {
            // Draw key background (slightly lighter than plate)
            ctx.fillStyle = '#4a4a4a';
            ctx.fillRect(key.x, key.y, key.width, key.height);
            
            // Draw key label
            ctx.fillStyle = '#fff';
            ctx.font = key.label === 'SPACE' ? 'bold 16px monospace' : 'bold 20px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
            ctx.shadowBlur = 4;
            ctx.fillText(key.label, key.centerX, key.centerY);
          });
          
          ctx.shadowBlur = 0;
          ctx.globalAlpha = 1;
        }
        
        // Draw typing text ON TOP of everything
        if (isBonusMode) {
          drawTypingText(ctx, vw, vh);
        }
        
        if (animationFrame < maxClusterFrames) {
          requestAnimationFrame(animateKeyboardCluster);
        } else {
          // Hold keyboard and highlight sequence
          setTimeout(() => {
            highlightKeySequence(ctx, vw, vh, keyPositions, plateX, plateY, plateWidth, plateHeight);
          }, 1000);
        }
      }
      
      animateKeyboardCluster();
    }
    
    function highlightKeySequence(ctx, vw, vh, keyPositions, plateX, plateY, plateWidth, plateHeight) {
      console.log('‚å®Ô∏è Highlighting key sequence...');
      
      // Sequence: Y E S SPACE A N D ?
      const sequence = ['Y', 'E', 'S', 'SPACE', 'A', 'N', 'D', '?'];
      const colors = ['#fff', '#E85D75', '#F39C12', '#9B59B6']; // White, red, yellow, purple
      let sequenceIndex = 0;
      let highlightFrame = 0;
      const framesPerKey = 30; // Hold each key for 0.5s
      const totalSequenceFrames = sequence.length * framesPerKey + 60; // Extra time at end
      
      function animateSequence() {
        highlightFrame++;
        
        // Clear canvas
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, vw, vh);
        
        // Redraw grass FIRST
        for (let i = 0; i < 200; i++) {
          ctx.fillStyle = Math.random() > 0.5 ? '#2a2a2a' : '#3a3a3a';
          const size = 8 + Math.random() * 8;
          ctx.fillRect(Math.random() * vw, vh - 200 + Math.random() * 200, size, size);
        }
        
        // Update and draw pixels
        window.graveyardPixels.forEach(p => {
          ctx.fillStyle = p.color;
          ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
        });
        
        // Draw rose on top
        drawRose(ctx);
        
        // Draw keyboard plate
        ctx.fillStyle = '#3a3a3a';
        ctx.fillRect(plateX, plateY, plateWidth, plateHeight);
        
        // Determine which key to highlight
        const currentKeyIndex = Math.floor(highlightFrame / framesPerKey);
        if (currentKeyIndex < sequence.length) {
          sequenceIndex = currentKeyIndex;
        }
        
        // Draw keys with full background color changes
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        keyPositions.forEach((key, idx) => {
          const isHighlighted = sequenceIndex < sequence.length && 
                                key.label === sequence[sequenceIndex];
          
          if (isHighlighted) {
            // Highlighted key - WHOLE KEY changes color
            const colorIndex = sequenceIndex % colors.length;
            ctx.fillStyle = colors[colorIndex];
            ctx.fillRect(key.x, key.y, key.width, key.height);
            
            // Glow effect around key
            ctx.shadowColor = colors[colorIndex];
            ctx.shadowBlur = 20;
            ctx.fillRect(key.x, key.y, key.width, key.height);
            ctx.shadowBlur = 0;
            
            // Draw label (white on colored background)
            ctx.fillStyle = '#000';
            ctx.font = key.label === 'SPACE' ? 'bold 20px monospace' : 'bold 28px monospace';
            ctx.fillText(key.label, key.centerX, key.centerY);
          } else {
            // Normal key
            ctx.fillStyle = '#4a4a4a';
            ctx.fillRect(key.x, key.y, key.width, key.height);
            
            ctx.fillStyle = '#fff';
            ctx.font = key.label === 'SPACE' ? 'bold 16px monospace' : 'bold 20px monospace';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
            ctx.shadowBlur = 4;
            ctx.fillText(key.label, key.centerX, key.centerY);
            ctx.shadowBlur = 0;
          }
        });
        
        // Draw typing text ON TOP of everything
        if (isBonusMode) {
          drawTypingText(ctx, vw, vh);
        }
        
        if (highlightFrame < totalSequenceFrames) {
          requestAnimationFrame(animateSequence);
        } else {
          setTimeout(() => {
            burstKeysToHourglass(ctx, vw, vh);
          }, 500);
        }
      }
      
      animateSequence();
    }
    
    function burstKeysToHourglass(ctx, vw, vh) {
      console.log('‚è≥ Bursting keys into hourglass...');
      
      // Each pixel bursts from its key center
      window.graveyardPixels.forEach(p => {
        const angle = Math.atan2(p.y - p.keyCenterY, p.x - p.keyCenterX);
        const speed = 8 + Math.random() * 12;
        p.vx = Math.cos(angle) * speed;
        p.vy = Math.sin(angle) * speed - 5; // Upward burst
        p.phase = 'burst2';
        // Change to golden yellow
        p.color = `hsl(${45 + Math.random() * 15}, ${80 + Math.random() * 20}%, ${60 + Math.random() * 20}%)`;
      });
      
      let animationFrame = 0;
      const maxBurstFrames = 60;
      
      function animateBurst() {
        animationFrame++;
        
        // Clear canvas
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, vw, vh);
        
        // Redraw grass FIRST
        for (let i = 0; i < 200; i++) {
          ctx.fillStyle = Math.random() > 0.5 ? '#2a2a2a' : '#3a3a3a';
          const size = 8 + Math.random() * 8;
          ctx.fillRect(Math.random() * vw, vh - 200 + Math.random() * 200, size, size);
        }
        
        // Update burst pixels
        window.graveyardPixels.forEach(p => {
          p.x += p.vx;
          p.y += p.vy;
          p.vx *= 0.97;
          p.vy *= 0.97;
          
          ctx.fillStyle = p.color;
          ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
          
          // Golden glow
          ctx.globalAlpha = 0.5;
          ctx.fillRect(p.x - p.size, p.y - p.size, p.size * 2, p.size * 2);
          ctx.globalAlpha = 1;
        });
        
        // Draw rose on top
        drawRose(ctx);
        
        // Draw typing text ON TOP of everything
        if (isBonusMode) {
          drawTypingText(ctx, vw, vh);
        }
        
        if (animationFrame < maxBurstFrames) {
          requestAnimationFrame(animateBurst);
        } else {
          setTimeout(() => {
            formHourglass(ctx, vw, vh);
          }, 300);
        }
      }
      
      animateBurst();
    }
    
    function formHourglass(ctx, vw, vh) {
      console.log('‚è≥ Forming golden hourglass...');
      
      // Hourglass dimensions
      const hourglassWidth = 180;
      const hourglassHeight = 300;
      const centerX = vw / 2;
      const centerY = vh / 2 - 50;
      
      // Assign pixels to hourglass shape
      let pixelIdx = 0;
      window.graveyardPixels.forEach((p, i) => {
        // Hourglass shape: two triangles meeting at center
        const normalizedY = (i / window.graveyardPixels.length) * hourglassHeight;
        const distFromCenter = Math.abs(normalizedY - hourglassHeight / 2);
        const widthAtY = (distFromCenter / (hourglassHeight / 2)) * (hourglassWidth / 2);
        
        const row = Math.floor(normalizedY / 8);
        const col = (i % Math.floor(widthAtY / 4)) - Math.floor(widthAtY / 8);
        
        p.targetX = centerX + col * 8;
        p.targetY = centerY - hourglassHeight / 2 + normalizedY;
        p.phase = 'hourglass';
      });
      
      let animationFrame = 0;
      const maxHourglassFrames = 90;
      
      function animateHourglass() {
        animationFrame++;
        
        // Clear canvas
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, vw, vh);
        
        // Draw typing text first (in background)
        if (isBonusMode) {
          drawTypingText(ctx, vw, vh);
        }
        
        // Redraw grass
        for (let i = 0; i < 200; i++) {
          ctx.fillStyle = Math.random() > 0.5 ? '#2a2a2a' : '#3a3a3a';
          const size = 8 + Math.random() * 8;
          ctx.fillRect(Math.random() * vw, vh - 200 + Math.random() * 200, size, size);
        }
        
        // Draw complete hourglass frame with both triangles connected
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 4;
        ctx.beginPath();
        // Top triangle
        ctx.moveTo(centerX - hourglassWidth / 2, centerY - hourglassHeight / 2);
        ctx.lineTo(centerX + hourglassWidth / 2, centerY - hourglassHeight / 2);
        ctx.lineTo(centerX, centerY);
        ctx.lineTo(centerX - hourglassWidth / 2, centerY - hourglassHeight / 2);
        // Bottom triangle
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(centerX - hourglassWidth / 2, centerY + hourglassHeight / 2);
        ctx.lineTo(centerX + hourglassWidth / 2, centerY + hourglassHeight / 2);
        ctx.lineTo(centerX, centerY);
        ctx.stroke();
        
        // Update pixels moving to hourglass
        window.graveyardPixels.forEach(p => {
          const dx = p.targetX - p.x;
          const dy = p.targetY - p.y;
          p.x += dx * 0.1;
          p.y += dy * 0.1;
          
          ctx.fillStyle = p.color;
          ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
          
          // Sparkle
          if (Math.random() < 0.05) {
            ctx.fillStyle = '#fff';
            ctx.fillRect(p.x - 1, p.y - 1, 2, 2);
          }
        });
        
        // Draw rose on top
        drawRose(ctx);
        
        if (animationFrame < maxHourglassFrames) {
          requestAnimationFrame(animateHourglass);
        } else {
          setTimeout(() => {
            sandFall(ctx, vw, vh, centerX, centerY, hourglassHeight);
          }, 1000);
        }
      }
      
      animateHourglass();
    }
    
    function sandFall(ctx, vw, vh, centerX, centerY, hourglassHeight) {
      console.log('‚è≥ Sand falling through hourglass...');
      
      // Make pixels fall through hourglass
      window.graveyardPixels.forEach(p => {
        p.vy = 2 + Math.random() * 3;
        p.phase = 'falling';
      });
      
      // Create frame crumble particles
      const hourglassWidth = 180;
      const frameParticles = [];
      const framePoints = [
        // Top left to top right
        ...Array.from({length: 20}, (_, i) => ({
          x: centerX - hourglassWidth / 2 + (hourglassWidth * i / 19),
          y: centerY - hourglassHeight / 2
        })),
        // Top right to center
        ...Array.from({length: 15}, (_, i) => ({
          x: centerX + hourglassWidth / 2 - (hourglassWidth / 2 * i / 14),
          y: centerY - hourglassHeight / 2 + (hourglassHeight / 2 * i / 14)
        })),
        // Center to bottom left
        ...Array.from({length: 15}, (_, i) => ({
          x: centerX - (hourglassWidth / 2 * i / 14),
          y: centerY + (hourglassHeight / 2 * i / 14)
        })),
        // Bottom left to bottom right
        ...Array.from({length: 20}, (_, i) => ({
          x: centerX - hourglassWidth / 2 + (hourglassWidth * i / 19),
          y: centerY + hourglassHeight / 2
        }))
      ];
      framePoints.forEach(pt => {
        frameParticles.push({
          x: pt.x,
          y: pt.y,
          vx: (Math.random() - 0.5) * 4,
          vy: -1 - Math.random() * 3,
          life: 1,
          size: 4
        });
      });
      
      let animationFrame = 0;
      const maxFallFrames = 180;
      const crumbleStartFrame = 60; // Start crumbling partway through
      
      function animateFall() {
        animationFrame++;
        
        // Clear canvas
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, vw, vh);
        
        // Draw typing text first (in background)
        if (isBonusMode) {
          drawTypingText(ctx, vw, vh);
        }
        
        // Redraw grass
        for (let i = 0; i < 200; i++) {
          ctx.fillStyle = Math.random() > 0.5 ? '#2a2a2a' : '#3a3a3a';
          const size = 8 + Math.random() * 8;
          ctx.fillRect(Math.random() * vw, vh - 200 + Math.random() * 200, size, size);
        }
        
        // Draw hourglass frame (crumbles after crumbleStartFrame)
        if (animationFrame < crumbleStartFrame) {
          // Draw solid frame
          ctx.strokeStyle = '#666';
          ctx.lineWidth = 4;
          ctx.beginPath();
          const hourglassWidth = 180;
          ctx.moveTo(centerX - hourglassWidth / 2, centerY - hourglassHeight / 2);
          ctx.lineTo(centerX + hourglassWidth / 2, centerY - hourglassHeight / 2);
          ctx.lineTo(centerX, centerY);
          ctx.lineTo(centerX - hourglassWidth / 2, centerY - hourglassHeight / 2);
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(centerX - hourglassWidth / 2, centerY + hourglassHeight / 2);
          ctx.lineTo(centerX + hourglassWidth / 2, centerY + hourglassHeight / 2);
          ctx.lineTo(centerX, centerY);
          ctx.stroke();
        } else {
          // Draw crumbling frame particles
          frameParticles.forEach(fp => {
            fp.x += fp.vx;
            fp.y += fp.vy;
            fp.vy += 0.3; // gravity
            fp.vx *= 0.98;
            fp.life -= 0.01;
            
            if (fp.life > 0) {
              ctx.fillStyle = `rgba(102, 102, 102, ${fp.life})`;
              ctx.fillRect(fp.x - fp.size / 2, fp.y - fp.size / 2, fp.size, fp.size);
            }
          });
        }
        
        // Update falling pixels with compaction to ensure contact/stacking
        const gridSize = 8; // pixel step
        const floorY = vh - 90; // slightly above bottom for visible floor
        const compaction = 0.4; // compaction factor to remove gaps
        window.graveyardPixels.forEach(p => {
          p.y += p.vy;
          p.x += (Math.random() - 0.5) * 0.3; // small drift only
          
          // Floor collision
          if (p.y > floorY) {
            p.y = floorY;
            p.vy = 0;
          }
        });
        
        // Simple vertical compaction sweep: pull pixels down to rest on nearest below
        // This enforces that pixels touch either floor or another pixel
        for (let sweep = 0; sweep < 2; sweep++) {
          for (let i = 0; i < window.graveyardPixels.length; i++) {
            const p = window.graveyardPixels[i];
            if (p.vy !== 0) continue; // only compact settled-ish pixels
            // find nearest neighbor directly below within column band
            let nearestY = floorY;
            for (let j = 0; j < window.graveyardPixels.length; j++) {
              if (i === j) continue;
              const q = window.graveyardPixels[j];
              if (Math.abs(q.x - p.x) < gridSize && q.y >= p.y) {
                nearestY = Math.min(nearestY, q.y - gridSize);
              }
            }
            if (p.y < nearestY - compaction) {
              p.y = Math.min(nearestY, p.y + compaction);
            } else if (p.y > nearestY) {
              p.y = nearestY;
            }
          }
        }
        
        // Spill over effect: pixels above a steeper slope slip sideways
        window.graveyardPixels.forEach(p => {
          if (p.y < floorY - 120 && Math.random() < 0.02) {
            p.x += (Math.random() < 0.5 ? -gridSize : gridSize);
          }
          ctx.fillStyle = p.color;
          ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
        });
        
        // Store the pile height for the next phase
        if (!window.sandPileHeight) window.sandPileHeight = floorY;
        window.sandPileHeight = floorY; // fixed base for wave phase
        
        // Draw rose on top
        drawRose(ctx);
        
        if (animationFrame < maxFallFrames) {
          requestAnimationFrame(animateFall);
        } else {
          // Start huge sand wave from top
          setTimeout(() => {
            hugeSandWave(ctx, vw, vh, centerX, centerY, hourglassHeight);
          }, 500);
        }
      }
      
      animateFall();
    }
    
    function hugeSandWave(oldCtx, vw, vh, centerX, centerY, hourglassHeight) {
      console.log('üåä Huge sand wave incoming...');
      
      // NUCLEAR: Remove graveyard overlay so it doesn't block environmental particles
      const graveyardOverlay = document.getElementById('graveyardOverlay');
      if (graveyardOverlay) {
        graveyardOverlay.remove();
        console.log('üóëÔ∏è Removed graveyard overlay to show fire/snow particles');
      }
      graveyardActive = false;
      
      // Create NEW canvas for wave that doesn't block environmental particles
      const viewport = document.getElementById('viewport');
      const waveCanvas = document.createElement('canvas');
      waveCanvas.id = 'waveCanvas';
      waveCanvas.width = vw;
      waveCanvas.height = vh;
      waveCanvas.style.position = 'fixed';
      waveCanvas.style.inset = '0';
      waveCanvas.style.zIndex = '75'; // BELOW fxOverlay (80) and particleCanvas (90) so fire/snow show on top
      waveCanvas.style.pointerEvents = 'none';
      viewport.appendChild(waveCanvas);
      const ctx = waveCanvas.getContext('2d', { alpha: true });
      console.log('üé® Created wave canvas at z-index 75 (below fire/snow at 80/90)');
      
      // NUCLEAR FIX: Start FRESH - don't keep old hourglass particles
      const MAX_WAVE_PARTICLES = 1200;  // Enough particles to form train
      const DRAW_DECIMATE_FALL = 1;     // draw EVERY particle
      const DRAW_DECIMATE_SHAPE = 1;    // draw EVERY particle for visible train
      const DRAW_DECIMATE_ROLL = 1;     // draw EVERY particle for visible train
      const waveParticles = [];  // START EMPTY for continuous spawning
      const waveWidth = vw * 0.8;
      const waveHeight = vh * 0.6;
      
      console.log(`üí• Starting FRESH wave - continuous particle spawning!`);
      
      // Initialize column height tracking for particle stacking
      window.columnHeights = {};
      let currentPileHeight = vh - 90; // Track the highest point of the sand pile
      
      let waveFrame = 0;
      const maxWaveFrames = 1100; // ~18 seconds finale (slightly longer)
      let newParticleTimer = 0;
      let wavePhase = 'fall'; // 'fall' -> 'shape' -> 'roll'
      let shapeFrame = 0;
      let rollOffsetX = 0;
      let trainTargets = [];
      let smokePlumes = [];
      // Fall staging: 0=center sparse, 1=wide sparse, 2=wide medium, 3=wide heavy, 4=wait, 5-7=three intense cascades
      let fallStage = 0;
      let fallStageFrame = 0;
      let cascadeActive = false; // Dense sand cascade flag
      let cascadeFrame = 0;
      const stageDurations = [120, 90, 90, 90, 60, 45, 45, 45]; // Added three short intense bursts
      function advanceFallStage() { fallStage++; fallStageFrame = 0; }
      let rollInit = false; // initialize deterministic sandfall on first roll frame
      let carNextEmitFrame = [];
      const CAR_EMIT_INTERVAL_BASE = 10; // frames between trickles per car (base)
      // Hoisted silhouette metrics so animation phases can reference them
      let baseX = 0;
      let baseY = 0;
      let engineH = 0;
      let chimneyH = 0;
      let engineW = 0; // hoisted so roll/shape can reference
      let numCars = 0; // hoisted for trickle emission
      let carW = 0;    // hoisted for trickle emission
      let carGap = 0;  // hoisted for trickle emission
      // Skull towers for finale (two left, one center, two right)
      const floorYFinale = vh - 90;
      let skullTowers = [];
      let skullsBuilt = false;
      let skullsCollapse = false;
      function buildSkullTowers(riseProgress = 0) {
        if (skullsBuilt) return;
        skullsBuilt = true;
        const towerXs = [vw * 0.12, vw * 0.26, vw * 0.5, vw * 0.74, vw * 0.88];
        const rows = 12; // taller towers
        const spacing = 26;
        const jitter = 6;
        const skullSize = 22;
        towerXs.forEach((tx) => {
          for (let r = 0; r < rows; r++) {
            const count = rows - r; // pyramid shape
            const totalWidth = (count - 1) * spacing;
            const baseX = tx - totalWidth / 2;
            // start lower and rise with tombstone progress
            const baseY = floorYFinale - r * spacing - 10;
            const y = baseY + (1 - riseProgress) * 140; // lifted into place as tomb rises
            const rowOffset = ((r % 2 === 0) ? -1 : 1) * (jitter * 0.6) + (Math.random() - 0.5) * jitter;
            for (let c = 0; c < count; c++) {
              skullTowers.push({
                x: baseX + c * spacing + rowOffset,
                y,
                vx: 0,
                vy: 0,
                size: skullSize,
                state: 'stack'
              });
            }
          }
        });
      }
      
      // Plummeting submit visual
      const plummet = {
        x: vw / 2,
        y: -120,
        vy: 18,
        width: 160,
        height: 48,
        active: true,
        emojiIdx: 0,
        lastEmojiTick: 0,
        rotation: 0, // Add rotation for visual feedback
        trail: []    // Add trail effect
      };

      function drawRoundedRect(ctx, x, y, w, h, r) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
      }

      function animateWave() {
        waveFrame++;
        newParticleTimer++;
        
        // Clear canvas
        ctx.clearRect(0, 0, vw, vh);
        
        // Draw black background during fall phase, transparent during train phases
        if (wavePhase === 'fall') {
          ctx.fillStyle = '#000000';
          ctx.fillRect(0, 0, vw, vh);
        }
        
        // Continuously add new particles with accelerating spawn rate
        const progress = waveFrame / maxWaveFrames;
        
        // DRAMATIC spawn rates from the start for visual impact!
        // Start: every frame, 8-15 particles
        // Middle: every frame, 15-25 particles  
        // End: every frame, 20-35 particles
        let spawnInterval, minParticles, maxParticles;
        
        if (progress < 0.2) {
          // INTENSE initial cascade
          spawnInterval = 1;
          minParticles = 8;
          maxParticles = 15;
        } else if (progress < 0.5) {
          // Building up MORE
          spawnInterval = 1;
          minParticles = 15;
          maxParticles = 25;
        } else if (progress < 0.8) {
          // Heavy TORRENT
          spawnInterval = 1;
          minParticles = 20;
          maxParticles = 30;
        } else {
          // MAXIMUM cascade
          spawnInterval = 1;
          minParticles = 25;
          maxParticles = 40;
        }
        
        // Stage-controlled spawns following the submit drop
        const currentMax = MAX_WAVE_PARTICLES; // cap applies across stages
        if (newParticleTimer % spawnInterval === 0 && waveFrame < maxWaveFrames - 60 && waveParticles.length < currentMax) {
          let numNewParticles = 0;
          let xMin = 0;
          let xMax = vw;
          if (fallStage === 0) {
            // Center DRAMATIC start
            numNewParticles = Math.max(minParticles, maxParticles);
            xMin = vw * 0.3; xMax = vw * 0.7;
          } else if (fallStage === 1) {
            // Wide CASCADE
            numNewParticles = Math.max(minParticles, maxParticles);
            xMin = 0; xMax = vw;
          } else if (fallStage === 2) {
            // Wide INTENSE
            numNewParticles = Math.max(minParticles, maxParticles + 5);
            xMin = 0; xMax = vw;
          } else if (fallStage === 3) {
            // Wide TORRENT
            numNewParticles = Math.max(minParticles, maxParticles + 10);
            xMin = 0; xMax = vw;
          } else if (fallStage === 4) {
            // Brief pause with light trickle FULL WIDTH
            numNewParticles = Math.floor(minParticles * 0.5);
            xMin = 0; xMax = vw;
          } else if (fallStage === 5) {
            // First EXPLOSIVE cascade FULL WIDTH
            numNewParticles = Math.max(30, maxParticles + 15);
            xMin = 0; xMax = vw;
          } else if (fallStage === 6) {
            // Second EXPLOSIVE cascade FULL WIDTH
            numNewParticles = Math.max(35, maxParticles + 20);
            xMin = 0; xMax = vw;
          } else if (fallStage === 7) {
            // Final cascade FULL WIDTH for train transition
            numNewParticles = Math.max(40, maxParticles + 25);
            xMin = 0; xMax = vw;
          } else {
            numNewParticles = 0;
          }
          let spawned = 0;
          for (let i = 0; i < numNewParticles; i++) {
            if (waveParticles.length >= currentMax) break;
            const clusterX = xMin + Math.random() * (xMax - xMin);
            // Spawn ABOVE hourglass top for dramatic cascade effect
            const spawnY = centerY - hourglassHeight / 2 - 100 - Math.random() * 50;
            waveParticles.push({
              x: clusterX,
              y: spawnY,
              vx: (Math.random() - 0.5) * 3,
              vy: 2 + Math.random() * 5,
              size: 6 + Math.random() * 6,
              color: `hsl(${45 + Math.random() * 15}, ${80 + Math.random() * 20}%, ${60 + Math.random() * 20}%)`,
              life: 1,
              phase: 'falling'
            });
            spawned++;
          }
          // Log spawning activity every 60 frames
          if (spawned > 0 && waveFrame % 60 === 0) {
            console.log(`‚ú® Spawned ${spawned} particles at frame ${waveFrame} | xRange: ${xMin.toFixed(0)}-${xMax.toFixed(0)} | Total: ${waveParticles.length}/${currentMax} | Stage ${fallStage}`);
          }
        }
        
        // Update all particles, draw decimated for performance
        let fallingCount = 0;
        let settledCount = 0;
        for (let idx = 0; idx < waveParticles.length; idx++) {
          const p = waveParticles[idx];
          
          // Only update if falling
          if (p.phase === 'falling') {
            fallingCount++;
            p.y += p.vy;
            p.x += p.vx;
            p.vy += 0.2; // Gravity
            p.vx *= 0.99; // Friction
            
            // Slight drift
            p.x += Math.sin(waveFrame * 0.05 + idx * 0.1) * 0.3;
            
            // Stack particles in layers using approximate height tracking
            const floorY = vh - 90; // Bottom floor
            const columnWidth = 20; // Width of stacking columns
            const column = Math.floor(p.x / columnWidth);
            
            // Track highest point in each column for efficient stacking
            if (!p.column) p.column = column;
            if (!window.columnHeights) window.columnHeights = {};
            
            const currentColumnHeight = window.columnHeights[column] || floorY;
            
            // Check if particle has reached or passed the stack height in its column
            if (p.y >= currentColumnHeight - p.size * 2) {
              p.y = currentColumnHeight - p.size;
              p.vy = 0;
              p.vx = 0;
              p.phase = 'settled';
              p.settledTime = waveFrame;
              // Update column height
              window.columnHeights[column] = Math.min(currentColumnHeight, p.y);
              // Update global pile height (minimum/highest point across all columns)
              currentPileHeight = Math.min(currentPileHeight, p.y);
            }
          } else if (p.phase === 'settled') {
            settledCount++;
            // Keep settled particles - don't remove them so they build up in layers
          }
          
          // Draw particle (decimated); slightly denser during cascade
          if ((idx % (cascadeActive ? Math.max(1, DRAW_DECIMATE_FALL - 1) : DRAW_DECIMATE_FALL)) === 0) {
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
            // Golden sparkle
            if (Math.random() < 0.02 && p.phase === 'falling') {
              ctx.fillStyle = '#fff';
              ctx.fillRect(p.x - 1, p.y - 1, 2, 2);
            }
          }
        }
        
        // Log particle status periodically
        if (waveFrame % 60 === 0) {
          console.log(`üíß Wave frame ${waveFrame}/${maxWaveFrames}: ${waveParticles.length} total (${fallingCount} falling, ${settledCount} settled) | Stage ${fallStage}`);
        }

        // Manage fall stage timings; advance through all 8 stages before transitioning
        fallStageFrame++;
        if (fallStageFrame >= stageDurations[fallStage] && fallStage < stageDurations.length - 1) {
          advanceFallStage();
          console.log(`‚è≥ Advanced to fall stage ${fallStage} (${fallStage === 5 ? 'CASCADE 1' : fallStage === 6 ? 'CASCADE 2' : fallStage === 7 ? 'CASCADE 3' : ''})`);
        }
        
        // Draw rose on top
        drawRose(ctx);
        // Build skull towers on first frame of the finale
        if (!skullsBuilt) buildSkullTowers();
        
        // Visible plummeting submit button that pushes sand aside
        if (plummet.active) {
          // Update position and rotation
          plummet.vy += 1.0; // gravity
          plummet.y += plummet.vy;
          plummet.rotation += 0.08; // Slow rotation for visual feedback
          
          // Add trail effect
          plummet.trail.push({ x: plummet.x, y: plummet.y, alpha: 1 });
          if (plummet.trail.length > 8) plummet.trail.shift();
          
          // Update trail alpha
          plummet.trail.forEach((t, i) => {
            t.alpha = (i / plummet.trail.length) * 0.3;
          });
          
          // Draw trail
          plummet.trail.forEach((t, i) => {
            if (i < plummet.trail.length - 1) { // Skip current position
              ctx.save();
              ctx.translate(t.x, t.y);
              const trailW = plummet.width * (0.7 + i / plummet.trail.length * 0.3);
              const trailH = plummet.height * (0.7 + i / plummet.trail.length * 0.3);
              const btnX = -trailW / 2;
              const btnY = -trailH / 2;
              ctx.globalAlpha = t.alpha;
              ctx.fillStyle = '#ffffff';
              ctx.lineWidth = 2;
              ctx.strokeStyle = '#ffffff';
              drawRoundedRect(ctx, btnX, btnY, trailW, trailH, 8);
              ctx.restore();
            }
          });
          
          // Draw button with rotation
          ctx.save();
          ctx.translate(plummet.x, plummet.y);
          ctx.rotate(plummet.rotation);
          
          const btnX = -plummet.width / 2;
          const btnY = -plummet.height / 2;
          ctx.lineWidth = 3;
          ctx.strokeStyle = '#ffffff';
          ctx.fillStyle = '#ffffff';
          ctx.globalAlpha = 0.95;
          drawRoundedRect(ctx, btnX, btnY, plummet.width, plummet.height, 10);
          ctx.globalAlpha = 1;
          
          // Label
          ctx.fillStyle = '#000000';
          ctx.font = 'bold 18px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          const label = isBonusMode ? 'SOBMIT' : 'SUBMIT';
          const emojis = ['üò≠','üò¢','ü•≤','üòø'];
          if (isBonusMode && waveFrame - plummet.lastEmojiTick > 10) {
            plummet.emojiIdx = (plummet.emojiIdx + 1) % emojis.length;
            plummet.lastEmojiTick = waveFrame;
          }
          const emoji = isBonusMode ? ` ${emojis[plummet.emojiIdx]}` : '';
          ctx.fillText(label + emoji, 0, 0);
          
          ctx.restore();
          
          // Push particles away in a band around the button
          const halfW = plummet.width / 2 + 12;
          const halfH = plummet.height / 2 + 12;
          waveParticles.forEach(p => {
            if (Math.abs(p.x - plummet.x) < halfW && Math.abs(p.y - plummet.y) < halfH) {
              // Side burst
              const dir = (p.x < plummet.x) ? -1 : 1;
              p.vx += dir * (6 + Math.random() * 2);
              p.vy -= 2 + Math.random() * 2;
              p.phase = 'falling';
            }
          });
          // Collapse skull towers when submit slices into the sand pile
          if (!skullsCollapse && (plummet.y + plummet.height / 2) >= (currentPileHeight - 10)) {
            skullsCollapse = true;
            skullTowers.forEach(s => {
              s.state = 'collapse';
              s.vx = (Math.random() - 0.5) * 3;
              s.vy = -2 - Math.random() * 2;
            });
            // Trigger dense sand cascade for a short time
            cascadeActive = true;
            cascadeFrame = 0;
          }
          
          if (plummet.y - plummet.height / 2 > vh + 200) {
            plummet.active = false;
          }
        }

        // Update and draw skull towers (on top of sand and plummet)
        if (skullsBuilt) {
          ctx.font = '22px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          skullTowers.forEach(s => {
            if (s.state === 'collapse') {
              s.x += s.vx;
              s.y += s.vy;
              s.vy += 0.25; // gravity
              s.vx *= 0.99; // friction
              if (s.y > floorYFinale) {
                s.y = floorYFinale;
                s.vy *= -0.25; // small bounce
                s.vx *= 0.9;
              }
            }
            ctx.save();
            ctx.fillStyle = '#fff';
            ctx.shadowColor = 'rgba(255,255,255,0.4)';
            ctx.shadowBlur = 8;
            ctx.fillText('üíÄ', s.x, s.y);
            ctx.restore();
          });
        }

        // Phase transitions
        if (wavePhase === 'fall' && waveFrame >= maxWaveFrames && fallStage >= stageDurations.length - 1) {
          wavePhase = 'shape';
          shapeFrame = -120; // delay ~2s at 60fps before train spawns (after staged falls including three intense cascades)
          console.log(`üöÇ Transitioning to train shape phase! Particles: ${waveParticles.length}, WaveFrame: ${waveFrame}, FallStage: ${fallStage}`);
          // Clear column heights for train formation
          window.columnHeights = {};
          // Build train silhouette targets near floor (above stacked particles)
          baseY = vh - 160; // Fixed position near bottom
          baseX = 80; // left margin
          const cell = 8;
          engineW = 280;
          engineH = 100;
          const cabW = 110;
          const chimneyW = 36;
          chimneyH = 50;
          // Added cars + windows + wheels
          numCars = 3;
          carW = 180;
          const carH = 80;
          carGap = 30;
          const windowW = 64;
          const windowH = 40;
          const wheelR = 20;
          // Engine body
          for (let y = 0; y <= engineH; y += cell) {
            for (let x = 0; x <= engineW; x += cell) {
              trainTargets.push({x: baseX + x, y: baseY - y});
            }
          }
          // Cab (mirrored to left side)
          for (let y = 0; y <= engineH * 0.7; y += cell) {
            for (let x = 0; x <= cabW; x += cell) {
              trainTargets.push({x: baseX + x, y: baseY - engineH - y});
            }
          }
          // Chimney (mirrored to right/front)
          for (let y = 0; y <= chimneyH; y += cell) {
            for (let x = 0; x <= chimneyW; x += cell) {
              trainTargets.push({x: baseX + engineW - 40 - chimneyW + x, y: baseY - engineH - y});
            }
          }
          // Engine wheels (two pixel circles under engine)
          const wheelREng = 20;
          const wheelYEng = baseY + 10;
          const wheelEngCx1 = baseX + 60;
          const wheelEngCx2 = baseX + engineW - 60;
          for (let yy = -wheelREng; yy <= wheelREng; yy += cell) {
            for (let xx = -wheelREng; xx <= wheelREng; xx += cell) {
              if (xx*xx + yy*yy <= wheelREng*wheelREng) {
                trainTargets.push({ x: wheelEngCx1 + xx, y: wheelYEng - yy });
                trainTargets.push({ x: wheelEngCx2 + xx, y: wheelYEng - yy });
              }
            }
          }
          // Cars (rectangles with window holes)
          for (let c = 0; c < numCars; c++) {
            const startX = baseX - 50 - carW - c * (carW + carGap);
            for (let y = 0; y <= carH; y += cell) {
              for (let x = 0; x <= carW; x += cell) {
                const inWindow1 = (x > 20 && x < 20 + windowW && y > 20 && y < 20 + windowH);
                const inWindow2 = (x > carW - 20 - windowW && x < carW - 20 && y > 20 && y < 20 + windowH);
                if (inWindow1 || inWindow2) continue; // hole
                trainTargets.push({ x: startX + x, y: baseY - y });
              }
            }
            // Wheels (two pixel circles)
            const wheelY = baseY + 10;
            const wheelCx1 = startX + 36;
            const wheelCx2 = startX + carW - 36;
            for (let yy = -wheelREng; yy <= wheelREng; yy += cell) {
              for (let xx = -wheelREng; xx <= wheelREng; xx += cell) {
                if (xx*xx + yy*yy <= wheelREng*wheelREng) {
                  trainTargets.push({ x: wheelCx1 + xx, y: wheelY - yy });
                  trainTargets.push({ x: wheelCx2 + xx, y: wheelY - yy });
                }
              }
            }
          }
          // Assign targets to particles
          let tIdx = 0;
          waveParticles.forEach(p => {
            const t = trainTargets[tIdx % trainTargets.length];
            p.tX = t.x;
            p.tY = t.y;
            tIdx++;
          });
        }

        if (wavePhase === 'shape') {
          shapeFrame++;
          if (shapeFrame < 0) {
            // hold before drawing the train to allow staged falls + pause
            requestAnimationFrame(animateWave);
            return;
          }
          
          // Log train formation progress
          if (shapeFrame % 30 === 0) {
            console.log(`üöÇ SHAPE frame ${shapeFrame}: ${waveParticles.length} particles forming train`);
          }
          
          // Draw FULL background box to make ENTIRE train visible (including all 3 cars)
          const trainBounds = {
            left: baseX - 50 - carW - (numCars - 1) * (carW + carGap) - 100, // Include all cars to the left
            right: baseX + engineW + 100,
            top: baseY - engineH - chimneyH - 50,
            bottom: baseY + 60
          };
          ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
          ctx.fillRect(trainBounds.left, trainBounds.top, trainBounds.right - trainBounds.left, trainBounds.bottom - trainBounds.top);
          
          // Animate particles to targets, draw decimated lightweight rects
          waveParticles.forEach((p, idx) => {
            if (p.tX !== undefined) {
              p.x += (p.tX - p.x) * 0.12;
              p.y += (p.tY - p.y) * 0.12;
            }
            if ((idx % DRAW_DECIMATE_SHAPE) === 0) {
              ctx.fillStyle = p.color;
              // single rect with slight jitter for chunky look
              const jx = (Math.random() - 0.5) * 1.0;
              const jy = (Math.random() - 0.5) * 1.0;
              ctx.fillRect(p.x - p.size / 2 + jx, p.y - p.size / 2 + jy, p.size, p.size);
              // rare tiny crumble speck
              if (Math.random() < 0.01) emitTrickle(smokePlumes, p.x, p.y);
            }
          });
          // Chimney sand while shaping (mirrored chimney position)
          emitSmoke(smokePlumes, baseX + engineW - 40, baseY - engineH - chimneyH);
          drawSmoke(ctx, smokePlumes);
          if (shapeFrame > 140) {
            wavePhase = 'roll';
            rollOffsetX = 0;
            console.log(`üöÇ TRAIN ROLLING! Particles: ${waveParticles.length}`);
          }
        } else if (wavePhase === 'roll') {
          if (!rollInit) {
            rollInit = true;
            // Start tail earliest; stagger others
            carNextEmitFrame = Array(numCars).fill(0).map((_, c) => waveFrame + (numCars - 1 - c) * 8);
          }
          rollOffsetX += 8; // train moves right (faster)
          
          // Draw FULL background box to make ENTIRE train visible (follows train)
          const trainBounds = {
            left: baseX - 50 - carW - (numCars - 1) * (carW + carGap) - 100 + rollOffsetX, // Include all cars
            right: baseX + engineW + 100 + rollOffsetX,
            top: baseY - engineH - chimneyH - 50,
            bottom: baseY + 60
          };
          ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
          ctx.fillRect(trainBounds.left, trainBounds.top, trainBounds.right - trainBounds.left, trainBounds.bottom - trainBounds.top);
          
          // Move and draw particles with lightweight decimated rects
          waveParticles.forEach((p, idx) => {
            const tx = (p.tX !== undefined ? p.tX : p.x) + rollOffsetX;
            const ty = (p.tY !== undefined ? p.tY : p.y);
            // Follow with slight lag
            p.x += (tx - p.x) * 0.2;
            p.y += (ty - p.y) * 0.2;
            if ((idx % DRAW_DECIMATE_ROLL) === 0) {
              ctx.fillStyle = p.color;
              const jx = (Math.random() - 0.5) * 1.0;
              const jy = (Math.random() - 0.5) * 1.0;
              ctx.fillRect(p.x - p.size / 2 + jx, p.y - p.size / 2 + jy, p.size, p.size);
            }
          });
          // Emit chimney sand (mirrored chimney position)
          emitSmoke(smokePlumes, baseX + engineW - 40 + rollOffsetX, baseY - engineH - chimneyH);
          // Deterministic sand fall from back to front: schedule per car (denser)
          for (let c = numCars - 1; c >= 0; c--) {
            const xStart = baseX - 50 - carW - c * (carW + carGap) + rollOffsetX;
            const xEnd = xStart + carW;
            while (waveFrame >= carNextEmitFrame[c]) {
              // Emit multiple clumps for density
              const clumps = 2 + Math.floor(Math.random() * 2);
              for (let k = 0; k < clumps; k++) {
                const tx2 = xStart + Math.random() * (xEnd - xStart);
                emitTrickle(smokePlumes, tx2, baseY);
              }
              // Tail emits more frequently; front less
              const penalty = (numCars - 1 - c); // 0 at tail, larger toward front
              carNextEmitFrame[c] += Math.max(4, CAR_EMIT_INTERVAL_BASE - 2) + penalty * 5 + Math.floor(Math.random() * 3);
            }
          }
          drawSmoke(ctx, smokePlumes);
          if (rollOffsetX > vw + 400) {
            // Off-screen right: end sequence
            setTimeout(() => {
              window.location.href = '../../speed.html';
            }, 800);
            return;
          }
        }

        if (wavePhase === 'fall' && waveFrame < maxWaveFrames) {
          requestAnimationFrame(animateWave);
        } else if (wavePhase === 'shape' || wavePhase === 'roll') {
          requestAnimationFrame(animateWave);
        }
      }
      
      // Smoke helpers (now golden sand squares)
      function emitSmoke(arr, x, y) {
        // Upward drifting golden sand from chimney
        if (Math.random() < 0.8) {
          arr.push({ x, y, vx: (Math.random() - 0.5) * 0.9, vy: -2.2 - Math.random() * 1.3, size: 4 + Math.random() * 4, a: 1, color: '#f5d86a', type: 'up' });
        }
      }
      function emitTrickle(arr, x, y) {
        // Downward sand trickle from cars - medium clumps
        arr.push({ x, y, vx: (Math.random() - 0.5) * 0.9, vy: 1.1 + Math.random() * 2.1, size: 5 + Math.random() * 3, a: 1, color: '#f5d86a', type: 'down' });
      }
      function drawSmoke(ctx, arr) {
        for (let i = 0; i < arr.length; i++) {
          const s = arr[i];
          s.x += s.vx;
          s.y += s.vy;
          if (s.type === 'down') {
            s.vy += 0.05; // stronger gravity for falling clumps
            // Randomly break apart into smaller pieces (less frequent)
            if (Math.random() < 0.02 && s.size > 3) {
              // Split into 2 smaller clumps
              const numSplits = 2;
              for (let j = 0; j < numSplits; j++) {
                arr.push({
                  x: s.x + (Math.random() - 0.5) * 4,
                  y: s.y,
                  vx: s.vx + (Math.random() - 0.5) * 0.8,
                  vy: s.vy + Math.random() * 0.5,
                  size: s.size * (0.5 + Math.random() * 0.2),
                  a: s.a,
                  color: s.color,
                  type: 'down'
                });
              }
              s.size *= 0.6; // Shrink original less
            }
          } else {
            s.vy *= 0.98; // slow upward drift
          }
          s.a *= 0.96;
          if (s.a <= 0.02) { arr.splice(i,1); i--; continue; }
          
          ctx.globalAlpha = s.a;
          
          // Draw pixelated clumps with larger chunks
          const pixelSize = 3;
          const radius = s.size / 2;
          
          for (let px = -radius; px < radius; px += pixelSize) {
            for (let py = -radius; py < radius; py += pixelSize) {
              // Random missing pixels for crumbly look
              if (Math.random() < 0.3) continue;
              
              // Vary brightness
              const brightness = 245 + Math.floor(Math.random() * 10);
              ctx.fillStyle = `rgb(${brightness}, ${Math.floor(brightness * 0.88)}, 106)`;
              ctx.fillRect(s.x + px, s.y + py, pixelSize, pixelSize);
            }
          }
          
          ctx.globalAlpha = 1;
        }
      }

      animateWave();
    }
    
    function animateLogoCircles() {
      console.log('‚ú® Animating logo circles');
      
      const viewport = document.getElementById('viewport');
      const vw = viewport.clientWidth;
      const vh = viewport.clientHeight;
      
      // Get board position in scene coordinates
      const boardRect = assignaBoard.getBoundingClientRect();
      const sceneRect = document.getElementById('scene').getBoundingClientRect();
      
      // Logo position on board (relative to board canvas)
      const logoCircles = [
        { x: 42, y: 28 },  // Top
        { x: 32, y: 48 },  // Bottom left
        { x: 52, y: 48 }   // Bottom right
      ];
      
      // Triangle offsets from center (scaled up for visibility)
      const triangleOffsets = [
        { dx: 0, dy: -20 },    // Top
        { dx: -17, dy: 17 },   // Bottom left
        { dx: 17, dy: 17 }     // Bottom right
      ];
      
      // Create actual DOM circles
      const circles = logoCircles.map((pos, i) => {
        const circle = document.createElement('div');
        circle.style.position = 'fixed';
        circle.style.width = '16px';
        circle.style.height = '16px';
        circle.style.borderRadius = '50%';
        circle.style.background = '#ff5263';
        circle.style.zIndex = '1000';
        circle.style.transition = 'all 1.5s cubic-bezier(0.34, 1.56, 0.64, 1)';
        
        // Position relative to board in viewport
        const startX = boardRect.left + pos.x;
        const startY = boardRect.top + pos.y;
        circle.style.left = `${startX}px`;
        circle.style.top = `${startY}px`;
        
        viewport.appendChild(circle);
        return { el: circle, offset: triangleOffsets[i] };
      });
      
      // Blink twice
      let blinkCount = 0;
      const blinkInterval = setInterval(() => {
        circles.forEach(c => {
          c.el.style.opacity = c.el.style.opacity === '0' ? '1' : '0';
        });
        blinkCount++;
        if (blinkCount >= 4) { // 2 blinks = 4 toggles
          clearInterval(blinkInterval);
          circles.forEach(c => c.el.style.opacity = '1');
          
          // Move to center in triangle formation and glow
          setTimeout(() => {
            const centerX = vw / 2;
            const centerY = vh / 2;
            
            circles.forEach((c, i) => {
              // Keep triangle formation relative to center
              c.el.style.left = `${centerX + c.offset.dx}px`;
              c.el.style.top = `${centerY + c.offset.dy}px`;
              c.el.style.boxShadow = '0 0 30px #ff5263, 0 0 60px #ff5263, 0 0 90px #ff5263';
              c.el.style.transform = 'scale(2.5)';
            });
            
            console.log('üåü Circles glowing at center in triangle formation');
          }, 100);
        }
      }, 300);
    }
    
    function revealFinalBoard() {
      const scene = document.getElementById('scene');
      const viewport = document.getElementById('viewport');
      const vw = viewport.clientWidth;
      const vh = viewport.clientHeight;
      
      const boardCenterX = intakeCenterX;
      const boardCenterY = intakeCenterY + 400;
      
      const scale = 0.7;
      const targetX = vw / 2 - boardCenterX * scale;
      const targetY = vh / 2 - boardCenterY * scale;
      
      scene.style.transition = 'transform 2.5s cubic-bezier(0.23, 1, 0.32, 1)';
      scene.style.transform = `translate(${targetX}px, ${targetY}px) scale(${scale})`;
      
      // Animate logo circles before showing button (shorter pause)
      setTimeout(() => {
        animateLogoCircles();
      }, 800);
      
      // Show bonus button (only in normal mode) or auto-redirect (in bonus mode)
      setTimeout(() => {
        if (isBonusMode) {
          // Bonus complete, auto-redirect (flag already cleared at page load)
          console.log('üöÄ Bonus complete, redirecting to Rainbow Roadmap...');
          window.location.href = '../../speed.html';
        } else {
          // Show bonus offer button with countdown
          const bonusButton = document.getElementById('bonusButton');
          const countdown = document.getElementById('bonusCountdown');
          const segwayButton = document.getElementById('segwayButton');
          bonusButton.classList.add('visible');
          segwayButton.classList.add('visible');
          console.log('üéÅ Bonus button ready!');
          
          // Start 5 second countdown
          let secondsLeft = 5;
          countdown.textContent = `Auto-continuing in ${secondsLeft}s...`;
          
          const countdownInterval = setInterval(() => {
            secondsLeft--;
            if (secondsLeft > 0) {
              countdown.textContent = `Auto-continuing in ${secondsLeft}s...`;
            } else {
              clearInterval(countdownInterval);
              countdown.textContent = 'Continuing...';
              // Auto-redirect to speed.html
              setTimeout(() => {
                window.location.href = '../../speed.html';
              }, 500);
            }
          }, 1000);
          
          // Bonus button click handler
          bonusButton.onclick = () => {
            clearInterval(countdownInterval);
            if (!isBonusMode) {
              console.log('üéÅ Bonus mode activated!');
              sessionStorage.setItem('celli:bonusTrainMode', 'true');
              window.location.reload();
            }
          };

          // Segway button click handler
          segwayButton.onclick = () => {
            clearInterval(countdownInterval);
            console.log('üõ¥ Standup and Deliver clicked!');
            
            // Start glowing animation
            segwayButton.classList.add('glowing');
            
            // Fade out other elements
            bonusButton.style.transition = 'opacity 1s';
            bonusButton.style.opacity = '0';
            document.getElementById('scene').style.transition = 'opacity 1s';
            document.getElementById('scene').style.opacity = '0.2';
            document.getElementById('titleOverlay').style.transition = 'opacity 1s';
            document.getElementById('titleOverlay').style.opacity = '0.2';
            
            // After 1.5s, morph button into ball
            setTimeout(() => {
              segwayButton.style.transition = 'all 1s ease';
              segwayButton.style.borderRadius = '50%';
              segwayButton.style.width = '200px';
              segwayButton.style.height = '200px';
              segwayButton.style.padding = '0';
              segwayButton.style.fontSize = '0';
              
              // After morphing, show ball with typed text
              setTimeout(() => {
                segwayButton.style.display = 'none';
                const ball = document.getElementById('segwayBall');
                ball.classList.add('visible');
                
                // Typing animation
                const lines = [
                  "We're proud to present...",
                  "An innovation for the ages...",
                  "Something worlds will be built around...",
                  "THE SEGUE"
                ];
                
                let currentLine = 0;
                let currentChar = 0;
                let displayText = '';
                let expansionStarted = false;
                
                // Start expansion immediately as typing begins
                setTimeout(() => {
                  ball.classList.add('expanding');
                  
                  // Shift text to black as expansion continues
                  setTimeout(() => {
                    ball.classList.add('blackout');
                  }, 1500);
                }, 500);
                
                function typeNextChar() {
                  if (currentLine < lines.length) {
                    if (currentChar < lines[currentLine].length) {
                      displayText += lines[currentLine][currentChar];
                      ball.innerHTML = displayText.replace(/\n/g, '<br>');
                      currentChar++;
                      
                      setTimeout(typeNextChar, 50);
                    } else {
                      // Move to next line
                      displayText += '\n\n';
                      currentLine++;
                      currentChar = 0;
                      if (currentLine < lines.length) {
                        setTimeout(typeNextChar, 400);
                      } else {
                        // Typing complete, show card (will be covered by expanding circle)
                        setTimeout(() => {
                          document.getElementById('segwayCard').classList.add('visible');
                        }, 800);
                        
                        // Redirect to speed.html after expansion completes
                        setTimeout(() => {
                          window.location.href = '../../speed.html';
                        }, 3500);
                      }
                    }
                  }
                }
                
                typeNextChar();
              }, 1000);
            }, 1500);
          };
        }
      }, 4000);
    }
    
    function launchSubmitButton() {
      if (submitLaunched) return;
      submitLaunched = true;
      
      console.log('üöÄ SUBMIT SPRING LAUNCH!');
      
      const colors = ['#fff', '#2846ff', '#ff9d1c', '#ff185f'];
      let colorIdx = 0;
      
      // Get current position
      const currentX = parseFloat(submitEngine.style.left);
      const currentY = parseFloat(submitEngine.style.top);
      const currentAngle = getPathPosAndTangent(engineDistance).angle;
      
      // === SPRING COMPRESSION PHASE ===
      let springPhase = 0;
      const springDuration = 600; // ms
      const springStart = performance.now();
      
      function animateSpring(now) {
        const elapsed = now - springStart;
        springPhase = Math.min(1, elapsed / springDuration);
        
        if (springPhase < 0.7) {
          // SQUASH phase (compress like a spring)
          const squash = 1 - springPhase * 0.6; // Squash down to 40%
          const scaleY = squash;
          const scaleX = 1 + (1 - squash) * 0.3; // Widen as it squashes
          
          // Shake intensifies
          const shake = springPhase * 15;
          const offsetX = (Math.random() - 0.5) * shake;
          const offsetY = (Math.random() - 0.5) * shake;
          
          submitEngine.style.transform = `translate(-50%, -50%) rotate(${currentAngle}rad) scaleY(${scaleY}) scaleX(${scaleX})`;
          submitEngine.style.left = `${currentX + offsetX}px`;
          submitEngine.style.top = `${currentY + offsetY}px`;
          
          // Color pulse during compression
          submitEngine.style.background = colors[Math.floor(springPhase * 10) % colors.length];
          
          requestAnimationFrame(animateSpring);
        } else if (springPhase < 1.0) {
          // STRETCH phase (release spring)
          const stretch = 1 + (springPhase - 0.7) * 3.0; // Stretch up to 2x
          const scaleY = stretch;
          const scaleX = 1 / Math.sqrt(stretch); // Compress width to conserve volume
          
          submitEngine.style.transform = `translate(-50%, -50%) rotate(${currentAngle}rad) scaleY(${scaleY}) scaleX(${scaleX})`;
          
          requestAnimationFrame(animateSpring);
        } else {
          // === LAUNCH! ===
          const launchInterval = setInterval(() => {
            submitEngine.style.background = colors[colorIdx % colors.length];
            submitEngine.style.borderColor = colors[colorIdx % colors.length];
            submitEngine.style.color = colorIdx % colors.length === 0 ? '#000' : '#fff';
            colorIdx++;
          }, 100);
          
          // In bonus mode, launch toward intake box for bounce
          if (isBonusMode) {
            // Calculate trajectory to hit intake box top
            const intakeTopX = intakeCenterX;
            const intakeTopY = intakeCenterY;
            
            const dx = intakeTopX - currentX;
            const dy = intakeTopY - currentY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Aim for the intake
            let launchVx = (dx / distance) * 30;
            let launchVy = (dy / distance) * 30 - 15; // Add upward arc
            let launchY = currentY;
            let launchX = currentX;
            let launchRot = currentAngle;
            let hasHitIntake = false;
            let bounces = 0;
            
            function animateLaunch() {
              launchY += launchVy;
              launchX += launchVx;
              launchVy += 1.5; // gravity
              launchRot += 0.15; // spin
              
              submitEngine.style.top = `${launchY}px`;
              submitEngine.style.left = `${launchX}px`;
              submitEngine.style.transform = `translate(-50%, -50%) rotate(${launchRot}rad)`;
              
              // Check collision with intake box (700px wide box centered at intakeCenterX)
              const intakeLeft = intakeCenterX - 350;
              const intakeRight = intakeCenterX + 350;
              const intakeTop = intakeCenterY;
              const intakeBottom = intakeCenterY + 200;
              
              if (!hasHitIntake && 
                  launchX > intakeLeft && launchX < intakeRight &&
                  launchY > intakeTop - 50 && launchY < intakeTop + 50) {
                // HIT THE INTAKE!
                hasHitIntake = true;
                bounces++;
                console.log('üí• Submit button HIT the intake box!');
                
                // Shake the entire intake system
                intakeSystem.classList.add('intake-shake');
                setTimeout(() => {
                  intakeSystem.classList.remove('intake-shake');
                  
                  // Collapse and drop the ENTIRE intake system
                  console.log('üíß Intake system collapsing and falling!');
                  intakeSystem.classList.add('intake-collapse');
                }, 400);
                
                // Bounce off with reduced velocity
                launchVy = -Math.abs(launchVy) * 0.6; // Bounce up
                launchVx *= 0.5; // Reduce horizontal speed
                
                // After bounce, trigger hinge effect during tile processing
                setTimeout(() => {
                  if (zapPhase === 1 || zapPhase === 2) { // During tile processing
                    console.log('üîß Compartmentalizer tilting on hinge as it processes!');
                    intakeSystem.classList.add('intake-hinge');
                  }
                }, 200);
          }
              
              // Remove if off screen or after multiple bounces
              if (launchY > intakeCenterY + 1000 || launchX < -500 || launchX > 20000) {
                submitEngine.remove();
                clearInterval(launchInterval);
                return;
              }
              requestAnimationFrame(animateLaunch);
            }
            
            requestAnimationFrame(animateLaunch);
          } else {
            // NORMAL MODE: Launch off screen
            let launchVy = -40;
            let launchVx = 20;
            let launchY = currentY;
            let launchX = currentX;
            let launchRot = currentAngle;
            
            function animateLaunch() {
              launchY += launchVy;
              launchX += launchVx;
              launchVy += 1.5; // gravity
              launchRot += 0.15; // spin
              
              submitEngine.style.top = `${launchY}px`;
              submitEngine.style.left = `${launchX}px`;
              submitEngine.style.transform = `translate(-50%, -50%) rotate(${launchRot}rad)`;
              
              if (launchY < -500) {
                submitEngine.remove();
                clearInterval(launchInterval);
                return;
              }
              requestAnimationFrame(animateLaunch);
            }
            
            requestAnimationFrame(animateLaunch);
          }
        }
      }
      
      requestAnimationFrame(animateSpring);
    }
    
    // === ENVIRONMENTAL PARTICLES ===
    let fireParticles = [];
    let snowParticles = [];
    let fireZoneActive = false;
    let snowZoneActive = false;
    let skullBoneParticles = [];
    let cloudParticles = [];
    let nostalgiaSitesActive = false;
    let nostalgiaSites = [];
    let nostalgiaGlitched = false;
    
    function createFireParticle(x, y) {
      return {
        x: x + (Math.random() - 0.5) * 160,
        y: y,
        vx: (Math.random() - 0.5) * 3,
        vy: -7 - Math.random() * 7,
        life: 1,
        size: 8 + Math.random() * 18,
        color: `hsl(${10 + Math.random() * 35}, 100%, ${45 + Math.random() * 25}%)`
      };
    }
    
    function createSnowParticle(x, y) {
      return {
        x: x + (Math.random() - 0.5) * 500,
        y: y - 700 - Math.random() * 700,
        vx: (Math.random() - 0.5) * 2,
        vy: 1.2 + Math.random() * 2.4,
        life: 1,
        size: 4 + Math.random() * 8,
        rotation: Math.random() * Math.PI * 2,
        rotationSpeed: (Math.random() - 0.5) * 0.12
      };
    }
    
    function createSkullBoneParticle(x, y, angle) {
      // Emit from rear (opposite direction of travel)
      const rearAngle = angle + Math.PI; // 180 degrees opposite
      const spreadAngle = rearAngle + (Math.random() - 0.5) * 0.8; // Cone spread
      const speed = 3 + Math.random() * 4;
      
      return {
        x: x + Math.cos(rearAngle) * 30, // Start 30px behind button
        y: y + Math.sin(rearAngle) * 30,
        vx: Math.cos(spreadAngle) * speed,
        vy: Math.sin(spreadAngle) * speed,
        life: 1,
        size: 16 + Math.random() * 8,
        emoji: Math.random() < 0.5 ? 'üíÄ' : 'ü¶¥',
        rotation: Math.random() * Math.PI * 2,
        rotationSpeed: (Math.random() - 0.5) * 0.2
      };
    }
    
    function createCloudParticle(x, y) {
      // Create pixelated cloud puff
      return {
        x: x + (Math.random() - 0.5) * 60,
        y: y + (Math.random() - 0.5) * 30,
        vx: (Math.random() - 0.5) * 1,
        vy: 0.5 + Math.random() * 1.5, // Drift downward slowly
        life: 1,
        size: 12 + Math.random() * 16, // Pixelated block size
        opacity: 0.7 + Math.random() * 0.3
      };
    }
    
    function createNostalgiaSite() {
      // Map to feature names that have site layouts
      const sites = [
        { name: 'HOPES', displayName: 'Neopets' },      // Neopets layout
        { name: 'PASSIONS', displayName: 'Newgrounds' }, // Newgrounds layout
        { name: 'JOYS', displayName: 'Miniclip' },       // Miniclip layout
        { name: 'GRATITUDE', displayName: 'Club Penguin' }, // Club Penguin layout
        { name: 'COURAGE', displayName: 'Addicting Games' }  // Addicting Games layout
      ];
      
      const site = sites[Math.floor(Math.random() * sites.length)];
      
      // Create fixed overlay element with site layout
      const viewport = document.getElementById('viewport');
      const el = document.createElement('div');
      el.style.position = 'fixed';
      el.style.width = '320px';
      el.style.height = '240px';
      el.style.border = '4px solid #000';
      el.style.borderRadius = '8px';
      el.style.zIndex = '250';
      el.style.overflow = 'hidden';
      el.style.boxShadow = '0 8px 32px rgba(0,0,0,0.6)';
      el.style.transition = 'all 0.3s ease-out';
      
      // Random starting position (off-screen)
      const side = Math.random() < 0.5 ? 'left' : 'right';
      const startY = 20 + Math.random() * (window.innerHeight - 280);
      
      if (side === 'left') {
        el.style.left = '-340px';
        el.style.top = `${startY}px`;
      } else {
        el.style.right = '-340px';
        el.style.top = `${startY}px`;
      }
      
      // Generate childhood site layout
      const siteLayout = generateChildhoodSiteLayout(site.name);
      if (siteLayout) {
        el.innerHTML = siteLayout;
      } else {
        // Fallback (shouldn't happen)
        el.innerHTML = `<div style="padding:20px;text-align:center;font-size:2rem;">${site.displayName}</div>`;
      }
      
      viewport.appendChild(el);
      
      // Slide in after a frame
      requestAnimationFrame(() => {
        if (side === 'left') {
          el.style.left = '20px';
        } else {
          el.style.right = '20px';
        }
      });
      
      return { el, side, originalSite: site, createdAt: performance.now() };
    }
    
    function glitchToProductivityTool(siteObj) {
      // Map to feature names that have site layouts (SaaS/productivity tools)
      const tools = [
        { name: 'ANXIETIES', displayName: 'Trello' }  // Trello layout
      ];
      
      const tool = tools[Math.floor(Math.random() * tools.length)];
      const el = siteObj.el;
      
      // Add glitch effect
      el.style.animation = 'boardGlitch 0.3s infinite';
      
      setTimeout(() => {
        // Update content to productivity tool site layout
        const toolLayout = generateChildhoodSiteLayout(tool.name);
        if (toolLayout) {
          el.innerHTML = toolLayout;
        } else {
          // Fallback
          el.innerHTML = `<div style="padding:20px;text-align:center;font-size:1.5rem;">${tool.displayName}</div>`;
        }
        el.style.animation = '';
        
        // Fade out after a moment
        setTimeout(() => {
          el.style.opacity = '0';
          setTimeout(() => {
            if (el.parentNode) el.remove();
          }, 300);
        }, 2000);
      }, 300);
    }
    
    let graveyardActive = false;
    function updateEnvironmentalParticles(dt) {
      // Track-anchored particles (skulls/clouds) still use particleCanvas, but fire/snow/sandfall use fxOverlay
      const particleCanvas = document.getElementById('particleCanvas');
      const fxCanvas = document.getElementById('fxOverlay');
      const grainCanvas = document.getElementById('grainOverlay');
      if (!particleCanvas || !fxCanvas || !grainCanvas) return;
      const particleCtx = particleCanvas.getContext('2d');
      const fxCtx = fxCanvas.getContext('2d');
      const grainCtx = grainCanvas.getContext('2d');
      
      // Set grain canvas size (fxCanvas already sized/cleared by updateParticles)
      grainCanvas.width = window.innerWidth;
      grainCanvas.height = window.innerHeight;
      
      // Clear canvases (EXCEPT fxCanvas which was already cleared by updateParticles)
      // CRITICAL: NEVER clear particleCtx during zapPhase 2 or 3
      const shouldClearParticles = !graveyardActive && (typeof zapPhase === 'undefined' || zapPhase < 2);
      if (Math.random() < 0.02) {
        console.log(`üßπ updateEnvironmentalParticles - zapPhase: ${zapPhase}, graveyardActive: ${graveyardActive}`);
        console.log(`   fxCanvas NOT cleared here (cleared by updateParticles), drawing fire/snow ON TOP of sandfall particles`);
      }
      if (shouldClearParticles) {
        particleCtx.clearRect(0, 0, particleCanvas.width, particleCanvas.height);
      }
      // DON'T clear fxCanvas here - updateParticles already cleared it and drew sandfall particles
      grainCtx.clearRect(0, 0, grainCanvas.width, grainCanvas.height);
      
      // Update fire particles on overlay
      fireParticles.forEach((p, i) => {
        p.x += p.vx;
        p.y += p.vy;
        p.vy -= 0.15; // upward acceleration (negative = up)
        p.vx *= 0.98; // slight friction
        p.life -= dt * 0.6;
        p.size *= 0.99; // shrink as it rises
        
        if (p.life > 0) {
          fxCtx.fillStyle = p.color;
          fxCtx.globalAlpha = p.life * 0.9;
          fxCtx.beginPath();
          fxCtx.arc(p.x, p.y, p.size / 2, 0, Math.PI * 2);
          fxCtx.fill();
        }
      });
      fireParticles = fireParticles.filter(p => p.life > 0);
      
      // Update snow particles on overlay
      snowParticles.forEach((p, i) => {
        p.x += p.vx;
        p.y += p.vy;
        p.rotation += p.rotationSpeed;
        p.life -= dt * 0.3;
        
        if (p.life > 0) {
          fxCtx.save();
          fxCtx.translate(p.x, p.y);
          fxCtx.rotate(p.rotation);
          fxCtx.fillStyle = '#fff';
          fxCtx.globalAlpha = p.life * 0.8;
          fxCtx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
          fxCtx.restore();
        }
      });
      snowParticles = snowParticles.filter(p => p.life > 0);
      
      // Update skull and bone particles (also handle custom gold sand points)
      skullBoneParticles.forEach((p, i) => {
        p.x += p.vx;
        p.y += p.vy;
        p.vx *= 0.98; // Slight friction
        p.vy += 0.3; // Gravity
        p.rotation += p.rotationSpeed;
        p.life -= dt * 0.5;
        
        if (p.life > 0) {
          if (p.emoji === '‚Ä¢') {
            // render gold sand dot
            particleCtx.fillStyle = p.color || '#d8b141';
            particleCtx.globalAlpha = Math.min(1, p.life * 1.2);
            particleCtx.beginPath();
            particleCtx.arc(p.x, p.y, p.size * 0.25, 0, Math.PI * 2);
            particleCtx.fill();
          } else {
            particleCtx.save();
            particleCtx.translate(p.x, p.y);
            particleCtx.rotate(p.rotation);
            particleCtx.font = `${p.size}px Arial`;
            particleCtx.globalAlpha = p.life * 0.9;
            particleCtx.textAlign = 'center';
            particleCtx.textBaseline = 'middle';
            particleCtx.fillText(p.emoji, 0, 0);
            particleCtx.restore();
          }
        }
      });
      skullBoneParticles = skullBoneParticles.filter(p => p.life > 0);
      
      // Update cloud particles (pixelated puffs)
      cloudParticles.forEach((p, i) => {
        p.x += p.vx;
        p.y += p.vy;
        p.vx *= 0.99; // Slight friction
        p.life -= dt * 0.4; // Slower fade
        
        if (p.life > 0) {
          // Draw pixelated cloud as rounded rectangles
          particleCtx.fillStyle = `rgba(255, 255, 255, ${p.opacity * p.life})`;
          particleCtx.fillRect(Math.floor(p.x), Math.floor(p.y), p.size, p.size);
        }
      });
      cloudParticles = cloudParticles.filter(p => p.life > 0);
      
      particleCtx.globalAlpha = 1;

      // Draw animated film grain
      const grainDensity = Math.floor((grainCanvas.width * grainCanvas.height) / 8000);
      const t = performance.now() * 0.001;
      for (let i = 0; i < grainDensity; i++) {
        const x = (Math.random() * grainCanvas.width) | 0;
        const y = (Math.random() * grainCanvas.height) | 0;
        const shade = 180 + Math.floor(Math.sin((x + y + t * 60) * 0.05) * 20);
        grainCtx.fillStyle = `rgba(${shade},${shade},${shade},0.25)`;
        grainCtx.fillRect(x, y, 1, 1);
      }
    }
    
    // === MAIN ANIMATION ===
    let lastTime = performance.now();
    let audioFrameCount = 0;
    
    function animate(now) {
      const dt = Math.min(0.033, (now - lastTime) / 1000);
      lastTime = now;
      
      if (zapPhase < 2) {
        // Train animation with CONTINUOUS ACCELERATION
        const pos = getPathPosAndTangent(engineDistance);
        
        // Audio reactive track for bonus mode
        if (isBonusMode) {
          audioFrameCount++;
          
          // Update track every few frames for performance
          if (audioFrameCount % 2 === 0) {
            if (audioAnalyser && audioDataArray) {
              // Get frequency data
              audioAnalyser.getByteFrequencyData(audioDataArray);
              
              // Calculate average bass, mid, and treble
              const bassRange = Math.floor(audioBufferLength * 0.15);
              const midRange = Math.floor(audioBufferLength * 0.5);
              
              let bassSum = 0, midSum = 0, trebleSum = 0;
              for (let i = 0; i < bassRange; i++) bassSum += audioDataArray[i];
              for (let i = bassRange; i < midRange; i++) midSum += audioDataArray[i];
              for (let i = midRange; i < audioBufferLength; i++) trebleSum += audioDataArray[i];
              
              const bass = bassSum / bassRange / 255;
              const mid = midSum / (midRange - bassRange) / 255;
              const treble = trebleSum / (audioBufferLength - midRange) / 255;
              
              // Modulate control points based on audio
              controlPoints = baseControlPoints.map((p, i) => {
                // Use different frequency ranges for different sections
                const sectionRatio = i / baseControlPoints.length;
                let modulation = 0;
                
                if (sectionRatio < 0.33) {
                  // Early track reacts to bass
                  modulation = bass * 80;
                } else if (sectionRatio < 0.66) {
                  // Middle track reacts to mids
                  modulation = mid * 60;
                } else {
                  // Late track reacts to treble
                  modulation = treble * 40;
                }
                
                // Add some wave motion
                const wave = Math.sin(now * 0.001 + i * 0.5) * 20;
                
                return {
                  x: p.x,
                  y: p.y + modulation + wave
                };
              });
              
              // Rebuild path for physics
              trackPath = rebuildTrackPath(controlPoints);
            }
            
            // ALWAYS redraw track with camera position for dynamic bone rendering
            drawTrack(controlPoints, pos.x);
            
            // Draw typing text on track canvas in bonus mode
            if (window.typingText) {
              drawTypingText(trackCtx, trackCanvas.width, trackCanvas.height);
            }
          }
        }
        
        // DYNAMIC acceleration - responsive to slope changes!
        if (pos.slope > 0.05) {
          // Downhill - DYNAMIC acceleration based on slope steepness
          downhillTime += dt;
          
          // Progressive multiplier builds up faster for steeper slopes
          const slopeIntensity = Math.min(pos.slope * 2, 1.5); // Steeper = faster buildup
          const progressiveMultiplier = 1 + Math.min(downhillTime * slopeIntensity, 4.0); // Up to 5x!
          
          // Boost scales with both slope and progressive multiplier
          const boost = pos.slope * gravityAccel * dt * 100 * progressiveMultiplier;
          velocity += boost;
          
          // Extra burst on VERY steep sections
          if (pos.slope > 0.3) {
            velocity += pos.slope * dt * 50;
          }
        } else if (pos.slope < -0.05) {
          // Uphill - GENTLE slowdown, maintain momentum!
          const uphillResistance = Math.abs(pos.slope) * 0.5; // REDUCED resistance
          velocity *= (0.98 - uphillResistance * 0.02); // Much less slowdown
          downhillTime = Math.max(0, downhillTime - dt * 1.5); // Slower decay
        } else {
          // Flat - maintain most speed but slowly decay boost
          velocity *= 0.995; // Very gentle slowdown on flat
          downhillTime = Math.max(0, downhillTime - dt * 0.3);
        }
        
        // Dramatic braking only at halt zone
        if (haltingPhase) {
          velocity *= 0.85; // Strong braking when halting
        }
        
        // Clamp velocity with high max, reasonable minimum
        velocity = Math.min(maxSpeed, velocity);
        velocity = Math.max(baseSpeed * 0.6, velocity);
        
        // Log velocity at intervals for debugging
        if (Math.random() < 0.01) {
          console.log(`üèéÔ∏è Speed: ${velocity.toFixed(1)}x | Slope: ${pos.slope.toFixed(2)}`);
        }
        
        engineDistance += velocity * 60 * dt;
        
        // DYNAMIC camera shake scales with velocity
        const shake = velocity > 10 ? (velocity - 10) * 0.8 : 0; // More intense shake at high speed
        
        // Trigger environmental particles in bonus mode
        if (isBonusMode) {
          const viewport = document.getElementById('viewport');
          const scene = document.getElementById('scene');
          const sceneRect = scene.getBoundingClientRect();
          const viewportRect = viewport.getBoundingClientRect();
          
          // Calculate viewport edges in scene coordinates
          const viewportBottomInScene = -sceneRect.top + viewportRect.height;
          const viewportTopInScene = -sceneRect.top;
          
          // Fire zone (make it last longer: x:8800-10000)
          if (pos.x >= 8800 && pos.x <= 10000) {
            if (!fireZoneActive) {
              fireZoneActive = true;
              console.log('üî• Entering FIRE ZONE!');
            }
            // Generate fire particles at screen position just behind engine
            const behindX = (window.innerWidth / 2) - Math.cos(pos.angle) * 60;
            const behindY = (window.innerHeight / 2) - Math.sin(pos.angle) * 60 + 50;
            for (let i = 0; i < 16; i++) fireParticles.push(createFireParticle(behindX, behindY));
          } else if (fireZoneActive) {
            fireZoneActive = false;
            console.log('üî• Exiting fire zone');
          }
          
          // Nostalgia site zone (between fire and snow: x:10000-10500)
          if (pos.x >= 10000 && pos.x <= 10500) {
            if (!nostalgiaSitesActive) {
              nostalgiaSitesActive = true;
              nostalgiaGlitched = false;
              console.log('üéÆ Entering NOSTALGIA ZONE!');
              
              // Create 3-4 nostalgia sites staggered
              for (let i = 0; i < 3 + Math.floor(Math.random() * 2); i++) {
                setTimeout(() => {
                  const site = createNostalgiaSite();
                  nostalgiaSites.push(site);
                }, i * 800);
              }
            }
            
            // Glitch sites into productivity tools after 3 seconds
            if (!nostalgiaGlitched && performance.now() - (nostalgiaSites[0]?.createdAt || 0) > 3000) {
              nostalgiaGlitched = true;
              console.log('‚ö° GLITCHING nostalgia sites into productivity tools!');
              nostalgiaSites.forEach((site, i) => {
                setTimeout(() => {
                  glitchToProductivityTool(site);
                }, i * 400);
              });
            }
          } else if (nostalgiaSitesActive && pos.x > 10500) {
            nostalgiaSitesActive = false;
            console.log('üéÆ Exiting nostalgia zone');
            // Clean up any remaining sites
            nostalgiaSites.forEach(site => {
              if (site.el && site.el.parentNode) {
                site.el.style.opacity = '0';
                setTimeout(() => {
                  if (site.el.parentNode) site.el.remove();
                }, 300);
              }
            });
            nostalgiaSites = [];
          }
          
          // Snow zone (start earlier and last longer: x:10500-13500)
          if (pos.x >= 10500 && pos.x <= 13500) {
            if (!snowZoneActive) {
              snowZoneActive = true;
              console.log('‚ùÑÔ∏è Entering SNOW ZONE!');
            }
            // Generate snow particles above and slightly behind engine
            const aboveX = (window.innerWidth / 2) - Math.cos(pos.angle) * 40;
            const aboveY = (window.innerHeight / 2) - 160;
            for (let i = 0; i < 14; i++) snowParticles.push(createSnowParticle(aboveX, aboveY));
          } else if (snowZoneActive) {
            snowZoneActive = false;
            console.log('‚ùÑÔ∏è Exiting snow zone');
          }
        }
        
        // Emit skull and bone particles when going downhill at speed (BONUS MODE)
        if (isBonusMode && pos.slope > 0.15 && velocity > 15) {
          // High speed downhill = emit from rear!
          if (Math.random() < 0.3) { // 30% chance per frame
            skullBoneParticles.push(createSkullBoneParticle(pos.x, pos.y, pos.angle));
          }
        }
        
        // Check if in jump zone and apply FLIP animation!
        const wasInJumpZone = inJumpZone;
        inJumpZone = (pos.x >= jumpZoneStartX && pos.x <= jumpZoneEndX);
        
        if (inJumpZone) {
          // CINEMATIC FLIP during jump!
          if (!wasInJumpZone) {
            console.log('üé¨ JUMP! Starting flip animation!');
            jumpFlipRotation = 0;
          }
          // Smooth 360¬∞ flip over the jump
          const jumpProgress = (pos.x - jumpZoneStartX) / (jumpZoneEndX - jumpZoneStartX);
          jumpFlipRotation = jumpProgress * Math.PI * 2; // Full rotation
          
          // Position with flip
          submitEngine.style.left = `${pos.x + (Math.random() - 0.5) * shake}px`;
          submitEngine.style.top = `${pos.y + (Math.random() - 0.5) * shake}px`;
          submitEngine.style.transform = `translate(-50%, -50%) rotate(${pos.angle}rad) rotateY(${jumpFlipRotation}rad)`;
          submitEngine.style.transformStyle = 'preserve-3d';
        } else {
          // Normal positioning
          if (wasInJumpZone) {
            console.log('üé¨ LANDING! Flip complete!');
            submitEngine.style.transformStyle = '';
          }
          positionCar(submitEngine, {
            x: pos.x + (Math.random() - 0.5) * shake,
            y: pos.y + (Math.random() - 0.5) * shake,
            angle: pos.angle
          });

          // Shed skull/bone particles from engine (submit train only)
          if (isBonusMode && (pos.x > 8800) && Math.random() < 0.25) {
            skullBoneParticles.push(createSkullBoneParticle(pos.x, pos.y, pos.angle));
          }
        }
        
        // Add speed blur effect at high velocity (more responsive)
        if (velocity > 15) {
          submitEngine.classList.add('speed-blur');
        } else {
          submitEngine.classList.remove('speed-blur');
        }
        
        // Get viewport bounds for cloud detection
        let sceneEl = document.getElementById('scene');
        let viewportEl = document.getElementById('viewport');
        let sceneRect = sceneEl.getBoundingClientRect();
        let viewportRect = viewportEl.getBoundingClientRect();
        let viewportBottomInScene = -sceneRect.top + viewportRect.height;
        
        // Spawn clouds if submit button goes off bottom of visible viewport OR on upward climbs
        if (pos.y > viewportBottomInScene + 100) {
          // Spawn pixelated clouds beneath submit button
          if (Math.random() < 0.2) { // 20% chance per frame
            for (let j = 0; j < 4; j++) {
              cloudParticles.push(createCloudParticle(pos.x, viewportBottomInScene));
            }
          }
        }
        
        // Spawn clouds during upward climbs (negative slope)
        if (pos.slope < -0.1 && velocity > 5) {
          // Spawn clouds beneath train on climbs
          if (Math.random() < 0.25) { // stronger presence
            for (let j = 0; j < 6; j++) {
              cloudParticles.push(createCloudParticle(pos.x, pos.y + 100));
            }
          }
        }
        
        // Position feature cars with GENEROUS SPACING
        const carSpacing = 180;  // Increased to 180 for better visual separation
        
        trainCars.forEach((car, i) => {
          if (car.collected) return;
          
          const carDist = engineDistance - (i + 1) * carSpacing;
          if (carDist > 0) {
            const carPos = getPathPosAndTangent(carDist);
            
            // Add subtle shake to trailing cars too at high speed
            const carShake = velocity > 10 ? (velocity - 10) * 0.5 : 0;
            positionCar(car.el, {
              x: carPos.x + (Math.random() - 0.5) * carShake,
              y: carPos.y + (Math.random() - 0.5) * carShake,
              angle: carPos.angle
            });
            
            // Apply speed blur to cars at high speed
            if (velocity > 15) {
              car.el.classList.add('speed-blur');
            } else {
              car.el.classList.remove('speed-blur');
            }

            // Shed bone/skull particles from cars (submit train only)
            if (isBonusMode && Math.random() < 0.08) {
              skullBoneParticles.push(createSkullBoneParticle(carPos.x, carPos.y, carPos.angle));
            }
            
            // Spawn clouds if car goes off bottom of visible viewport
            if (carPos.y > viewportBottomInScene + 100) {
              // Spawn pixelated clouds beneath car
              if (Math.random() < 0.15) { // 15% chance per frame
                for (let j = 0; j < 3; j++) {
                  cloudParticles.push(createCloudParticle(carPos.x, viewportBottomInScene));
                }
              }
            }
            
            // Collect at drop zone (near the end where intake is)
            // Adjust threshold dynamically based on train length to prevent submit from jumping too far
            const trainLength = trainCars.length;
            const baseThreshold = 0.78;
            // For longer trains, start collecting earlier to ensure all cars get collected
            const adjustedThreshold = baseThreshold - (trainLength > 10 ? (trainLength - 10) * 0.01 : 0);
            const collectThreshold = pathLength * Math.max(0.70, adjustedThreshold);
            if (carDist >= collectThreshold) {
              collectItem(car, i);
            }
          }
        });
        
        // Show intake when collecting starts
        if (collectedCount > 0 && !intakeSystem.classList.contains('visible')) {
          intakeSystem.classList.add('visible');
        }
        
        // Launch submit after all collected
        if (allCollected && !submitLaunched && zapPhase === 0) {
          launchSubmitButton();
        }
        
        // Camera follow (reuse scene/viewport from above)
        const vw = viewportEl.clientWidth;
        const vh = viewportEl.clientHeight;
        
        let targetX, targetY;
        
        if (haltingPhase || collectedCount > 0) {
          // Center on intake when stopping/collecting
          targetX = vw / 2 - intakeCenterX;
          targetY = vh / 2 - intakeCenterY;
        } else {
          // Follow train
          targetX = vw / 2 - pos.x;
          targetY = vh / 2 - pos.y + 100;
        }
        
        sceneEl.style.transition = 'transform 0.5s ease-out';
        sceneEl.style.transform = `translate(${targetX}px, ${targetY}px)`;
      }
      
      // Update falling tiles (continue during zapPhase 1 AND 2 until all tiles convert)
      if ((zapPhase === 1 || zapPhase === 2) && fallingTiles.length > 0 && tilesConvertedToParticles < TOTAL_FEATURES) {
        // Track when zapPhase 1 started
        if (!window.zapPhase1StartTime) {
          window.zapPhase1StartTime = performance.now();
          console.log(`‚è¨ ZapPhase 1 STARTED - ${TOTAL_FEATURES} features expected, ${fallingTiles.length} tiles in array`);
          fallingTiles.forEach((tile, i) => {
            console.log(`   Tile ${i}: ${tile.feature.name} | StartTime: ${tile.startTime} | Index: ${tile.index}`);
          });
        }
        
        updateFallingTiles(dt);
        
        // Debug tile count occasionally
        if (Math.random() < 0.02) {
          const stillFalling = fallingTiles.filter(t => !t.inFunnel).length;
          console.log(`‚è¨ ZapPhase ${zapPhase}: ${stillFalling} tiles still falling | Converted: ${tilesConvertedToParticles}/${TOTAL_FEATURES}`);
        }
        
        const zapPhase1Elapsed = performance.now() - window.zapPhase1StartTime;
        
        // SUPER AGGRESSIVE: Force-convert any remaining tiles after just 3 seconds
        if (zapPhase1Elapsed > 3000 && tilesConvertedToParticles < TOTAL_FEATURES) {
          const unconverted = fallingTiles.filter(t => !t.inFunnel && !t.hasBurst);
          if (unconverted.length > 0) {
            console.log(`üö®üö®üö® FORCE CONVERTING ${unconverted.length} stuck tiles after ${(zapPhase1Elapsed/1000).toFixed(1)}s`);
            console.log(`Converted so far: ${tilesConvertedToParticles}/${TOTAL_FEATURES}`);
            unconverted.forEach((tile) => {
              if (!tile.inFunnel && !tile.hasBurst) {
                tile.inFunnel = true;
                console.log(`   üîß Force-burst #${tile.index}: ${tile.feature.name}`);
                burstTileIntoParticles(tile, tile.index);
              }
            });
          }
        }
        
        // NUCLEAR option: After 5 seconds, convert EVERYTHING regardless
        if (zapPhase1Elapsed > 5000 && tilesConvertedToParticles < TOTAL_FEATURES) {
          console.log(`‚ò¢Ô∏è‚ò¢Ô∏è‚ò¢Ô∏è NUCLEAR FAILSAFE at ${(zapPhase1Elapsed/1000).toFixed(1)}s - Converting ALL ${fallingTiles.length} tiles`);
          console.log(`Current conversion status: ${tilesConvertedToParticles}/${TOTAL_FEATURES}`);
          fallingTiles.forEach((tile) => {
            if (!tile.hasBurst) {
              tile.inFunnel = true;
              tile.hasBurst = true;
              console.log(`   ‚ò¢Ô∏è Nuclear #${tile.index}: ${tile.feature.name}`);
              burstTileIntoParticles(tile, tile.index);
            }
          });
          console.log(`After nuclear: ${tilesConvertedToParticles}/${TOTAL_FEATURES} converted`);
        }
      }
      
      // Update particles
      if (zapPhase === 2) {
        if (!window.burstStartTime) {
          window.burstStartTime = performance.now();
          console.log(`üéÜ ZapPhase 2: Particle animation started with ${particles.length} particles`);
          console.log(`   üìç Rendering sandfall particles to fxOverlay (fixed viewport overlay)`);
        }
        updateParticles(dt);
        
        // Periodic status update
        if (Math.random() < 0.01) {
          console.log(`üìä Status: ${tilesConvertedToParticles}/${TOTAL_FEATURES} tiles ‚Üí particles | ${cardsFullyMaterialized}/${TOTAL_FEATURES} cards materialized | ${particles.length} particles active`);
        }
      }
      
      // Update environmental particles (fire/snow/skull-bones/clouds) and film grain every frame
      updateEnvironmentalParticles(dt);
      
      // Trigger Assigna bloom after fire zone while climbing (guard against missing pos)
      try {
        const assignaCanvasEl = document.getElementById('assignaCanvas');
        if (assignaCanvasEl && typeof pos === 'object') {
          if (isBonusMode && pos.x > 10000 && pos.slope < -0.05) {
            assignaCanvasEl.classList.add('bloom');
          } else if (!isBonusMode || pos.x < 8800) {
            assignaCanvasEl.classList.remove('bloom');
          }
        }
      } catch (e) {
        // no-op; happens during initial frames before pos exists
      }
      
      // Butterfly tracking is now handled by trackButterfliesUpward() function
      // This prevents camera snapping issues
      
      requestAnimationFrame(animate);
    }
    
    // Initialize typing animation for bonus mode (starts immediately)
    if (isBonusMode) {
      window.typingText = '';
      window.typingCharIndex = 0;
      startTypingAnimation();
    }

    // Debug jump handler
    (function attachDebugJump(){
      const btn = document.getElementById('debugJump');
      if (!btn) return;
      btn.addEventListener('click', () => {
        try {
          // Place engine near start of the very lengthy steep descent (bonus track ~ x:7700)
          const targetX = isBonusMode ? 8000 : Math.floor(trackPath.length * 0.7);
          // Convert approximate x to distance by scanning path
          let bestDist = 0, bestDiff = Infinity;
          let distAccum = 0;
          for (let i = 0; i < trackPath.length - 1; i++) {
            const p = trackPath[i];
            const q = trackPath[i+1];
            const segLen = Math.hypot(q.x - p.x, q.y - p.y);
            const diff = Math.abs(p.x - targetX);
            if (diff < bestDiff) { bestDiff = diff; bestDist = distAccum; }
            distAccum += segLen;
          }
          engineDistance = bestDist;
          console.log('üêõ Debug jump: engineDistance', engineDistance);
        } catch (e) {
          console.warn('Debug jump failed', e);
        }
      });
    })();

    // Debug graveyard handler
    (function attachDebugGraveyard(){
      const btn = document.getElementById('debugGraveyard');
      if (!btn) return;
      btn.addEventListener('click', () => {
        try {
          showGraveyard();
        } catch (e) {
          console.warn('Debug graveyard failed', e);
        }
      });
    })();
    
    // === START ===
    setTimeout(() => {
      console.log('‚ñ∂Ô∏è RELEASE TRAIN DEPARTING!');
      
      // Load correct audio based on mode
      const audio = document.getElementById('trainAudio');
      const audioFile = isBonusMode ? 'train2.mp3' : 'train.mp3';
      const audioPaths = [`../../${audioFile}`, `../${audioFile}`, audioFile];
      
      let sourceIdx = 0;
      const tryAudio = () => {
        if (sourceIdx < audioPaths.length) {
          audio.src = audioPaths[sourceIdx];
          audio.load();
          audio.volume = 0.5;
          audio.play().then(() => {
            // Connect audio to analyzer for reactive track
            if (isBonusMode && audioContext && audioAnalyser) {
              try {
                const source = audioContext.createMediaElementSource(audio);
                source.connect(audioAnalyser);
                audioAnalyser.connect(audioContext.destination);
                console.log('üéµ Audio connected to analyzer');
              } catch (e) {
                console.warn('Could not connect audio to analyzer:', e);
              }
            }
          }).catch(e => {
            console.log(`Audio path ${audioPaths[sourceIdx]} failed, trying next...`);
            sourceIdx++;
            tryAudio();
          });
        } else {
          console.log('All audio paths failed');
        }
      };
      tryAudio();
      
      setTimeout(() => {
        document.getElementById('titleOverlay').classList.add('hidden');
      }, 1800);
      
      requestAnimationFrame(animate);
    }, 800);
  </script>
</body>
</html>
