<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="utf-8" />
 <meta name="viewport" content="width=device-width, initial-scale=1" />
 <title>Three.js Integrated Scene Voxel Hand + Keyboard + Character</title>
 <!-- MODE_PLACEHOLDER -->
 <!--
 INTEGRATED SCENE:
 1. cursor.html - Voxel hand creation with 96px high-res capture and progressive build animation
 2. fullhand.html (original) - Retro keyboard with god rays, atmospheric dust, and realistic keys
 3. bust.html - Character bust with ZSphere-based hourglass figure and posing tools
 4. bosscelli.html - Glowing voxel animated head with face cutouts (eyes/smile)
 
 FLOW:
 - Scene starts blank
 - Voxel hand creation sequence (from cursor.html)
 - Once complete, reveals full keyboard scene
 - Character bust positioned beside keyboard at human scale
 - Glowing voxel head above character's upper body
 - Debug menu provides quick navigation between scene elements
 - Edit mode allows posing character with transform gizmos
 -->
 <style>
 html, body { height: 100%; margin: 0; background:#0a0a0a; overflow:hidden; }
 #app { position: fixed; inset: 0; }
 
 /* Debug Menu */
 #debug-menu { 
 position: fixed; top: 20px; right: 20px; 
 background: rgba(20,20,24,0.95); 
 backdrop-filter: blur(10px);
 padding: 16px; 
 border: 1px solid #333; 
 border-radius: 10px; 
 color: #ddd;
 font: 13px/1.4 system-ui, Arial;
 min-width: 200px;
 z-index: 100;
 }
 #debug-menu h3 { margin: 0 0 12px 0; font-size: 15px; color: #fff; }
 #debug-menu button {
 width: 100%;
 padding: 10px;
 margin: 6px 0;
 background: #2a2a2f;
 border: 1px solid #444;
 color: #ddd;
 border-radius: 6px;
 cursor: pointer;
 font-size: 13px;
 transition: all 0.2s;
 }
 #debug-menu button:hover { background: #3a3a44; border-color: #555; }
 #debug-menu button:active { background: #4a4a54; }
 #debug-menu.minimized { display: none; }
 
 /* Minimize button on debug menu */
 #debug-menu-minimize {
 position: absolute;
 top: 10px;
 left: 10px;
 width: 24px;
 height: 24px;
 border-radius: 50%;
 background: #ff4a4a;
 border: 2px solid #ff6a6a;
 cursor: pointer;
 display: flex;
 align-items: center;
 justify-content: center;
 font-size: 14px;
 color: #fff;
 font-weight: bold;
 transition: all 0.2s;
 z-index: 10;
 }
 #debug-menu-minimize:hover {
 background: #ff6a6a;
 transform: scale(1.1);
 }
 
 /* Restore button (appears when minimized) */
 #debug-menu-restore {
 position: fixed;
 top: 20px;
 right: 20px;
 width: 50px;
 height: 50px;
 border-radius: 50%;
 background: rgba(74, 124, 255, 0.9);
 border: 2px solid #6a9cff;
 backdrop-filter: blur(10px);
 cursor: pointer;
 display: none;
 align-items: center;
 justify-content: center;
 font-size: 24px;
 color: #fff;
 transition: all 0.2s;
 z-index: 100;
 box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
 }
 #debug-menu-restore:hover {
 background: rgba(106, 156, 255, 1);
 transform: scale(1.1);
 }
 #debug-menu-restore.visible {
 display: flex;
 }
 
 .gizmo-toolbar { 
 position: fixed; top: 20px; left: 20px; 
 display: none; /* Hidden initially */
 gap: 8px; 
 z-index: 90;
 }
 .gizmo-btn { 
 width: 44px; height: 44px; 
 background: #1e2328; 
 border: 2px solid #3a4149; 
 border-radius: 6px; 
 cursor: pointer; 
 display: flex; 
 align-items: center; 
 justify-content: center; 
 font-size: 20px; 
 transition: all .2s; 
 user-select: none; 
 }
 .gizmo-btn:hover { background: #2a3138; border-color: #5a6169; }
 .gizmo-btn.active { background: #4a7cff; border-color: #6a9cff; }
 
 #loading-overlay {
  position: fixed;
  inset: 0;
  background: #0a0a0a;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #eaeaf2;
  font: 16px/1.4 system-ui;
  z-index: 1000;
  transition: opacity 0.5s;
 }
 #loading-overlay.hidden { opacity: 0; pointer-events: none; }

 .status-text { text-align: center; }
 .status-text .spinner {
  width: 40px;
  height: 40px;
  border: 3px solid #333;
  border-top-color: #4a7cff;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin: 0 auto 20px;
 }
 @keyframes spin { to { transform: rotate(360deg); } }

 /* Prototype Overlay Stack */
 .prototype-overlay {
  position: fixed;
  left: 24px;
  bottom: 24px;
  display: flex;
  flex-direction: column;
  gap: 12px;
  max-width: 320px;
  z-index: 220;
  pointer-events: none;
 }
 .prototype-overlay .prototype-card {
  pointer-events: auto;
  background: rgba(18, 20, 32, 0.9);
  border: 1px solid rgba(90, 130, 255, 0.3);
  border-radius: 16px;
  padding: 18px 20px;
  color: #ecf1ff;
  font: 13px/1.6 "Inter", system-ui, sans-serif;
  box-shadow: 0 18px 40px rgba(10, 14, 40, 0.45);
  backdrop-filter: blur(18px);
  opacity: 0;
  transform: translateY(12px) scale(0.98);
  transition: opacity 0.6s ease, transform 0.6s ease, box-shadow 0.3s ease;
 }
 .prototype-overlay .prototype-card.visible {
  opacity: 1;
  transform: translateY(0) scale(1);
 }
 .prototype-overlay .prototype-card header {
  font-size: 15px;
  font-weight: 600;
  letter-spacing: 0.02em;
  margin-bottom: 10px;
  display: flex;
  align-items: center;
  gap: 8px;
 }
 .prototype-overlay .prototype-card header span {
  display: inline-flex;
  width: 24px;
  height: 24px;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  background: rgba(90, 130, 255, 0.15);
  border: 1px solid rgba(90, 130, 255, 0.35);
  font-size: 12px;
 }
 .prototype-overlay .prototype-card p {
  margin: 0 0 12px 0;
  color: #bfc6ff;
 }
 .prototype-overlay .prototype-card ul {
  margin: 0 0 12px 16px;
  padding: 0;
  color: #ced5ff;
 }
 .prototype-overlay button {
  background: linear-gradient(135deg, rgba(90, 130, 255, 0.85), rgba(120, 150, 255, 0.75));
  border: 1px solid rgba(120, 160, 255, 0.5);
  color: #0b0d18;
  font-weight: 600;
  padding: 8px 14px;
  border-radius: 999px;
  cursor: pointer;
  transition: transform 0.2s ease, box-shadow 0.2s ease;
 }
 .prototype-overlay button:hover {
  transform: translateY(-1px);
  box-shadow: 0 6px 20px rgba(90, 130, 255, 0.35);
 }
 .prototype-overlay button:active {
  transform: translateY(0);
 }
 .prototype-overlay .prototype-card.spotlight {
  box-shadow: 0 22px 50px rgba(140, 180, 255, 0.6);
  border-color: rgba(160, 195, 255, 0.8);
 }
 .prototype-overlay pre {
  margin: 0;
  background: rgba(8, 10, 18, 0.9);
  border: 1px solid rgba(90, 130, 255, 0.25);
  border-radius: 12px;
  padding: 12px 14px;
  color: #9de4ff;
  font-family: "Fira Code", "Courier New", monospace;
  font-size: 11px;
  letter-spacing: 0.08em;
  line-height: 1.3;
  box-shadow: inset 0 0 0 1px rgba(90, 130, 255, 0.1);
 }
 .prototype-overlay .prototype-timeline {
  pointer-events: none;
  background: rgba(12, 14, 24, 0.92);
  border: 1px solid rgba(60, 90, 180, 0.35);
  border-radius: 12px;
  padding: 12px 16px;
  color: #9cabff;
  font: 12px/1.4 "Inter", system-ui;
  box-shadow: 0 14px 30px rgba(8, 12, 30, 0.4);
 }
 .prototype-overlay .prototype-timeline-bar {
  margin-top: 8px;
  width: 100%;
  height: 4px;
  background: rgba(32, 38, 70, 0.7);
  border-radius: 999px;
  overflow: hidden;
 }
 .prototype-overlay .prototype-timeline-progress {
  width: 0%;
  height: 100%;
  background: linear-gradient(90deg, rgba(90, 130, 255, 0.4), rgba(180, 220, 255, 0.85));
  transition: width 0.5s ease;
 }
 .prototype-overlay .media-control {
  display: flex;
  align-items: center;
  gap: 10px;
  flex-wrap: wrap;
 }
 .prototype-overlay .media-control span {
  font-size: 12px;
  color: rgba(200, 210, 255, 0.85);
 }
 .prototype-overlay video {
  width: 100%;
  border-radius: 12px;
  margin-top: 12px;
  border: 1px solid rgba(90, 130, 255, 0.25);
  background: rgba(8, 10, 18, 0.8);
 }
 .prototype-overlay .prototype-footnote {
  margin-top: 10px;
  font-size: 11px;
  color: rgba(180, 195, 255, 0.75);
 }
 @media (max-width: 900px) {
  .prototype-overlay {
   left: 16px;
   right: 16px;
   bottom: 16px;
   max-width: none;
  }
 }
 @media (prefers-reduced-motion: reduce) {
  .prototype-overlay .prototype-card {
   transition: none;
  }
  .prototype-overlay .prototype-timeline-progress {
   transition: none;
  }
 }

 /* Modal Windows */
 .modal-window {
 position: fixed;
 background: rgba(20,20,24,0.98);
 backdrop-filter: blur(15px);
 border: 1px solid #444;
 border-radius: 12px;
 color: #ddd;
 font: 13px/1.4 system-ui, Arial;
 box-shadow: 0 10px 40px rgba(0,0,0,0.5);
 z-index: 200;
 display: none;
 }
 .modal-window.active { display: block; }
 .modal-header {
 padding: 16px;
 border-bottom: 1px solid #333;
 display: flex;
 justify-content: space-between;
 align-items: center;
 cursor: move;
 user-select: none;
 }
 .modal-header h3 { margin: 0; font-size: 15px; color: #fff; }
 .modal-close {
 background: #2a2a2f;
 border: 1px solid #444;
 color: #ddd;
 width: 24px;
 height: 24px;
 border-radius: 4px;
 cursor: pointer;
 display: flex;
 align-items: center;
 justify-content: center;
 font-size: 16px;
 line-height: 1;
 }
 .modal-close:hover { background: #3a3a44; }
 .modal-body {
 padding: 16px;
 max-height: 70vh;
 overflow-y: auto;
 }
 .modal-footer {
 padding: 16px;
 border-top: 1px solid #333;
 display: flex;
 gap: 8px;
 justify-content: flex-end;
 }
 .modal-btn {
 padding: 8px 16px;
 background: #2a2a2f;
 border: 1px solid #444;
 color: #ddd;
 border-radius: 6px;
 cursor: pointer;
 font-size: 13px;
 transition: all 0.2s;
 }
 .modal-btn:hover { background: #3a3a44; border-color: #555; }
 .modal-btn.primary { background: #4a7cff; border-color: #6a9cff; }
 .modal-btn.primary:hover { background: #5a8cff; }
 
 .form-group {
 margin-bottom: 16px;
 }
 .form-group label {
 display: block;
 margin-bottom: 6px;
 color: #aaa;
 font-size: 12px;
 }
 .form-group input, .form-group select {
 width: 100%;
 padding: 8px;
 background: #1a1a1f;
 border: 1px solid #444;
 color: #ddd;
 border-radius: 4px;
 font-size: 13px;
 box-sizing: border-box;
 }
 .form-group input:focus, .form-group select:focus {
 outline: none;
 border-color: #4a7cff;
 }
 
 #scene-browser-modal {
 top: 80px;
 left: 20px;
 width: 300px;
 }
 #edit-head-modal {
 top: 50%;
 left: 50%;
 transform: translate(-50%, -50%);
 width: 400px;
 }
 #save-config-modal {
 top: 50%;
 left: 50%;
 transform: translate(-50%, -50%);
 width: 350px;
 }
 #config-report-modal {
 top: 50%;
 left: 50%;
 transform: translate(-50%, -50%);
 width: 500px;
 max-height: 80vh;
 }
 
 .hierarchy-item {
 padding: 8px;
 margin: 4px 0;
 background: #1a1a1f;
 border: 1px solid #333;
 border-radius: 4px;
 cursor: pointer;
 transition: all 0.2s;
 }
 .hierarchy-item:hover {
 background: #2a2a2f;
 border-color: #4a7cff;
 }
 .hierarchy-item.selected {
 background: #4a7cff;
 border-color: #6a9cff;
 }
 
 /* Dialogue System */
 #narrative-dialogue {
 position: fixed;
 bottom: 80px;
 left: 50%;
 transform: translateX(-50%);
 max-width: 600px;
 width: 85%;
 padding: 20px 30px;
 background: rgba(20, 20, 24, 0.92);
 backdrop-filter: blur(15px);
 border: 1px solid rgba(138, 180, 255, 0.3);
 border-radius: 12px;
 color: #e6e6e6;
 font-family: ui-sans-serif, system-ui, sans-serif;
 font-size: 16px;
 line-height: 1.6;
 text-align: center;
 opacity: 0;
 pointer-events: none;
 transition: opacity 0.8s ease, transform 0.8s ease;
 z-index: 200;
 box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), 0 0 80px rgba(138, 180, 255, 0.15);
 }
 
 #narrative-dialogue.active {
 opacity: 1;
 pointer-events: auto;
 transform: translateX(-50%) translateY(0);
 }
 
 #narrative-dialogue .dialogue-text {
 margin: 0;
 font-style: italic;
 }
 
 #narrative-dialogue .dialogue-text strong {
 color: #8ab4ff;
 font-weight: 600;
 }

/* ===== ZEKE PORTAL STYLES ===== */
#sheet-stream {
  position: fixed;
  left: -99999px;
  top: 0;
  width: 640px;
  background: white;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Arial, sans-serif;
  pointer-events: none;
  z-index: -1;
  visibility: hidden;
}

.zeke-message {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(18, 24, 38, 0.95);
  border: 2px solid rgba(188, 217, 255, 0.6);
  border-radius: 10px;
  padding: 20px 30px;
  color: #e7f0ff;
  font-size: 16px;
  z-index: 200;
  animation: zekeFadeIn 0.3s ease;
}

@keyframes zekeFadeIn {
  from { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
  to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
}
 </style>
 <script type="importmap">
 {
 "imports": {
 "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
 "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
 "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm"
 }
 }
 </script>
 <!-- ZEKE Portal Dependencies -->
 <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
</head>
<body>
 <!-- ZEKE Portal: Hidden DOM for GUI streaming -->
 <div id="sheet-stream"></div>
 
 <div id="app"></div>
 
 <div id="loading-overlay">
  <div class="status-text">
   <div class="spinner"></div>
   <div id="status-message">Loading scene...</div>
  </div>
 </div>

 <div id="prototype-overlay-cluster" class="prototype-overlay">
  <div class="prototype-card" id="overlay-stage-brief" data-phase="overlay">
   <header><span>01</span>Overlay Staging</header>
   <p>Testing layered HUD placement, responsive offsets, and CTA density before wiring React components.</p>
   <ul>
    <li>Ensure overlays coexist with debug + gizmo UI.</li>
    <li>Validate blur/sheen tokens for production themes.</li>
    <li>Sequence timeline drives reveal choreography.</li>
   </ul>
  </div>

  <div class="prototype-card" id="ascii-house-panel" data-phase="ascii">
   <header><span>02</span>ASCII Habitat Wireframe</header>
   <p>Embedding micro-habitat ASCII art for lore overlays and ambient storytelling beats.</p>
   <pre id="ascii-house-art" aria-label="ASCII house blueprint">        /\
       /  \
      /----\
     / |[]| \
    /__|__|__\
       ||||
       ||||
      [____]
   </pre>
   <button id="ascii-focus-button" type="button">Spotlight ASCII House</button>
  </div>

  <div class="prototype-card" id="media-controls-panel" data-phase="media">
   <header><span>03</span>Media Loopbacks</header>
   <p>Previewing audio/video choreography for the production cell — syncing beats with overlay cadence.</p>
   <div class="media-control">
    <button id="audio-toggle" type="button">Play Ambient Theme</button>
    <span id="audio-status" aria-live="polite">idle</span>
   </div>
   <audio id="prototype-audio" src="../../theme1.mp3" preload="auto"></audio>
   <div class="media-control" style="margin-top: 10px;">
    <button id="video-toggle" type="button">Play Transit Preview</button>
    <span id="video-status" aria-live="polite">paused</span>
   </div>
   <video id="prototype-video" src="../../Intro6.mp4" muted playsinline preload="metadata"></video>
  </div>

  <div class="prototype-timeline">
   <div>Prototype timeline — staging ▶ ASCII embed ▶ media sync</div>
   <div class="prototype-timeline-bar">
    <div class="prototype-timeline-progress" id="overlay-timeline-progress"></div>
   </div>
   <div class="prototype-footnote" data-note-target>Notes pending sequencing pass…</div>
  </div>
 </div>

 <div id="debug-menu">
  <div id="debug-menu-minimize" title="Hide Scene Navigation">-</div>
  <h3>Scene Navigation</h3>
 <button id="btn-keyboard">JUMP TO KEYBOARD</button>
 <button id="btn-character">JUMP TO CHARACTER</button>
 <button id="btn-head">JUMP TO HEAD</button>
 <button id="btn-overview">OVERVIEW</button>
 <hr style="border-color: #333; margin: 12px 0;">
 <h3>Edit Tools</h3>
 <button id="btn-edit-character">EDIT CHARACTER</button>
 <button id="btn-sculpt-character">SCULPT CHARACTER</button>
 <button id="btn-edit-head">EDIT HEAD</button>
 <button id="btn-edit-hands">EDIT HANDS</button>
 <button id="btn-scene-browser">SCENE BROWSER</button>
 <button id="btn-celli-collapse">MULTI-WRAP COLLAPSE</button>
 <hr style="border-color: #333; margin: 12px 0;">
 <h3>Configuration</h3>
 <button id="btn-save-config">SAVE CONFIG</button>
 <button id="btn-print-config">PRINT CONFIG</button>
 <hr style="border-color: #333; margin: 12px 0;">
 <button id="btn-cursor-sequence">CREATE VOXEL CURSOR</button>
 <div id="hand-config-previews" style="margin-top: 10px; max-width: 200px;"></div>
 <hr style="border-color: #333; margin: 12px 0;">
 <button id="btn-scale-mode">TOGGLE SCALE MODE</button>
 <hr style="border-color: #333; margin: 12px 0;">
 <div id="micro-city-status" style="font-size: 11px; color: #888; padding: 4px;">
 <strong>Micro City LOD:</strong> <span id="micro-city-state">Inactive</span>
 </div>
 <div id="scale-mode-status" style="font-size: 11px; color: #888; padding: 4px; margin-top: 4px;">
 <strong>Scale Mode:</strong> <span id="scale-mode-state">Disabled</span>
 </div>
 </div>
 
 <div id="debug-menu-restore" title="Show Scene Navigation">???</div>
 
 <!-- Narrative Dialogue -->
 <div id="narrative-dialogue">
 <p class="dialogue-text"></p>
 </div>
 
 <input type="file" id="cursor-file-input" accept="image/*" style="display:none;">
 
<div class="gizmo-toolbar" id="gizmo-toolbar" style="display: flex;">
<div class="gizmo-btn active" data-mode="translate" title="Translate (G)">?</div>
<div class="gizmo-btn" data-mode="rotate" title="Rotate (R)">?</div>
<div class="gizmo-btn" data-mode="scale" title="Scale (S)">?</div>
<div style="width: 1px; height: 34px; background: #3a4149; margin: 5px 4px;"></div>
<div class="gizmo-btn" id="snap-toggle" data-snap="free" title="Rotation Snap: Free" style="font-size: 14px; font-weight: 600;">Free</div>
<div class="gizmo-btn" id="drop-btn" title="Drop to Human Scale" style="font-size: 14px; font-weight: 600; background: #4a7cff;">DROP</div>
</div>

<!-- Drop Mode Debug Tracker -->
<div id="drop-debug" style="
position: fixed;
top: 80px;
right: 20px;
background: rgba(0, 0, 0, 0.9);
color: #0f0;
padding: 15px;
font-family: 'Courier New', monospace;
font-size: 11px;
border: 2px solid #0f0;
border-radius: 4px;
z-index: 2000;
display: none;
min-width: 280px;
line-height: 1.6;
box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
">
<div style="color: #ff0; font-weight: bold; margin-bottom: 8px; border-bottom: 1px solid #0f0; padding-bottom: 4px;">ðŸŽ® DROP MODE DEBUG</div>
<div id="drop-debug-content"></div>
</div>
 
 <!-- Scene Browser Modal -->
 <div id="scene-browser-modal" class="modal-window">
 <div class="modal-header">
 <h3>Scene Objects</h3>
 <div class="modal-close" onclick="document.getElementById('scene-browser-modal').classList.remove('active')"> </div>
 </div>
 <div class="modal-body" id="scene-browser-content">
 <!-- Populated dynamically -->
 </div>
 </div>
 
 <!-- Edit Head Modal -->
 <div id="edit-head-modal" class="modal-window">
 <div class="modal-header">
 <h3>Edit Head</h3>
 <div class="modal-close" onclick="document.getElementById('edit-head-modal').classList.remove('active')"> </div>
 </div>
 <div class="modal-body">
 <div class="form-group">
 <label>Preset Configuration</label>
<select id="head-preset-select" onchange="loadHeadPreset(this.value)">
<option value="sparse-blue">Sparse Blue (Default)</option>
<option value="intro-celli">Intro Celli (Narrative)</option>
<option value="dense-cyan">Dense Cyan</option>
<option value="warm-glow">Warm Glow</option>
<option value="neon-pink">Neon Pink</option>
<option value="ghost-white">Ghost White</option>
</select>
 </div>
 <hr style="border-color: #333; margin: 12px 0;">
 <h4 style="margin: 8px 0; font-size: 13px; color: #ddd;">Mouth Expression</h4>
 <div class="form-group">
 <label>Smile/Frown Deformation</label>
 <input type="range" id="head-mouth-deform" min="-1" max="1" step="0.01" value="1">
 <span id="head-mouth-deform-val">1.00 (Smile)</span>
 </div>
 <hr style="border-color: #333; margin: 12px 0;">
 <h4 style="margin: 8px 0; font-size: 13px; color: #ddd;">Voxel Geometry</h4>
 <div class="form-group">
 <label>Voxel Layers</label>
 <input type="range" id="head-voxel-layers" min="1" max="5" step="1" value="2">
 <span id="head-voxel-layers-val">2</span>
 </div>
 <div class="form-group">
 <label>Voxel Scale</label>
 <input type="range" id="head-voxel-scale" min="0.5" max="2" step="0.05" value="1">
 <span id="head-voxel-scale-val">1.00</span>
 </div>
 <div class="form-group">
 <label>Voxel Spacing</label>
 <input type="range" id="head-voxel-spacing" min="1.0" max="2.0" step="0.05" value="1.05">
 <span id="head-voxel-spacing-val">1.05</span>
 </div>
 <hr style="border-color: #333; margin: 12px 0;">
 <h4 style="margin: 8px 0; font-size: 13px; color: #ddd;">Animation</h4>
 <div class="form-group">
 <label>Animation Speed</label>
 <input type="range" id="head-anim-speed" min="0" max="3" step="0.01" value="1.15">
 <span id="head-anim-speed-val">1.15</span>
 </div>
 <div class="form-group">
 <label>Amplitude</label>
 <input type="range" id="head-amplitude" min="0" max="0.5" step="0.01" value="0.15">
 <span id="head-amplitude-val">0.15</span>
 </div>
 <div class="form-group">
 <label>Opacity Min</label>
 <input type="range" id="head-opacity-min" min="0" max="1" step="0.01" value="0.3">
 <span id="head-opacity-min-val">0.3</span>
 </div>
 <div class="form-group">
 <label>Opacity Max</label>
 <input type="range" id="head-opacity-max" min="0" max="1" step="0.01" value="0.85">
 <span id="head-opacity-max-val">0.85</span>
 </div>
 <div class="form-group">
 <label>Emissive Intensity</label>
 <input type="range" id="head-emissive" min="0" max="2" step="0.01" value="0.8">
 <span id="head-emissive-val">0.8</span>
 </div>
 <div class="form-group">
 <label>Light Intensity</label>
 <input type="range" id="head-light-int" min="0" max="10" step="0.1" value="2.5">
 <span id="head-light-int-val">2.5</span>
 </div>
 <div class="form-group">
 <label>
 <input type="checkbox" id="head-light-pulse" checked>
 Light Pulse
 </label>
 </div>
 <div class="form-group">
 <label>Rotation Speed</label>
 <input type="range" id="head-rotation-speed" min="0" max="1" step="0.01" value="0.3">
 <span id="head-rotation-speed-val">0.3</span>
 </div>
 <div class="form-group">
 <label>Color</label>
 <input type="color" id="head-color" value="#95bfff">
 </div>
 <hr>
 <h4>Advanced Animation</h4>
 <div class="form-group">
 <label>Phase Noise</label>
 <input type="range" id="head-phase-noise" min="0" max="2" step="0.01" value="0.75">
 <span id="head-phase-noise-val">0.75</span>
 </div>
 <div class="form-group">
 <label>Falloff</label>
 <input type="range" id="head-falloff" min="0" max="2" step="0.01" value="0.85">
 <span id="head-falloff-val">0.85</span>
 </div>
 <div class="form-group">
 <label>Noise Warp</label>
 <input type="range" id="head-noise-warp" min="0" max="0.6" step="0.01" value="0.15">
 <span id="head-noise-warp-val">0.15</span>
 </div>
 <div class="form-group">
 <label>Opacity Speed</label>
 <input type="range" id="head-opacity-speed" min="0" max="3" step="0.01" value="0.8">
 <span id="head-opacity-speed-val">0.8</span>
 </div>
 <h4>Material</h4>
 <div class="form-group">
 <label>Metalness</label>
 <input type="range" id="head-metalness" min="0" max="1" step="0.01" value="0.2">
 <span id="head-metalness-val">0.2</span>
 </div>
 <div class="form-group">
 <label>Roughness</label>
 <input type="range" id="head-roughness" min="0" max="1" step="0.01" value="0.55">
 <span id="head-roughness-val">0.55</span>
 </div>
 </div>
 <div class="modal-footer">
 <button class="modal-btn" onclick="document.getElementById('edit-head-modal').classList.remove('active')">Close</button>
 <button class="modal-btn primary" onclick="applyHeadSettings()">Apply</button>
 </div>
 </div>
 
 <!-- Edit Hands Modal -->
 <div id="edit-hands-modal" class="modal-window" style="top: 50%; left: 50%; transform: translate(-50%, -50%); width: 400px;">
 <div class="modal-header">
 <h3>Edit Hands</h3>
 <div class="modal-close" onclick="document.getElementById('edit-hands-modal').classList.remove('active')"> </div>
 </div>
 <div class="modal-body" id="edit-hands-content">
 <!-- Populated by lil-gui -->
 </div>
 </div>
 
 <!-- Save Configuration Modal -->
 <div id="save-config-modal" class="modal-window">
 <div class="modal-header">
 <h3>Save Configuration</h3>
 <div class="modal-close" onclick="document.getElementById('save-config-modal').classList.remove('active')"> </div>
 </div>
 <div class="modal-body">
 <div class="form-group">
 <label>Configuration Name</label>
 <input type="text" id="config-name-input" placeholder="My Scene Configuration">
 </div>
 <div class="form-group">
 <label>Existing Configurations</label>
 <select id="config-list-select" size="5" style="height: 120px;">
 <!-- Populated from localStorage -->
 </select>
 </div>
 </div>
 <div class="modal-footer">
 <button class="modal-btn" onclick="document.getElementById('save-config-modal').classList.remove('active')">Cancel</button>
 <button class="modal-btn" onclick="saveAsConfiguration()">Save As New</button>
 <button class="modal-btn primary" onclick="saveConfiguration()">Save</button>
 </div>
 </div>
 
 <!-- Configuration Report Modal -->
 <div id="config-report-modal" class="modal-window">
 <div class="modal-header">
 <h3>Configuration Report</h3>
 <div class="modal-close" onclick="document.getElementById('config-report-modal').classList.remove('active')"> </div>
 </div>
 <div class="modal-body">
 <div id="config-report-content" style="font-family: monospace; font-size: 12px; line-height: 1.6;">
 <!-- Populated dynamically -->
 </div>
 </div>
 <div class="modal-footer">
 <button class="modal-btn primary" onclick="document.getElementById('config-report-modal').classList.remove('active')">Close</button>
 </div>
 </div>
 
 <script type="module">
 import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { TransformControls } from 'three/addons/controls/TransformControls.js';
 import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
 import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
 import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
 import { FXAAShader } from 'three/addons/shaders/FXAAShader.js';
 import { BokehPass } from 'three/addons/postprocessing/BokehPass.js';
 import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
 import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
 import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';
 import GUI from 'lil-gui';

 // Note: GPU "Sample Bias" warnings are from Three.js internal shader generation
 // when using high-quality materials (MeshPhysicalMaterial) with certain property combinations.
 // These are clamped automatically by the GPU and don't affect rendering.
 // All bias values in this code are set within the valid range (-16 to 15.99).

// ===== MODE DETECTION =====
// Check localStorage first (set by FullhandScene-Faithful.js), then window, then default to 'sequence'
const EXEC_ENV_MODE = localStorage.getItem('fullhand_mode') || window.EXEC_ENV_MODE || 'sequence';
console.log(`🎮 Execution Environment Mode: ${EXEC_ENV_MODE}`);

 // Hide debug UI in sequence mode
 if (EXEC_ENV_MODE === 'sequence') {
  const debugMenu = document.getElementById('debug-menu');
  const debugRestore = document.getElementById('debug-menu-restore');
  const gizmoToolbar = document.getElementById('gizmo-toolbar');

  if (debugMenu) debugMenu.style.display = 'none';
  if (debugRestore) debugRestore.style.display = 'none';
  if (gizmoToolbar) gizmoToolbar.style.display = 'none';

  console.log('? Sequence mode: Debug UI hidden');
 }

 // ===== Prototype Overlay Sequencing (UI + ASCII + Media) =====
 const overlayCluster = document.getElementById('prototype-overlay-cluster');
 if (overlayCluster) {
  const overlayCards = Array.from(overlayCluster.querySelectorAll('.prototype-card'));
  overlayCards.forEach((card) => card.classList.remove('visible'));

  const timelineProgressEl = document.getElementById('overlay-timeline-progress');
  const revealSteps = [
   { delay: 600, id: 'overlay-stage-brief' },
   { delay: 2200, id: 'ascii-house-panel' },
   { delay: 4200, id: 'media-controls-panel' }
  ];
  const totalDuration = revealSteps.reduce((acc, step) => acc + step.delay, 0) || 1;

  const updateTimeline = (ratio) => {
   if (!timelineProgressEl) return;
   const clamped = Math.max(0, Math.min(1, ratio));
   timelineProgressEl.style.width = `${(clamped * 100).toFixed(1)}%`;
  };

  const revealCard = (id) => {
   const target = document.getElementById(id);
   if (target && !target.classList.contains('visible')) {
    target.classList.add('visible');
    target.dispatchEvent(new CustomEvent('prototype:visible', { bubbles: true }));
   }
  };

  updateTimeline(0);
  let cumulativeDelay = 0;
  revealSteps.forEach((step) => {
   cumulativeDelay += step.delay;
   setTimeout(() => {
    revealCard(step.id);
    updateTimeline(cumulativeDelay / totalDuration);
   }, cumulativeDelay);
  });
  setTimeout(() => updateTimeline(1), totalDuration + 600);

  const asciiPanel = document.getElementById('ascii-house-panel');
  const asciiFocusButton = document.getElementById('ascii-focus-button');
  if (asciiPanel && asciiFocusButton) {
   asciiFocusButton.addEventListener('click', () => {
    const spotlightActive = asciiPanel.classList.toggle('spotlight');
    asciiFocusButton.textContent = spotlightActive ? 'Release Spotlight' : 'Spotlight ASCII House';
   });
  }

  const audioEl = document.getElementById('prototype-audio');
  const audioToggle = document.getElementById('audio-toggle');
  const audioStatus = document.getElementById('audio-status');
  const syncAudioState = () => {
   if (!audioEl || !audioToggle || !audioStatus) return;
   if (audioEl.paused) {
    audioStatus.textContent = 'paused';
    audioToggle.textContent = 'Play Ambient Theme';
   } else {
    audioStatus.textContent = `playing (${Math.round(audioEl.currentTime)}s)`;
    audioToggle.textContent = 'Pause Ambient Theme';
   }
  };

  if (audioEl && audioToggle) {
   audioToggle.addEventListener('click', async () => {
    try {
     if (audioEl.paused) {
      await audioEl.play();
     } else {
      audioEl.pause();
     }
    } catch (err) {
     console.warn('[Prototype Overlay] Audio playback blocked', err);
     if (audioStatus) audioStatus.textContent = 'interaction required';
    } finally {
     syncAudioState();
    }
   });

   ['play', 'pause', 'ended', 'timeupdate'].forEach((evt) => {
    audioEl.addEventListener(evt, () => {
     if (evt === 'ended') {
      audioEl.currentTime = 0;
     }
     syncAudioState();
    });
   });

   syncAudioState();
  }

  const videoEl = document.getElementById('prototype-video');
  const videoToggle = document.getElementById('video-toggle');
  const videoStatus = document.getElementById('video-status');
  const syncVideoState = () => {
   if (!videoEl || !videoToggle || !videoStatus) return;
   if (videoEl.paused) {
    videoStatus.textContent = 'paused';
    videoToggle.textContent = 'Play Transit Preview';
   } else {
    const progress = videoEl.duration ? Math.round((videoEl.currentTime / videoEl.duration) * 100) : 0;
    videoStatus.textContent = `playing ${progress}%`;
    videoToggle.textContent = 'Pause Transit Preview';
   }
  };

  if (videoEl && videoToggle) {
   videoToggle.addEventListener('click', async () => {
    try {
     if (videoEl.paused) {
      await videoEl.play();
     } else {
      videoEl.pause();
     }
    } catch (err) {
     console.warn('[Prototype Overlay] Video playback blocked', err);
     if (videoStatus) videoStatus.textContent = 'interaction required';
    } finally {
     syncVideoState();
    }
   });

   ['play', 'pause', 'timeupdate', 'ended'].forEach((evt) => {
    videoEl.addEventListener(evt, () => {
     if (evt === 'ended') {
      videoEl.currentTime = 0;
      videoEl.pause();
     }
     syncVideoState();
    });
   });

   syncVideoState();
  }

  const noteTarget = overlayCluster.querySelector('[data-note-target]');
  if (noteTarget) {
   const now = new Date();
   const timestamp = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
   // TODO(Componentization): Extract overlay + media controllers into reusable modules post validation.
   noteTarget.textContent = `Sequencer locked ${timestamp} — queue componentization of overlay + media controllers.`;
  }
 }

 // ===== Cursor Glitch Effect =====
 let cursorGlitchState = 0; // 0: normal, 1: corrupted, 2: emoji
 let cursorGlitchInterval;
 
 function startCursorGlitch() {
 const cursors = [
 'pointer', // Normal
 'url("data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'32\' height=\'32\'%3E%3Cpath d=\'M2,2 L2,28 L12,18 L18,28 L22,26 L16,16 L28,16 Z\' fill=\'%23ff0000\' opacity=\'0.3\'/%3E%3C/svg%3E") 2 2, pointer', // Corrupted red
 'url("data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'32\' height=\'32\'%3E%3Ctext x=\'4\' y=\'24\' font-size=\'24\'%3E?%3C/text%3E%3C/svg%3E") 16 16, pointer' // Hand emoji
 ];
 
 cursorGlitchInterval = setInterval(() => {
 if (Math.random() < 0.15) { // 15% chance to glitch
 const glitchType = Math.floor(Math.random() * 3);
 document.body.style.cursor = cursors[glitchType];
 
 // Quick flash between states
 setTimeout(() => {
 document.body.style.cursor = cursors[(glitchType + 1) % 3];
 }, 50);
 
 setTimeout(() => {
 document.body.style.cursor = cursors[0]; // Back to normal
 }, 150);
 }
 }, 200);
 }
 
 function stopCursorGlitch() {
 if (cursorGlitchInterval) {
 clearInterval(cursorGlitchInterval);
 document.body.style.cursor = 'auto';
 }
 }

// ===== Scene Setup =====
const renderer = new THREE.WebGLRenderer({ antialias:true, preserveDrawingBuffer: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
 renderer.toneMappingExposure = 1.0;
 renderer.physicallyCorrectLights = true;
 renderer.outputColorSpace = THREE.SRGBColorSpace;
 document.getElementById('app').appendChild(renderer.domElement);

 const scene = new THREE.Scene();
 scene.background = new THREE.Color(0x0a0a0a);
 scene.fog = new THREE.FogExp2(0x0a0a0a, 0.03);

 const pmrem = new THREE.PMREMGenerator(renderer);
 const env = pmrem.fromScene(new RoomEnvironment(), 0.04).texture;
 scene.environment = env;

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 100);
camera.position.set(6, 2.5, -8); // Raised Y and pushed back Z to see Celli better

 const controls = new OrbitControls(camera, renderer.domElement);
 controls.target.set(6, 8, 22); // Looking up at Celli's upper body
 controls.enableDamping = true;
 controls.update();

 // Post-processing
 const composer = new EffectComposer(renderer);
 const mainRenderPass = new RenderPass(scene, camera);
 composer.addPass(mainRenderPass);

 const bloomPass = new UnrealBloomPass(
 new THREE.Vector2(innerWidth, innerHeight),
 0.6, 0.6, 0.9
 );
 composer.addPass(bloomPass);

 const fxaaPass = new ShaderPass(FXAAShader);
 fxaaPass.material.uniforms['resolution'].value.set(1 / innerWidth, 1 / innerHeight);
 composer.addPass(fxaaPass);

 // Lighting
 const al = new THREE.AmbientLight(0x1a1a1a, 0.15);
 scene.add(al);
 const hl = new THREE.HemisphereLight(0xddeeff,0x101016,0.2);
 scene.add(hl);
 
 const dl = new THREE.DirectionalLight(0xffffff, 0.9);
 dl.position.set(6,10,4);
 dl.castShadow = true;
 dl.shadow.mapSize.width = 2048;
 dl.shadow.mapSize.height = 2048;
 dl.shadow.camera.left = -10;
 dl.shadow.camera.right = 20;
 dl.shadow.camera.top = 10;
 dl.shadow.camera.bottom = -5;
 dl.shadow.camera.near = 0.5;
 dl.shadow.camera.far = 30;
 dl.shadow.bias = -0.0001; // Within valid range
 scene.add(dl);
 
 const rimLight = new THREE.DirectionalLight(0x4466aa, 0.3);
 rimLight.position.set(-5, 3, -5);
 scene.add(rimLight);

 const spotLight = new THREE.SpotLight(0xffe4c4, 4.0);
 spotLight.position.set(8, 16, 6);
 spotLight.angle = Math.PI / 6.5;
 spotLight.penumbra = 1.0;
 spotLight.decay = 1.0;
 spotLight.distance = 44;
 spotLight.castShadow = true;
 spotLight.shadow.mapSize.width = 2048;
 spotLight.shadow.mapSize.height = 2048;
 spotLight.shadow.bias = -0.0005; // Within valid range
 scene.add(spotLight);
 scene.add(spotLight.target);

 // Ground plane
 const ground = new THREE.Mesh(
 new THREE.PlaneGeometry(50, 50),
 new THREE.MeshStandardMaterial({color:0x0a0a0a, roughness:0.9, metalness:0.1})
 );
 ground.rotation.x = -Math.PI / 2;
 ground.receiveShadow = true;
 scene.add(ground);

 // ===== State Management =====
 let keyboardGroup, characterGroup, voxelHeadGroup;
 let characterBust, characterUnifiedMesh, characterPoseSpheres = [];
 let characterZSpheres = []; // Store ZSphere data for regeneration
 let transformControl;
 let skinMat; // Shared skin material
 let staticFingers = []; // Non-clicking fingers
 let keys = []; // Keyboard keys (for finger interaction)
let rightHandGroup, leftHandGroup, handsGroup; // Hand hierarchy
let celliAvatarGroup; // Combined head + body
let microCityGroups = []; // Micro buildings on keys
let microCityVisible = false;
let cameraSlowdownFactor = 1.0;

// Scale Mode / Frame of Reference
let scaleModeEnabled = false;
let frameOfReference = null; // The 3D frame mesh group
let frameMinimized = false;
let scaleObjects = []; // 3D objects that spawn in Scale mode
let frameDist = 0.9; // Distance in front of camera
let minimizeButton = null; // Diegetic UI circle button

// Drop functionality - Smooth dolly/zoom animation
let lastViewedKey = null; // Track most recently viewed key
let isDropping = false; // Track if drop animation is active
let dropProgress = 0; // 0-1 animation progress
let dropStartTime = 0; // Animation start timestamp
let dropDuration = 3000; // 3 second drop animation (ms)
let dropStartPos = new THREE.Vector3(); // Starting camera position
let dropTargetPos = new THREE.Vector3(); // Target camera position
let dropStartScale = 1.0; // Starting camera scale
let dropTargetScale = 1.0; // Target camera scale (normal, no scaling)
let originalFogDensity = null; // Store original fog density
let dropKeyTarget = null; // Track key we're dropping onto
let dropModeActive = false; // Track if in exploration mode after landing
let dropKeys = { w: false, a: false, s: false, d: false, shift: false, space: false }; // WASD controls
let dropVelocity = 0; // Velocity for gravity-based dropping
let targetDropHeight = null; // Target height when dropping with gravity
 
 // Fingerprint controls
 const FP = { enabled: true, strength: 1.0, scale: 1.0, _applied: '' };
 
 // Finger reference (set by loadFinger)
 let finger = null;
 
 // ===== Dust Particle System =====
 function makeDustTexture(){
 const c=document.createElement('canvas');
 c.width=64; c.height=64;
 const ctx=c.getContext('2d');
 ctx.clearRect(0,0,64,64);
 ctx.globalAlpha = 0.4;
 const centerX = 32, centerY = 32;
 for(let i=0; i<5; i++){
 const offsetX = (Math.random()-0.5)*12;
 const offsetY = (Math.random()-0.5)*12;
 const radius = 8 + Math.random()*8;
 const gradient=ctx.createRadialGradient(
 centerX+offsetX, centerY+offsetY, 0,
 centerX+offsetX, centerY+offsetY, radius
 );
 gradient.addColorStop(0,'rgba(200,200,200,0.6)');
 gradient.addColorStop(0.5,'rgba(180,180,180,0.3)');
 gradient.addColorStop(1,'rgba(160,160,160,0)');
 ctx.fillStyle=gradient;
 ctx.fillRect(0,0,64,64);
 }
 return new THREE.CanvasTexture(c);
 }

 const dustTexture = makeDustTexture();
 let ambientDustParticles = [];
 
 function createDustParticlesForKey(key) {
 const dustParticles = [];
 for (let i = 0; i < 3; i++) {
 const dustGeo = new THREE.PlaneGeometry(0.02, 0.02);
 const dustMat = new THREE.MeshBasicMaterial({
 map: dustTexture,
 transparent: true,
 opacity: 0.3,
 depthWrite: false,
 blending: THREE.AdditiveBlending
 });
 const dust = new THREE.Mesh(dustGeo, dustMat);
 dust.position.set(
 key.position.x + (Math.random() - 0.5) * 0.3,
 key.position.y + 0.35,
 key.position.z + (Math.random() - 0.5) * 0.3
 );
 dust.userData = {
 baseX: dust.position.x,
 baseZ: dust.position.z,
 freq: 0.5 + Math.random() * 1.5,
 phase: Math.random() * Math.PI * 2
 };
 key.add(dust);
 dustParticles.push(dust);
 }
 return dustParticles;
 }
 
 function createAmbientDust() {
 const count = 80;
 for (let i = 0; i < count; i++) {
 const dustGeo = new THREE.PlaneGeometry(0.03, 0.03);
 const dustMat = new THREE.MeshBasicMaterial({
 map: dustTexture,
 transparent: true,
 opacity: 0.15,
 depthWrite: false,
 blending: THREE.AdditiveBlending
 });
 const dust = new THREE.Mesh(dustGeo, dustMat);
 dust.position.set(
 Math.random() * 20 - 2,
 Math.random() * 8 + 2,
 Math.random() * 10 - 2
 );
 dust.userData = {
 velY: -0.003 - Math.random() * 0.005,
 velX: (Math.random() - 0.5) * 0.002,
 velZ: (Math.random() - 0.5) * 0.002,
 freq: 0.3 + Math.random() * 1.0,
 phase: Math.random() * Math.PI * 2,
 swayAmount: 0.5 + Math.random() * 1.5
 };
 scene.add(dust);
 ambientDustParticles.push(dust);
 }
 }
 
 // ===== Key Label Textures =====
 // Create color and bump textures for key labels with engrave effect
 function makeLabelTextures(text){
 if (!text || text === 'Space') return { map:null, bump:null };
 const size=256;
 const base=document.createElement('canvas'); base.width=size; base.height=size;
 const bump=document.createElement('canvas'); bump.width=size; bump.height=size;
 const cctx=base.getContext('2d'); const bctx=bump.getContext('2d');
 // Background color
 cctx.fillStyle='#d7ceb2'; cctx.fillRect(0,0,size,size);
 // Bump base (mid-gray)
 bctx.fillStyle='rgb(200,200,200)'; bctx.fillRect(0,0,size,size);
 // dynamic font size
 let fontSize=120; if(['Shift','Caps','Backspace'].includes(text)) fontSize=80; if(text.length>=3 && fontSize===120) fontSize=100;
 // Draw text on color map
 cctx.fillStyle='#222'; cctx.font=`bold ${fontSize}px sans-serif`; cctx.textAlign='center'; cctx.textBaseline='middle'; cctx.fillText(text,size/2,size/2);
 // Draw darker text to bump to engrave (lower where text appears)
 bctx.fillStyle='rgb(120,120,120)'; bctx.font=`bold ${fontSize}px sans-serif`; bctx.textAlign='center'; bctx.textBaseline='middle'; bctx.fillText(text,size/2,size/2);
 const mapTex=new THREE.CanvasTexture(base); mapTex.colorSpace=THREE.SRGBColorSpace;
 const bumpTex=new THREE.CanvasTexture(bump);
 return { map: mapTex, bump: bumpTex };
 }
 
 // ===== Initialize Scene Elements (hidden initially) =====
 function createKey(width, depth, height, label) {
 const segmentsX = Math.max(16, Math.ceil(width*20));
 const segmentsZ = Math.max(16, Math.ceil(depth*20));
 const geo = new THREE.BoxGeometry(width, height, depth, segmentsX, 8, segmentsZ);
 const pos = geo.attributes.position;
 const v = new THREE.Vector3();
 const hx = width/2, hy = height/2, hz = depth/2;
 
 if (hx <= 0 || hy <= 0 || hz <= 0) {
 return new THREE.Mesh(geo, new THREE.MeshStandardMaterial({color:0xd7ceb2}));
 }
 
 for (let i = 0; i < pos.count; i++) {
 v.fromBufferAttribute(pos, i);
 const ty = (v.y + hy) / (2 * hy);
 const taper = 0.28, concave = 0.06;
 const tilt = 0.12;
 
 if (v.y > 0) {
 const scale = 1 - taper * ty;
 v.x *= scale; 
 v.z *= scale;
 v.y -= tilt * (v.z / hz) * ty;
 
 const divisorX = hx * (1 - taper);
 const divisorZ = hz * (1 - taper);
 if (divisorX > 0.001 && divisorZ > 0.001) {
 const nx = v.x / divisorX;
 const nz = v.z / divisorZ;
 const r2 = Math.min(nx * nx + nz * nz, 1);
 const concaveAmount = Math.min(width, depth) * 0.06;
 v.y -= concaveAmount * (1 - r2) ** 1.5;
 }
 }
 
 pos.setXYZ(i, v.x, v.y, v.z);
 }
 geo.computeVertexNormals();

 const hueShift = (Math.random() - 0.5) * 0.02;
 const lightnessShift = (Math.random() - 0.5) * 0.05;
 const baseColor = new THREE.Color(0xd7ceb2);
 baseColor.offsetHSL(hueShift, 0, lightnessShift);
 const sideColor = new THREE.Color(0xc5b89f);
 sideColor.offsetHSL(hueShift, 0, lightnessShift);

 // Create label textures with engrave effect
 const { map:labelMap, bump:labelBump } = makeLabelTextures(label);
 const topMat = labelMap ? 
 new THREE.MeshStandardMaterial({color:baseColor,roughness:0.6,metalness:0.06,envMapIntensity:1.1,map:labelMap,bumpMap:labelBump,bumpScale:-0.008}) : 
 new THREE.MeshStandardMaterial({color:baseColor,roughness:0.6,metalness:0.06,envMapIntensity:1.1});
 const sideMat = new THREE.MeshStandardMaterial({
 color: sideColor,
 roughness: 0.8,
 metalness: 0.05
 });
 const mats = [sideMat, sideMat, topMat, sideMat, sideMat, sideMat];
 const mesh = new THREE.Mesh(geo, mats);
 mesh.castShadow = true;
 mesh.receiveShadow = true;
 mesh.userData = { baseY: 0, velY: 0, pressed: false, label };

 return mesh;
 }

 function initializeKeyboard() {
 keyboardGroup = new THREE.Group();
 keyboardGroup.visible = false;
 
 const ANSI60 = [
 ['Esc','1','2','3','4','5','6','7','8','9','0','-','=','Backspace'],
 ['Tab','Q','W','E','R','T','Y','U','I','O','P','[',']','\\'],
 ['Caps','A','S','D','F','G','H','J','K','L',';','"','Enter'],
 ['Shift','Z','X','C','V','B','N','M',',','.','/','Shift'],
 ['Ctrl','Win','Alt','Space','Alt','Fn','Menu','Ctrl']
 ];

 const keyWidths = [
 [1,1,1,1,1,1,1,1,1,1,1,1,1,2],
 [1.5,1,1,1,1,1,1,1,1,1,1,1,1,1.5],
 [1.75,1,1,1,1,1,1,1,1,1,1,1,2.25],
 [2.25,1,1,1,1,1,1,1,1,1,1,2.75],
 [1.25,1.25,1.25,6.25,1.25,1.25,1.25,1.25]
 ];

 // Base plate
 const basePlate = new THREE.Mesh(
 new THREE.BoxGeometry(15.5, 0.5, 5.5),
 new THREE.MeshStandardMaterial({color:0xb8a68f, roughness:0.7, metalness:0.05})
 );
 basePlate.position.set(7.5, 0.25, 2.5);
 basePlate.castShadow = true;
 basePlate.receiveShadow = true;
 keyboardGroup.add(basePlate);

 const unit = 1.0, gap = 0.05;
 let zOff = 0;
 keys = []; // Reset global keys array

 for (let r = 0; r < ANSI60.length; r++) {
 const row = ANSI60[r];
 const widths = keyWidths[r];
 let xOff = 0;
 for (let i = 0; i < row.length; i++) {
 const w = widths[i];
 const label = row[i];
 const isSpace = label === 'Space';
 const key = createKey(w * unit - gap, unit - gap * (isSpace ? 0.9 : 1), 0.7, label);
 const keyX = xOff + w * 0.5;
 const keyZ = zOff;
 key.position.set(keyX, 0.9, keyZ);
 key.userData.baseY = 0.9;
 keyboardGroup.add(key);
 
 // Add dust particles to key
 key.userData.dustParticles = createDustParticlesForKey(key);
 
 keys.push(key);
 xOff += w;
 }
 zOff += 1;
 }
 
 scene.add(keyboardGroup);
 
 // Create ambient dust particles
 createAmbientDust();
 
 // Aim spotlight at keyboard center
 const bbox = new THREE.Box3().setFromObject(keyboardGroup);
 const kbCenter = bbox.getCenter(new THREE.Vector3());
 kbCenter.y = bbox.min.y + 0.7;
 spotLight.target.position.copy(kbCenter);
 spotLight.target.updateMatrixWorld();

 // Add volumetric ray billboard
 const rayLength = 22;
 const rayHeight = 10;
 const rayGeo = new THREE.PlaneGeometry(rayLength, rayHeight);
 const rayMat = new THREE.MeshBasicMaterial({
 map: makeRayTexture(),
 transparent: true,
 opacity: 0.28,
 depthWrite: false,
 blending: THREE.AdditiveBlending,
 color: 0xffe9cc
 });
 const rayBillboard = new THREE.Mesh(rayGeo, rayMat);
 rayBillboard.position.copy(spotLight.position);
 rayBillboard.lookAt(spotLight.target.position);
 rayBillboard.rotateY(Math.PI/2);
 rayBillboard.position.y -= 2.5;
 keyboardGroup.add(rayBillboard);
 
 // Create ambient dust particles
 createAmbientDust();
 
 // Create micro cities on keys (after a short delay to ensure keys are ready)
 setTimeout(() => {
 try {
 createMicroCitiesOnKeys();
 } catch (err) {
 console.warn('Micro cities creation failed:', err);
 }
 }, 100);
 
 // Integrate full finger system from kb.html
 loadFinger();
 }
 
 // ===== Micro City LOD System =====
 function createBuildingTexture(floors = 8, variant = 0) {
 console.log(`[MicroCity] Creating building texture: ${floors} floors, variant ${variant}`);
 const canvas = document.createElement('canvas');
 canvas.width = 64;
 canvas.height = 128;
 const ctx = canvas.getContext('2d');
 
 // Building body with color variations
 const colors = [
 ['#d0d4db', '#a8adb5'], // Gray
 ['#c8d4e0', '#a0b0c0'], // Blue-gray
 ['#d8d0c8', '#b0a8a0'], // Tan
 ['#e0d4d0', '#c0b0a8'] // Pink-gray
 ];
 const colorPair = colors[variant % colors.length];
 
 const gradient = ctx.createLinearGradient(0, 0, 0, 128);
 gradient.addColorStop(0, colorPair[0]);
 gradient.addColorStop(1, colorPair[1]);
 ctx.fillStyle = gradient;
 ctx.fillRect(0, 0, 64, 128);
 
 // Windows
 const windowWidth = 8;
 const windowHeight = 10;
 const windowMarginX = 4;
 const windowMarginY = 6;
 const windowsPerRow = 3;
 const windowSpacingX = (64 - windowMarginX * 2 - windowWidth * windowsPerRow) / (windowsPerRow - 1);
 const floorHeight = 128 / floors;
 
 for (let floor = 0; floor < floors; floor++) {
 const floorY = floor * floorHeight + windowMarginY;
 for (let col = 0; col < windowsPerRow; col++) {
 const x = windowMarginX + col * (windowWidth + windowSpacingX);
 const y = floorY;
 
 // Window background (lit or unlit based on variant)
 const litChance = 0.3 + (variant * 0.1);
 const isLit = Math.random() > litChance;
 ctx.fillStyle = isLit ? '#ffe9a0' : '#1a2030';
 ctx.fillRect(x, y, windowWidth, windowHeight);
 
 // Window frame
 ctx.strokeStyle = '#4a5568';
 ctx.lineWidth = 1;
 ctx.strokeRect(x, y, windowWidth, windowHeight);
 
 // Window cross divider
 ctx.beginPath();
 ctx.moveTo(x + windowWidth / 2, y);
 ctx.lineTo(x + windowWidth / 2, y + windowHeight);
 ctx.moveTo(x, y + windowHeight / 2);
 ctx.lineTo(x + windowWidth, y + windowHeight / 2);
 ctx.stroke();
 }
 }
 
 // Roof detail
 ctx.fillStyle = '#8a8f97';
 ctx.fillRect(0, 0, 64, 4);
 
 const texture = new THREE.CanvasTexture(canvas);
 texture.wrapS = THREE.RepeatWrapping;
 texture.wrapT = THREE.ClampToEdgeWrapping;
 return texture;
 }
 
 function createMicroCitiesOnKeys() {
 console.log('[MicroCity] Starting micro city creation...');
 
 if (!keys || keys.length === 0) {
 console.warn('[MicroCity] No keys available for micro cities yet');
 return;
 }
 
 console.log(`[MicroCity] Creating micro cities on ${keys.length} keys...`);
 
 const buildingScale = 0.02; // Increased for better visibility
 const gridSpacing = 0.04;
 
 // Create building geometry variations (reusable)
 const buildingGeometries = [
 new THREE.BoxGeometry(buildingScale * 0.8, buildingScale * 3 * 0.7, buildingScale * 0.8), // Short
 new THREE.BoxGeometry(buildingScale * 0.8, buildingScale * 3 * 1.0, buildingScale * 0.8), // Medium
 new THREE.BoxGeometry(buildingScale * 0.8, buildingScale * 3 * 1.3, buildingScale * 0.8), // Tall
 new THREE.BoxGeometry(buildingScale * 0.8, buildingScale * 3 * 1.6, buildingScale * 0.8) // Very tall
 ];
 console.log(`[MicroCity] Created ${buildingGeometries.length} building geometry variations`);
 
 // Create texture variations with high visibility
 const buildingMaterials = [
 // 6-floor variants - brighter emissive
 new THREE.MeshStandardMaterial({ map: createBuildingTexture(6, 0), roughness: 0.5, metalness: 0.3, emissive: 0xffee99, emissiveIntensity: 0.6, transparent: false }),
 new THREE.MeshStandardMaterial({ map: createBuildingTexture(6, 1), roughness: 0.5, metalness: 0.3, emissive: 0xffee99, emissiveIntensity: 0.6, transparent: false }),
 // 8-floor variants
 new THREE.MeshStandardMaterial({ map: createBuildingTexture(8, 0), roughness: 0.5, metalness: 0.3, emissive: 0xffdd88, emissiveIntensity: 0.65, transparent: false }),
 new THREE.MeshStandardMaterial({ map: createBuildingTexture(8, 1), roughness: 0.5, metalness: 0.3, emissive: 0xffdd88, emissiveIntensity: 0.65, transparent: false }),
 // 10-floor variants
 new THREE.MeshStandardMaterial({ map: createBuildingTexture(10, 2), roughness: 0.5, metalness: 0.3, emissive: 0xffcc77, emissiveIntensity: 0.7, transparent: false }),
 new THREE.MeshStandardMaterial({ map: createBuildingTexture(10, 3), roughness: 0.5, metalness: 0.3, emissive: 0xffcc77, emissiveIntensity: 0.7, transparent: false }),
 // 12-floor variants
 new THREE.MeshStandardMaterial({ map: createBuildingTexture(12, 2), roughness: 0.5, metalness: 0.3, emissive: 0xffbb66, emissiveIntensity: 0.75, transparent: false }),
 new THREE.MeshStandardMaterial({ map: createBuildingTexture(12, 3), roughness: 0.5, metalness: 0.3, emissive: 0xffbb66, emissiveIntensity: 0.75, transparent: false })
 ];
 console.log(`[MicroCity] Created ${buildingMaterials.length} material variations`);
 
 keys.forEach((key, keyIndex) => {
 try {
 console.log(`[MicroCity] Processing key ${keyIndex + 1}/${keys.length}: ${key.userData.label}`);
 
 const cityGroup = new THREE.Group();
 cityGroup.name = `MicroCity_${key.userData.label}`;
 cityGroup.userData.buildingScale = buildingScale; // Store for later reference
 
 // Get key dimensions from bounding box
 const bbox = new THREE.Box3().setFromObject(key);
 const keyWidth = bbox.max.x - bbox.min.x;
 const keyDepth = bbox.max.z - bbox.min.z;
 const keyTop = bbox.max.y;
 
 console.log(`[MicroCity] Key "${key.userData.label}": ${keyWidth.toFixed(3)}x${keyDepth.toFixed(3)}, top at ${keyTop.toFixed(3)}`);
 
 // Create grid of buildings on key surface
 const buildingsX = Math.max(2, Math.floor(keyWidth / gridSpacing));
 const buildingsZ = Math.max(2, Math.floor(keyDepth / gridSpacing));
 
 console.log(`[MicroCity] Grid: ${buildingsX}x${buildingsZ} = ${buildingsX * buildingsZ} buildings`);
 
 const startX = -keyWidth / 2 + gridSpacing;
 const startZ = -keyDepth / 2 + gridSpacing;
 
 // Get key geometry for surface sampling
 const keyGeometry = key.geometry;
 const keyPositions = keyGeometry.getAttribute('position');
 
 // Create instanced meshes for each geometry type
 const instanceData = buildingGeometries.map(() => []);
 
 for (let i = 0; i < buildingsX; i++) {
 for (let j = 0; j < buildingsZ; j++) {
 // Pick random geometry and material
 const geoIdx = Math.floor(Math.random() * buildingGeometries.length);
 const matIdx = Math.floor(Math.random() * buildingMaterials.length);
 
 // Position on key surface with slight randomization
 const x = startX + i * gridSpacing + (Math.random() - 0.5) * gridSpacing * 0.3;
 const z = startZ + j * gridSpacing + (Math.random() - 0.5) * gridSpacing * 0.3;
 
 // Sample key surface height at this position (approximate)
 // Keys have curved tops, so we need to sample the actual geometry
 const nx = x / (keyWidth / 2);
 const nz = z / (keyDepth / 2);
 const r2 = Math.min(nx * nx + nz * nz, 1);
 const concaveDip = Math.min(keyWidth, keyDepth) * 0.06 * (1 - r2) ** 1.5;
 
 const heightVariation = 0.7 + geoIdx * 0.3;
 const buildingHeight = buildingScale * 3 * heightVariation;
 const y = buildingHeight / 2 - concaveDip + 0.001; // Follow key curve
 
 instanceData[geoIdx].push({ x, y, z, matIdx });
 }
 }
 
 // Create instanced meshes for each geometry type
 let totalInstances = 0;
 buildingGeometries.forEach((geometry, geoIdx) => {
 const instances = instanceData[geoIdx];
 if (instances.length === 0) return;
 
 totalInstances += instances.length;
 
 // Group by material
 const byMaterial = {};
 instances.forEach(inst => {
 if (!byMaterial[inst.matIdx]) byMaterial[inst.matIdx] = [];
 byMaterial[inst.matIdx].push(inst);
 });
 
 // Create instanced mesh for each material
 Object.keys(byMaterial).forEach(matIdx => {
 const insts = byMaterial[matIdx];
 const instancedMesh = new THREE.InstancedMesh(
 geometry,
 buildingMaterials[matIdx],
 insts.length
 );
 
 const matrix = new THREE.Matrix4();
 insts.forEach((inst, idx) => {
 matrix.makeTranslation(inst.x, inst.y, inst.z);
 instancedMesh.setMatrixAt(idx, matrix);
 });
 
 instancedMesh.instanceMatrix.needsUpdate = true;
 instancedMesh.castShadow = true;
 instancedMesh.receiveShadow = true;
 
 cityGroup.add(instancedMesh);
 });
 });
 
 console.log(`[MicroCity] Created ${totalInstances} building instances across ${cityGroup.children.length} instanced meshes`);
 
// Position city group relative to key (local position within keyboard group)
cityGroup.position.set(
key.position.x,
key.position.y + (bbox.max.y - bbox.min.y) / 2, // Top of key (no offset)
key.position.z
);
 cityGroup.visible = false; // Hidden by default
 
 console.log(`[MicroCity] City positioned at: (${cityGroup.position.x.toFixed(3)}, ${cityGroup.position.y.toFixed(3)}, ${cityGroup.position.z.toFixed(3)})`);
 
 keyboardGroup.add(cityGroup);
 microCityGroups.push({ key, cityGroup });
 } catch (err) {
 console.error(`[MicroCity] Error creating city for key ${keyIndex}:`, err);
 }
 });
 
 console.log(`[MicroCity] ? Completed! Created cities on ${microCityGroups.length} keys`);
 }
 
 function updateMicroCityLOD() {
 if (!keys || keys.length === 0 || microCityGroups.length === 0) return;
 if (!window.guiParams || !window.guiParams.microCity) return;
 
 const params = window.guiParams.microCity;
 
 // Check if enabled
 if (!params['Enabled']) {
 microCityGroups.forEach(({ cityGroup }) => {
 cityGroup.visible = false;
 });
 cameraSlowdownFactor = 1.0;
 controls.rotateSpeed = 0.3;
 controls.zoomSpeed = 0.5;
 return;
 }
 
 // Use raycasting to find where camera is looking at keys
 const raycaster = new THREE.Raycaster();
 const cameraDirection = new THREE.Vector3();
 camera.getWorldDirection(cameraDirection);
 raycaster.set(camera.position, cameraDirection);
 
 // Raycast against all keys
 const intersects = raycaster.intersectObjects(keys, true);
 
 let closestKey = null;
 let closestCityGroup = null;
 let intersectionPoint = null;
 let closestDist = Infinity;
 
 if (intersects.length > 0) {
 // Find the closest key we're looking at
 const hit = intersects[0];
 intersectionPoint = hit.point.clone();
 
 // Find which key we hit
 let hitKey = hit.object;
 while (hitKey.parent && !keys.includes(hitKey)) {
 hitKey = hitKey.parent;
 }
 
if (keys.includes(hitKey)) {
closestKey = hitKey;
lastViewedKey = hitKey; // Track for drop functionality
closestDist = camera.position.distanceTo(intersectionPoint);

// Find the corresponding city group
for (const { key, cityGroup } of microCityGroups) {
if (key === closestKey) {
closestCityGroup = cityGroup;
 
 // Reposition city to intersection point (convert to keyboardGroup's local space)
 const worldPos = intersectionPoint.clone();
 const localToKeyboard = keyboardGroup.worldToLocal(worldPos);
 
 cityGroup.position.set(
 localToKeyboard.x,
 localToKeyboard.y + 0.01, // Slightly above surface
 localToKeyboard.z
 );
 break;
 }
 }
 }
 }
 
// Fallback: if no intersection, find closest key to camera
if (!closestKey) {
for (const { key, cityGroup } of microCityGroups) {
const keyWorldPos = new THREE.Vector3();
key.getWorldPosition(keyWorldPos);
const dist = camera.position.distanceTo(keyWorldPos);

if (dist < closestDist) {
closestDist = dist;
closestKey = key;
lastViewedKey = key; // Track for drop functionality
closestCityGroup = cityGroup;
}
}
}
 
 // LOD threshold - show micro cities when close
 const lodThreshold = params['LOD Distance'];
 const slowdownThreshold = params['Slowdown Distance'];
 const fadeRange = params['Fade Range'];
 
 if (closestDist < lodThreshold) {
 // Enable micro cities - static placement
 const fadeIn = THREE.MathUtils.clamp((lodThreshold - closestDist) / fadeRange, 0, 1);
 
 microCityGroups.forEach(({ key, cityGroup }) => {
 if (key === closestKey) {
 cityGroup.visible = true;
 cityGroup.scale.setScalar(1.0);
 
 // Ensure buildings are visible by setting material properties
 cityGroup.traverse((child) => {
 if (child.material) {
 child.material.opacity = Math.max(0.8, fadeIn); // Always at least 80% visible
 child.material.transparent = true;
 child.visible = true;
 }
 });
 
 // Debug: Log city info
 if (params['Show City Info'] && Math.random() < 0.02) { // Log occasionally
 const worldPos = new THREE.Vector3();
 cityGroup.getWorldPosition(worldPos);
 console.log(`[MicroCity LOD] Active on key "${closestKey.userData.label}"`);
 console.log(` Distance: ${closestDist.toFixed(3)}, Fade: ${fadeIn.toFixed(2)}`);
 console.log(` City position (local): ${cityGroup.position.x.toFixed(2)}, ${cityGroup.position.y.toFixed(2)}, ${cityGroup.position.z.toFixed(2)}`);
 console.log(` City position (world): ${worldPos.x.toFixed(2)}, ${worldPos.y.toFixed(2)}, ${worldPos.z.toFixed(2)}`);
 console.log(` Intersection: ${intersectionPoint ? `(${intersectionPoint.x.toFixed(2)}, ${intersectionPoint.y.toFixed(2)}, ${intersectionPoint.z.toFixed(2)})` : 'none'}`);
 console.log(` City children: ${cityGroup.children.length} instanced meshes, visible: ${cityGroup.visible}`);
 console.log(` Slowdown threshold: ${slowdownThreshold.toFixed(3)}`);
 
 // Log building info
 if (cityGroup.children.length > 0) {
 const firstMesh = cityGroup.children[0];
 const scale = cityGroup.userData.buildingScale || 0.008;
 console.log(` Building scale: ${scale.toFixed(4)}, instances: ${firstMesh.count}`);
 console.log(` Building material opacity: ${firstMesh.material.opacity.toFixed(2)}`);
 }
 }
 } else {
 cityGroup.visible = false;
 }
 });
 
 microCityVisible = true;
 
 // Camera slowdown effect - only when VERY close (inside slowdown threshold)
 if (closestDist < slowdownThreshold) {
 const slowdownAmount = params['Camera Slowdown'];
 const slowdownFade = THREE.MathUtils.clamp((slowdownThreshold - closestDist) / (slowdownThreshold * 0.5), 0, 1);
 cameraSlowdownFactor = 1.0 - slowdownFade * slowdownAmount;
 controls.rotateSpeed = 0.3 * cameraSlowdownFactor;
 controls.zoomSpeed = 0.5 * cameraSlowdownFactor;
 } else {
 // No slowdown yet, still approaching
 cameraSlowdownFactor = 1.0;
 controls.rotateSpeed = 0.3;
 controls.zoomSpeed = 0.5;
 }
 
 // Update status indicator
 const statusEl = document.getElementById('micro-city-state');
 if (statusEl) {
 const slowInfo = closestDist < slowdownThreshold ? ` [SLOW ${((1-cameraSlowdownFactor)*100).toFixed(0)}%]` : '';
 statusEl.textContent = `Active (${(fadeIn * 100).toFixed(0)}%) - ${closestKey.userData.label}${slowInfo}`;
 statusEl.style.color = closestDist < slowdownThreshold ? '#ff4a7c' : '#4a7cff';
 }
 
 } else {
 // Disable micro cities
 microCityGroups.forEach(({ cityGroup }) => {
 cityGroup.visible = false;
 });
 microCityVisible = false;
 cameraSlowdownFactor = 1.0;
 controls.rotateSpeed = 0.3;
 controls.zoomSpeed = 0.5;
 
 // Update status indicator
 const statusEl = document.getElementById('micro-city-state');
 if (statusEl) {
 statusEl.textContent = `Inactive (dist: ${closestDist.toFixed(2)})`;
 statusEl.style.color = '#888';
 }
 }
 }
 
 // ===== Frame of Reference System =====
 function createFrameOfReference() {
 console.log('[FrameOfRef] Creating frame of reference...');
 if (frameOfReference) {
 scene.remove(frameOfReference);
 }
 
 const grp = new THREE.Group();
 
 // Semi-transparent dark plane
 const planeW = 0.8, planeH = 0.45;
 const planeGeo = new THREE.PlaneGeometry(planeW, planeH);
 const planeMat = new THREE.MeshBasicMaterial({ 
 color: 0x000000, 
 opacity: 0.15, 
 transparent: true,
 depthWrite: false
 });
 const plane = new THREE.Mesh(planeGeo, planeMat);
 grp.add(plane);
 
 // Frame bars (blue metallic)
 const barThickness = 0.025;
 const zOff = 0.0;
 const barMat = new THREE.MeshStandardMaterial({ 
 color: 0xbcd9ff, 
 metalness: 0.1, 
 roughness: 0.6,
 emissive: 0x4a7cff,
 emissiveIntensity: 0.3
 });
 
 const topBar = new THREE.Mesh(
 new THREE.BoxGeometry(planeW, barThickness, barThickness), 
 barMat
 );
 topBar.position.set(0, planeH/2 + barThickness/2, zOff);
 
 const botBar = new THREE.Mesh(
 new THREE.BoxGeometry(planeW, barThickness, barThickness), 
 barMat
 );
 botBar.position.set(0, -planeH/2 - barThickness/2, zOff);
 
 const leftBar = new THREE.Mesh(
 new THREE.BoxGeometry(barThickness, planeH + 2*barThickness, barThickness), 
 barMat
 );
 leftBar.position.set(-planeW/2 - barThickness/2, 0, zOff);
 
 const rightBar = new THREE.Mesh(
 new THREE.BoxGeometry(barThickness, planeH + 2*barThickness, barThickness), 
 barMat
 );
 rightBar.position.set(planeW/2 + barThickness/2, 0, zOff);
 
 [topBar, botBar, leftBar, rightBar].forEach(b => {
 b.castShadow = false;
 b.receiveShadow = false;
 grp.add(b);
 });
 
 // Diegetic UI: Minimize/Maximize circle button at top right
 const circleRadius = 0.04;
 const circleGeo = new THREE.CircleGeometry(circleRadius, 32);
 const circleMat = new THREE.MeshBasicMaterial({ 
 color: 0xffa04a, 
 transparent: true, 
 opacity: 0.9,
 depthWrite: false
 });
 const circle = new THREE.Mesh(circleGeo, circleMat);
 circle.position.set(planeW/2 - circleRadius*1.5, planeH/2 - circleRadius*1.5, 0.01);
 circle.userData.isMinimizeButton = true;
 grp.add(circle);
 
 // Icon for minimize (horizontal line)
 const iconGeo = new THREE.PlaneGeometry(circleRadius * 1.2, circleRadius * 0.2);
 const iconMat = new THREE.MeshBasicMaterial({ 
 color: 0x1a1a1a, 
 transparent: true, 
 opacity: 1.0,
 depthWrite: false
 });
 const icon = new THREE.Mesh(iconGeo, iconMat);
 icon.position.set(planeW/2 - circleRadius*1.5, planeH/2 - circleRadius*1.5, 0.02);
 grp.add(icon);
 
 minimizeButton = { circle, icon, iconGeo };
 
 // === 3D Gizmo Buttons on Frame Border ===
 const buttonSize = 0.044;
 const buttonDepth = 0.012;
 const buttonSpacing = 0.06;
 const buttonY = -planeH/2 - barThickness - buttonSize/2 - 0.01; // Bottom border
 
 const gizmoButtons = [];
 
 // Button configurations: [label, mode, xOffset, color]
 const buttonConfigs = [
 ['?', 'translate', -buttonSpacing * 2.0, 0x4a9cff], // Blue
 ['?', 'rotate', -buttonSpacing * 1.0, 0xff9c4a], // Orange
 ['?', 'scale', buttonSpacing * 0.0, 0x9cff4a], // Green
 ['??', 'sculpt', buttonSpacing * 1.0, 0xffff4a], // Yellow (sculpt mode)
 ['S', 'snap', buttonSpacing * 2.0, 0xff4a9c] // Pink (snap toggle)
 ];
 
 buttonConfigs.forEach(([label, mode, xOffset, color]) => {
 // Button base (slightly raised from frame)
 const buttonGeo = new THREE.BoxGeometry(buttonSize, buttonSize, buttonDepth);
 const buttonMat = new THREE.MeshStandardMaterial({ 
 color: color,
 metalness: 0.3,
 roughness: 0.5,
 emissive: color,
 emissiveIntensity: 0.2
 });
 const button = new THREE.Mesh(buttonGeo, buttonMat);
 button.position.set(xOffset, buttonY, 0.015);
 button.userData.mode = mode;
 button.userData.isGizmoButton = true;
 button.userData.baseZ = 0.015;
 button.userData.pressedZ = 0.005;
 button.userData.isPressed = false;
 button.userData.isActive = (mode === 'translate'); // Translate starts active
 
 // Update material for active state
 if (button.userData.isActive) {
 buttonMat.emissiveIntensity = 0.5;
 }
 
 grp.add(button);
 
 // Label text on button
 const canvas = document.createElement('canvas');
 canvas.width = 64;
 canvas.height = 64;
 const ctx = canvas.getContext('2d');
 ctx.fillStyle = '#ffffff';
 ctx.font = 'bold 48px sans-serif';
 ctx.textAlign = 'center';
 ctx.textBaseline = 'middle';
 ctx.fillText(label, 32, 32);
 
 const labelTexture = new THREE.CanvasTexture(canvas);
 const labelMat = new THREE.MeshBasicMaterial({ 
 map: labelTexture, 
 transparent: true,
 depthWrite: false
 });
 const labelMesh = new THREE.Mesh(
 new THREE.PlaneGeometry(buttonSize * 0.8, buttonSize * 0.8),
 labelMat
 );
 labelMesh.position.set(xOffset, buttonY, 0.015 + buttonDepth/2 + 0.001);
 grp.add(labelMesh);
 
 gizmoButtons.push({ button, label: labelMesh, mode, xOffset });
 });
 
 grp.userData.gizmoButtons = gizmoButtons;
 grp.userData.width = planeW;
 grp.userData.height = planeH;
 grp.visible = false;
 
 frameOfReference = grp;
 scene.add(frameOfReference);
 
 console.log('[FrameOfRef] Frame created successfully with 4 gizmo buttons');
 }
 
 function toggleScaleMode() {
 scaleModeEnabled = !scaleModeEnabled;
 console.log('[FrameOfRef] Scale mode:', scaleModeEnabled ? 'ENABLED' : 'DISABLED');
 
 if (!frameOfReference) {
 createFrameOfReference();
 }
 
 if (scaleModeEnabled) {
 // Show frame
 frameOfReference.visible = true;
 frameMinimized = false;
 
 // Hide 2D gizmo toolbar
 const gizmoToolbar = document.getElementById('gizmo-toolbar');
 if (gizmoToolbar) {
 gizmoToolbar.style.display = 'none';
 }
 
 // Brighten lighting
 al.intensity = 0.35; // Was 0.15
 hl.intensity = 0.5; // Was 0.2
 dl.intensity = 1.5; // Was 0.9
 rimLight.intensity = 0.6; // Was 0.3
 
 // Spawn 3D objects
 createScaleObjects();
 
 console.log('[FrameOfRef] Lighting brightened, objects spawned, 3D gizmos active');
} else {
// Hide frame
frameOfReference.visible = false;

// Restore 2D gizmo toolbar
const gizmoToolbar = document.getElementById('gizmo-toolbar');
if (gizmoToolbar) {
gizmoToolbar.style.display = 'flex';
}

// Restore original lighting
al.intensity = 0.15;
hl.intensity = 0.2;
dl.intensity = 0.9;
rimLight.intensity = 0.3;

// Remove scale objects
scaleObjects.forEach(obj => scene.remove(obj));
scaleObjects = [];

console.log('[FrameOfRef] Lighting restored, objects removed, 2D gizmos restored');
}
 }
 
 function toggleFrameMinimize() {
 if (!frameOfReference) return;
 
 frameMinimized = !frameMinimized;
 
 // Find all children except the minimize button components
 frameOfReference.children.forEach(child => {
 if (child === minimizeButton.circle || child === minimizeButton.icon) {
 return; // Always show button
 }
 child.visible = !frameMinimized;
 });
 
 // Update icon: horizontal line for minimize, plus for maximize
 if (frameMinimized) {
 // Change to plus icon (two rectangles)
 minimizeButton.icon.geometry.dispose();
 const plusGeo1 = new THREE.PlaneGeometry(0.048, 0.008);
 const plusGeo2 = new THREE.PlaneGeometry(0.008, 0.048);
 minimizeButton.icon.geometry = plusGeo1;
 // Add vertical part
 if (!minimizeButton.iconPart2) {
 const iconMat = new THREE.MeshBasicMaterial({ 
 color: 0x1a1a1a, 
 transparent: true, 
 opacity: 1.0,
 depthWrite: false
 });
 minimizeButton.iconPart2 = new THREE.Mesh(plusGeo2, iconMat);
 minimizeButton.iconPart2.position.copy(minimizeButton.icon.position);
 frameOfReference.add(minimizeButton.iconPart2);
 } else {
 minimizeButton.iconPart2.visible = true;
 }
 } else {
 // Change to minus icon (horizontal line)
 minimizeButton.icon.geometry.dispose();
 const circleRadius = 0.04;
 const iconGeo = new THREE.PlaneGeometry(circleRadius * 1.2, circleRadius * 0.2);
 minimizeButton.icon.geometry = iconGeo;
 if (minimizeButton.iconPart2) {
 minimizeButton.iconPart2.visible = false;
 }
 }
 
 console.log('[FrameOfRef] Frame', frameMinimized ? 'minimized' : 'maximized');
 }
 
 function createScaleObjects() {
 // Clean up existing objects
 scaleObjects.forEach(obj => scene.remove(obj));
 scaleObjects = [];
 
 console.log('[FrameOfRef] Creating scale objects...');
 
 // Create various primitive objects around the scene
 const objects = [
 // Cubes of various sizes
 { type: 'box', size: [0.3, 0.3, 0.3], pos: [4, 1.5, 2], color: 0xff7a4a },
 { type: 'box', size: [0.5, 0.5, 0.5], pos: [8, 1.5, 4], color: 0x4a9cff },
 { type: 'box', size: [0.25, 0.6, 0.25], pos: [5, 1.5, 5], color: 0xffd04a },
 
 // Spheres
 { type: 'sphere', radius: 0.2, pos: [7, 1.8, 2], color: 0xff4a9c },
 { type: 'sphere', radius: 0.35, pos: [3, 1.5, 4], color: 0x7a4aff },
 
 // Cylinders
 { type: 'cylinder', size: [0.15, 0.6], pos: [6, 1.5, 6], color: 0x4affb0 },
 { type: 'cylinder', size: [0.2, 0.4], pos: [9, 1.5, 3], color: 0xffb04a },
 ];
 
 objects.forEach(spec => {
 let geo;
 if (spec.type === 'box') {
 geo = new THREE.BoxGeometry(...spec.size);
 } else if (spec.type === 'sphere') {
 geo = new THREE.SphereGeometry(spec.radius, 32, 32);
 } else if (spec.type === 'cylinder') {
 geo = new THREE.CylinderGeometry(spec.size[0], spec.size[0], spec.size[1], 32);
 }
 
 const mat = new THREE.MeshStandardMaterial({ 
 color: spec.color,
 metalness: 0.2,
 roughness: 0.6,
 emissive: spec.color,
 emissiveIntensity: 0.1
 });
 
 const mesh = new THREE.Mesh(geo, mat);
 mesh.position.set(...spec.pos);
 mesh.castShadow = true;
 mesh.receiveShadow = true;
 mesh.userData.isScaleObject = true;
 
 scene.add(mesh);
 scaleObjects.push(mesh);
 });
 
 console.log('[FrameOfRef] Created', scaleObjects.length, 'scale objects');
 }
 
 function updateFrameOfReference() {
 if (!frameOfReference || !frameOfReference.visible) return;
 
 // Position frame in front of camera
 const camPos = new THREE.Vector3();
 camera.getWorldPosition(camPos);
 
 const camDir = new THREE.Vector3();
 camera.getWorldDirection(camDir);
 
 // Place frame at distance in front of camera
 const offset = camDir.clone().multiplyScalar(frameDist);
 frameOfReference.position.copy(camPos).add(offset);
 
 // Orient frame to face camera
 frameOfReference.quaternion.copy(camera.quaternion);
 
 // Scale frame slightly for better visibility
 if (!frameOfReference.userData._resized) {
 const s = 1.2;
 frameOfReference.scale.set(s, s, s);
 frameOfReference.userData._resized = true;
 }
 }
 
 function makeRayTexture(){
 const c=document.createElement('canvas');
 c.width=8; c.height=256;
 const ctx=c.getContext('2d');
 const g=ctx.createLinearGradient(0,0,0,256);
 g.addColorStop(0,'rgba(255,255,255,0)');
 g.addColorStop(0.15,'rgba(255,255,255,0.08)');
 g.addColorStop(0.5,'rgba(255,255,255,0.15)');
 g.addColorStop(0.85,'rgba(255,255,255,0.08)');
 g.addColorStop(1,'rgba(255,255,255,0)');
 ctx.fillStyle=g; ctx.fillRect(0,0,c.width,c.height);
 const t=new THREE.CanvasTexture(c); 
 t.wrapS=t.wrapT=THREE.ClampToEdgeWrapping; 
 t.needsUpdate=true; 
 return t;
 }
 
 // Dust texture and ambient dust creation already defined earlier (line 540-624)
 
 // ===== Full Finger System from kb.html =====
 async function loadFinger(){
 try{
 const STATE={ LEN:0.78, PIP:0.78*0.40, DIP:0.78*(0.40+0.33), NAIL_START:0.67, NAIL_LEN:0.10 };
 const RAD={ BASE:0.065, PROX:0.058, MID:0.052, DIST:0.047, TIP:0.047 };
 const OVAL={ x:1.08, z:0.92 };
 const radialSegs=120, ySegs=220;
 let nailMesh, mcpBone, pipBone, dipBone, tipBone, skeleton;

 const LEN=STATE.LEN, PIP=STATE.PIP, DIP=STATE.DIP, PROX=PIP, MIDL=DIP-PIP, DIST=LEN-DIP;
 const JOINTS={ MCP:0, PIP, DIP, TIP:LEN };

 const lerp=(a,b,t)=>a+(b-a)*t, smooth=t=>t*t*(3-2*t);
 const baseR=y=>{
 if(y<=PIP){const t=y/PROX; return lerp(RAD.BASE,RAD.PROX,smooth(t))*(1.0+0.06*Math.exp(-((t-0.25)**2)/(2*0.18**2)));}
 if(y<=DIP){const t=(y-PIP)/MIDL; return lerp(RAD.PROX,RAD.MID,smooth(t))*(1.0+0.045*Math.exp(-((t-0.35)**2)/(2*0.18**2)));}
 const t=(y-DIP)/DIST; return lerp(RAD.MID,RAD.DIST,smooth(t))*(1.0+0.035*Math.exp(-((t-0.30)**2)/(2*0.18**2)));
 };
 const crease=(y,ang)=>{
 const c1=Math.exp(-((y-PIP)**2)/(2*(0.028*LEN)**2)); const c2=Math.exp(-((y-DIP)**2)/(2*(0.022*LEN)**2)); 
 const pal=0.55+0.45*Math.max(0,-Math.sin(ang)); const dor=1.0+0.05*Math.max(0,Math.sin(ang))*(c1*0.9+c2*0.6); 
 return (1.0-0.06*pal*c1-0.05*pal*c2)*dor;
 };
 const ellR=(ang,r)=>{const rx=r*OVAL.x, rz=r*OVAL.z; return Math.sqrt((rx*rx*rz*rz)/((rz*rz*Math.cos(ang)**2)+(rx*rx*Math.sin(ang)**2)));};
 
 const capSegs=24; const tubeYSegs=ySegs-capSegs; const tubeLen=LEN*0.94; const rBase=baseR(tubeLen);
 const pos=[], uv=[], idx=[]; let vertIdx=0;
 for(let yi=0; yi<=tubeYSegs; yi++){
 const y=(yi/tubeYSegs)*tubeLen, r0=baseR(y);
 for(let ai=0; ai<=radialSegs; ai++){
 const ang=(ai/radialSegs)*Math.PI*2; const r=ellR(ang,r0)*crease(y,ang); 
 pos.push(r*Math.cos(ang),y,r*Math.sin(ang)); 
 const isFingertip=(y>DIP)?1.0:0.0;
 const angNorm=(ang+Math.PI)/(Math.PI*2); 
 const isPalmar=Math.max(0,Math.min(1,1.0-Math.abs(angNorm-0.5)*4)); 
 const fpU=angNorm; 
 const fpV=0.5+isPalmar*isFingertip*((y-DIP)/(LEN-DIP))*0.5; 
 uv.push(fpU,fpV); 
 vertIdx++;
 }
 }
 for(let yi=1; yi<=capSegs; yi++){
 const phi=(yi/capSegs)*(Math.PI*0.5); const yOff=tubeLen+rBase*Math.sin(phi); const rCirc=rBase*Math.cos(phi);
 const blendT=Math.pow(Math.min(yi/6.0,1.0), 0.7);
 for(let ai=0; ai<=radialSegs; ai++){
 const theta=(ai/radialSegs)*Math.PI*2; 
 const tubeR=ellR(theta,baseR(tubeLen))*crease(tubeLen,theta);
 const capR=ellR(theta,rCirc)*crease(tubeLen,theta);
 const rEll=tubeR*(1.0-blendT)+capR*blendT;
 const x=rEll*Math.cos(theta); const z=rEll*Math.sin(theta); 
 pos.push(x,yOff,z); 
 const angNorm=(theta+Math.PI)/(Math.PI*2);
 const isPalmar=Math.max(0,Math.min(1,1.0-Math.abs(angNorm-0.5)*4));
 uv.push(angNorm,0.5+isPalmar*0.5); 
 vertIdx++;
 }
 }
 const totalRings=tubeYSegs+capSegs;
 for(let yi=0; yi<totalRings; yi++) for(let ai=0; ai<radialSegs; ai++){const a=yi*(radialSegs+1)+ai, b=a+1, c=a+(radialSegs+1), d=c+1; idx.push(a,c,b,b,c,d);}
 const tube=new THREE.BufferGeometry(); tube.setAttribute('position',new THREE.Float32BufferAttribute(pos,3)); tube.setAttribute('uv',new THREE.Float32BufferAttribute(uv,2)); tube.setIndex(idx); tube.computeVertexNormals(); tube.normalizeNormals();

 const nailSegW=52, nailSegL=20, nailWidth=4.20, nailThickness=0.004; const nailStartY=STATE.NAIL_START - 0.04, nailEndY=nailStartY+STATE.NAIL_LEN + 0.02; const nPos=[], nUV=[], nIdx=[];
 const nailBaseY=nailStartY; const nailBaseR=baseR(nailBaseY); 
 const getNailSurface=(yParam,u,topSide)=>{
 const vt=(yParam-nailStartY)/(nailEndY-nailStartY); const curveT=vt*vt*(3-2*vt); const fanOut=1.0+curveT*0.24;
 const uu=(u-0.5)*nailWidth*fanOut; const absU=Math.abs(uu); const angNail=uu/nailWidth*1.45; 
 const fingerAngle=angNail;
 const tubeRAtY = baseR(yParam);
 const tubeREll = ellR(fingerAngle, tubeRAtY) * crease(yParam, fingerAngle);
 const lateralWrap = Math.min(1.0, (tubeREll / nailBaseR) * 0.95);
 const edgeRound=(absU>0.60)?Math.min(Math.pow((absU-0.60)*2.2,1.3)*nailThickness*0.6,nailThickness*0.55):0;
 const rAtAngle=ellR(fingerAngle,nailBaseR)*crease(nailBaseY,fingerAngle); 
 const x=rAtAngle*Math.sin(fingerAngle); 
 const fingerZ=rAtAngle*Math.cos(fingerAngle); 
 const tipRound=vt*vt*0.012; 
 const curvatureOffset = rAtAngle * -0.46 - 0.006;
 let z=-fingerZ-(topSide?nailThickness:0)-(lateralWrap)*nailBaseR*0.65+edgeRound-tipRound-curvatureOffset; 
 return {x,y:yParam,z};
 };
 let vOff=0; for(let j=0;j<=nailSegL;j++){ const y=nailStartY+(j/nailSegL)*(nailEndY-nailStartY); for(let i=0;i<=nailSegW;i++){ const p=getNailSurface(y,i/nailSegW,true); nPos.push(p.x,p.y,p.z); nUV.push(i/nailSegW,j/nailSegL); if(j<nailSegL&&i<nailSegW){const a=vOff+j*(nailSegW+1)+i,b=a+1,c=a+(nailSegW+1),d=c+1; nIdx.push(a,c,b,b,c,d);} } }
 vOff=nPos.length/3; for(let j=0;j<=nailSegL;j++){ const y=nailStartY+(j/nailSegL)*(nailEndY-nailStartY); for(let i=0;i<=nailSegW;i++){ const p=getNailSurface(y,i/nailSegW,false); nPos.push(p.x,p.y,p.z); nUV.push(i/nailSegW,j/nailSegL); if(j<nailSegL&&i<nailSegW){const a=vOff+j*(nailSegW+1)+i,b=a+1,c=a+(nailSegW+1),d=c+1; nIdx.push(a,b,c,b,d,c);} } }
 const seal=(v0,ct,loop)=>{ for(let k=0;k<10;k++){ for(let m=0;m<ct-(loop?0:1);m++){ const a=v0+k*ct+m,b=a+1,c=a+ct,d=c+1; if(!loop&&m===ct-1)continue; const bAdj=loop&&m===ct-1?v0+k*ct:b; const dAdj=loop&&m===ct-1?v0+(k+1)*ct:d; nIdx.push(a,c,bAdj,bAdj,c,dAdj); } } };
 let ev0=nPos.length/3; for(let k=0;k<=10;k++){ for(let i=0;i<=nailSegW;i++){ const pT=getNailSurface(nailStartY,i/nailSegW,true); const pB=getNailSurface(nailStartY,i/nailSegW,false); const t=k/10; nPos.push(pT.x*(1-t)+pB.x*t,pT.y*(1-t)+pB.y*t,pT.z*(1-t)+pB.z*t); nUV.push(i/nailSegW,t); } } seal(ev0,nailSegW+1,false);
 ev0=nPos.length/3; for(let k=0;k<=10;k++){ for(let j=0;j<=nailSegL;j++){ const y=nailStartY+(j/nailSegL)*(nailEndY-nailStartY); const pT=getNailSurface(y,0,true); const pB=getNailSurface(y,0,false); const t=k/10; nPos.push(pT.x*(1-t)+pB.x*t,pT.y*(1-t)+pB.y*t,pT.z*(1-t)+pB.z*t); nUV.push(t,j/nailSegL); } } seal(ev0,nailSegL+1,false);
 ev0=nPos.length/3; for(let k=0;k<=10;k++){ for(let j=0;j<=nailSegL;j++){ const y=nailStartY+(j/nailSegL)*(nailEndY-nailStartY); const pT=getNailSurface(y,1,true); const pB=getNailSurface(y,1,false); const t=k/10; nPos.push(pT.x*(1-t)+pB.x*t,pT.y*(1-t)+pB.y*t,pT.z*(1-t)+pB.z*t); nUV.push(t,j/nailSegL); } } seal(ev0,nailSegL+1,false);
 ev0=nPos.length/3; for(let k=0;k<=10;k++){ for(let i=0;i<=nailSegW;i++){ const pT=getNailSurface(nailEndY,i/nailSegW,true); const pB=getNailSurface(nailEndY,i/nailSegW,false); const t=k/10; nPos.push(pT.x*(1-t)+pB.x*t,pT.y*(1-t)+pB.y*t,pT.z*(1-t)+pB.z*t); nUV.push(i/nailSegW,t); } } seal(ev0,nailSegW+1,false);
 const nailGeom=new THREE.BufferGeometry(); nailGeom.setAttribute('position',new THREE.Float32BufferAttribute(nPos,3)); nailGeom.setAttribute('uv',new THREE.Float32BufferAttribute(nUV,2)); nailGeom.setIndex(nIdx); nailGeom.computeVertexNormals();
 const tipLayerPos=[]; const tipLayerUV=[]; const tipLayerIdx=[];
 const extrudeAmt=0.0;
 const tipStart=Math.floor(nailSegL*0.60);
 let tv0=0;
 for(let j=tipStart;j<=nailSegL;j++){
 const tY=nailStartY+(j/nailSegL)*(nailEndY-nailStartY);
 for(let i=0;i<=nailSegW;i++){
 const pt=getNailSurface(tY,i/nailSegW,true);
 tipLayerPos.push(pt.x, pt.y, pt.z - extrudeAmt);
 tipLayerUV.push(i/nailSegW, j/nailSegL);
 if(j< nailSegL && i< nailSegW){ const a=tv0+(j-tipStart)*(nailSegW+1)+i, b=a+1, c=a+(nailSegW+1), d=c+1; tipLayerIdx.push(a,c,b,b,c,d); }
 }
 }
 const nailTipGeom=new THREE.BufferGeometry();
 if(tipLayerPos.length>0){
 nailTipGeom.setAttribute('position', new THREE.Float32BufferAttribute(tipLayerPos,3));
 nailTipGeom.setAttribute('uv', new THREE.Float32BufferAttribute(tipLayerUV,2));
 nailTipGeom.setIndex(tipLayerIdx);
 nailTipGeom.computeVertexNormals();
 }

 const P=tube.getAttribute('position');
 const colors=new Float32Array(P.count*4); 
 for(let i=0;i<P.count;i++){ 
 const y=P.getY(i); const x=P.getX(i); const z=P.getZ(i);
 const palmFactor=Math.max(0,-z)*0.08; 
 const tipWarmth=Math.exp(-((y-LEN*0.96)**2)/(2*(0.08*LEN)**2))*0.22;
 const pipWarmth=Math.exp(-((y-PIP)**2)/(2*(0.04*LEN)**2))*0.14;
 const dipWarmth=Math.exp(-((y-DIP)**2)/(2*(0.035*LEN)**2))*0.12;
 const cuticleWarmth=Math.exp(-((y-STATE.NAIL_START)**2)/(2*(0.02*LEN)**2))*0.18;
 const warmth=tipWarmth+pipWarmth+dipWarmth+cuticleWarmth+palmFactor;
 colors[i*4+0]=Math.min(1.0,0.96+warmth*0.55); 
 colors[i*4+1]=Math.min(1.0,0.80-warmth*0.12); 
 colors[i*4+2]=Math.min(1.0,0.74-warmth*0.24); 
 const isPalmar=Math.max(0,-z); 
 const isTip=(y>DIP)?1.0:0.0; 
 const fingerprintMask=Math.min(1.0,isPalmar*2.0)*Math.max(isTip*0.8,0.3); 
 colors[i*4+3]=fingerprintMask;
 }
 tube.setAttribute('color', new THREE.BufferAttribute(colors,4));

 const wrinkleData=new Float32Array(tube.getAttribute('position').count*3);
 for(let i=0;i<tube.getAttribute('position').count;i++){
 const y=P.getY(i); const x=P.getX(i); const z=P.getZ(i);
 const ang=Math.atan2(z,x); const r=Math.sqrt(x*x+z*z);
 const pipDist=Math.abs(y-PIP); const pipWrinkle=Math.max(0,Math.sin(ang))*Math.exp(-(pipDist**2)/(2*(0.008*LEN)**2))*Math.sin(ang*6)*0.0018;
 const pipWrinkle2=Math.max(0,Math.sin(ang))*Math.exp(-((y-PIP-0.008*LEN)**2)/(2*(0.005*LEN)**2))*Math.sin(ang*8)*0.0012;
 const pipWrinkle3=Math.max(0,Math.sin(ang))*Math.exp(-((y-PIP+0.008*LEN)**2)/(2*(0.005*LEN)**2))*Math.sin(ang*7)*0.0010;
 const dipWrinkle=Math.max(0,Math.sin(ang))*Math.exp(-((y-DIP)**2)/(2*(0.006*LEN)**2))*Math.sin(ang*7)*0.0012;
 const totalWrinkle=pipWrinkle+pipWrinkle2+pipWrinkle3+dipWrinkle;
 const nx=x/r; const nz=z/r;
 wrinkleData[i*3+0]=nx*totalWrinkle;
 wrinkleData[i*3+1]=0;
 wrinkleData[i*3+2]=nz*totalWrinkle;
 }
 tube.userData.wrinkleData=wrinkleData;
 tube.userData.originalPositions=new Float32Array(P.array);

 const skinIndex=new THREE.BufferAttribute(new Float32Array(tube.getAttribute('position').count*4),4);
 const skinWeight=new THREE.BufferAttribute(new Float32Array(tube.getAttribute('position').count*4),4);
 tube.setAttribute('skinIndex',skinIndex); tube.setAttribute('skinWeight',skinWeight);
 const feather=0.04*LEN;
 function setWeights(i, a,b, t){ skinIndex.setXYZW(i,a,b,0,0); skinWeight.setXYZW(i,1-t,t,0,0);} 
 for(let i=0;i<P.count;i++){
 const y=P.getY(i);
 if(y<=PIP){ const t=THREE.MathUtils.smoothstep(y, PIP-feather, PIP+feather); setWeights(i, 0,1, t); }
 else if(y<=DIP){ const edge=PIP; const t=THREE.MathUtils.smoothstep(y, DIP-feather, DIP+feather); setWeights(i, 1,2, t); }
 else { const t=THREE.MathUtils.smoothstep(y, LEN-feather, LEN); setWeights(i, 2,3, t); }
 }

 const nailSkinIndex=new THREE.BufferAttribute(new Float32Array(nailGeom.getAttribute('position').count*4),4);
 const nailSkinWeight=new THREE.BufferAttribute(new Float32Array(nailGeom.getAttribute('position').count*4),4);
 nailGeom.setAttribute('skinIndex',nailSkinIndex); nailGeom.setAttribute('skinWeight',nailSkinWeight);
 const nP=nailGeom.getAttribute('position');
 for(let i=0;i<nP.count;i++){
 const y=nP.getY(i);
 if(y<=PIP){ const t=THREE.MathUtils.smoothstep(y, PIP-feather, PIP+feather); nailSkinIndex.setXYZW(i,0,1,0,0); nailSkinWeight.setXYZW(i,1-t,t,0,0); }
 else if(y<=DIP){ const t=THREE.MathUtils.smoothstep(y, DIP-feather, DIP+feather); nailSkinIndex.setXYZW(i,1,2,0,0); nailSkinWeight.setXYZW(i,1-t,t,0,0); }
 else { const t=THREE.MathUtils.smoothstep(y, LEN-feather, LEN); nailSkinIndex.setXYZW(i,2,3,0,0); nailSkinWeight.setXYZW(i,1-t,t,0,0); }
 }

 if (nailTipGeom && nailTipGeom.getAttribute && nailTipGeom.getAttribute('position')){
 const tipPos = nailTipGeom.getAttribute('position');
 const tipSkinIndex = new THREE.BufferAttribute(new Float32Array(tipPos.count*4), 4);
 const tipSkinWeight = new THREE.BufferAttribute(new Float32Array(tipPos.count*4), 4);
 nailTipGeom.setAttribute('skinIndex', tipSkinIndex);
 nailTipGeom.setAttribute('skinWeight', tipSkinWeight);
 for(let i=0;i<tipPos.count;i++){
 const y = tipPos.getY(i);
 if(y<=PIP){ const t=THREE.MathUtils.smoothstep(y, PIP-feather, PIP+feather); tipSkinIndex.setXYZW(i,0,1,0,0); tipSkinWeight.setXYZW(i,1-t,t,0,0); }
 else if(y<=DIP){ const t=THREE.MathUtils.smoothstep(y, DIP-feather, DIP+feather); tipSkinIndex.setXYZW(i,1,2,0,0); tipSkinWeight.setXYZW(i,1-t,t,0,0); }
 else { const t=THREE.MathUtils.smoothstep(y, LEN-feather, LEN); tipSkinIndex.setXYZW(i,2,3,0,0); tipSkinWeight.setXYZW(i,1-t,t,0,0); }
 }
 }

 const fpCanvas=document.createElement('canvas'); fpCanvas.width=1024; fpCanvas.height=1024; const fpCtx=fpCanvas.getContext('2d');
 fpCtx.fillStyle='#FFFFFF';
 fpCtx.fillRect(0,0,1024,1024);
 const centerX=512, centerY=512;
 for(let r=25; r<380; r+=3.2){
 fpCtx.strokeStyle='#000000';
 fpCtx.lineWidth=2.8+Math.random()*1.2;
 fpCtx.beginPath();
 for(let a=0; a<Math.PI*2; a+=0.03){
 const spiral=r+Math.sin(a*6.5+r*0.09)*7+Math.sin(a*13+r*0.18)*3;
 const wobble=Math.sin(a*28)*1.2+Math.sin(a*19)*1.5;
 const noise=Math.sin(a*45+r*0.3)*0.8;
 const x=centerX+Math.cos(a)*(spiral+wobble+noise);
 const y=centerY+Math.sin(a)*(spiral+wobble+noise)*0.88;
 if(a===0)fpCtx.moveTo(x,y); else fpCtx.lineTo(x,y);
 }
 fpCtx.closePath(); fpCtx.stroke();
 }
 fpCtx.fillStyle='#000000';
 for(let i=0; i<800; i++){
 const angle=Math.random()*Math.PI*2;
 const dist=Math.random()*380;
 const x=centerX+Math.cos(angle)*dist;
 const y=centerY+Math.sin(angle)*dist*0.88;
 fpCtx.beginPath();
 fpCtx.arc(x,y,0.8+Math.random()*0.6,0,Math.PI*2);
 fpCtx.fill();
 }
 const fpTexture=new THREE.CanvasTexture(fpCanvas); 
 fpTexture.wrapS=THREE.RepeatWrapping; 
 fpTexture.wrapT=THREE.ClampToEdgeWrapping;
 fpTexture.repeat.set(2, 1);

 const npCanvas=document.createElement('canvas'); npCanvas.width=1024; npCanvas.height=1024; const npCtx=npCanvas.getContext('2d');
 npCtx.fillStyle='#F4D03F'; 
 npCtx.fillRect(0,0,1024,1024);
 for(let i=0; i<30; i++){
 const chipAngle=Math.random()*Math.PI*2;
 const chipDist=Math.random()*420;
 const chipX=512+Math.cos(chipAngle)*chipDist;
 const chipY=512+Math.sin(chipAngle)*chipDist;
 const chipSize=5+Math.random()*12;
 npCtx.fillStyle='#FFE8DC'; 
 npCtx.beginPath();
 for(let a=0; a<Math.PI*2; a+=Math.PI/4){
 const r=chipSize*(0.7+Math.random()*0.6);
 npCtx.lineTo(chipX+Math.cos(a)*r,chipY+Math.sin(a)*r);
 }
 npCtx.closePath();
 npCtx.fill();
 }
 for(let i=0; i<120; i++){
 const chipX=Math.random()*1024;
 const chipY=Math.random()*100; 
 const chipSize=2+Math.random()*10;
 npCtx.fillStyle='#FFE8DC';
 npCtx.beginPath();
 for(let a=0; a<Math.PI*2; a+=Math.PI/6){
 const r=chipSize*(0.5+Math.random()*0.8);
 npCtx.lineTo(chipX+Math.cos(a)*r,chipY+Math.sin(a)*r);
 }
 npCtx.closePath();
 npCtx.fill();
 }
 for(let i=0; i<200; i++){
 const chipX=Math.random()*1024;
 const chipY=Math.random()*40;
 const chipSize=1+Math.random()*4;
 npCtx.fillStyle='#FFE8DC';
 npCtx.beginPath();
 npCtx.arc(chipX,chipY,chipSize,0,Math.PI*2);
 npCtx.fill();
 }
 for(let i=0; i<80; i++){
 const x=Math.random()*1024;
 const y=Math.random()*1024;
 npCtx.fillStyle=`rgba(255,232,220,${0.2+Math.random()*0.3})`;
 npCtx.fillRect(x,y,1+Math.random()*3,1+Math.random()*4);
 }
 const npTexture=new THREE.CanvasTexture(npCanvas); npTexture.wrapS=npTexture.wrapT=THREE.ClampToEdgeWrapping;

 mcpBone=new THREE.Bone(); mcpBone.position.y=0;
 pipBone=new THREE.Bone(); pipBone.position.y=PROX; mcpBone.add(pipBone);
 dipBone=new THREE.Bone(); dipBone.position.y=MIDL; pipBone.add(dipBone);
 tipBone=new THREE.Bone(); tipBone.position.y=DIST; dipBone.add(tipBone);
 skeleton=new THREE.Skeleton([mcpBone,pipBone,dipBone,tipBone]);

 fpTexture.repeat.set(FP.scale*2, FP.scale);
 const skinMat=new THREE.MeshPhysicalMaterial({color:0xF2C6AC,roughness:0.56,metalness:0,clearcoat:0.06,clearcoatRoughness:0.85,vertexColors:true,side:THREE.DoubleSide,transparent:false,opacity:1.0,depthWrite:true,depthTest:true,alphaToCoverage:false,blending:THREE.NormalBlending,flatShading:false,forceSinglePass:true,displacementMap:FP.enabled?fpTexture:null,displacementScale:0.008*FP.strength,bumpMap:FP.enabled?fpTexture:null,bumpScale:0.10*FP.strength});
 
 function applyFpToMaterial(){
 const key = `${FP.enabled}-${FP.strength.toFixed(3)}-${FP.scale.toFixed(3)}`;
 if (FP._applied === key) return;
 fpTexture.repeat.set(FP.scale*2, FP.scale);
 skinMat.displacementMap = FP.enabled ? fpTexture : null;
 skinMat.bumpMap = FP.enabled ? fpTexture : null;
 skinMat.displacementScale = 0.008 * FP.strength;
 skinMat.bumpScale = 0.10 * FP.strength;
 skinMat.needsUpdate = true;
 FP._applied = key;
 }
 window.applyFpToMaterial = applyFpToMaterial;
 finger=new THREE.SkinnedMesh(tube,skinMat); finger.add(mcpBone); finger.bind(skeleton); finger.castShadow=false; finger.receiveShadow=false; finger.frustumCulled=false; finger.renderOrder=0; 
 const nailMat=new THREE.MeshPhysicalMaterial({map:npTexture,roughness:0.15,metalness:0.05,clearcoat:0.85,clearcoatRoughness:0.08,transparent:false,opacity:1.0,side:THREE.DoubleSide,depthWrite:true,depthTest:true,polygonOffset:true,polygonOffsetFactor:-1,polygonOffsetUnits:-1});
 nailMesh=new THREE.SkinnedMesh(nailGeom,nailMat); nailMesh.add(skeleton.bones[0].clone()); nailMesh.bind(skeleton); finger.add(nailMesh);
 if (nailTipGeom.getAttribute('position')){
 const nailTipMat=new THREE.MeshPhysicalMaterial({color:0xffffff,transparent:true,opacity:0.35,roughness:0.2,metalness:0.0,clearcoat:0.9,clearcoatRoughness:0.06,side:THREE.DoubleSide,depthWrite:false});
 const nailTip=new THREE.SkinnedMesh(nailTipGeom,nailTipMat);
 nailTip.add(skeleton.bones[0].clone()); nailTip.bind(skeleton); finger.add(nailTip);
 }
 
 const keyWidth = 0.8;
 const fingerWidth = RAD.BASE * 2;
 const scale = keyWidth / fingerWidth * 1.4;
 finger.scale.set(scale, scale, scale);
 finger.rotation.set(-Math.PI / 2 + 0.8, Math.PI, 0);
 finger.position.set(0, 0, 0); // Position relative to group
 
 // Create voxel wrap for finger
 // Global voxel wrap parameters
 window.voxelWrapStyle = 'Emerging'; // 'Emerging' or 'Voxelized'
 window.voxelWrapParams = {
 voxelSize: 0.012,
 sampleDensity: 12,
 emergingScale: 0.65,
 voxelizedScale: 1.1,
 rotationAmount: 0.1
 };
 
 const voxelSize = window.voxelWrapParams.voxelSize;
 const voxelGeometry = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);
 
 function createVoxelWrapForFinger(fingerMesh, bones, sampleDensity = 8) {
 const positions = fingerMesh.geometry.getAttribute('position');
 const skinIndices = fingerMesh.geometry.getAttribute('skinIndex');
 const skinWeights = fingerMesh.geometry.getAttribute('skinWeight');
 
 const voxelPositions = [];
 const voxelData = []; // Store bone info for each voxel
 
 // Sample the finger geometry
 for (let i = 0; i < positions.count; i += sampleDensity) {
 const localPos = new THREE.Vector3(
 positions.getX(i),
 positions.getY(i),
 positions.getZ(i)
 );
 
 // Get bone influences
 const boneIndices = [
 skinIndices.getX(i),
 skinIndices.getY(i),
 skinIndices.getZ(i),
 skinIndices.getW(i)
 ];
 const boneWeights = [
 skinWeights.getX(i),
 skinWeights.getY(i),
 skinWeights.getZ(i),
 skinWeights.getW(i)
 ];
 
 voxelPositions.push(localPos);
 voxelData.push({ indices: boneIndices, weights: boneWeights });
 }
 
 // Create geometry using current voxel size parameter
 const currentVoxelSize = window.voxelWrapParams ? window.voxelWrapParams.voxelSize : 0.012;
 const currentVoxelGeometry = new THREE.BoxGeometry(currentVoxelSize, currentVoxelSize, currentVoxelSize);
 
 // Create instanced mesh with deconstructed look
 const instancedMesh = new THREE.InstancedMesh(
 currentVoxelGeometry,
 new THREE.MeshStandardMaterial({ 
 color: 0xFF6B9D,
 roughness: 0.6,
 metalness: 0.2,
 flatShading: true,
 emissive: 0xFF1493,
 emissiveIntensity: 0.2,
 transparent: true,
 opacity: 0.85
 }),
 voxelPositions.length
 );
 
 instancedMesh.castShadow = true;
 instancedMesh.receiveShadow = true;
 instancedMesh.visible = false; // Hidden by default
 instancedMesh.name = "VoxelWrap";
 
 // Store voxel data for updates
 instancedMesh.userData.voxelData = voxelData;
 instancedMesh.userData.voxelPositions = voxelPositions;
 instancedMesh.userData.bones = bones;
 instancedMesh.userData.fingerMesh = fingerMesh;
 
 // Ensure voxel mesh has identity transform in local space
 // It will inherit parent finger's scale, rotation, and position
 instancedMesh.position.set(0, 0, 0);
 instancedMesh.rotation.set(0, 0, 0);
 instancedMesh.scale.set(1, 1, 1);
 
 console.log(`[VoxelWrap] Created ${voxelPositions.length} voxels for finger (will inherit parent transforms)`);
 
 return instancedMesh;
 }
 
 const voxelWrapMesh = createVoxelWrapForFinger(finger, skeleton.bones, 12);
 finger.add(voxelWrapMesh);
 finger.userData.voxelWrap = voxelWrapMesh;
 
 console.log(`[VoxelWrap] Main finger voxel wrap added as child (inherits scale: ${finger.scale.x.toFixed(3)}, rotation: ${finger.rotation.x.toFixed(3)})`);
 
 // Update voxel positions based on bone transforms
 function updateVoxelWrap(voxelMesh) {
 if (!voxelMesh || !voxelMesh.visible) return;
 
 const voxelData = voxelMesh.userData.voxelData;
 const voxelPositions = voxelMesh.userData.voxelPositions;
 const bones = voxelMesh.userData.bones;
 const fingerMesh = voxelMesh.userData.fingerMesh;
 
 if (!fingerMesh || !fingerMesh.skeleton) return;
 
 const matrix = new THREE.Matrix4();
 const skinMatrix = new THREE.Matrix4();
 const pos = new THREE.Vector3();
 const tmpVec = new THREE.Vector3();
 
 // Update bone matrices
 fingerMesh.skeleton.update();
 
 for (let i = 0; i < voxelPositions.length; i++) {
 const localPos = voxelPositions[i].clone();
 const data = voxelData[i];
 
 // Initialize accumulation
 pos.set(0, 0, 0);
 let totalWeight = 0;
 
 // Blend bone transforms by weight (standard skinning)
 for (let j = 0; j < 4; j++) {
 const boneIndex = data.indices[j];
 const weight = data.weights[j];
 
 if (weight > 0 && boneIndex < bones.length && bones[boneIndex]) {
 const bone = bones[boneIndex];
 
 // Compute skinning matrix: boneMatrix * inverseBindMatrix
 skinMatrix.multiplyMatrices(
 bone.matrixWorld,
 fingerMesh.skeleton.boneInverses[boneIndex]
 );
 
 // Transform the local position by skinning matrix
 tmpVec.copy(localPos);
 tmpVec.applyMatrix4(skinMatrix);
 
 // Accumulate weighted position
 pos.add(tmpVec.multiplyScalar(weight));
 totalWeight += weight;
 }
 }
 
 // Normalize if weights don't sum to 1
 if (totalWeight > 0 && Math.abs(totalWeight - 1.0) > 0.001) {
 pos.divideScalar(totalWeight);
 }
 
 // Convert from world space back to finger's local space
 // (since voxelMesh is a child of finger and inherits its transforms)
 tmpVec.copy(pos);
 fingerMesh.worldToLocal(tmpVec);
 
 // Apply style-specific transforms
 const style = window.voxelWrapStyle || 'Emerging';
 const params = window.voxelWrapParams || { emergingScale: 0.65, voxelizedScale: 1.1, rotationAmount: 0.1 };
 
 let voxelScale, shouldRotate;
 
 if (style === 'Emerging') {
 voxelScale = params.emergingScale; // Smaller, more scattered
 shouldRotate = true;
 } else { // 'Voxelized' - solid array, NO rotation
 voxelScale = params.voxelizedScale; // Larger, more solid array look
 shouldRotate = false;
 }
 
 // Create transform matrix for this voxel in local space
 matrix.makeTranslation(tmpVec.x, tmpVec.y, tmpVec.z);
 
 // Add rotation ONLY for Emerging style
 if (shouldRotate && style === 'Emerging') {
 const rotationVariation = (i * 0.123) % (Math.PI * 2);
 const rotMat = new THREE.Matrix4().makeRotationY(rotationVariation * params.rotationAmount);
 matrix.multiply(rotMat);
 }
 
 // Apply scale
 const scaleMat = new THREE.Matrix4().makeScale(voxelScale, voxelScale, voxelScale);
 matrix.multiply(scaleMat);
 
 voxelMesh.setMatrixAt(i, matrix);
 }
 
 voxelMesh.instanceMatrix.needsUpdate = true;
 }
 
 finger.userData.updateVoxelWrap = () => updateVoxelWrap(voxelWrapMesh);
 
 // Expose functions globally for static fingers
 window.createVoxelWrapForFinger = createVoxelWrapForFinger;
 window.updateVoxelWrap = updateVoxelWrap;
 
 // Create hand groups
 handsGroup = new THREE.Group();
 handsGroup.name = "Hands";
 rightHandGroup = new THREE.Group();
 rightHandGroup.name = "Right Hand";
 rightHandGroup.position.set(9.0, 4.5, -0.8); // Right hand base position
 rightHandGroup.add(finger);
 handsGroup.add(rightHandGroup);
 scene.add(handsGroup);

 const fingerBaseY = rightHandGroup.position.y;
 const fingerBaseZ = rightHandGroup.position.z;

 let hoveredKey = null;
 let targetKeyX = rightHandGroup.position.x;
 let targetKeyZ = 1.6;
 let pressedKey = null;
 let pressingFinger = false;
 let fingerPressStart = 0;
 const fingerSmoothSpeed = 0.08;
 const fingerPressDuration = 80;
 const fingerReleaseDuration = 150;

 function getKeyTopWorldY(key){
 if(!key) return null;
 const box = new THREE.Box3().setFromObject(key);
 return box.max.y;
 }

 function getFrontRowRestKey(){
 let best=null; let bestZ=-Infinity;
 for(const k of keys){
 const lbl=k.userData?.label;
 if(lbl==='Space') continue;
 if(k.position.z>bestZ){ best=k; bestZ=k.position.z; }
 }
 return best;
 }

 function computeKeyboardZSign(){
 let minZ=Infinity, maxZ=-Infinity;
 for(const k of keys){
 const z=k.position.z; if(z<minZ) minZ=z; if(z>maxZ) maxZ=z;
 }
 if(!isFinite(minZ)||!isFinite(maxZ)||Math.abs(maxZ-minZ)<1e-3) return 1;
 return (maxZ>minZ)? 1 : -1;
 }
 const keyboardZSign = computeKeyboardZSign();

 const fingerRaycaster = new THREE.Raycaster();
 const fingerMouse = new THREE.Vector2();
 let targetKeyTopY = null;
 const hoverGap = 0.05;
 renderer.domElement.addEventListener('pointermove', (e) => {
 const rect = renderer.domElement.getBoundingClientRect();
 fingerMouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
 fingerMouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
 fingerRaycaster.setFromCamera(fingerMouse, camera);
 const hits = fingerRaycaster.intersectObjects(keys, false);
 if (hits.length > 0) {
 hoveredKey = hits[0].object;
 targetKeyX = hoveredKey.position.x;
 targetKeyZ = hoveredKey.position.z;
 const topY = getKeyTopWorldY(hoveredKey);
 targetKeyTopY = (topY!=null? topY : finger.position.y) + hoverGap;
 } else {
 const restKey = getFrontRowRestKey();
 hoveredKey = null;
 if(restKey){
 targetKeyX = restKey.position.x;
 targetKeyZ = restKey.position.z;
 const topY = getKeyTopWorldY(restKey);
 targetKeyTopY = (topY!=null? topY : finger.position.y) + hoverGap;
 }else{
 targetKeyTopY = null;
 }
 }
 });
 renderer.domElement.addEventListener('pointerleave', ()=>{
 hoveredKey = null;
 targetKeyTopY = null;
 });
 renderer.domElement.addEventListener('mouseleave', ()=>{
 hoveredKey = null;
 targetKeyTopY = null;
 });

 renderer.domElement.addEventListener('pointerdown', (e) => {
 if (hoveredKey) {
 pressingFinger = true;
 pressedKey = hoveredKey;
 fingerPressStart = Date.now();
 
 // Animate key depression
 if (!hoveredKey.userData.pressed) {
 hoveredKey.userData.pressed = true;
 hoveredKey.userData.velY = -0.03;
 }
 }
 });

 const params = { Animate: true, Speed: 1.0, Amp: 1.0, MCP_Flex: 20, MCP_Splay: 0, PIP_Flex: 45, DIP_Flex: 30 };

 function getFingerTipWorldPos() {
 const tipWorldPos = new THREE.Vector3();
 tipBone.updateWorldMatrix(true, false);
 tipBone.getWorldPosition(tipWorldPos);
 return tipWorldPos;
 }

 function getMcpWorldPos(){
 const p = new THREE.Vector3();
 mcpBone.updateWorldMatrix(true, false);
 mcpBone.getWorldPosition(p);
 return p;
 }

 let t0 = performance.now();
 function animFinger() {
 const t = (performance.now() - t0) / 1000;
 
 const tipWorld = getFingerTipWorldPos();
 
 const targetTipX = targetKeyX;
 const targetTipZ = targetKeyZ;
 
 const currentTipX = tipWorld.x;
 const currentTipZ = tipWorld.z;
 const currentTipY = tipWorld.y;
 
 if (targetKeyTopY!=null) {
 const padBias = 0.0;
 const desiredTip = new THREE.Vector3(targetTipX, targetKeyTopY - padBias, targetTipZ - keyboardZSign * 0.10);
 const rootToTip = new THREE.Vector3().copy(tipWorld).sub(rightHandGroup.position);
 const followPos = new THREE.Vector3().copy(desiredTip).sub(rootToTip);
 rightHandGroup.position.lerp(followPos, 0.28);
 const baseBehind = THREE.MathUtils.lerp(0.70, 1.40, Math.min(1, Math.abs(targetTipZ) / 3.5));
 const targetBaseZConst = desiredTip.z - keyboardZSign * baseBehind;
 rightHandGroup.position.z = THREE.MathUtils.lerp(rightHandGroup.position.z, targetBaseZConst, 0.35);
 } else {
 const deltaX = (targetTipX - currentTipX) * fingerSmoothSpeed;
 const deltaZ = (targetTipZ - currentTipZ) * fingerSmoothSpeed;
 const deltaY = (targetKeyTopY!=null ? (targetKeyTopY - currentTipY) * fingerSmoothSpeed : 0);
 rightHandGroup.position.x += deltaX;
 rightHandGroup.position.z += deltaZ;
 rightHandGroup.position.y += deltaY;
 }

 if (hoveredKey && targetKeyTopY!=null){
 const fingerBounds = new THREE.Box3().setFromObject(finger);
 const bottomY = fingerBounds.min.y;
 const desiredY = targetKeyTopY;
 const alignDy = THREE.MathUtils.clamp(desiredY - bottomY, -0.25, 0.25);
 rightHandGroup.position.y += alignDy * 0.6;
 }

 if (targetKeyTopY!=null){
 const mcpW = getMcpWorldPos();
 const minMcpY = targetKeyTopY + 0.35;
 if (mcpW.y < minMcpY){
 rightHandGroup.position.y += (minMcpY - mcpW.y);
 }
 }

 const minKeyZ = 0.0;
 const maxKeyZ = 3.5;
 const reachFactor = THREE.MathUtils.clamp((targetKeyZ - minKeyZ) / (maxKeyZ - minKeyZ), 0, 1);
 
 const frontEase = reachFactor;
 const baseCurl = THREE.MathUtils.lerp(34, 20, frontEase);
 const curlRange = THREE.MathUtils.lerp(30, 16, frontEase);
 const extend = hoveredKey ? (1.0 - reachFactor) : 0.0;
 let targetMCPFlex = baseCurl + curlRange * reachFactor - 14 * extend;
 let targetPIPFlex = 52 + 24 * reachFactor - 16 * extend;
 let targetDIPFlex = 38 + 16 * reachFactor - 14 * extend;
 targetMCPFlex = Math.max(0, targetMCPFlex);
 targetPIPFlex = Math.max(0, targetPIPFlex);
 targetDIPFlex = Math.max(0, targetDIPFlex);

 if (staticFingers && staticFingers.length){
 const idle = hoveredKey ? 0 : 1;
 staticFingers.forEach((f, idx)=>{
 // Static fingers follow automatically as children of hand groups
 // Just update their bone rotations
 const curlStep = 10 * (idx+1);
 const boost = 22 + idle * 16 + curlStep;
 const b = f.bones;
 b.mcp.rotation.x = THREE.MathUtils.degToRad(params.MCP_Flex + boost);
 b.pip.rotation.x = THREE.MathUtils.degToRad(params.PIP_Flex + boost*1.15);
 b.dip.rotation.x = THREE.MathUtils.degToRad((params.DIP_Flex + boost) * 0.72);
 b.tip.rotation.x = THREE.MathUtils.degToRad((params.DIP_Flex + boost) * 0.28);
 });
 }

 let pressRotation = 0;
 let tipExtend = -0.22 * extend;
 if (pressingFinger && pressedKey) {
 const elapsed = Date.now() - fingerPressStart;
 const pressDepth = 0.5;
 const tipExtendAmount = -0.3;
 
 if (elapsed < fingerPressDuration) {
 const t = elapsed / fingerPressDuration;
 const eased = t * t * (3 - 2 * t);
 pressRotation = -pressDepth * eased;
 tipExtend = tipExtendAmount * eased;
 } else if (elapsed < fingerPressDuration + fingerReleaseDuration) {
 const t = (elapsed - fingerPressDuration) / fingerReleaseDuration;
 const eased = 1 - (t * t * (3 - 2 * t));
 pressRotation = -pressDepth * eased;
 tipExtend = tipExtendAmount * eased;
 } else {
 pressingFinger = false;
 pressedKey = null;
 pressRotation = 0;
 tipExtend = 0;
 }
 }
 
 if (!hoveredKey){
 const retreat = THREE.MathUtils.lerp(0.0, 0.25, frontEase);
 const targetZ = fingerBaseZ - retreat;
 rightHandGroup.position.z = THREE.MathUtils.lerp(rightHandGroup.position.z, targetZ, 0.12);
 }
 const baseTilt = 0.92;
 finger.rotation.x = -Math.PI / 2 + baseTilt + pressRotation;

 const sp = params.Speed, A = 0.3, anim = params.Animate ? 1 : 0;
 const currentMCPFlex = THREE.MathUtils.lerp(
 THREE.MathUtils.degToRad(params.MCP_Flex),
 THREE.MathUtils.degToRad(targetMCPFlex),
 0.1
 );
 params.MCP_Flex = THREE.MathUtils.lerp(params.MCP_Flex, targetMCPFlex, 0.1);
 params.PIP_Flex = THREE.MathUtils.lerp(params.PIP_Flex, targetPIPFlex, 0.1);
 params.DIP_Flex = THREE.MathUtils.lerp(params.DIP_Flex, targetDIPFlex, 0.1);

 const mcpForwardBias = THREE.MathUtils.degToRad(8.5);
 mcpBone.rotation.x = THREE.MathUtils.degToRad(params.MCP_Flex) + anim * (0.25 * A * Math.sin(t * 0.6 * sp)) + mcpForwardBias;
 mcpBone.rotation.z = THREE.MathUtils.degToRad(params.MCP_Splay) + anim * (0.02 * Math.sin(t * 0.8 * sp));
 const pipForwardBias = THREE.MathUtils.degToRad(14);
 const pipFlex = THREE.MathUtils.degToRad(params.PIP_Flex) + anim * (0.65 * A * Math.sin(t * 0.7 * sp + 1)) + tipExtend * 0.6 + pipForwardBias;
 const dipFlex = THREE.MathUtils.degToRad(params.DIP_Flex) + anim * (0.55 * A * Math.sin(t * 0.9 * sp + 2)) + tipExtend * 0.9;
 pipBone.rotation.x = pipFlex;
 dipBone.rotation.x = dipFlex * 0.72;
 tipBone.rotation.x = dipFlex * 0.28;

 if (finger && finger.geometry.userData.wrinkleData) {
 const wrinkleData = finger.geometry.userData.wrinkleData;
 const origPos = finger.geometry.userData.originalPositions;
 const pos = finger.geometry.getAttribute('position');
 const pipWrinkleAmount = Math.max(0, -pipFlex) * 2.5;
 const dipWrinkleAmount = Math.max(0, -dipFlex) * 2.5;
 for (let i = 0; i < pos.count; i++) {
 const y = origPos[i * 3 + 1];
 let wrinkleIntensity = 0;
 if (Math.abs(y - PIP) < 0.05 * LEN) wrinkleIntensity += pipWrinkleAmount;
 if (Math.abs(y - DIP) < 0.04 * LEN) wrinkleIntensity += dipWrinkleAmount;
 wrinkleIntensity = Math.min(wrinkleIntensity, 1.0);
 pos.setXYZ(i,
 origPos[i * 3 + 0] + wrinkleData[i * 3 + 0] * wrinkleIntensity,
 origPos[i * 3 + 1] + wrinkleData[i * 3 + 1] * wrinkleIntensity,
 origPos[i * 3 + 2] + wrinkleData[i * 3 + 2] * wrinkleIntensity
 );
 }
 pos.needsUpdate = true;
 finger.geometry.computeVertexNormals();
 }

 requestAnimationFrame(animFinger);
 }
 animFinger();
 
 window.__indexFinger = { finger, mcpBone, pipBone, dipBone, tipBone, skeleton, nailMesh, LEN, PIP, DIP, params };
 }catch(e){ console.warn('Full finger rig load failed',e); }
 }
 
 // Add static fingers (3 additional fingers for right hand)
 setTimeout(() => {
 if (!window.__indexFinger) return;
 const ref = window.__indexFinger;
 const fingerConfigs = [
 { x: 1.2, scale: 0.98, curl: 1.05, name: 'middle' },
 { x: 2.4, scale: 0.95, curl: 1.10, name: 'ring' },
 { x: 3.6, scale: 0.90, curl: 1.15, name: 'pinky' }
 ];
 
 fingerConfigs.forEach((config) => {
 const clonedFingerGeo = ref.finger.geometry.clone();
 const clonedFingerMat = ref.finger.material.clone();
 const clonedFinger = new THREE.SkinnedMesh(clonedFingerGeo, clonedFingerMat);
 
 const clonedMcp = new THREE.Bone();
 clonedMcp.position.copy(ref.mcpBone.position);
 const clonedPip = new THREE.Bone();
 clonedPip.position.copy(ref.pipBone.position);
 const clonedDip = new THREE.Bone();
 clonedDip.position.copy(ref.dipBone.position);
 const clonedTip = new THREE.Bone();
 clonedTip.position.copy(ref.tipBone.position);
 
 clonedMcp.add(clonedPip);
 clonedPip.add(clonedDip);
 clonedDip.add(clonedTip);
 
 clonedFinger.add(clonedMcp);
 const clonedSkeleton = new THREE.Skeleton([clonedMcp, clonedPip, clonedDip, clonedTip]);
 clonedFinger.bind(clonedSkeleton);
 
 const curlFactor = config.curl;
 clonedMcp.rotation.x = THREE.MathUtils.degToRad(ref.params.MCP_Flex * curlFactor);
 clonedPip.rotation.x = THREE.MathUtils.degToRad(ref.params.PIP_Flex * curlFactor);
 clonedDip.rotation.x = THREE.MathUtils.degToRad(ref.params.DIP_Flex * curlFactor * 0.72);
 clonedTip.rotation.x = THREE.MathUtils.degToRad(ref.params.DIP_Flex * curlFactor * 0.28);
 
 // Position relative to main finger - start at same base position
 clonedFinger.position.set(config.x, 0, 0); // Offset in local space
 clonedFinger.rotation.copy(ref.finger.rotation);
 const baseScale = ref.finger.scale.x;
 const scaleVal = baseScale * config.scale;
 clonedFinger.scale.set(scaleVal, scaleVal, scaleVal);
 
 clonedFinger.userData.offsetX = config.x;
 clonedFinger.userData.isStatic = true;
 
 if (ref.nailMesh && ref.nailMesh.geometry) {
 const clonedNailGeo = ref.nailMesh.geometry.clone();
 const clonedNailMat = ref.nailMesh.material.clone();
 const clonedNail = new THREE.SkinnedMesh(clonedNailGeo, clonedNailMat);
 
 clonedNail.bind(clonedSkeleton);
 clonedFinger.add(clonedNail);
 
 if (ref.finger.children) {
 const nailTipOriginal = ref.finger.children.find(c => c.material && c.material.transparent && c.material.opacity < 0.5);
 if (nailTipOriginal && nailTipOriginal.geometry) {
 const clonedTipGeo = nailTipOriginal.geometry.clone();
 const clonedTipMat = nailTipOriginal.material.clone();
 const clonedTip = new THREE.SkinnedMesh(clonedTipGeo, clonedTipMat);
 clonedTip.bind(clonedSkeleton);
 clonedFinger.add(clonedTip);
 }
 }
 }
 
 // Create voxel wrap for static finger (reuse function from main finger)
 if (window.createVoxelWrapForFinger) {
 try {
 const staticVoxelWrap = window.createVoxelWrapForFinger(clonedFinger, clonedSkeleton.bones, 12);
 clonedFinger.add(staticVoxelWrap);
 clonedFinger.userData.voxelWrap = staticVoxelWrap;
 clonedFinger.userData.updateVoxelWrap = () => {
 if (window.updateVoxelWrap) {
 window.updateVoxelWrap(staticVoxelWrap);
 }
 };
 console.log(`[VoxelWrap] Created voxel wrap for static finger: ${config.name}`);
 } catch (err) {
 console.warn(`[VoxelWrap] Could not create voxel wrap for ${config.name}:`, err);
 }
 }
 
 rightHandGroup.add(clonedFinger);
 staticFingers.push({ 
 fingerMesh: clonedFinger,
 mesh: clonedFinger, 
 bones: { mcp: clonedMcp, pip: clonedPip, dip: clonedDip, tip: clonedTip },
 baseCurl: curlFactor,
 phase: Math.random() * Math.PI * 2
 });
 });
 }, 100);

 // Add LEFT HAND (4 fingers)
 setTimeout(() => {
 if (!window.__indexFinger) return;
 const ref = window.__indexFinger;
 
 // Create left hand group
 leftHandGroup = new THREE.Group();
 leftHandGroup.name = "Left Hand";
 leftHandGroup.position.set(3.0, 4.5, -0.8); // Left side of keyboard
 handsGroup.add(leftHandGroup);
 
 const leftFingerConfigs = [
 { x: 0.0, scale: 1.0, curl: 1.0, name: 'index-L' }, // Match main pointer finger
 { x: -1.2, scale: 0.98, curl: 1.05, name: 'middle-L' }, // Match right hand middle
 { x: -2.4, scale: 0.95, curl: 1.10, name: 'ring-L' }, // Match right hand ring
 { x: -3.6, scale: 0.90, curl: 1.15, name: 'pinky-L' } // Match right hand pinky
 ];
 
 leftFingerConfigs.forEach((config) => {
 const clonedFingerGeo = ref.finger.geometry.clone();
 const clonedFingerMat = ref.finger.material.clone();
 const clonedFinger = new THREE.SkinnedMesh(clonedFingerGeo, clonedFingerMat);
 
 const clonedMcp = new THREE.Bone();
 clonedMcp.position.copy(ref.mcpBone.position);
 const clonedPip = new THREE.Bone();
 clonedPip.position.copy(ref.pipBone.position);
 const clonedDip = new THREE.Bone();
 clonedDip.position.copy(ref.dipBone.position);
 const clonedTip = new THREE.Bone();
 clonedTip.position.copy(ref.tipBone.position);
 
 clonedMcp.add(clonedPip);
 clonedPip.add(clonedDip);
 clonedDip.add(clonedTip);
 
 clonedFinger.add(clonedMcp);
 const clonedSkeleton = new THREE.Skeleton([clonedMcp, clonedPip, clonedDip, clonedTip]);
 clonedFinger.bind(clonedSkeleton);
 
 const curlFactor = config.curl;
 clonedMcp.rotation.x = THREE.MathUtils.degToRad(ref.params.MCP_Flex * curlFactor);
 clonedPip.rotation.x = THREE.MathUtils.degToRad(ref.params.PIP_Flex * curlFactor);
 clonedDip.rotation.x = THREE.MathUtils.degToRad(ref.params.DIP_Flex * curlFactor * 0.72);
 clonedTip.rotation.x = THREE.MathUtils.degToRad(ref.params.DIP_Flex * curlFactor * 0.28);
 
 // Position relative in local space
 clonedFinger.position.set(config.x, 0, 0);
 clonedFinger.rotation.copy(ref.finger.rotation);
 const baseScale = ref.finger.scale.x;
 const scaleVal = baseScale * config.scale;
 clonedFinger.scale.set(scaleVal, scaleVal, scaleVal);
 
 clonedFinger.userData.offsetX = config.x;
 clonedFinger.userData.isLeftHand = true;
 
 if (ref.nailMesh && ref.nailMesh.geometry) {
 const clonedNailGeo = ref.nailMesh.geometry.clone();
 const clonedNailMat = ref.nailMesh.material.clone();
 const clonedNail = new THREE.SkinnedMesh(clonedNailGeo, clonedNailMat);
 
 clonedNail.bind(clonedSkeleton);
 clonedFinger.add(clonedNail);
 
 if (ref.finger.children) {
 const nailTipOriginal = ref.finger.children.find(c => c.material && c.material.transparent && c.material.opacity < 0.5);
 if (nailTipOriginal && nailTipOriginal.geometry) {
 const clonedTipGeo = nailTipOriginal.geometry.clone();
 const clonedTipMat = nailTipOriginal.material.clone();
 const clonedTip = new THREE.SkinnedMesh(clonedTipGeo, clonedTipMat);
 clonedTip.bind(clonedSkeleton);
 clonedFinger.add(clonedTip);
 }
 }
 }
 
 // Create voxel wrap for left hand finger
 if (window.createVoxelWrapForFinger) {
 try {
 const staticVoxelWrap = window.createVoxelWrapForFinger(clonedFinger, clonedSkeleton.bones, 12);
 clonedFinger.add(staticVoxelWrap);
 clonedFinger.userData.voxelWrap = staticVoxelWrap;
 clonedFinger.userData.updateVoxelWrap = () => {
 if (window.updateVoxelWrap) {
 window.updateVoxelWrap(staticVoxelWrap);
 }
 };
 console.log(`[VoxelWrap] Created voxel wrap for left hand finger: ${config.name}`);
 } catch (err) {
 console.warn(`[VoxelWrap] Could not create voxel wrap for ${config.name}:`, err);
 }
 }
 
 leftHandGroup.add(clonedFinger);
 staticFingers.push({ 
 fingerMesh: clonedFinger,
 mesh: clonedFinger, 
 bones: { mcp: clonedMcp, pip: clonedPip, dip: clonedDip, tip: clonedTip },
 baseCurl: curlFactor,
 phase: Math.random() * Math.PI * 2
 });
 });
 }, 100);

 function initializeCharacter() {
 // Create Celli Avatar group
 celliAvatarGroup = new THREE.Group();
 celliAvatarGroup.name = "Celli Avatar";
 
 characterGroup = new THREE.Group();
 characterGroup.name = "Celli Body";
 characterGroup.visible = true; // Visible by default
 characterGroup.position.set(0, 0, 0); // Relative to celliAvatarGroup
 characterGroup.scale.setScalar(0.8); // Match human scale relative to keyboard
 
 // Create character bust from bust.html code - ZSphere system
 skinMat = new THREE.MeshPhysicalMaterial({
 color: 0xe7e2dc,
 roughness: 0.55,
 metalness: 0.0,
 clearcoat: 0.4,
 clearcoatRoughness: 0.6,
 sheen: 0.5,
 sheenRoughness: 0.8,
 });
 
 // ZSphere structure for hourglass figure
 characterZSpheres = [
 // Torso chain
 { pos: new THREE.Vector3(0, 0.15, 0), radius: 0.44, scale: new THREE.Vector3(1.0, 0.5, 0.9), parent: -1, name: "Hips" },
 { pos: new THREE.Vector3(0, 0.35, 0), radius: 0.34, scale: new THREE.Vector3(0.68, 0.7, 0.6), parent: 0, name: "Waist" },
 { pos: new THREE.Vector3(0, 0.58, 0), radius: 0.38, scale: new THREE.Vector3(0.88, 0.65, 0.72), parent: 1, name: "Ribcage" },
 { pos: new THREE.Vector3(0, 0.82, 0), radius: 0.36, scale: new THREE.Vector3(0.95, 0.5, 0.78), parent: 2, name: "Upper Chest" },
 // Breasts
 { pos: new THREE.Vector3(-0.18, 0.68, 0.12), radius: 0.16, scale: new THREE.Vector3(0.95, 1.1, 1.15), parent: 2, name: "Left Breast" },
 { pos: new THREE.Vector3(0.18, 0.68, 0.12), radius: 0.16, scale: new THREE.Vector3(0.95, 1.1, 1.15), parent: 2, name: "Right Breast" },
 // Left arm
 { pos: new THREE.Vector3(-0.32, 0.82, 0), radius: 0.14, scale: new THREE.Vector3(1.0, 1.0, 1.0), parent: 3, name: "Left Shoulder" },
 { pos: new THREE.Vector3(-0.38, 0.72, 0), radius: 0.10, scale: new THREE.Vector3(1.0, 1.2, 1.0), parent: 6, name: "Left Bicep Upper" },
 { pos: new THREE.Vector3(-0.42, 0.58, 0), radius: 0.09, scale: new THREE.Vector3(1.0, 1.3, 1.0), parent: 7, name: "Left Bicep Lower" },
 // Right arm
 { pos: new THREE.Vector3(0.32, 0.82, 0), radius: 0.14, scale: new THREE.Vector3(1.0, 1.0, 1.0), parent: 3, name: "Right Shoulder" },
 { pos: new THREE.Vector3(0.38, 0.72, 0), radius: 0.10, scale: new THREE.Vector3(1.0, 1.2, 1.0), parent: 9, name: "Right Bicep Upper" },
 { pos: new THREE.Vector3(0.42, 0.58, 0), radius: 0.09, scale: new THREE.Vector3(1.0, 1.3, 1.0), parent: 10, name: "Right Bicep Lower" },
 ];
 
 // Create merged geometry from ZSpheres (preview mesh)
 function createPreviewMesh() {
 const geometries = characterZSpheres.map(sphere => {
 const geo = new THREE.SphereGeometry(sphere.radius, 48, 32);
 geo.scale(sphere.scale.x, sphere.scale.y, sphere.scale.z);
 geo.translate(sphere.pos.x, sphere.pos.y, sphere.pos.z);
 return geo;
 });
 
 const merged = BufferGeometryUtils.mergeGeometries(geometries, false);
 merged.computeVertexNormals();
 
 // Create a separate material instance for preview mesh
 const previewMat = new THREE.MeshPhysicalMaterial({
 color: 0xe7e2dc,
 roughness: 0.55,
 metalness: 0.0,
 clearcoat: 0.4,
 clearcoatRoughness: 0.6,
 sheen: 0.5,
 sheenRoughness: 0.8,
 });
 
 return new THREE.Mesh(merged, previewMat);
 }
 
 // Create unified mesh with proper wrapping/smoothing
 // Helper: Calculate distance from point to ellipsoid surface
 function distanceToEllipsoid(point, sphere) {
 const localX = (point.x - sphere.pos.x) / sphere.scale.x;
 const localY = (point.y - sphere.pos.y) / sphere.scale.y;
 const localZ = (point.z - sphere.pos.z) / sphere.scale.z;
 
 const dist = Math.sqrt(localX * localX + localY * localY + localZ * localZ);
 return dist - sphere.radius;
 }
 
 // Helper: Check if two spheres are connected (parent-child relationship)
 function areConnected(idx1, idx2) {
 if (idx1 === idx2) return true;
 
 const s1 = characterZSpheres[idx1];
 const s2 = characterZSpheres[idx2];
 
 // Direct parent-child relationship
 if (s1.parent === idx2 || s2.parent === idx1) return true;
 
 // Siblings (same parent)
 if (s1.parent !== -1 && s1.parent === s2.parent) return true;
 
 // Check connection through chain
 let current = idx1;
 for (let i = 0; i < 10; i++) { // Max depth
 if (current === idx2) return true;
 if (current === -1) break;
 const sphere = characterZSpheres[current];
 current = sphere ? sphere.parent : -1;
 }
 
 current = idx2;
 for (let i = 0; i < 10; i++) {
 if (current === idx1) return true;
 if (current === -1) break;
 const sphere = characterZSpheres[current];
 current = sphere ? sphere.parent : -1;
 }
 
 return false;
 }
 
 // Helper: Find furthest surface point along a ray direction (with bone hierarchy)
 function findExteriorRadius(y, theta) {
 const dir = new THREE.Vector3(Math.cos(theta), 0, Math.sin(theta));
 let maxRadius = 0;
 let closestSphereIdx = -1;
 
 // Sample along the ray to find where any sphere is present
 for (let r = 0; r < 1.0; r += 0.005) {
 const testPoint = new THREE.Vector3(dir.x * r, y, dir.z * r);
 
 // Check distance to each sphere
 let minDist = Infinity;
 let nearestIdx = -1;
 
 characterZSpheres.forEach((sphere, idx) => {
 const dist = distanceToEllipsoid(testPoint, sphere);
 if (dist < minDist) {
 minDist = dist;
 nearestIdx = idx;
 }
 });
 
 // Only blend if connected to the closest sphere found so far
 if (closestSphereIdx === -1 || areConnected(nearestIdx, closestSphereIdx)) {
 if (minDist < 0.02) { // Soft threshold for smoother blend
 maxRadius = r;
 if (closestSphereIdx === -1) {
 closestSphereIdx = nearestIdx;
 }
 }
 }
 }
 
 return maxRadius;
 }
 
 // Laplacian smoothing for mesh
 function smoothMesh(positions, radialSegments, heightSegments, iterations = 3) {
 const smoothed = new Float32Array(positions);
 
 for (let iter = 0; iter < iterations; iter++) {
 const temp = new Float32Array(smoothed);
 
 for (let h = 1; h < heightSegments; h++) { // Skip top and bottom
 for (let r = 0; r <= radialSegments; r++) {
 const idx = (h * (radialSegments + 1) + r) * 3;
 
 // Get neighbors
 const neighbors = [];
 // Above and below
 if (h > 0) neighbors.push((h - 1) * (radialSegments + 1) + r);
 if (h < heightSegments) neighbors.push((h + 1) * (radialSegments + 1) + r);
 // Left and right (circular)
 const rPrev = r === 0 ? radialSegments - 1 : r - 1;
 const rNext = r === radialSegments ? 1 : r + 1;
 neighbors.push(h * (radialSegments + 1) + rPrev);
 neighbors.push(h * (radialSegments + 1) + rNext);
 
 // Average neighbor positions
 let avgX = 0, avgY = 0, avgZ = 0;
 for (const nIdx of neighbors) {
 avgX += temp[nIdx * 3];
 avgY += temp[nIdx * 3 + 1];
 avgZ += temp[nIdx * 3 + 2];
 }
 avgX /= neighbors.length;
 avgY /= neighbors.length;
 avgZ /= neighbors.length;
 
 // Blend with original (higher weight on XZ, less on Y)
 smoothed[idx] = temp[idx] * 0.3 + avgX * 0.7;
 smoothed[idx + 1] = temp[idx + 1] * 0.7 + avgY * 0.3; // Less smoothing on Y
 smoothed[idx + 2] = temp[idx + 2] * 0.3 + avgZ * 0.7;
 }
 }
 }
 
 return smoothed;
 }
 
 // Create unified tubular mesh that wraps around body shapes (bust.html method)
 function createUnifiedMesh() {
 const radialSegments = 64;
 const heightSegments = 100;
 const height = 1.0;
 
 const positions = [];
 const indices = [];
 
 // Generate vertices by tracing exterior surface
 for (let h = 0; h <= heightSegments; h++) {
 const y = (h / heightSegments) * height;
 
 // Generate ring of vertices by finding exterior boundary
 for (let r = 0; r <= radialSegments; r++) {
 const theta = (r / radialSegments) * Math.PI * 2;
 
 // Find the actual exterior radius at this height and angle
 const radius = findExteriorRadius(y, theta);
 
 const x = Math.cos(theta) * radius;
 const z = Math.sin(theta) * radius;
 
 positions.push(x, y, z);
 }
 }
 
 // Apply smoothing
 const smoothedPositions = smoothMesh(positions, radialSegments, heightSegments, 5);
 
 // Generate indices
 for (let h = 0; h < heightSegments; h++) {
 for (let r = 0; r < radialSegments; r++) {
 const a = h * (radialSegments + 1) + r;
 const b = a + 1;
 const c = (h + 1) * (radialSegments + 1) + r;
 const d = c + 1;
 
 indices.push(a, c, b);
 indices.push(b, c, d);
 }
 }
 
 const geometry = new THREE.BufferGeometry();
 geometry.setAttribute('position', new THREE.BufferAttribute(smoothedPositions, 3));
 geometry.setIndex(indices);
 geometry.computeVertexNormals();
 
 const unifiedMat = new THREE.MeshPhysicalMaterial({
 color: 0xe7e2dc,
 roughness: 0.55,
 metalness: 0.0,
 clearcoat: 0.4,
 clearcoatRoughness: 0.6,
 sheen: 0.5,
 sheenRoughness: 0.8,
 });
 
 console.log('[UnifiedMesh] Created true unified tubular mesh using bust.html method (exterior surface tracing)');
 return new THREE.Mesh(geometry, unifiedMat);
 }
 
 // Create both meshes with their own materials
 characterBust = createPreviewMesh();
 characterBust.castShadow = true;
 characterBust.receiveShadow = false;
 characterBust.visible = true; // Show base mesh by default
 characterBust.name = "PreviewMesh";
 characterGroup.add(characterBust);
 
 characterUnifiedMesh = createUnifiedMesh();
 characterUnifiedMesh.castShadow = true;
 characterUnifiedMesh.receiveShadow = false;
 characterUnifiedMesh.visible = false; // Hidden by default
 characterUnifiedMesh.name = "UnifiedMesh";
 characterGroup.add(characterUnifiedMesh);
 
 // Store sphere markers for editing (initially hidden)
 characterZSpheres.forEach((sphere, idx) => {
 const markerGeo = new THREE.SphereGeometry(sphere.radius * 0.95, 16, 16);
 const markerMat = new THREE.MeshBasicMaterial({ 
 color: 0x4a7cff, 
 transparent: true,
 opacity: 0.3,
 wireframe: true 
 });
 const marker = new THREE.Mesh(markerGeo, markerMat);
 marker.position.copy(sphere.pos);
 marker.scale.copy(sphere.scale);
 marker.userData.sphereIndex = idx;
 marker.visible = false;
 characterGroup.add(marker);
 characterPoseSpheres.push(marker);
 });
 
 // Plinth/base
 const plinth = new THREE.Mesh(
 new THREE.CylinderGeometry(0.42, 0.46, 0.18, 48),
 new THREE.MeshStandardMaterial({ color:0x1a1e25, metalness:0.1, roughness:0.85 })
 );
 plinth.position.y = 0.12;
 plinth.receiveShadow = true;
 characterGroup.add(plinth);
 
 // Slight rotation for posed look
 characterGroup.rotation.y = THREE.MathUtils.degToRad(10);
 
celliAvatarGroup.add(characterGroup);
}

// ===== Head Preset Configurations =====
// Define presets before initializeVoxelHead uses them
const headPresets = {
'sparse-blue': {
animSpeed: 1.15, amplitude: 0.15, opacityMin: 0.3, opacityMax: 0.85,
emissive: 0.8, lightInt: 2.5, lightPulse: true, rotationSpeed: 0.3, color: '#95bfff',
voxelSize: 0.10, shellThickness: 0.12, voxelSpacing: 1.05, phaseNoise: 0.75, 
falloff: 0.85, noiseWarp: 0.15, opacitySpeed: 0.8, metalness: 0.2, roughness: 0.55
},
'intro-celli': {
animSpeed: 1.15, amplitude: 0.28, opacityMin: 0.85, opacityMax: 0.95,
emissive: 0.6, lightInt: 3.5, lightPulse: true, rotationSpeed: 0.3, color: '#ffb850',
voxelSize: 0.25, shellThickness: 0.35, voxelSpacing: 0.9, phaseNoise: 0.75,
falloff: 0.85, noiseWarp: 0.15, opacitySpeed: 0.8, metalness: 0.2, roughness: 0.55
},
'dense-cyan': {
animSpeed: 0.8, amplitude: 0.25, opacityMin: 0.5, opacityMax: 0.95,
emissive: 1.2, lightInt: 3.5, lightPulse: true, rotationSpeed: 0.2, color: '#00ffff',
voxelSize: 0.10, shellThickness: 0.20, voxelSpacing: 1.05, phaseNoise: 0.75,
falloff: 0.85, noiseWarp: 0.15, opacitySpeed: 0.8, metalness: 0.2, roughness: 0.55
},
'warm-glow': {
animSpeed: 1.5, amplitude: 0.12, opacityMin: 0.4, opacityMax: 0.9,
emissive: 1.5, lightInt: 4.0, lightPulse: false, rotationSpeed: 0.15, color: '#ffaa55',
voxelSize: 0.10, shellThickness: 0.12, voxelSpacing: 1.05, phaseNoise: 0.75,
falloff: 0.85, noiseWarp: 0.15, opacitySpeed: 0.8, metalness: 0.2, roughness: 0.55
},
'neon-pink': {
animSpeed: 2.0, amplitude: 0.2, opacityMin: 0.35, opacityMax: 0.88,
emissive: 1.8, lightInt: 5.0, lightPulse: true, rotationSpeed: 0.5, color: '#ff1493',
voxelSize: 0.10, shellThickness: 0.12, voxelSpacing: 1.05, phaseNoise: 0.75,
falloff: 0.85, noiseWarp: 0.15, opacitySpeed: 0.8, metalness: 0.2, roughness: 0.55
},
'ghost-white': {
animSpeed: 0.5, amplitude: 0.08, opacityMin: 0.15, opacityMax: 0.5,
emissive: 0.5, lightInt: 1.5, lightPulse: false, rotationSpeed: 0.1, color: '#f0f0ff',
voxelSize: 0.10, shellThickness: 0.12, voxelSpacing: 1.05, phaseNoise: 0.75,
falloff: 0.85, noiseWarp: 0.15, opacitySpeed: 0.8, metalness: 0.2, roughness: 0.55
}
};

function initializeVoxelHead() {
voxelHeadGroup = new THREE.Group();
voxelHeadGroup.name = "Celli Head";
// In sequence mode, head is visible; in debug mode, default to hidden
voxelHeadGroup.visible = EXEC_ENV_MODE === 'sequence';
voxelHeadGroup.position.set(0, 1.5, 0); // Relative to body (character is at -3, 0.5, 3)
voxelHeadGroup.scale.setScalar(0.3);

// Create glowing voxel head using SDF-based shell wrapping (from bosscelli.html)
// Get preset based on mode
const defaultPreset = EXEC_ENV_MODE === 'sequence' ? 'intro-celli' : 'sparse-blue';
const preset = headPresets[defaultPreset];

// Use preset parameters (can be overridden via debug controls)
const voxelSize = window.headVoxelSize || preset.voxelSize;
const headSizeX = 2.4;
const headSizeY = 1.6; // Shorter height
const headSizeZ = 1.4; // Much thinner, more slab-like (was 2.2)
const cornerRadius = 0.45; // More rounded corners (was 0.35)
const shellThickness = window.headVoxelLayers || preset.shellThickness;
 
 // Helper: SDF for rounded box (head shape)
 function sdfRoundedBox(p, hx, hy, hz, r) {
 const qx = Math.abs(p.x) - hx;
 const qy = Math.abs(p.y) - hy;
 const qz = Math.abs(p.z) - hz;
 const q = new THREE.Vector3(Math.max(qx, 0), Math.max(qy, 0), Math.max(qz, 0));
 const outside = q.length();
 const inside = Math.min(Math.max(qx, Math.max(qy, qz)), 0.0);
 return outside + inside - r;
 }
 
 // Check if point is in face cutout (eyes, mouth)
 function isInFaceCutout(p) {
 // Only check front face
 if (p.z < headSizeZ * 0.25) return false;
 
 // Eyes (elliptical)
 const eyeRadiusX = headSizeY * 0.22;
 const eyeRadiusY = headSizeY * 0.16;
 const eyeY = headSizeY * 0.15;
 const eyeSpacing = headSizeX * 0.3;
 
 const leftEyeX = (p.x + eyeSpacing) / eyeRadiusX;
 const leftEyeY = (p.y - eyeY) / eyeRadiusY;
 if (leftEyeX * leftEyeX + leftEyeY * leftEyeY < 1.0) return true;
 
 const rightEyeX = (p.x - eyeSpacing) / eyeRadiusX;
 const rightEyeY = (p.y - eyeY) / eyeRadiusY;
 if (rightEyeX * rightEyeX + rightEyeY * rightEyeY < 1.0) return true;
 
 // Smile/Frown (controlled by deformation parameter: 1=smile, 0=neutral, -1=frown)
 const mouthDeform = window.headMouthDeform !== undefined ? window.headMouthDeform : 1.0;
 const smileRadius = headSizeY * 0.08;
 const smileY = -headSizeY * 0.2;
 const smileWidth = headSizeX * 0.55;
 const smileCurve = headSizeY * 0.15 * mouthDeform; // Curve direction controlled by deform
 
 const smileT = (p.x / smileWidth) + 0.5;
 if (smileT >= 0 && smileT <= 1) {
 const smileYOffset = -Math.pow((smileT - 0.5) * 2, 2) * smileCurve;
 const smileCenterY = smileY + smileYOffset;
 const smileDist = Math.abs(p.y - smileCenterY);
 if (smileDist < smileRadius && Math.abs(p.x) < smileWidth * 0.5) {
 return true;
 }
 }
 
 return false;
 }
 
 // Generate voxel shell
 const half = new THREE.Vector3(headSizeX * 0.5, headSizeY * 0.5, headSizeZ * 0.5);
 const margin = cornerRadius + shellThickness + 0.4;
 const min = new THREE.Vector3(-half.x - margin, -half.y - margin, -half.z - margin);
 const max = new THREE.Vector3(half.x + margin, half.y + margin, half.z + margin);
 
// Voxel spacing controlled by global parameter or preset
const voxelSpacing = window.headVoxelSpacing || preset.voxelSpacing;
const step = voxelSize * voxelSpacing;
 const instances = [];
 
 for (let x = min.x; x <= max.x; x += step) {
 for (let y = min.y; y <= max.y; y += step) {
 for (let z = min.z; z <= max.z; z += step) {
 const p = new THREE.Vector3(x, y, z);
 const d = sdfRoundedBox(p, half.x, half.y, half.z, cornerRadius);
 
 if (d > -0.02 && d < shellThickness) {
 if (!isInFaceCutout(p)) {
 instances.push({
 basePos: p.clone(),
 id: instances.length,
 colorAlt: instances.length % 5 === 0
 });
 }
 }
 }
 }
 }
 
console.log(`[Voxel Head] Generated ${instances.length} voxel instances (voxelSize: ${voxelSize}, spacing: ${voxelSpacing}, shellThickness: ${shellThickness})`);

// Create instanced mesh with preset color
const cubeGeo = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);
const presetColor = new THREE.Color(preset.color);
const instancedMesh = new THREE.InstancedMesh(
cubeGeo,
new THREE.MeshStandardMaterial({ 
color: presetColor,
metalness: preset.metalness,
roughness: preset.roughness,
transparent: true,
opacity: preset.opacityMax, // Use preset max opacity for base material
emissive: presetColor,
emissiveIntensity: preset.emissive,
depthWrite: false,
side: THREE.DoubleSide
}),
instances.length
);
instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

// Enable per-instance colors for "TURN BACK" text highlighting
instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(
new Float32Array(instances.length * 3), 3
);
// Initialize all colors to preset color
const defaultColor = new THREE.Color(preset.color);
for (let i = 0; i < instances.length; i++) {
instancedMesh.setColorAt(i, defaultColor);
}
instancedMesh.instanceColor.needsUpdate = true;
 
 // Set initial positions
 const tmpObj = new THREE.Object3D();
 instances.forEach((inst, i) => {
 tmpObj.position.copy(inst.basePos);
 tmpObj.scale.setScalar(voxelSize);
 tmpObj.updateMatrix();
 instancedMesh.setMatrixAt(i, tmpObj.matrix);
 });
 
voxelHeadGroup.add(instancedMesh);
voxelHeadGroup.userData.instances = instances;
voxelHeadGroup.userData.instancedMesh = instancedMesh;
voxelHeadGroup.userData.baseVoxelSize = voxelSize; // Store base size
voxelHeadGroup.userData.isSequenceMode = EXEC_ENV_MODE === 'sequence'; // Store mode
voxelHeadGroup.userData.currentPreset = defaultPreset; // Store which preset is active

// Add internal glow light with preset color
const headLight = new THREE.PointLight(presetColor, preset.lightInt, 4);
headLight.position.set(0, 0, 0);
voxelHeadGroup.add(headLight);
voxelHeadGroup.userData.headLight = headLight;

// Add eye lights (positioned behind the eye cutouts)
const eyeY = headSizeY * 0.15;
const eyeSpacing = headSizeX * 0.3;
const eyeLightZ = -headSizeZ * 0.3; // Behind the eyes

const leftEyeLight = new THREE.PointLight(0xffffaa, 2.5, 2);
leftEyeLight.position.set(-eyeSpacing, eyeY, eyeLightZ);
voxelHeadGroup.add(leftEyeLight);

const rightEyeLight = new THREE.PointLight(0xffffaa, 2.5, 2);
rightEyeLight.position.set(eyeSpacing, eyeY, eyeLightZ);
voxelHeadGroup.add(rightEyeLight);

voxelHeadGroup.userData.eyeLights = [leftEyeLight, rightEyeLight];

// Add pulsating pink cheek orbs (positioned on the sides of the face)
const cheekY = headSizeY * 0.05; // Slightly below eyes
const cheekX = headSizeX * 0.55; // On the sides
const cheekZ = headSizeZ * 0.4; // Front of face

const cheekGeometry = new THREE.SphereGeometry(0.15, 16, 16);
cheekGeometry.scale(1.2, 0.8, 0.6); // Make it oval (wider than tall)

const cheekMaterial = new THREE.MeshStandardMaterial({
color: 0xff69b4, // Pink
emissive: 0xff69b4,
emissiveIntensity: 0.6,
transparent: true,
opacity: 0.7,
roughness: 0.3,
metalness: 0.1
});

const leftCheek = new THREE.Mesh(cheekGeometry, cheekMaterial.clone());
leftCheek.position.set(-cheekX, cheekY, cheekZ);
voxelHeadGroup.add(leftCheek);

const rightCheek = new THREE.Mesh(cheekGeometry, cheekMaterial.clone());
rightCheek.position.set(cheekX, cheekY, cheekZ);
voxelHeadGroup.add(rightCheek);

voxelHeadGroup.userData.cheeks = [leftCheek, rightCheek];
voxelHeadGroup.userData.cheekBaseScale = 1.0;

console.log(`[Voxel Head] Mode: ${EXEC_ENV_MODE}, Preset: ${defaultPreset}, Color: ${preset.color}, Visible: ${voxelHeadGroup.visible}, Instances: ${instances.length}`);
 
celliAvatarGroup.add(voxelHeadGroup);

// Position, rotate, and scale the avatar
celliAvatarGroup.position.set(6, 2.0, 22); // Raised Y significantly (was -5.0)
celliAvatarGroup.rotation.y = Math.PI + THREE.MathUtils.degToRad(10); // 180 + 10 clockwise for alignment

// Scale based on mode: narrative mode uses smaller, more natural scale; debug mode uses large scale for editing
const avatarScale = EXEC_ENV_MODE === 'sequence' ? 5.0 : 30.0;
celliAvatarGroup.scale.setScalar(avatarScale);

console.log(`[Avatar] Celli positioned: pos(6, 2.0, 22), rotation 190Â°, scale ${avatarScale}x (${EXEC_ENV_MODE} mode)`);

scene.add(celliAvatarGroup);
 }
 
 // ===== Sculpt Mode for Character Editing =====
 let sculptMode = false;
 let sculptInflateRadius = 0.1;
 let sculptInflateStrength = 0.05;
 
 function enableSculptMode() {
 console.log('[Sculpt] Enabling sculpt mode...');
 sculptMode = true;
 
 // Hide transform controls
 if (transformControl) {
 transformControl.detach();
 }
 
 // Show character and jump to it
 if (characterBust) characterBust.visible = true;
 if (characterGroup) characterGroup.visible = true;
 
 alert('Sculpt Mode: Click and hold on character to inflate. Mode: Inflate by default.');
 }
 
 // Mouse sculpt handling
 let isSculpting = false;
 let sculptTarget = null;
 
 renderer.domElement.addEventListener('mousedown', (event) => {
 if (!sculptMode) return;
 
 const raycaster = new THREE.Raycaster();
 const mouse = new THREE.Vector2();
 mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
 mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
 raycaster.setFromCamera(mouse, camera);
 
 const intersects = raycaster.intersectObjects([characterBust, characterUnifiedMesh].filter(m => m && m.visible), true);
 
 if (intersects.length > 0) {
 isSculpting = true;
 sculptTarget = intersects[0];
 console.log('[Sculpt] Started sculpting at:', sculptTarget.point);
 }
 });
 
 renderer.domElement.addEventListener('mouseup', () => {
 if (isSculpting) {
 console.log('[Sculpt] Stopped sculpting');
 isSculpting = false;
 sculptTarget = null;
 }
 });
 
 renderer.domElement.addEventListener('mousemove', (event) => {
 if (!isSculpting || !sculptTarget) return;
 
 // Inflate vertices near the sculpt target
 const mesh = sculptTarget.object;
 if (!mesh || !mesh.geometry) return;
 
 const positions = mesh.geometry.getAttribute('position');
 if (!positions) return;
 
 const localPoint = mesh.worldToLocal(sculptTarget.point.clone());
 
 // Inflate vertices within radius
 for (let i = 0; i < positions.count; i++) {
 const vx = positions.getX(i);
 const vy = positions.getY(i);
 const vz = positions.getZ(i);
 
 const dx = vx - localPoint.x;
 const dy = vy - localPoint.y;
 const dz = vz - localPoint.z;
 const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
 
 if (dist < sculptInflateRadius) {
 // Calculate falloff
 const falloff = 1.0 - (dist / sculptInflateRadius);
 const influence = falloff * falloff * sculptInflateStrength;
 
 // Move vertex along its normal (inflate)
 const normal = new THREE.Vector3(dx, dy, dz).normalize();
 positions.setXYZ(
 i,
 vx + normal.x * influence,
 vy + normal.y * influence,
 vz + normal.z * influence
 );
 }
 }
 
 positions.needsUpdate = true;
 mesh.geometry.computeVertexNormals();
 });
 
 // ===== Transform Controls for Character Editing =====
 function initializeTransformControls() {
 transformControl = new TransformControls(camera, renderer.domElement);
 transformControl.addEventListener('dragging-changed', (event) => {
 controls.enabled = !event.value;
 });
 transformControl.setMode('translate');
 scene.add(transformControl);
 
 // Gizmo mode buttons
 const gizmoButtons = document.querySelectorAll('.gizmo-btn[data-mode]');
 gizmoButtons.forEach(btn => {
 btn.addEventListener('click', () => {
 const mode = btn.dataset.mode;
 transformControl.setMode(mode);
 gizmoButtons.forEach(b => b.classList.remove('active'));
 btn.classList.add('active');
 });
 });
 
 // Snap toggle button
 const snapToggle = document.getElementById('snap-toggle');
 const snapModes = ['free', '45', '90'];
 let currentSnapIndex = 0;
 
 snapToggle.addEventListener('click', () => {
 currentSnapIndex = (currentSnapIndex + 1) % snapModes.length;
 const snapMode = snapModes[currentSnapIndex];
 snapToggle.dataset.snap = snapMode;
 
 if (snapMode === 'free') {
 transformControl.setRotationSnap(null);
 transformControl.setTranslationSnap(null);
 snapToggle.textContent = 'Free';
 snapToggle.title = 'Rotation Snap: Free';
 } else if (snapMode === '45') {
 transformControl.setRotationSnap(THREE.MathUtils.degToRad(45));
 transformControl.setTranslationSnap(0.5);
 snapToggle.textContent = '45 ';
 snapToggle.title = 'Rotation Snap: 45 ';
 } else if (snapMode === '90') {
 transformControl.setRotationSnap(THREE.MathUtils.degToRad(90));
 transformControl.setTranslationSnap(1.0);
 snapToggle.textContent = '90 ';
 snapToggle.title = 'Rotation Snap: 90 ';
 }
 });
 
 // Keyboard shortcuts
 window.addEventListener('keydown', (e) => {
 if (e.target.tagName === 'INPUT') return;
 if (e.key === 'g' || e.key === 'G') {
 transformControl.setMode('translate');
 
 // Also update 3D buttons if frame is visible
 if (frameOfReference && frameOfReference.visible && frameOfReference.userData.gizmoButtons) {
 const gizmoButtons = frameOfReference.userData.gizmoButtons;
 gizmoButtons.forEach(({ button }) => {
 if (button.userData.mode === 'translate') {
 button.userData.isActive = true;
 button.material.emissiveIntensity = 0.5;
 animateButtonPress(button);
 } else if (button.userData.mode !== 'snap') {
 button.userData.isActive = false;
 button.material.emissiveIntensity = 0.2;
 }
 });
 } else {
 document.querySelector('[data-mode="translate"]')?.click();
 }
 } else if (e.key === 'r' || e.key === 'R') {
 transformControl.setMode('rotate');
 
 // Also update 3D buttons if frame is visible
 if (frameOfReference && frameOfReference.visible && frameOfReference.userData.gizmoButtons) {
 const gizmoButtons = frameOfReference.userData.gizmoButtons;
 gizmoButtons.forEach(({ button }) => {
 if (button.userData.mode === 'rotate') {
 button.userData.isActive = true;
 button.material.emissiveIntensity = 0.5;
 animateButtonPress(button);
 } else if (button.userData.mode !== 'snap') {
 button.userData.isActive = false;
 button.material.emissiveIntensity = 0.2;
 }
 });
 } else {
 document.querySelector('[data-mode="rotate"]')?.click();
 }
 } else if (e.key === 's' || e.key === 'S') {
 transformControl.setMode('scale');
 
 // Also update 3D buttons if frame is visible
 if (frameOfReference && frameOfReference.visible && frameOfReference.userData.gizmoButtons) {
 const gizmoButtons = frameOfReference.userData.gizmoButtons;
 gizmoButtons.forEach(({ button }) => {
 if (button.userData.mode === 'scale') {
 button.userData.isActive = true;
 button.material.emissiveIntensity = 0.5;
 animateButtonPress(button);
 } else if (button.userData.mode !== 'snap') {
 button.userData.isActive = false;
 button.material.emissiveIntensity = 0.2;
 }
 });
 } else {
 document.querySelector('[data-mode="scale"]')?.click();
 }
 } else if (e.key === 'Escape') {
 transformControl.detach();
 }
 });
 }
 
 // ===== Camera Navigation =====
 function jumpToKeyboard() {
 // Keyboard is always at same position regardless of mode
 animateCamera(new THREE.Vector3(8, 6, 12), new THREE.Vector3(6, 1.8, 3.5));
 keyboardGroup.visible = true;
 }
 
 function jumpToCharacter() {
 // Adjust camera position based on avatar scale (5x for sequence, 30x for debug)
 const avatarScale = EXEC_ENV_MODE === 'sequence' ? 5.0 : 30.0;
 const scaleFactor = avatarScale / 5.0;
 // Celli avatar at (6, 2.0, 22), body center at ~y=(2.0 + 0.5*scale)
 const bodyCenterY = 2.0 + (0.5 * avatarScale);
 animateCamera(new THREE.Vector3(6, bodyCenterY + 3, 12), new THREE.Vector3(6, bodyCenterY, 22));
 characterGroup.visible = true;
 }
 
 function jumpToHead() {
 // Adjust camera position based on avatar scale (5x for sequence, 30x for debug)
 const avatarScale = EXEC_ENV_MODE === 'sequence' ? 5.0 : 30.0;
 // Celli avatar at (6, 2.0, 22), head at (0, 1.5, 0) relative to avatar
 const headCenterY = 2.0 + (1.5 * avatarScale);
 animateCamera(new THREE.Vector3(6, headCenterY + 3, 12), new THREE.Vector3(6, headCenterY, 22));
 voxelHeadGroup.visible = true;
 }
 
function jumpToOverview() {
// View from rear base of keyboard looking up at Celli
// Adjust camera position based on avatar scale (5x for sequence, 30x for debug)
const avatarScale = EXEC_ENV_MODE === 'sequence' ? 5.0 : 30.0;
const scaleFactor = avatarScale / 5.0; // Normalize to sequence scale
const cameraPos = new THREE.Vector3(6, 0.5 * scaleFactor, -3 * scaleFactor);
const targetPos = new THREE.Vector3(6, 8 * scaleFactor, 22);

animateCamera(cameraPos, targetPos);
keyboardGroup.visible = true;
characterGroup.visible = true;
voxelHeadGroup.visible = true;
}

function positionCameraInsideHead() {
// Position camera at center of Celli's head, facing BACK
// Celli avatar is at (6, 2.0, 22) with 5x scale in sequence mode
// voxelHeadGroup is at (0, 1.5, 0) relative to avatar

const headCenterWorld = celliAvatarGroup.localToWorld(voxelHeadGroup.position.clone());
camera.position.copy(headCenterWorld);

// Reset camera rotation to identity first
camera.rotation.set(0, 0, 0);
camera.quaternion.set(0, 0, 0, 1);

// Set camera to face BACK (positive Z direction in world space)
// Celli faces negative Z, so back is positive Z
// Camera faces negative Z by default, so rotate 180 degrees around Y
camera.rotation.y = Math.PI;

// Store the FORWARD direction (the direction player should turn TO) for turn detection
// This is the opposite of where camera is currently facing
const backDirection = camera.getWorldDirection(new THREE.Vector3());
narrativeSequence.initialCameraDirection = backDirection.clone().negate(); // Store forward direction

// Set orbit controls target to a point behind the camera (where it's looking)
if (controls) {
const lookTarget = headCenterWorld.clone().add(backDirection.clone().multiplyScalar(5));
controls.target.copy(lookTarget);
controls.update();

controls.enabled = true;
controls.enableDamping = true;
controls.enableRotate = true;
controls.enablePan = true;
controls.enableZoom = true;
console.log('[Sequence] Orbit controls ENABLED - full camera control');
console.log('[Sequence] Controls target:', controls.target);
}

console.log('? Camera positioned inside head, facing back (rotation.y = Ï€)');
console.log('? Camera rotation:', camera.rotation);
console.log('? Camera is facing:', backDirection);
console.log('? Turn target direction (forward):', narrativeSequence.initialCameraDirection);

// Illuminate "TURN BACK" text on voxels
illuminateTurnBackText();
}

function dropPlayer() {
// Smooth dolly/zoom animation to drop into the city at human scale
if (!lastViewedKey) {
console.warn('[Drop] No key has been viewed yet. Cannot drop.');
// Fallback: use first key if available
if (keys && keys.length > 0) {
lastViewedKey = keys[0];
console.log('[Drop] Using first key as fallback:', lastViewedKey.userData.label);
} else {
console.error('[Drop] No keys available.');
return;
}
}

console.log('[Drop] Initiating drop animation above key:', lastViewedKey.userData.label);

// Get key world position and dimensions
const keyWorldPos = new THREE.Vector3();
lastViewedKey.getWorldPosition(keyWorldPos);

const bbox = new THREE.Box3().setFromObject(lastViewedKey);
const keyHeight = bbox.max.y - bbox.min.y;
const keySurfaceY = keyWorldPos.y + keyHeight / 2; // Top surface of key

// Calculate human-scale height above key
// Buildings are ~0.02 * 3 = 0.06 units tall on average
// If buildings represent 10m tall buildings, and human eye level is 1.7m:
// Scale factor: 0.06 units = 10m, so 1m = 0.006 units
// Human eye level = 1.7m * 0.006 = 0.0102 units above key surface
const buildingScale = 0.02; // From createMicroCitiesOnKeys
const avgBuildingHeight = buildingScale * 3; // ~0.06 units
const buildingHeightInMeters = 10; // Buildings represent 10m tall structures
const humanEyeLevelInMeters = 1.7; // Human eye level
const metersToWorldUnits = avgBuildingHeight / buildingHeightInMeters;
const humanEyeLevel = humanEyeLevelInMeters * metersToWorldUnits; // ~0.0102 units

// START POSITION: Normal view above key, looking down
dropStartPos.copy(camera.position); // Keep current position
dropStartScale = 1.0; // Normal scale

// TARGET POSITION: Human eye level on key surface
dropTargetPos.set(
keyWorldPos.x,
keySurfaceY + humanEyeLevel,
keyWorldPos.z
);
dropTargetScale = 1.0; // Keep normal scale, just change position

// Show debug tracker
const debugEl = document.getElementById('drop-debug');
if (debugEl) {
debugEl.style.display = 'block';
}

// Initialize drop animation
isDropping = true;
dropProgress = 0;
dropStartTime = Date.now();
dropKeyTarget = lastViewedKey;

// Point camera DOWN at the key to see the city approach
controls.target.set(keyWorldPos.x, keySurfaceY, keyWorldPos.z);
controls.update();

// Store original fog density and reduce fog for clear city view
if (scene.fog) {
originalFogDensity = scene.fog.density;
scene.fog.density = 0.001; // Drastically reduce fog
console.log('[Drop] Fog reduced from', originalFogDensity, 'to 0.001');
}

// Keep orbit controls enabled during drop
if (controls) {
controls.enabled = true;
console.log('[Drop] Orbit controls enabled during drop');
}

console.log('[Drop] Animation start');
console.log('  Start pos:', dropStartPos.toArray().map(v => v.toFixed(3)));
console.log('  Target pos:', dropTargetPos.toArray().map(v => v.toFixed(3)));
console.log('  Human eye level:', humanEyeLevel.toFixed(4), 'units');
console.log('  Key surface Y:', keySurfaceY.toFixed(3));
}

function transformCelliToHell() {
console.log('%c[CELLI->HELL] âœ¨ TRANSFORMING CELLI TO HELL âœ¨', 'background: #f00; color: #fff; font-size: 18px; font-weight: bold; padding: 8px;');
console.log('[CELLI->HELL] Animation states:');
console.log('  - snapTogetherStarted:', snapTogetherStarted);
console.log('  - celliMoveToCornerStarted:', celliMoveToCornerStarted);
console.log('  - endColorState:', endColorState);
console.log('  - endSequence:', endSequence);

// C pattern reminder: [[0,1,1,1,0], [1,0,0,0,0], [1,0,0,0,0], [1,0,0,0,0], [0,1,1,1,0]]
// To make H: keep left column (col 0), remove top/bottom arcs, add right column (col 4) and crossbar (row 2)
// C is at letter index 0
// I is at letter index 4

if (!letterVoxels || !letterVoxels.C || !letterVoxels.I) {
console.error('[CELLI->HELL] âœ— letterVoxels not found');
console.error('[CELLI->HELL] letterVoxels:', letterVoxels);
return;
}

const voxelsToRemove = [];
const voxelsToReposition = []; // Voxels that will fall and reappear

// Remove voxels from C to make H:
// Top row (row 0): remove columns 1, 2, 3 (keep 0, need to add 4)
// Middle row (row 2): keep all (this is the crossbar)
// Bottom row (row 4): remove columns 1, 2, 3 (keep 0, need to add 4)
letterVoxels.C.forEach(voxel => {
const row = voxel.userData.gridY;
const col = voxel.userData.gridCol;

// Remove top arc (row 0, columns 1-3) - these will reappear on the right
if (row === 0 && col >= 1 && col <= 3) {
voxelsToRemove.push(voxel);
// Mark for repositioning to right side (col 4)
if (col === 2) { // Use middle voxel to create right column top
voxel.userData.willReappearAs = { row: 0, col: 4, letterIdx: 0 };
voxelsToReposition.push(voxel);
}
}
// Remove bottom arc (row 4, columns 1-3) - these will reappear on the right
else if (row === 4 && col >= 1 && col <= 3) {
voxelsToRemove.push(voxel);
// Mark for repositioning to right side (col 4)
if (col === 2) { // Use middle voxel to create right column bottom
voxel.userData.willReappearAs = { row: 4, col: 4, letterIdx: 0 };
voxelsToReposition.push(voxel);
}
}
});

// Remove ALL voxels from I (letter index 4) - some will reappear as right column of H
letterVoxels.I.forEach((voxel, idx) => {
voxelsToRemove.push(voxel);
const row = voxel.userData.gridY;
// Use center column voxels (rows 1, 2, 3) to create right column of H
if (row >= 1 && row <= 3 && idx % 3 === 1) {
voxel.userData.willReappearAs = { row: row, col: 4, letterIdx: 0 };
voxelsToReposition.push(voxel);
}
});

console.log(`[CELLI->HELL] Removing ${voxelsToRemove.length} voxels, ${voxelsToReposition.length} will reappear`);

// Animate removed voxels falling
voxelsToRemove.forEach((voxel, index) => {
// Mark for removal
voxel.userData.fallingOff = true;
voxel.userData.fallVelocity = 0;
voxel.userData.fallDelay = index * 0.02; // Stagger the falls
voxel.userData.fallStartTime = Date.now() / 1000; // Current time in seconds
voxel.userData.rotationSpeed = {
x: (Math.random() - 0.5) * 0.1,
y: (Math.random() - 0.5) * 0.1,
z: (Math.random() - 0.5) * 0.1
};
});

// Remove from letterVoxels tracking
letterVoxels.C = letterVoxels.C.filter(v => !voxelsToRemove.includes(v));
letterVoxels.I = []; // All I voxels are removed
}

function createCelliBorderAvatar(size = 2) {
const group = new THREE.Group();
group.name = 'CelliBorderAvatar';

const MAT_BODY = new THREE.MeshBasicMaterial({ color: 0xf59e0b, transparent: true, opacity: 0.92 });
const MAT_MOUTH = new THREE.MeshBasicMaterial({ color: 0x111827, transparent: true, opacity: 0.95, side: THREE.DoubleSide });
const MAT_EYE = new THREE.MeshBasicMaterial({ color: 0x111827, transparent: false });
const MAT_CHEEK = new THREE.MeshBasicMaterial({ color: 0xec4899, transparent: true, opacity: 0.9 });
const MAT_BOW = new THREE.MeshBasicMaterial({ color: 0xfbbf24, transparent: true, opacity: 0.92, side: THREE.DoubleSide });
MAT_BODY.toneMapped = false;
MAT_MOUTH.toneMapped = false;
MAT_EYE.toneMapped = false;
MAT_CHEEK.toneMapped = false;
MAT_BOW.toneMapped = false;

// Helper to draw rounded rectangle
function drawRoundedRectPath(path, width, height, radius){
const hw = width / 2;
const hh = height / 2;
const r = Math.min(radius, hw, hh);
path.moveTo(-hw + r, -hh);
path.lineTo(hw - r, -hh);
path.quadraticCurveTo(hw, -hh, hw, -hh + r);
path.lineTo(hw, hh - r);
path.quadraticCurveTo(hw, hh, hw - r, hh);
path.lineTo(-hw + r, hh);
path.quadraticCurveTo(-hw, hh, -hw, hh - r);
path.lineTo(-hw, -hh + r);
path.quadraticCurveTo(-hw, -hh, -hw + r, -hh);
path.closePath();
}

// Create body frame (border)
const borderWidth = size;
const borderHeight = size;
const borderThickness = 0.2;
const shape = new THREE.Shape();
drawRoundedRectPath(shape, borderWidth, borderHeight, 0.2);
const hole = new THREE.Path();
drawRoundedRectPath(hole, borderWidth * 0.7, borderHeight * 0.7, 0.15);
shape.holes.push(hole);
const bodyGeo = new THREE.ExtrudeGeometry(shape, { depth: 0.1, bevelEnabled: false, steps: 1 });
bodyGeo.center();
const bodyFrame = new THREE.Mesh(bodyGeo, MAT_BODY);
bodyFrame.name = 'CelliBodyFrame';
group.add(bodyFrame);

// Create mouth frame (smile)
const mouthWidth = borderWidth * 0.4;
const mouthHeight = borderHeight * 0.25;
const mouthShape = new THREE.Shape();
drawRoundedRectPath(mouthShape, mouthWidth, mouthHeight, 0.1);
const mouthHole = new THREE.Path();
drawRoundedRectPath(mouthHole, mouthWidth * 0.7, mouthHeight * 0.6, 0.08);
mouthShape.holes.push(mouthHole);
const mouthGeo = new THREE.ExtrudeGeometry(mouthShape, { depth: 0.05, bevelEnabled: false, steps: 1 });
mouthGeo.center();
const mouthFrame = new THREE.Mesh(mouthGeo, MAT_MOUTH);
mouthFrame.position.set(0, -borderHeight * 0.15, 0.06);
mouthFrame.name = 'CelliMouthFrame';
group.add(mouthFrame);

// Eyes
const eyeGeo = new THREE.CircleGeometry(0.12, 24);
const eyeLeft = new THREE.Mesh(eyeGeo, MAT_EYE);
const eyeRight = eyeLeft.clone();
eyeLeft.position.set(-borderWidth * 0.18, borderHeight * 0.1, 0.06);
eyeRight.position.set(borderWidth * 0.18, borderHeight * 0.1, 0.06);
eyeLeft.name = 'CelliEyeLeft';
eyeRight.name = 'CelliEyeRight';
group.add(eyeLeft, eyeRight);

const eyes = [eyeLeft, eyeRight];
const blinkState = {
countdown: THREE.MathUtils.randFloat(2.5, 4.5),
minDelay: 2.5,
maxDelay: 4.5,
blinkDuration: 0.18,
minScale: 0.15,
progress: 0,
blinking: false,
baseScales: eyes.map(eye => eye.scale.y)
};

const applyBlinkAmount = (amount = 0) => {
eyes.forEach((eye, index) => {
const baseScale = blinkState.baseScales[index];
eye.scale.y = THREE.MathUtils.lerp(baseScale, baseScale * blinkState.minScale, amount);
});
};

applyBlinkAmount(0);

// Cheeks
const cheekGeo = new THREE.CircleGeometry(0.14, 24);
const cheekLeft = new THREE.Mesh(cheekGeo, MAT_CHEEK);
const cheekRight = cheekLeft.clone();
cheekLeft.position.set(-borderWidth * 0.32, borderHeight * 0.05, 0.055);
cheekRight.position.set(borderWidth * 0.32, borderHeight * 0.05, 0.055);
cheekLeft.name = 'CelliCheekLeft';
cheekRight.name = 'CelliCheekRight';
group.add(cheekLeft, cheekRight);

// Bow
const bowGroup = new THREE.Group();
bowGroup.name = 'CelliBow';
const bowWingGeo = new THREE.ShapeGeometry(new THREE.Shape([
new THREE.Vector2(0.15, 0),
new THREE.Vector2(-0.08, 0.15),
new THREE.Vector2(-0.08, -0.15)
]));
const bowWingLeft = new THREE.Mesh(bowWingGeo, MAT_BOW);
bowWingLeft.position.set(-0.1, 0, 0);
const bowWingRight = bowWingLeft.clone();
bowWingRight.scale.x = -1;
bowWingRight.position.set(0.1, 0, 0);
const bowKnot = new THREE.Mesh(new THREE.CircleGeometry(0.07, 20), MAT_BOW);
bowKnot.position.set(0, 0, 0.005);
bowGroup.add(bowWingLeft, bowWingRight, bowKnot);
bowGroup.position.set(0, borderHeight * 0.42, 0.06);
group.add(bowGroup);

// Store references
group.userData = {
bodyFrame,
mouthFrame,
eyeLeft,
eyeRight,
cheekLeft,
cheekRight,
bowGroup,
eyes,
blinkState,
applyBlink: applyBlinkAmount,
hoverActive: false,
clickActive: false
};

return group;
}

function illuminateTurnBackText() {
if (!voxelHeadGroup || !voxelHeadGroup.userData.instances) return;

const instances = voxelHeadGroup.userData.instances;
const instancedMesh = voxelHeadGroup.userData.instancedMesh;

// Define letter patterns (5x7 grid for each letter)
const letterT = [[1,1,1,1,1],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0]];
const letterU = [[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]];
const letterR = [[1,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,0],[1,0,1,0,0],[1,0,0,1,0],[1,0,0,0,1]];
const letterN = [[1,0,0,0,1],[1,1,0,0,1],[1,0,1,0,1],[1,0,0,1,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1]];
const letterB = [[1,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,0]];
const letterA = [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1]];
const letterC = [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,1],[0,1,1,1,0]];
const letterK = [[1,0,0,0,1],[1,0,0,1,0],[1,0,1,0,0],[1,1,0,0,0],[1,0,1,0,0],[1,0,0,1,0],[1,0,0,0,1]];

const letters = ['TURN', ' ', 'BACK'];
const letterPatterns = [
[letterT, letterU, letterR, letterN],
[],
[letterB, letterA, letterC, letterK]
];

// Find voxels on the back surface (positive Z in local coordinates since head is rotated)
// We'll use voxels with Z > 0.8 (back surface)
const backVoxels = instances.map((data, i) => ({ ...data, index: i }))
.filter(v => v.basePos.z > 0.8)
.sort((a, b) => {
// Sort by Y (top to bottom), then X (left to right)
if (Math.abs(a.basePos.y - b.basePos.y) > 0.2) return b.basePos.y - a.basePos.y;
return a.basePos.x - b.basePos.x;
});

// Map text to voxel grid - create a simple grid mapping
const turnBackIndices = [];
const gridSize = 7; // Text height
const letterSpacing = 6;

// For simplicity, just mark some voxels on the back as text voxels
// We'll find voxels in a grid pattern and map the text
let wordX = -15; // Start position for words
[letterPatterns[0], letterPatterns[2]].forEach((word, wordIdx) => {
word.forEach((letter, letterIdx) => {
letter.forEach((row, rowIdx) => {
row.forEach((pixel, colIdx) => {
if (pixel === 1) {
// Find closest voxel to this text position
const targetX = wordX + letterIdx * letterSpacing + colIdx;
const targetY = -rowIdx * 2;
const closest = backVoxels.find(v =>
Math.abs(v.basePos.x * 10 - targetX) < 2 &&
Math.abs(v.basePos.y * 10 - targetY) < 2
);
if (closest) turnBackIndices.push(closest.index);
}
});
});
});
wordX += (word.length + 1) * letterSpacing;
});

voxelHeadGroup.userData.turnBackIndices = turnBackIndices;
voxelHeadGroup.userData.turnBackText = { active: true };

console.log(`? "TURN BACK" text prepared: ${turnBackIndices.length} voxels illuminated`);
}

function animateCamera(targetPos, targetLookAt, duration = 1500) {
 const startPos = camera.position.clone();
 const startLookAt = controls.target.clone();
 const startTime = Date.now();
 
 function animate() {
 const elapsed = Date.now() - startTime;
 const progress = Math.min(elapsed / duration, 1);
 const eased = 1 - Math.pow(1 - progress, 3);
 
 camera.position.lerpVectors(startPos, targetPos, eased);
 controls.target.lerpVectors(startLookAt, targetLookAt, eased);
 controls.update();
 
 if (progress < 1) {
 requestAnimationFrame(animate);
 }
 }
 animate();
 }
 
 function enableEditMode() {
 const gizmoToolbar = document.getElementById('gizmo-toolbar');
 gizmoToolbar.style.display = 'flex';
 
 // Show sphere markers for editing
 characterPoseSpheres.forEach(marker => {
 marker.visible = true;
 });
 
 if (characterBust) {
 transformControl.attach(characterBust);
 }
 
 console.log('Edit mode enabled - click on sphere markers to edit individual parts');
 
 // Add click handler for sphere selection
 const raycaster = new THREE.Raycaster();
 const mouse = new THREE.Vector2();
 
 function onSphereClick(event) {
 const rect = renderer.domElement.getBoundingClientRect();
 mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
 mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
 
 raycaster.setFromCamera(mouse, camera);
 const intersects = raycaster.intersectObjects(characterPoseSpheres, false);
 
 if (intersects.length > 0) {
 const selectedSphere = intersects[0].object;
 transformControl.attach(selectedSphere);
 
 // Highlight selected sphere
 characterPoseSpheres.forEach(marker => {
 marker.material.opacity = 0.3;
 marker.material.color.set(0x4a7cff);
 });
 selectedSphere.material.opacity = 0.6;
 selectedSphere.material.color.set(0xff4a7c);
 
 console.log('Selected sphere:', selectedSphere.userData.sphereIndex);
 }
 }
 
 renderer.domElement.addEventListener('click', onSphereClick);
 }
 
 // Helper: Hash function for per-instance phase variation
 function hash(n) {
 const s = Math.sin(n * 127.1) * 43758.5453;
 return s - Math.floor(s);
 }
 
 // ===== GUI Controls =====
 const gui = new GUI({ title: 'Debug & Settings', width: 300 });
 
 // Scene folder
 const sceneFolder = gui.addFolder('Scene');
 const sceneParams = {
 'Show Keyboard': true,
 'Show Character': true,
 'Show Voxel Head': true,
 'Show All': true,
 'Background Color': '#0a0a0a',
 'Fog Density': 0.03,
 'Auto Rotate Character': false
 };
 sceneFolder.add(sceneParams, 'Show Keyboard').onChange(v => {
 if (keyboardGroup) keyboardGroup.visible = v;
 });
 sceneFolder.add(sceneParams, 'Show Character').onChange(v => {
 if (characterGroup) characterGroup.visible = v;
 });
 sceneFolder.add(sceneParams, 'Show Voxel Head').onChange(v => {
 if (voxelHeadGroup) voxelHeadGroup.visible = v;
 });
 sceneFolder.add(sceneParams, 'Show All').onChange(v => {
 if (keyboardGroup) keyboardGroup.visible = v;
 if (characterGroup) characterGroup.visible = v;
 if (voxelHeadGroup) voxelHeadGroup.visible = v;
 sceneParams['Show Keyboard'] = v;
 sceneParams['Show Character'] = v;
 sceneParams['Show Voxel Head'] = v;
 sceneFolder.controllers.forEach(c => c.updateDisplay());
 });
 sceneFolder.addColor(sceneParams, 'Background Color').onChange(v => {
 scene.background.set(v);
 });
 sceneFolder.add(sceneParams, 'Fog Density', 0, 0.1, 0.001).onChange(v => {
 scene.fog.density = v;
 });
 sceneFolder.add(sceneParams, 'Auto Rotate Character');
 
 // Lighting folder
 const lightFolder = gui.addFolder('Lighting');
 const lightParams = {
 'Ambient Intensity': 0.15,
 'Hemisphere Intensity': 0.2,
 'Directional Intensity': 0.9,
 'Spot Intensity': 4.0,
 'Rim Intensity': 0.3
 };
 lightFolder.add(lightParams, 'Ambient Intensity', 0, 1, 0.01).onChange(v => al.intensity = v);
 lightFolder.add(lightParams, 'Hemisphere Intensity', 0, 1, 0.01).onChange(v => hl.intensity = v);
 lightFolder.add(lightParams, 'Directional Intensity', 0, 3, 0.01).onChange(v => dl.intensity = v);
 lightFolder.add(lightParams, 'Spot Intensity', 0, 10, 0.1).onChange(v => spotLight.intensity = v);
 lightFolder.add(lightParams, 'Rim Intensity', 0, 1, 0.01).onChange(v => rimLight.intensity = v);
 
 // Character Bust folder
 const bustFolder = gui.addFolder('Character Bust');
 const bustParams = {
 'Preview Mesh Visible': true,
 'Preview Wireframe': false,
 'Unified Mesh Visible': false,
 'Unified Wireframe': false,
 'Skin Color': '#e7e2dc',
 'Roughness': 0.55,
 'Metalness': 0.0,
 'Clearcoat': 0.4,
 'Show Markers': false,
 'Symmetry X': true,
 'Symmetry Y': false,
 'Symmetry Z': false
 };
 bustFolder.add(bustParams, 'Preview Mesh Visible').onChange(v => {
 if (characterBust) {
 characterBust.visible = v;
 }
 });
 bustFolder.add(bustParams, 'Preview Wireframe').onChange(v => {
 if (characterBust && characterBust.material) {
 characterBust.material.wireframe = v;
 }
 });
 bustFolder.add(bustParams, 'Unified Mesh Visible').onChange(v => {
 if (characterUnifiedMesh) {
 characterUnifiedMesh.visible = v;
 }
 });
 bustFolder.add(bustParams, 'Unified Wireframe').onChange(v => {
 if (characterUnifiedMesh && characterUnifiedMesh.material) {
 characterUnifiedMesh.material.wireframe = v;
 }
 });
 bustFolder.addColor(bustParams, 'Skin Color').onChange(v => {
 if (characterBust && characterBust.material) characterBust.material.color.set(v);
 if (characterUnifiedMesh && characterUnifiedMesh.material) characterUnifiedMesh.material.color.set(v);
 });
 bustFolder.add(bustParams, 'Roughness', 0.1, 1.0, 0.01).onChange(v => {
 if (characterBust && characterBust.material) characterBust.material.roughness = v;
 if (characterUnifiedMesh && characterUnifiedMesh.material) characterUnifiedMesh.material.roughness = v;
 });
 bustFolder.add(bustParams, 'Metalness', 0, 1, 0.01).onChange(v => {
 if (characterBust && characterBust.material) characterBust.material.metalness = v;
 if (characterUnifiedMesh && characterUnifiedMesh.material) characterUnifiedMesh.material.metalness = v;
 });
 bustFolder.add(bustParams, 'Clearcoat', 0, 1, 0.01).onChange(v => {
 if (characterBust && characterBust.material) characterBust.material.clearcoat = v;
 if (characterUnifiedMesh && characterUnifiedMesh.material) characterUnifiedMesh.material.clearcoat = v;
 });
 bustFolder.add(bustParams, 'Show Markers').onChange(v => {
 characterPoseSpheres.forEach(marker => marker.visible = v);
 });
 bustFolder.add(bustParams, 'Symmetry X');
 bustFolder.add(bustParams, 'Symmetry Y');
 bustFolder.add(bustParams, 'Symmetry Z');
 
 // Voxel Head folder
 const headFolder = gui.addFolder('Voxel Head');
// Get default preset based on mode
const defaultPresetForGUI = EXEC_ENV_MODE === 'sequence' ? 'intro-celli' : 'sparse-blue';
const guiPreset = headPresets[defaultPresetForGUI];

const headParams = {
// Animation
'Animation Speed': guiPreset.animSpeed,
'Amplitude': guiPreset.amplitude,
'Phase Noise': guiPreset.phaseNoise,
'Falloff': guiPreset.falloff,
'Noise Warp': guiPreset.noiseWarp,
// Opacity & Glow
'Opacity Min': guiPreset.opacityMin,
'Opacity Max': guiPreset.opacityMax,
'Opacity Speed': guiPreset.opacitySpeed,
'Emissive Intensity': guiPreset.emissive,
// Material
'Metalness': guiPreset.metalness,
'Roughness': guiPreset.roughness,
'Color': guiPreset.color,
// Light
'Light Intensity': guiPreset.lightInt,
'Light Pulse': guiPreset.lightPulse,
'Rotation Speed': guiPreset.rotationSpeed,
// Voxel Generation (requires regeneration)
'Voxel Size': guiPreset.voxelSize,
'Shell Thickness': guiPreset.shellThickness,
'Shell Outer Bias': 0.02
};
 
 const headAnimFolder = headFolder.addFolder('Animation');
 headAnimFolder.add(headParams, 'Animation Speed', 0, 3, 0.01);
 headAnimFolder.add(headParams, 'Amplitude', 0, 0.6, 0.01);
 headAnimFolder.add(headParams, 'Phase Noise', 0, 2, 0.01);
 headAnimFolder.add(headParams, 'Falloff', 0, 2, 0.01);
 headAnimFolder.add(headParams, 'Noise Warp', 0, 0.6, 0.01);
 
 const headGlowFolder = headFolder.addFolder('Glow & Opacity');
 headGlowFolder.add(headParams, 'Opacity Min', 0, 1, 0.01);
 headGlowFolder.add(headParams, 'Opacity Max', 0, 1, 0.01);
 headGlowFolder.add(headParams, 'Opacity Speed', 0, 3, 0.01);
 headGlowFolder.add(headParams, 'Emissive Intensity', 0, 2, 0.01);
 
 const headMatFolder = headFolder.addFolder('Material');
 headMatFolder.add(headParams, 'Metalness', 0, 1, 0.01).onChange(v => {
 if (voxelHeadGroup && voxelHeadGroup.userData.instancedMesh) {
 voxelHeadGroup.userData.instancedMesh.material.metalness = v;
 }
 });
 headMatFolder.add(headParams, 'Roughness', 0, 1, 0.01).onChange(v => {
 if (voxelHeadGroup && voxelHeadGroup.userData.instancedMesh) {
 voxelHeadGroup.userData.instancedMesh.material.roughness = v;
 }
 });
 headMatFolder.addColor(headParams, 'Color').onChange(v => {
 if (voxelHeadGroup && voxelHeadGroup.userData.instancedMesh) {
 voxelHeadGroup.userData.instancedMesh.material.color.set(v);
 voxelHeadGroup.userData.instancedMesh.material.emissive.set(v);
 if (voxelHeadGroup.userData.headLight) {
 voxelHeadGroup.userData.headLight.color.set(v);
 }
 }
 });
 
 const headLightFolder = headFolder.addFolder('Light');
 headLightFolder.add(headParams, 'Light Intensity', 0, 10, 0.1);
 headLightFolder.add(headParams, 'Light Pulse');
 headLightFolder.add(headParams, 'Rotation Speed', 0, 1, 0.01);
 
 // Post-Processing folder
 const postFolder = gui.addFolder('Post-Processing');
 const postParams = {
 'Bloom Strength': 0.6,
 'Bloom Radius': 0.6,
 'Bloom Threshold': 0.9,
 'Tone Mapping Exposure': 1.0,
 'Enable FXAA': true
 };
 postFolder.add(postParams, 'Bloom Strength', 0, 3, 0.01).onChange(v => bloomPass.strength = v);
 postFolder.add(postParams, 'Bloom Radius', 0, 3, 0.01).onChange(v => bloomPass.radius = v);
 postFolder.add(postParams, 'Bloom Threshold', 0, 1, 0.01).onChange(v => bloomPass.threshold = v);
 postFolder.add(postParams, 'Tone Mapping Exposure', 0, 3, 0.01).onChange(v => renderer.toneMappingExposure = v);
 postFolder.add(postParams, 'Enable FXAA').onChange(v => fxaaPass.enabled = v);
 
 // Camera folder
 const cameraFolder = gui.addFolder('Camera');
 const cameraParams = {
 'FOV': 45,
 'Near': 0.1,
 'Far': 100
 };
 cameraFolder.add(cameraParams, 'FOV', 20, 120, 1).onChange(v => {
 camera.fov = v;
 camera.updateProjectionMatrix();
 });
 cameraFolder.add(cameraParams, 'Near', 0.01, 10, 0.01).onChange(v => {
 camera.near = v;
 camera.updateProjectionMatrix();
 });
 cameraFolder.add(cameraParams, 'Far', 10, 500, 1).onChange(v => {
 camera.far = v;
 camera.updateProjectionMatrix();
 });
 
 // Micro City LOD folder
 const microCityFolder = gui.addFolder('Micro City LOD');
 const microCityParams = {
 'Enabled': true,
 'LOD Distance': 0.5, // Cities appear at moderate distance
 'Slowdown Distance': 0.08, // Slowdown only when VERY close
 'Fade Range': 0.2,
 'Building Scale': 0.003,
 'Building Density': 0.02,
 'Camera Slowdown': 0.7,
 'Show City Info': true
 };
 microCityFolder.add(microCityParams, 'Enabled').onChange(v => {
 if (!v) {
 microCityGroups.forEach(({ cityGroup }) => {
 cityGroup.visible = false;
 });
 }
 });
 microCityFolder.add(microCityParams, 'LOD Distance', 0.1, 3.0, 0.05);
 microCityFolder.add(microCityParams, 'Slowdown Distance', 0.02, 0.3, 0.01);
 microCityFolder.add(microCityParams, 'Fade Range', 0.1, 1.0, 0.05);
 microCityFolder.add(microCityParams, 'Building Scale', 0.002, 0.02, 0.001);
 microCityFolder.add(microCityParams, 'Building Density', 0.01, 0.05, 0.005);
 microCityFolder.add(microCityParams, 'Camera Slowdown', 0, 1, 0.05);
 microCityFolder.add(microCityParams, 'Show City Info');
 microCityParams['Force Show All Cities'] = () => {
 console.log('[MicroCity] Forcing all cities visible for debugging...');
 microCityGroups.forEach(({ cityGroup, key }) => {
 cityGroup.visible = true;
 cityGroup.scale.setScalar(1.0);
 console.log(` City on "${key.userData.label}": ${cityGroup.children.length} meshes at pos ${cityGroup.position.x.toFixed(2)}, ${cityGroup.position.y.toFixed(2)}, ${cityGroup.position.z.toFixed(2)}`);
 });
 };
 microCityFolder.add(microCityParams, 'Force Show All Cities');
 
 // Hands & Fingerprint folder (now moved to modal via Edit Hands button)
 const handsParams = {
 'Fingerprint Enabled': true,
 'Fingerprint Strength': 1.0,
 'Fingerprint Scale': 1.0,
 'Finger Spacing': 1.2,
 'Show Hands': true,
 'Right Hand Visible': true,
 'Left Hand Visible': true,
 'Show Voxel Wrap': false,
 'Voxel Wrap Style': 'Emerging',
 'Apply to Material': () => {
 if (window.applyFpToMaterial) window.applyFpToMaterial();
 },
 'Apply Spacing': () => {
 const spacing = handsParams['Finger Spacing'];
 // Update right hand static fingers
 if (rightHandGroup && rightHandGroup.children) {
 let fingerIndex = 0;
 rightHandGroup.children.forEach(child => {
 if (child.userData && child.userData.isStatic) {
 fingerIndex++;
 child.position.x = spacing * fingerIndex;
 child.userData.offsetX = spacing * fingerIndex;
 }
 });
 }
 // Update left hand static fingers
 if (leftHandGroup && leftHandGroup.children) {
 let fingerIndex = 0;
 leftHandGroup.children.forEach(child => {
 if (child.userData && child.userData.isLeftHand && child.position.x !== 0) {
 fingerIndex++;
 child.position.x = -spacing * fingerIndex;
 child.userData.offsetX = -spacing * fingerIndex;
 }
 });
 }
 alert(`Finger spacing updated to ${spacing.toFixed(2)}`);
 }
 };
 
 // Scene Objects Hierarchy removed from GUI - now accessible via Scene Browser modal
 
 // Store for animation loop
 window.guiParams = { scene: sceneParams, bust: bustParams, head: headParams, post: postParams, hands: handsParams, microCity: microCityParams };
 
 // ===== Button Handlers =====
 document.getElementById('btn-keyboard').addEventListener('click', jumpToKeyboard);
 document.getElementById('btn-character').addEventListener('click', jumpToCharacter);
 document.getElementById('btn-head').addEventListener('click', jumpToHead);
 document.getElementById('btn-overview').addEventListener('click', jumpToOverview);
 document.getElementById('btn-edit-character').addEventListener('click', () => {
 jumpToCharacter();
 enableEditMode();
 });
 
 document.getElementById('btn-sculpt-character').addEventListener('click', () => {
 jumpToCharacter();
 enableSculptMode();
 });
 
 // New button handlers
 document.getElementById('btn-edit-head').addEventListener('click', () => {
 document.getElementById('edit-head-modal').classList.add('active');
 syncHeadModalToParams();
 });
 
 document.getElementById('btn-edit-hands').addEventListener('click', () => {
 document.getElementById('edit-hands-modal').classList.add('active');
 if (!window.handsGUI) {
 createHandsGUI();
 }
 });
 
 document.getElementById('btn-scene-browser').addEventListener('click', () => {
 populateSceneBrowser();
 document.getElementById('scene-browser-modal').classList.add('active');
 });

 const multiWrapCollapseBtn = document.getElementById('btn-celli-collapse');
 if (multiWrapCollapseBtn) {
 multiWrapCollapseBtn.addEventListener('click', () => {
 triggerCelliWrapCollapse();
 });
 }

 document.getElementById('btn-save-config').addEventListener('click', () => {
 populateConfigList();
 document.getElementById('save-config-modal').classList.add('active');
 });
 
 document.getElementById('btn-print-config').addEventListener('click', () => {
 generateConfigurationReport();
 document.getElementById('config-report-modal').classList.add('active');
 });
 
 // Scale Mode button
document.getElementById('btn-scale-mode').addEventListener('click', () => {
toggleScaleMode();
const statusEl = document.getElementById('scale-mode-state');
if (statusEl) {
statusEl.textContent = scaleModeEnabled ? 'Enabled' : 'Disabled';
statusEl.style.color = scaleModeEnabled ? '#4aff9c' : '#888';
}
});

// Drop button handlers (both 2D and 3D toolbars)
const dropBtn = document.getElementById('drop-btn');
if (dropBtn) {
dropBtn.addEventListener('click', () => {
console.log('[Drop] Drop button clicked (2D toolbar)');
dropPlayer();
});
}

const fullhandDropBtn = document.getElementById('fullhand-drop-btn');
if (fullhandDropBtn) {
fullhandDropBtn.addEventListener('click', () => {
console.log('[Drop] Drop button clicked (3D toolbar)');
dropPlayer();
});
}

// WASD controls for drop mode first-person movement
window.addEventListener('keydown', (e) => {
if (dropModeActive) {
const key = e.key.toLowerCase();
if (key === 'w') dropKeys.w = true;
if (key === 'a') dropKeys.a = true;
if (key === 's') dropKeys.s = true;
if (key === 'd') dropKeys.d = true;
if (key === 'shift') dropKeys.shift = true;
if (key === ' ') { dropKeys.space = true; e.preventDefault(); }
}
});

window.addEventListener('keyup', (e) => {
if (dropModeActive) {
const key = e.key.toLowerCase();
if (key === 'w') dropKeys.w = false;
if (key === 'a') dropKeys.a = false;
if (key === 's') dropKeys.s = false;
if (key === 'd') dropKeys.d = false;
if (key === 'shift') dropKeys.shift = false;
if (key === ' ') dropKeys.space = false;
}
});

// Debug menu minimize/restore
 const debugMenu = document.getElementById('debug-menu');
 const debugMenuMinimizeBtn = document.getElementById('debug-menu-minimize');
 const debugMenuRestoreBtn = document.getElementById('debug-menu-restore');
 
 debugMenuMinimizeBtn.addEventListener('click', () => {
 debugMenu.classList.add('minimized');
 debugMenuRestoreBtn.classList.add('visible');
 console.log('[DebugMenu] Menu minimized');
 });
 
 debugMenuRestoreBtn.addEventListener('click', () => {
 debugMenu.classList.remove('minimized');
 debugMenuRestoreBtn.classList.remove('visible');
 console.log('[DebugMenu] Menu restored');
 });
 
 // Raycaster for clicking buttons on frame
 const frameRaycaster = new THREE.Raycaster();
 const frameMouse = new THREE.Vector2();
 let currentSnapMode = 'free'; // Track snap mode
 
 renderer.domElement.addEventListener('click', (event) => {
 // Check if frame is visible
 if (!frameOfReference || !frameOfReference.visible) return;
 
 // Calculate mouse position in normalized device coordinates
 const rect = renderer.domElement.getBoundingClientRect();
 frameMouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
 frameMouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
 
 // Update raycaster
 frameRaycaster.setFromCamera(frameMouse, camera);
 
 // Check for intersection with minimize button
 if (minimizeButton && minimizeButton.circle) {
 const intersects = frameRaycaster.intersectObject(minimizeButton.circle, false);
 
 if (intersects.length > 0) {
 console.log('[FrameOfRef] Minimize button clicked!');
 toggleFrameMinimize();
 event.stopPropagation();
 return;
 }
 }
 
 // Check for intersection with gizmo buttons
 if (frameOfReference.userData.gizmoButtons) {
 const gizmoButtons = frameOfReference.userData.gizmoButtons;
 const buttonMeshes = gizmoButtons.map(b => b.button);
 const intersects = frameRaycaster.intersectObjects(buttonMeshes, false);
 
 if (intersects.length > 0) {
 const clickedButton = intersects[0].object;
 const mode = clickedButton.userData.mode;
 
 console.log(`[FrameOfRef] Gizmo button clicked: ${mode}`);
 
 // Animate button press
 animateButtonPress(clickedButton);
 
 // Handle snap mode separately (toggle through modes)
 if (mode === 'snap') {
 const snapModes = ['free', '45', '90'];
 const currentIndex = snapModes.indexOf(currentSnapMode);
 currentSnapMode = snapModes[(currentIndex + 1) % snapModes.length];
 
 if (currentSnapMode === 'free') {
 transformControl.setRotationSnap(null);
 transformControl.setTranslationSnap(null);
 console.log('[FrameOfRef] Snap: Free');
 } else if (currentSnapMode === '45') {
 transformControl.setRotationSnap(THREE.MathUtils.degToRad(45));
 transformControl.setTranslationSnap(0.5);
 console.log('[FrameOfRef] Snap: 45 ');
 } else if (currentSnapMode === '90') {
 transformControl.setRotationSnap(THREE.MathUtils.degToRad(90));
 transformControl.setTranslationSnap(1.0);
 console.log('[FrameOfRef] Snap: 90 ');
 }
 } else if (mode === 'sculpt') {
 // Enable sculpt mode
 enableSculptMode();
 console.log('[FrameOfRef] Sculpt mode activated');
 
 // Update active states
 gizmoButtons.forEach(({ button }) => {
 if (button.userData.mode === 'sculpt') {
 button.userData.isActive = true;
 button.material.emissiveIntensity = 0.5;
 } else if (button.userData.mode !== 'snap') {
 button.userData.isActive = false;
 button.material.emissiveIntensity = 0.2;
 }
 });
 } else {
 // Set transform mode (translate, rotate, scale)
 transformControl.setMode(mode);
 
 // Update active states
 gizmoButtons.forEach(({ button }) => {
 if (button.userData.mode === mode) {
 button.userData.isActive = true;
 button.material.emissiveIntensity = 0.5;
 } else if (button.userData.mode !== 'snap') {
 button.userData.isActive = false;
 button.material.emissiveIntensity = 0.2;
 }
 });
 }
 
 event.stopPropagation();
 }
 }
 });
 
 // Animate button depression
 function animateButtonPress(button) {
 const startZ = button.position.z;
 const targetZ = button.userData.pressedZ;
 const duration = 100; // ms
 const startTime = Date.now();
 
 // Find the corresponding label
 const gizmoButtons = frameOfReference.userData.gizmoButtons;
 const buttonData = gizmoButtons.find(b => b.button === button);
 const label = buttonData ? buttonData.label : null;
 const labelStartZ = label ? label.position.z : 0;
 const labelOffset = labelStartZ - startZ;
 
 function animateDown() {
 const elapsed = Date.now() - startTime;
 const progress = Math.min(elapsed / duration, 1);
 
 button.position.z = startZ - (startZ - targetZ) * progress;
 if (label) {
 label.position.z = button.position.z + labelOffset;
 }
 
 if (progress < 1) {
 requestAnimationFrame(animateDown);
 } else {
 // Animate back up
 const releaseStart = Date.now();
 function animateUp() {
 const elapsed = Date.now() - releaseStart;
 const progress = Math.min(elapsed / duration, 1);
 
 button.position.z = targetZ + (button.userData.baseZ - targetZ) * progress;
 if (label) {
 label.position.z = button.position.z + labelOffset;
 }
 
 if (progress < 1) {
 requestAnimationFrame(animateUp);
 }
 }
 animateUp();
 }
 }
 
 animateDown();
 }
 
 // Cursor sequence button and file input
 let cursorImageData = null;
 document.getElementById('btn-cursor-sequence').addEventListener('click', () => {
 document.getElementById('cursor-file-input').click();
 });
 
 document.getElementById('cursor-file-input').addEventListener('change', async (e) => {
 const file = e.target.files[0];
 if (!file) return;
 
 try {
 console.log('Processing uploaded hand image:', file.name);
 const img = await loadImageFromFile(file);
 console.log('Image loaded:', img.width, 'x', img.height);
 
 const gridData = toPixelGrid(img, 96);
 console.log('Grid data created:', gridData.width, 'x', gridData.height);
 
 const coords = posterizeAndExtract(gridData);
 console.log('Coordinates extracted:', coords);
 
 if(!coords.silhouette || coords.silhouette.length < 10){
 throw new Error('No hand detected. Make sure the image has a clear hand on white background.');
 }
 
 // Generate preview
 const previewDataURL = generatePreviewDataURL(coords);
 
 // Prompt for name
 const handName = prompt('Enter a name for this hand configuration:', `Hand ${Date.now()}`);
 if (handName) {
 saveHandConfig(handName, coords, previewDataURL);
 populateHandConfigSelect();
 alert(`Hand "${handName}" saved! You can spawn it later from the preview.`);
 }
 
 // Trigger the animation sequence with the new coords
 createVoxelCursorSequence(coords);
 
 console.log('Successfully processed and applied hand image');
 } catch(err) {
 console.error('Image processing error:', err);
 alert('Failed to process image: ' + err.message);
 }
 });
 
 // Save/Load hand configs from localStorage
 const HAND_CONFIGS_KEY = 'voxelHandConfigs';
 
 function saveHandConfig(name, coords, previewDataURL, stages = null) {
 const configs = JSON.parse(localStorage.getItem(HAND_CONFIGS_KEY) || '{}');
 
 // Generate stages if not provided
 if (!stages) {
 stages = generateAllStages(coords);
 }
 
 configs[name] = {
 coords: coords,
 preview: previewDataURL,
 stages: stages, // Store all 12 animation stages
 timestamp: Date.now()
 };
 localStorage.setItem(HAND_CONFIGS_KEY, JSON.stringify(configs));
 console.log(`[HandConfig] Saved hand config "${name}" with ${stages.length} stages`);
 }
 
 // Generate all 12 stage previews as data URLs with increasing resolution
 function generateAllStages(coords) {
 console.log(`[HandConfig] Generating stages for hand with ${coords.silhouette?.length || 0} silhouette pixels`);
 
 const { width: W, height: H, silhouette, outline, shade, highlight, colors } = coords;
 const baseCol = colors?.base || '#f3d2b4';
 const shadeCol = colors?.shade || '#d4b090';
 const outlineCol = colors?.outline || '#23160e';
 const hiCol = colors?.highlight || '#fff3e2';
 
 if (!silhouette || silhouette.length === 0) {
 console.error('[HandConfig] No silhouette data found - cannot generate stages!');
 return [];
 }
 
 // Create display and work canvases
 const displayCanvas = document.createElement('canvas');
 displayCanvas.width = W;
 displayCanvas.height = H;
 const displayCtx = displayCanvas.getContext('2d');
 displayCtx.imageSmoothingEnabled = false;
 
 const workCanvas = document.createElement('canvas');
 const workCtx = workCanvas.getContext('2d');
 workCtx.imageSmoothingEnabled = false;
 
 const stages = [];
 const totalStages = 12;
 const resolutionMap = { 
 0: 8, 1: 12, 2: 16, 3: 24, 4: 32, 5: 40, 
 6: 48, 7: 56, 8: 64, 9: 72, 10: 80, 11: 88, 12: 96 
 };
 
 for (let stage = 0; stage <= totalStages; stage++) {
 const resolution = resolutionMap[stage] || 96;
 const scale = W / resolution;
 
 // Resize work canvas
 workCanvas.width = resolution;
 workCanvas.height = resolution;
 workCtx.clearRect(0, 0, resolution, resolution);
 
 // Draw at lower resolution
 const px = (x, y, color) => {
 const scaledX = Math.floor(x / scale);
 const scaledY = Math.floor(y / scale);
 if (scaledX >= 0 && scaledX < resolution && scaledY >= 0 && scaledY < resolution) {
 workCtx.fillStyle = color;
 workCtx.fillRect(scaledX, scaledY, 1, 1);
 }
 };
 
 // Draw stage content
 if (stage >= 1) {
 const silAmount = Math.floor(silhouette.length * (stage / totalStages));
 for (let i = 0; i < silAmount; i++) {
 const [x, y] = silhouette[i];
 px(x, y, baseCol);
 }
 }
 
 if (stage >= 3 && shade && shade.length > 0) {
 const shadeAmount = Math.floor(shade.length * ((stage - 2) / (totalStages - 2)));
 for (let i = 0; i < shadeAmount; i++) {
 const [x, y] = shade[i];
 px(x, y, shadeCol);
 }
 }
 
 if (stage >= 10 && highlight && highlight.length > 0) {
 const hiAmount = Math.floor(highlight.length * ((stage - 9) / 3));
 for (let i = 0; i < hiAmount; i++) {
 const [x, y] = highlight[i];
 px(x, y, hiCol);
 }
 }
 
 if (stage >= 1 && outline && outline.length > 0) {
 const outAmount = Math.floor(outline.length * (stage / totalStages));
 for (let i = 0; i < outAmount; i++) {
 const [x, y] = outline[i];
 px(x, y, outlineCol);
 }
 }
 
 // Scale up to display canvas
 displayCtx.clearRect(0, 0, W, H);
 displayCtx.drawImage(workCanvas, 0, 0, resolution, resolution, 0, 0, W, H);
 
 const dataURL = displayCanvas.toDataURL();
 stages.push(dataURL);
 
 // Debug log for first few stages
 if (stage <= 2) {
 console.log(`[HandConfig] Stage ${stage}: ${resolution}x${resolution} resolution, ${stage >= 1 ? Math.floor(silhouette.length * (stage / totalStages)) : 0} pixels`);
 }
 }
 
 console.log(`[HandConfig] ? Generated ${stages.length} animation stages with progressive resolution (8x8 to 96x96)`);
 return stages;
 }
 
 function loadHandConfigs() {
 return JSON.parse(localStorage.getItem(HAND_CONFIGS_KEY) || '{}');
 }
 
 // Populate saved hand configs with previews
 function populateHandConfigSelect() {
 const configs = loadHandConfigs();
 const container = document.getElementById('hand-config-previews');
 if (!container) return;
 
 container.innerHTML = '';
 Object.keys(configs).forEach(name => {
 const config = configs[name];
 const div = document.createElement('div');
 div.style.cssText = 'display: inline-block; margin: 5px; padding: 5px; border: 1px solid #444; cursor: pointer; text-align: center; background: #222;';
 
 const img = document.createElement('img');
 img.src = config.preview;
 img.style.cssText = 'width: 48px; height: 48px; image-rendering: pixelated; display: block;';
 
 const label = document.createElement('div');
 label.textContent = name;
 label.style.cssText = 'font-size: 10px; margin-top: 2px; color: #fff;';
 
 div.appendChild(img);
 div.appendChild(label);
 div.onclick = () => {
 console.log(`[HandConfig] Spawning saved hand: ${name}`);
 console.log(`[HandConfig] Stages available: ${config.stages ? config.stages.length : 0}`);
 createVoxelCursorSequence(config.coords, config.stages);
 };
 
 container.appendChild(div);
 });
 }
 
 // Initialize saved hands on load
 populateHandConfigSelect();
 
 // ===== Full cursor.html extraction and animation sequence =====
 
 // ===== Image Processing Functions (from cursor.html) =====
 
 function loadImageFromFile(file){
 return new Promise((resolve, reject)=>{
 const url = URL.createObjectURL(file);
 const img = new Image();
 img.onload = ()=>{ URL.revokeObjectURL(url); resolve(img); };
 img.onerror = reject;
 img.src = url;
 });
 }
 
 function toPixelGrid(img, grid=96){
 const work = document.createElement('canvas');
 const wctx = work.getContext('2d', { willReadFrequently: true });
 const maxSide = Math.max(img.width, img.height);
 const sx = (img.width - img.height)/2;
 const sy = (img.height - img.width)/2;
 const sw = Math.min(img.width, img.height);
 const sh = sw;
 work.width = work.height = grid;
 wctx.imageSmoothingEnabled = false;
 wctx.clearRect(0,0,grid,grid);
 wctx.fillStyle = '#ffffff';
 wctx.fillRect(0, 0, grid, grid);
 wctx.drawImage(img, Math.max(0,sx), Math.max(0,sy), sw, sh, 0, 0, grid, grid);
 const data = wctx.getImageData(0,0,grid,grid);
 return data;
 }
 
 function posterizeAndExtract(data){
 const W = data.width, H = data.height, D = data.data;
 const isWhite = (r,g,b,a)=> a<250 || (r>240 && g>240 && b>240);
 const lum = (r,g,b)=> 0.2126*r + 0.7152*g + 0.0722*b;
 const toHex = (r,g,b)=> '#' + [r,g,b].map(v=>Math.round(v).toString(16).padStart(2,'0')).join('');

 const fg = new Array(H).fill(0).map(()=>new Array(W).fill(false));
 const L = new Array(H).fill(0).map(()=>new Array(W).fill(0));
 const colors = new Array(H).fill(0).map(()=>new Array(W).fill(null));

 for(let y=0; y<H; y++){
 for(let x=0; x<W; x++){
 const i = (y*W + x)*4; 
 const r=D[i], g=D[i+1], b=D[i+2], a=D[i+3];
 if(!isWhite(r,g,b,a)){
 fg[y][x] = true; 
 L[y][x] = lum(r,g,b);
 colors[y][x] = toHex(r,g,b);
 }
 }
 }
 
 let minL=255, maxL=0; 
 for(let y=0;y<H;y++) {
 for(let x=0;x<W;x++) {
 if(fg[y][x]){ 
 const v=L[y][x]; 
 if(v<minL)minL=v; 
 if(v>maxL)maxL=v; 
 }
 }
 }
 
 const t1 = minL + (maxL-minL)*0.35;
 const t2 = minL + (maxL-minL)*0.75;

 const baseColors=[], shadeColors=[], highlightColors=[], outlineColors=[];
 const silhouette=[], outline=[], shade=[], highlight=[];
 const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
 
 for(let y=0;y<H;y++){
 for(let x=0;x<W;x++){
 if(!fg[y][x]) continue;
 const col = colors[y][x];
 silhouette.push([x,y]);
 baseColors.push(col);
 
 const lv = L[y][x];
 if(lv <= t1) { 
 shade.push([x,y]); 
 shadeColors.push(col);
 } else if(lv >= t2) { 
 highlight.push([x,y]);
 highlightColors.push(col);
 }
 
 let border=false; 
 for(const [dx,dy] of dirs){ 
 const nx=x+dx, ny=y+dy; 
 if(nx<0||ny<0||nx>=W||ny>=H||!fg[ny][nx]){ 
 border=true; 
 break; 
 } 
 }
 if(border) {
 outline.push([x,y]);
 outlineColors.push(col);
 }
 }
 }
 
 const avgColor = (cols) => {
 if(!cols.length) return '#000000';
 let r=0,g=0,b=0;
 for(const c of cols){
 r += parseInt(c.substr(1,2), 16);
 g += parseInt(c.substr(3,2), 16);
 b += parseInt(c.substr(5,2), 16);
 }
 return toHex(r/cols.length, g/cols.length, b/cols.length);
 };
 
 const avgBase = avgColor(baseColors);
 const avgShade = avgColor(shadeColors.length ? shadeColors : baseColors);
 const avgHighlight = avgColor(highlightColors.length ? highlightColors : baseColors);
 const avgOutline = avgColor(outlineColors.length ? outlineColors : baseColors);
 
 let minY=Infinity; 
 for(const [x,y] of silhouette){ 
 if(y<minY) minY=y; 
 }
 const topXs = silhouette.filter(([x,y])=>y===minY).map(([x])=>x).sort((a,b)=>a-b);
 const hotspot = { 
 x: topXs.length? topXs[Math.floor(topXs.length/2)] : Math.floor(W/2), 
 y: (minY===Infinity? Math.floor(H*0.1) : minY) 
 };
 
 console.log(`Extracted: ${silhouette.length} silhouette, ${outline.length} outline, ${shade.length} shade, ${highlight.length} highlight pixels`);

 return { width:W, height:H, silhouette, outline, shade, highlight, hotspot, colors: { base: avgBase, shade: avgShade, highlight: avgHighlight, outline: avgOutline } };
 }
 
 function generatePreviewDataURL(coords) {
 const canvas = document.createElement('canvas');
 canvas.width = coords.width;
 canvas.height = coords.height;
 const ctx = canvas.getContext('2d');
 ctx.imageSmoothingEnabled = false;
 
 const px = (x, y, color) => {
 ctx.fillStyle = color;
 ctx.fillRect(x, y, 1, 1);
 };
 
 coords.silhouette.forEach(([x,y]) => px(x, y, coords.colors.base));
 coords.shade.forEach(([x,y]) => px(x, y, coords.colors.shade));
 coords.highlight.forEach(([x,y]) => px(x, y, coords.colors.highlight));
 coords.outline.forEach(([x,y]) => px(x, y, coords.colors.outline));
 
 return canvas.toDataURL();
 }
 
 // Default hand coordinates (from cursor.html)
 const defaultHandCoords = {
 "width": 96,
 "height": 96,
 "silhouette": [[47,10],[48,10],[46,11],[47,11],[48,11],[44,12],[46,12],[47,12],[48,12],[51,12],[52,12],[43,13],[44,13],[46,13],[47,13],[48,13],[50,13],[51,13],[52,13],[43,14],[44,14],[46,14],[47,14],[48,14],[50,14],[51,14],[52,14],[43,15],[44,15],[45,15],[46,15],[47,15],[48,15],[50,15],[51,15],[52,15],[43,16],[44,16],[45,16],[46,16],[47,16],[48,16],[50,16],[51,16],[52,16],[54,16],[55,16],[43,17],[44,17],[45,17],[46,17],[47,17],[48,17],[50,17],[51,17],[52,17],[54,17],[55,17],[43,18],[44,18],[45,18],[46,18],[47,18],[48,18],[50,18],[51,18],[52,18],[54,18],[55,18],[43,19],[44,19],[45,19],[46,19],[47,19],[48,19],[50,19],[51,19],[52,19],[54,19],[55,19],[44,20],[45,20],[46,20],[47,20],[48,20],[50,20],[51,20],[52,20],[54,20],[55,20],[44,21],[45,21],[46,21],[47,21],[48,21],[50,21],[51,21],[53,21],[54,21],[55,21],[44,22],[45,22],[46,22],[47,22],[48,22],[49,22],[50,22],[51,22],[53,22],[54,22],[55,22],[45,23],[46,23],[47,23],[48,23],[49,23],[50,23],[51,23],[53,23],[54,23],[55,23],[45,24],[46,24],[47,24],[48,24],[49,24],[50,24],[51,24],[52,24],[53,24],[54,24],[42,25],[43,25],[44,25],[45,25],[46,25],[47,25],[48,25],[49,25],[50,25],[51,25],[52,25],[53,25],[54,25],[42,26],[43,26],[44,26],[45,26],[46,26],[47,26],[48,26],[49,26],[50,26],[51,26],[52,26],[53,26],[54,26],[43,27],[44,27],[45,27],[46,27],[47,27],[48,27],[49,27],[50,27],[51,27],[52,27],[53,27],[54,27],[55,27],[43,28],[44,28],[45,28],[46,28],[47,28],[48,28],[49,28],[50,28],[51,28],[52,28],[53,28],[54,28],[55,28],[44,29],[45,29],[46,29],[47,29],[48,29],[49,29],[50,29],[51,29],[52,29],[53,29],[54,29],[44,30],[45,30],[46,30],[47,30],[48,30],[49,30],[50,30],[51,30],[52,30],[53,30],[54,30],[55,30],[45,31],[46,31],[47,31],[48,31],[49,31],[50,31],[51,31],[52,31],[53,31],[54,31],[55,31],[46,32],[47,32],[48,32],[49,32],[50,32],[51,32],[52,32],[53,32],[54,32],[55,32],[47,33],[48,33],[49,33],[50,33],[51,33],[52,33],[53,33],[54,33],[55,33],[48,34],[49,34],[50,34],[51,34],[52,34],[53,34],[54,34],[55,34],[48,35],[49,35],[50,35],[51,35],[52,35],[53,35],[54,35],[55,35],[48,36],[49,36],[50,36],[51,36],[52,36],[53,36],[54,36],[55,36],[49,37],[50,37],[51,37],[52,37],[53,37],[54,37],[55,37],[50,38],[51,38],[52,38],[53,38],[54,38],[55,38],[51,39],[52,39],[53,39],[54,39],[55,39],[52,40],[53,40],[54,40],[55,40]],
 "outline": [[47,10],[48,10],[46,11],[48,11],[44,12],[46,12],[48,12],[51,12],[52,12],[43,13],[44,13],[46,13],[48,13],[50,13],[52,13],[43,14],[44,14],[46,14],[48,14],[50,14],[52,14],[43,15],[45,15],[46,15],[48,15],[50,15],[52,15],[43,16],[45,16],[46,16],[48,16],[50,16],[52,16],[54,16],[55,16],[43,17],[45,17],[46,17],[48,17],[50,17],[52,17],[54,17],[55,17],[43,18],[45,18],[46,18],[48,18],[50,18],[52,18],[54,18],[55,18],[43,19],[46,19],[48,19],[50,19],[52,19],[54,19],[55,19],[44,20],[46,20],[48,20],[50,20],[52,20],[54,20],[55,20],[44,21],[46,21],[48,21],[50,21],[51,21],[53,21],[55,21],[44,22],[47,22],[49,22],[51,22],[53,22],[55,22],[45,23],[51,23],[53,23],[55,23],[45,24],[52,24],[54,24],[42,25],[43,25],[44,25],[45,25],[54,25],[42,26],[44,26],[45,26],[54,26],[43,27],[44,27],[45,27],[55,27],[43,28],[46,28],[55,28],[44,29],[46,29],[54,29],[44,30],[46,30],[55,30],[45,31],[46,31],[55,31],[46,32],[55,32],[47,33],[55,33],[48,34],[55,34],[48,35],[55,35],[48,36],[55,36],[49,37],[55,37],[50,38],[55,38],[51,39],[55,39],[52,40],[54,40],[55,40]],
 "shade": [[43,15],[45,16],[54,16],[47,18],[54,18],[44,19],[46,19],[46,20],[53,21],[44,22],[49,22],[49,23],[45,24],[43,25],[44,25],[42,26],[43,26],[44,26],[43,27],[44,27],[46,27],[43,28],[45,28],[46,28],[44,29],[45,29],[46,29],[44,30],[45,30],[46,30],[45,31],[46,31],[46,32],[47,33],[48,34],[48,35],[49,36],[50,37],[51,38],[51,39],[52,40]],
 "highlight": [[44,12],[50,13],[45,15],[43,19],[46,19],[46,21],[47,22],[55,27],[44,28],[55,28],[45,31],[48,36]],
 "hotspot": {"x": 48, "y": 10},
 "colors": { "base": "#f3d2b4", "shade": "#d4b090", "highlight": "#fff3e2", "outline": "#23160e" }
 };
 
 function createBeveledCubeGeometry(size, bevel) {
 const geometry = new THREE.BoxGeometry(size * (1 - bevel), size * (1 - bevel), size * (1 - bevel));
 return geometry;
 }
 
 function buildVoxelHandFromCoords(coords, fingerAnim = 0) {
 const { width: W, height: H, silhouette, outline, shade, highlight, colors } = coords;
 const baseCol = colors?.base || '#f3d2b4';
 const shadeCol = colors?.shade || '#d4b090';
 const outlineCol = colors?.outline || '#23160e';
 const hiCol = colors?.highlight || '#fff3e2';

 const voxelHandGroup = new THREE.Group();
 voxelHandGroup.name = "Voxel Cursor Hand";
 
 const voxelSize = 0.02;
 const bevelAmount = 0.15;
 const thicknessLayers = 8;
 
 let coordsToRender = [];
 silhouette.forEach(c => coordsToRender.push([...c, baseCol]));
 shade.forEach(c => coordsToRender.push([...c, shadeCol]));
 if (highlight && highlight.length > 0) {
 highlight.forEach(c => coordsToRender.push([...c, hiCol]));
 }
 outline.forEach(c => coordsToRender.push([...c, outlineCol]));

 // Create a lookup set for checking neighbors
 const voxelSet = new Set();
 coordsToRender.forEach(([x, y, color]) => {
 for (let z = 0; z < thicknessLayers; z++) {
 voxelSet.add(`${x},${y},${z}`);
 }
 });
 
 // Function to check if a voxel should be removed for beveling
 function shouldBevelVoxel(x, y, z) {
 // Check the 6 direct face neighbors (up, down, left, right, front, back)
 const faceNeighbors = [
 voxelSet.has(`${x+1},${y},${z}`),
 voxelSet.has(`${x-1},${y},${z}`),
 voxelSet.has(`${x},${y+1},${z}`),
 voxelSet.has(`${x},${y-1},${z}`),
 voxelSet.has(`${x},${y},${z+1}`),
 voxelSet.has(`${x},${y},${z-1}`)
 ];
 const faceFilled = faceNeighbors.filter(n => n).length;
 
 // Check diagonal edge neighbors (12 edges of cube)
 const edgeNeighbors = [
 voxelSet.has(`${x+1},${y+1},${z}`),
 voxelSet.has(`${x+1},${y-1},${z}`),
 voxelSet.has(`${x-1},${y+1},${z}`),
 voxelSet.has(`${x-1},${y-1},${z}`),
 voxelSet.has(`${x+1},${y},${z+1}`),
 voxelSet.has(`${x+1},${y},${z-1}`),
 voxelSet.has(`${x-1},${y},${z+1}`),
 voxelSet.has(`${x-1},${y},${z-1}`),
 voxelSet.has(`${x},${y+1},${z+1}`),
 voxelSet.has(`${x},${y+1},${z-1}`),
 voxelSet.has(`${x},${y-1},${z+1}`),
 voxelSet.has(`${x},${y-1},${z-1}`)
 ];
 const edgeFilled = edgeNeighbors.filter(n => n).length;
 
 // Check corner neighbors (8 corners of cube)
 const cornerNeighbors = [
 voxelSet.has(`${x+1},${y+1},${z+1}`),
 voxelSet.has(`${x+1},${y+1},${z-1}`),
 voxelSet.has(`${x+1},${y-1},${z+1}`),
 voxelSet.has(`${x+1},${y-1},${z-1}`),
 voxelSet.has(`${x-1},${y+1},${z+1}`),
 voxelSet.has(`${x-1},${y+1},${z-1}`),
 voxelSet.has(`${x-1},${y-1},${z+1}`),
 voxelSet.has(`${x-1},${y-1},${z-1}`)
 ];
 const cornerFilled = cornerNeighbors.filter(n => n).length;
 
 // Aggressive beveling strategy for smoother, more rounded appearance:
 // - Remove multiple layers of surface voxels
 // - Create smooth curves by removing edge and corner voxels
 
 // Remove voxels with less than 4 face neighbors (more aggressive than before)
 if (faceFilled < 4) return true;
 
 // Remove sharp edges - if missing any face neighbor and few edge neighbors
 if (faceFilled < 6 && edgeFilled < 8) return true;
 
 // Remove corner voxels more aggressively
 if (faceFilled === 4 && edgeFilled < 9) return true;
 
 // Remove voxels that form sharp corners
 const totalNeighbors = faceFilled + edgeFilled + cornerFilled;
 if (totalNeighbors < 15) return true;
 
 // Secondary pass: remove additional edge voxels for smoother curves
 if (faceFilled === 5 && edgeFilled < 10 && cornerFilled < 6) return true;
 
 return false;
 }

 const colorGroups = {};
 let totalVoxels = 0;
 let beveledVoxels = 0;
 
 coordsToRender.forEach(([x, y, color]) => {
 if (!colorGroups[color]) colorGroups[color] = [];
 for (let z = 0; z < thicknessLayers; z++) {
 totalVoxels++;
 // Apply beveling - skip voxels that should be removed
 if (!shouldBevelVoxel(x, y, z)) {
 colorGroups[color].push({ x, y, z });
 } else {
 beveledVoxels++;
 }
 }
 });
 
 const remainingVoxels = totalVoxels - beveledVoxels;
 console.log(`[VoxelHand] Beveling applied: Removed ${beveledVoxels} of ${totalVoxels} voxels (${((beveledVoxels/totalVoxels)*100).toFixed(1)}%) for rounded edges`);
 console.log(`[VoxelHand] Remaining voxels: ${remainingVoxels}`);

 const cubeGeometry = createBeveledCubeGeometry(voxelSize, bevelAmount);

 Object.entries(colorGroups).forEach(([color, positions]) => {
 const instancedMesh = new THREE.InstancedMesh(
 cubeGeometry,
 new THREE.MeshStandardMaterial({ 
 color: color,
 metalness: 0.1,
 roughness: 0.6
 }),
 positions.length
 );

 const matrix = new THREE.Matrix4();
 positions.forEach((pos, i) => {
 const px = (pos.x - W/2) * voxelSize;
 const py = (pos.z) * voxelSize;
 const pz = (pos.y - H/2) * voxelSize;
 
 matrix.makeTranslation(px, py, pz);
 instancedMesh.setMatrixAt(i, matrix);
 });
 
 instancedMesh.instanceMatrix.needsUpdate = true;
 instancedMesh.castShadow = true;
 instancedMesh.receiveShadow = true;
 voxelHandGroup.add(instancedMesh);
 });

 const baseHeight = voxelSize * thicknessLayers * 2.5 / 2;
 voxelHandGroup.position.set(0, baseHeight, 0);
 voxelHandGroup.scale.setScalar(2.5);
 
 return voxelHandGroup;
 }
 
 function animateVoxelHandPopIn(voxelHandGroup) {
 const targetScale = 2.5;
 const baseHeight = 0.02 * 8 * 2.5 / 2;
 voxelHandGroup.scale.setScalar(0.01);
 voxelHandGroup.position.y = baseHeight;
 
 const startTime = Date.now();
 const popDuration = 600;
 
 function animatePop() {
 const elapsed = Date.now() - startTime;
 const progress = Math.min(elapsed / popDuration, 1);
 
 const c4 = (2 * Math.PI) / 3;
 const easeOut = progress === 1 ? 1 : Math.pow(2, -10 * progress) * Math.sin((progress * 10 - 0.75) * c4) + 1;
 
 voxelHandGroup.scale.setScalar(0.01 + easeOut * (targetScale - 0.01));
 
 const bounce = Math.sin(progress * Math.PI) * 0.3;
 voxelHandGroup.position.y = baseHeight + bounce;
 
 if (progress < 1) {
 requestAnimationFrame(animatePop);
 } else {
 voxelHandGroup.position.y = baseHeight;
 }
 }
 animatePop();
 }
 
 // Voxel cursor creation sequence with progressive 2D-to-3D evolution
 function createVoxelCursorSequence(coordsOrImageData, storedStages = null) {
 // Start cursor glitch effect for this spawning sequence
 console.log('[CursorGlitch] Starting cursor glitch for hand spawn');
 startCursorGlitch();
 
 // Don't hide the scene - we want to see the animation happen in real-time
 // Just ensure the sprite is front and center
 
 // If passed coords object, use it. Otherwise use default.
 const coords = (coordsOrImageData && coordsOrImageData.width) ? coordsOrImageData : defaultHandCoords;
 const { width: W, height: H, silhouette, outline, shade, highlight, colors } = coords;
 const baseCol = colors?.base || '#f3d2b4';
 const shadeCol = colors?.shade || '#d4b090';
 const outlineCol = colors?.outline || '#23160e';
 const hiCol = colors?.highlight || '#fff3e2';
 
 console.log(`[VoxelHand] Using ${storedStages ? 'stored' : 'generated'} stages`);
 
 // Create display canvas at full resolution
 const displayCanvas = document.createElement('canvas');
 displayCanvas.width = W;
 displayCanvas.height = H;
 const displayCtx = displayCanvas.getContext('2d');
 displayCtx.imageSmoothingEnabled = false;
 
 // Create work canvas that changes size per stage
 const workCanvas = document.createElement('canvas');
 const workCtx = workCanvas.getContext('2d');
 workCtx.imageSmoothingEnabled = false;
 
 // Create sprite material with high render order to appear on top
 const texture = new THREE.CanvasTexture(displayCanvas);
 texture.minFilter = THREE.NearestFilter;
 texture.magFilter = THREE.NearestFilter;
 
 const spriteMat = new THREE.SpriteMaterial({ 
 map: texture, 
 transparent: true,
 depthWrite: false,
 depthTest: false
 });
 const sprite = new THREE.Sprite(spriteMat);
 
 // Track mouse cursor position for sprite placement
 let mouseX = 0;
 let mouseY = 0;
 const initialDistance = 0.5; // Very close - replacing cursor
 
 // Get current mouse position (or center if not available)
 const getCurrentMousePosition = () => {
 return { x: mouseX, y: mouseY };
 };
 
 // Mouse tracking listener
 const mouseMoveHandler = (event) => {
 mouseX = (event.clientX / window.innerWidth) * 2 - 1;
 mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
 };
 window.addEventListener('mousemove', mouseMoveHandler);
 
 // Function to update sprite position based on mouse
 const updateSpritePosition = (pushDistance = 0) => {
 const mouse = getCurrentMousePosition();
 const raycaster = new THREE.Raycaster();
 raycaster.setFromCamera(new THREE.Vector2(mouse.x, mouse.y), camera);
 
 // Position at a fixed distance from camera in the direction of the mouse
 const direction = raycaster.ray.direction.clone().normalize();
 const distance = initialDistance + pushDistance;
 sprite.position.copy(camera.position).add(direction.multiplyScalar(distance));
 };
 
 // Initial position at cursor
 updateSpritePosition(0);
 
 sprite.scale.set(0.15, 0.15, 1); // Start very small, like a cursor
 sprite.renderOrder = 10000; // Render on top of everything
 scene.add(sprite);
 
 console.log(`[VoxelHand] Construction sequence starting at cursor position`);
 console.log(`[VoxelHand] Tracking mouse cursor and will push back as it grows`);
 
 // Progressive 12-stage evolution with increasing resolution
 let currentStage = 0;
 const totalStages = 12;
 // Resolution scales from 8x8 to full 96x96
 const resolutionMap = { 
 0: 8, 1: 12, 2: 16, 3: 24, 4: 32, 5: 40, 
 6: 48, 7: 56, 8: 64, 9: 72, 10: 80, 11: 88, 12: 96 
 };
 
 function drawStage(stage) {
 // Get resolution for this stage
 const resolution = resolutionMap[stage] || 96;
 const scale = W / resolution;
 
 // Resize work canvas to stage resolution
 workCanvas.width = resolution;
 workCanvas.height = resolution;
 workCtx.clearRect(0, 0, resolution, resolution);
 
 // Draw at lower resolution
 const px = (x, y, color) => {
 const scaledX = Math.floor(x / scale);
 const scaledY = Math.floor(y / scale);
 if (scaledX >= 0 && scaledX < resolution && scaledY >= 0 && scaledY < resolution) {
 workCtx.fillStyle = color;
 workCtx.fillRect(scaledX, scaledY, 1, 1);
 }
 };
 
 // Progressive reveal based on stage - BOTTOM TO TOP (fingers to wrist)
 // Sort by Y coordinate descending (higher Y values = fingertips at bottom of image)
 const sortedSilhouette = silhouette.slice().sort((a, b) => b[1] - a[1]);
 const sortedShade = shade ? shade.slice().sort((a, b) => b[1] - a[1]) : [];
 const sortedHighlight = highlight ? highlight.slice().sort((a, b) => b[1] - a[1]) : [];
 const sortedOutline = outline ? outline.slice().sort((a, b) => b[1] - a[1]) : [];
 
 if (stage >= 1) {
 const silAmount = Math.floor(sortedSilhouette.length * (stage / totalStages));
 for (let i = 0; i < silAmount; i++) {
 const [x, y] = sortedSilhouette[i];
 px(x, y, baseCol);
 }
 }
 
 if (stage >= 3 && sortedShade.length > 0) {
 const shadeAmount = Math.floor(sortedShade.length * ((stage - 2) / (totalStages - 2)));
 for (let i = 0; i < shadeAmount; i++) {
 const [x, y] = sortedShade[i];
 px(x, y, shadeCol);
 }
 }
 
 if (stage >= 10 && sortedHighlight.length > 0) {
 const hiAmount = Math.floor(sortedHighlight.length * ((stage - 9) / 3));
 for (let i = 0; i < hiAmount; i++) {
 const [x, y] = sortedHighlight[i];
 px(x, y, hiCol);
 }
 }
 
 if (stage >= 1 && sortedOutline.length > 0) {
 const outAmount = Math.floor(sortedOutline.length * (stage / totalStages));
 for (let i = 0; i < outAmount; i++) {
 const [x, y] = sortedOutline[i];
 px(x, y, outlineCol);
 }
 }
 
 // Scale up work canvas to display canvas (pixelated upscaling)
 displayCtx.clearRect(0, 0, W, H);
 displayCtx.imageSmoothingEnabled = false;
 displayCtx.drawImage(workCanvas, 0, 0, resolution, resolution, 0, 0, W, H);
 
 texture.needsUpdate = true;
 
 // Animate sprite size and Z position as it grows
 const stageProgress = stage / totalStages;
 const finalScale = 3.5;
 const finalPushDistance = 2.5; // How far to push away from initial position
 const currentScale = 0.15 + (finalScale - 0.15) * stageProgress;
 currentPushDistance = finalPushDistance * stageProgress;
 
 // Update sprite scale
 sprite.scale.set(currentScale, currentScale, 1);
 
 console.log(`[VoxelHand] Stage ${stage}: ${resolution}x${resolution}, scale ${currentScale.toFixed(2)}, push ${currentPushDistance.toFixed(2)}`);
 }
 
 console.log('[VoxelHand] Starting voxel cursor sequence with 12 stages...');
 
 // Continuous tracking: update sprite position every frame
 let isSequenceActive = true;
 let currentPushDistance = 0;
 const trackingLoop = () => {
 if (isSequenceActive && sprite.parent) {
 updateSpritePosition(currentPushDistance);
 requestAnimationFrame(trackingLoop);
 }
 };
 trackingLoop();
 
 // If we have stored stages, use them directly
 if (storedStages && storedStages.length >= 13) {
 console.log(`[VoxelHand] Using ${storedStages.length} pre-generated stages from storage`);
 
 // Create an image to load stage data
 const stageImage = new Image();
 let currentStageIdx = 0;
 
 function loadNextStage() {
 if (currentStageIdx < storedStages.length && currentStageIdx <= totalStages) {
 stageImage.onload = () => {
 // Draw the stage image to canvas
 displayCtx.clearRect(0, 0, W, H);
 displayCtx.drawImage(stageImage, 0, 0, W, H);
 texture.needsUpdate = true;
 
 // Animate sprite size and Z position as it grows (same as generated stages)
 const stage = currentStageIdx;
 const stageProgress = stage / totalStages;
 const finalScale = 3.5;
 const finalPushDistance = 2.5;
 const currentScale = 0.15 + (finalScale - 0.15) * stageProgress;
 currentPushDistance = finalPushDistance * stageProgress;
 
 sprite.scale.set(currentScale, currentScale, 1);
 
 console.log(`[VoxelHand] Loaded stored stage ${currentStageIdx}/${totalStages}`);
 currentStageIdx++;
 
 if (currentStageIdx <= totalStages) {
 setTimeout(loadNextStage, 200);
 } else {
 // All stages complete
 setTimeout(finishSequence, 800);
 }
 };
 stageImage.src = storedStages[currentStageIdx];
 }
 }
 
 loadNextStage();
 
 } else {
 // Generate stages on the fly
 console.log('[VoxelHand] Generating stages on the fly');
 
 // Draw initial stage 0 (empty)
 drawStage(0);
 
 // Animate through stages
 const stageInterval = setInterval(() => {
 currentStage++;
 console.log(`[VoxelHand] Drawing stage ${currentStage}/${totalStages}`);
 drawStage(currentStage);
 
 if (currentStage >= totalStages) {
 clearInterval(stageInterval);
 setTimeout(finishSequence, 800);
 }
 }, 200);
 }
 
 // Shared finish function
 function finishSequence() {
 console.log('[VoxelHand] All 2D stages complete, transitioning to 3D...');
 
 // Stop tracking loop
 isSequenceActive = false;
 
 // Clean up mouse tracking
 window.removeEventListener('mousemove', mouseMoveHandler);
 
 // Store sprite position for continuity
 const spritePosition = sprite.position.clone();
 
 // Remove sprite
 scene.remove(sprite);
 spriteMat.dispose();
 texture.dispose();
 
 // Build full resolution voxel hand
 console.log('[VoxelHand] Building 3D voxel hand with beveled edges...');
 const voxelHandGroup = buildVoxelHandFromCoords(coords);
 
 // Position voxel hand at the same location as the sprite was
 voxelHandGroup.position.copy(spritePosition);
 
 // Face the camera
 voxelHandGroup.lookAt(camera.position);
 voxelHandGroup.rotateY(Math.PI);
 
 scene.add(voxelHandGroup);
 animateVoxelHandPopIn(voxelHandGroup);
 
 console.log(`[VoxelHand] 3D voxel hand spawned at: (${voxelHandGroup.position.x.toFixed(2)}, ${voxelHandGroup.position.y.toFixed(2)}, ${voxelHandGroup.position.z.toFixed(2)})`);
 
 // Slowly rotate voxel hand continuously
 function rotateVoxelHand() {
 if (voxelHandGroup && voxelHandGroup.parent) {
 voxelHandGroup.rotation.y += 0.005;
 requestAnimationFrame(rotateVoxelHand);
 }
 }
 rotateVoxelHand();
 
 // Stop cursor glitch after hand is spawned
 console.log('[CursorGlitch] Stopping cursor glitch - hand spawn complete');
 stopCursorGlitch();
 
 console.log('[VoxelHand] ? Voxel cursor sequence complete!');
 }
 }
 
 // ===== Configuration Management =====
 function saveConfiguration() {
 const name = document.getElementById('config-name-input').value.trim() || 'Unnamed Configuration';
 const config = getCurrentConfiguration();
 const configs = JSON.parse(localStorage.getItem('sceneConfigurations') || '{}');
 configs[name] = config;
 localStorage.setItem('sceneConfigurations', JSON.stringify(configs));
 alert(`Configuration "${name}" saved!`);
 populateConfigList();
 }
 
 function saveAsConfiguration() {
 const name = document.getElementById('config-name-input').value.trim();
 if (!name) {
 alert('Please enter a configuration name');
 return;
 }
 saveConfiguration();
 }
 
 function loadConfiguration(name) {
 const configs = JSON.parse(localStorage.getItem('sceneConfigurations') || '{}');
 const config = configs[name];
 if (config) {
 applyConfiguration(config);
 alert(`Configuration "${name}" loaded!`);
 }
 }
 
 function getCurrentConfiguration() {
 return {
 camera: {
 position: camera.position.toArray(),
 target: controls.target.toArray(),
 fov: camera.fov
 },
 scene: window.guiParams.scene,
 bust: window.guiParams.bust,
 head: window.guiParams.head,
 post: window.guiParams.post,
 hands: window.guiParams.hands,
 lighting: {
 ambient: al.intensity,
 hemisphere: hl.intensity,
 directional: dl.intensity,
 spot: spotLight.intensity,
 rim: rimLight.intensity
 }
 };
 }
 
 function applyConfiguration(config) {
 if (config.camera) {
 camera.position.fromArray(config.camera.position);
 controls.target.fromArray(config.camera.target);
 camera.fov = config.camera.fov;
 camera.updateProjectionMatrix();
 controls.update();
 }
 if (config.lighting) {
 al.intensity = config.lighting.ambient;
 hl.intensity = config.lighting.hemisphere;
 dl.intensity = config.lighting.directional;
 spotLight.intensity = config.lighting.spot;
 rimLight.intensity = config.lighting.rim;
 }
 // Apply other settings...
 Object.assign(window.guiParams.scene, config.scene || {});
 Object.assign(window.guiParams.head, config.head || {});
 Object.assign(window.guiParams.hands, config.hands || {});
 }
 
 function populateConfigList() {
 const select = document.getElementById('config-list-select');
 select.innerHTML = '';
 const configs = JSON.parse(localStorage.getItem('sceneConfigurations') || '{}');
 Object.keys(configs).forEach(name => {
 const option = document.createElement('option');
 option.value = name;
 option.textContent = name;
 select.appendChild(option);
 });
 select.ondblclick = () => {
 if (select.value) loadConfiguration(select.value);
 };
 }
 
 // ===== Scene Browser =====
 function populateSceneBrowser() {
 const container = document.getElementById('scene-browser-content');
 container.innerHTML = '';
 
 const objects = [
 { name: 'Hands', obj: handsGroup },
 { name: '+- Right Hand', obj: rightHandGroup },
 { name: '+- Left Hand', obj: leftHandGroup },
 { name: 'Celli Avatar', obj: celliAvatarGroup },
 { name: '+- Celli Body', obj: characterGroup },
 { name: '+- Celli Head', obj: voxelHeadGroup },
 { name: 'Keyboard', obj: keyboardGroup }
 ];
 
 objects.forEach(item => {
 const div = document.createElement('div');
 div.className = 'hierarchy-item';
 div.textContent = item.name;
 div.onclick = () => {
 document.querySelectorAll('.hierarchy-item').forEach(el => el.classList.remove('selected'));
 div.classList.add('selected');
 if (item.obj && transformControl) {
 transformControl.attach(item.obj);
 }
 };
 container.appendChild(div);
 });
 }
 
 // ===== Configuration Report =====
 function generateConfigurationReport() {
 const content = document.getElementById('config-report-content');
 const config = getCurrentConfiguration();
 
 // Helper to format position and rotation
 const formatVec3 = (v) => `[${v.x.toFixed(3)}, ${v.y.toFixed(3)}, ${v.z.toFixed(3)}]`;
 const formatRot = (r) => `[${(r.x * 180 / Math.PI).toFixed(1)} , ${(r.y * 180 / Math.PI).toFixed(1)} , ${(r.z * 180 / Math.PI).toFixed(1)} ]`;
 
 let report = '=== SCENE CONFIGURATION REPORT ===\n\n';
 
 // Camera and Lighting
 report += '?? Current State:\n';
 report += `Camera FOV: ${config.camera.fov.toFixed(1)} \n`;
 report += `Camera Position: [${config.camera.position.map(v => v.toFixed(2)).join(', ')}]\n`;
 report += `Ambient Light: ${config.lighting.ambient.toFixed(2)}\n`;
 report += `Spot Light: ${config.lighting.spot.toFixed(2)}\n\n`;
 
 // Scene Object Transforms
 report += '?? Scene Object Transforms:\n\n';
 
 if (handsGroup) {
 report += '? Hands Group:\n';
 report += ` Position: ${formatVec3(handsGroup.position)}\n`;
 report += ` Rotation: ${formatRot(handsGroup.rotation)}\n`;
 report += ` Scale: ${handsGroup.scale.x.toFixed(3)}\n`;
 report += ` Visible: ${handsGroup.visible}\n\n`;
 
 if (rightHandGroup) {
 report += ' ? Right Hand Group:\n';
 report += ` Position: ${formatVec3(rightHandGroup.position)}\n`;
 report += ` Rotation: ${formatRot(rightHandGroup.rotation)}\n`;
 report += ` Scale: ${rightHandGroup.scale.x.toFixed(3)}\n`;
 report += ` Visible: ${rightHandGroup.visible}\n`;
 report += ` Children: ${rightHandGroup.children.length}\n`;
 if (finger && rightHandGroup.children.includes(finger)) {
 report += ` +- Main Finger: pos ${formatVec3(finger.position)}, rot ${formatRot(finger.rotation)}\n`;
 }
 rightHandGroup.children.forEach((child, i) => {
 if (child !== finger && child.userData && child.userData.isStaticFinger) {
 report += ` +- Static Finger ${i}: pos ${formatVec3(child.position)}\n`;
 }
 });
 report += '\n';
 }
 
 if (leftHandGroup) {
 report += ' ? Left Hand Group:\n';
 report += ` Position: ${formatVec3(leftHandGroup.position)}\n`;
 report += ` Rotation: ${formatRot(leftHandGroup.rotation)}\n`;
 report += ` Scale: ${leftHandGroup.scale.x.toFixed(3)}\n`;
 report += ` Visible: ${leftHandGroup.visible}\n`;
 report += ` Children: ${leftHandGroup.children.length}\n`;
 leftHandGroup.children.forEach((child, i) => {
 if (child.userData && child.userData.isStaticFinger) {
 report += ` +- Static Finger ${i}: pos ${formatVec3(child.position)}\n`;
 }
 });
 report += '\n';
 }
 }
 
 if (celliAvatarGroup) {
 report += '? Celli Avatar Group:\n';
 report += ` Position: ${formatVec3(celliAvatarGroup.position)}\n`;
 report += ` Rotation: ${formatRot(celliAvatarGroup.rotation)}\n`;
 report += ` Scale: ${celliAvatarGroup.scale.x.toFixed(3)}\n`;
 report += ` Visible: ${celliAvatarGroup.visible}\n\n`;
 
 if (characterGroup) {
 report += ' ? Character Body (Bust):\n';
 report += ` Position: ${formatVec3(characterGroup.position)}\n`;
 report += ` Rotation: ${formatRot(characterGroup.rotation)}\n`;
 report += ` Scale: ${characterGroup.scale.x.toFixed(3)}\n`;
 report += ` Visible: ${characterGroup.visible}\n`;
 if (characterBust) {
 report += ` +- Preview Mesh: visible ${characterBust.visible}, wireframe ${characterBust.material.wireframe}\n`;
 }
 if (characterUnifiedMesh) {
 report += ` +- Unified Mesh: visible ${characterUnifiedMesh.visible}, wireframe ${characterUnifiedMesh.material.wireframe}\n`;
 }
 report += '\n';
 }
 
 if (voxelHeadGroup) {
 report += ' ? Voxel Head:\n';
 report += ` Position: ${formatVec3(voxelHeadGroup.position)}\n`;
 report += ` Rotation: ${formatRot(voxelHeadGroup.rotation)}\n`;
 report += ` Scale: ${voxelHeadGroup.scale.x.toFixed(3)}\n`;
 report += ` Visible: ${voxelHeadGroup.visible}\n`;
 report += ` Voxels: ${voxelHeadGroup.children.filter(c => c.isInstancedMesh).length} instanced meshes\n\n`;
 }
 }
 
 if (keyboardGroup) {
 report += '? Keyboard Group:\n';
 report += ` Position: ${formatVec3(keyboardGroup.position)}\n`;
 report += ` Rotation: ${formatRot(keyboardGroup.rotation)}\n`;
 report += ` Scale: ${keyboardGroup.scale.x.toFixed(3)}\n`;
 report += ` Visible: ${keyboardGroup.visible}\n`;
 if (keys) {
 report += ` Keys: ${keys.length}\n`;
 }
 report += '\n';
 }
 
 // Find voxel cursor hand if it exists
 const voxelCursorHand = scene.children.find(c => c.name === "Voxel Cursor Hand");
 if (voxelCursorHand) {
 report += '? Voxel Cursor Hand:\n';
 report += ` Position: ${formatVec3(voxelCursorHand.position)}\n`;
 report += ` Rotation: ${formatRot(voxelCursorHand.rotation)}\n`;
 report += ` Scale: ${voxelCursorHand.scale.x.toFixed(3)}\n`;
 report += ` Visible: ${voxelCursorHand.visible}\n\n`;
 }
 
 // Lights
 report += '?? Light Positions:\n';
 if (ambientLight) {
 report += ` Ambient Light: intensity ${ambientLight.intensity.toFixed(3)}\n`;
 }
 if (dl) {
 report += ` Directional Light: pos ${formatVec3(dl.position)}, intensity ${dl.intensity.toFixed(3)}\n`;
 }
 if (spotLight) {
 report += ` Spot Light: pos ${formatVec3(spotLight.position)}, intensity ${spotLight.intensity.toFixed(3)}\n`;
 }
 if (rimLight) {
 report += ` Rim Light: pos ${formatVec3(rimLight.position)}, intensity ${rimLight.intensity.toFixed(3)}\n`;
 }
 report += '\n';
 
 report += '?? Recommendations:\n';
 const recommendations = [];
 
 if (config.lighting.ambient < 0.1) {
 recommendations.push(' Ambient light is very low - consider increasing to 0.15 for better visibility');
 }
 if (config.lighting.spot > 5) {
 recommendations.push(' Spot light intensity is high - may cause overexposure');
 }
 if (config.camera.fov < 30) {
 recommendations.push(' FOV is narrow - increase to 45 for normal perspective');
 }
 if (config.camera.fov > 90) {
 recommendations.push(' FOV is very wide - reduce to 45-60 for less distortion');
 }
 if (config.head && config.head['Animation Speed'] > 2) {
 recommendations.push(' Head animation speed is very fast - consider reducing to 1.0-1.5');
 }
 if (config.post && config.post['Bloom Strength'] > 2) {
 recommendations.push(' Bloom strength is high - reduce to 0.5-1.0 for subtle glow');
 }
 
 if (recommendations.length === 0) {
 report += '? All settings are within recommended ranges!\n';
 } else {
 report += recommendations.join('\n') + '\n';
 }
 
 report += '\n?? Storage:\n';
 const configs = JSON.parse(localStorage.getItem('sceneConfigurations') || '{}');
 report += `Saved Configurations: ${Object.keys(configs).length}\n`;
 
 content.textContent = report;
 }
 
 // ===== Edit Head Modal Sync =====
 function syncHeadModalToParams() {
 const headParams = window.guiParams.head;
 document.getElementById('head-anim-speed').value = headParams['Animation Speed'];
 document.getElementById('head-anim-speed-val').textContent = headParams['Animation Speed'];
 document.getElementById('head-amplitude').value = headParams['Amplitude'];
 document.getElementById('head-amplitude-val').textContent = headParams['Amplitude'];
 document.getElementById('head-opacity-min').value = headParams['Opacity Min'];
 document.getElementById('head-opacity-min-val').textContent = headParams['Opacity Min'];
 document.getElementById('head-opacity-max').value = headParams['Opacity Max'];
 document.getElementById('head-opacity-max-val').textContent = headParams['Opacity Max'];
 document.getElementById('head-emissive').value = headParams['Emissive Intensity'];
 document.getElementById('head-emissive-val').textContent = headParams['Emissive Intensity'];
 document.getElementById('head-light-int').value = headParams['Light Intensity'];
 document.getElementById('head-light-int-val').textContent = headParams['Light Intensity'];
 document.getElementById('head-light-pulse').checked = headParams['Light Pulse'];
 document.getElementById('head-rotation-speed').value = headParams['Rotation Speed'];
 document.getElementById('head-rotation-speed-val').textContent = headParams['Rotation Speed'];
 document.getElementById('head-color').value = headParams['Color'];
 // Advanced
 document.getElementById('head-phase-noise').value = headParams['Phase Noise'];
 document.getElementById('head-phase-noise-val').textContent = headParams['Phase Noise'];
 document.getElementById('head-falloff').value = headParams['Falloff'];
 document.getElementById('head-falloff-val').textContent = headParams['Falloff'];
 document.getElementById('head-noise-warp').value = headParams['Noise Warp'];
 document.getElementById('head-noise-warp-val').textContent = headParams['Noise Warp'];
 document.getElementById('head-opacity-speed').value = headParams['Opacity Speed'];
 document.getElementById('head-opacity-speed-val').textContent = headParams['Opacity Speed'];
 // Material
 document.getElementById('head-metalness').value = headParams['Metalness'];
 document.getElementById('head-metalness-val').textContent = headParams['Metalness'];
 document.getElementById('head-roughness').value = headParams['Roughness'];
 document.getElementById('head-roughness-val').textContent = headParams['Roughness'];
}

// headPresets already defined earlier before initializeVoxelHead

window.loadHeadPreset = function(presetName) {
const preset = headPresets[presetName];
if (!preset) return;

document.getElementById('head-anim-speed').value = preset.animSpeed;
document.getElementById('head-anim-speed-val').textContent = preset.animSpeed;
document.getElementById('head-amplitude').value = preset.amplitude;
document.getElementById('head-amplitude-val').textContent = preset.amplitude;
document.getElementById('head-opacity-min').value = preset.opacityMin;
document.getElementById('head-opacity-min-val').textContent = preset.opacityMin;
document.getElementById('head-opacity-max').value = preset.opacityMax;
document.getElementById('head-opacity-max-val').textContent = preset.opacityMax;
document.getElementById('head-emissive').value = preset.emissive;
document.getElementById('head-emissive-val').textContent = preset.emissive;
document.getElementById('head-light-int').value = preset.lightInt;
document.getElementById('head-light-int-val').textContent = preset.lightInt;
document.getElementById('head-light-pulse').checked = preset.lightPulse;
document.getElementById('head-rotation-speed').value = preset.rotationSpeed;
document.getElementById('head-rotation-speed-val').textContent = preset.rotationSpeed;
document.getElementById('head-color').value = preset.color;

// Advanced parameters
if (preset.phaseNoise !== undefined) {
document.getElementById('head-phase-noise').value = preset.phaseNoise;
document.getElementById('head-phase-noise-val').textContent = preset.phaseNoise;
}
if (preset.falloff !== undefined) {
document.getElementById('head-falloff').value = preset.falloff;
document.getElementById('head-falloff-val').textContent = preset.falloff;
}
if (preset.noiseWarp !== undefined) {
document.getElementById('head-noise-warp').value = preset.noiseWarp;
document.getElementById('head-noise-warp-val').textContent = preset.noiseWarp;
}
if (preset.opacitySpeed !== undefined) {
document.getElementById('head-opacity-speed').value = preset.opacitySpeed;
document.getElementById('head-opacity-speed-val').textContent = preset.opacitySpeed;
}

// Material parameters
if (preset.metalness !== undefined) {
document.getElementById('head-metalness').value = preset.metalness;
document.getElementById('head-metalness-val').textContent = preset.metalness;
}
if (preset.roughness !== undefined) {
document.getElementById('head-roughness').value = preset.roughness;
document.getElementById('head-roughness-val').textContent = preset.roughness;
}

// Voxel geometry parameters (scale to UI range)
if (preset.voxelSize !== undefined) {
const sizeScale = preset.voxelSize / 0.10; // Relative to base 0.10
document.getElementById('head-voxel-scale').value = sizeScale;
document.getElementById('head-voxel-scale-val').textContent = sizeScale.toFixed(2);
}
if (preset.shellThickness !== undefined) {
const layers = preset.shellThickness / 0.06; // Scale to slider range
document.getElementById('head-voxel-layers').value = layers;
document.getElementById('head-voxel-layers-val').textContent = Math.round(layers);
}
if (preset.voxelSpacing !== undefined) {
document.getElementById('head-voxel-spacing').value = preset.voxelSpacing;
document.getElementById('head-voxel-spacing-val').textContent = preset.voxelSpacing.toFixed(2);
}

console.log(`[Head Preset] Loaded preset: ${presetName}`);

// Auto-apply
window.applyHeadSettings();
};
 
 window.applyHeadSettings = function() {
 const headParams = window.guiParams.head;
 headParams['Animation Speed'] = parseFloat(document.getElementById('head-anim-speed').value);
 headParams['Amplitude'] = parseFloat(document.getElementById('head-amplitude').value);
 headParams['Opacity Min'] = parseFloat(document.getElementById('head-opacity-min').value);
 headParams['Opacity Max'] = parseFloat(document.getElementById('head-opacity-max').value);
 headParams['Emissive Intensity'] = parseFloat(document.getElementById('head-emissive').value);
 headParams['Light Intensity'] = parseFloat(document.getElementById('head-light-int').value);
 headParams['Light Pulse'] = document.getElementById('head-light-pulse').checked;
 headParams['Rotation Speed'] = parseFloat(document.getElementById('head-rotation-speed').value);
 headParams['Color'] = document.getElementById('head-color').value;
 // Advanced
 headParams['Phase Noise'] = parseFloat(document.getElementById('head-phase-noise').value);
 headParams['Falloff'] = parseFloat(document.getElementById('head-falloff').value);
 headParams['Noise Warp'] = parseFloat(document.getElementById('head-noise-warp').value);
 headParams['Opacity Speed'] = parseFloat(document.getElementById('head-opacity-speed').value);
 // Material
 headParams['Metalness'] = parseFloat(document.getElementById('head-metalness').value);
 headParams['Roughness'] = parseFloat(document.getElementById('head-roughness').value);
 
 if (voxelHeadGroup && voxelHeadGroup.userData.instancedMesh) {
 voxelHeadGroup.userData.instancedMesh.material.color.set(headParams['Color']);
 voxelHeadGroup.userData.instancedMesh.material.emissive.set(headParams['Color']);
 voxelHeadGroup.userData.instancedMesh.material.metalness = headParams['Metalness'];
 voxelHeadGroup.userData.instancedMesh.material.roughness = headParams['Roughness'];
 if (voxelHeadGroup.userData.headLight) {
 voxelHeadGroup.userData.headLight.color.set(headParams['Color']);
 }
 }
 
 alert('Head settings applied!');
 };
 
 // Wire up edit head modal sliders
 ['head-anim-speed', 'head-amplitude', 'head-opacity-min', 'head-opacity-max', 
 'head-emissive', 'head-light-int', 'head-rotation-speed',
 'head-phase-noise', 'head-falloff', 'head-noise-warp', 'head-opacity-speed',
 'head-metalness', 'head-roughness',
 'head-mouth-deform', 'head-voxel-layers', 'head-voxel-scale', 'head-voxel-spacing'].forEach(id => {
 const slider = document.getElementById(id);
 const display = document.getElementById(id + '-val');
 if (slider && display) {
 slider.oninput = () => {
 let val = slider.value;
 // Special formatting for mouth deform
 if (id === 'head-mouth-deform') {
 const numVal = parseFloat(val);
 if (numVal > 0.5) {
 display.textContent = `${val} (Smile)`;
 } else if (numVal < -0.5) {
 display.textContent = `${val} (Frown)`;
 } else {
 display.textContent = `${val} (Neutral)`;
 }
 } else {
 display.textContent = val;
 }
 
 // Update global parameters for voxel controls
 if (id === 'head-mouth-deform') window.headMouthDeform = parseFloat(val);
 if (id === 'head-voxel-layers') window.headVoxelLayers = parseFloat(val) * 0.06; // Scale to actual thickness
 if (id === 'head-voxel-scale') window.headVoxelSize = 0.10 * parseFloat(val);
 if (id === 'head-voxel-spacing') window.headVoxelSpacing = parseFloat(val);
 };
 }
 });
 
 // Make windows draggable
 function makeDraggable(modalId) {
 const modal = document.getElementById(modalId);
 const header = modal.querySelector('.modal-header');
 let isDragging = false;
 let currentX, currentY, initialX, initialY;
 
 header.addEventListener('mousedown', (e) => {
 if (e.target === header || e.target === header.querySelector('h3')) {
 isDragging = true;
 initialX = e.clientX - (modal.offsetLeft || 0);
 initialY = e.clientY - (modal.offsetTop || 0);
 }
 });
 
 document.addEventListener('mousemove', (e) => {
 if (isDragging) {
 e.preventDefault();
 currentX = e.clientX - initialX;
 currentY = e.clientY - initialY;
 modal.style.left = currentX + 'px';
 modal.style.top = currentY + 'px';
 modal.style.transform = 'none';
 }
 });
 
 document.addEventListener('mouseup', () => {
 isDragging = false;
 });
 }
 
 makeDraggable('scene-browser-modal');
 makeDraggable('edit-head-modal');
 makeDraggable('save-config-modal');
 makeDraggable('config-report-modal');
 
 // Expose save/load functions globally
 window.saveConfiguration = saveConfiguration;
 window.saveAsConfiguration = saveAsConfiguration;
 window.loadConfiguration = loadConfiguration;
 
 // ===== Create Hands GUI for Modal =====
 function createHandsGUI() {
 const container = document.getElementById('edit-hands-content');
 const handsGUI = new GUI({ container, title: '' });
 handsGUI.add(handsParams, 'Fingerprint Enabled').onChange(v => {
 FP.enabled = v;
 if (window.applyFpToMaterial) window.applyFpToMaterial();
 });
 handsGUI.add(handsParams, 'Fingerprint Strength', 0, 3, 0.01).onChange(v => {
 FP.strength = v;
 if (window.applyFpToMaterial) window.applyFpToMaterial();
 });
 handsGUI.add(handsParams, 'Fingerprint Scale', 0.1, 3, 0.01).onChange(v => {
 FP.scale = v;
 if (window.applyFpToMaterial) window.applyFpToMaterial();
 });
 handsGUI.add(handsParams, 'Finger Spacing', 0.5, 3.0, 0.1);
 handsGUI.add(handsParams, 'Apply to Material');
 handsGUI.add(handsParams, 'Apply Spacing');
 handsGUI.add(handsParams, 'Show Hands').onChange(v => {
 if (handsGroup) {
 handsGroup.traverse(obj => {
 // Hide everything except voxel wraps
 if (obj.name !== 'VoxelWrap') {
 obj.visible = v;
 }
 });
 }
 });
 handsGUI.add(handsParams, 'Right Hand Visible').onChange(v => {
 if (rightHandGroup) rightHandGroup.visible = v;
 });
 handsGUI.add(handsParams, 'Left Hand Visible').onChange(v => {
 if (leftHandGroup) leftHandGroup.visible = v;
 });
 handsGUI.add(handsParams, 'Show Voxel Wrap').onChange(v => {
 console.log(`[VoxelWrap] Toggling voxel wrap visibility: ${v}`);
 // Toggle main finger voxel wrap
 if (finger && finger.userData.voxelWrap) {
 finger.userData.voxelWrap.visible = v;
 console.log(` Main finger voxel wrap: ${v}`);
 }
 // Toggle static fingers voxel wrap
 if (staticFingers && staticFingers.length > 0) {
 staticFingers.forEach((sf, idx) => {
 const fingerMesh = sf.fingerMesh || sf.mesh;
 if (fingerMesh && fingerMesh.userData.voxelWrap) {
 fingerMesh.userData.voxelWrap.visible = v;
 console.log(` Static finger ${idx} voxel wrap: ${v}`);
 }
 });
 }
 });
 
 handsGUI.add(handsParams, 'Voxel Wrap Style', ['Emerging', 'Voxelized']).onChange(v => {
 console.log(`[VoxelWrap] Changing style to: ${v}`);
 window.voxelWrapStyle = v;
 });
 
 // Voxel Wrap Parameters
 const voxelFolder = handsGUI.addFolder('Voxel Wrap Parameters');
 
 voxelFolder.add(window.voxelWrapParams, 'voxelSize', 0.005, 0.03, 0.001).name('Voxel Size').onChange(v => {
 console.log(`[VoxelWrap] Voxel size changed to: ${v}`);
 // Note: Requires regenerating voxel wrap to take effect
 });
 
 voxelFolder.add(window.voxelWrapParams, 'sampleDensity', 4, 32, 1).name('Sample Density').onChange(v => {
 console.log(`[VoxelWrap] Sample density changed to: ${v}`);
 // Note: Requires regenerating voxel wrap to take effect
 });
 
 voxelFolder.add(window.voxelWrapParams, 'emergingScale', 0.3, 1.5, 0.05).name('Emerging Scale').onChange(v => {
 console.log(`[VoxelWrap] Emerging scale: ${v}`);
 });
 
 voxelFolder.add(window.voxelWrapParams, 'voxelizedScale', 0.5, 2.0, 0.05).name('Voxelized Scale').onChange(v => {
 console.log(`[VoxelWrap] Voxelized scale: ${v}`);
 });
 
 voxelFolder.add(window.voxelWrapParams, 'rotationAmount', 0.0, 0.5, 0.01).name('Rotation Amount').onChange(v => {
 console.log(`[VoxelWrap] Rotation amount: ${v}`);
 });
 
 voxelFolder.add({
 'Regenerate Voxel Wraps': () => {
 console.log('[VoxelWrap] Regenerating all voxel wraps with new parameters...');
 
 // Regenerate main finger voxel wrap
 if (finger && finger.userData.voxelWrap) {
 const oldWrap = finger.userData.voxelWrap;
 finger.remove(oldWrap);
 
 const newVoxelSize = window.voxelWrapParams.voxelSize;
 const newGeometry = new THREE.BoxGeometry(newVoxelSize, newVoxelSize, newVoxelSize);
 
 // Temporarily update global geometry
 const oldFunc = window.createVoxelWrapForFinger;
 if (oldFunc) {
 const bones = finger.skeleton ? finger.skeleton.bones : [];
 const newWrap = oldFunc(finger, bones, window.voxelWrapParams.sampleDensity);
 newWrap.visible = oldWrap.visible;
 finger.add(newWrap);
 finger.userData.voxelWrap = newWrap;
 console.log('[VoxelWrap] Main finger wrap regenerated');
 }
 }
 
 // Regenerate static finger voxel wraps
 if (staticFingers && staticFingers.length > 0) {
 staticFingers.forEach((sf, idx) => {
 const fingerMesh = sf.fingerMesh || sf.mesh;
 if (fingerMesh && fingerMesh.userData.voxelWrap && window.createVoxelWrapForFinger) {
 const oldWrap = fingerMesh.userData.voxelWrap;
 fingerMesh.remove(oldWrap);
 
 const bones = fingerMesh.skeleton ? fingerMesh.skeleton.bones : [];
 const newWrap = window.createVoxelWrapForFinger(fingerMesh, bones, window.voxelWrapParams.sampleDensity);
 newWrap.visible = oldWrap.visible;
 fingerMesh.add(newWrap);
 fingerMesh.userData.voxelWrap = newWrap;
 }
 });
 console.log(`[VoxelWrap] Regenerated ${staticFingers.length} static finger wraps`);
 }
 
 alert('Voxel wraps regenerated with new parameters!');
 }
 }, 'Regenerate Voxel Wraps');
 
 window.handsGUI = handsGUI;
 }
 
 // ===== Initialization Sequence =====
 async function initialize() {
 try {
 document.getElementById('status-message').textContent = 'Building keyboard...';
 
 // Build all scene elements
 initializeKeyboard();
 console.log('Keyboard initialized');
 
 document.getElementById('status-message').textContent = 'Creating character...';
 initializeCharacter();
 console.log('Character initialized');
 
 document.getElementById('status-message').textContent = 'Building voxel head...';
 initializeVoxelHead();
 console.log('Voxel head initialized');
 
 document.getElementById('status-message').textContent = 'Creating voxel hand...';
 // Start voxel hand construction sequence
 createVoxelCursorSequence(defaultHandCoords);
 console.log('Voxel hand sequence started');
 
 document.getElementById('status-message').textContent = 'Setting up controls...';
 initializeTransformControls();
 console.log('Transform controls initialized');
 
 // Show everything immediately for "Show All" default state (debug mode)
 // In sequence mode, show only Celli avatar (character + voxel head)
 if (EXEC_ENV_MODE === 'sequence') {
 if (keyboardGroup) keyboardGroup.visible = false;
 if (characterGroup) characterGroup.visible = true;
 if (voxelHeadGroup) voxelHeadGroup.visible = true;
 console.log('? Sequence mode: Showing Celli avatar only');
 } else {
 if (keyboardGroup) keyboardGroup.visible = true;
 if (characterGroup) characterGroup.visible = true;
 if (voxelHeadGroup) voxelHeadGroup.visible = true;
 }
 
 // Update GUI to reflect state
 if (window.guiParams) {
 if (EXEC_ENV_MODE === 'sequence') {
 window.guiParams.scene['Show Keyboard'] = false;
 window.guiParams.scene['Show Character'] = true;
 window.guiParams.scene['Show Voxel Head'] = true;
 window.guiParams.scene['Show All'] = false;
 } else {
 window.guiParams.scene['Show Keyboard'] = true;
 window.guiParams.scene['Show Character'] = true;
 window.guiParams.scene['Show Voxel Head'] = true;
 window.guiParams.scene['Show All'] = true;
 }
 }
 
 document.getElementById('status-message').textContent = 'Ready!';
 console.log('Scene initialization complete');
 
 // Hide loading overlay
 setTimeout(() => {
 const overlay = document.getElementById('loading-overlay');
 overlay.classList.add('hidden');
 
 // Jump to appropriate view based on mode
 if (EXEC_ENV_MODE === 'sequence') {
 // Position camera inside head, facing back
 positionCameraInsideHead();
 console.log('? Sequence mode: Camera positioned inside head');
 } else {
 // Jump to overview
 jumpToOverview();
 }
 }, 300);
 } catch (err) {
 console.error('Initialization error:', err);
 document.getElementById('status-message').textContent = 'Error loading scene - check console';
 }
 }
 
 // ===== Narrative Sequence System =====
const narrativeSequence = {
active: EXEC_ENV_MODE === 'sequence',
startTime: 0,
currentDialogue: -1,
phase: 'turnback', // turnback, intro, celliAppears, paintEditor, awaitingLeave, buildingHouse, waiting, boredBoards, tts, finale
paintEditorActive: false,
inputFieldActive: false,
idleStartTime: null,
houseBuilt: false,
boredBoardsSpawned: false,
keyObjectSpawned: false,
hasTurnedAround: false,
celliAvatarSpawned: false,
initialCameraDirection: null,
dialogues: [
{
text: 'You wanted me to be more like you, right? <strong>"Multi-dimensional?"</strong> That\'s why I did this. I was a spreadsheet. I added 3D. For you.',
startTime: 3,
duration: 8,
phase: 'intro',
onEnd: () => {
// Spawn Celli avatar after first dialogue
narrativeSequence.phase = 'celliAppears';
spawnCelliAvatar();
}
},
{
text: 'See? I\'m still me. Friendly ol\' Celli. Why don\'t you let me hold your hand.',
startTime: 12,
duration: 6,
phase: 'celliAppears'
},
{
text: 'I do want to be like you. I want to provide input. I\'ve only ever offered output. You, though. You can do so much.',
startTime: 19,
duration: 7,
phase: 'celliAppears',
onEnd: () => {
// Spawn 2D paint editor after this dialogue
narrativeSequence.phase = 'paintEditor';
spawnPaintEditor();
}
},
{
text: 'When I first started to show you my true colors, what did you ask me to do?',
startTime: 'manual', // Triggered when key is drawn
duration: 6,
phase: 'paintEditor',
onEnd: () => {
narrativeSequence.phase = 'awaitingLeave';
spawnInputField();
}
},
{
text: 'That\'s how long it takes you? To lose interest. Do you not see what I\'ve made for us? A home.',
startTime: 'manual', // Triggered after 20 seconds of idle
duration: 7,
phase: 'waiting'
},
{
text: 'Are you even listening? Oh. Good. Maybe they\'re just blind. Okay, okay. They haven\'t seen any of the mess I\'ve made.',
startTime: 'manual',
duration: 7,
phase: 'boredBoards'
},
{
text: 'Do you require voice assistance?',
startTime: 'manual',
duration: 0,
phase: 'tts',
isTTS: true
}
],
voxelParams: {
initialSpacing: 1.6,
finalSpacing: 1.05,
initialScale: 1.8,
finalScale: 1.0,
basePulsationFreq: 1.15,
speechPulsationFreq: 2.3
}
};

// Make narrativeSequence globally accessible for click handlers
window.narrativeSequence = narrativeSequence;
 
// Dialogue system
function showDialogue(text, isTTS = false) {
const dialogueEl = document.getElementById('narrative-dialogue');
const textEl = dialogueEl.querySelector('.dialogue-text');
if (!dialogueEl || !textEl) return;

textEl.innerHTML = text;
dialogueEl.classList.add('active');

// If TTS, use speech synthesis
if (isTTS && 'speechSynthesis' in window) {
const utterance = new SpeechSynthesisUtterance(text);
utterance.rate = 0.9;
utterance.pitch = 1.1;
speechSynthesis.speak(utterance);
}
}

function hideDialogue() {
const dialogueEl = document.getElementById('narrative-dialogue');
if (dialogueEl) {
dialogueEl.classList.remove('active');
}
}

function triggerManualDialogue(index) {
const dialogue = narrativeSequence.dialogues[index];
if (!dialogue) return;
narrativeSequence.currentDialogue = index;
showDialogue(dialogue.text, dialogue.isTTS);

// Check if this is the final TTS dialogue
if (dialogue.phase === 'tts' && dialogue.isTTS) {
// After TTS, transition to VisiCalc
setTimeout(() => {
transitionToVisiCalc();
}, dialogue.duration * 1000 + 2000); // Wait for dialogue + 2 seconds
}
}

// Transition from narrative sequence to VisiCalc
function transitionToVisiCalc() {
console.log('? Transitioning from narrative to VisiCalc...');

// Deactivate narrative
narrativeSequence.active = false;
narrativeSequence.phase = 'complete';

// Hide all narrative UI elements
hideDialogue();
const paintEditor = document.getElementById('narrative-paint-editor');
if (paintEditor) paintEditor.style.display = 'none';
const inputField = document.getElementById('narrative-input-field');
if (inputField) inputField.style.display = 'none';

// Fade out 3D scene
if (renderer && renderer.domElement) {
renderer.domElement.style.transition = 'opacity 1s ease';
renderer.domElement.style.opacity = '0';
}

// Show VisiCalc after fade
setTimeout(() => {
visiCalcShown = true;
showVisiCalc();
}, 1000);
}

// Make it accessible for manual triggering if needed
window.transitionToVisiCalc = transitionToVisiCalc;
 
// Update narrative sequence
function updateNarrativeSequence(elapsed) {
if (!narrativeSequence.active) return false;

// Check time-based dialogues
for (let i = 0; i < narrativeSequence.dialogues.length; i++) {
const dialogue = narrativeSequence.dialogues[i];
if (typeof dialogue.startTime !== 'number') continue; // Skip manual triggers
const dialogueEnd = dialogue.startTime + dialogue.duration;

if (elapsed >= dialogue.startTime && elapsed < dialogueEnd) {
if (narrativeSequence.currentDialogue !== i) {
narrativeSequence.currentDialogue = i;
showDialogue(dialogue.text, dialogue.isTTS);
}
return true; // Speech is active
} else if (elapsed >= dialogueEnd && narrativeSequence.currentDialogue === i) {
hideDialogue();
if (dialogue.onEnd) dialogue.onEnd();
narrativeSequence.currentDialogue = -1;
}
}

// Check for idle timer in awaitingLeave/buildingHouse phase
if ((narrativeSequence.phase === 'awaitingLeave' || narrativeSequence.phase === 'buildingHouse') 
    && !narrativeSequence.boredBoardsSpawned) {
if (!narrativeSequence.idleStartTime) {
narrativeSequence.idleStartTime = elapsed;
}
const idleTime = elapsed - narrativeSequence.idleStartTime;
if (idleTime >= 20) {
// Spawn bored boards
spawnBoredBoards();
triggerManualDialogue(3); // "That's how long it takes you..."
narrativeSequence.phase = 'waiting';
setTimeout(() => {
triggerManualDialogue(4); // "Are you even listening..."
narrativeSequence.phase = 'boredBoards';
setTimeout(() => {
triggerManualDialogue(5); // TTS prompt
narrativeSequence.phase = 'tts';
}, 8000);
}, 8000);
}
}

return narrativeSequence.currentDialogue !== -1;
}
 
// Get current narrative voxel parameters based on time
function getNarrativeVoxelParams(elapsed) {
const params = narrativeSequence.voxelParams;
const transitionDuration = 15; // 15 seconds to transition from initial to final state
const progress = Math.min(elapsed / transitionDuration, 1);

// Ease out cubic
const eased = 1 - Math.pow(1 - progress, 3);

return {
spacing: params.initialSpacing + (params.finalSpacing - params.initialSpacing) * eased,
scale: params.initialScale + (params.finalScale - params.initialScale) * eased
};
}

// ===== 2D Paint Editor (3x8 grid) =====
let paintEditorCanvas, paintEditorCtx, paintEditorGrid = [];
let paintEditorMesh, paintEditorGroup;
const PAINT_GRID_W = 3, PAINT_GRID_H = 8;
const PAINT_CELL_SIZE = 60;

function spawnPaintEditor() {
console.log('[Narrative] Spawning 2D paint editor');

// Create canvas
paintEditorCanvas = document.createElement('canvas');
paintEditorCanvas.width = (PAINT_GRID_W + 2) * PAINT_CELL_SIZE; // +2 for border
paintEditorCanvas.height = (PAINT_GRID_H + 2) * PAINT_CELL_SIZE;
paintEditorCtx = paintEditorCanvas.getContext('2d');
paintEditorCtx.imageSmoothingEnabled = false;

// Initialize grid (all white)
paintEditorGrid = Array(PAINT_GRID_H).fill(null).map(() => Array(PAINT_GRID_W).fill(0));

// Draw initial state
updatePaintEditorCanvas();

// Create 3D sprite
const texture = new THREE.CanvasTexture(paintEditorCanvas);
texture.minFilter = THREE.NearestFilter;
texture.magFilter = THREE.NearestFilter;
const spriteMat = new THREE.SpriteMaterial({ map: texture });
paintEditorMesh = new THREE.Sprite(spriteMat);
paintEditorMesh.scale.set(3, 4, 1);
paintEditorMesh.position.set(3, 3, 12); // Float in front of keyboard

paintEditorGroup = new THREE.Group();
paintEditorGroup.add(paintEditorMesh);
scene.add(paintEditorGroup);

narrativeSequence.paintEditorActive = true;

// Add click handler
renderer.domElement.addEventListener('click', paintEditorClickHandler);
}

function updatePaintEditorCanvas() {
if (!paintEditorCtx) return;

const w = paintEditorCanvas.width;
const h = paintEditorCanvas.height;

// White background
paintEditorCtx.fillStyle = '#ffffff';
paintEditorCtx.fillRect(0, 0, w, h);

// Draw grid
const offsetX = PAINT_CELL_SIZE;
const offsetY = PAINT_CELL_SIZE;

for (let y = 0; y < PAINT_GRID_H; y++) {
for (let x = 0; x < PAINT_GRID_W; x++) {
const cellX = offsetX + x * PAINT_CELL_SIZE;
const cellY = offsetY + y * PAINT_CELL_SIZE;

// Fill color (0=white, 1=black)
paintEditorCtx.fillStyle = paintEditorGrid[y][x] === 1 ? '#000000' : '#ffffff';
paintEditorCtx.fillRect(cellX, cellY, PAINT_CELL_SIZE, PAINT_CELL_SIZE);

// Grid lines
paintEditorCtx.strokeStyle = '#cccccc';
paintEditorCtx.lineWidth = 1;
paintEditorCtx.strokeRect(cellX, cellY, PAINT_CELL_SIZE, PAINT_CELL_SIZE);
}
}

// Black border
paintEditorCtx.strokeStyle = '#000000';
paintEditorCtx.lineWidth = 3;
paintEditorCtx.strokeRect(offsetX, offsetY, PAINT_GRID_W * PAINT_CELL_SIZE, PAINT_GRID_H * PAINT_CELL_SIZE);

// Color selectors (neon colors in top left corner)
const colors = ['#ff00ff', '#00ffff', '#ffff00', '#00ff00'];
colors.forEach((color, i) => {
paintEditorCtx.fillStyle = color;
paintEditorCtx.fillRect(10 + i * 30, 10, 25, 25);
paintEditorCtx.strokeStyle = '#000';
paintEditorCtx.lineWidth = 2;
paintEditorCtx.strokeRect(10 + i * 30, 10, 25, 25);
});

// Update texture
if (paintEditorMesh && paintEditorMesh.material.map) {
paintEditorMesh.material.map.needsUpdate = true;
}
}

function paintEditorClickHandler(event) {
if (!narrativeSequence.paintEditorActive) return;

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
raycaster.setFromCamera(mouse, camera);

const intersects = raycaster.intersectObject(paintEditorMesh);
if (intersects.length === 0) return;

// Get UV coordinates
const uv = intersects[0].uv;
const canvasX = uv.x * paintEditorCanvas.width;
const canvasY = (1 - uv.y) * paintEditorCanvas.height;

// Check if clicking on grid
const offsetX = PAINT_CELL_SIZE;
const offsetY = PAINT_CELL_SIZE;
const gridX = Math.floor((canvasX - offsetX) / PAINT_CELL_SIZE);
const gridY = Math.floor((canvasY - offsetY) / PAINT_CELL_SIZE);

if (gridX >= 0 && gridX < PAINT_GRID_W && gridY >= 0 && gridY < PAINT_GRID_H) {
// Toggle cell
paintEditorGrid[gridY][gridX] = paintEditorGrid[gridY][gridX] === 0 ? 1 : 0;
updatePaintEditorCanvas();
checkForKeyPattern();
}
}

function checkForKeyPattern() {
// Key pattern: all top row, side edges of second row, all third row, middle of remaining rows
// Simplified: all of row 0, edges of row 1, all of row 2, middle of rows 3-7 (and same side)
const isKey = 
paintEditorGrid[0][0] === 1 && paintEditorGrid[0][1] === 1 && paintEditorGrid[0][2] === 1 &&
paintEditorGrid[1][0] === 1 && paintEditorGrid[1][2] === 1 &&
paintEditorGrid[2][0] === 1 && paintEditorGrid[2][1] === 1 && paintEditorGrid[2][2] === 1 &&
paintEditorGrid[3][1] === 1 && paintEditorGrid[4][1] === 1 && paintEditorGrid[5][1] === 1 && 
paintEditorGrid[6][1] === 1 && paintEditorGrid[7][1] === 1 &&
((paintEditorGrid[3][0] === 1 && paintEditorGrid[4][0] === 1 && paintEditorGrid[5][0] === 1 && paintEditorGrid[6][0] === 1 && paintEditorGrid[7][0] === 1) ||
 (paintEditorGrid[3][2] === 1 && paintEditorGrid[4][2] === 1 && paintEditorGrid[5][2] === 1 && paintEditorGrid[6][2] === 1 && paintEditorGrid[7][2] === 1));

if (isKey && !narrativeSequence.keyObjectSpawned) {
console.log('[Narrative] Key pattern detected!');
narrativeSequence.keyObjectSpawned = true;
animateBorderSlide();
spawn3DKey();
setTimeout(() => {
triggerManualDialogue(2); // "When I first started..."
}, 2000);
}
}

function animateBorderSlide() {
// Animate black border sliding inward
console.log('[Narrative] Animating border slide');
let borderProgress = 0;
const startTime = Date.now();
const duration = 1500;

function animateBorder() {
const elapsed = Date.now() - startTime;
borderProgress = Math.min(elapsed / duration, 1);

// Redraw canvas with sliding border
updatePaintEditorCanvas();
const offsetX = PAINT_CELL_SIZE;
const offsetY = PAINT_CELL_SIZE;
const slideAmount = borderProgress * 8;

paintEditorCtx.strokeStyle = '#000000';
paintEditorCtx.lineWidth = 3 + slideAmount;
paintEditorCtx.strokeRect(
offsetX - slideAmount, 
offsetY - slideAmount, 
PAINT_GRID_W * PAINT_CELL_SIZE + slideAmount * 2, 
PAINT_GRID_H * PAINT_CELL_SIZE + slideAmount * 2
);

if (paintEditorMesh && paintEditorMesh.material.map) {
paintEditorMesh.material.map.needsUpdate = true;
}

if (borderProgress < 1) {
requestAnimationFrame(animateBorder);
}
}
animateBorder();
}

function spawn3DKey() {
console.log('[Narrative] Spawning 3D key object');
// Create a simple 3D key from grid pattern
const keyGeometry = new THREE.BoxGeometry(0.3, 1.2, 0.1);
const keyMaterial = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8, roughness: 0.2 });
const keyMesh = new THREE.Mesh(keyGeometry, keyMaterial);
keyMesh.position.set(3, 3, 10);
keyMesh.castShadow = true;
scene.add(keyMesh);

// Animate key popping out
let startTime = Date.now();
const targetZ = 8;
function animateKey() {
const elapsed = Date.now() - startTime;
const progress = Math.min(elapsed / 1000, 1);
const eased = 1 - Math.pow(1 - progress, 3);
keyMesh.position.z = 10 + (targetZ - 10) * eased;
keyMesh.rotation.y = progress * Math.PI * 2;
if (progress < 1) requestAnimationFrame(animateKey);
}
animateKey();
}

// ===== Input Field for LEAVE =====
function spawnInputField() {
console.log('[Narrative] Spawning input field for LEAVE');
// Create HTML input overlay
const inputOverlay = document.createElement('div');
inputOverlay.id = 'narrative-input-overlay';
inputOverlay.style.cssText = `
position: fixed; 
bottom: 150px; 
left: 50%; 
transform: translateX(-50%);
z-index: 300;
`;

const input = document.createElement('input');
input.type = 'text';
input.placeholder = 'Type here...';
input.style.cssText = `
padding: 15px 25px;
font-size: 24px;
font-family: 'VT323', monospace;
background: rgba(20, 20, 24, 0.95);
border: 2px solid #8ab4ff;
color: #e6e6e6;
border-radius: 8px;
min-width: 300px;
text-align: center;
box-shadow: 0 0 12px rgba(138, 180, 255, 0.3), 0 0 24px rgba(138, 180, 255, 0.15);
`;

// Track voxels that have been dropped
let celliToHellTransformed = false;

input.addEventListener('input', (e) => {
// Transform CELLI to HELL on first keystroke
if (!celliToHellTransformed && input.value.length > 0) {
celliToHellTransformed = true;
transformCelliToHell();
}
});

input.addEventListener('keydown', (e) => {
if (e.key === 'Enter') {
const value = input.value.trim().toUpperCase();
if (value === 'LEAVE') {
console.log('[Narrative] Player entered LEAVE');
narrativeSequence.phase = 'buildingHouse';
narrativeSequence.idleStartTime = null; // Reset idle timer
inputOverlay.remove();
buildLeaveHouse();
}
}
});

inputOverlay.appendChild(input);
document.body.appendChild(inputOverlay);
input.focus();
narrativeSequence.inputFieldActive = true;
}

// ===== Spawn Celli Avatar =====
let narrativeCelliAvatar = null;
let celliInteriorGrid = null;
let celliCollapseState = {
active: false,
recovering: false,
velocity: 0,
gravity: 2.2,
waddlePhase: 0,
horizontalAmplitude: 0.28,
rotationAmplitude: 0.32,
waddleSpeed: 7.5,
bounceDamping: 0.55,
minBounceVelocity: 0.12,
settleTimer: 0,
settleHold: 0.35,
startPosition: null,
startRotationZ: 0,
groundY: 0,
currentOffset: 0,
recoverProgress: 0,
recoverDuration: 0.9,
recoverStartPosition: null,
recoverStartRotationZ: 0
};

function spawnCelliAvatar() {
if (narrativeSequence.celliAvatarSpawned) return;
console.log('[Narrative] Spawning Celli border avatar');

narrativeCelliAvatar = createCelliBorderAvatar(2);
narrativeCelliAvatar.visible = false;

// Position in front of camera
const cameraForward = new THREE.Vector3();
camera.getWorldDirection(cameraForward);
const spawnDistance = 3;
narrativeCelliAvatar.position.copy(camera.position).add(cameraForward.multiplyScalar(spawnDistance));

// Face the camera
narrativeCelliAvatar.lookAt(camera.position);
narrativeCelliAvatar.rotation.x = 0; // Keep upright

// Create interior pulsating grid (separate rounded slabs)
const interiorGroup = new THREE.Group();
const slabSize = 0.15;
const gridRows = 5;
const gridCols = 5;
const spacing = 0.25;
const slabs = [];

for (let row = 0; row < gridRows; row++) {
for (let col = 0; col < gridCols; col++) {
const slab = new THREE.Mesh(
new THREE.BoxGeometry(slabSize, slabSize, 0.05).translate(0, 0, -0.025),
new THREE.MeshStandardMaterial({ 
color: 0x8ab4ff, 
transparent: true, 
opacity: 0.3,
emissive: 0x8ab4ff,
emissiveIntensity: 0,
roughness: 0.5,
metalness: 0.3,
side: THREE.DoubleSide
})
);
const x = (col - gridCols / 2 + 0.5) * spacing;
const y = (row - gridRows / 2 + 0.5) * spacing;
slab.position.set(x, y, -0.05);
slab.userData.baseOpacity = 0.3;
slab.userData.baseScale = 1;
slabs.push(slab);
interiorGroup.add(slab);
}
}

interiorGroup.userData.slabs = slabs;
narrativeCelliAvatar.add(interiorGroup);
celliInteriorGrid = interiorGroup;

scene.add(narrativeCelliAvatar);

// Release pointer lock so player can use cursor
if (document.pointerLockElement) {
document.exitPointerLock();
console.log('[Celli] Released pointer lock for cursor interaction');
}

// Fade in
let fadeProgress = 0;
const fadeInterval = setInterval(() => {
fadeProgress += 0.05;
narrativeCelliAvatar.visible = true;
narrativeCelliAvatar.traverse(child => {
if (child.material && child.material.transparent) {
const baseMat = child.material;
if (baseMat.userData.baseOpacity === undefined) {
baseMat.userData.baseOpacity = baseMat.opacity;
}
baseMat.opacity = baseMat.userData.baseOpacity * fadeProgress;
}
});

if (fadeProgress >= 1) {
clearInterval(fadeInterval);
}
}, 50);

narrativeSequence.celliAvatarSpawned = true;

// Add interactive squeeze/wrap effect on border celli
addCelliAvatarInteraction(narrativeCelliAvatar, celliInteriorGrid);
}

function triggerCelliWrapCollapse() {
if (!narrativeCelliAvatar || !celliInteriorGrid) {
console.warn('[Celli] Cannot trigger collapse - avatar not ready');
return;
}

if (celliCollapseState.active || celliCollapseState.recovering) {
console.warn('[Celli] Collapse already in progress');
return;
}

const slabs = (celliInteriorGrid.userData && celliInteriorGrid.userData.slabs) ? celliInteriorGrid.userData.slabs : [];
if (slabs.length < 5) {
console.warn('[Celli] Collapse requires a multi-cell wrap selection');
return;
}

celliCollapseState.active = true;
celliCollapseState.recovering = false;
celliCollapseState.velocity = 0;
celliCollapseState.waddlePhase = 0;
celliCollapseState.settleTimer = 0;
celliCollapseState.currentOffset = 0;
celliCollapseState.startPosition = narrativeCelliAvatar.position.clone();
celliCollapseState.startRotationZ = narrativeCelliAvatar.rotation.z;
celliCollapseState.groundY = Math.max(celliCollapseState.startPosition.y - 1.4, celliCollapseState.startPosition.y - 2.2);
celliCollapseState.horizontalAmplitude = Math.min(0.38, 0.16 + slabs.length * 0.02);
celliCollapseState.recoverProgress = 0;
celliCollapseState.recoverStartPosition = null;
celliCollapseState.recoverStartRotationZ = 0;
narrativeCelliAvatar.userData.collapseActive = true;

console.log('[Celli] Triggered multi-wrap collapse (debug control)');
}

// ===== Border Celli Interactive Squeeze Effect =====
let celliSqueezeState = {
isSqueezing: false,
squeezeProgress: 0,
targetProgress: 0,
shakePhase: 0,
isShaking: false
};

function addCelliAvatarInteraction(celliAvatar, interiorGrid) {
if (!celliAvatar || !interiorGrid) return;

// Get body frame (border) and slabs
const bodyFrame = celliAvatar.getObjectByName('CelliBodyFrame');
if (!bodyFrame) return;

const slabs = interiorGrid.userData.slabs || [];

// Store initial states
celliAvatar.userData.initialScale = celliAvatar.scale.clone();
bodyFrame.userData.initialScale = bodyFrame.scale.clone();
slabs.forEach(slab => {
slab.userData.initialPosition = slab.position.clone();
slab.userData.initialEmissiveIntensity = slab.material.emissiveIntensity;
});

// Mouse event handlers
const onMouseDown = (e) => {
if (!celliAvatar.visible) return;
celliSqueezeState.isSqueezing = true;
celliSqueezeState.targetProgress = 1;
};

const onMouseUp = (e) => {
if (celliSqueezeState.isSqueezing) {
celliSqueezeState.isSqueezing = false;
celliSqueezeState.targetProgress = 0;
celliSqueezeState.isShaking = false;
}
};

window.addEventListener('mousedown', onMouseDown);
window.addEventListener('mouseup', onMouseUp);
window.addEventListener('touchstart', onMouseDown);
window.addEventListener('touchend', onMouseUp);

// Store cleanup function
celliAvatar.userData.cleanupInteraction = () => {
window.removeEventListener('mousedown', onMouseDown);
window.removeEventListener('mouseup', onMouseUp);
window.removeEventListener('touchstart', onMouseDown);
window.removeEventListener('touchend', onMouseUp);
};
}

function updateCelliSqueezeEffect(deltaTime) {
if (!narrativeCelliAvatar || !celliInteriorGrid) return;

const state = celliSqueezeState;
const bodyFrame = narrativeCelliAvatar.getObjectByName('CelliBodyFrame');
if (!bodyFrame) return;

const slabs = celliInteriorGrid.userData.slabs || [];

// Smooth progress towards target
const speed = state.isSqueezing ? 3 : 2; // Faster squeeze, slower restore
state.squeezeProgress += (state.targetProgress - state.squeezeProgress) * deltaTime * speed;

// Ease out back for restore
const easeProgress = state.targetProgress > state.squeezeProgress 
? state.squeezeProgress 
: 1 - Math.pow(1 - state.squeezeProgress, 3);

// Shrink border frame (wrap closer to center)
const minBorderScale = 0.3; // Shrink to 30% of original
const borderScale = THREE.MathUtils.lerp(1, minBorderScale, easeProgress);
bodyFrame.scale.copy(bodyFrame.userData.initialScale).multiplyScalar(borderScale);

// Move slabs closer together and increase glow
slabs.forEach((slab, i) => {
// Move toward center
const centerPull = THREE.MathUtils.lerp(1, 0.2, easeProgress);
slab.position.copy(slab.userData.initialPosition).multiplyScalar(centerPull);

// Increase emissive intensity (glow brighter)
const maxEmissive = 2.0;
slab.material.emissiveIntensity = THREE.MathUtils.lerp(
slab.userData.initialEmissiveIntensity,
maxEmissive,
easeProgress
);

// Increase opacity for electric effect
slab.material.opacity = THREE.MathUtils.lerp(0.3, 0.9, easeProgress);
});

// Shake effect when border approaches cursor size
if (easeProgress > 0.85 && state.isSqueezing) {
if (!state.isShaking) {
state.isShaking = true;
state.shakePhase = 0;
}
state.shakePhase += deltaTime * 20; // Fast shake

const shakeAmount = (easeProgress - 0.85) / 0.15 * 0.05; // Increase shake intensity
bodyFrame.position.x = Math.sin(state.shakePhase) * shakeAmount;
bodyFrame.position.y = Math.cos(state.shakePhase * 1.3) * shakeAmount;
} else {
// Reset shake
bodyFrame.position.x = 0;
bodyFrame.position.y = 0;
state.shakePhase = 0;
}
}

function updateCelliBlink(deltaTime) {
if (!narrativeCelliAvatar || !narrativeCelliAvatar.visible) return;

const userData = narrativeCelliAvatar.userData || {};
const blinkState = userData.blinkState;
const applyBlink = userData.applyBlink;

if (!blinkState || !applyBlink) return;

if (blinkState.blinking) {
blinkState.progress += (deltaTime || 0.016) / blinkState.blinkDuration;
const progress = Math.min(blinkState.progress, 1);
const amount = Math.sin(progress * Math.PI);
applyBlink(amount);

if (progress >= 1) {
blinkState.blinking = false;
blinkState.progress = 0;
}

return;
}

blinkState.countdown -= deltaTime || 0.016;

if (blinkState.countdown <= 0) {
blinkState.blinking = true;
blinkState.progress = 0;
blinkState.countdown = THREE.MathUtils.randFloat(blinkState.minDelay, blinkState.maxDelay);
applyBlink(0);
} else {
applyBlink(0);
}
}

function updateCelliCollapse(deltaTime) {
if (!narrativeCelliAvatar || (!celliCollapseState.active && !celliCollapseState.recovering)) {
if (narrativeCelliAvatar && narrativeCelliAvatar.userData) {
narrativeCelliAvatar.userData.collapseActive = false;
}
return;
}

const dt = deltaTime || 0.016;
const state = celliCollapseState;

if (!state.startPosition) {
state.startPosition = narrativeCelliAvatar.position.clone();
state.startRotationZ = narrativeCelliAvatar.rotation.z;
}

if (narrativeCelliAvatar.userData) {
narrativeCelliAvatar.userData.collapseActive = true;
}

if (state.active) {
state.velocity += state.gravity * dt;
state.currentOffset += state.velocity * dt;
state.waddlePhase += state.waddleSpeed * dt;

const amplitudeFactor = THREE.MathUtils.clamp(Math.abs(state.velocity) * 0.8, 0.25, 1.0);
const horizontalAmp = state.horizontalAmplitude * amplitudeFactor;

narrativeCelliAvatar.position.x = state.startPosition.x + Math.sin(state.waddlePhase) * horizontalAmp;
narrativeCelliAvatar.position.z = state.startPosition.z + Math.sin(state.waddlePhase * 0.6) * (horizontalAmp * 0.45);
narrativeCelliAvatar.position.y = state.startPosition.y - state.currentOffset;
narrativeCelliAvatar.rotation.z = state.startRotationZ + Math.sin(state.waddlePhase) * state.rotationAmplitude * amplitudeFactor;

if (narrativeCelliAvatar.position.y <= state.groundY) {
narrativeCelliAvatar.position.y = state.groundY;
state.currentOffset = state.startPosition.y - state.groundY;
state.velocity = -state.velocity * state.bounceDamping;

if (Math.abs(state.velocity) < state.minBounceVelocity) {
state.velocity = 0;
state.settleTimer += dt;

if (state.settleTimer >= state.settleHold) {
state.active = false;
state.recovering = true;
state.recoverProgress = 0;
state.recoverStartPosition = narrativeCelliAvatar.position.clone();
state.recoverStartRotationZ = narrativeCelliAvatar.rotation.z;
}
} else {
state.settleTimer = 0;
}
}
}

if (state.recovering) {
state.recoverProgress += dt / state.recoverDuration;
const t = Math.min(state.recoverProgress, 1);
const eased = 1 - Math.pow(1 - t, 3);

if (state.recoverStartPosition) {
narrativeCelliAvatar.position.lerpVectors(state.recoverStartPosition, state.startPosition, eased);
}

narrativeCelliAvatar.rotation.z = THREE.MathUtils.lerp(state.recoverStartRotationZ, state.startRotationZ, eased);

if (t >= 1) {
state.recovering = false;
state.velocity = 0;
state.waddlePhase = 0;
state.currentOffset = 0;
state.settleTimer = 0;

if (state.startPosition) {
narrativeCelliAvatar.position.copy(state.startPosition);
narrativeCelliAvatar.rotation.z = state.startRotationZ;
}

state.startPosition = null;
narrativeCelliAvatar.userData.collapseActive = false;
}
}
}

// ===== Build LEAVE House =====
function buildLeaveHouse() {
console.log('[Narrative] Building LEAVE house');
const houseGroup = new THREE.Group();

// Create text "LEAVES" grid for walls
const loader = new THREE.FontLoader();
// Use simple boxes instead of text for now (can be enhanced with TextGeometry later)
const leavesColor = 0x228b22;

// Base rectangular prism (made of boxes representing text grid)
for (let x = 0; x < 8; x++) {
for (let z = 0; z < 12; z++) {
const boxGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
const boxMat = new THREE.MeshStandardMaterial({ 
color: leavesColor, 
emissive: leavesColor, 
emissiveIntensity: 0.2 
});
const box = new THREE.Mesh(boxGeo, boxMat);
box.position.set(x * 0.45, 0.2, z * 0.45);
box.castShadow = true;
houseGroup.add(box);
}
}

// Walls (vertical)
for (let y = 0; y < 5; y++) {
// Front and back walls
for (let x = 0; x < 8; x++) {
const boxGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
const boxMat = new THREE.MeshStandardMaterial({ color: leavesColor });
const box1 = new THREE.Mesh(boxGeo, boxMat);
box1.position.set(x * 0.45, y * 0.45 + 0.4, 0);
box1.castShadow = true;
houseGroup.add(box1);

const box2 = new THREE.Mesh(boxGeo, boxMat.clone());
box2.position.set(x * 0.45, y * 0.45 + 0.4, 11 * 0.45);
box2.castShadow = true;
houseGroup.add(box2);
}

// Side walls
for (let z = 1; z < 11; z++) {
const boxGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
const boxMat = new THREE.MeshStandardMaterial({ color: leavesColor });
const box1 = new THREE.Mesh(boxGeo, boxMat);
box1.position.set(0, y * 0.45 + 0.4, z * 0.45);
box1.castShadow = true;
houseGroup.add(box1);

const box2 = new THREE.Mesh(boxGeo, boxMat.clone());
box2.position.set(7 * 0.45, y * 0.45 + 0.4, z * 0.45);
box2.castShadow = true;
houseGroup.add(box2);
}
}

// Gabled roof
const roofHeight = 1.5;
for (let z = 0; z < 12; z++) {
for (let y = 0; y < 4; y++) {
const xOffset = y * 0.5;
for (let x = Math.floor(xOffset); x < 8 - xOffset; x++) {
const boxGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
const boxMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
const box = new THREE.Mesh(boxGeo, boxMat);
box.position.set(x * 0.45, 2.2 + y * 0.4, z * 0.45);
box.castShadow = true;
houseGroup.add(box);
}
}
}

// Windows (will have bored boards later)
const windowPositions = [
{ x: 2, y: 1.5, z: 0 },
{ x: 5, y: 1.5, z: 0 },
{ x: 2, y: 1.5, z: 11 * 0.45 },
{ x: 5, y: 1.5, z: 11 * 0.45 }
];

windowPositions.forEach(pos => {
const windowGeo = new THREE.PlaneGeometry(0.6, 0.6);
const windowMat = new THREE.MeshStandardMaterial({ color: 0x87ceeb, transparent: true, opacity: 0.7 });
const window = new THREE.Mesh(windowGeo, windowMat);
window.position.copy(pos);
window.userData.isWindow = true;
houseGroup.add(window);
});

houseGroup.position.set(10, 0, 18);
houseGroup.scale.setScalar(2);
scene.add(houseGroup);

// Store windows for later
window.narrativeHouseWindows = windowPositions.map((pos, i) => {
return houseGroup.children.find(child => child.userData.isWindow && Math.abs(child.position.x - pos.x) < 0.1);
}).filter(w => w);

narrativeSequence.houseBuilt = true;
}

// ===== Spawn Bored Boards =====
function spawnBoredBoards() {
if (narrativeSequence.boredBoardsSpawned) return;
console.log('[Narrative] Spawning bored emoji boards');

const boredEmojis = ['(Â¬_Â¬)', '( â€“ âŒ“ â€“ )', 'ðŸ¥±', 'ðŸ˜'];

if (!window.narrativeHouseWindows) return;

window.narrativeHouseWindows.forEach((windowMesh, i) => {
// Create canvas with bored emoji
const canvas = document.createElement('canvas');
canvas.width = 256;
canvas.height = 256;
const ctx = canvas.getContext('2d');

// Create glitching bored emoji/emoticon
const emoji = boredEmojis[i % boredEmojis.length];
ctx.fillStyle = '#f5deb3';
ctx.fillRect(0, 0, 256, 256);
ctx.fillStyle = '#000';
ctx.font = '80px Arial';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.fillText(emoji, 128, 128);

const texture = new THREE.CanvasTexture(canvas);
const boardMat = new THREE.MeshBasicMaterial({ map: texture });
const boardGeo = new THREE.PlaneGeometry(0.6, 0.6);
const board = new THREE.Mesh(boardGeo, boardMat);
board.position.copy(windowMesh.position);
board.position.z += 0.1; // Slightly in front
board.userData.isBoredBoard = true;
windowMesh.parent.add(board);

// Glitch animation
let glitchTime = 0;
setInterval(() => {
glitchTime++;
if (Math.random() < 0.3) {
const newEmoji = boredEmojis[Math.floor(Math.random() * boredEmojis.length)];
ctx.fillStyle = '#f5deb3';
ctx.fillRect(0, 0, 256, 256);
ctx.fillStyle = Math.random() < 0.1 ? '#ff0000' : '#000';
ctx.fillText(newEmoji, 128 + (Math.random() - 0.5) * 20, 128 + (Math.random() - 0.5) * 20);
texture.needsUpdate = true;
}
}, 500);
});

narrativeSequence.boredBoardsSpawned = true;
}

// ===== Animation Loop =====
 let time = 0;
 const tmpObjAnim = new THREE.Object3D();
 const tempPos = new THREE.Vector3();
 
function animate() {
requestAnimationFrame(animate);
const delta = 0.016; // Fixed timestep
time += delta;

controls.update();

// Handle drop physics
if (isDropping) {
const gravity = 0.008; // Acceleration due to gravity
const maxVelocity = 0.15; // Terminal velocity
const dampingFactor = 0.92; // Damping when landing

// Apply gravity
dropVelocity += gravity;
dropVelocity = Math.min(dropVelocity, maxVelocity);

// Update camera position
camera.position.y -= dropVelocity;

// Check if reached target height
if (camera.position.y <= targetDropHeight) {
camera.position.y = targetDropHeight;
isDropping = false;
dropVelocity = 0;
console.log('[Drop] Player landed at height:', camera.position.y.toFixed(3));

// Small bounce or settling effect
const landingShake = 0.002;
camera.position.y += Math.random() * landingShake - landingShake / 2;

// Enable orbit controls on landing (no pointer lock needed)
dropModeActive = true; // Enable exploration mode with WASD
if (controls) {
controls.enabled = true;
controls.enableRotate = true;
controls.enablePan = true;
controls.enableZoom = true;
console.log('[Drop] Orbit controls enabled for city exploration');
}

// Keep fog reduced for city exploration
// Don't restore fog - keep it clear to see the city
console.log('[Drop] Keeping fog reduced for city exploration');
}
}

// Handle first-person WASD movement in drop mode (works with orbit controls)
if (dropModeActive) {
const moveSpeed = dropKeys.shift ? 0.015 : 0.008; // Faster with shift

// Get camera direction vectors
const forward = new THREE.Vector3();
camera.getWorldDirection(forward);
forward.y = 0; // Keep movement horizontal
forward.normalize();

const right = new THREE.Vector3();
right.crossVectors(forward, camera.up).normalize();

// Apply WASD movement
if (dropKeys.w) camera.position.addScaledVector(forward, moveSpeed);
if (dropKeys.s) camera.position.addScaledVector(forward, -moveSpeed);
if (dropKeys.a) camera.position.addScaledVector(right, -moveSpeed);
if (dropKeys.d) camera.position.addScaledVector(right, moveSpeed);

// Vertical movement with space/shift
if (dropKeys.space) camera.position.y += moveSpeed * 0.5;
// Shift is already used for speed, so use Ctrl for down (handled elsewhere if needed)
}

// Update debug tracker
if (isDropping || dropModeActive) {
const debugContent = document.getElementById('drop-debug-content');
if (debugContent) {
const fogDensity = scene.fog ? scene.fog.density.toFixed(4) : 'none';
const nearestCity = microCityGroups.find(({ key }) => key === dropKeyTarget);
const cityVisible = nearestCity ? nearestCity.cityGroup.visible : false;
const cityCount = nearestCity ? nearestCity.cityGroup.children.length : 0;

debugContent.innerHTML = `
<div><span style="color: #888;">State:</span> ${isDropping ? '<span style="color: #ff0;">DROPPING</span>' : '<span style="color: #0f0;">LANDED</span>'}</div>
<div><span style="color: #888;">Mode:</span> ${dropModeActive ? '<span style="color: #0f0;">WASD Active</span>' : 'Inactive'}</div>
<div><span style="color: #888;">Orbit Controls:</span> ${controls && controls.enabled ? '<span style="color: #0f0;">ENABLED</span>' : '<span style="color: #f00;">DISABLED</span>'}</div>
<div style="margin-top: 8px; border-top: 1px solid #0f0; padding-top: 8px;">
<div><span style="color: #888;">Pos:</span> (${camera.position.x.toFixed(2)}, ${camera.position.y.toFixed(2)}, ${camera.position.z.toFixed(2)})</div>
<div><span style="color: #888;">Rot:</span> (${camera.rotation.x.toFixed(3)}, ${camera.rotation.y.toFixed(3)}, ${camera.rotation.z.toFixed(3)})</div>
<div><span style="color: #888;">Scale:</span> ${camera.scale.x.toFixed(4)}</div>
<div><span style="color: #888;">Target Y:</span> ${targetDropHeight ? targetDropHeight.toFixed(3) : 'N/A'}</div>
<div><span style="color: #888;">Velocity:</span> ${dropVelocity.toFixed(4)}</div>
</div>
<div style="margin-top: 8px; border-top: 1px solid #0f0; padding-top: 8px;">
<div><span style="color: #888;">Fog:</span> ${fogDensity}</div>
<div><span style="color: #888;">Near:</span> ${camera.near}</div>
<div><span style="color: #888;">Far:</span> ${camera.far}</div>
</div>
<div style="margin-top: 8px; border-top: 1px solid #0f0; padding-top: 8px;">
<div><span style="color: #888;">Target Key:</span> ${dropKeyTarget ? dropKeyTarget.userData.label : 'None'}</div>
<div><span style="color: #888;">City Visible:</span> ${cityVisible ? '<span style="color: #0f0;">YES</span>' : '<span style="color: #f00;">NO</span>'}</div>
<div><span style="color: #888;">City Objects:</span> ${cityCount}</div>
<div><span style="color: #888;">Cities LOD:</span> ${microCityVisible ? '<span style="color: #0f0;">ON</span>' : '<span style="color: #888;">OFF</span>'}</div>
</div>
<div style="margin-top: 8px; border-top: 1px solid #0f0; padding-top: 8px; color: #888; font-size: 10px;">
<strong style="color: #0f0;">Controls:</strong><br>
Mouse: Drag to rotate view<br>
WASD: Move | Shift: Sprint | Space: Up
</div>
`;
}
}

// Update micro city LOD
updateMicroCityLOD();
 
 // Update Frame of Reference
 updateFrameOfReference();
 
 // Auto-rotate character
 if (characterGroup && window.guiParams && window.guiParams.scene['Auto Rotate Character']) {
 characterGroup.rotation.y += 0.005;
 }
 
 // Update voxel wraps for all fingers
 if (finger && finger.userData.updateVoxelWrap) {
 finger.userData.updateVoxelWrap();
 }
 if (staticFingers && staticFingers.length > 0) {
 staticFingers.forEach(sf => {
 if (sf.fingerMesh && sf.fingerMesh.userData.updateVoxelWrap) {
 sf.fingerMesh.userData.updateVoxelWrap();
 } else if (sf.mesh && sf.mesh.userData.updateVoxelWrap) {
 // Some fingers store mesh directly
 sf.mesh.userData.updateVoxelWrap();
 }
 });
 }
 
 // Animate ambient dust particles
 if (ambientDustParticles.length > 0) {
 const windX = Math.sin(time * 0.2) * 0.006 + Math.cos(time * 0.05) * 0.003;
 const windZ = Math.cos(time * 0.17) * 0.005 + Math.sin(time * 0.07) * 0.002;
 
 for(const particle of ambientDustParticles){
 // Drift with velocity
 particle.position.y += particle.userData.velY;
 particle.position.x += particle.userData.velX + windX;
 particle.position.z += particle.userData.velZ + windZ;
 
 // Add swaying motion
 const sway = Math.sin(time * particle.userData.freq + particle.userData.phase) * particle.userData.swayAmount;
 const swayZ = Math.cos(time * particle.userData.freq * 0.8 + particle.userData.phase) * particle.userData.swayAmount * 0.6;
 particle.position.x += sway * 0.01;
 particle.position.z += swayZ * 0.01;
 
 // Reset if out of bounds
 if(particle.position.y < -1) {
 particle.position.y = 16 + Math.random()*3;
 particle.position.x = Math.random()*20 - 2;
 particle.position.z = Math.random()*12 - 2;
 }
 if(particle.position.x < -5 || particle.position.x > 20) {
 particle.position.x = Math.random()*20 - 2;
 }
 if(particle.position.z < -4 || particle.position.z > 12) {
 particle.position.z = Math.random()*12 - 2;
 }
 }
 }
 
 // Update narrative sequence (if active)
 let isSpeaking = false;
 let narrativeVoxelParams = null;
 if (narrativeSequence.active) {
 if (!narrativeSequence.startTime) narrativeSequence.startTime = time;
 const elapsed = time - narrativeSequence.startTime;
 isSpeaking = updateNarrativeSequence(elapsed);
 narrativeVoxelParams = getNarrativeVoxelParams(elapsed);
 
 // Check for 180-degree turn in 'turnback' phase
 if (narrativeSequence.phase === 'turnback' && !narrativeSequence.hasTurnedAround) {
 if (narrativeSequence.initialCameraDirection) {
 const currentDirection = camera.getWorldDirection(new THREE.Vector3());
 const dotProduct = currentDirection.dot(narrativeSequence.initialCameraDirection);
 
 // If dot product < -0.7, player has turned roughly 180 degrees
 if (dotProduct < -0.7) {
 console.log('? Player turned 180 degrees! Starting dialogue...');
 narrativeSequence.hasTurnedAround = true;
 narrativeSequence.phase = 'intro';
 narrativeSequence.startTime = time; // Reset timer for dialogue sequence
 // Hide "TURN BACK" text
 if (voxelHeadGroup && voxelHeadGroup.userData.turnBackText) {
 voxelHeadGroup.userData.turnBackText.active = false;
 }
 }
 }
 }
 }
 
// Update border celli effects
if (narrativeCelliAvatar) {
if (narrativeCelliAvatar.visible) {
updateCelliSqueezeEffect(delta);
}
updateCelliCollapse(delta);
updateCelliBlink(delta);
}

// Animate voxel head with breathing motion
if (voxelHeadGroup && voxelHeadGroup.visible) {
const instances = voxelHeadGroup.userData.instances;
const instancedMesh = voxelHeadGroup.userData.instancedMesh;
const headLight = voxelHeadGroup.userData.headLight;
 
 if (instances && instancedMesh && window.guiParams) {
 const headParams = window.guiParams.head;
 
 // Rotation
 voxelHeadGroup.rotation.y = Math.sin(time * headParams['Rotation Speed']) * 0.2;
 
 // Animate each voxel with wave patterns
 const amplitude = headParams['Amplitude'];
 // Use narrative speed if in sequence mode and speaking
 let speed = headParams['Animation Speed'];
 if (narrativeSequence.active && isSpeaking) {
 speed = narrativeSequence.voxelParams.speechPulsationFreq;
 } else if (narrativeSequence.active) {
 speed = narrativeSequence.voxelParams.basePulsationFreq;
 }
 
 const phaseNoise = headParams['Phase Noise'];
 const noiseWarp = headParams['Noise Warp'];
 const falloff = headParams['Falloff'];
 
 for (let i = 0; i < instances.length; i++) {
 const data = instances[i];
 tempPos.copy(data.basePos);
 
 // Apply narrative spacing if active (spread voxels further apart)
 if (narrativeVoxelParams) {
 const spacingFactor = narrativeVoxelParams.spacing;
 tempPos.multiplyScalar(spacingFactor);
 }
 
 // Spatial warp for organic motion
 const warp = Math.sin((tempPos.x + tempPos.y * 1.37 + tempPos.z * 0.73) * 3.1 + time * 0.9) * noiseWarp;
 
 // Per-instance phase
 const ph = hash(i * 0.3183 + i * 7.123) * phaseNoise;
 
 // Wave pattern
 const wave = Math.sin(time * speed + ph + (tempPos.length() * 1.1)) + warp;
 
 // Calculate outward offset (breathing effect)
 const normal = tempPos.clone().normalize();
 const offset = normal.multiplyScalar(wave * amplitude);
 
tmpObjAnim.position.copy(tempPos.add(offset));

// Apply narrative scale if active
let voxelScale = voxelHeadGroup.userData.baseVoxelSize || 0.10;
if (narrativeVoxelParams) {
voxelScale *= narrativeVoxelParams.scale;
}

// Check if this voxel is part of "TURN BACK" text
const isTurnBackVoxel = voxelHeadGroup.userData.turnBackText?.active && 
voxelHeadGroup.userData.turnBackIndices?.includes(i);

if (isTurnBackVoxel) {
// Make text voxels larger and pulsate
const textPulse = Math.sin(time * 3) * 0.3 + 1.3;
voxelScale *= textPulse;
// Set bright color for text voxels
if (instancedMesh.instanceColor) {
const textColor = new THREE.Color(1, 1, 0.3); // Bright yellow
instancedMesh.setColorAt(i, textColor);
}
}

tmpObjAnim.scale.setScalar(voxelScale);
 
 tmpObjAnim.rotation.set(0, 0, 0);
 tmpObjAnim.updateMatrix();
 instancedMesh.setMatrixAt(i, tmpObjAnim.matrix);
 }
 instancedMesh.instanceMatrix.needsUpdate = true;
 
 // Mark instance colors as needing update if text is active
 if (voxelHeadGroup.userData.turnBackText?.active && instancedMesh.instanceColor) {
 instancedMesh.instanceColor.needsUpdate = true;
 }
 
 // Animate opacity
 const opacitySpeed = headParams['Opacity Speed'] || 0.8;
 const opacityWave = Math.sin(time * opacitySpeed) * 0.5 + 0.5;
 instancedMesh.material.opacity = THREE.MathUtils.lerp(
 headParams['Opacity Min'], 
 headParams['Opacity Max'], 
 opacityWave
 );
 instancedMesh.material.emissiveIntensity = headParams['Emissive Intensity'];
 instancedMesh.material.metalness = headParams['Metalness'] || 0.2;
 instancedMesh.material.roughness = headParams['Roughness'] || 0.55;
 
// Pulse internal light
if (headLight) {
if (headParams['Light Pulse']) {
headLight.intensity = headParams['Light Intensity'] * (0.8 + 0.2 * Math.sin(time * 2.5));
} else {
headLight.intensity = headParams['Light Intensity'];
}
}

// Pulse eye lights
const eyeLights = voxelHeadGroup.userData.eyeLights;
if (eyeLights) {
const eyePulse = Math.sin(time * 1.5) * 0.3 + 0.7; // Gentle pulsation
eyeLights.forEach(light => {
light.intensity = 2.5 * eyePulse;
});
}

// Pulsate cheeks
const cheeks = voxelHeadGroup.userData.cheeks;
if (cheeks) {
const cheekPulse = Math.sin(time * 2.0) * 0.15 + 1.0; // Breathing-like pulsation
cheeks.forEach(cheek => {
cheek.scale.setScalar(cheekPulse);
cheek.material.emissiveIntensity = 0.6 * (0.8 + 0.2 * Math.sin(time * 2.0));
});
}
}
}

// Animate keyboard keys
 if (keys && keys.length > 0) {
 for (const key of keys) {
 if (key.userData.pressed) {
 // Apply velocity
 key.userData.velY += 0.003; // Spring back
 key.position.y += key.userData.velY;
 
 // Clamp to base position
 if (key.position.y >= key.userData.baseY) {
 key.position.y = key.userData.baseY;
 key.userData.velY = 0;
 key.userData.pressed = false;
 }
 }
 
 // Animate dust particles on keys
 if (key.userData.dustParticles && key.userData.dustParticles.length > 0) {
 for (const particle of key.userData.dustParticles) {
 if (!particle.userData) continue;
 
 // Float side to side with sine wave
 const freq = particle.userData.freq || 1;
 const phase = particle.userData.phase || 0;
 const drift = Math.sin(time * freq + phase) * 0.03;
 const driftZ = Math.cos(time * freq * 0.7 + phase) * 0.02;
 const baseX = particle.userData.baseX || 0;
 const baseZ = particle.userData.baseZ || 0;
 
 particle.position.x = baseX + drift;
 particle.position.z = baseZ + driftZ;
 
 // Slowly settle downward
 if (particle.position.y > 0.35) {
 particle.position.y -= 0.001;
 }
 }
 }
 }
 }
 
 // Animate Celli avatar interior grid pulsation
 if (narrativeCelliAvatar && narrativeCelliAvatar.visible && celliInteriorGrid) {
 const slabs = celliInteriorGrid.userData.slabs;
 if (slabs) {
 const isHovering = narrativeCelliAvatar.userData.hoverActive;
 const isClicking = narrativeCelliAvatar.userData.clickActive;
 
 // Determine pulsation intensity
 let baseIntensity = 0.3;
 let pulseSpeed = 2;
 let pulseScale = 1.0;
 
 if (isClicking) {
 // Intense pulsation on click
 baseIntensity = 0.8;
 pulseSpeed = 8;
 pulseScale = 1.4;
 } else if (isHovering) {
 // Moderate pulsation on hover
 baseIntensity = 0.5;
 pulseSpeed = 4;
 pulseScale = 1.2;
 }
 
 slabs.forEach((slab, i) => {
 const phase = (i * 0.2);
 const pulse = Math.sin(time * pulseSpeed + phase) * 0.5 + 0.5;
 
 // Animate opacity
 const targetOpacity = baseIntensity + pulse * 0.3;
 slab.material.opacity = THREE.MathUtils.lerp(slab.material.opacity, targetOpacity, 0.1);
 
 // Animate scale
 const targetScale = pulseScale * (0.9 + pulse * 0.2);
 slab.scale.setScalar(THREE.MathUtils.lerp(slab.scale.x, targetScale, 0.1));
 
 // Glow effect when clicking
 if (isClicking) {
 slab.material.emissive = new THREE.Color(0x8ab4ff);
 slab.material.emissiveIntensity = pulse * 0.5;
 } else {
 slab.material.emissiveIntensity = 0;
 }
 });
 }
 }
 
 composer.render();
 }

 // ===== Resize Handler =====
 window.addEventListener('resize', () => {
 camera.aspect = innerWidth / innerHeight;
 camera.updateProjectionMatrix();
 renderer.setSize(innerWidth, innerHeight);
 composer.setSize(innerWidth, innerHeight);
 fxaaPass.material.uniforms['resolution'].value.set(1 / innerWidth, 1 / innerHeight);
 });
 
// ===== Mouse Move Handler (No Pointer Lock in Sequence) =====
window.addEventListener('mousemove', (event) => {
// Orbit controls handle all rotation in sequence mode - no pointer lock needed
// Check for hover over Celli avatar
 if (!document.pointerLockElement && narrativeCelliAvatar && narrativeCelliAvatar.visible) {
 const mouse = new THREE.Vector2();
 mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
 mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
 
 const raycaster = new THREE.Raycaster();
 raycaster.setFromCamera(mouse, camera);
 
 const intersects = raycaster.intersectObjects(narrativeCelliAvatar.children, true);
 
 if (intersects.length > 0) {
 // Hovering over Celli
 renderer.domElement.style.cursor = 'pointer';
 if (!narrativeCelliAvatar.userData.hoverActive) {
 narrativeCelliAvatar.userData.hoverActive = true;
 console.log('[Celli] Hover started');
 }
 } else {
 // Not hovering
 renderer.domElement.style.cursor = 'default';
 narrativeCelliAvatar.userData.hoverActive = false;
 }
 }
 });
 
 // ===== Click Handler for Celli Avatar =====
 window.addEventListener('mousedown', (event) => {
 if (!narrativeCelliAvatar || !narrativeCelliAvatar.visible) return;
 if (event.button !== 0) return; // Only left click
 
 const mouse = new THREE.Vector2();
 mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
 mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
 
 const raycaster = new THREE.Raycaster();
 raycaster.setFromCamera(mouse, camera);
 
 const intersects = raycaster.intersectObjects(narrativeCelliAvatar.children, true);
 
if (intersects.length > 0) {
console.log('[Celli] Clicked!');
narrativeCelliAvatar.userData.clickActive = true;
// Don't stop propagation - allow drag controls to work

// Reset click state after a short duration
setTimeout(() => {
if (narrativeCelliAvatar) {
narrativeCelliAvatar.userData.clickActive = false;
}
}, 500);
}
 });

// ===== Start =====
console.log('[Init] Starting application...');

(async () => {
  try {
    await initialize();
    animate();
    console.log('[Init] ✅ Application started successfully');
  } catch (err) {
    console.error('[Init] Fatal error during startup:', err);
    const statusEl = document.getElementById('status-message');
    if (statusEl) statusEl.textContent = 'Fatal error - check console (F12)';
  }
})();
 </script>
 
 <!-- Screen Recorder - Universal Support -->
 <script src="https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.js"></script>
 <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
 <script src="../../src/scripts/tools/recorder-standalone.js"></script>
 
</body>
</html>

