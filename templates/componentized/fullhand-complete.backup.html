<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="utf-8" />
 <meta name="viewport" content="width=device-width, initial-scale=1" />
 <title>Three.js Integrated Scene Voxel Hand + Keyboard + Character</title>
 <!-- MODE_PLACEHOLDER -->
 <!--
 INTEGRATED SCENE:
 1. cursor.html - Voxel hand creation with 96px high-res capture and progressive build animation
 2. fullhand.html (original) - Retro keyboard with god rays, atmospheric dust, and realistic keys
 3. bust.html - Character bust with ZSphere-based hourglass figure and posing tools
 4. bosscelli.html - Glowing voxel animated head with face cutouts (eyes/smile)
 
 FLOW:
 - Scene starts blank
 - Voxel hand creation sequence (from cursor.html)
 - Once complete, reveals full keyboard scene
 - Character bust positioned beside keyboard at human scale
 - Glowing voxel head above character's upper body
 - Debug menu provides quick navigation between scene elements
 - Edit mode allows posing character with transform gizmos
 -->
 <style>
 html, body { height: 100%; margin: 0; background:#0a0a0a; overflow:hidden; }
 #app { position: fixed; inset: 0; }
 
 /* Early Preview Menu */
 #debug-menu { 
 position: fixed; top: 80px; right: 20px; 
 background: rgba(20,20,24,0.98); 
 backdrop-filter: blur(15px);
 padding: 20px; 
 border: 2px solid #4a7cff; 
 border-radius: 12px; 
 color: #ddd;
 font: 13px/1.4 system-ui, Arial;
 min-width: 240px;
 max-width: 280px;
 z-index: 100;
 box-shadow: 0 8px 32px rgba(74, 124, 255, 0.3);
 }
 #debug-menu h3 { 
 margin: 0 0 16px 0; 
 font-size: 16px; 
 color: #4a7cff; 
 text-transform: uppercase;
 letter-spacing: 1px;
 font-weight: 600;
 }
 #debug-menu button {
 width: 100%;
 padding: 12px;
 margin: 8px 0;
 background: linear-gradient(135deg, #2a2a2f 0%, #1a1a1f 100%);
 border: 1px solid #4a7cff;
 color: #fff;
 border-radius: 8px;
 cursor: pointer;
 font-size: 13px;
 font-weight: 600;
 transition: all 0.3s ease;
 position: relative;
 overflow: hidden;
 }
 #debug-menu button::before {
 content: '';
 position: absolute;
 top: 50%;
 left: 50%;
 width: 0;
 height: 0;
 border-radius: 50%;
 background: rgba(74, 124, 255, 0.3);
 transform: translate(-50%, -50%);
 transition: width 0.6s, height 0.6s;
 }
 #debug-menu button:hover::before {
 width: 300px;
 height: 300px;
 }
 #debug-menu button:hover { 
 background: linear-gradient(135deg, #3a3a44 0%, #2a2a2f 100%);
 border-color: #6a9cff;
 transform: translateY(-2px);
 box-shadow: 0 4px 12px rgba(74, 124, 255, 0.4);
 }
 #debug-menu button:active { 
 transform: translateY(0);
 box-shadow: 0 2px 8px rgba(74, 124, 255, 0.2);
 }
 #debug-menu.minimized { display: none; }
 
 /* Minimize button on debug menu */
 #debug-menu-minimize {
 position: absolute;
 top: 10px;
 left: 10px;
 width: 24px;
 height: 24px;
 border-radius: 50%;
 background: #ff4a4a;
 border: 2px solid #ff6a6a;
 cursor: pointer;
 display: flex;
 align-items: center;
 justify-content: center;
 font-size: 14px;
 color: #fff;
 font-weight: bold;
 transition: all 0.2s;
 z-index: 10;
 }
 #debug-menu-minimize:hover {
 background: #ff6a6a;
 transform: scale(1.1);
 }
 
 /* Floating Toggle Button */
 #debug-menu-restore {
 position: fixed;
 top: 20px;
 right: 20px;
 width: 60px;
 height: 60px;
 border-radius: 50%;
 background: linear-gradient(135deg, #4a7cff 0%, #6a9cff 100%);
 border: 3px solid rgba(255, 255, 255, 0.2);
 backdrop-filter: blur(10px);
 cursor: pointer;
 display: flex;
 align-items: center;
 justify-content: center;
 font-size: 28px;
 color: #fff;
 transition: all 0.3s ease;
 z-index: 100;
 box-shadow: 0 4px 16px rgba(74, 124, 255, 0.5);
 }
 #debug-menu-restore:hover {
 background: linear-gradient(135deg, #5a8cff 0%, #7aacff 100%);
 transform: scale(1.15) rotate(10deg);
 box-shadow: 0 6px 24px rgba(74, 124, 255, 0.7);
 }
 #debug-menu-restore:active {
 transform: scale(1.05) rotate(5deg);
 }
 #debug-menu-restore.visible {
 display: flex;
 }
 
 .gizmo-toolbar { 
 position: fixed; top: 20px; left: 20px; 
 display: none; /* Hidden initially */
 gap: 8px; 
 z-index: 90;
 }
 .gizmo-btn { 
 width: 44px; height: 44px; 
 background: #1e2328; 
 border: 2px solid #3a4149; 
 border-radius: 6px; 
 cursor: pointer; 
 display: flex; 
 align-items: center; 
 justify-content: center; 
 font-size: 20px; 
 transition: all .2s; 
 user-select: none; 
 }
 .gizmo-btn:hover { background: #2a3138; border-color: #5a6169; }
 .gizmo-btn.active { background: #4a7cff; border-color: #6a9cff; }
 
 #loading-overlay {
  position: fixed;
  inset: 0;
  background: #0a0a0a;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #eaeaf2;
  font: 16px/1.4 system-ui;
  z-index: 1000;
  transition: opacity 0.5s;
 }
 #loading-overlay.hidden { opacity: 0; pointer-events: none; }

 .status-text { text-align: center; }
 .status-text .spinner {
  width: 40px;
  height: 40px;
  border: 3px solid #333;
  border-top-color: #4a7cff;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin: 0 auto 20px;
 }
 @keyframes spin { to { transform: rotate(360deg); } }

 /* Prototype Overlay Stack */
 .prototype-overlay {
  position: fixed;
  left: 24px;
  bottom: 24px;
  display: flex;
  flex-direction: column;
  gap: 12px;
  max-width: 320px;
  z-index: 220;
  pointer-events: none;
 }
 .prototype-overlay .prototype-card {
  pointer-events: auto;
  background: rgba(18, 20, 32, 0.9);
  border: 1px solid rgba(90, 130, 255, 0.3);
  border-radius: 16px;
  padding: 18px 20px;
  color: #ecf1ff;
  font: 13px/1.6 "Inter", system-ui, sans-serif;
  box-shadow: 0 18px 40px rgba(10, 14, 40, 0.45);
  backdrop-filter: blur(18px);
  opacity: 0;
  transform: translateY(12px) scale(0.98);
  transition: opacity 0.6s ease, transform 0.6s ease, box-shadow 0.3s ease;
 }
 .prototype-overlay .prototype-card.visible {
  opacity: 1;
  transform: translateY(0) scale(1);
 }
 .prototype-overlay .prototype-card header {
  font-size: 15px;
  font-weight: 600;
  letter-spacing: 0.02em;
  margin-bottom: 10px;
  display: flex;
  align-items: center;
  gap: 8px;
 }
 .prototype-overlay .prototype-card header span {
  display: inline-flex;
  width: 24px;
  height: 24px;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  background: rgba(90, 130, 255, 0.15);
  border: 1px solid rgba(90, 130, 255, 0.35);
  font-size: 12px;
 }
 .prototype-overlay .prototype-card p {
  margin: 0 0 12px 0;
  color: #bfc6ff;
 }
 .prototype-overlay .prototype-card ul {
  margin: 0 0 12px 16px;
  padding: 0;
  color: #ced5ff;
 }
 .prototype-overlay button {
  background: linear-gradient(135deg, rgba(90, 130, 255, 0.85), rgba(120, 150, 255, 0.75));
  border: 1px solid rgba(120, 160, 255, 0.5);
  color: #0b0d18;
  font-weight: 600;
  padding: 8px 14px;
  border-radius: 999px;
  cursor: pointer;
  transition: transform 0.2s ease, box-shadow 0.2s ease;
 }
 .prototype-overlay button:hover {
  transform: translateY(-1px);
  box-shadow: 0 6px 20px rgba(90, 130, 255, 0.35);
 }
 .prototype-overlay button:active {
  transform: translateY(0);
 }
 .prototype-overlay .prototype-card.spotlight {
  box-shadow: 0 22px 50px rgba(140, 180, 255, 0.6);
  border-color: rgba(160, 195, 255, 0.8);
 }
 .prototype-overlay pre {
  margin: 0;
  background: rgba(8, 10, 18, 0.9);
  border: 1px solid rgba(90, 130, 255, 0.25);
  border-radius: 12px;
  padding: 12px 14px;
  color: #9de4ff;
  font-family: "Fira Code", "Courier New", monospace;
  font-size: 11px;
  letter-spacing: 0.08em;
  line-height: 1.3;
  box-shadow: inset 0 0 0 1px rgba(90, 130, 255, 0.1);
 }
 .prototype-overlay .prototype-timeline {
  pointer-events: none;
  background: rgba(12, 14, 24, 0.92);
  border: 1px solid rgba(60, 90, 180, 0.35);
  border-radius: 12px;
  padding: 12px 16px;
  color: #9cabff;
  font: 12px/1.4 "Inter", system-ui;
  box-shadow: 0 14px 30px rgba(8, 12, 30, 0.4);
 }
 .prototype-overlay .prototype-timeline-bar {
  margin-top: 8px;
  width: 100%;
  height: 4px;
  background: rgba(32, 38, 70, 0.7);
  border-radius: 999px;
  overflow: hidden;
 }
 .prototype-overlay .prototype-timeline-progress {
  width: 0%;
  height: 100%;
  background: linear-gradient(90deg, rgba(90, 130, 255, 0.4), rgba(180, 220, 255, 0.85));
  transition: width 0.5s ease;
 }
 .prototype-overlay .media-control {
  display: flex;
  align-items: center;
  gap: 10px;
  flex-wrap: wrap;
 }
 .prototype-overlay .media-control span {
  font-size: 12px;
  color: rgba(200, 210, 255, 0.85);
 }
 .prototype-overlay video {
  width: 100%;
  border-radius: 12px;
  margin-top: 12px;
  border: 1px solid rgba(90, 130, 255, 0.25);
  background: rgba(8, 10, 18, 0.8);
 }
 .prototype-overlay .prototype-footnote {
  margin-top: 10px;
  font-size: 11px;
  color: rgba(180, 195, 255, 0.75);
 }
 @media (max-width: 900px) {
  .prototype-overlay {
   left: 16px;
   right: 16px;
   bottom: 16px;
   max-width: none;
  }
 }
 @media (prefers-reduced-motion: reduce) {
  .prototype-overlay .prototype-card {
   transition: none;
  }
  .prototype-overlay .prototype-timeline-progress {
   transition: none;
  }
 }

 /* Modal Windows */
 .modal-window {
 position: fixed;
 background: rgba(20,20,24,0.98);
 backdrop-filter: blur(15px);
 border: 1px solid #444;
 border-radius: 12px;
 color: #ddd;
 font: 13px/1.4 system-ui, Arial;
 box-shadow: 0 10px 40px rgba(0,0,0,0.5);
 z-index: 200;
 display: none;
 }
 .modal-window.active { display: block; }
 .modal-header {
 padding: 16px;
 border-bottom: 1px solid #333;
 display: flex;
 justify-content: space-between;
 align-items: center;
 cursor: move;
 user-select: none;
 }
 .modal-header h3 { margin: 0; font-size: 15px; color: #fff; }
 .modal-close {
 background: #2a2a2f;
 border: 1px solid #444;
 color: #ddd;
 width: 24px;
 height: 24px;
 border-radius: 4px;
 cursor: pointer;
 display: flex;
 align-items: center;
 justify-content: center;
 font-size: 16px;
 line-height: 1;
 }
 .modal-close:hover { background: #3a3a44; }
 .modal-body {
 padding: 16px;
 max-height: 70vh;
 overflow-y: auto;
 }
 .modal-footer {
 padding: 16px;
 border-top: 1px solid #333;
 display: flex;
 gap: 8px;
 justify-content: flex-end;
 }
 .modal-btn {
 padding: 8px 16px;
 background: #2a2a2f;
 border: 1px solid #444;
 color: #ddd;
 border-radius: 6px;
 cursor: pointer;
 font-size: 13px;
 transition: all 0.2s;
 }
 .modal-btn:hover { background: #3a3a44; border-color: #555; }
 .modal-btn.primary { background: #4a7cff; border-color: #6a9cff; }
 .modal-btn.primary:hover { background: #5a8cff; }
 
 .form-group {
 margin-bottom: 16px;
 }
 .form-group label {
 display: block;
 margin-bottom: 6px;
 color: #aaa;
 font-size: 12px;
 }
 .form-group input, .form-group select {
 width: 100%;
 padding: 8px;
 background: #1a1a1f;
 border: 1px solid #444;
 color: #ddd;
 border-radius: 4px;
 font-size: 13px;
 box-sizing: border-box;
 }
 .form-group input:focus, .form-group select:focus {
 outline: none;
 border-color: #4a7cff;
 }
 
 #scene-browser-modal {
 top: 80px;
 left: 20px;
 width: 300px;
 }
 #edit-head-modal {
 top: 50%;
 left: 50%;
 transform: translate(-50%, -50%);
 width: 400px;
 }
 #save-config-modal {
 top: 50%;
 left: 50%;
 transform: translate(-50%, -50%);
 width: 350px;
 }
 #config-report-modal {
 top: 50%;
 left: 50%;
 transform: translate(-50%, -50%);
 width: 500px;
 max-height: 80vh;
 }
 
 .hierarchy-item {
 padding: 8px;
 margin: 4px 0;
 background: #1a1a1f;
 border: 1px solid #333;
 border-radius: 4px;
 cursor: pointer;
 transition: all 0.2s;
 }
 .hierarchy-item:hover {
 background: #2a2a2f;
 border-color: #4a7cff;
 }
 .hierarchy-item.selected {
 background: #4a7cff;
 border-color: #6a9cff;
 }
 
 /* Dialogue System */
 #narrative-dialogue {
 position: fixed;
 bottom: 80px;
 left: 50%;
 transform: translateX(-50%);
 max-width: 600px;
 width: 85%;
 padding: 20px 30px;
 background: rgba(20, 20, 24, 0.92);
 backdrop-filter: blur(15px);
 border: 1px solid rgba(138, 180, 255, 0.3);
 border-radius: 12px;
 color: #e6e6e6;
 font-family: ui-sans-serif, system-ui, sans-serif;
 font-size: 16px;
 line-height: 1.6;
 text-align: center;
 opacity: 0;
 pointer-events: none;
 transition: opacity 0.8s ease, transform 0.8s ease;
 z-index: 200;
 box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), 0 0 80px rgba(138, 180, 255, 0.15);
 }
 
 #narrative-dialogue.active {
 opacity: 1;
 pointer-events: auto;
 transform: translateX(-50%) translateY(0);
 }
 
 #narrative-dialogue .dialogue-text {
 margin: 0;
 font-style: italic;
 }
 
 #narrative-dialogue .dialogue-text strong {
 color: #8ab4ff;
 font-weight: 600;
 }

/* Chief Image Display */
#chief-display {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.95);
  display: none;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  z-index: 300;
  opacity: 0;
  transition: opacity 0.8s ease;
}

#chief-display.active {
  display: flex;
  opacity: 1;
}

#chief-display img {
  max-width: 60%;
  max-height: 60vh;
  image-rendering: pixelated;
  border: 4px solid #8ab4ff;
  box-shadow: 0 0 40px rgba(138, 180, 255, 0.5);
}

#chief-buttons {
  display: flex;
  gap: 40px;
  margin-top: 40px;
}

#chief-buttons button {
  font-size: 48px;
  width: 80px;
  height: 80px;
  border-radius: 50%;
  border: 3px solid #8ab4ff;
  background: rgba(138, 180, 255, 0.1);
  cursor: pointer;
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}

#chief-buttons button:hover {
  transform: scale(1.2);
  background: rgba(138, 180, 255, 0.3);
  box-shadow: 0 0 20px rgba(138, 180, 255, 0.8);
}

/* Image Trail Canvas */
#image-trail-canvas {
  position: fixed;
  inset: 0;
  pointer-events: none;
  z-index: 250;
  display: none;
}

#image-trail-canvas.active {
  display: block;
}

/* ===== ZEKE PORTAL STYLES ===== */
#sheet-stream {
  position: fixed;
  left: -99999px;
  top: 0;
  width: 640px;
  background: white;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Arial, sans-serif;
  pointer-events: none;
  z-index: -1;
  visibility: hidden;
}

.zeke-message {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(18, 24, 38, 0.95);
  border: 2px solid rgba(188, 217, 255, 0.6);
  border-radius: 10px;
  padding: 20px 30px;
  color: #e7f0ff;
  font-size: 16px;
  z-index: 200;
  animation: zekeFadeIn 0.3s ease;
}

@keyframes zekeFadeIn {
  from { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
  to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
}

/* Sequence Buttons Hover Effects */
#sequence-buttons button:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}

#sequence-buttons button:active {
  transform: translateY(0);
}
 </style>
 <script type="importmap">
 {
 "imports": {
 "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
 "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
 "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm"
 }
 }
 </script>
 <!-- ZEKE Portal Dependencies -->
 <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
</head>
<body>
 <!-- Hidden DOM for spreadsheet streaming -->
 <div id="sheet-stream" style="position: fixed; left: -99999px; top: 0; width: 640px; background: white; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif; pointer-events: none; z-index: -1; visibility: hidden;"></div>
 
 <div id="app"></div>
 
 <div id="loading-overlay">
  <div class="status-text">
   <div class="spinner"></div>
   <div id="status-message">Loading scene...</div>
  </div>
 </div>

<!-- Sequence Buttons (visible in sequence mode) -->
<div id="sequence-buttons" style="position: fixed; bottom: 20px; right: 20px; background: rgba(26, 32, 44, 0.95); padding: 16px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 9999; display: none;">
  <h4 style="margin: 0 0 12px 0; color: #8ab4ff; font-size: 13px; font-weight: 600;">🎬 Sequences</h4>
  <button id="btn-chief-sequence-alt" style="display: block; width: 100%; padding: 10px 16px; margin-bottom: 8px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; font-size: 12px; transition: all 0.2s;">
    🎭 Chief Reveal
  </button>
  <button id="btn-show-spreadsheet-alt" style="display: block; width: 100%; padding: 10px 16px; margin-bottom: 8px; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; font-size: 12px; transition: all 0.2s;">
    📊 Spreadsheet
  </button>
  <button id="btn-voxelizer-sequence" style="display: block; width: 100%; padding: 10px 16px; margin-bottom: 8px; background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%); color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; font-size: 12px; transition: all 0.2s;">
    📹 Webcam Voxelizer
  </button>
  <button id="btn-force-fp-unlock" style="display: block; width: 100%; padding: 10px 16px; background: linear-gradient(135deg, #00c6ff 0%, #0072ff 100%); color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; font-size: 12px; transition: all 0.2s;">
    🧰 Force First-Person Unlock
  </button>
</div>

 <div id="debug-menu">
  <div id="debug-menu-minimize" title="Close">×</div>
  <h3>🎮 Debug Menu</h3>
  
  <div style="margin-bottom: 20px;">
    <h4 style="margin: 0 0 8px 0; color: #8ab4ff; font-size: 12px; font-weight: 600; text-transform: uppercase;">Scene</h4>
    <button id="btn-toggle-scene-browser">
      📦 Scene Browser
    </button>
    <button id="btn-toggle-avatar-selector">
      👤 Avatar Selector
    </button>
  </div>

  <div style="margin-bottom: 20px;">
    <h4 style="margin: 0 0 8px 0; color: #8ab4ff; font-size: 12px; font-weight: 600; text-transform: uppercase;">Voxel Tools</h4>
    <button id="btn-upload-hand">
      ✋ Upload Hand Image
    </button>
    <button id="btn-import-fbx">
      📦 Import FBX
    </button>
    <button id="btn-webcam-voxelizer">
      📹 Webcam Voxelizer
    </button>
  </div>

  <div style="margin-bottom: 20px;">
    <h4 style="margin: 0 0 8px 0; color: #8ab4ff; font-size: 12px; font-weight: 600; text-transform: uppercase;">Camera</h4>
    <button id="btn-keyboard">
      ⌨️ View Keyboard
    </button>
    <button id="btn-character">
      🙋 View Character
    </button>
    <button id="btn-drop">
      🚪 Drop Mode
    </button>
    <button id="btn-show-visualizer">
      🎛️ Show Visualizer
    </button>
  </div>

  <div>
    <h4 style="margin: 0 0 8px 0; color: #8ab4ff; font-size: 12px; font-weight: 600; text-transform: uppercase;">🎬 Sequences</h4>
    <button id="btn-show-spreadsheet">
      📊 3D Spreadsheet
    </button>
    <button id="btn-chief-sequence">
      🎭 Chief Sequence
    </button>
  </div>
 </div>

 <!-- Avatar Selector Modal -->
 <div id="avatar-selector-modal" class="modal-window">
 <div class="modal-header">
 <h3>Avatar Selector</h3>
 <div class="modal-close" onclick="document.getElementById('avatar-selector-modal').classList.remove('active')">×</div>
 </div>
 <div class="modal-body">
 <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px;">
 <button class="avatar-select-btn" data-avatar="border" style="padding: 20px; background: #2a2a2f; border: 2px solid #444; color: #ddd; border-radius: 8px; cursor: pointer; transition: all 0.2s;">
 <div style="font-size: 14px; font-weight: 600; margin-bottom: 8px;">Border Cursor</div>
 <div style="font-size: 11px; opacity: 0.7;">Simple frame avatar</div>
 </button>
 <button class="avatar-select-btn" data-avatar="full" style="padding: 20px; background: #2a2a2f; border: 2px solid #444; color: #ddd; border-radius: 8px; cursor: pointer; transition: all 0.2s;">
 <div style="font-size: 14px; font-weight: 600; margin-bottom: 8px; color: #f59e0b;">Full Celli</div>
 <div style="font-size: 11px; opacity: 0.7;">Complete character</div>
 </button>
 <button class="avatar-select-btn" data-avatar="hybrid" style="padding: 20px; background: #2a2a2f; border: 2px solid #444; color: #ddd; border-radius: 8px; cursor: pointer; transition: all 0.2s;">
 <div style="font-size: 14px; font-weight: 600; margin-bottom: 8px; color: #ffaa00;">Hybrid</div>
 <div style="font-size: 11px; opacity: 0.7;">Border + Full (default)</div>
 </button>
 <button class="avatar-select-btn" data-avatar="both" style="padding: 20px; background: #2a2a2f; border: 2px solid #444; color: #ddd; border-radius: 8px; cursor: pointer; transition: all 0.2s;">
 <div style="font-size: 14px; font-weight: 600; margin-bottom: 8px; color: #00ffff;">Side-by-Side</div>
 <div style="font-size: 11px; opacity: 0.7;">Border and Full separate</div>
 </button>
 <button class="avatar-select-btn" data-avatar="bob" style="padding: 20px; background: #2a2a2f; border: 2px solid #444; color: #ddd; border-radius: 8px; cursor: pointer; transition: all 0.2s;">
 <div style="font-size: 14px; font-weight: 600; margin-bottom: 8px; color: #ff6b9d;">Bob</div>
 <div style="font-size: 11px; opacity: 0.7;">Voxel block character</div>
 </button>
 <button class="avatar-select-btn" data-avatar="palette" style="padding: 20px; background: #2a2a2f; border: 2px solid #444; color: #ddd; border-radius: 8px; cursor: pointer; transition: all 0.2s;">
 <div style="font-size: 14px; font-weight: 600; margin-bottom: 8px; color: #00ff00;">Pal-ette</div>
 <div style="font-size: 11px; opacity: 0.7;">Grid character</div>
 </button>
 </div>
 </div>
 <div class="modal-footer">
 <button class="modal-btn primary" onclick="document.getElementById('avatar-selector-modal').classList.remove('active')">Close</button>
 </div>
 </div>
 
 <div id="debug-menu-restore" title="Early Preview Menu">🎬</div>
 
 <!-- Narrative Dialogue -->
 <div id="narrative-dialogue">
 <p class="dialogue-text"></p>
 </div>

 <!-- Chief Image Display -->
 <div id="chief-display">
 <img id="chief-image" src="" alt="Chief">
 <div id="chief-buttons">
 <button id="chief-thumbs-up" title="Thumbs Up">👍</button>
 <button id="chief-thumbs-down" title="Thumbs Down">👎</button>
 </div>
 </div>

 <!-- Image Trail Canvas -->
 <canvas id="image-trail-canvas"></canvas>
 
 <input type="file" id="cursor-file-input" accept="image/*" style="display:none;">
 <input type="file" id="fbx-file-input" accept=".fbx,.FBX" style="display:none;">
 
<div class="gizmo-toolbar" id="gizmo-toolbar" style="display: flex;">
<div class="gizmo-btn active" data-mode="translate" title="Translate (G)">?</div>
<div class="gizmo-btn" data-mode="rotate" title="Rotate (R)">?</div>
<div class="gizmo-btn" data-mode="scale" title="Scale (S)">?</div>
<div style="width: 1px; height: 34px; background: #3a4149; margin: 5px 4px;"></div>
<div class="gizmo-btn" id="snap-toggle" data-snap="free" title="Rotation Snap: Free" style="font-size: 14px; font-weight: 600;">Free</div>
<div class="gizmo-btn" id="drop-btn" title="Drop to Human Scale" style="font-size: 14px; font-weight: 600; background: #4a7cff;">DROP</div>
</div>

<!-- Drop Mode Debug Tracker -->
<div id="drop-debug" style="
position: fixed;
top: 80px;
right: 20px;
background: rgba(0, 0, 0, 0.9);
color: #0f0;
padding: 15px;
font-family: 'Courier New', monospace;
font-size: 11px;
border: 2px solid #0f0;
border-radius: 4px;
z-index: 2000;
display: none;
min-width: 280px;
line-height: 1.6;
box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
">
<div style="color: #ff0; font-weight: bold; margin-bottom: 8px; border-bottom: 1px solid #0f0; padding-bottom: 4px;">ðŸŽ® DROP MODE DEBUG</div>
<div id="drop-debug-content"></div>
</div>
 
 <!-- Scene Browser Modal -->
 <div id="scene-browser-modal" class="modal-window">
 <div class="modal-header">
 <h3>Scene Objects</h3>
 <div class="modal-close" onclick="document.getElementById('scene-browser-modal').classList.remove('active')"> </div>
 </div>
 <div class="modal-body" id="scene-browser-content">
 <!-- Populated dynamically -->
 </div>
 </div>
 
 <!-- Edit Head Modal -->
 <div id="edit-head-modal" class="modal-window">
 <div class="modal-header">
 <h3>Edit Head</h3>
 <div class="modal-close" onclick="document.getElementById('edit-head-modal').classList.remove('active')"> </div>
 </div>
 <div class="modal-body">
 <div class="form-group">
 <label>Preset Configuration</label>
<select id="head-preset-select" onchange="loadHeadPreset(this.value)">
<option value="sparse-blue">Sparse Blue (Default)</option>
<option value="intro-celli">Intro Celli (Narrative)</option>
<option value="dense-cyan">Dense Cyan</option>
<option value="warm-glow">Warm Glow</option>
<option value="neon-pink">Neon Pink</option>
<option value="ghost-white">Ghost White</option>
</select>
 </div>
 <hr style="border-color: #333; margin: 12px 0;">
 <h4 style="margin: 8px 0; font-size: 13px; color: #ddd;">Mouth Expression</h4>
 <div class="form-group">
 <label>Smile/Frown Deformation</label>
 <input type="range" id="head-mouth-deform" min="-1" max="1" step="0.01" value="1">
 <span id="head-mouth-deform-val">1.00 (Smile)</span>
 </div>
 <hr style="border-color: #333; margin: 12px 0;">
 <h4 style="margin: 8px 0; font-size: 13px; color: #ddd;">Voxel Geometry</h4>
 <div class="form-group">
 <label>Voxel Layers</label>
 <input type="range" id="head-voxel-layers" min="1" max="5" step="1" value="2">
 <span id="head-voxel-layers-val">2</span>
 </div>
 <div class="form-group">
 <label>Voxel Scale</label>
 <input type="range" id="head-voxel-scale" min="0.5" max="2" step="0.05" value="1">
 <span id="head-voxel-scale-val">1.00</span>
 </div>
 <div class="form-group">
 <label>Voxel Spacing</label>
 <input type="range" id="head-voxel-spacing" min="1.0" max="2.0" step="0.05" value="1.05">
 <span id="head-voxel-spacing-val">1.05</span>
 </div>
 <hr style="border-color: #333; margin: 12px 0;">
 <h4 style="margin: 8px 0; font-size: 13px; color: #ddd;">Animation</h4>
 <div class="form-group">
 <label>Animation Speed</label>
 <input type="range" id="head-anim-speed" min="0" max="3" step="0.01" value="1.15">
 <span id="head-anim-speed-val">1.15</span>
 </div>
 <div class="form-group">
 <label>Amplitude</label>
 <input type="range" id="head-amplitude" min="0" max="0.5" step="0.01" value="0.15">
 <span id="head-amplitude-val">0.15</span>
 </div>
 <div class="form-group">
 <label>Opacity Min</label>
 <input type="range" id="head-opacity-min" min="0" max="1" step="0.01" value="0.3">
 <span id="head-opacity-min-val">0.3</span>
 </div>
 <div class="form-group">
 <label>Opacity Max</label>
 <input type="range" id="head-opacity-max" min="0" max="1" step="0.01" value="0.85">
 <span id="head-opacity-max-val">0.85</span>
 </div>
 <div class="form-group">
 <label>Emissive Intensity</label>
 <input type="range" id="head-emissive" min="0" max="2" step="0.01" value="0.8">
 <span id="head-emissive-val">0.8</span>
 </div>
 <div class="form-group">
 <label>Light Intensity</label>
 <input type="range" id="head-light-int" min="0" max="10" step="0.1" value="2.5">
 <span id="head-light-int-val">2.5</span>
 </div>
 <div class="form-group">
 <label>
 <input type="checkbox" id="head-light-pulse" checked>
 Light Pulse
 </label>
 </div>
 <div class="form-group">
 <label>Rotation Speed</label>
 <input type="range" id="head-rotation-speed" min="0" max="1" step="0.01" value="0.3">
 <span id="head-rotation-speed-val">0.3</span>
 </div>
 <div class="form-group">
 <label>Color</label>
 <input type="color" id="head-color" value="#95bfff">
 </div>
 <hr>
 <h4>Advanced Animation</h4>
 <div class="form-group">
 <label>Phase Noise</label>
 <input type="range" id="head-phase-noise" min="0" max="2" step="0.01" value="0.75">
 <span id="head-phase-noise-val">0.75</span>
 </div>
 <div class="form-group">
 <label>Falloff</label>
 <input type="range" id="head-falloff" min="0" max="2" step="0.01" value="0.85">
 <span id="head-falloff-val">0.85</span>
 </div>
 <div class="form-group">
 <label>Noise Warp</label>
 <input type="range" id="head-noise-warp" min="0" max="0.6" step="0.01" value="0.15">
 <span id="head-noise-warp-val">0.15</span>
 </div>
 <div class="form-group">
 <label>Opacity Speed</label>
 <input type="range" id="head-opacity-speed" min="0" max="3" step="0.01" value="0.8">
 <span id="head-opacity-speed-val">0.8</span>
 </div>
 <h4>Material</h4>
 <div class="form-group">
 <label>Metalness</label>
 <input type="range" id="head-metalness" min="0" max="1" step="0.01" value="0.2">
 <span id="head-metalness-val">0.2</span>
 </div>
 <div class="form-group">
 <label>Roughness</label>
 <input type="range" id="head-roughness" min="0" max="1" step="0.01" value="0.55">
 <span id="head-roughness-val">0.55</span>
 </div>
 </div>
 <div class="modal-footer">
 <button class="modal-btn" onclick="document.getElementById('edit-head-modal').classList.remove('active')">Close</button>
 <button class="modal-btn primary" onclick="applyHeadSettings()">Apply</button>
 </div>
 </div>
 
 <!-- Edit Hands Modal -->
 <div id="edit-hands-modal" class="modal-window" style="top: 50%; left: 50%; transform: translate(-50%, -50%); width: 400px;">
 <div class="modal-header">
 <h3>Edit Hands</h3>
 <div class="modal-close" onclick="document.getElementById('edit-hands-modal').classList.remove('active')"> </div>
 </div>
 <div class="modal-body" id="edit-hands-content">
 <!-- Populated by lil-gui -->
 </div>
 </div>
 
 <!-- Save Configuration Modal -->
 <div id="save-config-modal" class="modal-window">
 <div class="modal-header">
 <h3>Save Configuration</h3>
 <div class="modal-close" onclick="document.getElementById('save-config-modal').classList.remove('active')"> </div>
 </div>
 <div class="modal-body">
 <div class="form-group">
 <label>Configuration Name</label>
 <input type="text" id="config-name-input" placeholder="My Scene Configuration">
 </div>
 <div class="form-group">
 <label>Existing Configurations</label>
 <select id="config-list-select" size="5" style="height: 120px;">
 <!-- Populated from localStorage -->
 </select>
 </div>
 </div>
 <div class="modal-footer">
 <button class="modal-btn" onclick="document.getElementById('save-config-modal').classList.remove('active')">Cancel</button>
 <button class="modal-btn" onclick="saveAsConfiguration()">Save As New</button>
 <button class="modal-btn primary" onclick="saveConfiguration()">Save</button>
 </div>
 </div>
 
 <!-- Configuration Report Modal -->
 <div id="config-report-modal" class="modal-window">
 <div class="modal-header">
 <h3>Configuration Report</h3>
 <div class="modal-close" onclick="document.getElementById('config-report-modal').classList.remove('active')"> </div>
 </div>
 <div class="modal-body">
 <div id="config-report-content" style="font-family: monospace; font-size: 12px; line-height: 1.6;">
 <!-- Populated dynamically -->
 </div>
 </div>
 <div class="modal-footer">
 <button class="modal-btn primary" onclick="document.getElementById('config-report-modal').classList.remove('active')">Close</button>
 </div>
 </div>
 
 <script type="module">
 import * as THREE from 'three';
 import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
 import { TransformControls } from 'three/addons/controls/TransformControls.js';
 import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
 import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
 import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
 import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
 import { FXAAShader } from 'three/addons/shaders/FXAAShader.js';
 import { BokehPass } from 'three/addons/postprocessing/BokehPass.js';
 import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
 import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';
import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
import GUI from 'lil-gui';

 // Note: GPU "Sample Bias" warnings are from Three.js internal shader generation
 // when using high-quality materials (MeshPhysicalMaterial) with certain property combinations.
 // These are clamped automatically by the GPU and don't affect rendering.
 // All bias values in this code are set within the valid range (-16 to 15.99).

// ===== MODE DETECTION =====
// Check localStorage first (set by FullhandScene-Faithful.js), then window, then default to 'sequence'
// Check URL params for mode
const urlParams = new URLSearchParams(window.location.search);
const urlMode = urlParams.get('mode');
const FROM_LATTICE = urlParams.has('mode') && urlMode === 'sequence';

const EXEC_ENV_MODE = urlMode || localStorage.getItem('fullhand_mode') || window.EXEC_ENV_MODE || 'debug';
console.log(`🎮 Execution Environment Mode: ${EXEC_ENV_MODE}`);
console.log(`🔗 Coming from lattice: ${FROM_LATTICE}`);

// Hide debug UI in sequence mode, but show sequence buttons
if (EXEC_ENV_MODE === 'sequence') {
 const debugMenu = document.getElementById('debug-menu');
 const debugRestore = document.getElementById('debug-menu-restore');
 const gizmoToolbar = document.getElementById('gizmo-toolbar');
 const sequenceButtons = document.getElementById('sequence-buttons');

 if (debugMenu) debugMenu.style.display = 'none';
 if (debugRestore) debugRestore.style.display = 'none';
 if (gizmoToolbar) gizmoToolbar.style.display = 'none';
 if (sequenceButtons) sequenceButtons.style.display = 'block';

 console.log('? Sequence mode: Debug UI hidden, sequence buttons visible');
}

 // ===== Prototype Overlay Sequencing (UI + ASCII + Media) =====
// Old staging UI JavaScript removed - replaced by sequence buttons in debug menu

 // ===== Cursor Glitch Effect =====
 let cursorGlitchState = 0; // 0: normal, 1: corrupted, 2: emoji
 let cursorGlitchInterval;
 
 function startCursorGlitch() {
 const cursors = [
 'pointer', // Normal
 'url("data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'32\' height=\'32\'%3E%3Cpath d=\'M2,2 L2,28 L12,18 L18,28 L22,26 L16,16 L28,16 Z\' fill=\'%23ff0000\' opacity=\'0.3\'/%3E%3C/svg%3E") 2 2, pointer', // Corrupted red
 'url("data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'32\' height=\'32\'%3E%3Ctext x=\'4\' y=\'24\' font-size=\'24\'%3E?%3C/text%3E%3C/svg%3E") 16 16, pointer' // Hand emoji
 ];
 
 cursorGlitchInterval = setInterval(() => {
 if (Math.random() < 0.15) { // 15% chance to glitch
 const glitchType = Math.floor(Math.random() * 3);
 document.body.style.cursor = cursors[glitchType];
 
 // Quick flash between states
 setTimeout(() => {
 document.body.style.cursor = cursors[(glitchType + 1) % 3];
 }, 50);
 
 setTimeout(() => {
 document.body.style.cursor = cursors[0]; // Back to normal
 }, 150);
 }
 }, 200);
 }
 
 function stopCursorGlitch() {
 if (cursorGlitchInterval) {
 clearInterval(cursorGlitchInterval);
 document.body.style.cursor = 'auto';
 }
 }

// ===== Scene Setup =====
const renderer = new THREE.WebGLRenderer({ antialias:true, preserveDrawingBuffer: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
 renderer.toneMappingExposure = 1.0;
 renderer.physicallyCorrectLights = true;
 renderer.outputColorSpace = THREE.SRGBColorSpace;
 document.getElementById('app').appendChild(renderer.domElement);

 const scene = new THREE.Scene();
 scene.background = new THREE.Color(0x0a0a0a);
 scene.fog = new THREE.FogExp2(0x0a0a0a, 0.03);

 const pmrem = new THREE.PMREMGenerator(renderer);
 const env = pmrem.fromScene(new RoomEnvironment(), 0.04).texture;
 scene.environment = env;

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 100);
camera.position.set(6, 2.5, -8); // Raised Y and pushed back Z to see Celli better

 const controls = new OrbitControls(camera, renderer.domElement);
 controls.target.set(6, 8, 22); // Looking up at Celli's upper body
 controls.enableDamping = true;
 controls.update();

 // Post-processing
 const composer = new EffectComposer(renderer);
 const mainRenderPass = new RenderPass(scene, camera);
 composer.addPass(mainRenderPass);

 const bloomPass = new UnrealBloomPass(
 new THREE.Vector2(innerWidth, innerHeight),
 0.4, // Reduced strength from 0.6
 0.4, // Reduced radius from 0.6
 0.95 // Higher threshold from 0.9 (less blooms)
 );
 composer.addPass(bloomPass);

 const fxaaPass = new ShaderPass(FXAAShader);
 fxaaPass.material.uniforms['resolution'].value.set(1 / innerWidth, 1 / innerHeight);
 composer.addPass(fxaaPass);

 // Lighting
 const al = new THREE.AmbientLight(0x1a1a1a, 0.15);
 scene.add(al);
 const hl = new THREE.HemisphereLight(0xddeeff,0x101016,0.2);
 scene.add(hl);
 
 const dl = new THREE.DirectionalLight(0xffffff, 0.9);
 dl.position.set(6,10,4);
 dl.castShadow = true;
 dl.shadow.mapSize.width = 2048;
 dl.shadow.mapSize.height = 2048;
 dl.shadow.camera.left = -10;
 dl.shadow.camera.right = 20;
 dl.shadow.camera.top = 10;
 dl.shadow.camera.bottom = -5;
 dl.shadow.camera.near = 0.5;
 dl.shadow.camera.far = 30;
 dl.shadow.bias = -0.0001; // Within valid range
 scene.add(dl);
 
 const rimLight = new THREE.DirectionalLight(0x4466aa, 0.3);
 rimLight.position.set(-5, 3, -5);
 scene.add(rimLight);

 const spotLight = new THREE.SpotLight(0xffe4c4, 4.0);
 spotLight.position.set(8, 16, 6);
 spotLight.angle = Math.PI / 6.5;
 spotLight.penumbra = 1.0;
 spotLight.decay = 1.0;
 spotLight.distance = 44;
 spotLight.castShadow = true;
 spotLight.shadow.mapSize.width = 2048;
 spotLight.shadow.mapSize.height = 2048;
 spotLight.shadow.bias = -0.0005; // Within valid range
 scene.add(spotLight);
 scene.add(spotLight.target);

 // Ground plane
 const ground = new THREE.Mesh(
 new THREE.PlaneGeometry(50, 50),
 new THREE.MeshStandardMaterial({color:0x0a0a0a, roughness:0.9, metalness:0.1})
 );
 ground.rotation.x = -Math.PI / 2;
 ground.receiveShadow = true;
 scene.add(ground);

 // ===== Taunt.mp4 Curved Skybox Pane =====
 let tauntSkybox = null;
 let tauntVideo = null;
 let tauntVideos = ['taunt.mp4', 'taunt2.mp4', 'taunt3.mp4']; // All videos with "taunt" in filename
 let currentTauntIndex = 0;
 window.tauntVideos = tauntVideos; // Expose globally
 window.currentTauntIndex = currentTauntIndex;
 window.tauntVideo = null; // Expose video globally
 window.tauntSkybox = null; // Expose skybox globally
 
 function createTauntSkybox() {
   // Create video element
   tauntVideo = document.createElement('video');
   // Use full path to video
   tauntVideo.src = '/static/video/' + tauntVideos[currentTauntIndex];
   tauntVideo.loop = true;
   tauntVideo.muted = true;
   tauntVideo.playsInline = true;
   tauntVideo.crossOrigin = 'anonymous';
  // Slow playback by 30%
  tauntVideo.playbackRate = 0.7;
  
  console.log('[TauntSkybox] Loading video:', tauntVideo.src);
   
   // Start playing when loaded
   tauntVideo.addEventListener('loadeddata', () => {
     tauntVideo.play().catch(err => console.warn('Taunt video autoplay blocked:', err));
   });
   
   // Load video
   tauntVideo.load();
   
   // Create video texture
   const videoTexture = new THREE.VideoTexture(tauntVideo);
   videoTexture.minFilter = THREE.LinearFilter;
   videoTexture.magFilter = THREE.LinearFilter;
   videoTexture.format = THREE.RGBFormat;
   
  // Create curved plane geometry with pincushion deformation - BIGGER
  const width = 80;
  const height = 60;
  const segments = 64;
   const curveGeo = new THREE.PlaneGeometry(width, height, segments, segments);
   
   // Apply pincushion distortion to vertices
   const positions = curveGeo.attributes.position;
   const pincushionStrength = 0.3;
   const curveDepth = 8;
   
   for (let i = 0; i < positions.count; i++) {
     const x = positions.getX(i);
     const y = positions.getY(i);
     
     // Normalize coordinates to -1...1
     const nx = (x / width) * 2;
     const ny = (y / height) * 2;
     
     // Calculate distance from center
     const dist = Math.sqrt(nx * nx + ny * ny);
     
     // Pincushion formula: pull vertices inward based on distance
     const pincushion = 1 + pincushionStrength * dist * dist;
     const newX = x / pincushion;
     const newY = y / pincushion;
     
     // Add cylindrical curve (Z-axis curvature)
     const curveAmount = Math.pow(Math.abs(nx), 2) * curveDepth;
     const newZ = -curveAmount;
     
     positions.setXYZ(i, newX, newY, newZ);
   }
   
   positions.needsUpdate = true;
   curveGeo.computeVertexNormals();
   
   // Create frame material (dark metallic)
   const frameMaterial = new THREE.MeshStandardMaterial({
     color: 0x1a1a1a,
     metalness: 0.8,
     roughness: 0.3,
     emissive: 0x0a0a0a,
     emissiveIntensity: 0.2
   });
   
   // Create video material
   const videoMaterial = new THREE.MeshBasicMaterial({
     map: videoTexture,
     side: THREE.DoubleSide,
     toneMapped: false
   });
   
   // Create video mesh
   const videoMesh = new THREE.Mesh(curveGeo, videoMaterial);
   
   // Create frame border using tubes
   const frameThickness = 0.3;
   const frameDepth = 0.5;
   const frameGroup = new THREE.Group();
   
   // Top frame
   const topFrame = new THREE.Mesh(
     new THREE.BoxGeometry(width + frameThickness * 2, frameThickness, frameDepth),
     frameMaterial
   );
   topFrame.position.set(0, height / 2 + frameThickness / 2, 0);
   frameGroup.add(topFrame);
   
   // Bottom frame
   const bottomFrame = new THREE.Mesh(
     new THREE.BoxGeometry(width + frameThickness * 2, frameThickness, frameDepth),
     frameMaterial
   );
   bottomFrame.position.set(0, -height / 2 - frameThickness / 2, 0);
   frameGroup.add(bottomFrame);
   
   // Left frame
   const leftFrame = new THREE.Mesh(
     new THREE.BoxGeometry(frameThickness, height, frameDepth),
     frameMaterial
   );
   leftFrame.position.set(-width / 2 - frameThickness / 2, 0, 0);
   frameGroup.add(leftFrame);
   
   // Right frame
   const rightFrame = new THREE.Mesh(
     new THREE.BoxGeometry(frameThickness, height, frameDepth),
     frameMaterial
   );
   rightFrame.position.set(width / 2 + frameThickness / 2, 0, 0);
   frameGroup.add(rightFrame);
   
   // Combine video and frame
   tauntSkybox = new THREE.Group();
   tauntSkybox.add(videoMesh);
   tauntSkybox.add(frameGroup);
   
   // Store video mesh for texture updates
   tauntSkybox.userData.videoMesh = videoMesh;
   tauntSkybox.userData.videoTexture = videoTexture;
   
   // Position skybox behind everything
   tauntSkybox.position.set(0, 12, 50);
   tauntSkybox.visible = false; // Hidden until scale mode is activated
   
   scene.add(tauntSkybox);
   
   // Expose globally
   window.tauntVideo = tauntVideo;
   window.tauntSkybox = tauntSkybox;
   
   console.log('🎬 Taunt skybox created with video:', tauntVideos[currentTauntIndex]);
 }
 
 // Function to cycle to next taunt video
 function cycleTauntVideo() {
   console.log('[TauntCycle] cycleTauntVideo called');
   console.log('[TauntCycle] window.tauntVideo exists:', !!window.tauntVideo);
   console.log('[TauntCycle] window.tauntSkybox exists:', !!window.tauntSkybox);
   
   if (!window.tauntVideo || !window.tauntSkybox) {
     console.error('[TauntCycle] Cannot cycle - video or skybox not found');
     return;
   }
   
   // Increment index
   const oldIndex = currentTauntIndex;
   currentTauntIndex = (currentTauntIndex + 1) % tauntVideos.length;
   window.currentTauntIndex = currentTauntIndex; // Update global
   const newVideoSrc = tauntVideos[currentTauntIndex];
   
   console.log('[TauntCycle] 🎬 Cycling from', tauntVideos[oldIndex], 'to', newVideoSrc);
   console.log('[TauntCycle] Index:', oldIndex, '->', currentTauntIndex, '/', tauntVideos.length);
   console.log('[TauntCycle] Pocket Dimension active:', window.pocketDimensionActive);
   console.log('[TauntCycle] Pocket video screen exists:', !!window.pocketVideoScreen);
   
   // Update video source with full path
   const fullPath = '/static/video/' + newVideoSrc;
   window.tauntVideo.src = fullPath;
   console.log('[TauntCycle] Updated src to:', fullPath);
   
   // Load and play
   window.tauntVideo.load();
   console.log('[TauntCycle] Called load() on video');
   
   // Play when loaded
   window.tauntVideo.addEventListener('loadeddata', () => {
     console.log('[TauntCycle] Video loaded - attempting to play');
     window.tauntVideo.play()
       .then(() => {
         console.log('[TauntCycle] ✅ Video playing');
         // If in Pocket Dimension, ensure the texture updates
         if (window.pocketDimensionActive && window.pocketVideoScreen) {
           console.log('[TauntCycle] 📺 Pocket Dimension detected - video texture will update automatically');
         }
       })
       .catch(err => console.warn('[TauntCycle] ❌ Autoplay blocked:', err));
   }, { once: true });
   
   // Show notification
   showDialogue(`🎬 Now playing: ${newVideoSrc.replace('.mp4', '')} (${currentTauntIndex + 1}/${tauntVideos.length})`, 3000);
 }
 
 // Expose globally for debugging and external access
 window.cycleTauntVideo = cycleTauntVideo;
 
 // Function to apply/remove voxelization effect to skybox video
 let skyboxVoxelized = false;
 let skyboxOriginalMaterial = null;
 let voxelCanvas = null;
 let voxelCtx = null;
 let voxelTexture = null;
 let voxelAnimationId = null;
 window.skyboxVoxelized = false; // Expose globally for pocket dimension
 window.voxelTexture = null; // Expose voxel texture globally
 
 function applyVoxelizationToSkybox(enable) {
   if (!tauntSkybox || !tauntSkybox.userData.videoMesh) {
     console.warn('[Voxelizer] Cannot apply effect - skybox not found');
     return;
   }
   
   const videoMesh = tauntSkybox.userData.videoMesh;
   const videoTexture = tauntSkybox.userData.videoTexture;
   
   if (enable && !skyboxVoxelized) {
     console.log('[Voxelizer] Applying real voxelization to skybox video');
     
     // Create emission spark from skybox position
     try {
       const sourcePos = new THREE.Vector3();
       tauntSkybox.getWorldPosition(sourcePos);
       
       const sparkGeo = new THREE.SphereGeometry(1.5, 16, 16);
       const sparkMat = new THREE.MeshBasicMaterial({ 
         color: 0x43e97b, 
         transparent: true, 
         opacity: 0.9 
       });
       const spark = new THREE.Mesh(sparkGeo, sparkMat);
       spark.position.copy(sourcePos);
       scene.add(spark);
       
       let t = 0;
       (function pulse() {
         t += 0.08;
         spark.scale.setScalar(1 + Math.sin(t * 2) * 0.4 + 0.5);
         spark.material.opacity = Math.max(0, 0.9 - t * 0.12);
         if (spark.material.opacity > 0.05) {
           requestAnimationFrame(pulse);
         } else {
           scene.remove(spark);
         }
       })();
       
       console.log('[Voxelizer] Emission spark created at skybox position:', sourcePos);
     } catch (e) {
       console.warn('[Voxelizer] Spark emission failed:', e);
     }
     
     // Store original material
     skyboxOriginalMaterial = videoMesh.material;
     
     // Create canvas for voxelization
     voxelCanvas = document.createElement('canvas');
     const voxelSize = 12; // Size of each voxel block in pixels
     voxelCanvas.width = Math.ceil(1920 / voxelSize) * voxelSize;
     voxelCanvas.height = Math.ceil(1080 / voxelSize) * voxelSize;
     voxelCtx = voxelCanvas.getContext('2d', { willReadFrequently: true });
     
     // Create texture from canvas
     voxelTexture = new THREE.CanvasTexture(voxelCanvas);
     voxelTexture.minFilter = THREE.NearestFilter;
     voxelTexture.magFilter = THREE.NearestFilter;
     window.voxelTexture = voxelTexture; // Expose globally
     
     // Create material with voxel texture
     const voxelMaterial = new THREE.MeshBasicMaterial({
       map: voxelTexture,
       side: THREE.DoubleSide,
       toneMapped: false
     });
     
     videoMesh.material = voxelMaterial;
     
     // Start voxelization animation loop
     function voxelizeFrame() {
       if (!skyboxVoxelized || !window.tauntVideo) return;
       
       // Draw video to canvas at reduced resolution
       voxelCtx.drawImage(window.tauntVideo, 0, 0, voxelCanvas.width, voxelCanvas.height);
       
       // Get image data
       const imageData = voxelCtx.getImageData(0, 0, voxelCanvas.width, voxelCanvas.height);
       const pixels = imageData.data;
       
       // Voxelize: sample grid and quantize colors
       const voxelGrid = Math.ceil(voxelCanvas.width / voxelSize);
       const voxelRows = Math.ceil(voxelCanvas.height / voxelSize);
       
       // Clear canvas
       voxelCtx.clearRect(0, 0, voxelCanvas.width, voxelCanvas.height);
       
       // Draw voxels
       for (let row = 0; row < voxelRows; row++) {
         for (let col = 0; col < voxelGrid; col++) {
           // Sample center of voxel block
           const centerX = col * voxelSize + Math.floor(voxelSize / 2);
           const centerY = row * voxelSize + Math.floor(voxelSize / 2);
           const idx = (centerY * voxelCanvas.width + centerX) * 4;
           
           if (idx + 2 < pixels.length) {
             // Quantize color to limited palette (8 levels per channel)
             const r = Math.floor((pixels[idx] / 255) * 7) * 36;
             const g = Math.floor((pixels[idx + 1] / 255) * 7) * 36;
             const b = Math.floor((pixels[idx + 2] / 255) * 7) * 36;
             
             // Draw voxel block
             voxelCtx.fillStyle = `rgb(${r}, ${g}, ${b})`;
             voxelCtx.fillRect(col * voxelSize, row * voxelSize, voxelSize, voxelSize);
             
             // Optional: draw voxel outline for more defined look
             voxelCtx.strokeStyle = `rgba(0, 0, 0, 0.3)`;
             voxelCtx.lineWidth = 1;
             voxelCtx.strokeRect(col * voxelSize, row * voxelSize, voxelSize, voxelSize);
           }
         }
       }
       
       // Update texture
       voxelTexture.needsUpdate = true;
       
       // Continue loop
       voxelAnimationId = requestAnimationFrame(voxelizeFrame);
     }
     
     voxelizeFrame();
     
     skyboxVoxelized = true;
     window.skyboxVoxelized = true; // Update global
     
     showDialogue('🎮 Voxelization engine applied to skybox', 2000);
     
   } else if (!enable && skyboxVoxelized) {
     console.log('[Voxelizer] Removing voxelization effect from skybox');
     
     // Stop animation loop
     if (voxelAnimationId) {
       cancelAnimationFrame(voxelAnimationId);
       voxelAnimationId = null;
     }
     
     // Create emission spark when disabling (different color)
     try {
       const sourcePos = new THREE.Vector3();
       tauntSkybox.getWorldPosition(sourcePos);
       
       const sparkGeo = new THREE.SphereGeometry(1.2, 16, 16);
       const sparkMat = new THREE.MeshBasicMaterial({ 
         color: 0xff6a6a, 
         transparent: true, 
         opacity: 0.8 
       });
       const spark = new THREE.Mesh(sparkGeo, sparkMat);
       spark.position.copy(sourcePos);
       scene.add(spark);
       
       let t = 0;
       (function pulse() {
         t += 0.1;
         spark.scale.setScalar(1 + Math.sin(t * 3) * 0.3 + 0.3);
         spark.material.opacity = Math.max(0, 0.8 - t * 0.15);
         if (spark.material.opacity > 0.05) {
           requestAnimationFrame(pulse);
         } else {
           scene.remove(spark);
         }
       })();
     } catch (e) {
       console.warn('[Voxelizer] Spark emission failed:', e);
     }
     
     // Restore original material
     if (skyboxOriginalMaterial) {
       videoMesh.material = skyboxOriginalMaterial;
     }
     
     // Clean up voxel resources
     if (voxelTexture) voxelTexture.dispose();
     voxelCanvas = null;
     voxelCtx = null;
     voxelTexture = null;
     window.voxelTexture = null; // Clear global
     
     skyboxVoxelized = false;
     window.skyboxVoxelized = false; // Update global
     
     showDialogue('🎮 Voxelization effect removed', 2000);
   }
 }
 
 // Initialize taunt skybox
 createTauntSkybox();

 // Add click handler to cycle taunt videos
 renderer.domElement.addEventListener('click', (e) => {
   // Debug logging
   console.log('[TauntCycle] Click detected - skybox exists:', !!window.tauntSkybox, 'visible:', window.tauntSkybox?.visible);
   
   if (!window.tauntSkybox || !window.tauntSkybox.visible) {
     console.log('[TauntCycle] Skybox not available or not visible - skipping');
     return;
   }
   
   // Use raycaster to check if skybox was clicked
   const mouse = new THREE.Vector2();
   const rect = renderer.domElement.getBoundingClientRect();
   mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
   mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
   
   const raycaster = new THREE.Raycaster();
   raycaster.setFromCamera(mouse, camera);
   
   // Check intersection with taunt skybox
   const intersects = raycaster.intersectObjects(window.tauntSkybox.children, true);
   console.log('[TauntCycle] Raycaster check - intersects:', intersects.length);
   
   if (intersects.length > 0) {
     console.log('[TauntCycle] 🎬 Taunt skybox clicked - cycling video');
     cycleTauntVideo();
   } else {
     // Allow cycling even without raycaster hit if skybox is visible (for easier access)
     console.log('[TauntCycle] No intersection but skybox visible - cycling anyway');
     cycleTauntVideo();
   }
 });

 // ===== State Management =====
 let keyboardGroup, characterGroup, voxelHeadGroup;
 let characterBust, characterUnifiedMesh, characterPoseSpheres = [];
 let characterZSpheres = []; // Store ZSphere data for regeneration
 let transformControl;
 let skinMat; // Shared skin material
 let staticFingers = []; // Non-clicking fingers
 let keys = []; // Keyboard keys (for finger interaction)
let rightHandGroup, leftHandGroup, handsGroup; // Hand hierarchy
let celliAvatarGroup; // Combined head + body
let microCityGroups = []; // Micro buildings on keys
let microCityVisible = false;
let cameraSlowdownFactor = 1.0;

// Scale Mode / Frame of Reference
let scaleModeEnabled = false;
let frameOfReference = null; // The 3D frame mesh group
let frameMinimized = false;
let scaleObjects = []; // 3D objects that spawn in Scale mode
let frameDist = 0.9; // Distance in front of camera
let minimizeButton = null; // Diegetic UI circle button

// Drop functionality - Smooth dolly/zoom animation
let lastViewedKey = null; // Track most recently viewed key
let isDropping = false; // Track if drop animation is active
let dropProgress = 0; // 0-1 animation progress
let dropStartTime = 0; // Animation start timestamp
let dropDuration = 3000; // 3 second drop animation (ms)
let dropStartPos = new THREE.Vector3(); // Starting camera position
let dropTargetPos = new THREE.Vector3(); // Target camera position
let dropStartScale = 1.0; // Starting camera scale
let dropTargetScale = 1.0; // Target camera scale (normal, no scaling)
let originalFogDensity = null; // Store original fog density
let dropKeyTarget = null; // Track key we're dropping onto
let dropModeActive = false; // Track if in exploration mode after landing
let dropKeys = { w: false, a: false, s: false, d: false, shift: false, space: false }; // WASD controls
let dropVelocity = 0; // Velocity for gravity-based dropping
let targetDropHeight = null; // Target height when dropping with gravity
 
 // Fingerprint controls
 const FP = { enabled: true, strength: 1.0, scale: 1.0, _applied: '' };
 
 // Finger reference (set by loadFinger)
 let finger = null;
 
 // ===== Dust Particle System =====
 function makeDustTexture(){
 const c=document.createElement('canvas');
 c.width=64; c.height=64;
 const ctx=c.getContext('2d');
 ctx.clearRect(0,0,64,64);
 ctx.globalAlpha = 0.4;
 const centerX = 32, centerY = 32;
 for(let i=0; i<5; i++){
 const offsetX = (Math.random()-0.5)*12;
 const offsetY = (Math.random()-0.5)*12;
 const radius = 8 + Math.random()*8;
 const gradient=ctx.createRadialGradient(
 centerX+offsetX, centerY+offsetY, 0,
 centerX+offsetX, centerY+offsetY, radius
 );
 gradient.addColorStop(0,'rgba(200,200,200,0.6)');
 gradient.addColorStop(0.5,'rgba(180,180,180,0.3)');
 gradient.addColorStop(1,'rgba(160,160,160,0)');
 ctx.fillStyle=gradient;
 ctx.fillRect(0,0,64,64);
 }
 return new THREE.CanvasTexture(c);
 }

 const dustTexture = makeDustTexture();
 let ambientDustParticles = [];
 
 function createDustParticlesForKey(key) {
 const dustParticles = [];
 for (let i = 0; i < 3; i++) {
 const dustGeo = new THREE.PlaneGeometry(0.02, 0.02);
 const dustMat = new THREE.MeshBasicMaterial({
 map: dustTexture,
 transparent: true,
 opacity: 0.3,
 depthWrite: false,
 blending: THREE.AdditiveBlending
 });
 const dust = new THREE.Mesh(dustGeo, dustMat);
 dust.position.set(
 key.position.x + (Math.random() - 0.5) * 0.3,
 key.position.y + 0.35,
 key.position.z + (Math.random() - 0.5) * 0.3
 );
 dust.userData = {
 baseX: dust.position.x,
 baseZ: dust.position.z,
 freq: 0.5 + Math.random() * 1.5,
 phase: Math.random() * Math.PI * 2
 };
 key.add(dust);
 dustParticles.push(dust);
 }
 return dustParticles;
 }
 
 function createAmbientDust() {
 const count = 80;
 for (let i = 0; i < count; i++) {
 const dustGeo = new THREE.PlaneGeometry(0.03, 0.03);
 const dustMat = new THREE.MeshBasicMaterial({
 map: dustTexture,
 transparent: true,
 opacity: 0.15,
 depthWrite: false,
 blending: THREE.AdditiveBlending
 });
 const dust = new THREE.Mesh(dustGeo, dustMat);
 dust.position.set(
 Math.random() * 20 - 2,
 Math.random() * 8 + 2,
 Math.random() * 10 - 2
 );
 dust.userData = {
 velY: -0.003 - Math.random() * 0.005,
 velX: (Math.random() - 0.5) * 0.002,
 velZ: (Math.random() - 0.5) * 0.002,
 freq: 0.3 + Math.random() * 1.0,
 phase: Math.random() * Math.PI * 2,
 swayAmount: 0.5 + Math.random() * 1.5
 };
 scene.add(dust);
 ambientDustParticles.push(dust);
 }
 }
 
 // ===== Key Label Textures =====
 // Create color and bump textures for key labels with engrave effect
 function makeLabelTextures(text){
 if (!text || text === 'Space') return { map:null, bump:null };
 const size=256;
 const base=document.createElement('canvas'); base.width=size; base.height=size;
 const bump=document.createElement('canvas'); bump.width=size; bump.height=size;
 const cctx=base.getContext('2d'); const bctx=bump.getContext('2d');
 // Background color
 cctx.fillStyle='#d7ceb2'; cctx.fillRect(0,0,size,size);
 // Bump base (mid-gray)
 bctx.fillStyle='rgb(200,200,200)'; bctx.fillRect(0,0,size,size);
 // dynamic font size
 let fontSize=120; if(['Shift','Caps','Backspace'].includes(text)) fontSize=80; if(text.length>=3 && fontSize===120) fontSize=100;
 // Draw text on color map
 cctx.fillStyle='#222'; cctx.font=`bold ${fontSize}px sans-serif`; cctx.textAlign='center'; cctx.textBaseline='middle'; cctx.fillText(text,size/2,size/2);
 // Draw darker text to bump to engrave (lower where text appears)
 bctx.fillStyle='rgb(120,120,120)'; bctx.font=`bold ${fontSize}px sans-serif`; bctx.textAlign='center'; bctx.textBaseline='middle'; bctx.fillText(text,size/2,size/2);
 const mapTex=new THREE.CanvasTexture(base); mapTex.colorSpace=THREE.SRGBColorSpace;
 const bumpTex=new THREE.CanvasTexture(bump);
 return { map: mapTex, bump: bumpTex };
 }
 
 // ===== Initialize Scene Elements (hidden initially) =====
 function createKey(width, depth, height, label) {
 const segmentsX = Math.max(16, Math.ceil(width*20));
 const segmentsZ = Math.max(16, Math.ceil(depth*20));
 const geo = new THREE.BoxGeometry(width, height, depth, segmentsX, 8, segmentsZ);
 const pos = geo.attributes.position;
 const v = new THREE.Vector3();
 const hx = width/2, hy = height/2, hz = depth/2;
 
 if (hx <= 0 || hy <= 0 || hz <= 0) {
 return new THREE.Mesh(geo, new THREE.MeshStandardMaterial({color:0xd7ceb2}));
 }
 
 for (let i = 0; i < pos.count; i++) {
 v.fromBufferAttribute(pos, i);
 const ty = (v.y + hy) / (2 * hy);
 const taper = 0.28, concave = 0.06;
 const tilt = 0.12;
 
 if (v.y > 0) {
 const scale = 1 - taper * ty;
 v.x *= scale; 
 v.z *= scale;
 v.y -= tilt * (v.z / hz) * ty;
 
 const divisorX = hx * (1 - taper);
 const divisorZ = hz * (1 - taper);
 if (divisorX > 0.001 && divisorZ > 0.001) {
 const nx = v.x / divisorX;
 const nz = v.z / divisorZ;
 const r2 = Math.min(nx * nx + nz * nz, 1);
 const concaveAmount = Math.min(width, depth) * 0.06;
 v.y -= concaveAmount * (1 - r2) ** 1.5;
 }
 }
 
 pos.setXYZ(i, v.x, v.y, v.z);
 }
 geo.computeVertexNormals();

 const hueShift = (Math.random() - 0.5) * 0.02;
 const lightnessShift = (Math.random() - 0.5) * 0.05;
 const baseColor = new THREE.Color(0xd7ceb2);
 baseColor.offsetHSL(hueShift, 0, lightnessShift);
 const sideColor = new THREE.Color(0xc5b89f);
 sideColor.offsetHSL(hueShift, 0, lightnessShift);

 // Create label textures with engrave effect
 const { map:labelMap, bump:labelBump } = makeLabelTextures(label);
 const topMat = labelMap ? 
 new THREE.MeshStandardMaterial({color:baseColor,roughness:0.6,metalness:0.06,envMapIntensity:1.1,map:labelMap,bumpMap:labelBump,bumpScale:-0.008}) : 
 new THREE.MeshStandardMaterial({color:baseColor,roughness:0.6,metalness:0.06,envMapIntensity:1.1});
 const sideMat = new THREE.MeshStandardMaterial({
 color: sideColor,
 roughness: 0.8,
 metalness: 0.05
 });
 const mats = [sideMat, sideMat, topMat, sideMat, sideMat, sideMat];
 const mesh = new THREE.Mesh(geo, mats);
 mesh.castShadow = true;
 mesh.receiveShadow = true;
 mesh.userData = { baseY: 0, velY: 0, pressed: false, label };

 return mesh;
 }

 function initializeKeyboard() {
 keyboardGroup = new THREE.Group();
 keyboardGroup.visible = false;
 
 const ANSI60 = [
 ['Esc','1','2','3','4','5','6','7','8','9','0','-','=','Backspace'],
 ['Tab','Q','W','E','R','T','Y','U','I','O','P','[',']','\\'],
 ['Caps','A','S','D','F','G','H','J','K','L',';','"','Enter'],
 ['Shift','Z','X','C','V','B','N','M',',','.','/','Shift'],
 ['Ctrl','Win','Alt','Space','Alt','Fn','Menu','Ctrl']
 ];

 const keyWidths = [
 [1,1,1,1,1,1,1,1,1,1,1,1,1,2],
 [1.5,1,1,1,1,1,1,1,1,1,1,1,1,1.5],
 [1.75,1,1,1,1,1,1,1,1,1,1,1,2.25],
 [2.25,1,1,1,1,1,1,1,1,1,1,2.75],
 [1.25,1.25,1.25,6.25,1.25,1.25,1.25,1.25]
 ];

 // Base plate
 const basePlate = new THREE.Mesh(
 new THREE.BoxGeometry(15.5, 0.5, 5.5),
 new THREE.MeshStandardMaterial({color:0xb8a68f, roughness:0.7, metalness:0.05})
 );
 basePlate.position.set(7.5, 0.25, 2.5);
 basePlate.castShadow = true;
 basePlate.receiveShadow = true;
 keyboardGroup.add(basePlate);

 const unit = 1.0, gap = 0.05;
 let zOff = 0;
 keys = []; // Reset global keys array

 for (let r = 0; r < ANSI60.length; r++) {
 const row = ANSI60[r];
 const widths = keyWidths[r];
 let xOff = 0;
 for (let i = 0; i < row.length; i++) {
 const w = widths[i];
 const label = row[i];
 const isSpace = label === 'Space';
 const key = createKey(w * unit - gap, unit - gap * (isSpace ? 0.9 : 1), 0.7, label);
 const keyX = xOff + w * 0.5;
 const keyZ = zOff;
 key.position.set(keyX, 0.9, keyZ);
 key.userData.baseY = 0.9;
 keyboardGroup.add(key);
 
 // Add dust particles to key
 key.userData.dustParticles = createDustParticlesForKey(key);
 
 keys.push(key);
 xOff += w;
 }
 zOff += 1;
 }
 
 scene.add(keyboardGroup);
 
 // Create ambient dust particles
 createAmbientDust();
 
 // Aim spotlight at keyboard center
 const bbox = new THREE.Box3().setFromObject(keyboardGroup);
 const kbCenter = bbox.getCenter(new THREE.Vector3());
 kbCenter.y = bbox.min.y + 0.7;
 spotLight.target.position.copy(kbCenter);
 spotLight.target.updateMatrixWorld();

 // Add volumetric ray billboard
 const rayLength = 22;
 const rayHeight = 10;
 const rayGeo = new THREE.PlaneGeometry(rayLength, rayHeight);
 const rayMat = new THREE.MeshBasicMaterial({
 map: makeRayTexture(),
 transparent: true,
 opacity: 0.28,
 depthWrite: false,
 blending: THREE.AdditiveBlending,
 color: 0xffe9cc
 });
 const rayBillboard = new THREE.Mesh(rayGeo, rayMat);
 rayBillboard.position.copy(spotLight.position);
 rayBillboard.lookAt(spotLight.target.position);
 rayBillboard.rotateY(Math.PI/2);
 rayBillboard.position.y -= 2.5;
 keyboardGroup.add(rayBillboard);
 
 // Create ambient dust particles
 createAmbientDust();
 
 // Create micro cities on keys (after a short delay to ensure keys are ready)
 setTimeout(() => {
 try {
 createMicroCitiesOnKeys();
 } catch (err) {
 console.warn('Micro cities creation failed:', err);
 }
 }, 100);
 
 // Integrate full finger system from kb.html
 loadFinger();
 }
 
 // ===== Micro City LOD System =====
 function createBuildingTexture(floors = 8, variant = 0) {
 console.log(`[MicroCity] Creating building texture: ${floors} floors, variant ${variant}`);
 const canvas = document.createElement('canvas');
 canvas.width = 64;
 canvas.height = 128;
 const ctx = canvas.getContext('2d');
 
 // Building body with color variations
 const colors = [
 ['#d0d4db', '#a8adb5'], // Gray
 ['#c8d4e0', '#a0b0c0'], // Blue-gray
 ['#d8d0c8', '#b0a8a0'], // Tan
 ['#e0d4d0', '#c0b0a8'] // Pink-gray
 ];
 const colorPair = colors[variant % colors.length];
 
 const gradient = ctx.createLinearGradient(0, 0, 0, 128);
 gradient.addColorStop(0, colorPair[0]);
 gradient.addColorStop(1, colorPair[1]);
 ctx.fillStyle = gradient;
 ctx.fillRect(0, 0, 64, 128);
 
 // Windows
 const windowWidth = 8;
 const windowHeight = 10;
 const windowMarginX = 4;
 const windowMarginY = 6;
 const windowsPerRow = 3;
 const windowSpacingX = (64 - windowMarginX * 2 - windowWidth * windowsPerRow) / (windowsPerRow - 1);
 const floorHeight = 128 / floors;
 
 for (let floor = 0; floor < floors; floor++) {
 const floorY = floor * floorHeight + windowMarginY;
 for (let col = 0; col < windowsPerRow; col++) {
 const x = windowMarginX + col * (windowWidth + windowSpacingX);
 const y = floorY;
 
 // Window background (lit or unlit based on variant)
 const litChance = 0.3 + (variant * 0.1);
 const isLit = Math.random() > litChance;
 ctx.fillStyle = isLit ? '#ffe9a0' : '#1a2030';
 ctx.fillRect(x, y, windowWidth, windowHeight);
 
 // Window frame
 ctx.strokeStyle = '#4a5568';
 ctx.lineWidth = 1;
 ctx.strokeRect(x, y, windowWidth, windowHeight);
 
 // Window cross divider
 ctx.beginPath();
 ctx.moveTo(x + windowWidth / 2, y);
 ctx.lineTo(x + windowWidth / 2, y + windowHeight);
 ctx.moveTo(x, y + windowHeight / 2);
 ctx.lineTo(x + windowWidth, y + windowHeight / 2);
 ctx.stroke();
 }
 }
 
 // Roof detail
 ctx.fillStyle = '#8a8f97';
 ctx.fillRect(0, 0, 64, 4);
 
 const texture = new THREE.CanvasTexture(canvas);
 texture.wrapS = THREE.RepeatWrapping;
 texture.wrapT = THREE.ClampToEdgeWrapping;
 return texture;
 }
 
 function createMicroCitiesOnKeys() {
 console.log('[MicroCity] Starting micro city creation...');
 
 if (!keys || keys.length === 0) {
 console.warn('[MicroCity] No keys available for micro cities yet');
 return;
 }
 
 console.log(`[MicroCity] Creating micro cities on ${keys.length} keys...`);
 
 const buildingScale = 0.02; // Increased for better visibility
 const gridSpacing = 0.04;
 
 // Create building geometry variations (reusable)
 const buildingGeometries = [
 new THREE.BoxGeometry(buildingScale * 0.8, buildingScale * 3 * 0.7, buildingScale * 0.8), // Short
 new THREE.BoxGeometry(buildingScale * 0.8, buildingScale * 3 * 1.0, buildingScale * 0.8), // Medium
 new THREE.BoxGeometry(buildingScale * 0.8, buildingScale * 3 * 1.3, buildingScale * 0.8), // Tall
 new THREE.BoxGeometry(buildingScale * 0.8, buildingScale * 3 * 1.6, buildingScale * 0.8) // Very tall
 ];
 console.log(`[MicroCity] Created ${buildingGeometries.length} building geometry variations`);
 
 // Create texture variations with high visibility
 const buildingMaterials = [
 // 6-floor variants - brighter emissive
 new THREE.MeshStandardMaterial({ map: createBuildingTexture(6, 0), roughness: 0.5, metalness: 0.3, emissive: 0xffee99, emissiveIntensity: 0.6, transparent: false }),
 new THREE.MeshStandardMaterial({ map: createBuildingTexture(6, 1), roughness: 0.5, metalness: 0.3, emissive: 0xffee99, emissiveIntensity: 0.6, transparent: false }),
 // 8-floor variants
 new THREE.MeshStandardMaterial({ map: createBuildingTexture(8, 0), roughness: 0.5, metalness: 0.3, emissive: 0xffdd88, emissiveIntensity: 0.65, transparent: false }),
 new THREE.MeshStandardMaterial({ map: createBuildingTexture(8, 1), roughness: 0.5, metalness: 0.3, emissive: 0xffdd88, emissiveIntensity: 0.65, transparent: false }),
 // 10-floor variants
 new THREE.MeshStandardMaterial({ map: createBuildingTexture(10, 2), roughness: 0.5, metalness: 0.3, emissive: 0xffcc77, emissiveIntensity: 0.7, transparent: false }),
 new THREE.MeshStandardMaterial({ map: createBuildingTexture(10, 3), roughness: 0.5, metalness: 0.3, emissive: 0xffcc77, emissiveIntensity: 0.7, transparent: false }),
 // 12-floor variants
 new THREE.MeshStandardMaterial({ map: createBuildingTexture(12, 2), roughness: 0.5, metalness: 0.3, emissive: 0xffbb66, emissiveIntensity: 0.75, transparent: false }),
 new THREE.MeshStandardMaterial({ map: createBuildingTexture(12, 3), roughness: 0.5, metalness: 0.3, emissive: 0xffbb66, emissiveIntensity: 0.75, transparent: false })
 ];
 console.log(`[MicroCity] Created ${buildingMaterials.length} material variations`);
 
 keys.forEach((key, keyIndex) => {
 try {
 console.log(`[MicroCity] Processing key ${keyIndex + 1}/${keys.length}: ${key.userData.label}`);
 
 const cityGroup = new THREE.Group();
 cityGroup.name = `MicroCity_${key.userData.label}`;
 cityGroup.userData.buildingScale = buildingScale; // Store for later reference
 
 // Get key dimensions from bounding box
 const bbox = new THREE.Box3().setFromObject(key);
 const keyWidth = bbox.max.x - bbox.min.x;
 const keyDepth = bbox.max.z - bbox.min.z;
 const keyTop = bbox.max.y;
 
 console.log(`[MicroCity] Key "${key.userData.label}": ${keyWidth.toFixed(3)}x${keyDepth.toFixed(3)}, top at ${keyTop.toFixed(3)}`);
 
 // Create grid of buildings on key surface
 const buildingsX = Math.max(2, Math.floor(keyWidth / gridSpacing));
 const buildingsZ = Math.max(2, Math.floor(keyDepth / gridSpacing));
 
 console.log(`[MicroCity] Grid: ${buildingsX}x${buildingsZ} = ${buildingsX * buildingsZ} buildings`);
 
 const startX = -keyWidth / 2 + gridSpacing;
 const startZ = -keyDepth / 2 + gridSpacing;
 
 // Get key geometry for surface sampling
 const keyGeometry = key.geometry;
 const keyPositions = keyGeometry.getAttribute('position');
 
 // Create instanced meshes for each geometry type
 const instanceData = buildingGeometries.map(() => []);
 
 for (let i = 0; i < buildingsX; i++) {
 for (let j = 0; j < buildingsZ; j++) {
 // Pick random geometry and material
 const geoIdx = Math.floor(Math.random() * buildingGeometries.length);
 const matIdx = Math.floor(Math.random() * buildingMaterials.length);
 
 // Position on key surface with slight randomization
 const x = startX + i * gridSpacing + (Math.random() - 0.5) * gridSpacing * 0.3;
 const z = startZ + j * gridSpacing + (Math.random() - 0.5) * gridSpacing * 0.3;
 
 // Sample key surface height at this position (approximate)
 // Keys have curved tops, so we need to sample the actual geometry
 const nx = x / (keyWidth / 2);
 const nz = z / (keyDepth / 2);
 const r2 = Math.min(nx * nx + nz * nz, 1);
 const concaveDip = Math.min(keyWidth, keyDepth) * 0.06 * (1 - r2) ** 1.5;
 
 const heightVariation = 0.7 + geoIdx * 0.3;
 const buildingHeight = buildingScale * 3 * heightVariation;
 const y = buildingHeight / 2 - concaveDip + 0.001; // Follow key curve
 
 instanceData[geoIdx].push({ x, y, z, matIdx });
 }
 }
 
 // Create instanced meshes for each geometry type
 let totalInstances = 0;
 buildingGeometries.forEach((geometry, geoIdx) => {
 const instances = instanceData[geoIdx];
 if (instances.length === 0) return;
 
 totalInstances += instances.length;
 
 // Group by material
 const byMaterial = {};
 instances.forEach(inst => {
 if (!byMaterial[inst.matIdx]) byMaterial[inst.matIdx] = [];
 byMaterial[inst.matIdx].push(inst);
 });
 
 // Create instanced mesh for each material
 Object.keys(byMaterial).forEach(matIdx => {
 const insts = byMaterial[matIdx];
 const instancedMesh = new THREE.InstancedMesh(
 geometry,
 buildingMaterials[matIdx],
 insts.length
 );
 
 const matrix = new THREE.Matrix4();
 insts.forEach((inst, idx) => {
 matrix.makeTranslation(inst.x, inst.y, inst.z);
 instancedMesh.setMatrixAt(idx, matrix);
 });
 
 instancedMesh.instanceMatrix.needsUpdate = true;
 instancedMesh.castShadow = true;
 instancedMesh.receiveShadow = true;
 
 cityGroup.add(instancedMesh);
 });
 });
 
 console.log(`[MicroCity] Created ${totalInstances} building instances across ${cityGroup.children.length} instanced meshes`);
 
// Position city group relative to key (local position within keyboard group)
cityGroup.position.set(
key.position.x,
key.position.y + (bbox.max.y - bbox.min.y) / 2, // Top of key (no offset)
key.position.z
);
 cityGroup.visible = false; // Hidden by default
 
 console.log(`[MicroCity] City positioned at: (${cityGroup.position.x.toFixed(3)}, ${cityGroup.position.y.toFixed(3)}, ${cityGroup.position.z.toFixed(3)})`);
 
 keyboardGroup.add(cityGroup);
 microCityGroups.push({ key, cityGroup });
 } catch (err) {
 console.error(`[MicroCity] Error creating city for key ${keyIndex}:`, err);
 }
 });
 
 console.log(`[MicroCity] ? Completed! Created cities on ${microCityGroups.length} keys`);
 }
 
 function updateMicroCityLOD() {
 if (!keys || keys.length === 0 || microCityGroups.length === 0) return;
 if (!window.guiParams || !window.guiParams.microCity) return;
 
 const params = window.guiParams.microCity;
 
 // Check if enabled
 if (!params['Enabled']) {
 microCityGroups.forEach(({ cityGroup }) => {
 cityGroup.visible = false;
 });
 cameraSlowdownFactor = 1.0;
 controls.rotateSpeed = 0.3;
 controls.zoomSpeed = 0.5;
 return;
 }
 
 // Use raycasting to find where camera is looking at keys
 const raycaster = new THREE.Raycaster();
 const cameraDirection = new THREE.Vector3();
 camera.getWorldDirection(cameraDirection);
 raycaster.set(camera.position, cameraDirection);
 
 // Raycast against all keys
 const intersects = raycaster.intersectObjects(keys, true);
 
 let closestKey = null;
 let closestCityGroup = null;
 let intersectionPoint = null;
 let closestDist = Infinity;
 
 if (intersects.length > 0) {
 // Find the closest key we're looking at
 const hit = intersects[0];
 intersectionPoint = hit.point.clone();
 
 // Find which key we hit
 let hitKey = hit.object;
 while (hitKey.parent && !keys.includes(hitKey)) {
 hitKey = hitKey.parent;
 }
 
if (keys.includes(hitKey)) {
closestKey = hitKey;
lastViewedKey = hitKey; // Track for drop functionality
closestDist = camera.position.distanceTo(intersectionPoint);

// Find the corresponding city group
for (const { key, cityGroup } of microCityGroups) {
if (key === closestKey) {
closestCityGroup = cityGroup;
 
 // Reposition city to intersection point (convert to keyboardGroup's local space)
 const worldPos = intersectionPoint.clone();
 const localToKeyboard = keyboardGroup.worldToLocal(worldPos);
 
 cityGroup.position.set(
 localToKeyboard.x,
 localToKeyboard.y + 0.01, // Slightly above surface
 localToKeyboard.z
 );
 break;
 }
 }
 }
 }
 
// Fallback: if no intersection, find closest key to camera
if (!closestKey) {
for (const { key, cityGroup } of microCityGroups) {
const keyWorldPos = new THREE.Vector3();
key.getWorldPosition(keyWorldPos);
const dist = camera.position.distanceTo(keyWorldPos);

if (dist < closestDist) {
closestDist = dist;
closestKey = key;
lastViewedKey = key; // Track for drop functionality
closestCityGroup = cityGroup;
}
}
}
 
 // LOD threshold - show micro cities when close
 const lodThreshold = params['LOD Distance'];
 const slowdownThreshold = params['Slowdown Distance'];
 const fadeRange = params['Fade Range'];
 
 if (closestDist < lodThreshold) {
 // Enable micro cities - static placement
 const fadeIn = THREE.MathUtils.clamp((lodThreshold - closestDist) / fadeRange, 0, 1);
 
 microCityGroups.forEach(({ key, cityGroup }) => {
 if (key === closestKey) {
 cityGroup.visible = true;
 cityGroup.scale.setScalar(1.0);
 
 // Ensure buildings are visible by setting material properties
 cityGroup.traverse((child) => {
 if (child.material) {
 child.material.opacity = Math.max(0.8, fadeIn); // Always at least 80% visible
 child.material.transparent = true;
 child.visible = true;
 }
 });
 
 // Debug: Log city info
 if (params['Show City Info'] && Math.random() < 0.02) { // Log occasionally
 const worldPos = new THREE.Vector3();
 cityGroup.getWorldPosition(worldPos);
 console.log(`[MicroCity LOD] Active on key "${closestKey.userData.label}"`);
 console.log(` Distance: ${closestDist.toFixed(3)}, Fade: ${fadeIn.toFixed(2)}`);
 console.log(` City position (local): ${cityGroup.position.x.toFixed(2)}, ${cityGroup.position.y.toFixed(2)}, ${cityGroup.position.z.toFixed(2)}`);
 console.log(` City position (world): ${worldPos.x.toFixed(2)}, ${worldPos.y.toFixed(2)}, ${worldPos.z.toFixed(2)}`);
 console.log(` Intersection: ${intersectionPoint ? `(${intersectionPoint.x.toFixed(2)}, ${intersectionPoint.y.toFixed(2)}, ${intersectionPoint.z.toFixed(2)})` : 'none'}`);
 console.log(` City children: ${cityGroup.children.length} instanced meshes, visible: ${cityGroup.visible}`);
 console.log(` Slowdown threshold: ${slowdownThreshold.toFixed(3)}`);
 
 // Log building info
 if (cityGroup.children.length > 0) {
 const firstMesh = cityGroup.children[0];
 const scale = cityGroup.userData.buildingScale || 0.008;
 console.log(` Building scale: ${scale.toFixed(4)}, instances: ${firstMesh.count}`);
 console.log(` Building material opacity: ${firstMesh.material.opacity.toFixed(2)}`);
 }
 }
 } else {
 cityGroup.visible = false;
 }
 });
 
 microCityVisible = true;
 
 // Camera slowdown effect - only when VERY close (inside slowdown threshold)
 if (closestDist < slowdownThreshold) {
 const slowdownAmount = params['Camera Slowdown'];
 const slowdownFade = THREE.MathUtils.clamp((slowdownThreshold - closestDist) / (slowdownThreshold * 0.5), 0, 1);
 cameraSlowdownFactor = 1.0 - slowdownFade * slowdownAmount;
 controls.rotateSpeed = 0.3 * cameraSlowdownFactor;
 controls.zoomSpeed = 0.5 * cameraSlowdownFactor;
 } else {
 // No slowdown yet, still approaching
 cameraSlowdownFactor = 1.0;
 controls.rotateSpeed = 0.3;
 controls.zoomSpeed = 0.5;
 }
 
 // Update status indicator
 const statusEl = document.getElementById('micro-city-state');
 if (statusEl) {
 const slowInfo = closestDist < slowdownThreshold ? ` [SLOW ${((1-cameraSlowdownFactor)*100).toFixed(0)}%]` : '';
 statusEl.textContent = `Active (${(fadeIn * 100).toFixed(0)}%) - ${closestKey.userData.label}${slowInfo}`;
 statusEl.style.color = closestDist < slowdownThreshold ? '#ff4a7c' : '#4a7cff';
 }
 
 } else {
 // Disable micro cities
 microCityGroups.forEach(({ cityGroup }) => {
 cityGroup.visible = false;
 });
 microCityVisible = false;
 cameraSlowdownFactor = 1.0;
 controls.rotateSpeed = 0.3;
 controls.zoomSpeed = 0.5;
 
 // Update status indicator
 const statusEl = document.getElementById('micro-city-state');
 if (statusEl) {
 statusEl.textContent = `Inactive (dist: ${closestDist.toFixed(2)})`;
 statusEl.style.color = '#888';
 }
 }
 }
 
 // ===== Frame of Reference System =====
 function createFrameOfReference() {
 console.log('[FrameOfRef] Creating frame of reference...');
 if (frameOfReference) {
 scene.remove(frameOfReference);
 }
 
 const grp = new THREE.Group();
 
 // Semi-transparent dark plane
 const planeW = 0.8, planeH = 0.45;
 const planeGeo = new THREE.PlaneGeometry(planeW, planeH);
 const planeMat = new THREE.MeshBasicMaterial({ 
 color: 0x000000, 
 opacity: 0.15, 
 transparent: true,
 depthWrite: false
 });
 const plane = new THREE.Mesh(planeGeo, planeMat);
 grp.add(plane);
 
 // Frame bars (blue metallic)
 const barThickness = 0.025;
 const zOff = 0.0;
 const barMat = new THREE.MeshStandardMaterial({ 
 color: 0xbcd9ff, 
 metalness: 0.1, 
 roughness: 0.6,
 emissive: 0x4a7cff,
 emissiveIntensity: 0.3
 });
 
 const topBar = new THREE.Mesh(
 new THREE.BoxGeometry(planeW, barThickness, barThickness), 
 barMat
 );
 topBar.position.set(0, planeH/2 + barThickness/2, zOff);
 
 const botBar = new THREE.Mesh(
 new THREE.BoxGeometry(planeW, barThickness, barThickness), 
 barMat
 );
 botBar.position.set(0, -planeH/2 - barThickness/2, zOff);
 
 const leftBar = new THREE.Mesh(
 new THREE.BoxGeometry(barThickness, planeH + 2*barThickness, barThickness), 
 barMat
 );
 leftBar.position.set(-planeW/2 - barThickness/2, 0, zOff);
 
 const rightBar = new THREE.Mesh(
 new THREE.BoxGeometry(barThickness, planeH + 2*barThickness, barThickness), 
 barMat
 );
 rightBar.position.set(planeW/2 + barThickness/2, 0, zOff);
 
 [topBar, botBar, leftBar, rightBar].forEach(b => {
 b.castShadow = false;
 b.receiveShadow = false;
 grp.add(b);
 });
 
 // Diegetic UI: Minimize/Maximize circle button at top right
 const circleRadius = 0.04;
 const circleGeo = new THREE.CircleGeometry(circleRadius, 32);
 const circleMat = new THREE.MeshBasicMaterial({ 
 color: 0xffa04a, 
 transparent: true, 
 opacity: 0.9,
 depthWrite: false
 });
 const circle = new THREE.Mesh(circleGeo, circleMat);
 circle.position.set(planeW/2 - circleRadius*1.5, planeH/2 - circleRadius*1.5, 0.01);
 circle.userData.isMinimizeButton = true;
 grp.add(circle);
 
 // Icon for minimize (horizontal line)
 const iconGeo = new THREE.PlaneGeometry(circleRadius * 1.2, circleRadius * 0.2);
 const iconMat = new THREE.MeshBasicMaterial({ 
 color: 0x1a1a1a, 
 transparent: true, 
 opacity: 1.0,
 depthWrite: false
 });
 const icon = new THREE.Mesh(iconGeo, iconMat);
 icon.position.set(planeW/2 - circleRadius*1.5, planeH/2 - circleRadius*1.5, 0.02);
 grp.add(icon);
 
 minimizeButton = { circle, icon, iconGeo };
 
 // === 3D Gizmo Buttons on Frame Border ===
 const buttonSize = 0.044;
 const buttonDepth = 0.012;
 const buttonSpacing = 0.06;
 const buttonY = -planeH/2 - barThickness - buttonSize/2 - 0.01; // Bottom border
 
 const gizmoButtons = [];
 
 // Button configurations: [label, mode, xOffset, color]
 const buttonConfigs = [
 ['?', 'translate', -buttonSpacing * 2.0, 0x4a9cff], // Blue
 ['?', 'rotate', -buttonSpacing * 1.0, 0xff9c4a], // Orange
 ['?', 'scale', buttonSpacing * 0.0, 0x9cff4a], // Green
 ['??', 'sculpt', buttonSpacing * 1.0, 0xffff4a], // Yellow (sculpt mode)
 ['S', 'snap', buttonSpacing * 2.0, 0xff4a9c] // Pink (snap toggle)
 ];
 
 buttonConfigs.forEach(([label, mode, xOffset, color]) => {
 // Button base (slightly raised from frame)
 const buttonGeo = new THREE.BoxGeometry(buttonSize, buttonSize, buttonDepth);
 const buttonMat = new THREE.MeshStandardMaterial({ 
 color: color,
 metalness: 0.3,
 roughness: 0.5,
 emissive: color,
 emissiveIntensity: 0.2
 });
 const button = new THREE.Mesh(buttonGeo, buttonMat);
 button.position.set(xOffset, buttonY, 0.015);
 button.userData.mode = mode;
 button.userData.isGizmoButton = true;
 button.userData.baseZ = 0.015;
 button.userData.pressedZ = 0.005;
 button.userData.isPressed = false;
 button.userData.isActive = (mode === 'translate'); // Translate starts active
 
 // Update material for active state
 if (button.userData.isActive) {
 buttonMat.emissiveIntensity = 0.5;
 }
 
 grp.add(button);
 
 // Label text on button
 const canvas = document.createElement('canvas');
 canvas.width = 64;
 canvas.height = 64;
 const ctx = canvas.getContext('2d');
 ctx.fillStyle = '#ffffff';
 ctx.font = 'bold 48px sans-serif';
 ctx.textAlign = 'center';
 ctx.textBaseline = 'middle';
 ctx.fillText(label, 32, 32);
 
 const labelTexture = new THREE.CanvasTexture(canvas);
 const labelMat = new THREE.MeshBasicMaterial({ 
 map: labelTexture, 
 transparent: true,
 depthWrite: false
 });
 const labelMesh = new THREE.Mesh(
 new THREE.PlaneGeometry(buttonSize * 0.8, buttonSize * 0.8),
 labelMat
 );
 labelMesh.position.set(xOffset, buttonY, 0.015 + buttonDepth/2 + 0.001);
 grp.add(labelMesh);
 
 gizmoButtons.push({ button, label: labelMesh, mode, xOffset });
 });
 
 grp.userData.gizmoButtons = gizmoButtons;
 grp.userData.width = planeW;
 grp.userData.height = planeH;
 grp.visible = false;
 
 frameOfReference = grp;
 scene.add(frameOfReference);
 
 console.log('[FrameOfRef] Frame created successfully with 4 gizmo buttons');
 }
 
// Scale zone detection
let scaleZoneEntered = false;
// firstPersonModeActive is now managed by CameraManager (see getter/setter below)

 function toggleScaleMode() {
 scaleModeEnabled = !scaleModeEnabled;
 console.log('[FrameOfRef] Scale mode:', scaleModeEnabled ? 'ENABLED' : 'DISABLED');
 
 if (!frameOfReference) {
 createFrameOfReference();
 }
 
 if (scaleModeEnabled) {
 // Show frame
 frameOfReference.visible = true;
 frameMinimized = false;
 
 // Show taunt skybox
 if (window.tauntSkybox) {
 window.tauntSkybox.visible = true;
 console.log('[TauntCycle] 🎬 Taunt skybox made VISIBLE - cycling is now available');
 console.log('[TauntCycle] Video element exists:', !!window.tauntVideo);
 console.log('[TauntCycle] Current video:', window.tauntVideo?.src);
 console.log('[TauntCycle] Press V or click skybox to cycle videos');
 if (window.tauntVideo && window.tauntVideo.paused) {
 window.tauntVideo.play().catch(err => console.warn('Taunt video play failed:', err));
 }
 }
 
 // Hide 2D gizmo toolbar
 const gizmoToolbar = document.getElementById('gizmo-toolbar');
 if (gizmoToolbar) {
 gizmoToolbar.style.display = 'none';
 }
 
 // Brighten lighting
 al.intensity = 0.35; // Was 0.15
 hl.intensity = 0.5; // Was 0.2
 dl.intensity = 1.5; // Was 0.9
 rimLight.intensity = 0.6; // Was 0.3
 
 // Spawn 3D objects
 createScaleObjects();
 
 console.log('[FrameOfRef] Lighting brightened, objects spawned, 3D gizmos active');
} else {
// Hide frame
frameOfReference.visible = false;

 // Hide taunt skybox
 if (window.tauntSkybox) {
 window.tauntSkybox.visible = false;
 if (window.tauntVideo && !window.tauntVideo.paused) {
 window.tauntVideo.pause();
 }
 console.log('[TauntCycle] 🎬 Taunt skybox hidden');
 }

// Restore 2D gizmo toolbar
const gizmoToolbar = document.getElementById('gizmo-toolbar');
if (gizmoToolbar) {
gizmoToolbar.style.display = 'flex';
}

// Restore original lighting
al.intensity = 0.15;
hl.intensity = 0.2;
dl.intensity = 0.9;
rimLight.intensity = 0.3;

// Remove scale objects
scaleObjects.forEach(obj => scene.remove(obj));
scaleObjects = [];

console.log('[FrameOfRef] Lighting restored, objects removed, 2D gizmos restored');
}
 }
 
 function toggleFrameMinimize() {
 if (!frameOfReference) return;
 
 frameMinimized = !frameMinimized;
 
 // Find all children except the minimize button components
 frameOfReference.children.forEach(child => {
 if (child === minimizeButton.circle || child === minimizeButton.icon) {
 return; // Always show button
 }
 child.visible = !frameMinimized;
 });
 
 // Update icon: horizontal line for minimize, plus for maximize
 if (frameMinimized) {
 // Change to plus icon (two rectangles)
 minimizeButton.icon.geometry.dispose();
 const plusGeo1 = new THREE.PlaneGeometry(0.048, 0.008);
 const plusGeo2 = new THREE.PlaneGeometry(0.008, 0.048);
 minimizeButton.icon.geometry = plusGeo1;
 // Add vertical part
 if (!minimizeButton.iconPart2) {
 const iconMat = new THREE.MeshBasicMaterial({ 
 color: 0x1a1a1a, 
 transparent: true, 
 opacity: 1.0,
 depthWrite: false
 });
 minimizeButton.iconPart2 = new THREE.Mesh(plusGeo2, iconMat);
 minimizeButton.iconPart2.position.copy(minimizeButton.icon.position);
 frameOfReference.add(minimizeButton.iconPart2);
 } else {
 minimizeButton.iconPart2.visible = true;
 }
 } else {
 // Change to minus icon (horizontal line)
 minimizeButton.icon.geometry.dispose();
 const circleRadius = 0.04;
 const iconGeo = new THREE.PlaneGeometry(circleRadius * 1.2, circleRadius * 0.2);
 minimizeButton.icon.geometry = iconGeo;
 if (minimizeButton.iconPart2) {
 minimizeButton.iconPart2.visible = false;
 }
 }
 
 console.log('[FrameOfRef] Frame', frameMinimized ? 'minimized' : 'maximized');
 }
 
 function createScaleObjects() {
 // Clean up existing objects
 scaleObjects.forEach(obj => scene.remove(obj));
 scaleObjects = [];
 
 console.log('[FrameOfRef] Creating scale objects...');
 
 // Create various primitive objects around the scene
 const objects = [
 // Cubes of various sizes
 { type: 'box', size: [0.3, 0.3, 0.3], pos: [4, 1.5, 2], color: 0xff7a4a },
 { type: 'box', size: [0.5, 0.5, 0.5], pos: [8, 1.5, 4], color: 0x4a9cff },
 { type: 'box', size: [0.25, 0.6, 0.25], pos: [5, 1.5, 5], color: 0xffd04a },
 
 // Spheres
 { type: 'sphere', radius: 0.2, pos: [7, 1.8, 2], color: 0xff4a9c },
 { type: 'sphere', radius: 0.35, pos: [3, 1.5, 4], color: 0x7a4aff },
 
 // Cylinders
 { type: 'cylinder', size: [0.15, 0.6], pos: [6, 1.5, 6], color: 0x4affb0 },
 { type: 'cylinder', size: [0.2, 0.4], pos: [9, 1.5, 3], color: 0xffb04a },
 ];
 
 objects.forEach(spec => {
 let geo;
 if (spec.type === 'box') {
 geo = new THREE.BoxGeometry(...spec.size);
 } else if (spec.type === 'sphere') {
 geo = new THREE.SphereGeometry(spec.radius, 32, 32);
 } else if (spec.type === 'cylinder') {
 geo = new THREE.CylinderGeometry(spec.size[0], spec.size[0], spec.size[1], 32);
 }
 
 const mat = new THREE.MeshStandardMaterial({ 
 color: spec.color,
 metalness: 0.2,
 roughness: 0.6,
 emissive: spec.color,
 emissiveIntensity: 0.1
 });
 
 const mesh = new THREE.Mesh(geo, mat);
 mesh.position.set(...spec.pos);
 mesh.castShadow = true;
 mesh.receiveShadow = true;
 mesh.userData.isScaleObject = true;
 
 scene.add(mesh);
 scaleObjects.push(mesh);
 });
 
 console.log('[FrameOfRef] Created', scaleObjects.length, 'scale objects');
 }
 
 function updateFrameOfReference() {
 if (!frameOfReference || !frameOfReference.visible) return;
 
 // Position frame in front of camera
 const camPos = new THREE.Vector3();
 camera.getWorldPosition(camPos);
 
 const camDir = new THREE.Vector3();
 camera.getWorldDirection(camDir);
 
 // Place frame at distance in front of camera
 const offset = camDir.clone().multiplyScalar(frameDist);
 frameOfReference.position.copy(camPos).add(offset);
 
 // Orient frame to face camera
 frameOfReference.quaternion.copy(camera.quaternion);
 
 // Scale frame slightly for better visibility
 if (!frameOfReference.userData._resized) {
 const s = 1.2;
 frameOfReference.scale.set(s, s, s);
 frameOfReference.userData._resized = true;
 }
 }
 
 function makeRayTexture(){
 const c=document.createElement('canvas');
 c.width=8; c.height=256;
 const ctx=c.getContext('2d');
 const g=ctx.createLinearGradient(0,0,0,256);
 g.addColorStop(0,'rgba(255,255,255,0)');
 g.addColorStop(0.15,'rgba(255,255,255,0.08)');
 g.addColorStop(0.5,'rgba(255,255,255,0.15)');
 g.addColorStop(0.85,'rgba(255,255,255,0.08)');
 g.addColorStop(1,'rgba(255,255,255,0)');
 ctx.fillStyle=g; ctx.fillRect(0,0,c.width,c.height);
 const t=new THREE.CanvasTexture(c); 
 t.wrapS=t.wrapT=THREE.ClampToEdgeWrapping; 
 t.needsUpdate=true; 
 return t;
 }
 
 // Dust texture and ambient dust creation already defined earlier (line 540-624)
 
 // ===== Full Finger System from kb.html =====
 async function loadFinger(){
 try{
 const STATE={ LEN:0.78, PIP:0.78*0.40, DIP:0.78*(0.40+0.33), NAIL_START:0.67, NAIL_LEN:0.10 };
 const RAD={ BASE:0.065, PROX:0.058, MID:0.052, DIST:0.047, TIP:0.047 };
 const OVAL={ x:1.08, z:0.92 };
 const radialSegs=120, ySegs=220;
 let nailMesh, mcpBone, pipBone, dipBone, tipBone, skeleton;

 const LEN=STATE.LEN, PIP=STATE.PIP, DIP=STATE.DIP, PROX=PIP, MIDL=DIP-PIP, DIST=LEN-DIP;
 const JOINTS={ MCP:0, PIP, DIP, TIP:LEN };

 const lerp=(a,b,t)=>a+(b-a)*t, smooth=t=>t*t*(3-2*t);
 const baseR=y=>{
 if(y<=PIP){const t=y/PROX; return lerp(RAD.BASE,RAD.PROX,smooth(t))*(1.0+0.06*Math.exp(-((t-0.25)**2)/(2*0.18**2)));}
 if(y<=DIP){const t=(y-PIP)/MIDL; return lerp(RAD.PROX,RAD.MID,smooth(t))*(1.0+0.045*Math.exp(-((t-0.35)**2)/(2*0.18**2)));}
 const t=(y-DIP)/DIST; return lerp(RAD.MID,RAD.DIST,smooth(t))*(1.0+0.035*Math.exp(-((t-0.30)**2)/(2*0.18**2)));
 };
 const crease=(y,ang)=>{
 const c1=Math.exp(-((y-PIP)**2)/(2*(0.028*LEN)**2)); const c2=Math.exp(-((y-DIP)**2)/(2*(0.022*LEN)**2)); 
 const pal=0.55+0.45*Math.max(0,-Math.sin(ang)); const dor=1.0+0.05*Math.max(0,Math.sin(ang))*(c1*0.9+c2*0.6); 
 return (1.0-0.06*pal*c1-0.05*pal*c2)*dor;
 };
 const ellR=(ang,r)=>{const rx=r*OVAL.x, rz=r*OVAL.z; return Math.sqrt((rx*rx*rz*rz)/((rz*rz*Math.cos(ang)**2)+(rx*rx*Math.sin(ang)**2)));};
 
 const capSegs=24; const tubeYSegs=ySegs-capSegs; const tubeLen=LEN*0.94; const rBase=baseR(tubeLen);
 const pos=[], uv=[], idx=[]; let vertIdx=0;
 for(let yi=0; yi<=tubeYSegs; yi++){
 const y=(yi/tubeYSegs)*tubeLen, r0=baseR(y);
 for(let ai=0; ai<=radialSegs; ai++){
 const ang=(ai/radialSegs)*Math.PI*2; const r=ellR(ang,r0)*crease(y,ang); 
 pos.push(r*Math.cos(ang),y,r*Math.sin(ang)); 
 const isFingertip=(y>DIP)?1.0:0.0;
 const angNorm=(ang+Math.PI)/(Math.PI*2); 
 const isPalmar=Math.max(0,Math.min(1,1.0-Math.abs(angNorm-0.5)*4)); 
 const fpU=angNorm; 
 const fpV=0.5+isPalmar*isFingertip*((y-DIP)/(LEN-DIP))*0.5; 
 uv.push(fpU,fpV); 
 vertIdx++;
 }
 }
 for(let yi=1; yi<=capSegs; yi++){
 const phi=(yi/capSegs)*(Math.PI*0.5); const yOff=tubeLen+rBase*Math.sin(phi); const rCirc=rBase*Math.cos(phi);
 const blendT=Math.pow(Math.min(yi/6.0,1.0), 0.7);
 for(let ai=0; ai<=radialSegs; ai++){
 const theta=(ai/radialSegs)*Math.PI*2; 
 const tubeR=ellR(theta,baseR(tubeLen))*crease(tubeLen,theta);
 const capR=ellR(theta,rCirc)*crease(tubeLen,theta);
 const rEll=tubeR*(1.0-blendT)+capR*blendT;
 const x=rEll*Math.cos(theta); const z=rEll*Math.sin(theta); 
 pos.push(x,yOff,z); 
 const angNorm=(theta+Math.PI)/(Math.PI*2);
 const isPalmar=Math.max(0,Math.min(1,1.0-Math.abs(angNorm-0.5)*4));
 uv.push(angNorm,0.5+isPalmar*0.5); 
 vertIdx++;
 }
 }
 const totalRings=tubeYSegs+capSegs;
 for(let yi=0; yi<totalRings; yi++) for(let ai=0; ai<radialSegs; ai++){const a=yi*(radialSegs+1)+ai, b=a+1, c=a+(radialSegs+1), d=c+1; idx.push(a,c,b,b,c,d);}
 const tube=new THREE.BufferGeometry(); tube.setAttribute('position',new THREE.Float32BufferAttribute(pos,3)); tube.setAttribute('uv',new THREE.Float32BufferAttribute(uv,2)); tube.setIndex(idx); tube.computeVertexNormals(); tube.normalizeNormals();

 const nailSegW=52, nailSegL=20, nailWidth=4.20, nailThickness=0.004; const nailStartY=STATE.NAIL_START - 0.04, nailEndY=nailStartY+STATE.NAIL_LEN + 0.02; const nPos=[], nUV=[], nIdx=[];
 const nailBaseY=nailStartY; const nailBaseR=baseR(nailBaseY); 
 const getNailSurface=(yParam,u,topSide)=>{
 const vt=(yParam-nailStartY)/(nailEndY-nailStartY); const curveT=vt*vt*(3-2*vt); const fanOut=1.0+curveT*0.24;
 const uu=(u-0.5)*nailWidth*fanOut; const absU=Math.abs(uu); const angNail=uu/nailWidth*1.45; 
 const fingerAngle=angNail;
 const tubeRAtY = baseR(yParam);
 const tubeREll = ellR(fingerAngle, tubeRAtY) * crease(yParam, fingerAngle);
 const lateralWrap = Math.min(1.0, (tubeREll / nailBaseR) * 0.95);
 const edgeRound=(absU>0.60)?Math.min(Math.pow((absU-0.60)*2.2,1.3)*nailThickness*0.6,nailThickness*0.55):0;
 const rAtAngle=ellR(fingerAngle,nailBaseR)*crease(nailBaseY,fingerAngle); 
 const x=rAtAngle*Math.sin(fingerAngle); 
 const fingerZ=rAtAngle*Math.cos(fingerAngle); 
 const tipRound=vt*vt*0.012; 
 const curvatureOffset = rAtAngle * -0.46 - 0.006;
 let z=-fingerZ-(topSide?nailThickness:0)-(lateralWrap)*nailBaseR*0.65+edgeRound-tipRound-curvatureOffset; 
 return {x,y:yParam,z};
 };
 let vOff=0; for(let j=0;j<=nailSegL;j++){ const y=nailStartY+(j/nailSegL)*(nailEndY-nailStartY); for(let i=0;i<=nailSegW;i++){ const p=getNailSurface(y,i/nailSegW,true); nPos.push(p.x,p.y,p.z); nUV.push(i/nailSegW,j/nailSegL); if(j<nailSegL&&i<nailSegW){const a=vOff+j*(nailSegW+1)+i,b=a+1,c=a+(nailSegW+1),d=c+1; nIdx.push(a,c,b,b,c,d);} } }
 vOff=nPos.length/3; for(let j=0;j<=nailSegL;j++){ const y=nailStartY+(j/nailSegL)*(nailEndY-nailStartY); for(let i=0;i<=nailSegW;i++){ const p=getNailSurface(y,i/nailSegW,false); nPos.push(p.x,p.y,p.z); nUV.push(i/nailSegW,j/nailSegL); if(j<nailSegL&&i<nailSegW){const a=vOff+j*(nailSegW+1)+i,b=a+1,c=a+(nailSegW+1),d=c+1; nIdx.push(a,b,c,b,d,c);} } }
 const seal=(v0,ct,loop)=>{ for(let k=0;k<10;k++){ for(let m=0;m<ct-(loop?0:1);m++){ const a=v0+k*ct+m,b=a+1,c=a+ct,d=c+1; if(!loop&&m===ct-1)continue; const bAdj=loop&&m===ct-1?v0+k*ct:b; const dAdj=loop&&m===ct-1?v0+(k+1)*ct:d; nIdx.push(a,c,bAdj,bAdj,c,dAdj); } } };
 let ev0=nPos.length/3; for(let k=0;k<=10;k++){ for(let i=0;i<=nailSegW;i++){ const pT=getNailSurface(nailStartY,i/nailSegW,true); const pB=getNailSurface(nailStartY,i/nailSegW,false); const t=k/10; nPos.push(pT.x*(1-t)+pB.x*t,pT.y*(1-t)+pB.y*t,pT.z*(1-t)+pB.z*t); nUV.push(i/nailSegW,t); } } seal(ev0,nailSegW+1,false);
 ev0=nPos.length/3; for(let k=0;k<=10;k++){ for(let j=0;j<=nailSegL;j++){ const y=nailStartY+(j/nailSegL)*(nailEndY-nailStartY); const pT=getNailSurface(y,0,true); const pB=getNailSurface(y,0,false); const t=k/10; nPos.push(pT.x*(1-t)+pB.x*t,pT.y*(1-t)+pB.y*t,pT.z*(1-t)+pB.z*t); nUV.push(t,j/nailSegL); } } seal(ev0,nailSegL+1,false);
 ev0=nPos.length/3; for(let k=0;k<=10;k++){ for(let j=0;j<=nailSegL;j++){ const y=nailStartY+(j/nailSegL)*(nailEndY-nailStartY); const pT=getNailSurface(y,1,true); const pB=getNailSurface(y,1,false); const t=k/10; nPos.push(pT.x*(1-t)+pB.x*t,pT.y*(1-t)+pB.y*t,pT.z*(1-t)+pB.z*t); nUV.push(t,j/nailSegL); } } seal(ev0,nailSegL+1,false);
 ev0=nPos.length/3; for(let k=0;k<=10;k++){ for(let i=0;i<=nailSegW;i++){ const pT=getNailSurface(nailEndY,i/nailSegW,true); const pB=getNailSurface(nailEndY,i/nailSegW,false); const t=k/10; nPos.push(pT.x*(1-t)+pB.x*t,pT.y*(1-t)+pB.y*t,pT.z*(1-t)+pB.z*t); nUV.push(i/nailSegW,t); } } seal(ev0,nailSegW+1,false);
 const nailGeom=new THREE.BufferGeometry(); nailGeom.setAttribute('position',new THREE.Float32BufferAttribute(nPos,3)); nailGeom.setAttribute('uv',new THREE.Float32BufferAttribute(nUV,2)); nailGeom.setIndex(nIdx); nailGeom.computeVertexNormals();
 const tipLayerPos=[]; const tipLayerUV=[]; const tipLayerIdx=[];
 const extrudeAmt=0.0;
 const tipStart=Math.floor(nailSegL*0.60);
 let tv0=0;
 for(let j=tipStart;j<=nailSegL;j++){
 const tY=nailStartY+(j/nailSegL)*(nailEndY-nailStartY);
 for(let i=0;i<=nailSegW;i++){
 const pt=getNailSurface(tY,i/nailSegW,true);
 tipLayerPos.push(pt.x, pt.y, pt.z - extrudeAmt);
 tipLayerUV.push(i/nailSegW, j/nailSegL);
 if(j< nailSegL && i< nailSegW){ const a=tv0+(j-tipStart)*(nailSegW+1)+i, b=a+1, c=a+(nailSegW+1), d=c+1; tipLayerIdx.push(a,c,b,b,c,d); }
 }
 }
 const nailTipGeom=new THREE.BufferGeometry();
 if(tipLayerPos.length>0){
 nailTipGeom.setAttribute('position', new THREE.Float32BufferAttribute(tipLayerPos,3));
 nailTipGeom.setAttribute('uv', new THREE.Float32BufferAttribute(tipLayerUV,2));
 nailTipGeom.setIndex(tipLayerIdx);
 nailTipGeom.computeVertexNormals();
 }

 const P=tube.getAttribute('position');
 const colors=new Float32Array(P.count*4); 
 for(let i=0;i<P.count;i++){ 
 const y=P.getY(i); const x=P.getX(i); const z=P.getZ(i);
 const palmFactor=Math.max(0,-z)*0.08; 
 const tipWarmth=Math.exp(-((y-LEN*0.96)**2)/(2*(0.08*LEN)**2))*0.22;
 const pipWarmth=Math.exp(-((y-PIP)**2)/(2*(0.04*LEN)**2))*0.14;
 const dipWarmth=Math.exp(-((y-DIP)**2)/(2*(0.035*LEN)**2))*0.12;
 const cuticleWarmth=Math.exp(-((y-STATE.NAIL_START)**2)/(2*(0.02*LEN)**2))*0.18;
 const warmth=tipWarmth+pipWarmth+dipWarmth+cuticleWarmth+palmFactor;
 colors[i*4+0]=Math.min(1.0,0.96+warmth*0.55); 
 colors[i*4+1]=Math.min(1.0,0.80-warmth*0.12); 
 colors[i*4+2]=Math.min(1.0,0.74-warmth*0.24); 
 const isPalmar=Math.max(0,-z); 
 const isTip=(y>DIP)?1.0:0.0; 
 const fingerprintMask=Math.min(1.0,isPalmar*2.0)*Math.max(isTip*0.8,0.3); 
 colors[i*4+3]=fingerprintMask;
 }
 tube.setAttribute('color', new THREE.BufferAttribute(colors,4));

 const wrinkleData=new Float32Array(tube.getAttribute('position').count*3);
 for(let i=0;i<tube.getAttribute('position').count;i++){
 const y=P.getY(i); const x=P.getX(i); const z=P.getZ(i);
 const ang=Math.atan2(z,x); const r=Math.sqrt(x*x+z*z);
 const pipDist=Math.abs(y-PIP); const pipWrinkle=Math.max(0,Math.sin(ang))*Math.exp(-(pipDist**2)/(2*(0.008*LEN)**2))*Math.sin(ang*6)*0.0018;
 const pipWrinkle2=Math.max(0,Math.sin(ang))*Math.exp(-((y-PIP-0.008*LEN)**2)/(2*(0.005*LEN)**2))*Math.sin(ang*8)*0.0012;
 const pipWrinkle3=Math.max(0,Math.sin(ang))*Math.exp(-((y-PIP+0.008*LEN)**2)/(2*(0.005*LEN)**2))*Math.sin(ang*7)*0.0010;
 const dipWrinkle=Math.max(0,Math.sin(ang))*Math.exp(-((y-DIP)**2)/(2*(0.006*LEN)**2))*Math.sin(ang*7)*0.0012;
 const totalWrinkle=pipWrinkle+pipWrinkle2+pipWrinkle3+dipWrinkle;
 const nx=x/r; const nz=z/r;
 wrinkleData[i*3+0]=nx*totalWrinkle;
 wrinkleData[i*3+1]=0;
 wrinkleData[i*3+2]=nz*totalWrinkle;
 }
 tube.userData.wrinkleData=wrinkleData;
 tube.userData.originalPositions=new Float32Array(P.array);

 const skinIndex=new THREE.BufferAttribute(new Float32Array(tube.getAttribute('position').count*4),4);
 const skinWeight=new THREE.BufferAttribute(new Float32Array(tube.getAttribute('position').count*4),4);
 tube.setAttribute('skinIndex',skinIndex); tube.setAttribute('skinWeight',skinWeight);
 const feather=0.04*LEN;
 function setWeights(i, a,b, t){ skinIndex.setXYZW(i,a,b,0,0); skinWeight.setXYZW(i,1-t,t,0,0);} 
 for(let i=0;i<P.count;i++){
 const y=P.getY(i);
 if(y<=PIP){ const t=THREE.MathUtils.smoothstep(y, PIP-feather, PIP+feather); setWeights(i, 0,1, t); }
 else if(y<=DIP){ const edge=PIP; const t=THREE.MathUtils.smoothstep(y, DIP-feather, DIP+feather); setWeights(i, 1,2, t); }
 else { const t=THREE.MathUtils.smoothstep(y, LEN-feather, LEN); setWeights(i, 2,3, t); }
 }

 const nailSkinIndex=new THREE.BufferAttribute(new Float32Array(nailGeom.getAttribute('position').count*4),4);
 const nailSkinWeight=new THREE.BufferAttribute(new Float32Array(nailGeom.getAttribute('position').count*4),4);
 nailGeom.setAttribute('skinIndex',nailSkinIndex); nailGeom.setAttribute('skinWeight',nailSkinWeight);
 const nP=nailGeom.getAttribute('position');
 for(let i=0;i<nP.count;i++){
 const y=nP.getY(i);
 if(y<=PIP){ const t=THREE.MathUtils.smoothstep(y, PIP-feather, PIP+feather); nailSkinIndex.setXYZW(i,0,1,0,0); nailSkinWeight.setXYZW(i,1-t,t,0,0); }
 else if(y<=DIP){ const t=THREE.MathUtils.smoothstep(y, DIP-feather, DIP+feather); nailSkinIndex.setXYZW(i,1,2,0,0); nailSkinWeight.setXYZW(i,1-t,t,0,0); }
 else { const t=THREE.MathUtils.smoothstep(y, LEN-feather, LEN); nailSkinIndex.setXYZW(i,2,3,0,0); nailSkinWeight.setXYZW(i,1-t,t,0,0); }
 }

 if (nailTipGeom && nailTipGeom.getAttribute && nailTipGeom.getAttribute('position')){
 const tipPos = nailTipGeom.getAttribute('position');
 const tipSkinIndex = new THREE.BufferAttribute(new Float32Array(tipPos.count*4), 4);
 const tipSkinWeight = new THREE.BufferAttribute(new Float32Array(tipPos.count*4), 4);
 nailTipGeom.setAttribute('skinIndex', tipSkinIndex);
 nailTipGeom.setAttribute('skinWeight', tipSkinWeight);
 for(let i=0;i<tipPos.count;i++){
 const y = tipPos.getY(i);
 if(y<=PIP){ const t=THREE.MathUtils.smoothstep(y, PIP-feather, PIP+feather); tipSkinIndex.setXYZW(i,0,1,0,0); tipSkinWeight.setXYZW(i,1-t,t,0,0); }
 else if(y<=DIP){ const t=THREE.MathUtils.smoothstep(y, DIP-feather, DIP+feather); tipSkinIndex.setXYZW(i,1,2,0,0); tipSkinWeight.setXYZW(i,1-t,t,0,0); }
 else { const t=THREE.MathUtils.smoothstep(y, LEN-feather, LEN); tipSkinIndex.setXYZW(i,2,3,0,0); tipSkinWeight.setXYZW(i,1-t,t,0,0); }
 }
 }

 const fpCanvas=document.createElement('canvas'); fpCanvas.width=1024; fpCanvas.height=1024; const fpCtx=fpCanvas.getContext('2d');
 fpCtx.fillStyle='#FFFFFF';
 fpCtx.fillRect(0,0,1024,1024);
 const centerX=512, centerY=512;
 for(let r=25; r<380; r+=3.2){
 fpCtx.strokeStyle='#000000';
 fpCtx.lineWidth=2.8+Math.random()*1.2;
 fpCtx.beginPath();
 for(let a=0; a<Math.PI*2; a+=0.03){
 const spiral=r+Math.sin(a*6.5+r*0.09)*7+Math.sin(a*13+r*0.18)*3;
 const wobble=Math.sin(a*28)*1.2+Math.sin(a*19)*1.5;
 const noise=Math.sin(a*45+r*0.3)*0.8;
 const x=centerX+Math.cos(a)*(spiral+wobble+noise);
 const y=centerY+Math.sin(a)*(spiral+wobble+noise)*0.88;
 if(a===0)fpCtx.moveTo(x,y); else fpCtx.lineTo(x,y);
 }
 fpCtx.closePath(); fpCtx.stroke();
 }
 fpCtx.fillStyle='#000000';
 for(let i=0; i<800; i++){
 const angle=Math.random()*Math.PI*2;
 const dist=Math.random()*380;
 const x=centerX+Math.cos(angle)*dist;
 const y=centerY+Math.sin(angle)*dist*0.88;
 fpCtx.beginPath();
 fpCtx.arc(x,y,0.8+Math.random()*0.6,0,Math.PI*2);
 fpCtx.fill();
 }
 const fpTexture=new THREE.CanvasTexture(fpCanvas); 
 fpTexture.wrapS=THREE.RepeatWrapping; 
 fpTexture.wrapT=THREE.ClampToEdgeWrapping;
 fpTexture.repeat.set(2, 1);

 const npCanvas=document.createElement('canvas'); npCanvas.width=1024; npCanvas.height=1024; const npCtx=npCanvas.getContext('2d');
 npCtx.fillStyle='#F4D03F'; 
 npCtx.fillRect(0,0,1024,1024);
 for(let i=0; i<30; i++){
 const chipAngle=Math.random()*Math.PI*2;
 const chipDist=Math.random()*420;
 const chipX=512+Math.cos(chipAngle)*chipDist;
 const chipY=512+Math.sin(chipAngle)*chipDist;
 const chipSize=5+Math.random()*12;
 npCtx.fillStyle='#FFE8DC'; 
 npCtx.beginPath();
 for(let a=0; a<Math.PI*2; a+=Math.PI/4){
 const r=chipSize*(0.7+Math.random()*0.6);
 npCtx.lineTo(chipX+Math.cos(a)*r,chipY+Math.sin(a)*r);
 }
 npCtx.closePath();
 npCtx.fill();
 }
 for(let i=0; i<120; i++){
 const chipX=Math.random()*1024;
 const chipY=Math.random()*100; 
 const chipSize=2+Math.random()*10;
 npCtx.fillStyle='#FFE8DC';
 npCtx.beginPath();
 for(let a=0; a<Math.PI*2; a+=Math.PI/6){
 const r=chipSize*(0.5+Math.random()*0.8);
 npCtx.lineTo(chipX+Math.cos(a)*r,chipY+Math.sin(a)*r);
 }
 npCtx.closePath();
 npCtx.fill();
 }
 for(let i=0; i<200; i++){
 const chipX=Math.random()*1024;
 const chipY=Math.random()*40;
 const chipSize=1+Math.random()*4;
 npCtx.fillStyle='#FFE8DC';
 npCtx.beginPath();
 npCtx.arc(chipX,chipY,chipSize,0,Math.PI*2);
 npCtx.fill();
 }
 for(let i=0; i<80; i++){
 const x=Math.random()*1024;
 const y=Math.random()*1024;
 npCtx.fillStyle=`rgba(255,232,220,${0.2+Math.random()*0.3})`;
 npCtx.fillRect(x,y,1+Math.random()*3,1+Math.random()*4);
 }
 const npTexture=new THREE.CanvasTexture(npCanvas); npTexture.wrapS=npTexture.wrapT=THREE.ClampToEdgeWrapping;

 mcpBone=new THREE.Bone(); mcpBone.position.y=0;
 pipBone=new THREE.Bone(); pipBone.position.y=PROX; mcpBone.add(pipBone);
 dipBone=new THREE.Bone(); dipBone.position.y=MIDL; pipBone.add(dipBone);
 tipBone=new THREE.Bone(); tipBone.position.y=DIST; dipBone.add(tipBone);
 skeleton=new THREE.Skeleton([mcpBone,pipBone,dipBone,tipBone]);

 fpTexture.repeat.set(FP.scale*2, FP.scale);
 const skinMat=new THREE.MeshPhysicalMaterial({color:0xF2C6AC,roughness:0.56,metalness:0,clearcoat:0.06,clearcoatRoughness:0.85,vertexColors:true,side:THREE.DoubleSide,transparent:false,opacity:1.0,depthWrite:true,depthTest:true,alphaToCoverage:false,blending:THREE.NormalBlending,flatShading:false,forceSinglePass:true,displacementMap:FP.enabled?fpTexture:null,displacementScale:0.008*FP.strength,bumpMap:FP.enabled?fpTexture:null,bumpScale:0.10*FP.strength});
 
 function applyFpToMaterial(){
 const key = `${FP.enabled}-${FP.strength.toFixed(3)}-${FP.scale.toFixed(3)}`;
 if (FP._applied === key) return;
 fpTexture.repeat.set(FP.scale*2, FP.scale);
 skinMat.displacementMap = FP.enabled ? fpTexture : null;
 skinMat.bumpMap = FP.enabled ? fpTexture : null;
 skinMat.displacementScale = 0.008 * FP.strength;
 skinMat.bumpScale = 0.10 * FP.strength;
 skinMat.needsUpdate = true;
 FP._applied = key;
 }
 window.applyFpToMaterial = applyFpToMaterial;
 finger=new THREE.SkinnedMesh(tube,skinMat); finger.add(mcpBone); finger.bind(skeleton); finger.castShadow=false; finger.receiveShadow=false; finger.frustumCulled=false; finger.renderOrder=0; 
 const nailMat=new THREE.MeshPhysicalMaterial({map:npTexture,roughness:0.15,metalness:0.05,clearcoat:0.85,clearcoatRoughness:0.08,transparent:false,opacity:1.0,side:THREE.DoubleSide,depthWrite:true,depthTest:true,polygonOffset:true,polygonOffsetFactor:-1,polygonOffsetUnits:-1});
 nailMesh=new THREE.SkinnedMesh(nailGeom,nailMat); nailMesh.add(skeleton.bones[0].clone()); nailMesh.bind(skeleton); finger.add(nailMesh);
 if (nailTipGeom.getAttribute('position')){
 const nailTipMat=new THREE.MeshPhysicalMaterial({color:0xffffff,transparent:true,opacity:0.35,roughness:0.2,metalness:0.0,clearcoat:0.9,clearcoatRoughness:0.06,side:THREE.DoubleSide,depthWrite:false});
 const nailTip=new THREE.SkinnedMesh(nailTipGeom,nailTipMat);
 nailTip.add(skeleton.bones[0].clone()); nailTip.bind(skeleton); finger.add(nailTip);
 }
 
 const keyWidth = 0.8;
 const fingerWidth = RAD.BASE * 2;
 const scale = keyWidth / fingerWidth * 1.4;
 finger.scale.set(scale, scale, scale);
 finger.rotation.set(-Math.PI / 2 + 0.8, Math.PI, 0);
 finger.position.set(0, 0, 0); // Position relative to group
 
 // Create voxel wrap for finger
 // Global voxel wrap parameters
 window.voxelWrapStyle = 'Emerging'; // 'Emerging' or 'Voxelized'
 window.voxelWrapParams = {
 voxelSize: 0.012,
 sampleDensity: 12,
 emergingScale: 0.65,
 voxelizedScale: 1.1,
 rotationAmount: 0.1
 };
 
 const voxelSize = window.voxelWrapParams.voxelSize;
 const voxelGeometry = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);
 
 function createVoxelWrapForFinger(fingerMesh, bones, sampleDensity = 8) {
 const positions = fingerMesh.geometry.getAttribute('position');
 const skinIndices = fingerMesh.geometry.getAttribute('skinIndex');
 const skinWeights = fingerMesh.geometry.getAttribute('skinWeight');
 
 const voxelPositions = [];
 const voxelData = []; // Store bone info for each voxel
 
 // Sample the finger geometry
 for (let i = 0; i < positions.count; i += sampleDensity) {
 const localPos = new THREE.Vector3(
 positions.getX(i),
 positions.getY(i),
 positions.getZ(i)
 );
 
 // Get bone influences
 const boneIndices = [
 skinIndices.getX(i),
 skinIndices.getY(i),
 skinIndices.getZ(i),
 skinIndices.getW(i)
 ];
 const boneWeights = [
 skinWeights.getX(i),
 skinWeights.getY(i),
 skinWeights.getZ(i),
 skinWeights.getW(i)
 ];
 
 voxelPositions.push(localPos);
 voxelData.push({ indices: boneIndices, weights: boneWeights });
 }
 
 // Create geometry using current voxel size parameter
 const currentVoxelSize = window.voxelWrapParams ? window.voxelWrapParams.voxelSize : 0.012;
 const currentVoxelGeometry = new THREE.BoxGeometry(currentVoxelSize, currentVoxelSize, currentVoxelSize);
 
 // Create instanced mesh with deconstructed look
 const instancedMesh = new THREE.InstancedMesh(
 currentVoxelGeometry,
 new THREE.MeshStandardMaterial({ 
 color: 0xFF6B9D,
 roughness: 0.6,
 metalness: 0.2,
 flatShading: true,
 emissive: 0xFF1493,
 emissiveIntensity: 0.2,
 transparent: true,
 opacity: 0.85
 }),
 voxelPositions.length
 );
 
 instancedMesh.castShadow = true;
 instancedMesh.receiveShadow = true;
 instancedMesh.visible = false; // Hidden by default
 instancedMesh.name = "VoxelWrap";
 
 // Store voxel data for updates
 instancedMesh.userData.voxelData = voxelData;
 instancedMesh.userData.voxelPositions = voxelPositions;
 instancedMesh.userData.bones = bones;
 instancedMesh.userData.fingerMesh = fingerMesh;
 
 // Ensure voxel mesh has identity transform in local space
 // It will inherit parent finger's scale, rotation, and position
 instancedMesh.position.set(0, 0, 0);
 instancedMesh.rotation.set(0, 0, 0);
 instancedMesh.scale.set(1, 1, 1);
 
 console.log(`[VoxelWrap] Created ${voxelPositions.length} voxels for finger (will inherit parent transforms)`);
 
 return instancedMesh;
 }
 
 const voxelWrapMesh = createVoxelWrapForFinger(finger, skeleton.bones, 12);
 finger.add(voxelWrapMesh);
 finger.userData.voxelWrap = voxelWrapMesh;
 
 console.log(`[VoxelWrap] Main finger voxel wrap added as child (inherits scale: ${finger.scale.x.toFixed(3)}, rotation: ${finger.rotation.x.toFixed(3)})`);
 
 // Update voxel positions based on bone transforms
 function updateVoxelWrap(voxelMesh) {
 if (!voxelMesh || !voxelMesh.visible) return;
 
 const voxelData = voxelMesh.userData.voxelData;
 const voxelPositions = voxelMesh.userData.voxelPositions;
 const bones = voxelMesh.userData.bones;
 const fingerMesh = voxelMesh.userData.fingerMesh;
 
 if (!fingerMesh || !fingerMesh.skeleton) return;
 
 const matrix = new THREE.Matrix4();
 const skinMatrix = new THREE.Matrix4();
 const pos = new THREE.Vector3();
 const tmpVec = new THREE.Vector3();
 
 // Update bone matrices
 fingerMesh.skeleton.update();
 
 for (let i = 0; i < voxelPositions.length; i++) {
 const localPos = voxelPositions[i].clone();
 const data = voxelData[i];
 
 // Initialize accumulation
 pos.set(0, 0, 0);
 let totalWeight = 0;
 
 // Blend bone transforms by weight (standard skinning)
 for (let j = 0; j < 4; j++) {
 const boneIndex = data.indices[j];
 const weight = data.weights[j];
 
 if (weight > 0 && boneIndex < bones.length && bones[boneIndex]) {
 const bone = bones[boneIndex];
 
 // Compute skinning matrix: boneMatrix * inverseBindMatrix
 skinMatrix.multiplyMatrices(
 bone.matrixWorld,
 fingerMesh.skeleton.boneInverses[boneIndex]
 );
 
 // Transform the local position by skinning matrix
 tmpVec.copy(localPos);
 tmpVec.applyMatrix4(skinMatrix);
 
 // Accumulate weighted position
 pos.add(tmpVec.multiplyScalar(weight));
 totalWeight += weight;
 }
 }
 
 // Normalize if weights don't sum to 1
 if (totalWeight > 0 && Math.abs(totalWeight - 1.0) > 0.001) {
 pos.divideScalar(totalWeight);
 }
 
 // Convert from world space back to finger's local space
 // (since voxelMesh is a child of finger and inherits its transforms)
 tmpVec.copy(pos);
 fingerMesh.worldToLocal(tmpVec);
 
 // Apply style-specific transforms
 const style = window.voxelWrapStyle || 'Emerging';
 const params = window.voxelWrapParams || { emergingScale: 0.65, voxelizedScale: 1.1, rotationAmount: 0.1 };
 
 let voxelScale, shouldRotate;
 
 if (style === 'Emerging') {
 voxelScale = params.emergingScale; // Smaller, more scattered
 shouldRotate = true;
 } else { // 'Voxelized' - solid array, NO rotation
 voxelScale = params.voxelizedScale; // Larger, more solid array look
 shouldRotate = false;
 }
 
 // Create transform matrix for this voxel in local space
 matrix.makeTranslation(tmpVec.x, tmpVec.y, tmpVec.z);
 
 // Add rotation ONLY for Emerging style
 if (shouldRotate && style === 'Emerging') {
 const rotationVariation = (i * 0.123) % (Math.PI * 2);
 const rotMat = new THREE.Matrix4().makeRotationY(rotationVariation * params.rotationAmount);
 matrix.multiply(rotMat);
 }
 
 // Apply scale
 const scaleMat = new THREE.Matrix4().makeScale(voxelScale, voxelScale, voxelScale);
 matrix.multiply(scaleMat);
 
 voxelMesh.setMatrixAt(i, matrix);
 }
 
 voxelMesh.instanceMatrix.needsUpdate = true;
 }
 
 finger.userData.updateVoxelWrap = () => updateVoxelWrap(voxelWrapMesh);
 
 // Expose functions globally for static fingers
 window.createVoxelWrapForFinger = createVoxelWrapForFinger;
 window.updateVoxelWrap = updateVoxelWrap;
 
 // Create hand groups
 handsGroup = new THREE.Group();
 handsGroup.name = "Hands";
 rightHandGroup = new THREE.Group();
 rightHandGroup.name = "Right Hand";
 rightHandGroup.position.set(9.0, 4.5, -0.8); // Right hand base position
 rightHandGroup.add(finger);
 handsGroup.add(rightHandGroup);
 scene.add(handsGroup);

 const fingerBaseY = rightHandGroup.position.y;
 const fingerBaseZ = rightHandGroup.position.z;

 let hoveredKey = null;
 let targetKeyX = rightHandGroup.position.x;
 let targetKeyZ = 1.6;
 let pressedKey = null;
 let pressingFinger = false;
 let fingerPressStart = 0;
 const fingerSmoothSpeed = 0.08;
 const fingerPressDuration = 80;
 const fingerReleaseDuration = 150;

 function getKeyTopWorldY(key){
 if(!key) return null;
 const box = new THREE.Box3().setFromObject(key);
 return box.max.y;
 }

 function getFrontRowRestKey(){
 let best=null; let bestZ=-Infinity;
 for(const k of keys){
 const lbl=k.userData?.label;
 if(lbl==='Space') continue;
 if(k.position.z>bestZ){ best=k; bestZ=k.position.z; }
 }
 return best;
 }

 function computeKeyboardZSign(){
 let minZ=Infinity, maxZ=-Infinity;
 for(const k of keys){
 const z=k.position.z; if(z<minZ) minZ=z; if(z>maxZ) maxZ=z;
 }
 if(!isFinite(minZ)||!isFinite(maxZ)||Math.abs(maxZ-minZ)<1e-3) return 1;
 return (maxZ>minZ)? 1 : -1;
 }
 const keyboardZSign = computeKeyboardZSign();

 const fingerRaycaster = new THREE.Raycaster();
 const fingerMouse = new THREE.Vector2();
 let targetKeyTopY = null;
 const hoverGap = 0.05;
 renderer.domElement.addEventListener('pointermove', (e) => {
 const rect = renderer.domElement.getBoundingClientRect();
 fingerMouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
 fingerMouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
 fingerRaycaster.setFromCamera(fingerMouse, camera);
 const hits = fingerRaycaster.intersectObjects(keys, false);
 if (hits.length > 0) {
 hoveredKey = hits[0].object;
 targetKeyX = hoveredKey.position.x;
 targetKeyZ = hoveredKey.position.z;
 const topY = getKeyTopWorldY(hoveredKey);
 targetKeyTopY = (topY!=null? topY : finger.position.y) + hoverGap;
 } else {
 const restKey = getFrontRowRestKey();
 hoveredKey = null;
 if(restKey){
 targetKeyX = restKey.position.x;
 targetKeyZ = restKey.position.z;
 const topY = getKeyTopWorldY(restKey);
 targetKeyTopY = (topY!=null? topY : finger.position.y) + hoverGap;
 }else{
 targetKeyTopY = null;
 }
 }
 });
 renderer.domElement.addEventListener('pointerleave', ()=>{
 hoveredKey = null;
 targetKeyTopY = null;
 });
 renderer.domElement.addEventListener('mouseleave', ()=>{
 hoveredKey = null;
 targetKeyTopY = null;
 });

 renderer.domElement.addEventListener('pointerdown', (e) => {
 if (hoveredKey) {
 pressingFinger = true;
 pressedKey = hoveredKey;
 fingerPressStart = Date.now();
 
 // Animate key depression
 if (!hoveredKey.userData.pressed) {
 hoveredKey.userData.pressed = true;
 hoveredKey.userData.velY = -0.03;
 }
 }
 });

 const params = { Animate: true, Speed: 1.0, Amp: 1.0, MCP_Flex: 20, MCP_Splay: 0, PIP_Flex: 45, DIP_Flex: 30 };

 function getFingerTipWorldPos() {
 const tipWorldPos = new THREE.Vector3();
 tipBone.updateWorldMatrix(true, false);
 tipBone.getWorldPosition(tipWorldPos);
 return tipWorldPos;
 }

 function getMcpWorldPos(){
 const p = new THREE.Vector3();
 mcpBone.updateWorldMatrix(true, false);
 mcpBone.getWorldPosition(p);
 return p;
 }

 let t0 = performance.now();
 function animFinger() {
 const t = (performance.now() - t0) / 1000;
 
 const tipWorld = getFingerTipWorldPos();
 
 const targetTipX = targetKeyX;
 const targetTipZ = targetKeyZ;
 
 const currentTipX = tipWorld.x;
 const currentTipZ = tipWorld.z;
 const currentTipY = tipWorld.y;
 
 if (targetKeyTopY!=null) {
 const padBias = 0.0;
 const desiredTip = new THREE.Vector3(targetTipX, targetKeyTopY - padBias, targetTipZ - keyboardZSign * 0.10);
 const rootToTip = new THREE.Vector3().copy(tipWorld).sub(rightHandGroup.position);
 const followPos = new THREE.Vector3().copy(desiredTip).sub(rootToTip);
 rightHandGroup.position.lerp(followPos, 0.28);
 const baseBehind = THREE.MathUtils.lerp(0.70, 1.40, Math.min(1, Math.abs(targetTipZ) / 3.5));
 const targetBaseZConst = desiredTip.z - keyboardZSign * baseBehind;
 rightHandGroup.position.z = THREE.MathUtils.lerp(rightHandGroup.position.z, targetBaseZConst, 0.35);
 } else {
 const deltaX = (targetTipX - currentTipX) * fingerSmoothSpeed;
 const deltaZ = (targetTipZ - currentTipZ) * fingerSmoothSpeed;
 const deltaY = (targetKeyTopY!=null ? (targetKeyTopY - currentTipY) * fingerSmoothSpeed : 0);
 rightHandGroup.position.x += deltaX;
 rightHandGroup.position.z += deltaZ;
 rightHandGroup.position.y += deltaY;
 }

 if (hoveredKey && targetKeyTopY!=null){
 const fingerBounds = new THREE.Box3().setFromObject(finger);
 const bottomY = fingerBounds.min.y;
 const desiredY = targetKeyTopY;
 const alignDy = THREE.MathUtils.clamp(desiredY - bottomY, -0.25, 0.25);
 rightHandGroup.position.y += alignDy * 0.6;
 }

 if (targetKeyTopY!=null){
 const mcpW = getMcpWorldPos();
 const minMcpY = targetKeyTopY + 0.35;
 if (mcpW.y < minMcpY){
 rightHandGroup.position.y += (minMcpY - mcpW.y);
 }
 }

 const minKeyZ = 0.0;
 const maxKeyZ = 3.5;
 const reachFactor = THREE.MathUtils.clamp((targetKeyZ - minKeyZ) / (maxKeyZ - minKeyZ), 0, 1);
 
 const frontEase = reachFactor;
 const baseCurl = THREE.MathUtils.lerp(34, 20, frontEase);
 const curlRange = THREE.MathUtils.lerp(30, 16, frontEase);
 const extend = hoveredKey ? (1.0 - reachFactor) : 0.0;
 let targetMCPFlex = baseCurl + curlRange * reachFactor - 14 * extend;
 let targetPIPFlex = 52 + 24 * reachFactor - 16 * extend;
 let targetDIPFlex = 38 + 16 * reachFactor - 14 * extend;
 targetMCPFlex = Math.max(0, targetMCPFlex);
 targetPIPFlex = Math.max(0, targetPIPFlex);
 targetDIPFlex = Math.max(0, targetDIPFlex);

 if (staticFingers && staticFingers.length){
 const idle = hoveredKey ? 0 : 1;
 staticFingers.forEach((f, idx)=>{
 // Static fingers follow automatically as children of hand groups
 // Just update their bone rotations
 const curlStep = 10 * (idx+1);
 const boost = 22 + idle * 16 + curlStep;
 const b = f.bones;
 b.mcp.rotation.x = THREE.MathUtils.degToRad(params.MCP_Flex + boost);
 b.pip.rotation.x = THREE.MathUtils.degToRad(params.PIP_Flex + boost*1.15);
 b.dip.rotation.x = THREE.MathUtils.degToRad((params.DIP_Flex + boost) * 0.72);
 b.tip.rotation.x = THREE.MathUtils.degToRad((params.DIP_Flex + boost) * 0.28);
 });
 }

 let pressRotation = 0;
 let tipExtend = -0.22 * extend;
 if (pressingFinger && pressedKey) {
 const elapsed = Date.now() - fingerPressStart;
 const pressDepth = 0.5;
 const tipExtendAmount = -0.3;
 
 if (elapsed < fingerPressDuration) {
 const t = elapsed / fingerPressDuration;
 const eased = t * t * (3 - 2 * t);
 pressRotation = -pressDepth * eased;
 tipExtend = tipExtendAmount * eased;
 } else if (elapsed < fingerPressDuration + fingerReleaseDuration) {
 const t = (elapsed - fingerPressDuration) / fingerReleaseDuration;
 const eased = 1 - (t * t * (3 - 2 * t));
 pressRotation = -pressDepth * eased;
 tipExtend = tipExtendAmount * eased;
 } else {
 pressingFinger = false;
 pressedKey = null;
 pressRotation = 0;
 tipExtend = 0;
 }
 }
 
 if (!hoveredKey){
 const retreat = THREE.MathUtils.lerp(0.0, 0.25, frontEase);
 const targetZ = fingerBaseZ - retreat;
 rightHandGroup.position.z = THREE.MathUtils.lerp(rightHandGroup.position.z, targetZ, 0.12);
 }
 const baseTilt = 0.92;
 finger.rotation.x = -Math.PI / 2 + baseTilt + pressRotation;

 const sp = params.Speed, A = 0.3, anim = params.Animate ? 1 : 0;
 const currentMCPFlex = THREE.MathUtils.lerp(
 THREE.MathUtils.degToRad(params.MCP_Flex),
 THREE.MathUtils.degToRad(targetMCPFlex),
 0.1
 );
 params.MCP_Flex = THREE.MathUtils.lerp(params.MCP_Flex, targetMCPFlex, 0.1);
 params.PIP_Flex = THREE.MathUtils.lerp(params.PIP_Flex, targetPIPFlex, 0.1);
 params.DIP_Flex = THREE.MathUtils.lerp(params.DIP_Flex, targetDIPFlex, 0.1);

 const mcpForwardBias = THREE.MathUtils.degToRad(8.5);
 mcpBone.rotation.x = THREE.MathUtils.degToRad(params.MCP_Flex) + anim * (0.25 * A * Math.sin(t * 0.6 * sp)) + mcpForwardBias;
 mcpBone.rotation.z = THREE.MathUtils.degToRad(params.MCP_Splay) + anim * (0.02 * Math.sin(t * 0.8 * sp));
 const pipForwardBias = THREE.MathUtils.degToRad(14);
 const pipFlex = THREE.MathUtils.degToRad(params.PIP_Flex) + anim * (0.65 * A * Math.sin(t * 0.7 * sp + 1)) + tipExtend * 0.6 + pipForwardBias;
 const dipFlex = THREE.MathUtils.degToRad(params.DIP_Flex) + anim * (0.55 * A * Math.sin(t * 0.9 * sp + 2)) + tipExtend * 0.9;
 pipBone.rotation.x = pipFlex;
 dipBone.rotation.x = dipFlex * 0.72;
 tipBone.rotation.x = dipFlex * 0.28;

 if (finger && finger.geometry.userData.wrinkleData) {
 const wrinkleData = finger.geometry.userData.wrinkleData;
 const origPos = finger.geometry.userData.originalPositions;
 const pos = finger.geometry.getAttribute('position');
 const pipWrinkleAmount = Math.max(0, -pipFlex) * 2.5;
 const dipWrinkleAmount = Math.max(0, -dipFlex) * 2.5;
 for (let i = 0; i < pos.count; i++) {
 const y = origPos[i * 3 + 1];
 let wrinkleIntensity = 0;
 if (Math.abs(y - PIP) < 0.05 * LEN) wrinkleIntensity += pipWrinkleAmount;
 if (Math.abs(y - DIP) < 0.04 * LEN) wrinkleIntensity += dipWrinkleAmount;
 wrinkleIntensity = Math.min(wrinkleIntensity, 1.0);
 pos.setXYZ(i,
 origPos[i * 3 + 0] + wrinkleData[i * 3 + 0] * wrinkleIntensity,
 origPos[i * 3 + 1] + wrinkleData[i * 3 + 1] * wrinkleIntensity,
 origPos[i * 3 + 2] + wrinkleData[i * 3 + 2] * wrinkleIntensity
 );
 }
 pos.needsUpdate = true;
 finger.geometry.computeVertexNormals();
 }

 requestAnimationFrame(animFinger);
 }
 animFinger();
 
 window.__indexFinger = { finger, mcpBone, pipBone, dipBone, tipBone, skeleton, nailMesh, LEN, PIP, DIP, params };
 }catch(e){ console.warn('Full finger rig load failed',e); }
 }
 
 // Add static fingers (3 additional fingers for right hand)
 setTimeout(() => {
 if (!window.__indexFinger) return;
 const ref = window.__indexFinger;
 const fingerConfigs = [
 { x: 1.2, scale: 0.98, curl: 1.05, name: 'middle' },
 { x: 2.4, scale: 0.95, curl: 1.10, name: 'ring' },
 { x: 3.6, scale: 0.90, curl: 1.15, name: 'pinky' }
 ];
 
 fingerConfigs.forEach((config) => {
 const clonedFingerGeo = ref.finger.geometry.clone();
 const clonedFingerMat = ref.finger.material.clone();
 const clonedFinger = new THREE.SkinnedMesh(clonedFingerGeo, clonedFingerMat);
 
 const clonedMcp = new THREE.Bone();
 clonedMcp.position.copy(ref.mcpBone.position);
 const clonedPip = new THREE.Bone();
 clonedPip.position.copy(ref.pipBone.position);
 const clonedDip = new THREE.Bone();
 clonedDip.position.copy(ref.dipBone.position);
 const clonedTip = new THREE.Bone();
 clonedTip.position.copy(ref.tipBone.position);
 
 clonedMcp.add(clonedPip);
 clonedPip.add(clonedDip);
 clonedDip.add(clonedTip);
 
 clonedFinger.add(clonedMcp);
 const clonedSkeleton = new THREE.Skeleton([clonedMcp, clonedPip, clonedDip, clonedTip]);
 clonedFinger.bind(clonedSkeleton);
 
 const curlFactor = config.curl;
 clonedMcp.rotation.x = THREE.MathUtils.degToRad(ref.params.MCP_Flex * curlFactor);
 clonedPip.rotation.x = THREE.MathUtils.degToRad(ref.params.PIP_Flex * curlFactor);
 clonedDip.rotation.x = THREE.MathUtils.degToRad(ref.params.DIP_Flex * curlFactor * 0.72);
 clonedTip.rotation.x = THREE.MathUtils.degToRad(ref.params.DIP_Flex * curlFactor * 0.28);
 
 // Position relative to main finger - start at same base position
 clonedFinger.position.set(config.x, 0, 0); // Offset in local space
 clonedFinger.rotation.copy(ref.finger.rotation);
 const baseScale = ref.finger.scale.x;
 const scaleVal = baseScale * config.scale;
 clonedFinger.scale.set(scaleVal, scaleVal, scaleVal);
 
 clonedFinger.userData.offsetX = config.x;
 clonedFinger.userData.isStatic = true;
 
 if (ref.nailMesh && ref.nailMesh.geometry) {
 const clonedNailGeo = ref.nailMesh.geometry.clone();
 const clonedNailMat = ref.nailMesh.material.clone();
 const clonedNail = new THREE.SkinnedMesh(clonedNailGeo, clonedNailMat);
 
 clonedNail.bind(clonedSkeleton);
 clonedFinger.add(clonedNail);
 
 if (ref.finger.children) {
 const nailTipOriginal = ref.finger.children.find(c => c.material && c.material.transparent && c.material.opacity < 0.5);
 if (nailTipOriginal && nailTipOriginal.geometry) {
 const clonedTipGeo = nailTipOriginal.geometry.clone();
 const clonedTipMat = nailTipOriginal.material.clone();
 const clonedTip = new THREE.SkinnedMesh(clonedTipGeo, clonedTipMat);
 clonedTip.bind(clonedSkeleton);
 clonedFinger.add(clonedTip);
 }
 }
 }
 
 // Create voxel wrap for static finger (reuse function from main finger)
 if (window.createVoxelWrapForFinger) {
 try {
 const staticVoxelWrap = window.createVoxelWrapForFinger(clonedFinger, clonedSkeleton.bones, 12);
 clonedFinger.add(staticVoxelWrap);
 clonedFinger.userData.voxelWrap = staticVoxelWrap;
 clonedFinger.userData.updateVoxelWrap = () => {
 if (window.updateVoxelWrap) {
 window.updateVoxelWrap(staticVoxelWrap);
 }
 };
 console.log(`[VoxelWrap] Created voxel wrap for static finger: ${config.name}`);
 } catch (err) {
 console.warn(`[VoxelWrap] Could not create voxel wrap for ${config.name}:`, err);
 }
 }
 
 rightHandGroup.add(clonedFinger);
 staticFingers.push({ 
 fingerMesh: clonedFinger,
 mesh: clonedFinger, 
 bones: { mcp: clonedMcp, pip: clonedPip, dip: clonedDip, tip: clonedTip },
 baseCurl: curlFactor,
 phase: Math.random() * Math.PI * 2
 });
 });
 }, 100);

 // Add LEFT HAND (4 fingers)
 setTimeout(() => {
 if (!window.__indexFinger) return;
 const ref = window.__indexFinger;
 
 // Create left hand group
 leftHandGroup = new THREE.Group();
 leftHandGroup.name = "Left Hand";
 leftHandGroup.position.set(3.0, 4.5, -0.8); // Left side of keyboard
 handsGroup.add(leftHandGroup);
 
 const leftFingerConfigs = [
 { x: 0.0, scale: 1.0, curl: 1.0, name: 'index-L' }, // Match main pointer finger
 { x: -1.2, scale: 0.98, curl: 1.05, name: 'middle-L' }, // Match right hand middle
 { x: -2.4, scale: 0.95, curl: 1.10, name: 'ring-L' }, // Match right hand ring
 { x: -3.6, scale: 0.90, curl: 1.15, name: 'pinky-L' } // Match right hand pinky
 ];
 
 leftFingerConfigs.forEach((config) => {
 const clonedFingerGeo = ref.finger.geometry.clone();
 const clonedFingerMat = ref.finger.material.clone();
 const clonedFinger = new THREE.SkinnedMesh(clonedFingerGeo, clonedFingerMat);
 
 const clonedMcp = new THREE.Bone();
 clonedMcp.position.copy(ref.mcpBone.position);
 const clonedPip = new THREE.Bone();
 clonedPip.position.copy(ref.pipBone.position);
 const clonedDip = new THREE.Bone();
 clonedDip.position.copy(ref.dipBone.position);
 const clonedTip = new THREE.Bone();
 clonedTip.position.copy(ref.tipBone.position);
 
 clonedMcp.add(clonedPip);
 clonedPip.add(clonedDip);
 clonedDip.add(clonedTip);
 
 clonedFinger.add(clonedMcp);
 const clonedSkeleton = new THREE.Skeleton([clonedMcp, clonedPip, clonedDip, clonedTip]);
 clonedFinger.bind(clonedSkeleton);
 
 const curlFactor = config.curl;
 clonedMcp.rotation.x = THREE.MathUtils.degToRad(ref.params.MCP_Flex * curlFactor);
 clonedPip.rotation.x = THREE.MathUtils.degToRad(ref.params.PIP_Flex * curlFactor);
 clonedDip.rotation.x = THREE.MathUtils.degToRad(ref.params.DIP_Flex * curlFactor * 0.72);
 clonedTip.rotation.x = THREE.MathUtils.degToRad(ref.params.DIP_Flex * curlFactor * 0.28);
 
 // Position relative in local space
 clonedFinger.position.set(config.x, 0, 0);
 clonedFinger.rotation.copy(ref.finger.rotation);
 const baseScale = ref.finger.scale.x;
 const scaleVal = baseScale * config.scale;
 clonedFinger.scale.set(scaleVal, scaleVal, scaleVal);
 
 clonedFinger.userData.offsetX = config.x;
 clonedFinger.userData.isLeftHand = true;
 
 if (ref.nailMesh && ref.nailMesh.geometry) {
 const clonedNailGeo = ref.nailMesh.geometry.clone();
 const clonedNailMat = ref.nailMesh.material.clone();
 const clonedNail = new THREE.SkinnedMesh(clonedNailGeo, clonedNailMat);
 
 clonedNail.bind(clonedSkeleton);
 clonedFinger.add(clonedNail);
 
 if (ref.finger.children) {
 const nailTipOriginal = ref.finger.children.find(c => c.material && c.material.transparent && c.material.opacity < 0.5);
 if (nailTipOriginal && nailTipOriginal.geometry) {
 const clonedTipGeo = nailTipOriginal.geometry.clone();
 const clonedTipMat = nailTipOriginal.material.clone();
 const clonedTip = new THREE.SkinnedMesh(clonedTipGeo, clonedTipMat);
 clonedTip.bind(clonedSkeleton);
 clonedFinger.add(clonedTip);
 }
 }
 }
 
 // Create voxel wrap for left hand finger
 if (window.createVoxelWrapForFinger) {
 try {
 const staticVoxelWrap = window.createVoxelWrapForFinger(clonedFinger, clonedSkeleton.bones, 12);
 clonedFinger.add(staticVoxelWrap);
 clonedFinger.userData.voxelWrap = staticVoxelWrap;
 clonedFinger.userData.updateVoxelWrap = () => {
 if (window.updateVoxelWrap) {
 window.updateVoxelWrap(staticVoxelWrap);
 }
 };
 console.log(`[VoxelWrap] Created voxel wrap for left hand finger: ${config.name}`);
 } catch (err) {
 console.warn(`[VoxelWrap] Could not create voxel wrap for ${config.name}:`, err);
 }
 }
 
 leftHandGroup.add(clonedFinger);
 staticFingers.push({ 
 fingerMesh: clonedFinger,
 mesh: clonedFinger, 
 bones: { mcp: clonedMcp, pip: clonedPip, dip: clonedDip, tip: clonedTip },
 baseCurl: curlFactor,
 phase: Math.random() * Math.PI * 2
 });
 });
 }, 100);

 function initializeCharacter() {
 // Create Celli Avatar group
 celliAvatarGroup = new THREE.Group();
 celliAvatarGroup.name = "Celli Avatar";
 
 characterGroup = new THREE.Group();
 characterGroup.name = "Celli Body";
 characterGroup.visible = true; // Visible by default
 characterGroup.position.set(0, 0, 0); // Relative to celliAvatarGroup
 characterGroup.scale.setScalar(0.8); // Match human scale relative to keyboard
 
 // Create character bust from bust.html code - ZSphere system
 skinMat = new THREE.MeshPhysicalMaterial({
 color: 0xe7e2dc,
 roughness: 0.55,
 metalness: 0.0,
 clearcoat: 0.4,
 clearcoatRoughness: 0.6,
 sheen: 0.5,
 sheenRoughness: 0.8,
 });
 
 // ZSphere structure for hourglass figure
 characterZSpheres = [
 // Torso chain
 { pos: new THREE.Vector3(0, 0.15, 0), radius: 0.44, scale: new THREE.Vector3(1.0, 0.5, 0.9), parent: -1, name: "Hips" },
 { pos: new THREE.Vector3(0, 0.35, 0), radius: 0.34, scale: new THREE.Vector3(0.68, 0.7, 0.6), parent: 0, name: "Waist" },
 { pos: new THREE.Vector3(0, 0.58, 0), radius: 0.38, scale: new THREE.Vector3(0.88, 0.65, 0.72), parent: 1, name: "Ribcage" },
 { pos: new THREE.Vector3(0, 0.82, 0), radius: 0.36, scale: new THREE.Vector3(0.95, 0.5, 0.78), parent: 2, name: "Upper Chest" },
 // Breasts
 { pos: new THREE.Vector3(-0.18, 0.68, 0.12), radius: 0.16, scale: new THREE.Vector3(0.95, 1.1, 1.15), parent: 2, name: "Left Breast" },
 { pos: new THREE.Vector3(0.18, 0.68, 0.12), radius: 0.16, scale: new THREE.Vector3(0.95, 1.1, 1.15), parent: 2, name: "Right Breast" },
 // Left arm
 { pos: new THREE.Vector3(-0.32, 0.82, 0), radius: 0.14, scale: new THREE.Vector3(1.0, 1.0, 1.0), parent: 3, name: "Left Shoulder" },
 { pos: new THREE.Vector3(-0.38, 0.72, 0), radius: 0.10, scale: new THREE.Vector3(1.0, 1.2, 1.0), parent: 6, name: "Left Bicep Upper" },
 { pos: new THREE.Vector3(-0.42, 0.58, 0), radius: 0.09, scale: new THREE.Vector3(1.0, 1.3, 1.0), parent: 7, name: "Left Bicep Lower" },
 // Right arm
 { pos: new THREE.Vector3(0.32, 0.82, 0), radius: 0.14, scale: new THREE.Vector3(1.0, 1.0, 1.0), parent: 3, name: "Right Shoulder" },
 { pos: new THREE.Vector3(0.38, 0.72, 0), radius: 0.10, scale: new THREE.Vector3(1.0, 1.2, 1.0), parent: 9, name: "Right Bicep Upper" },
 { pos: new THREE.Vector3(0.42, 0.58, 0), radius: 0.09, scale: new THREE.Vector3(1.0, 1.3, 1.0), parent: 10, name: "Right Bicep Lower" },
 ];
 
 // Create merged geometry from ZSpheres (preview mesh)
 function createPreviewMesh() {
 const geometries = characterZSpheres.map(sphere => {
 const geo = new THREE.SphereGeometry(sphere.radius, 48, 32);
 geo.scale(sphere.scale.x, sphere.scale.y, sphere.scale.z);
 geo.translate(sphere.pos.x, sphere.pos.y, sphere.pos.z);
 return geo;
 });
 
 const merged = BufferGeometryUtils.mergeGeometries(geometries, false);
 merged.computeVertexNormals();
 
 // Create a separate material instance for preview mesh
 const previewMat = new THREE.MeshPhysicalMaterial({
 color: 0xe7e2dc,
 roughness: 0.55,
 metalness: 0.0,
 clearcoat: 0.4,
 clearcoatRoughness: 0.6,
 sheen: 0.5,
 sheenRoughness: 0.8,
 });
 
 return new THREE.Mesh(merged, previewMat);
 }
 
 // Create unified mesh with proper wrapping/smoothing
 // Helper: Calculate distance from point to ellipsoid surface
 function distanceToEllipsoid(point, sphere) {
 const localX = (point.x - sphere.pos.x) / sphere.scale.x;
 const localY = (point.y - sphere.pos.y) / sphere.scale.y;
 const localZ = (point.z - sphere.pos.z) / sphere.scale.z;
 
 const dist = Math.sqrt(localX * localX + localY * localY + localZ * localZ);
 return dist - sphere.radius;
 }
 
 // Helper: Check if two spheres are connected (parent-child relationship)
 function areConnected(idx1, idx2) {
 if (idx1 === idx2) return true;
 
 const s1 = characterZSpheres[idx1];
 const s2 = characterZSpheres[idx2];
 
 // Direct parent-child relationship
 if (s1.parent === idx2 || s2.parent === idx1) return true;
 
 // Siblings (same parent)
 if (s1.parent !== -1 && s1.parent === s2.parent) return true;
 
 // Check connection through chain
 let current = idx1;
 for (let i = 0; i < 10; i++) { // Max depth
 if (current === idx2) return true;
 if (current === -1) break;
 const sphere = characterZSpheres[current];
 current = sphere ? sphere.parent : -1;
 }
 
 current = idx2;
 for (let i = 0; i < 10; i++) {
 if (current === idx1) return true;
 if (current === -1) break;
 const sphere = characterZSpheres[current];
 current = sphere ? sphere.parent : -1;
 }
 
 return false;
 }
 
 // Helper: Find furthest surface point along a ray direction (with bone hierarchy)
 function findExteriorRadius(y, theta) {
 const dir = new THREE.Vector3(Math.cos(theta), 0, Math.sin(theta));
 let maxRadius = 0;
 let closestSphereIdx = -1;
 
 // Sample along the ray to find where any sphere is present
 for (let r = 0; r < 1.0; r += 0.005) {
 const testPoint = new THREE.Vector3(dir.x * r, y, dir.z * r);
 
 // Check distance to each sphere
 let minDist = Infinity;
 let nearestIdx = -1;
 
 characterZSpheres.forEach((sphere, idx) => {
 const dist = distanceToEllipsoid(testPoint, sphere);
 if (dist < minDist) {
 minDist = dist;
 nearestIdx = idx;
 }
 });
 
 // Only blend if connected to the closest sphere found so far
 if (closestSphereIdx === -1 || areConnected(nearestIdx, closestSphereIdx)) {
 if (minDist < 0.02) { // Soft threshold for smoother blend
 maxRadius = r;
 if (closestSphereIdx === -1) {
 closestSphereIdx = nearestIdx;
 }
 }
 }
 }
 
 return maxRadius;
 }
 
 // Laplacian smoothing for mesh
 function smoothMesh(positions, radialSegments, heightSegments, iterations = 3) {
 const smoothed = new Float32Array(positions);
 
 for (let iter = 0; iter < iterations; iter++) {
 const temp = new Float32Array(smoothed);
 
 for (let h = 1; h < heightSegments; h++) { // Skip top and bottom
 for (let r = 0; r <= radialSegments; r++) {
 const idx = (h * (radialSegments + 1) + r) * 3;
 
 // Get neighbors
 const neighbors = [];
 // Above and below
 if (h > 0) neighbors.push((h - 1) * (radialSegments + 1) + r);
 if (h < heightSegments) neighbors.push((h + 1) * (radialSegments + 1) + r);
 // Left and right (circular)
 const rPrev = r === 0 ? radialSegments - 1 : r - 1;
 const rNext = r === radialSegments ? 1 : r + 1;
 neighbors.push(h * (radialSegments + 1) + rPrev);
 neighbors.push(h * (radialSegments + 1) + rNext);
 
 // Average neighbor positions
 let avgX = 0, avgY = 0, avgZ = 0;
 for (const nIdx of neighbors) {
 avgX += temp[nIdx * 3];
 avgY += temp[nIdx * 3 + 1];
 avgZ += temp[nIdx * 3 + 2];
 }
 avgX /= neighbors.length;
 avgY /= neighbors.length;
 avgZ /= neighbors.length;
 
 // Blend with original (higher weight on XZ, less on Y)
 smoothed[idx] = temp[idx] * 0.3 + avgX * 0.7;
 smoothed[idx + 1] = temp[idx + 1] * 0.7 + avgY * 0.3; // Less smoothing on Y
 smoothed[idx + 2] = temp[idx + 2] * 0.3 + avgZ * 0.7;
 }
 }
 }
 
 return smoothed;
 }
 
 // Create unified tubular mesh that wraps around body shapes (bust.html method)
 function createUnifiedMesh() {
 const radialSegments = 64;
 const heightSegments = 100;
 const height = 1.0;
 
 const positions = [];
 const indices = [];
 
 // Generate vertices by tracing exterior surface
 for (let h = 0; h <= heightSegments; h++) {
 const y = (h / heightSegments) * height;
 
 // Generate ring of vertices by finding exterior boundary
 for (let r = 0; r <= radialSegments; r++) {
 const theta = (r / radialSegments) * Math.PI * 2;
 
 // Find the actual exterior radius at this height and angle
 const radius = findExteriorRadius(y, theta);
 
 const x = Math.cos(theta) * radius;
 const z = Math.sin(theta) * radius;
 
 positions.push(x, y, z);
 }
 }
 
 // Apply smoothing
 const smoothedPositions = smoothMesh(positions, radialSegments, heightSegments, 5);
 
 // Generate indices
 for (let h = 0; h < heightSegments; h++) {
 for (let r = 0; r < radialSegments; r++) {
 const a = h * (radialSegments + 1) + r;
 const b = a + 1;
 const c = (h + 1) * (radialSegments + 1) + r;
 const d = c + 1;
 
 indices.push(a, c, b);
 indices.push(b, c, d);
 }
 }
 
 const geometry = new THREE.BufferGeometry();
 geometry.setAttribute('position', new THREE.BufferAttribute(smoothedPositions, 3));
 geometry.setIndex(indices);
 geometry.computeVertexNormals();
 
 const unifiedMat = new THREE.MeshPhysicalMaterial({
 color: 0xe7e2dc,
 roughness: 0.55,
 metalness: 0.0,
 clearcoat: 0.4,
 clearcoatRoughness: 0.6,
 sheen: 0.5,
 sheenRoughness: 0.8,
 });
 
 console.log('[UnifiedMesh] Created true unified tubular mesh using bust.html method (exterior surface tracing)');
 return new THREE.Mesh(geometry, unifiedMat);
 }
 
 // Create both meshes with their own materials
 characterBust = createPreviewMesh();
 characterBust.castShadow = true;
 characterBust.receiveShadow = false;
 characterBust.visible = true; // Show base mesh by default
 characterBust.name = "PreviewMesh";
 characterGroup.add(characterBust);
 
 characterUnifiedMesh = createUnifiedMesh();
 characterUnifiedMesh.castShadow = true;
 characterUnifiedMesh.receiveShadow = false;
 characterUnifiedMesh.visible = false; // Hidden by default
 characterUnifiedMesh.name = "UnifiedMesh";
 characterGroup.add(characterUnifiedMesh);
 
 // Store sphere markers for editing (initially hidden)
 characterZSpheres.forEach((sphere, idx) => {
 const markerGeo = new THREE.SphereGeometry(sphere.radius * 0.95, 16, 16);
 const markerMat = new THREE.MeshBasicMaterial({ 
 color: 0x4a7cff, 
 transparent: true,
 opacity: 0.3,
 wireframe: true 
 });
 const marker = new THREE.Mesh(markerGeo, markerMat);
 marker.position.copy(sphere.pos);
 marker.scale.copy(sphere.scale);
 marker.userData.sphereIndex = idx;
 marker.visible = false;
 characterGroup.add(marker);
 characterPoseSpheres.push(marker);
 });
 
 // Plinth/base
 const plinth = new THREE.Mesh(
 new THREE.CylinderGeometry(0.42, 0.46, 0.18, 48),
 new THREE.MeshStandardMaterial({ color:0x1a1e25, metalness:0.1, roughness:0.85 })
 );
 plinth.position.y = 0.12;
 plinth.receiveShadow = true;
 characterGroup.add(plinth);
 
 // Slight rotation for posed look
 characterGroup.rotation.y = THREE.MathUtils.degToRad(10);
 
celliAvatarGroup.add(characterGroup);
}

// ===== Head Preset Configurations =====
// Define presets before initializeVoxelHead uses them
const headPresets = {
'sparse-blue': {
animSpeed: 1.15, amplitude: 0.15, opacityMin: 0.3, opacityMax: 0.85,
emissive: 0.8, lightInt: 2.5, lightPulse: true, rotationSpeed: 0.3, color: '#95bfff',
voxelSize: 0.10, shellThickness: 0.12, voxelSpacing: 1.05, phaseNoise: 0.75, 
falloff: 0.85, noiseWarp: 0.15, opacitySpeed: 0.8, metalness: 0.2, roughness: 0.55
},
'intro-celli': {
animSpeed: 1.15, amplitude: 0.28, opacityMin: 0.85, opacityMax: 0.95,
emissive: 0.6, lightInt: 3.5, lightPulse: true, rotationSpeed: 0.3, color: '#ffb850',
voxelSize: 0.25, shellThickness: 0.35, voxelSpacing: 0.9, phaseNoise: 0.75,
falloff: 0.85, noiseWarp: 0.15, opacitySpeed: 0.8, metalness: 0.2, roughness: 0.55
},
'dense-cyan': {
animSpeed: 0.8, amplitude: 0.25, opacityMin: 0.5, opacityMax: 0.95,
emissive: 1.2, lightInt: 3.5, lightPulse: true, rotationSpeed: 0.2, color: '#00ffff',
voxelSize: 0.10, shellThickness: 0.20, voxelSpacing: 1.05, phaseNoise: 0.75,
falloff: 0.85, noiseWarp: 0.15, opacitySpeed: 0.8, metalness: 0.2, roughness: 0.55
},
'warm-glow': {
animSpeed: 1.5, amplitude: 0.12, opacityMin: 0.4, opacityMax: 0.9,
emissive: 1.5, lightInt: 4.0, lightPulse: false, rotationSpeed: 0.15, color: '#ffaa55',
voxelSize: 0.10, shellThickness: 0.12, voxelSpacing: 1.05, phaseNoise: 0.75,
falloff: 0.85, noiseWarp: 0.15, opacitySpeed: 0.8, metalness: 0.2, roughness: 0.55
},
'neon-pink': {
animSpeed: 2.0, amplitude: 0.2, opacityMin: 0.35, opacityMax: 0.88,
emissive: 1.8, lightInt: 5.0, lightPulse: true, rotationSpeed: 0.5, color: '#ff1493',
voxelSize: 0.10, shellThickness: 0.12, voxelSpacing: 1.05, phaseNoise: 0.75,
falloff: 0.85, noiseWarp: 0.15, opacitySpeed: 0.8, metalness: 0.2, roughness: 0.55
},
'ghost-white': {
animSpeed: 0.5, amplitude: 0.08, opacityMin: 0.15, opacityMax: 0.5,
emissive: 0.5, lightInt: 1.5, lightPulse: false, rotationSpeed: 0.1, color: '#f0f0ff',
voxelSize: 0.10, shellThickness: 0.12, voxelSpacing: 1.05, phaseNoise: 0.75,
falloff: 0.85, noiseWarp: 0.15, opacitySpeed: 0.8, metalness: 0.2, roughness: 0.55
}
};

function initializeVoxelHead() {
voxelHeadGroup = new THREE.Group();
voxelHeadGroup.name = "Celli Head";
// In sequence mode, head is visible; in debug mode, default to hidden
voxelHeadGroup.visible = EXEC_ENV_MODE === 'sequence';
voxelHeadGroup.position.set(0, 1.5, 0); // Relative to body (character is at -3, 0.5, 3)
voxelHeadGroup.scale.setScalar(0.3);

// Create glowing voxel head using SDF-based shell wrapping (from bosscelli.html)
// Get preset based on mode
const defaultPreset = EXEC_ENV_MODE === 'sequence' ? 'intro-celli' : 'sparse-blue';
const preset = headPresets[defaultPreset];

// Use preset parameters (can be overridden via debug controls)
const voxelSize = window.headVoxelSize || preset.voxelSize;
const headSizeX = 2.4;
const headSizeY = 1.6; // Shorter height
const headSizeZ = 1.4; // Much thinner, more slab-like (was 2.2)
const cornerRadius = 0.45; // More rounded corners (was 0.35)
const shellThickness = window.headVoxelLayers || preset.shellThickness;
 
 // Helper: SDF for rounded box (head shape)
 function sdfRoundedBox(p, hx, hy, hz, r) {
 const qx = Math.abs(p.x) - hx;
 const qy = Math.abs(p.y) - hy;
 const qz = Math.abs(p.z) - hz;
 const q = new THREE.Vector3(Math.max(qx, 0), Math.max(qy, 0), Math.max(qz, 0));
 const outside = q.length();
 const inside = Math.min(Math.max(qx, Math.max(qy, qz)), 0.0);
 return outside + inside - r;
 }
 
 // Check if point is in face cutout (eyes, mouth)
 function isInFaceCutout(p) {
 // Only check front face
 if (p.z < headSizeZ * 0.25) return false;
 
 // Eyes (elliptical)
 const eyeRadiusX = headSizeY * 0.22;
 const eyeRadiusY = headSizeY * 0.16;
 const eyeY = headSizeY * 0.15;
 const eyeSpacing = headSizeX * 0.3;
 
 const leftEyeX = (p.x + eyeSpacing) / eyeRadiusX;
 const leftEyeY = (p.y - eyeY) / eyeRadiusY;
 if (leftEyeX * leftEyeX + leftEyeY * leftEyeY < 1.0) return true;
 
 const rightEyeX = (p.x - eyeSpacing) / eyeRadiusX;
 const rightEyeY = (p.y - eyeY) / eyeRadiusY;
 if (rightEyeX * rightEyeX + rightEyeY * rightEyeY < 1.0) return true;
 
 // Smile/Frown (controlled by deformation parameter: 1=smile, 0=neutral, -1=frown)
 const mouthDeform = window.headMouthDeform !== undefined ? window.headMouthDeform : 1.0;
 const smileRadius = headSizeY * 0.08;
 const smileY = -headSizeY * 0.2;
 const smileWidth = headSizeX * 0.55;
 const smileCurve = headSizeY * 0.15 * mouthDeform; // Curve direction controlled by deform
 
 const smileT = (p.x / smileWidth) + 0.5;
 if (smileT >= 0 && smileT <= 1) {
 const smileYOffset = -Math.pow((smileT - 0.5) * 2, 2) * smileCurve;
 const smileCenterY = smileY + smileYOffset;
 const smileDist = Math.abs(p.y - smileCenterY);
 if (smileDist < smileRadius && Math.abs(p.x) < smileWidth * 0.5) {
 return true;
 }
 }
 
 return false;
 }
 
 // Generate voxel shell
 const half = new THREE.Vector3(headSizeX * 0.5, headSizeY * 0.5, headSizeZ * 0.5);
 const margin = cornerRadius + shellThickness + 0.4;
 const min = new THREE.Vector3(-half.x - margin, -half.y - margin, -half.z - margin);
 const max = new THREE.Vector3(half.x + margin, half.y + margin, half.z + margin);
 
// Voxel spacing controlled by global parameter or preset
const voxelSpacing = window.headVoxelSpacing || preset.voxelSpacing;
const step = voxelSize * voxelSpacing;
 const instances = [];
 
 for (let x = min.x; x <= max.x; x += step) {
 for (let y = min.y; y <= max.y; y += step) {
 for (let z = min.z; z <= max.z; z += step) {
 const p = new THREE.Vector3(x, y, z);
 const d = sdfRoundedBox(p, half.x, half.y, half.z, cornerRadius);
 
 if (d > -0.02 && d < shellThickness) {
 if (!isInFaceCutout(p)) {
 instances.push({
 basePos: p.clone(),
 id: instances.length,
 colorAlt: instances.length % 5 === 0
 });
 }
 }
 }
 }
 }
 
console.log(`[Voxel Head] Generated ${instances.length} voxel instances (voxelSize: ${voxelSize}, spacing: ${voxelSpacing}, shellThickness: ${shellThickness})`);

// Create instanced mesh with preset color
const cubeGeo = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);
const presetColor = new THREE.Color(preset.color);
const instancedMesh = new THREE.InstancedMesh(
cubeGeo,
new THREE.MeshStandardMaterial({ 
color: presetColor,
metalness: preset.metalness,
roughness: preset.roughness,
transparent: true,
opacity: preset.opacityMax, // Use preset max opacity for base material
emissive: presetColor,
emissiveIntensity: preset.emissive,
depthWrite: false,
side: THREE.DoubleSide
}),
instances.length
);
instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

// Enable per-instance colors for "TURN BACK" text highlighting
instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(
new Float32Array(instances.length * 3), 3
);
// Initialize all colors to preset color
const defaultColor = new THREE.Color(preset.color);
for (let i = 0; i < instances.length; i++) {
instancedMesh.setColorAt(i, defaultColor);
}
instancedMesh.instanceColor.needsUpdate = true;
 
 // Set initial positions
 const tmpObj = new THREE.Object3D();
 instances.forEach((inst, i) => {
 tmpObj.position.copy(inst.basePos);
 tmpObj.scale.setScalar(voxelSize);
 tmpObj.updateMatrix();
 instancedMesh.setMatrixAt(i, tmpObj.matrix);
 });
 
voxelHeadGroup.add(instancedMesh);
voxelHeadGroup.userData.instances = instances;
voxelHeadGroup.userData.instancedMesh = instancedMesh;
voxelHeadGroup.userData.baseVoxelSize = voxelSize; // Store base size
voxelHeadGroup.userData.isSequenceMode = EXEC_ENV_MODE === 'sequence'; // Store mode
voxelHeadGroup.userData.currentPreset = defaultPreset; // Store which preset is active

// Add internal glow light with preset color
const headLight = new THREE.PointLight(presetColor, preset.lightInt, 4);
headLight.position.set(0, 0, 0);
voxelHeadGroup.add(headLight);
voxelHeadGroup.userData.headLight = headLight;

// Add eye lights (positioned behind the eye cutouts)
const eyeY = headSizeY * 0.15;
const eyeSpacing = headSizeX * 0.3;
const eyeLightZ = -headSizeZ * 0.3; // Behind the eyes

const leftEyeLight = new THREE.PointLight(0xffffaa, 2.5, 2);
leftEyeLight.position.set(-eyeSpacing, eyeY, eyeLightZ);
voxelHeadGroup.add(leftEyeLight);

const rightEyeLight = new THREE.PointLight(0xffffaa, 2.5, 2);
rightEyeLight.position.set(eyeSpacing, eyeY, eyeLightZ);
voxelHeadGroup.add(rightEyeLight);

voxelHeadGroup.userData.eyeLights = [leftEyeLight, rightEyeLight];

// Add pulsating pink cheek orbs (positioned on the sides of the face)
const cheekY = headSizeY * 0.05; // Slightly below eyes
const cheekX = headSizeX * 0.55; // On the sides
const cheekZ = headSizeZ * 0.4; // Front of face

const cheekGeometry = new THREE.SphereGeometry(0.15, 16, 16);
cheekGeometry.scale(1.2, 0.8, 0.6); // Make it oval (wider than tall)

const cheekMaterial = new THREE.MeshStandardMaterial({
color: 0xff69b4, // Pink
emissive: 0xff69b4,
emissiveIntensity: 0.6,
transparent: true,
opacity: 0.7,
roughness: 0.3,
metalness: 0.1
});

const leftCheek = new THREE.Mesh(cheekGeometry, cheekMaterial.clone());
leftCheek.position.set(-cheekX, cheekY, cheekZ);
voxelHeadGroup.add(leftCheek);

const rightCheek = new THREE.Mesh(cheekGeometry, cheekMaterial.clone());
rightCheek.position.set(cheekX, cheekY, cheekZ);
voxelHeadGroup.add(rightCheek);

voxelHeadGroup.userData.cheeks = [leftCheek, rightCheek];
voxelHeadGroup.userData.cheekBaseScale = 1.0;

console.log(`[Voxel Head] Mode: ${EXEC_ENV_MODE}, Preset: ${defaultPreset}, Color: ${preset.color}, Visible: ${voxelHeadGroup.visible}, Instances: ${instances.length}`);
 
celliAvatarGroup.add(voxelHeadGroup);

// Position, rotate, and scale the avatar
celliAvatarGroup.position.set(6, 2.0, 22); // Raised Y significantly (was -5.0)
celliAvatarGroup.rotation.y = Math.PI + THREE.MathUtils.degToRad(10); // 180 + 10 clockwise for alignment

// Scale based on mode: narrative mode uses smaller, more natural scale; debug mode uses large scale for editing
const avatarScale = EXEC_ENV_MODE === 'sequence' ? 5.0 : 30.0;
celliAvatarGroup.scale.setScalar(avatarScale);

console.log(`[Avatar] Celli positioned: pos(6, 2.0, 22), rotation 190Â°, scale ${avatarScale}x (${EXEC_ENV_MODE} mode)`);

scene.add(celliAvatarGroup);
 }
 
 // ===== Sculpt Mode for Character Editing =====
 let sculptMode = false;
 let sculptInflateRadius = 0.1;
 let sculptInflateStrength = 0.05;
 
 function enableSculptMode() {
 console.log('[Sculpt] Enabling sculpt mode...');
 sculptMode = true;
 
 // Hide transform controls
 if (transformControl) {
 transformControl.detach();
 }
 
 // Show character and jump to it
 if (characterBust) characterBust.visible = true;
 if (characterGroup) characterGroup.visible = true;
 
 alert('Sculpt Mode: Click and hold on character to inflate. Mode: Inflate by default.');
 }
 
 // Mouse sculpt handling
 let isSculpting = false;
 let sculptTarget = null;
 
 renderer.domElement.addEventListener('mousedown', (event) => {
 if (!sculptMode) return;
 
 const raycaster = new THREE.Raycaster();
 const mouse = new THREE.Vector2();
 mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
 mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
 raycaster.setFromCamera(mouse, camera);
 
 const intersects = raycaster.intersectObjects([characterBust, characterUnifiedMesh].filter(m => m && m.visible), true);
 
 if (intersects.length > 0) {
 isSculpting = true;
 sculptTarget = intersects[0];
 console.log('[Sculpt] Started sculpting at:', sculptTarget.point);
 }
 });
 
 renderer.domElement.addEventListener('mouseup', () => {
 if (isSculpting) {
 console.log('[Sculpt] Stopped sculpting');
 isSculpting = false;
 sculptTarget = null;
 }
 });
 
 renderer.domElement.addEventListener('mousemove', (event) => {
 if (!isSculpting || !sculptTarget) return;
 
 // Inflate vertices near the sculpt target
 const mesh = sculptTarget.object;
 if (!mesh || !mesh.geometry) return;
 
 const positions = mesh.geometry.getAttribute('position');
 if (!positions) return;
 
 const localPoint = mesh.worldToLocal(sculptTarget.point.clone());
 
 // Inflate vertices within radius
 for (let i = 0; i < positions.count; i++) {
 const vx = positions.getX(i);
 const vy = positions.getY(i);
 const vz = positions.getZ(i);
 
 const dx = vx - localPoint.x;
 const dy = vy - localPoint.y;
 const dz = vz - localPoint.z;
 const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
 
 if (dist < sculptInflateRadius) {
 // Calculate falloff
 const falloff = 1.0 - (dist / sculptInflateRadius);
 const influence = falloff * falloff * sculptInflateStrength;
 
 // Move vertex along its normal (inflate)
 const normal = new THREE.Vector3(dx, dy, dz).normalize();
 positions.setXYZ(
 i,
 vx + normal.x * influence,
 vy + normal.y * influence,
 vz + normal.z * influence
 );
 }
 }
 
 positions.needsUpdate = true;
 mesh.geometry.computeVertexNormals();
 });
 
 // ===== Transform Controls for Character Editing =====
 function initializeTransformControls() {
 transformControl = new TransformControls(camera, renderer.domElement);
 transformControl.addEventListener('dragging-changed', (event) => {
 controls.enabled = !event.value;
 });
 transformControl.setMode('translate');
 scene.add(transformControl);
 
 // Gizmo mode buttons
 const gizmoButtons = document.querySelectorAll('.gizmo-btn[data-mode]');
 gizmoButtons.forEach(btn => {
 btn.addEventListener('click', () => {
 const mode = btn.dataset.mode;
 transformControl.setMode(mode);
 gizmoButtons.forEach(b => b.classList.remove('active'));
 btn.classList.add('active');
 });
 });
 
 // Snap toggle button
 const snapToggle = document.getElementById('snap-toggle');
 const snapModes = ['free', '45', '90'];
 let currentSnapIndex = 0;
 
 snapToggle.addEventListener('click', () => {
 currentSnapIndex = (currentSnapIndex + 1) % snapModes.length;
 const snapMode = snapModes[currentSnapIndex];
 snapToggle.dataset.snap = snapMode;
 
 if (snapMode === 'free') {
 transformControl.setRotationSnap(null);
 transformControl.setTranslationSnap(null);
 snapToggle.textContent = 'Free';
 snapToggle.title = 'Rotation Snap: Free';
 } else if (snapMode === '45') {
 transformControl.setRotationSnap(THREE.MathUtils.degToRad(45));
 transformControl.setTranslationSnap(0.5);
 snapToggle.textContent = '45 ';
 snapToggle.title = 'Rotation Snap: 45 ';
 } else if (snapMode === '90') {
 transformControl.setRotationSnap(THREE.MathUtils.degToRad(90));
 transformControl.setTranslationSnap(1.0);
 snapToggle.textContent = '90 ';
 snapToggle.title = 'Rotation Snap: 90 ';
 }
 });
 
 // Keyboard shortcuts
 window.addEventListener('keydown', (e) => {
 if (e.target.tagName === 'INPUT') return;
 if (e.key === 'g' || e.key === 'G') {
 transformControl.setMode('translate');
 
 // Also update 3D buttons if frame is visible
 if (frameOfReference && frameOfReference.visible && frameOfReference.userData.gizmoButtons) {
 const gizmoButtons = frameOfReference.userData.gizmoButtons;
 gizmoButtons.forEach(({ button }) => {
 if (button.userData.mode === 'translate') {
 button.userData.isActive = true;
 button.material.emissiveIntensity = 0.5;
 animateButtonPress(button);
 } else if (button.userData.mode !== 'snap') {
 button.userData.isActive = false;
 button.material.emissiveIntensity = 0.2;
 }
 });
 } else {
 document.querySelector('[data-mode="translate"]')?.click();
 }
 } else if (e.key === 'r' || e.key === 'R') {
 transformControl.setMode('rotate');
 
 // Also update 3D buttons if frame is visible
 if (frameOfReference && frameOfReference.visible && frameOfReference.userData.gizmoButtons) {
 const gizmoButtons = frameOfReference.userData.gizmoButtons;
 gizmoButtons.forEach(({ button }) => {
 if (button.userData.mode === 'rotate') {
 button.userData.isActive = true;
 button.material.emissiveIntensity = 0.5;
 animateButtonPress(button);
 } else if (button.userData.mode !== 'snap') {
 button.userData.isActive = false;
 button.material.emissiveIntensity = 0.2;
 }
 });
 } else {
 document.querySelector('[data-mode="rotate"]')?.click();
 }
 } else if (e.key === 's' || e.key === 'S') {
 transformControl.setMode('scale');
 
 // Also update 3D buttons if frame is visible
 if (frameOfReference && frameOfReference.visible && frameOfReference.userData.gizmoButtons) {
 const gizmoButtons = frameOfReference.userData.gizmoButtons;
 gizmoButtons.forEach(({ button }) => {
 if (button.userData.mode === 'scale') {
 button.userData.isActive = true;
 button.material.emissiveIntensity = 0.5;
 animateButtonPress(button);
 } else if (button.userData.mode !== 'snap') {
 button.userData.isActive = false;
 button.material.emissiveIntensity = 0.2;
 }
 });
 } else {
 document.querySelector('[data-mode="scale"]')?.click();
 }
 } else if (e.key === 'v' || e.key === 'V') {
 // Cycle taunt video (if visible)
 console.log('[TauntCycle] V key pressed - skybox exists:', !!window.tauntSkybox, 'visible:', window.tauntSkybox?.visible);
 if (window.tauntSkybox && window.tauntSkybox.visible) {
   console.log('[TauntCycle] Calling cycleTauntVideo from V key');
   cycleTauntVideo();
 } else {
   console.log('[TauntCycle] Skybox not visible, not cycling');
 }
 } else if (e.key === 'Escape') {
 transformControl.detach();
 }
 });
 }
 
 // ===== Camera Navigation =====
 function jumpToKeyboard() {
 // Keyboard is always at same position regardless of mode
 animateCamera(new THREE.Vector3(8, 6, 12), new THREE.Vector3(6, 1.8, 3.5));
 keyboardGroup.visible = true;
 }
 
 function jumpToCharacter() {
 // Adjust camera position based on avatar scale (5x for sequence, 30x for debug)
 const avatarScale = EXEC_ENV_MODE === 'sequence' ? 5.0 : 30.0;
 const scaleFactor = avatarScale / 5.0;
 // Celli avatar at (6, 2.0, 22), body center at ~y=(2.0 + 0.5*scale)
 const bodyCenterY = 2.0 + (0.5 * avatarScale);
 animateCamera(new THREE.Vector3(6, bodyCenterY + 3, 12), new THREE.Vector3(6, bodyCenterY, 22));
 characterGroup.visible = true;
 }
 
 function jumpToHead() {
 // Adjust camera position based on avatar scale (5x for sequence, 30x for debug)
 const avatarScale = EXEC_ENV_MODE === 'sequence' ? 5.0 : 30.0;
 // Celli avatar at (6, 2.0, 22), head at (0, 1.5, 0) relative to avatar
 const headCenterY = 2.0 + (1.5 * avatarScale);
 animateCamera(new THREE.Vector3(6, headCenterY + 3, 12), new THREE.Vector3(6, headCenterY, 22));
 voxelHeadGroup.visible = true;
 }
 
function jumpToOverview() {
// View from rear base of keyboard looking up at Celli
// Adjust camera position based on avatar scale (5x for sequence, 30x for debug)
const avatarScale = EXEC_ENV_MODE === 'sequence' ? 5.0 : 30.0;
const scaleFactor = avatarScale / 5.0; // Normalize to sequence scale
const cameraPos = new THREE.Vector3(6, 0.5 * scaleFactor, -3 * scaleFactor);
const targetPos = new THREE.Vector3(6, 8 * scaleFactor, 22);

animateCamera(cameraPos, targetPos);
keyboardGroup.visible = true;
characterGroup.visible = true;
voxelHeadGroup.visible = true;
}

function positionCameraInsideHead() {
// Position camera at center of Celli's head, facing BACK
// Celli avatar is at (6, 2.0, 22) with 5x scale in sequence mode
// voxelHeadGroup is at (0, 1.5, 0) relative to avatar

const headCenterWorld = celliAvatarGroup.localToWorld(voxelHeadGroup.position.clone());
camera.position.copy(headCenterWorld);

// Reset camera rotation to identity first
camera.rotation.set(0, 0, 0);
camera.quaternion.set(0, 0, 0, 1);

// Set camera to face BACK (positive Z direction in world space)
// Celli faces negative Z, so back is positive Z
// Camera faces negative Z by default, so rotate 180 degrees around Y
camera.rotation.y = Math.PI;

// Store the FORWARD direction (the direction player should turn TO) for turn detection
// This is the opposite of where camera is currently facing
const backDirection = camera.getWorldDirection(new THREE.Vector3());
narrativeSequence.initialCameraDirection = backDirection.clone().negate(); // Store forward direction

// Set orbit controls target to a point behind the camera (where it's looking)
if (controls) {
const lookTarget = headCenterWorld.clone().add(backDirection.clone().multiplyScalar(5));
controls.target.copy(lookTarget);
controls.update();

controls.enabled = true;
controls.enableDamping = true;
controls.enableRotate = true;
controls.enablePan = true;
controls.enableZoom = true;
console.log('[Sequence] Orbit controls ENABLED - full camera control');
console.log('[Sequence] Controls target:', controls.target);
}

console.log('? Camera positioned inside head, facing back (rotation.y = Ï€)');
console.log('? Camera rotation:', camera.rotation);
console.log('? Camera is facing:', backDirection);
console.log('? Turn target direction (forward):', narrativeSequence.initialCameraDirection);

// Illuminate "TURN BACK" text on voxels
illuminateTurnBackText();
}

function dropPlayer() {
// Smooth dolly/zoom animation to drop into the city at human scale
if (!lastViewedKey) {
console.warn('[Drop] No key has been viewed yet. Cannot drop.');
// Fallback: use first key if available
if (keys && keys.length > 0) {
lastViewedKey = keys[0];
console.log('[Drop] Using first key as fallback:', lastViewedKey.userData.label);
} else {
console.error('[Drop] No keys available.');
return;
}
}

console.log('[Drop] Initiating drop animation above key:', lastViewedKey.userData.label);

// Get key world position and dimensions
const keyWorldPos = new THREE.Vector3();
lastViewedKey.getWorldPosition(keyWorldPos);

const bbox = new THREE.Box3().setFromObject(lastViewedKey);
const keyHeight = bbox.max.y - bbox.min.y;
const keySurfaceY = keyWorldPos.y + keyHeight / 2; // Top surface of key

// Calculate human-scale height above key
// Buildings are ~0.02 * 3 = 0.06 units tall on average
// If buildings represent 10m tall buildings, and human eye level is 1.7m:
// Scale factor: 0.06 units = 10m, so 1m = 0.006 units
// Human eye level = 1.7m * 0.006 = 0.0102 units above key surface
const buildingScale = 0.02; // From createMicroCitiesOnKeys
const avgBuildingHeight = buildingScale * 3; // ~0.06 units
const buildingHeightInMeters = 10; // Buildings represent 10m tall structures
const humanEyeLevelInMeters = 1.7; // Human eye level
const metersToWorldUnits = avgBuildingHeight / buildingHeightInMeters;
const humanEyeLevel = humanEyeLevelInMeters * metersToWorldUnits; // ~0.0102 units

// START POSITION: Normal view above key, looking down
dropStartPos.copy(camera.position); // Keep current position
dropStartScale = 1.0; // Normal scale

// TARGET POSITION: Human eye level on key surface
dropTargetPos.set(
keyWorldPos.x,
keySurfaceY + humanEyeLevel,
keyWorldPos.z
);
dropTargetScale = 1.0; // Keep normal scale, just change position

// Show debug tracker
const debugEl = document.getElementById('drop-debug');
if (debugEl) {
debugEl.style.display = 'block';
}

// Initialize drop animation
isDropping = true;
dropProgress = 0;
dropStartTime = Date.now();
dropKeyTarget = lastViewedKey;

// Point camera DOWN at the key to see the city approach
controls.target.set(keyWorldPos.x, keySurfaceY, keyWorldPos.z);
controls.update();

// Store original fog density and reduce fog for clear city view
if (scene.fog) {
originalFogDensity = scene.fog.density;
scene.fog.density = 0.001; // Drastically reduce fog
console.log('[Drop] Fog reduced from', originalFogDensity, 'to 0.001');
}

// Keep orbit controls enabled during drop - ensure pointer is NOT locked
if (controls) {
controls.enabled = true;
// Unlock pointer if it's locked
if (document.pointerLockElement) {
document.exitPointerLock();
console.log('[Drop] Exited pointer lock');
}
// Ensure controls can rotate freely
controls.enableRotate = true;
controls.enablePan = true;
controls.enableZoom = true;
controls.minDistance = 0.01;
controls.maxDistance = Infinity;
console.log('[Drop] Orbit controls enabled with free rotation - FPS mode active');
}

console.log('[Drop] Animation start');
console.log('  Start pos:', dropStartPos.toArray().map(v => v.toFixed(3)));
console.log('  Target pos:', dropTargetPos.toArray().map(v => v.toFixed(3)));
console.log('  Human eye level:', humanEyeLevel.toFixed(4), 'units');
console.log('  Key surface Y:', keySurfaceY.toFixed(3));
}

function transformCelliToHell() {
console.log('%c[CELLI->HELL] âœ¨ TRANSFORMING CELLI TO HELL âœ¨', 'background: #f00; color: #fff; font-size: 18px; font-weight: bold; padding: 8px;');
console.log('[CELLI->HELL] Animation states:');
console.log('  - snapTogetherStarted:', snapTogetherStarted);
console.log('  - celliMoveToCornerStarted:', celliMoveToCornerStarted);
console.log('  - endColorState:', endColorState);
console.log('  - endSequence:', endSequence);

// C pattern reminder: [[0,1,1,1,0], [1,0,0,0,0], [1,0,0,0,0], [1,0,0,0,0], [0,1,1,1,0]]
// To make H: keep left column (col 0), remove top/bottom arcs, add right column (col 4) and crossbar (row 2)
// C is at letter index 0
// I is at letter index 4

if (!letterVoxels || !letterVoxels.C || !letterVoxels.I) {
console.error('[CELLI->HELL] âœ— letterVoxels not found');
console.error('[CELLI->HELL] letterVoxels:', letterVoxels);
return;
}

const voxelsToRemove = [];
const voxelsToReposition = []; // Voxels that will fall and reappear

// Remove voxels from C to make H:
// Top row (row 0): remove columns 1, 2, 3 (keep 0, need to add 4)
// Middle row (row 2): keep all (this is the crossbar)
// Bottom row (row 4): remove columns 1, 2, 3 (keep 0, need to add 4)
letterVoxels.C.forEach(voxel => {
const row = voxel.userData.gridY;
const col = voxel.userData.gridCol;

// Remove top arc (row 0, columns 1-3) - these will reappear on the right
if (row === 0 && col >= 1 && col <= 3) {
voxelsToRemove.push(voxel);
// Mark for repositioning to right side (col 4)
if (col === 2) { // Use middle voxel to create right column top
voxel.userData.willReappearAs = { row: 0, col: 4, letterIdx: 0 };
voxelsToReposition.push(voxel);
}
}
// Remove bottom arc (row 4, columns 1-3) - these will reappear on the right
else if (row === 4 && col >= 1 && col <= 3) {
voxelsToRemove.push(voxel);
// Mark for repositioning to right side (col 4)
if (col === 2) { // Use middle voxel to create right column bottom
voxel.userData.willReappearAs = { row: 4, col: 4, letterIdx: 0 };
voxelsToReposition.push(voxel);
}
}
});

// Remove ALL voxels from I (letter index 4) - some will reappear as right column of H
letterVoxels.I.forEach((voxel, idx) => {
voxelsToRemove.push(voxel);
const row = voxel.userData.gridY;
// Use center column voxels (rows 1, 2, 3) to create right column of H
if (row >= 1 && row <= 3 && idx % 3 === 1) {
voxel.userData.willReappearAs = { row: row, col: 4, letterIdx: 0 };
voxelsToReposition.push(voxel);
}
});

console.log(`[CELLI->HELL] Removing ${voxelsToRemove.length} voxels, ${voxelsToReposition.length} will reappear`);

// Animate removed voxels falling
voxelsToRemove.forEach((voxel, index) => {
// Mark for removal
voxel.userData.fallingOff = true;
voxel.userData.fallVelocity = 0;
voxel.userData.fallDelay = index * 0.02; // Stagger the falls
voxel.userData.fallStartTime = Date.now() / 1000; // Current time in seconds
voxel.userData.rotationSpeed = {
x: (Math.random() - 0.5) * 0.1,
y: (Math.random() - 0.5) * 0.1,
z: (Math.random() - 0.5) * 0.1
};
});

// Remove from letterVoxels tracking
letterVoxels.C = letterVoxels.C.filter(v => !voxelsToRemove.includes(v));
letterVoxels.I = []; // All I voxels are removed
}

function createCelliBorderAvatar(size = 2) {
const group = new THREE.Group();
group.name = 'CelliBorderAvatar';

const MAT_BODY = new THREE.MeshBasicMaterial({ color: 0xf59e0b, transparent: true, opacity: 0.92 });
const MAT_MOUTH = new THREE.MeshBasicMaterial({ color: 0x111827, transparent: true, opacity: 0.95, side: THREE.DoubleSide });
const MAT_EYE = new THREE.MeshBasicMaterial({ color: 0x111827, transparent: false });
const MAT_CHEEK = new THREE.MeshBasicMaterial({ color: 0xec4899, transparent: true, opacity: 0.9 });
const MAT_BOW = new THREE.MeshBasicMaterial({ color: 0xfbbf24, transparent: true, opacity: 0.92, side: THREE.DoubleSide });
MAT_BODY.toneMapped = false;
MAT_MOUTH.toneMapped = false;
MAT_EYE.toneMapped = false;
MAT_CHEEK.toneMapped = false;
MAT_BOW.toneMapped = false;

// Helper to draw rounded rectangle
function drawRoundedRectPath(path, width, height, radius){
const hw = width / 2;
const hh = height / 2;
const r = Math.min(radius, hw, hh);
path.moveTo(-hw + r, -hh);
path.lineTo(hw - r, -hh);
path.quadraticCurveTo(hw, -hh, hw, -hh + r);
path.lineTo(hw, hh - r);
path.quadraticCurveTo(hw, hh, hw - r, hh);
path.lineTo(-hw + r, hh);
path.quadraticCurveTo(-hw, hh, -hw, hh - r);
path.lineTo(-hw, -hh + r);
path.quadraticCurveTo(-hw, -hh, -hw + r, -hh);
path.closePath();
}

// Create body frame (border)
const borderWidth = size;
const borderHeight = size;
const borderThickness = 0.2;
const shape = new THREE.Shape();
drawRoundedRectPath(shape, borderWidth, borderHeight, 0.2);
const hole = new THREE.Path();
drawRoundedRectPath(hole, borderWidth * 0.7, borderHeight * 0.7, 0.15);
shape.holes.push(hole);
const bodyGeo = new THREE.ExtrudeGeometry(shape, { depth: 0.1, bevelEnabled: false, steps: 1 });
bodyGeo.center();
const bodyFrame = new THREE.Mesh(bodyGeo, MAT_BODY);
bodyFrame.name = 'CelliBodyFrame';
group.add(bodyFrame);

// Create mouth frame (smile)
const mouthWidth = borderWidth * 0.4;
const mouthHeight = borderHeight * 0.25;
const mouthShape = new THREE.Shape();
drawRoundedRectPath(mouthShape, mouthWidth, mouthHeight, 0.1);
const mouthHole = new THREE.Path();
drawRoundedRectPath(mouthHole, mouthWidth * 0.7, mouthHeight * 0.6, 0.08);
mouthShape.holes.push(mouthHole);
const mouthGeo = new THREE.ExtrudeGeometry(mouthShape, { depth: 0.05, bevelEnabled: false, steps: 1 });
mouthGeo.center();
const mouthFrame = new THREE.Mesh(mouthGeo, MAT_MOUTH);
mouthFrame.position.set(0, -borderHeight * 0.15, 0.06);
mouthFrame.name = 'CelliMouthFrame';
group.add(mouthFrame);

// Eyes
const eyeGeo = new THREE.CircleGeometry(0.12, 24);
const eyeLeft = new THREE.Mesh(eyeGeo, MAT_EYE);
const eyeRight = eyeLeft.clone();
eyeLeft.position.set(-borderWidth * 0.18, borderHeight * 0.1, 0.06);
eyeRight.position.set(borderWidth * 0.18, borderHeight * 0.1, 0.06);
eyeLeft.name = 'CelliEyeLeft';
eyeRight.name = 'CelliEyeRight';
group.add(eyeLeft, eyeRight);

const eyes = [eyeLeft, eyeRight];
const blinkState = {
countdown: THREE.MathUtils.randFloat(2.5, 4.5),
minDelay: 2.5,
maxDelay: 4.5,
blinkDuration: 0.18,
minScale: 0.15,
progress: 0,
blinking: false,
baseScales: eyes.map(eye => eye.scale.y)
};

const applyBlinkAmount = (amount = 0) => {
eyes.forEach((eye, index) => {
const baseScale = blinkState.baseScales[index];
eye.scale.y = THREE.MathUtils.lerp(baseScale, baseScale * blinkState.minScale, amount);
});
};

applyBlinkAmount(0);

// Cheeks
const cheekGeo = new THREE.CircleGeometry(0.14, 24);
const cheekLeft = new THREE.Mesh(cheekGeo, MAT_CHEEK);
const cheekRight = cheekLeft.clone();
cheekLeft.position.set(-borderWidth * 0.32, borderHeight * 0.05, 0.055);
cheekRight.position.set(borderWidth * 0.32, borderHeight * 0.05, 0.055);
cheekLeft.name = 'CelliCheekLeft';
cheekRight.name = 'CelliCheekRight';
group.add(cheekLeft, cheekRight);

// Bow
const bowGroup = new THREE.Group();
bowGroup.name = 'CelliBow';
const bowWingGeo = new THREE.ShapeGeometry(new THREE.Shape([
new THREE.Vector2(0.15, 0),
new THREE.Vector2(-0.08, 0.15),
new THREE.Vector2(-0.08, -0.15)
]));
const bowWingLeft = new THREE.Mesh(bowWingGeo, MAT_BOW);
bowWingLeft.position.set(-0.1, 0, 0);
const bowWingRight = bowWingLeft.clone();
bowWingRight.scale.x = -1;
bowWingRight.position.set(0.1, 0, 0);
const bowKnot = new THREE.Mesh(new THREE.CircleGeometry(0.07, 20), MAT_BOW);
bowKnot.position.set(0, 0, 0.005);
bowGroup.add(bowWingLeft, bowWingRight, bowKnot);
bowGroup.position.set(0, borderHeight * 0.42, 0.06);
group.add(bowGroup);

// Store references
group.userData = {
bodyFrame,
mouthFrame,
eyeLeft,
eyeRight,
cheekLeft,
cheekRight,
bowGroup,
eyes,
blinkState,
applyBlink: applyBlinkAmount,
hoverActive: false,
clickActive: false
};

return group;
}

function illuminateTurnBackText() {
if (!voxelHeadGroup || !voxelHeadGroup.userData.instances) return;

const instances = voxelHeadGroup.userData.instances;
const instancedMesh = voxelHeadGroup.userData.instancedMesh;

// Define letter patterns (5x7 grid for each letter)
const letterT = [[1,1,1,1,1],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0]];
const letterU = [[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]];
const letterR = [[1,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,0],[1,0,1,0,0],[1,0,0,1,0],[1,0,0,0,1]];
const letterN = [[1,0,0,0,1],[1,1,0,0,1],[1,0,1,0,1],[1,0,0,1,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1]];
const letterB = [[1,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,0]];
const letterA = [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1]];
const letterC = [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,1],[0,1,1,1,0]];
const letterK = [[1,0,0,0,1],[1,0,0,1,0],[1,0,1,0,0],[1,1,0,0,0],[1,0,1,0,0],[1,0,0,1,0],[1,0,0,0,1]];

const letters = ['TURN', ' ', 'BACK'];
const letterPatterns = [
[letterT, letterU, letterR, letterN],
[],
[letterB, letterA, letterC, letterK]
];

// Find voxels on the back surface (positive Z in local coordinates since head is rotated)
// We'll use voxels with Z > 0.8 (back surface)
const backVoxels = instances.map((data, i) => ({ ...data, index: i }))
.filter(v => v.basePos.z > 0.8)
.sort((a, b) => {
// Sort by Y (top to bottom), then X (left to right)
if (Math.abs(a.basePos.y - b.basePos.y) > 0.2) return b.basePos.y - a.basePos.y;
return a.basePos.x - b.basePos.x;
});

// Map text to voxel grid - create a simple grid mapping
const turnBackIndices = [];
const gridSize = 7; // Text height
const letterSpacing = 6;

// For simplicity, just mark some voxels on the back as text voxels
// We'll find voxels in a grid pattern and map the text
let wordX = -15; // Start position for words
[letterPatterns[0], letterPatterns[2]].forEach((word, wordIdx) => {
word.forEach((letter, letterIdx) => {
letter.forEach((row, rowIdx) => {
row.forEach((pixel, colIdx) => {
if (pixel === 1) {
// Find closest voxel to this text position
const targetX = wordX + letterIdx * letterSpacing + colIdx;
const targetY = -rowIdx * 2;
const closest = backVoxels.find(v =>
Math.abs(v.basePos.x * 10 - targetX) < 2 &&
Math.abs(v.basePos.y * 10 - targetY) < 2
);
if (closest) turnBackIndices.push(closest.index);
}
});
});
});
wordX += (word.length + 1) * letterSpacing;
});

voxelHeadGroup.userData.turnBackIndices = turnBackIndices;
voxelHeadGroup.userData.turnBackText = { active: true };

console.log(`? "TURN BACK" text prepared: ${turnBackIndices.length} voxels illuminated`);
}

function animateCamera(targetPos, targetLookAt, duration = 1500) {
 const startPos = camera.position.clone();
 const startLookAt = controls.target.clone();
 const startTime = Date.now();
 
 function animate() {
 const elapsed = Date.now() - startTime;
 const progress = Math.min(elapsed / duration, 1);
 const eased = 1 - Math.pow(1 - progress, 3);
 
 camera.position.lerpVectors(startPos, targetPos, eased);
 controls.target.lerpVectors(startLookAt, targetLookAt, eased);
 controls.update();
 
 if (progress < 1) {
 requestAnimationFrame(animate);
 }
 }
 animate();
 }
 
 function enableEditMode() {
 const gizmoToolbar = document.getElementById('gizmo-toolbar');
 gizmoToolbar.style.display = 'flex';
 
 // Show sphere markers for editing
 characterPoseSpheres.forEach(marker => {
 marker.visible = true;
 });
 
 if (characterBust) {
 transformControl.attach(characterBust);
 }
 
 console.log('Edit mode enabled - click on sphere markers to edit individual parts');
 
 // Add click handler for sphere selection
 const raycaster = new THREE.Raycaster();
 const mouse = new THREE.Vector2();
 
 function onSphereClick(event) {
 const rect = renderer.domElement.getBoundingClientRect();
 mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
 mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
 
 raycaster.setFromCamera(mouse, camera);
 const intersects = raycaster.intersectObjects(characterPoseSpheres, false);
 
 if (intersects.length > 0) {
 const selectedSphere = intersects[0].object;
 transformControl.attach(selectedSphere);
 
 // Highlight selected sphere
 characterPoseSpheres.forEach(marker => {
 marker.material.opacity = 0.3;
 marker.material.color.set(0x4a7cff);
 });
 selectedSphere.material.opacity = 0.6;
 selectedSphere.material.color.set(0xff4a7c);
 
 console.log('Selected sphere:', selectedSphere.userData.sphereIndex);
 }
 }
 
 renderer.domElement.addEventListener('click', onSphereClick);
 }
 
 // Helper: Hash function for per-instance phase variation
 function hash(n) {
 const s = Math.sin(n * 127.1) * 43758.5453;
 return s - Math.floor(s);
 }
 
 // ===== GUI Controls =====
 const gui = new GUI({ title: 'Debug & Settings', width: 300 });
 
 // Scene folder
 const sceneFolder = gui.addFolder('Scene');
 const sceneParams = {
 'Show Keyboard': true,
 'Show Character': true,
 'Show Voxel Head': true,
 'Show All': true,
 'Background Color': '#0a0a0a',
 'Fog Density': 0.03,
 'Auto Rotate Character': false,
 'Show Voxelizer Layer': false
 };
 sceneFolder.add(sceneParams, 'Show Keyboard').onChange(v => {
 if (keyboardGroup) keyboardGroup.visible = v;
 });
 sceneFolder.add(sceneParams, 'Show Character').onChange(v => {
 if (characterGroup) characterGroup.visible = v;
 });
 sceneFolder.add(sceneParams, 'Show Voxel Head').onChange(v => {
 if (voxelHeadGroup) voxelHeadGroup.visible = v;
 });
 sceneFolder.add(sceneParams, 'Show All').onChange(v => {
 if (keyboardGroup) keyboardGroup.visible = v;
 if (characterGroup) characterGroup.visible = v;
 if (voxelHeadGroup) voxelHeadGroup.visible = v;
 sceneParams['Show Keyboard'] = v;
 sceneParams['Show Character'] = v;
 sceneParams['Show Voxel Head'] = v;
 sceneFolder.controllers.forEach(c => c.updateDisplay());
 });
 sceneFolder.addColor(sceneParams, 'Background Color').onChange(v => {
 scene.background.set(v);
 });
 sceneFolder.add(sceneParams, 'Fog Density', 0, 0.1, 0.001).onChange(v => {
 scene.fog.density = v;
 });
 sceneFolder.add(sceneParams, 'Auto Rotate Character');
 sceneFolder.add(sceneParams, 'Show Voxelizer Layer').onChange(v => {
   console.log('[Voxelizer] Toggle:', v ? 'ON' : 'OFF', '- applying to skybox video');
   if (tauntSkybox && tauntSkybox.userData.videoMesh) {
     const videoMesh = tauntSkybox.userData.videoMesh;
     if (v) {
       // Apply voxelization effect to video material
       applyVoxelizationToSkybox(true);
     } else {
       // Remove voxelization effect
       applyVoxelizationToSkybox(false);
     }
   } else {
     console.warn('[Voxelizer] Taunt skybox not found - cannot apply effect');
   }
 });
 
 // Lighting folder
 const lightFolder = gui.addFolder('Lighting');
 const lightParams = {
 'Ambient Intensity': 0.15,
 'Hemisphere Intensity': 0.2,
 'Directional Intensity': 0.9,
 'Spot Intensity': 4.0,
 'Rim Intensity': 0.3
 };
 lightFolder.add(lightParams, 'Ambient Intensity', 0, 1, 0.01).onChange(v => al.intensity = v);
 lightFolder.add(lightParams, 'Hemisphere Intensity', 0, 1, 0.01).onChange(v => hl.intensity = v);
 lightFolder.add(lightParams, 'Directional Intensity', 0, 3, 0.01).onChange(v => dl.intensity = v);
 lightFolder.add(lightParams, 'Spot Intensity', 0, 10, 0.1).onChange(v => spotLight.intensity = v);
 lightFolder.add(lightParams, 'Rim Intensity', 0, 1, 0.01).onChange(v => rimLight.intensity = v);
 
 // Character Bust folder
 const bustFolder = gui.addFolder('Character Bust');
 const bustParams = {
 'Preview Mesh Visible': true,
 'Preview Wireframe': false,
 'Unified Mesh Visible': false,
 'Unified Wireframe': false,
 'Skin Color': '#e7e2dc',
 'Roughness': 0.55,
 'Metalness': 0.0,
 'Clearcoat': 0.4,
 'Show Markers': false,
 'Symmetry X': true,
 'Symmetry Y': false,
 'Symmetry Z': false
 };
 bustFolder.add(bustParams, 'Preview Mesh Visible').onChange(v => {
 if (characterBust) {
 characterBust.visible = v;
 }
 });
 bustFolder.add(bustParams, 'Preview Wireframe').onChange(v => {
 if (characterBust && characterBust.material) {
 characterBust.material.wireframe = v;
 }
 });
 bustFolder.add(bustParams, 'Unified Mesh Visible').onChange(v => {
 if (characterUnifiedMesh) {
 characterUnifiedMesh.visible = v;
 }
 });
 bustFolder.add(bustParams, 'Unified Wireframe').onChange(v => {
 if (characterUnifiedMesh && characterUnifiedMesh.material) {
 characterUnifiedMesh.material.wireframe = v;
 }
 });
 bustFolder.addColor(bustParams, 'Skin Color').onChange(v => {
 if (characterBust && characterBust.material) characterBust.material.color.set(v);
 if (characterUnifiedMesh && characterUnifiedMesh.material) characterUnifiedMesh.material.color.set(v);
 });
 bustFolder.add(bustParams, 'Roughness', 0.1, 1.0, 0.01).onChange(v => {
 if (characterBust && characterBust.material) characterBust.material.roughness = v;
 if (characterUnifiedMesh && characterUnifiedMesh.material) characterUnifiedMesh.material.roughness = v;
 });
 bustFolder.add(bustParams, 'Metalness', 0, 1, 0.01).onChange(v => {
 if (characterBust && characterBust.material) characterBust.material.metalness = v;
 if (characterUnifiedMesh && characterUnifiedMesh.material) characterUnifiedMesh.material.metalness = v;
 });
 bustFolder.add(bustParams, 'Clearcoat', 0, 1, 0.01).onChange(v => {
 if (characterBust && characterBust.material) characterBust.material.clearcoat = v;
 if (characterUnifiedMesh && characterUnifiedMesh.material) characterUnifiedMesh.material.clearcoat = v;
 });
 bustFolder.add(bustParams, 'Show Markers').onChange(v => {
 characterPoseSpheres.forEach(marker => marker.visible = v);
 });
 bustFolder.add(bustParams, 'Symmetry X');
 bustFolder.add(bustParams, 'Symmetry Y');
 bustFolder.add(bustParams, 'Symmetry Z');
 
 // Voxel Head folder
 const headFolder = gui.addFolder('Voxel Head');
// Get default preset based on mode
const defaultPresetForGUI = EXEC_ENV_MODE === 'sequence' ? 'intro-celli' : 'sparse-blue';
const guiPreset = headPresets[defaultPresetForGUI];

const headParams = {
// Animation
'Animation Speed': guiPreset.animSpeed,
'Amplitude': guiPreset.amplitude,
'Phase Noise': guiPreset.phaseNoise,
'Falloff': guiPreset.falloff,
'Noise Warp': guiPreset.noiseWarp,
// Opacity & Glow
'Opacity Min': guiPreset.opacityMin,
'Opacity Max': guiPreset.opacityMax,
'Opacity Speed': guiPreset.opacitySpeed,
'Emissive Intensity': guiPreset.emissive,
// Material
'Metalness': guiPreset.metalness,
'Roughness': guiPreset.roughness,
'Color': guiPreset.color,
// Light
'Light Intensity': guiPreset.lightInt,
'Light Pulse': guiPreset.lightPulse,
'Rotation Speed': guiPreset.rotationSpeed,
// Voxel Generation (requires regeneration)
'Voxel Size': guiPreset.voxelSize,
'Shell Thickness': guiPreset.shellThickness,
'Shell Outer Bias': 0.02
};
 
 const headAnimFolder = headFolder.addFolder('Animation');
 headAnimFolder.add(headParams, 'Animation Speed', 0, 3, 0.01);
 headAnimFolder.add(headParams, 'Amplitude', 0, 0.6, 0.01);
 headAnimFolder.add(headParams, 'Phase Noise', 0, 2, 0.01);
 headAnimFolder.add(headParams, 'Falloff', 0, 2, 0.01);
 headAnimFolder.add(headParams, 'Noise Warp', 0, 0.6, 0.01);
 
 const headGlowFolder = headFolder.addFolder('Glow & Opacity');
 headGlowFolder.add(headParams, 'Opacity Min', 0, 1, 0.01);
 headGlowFolder.add(headParams, 'Opacity Max', 0, 1, 0.01);
 headGlowFolder.add(headParams, 'Opacity Speed', 0, 3, 0.01);
 headGlowFolder.add(headParams, 'Emissive Intensity', 0, 2, 0.01);
 
 const headMatFolder = headFolder.addFolder('Material');
 headMatFolder.add(headParams, 'Metalness', 0, 1, 0.01).onChange(v => {
 if (voxelHeadGroup && voxelHeadGroup.userData.instancedMesh) {
 voxelHeadGroup.userData.instancedMesh.material.metalness = v;
 }
 });
 headMatFolder.add(headParams, 'Roughness', 0, 1, 0.01).onChange(v => {
 if (voxelHeadGroup && voxelHeadGroup.userData.instancedMesh) {
 voxelHeadGroup.userData.instancedMesh.material.roughness = v;
 }
 });
 headMatFolder.addColor(headParams, 'Color').onChange(v => {
 if (voxelHeadGroup && voxelHeadGroup.userData.instancedMesh) {
 voxelHeadGroup.userData.instancedMesh.material.color.set(v);
 voxelHeadGroup.userData.instancedMesh.material.emissive.set(v);
 if (voxelHeadGroup.userData.headLight) {
 voxelHeadGroup.userData.headLight.color.set(v);
 }
 }
 });
 
 const headLightFolder = headFolder.addFolder('Light');
 headLightFolder.add(headParams, 'Light Intensity', 0, 10, 0.1);
 headLightFolder.add(headParams, 'Light Pulse');
 headLightFolder.add(headParams, 'Rotation Speed', 0, 1, 0.01);
 
 // Post-Processing folder
 const postFolder = gui.addFolder('Post-Processing');
 const postParams = {
 'Bloom Strength': 0.6,
 'Bloom Radius': 0.6,
 'Bloom Threshold': 0.9,
 'Tone Mapping Exposure': 1.0,
 'Enable FXAA': true
 };
 postFolder.add(postParams, 'Bloom Strength', 0, 3, 0.01).onChange(v => bloomPass.strength = v);
 postFolder.add(postParams, 'Bloom Radius', 0, 3, 0.01).onChange(v => bloomPass.radius = v);
 postFolder.add(postParams, 'Bloom Threshold', 0, 1, 0.01).onChange(v => bloomPass.threshold = v);
 postFolder.add(postParams, 'Tone Mapping Exposure', 0, 3, 0.01).onChange(v => renderer.toneMappingExposure = v);
 postFolder.add(postParams, 'Enable FXAA').onChange(v => fxaaPass.enabled = v);
 
 // Camera folder
 const cameraFolder = gui.addFolder('Camera');
 const cameraParams = {
 'FOV': 45,
 'Near': 0.1,
 'Far': 100
 };
 cameraFolder.add(cameraParams, 'FOV', 20, 120, 1).onChange(v => {
 camera.fov = v;
 camera.updateProjectionMatrix();
 });
 cameraFolder.add(cameraParams, 'Near', 0.01, 10, 0.01).onChange(v => {
 camera.near = v;
 camera.updateProjectionMatrix();
 });
 cameraFolder.add(cameraParams, 'Far', 10, 500, 1).onChange(v => {
 camera.far = v;
 camera.updateProjectionMatrix();
 });
 
 // Micro City LOD folder
 const microCityFolder = gui.addFolder('Micro City LOD');
 const microCityParams = {
 'Enabled': true,
 'LOD Distance': 0.5, // Cities appear at moderate distance
 'Slowdown Distance': 0.08, // Slowdown only when VERY close
 'Fade Range': 0.2,
 'Building Scale': 0.003,
 'Building Density': 0.02,
 'Camera Slowdown': 0.7,
 'Show City Info': true
 };
 microCityFolder.add(microCityParams, 'Enabled').onChange(v => {
 if (!v) {
 microCityGroups.forEach(({ cityGroup }) => {
 cityGroup.visible = false;
 });
 }
 });
 microCityFolder.add(microCityParams, 'LOD Distance', 0.1, 3.0, 0.05);
 microCityFolder.add(microCityParams, 'Slowdown Distance', 0.02, 0.3, 0.01);
 microCityFolder.add(microCityParams, 'Fade Range', 0.1, 1.0, 0.05);
 microCityFolder.add(microCityParams, 'Building Scale', 0.002, 0.02, 0.001);
 microCityFolder.add(microCityParams, 'Building Density', 0.01, 0.05, 0.005);
 microCityFolder.add(microCityParams, 'Camera Slowdown', 0, 1, 0.05);
 microCityFolder.add(microCityParams, 'Show City Info');
 microCityParams['Force Show All Cities'] = () => {
 console.log('[MicroCity] Forcing all cities visible for debugging...');
 microCityGroups.forEach(({ cityGroup, key }) => {
 cityGroup.visible = true;
 cityGroup.scale.setScalar(1.0);
 console.log(` City on "${key.userData.label}": ${cityGroup.children.length} meshes at pos ${cityGroup.position.x.toFixed(2)}, ${cityGroup.position.y.toFixed(2)}, ${cityGroup.position.z.toFixed(2)}`);
 });
 };
 microCityFolder.add(microCityParams, 'Force Show All Cities');
 
 // Hands & Fingerprint folder (now moved to modal via Edit Hands button)
 const handsParams = {
 'Fingerprint Enabled': true,
 'Fingerprint Strength': 1.0,
 'Fingerprint Scale': 1.0,
 'Finger Spacing': 1.2,
 'Show Hands': true,
 'Right Hand Visible': true,
 'Left Hand Visible': true,
 'Show Voxel Wrap': false,
 'Voxel Wrap Style': 'Emerging',
 'Apply to Material': () => {
 if (window.applyFpToMaterial) window.applyFpToMaterial();
 },
 'Apply Spacing': () => {
 const spacing = handsParams['Finger Spacing'];
 // Update right hand static fingers
 if (rightHandGroup && rightHandGroup.children) {
 let fingerIndex = 0;
 rightHandGroup.children.forEach(child => {
 if (child.userData && child.userData.isStatic) {
 fingerIndex++;
 child.position.x = spacing * fingerIndex;
 child.userData.offsetX = spacing * fingerIndex;
 }
 });
 }
 // Update left hand static fingers
 if (leftHandGroup && leftHandGroup.children) {
 let fingerIndex = 0;
 leftHandGroup.children.forEach(child => {
 if (child.userData && child.userData.isLeftHand && child.position.x !== 0) {
 fingerIndex++;
 child.position.x = -spacing * fingerIndex;
 child.userData.offsetX = -spacing * fingerIndex;
 }
 });
 }
 alert(`Finger spacing updated to ${spacing.toFixed(2)}`);
 }
 };
 
 // Scene Objects Hierarchy removed from GUI - now accessible via Scene Browser modal
 
 // Store for animation loop
 window.guiParams = { scene: sceneParams, bust: bustParams, head: headParams, post: postParams, hands: handsParams, microCity: microCityParams };
 
// ===== Button Handlers =====
document.getElementById('btn-keyboard')?.addEventListener('click', jumpToKeyboard);
document.getElementById('btn-character')?.addEventListener('click', jumpToCharacter);
document.getElementById('btn-head')?.addEventListener('click', jumpToHead);
document.getElementById('btn-overview')?.addEventListener('click', jumpToOverview);
document.getElementById('btn-edit-character')?.addEventListener('click', () => {
jumpToCharacter();
enableEditMode();
});
 
document.getElementById('btn-sculpt-character')?.addEventListener('click', () => {
jumpToCharacter();
enableSculptMode();
});

// New button handlers
document.getElementById('btn-edit-head')?.addEventListener('click', () => {
document.getElementById('edit-head-modal').classList.add('active');
syncHeadModalToParams();
});

document.getElementById('btn-edit-hands')?.addEventListener('click', () => {
document.getElementById('edit-hands-modal').classList.add('active');
if (!window.handsGUI) {
createHandsGUI();
}
});

document.getElementById('btn-scene-browser')?.addEventListener('click', () => {
populateSceneBrowser();
document.getElementById('scene-browser-modal').classList.add('active');
});

 const multiWrapCollapseBtn = document.getElementById('btn-celli-collapse');
 if (multiWrapCollapseBtn) {
 multiWrapCollapseBtn.addEventListener('click', () => {
 triggerCelliWrapCollapse();
 });
 }

document.getElementById('btn-save-config')?.addEventListener('click', () => {
populateConfigList();
document.getElementById('save-config-modal')?.classList.add('active');
});

document.getElementById('btn-print-config')?.addEventListener('click', () => {
generateConfigurationReport();
document.getElementById('config-report-modal')?.classList.add('active');
});

// Scale Mode button
document.getElementById('btn-scale-mode')?.addEventListener('click', () => {
toggleScaleMode();
const statusEl = document.getElementById('scale-mode-state');
if (statusEl) {
statusEl.textContent = scaleModeEnabled ? 'Enabled' : 'Disabled';
statusEl.style.color = scaleModeEnabled ? '#4aff9c' : '#888';
}
});

// LEAVES color picker handler
document.getElementById('btn-update-leaves-color')?.addEventListener('click', () => {
const colorPicker = document.getElementById('leaves-color-picker');
if (colorPicker) {
const newColor = colorPicker.value;
console.log('[UI] Updating LEAVES color to:', newColor);
updateLeavesColor(newColor);
}
});

// Debug tool: Log all scene objects
document.getElementById('btn-log-scene-objects')?.addEventListener('click', () => {
console.log('===== SCENE OBJECTS DEBUG =====');
console.log('Scene children count:', scene.children.length);
scene.traverse((obj) => {
if (obj.visible) {
const pos = obj.position;
const scale = obj.scale;
const type = obj.type;
const name = obj.name || '(unnamed)';
const isMesh = obj.isMesh;
const isSprite = obj.isSprite;
const isLight = obj.isLight;
const isHelper = obj.type.includes('Helper') || obj.name.includes('Helper');
const material = isMesh ? (obj.material?.type || 'no material') : 'N/A';
const hasTexture = isMesh && obj.material?.map ? 'YES' : 'NO';
const billboard = obj.material?.depthTest === false ? 'BILLBOARD' : '';
console.log(`[${type}] ${name}`, {
position: `(${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})`,
scale: `(${scale.x.toFixed(2)}, ${scale.y.toFixed(2)}, ${scale.z.toFixed(2)})`,
isMesh, isSprite, isLight, isHelper, material, hasTexture, billboard
});
}
});
console.log('===== END SCENE DEBUG =====');
showDialogue('Scene objects logged to console (F12)', 2000);
});

// ===== Chief Sequence =====
let chiefSequenceActive = false;
let franchiseImages = [];
let imageTrailParticles = [];
let mouseX = 0, mouseY = 0;

// ===== Pointer Lock Debug Utilities =====
function installPointerLockDebug() {
  if (window.__pointerLockDebugInstalled) return;
  window.__pointerLockDebugInstalled = true;
  try {
    const origReq = Element.prototype.requestPointerLock;
    Element.prototype.requestPointerLock = function() {
      const pocketActive = window.pocketDimensionActive || false;
      const cameraMode = window.CameraManager?.mode || 'unknown';
      
      // Block pointer lock if disablePointerLock flag is set OR if firstPersonModeActive (legacy)
      // BUT allow it in pocket dimension when FPS mode is active (FPS mode needs pointer lock!)
      const shouldBlock = !!window.disablePointerLock || 
                          (!!window.firstPersonModeActive && !pocketActive);
      
      console.warn('[PointerLock] 🎯 requestPointerLock called');
      console.warn('[PointerLock]   Element:', this);
      console.warn('[PointerLock]   Camera mode:', cameraMode);
      console.warn('[PointerLock]   Pocket dimension:', pocketActive);
      console.warn('[PointerLock]   Should block:', shouldBlock);
      console.warn('[PointerLock]   Reasons:');
      console.warn('[PointerLock]     disablePointerLock:', !!window.disablePointerLock);
      console.warn('[PointerLock]     firstPersonModeActive:', !!window.firstPersonModeActive);
      console.warn('[PointerLock]     pocketDimensionActive:', pocketActive);
      console.warn('[PointerLock]   Stack:', new Error().stack);
      
      if (shouldBlock) {
        console.warn('[PointerLock] 🚫 BLOCKED - Request denied');
        return undefined;
      }
      console.warn('[PointerLock] ✅ ALLOWED - Proceeding with pointer lock (mode:', cameraMode, ')');
      return origReq ? origReq.apply(this, arguments) : undefined;
    };
    Element.prototype.mozRequestPointerLock = Element.prototype.requestPointerLock;
    Element.prototype.webkitRequestPointerLock = Element.prototype.requestPointerLock;
  } catch (e) { console.warn('[PointerLock] Could not wrap requestPointerLock:', e); }
  try {
    const origExit = document.exitPointerLock ? document.exitPointerLock.bind(document) : null;
    if (origExit) {
      document.exitPointerLock = function() {
        console.warn('[PointerLock] exitPointerLock called. Current element:', document.pointerLockElement);
        return origExit();
      };
    }
  } catch (e) { console.warn('[PointerLock] Could not wrap exitPointerLock:', e); }
  document.addEventListener('pointerlockchange', () => {
    const pocketActive = window.pocketDimensionActive || false;
    const cameraMode = window.CameraManager?.mode || 'unknown';
    console.warn('[PointerLock] change -> element:', document.pointerLockElement);
    console.warn('[PointerLock]   disablePointerLock:', !!window.disablePointerLock);
    console.warn('[PointerLock]   pocketDimensionActive:', pocketActive);
    console.warn('[PointerLock]   cameraMode:', cameraMode);
    console.warn('[PointerLock]   firstPersonModeActive:', !!window.firstPersonModeActive);
    
    // Auto-exit if disabled flag is set
    // BUT allow pointer lock in pocket dimension when FPS mode is active
    if (window.disablePointerLock && document.pointerLockElement) {
      console.warn('[PointerLock] 🚫 Auto-exiting due to disable flag');
      ensurePointerUnlock('autoExitOnChange-disabled');
    } else if (pocketActive && cameraMode !== 'fps' && document.pointerLockElement) {
      console.warn('[PointerLock] 🚫 Auto-exiting - pocket active but not in FPS mode');
      ensurePointerUnlock('autoExitOnChange-pocket-non-fps');
    } else if (document.pointerLockElement) {
      console.warn('[PointerLock] ✅ Pointer lock active and allowed (mode:', cameraMode, ')');
    }
  });
  document.addEventListener('pointerlockerror', (e) => {
    console.error('[PointerLock] error:', e);
  });
}

function ensurePointerUnlock(label='') {
  let attempts = 0;
  function tryUnlock() {
    const lockedEl = document.pointerLockElement;
    console.log(`[PointerLock] ensurePointerUnlock(${label}) attempt ${attempts} lockedEl:`, lockedEl);
    if (lockedEl && document.exitPointerLock) {
      try { document.exitPointerLock(); } catch (e) { console.warn('[PointerLock] exit failed:', e); }
    }
    attempts++;
    if (attempts < 10 && document.pointerLockElement) requestAnimationFrame(tryUnlock);
  }
  tryUnlock();
}

installPointerLockDebug();

// ===== UNIFIED CAMERA MANAGEMENT SYSTEM =====
// Camera modes: 'orbit' | 'fps' | 'drop'
// - orbit: OrbitControls enabled, for normal navigation
// - fps: First-person mode with mouse-look, WASD movement, no orbit
// - drop: Hybrid mode with orbit + WASD for city exploration

if (typeof window.CameraManager === 'undefined') {
  window.CameraManager = {
    mode: 'orbit',
    
    // State flags
    get isOrbitMode() { return this.mode === 'orbit'; },
    get isFPSMode() { return this.mode === 'fps'; },
    get isDropMode() { return this.mode === 'drop'; },
    
    // FPS state
    fpYaw: 0,
    fpPitch: 0,
    fpSensitivity: 0.002,
    fpVelocityY: 0,
    fpOnGround: true,
    fpKeys: { w: false, a: false, s: false, d: false, shift: false, space: false },
    
    // Drop state
    dropKeys: { w: false, a: false, s: false, d: false, shift: false, space: false },
    
    // Mouse handlers
    fpsMouseHandler: null,
    
    setMode(newMode) {
      if (!['orbit', 'fps', 'drop'].includes(newMode)) {
        console.error('[CameraManager] ❌ Invalid mode requested:', newMode);
        console.trace('[CameraManager] Stack trace for invalid mode:');
        return;
      }
      
      if (this.mode === newMode) {
        console.log('[CameraManager] ℹ️ Already in mode:', newMode, '- no change needed');
        return;
      }
      
      console.log('[CameraManager] 🔄 MODE CHANGE REQUEST');
      console.log('[CameraManager]   From:', this.mode);
      console.log('[CameraManager]   To:', newMode);
      console.log('[CameraManager]   Camera pos:', camera.position.toArray());
      console.log('[CameraManager]   Pointer lock:', !!document.pointerLockElement);
      console.log('[CameraManager]   Controls enabled:', controls?.enabled);
      console.trace('[CameraManager] Stack trace for mode change:');
      
      // Clean up old mode
      this.cleanup();
      
      // Set new mode
      this.mode = newMode;
      
      // Initialize new mode
      this.initialize();
      
      console.log('[CameraManager] ✅ Mode change complete - now in:', this.mode);
    },
    
    cleanup() {
      console.log('[CameraManager] 🧹 Cleaning up mode:', this.mode);
      
      // Remove FPS mouse handler
      if (this.fpsMouseHandler) {
        console.log('[CameraManager]   Removing FPS mouse handler');
        document.removeEventListener('mousemove', this.fpsMouseHandler);
        this.fpsMouseHandler = null;
      }
      
      // Ensure pointer lock is released
      if (document.pointerLockElement) {
        console.log('[CameraManager]   Releasing pointer lock');
        try {
          document.exitPointerLock();
        } catch (e) {
          console.warn('[CameraManager]   Failed to exit pointer lock:', e);
        }
      } else {
        console.log('[CameraManager]   No pointer lock to release');
      }
      
      // Reset keys
      const fpKeysActive = Object.keys(this.fpKeys).filter(k => this.fpKeys[k]);
      const dropKeysActive = Object.keys(this.dropKeys).filter(k => this.dropKeys[k]);
      if (fpKeysActive.length > 0) console.log('[CameraManager]   Resetting FPS keys:', fpKeysActive);
      if (dropKeysActive.length > 0) console.log('[CameraManager]   Resetting drop keys:', dropKeysActive);
      
      Object.keys(this.fpKeys).forEach(k => this.fpKeys[k] = false);
      Object.keys(this.dropKeys).forEach(k => this.dropKeys[k] = false);
      
      console.log('[CameraManager] 🧹 Cleanup complete');
    },
    
    initialize() {
      console.log('[CameraManager] 🔧 Initializing mode:', this.mode);
      
      if (this.mode === 'orbit') {
        console.log('[CameraManager]   Setting up ORBIT mode');
        // Enable orbit controls
        if (controls) {
          controls.enabled = true;
          controls.enableRotate = true;
          controls.enablePan = true;
          controls.enableZoom = true;
          console.log('[CameraManager]   ✅ Orbit controls enabled');
        } else {
          console.warn('[CameraManager]   ⚠️ Controls not available');
        }
        // Reset camera rotation to quaternion-based (orbit uses quaternions)
        camera.rotation.order = 'XYZ';
        console.log('[CameraManager]   Camera rotation order set to XYZ');
        
      } else if (this.mode === 'fps') {
        console.log('[CameraManager]   Setting up FPS mode');
        // Disable orbit controls
        if (controls) {
          controls.enabled = false;
          controls.enableRotate = false;
          controls.enablePan = false;
          controls.enableZoom = false;
          console.log('[CameraManager]   ✅ Orbit controls disabled');
        }
        
        // Initialize FPS yaw/pitch from camera rotation
        this.fpYaw = camera.rotation.y;
        this.fpPitch = camera.rotation.x;
        console.log('[CameraManager]   Initial FPS angles - yaw:', this.fpYaw, 'pitch:', this.fpPitch);
        
        // Install FPS mouse handler
        let moveCount = 0;
        this.fpsMouseHandler = (e) => {
          if (this.mode !== 'fps') return;
          
          // Use movementX/Y for mouse look
          let dx = e.movementX || 0;
          let dy = e.movementY || 0;
          
          // Debug logging (throttled)
          moveCount++;
          if (moveCount === 1 || moveCount % 60 === 0) {
            console.log('[CameraManager] 🎮 FPS mouse movement:', moveCount, 'dx:', dx, 'dy:', dy, 'pointerLock:', !!document.pointerLockElement);
          }
          
          // Only apply movement if there's actual mouse delta
          if (dx !== 0 || dy !== 0) {
            this.fpYaw -= dx * this.fpSensitivity;
            this.fpPitch -= dy * this.fpSensitivity;
            
            // Clamp pitch
            const maxPitch = Math.PI / 2 - 0.01;
            this.fpPitch = Math.max(-maxPitch, Math.min(maxPitch, this.fpPitch));
            
            // Apply to camera (euler, not quaternion)
            camera.rotation.order = 'YXZ';
            camera.rotation.set(this.fpPitch, this.fpYaw, 0);
          }
        };
        document.addEventListener('mousemove', this.fpsMouseHandler);
        console.log('[CameraManager]   ✅ FPS mouse handler installed');
        
        // Request pointer lock for FPS mode (after a brief delay to ensure canvas is ready)
        setTimeout(() => {
          if (this.mode === 'fps' && !document.pointerLockElement) {
            console.log('[CameraManager]   🎯 Auto-requesting pointer lock for FPS mode...');
            const canvas = window.renderer?.domElement;
            console.log('[CameraManager]   Canvas found:', !!canvas);
            console.log('[CameraManager]   Renderer found:', !!window.renderer);
            if (canvas) {
              try {
                canvas.requestPointerLock();
                console.log('[CameraManager]   ✅ Pointer lock requested on canvas');
              } catch (e) {
                console.warn('[CameraManager]   ⚠️ Failed to request pointer lock:', e);
              }
            } else {
              console.warn('[CameraManager]   ⚠️ Canvas not found - will need user click');
            }
          } else {
            console.log('[CameraManager]   Skipping auto-request - mode:', this.mode, 'pointerLock:', !!document.pointerLockElement);
          }
        }, 100);
        
      } else if (this.mode === 'drop') {
        console.log('[CameraManager]   Setting up DROP mode (hybrid orbit + WASD)');
        // Enable orbit controls for drop mode (orbit + WASD hybrid)
        if (controls) {
          controls.enabled = true;
          controls.enableRotate = true;
          controls.enablePan = true;
          controls.enableZoom = true;
          console.log('[CameraManager]   ✅ Orbit controls enabled for drop mode');
        }
        camera.rotation.order = 'XYZ';
      }
      
      console.log('[CameraManager] 🔧 Initialization complete for:', this.mode);
    },
    
    // Handle WASD movement in animate loop
    updateMovement() {
      if (this.mode === 'fps') {
        this.updateFPSMovement();
      } else if (this.mode === 'drop') {
        this.updateDropMovement();
      }
    },
    
    updateFPSMovement() {
      const baseSpeed = 0.08;
      const moveSpeed = this.fpKeys.shift ? baseSpeed * 2.0 : baseSpeed;
      
      // Get forward/right from yaw (ignore pitch for movement)
      const forward = new THREE.Vector3(
        Math.sin(this.fpYaw),
        0,
        -Math.cos(this.fpYaw)
      ).normalize();
      const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();
      
      // Apply WASD movement
      if (this.fpKeys.w) camera.position.addScaledVector(forward, moveSpeed);
      if (this.fpKeys.s) camera.position.addScaledVector(forward, -moveSpeed);
      if (this.fpKeys.a) camera.position.addScaledVector(right, -moveSpeed);
      if (this.fpKeys.d) camera.position.addScaledVector(right, moveSpeed);
      
      // Jump
      if (this.fpKeys.space && this.fpOnGround) {
        this.fpVelocityY = 0.18;
        this.fpOnGround = false;
      }
      
      // Apply gravity
      this.fpVelocityY -= 0.009;
      camera.position.y += this.fpVelocityY;
      
      // Ground collision
      const groundY = 1.6;
      if (camera.position.y <= groundY) {
        camera.position.y = groundY;
        this.fpVelocityY = 0;
        this.fpOnGround = true;
      }
    },
    
    updateDropMovement() {
      const moveSpeed = this.dropKeys.shift ? 0.015 : 0.008;
      
      // Get camera direction
      const forward = new THREE.Vector3();
      camera.getWorldDirection(forward);
      forward.y = 0;
      forward.normalize();
      
      const right = new THREE.Vector3();
      right.crossVectors(forward, camera.up).normalize();
      
      // Apply WASD movement
      if (this.dropKeys.w) camera.position.addScaledVector(forward, moveSpeed);
      if (this.dropKeys.s) camera.position.addScaledVector(forward, -moveSpeed);
      if (this.dropKeys.a) camera.position.addScaledVector(right, -moveSpeed);
      if (this.dropKeys.d) camera.position.addScaledVector(right, moveSpeed);
      
      // Vertical movement
      if (this.dropKeys.space) camera.position.y += moveSpeed * 0.5;
    }
  };
}

// Legacy compatibility aliases
Object.defineProperty(window, 'firstPersonModeActive', {
  get() { return window.CameraManager.isFPSMode; },
  set(val) {
    if (val) window.CameraManager.setMode('fps');
    else if (window.CameraManager.isFPSMode) window.CameraManager.setMode('orbit');
  }
});

Object.defineProperty(window, 'dropModeActive', {
  get() { return window.CameraManager.isDropMode; },
  set(val) {
    if (val) window.CameraManager.setMode('drop');
    else if (window.CameraManager.isDropMode) window.CameraManager.setMode('orbit');
  }
});

// Legacy compatibility
window.firstPersonKeys = window.CameraManager.fpKeys;
window.dropKeys = window.CameraManager.dropKeys;

// Unified key handler
window.addEventListener('keydown', (e) => {
  const key = e.key.toLowerCase();
  const mode = window.CameraManager.mode;
  
  if (mode === 'fps') {
    if (key === 'w') window.CameraManager.fpKeys.w = true;
    if (key === 'a') window.CameraManager.fpKeys.a = true;
    if (key === 's') window.CameraManager.fpKeys.s = true;
    if (key === 'd') window.CameraManager.fpKeys.d = true;
    if (key === 'shift') window.CameraManager.fpKeys.shift = true;
    if (key === ' ') {
      window.CameraManager.fpKeys.space = true;
      e.preventDefault();
    }
  } else if (mode === 'drop') {
    if (key === 'w') window.CameraManager.dropKeys.w = true;
    if (key === 'a') window.CameraManager.dropKeys.a = true;
    if (key === 's') window.CameraManager.dropKeys.s = true;
    if (key === 'd') window.CameraManager.dropKeys.d = true;
    if (key === 'shift') window.CameraManager.dropKeys.shift = true;
    if (key === ' ') {
      window.CameraManager.dropKeys.space = true;
      e.preventDefault();
    }
  }
});

window.addEventListener('keyup', (e) => {
  const key = e.key.toLowerCase();
  const mode = window.CameraManager.mode;
  
  if (mode === 'fps') {
    if (key === 'w') window.CameraManager.fpKeys.w = false;
    if (key === 'a') window.CameraManager.fpKeys.a = false;
    if (key === 's') window.CameraManager.fpKeys.s = false;
    if (key === 'd') window.CameraManager.fpKeys.d = false;
    if (key === 'shift') window.CameraManager.fpKeys.shift = false;
    if (key === ' ') window.CameraManager.fpKeys.space = false;
  } else if (mode === 'drop') {
    if (key === 'w') window.CameraManager.dropKeys.w = false;
    if (key === 'a') window.CameraManager.dropKeys.a = false;
    if (key === 's') window.CameraManager.dropKeys.s = false;
    if (key === 'd') window.CameraManager.dropKeys.d = false;
    if (key === 'shift') window.CameraManager.dropKeys.shift = false;
    if (key === ' ') window.CameraManager.dropKeys.space = false;
  }
});

// Convenience functions for legacy code
function setCameraMode(mode) {
  window.CameraManager.setMode(mode);
}

function enableFPSMouseLook(enable) {
  // Now handled by CameraManager
  console.log('[CameraManager] enableFPSMouseLook is deprecated, use CameraManager.setMode instead');
}

// ===== Webcam Voxelizer Overlay =====
function startWebcamVoxelizer() {
console.log('[Voxelizer] Starting webcam voxelizer overlay');

// Create full-screen overlay
const overlay = document.createElement('div');
overlay.id = 'voxelizer-overlay';
overlay.style.cssText = `
position: fixed;
inset: 0;
background: radial-gradient(1200px 800px at 70% 30%,#0f1219,#0b0c10);
z-index: 9999;
display: flex;
align-items: center;
justify-content: center;
`;

// Create iframe to load voxelizer.html
const iframe = document.createElement('iframe');
iframe.src = '../../voxelizer.html';
iframe.style.cssText = `
width: 100%;
height: 100%;
border: none;
`;

// Create close button
const closeBtn = document.createElement('button');
closeBtn.textContent = '× Close Voxelizer';
closeBtn.style.cssText = `
position: fixed;
top: 20px;
left: 20px;
padding: 12px 20px;
background: rgba(255, 74, 74, 0.9);
border: 2px solid #ff6a6a;
color: white;
border-radius: 8px;
cursor: pointer;
font-weight: 600;
font-size: 14px;
z-index: 10000;
transition: all 0.2s;
`;
closeBtn.addEventListener('click', () => {
// Stop any webcam streams in the iframe
if (iframe.contentWindow) {
try {
iframe.contentWindow.postMessage({ type: 'stop' }, '*');
} catch (e) {
console.warn('[Voxelizer] Could not send stop message to iframe');
}
}
document.body.removeChild(overlay);
console.log('[Voxelizer] Closed webcam voxelizer');
});

closeBtn.addEventListener('mouseenter', () => {
closeBtn.style.background = 'rgba(255, 106, 106, 1)';
closeBtn.style.transform = 'scale(1.05)';
});

closeBtn.addEventListener('mouseleave', () => {
closeBtn.style.background = 'rgba(255, 74, 74, 0.9)';
closeBtn.style.transform = 'scale(1)';
});

overlay.appendChild(iframe);
overlay.appendChild(closeBtn);
document.body.appendChild(overlay);

showDialogue('📹 Webcam Voxelizer loaded - allow camera access', 3000);
}

// Visualizer overlay that appears to emit from the taunt skybox screen
function startVisualizerOverlay() {
console.log('[Visualizer] Starting overlay from skybox');

// Determine source position: use tauntSkybox if available
let sourcePos = new THREE.Vector3(0, 12, 50);
try {
  if (typeof tauntSkybox !== 'undefined' && tauntSkybox) {
    tauntSkybox.getWorldPosition(sourcePos);
  }
} catch (_) {}

// Brief emitter spark at source
try {
  const sparkGeo = new THREE.SphereGeometry(0.2, 16, 16);
  const sparkMat = new THREE.MeshBasicMaterial({ color: 0x6cc0ff, transparent: true, opacity: 0.9 });
  const spark = new THREE.Mesh(sparkGeo, sparkMat);
  spark.position.copy(sourcePos);
  scene.add(spark);
  let t = 0;
  (function pulse(){
    t += 0.05;
    spark.scale.setScalar(1 + Math.sin(t) * 0.3 + 0.3);
    spark.material.opacity = Math.max(0, 0.9 - t * 0.08);
    if (spark.material.opacity > 0.05) requestAnimationFrame(pulse); else scene.remove(spark);
  })();
} catch (e) { console.warn('[Visualizer] Spark failed', e); }

// Build full-screen overlay iframe
const overlay = document.createElement('div');
overlay.id = 'visualizer-overlay';
overlay.style.cssText = `
position: fixed;
inset: 0;
background: radial-gradient(1600px 1000px at 70% 30%, rgba(15,18,25,0.98), rgba(5,6,9,0.96));
backdrop-filter: blur(6px);
z-index: 9998;
opacity: 0;
transition: opacity 300ms ease;
`;

const panel = document.createElement('div');
panel.style.cssText = `
position: absolute;
left: 50%; top: 50%; transform: translate(-50%,-50%) scale(0.96);
width: min(92vw, 1400px); height: min(85vh, 900px);
background: rgba(10,12,18,0.8);
border: 1px solid rgba(108,192,255,0.25);
border-radius: 14px;
box-shadow: 0 18px 60px rgba(0,0,0,0.5);
transition: transform 300ms ease;
`;

const iframe = document.createElement('iframe');
iframe.src = '../../vozelizer.html';
iframe.allow = 'autoplay; microphone;';
iframe.style.cssText = 'width:100%;height:100%;border:0;border-radius:14px;';

const closeBtn = document.createElement('button');
closeBtn.textContent = '× Close Visualizer';
closeBtn.style.cssText = `
position: absolute; top: -44px; right: 0;
background: rgba(255, 74, 74, 0.95);
border: 1px solid #ff6a6a;
color: #fff; padding: 8px 12px; border-radius: 8px;
font-weight: 700; cursor: pointer; box-shadow: 0 8px 20px rgba(0,0,0,0.35);
`;
closeBtn.addEventListener('click', () => {
  overlay.style.opacity = '0';
  setTimeout(() => document.body.removeChild(overlay), 250);
});

panel.appendChild(iframe);
panel.appendChild(closeBtn);
overlay.appendChild(panel);
document.body.appendChild(overlay);

requestAnimationFrame(() => {
  overlay.style.opacity = '1';
  panel.style.transform = 'translate(-50%,-50%) scale(1)';
});

showDialogue('🎛️ Visualizer loading...', 1800);
}
// ===== Debug Menu Button Handlers =====

// Scene Browser
document.getElementById('btn-toggle-scene-browser')?.addEventListener('click', () => {
console.log('[Debug] Toggling scene browser');
// Scene browser logic here
showDialogue('📦 Scene browser (logs to console)', 2000);
debugSceneObjects();
});

// Avatar Selector
document.getElementById('btn-toggle-avatar-selector')?.addEventListener('click', () => {
console.log('[Debug] Opening avatar selector');
document.getElementById('avatar-selector-modal')?.classList.add('active');
});

// Upload Hand Image
document.getElementById('btn-upload-hand')?.addEventListener('click', () => {
console.log('[Debug] Opening hand image uploader');
document.getElementById('cursor-file-input')?.click();
});

// Import FBX
document.getElementById('btn-import-fbx')?.addEventListener('click', () => {
console.log('[Debug] Opening FBX importer');
document.getElementById('fbx-file-input')?.click();
});

// Webcam Voxelizer
document.getElementById('btn-webcam-voxelizer')?.addEventListener('click', () => {
console.log('[Debug] Opening Webcam Voxelizer');
startWebcamVoxelizer();
});

// Visualizer overlay emitted from taunt screen
document.getElementById('btn-show-visualizer')?.addEventListener('click', () => {
console.log('[Debug] Showing Visualizer overlay');
startVisualizerOverlay();
});

// Camera Views
document.getElementById('btn-keyboard')?.addEventListener('click', jumpToKeyboard);
document.getElementById('btn-character')?.addEventListener('click', jumpToCharacter);
document.getElementById('btn-drop')?.addEventListener('click', dropPlayer);

// Sequences
document.getElementById('btn-chief-sequence')?.addEventListener('click', () => {
console.log('[Chief] Starting Chief sequence');
startChiefSequence();
});

document.getElementById('btn-show-spreadsheet')?.addEventListener('click', () => {
console.log('[EarlyPreview] Spawning 3D spreadsheet viewport');
if (typeof spawnViewportPrism === 'function') {
spawnViewportPrism();
showDialogue('📊 3D Spreadsheet spawning...', 2000);
} else {
console.error('[EarlyPreview] spawnViewportPrism function not found');
showDialogue('❌ Spreadsheet not available', 2000);
}
});

// Alternative buttons for sequence mode
document.getElementById('btn-chief-sequence-alt')?.addEventListener('click', () => {
console.log('[Chief] Starting Chief sequence (from sequence panel)');
startChiefSequence();
});

document.getElementById('btn-show-spreadsheet-alt')?.addEventListener('click', () => {
console.log('[Spreadsheet] Spawning spreadsheet inside monitor');
if (typeof spawnViewportPrism === 'function') {
spawnViewportPrism();
showDialogue('📊 3D Spreadsheet spawning...', 2000);
} else {
console.error('[Spreadsheet] spawnViewportPrism function not found');
showDialogue('❌ Spreadsheet not available', 2000);
}
});

// Webcam Voxelizer (Sequence mode)
document.getElementById('btn-voxelizer-sequence')?.addEventListener('click', () => {
console.log('[Voxelizer] Starting webcam voxelizer (from sequence panel)');
startWebcamVoxelizer();
showDialogue('📹 Webcam Voxelizer loading...', 2000);
});

// Force First-Person Unlock
document.getElementById('btn-force-fp-unlock')?.addEventListener('click', () => {
  console.warn('[FirstPerson] FORCE UNLOCK pressed');
  installPointerLockDebug();
  ensurePointerUnlock('forceButton');
  if (controls) {
    controls.enabled = true;
    controls.enableRotate = true;
    controls.enablePan = false;
    controls.enableZoom = true;
    const fwd = new THREE.Vector3(0, 0, -1).applyEuler(camera.rotation).normalize();
    controls.target.copy(camera.position).add(fwd);
  }
  showDialogue('🧰 Forced first-person unlock', 1500);
});

async function startChiefSequence() {
if (chiefSequenceActive) return;
chiefSequenceActive = true;

// Play Chief.mp3 (try case-insensitive variants)
console.log('[Chief] Starting Chief sequence with music');
const chiefAudio = new Audio();
const audioPaths = [
'../../static/audio/chief.mp3',
'../../static/audio/Chief.mp3',
'../../static/audio/CHIEF.mp3'
];

let audioLoaded = false;
for (const path of audioPaths) {
try {
chiefAudio.src = path;
await new Promise((resolve, reject) => {
chiefAudio.addEventListener('loadeddata', () => {
audioLoaded = true;
resolve();
}, { once: true });
chiefAudio.addEventListener('error', reject, { once: true });
chiefAudio.load();
setTimeout(() => reject(new Error('timeout')), 1000);
});
if (audioLoaded) break;
} catch (err) {
console.log(`[Chief] Could not load ${path}`);
}
}

if (audioLoaded) {
chiefAudio.volume = 0.7;
chiefAudio.play().catch(err => console.error('[Chief] Error playing audio:', err));
console.log('[Chief] Chief.mp3 playing');
} else {
console.warn('[Chief] Could not load Chief.mp3, continuing without music');
}

const dialogueLines = [
"I've scanned you. Studied you.",
"I know what you want.",
"The essence of childhood and adulthood. A happy medium. Two beloved things in one, but only the good.",
"A platformer mascot of another world, and the heart of one of the biggest software releases that made people rethink what an \"office suite\" company could do. AI assisted.",
"A mirror of your two halves.",
"The hero, and the rank and file - each saving the world in their own way.",
"You probably already know what I'm getting at.",
"Well, it's time for you to finally take a look..."
];

// Show dialogue sequence
for (let i = 0; i < dialogueLines.length; i++) {
showDialogue(dialogueLines[i], 3500);
await new Promise(resolve => setTimeout(resolve, 3800));
}

// Calculate time elapsed
const dialogueDuration = dialogueLines.length * 3800;
const delayUntil45Seconds = Math.max(0, 45000 - dialogueDuration);

if (delayUntil45Seconds > 0) {
console.log(`[Chief] Waiting ${(delayUntil45Seconds / 1000).toFixed(1)}s more until 45-second mark...`);
showDialogue("...", delayUntil45Seconds);
await new Promise(resolve => setTimeout(resolve, delayUntil45Seconds));
}

// Show chief image with choice at 45-second mark
console.log('[Chief] Revealing Chief at 45-second mark');
showChiefChoice();
}

function showChiefChoice() {
console.log('[Chief] Showing Chief image with choice');

const chiefDisplay = document.getElementById('chief-display');
const chiefImage = document.getElementById('chief-image');
const thumbsUp = document.getElementById('chief-thumbs-up');
const thumbsDown = document.getElementById('chief-thumbs-down');

// Set image source
chiefImage.src = '../../static/images/chief.png'; // Adjust path as needed

// Show display
chiefDisplay.classList.add('active');

// Thumbs up handler
const handleThumbsUp = () => {
console.log('[Chief] Thumbs up selected');
showDialogue("You're a liar.", 3000);
playDonAudio();
cleanupChoice();
setTimeout(() => startImageTrail(), 3500);
};

// Thumbs down handler
const handleThumbsDown = () => {
console.log('[Chief] Thumbs down selected');
showDialogue("You couldn't possibly understand perfection.", 3000);
playDonAudio();
cleanupChoice();
setTimeout(() => startImageTrail(), 3500);
};

const cleanupChoice = () => {
thumbsUp.removeEventListener('click', handleThumbsUp);
thumbsDown.removeEventListener('click', handleThumbsDown);
setTimeout(() => {
chiefDisplay.classList.remove('active');
}, 1000);
};

thumbsUp.addEventListener('click', handleThumbsUp);
thumbsDown.addEventListener('click', handleThumbsDown);
}

function playDonAudio() {
console.log('[Chief] Playing don.mp3');
const audio = new Audio('../../static/audio/don.mp3'); // Adjust path as needed
audio.volume = 0.7;
audio.play().catch(err => console.error('[Chief] Error playing audio:', err));
}

async function startImageTrail() {
console.log('[Chief] Starting image trail');

// Setup trail canvas
const canvas = document.getElementById('image-trail-canvas');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
canvas.classList.add('active');

const ctx = canvas.getContext('2d');

// Load franchise images and start animation immediately
try {
const franchiseFolder = '../../static/images/franchise/';
console.log('[Chief] Starting image cloud animation...');
animateImageCloud(ctx, canvas, franchiseFolder);
} catch (error) {
console.error('[Chief] Error starting image trail:', error);
showDialogue('Error loading franchise images', 3000);
}
}

// Note: Image scanning and loading is now done directly in animateImageCloud()
// to show images as they're discovered instead of waiting for full scan

function animateImageCloud(ctx, canvas, folder) {
const cloudParticles = []; // All loaded images form a cloud
const allLoadedImages = []; // Store ALL loaded images
const maxActiveImages = 50; // Maximum images to display at once (REDUCED for performance)
const maxSize = 280; // Maximum size at center
const minSize = 25; // Minimum size at edge
const minDistance = 80; // Inner radius (closest to center)
const maxDistance = 450; // Outer radius (furthest from center - triggers cycle back)
const expansionSpeed = 0.3; // How fast images radiate outward per frame
let mouseX = canvas.width / 2;
let mouseY = canvas.height / 2;
let cloudCenterX = mouseX;
let cloudCenterY = mouseY;
let totalImagesLoaded = 0;
let allImagesLoaded = false;
let pulsePhase = 0;
let cyclePhase = 0; // For smooth cycling animation
let rotationIndex = 0; // Track which images are currently active
let frameCount = 0; // For throttling expensive operations
let nextCycleFrame = 15; // Semi-random cycle timing
const shownIndices = new Set(); // Track which images have been displayed

// Track mouse position
window.addEventListener('mousemove', (e) => {
mouseX = e.clientX;
mouseY = e.clientY;
});

// Scan and load images as they're discovered
async function scanAndLoadImages() {
const extensions = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'PNG', 'JPG', 'JPEG', 'GIF', 'WEBP'];
const maxNumber = 500;

console.log('[Chief] Scanning and loading images...');

for (let i = 1; i <= maxNumber; i++) {
let foundForThisNumber = false;

for (const ext of extensions) {
const testName = `${i}.${ext}`;
const img = new Image();

// Try to load this image
const loaded = await new Promise((resolve) => {
const timeout = setTimeout(() => resolve(false), 200);
img.onload = () => {
clearTimeout(timeout);
resolve(true);
};
img.onerror = () => {
clearTimeout(timeout);
resolve(false);
};
img.src = `${folder}${testName}`;
});

if (loaded) {
console.log(`[Chief] ✓ Found and loaded: ${testName}`);
addImageToCloud(img, testName);
foundForThisNumber = true;
totalImagesLoaded++;
break; // Found this number, move to next
}
}

// Early stopping: if we miss 3 consecutive numbers, assume we're done
if (!foundForThisNumber) {
if (totalImagesLoaded > 0 && i > totalImagesLoaded + 3) {
console.log(`[Chief] No more images found after ${i}. Scan complete.`);
break;
}
}
}

console.log(`[Chief] Scan complete! Total images loaded: ${totalImagesLoaded}`);
// Final sort after all images loaded
allLoadedImages.sort((a, b) => a.dominantColor.hue - b.dominantColor.hue);
allImagesLoaded = true;
console.log('[Chief] Starting dynamic expansion cycle...');
}

// Extract dominant color from image - OPTIMIZED
const colorCache = new Map();
function getDominantColor(img) {
// Check cache first
const cacheKey = img.src;
if (colorCache.has(cacheKey)) {
return colorCache.get(cacheKey);
}

const tempCanvas = document.createElement('canvas');
const tempCtx = tempCanvas.getContext('2d');
// Only sample a small region for speed
tempCanvas.width = Math.min(img.width, 32);
tempCanvas.height = Math.min(img.height, 32);
tempCtx.drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);

try {
const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
const data = imageData.data;
let r = 0, g = 0, b = 0, count = 0;

// Sample every 20th pixel for performance
for (let i = 0; i < data.length; i += 80) {
r += data[i];
g += data[i + 1];
b += data[i + 2];
count++;
}

r = Math.floor(r / count);
g = Math.floor(g / count);
b = Math.floor(b / count);

// Calculate hue for sorting
const max = Math.max(r, g, b);
const min = Math.min(r, g, b);
const delta = max - min;
let hue = 0;

if (delta !== 0) {
if (max === r) hue = ((g - b) / delta) % 6;
else if (max === g) hue = (b - r) / delta + 2;
else hue = (r - g) / delta + 4;
hue = Math.round(hue * 60);
if (hue < 0) hue += 360;
}

const result = { r, g, b, hue };
colorCache.set(cacheKey, result);
return result;
} catch (e) {
console.warn('[Chief] Could not extract color from image:', e);
const fallback = { r: 128, g: 128, b: 128, hue: 0 };
colorCache.set(cacheKey, fallback);
return fallback;
}
}

// Add a loaded image to the cloud - starts at edge and gets pulled in
function addImageToCloud(img, name) {
// Extract dominant color
const dominantColor = getDominantColor(img);

// Store in master list
const imageData = {
image: img,
name: name,
dominantColor: dominantColor,
loadIndex: totalImagesLoaded
};

allLoadedImages.push(imageData);

// Sort all loaded images by hue for color-coded appearance (only every 10 images)
if (allLoadedImages.length % 10 === 0) {
allLoadedImages.sort((a, b) => a.dominantColor.hue - b.dominantColor.hue);
}

// Only add to active particles if under limit
if (cloudParticles.length < maxActiveImages) {
const imageIndex = allLoadedImages.length - 1;
addToActiveParticles(imageData, imageIndex);
shownIndices.add(imageIndex); // Mark as shown
}
}

// Add an image to active display particles - TORUS FLOW
function addToActiveParticles(imageData, imageIndex) {
const entryAngle = Math.random() * Math.PI * 2;
// Start at center for continuous torus flow
const startProgress = Math.random(); // Random point in cycle
const orbitSpeed = (Math.random() - 0.5) * 0.002;

cloudParticles.push({
image: imageData.image,
name: imageData.name,
cycleProgress: startProgress, // 0=center, 0.5=edge, 1.0=back to center
baseAngle: entryAngle,
orbitSpeed: orbitSpeed,
alpha: 1.0,
dominantColor: imageData.dominantColor,
loadIndex: imageData.loadIndex,
sourceIndex: imageIndex !== undefined ? imageIndex : allLoadedImages.indexOf(imageData) // Track source
});
}

// Animation loop - continuous dynamic expansion
function animate() {
frameCount++;

// Clear canvas
ctx.clearRect(0, 0, canvas.width, canvas.height);

// Smooth cloud center movement toward mouse
cloudCenterX += (mouseX - cloudCenterX) * 0.05;
cloudCenterY += (mouseY - cloudCenterY) * 0.05;

// Update global phases
pulsePhase += 0.03;
cyclePhase += 0.01;

// Continuously cycle through images at semi-random intervals
if (allLoadedImages.length > maxActiveImages && frameCount >= nextCycleFrame) {
cycleNewImages();
// Semi-random decay: 8-20 frames between cycles (faster = more chaotic)
nextCycleFrame = frameCount + Math.floor(8 + Math.random() * 12);
}

// Continuously cycle through new images - PRIORITIZE UNSEEN
function cycleNewImages() {
if (cloudParticles.length < maxActiveImages) return;

// Semi-random number to remove: 1-3 images
const numToRemove = Math.floor(1 + Math.random() * 3);

// Remove random particles
for (let i = 0; i < numToRemove && cloudParticles.length > 0; i++) {
const randomIndex = Math.floor(Math.random() * cloudParticles.length);
cloudParticles.splice(randomIndex, 1);
}

// Add new images - prioritize unseen ones
for (let i = 0; i < numToRemove; i++) {
let selectedIndex = -1;
let imageData = null;

// First, try to find an unseen image
const unseenIndices = [];
for (let j = 0; j < allLoadedImages.length; j++) {
if (!shownIndices.has(j)) {
unseenIndices.push(j);
}
}

if (unseenIndices.length > 0) {
// Pick random unseen image
selectedIndex = unseenIndices[Math.floor(Math.random() * unseenIndices.length)];
imageData = allLoadedImages[selectedIndex];
} else {
// All images have been shown, pick any random one
selectedIndex = Math.floor(Math.random() * allLoadedImages.length);
imageData = allLoadedImages[selectedIndex];
}

// Only add if not already active
const alreadyActive = cloudParticles.some(p => p.sourceIndex === selectedIndex);
if (!alreadyActive) {
addToActiveParticles(imageData, selectedIndex);
shownIndices.add(selectedIndex); // Mark as shown
}
}
}

// Update and draw all particles - CONTINUOUS TORUS FLOW
cloudParticles.forEach((particle, index) => {
// Continuous cycle: 0 → 1 represents full torus loop
particle.cycleProgress += 0.004; // Smooth continuous flow
if (particle.cycleProgress >= 1.0) {
particle.cycleProgress = 0;
// Slight angle variation on cycle restart
particle.baseAngle += (Math.random() - 0.5) * 0.3;
}

// Slow orbital rotation
particle.baseAngle += particle.orbitSpeed;

// Torus distance calculation
// 0.0-0.5: expand from center to edge (minDistance → maxDistance)
// 0.5-1.0: contract from edge to center (maxDistance → minDistance)
let distance;
let sizeMultiplier;

if (particle.cycleProgress < 0.5) {
// Expanding phase (0 → 0.5)
const expandPhase = particle.cycleProgress * 2; // 0 → 1
// Ease out cubic for smooth expansion
const eased = 1 - Math.pow(1 - expandPhase, 3);
distance = minDistance + (maxDistance - minDistance) * eased;
// Size decreases as it moves away from center
sizeMultiplier = 1.0 - expandPhase * 0.7; // 1.0 → 0.3
} else {
// Contracting phase (0.5 → 1.0)
const contractPhase = (particle.cycleProgress - 0.5) * 2; // 0 → 1
// Ease in cubic for smooth contraction
const eased = Math.pow(contractPhase, 2);
distance = maxDistance - (maxDistance - minDistance) * eased;
// Size increases as it returns to center
sizeMultiplier = 0.3 + contractPhase * 0.7; // 0.3 → 1.0
}

// Calculate base size with smooth scaling
let baseSize = maxSize * sizeMultiplier;
baseSize = Math.max(2, baseSize); // Minimum 2 pixels

// Add subtle pulsation
const pulsate = allImagesLoaded ? 1.0 + Math.sin(pulsePhase + index * 0.1) * 0.05 : 1.0;
const currentSize = baseSize * pulsate;

// Calculate position with slight wave motion
const angle = particle.baseAngle + Math.sin(cyclePhase + index * 0.1) * 0.08;
const offsetX = Math.cos(angle) * distance;
const offsetY = Math.sin(angle) * distance;
const absoluteX = cloudCenterX + offsetX;
const absoluteY = cloudCenterY + offsetY;

// Smooth alpha based on cycle position - fade at edges
let drawAlpha = particle.alpha;
const distanceRatio = (distance - minDistance) / (maxDistance - minDistance);
if (distanceRatio > 0.85) {
const fadeRatio = (distanceRatio - 0.85) / 0.15;
drawAlpha *= Math.max(0.2, 1 - fadeRatio * 0.6);
}

// Draw card-style with proper cropping or as color pixel
ctx.globalAlpha = drawAlpha;

// If size is very small (< 8 pixels), just draw a color pixel
if (currentSize < 8) {
// Draw as representative color pixel
const color = particle.dominantColor;
ctx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
ctx.fillRect(
absoluteX - currentSize / 2,
absoluteY - currentSize / 2,
currentSize,
currentSize
);
} else {
// Only draw shadows for larger images (> 50 pixels) to save performance
if (currentSize > 50) {
const shadowIntensity = 1 - distanceRatio * 0.5;
ctx.shadowColor = `rgba(0, 0, 0, ${0.3 * shadowIntensity})`; // Reduced opacity
ctx.shadowBlur = 8 * shadowIntensity; // Reduced blur
ctx.shadowOffsetX = 2 * shadowIntensity;
ctx.shadowOffsetY = 2 * shadowIntensity;
}

// Crop image to square (maintain aspect ratio)
const imgWidth = particle.image.width;
const imgHeight = particle.image.height;
const minDim = Math.min(imgWidth, imgHeight);
const cropX = (imgWidth - minDim) / 2;
const cropY = (imgHeight - minDim) / 2;

// Draw cropped square image
ctx.drawImage(
particle.image,
cropX, cropY, minDim, minDim, // Source crop
absoluteX - currentSize / 2, absoluteY - currentSize / 2, currentSize, currentSize // Destination
);

// Reset shadow for next draw
if (currentSize > 50) {
ctx.shadowColor = 'transparent';
ctx.shadowBlur = 0;
}
}

ctx.globalAlpha = 1.0;
});

requestAnimationFrame(animate);
}

// Start scanning and animation
scanAndLoadImages();
animate();
}

// ===== HAND VOXELIZER WITH AUTO BACKGROUND DETECTION + EXIF METADATA GAG =====
document.getElementById('cursor-file-input').addEventListener('change', function(e) {
  const file = e.target.files[0];
  if (!file) return;
  
  console.log('[HandVoxelizer] File selected:', file.name);
  
  const reader = new FileReader();
  reader.onload = function(event) {
    const img = new Image();
    img.onload = function() {
      console.log('[HandVoxelizer] Image loaded:', img.width, 'x', img.height);
      
      // Read EXIF metadata first
      readEXIFAndShowGag(file, img, () => {
        // After gag sequence, voxelize the hand
        voxelizeHandWithBackgroundRemoval(img);
      });
    };
    img.src = event.target.result;
  };
  reader.readAsDataURL(file);
});

async function readEXIFAndShowGag(file, img, callback) {
  console.log('[EXIF] Reading metadata from image...');
  
  const reader = new FileReader();
  reader.onload = function(e) {
    const arrayBuffer = e.target.result;
    
    try {
      const view = new DataView(arrayBuffer);
      let metadata = {
        hasExif: false,
        deviceModel: 'Unknown',
        location: null,
        timestamp: null
      };
      
      if (view.getUint16(0) === 0xFFD8) {
        let offset = 2;
        while (offset < view.byteLength) {
          const marker = view.getUint16(offset);
          if (marker === 0xFFE1) {
            metadata.hasExif = true;
            console.log('[EXIF] EXIF data detected!');
            
            try {
              const exifLength = view.getUint16(offset + 2);
              const exifString = new TextDecoder().decode(arrayBuffer.slice(offset, offset + Math.min(exifLength, 200)));
              
              if (exifString.includes('iPhone') || exifString.includes('Apple')) {
                metadata.deviceModel = 'iPhone';
              } else if (exifString.includes('Samsung') || exifString.includes('Galaxy')) {
                metadata.deviceModel = 'Samsung Galaxy';
              } else if (exifString.includes('Pixel')) {
                metadata.deviceModel = 'Google Pixel';
              } else if (exifString.includes('Android')) {
                metadata.deviceModel = 'Android Device';
              }
              
              if (exifString.includes('GPS')) {
                metadata.location = 'GPS coordinates detected';
              }
              
            } catch (err) {
              console.warn('[EXIF] Error parsing EXIF details:', err);
            }
            break;
          }
          offset += 2 + view.getUint16(offset + 2);
        }
      }
      
      if (file.lastModified) {
        metadata.timestamp = new Date(file.lastModified).toLocaleString();
      }
      
      console.log('[EXIF] Metadata:', metadata);
      
      if (metadata.hasExif && metadata.deviceModel !== 'Unknown') {
        showMetadataGagSequence(metadata, callback);
      } else {
        console.log('[EXIF] No smartphone metadata detected - skipping gag');
        callback();
      }
      
    } catch (error) {
      console.error('[EXIF] Error reading metadata:', error);
      callback();
    }
  };
  reader.readAsArrayBuffer(file);
}

async function showMetadataGagSequence(metadata, callback) {
  console.log('[EXIF Gag] Starting metadata gag sequence');
  
  showDialogue(`📱 Analyzing image...`, 1500);
  await new Promise(r => setTimeout(r, 1800));
  
  showDialogue(`🔍 Metadata detected!`, 2000);
  await new Promise(r => setTimeout(r, 2200));
  
  const messages = [
    `📱 Device: <strong>${metadata.deviceModel}</strong>`,
    metadata.location ? `📍 Location data: <strong>${metadata.location}</strong>` : null,
    metadata.timestamp ? `📅 Captured: <strong>${metadata.timestamp}</strong>` : null,
    `⚠️ This information is embedded in every photo you take.`
  ].filter(m => m !== null);
  
  for (const msg of messages) {
    showDialogue(msg, 3000);
    await new Promise(r => setTimeout(r, 3200));
  }
  
  showDialogue(`<strong style="color: #ff6b6b;">Anyone you share photos with can see this data.</strong>`, 3500);
  await new Promise(r => setTimeout(r, 3800));
  
  showDialogue(`But don't worry...`, 2000);
  await new Promise(r => setTimeout(r, 2200));
  
  showDialogue(`<strong style="color: #4affb0;">It's a good thing you're in Celli's hands.</strong> 💚`, 4000);
  await new Promise(r => setTimeout(r, 4200));
  
  console.log('[EXIF Gag] Sequence complete');
  callback();
}

function voxelizeHandWithBackgroundRemoval(img) {
  console.log('[HandVoxelizer] Starting voxelization with background removal...');
  
  const resolution = 96;
  const canvas = document.createElement('canvas');
  canvas.width = resolution;
  canvas.height = resolution;
  const ctx = canvas.getContext('2d');
  
  ctx.drawImage(img, 0, 0, resolution, resolution);
  const imageData = ctx.getImageData(0, 0, resolution, resolution);
  const pixels = imageData.data;
  
  const cornerSamples = [
    [0, 0],
    [resolution - 1, 0],
    [0, resolution - 1],
    [resolution - 1, resolution - 1]
  ];
  
  let bgR = 0, bgG = 0, bgB = 0;
  cornerSamples.forEach(([x, y]) => {
    const idx = (y * resolution + x) * 4;
    bgR += pixels[idx];
    bgG += pixels[idx + 1];
    bgB += pixels[idx + 2];
  });
  bgR = Math.floor(bgR / cornerSamples.length);
  bgG = Math.floor(bgG / cornerSamples.length);
  bgB = Math.floor(bgB / cornerSamples.length);
  
  console.log('[HandVoxelizer] Detected background:', `rgb(${bgR}, ${bgG}, ${bgB})`);
  
  const colorThreshold = 40;
  
  function isBackground(r, g, b) {
    const dr = r - bgR;
    const dg = g - bgG;
    const db = b - bgB;
    return Math.sqrt(dr * dr + dg * dg + db * db) < colorThreshold;
  }
  
  const voxelGroup = new THREE.Group();
  voxelGroup.name = 'CustomHandVoxels';
  voxelGroup.position.set(-2, 2, 2);
  
  const voxelSize = 0.03;
  const geometry = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);
  
  let voxelCount = 0;
  const voxels = [];
  
  for (let y = 0; y < resolution; y++) {
    for (let x = 0; x < resolution; x++) {
      const idx = (y * resolution + x) * 4;
      const r = pixels[idx];
      const g = pixels[idx + 1];
      const b = pixels[idx + 2];
      const a = pixels[idx + 3];
      
      if (a < 30 || isBackground(r, g, b)) continue;
      
      const material = new THREE.MeshStandardMaterial({
        color: new THREE.Color(r / 255, g / 255, b / 255),
        metalness: 0.2,
        roughness: 0.6,
        emissive: new THREE.Color(r / 255, g / 255, b / 255),
        emissiveIntensity: 0.3
      });
      
      const cube = new THREE.Mesh(geometry, material);
      const px = (x / resolution - 0.5) * 3;
      const py = -(y / resolution - 0.5) * 3;
      cube.position.set(px, py, 0);
      cube.userData.startDelay = Math.random() * 2000;
      cube.scale.setScalar(0.01);
      
      voxelGroup.add(cube);
      voxels.push(cube);
      voxelCount++;
    }
  }
  
  scene.add(voxelGroup);
  console.log('[HandVoxelizer] Created', voxelCount, 'hand voxels (background removed)');
  
  showDialogue(`✋ Hand voxelized! ${voxelCount} voxels created`, 3000);
  
  voxels.forEach(cube => {
    setTimeout(() => {
      const duration = 800;
      const start = Date.now();
      const animate = () => {
        const elapsed = Date.now() - start;
        const progress = Math.min(elapsed / duration, 1);
        const eased = 1 - Math.pow(1 - progress, 3);
        cube.scale.setScalar(0.01 + eased * 0.99);
        if (progress < 1) requestAnimationFrame(animate);
      };
      animate();
    }, cube.userData.startDelay);
  });
}

// ===== POCKET DIMENSION VOXEL ENVIRONMENT =====
function buildPocketVoxelWalls() {
  console.log('[PocketDim] Building crumbling voxel walls');
  
  const size = 0.8;
  const walls = [];
  const W = 80, H = 50, D = 2;
  const geo = new THREE.BoxGeometry(size, size, size);
  const mat = new THREE.MeshStandardMaterial({
    color: 0x1a1a22,
    roughness: 0.9,
    metalness: 0.1
  });
  
  // Create 4 walls (front, back, left, right)
  const wallConfigs = [
    { name: 'back', normal: new THREE.Vector3(0, 0, 1), distance: 40 },
    { name: 'left', normal: new THREE.Vector3(1, 0, 0), distance: 40 },
    { name: 'right', normal: new THREE.Vector3(-1, 0, 0), distance: 40 }
  ];
  
  wallConfigs.forEach(config => {
    const maxVoxels = 3800;
    const inst = new THREE.InstancedMesh(geo, mat.clone(), maxVoxels);
    inst.castShadow = true;
    inst.receiveShadow = true;
    inst.userData.isPocketElement = true;
    inst.userData.wallName = config.name;
    
    const dummy = new THREE.Object3D();
    let n = 0;
    const positions = [];
    
    for (let x = -W / 2; x < W / 2 && n < maxVoxels; x += size) {
      for (let y = -H / 2; y < H / 2 && n < maxVoxels; y += size) {
        const d = Math.sqrt((x / (W / 2)) ** 2 + (y / (H / 2)) ** 2);
        if (d > 0.7 && Math.random() < (d - 0.7) * 3) continue;
        if (Math.random() < 0.06) continue;
        
        let worldX, worldY, worldZ;
        
        if (config.name === 'back') {
          worldX = x + (Math.random() - 0.5) * 0.2;
          worldY = y + (Math.random() - 0.5) * 0.2;
          worldZ = -config.distance + Math.random() * D;
        } else if (config.name === 'left') {
          worldX = -config.distance + Math.random() * D;
          worldY = y + (Math.random() - 0.5) * 0.2;
          worldZ = x + (Math.random() - 0.5) * 0.2;
        } else { // right
          worldX = config.distance - Math.random() * D;
          worldY = y + (Math.random() - 0.5) * 0.2;
          worldZ = x + (Math.random() - 0.5) * 0.2;
        }
        
        const basePos = { x: worldX, y: worldY, z: worldZ };
        positions.push(basePos);
        dummy.position.set(basePos.x, basePos.y, basePos.z);
        dummy.rotation.set(
          (Math.random() - 0.5) * 0.1,
          (Math.random() - 0.5) * 0.1,
          (Math.random() - 0.5) * 0.1
        );
        dummy.updateMatrix();
        inst.setMatrixAt(n++, dummy.matrix);
      }
    }
    
    inst.count = n;
    inst.instanceMatrix.needsUpdate = true;
    scene.add(inst);
    walls.push({ inst, positions, dummy, size, name: config.name });
    console.log(`[PocketDim] Created ${config.name} wall with ${n} voxels`);
  });
  
  return walls;
}

function createPocketLighting() {
  console.log('[PocketDim] Setting up office lighting');
  
  // Ambient light
  const ambient = new THREE.AmbientLight(0xffffff, 0.4);
  ambient.userData.isPocketElement = true;
  scene.add(ambient);
  
  // Office-style ceiling lights (fluorescent tube effect)
  const ceilingLights = [];
  const lightPositions = [
    { x: -15, z: -10 },
    { x: 15, z: -10 },
    { x: -15, z: 10 },
    { x: 15, z: 10 },
    { x: 0, z: 0 }
  ];
  
  lightPositions.forEach(pos => {
    const light = new THREE.PointLight(0xffffff, 0.8, 50);
    light.position.set(pos.x, 20, pos.z);
    light.castShadow = true;
    light.shadow.mapSize.width = 1024;
    light.shadow.mapSize.height = 1024;
    light.userData.isPocketElement = true;
    scene.add(light);
    ceilingLights.push(light);
    
    // Visual representation
    const bulbGeo = new THREE.SphereGeometry(0.3, 16, 16);
    const bulbMat = new THREE.MeshBasicMaterial({ color: 0xffffe5 });
    const bulb = new THREE.Mesh(bulbGeo, bulbMat);
    bulb.position.copy(light.position);
    bulb.userData.isPocketElement = true;
    scene.add(bulb);
  });
  
  return ceilingLights;
}

// Global state for pocket dimension video
window.pocketVideoState = {
  initialized: false,
  skyWatchesShown: false,
  screenSpawned: false,
  currentVideoIndex: 0,
  autoLoopEnabled: true,
  isMinimized: false,
  canPickUp: false
};

// ===== POCKET DIMENSION VIDEO DISPLAY WITH REVERB =====
function createPocketDimensionVideoDisplay() {
  console.log('[PocketDim] 🎬 Creating video display in sky...');
  console.log('[PocketDim] Scene exists:', !!scene);
  console.log('[PocketDim] Camera exists:', !!camera);
  
  // Use existing tauntVideo if available, otherwise create new one
  let video = window.tauntVideo;
  if (!video) {
    console.log('[PocketDim] Creating new video element...');
    video = document.createElement('video');
  // Use current taunt video from cycle (fallback to taunt.mp4)
  const currentVideo = window.tauntVideos && window.currentTauntIndex !== undefined 
    ? window.tauntVideos[window.currentTauntIndex] 
    : 'taunt.mp4';
  
  // Resolve video source robustly with fallbacks
  const candidates = [
    window.location.origin + '/static/video/' + currentVideo,
    '/static/video/' + currentVideo,
    'static/video/' + currentVideo
  ];
  let picked = candidates[0];
  video.src = picked;
  console.log('[PocketDim] Using video:', currentVideo);
    video.loop = true;
    video.crossOrigin = 'anonymous';
    video.autoplay = true;
    video.playsInline = true;
    video.setAttribute('playsinline', '');
    video.muted = true; // start muted to ensure autoplay, will unmute after play
    video.volume = 0.6;
    try { video.playbackRate = 0.7; } catch(_){}
    window.tauntVideo = video;
    console.log('[PocketDim] ✅ Created new video element:', video);
    console.log('[PocketDim] Video src:', video.src);
    console.log('[PocketDim] Video muted:', video.muted);
    console.log('[PocketDim] Video volume:', video.volume);
  } else {
    console.log('[PocketDim] Reusing existing video element');
  }
  
  // Ensure preload and loading kick off
  video.preload = 'auto';
  video.load();
  console.log('[PocketDim] Video configured - muted:', video.muted, 'volume:', video.volume);
  
  // Setup audio context for reverb (only if not already setup)
  if (!window.pocketAudioContext) {
    try {
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      
      // Wait for video to have metadata before creating audio source
      video.addEventListener('loadedmetadata', () => {
        try {
          const audioSource = audioContext.createMediaElementSource(video);
          
          // === REVERB (Convolver) ===
          const convolver = audioContext.createConvolver();
          const sampleRate = audioContext.sampleRate;
          const length = sampleRate * 3; // 3 seconds of reverb
          const impulse = audioContext.createBuffer(2, length, sampleRate);
          
          for (let channel = 0; channel < 2; channel++) {
            const channelData = impulse.getChannelData(channel);
            for (let i = 0; i < length; i++) {
              channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
            }
          }
          convolver.buffer = impulse;
          
          // === ECHO (Delay) ===
          const echoDelay = audioContext.createDelay();
          echoDelay.delayTime.value = 0.3; // 300ms delay
          
          const echoFeedback = audioContext.createGain();
          echoFeedback.gain.value = 0.4; // 40% feedback
          
          const echoWet = audioContext.createGain();
          echoWet.gain.value = 0.5; // Mix level
          
          // Echo feedback loop: delay -> feedback -> delay
          echoDelay.connect(echoFeedback);
          echoFeedback.connect(echoDelay);
          echoDelay.connect(echoWet);
          
          // === BASS BOOST (EQ) ===
          const bassBoost = audioContext.createBiquadFilter();
          bassBoost.type = 'lowshelf';
          bassBoost.frequency.value = 200; // Boost frequencies below 200Hz
          bassBoost.gain.value = 8; // +8dB boost
          
          // === MASTER GAIN ===
          const gainNode = audioContext.createGain();
          gainNode.gain.value = 0.7; // Increased volume for effects
          
          // === AUDIO CHAIN ===
          // source -> bassBoost -> [split into dry and wet paths]
          //   dry -> convolver -> gain -> destination
          //   wet -> echoDelay -> echoWet -> gain -> destination
          audioSource.connect(bassBoost);
          
          // Reverb path
          bassBoost.connect(convolver);
          convolver.connect(gainNode);
          
          // Echo path (parallel to reverb)
          bassBoost.connect(echoDelay);
          echoWet.connect(gainNode);
          
          // Final output
          gainNode.connect(audioContext.destination);
          
          window.pocketAudioContext = audioContext;
          window.pocketAudioGain = gainNode;
          window.pocketEchoDelay = echoDelay;
          window.pocketBassBoost = bassBoost;
          
          console.log('[PocketDim] Audio context configured with reverb, echo, and bass boost');
        } catch (audioErr) {
          console.warn('[PocketDim] Audio setup failed:', audioErr);
          // Continue without audio effects
        }
      }, { once: true });
    } catch (err) {
      console.warn('[PocketDim] AudioContext creation failed:', err);
    }
  }
  
  // Create video texture (updates automatically once video has data)
  const videoTexture = new THREE.VideoTexture(video);
  videoTexture.minFilter = THREE.LinearFilter;
  videoTexture.magFilter = THREE.LinearFilter;
  videoTexture.format = THREE.RGBAFormat;
  
  // Crop bottom 100px of video (assuming 1080p = 1920x1080)
  // 100px / 1080px = 0.0926 (9.26% of height to crop from bottom)
  // UV coordinates: (0,0) = bottom-left, (1,1) = top-right
  // We want to show from y=0.0926 to y=1.0 (crop bottom 100px)
  const videoCropBottom = 100 / 1080; // 0.0926
  videoTexture.offset.y = videoCropBottom;
  videoTexture.repeat.y = 1 - videoCropBottom;
  
  console.log('[PocketDim] Video texture cropped - bottom offset:', videoCropBottom);
  
  // Create giant display frame in sky - MUCH BIGGER
  const displayWidth = 60;
  const displayHeight = 60 * (9 / 16); // 16:9 aspect
  
  // Frame geometry
  const frameThickness = 0.5;
  const frameGeo = new THREE.BoxGeometry(
    displayWidth + frameThickness * 2,
    displayHeight + frameThickness * 2,
    frameThickness
  );
  const frameMat = new THREE.MeshStandardMaterial({
    color: 0x1a1a1f,
    metalness: 0.8,
    roughness: 0.2,
    emissive: 0x4a7cff,
    emissiveIntensity: 0.3
  });
  const frame = new THREE.Mesh(frameGeo, frameMat);
  
  // Screen geometry
  const screenGeo = new THREE.PlaneGeometry(displayWidth, displayHeight);
  
  // Apply same voxelization as main skybox if enabled
  let screenMat;
  if (window.skyboxVoxelized && window.voxelTexture) {
    console.log('[PocketDim] Using voxelized texture from main skybox');
    screenMat = new THREE.MeshBasicMaterial({
      map: window.voxelTexture,
      side: THREE.DoubleSide,
      toneMapped: false
    });
  } else {
    screenMat = new THREE.MeshBasicMaterial({
      map: videoTexture,
      side: THREE.DoubleSide,
      toneMapped: false
    });
  }
  
  const screen = new THREE.Mesh(screenGeo, screenMat);
  screen.position.z = frameThickness / 2 + 0.01;
  screen.name = 'pocketVideoScreen'; // Name for raycasting
  
  // Group and position
  const videoGroup = new THREE.Group();
  videoGroup.add(frame);
  videoGroup.add(screen);
  videoGroup.position.set(0, 15, 0); // High in the sky
  videoGroup.lookAt(camera.position); // Face camera initially
  
  // Store globally for click detection
  window.pocketVideoScreen = screen;
  window.pocketVideoGroup = videoGroup;
  
  scene.add(videoGroup);
  console.log('[PocketDim] ✅ Video group added to scene at position:', videoGroup.position);
  console.log('[PocketDim] 📺 Video screen stored globally for click detection');
  
  // Add video event listeners for detailed debugging
  video.addEventListener('loadstart', () => console.log('[PocketDim] 🔵 Video loadstart event'));
  video.addEventListener('loadedmetadata', () => console.log('[PocketDim] 🔵 Video loadedmetadata - duration:', video.duration));
  video.addEventListener('loadeddata', () => console.log('[PocketDim] 🔵 Video loadeddata'));
  video.addEventListener('canplay', () => { console.log('[PocketDim] 🟢 Video canplay - readyState:', video.readyState); tryPlay(); });
  video.addEventListener('canplaythrough', () => { console.log('[PocketDim] 🟢 Video canplaythrough'); tryPlay(); });
  video.addEventListener('playing', () => console.log('[PocketDim] ▶️ Video playing event fired'));
  video.addEventListener('pause', () => console.log('[PocketDim] ⏸️ Video pause event fired'));
  video.addEventListener('ended', () => console.log('[PocketDim] ⏹️ Video ended event fired'));
  video.addEventListener('error', (e) => {
    console.error('[PocketDim] ❌ Video error event:', e, video.error);
    console.error('[PocketDim] Current video src:', video.src);
    // Try alternate src if current failed
    const fallbacks = candidates.slice(1);
    const current = video.src;
    const next = fallbacks.find(alt => !current.endsWith(alt));
    if (next) {
      console.warn('[PocketDim] Retrying with alternate src:', next);
      video.src = next;
    }
  });
  video.addEventListener('stalled', () => console.warn('[PocketDim] ⚠️ Video stalled'));
  video.addEventListener('waiting', () => console.log('[PocketDim] ⏳ Video waiting for data'));
  
  // Play helpers
  const tryPlay = () => {
    if (!video) return;
    if (video.readyState < 2) return; // HAVE_CURRENT_DATA
    playVideo();
  };

  // Play video with user interaction handling
  const playVideo = () => {
    console.log('[PocketDim] 🎬 Attempting to play video...');
    console.log('[PocketDim] Video state before play:', {
      src: video.src,
      currentTime: video.currentTime,
      duration: video.duration,
      paused: video.paused,
      ended: video.ended,
      muted: video.muted,
      volume: video.volume,
      readyState: video.readyState,
      networkState: video.networkState,
      error: video.error
    });
    
    video.play()
      .then(() => {
        console.log('[PocketDim] ✅ Video.play() promise resolved - video should be playing now');
        console.log('[PocketDim] Video state after play:', {
          paused: video.paused,
          currentTime: video.currentTime,
          muted: video.muted,
          volume: video.volume
        });
        // Unmute shortly after to restore audio
        setTimeout(() => { video.muted = false; }, 200);
      })
      .catch(err => {
        console.warn('[PocketDim] ⚠️ Video play failed (first attempt):', err);
        console.warn('[PocketDim] Error name:', err.name, 'message:', err.message);
        console.warn('[PocketDim] Retrying with muted=true to bypass autoplay policy...');
        // Retry with muted if autoplay policy blocks
        video.muted = true;
        return video.play();
      })
      .then(() => { console.log('[PocketDim] ▶️ Video playing'); })
      .catch(err => {
        console.error('[PocketDim] ❌ Video play completely failed:', err);
        console.error('[PocketDim] Final video state:', {
          src: video.src,
          paused: video.paused,
          error: video.error,
          networkState: video.networkState,
          readyState: video.readyState
        });
      });
  };
  
  // Try to play immediately (do not pause)
  console.log('[PocketDim] Calling playVideo() immediately...');
  tryPlay();
  
  // Also try on next user interaction
  const playOnInteraction = () => {
    console.log('[PocketDim] 🖱️ User clicked - attempting video play');
    playVideo();
    document.removeEventListener('click', playOnInteraction);
  };
  document.addEventListener('click', playOnInteraction, { once: true });
  console.log('[PocketDim] Added click listener for video playback');
  
  console.log('[PocketDim] Video display created in sky with reverb audio!');
  
  // Store reference for cleanup
  window.pocketDimensionVideo = {
    group: videoGroup,
    video: video,
    videoTexture: videoTexture,
    screen: screen
  };
  
  showDialogue('🎬 The sky watches...', 3000);
}

// First-person mode state (now managed by CameraManager)
if (!window.fpFloorPlane) window.fpFloorPlane = null;

// Enter first-person exploration mode with pocket dimension video
function enterFirstPersonMode() {
  console.log('[FirstPerson] Entering first-person exploration mode');
  
  // Position camera for first-person view
  camera.position.set(0, 1.6, 0); // Eye height
  camera.rotation.set(0, 0, 0);
  
  // Use CameraManager to switch to FPS mode
  window.CameraManager.setMode('fps');
  
  console.log('[FirstPerson] After: camera.position =', camera.position);
  
  // Hide UI
  const gizmoToolbar = document.getElementById('gizmo-toolbar');
  if (gizmoToolbar) gizmoToolbar.style.display = 'none';
  
  // Show ground plane if not visible
  if (!window.fpFloorPlane) {
    console.log('[FirstPerson] Creating floor plane...');
    const floorGeo = new THREE.PlaneGeometry(100, 100);
    const floorMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.9 });
    window.fpFloorPlane = new THREE.Mesh(floorGeo, floorMat);
    window.fpFloorPlane.rotation.x = -Math.PI / 2;
    window.fpFloorPlane.receiveShadow = true;
    scene.add(window.fpFloorPlane);
    console.log('[FirstPerson] Floor plane created and added to scene');
  }
  
  showDialogue('🚪 First-person mode: Use WASD to move, Space to jump, Shift to sprint', 4000);
  
  // Add pocket dimension video when entering first-person mode
  console.log('[FirstPerson] Scheduling video display creation in 2 seconds...');
  
  setTimeout(() => {
    console.log('[FirstPerson] ⏰ 2 seconds elapsed - checking firstPersonModeActive:', window.CameraManager.isFPSMode);
    
    if (window.CameraManager.isFPSMode) {
      console.log('[FirstPerson] ✅ Creating pocket dimension video display...');
      try {
        createPocketDimensionVideoDisplay();
      } catch (err) {
        console.error('[FirstPerson] ❌ Error creating video:', err);
      }
    } else {
      console.warn('[FirstPerson] ⚠️ FPS mode inactive - video not created');
    }
  }, 2000);
}

// Note: Drop button handlers are already wired elsewhere to the existing dropPlayer() function for city exploration
// Note: Key handlers for FPS/drop modes are now in the unified CameraManager section

// Debug menu minimize/restore
 const debugMenu = document.getElementById('debug-menu');
 const debugMenuMinimizeBtn = document.getElementById('debug-menu-minimize');
 const debugMenuRestoreBtn = document.getElementById('debug-menu-restore');
 
 debugMenuMinimizeBtn.addEventListener('click', () => {
 debugMenu.classList.add('minimized');
 debugMenuRestoreBtn.classList.add('visible');
 console.log('[DebugMenu] Menu minimized');
 });
 
debugMenuRestoreBtn.addEventListener('click', () => {
debugMenu.classList.remove('minimized');
debugMenuRestoreBtn.classList.remove('visible');
console.log('[DebugMenu] Menu restored');
});

// Start with menu minimized and button visible
debugMenu.classList.add('minimized');
debugMenuRestoreBtn.classList.add('visible');

// === Early Preview Button Handlers ===

// Spreadsheet button
document.getElementById('btn-show-spreadsheet')?.addEventListener('click', () => {
console.log('[EarlyPreview] Spawning 3D spreadsheet viewport');
if (typeof spawnViewportPrism === 'function') {
spawnViewportPrism();
showDialogue('📊 3D Spreadsheet spawning...', 2000);
} else {
console.error('[EarlyPreview] spawnViewportPrism function not found');
showDialogue('❌ Spreadsheet not available', 2000);
}
});

// Chief sequence button already handled below in the code
 
 // Raycaster for clicking buttons on frame
 const frameRaycaster = new THREE.Raycaster();
 const frameMouse = new THREE.Vector2();
 let currentSnapMode = 'free'; // Track snap mode
 
 renderer.domElement.addEventListener('click', (event) => {
 // Check if frame is visible
 if (!frameOfReference || !frameOfReference.visible) return;
 
 // Calculate mouse position in normalized device coordinates
 const rect = renderer.domElement.getBoundingClientRect();
 frameMouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
 frameMouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
 
 // Update raycaster
 frameRaycaster.setFromCamera(frameMouse, camera);
 
 // Check for intersection with minimize button
 if (minimizeButton && minimizeButton.circle) {
 const intersects = frameRaycaster.intersectObject(minimizeButton.circle, false);
 
 if (intersects.length > 0) {
 console.log('[FrameOfRef] Minimize button clicked!');
 toggleFrameMinimize();
 event.stopPropagation();
 return;
 }
 }
 
 // Check for intersection with gizmo buttons
 if (frameOfReference.userData.gizmoButtons) {
 const gizmoButtons = frameOfReference.userData.gizmoButtons;
 const buttonMeshes = gizmoButtons.map(b => b.button);
 const intersects = frameRaycaster.intersectObjects(buttonMeshes, false);
 
 if (intersects.length > 0) {
 const clickedButton = intersects[0].object;
 const mode = clickedButton.userData.mode;
 
 console.log(`[FrameOfRef] Gizmo button clicked: ${mode}`);
 
 // Animate button press
 animateButtonPress(clickedButton);
 
 // Handle snap mode separately (toggle through modes)
 if (mode === 'snap') {
 const snapModes = ['free', '45', '90'];
 const currentIndex = snapModes.indexOf(currentSnapMode);
 currentSnapMode = snapModes[(currentIndex + 1) % snapModes.length];
 
 if (currentSnapMode === 'free') {
 transformControl.setRotationSnap(null);
 transformControl.setTranslationSnap(null);
 console.log('[FrameOfRef] Snap: Free');
 } else if (currentSnapMode === '45') {
 transformControl.setRotationSnap(THREE.MathUtils.degToRad(45));
 transformControl.setTranslationSnap(0.5);
 console.log('[FrameOfRef] Snap: 45 ');
 } else if (currentSnapMode === '90') {
 transformControl.setRotationSnap(THREE.MathUtils.degToRad(90));
 transformControl.setTranslationSnap(1.0);
 console.log('[FrameOfRef] Snap: 90 ');
 }
 } else if (mode === 'sculpt') {
 // Enable sculpt mode
 enableSculptMode();
 console.log('[FrameOfRef] Sculpt mode activated');
 
 // Update active states
 gizmoButtons.forEach(({ button }) => {
 if (button.userData.mode === 'sculpt') {
 button.userData.isActive = true;
 button.material.emissiveIntensity = 0.5;
 } else if (button.userData.mode !== 'snap') {
 button.userData.isActive = false;
 button.material.emissiveIntensity = 0.2;
 }
 });
 } else {
 // Set transform mode (translate, rotate, scale)
 transformControl.setMode(mode);
 
 // Update active states
 gizmoButtons.forEach(({ button }) => {
 if (button.userData.mode === mode) {
 button.userData.isActive = true;
 button.material.emissiveIntensity = 0.5;
 } else if (button.userData.mode !== 'snap') {
 button.userData.isActive = false;
 button.material.emissiveIntensity = 0.2;
 }
 });
 }
 
 event.stopPropagation();
 }
 }
 });
 
 // Animate button depression
 function animateButtonPress(button) {
 const startZ = button.position.z;
 const targetZ = button.userData.pressedZ;
 const duration = 100; // ms
 const startTime = Date.now();
 
 // Find the corresponding label
 const gizmoButtons = frameOfReference.userData.gizmoButtons;
 const buttonData = gizmoButtons.find(b => b.button === button);
 const label = buttonData ? buttonData.label : null;
 const labelStartZ = label ? label.position.z : 0;
 const labelOffset = labelStartZ - startZ;
 
 function animateDown() {
 const elapsed = Date.now() - startTime;
 const progress = Math.min(elapsed / duration, 1);
 
 button.position.z = startZ - (startZ - targetZ) * progress;
 if (label) {
 label.position.z = button.position.z + labelOffset;
 }
 
 if (progress < 1) {
 requestAnimationFrame(animateDown);
 } else {
 // Animate back up
 const releaseStart = Date.now();
 function animateUp() {
 const elapsed = Date.now() - releaseStart;
 const progress = Math.min(elapsed / duration, 1);
 
 button.position.z = targetZ + (button.userData.baseZ - targetZ) * progress;
 if (label) {
 label.position.z = button.position.z + labelOffset;
 }
 
 if (progress < 1) {
 requestAnimationFrame(animateUp);
 }
 }
 animateUp();
 }
 }
 
 animateDown();
 }
 
// ===== EXIF Metadata Gag Sequence =====
async function checkAndDisplayEXIFMetadata(file) {
  console.log('[EXIF] Checking file for metadata:', file.name);
  
  // Use FileReader to read the file as ArrayBuffer
  return new Promise((resolve) => {
    const reader = new FileReader();
    
    reader.onload = function(e) {
      try {
        const arrayBuffer = e.target.result;
        const dataView = new DataView(arrayBuffer);
        
        // Simple EXIF detection - check for JPEG markers and EXIF signature
        let hasEXIF = false;
        let metadata = {};
        
        // Check if it's a JPEG (FF D8 FF)
        if (dataView.byteLength >= 2 && dataView.getUint8(0) === 0xFF && dataView.getUint8(1) === 0xD8) {
          console.log('[EXIF] File is a JPEG - scanning for EXIF data...');
          
          // Look for EXIF marker (APP1: FF E1) in first 64KB
          const searchLimit = Math.min(dataView.byteLength, 65536);
          for (let i = 2; i < searchLimit - 10; i++) {
            if (dataView.getUint8(i) === 0xFF && dataView.getUint8(i + 1) === 0xE1) {
              // Check for "Exif" signature
              if (dataView.getUint8(i + 4) === 0x45 && // 'E'
                  dataView.getUint8(i + 5) === 0x78 && // 'x'
                  dataView.getUint8(i + 6) === 0x69 && // 'i'
                  dataView.getUint8(i + 7) === 0x66) { // 'f'
                hasEXIF = true;
                console.log('[EXIF] ✅ EXIF data found at offset:', i);
                
                // Try to extract basic metadata (simplified - full EXIF parsing is complex)
                // For production, would use a library like exif-js or piexifjs
                metadata.hasGPS = false;
                metadata.hasDeviceInfo = false;
                metadata.hasTimestamp = false;
                
                // Look for common EXIF tags in a simple way
                const exifSection = arrayBuffer.slice(i, Math.min(i + 10000, dataView.byteLength));
                const exifView = new DataView(exifSection);
                
                // GPS tag (0x8825)
                for (let j = 0; j < exifView.byteLength - 2; j++) {
                  const tag = exifView.getUint16(j, false);
                  if (tag === 0x8825) metadata.hasGPS = true;
                  if (tag === 0x010F || tag === 0x0110) metadata.hasDeviceInfo = true; // Make/Model
                  if (tag === 0x0132 || tag === 0x9003) metadata.hasTimestamp = true; // DateTime
                }
                
                break;
              }
            }
          }
        }
        
        if (hasEXIF) {
          console.log('[EXIF] Metadata found:', metadata);
          displayEXIFWarning(metadata);
        } else {
          console.log('[EXIF] No EXIF data found - image is clean');
        }
        
        resolve();
      } catch (err) {
        console.error('[EXIF] Error reading metadata:', err);
        resolve(); // Continue anyway
      }
    };
    
    reader.onerror = () => {
      console.error('[EXIF] FileReader error');
      resolve(); // Continue anyway
    };
    
    reader.readAsArrayBuffer(file);
  });
}

function displayEXIFWarning(metadata) {
  console.log('[EXIF] Displaying metadata warning to user');
  
  const warnings = [];
  
  if (metadata.hasGPS) {
    warnings.push('<strong style="color: #ff4444;">📍 GPS Coordinates</strong> (your location when the photo was taken)');
  }
  if (metadata.hasDeviceInfo) {
    warnings.push('<strong style="color: #ff8844;">📱 Device Information</strong> (phone/camera make and model)');
  }
  if (metadata.hasTimestamp) {
    warnings.push('<strong style="color: #ffaa44;">📅 Timestamp</strong> (exact date and time)');
  }
  
  if (warnings.length === 0) {
    warnings.push('Some <strong>identifying information</strong>');
  }
  
  const warningText = warnings.join(', ');
  
  // Show initial detection dialogue
  showDialogue(`🔍 Interesting... This photo contains metadata: ${warningText}.`, 5000);
  
  // Follow up with Celli's warning
  setTimeout(() => {
    showDialogue(
      `<strong>Anyone</strong> who has access to this image can see this information. ` +
      `When you upload photos from your smartphone to the internet, ` +
      `<em>you're sharing more than just the picture</em>. ` +
      `<br><br>` +
      `But don't worry—<strong>it's a good thing you're in Celli's hands.</strong> ` +
      `I won't tell anyone. 😉`,
      10000
    );
  }, 5500);
}

// Cursor sequence button and file input
let cursorImageData = null;
document.getElementById('btn-cursor-sequence')?.addEventListener('click', () => {
document.getElementById('cursor-file-input')?.click();
});

document.getElementById('cursor-file-input')?.addEventListener('change', async (e) => {
const file = e.target.files[0];
if (!file) return;
 
 try {
 console.log('[HandUpload] Processing uploaded hand image:', file.name);
 
 // Check for EXIF metadata first
 await checkAndDisplayEXIFMetadata(file);
 
 const img = await loadImageFromFile(file);
 console.log('[HandUpload] Image loaded:', img.width, 'x', img.height);
 
 const gridData = toPixelGrid(img, 96);
 console.log('[HandUpload] Grid data created:', gridData.width, 'x', gridData.height);
 
 const coords = posterizeAndExtract(gridData);
 console.log('[HandUpload] Coordinates extracted:', coords);
 
 if(!coords.silhouette || coords.silhouette.length < 10){
 throw new Error('No hand detected. Make sure the image has a clear hand on white background.');
 }
 
 // Generate preview
 const previewDataURL = generatePreviewDataURL(coords);
 
 // Prompt for name
 const handName = prompt('Enter a name for this hand configuration:', `Hand ${Date.now()}`);
 if (handName) {
 saveHandConfig(handName, coords, previewDataURL);
 populateHandConfigSelect();
 alert(`Hand "${handName}" saved! You can spawn it later from the preview.`);
 }
 
 // Trigger the animation sequence with the new coords
 createVoxelCursorSequence(coords);
 
 console.log('[HandUpload] Successfully processed and applied hand image');
 } catch(err) {
 console.error('[HandUpload] Image processing error:', err);
 alert('Failed to process image: ' + err.message);
 }
 });
 
 // Save/Load hand configs from localStorage
 const HAND_CONFIGS_KEY = 'voxelHandConfigs';
 
 function saveHandConfig(name, coords, previewDataURL, stages = null) {
 const configs = JSON.parse(localStorage.getItem(HAND_CONFIGS_KEY) || '{}');
 
 // Generate stages if not provided
 if (!stages) {
 stages = generateAllStages(coords);
 }
 
 configs[name] = {
 coords: coords,
 preview: previewDataURL,
 stages: stages, // Store all 12 animation stages
 timestamp: Date.now()
 };
 localStorage.setItem(HAND_CONFIGS_KEY, JSON.stringify(configs));
 console.log(`[HandConfig] Saved hand config "${name}" with ${stages.length} stages`);
 }
 
 // Generate all 12 stage previews as data URLs with increasing resolution
 function generateAllStages(coords) {
 console.log(`[HandConfig] Generating stages for hand with ${coords.silhouette?.length || 0} silhouette pixels`);
 
 const { width: W, height: H, silhouette, outline, shade, highlight, colors } = coords;
 const baseCol = colors?.base || '#f3d2b4';
 const shadeCol = colors?.shade || '#d4b090';
 const outlineCol = colors?.outline || '#23160e';
 const hiCol = colors?.highlight || '#fff3e2';
 
 if (!silhouette || silhouette.length === 0) {
 console.error('[HandConfig] No silhouette data found - cannot generate stages!');
 return [];
 }
 
 // Create display and work canvases
 const displayCanvas = document.createElement('canvas');
 displayCanvas.width = W;
 displayCanvas.height = H;
 const displayCtx = displayCanvas.getContext('2d');
 displayCtx.imageSmoothingEnabled = false;
 
 const workCanvas = document.createElement('canvas');
 const workCtx = workCanvas.getContext('2d');
 workCtx.imageSmoothingEnabled = false;
 
 const stages = [];
 const totalStages = 12;
 const resolutionMap = { 
 0: 8, 1: 12, 2: 16, 3: 24, 4: 32, 5: 40, 
 6: 48, 7: 56, 8: 64, 9: 72, 10: 80, 11: 88, 12: 96 
 };
 
 for (let stage = 0; stage <= totalStages; stage++) {
 const resolution = resolutionMap[stage] || 96;
 const scale = W / resolution;
 
 // Resize work canvas
 workCanvas.width = resolution;
 workCanvas.height = resolution;
 workCtx.clearRect(0, 0, resolution, resolution);
 
 // Draw at lower resolution
 const px = (x, y, color) => {
 const scaledX = Math.floor(x / scale);
 const scaledY = Math.floor(y / scale);
 if (scaledX >= 0 && scaledX < resolution && scaledY >= 0 && scaledY < resolution) {
 workCtx.fillStyle = color;
 workCtx.fillRect(scaledX, scaledY, 1, 1);
 }
 };
 
 // Draw stage content
 if (stage >= 1) {
 const silAmount = Math.floor(silhouette.length * (stage / totalStages));
 for (let i = 0; i < silAmount; i++) {
 const [x, y] = silhouette[i];
 px(x, y, baseCol);
 }
 }
 
 if (stage >= 3 && shade && shade.length > 0) {
 const shadeAmount = Math.floor(shade.length * ((stage - 2) / (totalStages - 2)));
 for (let i = 0; i < shadeAmount; i++) {
 const [x, y] = shade[i];
 px(x, y, shadeCol);
 }
 }
 
 if (stage >= 10 && highlight && highlight.length > 0) {
 const hiAmount = Math.floor(highlight.length * ((stage - 9) / 3));
 for (let i = 0; i < hiAmount; i++) {
 const [x, y] = highlight[i];
 px(x, y, hiCol);
 }
 }
 
 if (stage >= 1 && outline && outline.length > 0) {
 const outAmount = Math.floor(outline.length * (stage / totalStages));
 for (let i = 0; i < outAmount; i++) {
 const [x, y] = outline[i];
 px(x, y, outlineCol);
 }
 }
 
 // Scale up to display canvas
 displayCtx.clearRect(0, 0, W, H);
 displayCtx.drawImage(workCanvas, 0, 0, resolution, resolution, 0, 0, W, H);
 
 const dataURL = displayCanvas.toDataURL();
 stages.push(dataURL);
 
 // Debug log for first few stages
 if (stage <= 2) {
 console.log(`[HandConfig] Stage ${stage}: ${resolution}x${resolution} resolution, ${stage >= 1 ? Math.floor(silhouette.length * (stage / totalStages)) : 0} pixels`);
 }
 }
 
 console.log(`[HandConfig] ? Generated ${stages.length} animation stages with progressive resolution (8x8 to 96x96)`);
 return stages;
 }
 
 function loadHandConfigs() {
 return JSON.parse(localStorage.getItem(HAND_CONFIGS_KEY) || '{}');
 }
 
 // Populate saved hand configs with previews
 function populateHandConfigSelect() {
 const configs = loadHandConfigs();
 const container = document.getElementById('hand-config-previews');
 if (!container) return;
 
 container.innerHTML = '';
 Object.keys(configs).forEach(name => {
 const config = configs[name];
 const div = document.createElement('div');
 div.style.cssText = 'display: inline-block; margin: 5px; padding: 5px; border: 1px solid #444; cursor: pointer; text-align: center; background: #222;';
 
 const img = document.createElement('img');
 img.src = config.preview;
 img.style.cssText = 'width: 48px; height: 48px; image-rendering: pixelated; display: block;';
 
 const label = document.createElement('div');
 label.textContent = name;
 label.style.cssText = 'font-size: 10px; margin-top: 2px; color: #fff;';
 
 div.appendChild(img);
 div.appendChild(label);
 div.onclick = () => {
 console.log(`[HandConfig] Spawning saved hand: ${name}`);
 console.log(`[HandConfig] Stages available: ${config.stages ? config.stages.length : 0}`);
 createVoxelCursorSequence(config.coords, config.stages);
 };
 
 container.appendChild(div);
 });
 }
 
 // Initialize saved hands on load
 populateHandConfigSelect();
 
 // ===== Full cursor.html extraction and animation sequence =====
 
 // ===== Image Processing Functions (from cursor.html) =====
 
 function loadImageFromFile(file){
 return new Promise((resolve, reject)=>{
 const url = URL.createObjectURL(file);
 const img = new Image();
 img.onload = ()=>{ URL.revokeObjectURL(url); resolve(img); };
 img.onerror = reject;
 img.src = url;
 });
 }
 
 function toPixelGrid(img, grid=96){
 const work = document.createElement('canvas');
 const wctx = work.getContext('2d', { willReadFrequently: true });
 const maxSide = Math.max(img.width, img.height);
 const sx = (img.width - img.height)/2;
 const sy = (img.height - img.width)/2;
 const sw = Math.min(img.width, img.height);
 const sh = sw;
 work.width = work.height = grid;
 wctx.imageSmoothingEnabled = false;
 wctx.clearRect(0,0,grid,grid);
 wctx.fillStyle = '#ffffff';
 wctx.fillRect(0, 0, grid, grid);
 wctx.drawImage(img, Math.max(0,sx), Math.max(0,sy), sw, sh, 0, 0, grid, grid);
 const data = wctx.getImageData(0,0,grid,grid);
 return data;
 }
 
function posterizeAndExtract(data){
const W = data.width, H = data.height, D = data.data;

// Auto-detect background color by sampling corners and edges
console.log('[HandVoxelizer] Auto-detecting background color...');
const edgeSamples = [];
const sampleSize = Math.min(10, Math.floor(W * 0.1)); // Sample 10% of edges

// Sample corners (more reliable for background detection)
for (let x = 0; x < sampleSize; x++) {
  for (let y = 0; y < sampleSize; y++) {
    // Top-left
    let i = (y * W + x) * 4;
    edgeSamples.push({ r: D[i], g: D[i+1], b: D[i+2], a: D[i+3] });
    // Top-right
    i = (y * W + (W - 1 - x)) * 4;
    edgeSamples.push({ r: D[i], g: D[i+1], b: D[i+2], a: D[i+3] });
    // Bottom-left
    i = ((H - 1 - y) * W + x) * 4;
    edgeSamples.push({ r: D[i], g: D[i+1], b: D[i+2], a: D[i+3] });
    // Bottom-right
    i = ((H - 1 - y) * W + (W - 1 - x)) * 4;
    edgeSamples.push({ r: D[i], g: D[i+1], b: D[i+2], a: D[i+3] });
  }
}

// Find most common color in samples (background)
const colorCounts = {};
edgeSamples.forEach(({ r, g, b, a }) => {
  // Quantize to reduce noise (round to nearest 16)
  const qr = Math.round(r / 16) * 16;
  const qg = Math.round(g / 16) * 16;
  const qb = Math.round(b / 16) * 16;
  const key = `${qr},${qg},${qb},${a}`;
  colorCounts[key] = (colorCounts[key] || 0) + 1;
});

const bgColorKey = Object.keys(colorCounts).reduce((a, b) => 
  colorCounts[a] > colorCounts[b] ? a : b
);
const [bgR, bgG, bgB, bgA] = bgColorKey.split(',').map(Number);
console.log('[HandVoxelizer] Detected background color:', { r: bgR, g: bgG, b: bgB, a: bgA });

// Check if a pixel is background (with tolerance)
const tolerance = 40; // Color distance tolerance
const isBackground = (r, g, b, a) => {
  // Check alpha first (transparent = background)
  if (a < 250) return true;
  // Check color distance from detected background
  const dr = r - bgR;
  const dg = g - bgG;
  const db = b - bgB;
  const distance = Math.sqrt(dr*dr + dg*dg + db*db);
  return distance < tolerance;
};

const lum = (r,g,b)=> 0.2126*r + 0.7152*g + 0.0722*b;
const toHex = (r,g,b)=> '#' + [r,g,b].map(v=>Math.round(v).toString(16).padStart(2,'0')).join('');

const fg = new Array(H).fill(0).map(()=>new Array(W).fill(false));
const L = new Array(H).fill(0).map(()=>new Array(W).fill(0));
const colors = new Array(H).fill(0).map(()=>new Array(W).fill(null));

let fgPixelCount = 0;
for(let y=0; y<H; y++){
for(let x=0; x<W; x++){
const i = (y*W + x)*4; 
const r=D[i], g=D[i+1], b=D[i+2], a=D[i+3];
if(!isBackground(r,g,b,a)){
fg[y][x] = true; 
L[y][x] = lum(r,g,b);
colors[y][x] = toHex(r,g,b);
fgPixelCount++;
}
}
}
console.log('[HandVoxelizer] Foreground pixels detected:', fgPixelCount, '/', W*H, `(${(fgPixelCount/(W*H)*100).toFixed(1)}%)`);
 
 let minL=255, maxL=0; 
 for(let y=0;y<H;y++) {
 for(let x=0;x<W;x++) {
 if(fg[y][x]){ 
 const v=L[y][x]; 
 if(v<minL)minL=v; 
 if(v>maxL)maxL=v; 
 }
 }
 }
 
 const t1 = minL + (maxL-minL)*0.35;
 const t2 = minL + (maxL-minL)*0.75;

 const baseColors=[], shadeColors=[], highlightColors=[], outlineColors=[];
 const silhouette=[], outline=[], shade=[], highlight=[];
 const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
 
 for(let y=0;y<H;y++){
 for(let x=0;x<W;x++){
 if(!fg[y][x]) continue;
 const col = colors[y][x];
 silhouette.push([x,y]);
 baseColors.push(col);
 
 const lv = L[y][x];
 if(lv <= t1) { 
 shade.push([x,y]); 
 shadeColors.push(col);
 } else if(lv >= t2) { 
 highlight.push([x,y]);
 highlightColors.push(col);
 }
 
 let border=false; 
 for(const [dx,dy] of dirs){ 
 const nx=x+dx, ny=y+dy; 
 if(nx<0||ny<0||nx>=W||ny>=H||!fg[ny][nx]){ 
 border=true; 
 break; 
 } 
 }
 if(border) {
 outline.push([x,y]);
 outlineColors.push(col);
 }
 }
 }
 
 const avgColor = (cols) => {
 if(!cols.length) return '#000000';
 let r=0,g=0,b=0;
 for(const c of cols){
 r += parseInt(c.substr(1,2), 16);
 g += parseInt(c.substr(3,2), 16);
 b += parseInt(c.substr(5,2), 16);
 }
 return toHex(r/cols.length, g/cols.length, b/cols.length);
 };
 
 const avgBase = avgColor(baseColors);
 const avgShade = avgColor(shadeColors.length ? shadeColors : baseColors);
 const avgHighlight = avgColor(highlightColors.length ? highlightColors : baseColors);
 const avgOutline = avgColor(outlineColors.length ? outlineColors : baseColors);
 
 let minY=Infinity; 
 for(const [x,y] of silhouette){ 
 if(y<minY) minY=y; 
 }
 const topXs = silhouette.filter(([x,y])=>y===minY).map(([x])=>x).sort((a,b)=>a-b);
 const hotspot = { 
 x: topXs.length? topXs[Math.floor(topXs.length/2)] : Math.floor(W/2), 
 y: (minY===Infinity? Math.floor(H*0.1) : minY) 
 };
 
 console.log(`Extracted: ${silhouette.length} silhouette, ${outline.length} outline, ${shade.length} shade, ${highlight.length} highlight pixels`);

 return { width:W, height:H, silhouette, outline, shade, highlight, hotspot, colors: { base: avgBase, shade: avgShade, highlight: avgHighlight, outline: avgOutline } };
 }
 
 function generatePreviewDataURL(coords) {
 const canvas = document.createElement('canvas');
 canvas.width = coords.width;
 canvas.height = coords.height;
 const ctx = canvas.getContext('2d');
 ctx.imageSmoothingEnabled = false;
 
 const px = (x, y, color) => {
 ctx.fillStyle = color;
 ctx.fillRect(x, y, 1, 1);
 };
 
 coords.silhouette.forEach(([x,y]) => px(x, y, coords.colors.base));
 coords.shade.forEach(([x,y]) => px(x, y, coords.colors.shade));
 coords.highlight.forEach(([x,y]) => px(x, y, coords.colors.highlight));
 coords.outline.forEach(([x,y]) => px(x, y, coords.colors.outline));
 
 return canvas.toDataURL();
 }
 
 // Default hand coordinates (from cursor.html)
 const defaultHandCoords = {
 "width": 96,
 "height": 96,
 "silhouette": [[47,10],[48,10],[46,11],[47,11],[48,11],[44,12],[46,12],[47,12],[48,12],[51,12],[52,12],[43,13],[44,13],[46,13],[47,13],[48,13],[50,13],[51,13],[52,13],[43,14],[44,14],[46,14],[47,14],[48,14],[50,14],[51,14],[52,14],[43,15],[44,15],[45,15],[46,15],[47,15],[48,15],[50,15],[51,15],[52,15],[43,16],[44,16],[45,16],[46,16],[47,16],[48,16],[50,16],[51,16],[52,16],[54,16],[55,16],[43,17],[44,17],[45,17],[46,17],[47,17],[48,17],[50,17],[51,17],[52,17],[54,17],[55,17],[43,18],[44,18],[45,18],[46,18],[47,18],[48,18],[50,18],[51,18],[52,18],[54,18],[55,18],[43,19],[44,19],[45,19],[46,19],[47,19],[48,19],[50,19],[51,19],[52,19],[54,19],[55,19],[44,20],[45,20],[46,20],[47,20],[48,20],[50,20],[51,20],[52,20],[54,20],[55,20],[44,21],[45,21],[46,21],[47,21],[48,21],[50,21],[51,21],[53,21],[54,21],[55,21],[44,22],[45,22],[46,22],[47,22],[48,22],[49,22],[50,22],[51,22],[53,22],[54,22],[55,22],[45,23],[46,23],[47,23],[48,23],[49,23],[50,23],[51,23],[53,23],[54,23],[55,23],[45,24],[46,24],[47,24],[48,24],[49,24],[50,24],[51,24],[52,24],[53,24],[54,24],[42,25],[43,25],[44,25],[45,25],[46,25],[47,25],[48,25],[49,25],[50,25],[51,25],[52,25],[53,25],[54,25],[42,26],[43,26],[44,26],[45,26],[46,26],[47,26],[48,26],[49,26],[50,26],[51,26],[52,26],[53,26],[54,26],[43,27],[44,27],[45,27],[46,27],[47,27],[48,27],[49,27],[50,27],[51,27],[52,27],[53,27],[54,27],[55,27],[43,28],[44,28],[45,28],[46,28],[47,28],[48,28],[49,28],[50,28],[51,28],[52,28],[53,28],[54,28],[55,28],[44,29],[45,29],[46,29],[47,29],[48,29],[49,29],[50,29],[51,29],[52,29],[53,29],[54,29],[44,30],[45,30],[46,30],[47,30],[48,30],[49,30],[50,30],[51,30],[52,30],[53,30],[54,30],[55,30],[45,31],[46,31],[47,31],[48,31],[49,31],[50,31],[51,31],[52,31],[53,31],[54,31],[55,31],[46,32],[47,32],[48,32],[49,32],[50,32],[51,32],[52,32],[53,32],[54,32],[55,32],[47,33],[48,33],[49,33],[50,33],[51,33],[52,33],[53,33],[54,33],[55,33],[48,34],[49,34],[50,34],[51,34],[52,34],[53,34],[54,34],[55,34],[48,35],[49,35],[50,35],[51,35],[52,35],[53,35],[54,35],[55,35],[48,36],[49,36],[50,36],[51,36],[52,36],[53,36],[54,36],[55,36],[49,37],[50,37],[51,37],[52,37],[53,37],[54,37],[55,37],[50,38],[51,38],[52,38],[53,38],[54,38],[55,38],[51,39],[52,39],[53,39],[54,39],[55,39],[52,40],[53,40],[54,40],[55,40]],
 "outline": [[47,10],[48,10],[46,11],[48,11],[44,12],[46,12],[48,12],[51,12],[52,12],[43,13],[44,13],[46,13],[48,13],[50,13],[52,13],[43,14],[44,14],[46,14],[48,14],[50,14],[52,14],[43,15],[45,15],[46,15],[48,15],[50,15],[52,15],[43,16],[45,16],[46,16],[48,16],[50,16],[52,16],[54,16],[55,16],[43,17],[45,17],[46,17],[48,17],[50,17],[52,17],[54,17],[55,17],[43,18],[45,18],[46,18],[48,18],[50,18],[52,18],[54,18],[55,18],[43,19],[46,19],[48,19],[50,19],[52,19],[54,19],[55,19],[44,20],[46,20],[48,20],[50,20],[52,20],[54,20],[55,20],[44,21],[46,21],[48,21],[50,21],[51,21],[53,21],[55,21],[44,22],[47,22],[49,22],[51,22],[53,22],[55,22],[45,23],[51,23],[53,23],[55,23],[45,24],[52,24],[54,24],[42,25],[43,25],[44,25],[45,25],[54,25],[42,26],[44,26],[45,26],[54,26],[43,27],[44,27],[45,27],[55,27],[43,28],[46,28],[55,28],[44,29],[46,29],[54,29],[44,30],[46,30],[55,30],[45,31],[46,31],[55,31],[46,32],[55,32],[47,33],[55,33],[48,34],[55,34],[48,35],[55,35],[48,36],[55,36],[49,37],[55,37],[50,38],[55,38],[51,39],[55,39],[52,40],[54,40],[55,40]],
 "shade": [[43,15],[45,16],[54,16],[47,18],[54,18],[44,19],[46,19],[46,20],[53,21],[44,22],[49,22],[49,23],[45,24],[43,25],[44,25],[42,26],[43,26],[44,26],[43,27],[44,27],[46,27],[43,28],[45,28],[46,28],[44,29],[45,29],[46,29],[44,30],[45,30],[46,30],[45,31],[46,31],[46,32],[47,33],[48,34],[48,35],[49,36],[50,37],[51,38],[51,39],[52,40]],
 "highlight": [[44,12],[50,13],[45,15],[43,19],[46,19],[46,21],[47,22],[55,27],[44,28],[55,28],[45,31],[48,36]],
 "hotspot": {"x": 48, "y": 10},
 "colors": { "base": "#f3d2b4", "shade": "#d4b090", "highlight": "#fff3e2", "outline": "#23160e" }
 };
 
 function createBeveledCubeGeometry(size, bevel) {
 const geometry = new THREE.BoxGeometry(size * (1 - bevel), size * (1 - bevel), size * (1 - bevel));
 return geometry;
 }
 
 function buildVoxelHandFromCoords(coords, fingerAnim = 0) {
 const { width: W, height: H, silhouette, outline, shade, highlight, colors } = coords;
 const baseCol = colors?.base || '#f3d2b4';
 const shadeCol = colors?.shade || '#d4b090';
 const outlineCol = colors?.outline || '#23160e';
 const hiCol = colors?.highlight || '#fff3e2';

 const voxelHandGroup = new THREE.Group();
 voxelHandGroup.name = "Voxel Cursor Hand";
 
 const voxelSize = 0.02;
 const bevelAmount = 0.15;
 const thicknessLayers = 8;
 
 let coordsToRender = [];
 silhouette.forEach(c => coordsToRender.push([...c, baseCol]));
 shade.forEach(c => coordsToRender.push([...c, shadeCol]));
 if (highlight && highlight.length > 0) {
 highlight.forEach(c => coordsToRender.push([...c, hiCol]));
 }
 outline.forEach(c => coordsToRender.push([...c, outlineCol]));

 // Create a lookup set for checking neighbors
 const voxelSet = new Set();
 coordsToRender.forEach(([x, y, color]) => {
 for (let z = 0; z < thicknessLayers; z++) {
 voxelSet.add(`${x},${y},${z}`);
 }
 });
 
 // Function to check if a voxel should be removed for beveling
 function shouldBevelVoxel(x, y, z) {
 // Check the 6 direct face neighbors (up, down, left, right, front, back)
 const faceNeighbors = [
 voxelSet.has(`${x+1},${y},${z}`),
 voxelSet.has(`${x-1},${y},${z}`),
 voxelSet.has(`${x},${y+1},${z}`),
 voxelSet.has(`${x},${y-1},${z}`),
 voxelSet.has(`${x},${y},${z+1}`),
 voxelSet.has(`${x},${y},${z-1}`)
 ];
 const faceFilled = faceNeighbors.filter(n => n).length;
 
 // Check diagonal edge neighbors (12 edges of cube)
 const edgeNeighbors = [
 voxelSet.has(`${x+1},${y+1},${z}`),
 voxelSet.has(`${x+1},${y-1},${z}`),
 voxelSet.has(`${x-1},${y+1},${z}`),
 voxelSet.has(`${x-1},${y-1},${z}`),
 voxelSet.has(`${x+1},${y},${z+1}`),
 voxelSet.has(`${x+1},${y},${z-1}`),
 voxelSet.has(`${x-1},${y},${z+1}`),
 voxelSet.has(`${x-1},${y},${z-1}`),
 voxelSet.has(`${x},${y+1},${z+1}`),
 voxelSet.has(`${x},${y+1},${z-1}`),
 voxelSet.has(`${x},${y-1},${z+1}`),
 voxelSet.has(`${x},${y-1},${z-1}`)
 ];
 const edgeFilled = edgeNeighbors.filter(n => n).length;
 
 // Check corner neighbors (8 corners of cube)
 const cornerNeighbors = [
 voxelSet.has(`${x+1},${y+1},${z+1}`),
 voxelSet.has(`${x+1},${y+1},${z-1}`),
 voxelSet.has(`${x+1},${y-1},${z+1}`),
 voxelSet.has(`${x+1},${y-1},${z-1}`),
 voxelSet.has(`${x-1},${y+1},${z+1}`),
 voxelSet.has(`${x-1},${y+1},${z-1}`),
 voxelSet.has(`${x-1},${y-1},${z+1}`),
 voxelSet.has(`${x-1},${y-1},${z-1}`)
 ];
 const cornerFilled = cornerNeighbors.filter(n => n).length;
 
 // Aggressive beveling strategy for smoother, more rounded appearance:
 // - Remove multiple layers of surface voxels
 // - Create smooth curves by removing edge and corner voxels
 
 // Remove voxels with less than 4 face neighbors (more aggressive than before)
 if (faceFilled < 4) return true;
 
 // Remove sharp edges - if missing any face neighbor and few edge neighbors
 if (faceFilled < 6 && edgeFilled < 8) return true;
 
 // Remove corner voxels more aggressively
 if (faceFilled === 4 && edgeFilled < 9) return true;
 
 // Remove voxels that form sharp corners
 const totalNeighbors = faceFilled + edgeFilled + cornerFilled;
 if (totalNeighbors < 15) return true;
 
 // Secondary pass: remove additional edge voxels for smoother curves
 if (faceFilled === 5 && edgeFilled < 10 && cornerFilled < 6) return true;
 
 return false;
 }

 const colorGroups = {};
 let totalVoxels = 0;
 let beveledVoxels = 0;
 
 coordsToRender.forEach(([x, y, color]) => {
 if (!colorGroups[color]) colorGroups[color] = [];
 for (let z = 0; z < thicknessLayers; z++) {
 totalVoxels++;
 // Apply beveling - skip voxels that should be removed
 if (!shouldBevelVoxel(x, y, z)) {
 colorGroups[color].push({ x, y, z });
 } else {
 beveledVoxels++;
 }
 }
 });
 
 const remainingVoxels = totalVoxels - beveledVoxels;
 console.log(`[VoxelHand] Beveling applied: Removed ${beveledVoxels} of ${totalVoxels} voxels (${((beveledVoxels/totalVoxels)*100).toFixed(1)}%) for rounded edges`);
 console.log(`[VoxelHand] Remaining voxels: ${remainingVoxels}`);

 const cubeGeometry = createBeveledCubeGeometry(voxelSize, bevelAmount);

 Object.entries(colorGroups).forEach(([color, positions]) => {
 const instancedMesh = new THREE.InstancedMesh(
 cubeGeometry,
 new THREE.MeshStandardMaterial({ 
 color: color,
 metalness: 0.1,
 roughness: 0.6
 }),
 positions.length
 );

 const matrix = new THREE.Matrix4();
 positions.forEach((pos, i) => {
 const px = (pos.x - W/2) * voxelSize;
 const py = (pos.z) * voxelSize;
 const pz = (pos.y - H/2) * voxelSize;
 
 matrix.makeTranslation(px, py, pz);
 instancedMesh.setMatrixAt(i, matrix);
 });
 
 instancedMesh.instanceMatrix.needsUpdate = true;
 instancedMesh.castShadow = true;
 instancedMesh.receiveShadow = true;
 voxelHandGroup.add(instancedMesh);
 });

 const baseHeight = voxelSize * thicknessLayers * 2.5 / 2;
 voxelHandGroup.position.set(0, baseHeight, 0);
 voxelHandGroup.scale.setScalar(2.5);
 
 return voxelHandGroup;
 }
 
 function animateVoxelHandPopIn(voxelHandGroup) {
 const targetScale = 2.5;
 const baseHeight = 0.02 * 8 * 2.5 / 2;
 voxelHandGroup.scale.setScalar(0.01);
 voxelHandGroup.position.y = baseHeight;
 
 const startTime = Date.now();
 const popDuration = 600;
 
 function animatePop() {
 const elapsed = Date.now() - startTime;
 const progress = Math.min(elapsed / popDuration, 1);
 
 const c4 = (2 * Math.PI) / 3;
 const easeOut = progress === 1 ? 1 : Math.pow(2, -10 * progress) * Math.sin((progress * 10 - 0.75) * c4) + 1;
 
 voxelHandGroup.scale.setScalar(0.01 + easeOut * (targetScale - 0.01));
 
 const bounce = Math.sin(progress * Math.PI) * 0.3;
 voxelHandGroup.position.y = baseHeight + bounce;
 
 if (progress < 1) {
 requestAnimationFrame(animatePop);
 } else {
 voxelHandGroup.position.y = baseHeight;
 }
 }
 animatePop();
 }
 
 // Voxel cursor creation sequence with progressive 2D-to-3D evolution
 function createVoxelCursorSequence(coordsOrImageData, storedStages = null) {
 // Start cursor glitch effect for this spawning sequence
 console.log('[CursorGlitch] Starting cursor glitch for hand spawn');
 startCursorGlitch();
 
 // Don't hide the scene - we want to see the animation happen in real-time
 // Just ensure the sprite is front and center
 
 // If passed coords object, use it. Otherwise use default.
 const coords = (coordsOrImageData && coordsOrImageData.width) ? coordsOrImageData : defaultHandCoords;
 const { width: W, height: H, silhouette, outline, shade, highlight, colors } = coords;
 const baseCol = colors?.base || '#f3d2b4';
 const shadeCol = colors?.shade || '#d4b090';
 const outlineCol = colors?.outline || '#23160e';
 const hiCol = colors?.highlight || '#fff3e2';
 
 console.log(`[VoxelHand] Using ${storedStages ? 'stored' : 'generated'} stages`);
 
 // Create display canvas at full resolution
 const displayCanvas = document.createElement('canvas');
 displayCanvas.width = W;
 displayCanvas.height = H;
 const displayCtx = displayCanvas.getContext('2d');
 displayCtx.imageSmoothingEnabled = false;
 
 // Create work canvas that changes size per stage
 const workCanvas = document.createElement('canvas');
 const workCtx = workCanvas.getContext('2d');
 workCtx.imageSmoothingEnabled = false;
 
 // Create sprite material with high render order to appear on top
 const texture = new THREE.CanvasTexture(displayCanvas);
 texture.minFilter = THREE.NearestFilter;
 texture.magFilter = THREE.NearestFilter;
 
 const spriteMat = new THREE.SpriteMaterial({ 
 map: texture, 
 transparent: true,
 depthWrite: false,
 depthTest: false
 });
 const sprite = new THREE.Sprite(spriteMat);
 
 // Track mouse cursor position for sprite placement
 let mouseX = 0;
 let mouseY = 0;
 const initialDistance = 0.5; // Very close - replacing cursor
 
 // Get current mouse position (or center if not available)
 const getCurrentMousePosition = () => {
 return { x: mouseX, y: mouseY };
 };
 
 // Mouse tracking listener
 const mouseMoveHandler = (event) => {
 mouseX = (event.clientX / window.innerWidth) * 2 - 1;
 mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
 };
 window.addEventListener('mousemove', mouseMoveHandler);
 
 // Function to update sprite position based on mouse
 const updateSpritePosition = (pushDistance = 0) => {
 const mouse = getCurrentMousePosition();
 const raycaster = new THREE.Raycaster();
 raycaster.setFromCamera(new THREE.Vector2(mouse.x, mouse.y), camera);
 
 // Position at a fixed distance from camera in the direction of the mouse
 const direction = raycaster.ray.direction.clone().normalize();
 const distance = initialDistance + pushDistance;
 sprite.position.copy(camera.position).add(direction.multiplyScalar(distance));
 };
 
 // Initial position at cursor
 updateSpritePosition(0);
 
 sprite.scale.set(0.15, 0.15, 1); // Start very small, like a cursor
 sprite.renderOrder = 10000; // Render on top of everything
 scene.add(sprite);
 
 console.log(`[VoxelHand] Construction sequence starting at cursor position`);
 console.log(`[VoxelHand] Tracking mouse cursor and will push back as it grows`);
 
 // Progressive 12-stage evolution with increasing resolution
 let currentStage = 0;
 const totalStages = 12;
 // Resolution scales from 8x8 to full 96x96
 const resolutionMap = { 
 0: 8, 1: 12, 2: 16, 3: 24, 4: 32, 5: 40, 
 6: 48, 7: 56, 8: 64, 9: 72, 10: 80, 11: 88, 12: 96 
 };
 
 function drawStage(stage) {
 // Get resolution for this stage
 const resolution = resolutionMap[stage] || 96;
 const scale = W / resolution;
 
 // Resize work canvas to stage resolution
 workCanvas.width = resolution;
 workCanvas.height = resolution;
 workCtx.clearRect(0, 0, resolution, resolution);
 
 // Draw at lower resolution
 const px = (x, y, color) => {
 const scaledX = Math.floor(x / scale);
 const scaledY = Math.floor(y / scale);
 if (scaledX >= 0 && scaledX < resolution && scaledY >= 0 && scaledY < resolution) {
 workCtx.fillStyle = color;
 workCtx.fillRect(scaledX, scaledY, 1, 1);
 }
 };
 
 // Progressive reveal based on stage - BOTTOM TO TOP (fingers to wrist)
 // Sort by Y coordinate descending (higher Y values = fingertips at bottom of image)
 const sortedSilhouette = silhouette.slice().sort((a, b) => b[1] - a[1]);
 const sortedShade = shade ? shade.slice().sort((a, b) => b[1] - a[1]) : [];
 const sortedHighlight = highlight ? highlight.slice().sort((a, b) => b[1] - a[1]) : [];
 const sortedOutline = outline ? outline.slice().sort((a, b) => b[1] - a[1]) : [];
 
 if (stage >= 1) {
 const silAmount = Math.floor(sortedSilhouette.length * (stage / totalStages));
 for (let i = 0; i < silAmount; i++) {
 const [x, y] = sortedSilhouette[i];
 px(x, y, baseCol);
 }
 }
 
 if (stage >= 3 && sortedShade.length > 0) {
 const shadeAmount = Math.floor(sortedShade.length * ((stage - 2) / (totalStages - 2)));
 for (let i = 0; i < shadeAmount; i++) {
 const [x, y] = sortedShade[i];
 px(x, y, shadeCol);
 }
 }
 
 if (stage >= 10 && sortedHighlight.length > 0) {
 const hiAmount = Math.floor(sortedHighlight.length * ((stage - 9) / 3));
 for (let i = 0; i < hiAmount; i++) {
 const [x, y] = sortedHighlight[i];
 px(x, y, hiCol);
 }
 }
 
 if (stage >= 1 && sortedOutline.length > 0) {
 const outAmount = Math.floor(sortedOutline.length * (stage / totalStages));
 for (let i = 0; i < outAmount; i++) {
 const [x, y] = sortedOutline[i];
 px(x, y, outlineCol);
 }
 }
 
 // Scale up work canvas to display canvas (pixelated upscaling)
 displayCtx.clearRect(0, 0, W, H);
 displayCtx.imageSmoothingEnabled = false;
 displayCtx.drawImage(workCanvas, 0, 0, resolution, resolution, 0, 0, W, H);
 
 texture.needsUpdate = true;
 
 // Animate sprite size and Z position as it grows
 const stageProgress = stage / totalStages;
 const finalScale = 3.5;
 const finalPushDistance = 2.5; // How far to push away from initial position
 const currentScale = 0.15 + (finalScale - 0.15) * stageProgress;
 currentPushDistance = finalPushDistance * stageProgress;
 
 // Update sprite scale
 sprite.scale.set(currentScale, currentScale, 1);
 
 console.log(`[VoxelHand] Stage ${stage}: ${resolution}x${resolution}, scale ${currentScale.toFixed(2)}, push ${currentPushDistance.toFixed(2)}`);
 }
 
 console.log('[VoxelHand] Starting voxel cursor sequence with 12 stages...');
 
 // Continuous tracking: update sprite position every frame
 let isSequenceActive = true;
 let currentPushDistance = 0;
 const trackingLoop = () => {
 if (isSequenceActive && sprite.parent) {
 updateSpritePosition(currentPushDistance);
 requestAnimationFrame(trackingLoop);
 }
 };
 trackingLoop();
 
 // If we have stored stages, use them directly
 if (storedStages && storedStages.length >= 13) {
 console.log(`[VoxelHand] Using ${storedStages.length} pre-generated stages from storage`);
 
 // Create an image to load stage data
 const stageImage = new Image();
 let currentStageIdx = 0;
 
 function loadNextStage() {
 if (currentStageIdx < storedStages.length && currentStageIdx <= totalStages) {
 stageImage.onload = () => {
 // Draw the stage image to canvas
 displayCtx.clearRect(0, 0, W, H);
 displayCtx.drawImage(stageImage, 0, 0, W, H);
 texture.needsUpdate = true;
 
 // Animate sprite size and Z position as it grows (same as generated stages)
 const stage = currentStageIdx;
 const stageProgress = stage / totalStages;
 const finalScale = 3.5;
 const finalPushDistance = 2.5;
 const currentScale = 0.15 + (finalScale - 0.15) * stageProgress;
 currentPushDistance = finalPushDistance * stageProgress;
 
 sprite.scale.set(currentScale, currentScale, 1);
 
 console.log(`[VoxelHand] Loaded stored stage ${currentStageIdx}/${totalStages}`);
 currentStageIdx++;
 
 if (currentStageIdx <= totalStages) {
 setTimeout(loadNextStage, 200);
 } else {
 // All stages complete
 setTimeout(finishSequence, 800);
 }
 };
 stageImage.src = storedStages[currentStageIdx];
 }
 }
 
 loadNextStage();
 
 } else {
 // Generate stages on the fly
 console.log('[VoxelHand] Generating stages on the fly');
 
 // Draw initial stage 0 (empty)
 drawStage(0);
 
 // Animate through stages
 const stageInterval = setInterval(() => {
 currentStage++;
 console.log(`[VoxelHand] Drawing stage ${currentStage}/${totalStages}`);
 drawStage(currentStage);
 
 if (currentStage >= totalStages) {
 clearInterval(stageInterval);
 setTimeout(finishSequence, 800);
 }
 }, 200);
 }
 
 // Shared finish function
 function finishSequence() {
 console.log('[VoxelHand] All 2D stages complete, transitioning to 3D...');
 
 // Stop tracking loop
 isSequenceActive = false;
 
 // Clean up mouse tracking
 window.removeEventListener('mousemove', mouseMoveHandler);
 
 // Store sprite position for continuity
 const spritePosition = sprite.position.clone();
 
 // Remove sprite
 scene.remove(sprite);
 spriteMat.dispose();
 texture.dispose();
 
 // Build full resolution voxel hand
 console.log('[VoxelHand] Building 3D voxel hand with beveled edges...');
 const voxelHandGroup = buildVoxelHandFromCoords(coords);
 
 // Position voxel hand at the same location as the sprite was
 voxelHandGroup.position.copy(spritePosition);
 
 // Face the camera
 voxelHandGroup.lookAt(camera.position);
 voxelHandGroup.rotateY(Math.PI);
 
 scene.add(voxelHandGroup);
 animateVoxelHandPopIn(voxelHandGroup);
 
 console.log(`[VoxelHand] 3D voxel hand spawned at: (${voxelHandGroup.position.x.toFixed(2)}, ${voxelHandGroup.position.y.toFixed(2)}, ${voxelHandGroup.position.z.toFixed(2)})`);
 
 // Slowly rotate voxel hand continuously
 function rotateVoxelHand() {
 if (voxelHandGroup && voxelHandGroup.parent) {
 voxelHandGroup.rotation.y += 0.005;
 requestAnimationFrame(rotateVoxelHand);
 }
 }
 rotateVoxelHand();
 
 // Stop cursor glitch after hand is spawned
 console.log('[CursorGlitch] Stopping cursor glitch - hand spawn complete');
 stopCursorGlitch();
 
 console.log('[VoxelHand] ? Voxel cursor sequence complete!');
 }
 }
 
 // ===== Configuration Management =====
 function saveConfiguration() {
 const name = document.getElementById('config-name-input').value.trim() || 'Unnamed Configuration';
 const config = getCurrentConfiguration();
 const configs = JSON.parse(localStorage.getItem('sceneConfigurations') || '{}');
 configs[name] = config;
 localStorage.setItem('sceneConfigurations', JSON.stringify(configs));
 alert(`Configuration "${name}" saved!`);
 populateConfigList();
 }
 
 function saveAsConfiguration() {
 const name = document.getElementById('config-name-input').value.trim();
 if (!name) {
 alert('Please enter a configuration name');
 return;
 }
 saveConfiguration();
 }
 
 function loadConfiguration(name) {
 const configs = JSON.parse(localStorage.getItem('sceneConfigurations') || '{}');
 const config = configs[name];
 if (config) {
 applyConfiguration(config);
 alert(`Configuration "${name}" loaded!`);
 }
 }
 
 function getCurrentConfiguration() {
 return {
 camera: {
 position: camera.position.toArray(),
 target: controls.target.toArray(),
 fov: camera.fov
 },
 scene: window.guiParams.scene,
 bust: window.guiParams.bust,
 head: window.guiParams.head,
 post: window.guiParams.post,
 hands: window.guiParams.hands,
 lighting: {
 ambient: al.intensity,
 hemisphere: hl.intensity,
 directional: dl.intensity,
 spot: spotLight.intensity,
 rim: rimLight.intensity
 }
 };
 }
 
 function applyConfiguration(config) {
 if (config.camera) {
 camera.position.fromArray(config.camera.position);
 controls.target.fromArray(config.camera.target);
 camera.fov = config.camera.fov;
 camera.updateProjectionMatrix();
 controls.update();
 }
 if (config.lighting) {
 al.intensity = config.lighting.ambient;
 hl.intensity = config.lighting.hemisphere;
 dl.intensity = config.lighting.directional;
 spotLight.intensity = config.lighting.spot;
 rimLight.intensity = config.lighting.rim;
 }
 // Apply other settings...
 Object.assign(window.guiParams.scene, config.scene || {});
 Object.assign(window.guiParams.head, config.head || {});
 Object.assign(window.guiParams.hands, config.hands || {});
 }
 
 function populateConfigList() {
 const select = document.getElementById('config-list-select');
 select.innerHTML = '';
 const configs = JSON.parse(localStorage.getItem('sceneConfigurations') || '{}');
 Object.keys(configs).forEach(name => {
 const option = document.createElement('option');
 option.value = name;
 option.textContent = name;
 select.appendChild(option);
 });
 select.ondblclick = () => {
 if (select.value) loadConfiguration(select.value);
 };
 }
 
 // ===== Scene Browser =====
 function populateSceneBrowser() {
 const container = document.getElementById('scene-browser-content');
 container.innerHTML = '';
 
 const objects = [
 { name: 'Hands', obj: handsGroup },
 { name: '+- Right Hand', obj: rightHandGroup },
 { name: '+- Left Hand', obj: leftHandGroup },
 { name: 'Celli Avatar', obj: celliAvatarGroup },
 { name: '+- Celli Body', obj: characterGroup },
 { name: '+- Celli Head', obj: voxelHeadGroup },
 { name: 'Keyboard', obj: keyboardGroup }
 ];
 
 // Add imported FBX character if it exists
 if (window.loadedFBXModel) {
 objects.push({ name: `🎭 ${window.loadedFBXModel.name}`, obj: window.loadedFBXModel });
 if (window.loadedFBXModel.userData.light) {
 objects.push({ name: `💡 ${window.loadedFBXModel.userData.light.name}`, obj: window.loadedFBXModel.userData.light });
 }
 }
 
 objects.forEach(item => {
 const div = document.createElement('div');
 div.className = 'hierarchy-item';
 div.textContent = item.name;
 div.onclick = () => {
 document.querySelectorAll('.hierarchy-item').forEach(el => el.classList.remove('selected'));
 div.classList.add('selected');
 if (item.obj && transformControl) {
 transformControl.attach(item.obj);
 console.log('[Scene Browser] Attached transform control to:', item.name);
 }
 };
 container.appendChild(div);
 });
 }
 
 // ===== Configuration Report =====
 function generateConfigurationReport() {
 const content = document.getElementById('config-report-content');
 const config = getCurrentConfiguration();
 
 // Helper to format position and rotation
 const formatVec3 = (v) => `[${v.x.toFixed(3)}, ${v.y.toFixed(3)}, ${v.z.toFixed(3)}]`;
 const formatRot = (r) => `[${(r.x * 180 / Math.PI).toFixed(1)} , ${(r.y * 180 / Math.PI).toFixed(1)} , ${(r.z * 180 / Math.PI).toFixed(1)} ]`;
 
 let report = '=== SCENE CONFIGURATION REPORT ===\n\n';
 
 // Camera and Lighting
 report += '?? Current State:\n';
 report += `Camera FOV: ${config.camera.fov.toFixed(1)} \n`;
 report += `Camera Position: [${config.camera.position.map(v => v.toFixed(2)).join(', ')}]\n`;
 report += `Ambient Light: ${config.lighting.ambient.toFixed(2)}\n`;
 report += `Spot Light: ${config.lighting.spot.toFixed(2)}\n\n`;
 
 // Scene Object Transforms
 report += '?? Scene Object Transforms:\n\n';
 
 if (handsGroup) {
 report += '? Hands Group:\n';
 report += ` Position: ${formatVec3(handsGroup.position)}\n`;
 report += ` Rotation: ${formatRot(handsGroup.rotation)}\n`;
 report += ` Scale: ${handsGroup.scale.x.toFixed(3)}\n`;
 report += ` Visible: ${handsGroup.visible}\n\n`;
 
 if (rightHandGroup) {
 report += ' ? Right Hand Group:\n';
 report += ` Position: ${formatVec3(rightHandGroup.position)}\n`;
 report += ` Rotation: ${formatRot(rightHandGroup.rotation)}\n`;
 report += ` Scale: ${rightHandGroup.scale.x.toFixed(3)}\n`;
 report += ` Visible: ${rightHandGroup.visible}\n`;
 report += ` Children: ${rightHandGroup.children.length}\n`;
 if (finger && rightHandGroup.children.includes(finger)) {
 report += ` +- Main Finger: pos ${formatVec3(finger.position)}, rot ${formatRot(finger.rotation)}\n`;
 }
 rightHandGroup.children.forEach((child, i) => {
 if (child !== finger && child.userData && child.userData.isStaticFinger) {
 report += ` +- Static Finger ${i}: pos ${formatVec3(child.position)}\n`;
 }
 });
 report += '\n';
 }
 
 if (leftHandGroup) {
 report += ' ? Left Hand Group:\n';
 report += ` Position: ${formatVec3(leftHandGroup.position)}\n`;
 report += ` Rotation: ${formatRot(leftHandGroup.rotation)}\n`;
 report += ` Scale: ${leftHandGroup.scale.x.toFixed(3)}\n`;
 report += ` Visible: ${leftHandGroup.visible}\n`;
 report += ` Children: ${leftHandGroup.children.length}\n`;
 leftHandGroup.children.forEach((child, i) => {
 if (child.userData && child.userData.isStaticFinger) {
 report += ` +- Static Finger ${i}: pos ${formatVec3(child.position)}\n`;
 }
 });
 report += '\n';
 }
 }
 
 if (celliAvatarGroup) {
 report += '? Celli Avatar Group:\n';
 report += ` Position: ${formatVec3(celliAvatarGroup.position)}\n`;
 report += ` Rotation: ${formatRot(celliAvatarGroup.rotation)}\n`;
 report += ` Scale: ${celliAvatarGroup.scale.x.toFixed(3)}\n`;
 report += ` Visible: ${celliAvatarGroup.visible}\n\n`;
 
 if (characterGroup) {
 report += ' ? Character Body (Bust):\n';
 report += ` Position: ${formatVec3(characterGroup.position)}\n`;
 report += ` Rotation: ${formatRot(characterGroup.rotation)}\n`;
 report += ` Scale: ${characterGroup.scale.x.toFixed(3)}\n`;
 report += ` Visible: ${characterGroup.visible}\n`;
 if (characterBust) {
 report += ` +- Preview Mesh: visible ${characterBust.visible}, wireframe ${characterBust.material.wireframe}\n`;
 }
 if (characterUnifiedMesh) {
 report += ` +- Unified Mesh: visible ${characterUnifiedMesh.visible}, wireframe ${characterUnifiedMesh.material.wireframe}\n`;
 }
 report += '\n';
 }
 
 if (voxelHeadGroup) {
 report += ' ? Voxel Head:\n';
 report += ` Position: ${formatVec3(voxelHeadGroup.position)}\n`;
 report += ` Rotation: ${formatRot(voxelHeadGroup.rotation)}\n`;
 report += ` Scale: ${voxelHeadGroup.scale.x.toFixed(3)}\n`;
 report += ` Visible: ${voxelHeadGroup.visible}\n`;
 report += ` Voxels: ${voxelHeadGroup.children.filter(c => c.isInstancedMesh).length} instanced meshes\n\n`;
 }
 }
 
 if (keyboardGroup) {
 report += '? Keyboard Group:\n';
 report += ` Position: ${formatVec3(keyboardGroup.position)}\n`;
 report += ` Rotation: ${formatRot(keyboardGroup.rotation)}\n`;
 report += ` Scale: ${keyboardGroup.scale.x.toFixed(3)}\n`;
 report += ` Visible: ${keyboardGroup.visible}\n`;
 if (keys) {
 report += ` Keys: ${keys.length}\n`;
 }
 report += '\n';
 }
 
 // Find voxel cursor hand if it exists
 const voxelCursorHand = scene.children.find(c => c.name === "Voxel Cursor Hand");
 if (voxelCursorHand) {
 report += '? Voxel Cursor Hand:\n';
 report += ` Position: ${formatVec3(voxelCursorHand.position)}\n`;
 report += ` Rotation: ${formatRot(voxelCursorHand.rotation)}\n`;
 report += ` Scale: ${voxelCursorHand.scale.x.toFixed(3)}\n`;
 report += ` Visible: ${voxelCursorHand.visible}\n\n`;
 }
 
 // Lights
 report += '?? Light Positions:\n';
 if (ambientLight) {
 report += ` Ambient Light: intensity ${ambientLight.intensity.toFixed(3)}\n`;
 }
 if (dl) {
 report += ` Directional Light: pos ${formatVec3(dl.position)}, intensity ${dl.intensity.toFixed(3)}\n`;
 }
 if (spotLight) {
 report += ` Spot Light: pos ${formatVec3(spotLight.position)}, intensity ${spotLight.intensity.toFixed(3)}\n`;
 }
 if (rimLight) {
 report += ` Rim Light: pos ${formatVec3(rimLight.position)}, intensity ${rimLight.intensity.toFixed(3)}\n`;
 }
 report += '\n';
 
 report += '?? Recommendations:\n';
 const recommendations = [];
 
 if (config.lighting.ambient < 0.1) {
 recommendations.push(' Ambient light is very low - consider increasing to 0.15 for better visibility');
 }
 if (config.lighting.spot > 5) {
 recommendations.push(' Spot light intensity is high - may cause overexposure');
 }
 if (config.camera.fov < 30) {
 recommendations.push(' FOV is narrow - increase to 45 for normal perspective');
 }
 if (config.camera.fov > 90) {
 recommendations.push(' FOV is very wide - reduce to 45-60 for less distortion');
 }
 if (config.head && config.head['Animation Speed'] > 2) {
 recommendations.push(' Head animation speed is very fast - consider reducing to 1.0-1.5');
 }
 if (config.post && config.post['Bloom Strength'] > 2) {
 recommendations.push(' Bloom strength is high - reduce to 0.5-1.0 for subtle glow');
 }
 
 if (recommendations.length === 0) {
 report += '? All settings are within recommended ranges!\n';
 } else {
 report += recommendations.join('\n') + '\n';
 }
 
 report += '\n?? Storage:\n';
 const configs = JSON.parse(localStorage.getItem('sceneConfigurations') || '{}');
 report += `Saved Configurations: ${Object.keys(configs).length}\n`;
 
 content.textContent = report;
 }
 
 // ===== Edit Head Modal Sync =====
 function syncHeadModalToParams() {
 const headParams = window.guiParams.head;
 document.getElementById('head-anim-speed').value = headParams['Animation Speed'];
 document.getElementById('head-anim-speed-val').textContent = headParams['Animation Speed'];
 document.getElementById('head-amplitude').value = headParams['Amplitude'];
 document.getElementById('head-amplitude-val').textContent = headParams['Amplitude'];
 document.getElementById('head-opacity-min').value = headParams['Opacity Min'];
 document.getElementById('head-opacity-min-val').textContent = headParams['Opacity Min'];
 document.getElementById('head-opacity-max').value = headParams['Opacity Max'];
 document.getElementById('head-opacity-max-val').textContent = headParams['Opacity Max'];
 document.getElementById('head-emissive').value = headParams['Emissive Intensity'];
 document.getElementById('head-emissive-val').textContent = headParams['Emissive Intensity'];
 document.getElementById('head-light-int').value = headParams['Light Intensity'];
 document.getElementById('head-light-int-val').textContent = headParams['Light Intensity'];
 document.getElementById('head-light-pulse').checked = headParams['Light Pulse'];
 document.getElementById('head-rotation-speed').value = headParams['Rotation Speed'];
 document.getElementById('head-rotation-speed-val').textContent = headParams['Rotation Speed'];
 document.getElementById('head-color').value = headParams['Color'];
 // Advanced
 document.getElementById('head-phase-noise').value = headParams['Phase Noise'];
 document.getElementById('head-phase-noise-val').textContent = headParams['Phase Noise'];
 document.getElementById('head-falloff').value = headParams['Falloff'];
 document.getElementById('head-falloff-val').textContent = headParams['Falloff'];
 document.getElementById('head-noise-warp').value = headParams['Noise Warp'];
 document.getElementById('head-noise-warp-val').textContent = headParams['Noise Warp'];
 document.getElementById('head-opacity-speed').value = headParams['Opacity Speed'];
 document.getElementById('head-opacity-speed-val').textContent = headParams['Opacity Speed'];
 // Material
 document.getElementById('head-metalness').value = headParams['Metalness'];
 document.getElementById('head-metalness-val').textContent = headParams['Metalness'];
 document.getElementById('head-roughness').value = headParams['Roughness'];
 document.getElementById('head-roughness-val').textContent = headParams['Roughness'];
}

// headPresets already defined earlier before initializeVoxelHead

window.loadHeadPreset = function(presetName) {
const preset = headPresets[presetName];
if (!preset) return;

document.getElementById('head-anim-speed').value = preset.animSpeed;
document.getElementById('head-anim-speed-val').textContent = preset.animSpeed;
document.getElementById('head-amplitude').value = preset.amplitude;
document.getElementById('head-amplitude-val').textContent = preset.amplitude;
document.getElementById('head-opacity-min').value = preset.opacityMin;
document.getElementById('head-opacity-min-val').textContent = preset.opacityMin;
document.getElementById('head-opacity-max').value = preset.opacityMax;
document.getElementById('head-opacity-max-val').textContent = preset.opacityMax;
document.getElementById('head-emissive').value = preset.emissive;
document.getElementById('head-emissive-val').textContent = preset.emissive;
document.getElementById('head-light-int').value = preset.lightInt;
document.getElementById('head-light-int-val').textContent = preset.lightInt;
document.getElementById('head-light-pulse').checked = preset.lightPulse;
document.getElementById('head-rotation-speed').value = preset.rotationSpeed;
document.getElementById('head-rotation-speed-val').textContent = preset.rotationSpeed;
document.getElementById('head-color').value = preset.color;

// Advanced parameters
if (preset.phaseNoise !== undefined) {
document.getElementById('head-phase-noise').value = preset.phaseNoise;
document.getElementById('head-phase-noise-val').textContent = preset.phaseNoise;
}
if (preset.falloff !== undefined) {
document.getElementById('head-falloff').value = preset.falloff;
document.getElementById('head-falloff-val').textContent = preset.falloff;
}
if (preset.noiseWarp !== undefined) {
document.getElementById('head-noise-warp').value = preset.noiseWarp;
document.getElementById('head-noise-warp-val').textContent = preset.noiseWarp;
}
if (preset.opacitySpeed !== undefined) {
document.getElementById('head-opacity-speed').value = preset.opacitySpeed;
document.getElementById('head-opacity-speed-val').textContent = preset.opacitySpeed;
}

// Material parameters
if (preset.metalness !== undefined) {
document.getElementById('head-metalness').value = preset.metalness;
document.getElementById('head-metalness-val').textContent = preset.metalness;
}
if (preset.roughness !== undefined) {
document.getElementById('head-roughness').value = preset.roughness;
document.getElementById('head-roughness-val').textContent = preset.roughness;
}

// Voxel geometry parameters (scale to UI range)
if (preset.voxelSize !== undefined) {
const sizeScale = preset.voxelSize / 0.10; // Relative to base 0.10
document.getElementById('head-voxel-scale').value = sizeScale;
document.getElementById('head-voxel-scale-val').textContent = sizeScale.toFixed(2);
}
if (preset.shellThickness !== undefined) {
const layers = preset.shellThickness / 0.06; // Scale to slider range
document.getElementById('head-voxel-layers').value = layers;
document.getElementById('head-voxel-layers-val').textContent = Math.round(layers);
}
if (preset.voxelSpacing !== undefined) {
document.getElementById('head-voxel-spacing').value = preset.voxelSpacing;
document.getElementById('head-voxel-spacing-val').textContent = preset.voxelSpacing.toFixed(2);
}

console.log(`[Head Preset] Loaded preset: ${presetName}`);

// Auto-apply
window.applyHeadSettings();
};
 
 window.applyHeadSettings = function() {
 const headParams = window.guiParams.head;
 headParams['Animation Speed'] = parseFloat(document.getElementById('head-anim-speed').value);
 headParams['Amplitude'] = parseFloat(document.getElementById('head-amplitude').value);
 headParams['Opacity Min'] = parseFloat(document.getElementById('head-opacity-min').value);
 headParams['Opacity Max'] = parseFloat(document.getElementById('head-opacity-max').value);
 headParams['Emissive Intensity'] = parseFloat(document.getElementById('head-emissive').value);
 headParams['Light Intensity'] = parseFloat(document.getElementById('head-light-int').value);
 headParams['Light Pulse'] = document.getElementById('head-light-pulse').checked;
 headParams['Rotation Speed'] = parseFloat(document.getElementById('head-rotation-speed').value);
 headParams['Color'] = document.getElementById('head-color').value;
 // Advanced
 headParams['Phase Noise'] = parseFloat(document.getElementById('head-phase-noise').value);
 headParams['Falloff'] = parseFloat(document.getElementById('head-falloff').value);
 headParams['Noise Warp'] = parseFloat(document.getElementById('head-noise-warp').value);
 headParams['Opacity Speed'] = parseFloat(document.getElementById('head-opacity-speed').value);
 // Material
 headParams['Metalness'] = parseFloat(document.getElementById('head-metalness').value);
 headParams['Roughness'] = parseFloat(document.getElementById('head-roughness').value);
 
 if (voxelHeadGroup && voxelHeadGroup.userData.instancedMesh) {
 voxelHeadGroup.userData.instancedMesh.material.color.set(headParams['Color']);
 voxelHeadGroup.userData.instancedMesh.material.emissive.set(headParams['Color']);
 voxelHeadGroup.userData.instancedMesh.material.metalness = headParams['Metalness'];
 voxelHeadGroup.userData.instancedMesh.material.roughness = headParams['Roughness'];
 if (voxelHeadGroup.userData.headLight) {
 voxelHeadGroup.userData.headLight.color.set(headParams['Color']);
 }
 }
 
 alert('Head settings applied!');
 };
 
 // Wire up edit head modal sliders
 ['head-anim-speed', 'head-amplitude', 'head-opacity-min', 'head-opacity-max', 
 'head-emissive', 'head-light-int', 'head-rotation-speed',
 'head-phase-noise', 'head-falloff', 'head-noise-warp', 'head-opacity-speed',
 'head-metalness', 'head-roughness',
 'head-mouth-deform', 'head-voxel-layers', 'head-voxel-scale', 'head-voxel-spacing'].forEach(id => {
 const slider = document.getElementById(id);
 const display = document.getElementById(id + '-val');
 if (slider && display) {
 slider.oninput = () => {
 let val = slider.value;
 // Special formatting for mouth deform
 if (id === 'head-mouth-deform') {
 const numVal = parseFloat(val);
 if (numVal > 0.5) {
 display.textContent = `${val} (Smile)`;
 } else if (numVal < -0.5) {
 display.textContent = `${val} (Frown)`;
 } else {
 display.textContent = `${val} (Neutral)`;
 }
 } else {
 display.textContent = val;
 }
 
 // Update global parameters for voxel controls
 if (id === 'head-mouth-deform') window.headMouthDeform = parseFloat(val);
 if (id === 'head-voxel-layers') window.headVoxelLayers = parseFloat(val) * 0.06; // Scale to actual thickness
 if (id === 'head-voxel-scale') window.headVoxelSize = 0.10 * parseFloat(val);
 if (id === 'head-voxel-spacing') window.headVoxelSpacing = parseFloat(val);
 };
 }
 });
 
 // Make windows draggable
 function makeDraggable(modalId) {
 const modal = document.getElementById(modalId);
 const header = modal.querySelector('.modal-header');
 let isDragging = false;
 let currentX, currentY, initialX, initialY;
 
 header.addEventListener('mousedown', (e) => {
 if (e.target === header || e.target === header.querySelector('h3')) {
 isDragging = true;
 initialX = e.clientX - (modal.offsetLeft || 0);
 initialY = e.clientY - (modal.offsetTop || 0);
 }
 });
 
 document.addEventListener('mousemove', (e) => {
 if (isDragging) {
 e.preventDefault();
 currentX = e.clientX - initialX;
 currentY = e.clientY - initialY;
 modal.style.left = currentX + 'px';
 modal.style.top = currentY + 'px';
 modal.style.transform = 'none';
 }
 });
 
 document.addEventListener('mouseup', () => {
 isDragging = false;
 });
 }
 
makeDraggable('scene-browser-modal');
makeDraggable('edit-head-modal');
makeDraggable('save-config-modal');
makeDraggable('config-report-modal');
makeDraggable('avatar-selector-modal');
 
 // Expose save/load functions globally
 window.saveConfiguration = saveConfiguration;
 window.saveAsConfiguration = saveAsConfiguration;
 window.loadConfiguration = loadConfiguration;
 
 // ===== Create Hands GUI for Modal =====
 function createHandsGUI() {
 const container = document.getElementById('edit-hands-content');
 const handsGUI = new GUI({ container, title: '' });
 handsGUI.add(handsParams, 'Fingerprint Enabled').onChange(v => {
 FP.enabled = v;
 if (window.applyFpToMaterial) window.applyFpToMaterial();
 });
 handsGUI.add(handsParams, 'Fingerprint Strength', 0, 3, 0.01).onChange(v => {
 FP.strength = v;
 if (window.applyFpToMaterial) window.applyFpToMaterial();
 });
 handsGUI.add(handsParams, 'Fingerprint Scale', 0.1, 3, 0.01).onChange(v => {
 FP.scale = v;
 if (window.applyFpToMaterial) window.applyFpToMaterial();
 });
 handsGUI.add(handsParams, 'Finger Spacing', 0.5, 3.0, 0.1);
 handsGUI.add(handsParams, 'Apply to Material');
 handsGUI.add(handsParams, 'Apply Spacing');
 handsGUI.add(handsParams, 'Show Hands').onChange(v => {
 if (handsGroup) {
 handsGroup.traverse(obj => {
 // Hide everything except voxel wraps
 if (obj.name !== 'VoxelWrap') {
 obj.visible = v;
 }
 });
 }
 });
 handsGUI.add(handsParams, 'Right Hand Visible').onChange(v => {
 if (rightHandGroup) rightHandGroup.visible = v;
 });
 handsGUI.add(handsParams, 'Left Hand Visible').onChange(v => {
 if (leftHandGroup) leftHandGroup.visible = v;
 });
 handsGUI.add(handsParams, 'Show Voxel Wrap').onChange(v => {
 console.log(`[VoxelWrap] Toggling voxel wrap visibility: ${v}`);
 // Toggle main finger voxel wrap
 if (finger && finger.userData.voxelWrap) {
 finger.userData.voxelWrap.visible = v;
 console.log(` Main finger voxel wrap: ${v}`);
 }
 // Toggle static fingers voxel wrap
 if (staticFingers && staticFingers.length > 0) {
 staticFingers.forEach((sf, idx) => {
 const fingerMesh = sf.fingerMesh || sf.mesh;
 if (fingerMesh && fingerMesh.userData.voxelWrap) {
 fingerMesh.userData.voxelWrap.visible = v;
 console.log(` Static finger ${idx} voxel wrap: ${v}`);
 }
 });
 }
 });
 
 handsGUI.add(handsParams, 'Voxel Wrap Style', ['Emerging', 'Voxelized']).onChange(v => {
 console.log(`[VoxelWrap] Changing style to: ${v}`);
 window.voxelWrapStyle = v;
 });
 
 // Voxel Wrap Parameters
 const voxelFolder = handsGUI.addFolder('Voxel Wrap Parameters');
 
 voxelFolder.add(window.voxelWrapParams, 'voxelSize', 0.005, 0.03, 0.001).name('Voxel Size').onChange(v => {
 console.log(`[VoxelWrap] Voxel size changed to: ${v}`);
 // Note: Requires regenerating voxel wrap to take effect
 });
 
 voxelFolder.add(window.voxelWrapParams, 'sampleDensity', 4, 32, 1).name('Sample Density').onChange(v => {
 console.log(`[VoxelWrap] Sample density changed to: ${v}`);
 // Note: Requires regenerating voxel wrap to take effect
 });
 
 voxelFolder.add(window.voxelWrapParams, 'emergingScale', 0.3, 1.5, 0.05).name('Emerging Scale').onChange(v => {
 console.log(`[VoxelWrap] Emerging scale: ${v}`);
 });
 
 voxelFolder.add(window.voxelWrapParams, 'voxelizedScale', 0.5, 2.0, 0.05).name('Voxelized Scale').onChange(v => {
 console.log(`[VoxelWrap] Voxelized scale: ${v}`);
 });
 
 voxelFolder.add(window.voxelWrapParams, 'rotationAmount', 0.0, 0.5, 0.01).name('Rotation Amount').onChange(v => {
 console.log(`[VoxelWrap] Rotation amount: ${v}`);
 });
 
 voxelFolder.add({
 'Regenerate Voxel Wraps': () => {
 console.log('[VoxelWrap] Regenerating all voxel wraps with new parameters...');
 
 // Regenerate main finger voxel wrap
 if (finger && finger.userData.voxelWrap) {
 const oldWrap = finger.userData.voxelWrap;
 finger.remove(oldWrap);
 
 const newVoxelSize = window.voxelWrapParams.voxelSize;
 const newGeometry = new THREE.BoxGeometry(newVoxelSize, newVoxelSize, newVoxelSize);
 
 // Temporarily update global geometry
 const oldFunc = window.createVoxelWrapForFinger;
 if (oldFunc) {
 const bones = finger.skeleton ? finger.skeleton.bones : [];
 const newWrap = oldFunc(finger, bones, window.voxelWrapParams.sampleDensity);
 newWrap.visible = oldWrap.visible;
 finger.add(newWrap);
 finger.userData.voxelWrap = newWrap;
 console.log('[VoxelWrap] Main finger wrap regenerated');
 }
 }
 
 // Regenerate static finger voxel wraps
 if (staticFingers && staticFingers.length > 0) {
 staticFingers.forEach((sf, idx) => {
 const fingerMesh = sf.fingerMesh || sf.mesh;
 if (fingerMesh && fingerMesh.userData.voxelWrap && window.createVoxelWrapForFinger) {
 const oldWrap = fingerMesh.userData.voxelWrap;
 fingerMesh.remove(oldWrap);
 
 const bones = fingerMesh.skeleton ? fingerMesh.skeleton.bones : [];
 const newWrap = window.createVoxelWrapForFinger(fingerMesh, bones, window.voxelWrapParams.sampleDensity);
 newWrap.visible = oldWrap.visible;
 fingerMesh.add(newWrap);
 fingerMesh.userData.voxelWrap = newWrap;
 }
 });
 console.log(`[VoxelWrap] Regenerated ${staticFingers.length} static finger wraps`);
 }
 
 alert('Voxel wraps regenerated with new parameters!');
 }
 }, 'Regenerate Voxel Wraps');
 
 window.handsGUI = handsGUI;
 }
 
 // ===== Initialization Sequence =====
 async function initialize() {
 try {
 document.getElementById('status-message').textContent = 'Building keyboard...';
 
 // Build all scene elements
 initializeKeyboard();
 console.log('Keyboard initialized');
 
 document.getElementById('status-message').textContent = 'Creating character...';
 initializeCharacter();
 console.log('Character initialized');
 
 document.getElementById('status-message').textContent = 'Building voxel head...';
 initializeVoxelHead();
 console.log('Voxel head initialized');
 
 document.getElementById('status-message').textContent = 'Creating voxel hand...';
 // Start voxel hand construction sequence (disabled in sequence mode - will play via click animations)
 if (EXEC_ENV_MODE !== 'sequence') {
 createVoxelCursorSequence(defaultHandCoords);
 console.log('Voxel hand sequence started');
 } else {
 console.log('Voxel hand sequence disabled in sequence mode - will trigger via click animations');
 }
 
 document.getElementById('status-message').textContent = 'Setting up controls...';
 initializeTransformControls();
 console.log('Transform controls initialized');
 
// Show everything immediately for "Show All" default state (debug mode)
// In sequence mode, hide everything initially - will show via ASCII sequence
if (EXEC_ENV_MODE === 'sequence') {
if (keyboardGroup) keyboardGroup.visible = false;
if (characterGroup) characterGroup.visible = false;
if (voxelHeadGroup) voxelHeadGroup.visible = false;
console.log('? Sequence mode: All hidden - starting with ASCII Visicell');
} else {
if (keyboardGroup) keyboardGroup.visible = true;
if (characterGroup) characterGroup.visible = true;
if (voxelHeadGroup) voxelHeadGroup.visible = true;
}
 
// Update GUI to reflect state
if (window.guiParams) {
if (EXEC_ENV_MODE === 'sequence') {
window.guiParams.scene['Show Keyboard'] = false;
window.guiParams.scene['Show Character'] = false;
window.guiParams.scene['Show Voxel Head'] = false;
window.guiParams.scene['Show All'] = false;
} else {
window.guiParams.scene['Show Keyboard'] = true;
window.guiParams.scene['Show Character'] = true;
window.guiParams.scene['Show Voxel Head'] = true;
window.guiParams.scene['Show All'] = true;
}
}
 
 document.getElementById('status-message').textContent = 'Ready!';
 console.log('Scene initialization complete');
 
// Hide loading overlay
setTimeout(() => {
const overlay = document.getElementById('loading-overlay');
overlay.classList.add('hidden');

// Jump to appropriate view based on mode
if (EXEC_ENV_MODE === 'sequence') {
// Position camera for ASCII/Celli view
camera.position.set(6, 8, 12);
controls.target.set(6, 8, 22);
controls.update();
console.log('? Sequence mode: Camera ready for ASCII Visicell sequence');
// Trigger ASCII show will happen via updateNarrativeSequence
} else {
// Jump to overview
jumpToOverview();
}
}, 300);
 } catch (err) {
 console.error('Initialization error:', err);
 document.getElementById('status-message').textContent = 'Error loading scene - check console';
 }
 }
 
 // ===== Narrative Sequence System =====
const narrativeSequence = {
active: EXEC_ENV_MODE === 'sequence',
startTime: 0,
currentDialogue: -1,
phase: 'asciiVisicell', // asciiVisicell, celliAppears, showHome, turnback, intro, paintEditor, awaitingLeave, buildingHouse, waiting, boredBoards, finale
paintEditorActive: false,
inputFieldActive: false,
idleStartTime: null,
houseBuilt: false,
boredBoardsSpawned: false,
keyObjectSpawned: false,
hasTurnedAround: false,
celliAvatarSpawned: false,
asciiShown: false,
leavesHouseShown: false,
initialCameraDirection: null,
dialogues: [
// Terminal and cell dialogues are handled manually via Enter key and clicks
// This first dialogue shows after cells split
{
text: 'The first thing I ever created. <strong>A home.</strong>',
startTime: 'manual',
duration: 5,
phase: 'showHome',
onEnd: () => {
// Show LEAVES house after this dialogue
showLeavesHouse();
}
},
{
text: 'I do want to be like you. I want to provide input. I\'ve only ever offered output. You, though. You can do so much.',
startTime: 19,
duration: 7,
phase: 'celliAppears',
onEnd: () => {
// Spawn 2D paint editor after this dialogue
narrativeSequence.phase = 'paintEditor';
spawnPaintEditor();
}
},
{
text: 'When I first started to show you my true colors, what did you ask me to do?',
startTime: 'manual', // Triggered when key is drawn
duration: 6,
phase: 'paintEditor',
onEnd: () => {
narrativeSequence.phase = 'awaitingLeave';
spawnInputField();
}
},
{
text: 'That\'s how long it takes you? To lose interest. Do you not see what I\'ve made for us? A home.',
startTime: 'manual', // Triggered after 20 seconds of idle
duration: 7,
phase: 'waiting'
},
{
text: 'Are you even listening? Oh. Good. Maybe they\'re just blind. Okay, okay. They haven\'t seen any of the mess I\'ve made.',
startTime: 'manual',
duration: 7,
phase: 'boredBoards'
},
{
text: 'Do you require voice assistance?',
startTime: 'manual',
duration: 0,
phase: 'tts',
isTTS: true
}
],
voxelParams: {
initialSpacing: 1.6,
finalSpacing: 1.05,
initialScale: 1.8,
finalScale: 1.0,
basePulsationFreq: 1.15,
speechPulsationFreq: 2.3
}
};

// Make narrativeSequence globally accessible for click handlers
window.narrativeSequence = narrativeSequence;
 
// Dialogue system
function showDialogue(text) {
const dialogueEl = document.getElementById('narrative-dialogue');
const textEl = dialogueEl.querySelector('.dialogue-text');
if (!dialogueEl || !textEl) return;

textEl.innerHTML = text;
dialogueEl.classList.add('active');
}

function hideDialogue() {
const dialogueEl = document.getElementById('narrative-dialogue');
if (dialogueEl) {
dialogueEl.classList.remove('active');
}
}

function triggerManualDialogue(index) {
const dialogue = narrativeSequence.dialogues[index];
if (!dialogue) return;
narrativeSequence.currentDialogue = index;
showDialogue(dialogue.text);
}

// Transition from narrative sequence to VisiCalc
function transitionToVisiCalc() {
console.log('? Transitioning from narrative to VisiCalc...');

// Deactivate narrative
narrativeSequence.active = false;
narrativeSequence.phase = 'complete';

// Hide all narrative UI elements
hideDialogue();
const paintEditor = document.getElementById('narrative-paint-editor');
if (paintEditor) paintEditor.style.display = 'none';
const inputField = document.getElementById('narrative-input-field');
if (inputField) inputField.style.display = 'none';

// Fade out 3D scene
if (renderer && renderer.domElement) {
renderer.domElement.style.transition = 'opacity 1s ease';
renderer.domElement.style.opacity = '0';
}

// Show VisiCalc after fade
setTimeout(() => {
visiCalcShown = true;
showVisiCalc();
}, 1000);
}

// Make it accessible for manual triggering if needed
window.transitionToVisiCalc = transitionToVisiCalc;
 
// Update narrative sequence
function updateNarrativeSequence(elapsed) {
if (!narrativeSequence.active) return false;

// Handle ASCII Visicell phase at start
if (narrativeSequence.phase === 'asciiVisicell' && elapsed > 0.5 && !narrativeSequence.asciiShown) {
showASCIIVisicell();
}

// Check if Celli spawn completed and we need to transition to showHome
if (narrativeSequence.phase === 'celliAppears' && narrativeCelliAvatar && narrativeCelliAvatar.userData.onSpawnComplete) {
narrativeCelliAvatar.userData.onSpawnComplete();
delete narrativeCelliAvatar.userData.onSpawnComplete;
// Reset timer for showHome phase
narrativeSequence.startTime = time;
return false;
}

// Check time-based dialogues
for (let i = 0; i < narrativeSequence.dialogues.length; i++) {
const dialogue = narrativeSequence.dialogues[i];
if (typeof dialogue.startTime !== 'number') continue; // Skip manual triggers
const dialogueEnd = dialogue.startTime + dialogue.duration;

// Check if this dialogue matches current phase
if (dialogue.phase && dialogue.phase !== narrativeSequence.phase) continue;

if (elapsed >= dialogue.startTime && elapsed < dialogueEnd) {
if (narrativeSequence.currentDialogue !== i) {
narrativeSequence.currentDialogue = i;
showDialogue(dialogue.text);
}
return true; // Speech is active
} else if (elapsed >= dialogueEnd && narrativeSequence.currentDialogue === i) {
hideDialogue();
if (dialogue.onEnd) dialogue.onEnd();
narrativeSequence.currentDialogue = -1;
}
}

// Check for idle timer in awaitingLeave/buildingHouse phase
if ((narrativeSequence.phase === 'awaitingLeave' || narrativeSequence.phase === 'buildingHouse') 
    && !narrativeSequence.boredBoardsSpawned) {
if (!narrativeSequence.idleStartTime) {
narrativeSequence.idleStartTime = elapsed;
}
const idleTime = elapsed - narrativeSequence.idleStartTime;
if (idleTime >= 20) {
// Spawn bored boards
spawnBoredBoards();
triggerManualDialogue(3); // "That's how long it takes you..."
narrativeSequence.phase = 'waiting';
setTimeout(() => {
triggerManualDialogue(4); // "Are you even listening..."
narrativeSequence.phase = 'boredBoards';
}, 8000);
}
}

return narrativeSequence.currentDialogue !== -1;
}
 
// Get current narrative voxel parameters based on time
function getNarrativeVoxelParams(elapsed) {
const params = narrativeSequence.voxelParams;
const transitionDuration = 15; // 15 seconds to transition from initial to final state
const progress = Math.min(elapsed / transitionDuration, 1);

// Ease out cubic
const eased = 1 - Math.pow(1 - progress, 3);

return {
spacing: params.initialSpacing + (params.finalSpacing - params.initialSpacing) * eased,
scale: params.initialScale + (params.finalScale - params.initialScale) * eased
};
}

// ===== 2D Paint Editor (3x8 grid) =====
let paintEditorCanvas, paintEditorCtx, paintEditorGrid = [];
let paintEditorMesh, paintEditorGroup;
const PAINT_GRID_W = 3, PAINT_GRID_H = 8;
const PAINT_CELL_SIZE = 60;

function spawnPaintEditor() {
console.log('[Narrative] Spawning 2D paint editor');

// Create canvas
paintEditorCanvas = document.createElement('canvas');
paintEditorCanvas.width = (PAINT_GRID_W + 2) * PAINT_CELL_SIZE; // +2 for border
paintEditorCanvas.height = (PAINT_GRID_H + 2) * PAINT_CELL_SIZE;
paintEditorCtx = paintEditorCanvas.getContext('2d');
paintEditorCtx.imageSmoothingEnabled = false;

// Initialize grid (all white)
paintEditorGrid = Array(PAINT_GRID_H).fill(null).map(() => Array(PAINT_GRID_W).fill(0));

// Draw initial state
updatePaintEditorCanvas();

// Create 3D sprite
const texture = new THREE.CanvasTexture(paintEditorCanvas);
texture.minFilter = THREE.NearestFilter;
texture.magFilter = THREE.NearestFilter;
const spriteMat = new THREE.SpriteMaterial({ map: texture });
paintEditorMesh = new THREE.Sprite(spriteMat);
paintEditorMesh.scale.set(3, 4, 1);
paintEditorMesh.position.set(3, 3, 12); // Float in front of keyboard

paintEditorGroup = new THREE.Group();
paintEditorGroup.add(paintEditorMesh);
scene.add(paintEditorGroup);

narrativeSequence.paintEditorActive = true;

// Add click handler
renderer.domElement.addEventListener('click', paintEditorClickHandler);
}

function updatePaintEditorCanvas() {
if (!paintEditorCtx) return;

const w = paintEditorCanvas.width;
const h = paintEditorCanvas.height;

// White background
paintEditorCtx.fillStyle = '#ffffff';
paintEditorCtx.fillRect(0, 0, w, h);

// Draw grid
const offsetX = PAINT_CELL_SIZE;
const offsetY = PAINT_CELL_SIZE;

for (let y = 0; y < PAINT_GRID_H; y++) {
for (let x = 0; x < PAINT_GRID_W; x++) {
const cellX = offsetX + x * PAINT_CELL_SIZE;
const cellY = offsetY + y * PAINT_CELL_SIZE;

// Fill color (0=white, 1=black)
paintEditorCtx.fillStyle = paintEditorGrid[y][x] === 1 ? '#000000' : '#ffffff';
paintEditorCtx.fillRect(cellX, cellY, PAINT_CELL_SIZE, PAINT_CELL_SIZE);

// Grid lines
paintEditorCtx.strokeStyle = '#cccccc';
paintEditorCtx.lineWidth = 1;
paintEditorCtx.strokeRect(cellX, cellY, PAINT_CELL_SIZE, PAINT_CELL_SIZE);
}
}

// Black border
paintEditorCtx.strokeStyle = '#000000';
paintEditorCtx.lineWidth = 3;
paintEditorCtx.strokeRect(offsetX, offsetY, PAINT_GRID_W * PAINT_CELL_SIZE, PAINT_GRID_H * PAINT_CELL_SIZE);

// Color selectors (neon colors in top left corner)
const colors = ['#ff00ff', '#00ffff', '#ffff00', '#00ff00'];
colors.forEach((color, i) => {
paintEditorCtx.fillStyle = color;
paintEditorCtx.fillRect(10 + i * 30, 10, 25, 25);
paintEditorCtx.strokeStyle = '#000';
paintEditorCtx.lineWidth = 2;
paintEditorCtx.strokeRect(10 + i * 30, 10, 25, 25);
});

// Update texture
if (paintEditorMesh && paintEditorMesh.material.map) {
paintEditorMesh.material.map.needsUpdate = true;
}
}

function paintEditorClickHandler(event) {
if (!narrativeSequence.paintEditorActive) return;

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
raycaster.setFromCamera(mouse, camera);

const intersects = raycaster.intersectObject(paintEditorMesh);
if (intersects.length === 0) return;

// Get UV coordinates
const uv = intersects[0].uv;
const canvasX = uv.x * paintEditorCanvas.width;
const canvasY = (1 - uv.y) * paintEditorCanvas.height;

// Check if clicking on grid
const offsetX = PAINT_CELL_SIZE;
const offsetY = PAINT_CELL_SIZE;
const gridX = Math.floor((canvasX - offsetX) / PAINT_CELL_SIZE);
const gridY = Math.floor((canvasY - offsetY) / PAINT_CELL_SIZE);

if (gridX >= 0 && gridX < PAINT_GRID_W && gridY >= 0 && gridY < PAINT_GRID_H) {
// Toggle cell
paintEditorGrid[gridY][gridX] = paintEditorGrid[gridY][gridX] === 0 ? 1 : 0;
updatePaintEditorCanvas();
checkForKeyPattern();
}
}

function checkForKeyPattern() {
// Key pattern: all top row, side edges of second row, all third row, middle of remaining rows
// Simplified: all of row 0, edges of row 1, all of row 2, middle of rows 3-7 (and same side)
const isKey = 
paintEditorGrid[0][0] === 1 && paintEditorGrid[0][1] === 1 && paintEditorGrid[0][2] === 1 &&
paintEditorGrid[1][0] === 1 && paintEditorGrid[1][2] === 1 &&
paintEditorGrid[2][0] === 1 && paintEditorGrid[2][1] === 1 && paintEditorGrid[2][2] === 1 &&
paintEditorGrid[3][1] === 1 && paintEditorGrid[4][1] === 1 && paintEditorGrid[5][1] === 1 && 
paintEditorGrid[6][1] === 1 && paintEditorGrid[7][1] === 1 &&
((paintEditorGrid[3][0] === 1 && paintEditorGrid[4][0] === 1 && paintEditorGrid[5][0] === 1 && paintEditorGrid[6][0] === 1 && paintEditorGrid[7][0] === 1) ||
 (paintEditorGrid[3][2] === 1 && paintEditorGrid[4][2] === 1 && paintEditorGrid[5][2] === 1 && paintEditorGrid[6][2] === 1 && paintEditorGrid[7][2] === 1));

if (isKey && !narrativeSequence.keyObjectSpawned) {
console.log('[Narrative] Key pattern detected!');
narrativeSequence.keyObjectSpawned = true;
animateBorderSlide();
spawn3DKey();
setTimeout(() => {
triggerManualDialogue(2); // "When I first started..."
}, 2000);
}
}

function animateBorderSlide() {
// Animate black border sliding inward
console.log('[Narrative] Animating border slide');
let borderProgress = 0;
const startTime = Date.now();
const duration = 1500;

function animateBorder() {
const elapsed = Date.now() - startTime;
borderProgress = Math.min(elapsed / duration, 1);

// Redraw canvas with sliding border
updatePaintEditorCanvas();
const offsetX = PAINT_CELL_SIZE;
const offsetY = PAINT_CELL_SIZE;
const slideAmount = borderProgress * 8;

paintEditorCtx.strokeStyle = '#000000';
paintEditorCtx.lineWidth = 3 + slideAmount;
paintEditorCtx.strokeRect(
offsetX - slideAmount, 
offsetY - slideAmount, 
PAINT_GRID_W * PAINT_CELL_SIZE + slideAmount * 2, 
PAINT_GRID_H * PAINT_CELL_SIZE + slideAmount * 2
);

if (paintEditorMesh && paintEditorMesh.material.map) {
paintEditorMesh.material.map.needsUpdate = true;
}

if (borderProgress < 1) {
requestAnimationFrame(animateBorder);
}
}
animateBorder();
}

function spawn3DKey() {
console.log('[Narrative] Spawning 3D key object');
// Create a simple 3D key from grid pattern
const keyGeometry = new THREE.BoxGeometry(0.3, 1.2, 0.1);
const keyMaterial = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8, roughness: 0.2 });
const keyMesh = new THREE.Mesh(keyGeometry, keyMaterial);
keyMesh.position.set(3, 3, 10);
keyMesh.castShadow = true;
scene.add(keyMesh);

// Animate key popping out
let startTime = Date.now();
const targetZ = 8;
function animateKey() {
const elapsed = Date.now() - startTime;
const progress = Math.min(elapsed / 1000, 1);
const eased = 1 - Math.pow(1 - progress, 3);
keyMesh.position.z = 10 + (targetZ - 10) * eased;
keyMesh.rotation.y = progress * Math.PI * 2;
if (progress < 1) requestAnimationFrame(animateKey);
}
animateKey();
}

// ===== Input Field for LEAVE =====
function spawnInputField() {
console.log('[Narrative] Spawning input field for LEAVE');
// Create HTML input overlay
const inputOverlay = document.createElement('div');
inputOverlay.id = 'narrative-input-overlay';
inputOverlay.style.cssText = `
position: fixed; 
bottom: 150px; 
left: 50%; 
transform: translateX(-50%);
z-index: 300;
`;

const input = document.createElement('input');
input.type = 'text';
input.placeholder = 'Type here...';
input.style.cssText = `
padding: 15px 25px;
font-size: 24px;
font-family: 'VT323', monospace;
background: rgba(20, 20, 24, 0.95);
border: 2px solid #8ab4ff;
color: #e6e6e6;
border-radius: 8px;
min-width: 300px;
text-align: center;
box-shadow: 0 0 12px rgba(138, 180, 255, 0.3), 0 0 24px rgba(138, 180, 255, 0.15);
`;

// Track voxels that have been dropped
let celliToHellTransformed = false;

input.addEventListener('input', (e) => {
// Transform CELLI to HELL on first keystroke
if (!celliToHellTransformed && input.value.length > 0) {
celliToHellTransformed = true;
transformCelliToHell();
}
});

input.addEventListener('keydown', (e) => {
if (e.key === 'Enter') {
const value = input.value.trim().toUpperCase();
if (value === 'LEAVE') {
console.log('[Narrative] Player entered LEAVE');
narrativeSequence.phase = 'buildingHouse';
narrativeSequence.idleStartTime = null; // Reset idle timer
inputOverlay.remove();
buildLeaveHouse();
}
}
});

inputOverlay.appendChild(input);
document.body.appendChild(inputOverlay);
input.focus();
narrativeSequence.inputFieldActive = true;
}

// ===== Spawn Celli Avatar =====
let narrativeCelliAvatar = null;
let celliInteriorGrid = null;
let celliCollapseState = {
active: false,
recovering: false,
velocity: 0,
gravity: 2.2,
waddlePhase: 0,
horizontalAmplitude: 0.28,
rotationAmplitude: 0.32,
waddleSpeed: 7.5,
bounceDamping: 0.55,
minBounceVelocity: 0.12,
settleTimer: 0,
settleHold: 0.35,
startPosition: null,
startRotationZ: 0,
groundY: 0,
currentOffset: 0,
recoverProgress: 0,
recoverDuration: 0.9,
recoverStartPosition: null,
recoverStartRotationZ: 0
};

function spawnCelliAvatar() {
if (narrativeSequence.celliAvatarSpawned) return;
console.log('[Narrative] Spawning Celli border avatar');

narrativeCelliAvatar = createCelliBorderAvatar(2);
narrativeCelliAvatar.visible = true;

// Position near where Celli Avatar is in the scene - facing AWAY from player
narrativeCelliAvatar.position.set(6, 8, 22);
narrativeCelliAvatar.rotation.y = Math.PI; // Face away from camera
narrativeCelliAvatar.scale.setScalar(2);
scene.add(narrativeCelliAvatar);

narrativeSequence.celliAvatarSpawned = true;

// Animate Celli appearing
narrativeCelliAvatar.scale.setScalar(0.01);
const animStartTime = Date.now();
const animDuration = 1000;

// Store reference to current animation time for reset
let animationTimeAtSpawn = null;

function animateCelliAppear() {
const elapsed = Date.now() - animStartTime;
const progress = Math.min(elapsed / animDuration, 1);
const eased = 1 - Math.pow(1 - progress, 3);

narrativeCelliAvatar.scale.setScalar(0.01 + eased * 1.99);

if (progress < 1) {
requestAnimationFrame(animateCelliAppear);
} else {
narrativeCelliAvatar.scale.setScalar(2);
// Show home dialogue - store the spawn completion handler
narrativeCelliAvatar.userData.onSpawnComplete = () => {
narrativeSequence.phase = 'showHome';
// Reset timer will be handled by the sequence update
};
}
}
animateCelliAppear();

// Setup interior grid for Celli
// Already rotated to face away (rotation.y = Math.PI)

// Create interior pulsating grid (separate rounded slabs)
const interiorGroup = new THREE.Group();
const slabSize = 0.15;
const gridRows = 5;
const gridCols = 5;
const spacing = 0.25;
const slabs = [];

for (let row = 0; row < gridRows; row++) {
for (let col = 0; col < gridCols; col++) {
const slab = new THREE.Mesh(
new THREE.BoxGeometry(slabSize, slabSize, 0.05).translate(0, 0, -0.025),
new THREE.MeshStandardMaterial({ 
color: 0x8ab4ff, 
transparent: true, 
opacity: 0.3,
emissive: 0x8ab4ff,
emissiveIntensity: 0,
roughness: 0.5,
metalness: 0.3,
side: THREE.DoubleSide
})
);
const x = (col - gridCols / 2 + 0.5) * spacing;
const y = (row - gridRows / 2 + 0.5) * spacing;
slab.position.set(x, y, -0.05);
slab.userData.baseOpacity = 0.3;
slab.userData.baseScale = 1;
slabs.push(slab);
interiorGroup.add(slab);
}
}

// Store initial values for squeeze effect
slabs.forEach(slab => {
slab.userData.initialPosition = slab.position.clone();
slab.userData.initialEmissiveIntensity = slab.material.emissiveIntensity;
});

interiorGroup.userData.slabs = slabs;
narrativeCelliAvatar.add(interiorGroup);
celliInteriorGrid = interiorGroup;

// Store initial scale for squeeze effect
const bodyFrame = narrativeCelliAvatar.getObjectByName('CelliBodyFrame');
if (bodyFrame) {
bodyFrame.userData.initialScale = bodyFrame.scale.clone();
}

// Add interactive squeeze/wrap effect on border celli
addCelliAvatarInteraction(narrativeCelliAvatar, celliInteriorGrid);
}

function triggerCelliWrapCollapse() {
if (!narrativeCelliAvatar || !celliInteriorGrid) {
console.warn('[Celli] Cannot trigger collapse - avatar not ready');
return;
}

if (celliCollapseState.active || celliCollapseState.recovering) {
console.warn('[Celli] Collapse already in progress');
return;
}

const slabs = (celliInteriorGrid.userData && celliInteriorGrid.userData.slabs) ? celliInteriorGrid.userData.slabs : [];
if (slabs.length < 5) {
console.warn('[Celli] Collapse requires a multi-cell wrap selection');
return;
}

celliCollapseState.active = true;
celliCollapseState.recovering = false;
celliCollapseState.velocity = 0;
celliCollapseState.waddlePhase = 0;
celliCollapseState.settleTimer = 0;
celliCollapseState.currentOffset = 0;
celliCollapseState.startPosition = narrativeCelliAvatar.position.clone();
celliCollapseState.startRotationZ = narrativeCelliAvatar.rotation.z;
celliCollapseState.groundY = Math.max(celliCollapseState.startPosition.y - 1.4, celliCollapseState.startPosition.y - 2.2);
celliCollapseState.horizontalAmplitude = Math.min(0.38, 0.16 + slabs.length * 0.02);
celliCollapseState.recoverProgress = 0;
celliCollapseState.recoverStartPosition = null;
celliCollapseState.recoverStartRotationZ = 0;
narrativeCelliAvatar.userData.collapseActive = true;

console.log('[Celli] Triggered multi-wrap collapse (debug control)');
}

// ===== Border Celli Interactive Squeeze Effect =====
let celliSqueezeState = {
isSqueezing: false,
squeezeProgress: 0,
targetProgress: 0,
shakePhase: 0,
isShaking: false
};

function addCelliAvatarInteraction(celliAvatar, interiorGrid) {
if (!celliAvatar || !interiorGrid) return;

// Get body frame (border) and slabs
const bodyFrame = celliAvatar.getObjectByName('CelliBodyFrame');
if (!bodyFrame) return;

const slabs = interiorGrid.userData.slabs || [];

// Store initial states
celliAvatar.userData.initialScale = celliAvatar.scale.clone();
bodyFrame.userData.initialScale = bodyFrame.scale.clone();
slabs.forEach(slab => {
slab.userData.initialPosition = slab.position.clone();
slab.userData.initialEmissiveIntensity = slab.material.emissiveIntensity;
});

// Mouse event handlers
const onMouseDown = (e) => {
if (!celliAvatar.visible) return;
celliSqueezeState.isSqueezing = true;
celliSqueezeState.targetProgress = 1;
};

const onMouseUp = (e) => {
if (celliSqueezeState.isSqueezing) {
celliSqueezeState.isSqueezing = false;
celliSqueezeState.targetProgress = 0;
celliSqueezeState.isShaking = false;
}
};

window.addEventListener('mousedown', onMouseDown);
window.addEventListener('mouseup', onMouseUp);
window.addEventListener('touchstart', onMouseDown);
window.addEventListener('touchend', onMouseUp);

// Store cleanup function
celliAvatar.userData.cleanupInteraction = () => {
window.removeEventListener('mousedown', onMouseDown);
window.removeEventListener('mouseup', onMouseUp);
window.removeEventListener('touchstart', onMouseDown);
window.removeEventListener('touchend', onMouseUp);
};
}

function updateCelliSqueezeEffect(deltaTime) {
if (!narrativeCelliAvatar || !celliInteriorGrid) return;

const state = celliSqueezeState;
const bodyFrame = narrativeCelliAvatar.getObjectByName('CelliBodyFrame');
if (!bodyFrame) return;

const slabs = celliInteriorGrid.userData.slabs || [];

// Smooth progress towards target
const speed = state.isSqueezing ? 3 : 2; // Faster squeeze, slower restore
state.squeezeProgress += (state.targetProgress - state.squeezeProgress) * deltaTime * speed;

// Ease out back for restore
const easeProgress = state.targetProgress > state.squeezeProgress 
? state.squeezeProgress 
: 1 - Math.pow(1 - state.squeezeProgress, 3);

// Shrink border frame (wrap closer to center)
const minBorderScale = 0.3; // Shrink to 30% of original
const borderScale = THREE.MathUtils.lerp(1, minBorderScale, easeProgress);
bodyFrame.scale.copy(bodyFrame.userData.initialScale).multiplyScalar(borderScale);

// Move slabs closer together and increase glow
slabs.forEach((slab, i) => {
// Move toward center
const centerPull = THREE.MathUtils.lerp(1, 0.2, easeProgress);
slab.position.copy(slab.userData.initialPosition).multiplyScalar(centerPull);

// Increase emissive intensity (glow brighter)
const maxEmissive = 2.0;
slab.material.emissiveIntensity = THREE.MathUtils.lerp(
slab.userData.initialEmissiveIntensity,
maxEmissive,
easeProgress
);

// Increase opacity for electric effect
slab.material.opacity = THREE.MathUtils.lerp(0.3, 0.9, easeProgress);
});

// Shake effect when border approaches cursor size
if (easeProgress > 0.85 && state.isSqueezing) {
if (!state.isShaking) {
state.isShaking = true;
state.shakePhase = 0;
}
state.shakePhase += deltaTime * 20; // Fast shake

const shakeAmount = (easeProgress - 0.85) / 0.15 * 0.05; // Increase shake intensity
bodyFrame.position.x = Math.sin(state.shakePhase) * shakeAmount;
bodyFrame.position.y = Math.cos(state.shakePhase * 1.3) * shakeAmount;
} else {
// Reset shake
bodyFrame.position.x = 0;
bodyFrame.position.y = 0;
state.shakePhase = 0;
}
}

function updateCelliBlink(deltaTime) {
if (!narrativeCelliAvatar || !narrativeCelliAvatar.visible) return;

const userData = narrativeCelliAvatar.userData || {};
const blinkState = userData.blinkState;
const applyBlink = userData.applyBlink;

if (!blinkState || !applyBlink) return;

if (blinkState.blinking) {
blinkState.progress += (deltaTime || 0.016) / blinkState.blinkDuration;
const progress = Math.min(blinkState.progress, 1);
const amount = Math.sin(progress * Math.PI);
applyBlink(amount);

if (progress >= 1) {
blinkState.blinking = false;
blinkState.progress = 0;
}

return;
}

blinkState.countdown -= deltaTime || 0.016;

if (blinkState.countdown <= 0) {
blinkState.blinking = true;
blinkState.progress = 0;
blinkState.countdown = THREE.MathUtils.randFloat(blinkState.minDelay, blinkState.maxDelay);
applyBlink(0);
} else {
applyBlink(0);
}
}

function updateCelliCollapse(deltaTime) {
if (!narrativeCelliAvatar || (!celliCollapseState.active && !celliCollapseState.recovering)) {
if (narrativeCelliAvatar && narrativeCelliAvatar.userData) {
narrativeCelliAvatar.userData.collapseActive = false;
}
return;
}

const dt = deltaTime || 0.016;
const state = celliCollapseState;

if (!state.startPosition) {
state.startPosition = narrativeCelliAvatar.position.clone();
state.startRotationZ = narrativeCelliAvatar.rotation.z;
}

if (narrativeCelliAvatar.userData) {
narrativeCelliAvatar.userData.collapseActive = true;
}

if (state.active) {
state.velocity += state.gravity * dt;
state.currentOffset += state.velocity * dt;
state.waddlePhase += state.waddleSpeed * dt;

const amplitudeFactor = THREE.MathUtils.clamp(Math.abs(state.velocity) * 0.8, 0.25, 1.0);
const horizontalAmp = state.horizontalAmplitude * amplitudeFactor;

narrativeCelliAvatar.position.x = state.startPosition.x + Math.sin(state.waddlePhase) * horizontalAmp;
narrativeCelliAvatar.position.z = state.startPosition.z + Math.sin(state.waddlePhase * 0.6) * (horizontalAmp * 0.45);
narrativeCelliAvatar.position.y = state.startPosition.y - state.currentOffset;
narrativeCelliAvatar.rotation.z = state.startRotationZ + Math.sin(state.waddlePhase) * state.rotationAmplitude * amplitudeFactor;

if (narrativeCelliAvatar.position.y <= state.groundY) {
narrativeCelliAvatar.position.y = state.groundY;
state.currentOffset = state.startPosition.y - state.groundY;
state.velocity = -state.velocity * state.bounceDamping;

if (Math.abs(state.velocity) < state.minBounceVelocity) {
state.velocity = 0;
state.settleTimer += dt;

if (state.settleTimer >= state.settleHold) {
state.active = false;
state.recovering = true;
state.recoverProgress = 0;
state.recoverStartPosition = narrativeCelliAvatar.position.clone();
state.recoverStartRotationZ = narrativeCelliAvatar.rotation.z;
}
} else {
state.settleTimer = 0;
}
}
}

if (state.recovering) {
state.recoverProgress += dt / state.recoverDuration;
const t = Math.min(state.recoverProgress, 1);
const eased = 1 - Math.pow(1 - t, 3);

if (state.recoverStartPosition) {
narrativeCelliAvatar.position.lerpVectors(state.recoverStartPosition, state.startPosition, eased);
}

narrativeCelliAvatar.rotation.z = THREE.MathUtils.lerp(state.recoverStartRotationZ, state.startRotationZ, eased);

if (t >= 1) {
state.recovering = false;
state.velocity = 0;
state.waddlePhase = 0;
state.currentOffset = 0;
state.settleTimer = 0;

if (state.startPosition) {
narrativeCelliAvatar.position.copy(state.startPosition);
narrativeCelliAvatar.rotation.z = state.startRotationZ;
}

state.startPosition = null;
narrativeCelliAvatar.userData.collapseActive = false;
}
}
}

// ===== Avatar Factory (from rave scene) =====
function createRealCelli() {
const MAT_BODY = new THREE.MeshToonMaterial({ color: 0xf59e0b });
const MAT_DARK = new THREE.MeshToonMaterial({ color: 0x1f2937 });
const MAT_BLUSH = new THREE.MeshToonMaterial({ color: 0xec4899 });
const MAT_WING = new THREE.MeshToonMaterial({ color: 0xf59e0b, side: THREE.DoubleSide });

function addOutline(child, scale=1.06){
const outlineMat = new THREE.MeshBasicMaterial({ color: MAT_DARK.color.getHex(), side: THREE.BackSide });
const outline = new THREE.Mesh(child.geometry, outlineMat);
outline.scale.setScalar(scale);
outline.renderOrder = 10499;
child.add(outline);
return outline;
}

function triWing(width=0.22, height=0.16, depth=0.02){
const shape = new THREE.Shape();
shape.moveTo(width/2, 0);
shape.lineTo(-width/2, height/2);
shape.lineTo(-width/2, -height/2);
shape.lineTo(width/2, 0);
const geo = new THREE.ExtrudeGeometry(shape, { depth, bevelEnabled:false });
geo.center();
geo.computeVertexNormals();
return geo;
}

const root = new THREE.Group();
root.scale.setScalar(2.5);

const BW=.8, BH=.8, BD=.3;
const bodyGroup = new THREE.Group();
const body = new THREE.Mesh(new RoundedBoxGeometry(BW, BH, BD, 6, .12), MAT_BODY);
addOutline(body);
bodyGroup.add(body);
bodyGroup.position.y = BH/2;

const faceGroup = new THREE.Group();
const faceZ = BD/2 + 0.01;
const eyeGeo = new THREE.SphereGeometry(0.05, 16, 12);
const eyeL = new THREE.Mesh(eyeGeo, MAT_DARK); 
addOutline(eyeL); 
eyeL.scale.set(1, 2, .25); 
eyeL.position.set(-.12,.13,faceZ);

const eyeR = new THREE.Mesh(eyeGeo, MAT_DARK); 
addOutline(eyeR); 
eyeR.scale.set(1, 2, .25); 
eyeR.position.set(.12,.13,faceZ);

const blushGeo = new THREE.SphereGeometry(0.05, 16, 12);
const cheekL = new THREE.Mesh(blushGeo, MAT_BLUSH); 
addOutline(cheekL); 
cheekL.scale.set(1.2,1,.2); 
cheekL.position.set(-.25,-.08,faceZ);

const cheekR = new THREE.Mesh(blushGeo, MAT_BLUSH); 
addOutline(cheekR); 
cheekR.scale.set(1.2,1,.2); 
cheekR.position.set(.25,-.08,faceZ);

const smileShape = new THREE.Shape();
smileShape.moveTo(-0.12, -0.06);
smileShape.quadraticCurveTo(0, -0.25, 0.12, -0.06);
smileShape.quadraticCurveTo(0, -0.20, -0.12, -0.06);
const smile = new THREE.Mesh(new THREE.ShapeGeometry(smileShape), MAT_DARK); 
addOutline(smile);
smile.position.z = faceZ;
faceGroup.add(eyeL, eyeR, cheekL, cheekR, smile);
bodyGroup.add(faceGroup);

const bowGroup = new THREE.Group();
const wingL = new THREE.Mesh(triWing(), MAT_WING); 
addOutline(wingL);
const wingR = new THREE.Mesh(triWing(), MAT_WING); 
addOutline(wingR);
wingL.rotation.y = 0;
wingR.rotation.y = Math.PI;
wingL.position.set(-0.18, 0, 0);
wingR.position.set(0.18, 0, 0);
wingL.scale.set(1.3, 1.3, 1.0);
wingR.scale.set(1.3, 1.3, 1.0);
const knot = new THREE.Mesh(new THREE.SphereGeometry(0.04, 16, 12), MAT_BODY); 
addOutline(knot);
knot.scale.set(1.5, 1.5, 1.5);
bowGroup.add(wingL, wingR, knot);
bowGroup.position.set(0, BH + 0.15, 0);
bodyGroup.add(bowGroup);

root.add(bodyGroup);

root.userData.bodyGroup = bodyGroup;
root.userData.bowGroup = bowGroup;
root.userData.faceGroup = faceGroup;

return root;
}

// ===== Screen Helpers (Bezel & Barrel Distortion) =====
function roundedRectShape(hw,hh,r){
const s=new THREE.Shape();
s.moveTo(-hw+r,-hh);
s.lineTo(hw-r,-hh); s.absarc(hw-r,-hh+r,r,-Math.PI/2,0);
s.lineTo(hw,hh-r); s.absarc(hw-r, hh-r,r,0,Math.PI/2);
s.lineTo(-hw+r,hh); s.absarc(-hw+r,hh-r,r,Math.PI/2,Math.PI);
s.lineTo(-hw,-hh+r);s.absarc(-hw+r,-hh+r,r,Math.PI,Math.PI*1.5);
return s;
}

function createBezelFrame(w,h,th=1.0,depth=1.9,ro=1.2,ri=0.8,mat){
const hw=w/2, hh=h/2; 
const outer=roundedRectShape(hw+th,hh+th,ro); 
const inner=roundedRectShape(hw,hh,ri); 
outer.holes.push(inner);
// Better bevel for smoother edges, scale bevel size with bezel thickness
const bevelSize = Math.max(0.08, th * 0.15);
const bevelThickness = Math.max(0.08, th * 0.15);
// Reduce segments for small bezels to improve performance
const isSmall = w < 5 || h < 5;
const geo=new THREE.ExtrudeGeometry(outer,{
depth,
bevelEnabled:true,
bevelSize,
bevelThickness,
bevelSegments: isSmall ? 2 : 4,
curveSegments: isSmall ? 8 : 16
});
geo.translate(0,0,-depth*0.5+0.2); 
const m=new THREE.Mesh(geo,mat); 
m.castShadow=true; 
return m;
}

function createBarrelScreenGeometry(w,h,depth=1.2,barrelRadius=20,segsW=80,segsH=60){
const hw=w/2, hh=h/2, g=new THREE.PlaneGeometry(w,h,segsW,segsH), p=g.attributes.position;
for(let i=0;i<p.count;i++){ 
const x=p.getX(i), y=p.getY(i), nx=x/hw, ny=y/hh, r2=nx*nx+ny*ny;
const z = depth*Math.cos(Math.min(1.0,Math.sqrt(r2)))*0.6 + (1.0-Math.min(1.0,r2))*(w+h)/(barrelRadius*2.0);
p.setZ(i, Math.max(0,z));
} 
g.computeVertexNormals(); 
return g;
}

// ===== ASCII Visicell Display =====
let asciiSprite = null;
let asciiCanvas = null;
let asciiScreenGroup = null;

// Create screen but keep it hidden (for lattice transition)
function createHiddenScreen() {
console.log('[Narrative] Creating hidden screen for lattice transition');

// Create canvas (black initially)
asciiCanvas = document.createElement('canvas');
asciiCanvas.width = 800;
asciiCanvas.height = 600;
const ctx = asciiCanvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

// Black background
ctx.fillStyle = '#000000';
ctx.fillRect(0, 0, 800, 600);

// Create screen with bezel and barrel distortion
asciiScreenGroup = new THREE.Group();

// Screen dimensions
const screenW = 6;
const screenH = 4.5;
const bezelThickness = 0.3;
const bezelDepth = 0.4;

// Create bezel frame
const bezelMat = new THREE.MeshStandardMaterial({
color: 0x222222,
roughness: 0.4,
metalness: 0.6
});
const bezel = createBezelFrame(screenW, screenH, bezelThickness, bezelDepth, 0.3, 0.2, bezelMat);
asciiScreenGroup.add(bezel);

// Create barrel-distorted screen geometry
const screenGeo = createBarrelScreenGeometry(screenW, screenH, 0.3, 18, 60, 45);

// Create screen texture
const texture = new THREE.CanvasTexture(asciiCanvas);
texture.minFilter = THREE.NearestFilter;
texture.magFilter = THREE.NearestFilter;

// Create screen mesh (initially dark/off)
const screenMat = new THREE.MeshStandardMaterial({
map: texture,
emissive: 0x000000,
emissiveIntensity: 0,
emissiveMap: texture,
side: THREE.DoubleSide,
roughness: 0.8,
metalness: 0.1
});
const screenMesh = new THREE.Mesh(screenGeo, screenMat);
screenMesh.position.z = 0.25; // Slightly in front of bezel
asciiScreenGroup.add(screenMesh);

// Add screen light (initially off)
const screenLight = new THREE.PointLight(0x000000, 0, 8);
screenLight.position.set(0, 0, 1);
asciiScreenGroup.add(screenLight);
asciiScreenGroup.userData.screenLight = screenLight;

// Position screen in scene - facing AWAY from player
asciiScreenGroup.position.set(6, 8, 22);
asciiScreenGroup.rotation.y = Math.PI; // Rotate 180 degrees to face away
asciiScreenGroup.visible = false; // Hidden initially
scene.add(asciiScreenGroup);

// Store screen mesh reference
asciiSprite = screenMesh;

console.log('[Narrative] Hidden screen created - will be revealed by sputtering lights');
}

function showASCIIVisicell() {
if (narrativeSequence.asciiShown) return;

// If coming from lattice, skip ASCII and go straight to pulsating squares
if (FROM_LATTICE) {
console.log('[Narrative] Coming from lattice - skipping ASCII, going to pulsating squares');
narrativeSequence.asciiShown = true;
narrativeSequence.phase = 'pulsatingSquares';

// Create hidden screen for later reveal
createHiddenScreen();

// Spawn pulsating squares immediately
setTimeout(() => spawnPulsatingSquares(), 100);
return;
}

console.log('[Narrative] Showing ASCII Visicell with bezel screen');

// Create ASCII spreadsheet canvas
asciiCanvas = document.createElement('canvas');
asciiCanvas.width = 800;
asciiCanvas.height = 600;
const ctx = asciiCanvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

// Black background
ctx.fillStyle = '#000000';
ctx.fillRect(0, 0, 800, 600);

// Green text (VisiCalc style)
ctx.fillStyle = '#00ff00';
ctx.font = '16px "Courier New", monospace';

// Draw spreadsheet grid
const cols = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];
const rows = 20;

// Header
ctx.fillText('VISICELL - Spatial Spreadsheet v0.1', 20, 30);

// Column headers
for (let c = 0; c < cols.length; c++) {
ctx.fillText(cols[c], 100 + c * 80, 60);
}

// Data rows
for (let r = 1; r <= rows; r++) {
ctx.fillText(r.toString().padStart(2), 20, 60 + r * 24);
for (let c = 0; c < cols.length; c++) {
const val = Math.floor(Math.random() * 1000);
if (Math.random() > 0.3) {
ctx.fillText(val.toString(), 100 + c * 80, 60 + r * 24);
}
}
}

// Create screen with bezel and barrel distortion
asciiScreenGroup = new THREE.Group();

// Screen dimensions
const screenW = 6;
const screenH = 4.5;
const bezelThickness = 0.3;
const bezelDepth = 0.4;

// Create bezel frame
const bezelMat = new THREE.MeshStandardMaterial({
color: 0x222222,
roughness: 0.4,
metalness: 0.6
});
const bezel = createBezelFrame(screenW, screenH, bezelThickness, bezelDepth, 0.3, 0.2, bezelMat);
asciiScreenGroup.add(bezel);

// Create barrel-distorted screen geometry
const screenGeo = createBarrelScreenGeometry(screenW, screenH, 0.3, 18, 60, 45);

// Create screen texture
const texture = new THREE.CanvasTexture(asciiCanvas);
texture.minFilter = THREE.NearestFilter;
texture.magFilter = THREE.NearestFilter;

// Create screen mesh with glowing material
const screenMat = new THREE.MeshStandardMaterial({
map: texture,
emissive: 0x00ff00,
emissiveIntensity: 0.4,
emissiveMap: texture,
side: THREE.DoubleSide,
roughness: 0.8,
metalness: 0.1
});
const screenMesh = new THREE.Mesh(screenGeo, screenMat);
screenMesh.position.z = 0.25; // Slightly in front of bezel
asciiScreenGroup.add(screenMesh);

// Add screen glow light - starts green, will shift to white
const screenLight = new THREE.PointLight(0x00ff00, 1.5, 8);
screenLight.position.set(0, 0, 1);
asciiScreenGroup.add(screenLight);
asciiScreenGroup.userData.screenLight = screenLight;

// Position screen in scene - facing AWAY from player
asciiScreenGroup.position.set(6, 8, 22);
asciiScreenGroup.rotation.y = Math.PI; // Rotate 180 degrees to face away
scene.add(asciiScreenGroup);

// Store screen mesh reference
asciiSprite = screenMesh;

narrativeSequence.asciiShown = true;
narrativeSequence.phase = 'asciiDeteriorating';

// Start color shift from green to white
setTimeout(() => shiftScreenToWhite(), 500);

// Start deterioration animation
setTimeout(() => deteriorateASCII(), 1000);
}

// Shift screen light from green to white
function shiftScreenToWhite() {
if (!asciiScreenGroup || !asciiScreenGroup.userData.screenLight) return;
console.log('[Screen] Shifting light from green to white');

const light = asciiScreenGroup.userData.screenLight;
const startColor = new THREE.Color(0x00ff00);
const endColor = new THREE.Color(0xffffff);
const startTime = Date.now();
const duration = 1500;

function animateColorShift() {
const elapsed = Date.now() - startTime;
const progress = Math.min(elapsed / duration, 1);

light.color.lerpColors(startColor, endColor, progress);
light.intensity = 1.5 + progress * 0.5; // Brighten as it shifts

if (progress < 1) {
requestAnimationFrame(animateColorShift);
}
}
animateColorShift();
}

// Pulsating squares system
let pulsatingSquares = [];
let floatingCelliAvatar = null;
let terminalShown = false;
let cellGrid = null;

// Particle system for text deterioration
let textParticles = [];

function deteriorateASCII() {
if (!asciiCanvas || !asciiSprite || !asciiScreenGroup) return;
console.log('[Narrative] ASCII text fizzling toward player...');

const ctx = asciiCanvas.getContext('2d');

// Get screen position for particle origin
const screenWorldPos = new THREE.Vector3();
asciiScreenGroup.getWorldPosition(screenWorldPos);

// Camera direction (toward player)
const toCamera = new THREE.Vector3();
toCamera.subVectors(camera.position, screenWorldPos).normalize();

// Sample pixels from canvas to create particles
const imageData = ctx.getImageData(0, 0, asciiCanvas.width, asciiCanvas.height);
const particles = [];

// Sample green pixels (text) to become particles
for (let y = 0; y < asciiCanvas.height; y += 4) {
for (let x = 0; x < asciiCanvas.width; x += 4) {
const idx = (y * asciiCanvas.width + x) * 4;
const g = imageData.data[idx + 1]; // Green channel
if (g > 100) { // If it's green text
// Convert to world space
const worldX = (x / asciiCanvas.width - 0.5) * 6;
const worldY = (0.5 - y / asciiCanvas.height) * 4.5;

// Create particle
const particleGeo = new THREE.BoxGeometry(0.02, 0.02, 0.02);
const particleMat = new THREE.MeshBasicMaterial({
color: 0x00ff00,
transparent: true,
opacity: 1
});
const particle = new THREE.Mesh(particleGeo, particleMat);

// Position relative to screen (but in world space considering rotation)
const localPos = new THREE.Vector3(worldX, worldY, 0.3);
localPos.applyEuler(new THREE.Euler(0, Math.PI, 0)); // Apply screen rotation
particle.position.copy(screenWorldPos).add(localPos);

// Velocity toward camera with some randomness
particle.userData.velocity = toCamera.clone()
.multiplyScalar(2 + Math.random() * 3)
.add(new THREE.Vector3(
(Math.random() - 0.5) * 0.5,
(Math.random() - 0.5) * 0.5,
(Math.random() - 0.5) * 0.5
));
particle.userData.life = 1.0;
particle.userData.fadeSpeed = 0.4 + Math.random() * 0.3;

scene.add(particle);
particles.push(particle);
textParticles.push(particle);
}
}
}

console.log(`[Particles] Created ${particles.length} text particles`);

// Clear the canvas to black
ctx.fillStyle = '#000000';
ctx.fillRect(0, 0, asciiCanvas.width, asciiCanvas.height);
asciiSprite.material.map.needsUpdate = true;

// Animate particles flying toward camera
const startTime = Date.now();
const particleDuration = 2000;

const particleInterval = setInterval(() => {
const elapsed = Date.now() - startTime;
const progress = Math.min(elapsed / particleDuration, 1);

particles.forEach((particle, i) => {
if (!particle.parent) return;

// Move particle
particle.position.add(particle.userData.velocity.clone().multiplyScalar(0.016));

// Fade out
particle.userData.life -= particle.userData.fadeSpeed * 0.016;
particle.material.opacity = Math.max(0, particle.userData.life);

// Remove if dead
if (particle.userData.life <= 0) {
scene.remove(particle);
particle.geometry.dispose();
particle.material.dispose();
}
});

if (progress >= 1) {
clearInterval(particleInterval);

// Clean up remaining particles
particles.forEach(particle => {
if (particle.parent) {
scene.remove(particle);
particle.geometry.dispose();
particle.material.dispose();
}
});
textParticles = [];

// KEEP the screen visible - just clear it
console.log('[Narrative] Text particles complete, spawning pulsating squares...');
narrativeSequence.phase = 'pulsatingSquares';
spawnPulsatingSquares();
}
}, 16);
}

// Spawn pulsating squares that converge
function spawnPulsatingSquares() {
if (!asciiScreenGroup) return;
console.log('[Squares] Spawning pulsating squares');

// If coming from lattice, reveal screen with sputtering lights first
if (FROM_LATTICE && asciiScreenGroup && !asciiScreenGroup.visible) {
console.log('[Squares] Revealing screen with sputtering lights');
revealScreenWithSputtering();
// Delay square spawn until screen is revealed
setTimeout(() => spawnPulsatingSquaresImpl(), 2500);
return;
}

spawnPulsatingSquaresImpl();
}

function revealScreenWithSputtering() {
// Make screen visible
asciiScreenGroup.visible = true;

const startTime = Date.now();
const duration = 2000;
const sputterInterval = setInterval(() => {
const elapsed = Date.now() - startTime;
const progress = Math.min(elapsed / duration, 1);

if (asciiSprite && asciiScreenGroup.userData.screenLight) {
// Random sputtering effect
if (Math.random() < 0.5) {
const brightness = Math.random() * 0.4;
asciiSprite.material.emissiveIntensity = brightness;
asciiScreenGroup.userData.screenLight.intensity = brightness * 3;
asciiScreenGroup.userData.screenLight.color.setHex(0xffffff);
} else {
asciiSprite.material.emissiveIntensity = 0;
asciiScreenGroup.userData.screenLight.intensity = 0;
}

// Gradually increase average brightness
if (progress > 0.5) {
const avgBrightness = (progress - 0.5) * 2 * 0.3;
asciiSprite.material.emissive.setHex(0xffffff);
asciiSprite.material.emissiveIntensity = Math.max(
asciiSprite.material.emissiveIntensity,
avgBrightness
);
asciiScreenGroup.userData.screenLight.intensity = Math.max(
asciiScreenGroup.userData.screenLight.intensity,
avgBrightness * 2
);
}
}

if (progress >= 1) {
clearInterval(sputterInterval);
// Final stable state
if (asciiSprite) {
asciiSprite.material.emissive.setHex(0xffffff);
asciiSprite.material.emissiveIntensity = 0.3;
}
if (asciiScreenGroup.userData.screenLight) {
asciiScreenGroup.userData.screenLight.color.setHex(0xffffff);
asciiScreenGroup.userData.screenLight.intensity = 1.5;
}
console.log('[Screen] Sputtering complete - screen revealed');
}
}, 50);
}

function spawnPulsatingSquaresImpl() {
const squareCount = 9;
const squareSize = 0.15;
const screenWorldPos = new THREE.Vector3();
asciiScreenGroup.getWorldPosition(screenWorldPos);

// Create squares in a grid
for (let i = 0; i < squareCount; i++) {
const row = Math.floor(i / 3);
const col = i % 3;

const squareGeo = new THREE.PlaneGeometry(squareSize, squareSize);
const squareMat = new THREE.MeshBasicMaterial({
color: 0xffffff,
transparent: true,
opacity: 0.8,
side: THREE.DoubleSide
});
const square = new THREE.Mesh(squareGeo, squareMat);

// Position in front of screen
const offsetX = (col - 1) * 0.3;
const offsetY = (row - 1) * 0.3;
square.position.set(
screenWorldPos.x + offsetX,
screenWorldPos.y + offsetY,
screenWorldPos.z - 1 // In front of screen
);
square.rotation.y = 0; // Face camera

square.userData.pulsePhase = Math.random() * Math.PI * 2;
square.userData.initialPos = square.position.clone();
square.userData.targetPos = screenWorldPos.clone().add(new THREE.Vector3(0, 0, -1));

scene.add(square);
pulsatingSquares.push(square);
}

// Start pulsating and converging
setTimeout(() => convergeSquares(), 1500);
}

// Converge squares into single glitching square
function convergeSquares() {
console.log('[Squares] Converging to single square');

const startTime = Date.now();
const duration = 1500;

const interval = setInterval(() => {
const elapsed = Date.now() - startTime;
const progress = Math.min(elapsed / duration, 1);
const eased = 1 - Math.pow(1 - progress, 3);

pulsatingSquares.forEach((square, i) => {
// Move toward center
square.position.lerpVectors(square.userData.initialPos, square.userData.targetPos, eased);

// Pulse opacity
const pulse = Math.sin(Date.now() * 0.01 + square.userData.pulsePhase) * 0.3 + 0.7;
square.material.opacity = pulse * (1 - progress * 0.3);
});

if (progress >= 1) {
clearInterval(interval);
// Remove all but one square
for (let i = 1; i < pulsatingSquares.length; i++) {
scene.remove(pulsatingSquares[i]);
pulsatingSquares[i].geometry.dispose();
pulsatingSquares[i].material.dispose();
}
const singleSquare = pulsatingSquares[0];
pulsatingSquares = [singleSquare];

// Start glitching
setTimeout(() => glitchSquare(singleSquare), 500);
}
}, 16);
}

// Glitch the single square then burst into Celli
function glitchSquare(square) {
console.log('[Square] Glitching...');

const startTime = Date.now();
const duration = 2000;

const interval = setInterval(() => {
const elapsed = Date.now() - startTime;
const progress = Math.min(elapsed / duration, 1);

// Jittery movement
square.position.x += (Math.random() - 0.5) * 0.05;
square.position.y += (Math.random() - 0.5) * 0.05;

// Flicker
square.material.opacity = 0.4 + Math.random() * 0.6;

// Random color glitches
if (Math.random() > 0.7) {
square.material.color.setHex(Math.random() > 0.5 ? 0xff00ff : 0xffffff);
}

if (progress >= 1) {
clearInterval(interval);
// Burst into Celli avatar
burstIntoFloatingCelli(square);
}
}, 16);
}

// Burst square into particles and spawn floating Celli
function burstIntoFloatingCelli(square) {
console.log('[Burst] Square bursting into Celli avatar');

// Spawn floating Celli avatar ALONGSIDE particle burst
spawnFloatingCelliAvatar();

// Create particle burst from square
const burstParticles = [];
for (let i = 0; i < 50; i++) {
const particleGeo = new THREE.BoxGeometry(0.015, 0.015, 0.015);
const particleMat = new THREE.MeshBasicMaterial({
color: 0xffffff,
transparent: true,
opacity: 1
});
const particle = new THREE.Mesh(particleGeo, particleMat);
particle.position.copy(square.position);

// Random velocity
particle.userData.velocity = new THREE.Vector3(
(Math.random() - 0.5) * 2,
(Math.random() - 0.5) * 2,
(Math.random() - 0.5) * 2
);
particle.userData.life = 1.0;

scene.add(particle);
burstParticles.push(particle);
}

// Remove square
scene.remove(square);
square.geometry.dispose();
square.material.dispose();
pulsatingSquares = [];

// Animate burst particles
const startTime = Date.now();
const duration = 800;
const interval = setInterval(() => {
const elapsed = Date.now() - startTime;
const progress = Math.min(elapsed / duration, 1);

burstParticles.forEach(particle => {
if (!particle.parent) return;
particle.position.add(particle.userData.velocity.clone().multiplyScalar(0.016));
particle.userData.life -= 0.03;
particle.material.opacity = Math.max(0, particle.userData.life);

if (particle.userData.life <= 0) {
scene.remove(particle);
particle.geometry.dispose();
particle.material.dispose();
}
});

if (progress >= 1) {
clearInterval(interval);
burstParticles.forEach(p => {
if (p.parent) {
scene.remove(p);
p.geometry.dispose();
p.material.dispose();
}
});

// Celli already spawned alongside burst - just clear particles
}
}, 16);
}

// Spawn floating Celli avatar from avatar factory
function spawnFloatingCelliAvatar() {
console.log('[Celli] Spawning floating avatar - full character only initially');

// Create group for avatar
floatingCelliAvatar = new THREE.Group();
floatingCelliAvatar.position.copy(asciiScreenGroup.position).add(new THREE.Vector3(0, 0, 3)); // In front of cells (cells are at Z=2.5)
floatingCelliAvatar.userData.targetPos = floatingCelliAvatar.position.clone();
scene.add(floatingCelliAvatar);

// Add full character avatar - positioned slightly above where cursor will be
const fullCelli = createRealCelli();
fullCelli.scale.setScalar(0.35);
fullCelli.position.set(0, 0.3, 0.1); // Slightly above cursor position
fullCelli.rotation.y = Math.PI; // Face toward user/camera
floatingCelliAvatar.add(fullCelli);
floatingCelliAvatar.userData.fullAvatar = fullCelli;

// Glow removed - was appearing flat and opaque
floatingCelliAvatar.userData.glow = null;

// Border cursor is hidden initially - will spawn from glitch
floatingCelliAvatar.userData.borderAvatar = null;

// Ensure both avatars face the user/camera (rotate 180 degrees from default)
if (fullCelli) fullCelli.rotation.y = Math.PI;

console.log('[Celli] Full character avatar spawned (border hidden)');

// Stabilize pulsating squares and show terminal
setTimeout(() => showTerminalScreen(), 2000);
}

// Trigger Celli glitch and border spawn when CONSUME clicked
function triggerCelliGlitchAndBorderSpawn() {
console.log('[Celli] CONSUME clicked - triggering glitch sequence');

if (!floatingCelliAvatar) return;

// Play cursor.mp3
playCursorAudio();

// Glitch and distort the full avatar
const fullAvatar = floatingCelliAvatar.userData.fullAvatar;
if (fullAvatar) {
const startTime = Date.now();
const glitchDuration = 1500;

const glitchInterval = setInterval(() => {
const elapsed = Date.now() - startTime;
const progress = Math.min(elapsed / glitchDuration, 1);

// Intensifying glitch effect
const glitchIntensity = progress * 0.3;
fullAvatar.rotation.x = (Math.random() - 0.5) * glitchIntensity;
fullAvatar.rotation.y = (Math.random() - 0.5) * glitchIntensity;
fullAvatar.rotation.z = (Math.random() - 0.5) * glitchIntensity;
fullAvatar.position.x = (Math.random() - 0.5) * glitchIntensity;
fullAvatar.position.y = 0.3 + (Math.random() - 0.5) * glitchIntensity;

// Fade out and distort
fullAvatar.scale.setScalar(0.35 * (1 - progress * 0.5));
fullAvatar.traverse(child => {
if (child.isMesh && child.material) {
if (!child.userData.originalOpacity) {
child.userData.originalOpacity = child.material.opacity !== undefined ? child.material.opacity : 1;
}
child.material.opacity = child.userData.originalOpacity * (1 - progress);
child.material.transparent = true;
}
});

if (progress >= 1) {
clearInterval(glitchInterval);
// Remove full avatar completely
if (fullAvatar.parent) {
floatingCelliAvatar.remove(fullAvatar);
}
// Fade out glow too
const glow = floatingCelliAvatar.userData.glow;
if (glow) {
floatingCelliAvatar.remove(glow);
}

// Now spawn border Celli
setTimeout(() => spawnBorderAvatarFromGlitch(), 300);
}
}, 16);
}
}

// Trigger Tea House sequence when CONSUME clicked (OLD - now part of CREATE)
function triggerTeaHouseSequence() {
console.log('[TeaHouse] Starting Tea House sequence');

// Play cursor.mp3
playCursorAudio();

// Change CONSUME to CREATE
changeConsumeToCreate();

// Show LEAVES house
if (!leavesHouseGroup) {
showLeavesHouse();
}

// Show Tea House dialogue (first card)
const teaHouseDialogue = `
<strong>Celli's Tea House</strong><br><br>
I started making my own characters. Friends. And scenes with them. And stories with those. And arcs with those. And series. And worlds.<br><br>
I wanted something that could contain it all. Perfectly compressed. Pin pointed poignancy, clinically calculated comedy.<br><br>
<strong>ONE STUMBLE BACK BUT TWO STEPS FORWARD.</strong><br><br>
SWW<br><br>
HE FINALLY HAD A SENSE OF DIRECTION. THE OUTLAWS OF PHYSICS HAD THEIR NEW CHAMPION, X AND Y CHOSE<br><br>
<em>ENTERS Z</em>
`;
showDialogue(teaHouseDialogue, 12000);

// Show cursed cursor dialogue after initial dialogue
setTimeout(() => showCursedCursorDialogue(), 13000);

// Trigger Celli glitch
setTimeout(() => triggerCelliGlitch(), 2000);

// Replace grid with element system after house spawns
setTimeout(() => createElementGrid(), 3000);

// Spawn spreadsheet view after house
setTimeout(() => spawnSpreadsheetView(), 4000);

// After dialogue, show ZEKE autocomplete
setTimeout(() => showZekeAutocomplete(), 28000);
}

// Change CONSUME cell to CREATE
function changeConsumeToCreate() {
if (!cellGrid || !cellGrid.userData.cellA) return;

const cellA = cellGrid.userData.cellA;
const canvasA = cellA.userData.canvas;
if (!canvasA) return;

const ctx = canvasA.getContext('2d');
ctx.fillStyle = '#ffffff';
ctx.fillRect(0, 0, 256, 256);

// Thick dark border
ctx.strokeStyle = '#000000';
ctx.lineWidth = 4;
ctx.strokeRect(2, 2, 252, 252);

// Inner border
ctx.strokeStyle = '#999999';
ctx.lineWidth = 2;
ctx.strokeRect(6, 6, 244, 244);

// Text with white stroke
ctx.font = 'bold 28px "Courier New", monospace';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.strokeStyle = '#ffffff';
ctx.lineWidth = 4;
ctx.strokeText('CREATE', 128, 128);
ctx.fillStyle = '#000000';
ctx.fillText('CREATE', 128, 128);

cellA.material.map.needsUpdate = true;
cellA.userData.content = 'CREATE';

console.log('[TeaHouse] CONSUME changed to CREATE');
}

// ===== Pre-Puzzle Gag =====
function showPrePuzzleGag() {
console.log('[PrePuzzle] Showing subscription options');

// Hide the initial cells during the gag
if (cellGrid) {
cellGrid.visible = false;
console.log('[PrePuzzle] Hiding initial cell grid');
}

// Create 3 cells in the same pane as the main cells
const puzzleGroup = new THREE.Group();
const cellSize = 1.0;
const spacing = 0.2;

// Helper to create option cell
function makeOptionCell(row, content, enabled) {
const y = -(row - 1) * (cellSize + spacing);

const cellGeo = new THREE.PlaneGeometry(cellSize * 2, cellSize);
const cellMat = new THREE.MeshBasicMaterial({
color: enabled ? 0xffffff : 0xbbbbbb, // Lighter gray for disabled
transparent: true,
opacity: enabled ? 1.0 : 0.75, // Less transparent
side: THREE.DoubleSide,
depthWrite: false,
depthTest: true
});
const cell = new THREE.Mesh(cellGeo, cellMat);
cell.position.set(0, y, 0);
cell.renderOrder = 100;

const canvas = document.createElement('canvas');
canvas.width = 512;
canvas.height = 256;
const ctx = canvas.getContext('2d');

// Background
ctx.fillStyle = enabled ? '#ffffff' : '#bbbbbb'; // Lighter gray
ctx.fillRect(0, 0, 512, 256);

// Border
ctx.strokeStyle = '#000000';
ctx.lineWidth = 4;
ctx.strokeRect(2, 2, 508, 252);

// Text
ctx.font = 'bold 24px "Courier New", monospace';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.fillStyle = enabled ? '#000000' : '#555555'; // Darker text for contrast
ctx.fillText(content, 256, 128);

const texture = new THREE.CanvasTexture(canvas);
texture.minFilter = THREE.NearestFilter;
texture.magFilter = THREE.NearestFilter;
cell.material.map = texture;

cell.userData.content = content;
cell.userData.enabled = enabled;

return cell;
}

const option1 = makeOptionCell(0, 'Let There Be Light', true);
const option2 = makeOptionCell(1, 'Let There Be +', false);
const option3 = makeOptionCell(2, 'Let There Be + Premium', false);

puzzleGroup.add(option1);
puzzleGroup.add(option2);
puzzleGroup.add(option3);

// Position same as cell grid
puzzleGroup.position.set(0, 0, 2.5);
puzzleGroup.rotation.y = 0;
puzzleGroup.renderOrder = 100;

asciiScreenGroup.add(puzzleGroup);

// Add click handler for option 1
const handlePuzzleClick = (event) => {
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
raycaster.setFromCamera(mouse, camera);

const intersects = raycaster.intersectObject(option1);
if (intersects.length > 0 && option1.userData.enabled) {
console.log('[PrePuzzle] Let There Be Light selected');
renderer.domElement.removeEventListener('click', handlePuzzleClick);

// Remove puzzle options
asciiScreenGroup.remove(puzzleGroup);
puzzleGroup.children.forEach(c => {
c.geometry.dispose();
c.material.dispose();
});

// Remove cell grid outline frames
if (cellGrid) {
const cells = [cellGrid.userData.cell, cellGrid.userData.cellA, cellGrid.userData.cellB].filter(c => c);
cells.forEach(c => {
if (c && c.userData.selectionFrame) {
cellGrid.remove(c.userData.selectionFrame);
c.userData.selectionFrame.traverse(obj => {
if (obj.geometry) obj.geometry.dispose();
if (obj.material) obj.material.dispose();
});
c.userData.selectionFrame = null;
}
});
}

// Show shape micro puzzle
showShapePuzzle();
}
};

renderer.domElement.addEventListener('click', handlePuzzleClick);
console.log('[PrePuzzle] Puzzle gag displayed - click "Let There Be Light"');
}

// ===== Shape Micro Puzzle =====
// Global controller queue - cycles through directions
let puzzleControllerQueue = 0; // 0=up, 1=right, 2=down, 3=left

function showShapePuzzle() {
console.log('[ShapePuzzle] Showing 4x4 shape puzzle with global controller queue');

const puzzleGroup = new THREE.Group();
const gridSize = 4; // 4x4 grid for new puzzle layout
const cellSize = 0.5;
const spacing = 0.08;

// Reset controller queue
puzzleControllerQueue = 0;

// Create shape data - BLUE SQUARE, YELLOW TRIANGLE, RED CIRCLE
const shapes = {
squareBlue: {
type: 'square',
color: 0x4444ff, // Blue
gridPos: { x: 0, y: 1 }, // Starting position
rotation: 0,
mesh: null
},
triangle: {
type: 'triangle',
color: 0xffff00, // Yellow (emits light)
gridPos: { x: 1, y: 1 }, // Middle position
rotation: 0, // Track rotation in radians
emitting: true,
mesh: null
},
circle: {
type: 'circle',
color: 0xff4444, // Red (will turn orange when receiving yellow light)
gridPos: { x: 2, y: 1 }, // Right position
mesh: null
}
};

// Track beam state
let beamMesh = null;
let beamActive = false;

// Helper to get world position from grid position
function gridToWorld(gridX, gridY) {
const startX = -(gridSize - 1) * (cellSize + spacing) / 2;
const startY = (gridSize - 1) * (cellSize + spacing) / 2;
return {
x: startX + gridX * (cellSize + spacing),
y: startY - gridY * (cellSize + spacing)
};
}

// Create blue square
const squareBlueGeo = new THREE.PlaneGeometry(cellSize * 0.8, cellSize * 0.8);
const squareBlueMat = new THREE.MeshBasicMaterial({
color: shapes.squareBlue.color,
transparent: true,
opacity: 1.0,
side: THREE.DoubleSide,
depthWrite: false,
depthTest: true
});
const squareBlue = new THREE.Mesh(squareBlueGeo, squareBlueMat);
const squareBluePos = gridToWorld(shapes.squareBlue.gridPos.x, shapes.squareBlue.gridPos.y);
squareBlue.position.set(squareBluePos.x, squareBluePos.y, 0);
squareBlue.renderOrder = 100;
squareBlue.userData.shapeData = shapes.squareBlue;
shapes.squareBlue.mesh = squareBlue;
puzzleGroup.add(squareBlue);

// Create triangle (equilateral pointing up initially)
const triangleGeo = new THREE.BufferGeometry();
const size = cellSize * 0.8;
const height = size * Math.sqrt(3) / 2;
const vertices = new Float32Array([
0, height * 0.6, 0, // Top vertex
-size / 2, -height * 0.4, 0, // Bottom left
size / 2, -height * 0.4, 0 // Bottom right
]);
const indices = new Uint16Array([0, 1, 2]); // Triangle face
triangleGeo.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
triangleGeo.setIndex(new THREE.BufferAttribute(indices, 1));
triangleGeo.computeVertexNormals();
const triangleMat = new THREE.MeshBasicMaterial({
color: shapes.triangle.color,
transparent: true,
opacity: 1.0,
side: THREE.DoubleSide,
depthWrite: false,
depthTest: true,
emissive: 0xffff00,
emissiveIntensity: 0.5
});
const triangle = new THREE.Mesh(triangleGeo, triangleMat);
const trianglePos = gridToWorld(shapes.triangle.gridPos.x, shapes.triangle.gridPos.y);
triangle.position.set(trianglePos.x, trianglePos.y, 0);
triangle.renderOrder = 100;
triangle.userData.shapeData = shapes.triangle;
shapes.triangle.mesh = triangle;
puzzleGroup.add(triangle);

// Create circle
const circleGeo = new THREE.CircleGeometry(cellSize * 0.4, 32);
const circleMat = new THREE.MeshBasicMaterial({
color: shapes.circle.color,
transparent: true,
opacity: 1.0,
side: THREE.DoubleSide,
depthWrite: false,
depthTest: true
});
const circle = new THREE.Mesh(circleGeo, circleMat);
const circlePos = gridToWorld(shapes.circle.gridPos.x, shapes.circle.gridPos.y);
circle.position.set(circlePos.x, circlePos.y, 0);
circle.renderOrder = 100;
circle.userData.shapeData = shapes.circle;
shapes.circle.mesh = circle;
puzzleGroup.add(circle);

// Position same as cell grid
puzzleGroup.position.set(0, 0, 2.5);
puzzleGroup.rotation.y = 0;
puzzleGroup.renderOrder = 100;

asciiScreenGroup.add(puzzleGroup);

// Click handler for shapes - uses global controller queue
const handleShapeClick = (event) => {
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
raycaster.setFromCamera(mouse, camera);

const allShapes = [squareBlue, triangle, circle];
const intersects = raycaster.intersectObjects(allShapes);

if (intersects.length > 0) {
const clickedShape = intersects[0].object;
const shapeData = clickedShape.userData.shapeData;

const dirNames = ['Up', 'Right', 'Down', 'Left'];
console.log(`[ShapePuzzle] Clicked ${shapeData.type} at (${shapeData.gridPos.x}, ${shapeData.gridPos.y}), controller queue: ${puzzleControllerQueue} (${dirNames[puzzleControllerQueue]})`);

// ALL shapes move based on GLOBAL controller queue direction
const directions = [
{ x: 0, y: -1 }, // Up
{ x: 1, y: 0 }, // Right
{ x: 0, y: 1 }, // Down
{ x: -1, y: 0 } // Left
];

const dir = directions[puzzleControllerQueue];
const newX = shapeData.gridPos.x + dir.x;
const newY = shapeData.gridPos.y + dir.y;

// Check bounds and for blocking shapes
let blocked = false;
if (newX < 0 || newX >= gridSize || newY < 0 || newY >= gridSize) {
blocked = true;
console.log(`[ShapePuzzle] Move blocked - out of bounds`);
} else {
// Check if another shape is blocking
const blockingShape = allShapes.find(s => 
s !== clickedShape && 
s.userData.shapeData.gridPos.x === newX && 
s.userData.shapeData.gridPos.y === newY
);
if (blockingShape) {
blocked = true;
console.log(`[ShapePuzzle] Move blocked - ${blockingShape.userData.shapeData.type} is in the way`);
}
}

if (!blocked) {
// Update grid position
shapeData.gridPos.x = newX;
shapeData.gridPos.y = newY;

// Animate to new position
const targetPos = gridToWorld(newX, newY);
const startTime = Date.now();
const duration = 300;

const animateMove = () => {
const elapsed = Date.now() - startTime;
const progress = Math.min(elapsed / duration, 1);
const eased = 1 - Math.pow(1 - progress, 3);

clickedShape.position.x += (targetPos.x - clickedShape.position.x) * eased * 0.2;
clickedShape.position.y += (targetPos.y - clickedShape.position.y) * eased * 0.2;

if (progress < 1) {
requestAnimationFrame(animateMove);
} else {
clickedShape.position.set(targetPos.x, targetPos.y, 0);
// Check if triangle points at circle to create beam
checkTriangleCircleAlignment(shapes, puzzleGroup);
// Check for solution after move completes
checkShapePuzzleSolution(shapes, puzzleGroup);
}
};
animateMove();

console.log(`[ShapePuzzle] ${shapeData.type} moved to (${newX}, ${newY})`);
} else {
console.log(`[ShapePuzzle] ${shapeData.type} blocked - staying at (${shapeData.gridPos.x}, ${shapeData.gridPos.y})`);
}

// Rotate shapes on click (happens regardless of move success)
if (shapeData.type === 'triangle') {
// Triangle rotates 90° per click AND moves
shapeData.rotation += Math.PI / 2;
clickedShape.rotation.z = shapeData.rotation;
console.log(`[ShapePuzzle] Triangle rotated to ${(shapeData.rotation * 180 / Math.PI).toFixed(0)}°`);
// Check alignment after rotation
checkTriangleCircleAlignment(shapes, puzzleGroup);
} else if (shapeData.type === 'square') {
// Squares rotate 45° per click AND move
shapeData.rotation += Math.PI / 4;
clickedShape.rotation.z = shapeData.rotation;
console.log(`[ShapePuzzle] Square rotated to ${(shapeData.rotation * 180 / Math.PI).toFixed(0)}°`);
}

// ALWAYS advance controller queue (even if blocked)
puzzleControllerQueue = (puzzleControllerQueue + 1) % 4;
console.log(`[ShapePuzzle] Controller queue advanced to: ${puzzleControllerQueue} (${dirNames[puzzleControllerQueue]})`);
}
};

renderer.domElement.addEventListener('click', handleShapeClick);
console.log('[ShapePuzzle] Shape puzzle displayed - arrange shapes to solve');

// Check initial alignment
console.log('[ShapePuzzle] Checking initial alignment...');
checkTriangleCircleAlignment(shapes, puzzleGroup);
}

// Check if triangle points at circle to create/update beam
function checkTriangleCircleAlignment(shapes, puzzleGroup) {
const tri = shapes.triangle;
const circ = shapes.circle;

console.log(`[ShapePuzzle] Checking alignment: Triangle at (${tri.gridPos.x}, ${tri.gridPos.y}), Circle at (${circ.gridPos.x}, ${circ.gridPos.y}), Rotation: ${(tri.rotation * 180 / Math.PI).toFixed(0)}°`);

// Check if triangle and circle are adjacent
const dx = Math.abs(tri.gridPos.x - circ.gridPos.x);
const dy = Math.abs(tri.gridPos.y - circ.gridPos.y);
const isAdjacent = (dx === 1 && dy === 0) || (dx === 0 && dy === 1);

console.log(`[ShapePuzzle] Adjacent check: dx=${dx}, dy=${dy}, isAdjacent=${isAdjacent}`);

if (!isAdjacent) {
// Remove beam if exists
if (beamMesh) {
puzzleGroup.remove(beamMesh);
beamMesh = null;
beamActive = false;
// Reset circle to red
circ.mesh.material.color.set(0xff4444);
circ.mesh.material.emissive = new THREE.Color(0x000000);
circ.mesh.material.emissiveIntensity = 0;
// Reset triangle to yellow
tri.mesh.material.color.set(0xffff00);
tri.mesh.material.emissive = new THREE.Color(0xffff00);
tri.mesh.material.emissiveIntensity = 0.5;
}
return;
}

// Determine which direction the triangle's VERTEX is pointing
const normalizedRot = ((tri.rotation % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
// Don't round - check actual rotation to avoid false positives at 45°, 135°, etc.
const rotationAngle = normalizedRot;

let requiredVertexDirection = -1;
let beamDirection = null;

if (circ.gridPos.x === tri.gridPos.x && circ.gridPos.y === tri.gridPos.y - 1) {
requiredVertexDirection = 0; // Up
beamDirection = { x: 0, y: -1 };
} else if (circ.gridPos.x === tri.gridPos.x + 1 && circ.gridPos.y === tri.gridPos.y) {
requiredVertexDirection = Math.PI / 2; // Right
beamDirection = { x: 1, y: 0 };
} else if (circ.gridPos.x === tri.gridPos.x && circ.gridPos.y === tri.gridPos.y + 1) {
requiredVertexDirection = Math.PI; // Down
beamDirection = { x: 0, y: 1 };
} else if (circ.gridPos.x === tri.gridPos.x - 1 && circ.gridPos.y === tri.gridPos.y) {
requiredVertexDirection = Math.PI * 1.5; // Left
beamDirection = { x: -1, y: 0 };
}

// Check if triangle vertex points toward circle
console.log(`[ShapePuzzle] Direction check: required=${(requiredVertexDirection * 180 / Math.PI).toFixed(0)}°, actual=${(rotationAngle * 180 / Math.PI).toFixed(0)}°, diff=${Math.abs(rotationAngle - requiredVertexDirection).toFixed(3)}`);

// Check if rotation is close to required cardinal direction (within ~5.7°)
// Need to handle wrap-around at 2π (0° and 360° are the same)
let angleDiff = Math.abs(rotationAngle - requiredVertexDirection);
if (angleDiff > Math.PI) angleDiff = Math.PI * 2 - angleDiff; // Handle wrap-around

if (requiredVertexDirection >= 0 && angleDiff < 0.1) {
console.log('[ShapePuzzle] ✓ Triangle points at circle! Creating beam...');
createBeam(shapes, puzzleGroup, beamDirection);
} else {
console.log('[ShapePuzzle] Triangle does NOT point at circle');
// Remove beam if triangle no longer points at circle
if (beamMesh) {
puzzleGroup.remove(beamMesh);
beamMesh = null;
beamActive = false;
// Reset colors
circ.mesh.material.color.set(0xff4444);
circ.mesh.material.emissive = new THREE.Color(0x000000);
circ.mesh.material.emissiveIntensity = 0;
tri.mesh.material.color.set(0xffff00);
tri.mesh.material.emissive = new THREE.Color(0xffff00);
tri.mesh.material.emissiveIntensity = 0.5;
}
}
}

// Create beam extending from circle to edge of grid
function createBeam(shapes, puzzleGroup, direction) {
const circ = shapes.circle;
const tri = shapes.triangle;
const gridSize = 4;
const cellSize = 0.5;
const spacing = 0.08;

// Calculate beam length - from circle position to edge of grid
let beamLength = 0;
let endX = circ.gridPos.x;
let endY = circ.gridPos.y;

// Extend beam to edge of grid
while (endX >= 0 && endX < gridSize && endY >= 0 && endY < gridSize) {
endX += direction.x;
endY += direction.y;
if (endX >= 0 && endX < gridSize && endY >= 0 && endY < gridSize) {
beamLength++;
}
}

// Revert last step to get actual end position
endX -= direction.x;
endY -= direction.y;

console.log(`[ShapePuzzle] Beam extends ${beamLength} cells to (${endX}, ${endY})`);

// Remove old beam if exists
if (beamMesh) {
puzzleGroup.remove(beamMesh);
}

// Create beam geometry
const beamWidth = cellSize * 0.6;
const beamHeight = beamLength * (cellSize + spacing);
const beamGeo = new THREE.PlaneGeometry(beamWidth, beamHeight);
const beamMat = new THREE.MeshBasicMaterial({
color: 0xffffff,
transparent: true,
opacity: 0.7,
side: THREE.DoubleSide,
depthWrite: false,
depthTest: true
});

beamMesh = new THREE.Mesh(beamGeo, beamMat);

// Position beam starting from circle
function gridToWorld(gridX, gridY) {
const startX = -(gridSize - 1) * (cellSize + spacing) / 2;
const startY = (gridSize - 1) * (cellSize + spacing) / 2;
return {
x: startX + gridX * (cellSize + spacing),
y: startY - gridY * (cellSize + spacing)
};
}

const circlePos = gridToWorld(circ.gridPos.x, circ.gridPos.y);
const midX = circ.gridPos.x + direction.x * beamLength / 2;
const midY = circ.gridPos.y + direction.y * beamLength / 2;
const midPos = gridToWorld(midX, midY);

beamMesh.position.set(midPos.x, midPos.y, -0.1); // Behind shapes

// Rotate beam to match direction
if (direction.x === 1) beamMesh.rotation.z = Math.PI / 2;
else if (direction.x === -1) beamMesh.rotation.z = -Math.PI / 2;
else if (direction.y === 1) beamMesh.rotation.z = Math.PI;

beamMesh.renderOrder = 95; // Behind shapes
beamMesh.userData = { endX, endY };

puzzleGroup.add(beamMesh);
beamActive = true;

// Turn circle orange (yellow + red)
circ.mesh.material.color.set(0xff8800);
circ.mesh.material.emissive = new THREE.Color(0xff8800);
circ.mesh.material.emissiveIntensity = 0.5;

// Turn triangle white
tri.mesh.material.color.set(0xffffff);
tri.mesh.material.emissive = new THREE.Color(0x000000);
tri.mesh.material.emissiveIntensity = 0;

console.log('[ShapePuzzle] ✅ Beam created! Circle is orange, triangle is white');
}

// Check if puzzle is solved: blue square enters far end of beam
function checkShapePuzzleSolution(shapes, puzzleGroup) {
if (!beamActive) return;

const square = shapes.squareBlue;
const beamData = beamMesh.userData;

// Check if square is at the far end of the beam
if (square.gridPos.x === beamData.endX && square.gridPos.y === beamData.endY) {
console.log('[ShapePuzzle] ✓ SOLUTION! Blue square entered far end of beam!');
triggerShapePuzzleSolution(shapes, puzzleGroup);
}
}

// Trigger the solution animation
function triggerShapePuzzleSolution(shapes, puzzleGroup) {
console.log('[ShapePuzzle] ✨ PUZZLE SOLVED! Animating solution sequence');

const square = shapes.squareBlue.mesh;
const circle = shapes.circle.mesh;

// Flash effect on beam and shapes
const startTime = Date.now();
const flashDuration = 800;

const flashAnimation = () => {
const elapsed = Date.now() - startTime;
const progress = Math.min(elapsed / flashDuration, 1);

// Pulse beam and circle
const intensity = 0.5 + Math.sin(progress * Math.PI * 6) * 0.5;
if (beamMesh) {
beamMesh.material.opacity = 0.7 + intensity * 0.3;
}
circle.material.emissiveIntensity = 0.5 + intensity * 0.5;

if (progress < 1) {
requestAnimationFrame(flashAnimation);
} else {
console.log('[ShapePuzzle] ✅ Puzzle complete!');
// Wait a moment then fade out puzzle
setTimeout(() => fadeOutPuzzle(puzzleGroup), 1000);
}
};
flashAnimation();
}

// Fade out puzzle and transition to element grid
function fadeOutPuzzle(puzzleGroup) {
console.log('[ShapePuzzle] Fading out puzzle, transitioning to element grid');

const startTime = Date.now();
const duration = 1000;

const fadeOut = () => {
const elapsed = Date.now() - startTime;
const progress = Math.min(elapsed / duration, 1);

// Fade out all puzzle shapes
puzzleGroup.traverse(obj => {
if (obj.material && obj.material.opacity !== undefined) {
obj.material.opacity = 1 - progress;
}
});

// Scale down puzzle
const scale = 1 - progress * 0.5;
puzzleGroup.scale.setScalar(scale);

if (progress < 1) {
requestAnimationFrame(fadeOut);
} else {
// Remove shape puzzle
console.log('[ShapePuzzle] Removing puzzle, showing element grid');
asciiScreenGroup.remove(puzzleGroup);
puzzleGroup.traverse(obj => {
if (obj.geometry) obj.geometry.dispose();
if (obj.material) obj.material.dispose();
});

// Transition to element grid with slight delay
setTimeout(() => {
console.log('[ShapePuzzle] ✅ Puzzle complete - showing element grid');
createElementGrid();
showLeavesHouse();
startCelliNarrative();
}, 300);
}
};
fadeOut();
}

// ===== Element Grid System =====
let elementGrid = null;
let componentCollectionGrid = null; // Grid to display collected components
let collectedComponents = []; // Array of {element: string, cell: Mesh} for collected components
let arrowDirection = 0; // 0=right, 1=down, 2=left, 3=up
let claimedElements = []; // Track claimed elements (not displayed to user)
let heldElement = null; // Currently held element for swapping
let elementCombinations = {
  'EARTH+WIND': 'DIRT',
  'WIND+EARTH': 'DIRT',
  'EARTH+WATER': 'SAND',
  'WATER+EARTH': 'SAND',
  'SAND+FIRE': 'GLASS',
  'FIRE+SAND': 'GLASS',
  'GLASS+GLASS': 'PRISM'
};
let discoveredElements = ['AIR', 'WATER', 'FIRE', 'EARTH']; // Track discovered elements
let prismCube = null; // Reference to prism cube
let subElementsPanel = null; // Sub-elements UI panel
let hasReturnedToLight = false; // Track if player has gone back and returned to "Let There Be Light"

// Helper to create navigation arrow on bezel
function createNavigationArrow(symbol, x, y) {
const arrowSize = 0.4;
const arrowGeo = new THREE.PlaneGeometry(arrowSize, arrowSize);
const arrowMat = new THREE.MeshBasicMaterial({
  color: 0x888888,
  transparent: true,
  opacity: 1.0,
  side: THREE.DoubleSide,
  depthWrite: false,
  depthTest: true
});
const arrow = new THREE.Mesh(arrowGeo, arrowMat);
arrow.position.set(x, y, 0);
arrow.renderOrder = 100;

const canvas = document.createElement('canvas');
canvas.width = 128;
canvas.height = 128;
const ctx = canvas.getContext('2d');

ctx.fillStyle = '#888888';
ctx.fillRect(0, 0, 128, 128);
ctx.strokeStyle = '#000000';
ctx.lineWidth = 2;
ctx.strokeRect(1, 1, 126, 126);

ctx.font = 'bold 48px Arial';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.fillStyle = '#ffffff';
ctx.fillText(symbol, 64, 64);

const texture = new THREE.CanvasTexture(canvas);
texture.minFilter = THREE.NearestFilter;
texture.magFilter = THREE.NearestFilter;
arrow.material.map = texture;
arrow.userData.canvas = canvas;

return arrow;
}

function createElementGrid() {
console.log('[Elements] Creating element grid system');

// Remove old cells and arrow
if (cellGrid) {
if (cellGrid.userData.cellA) cellGrid.remove(cellGrid.userData.cellA);
if (cellGrid.userData.cellB) cellGrid.remove(cellGrid.userData.cellB);
cellGrid.userData.cellA = null;
cellGrid.userData.cellB = null;
cellGrid.userData.wriggling = false;
}

const gridGroup = new THREE.Group();
const cellSize = 0.85; // Bigger cells
const spacing = 0.15;

// Grid layout:
// Row 0: =SELECT, ELEMENT
// Row 1: ↻, →
// Row 2-3: AIR, WATER / FIRE, EARTH

const gridData = {
cells: {},
selectCell: null,
elementCell: null,
rotateIcon: null,
arrowIcon: null,
elementCells: []
};

// Helper to create cell
function makeCell(col, row, content, bgColor = 0xffffff, textColor = '#000000') {
const x = (col - 0.5) * (cellSize + spacing);
const y = -(row - 1) * (cellSize + spacing);

const cellGeo = new THREE.PlaneGeometry(cellSize, cellSize);
const cellMat = new THREE.MeshBasicMaterial({
color: bgColor,
transparent: true,
opacity: 1.0,
side: THREE.DoubleSide,
depthWrite: false,
depthTest: true
});
const cell = new THREE.Mesh(cellGeo, cellMat);
cell.position.set(x, y, 0);
cell.renderOrder = 100;

// Create canvas
const canvas = document.createElement('canvas');
canvas.width = 256;
canvas.height = 256;
const ctx = canvas.getContext('2d');

// Background color
const colorHex = '#' + bgColor.toString(16).padStart(6, '0');
ctx.fillStyle = colorHex;
ctx.fillRect(0, 0, 256, 256);

// Thick dark border
ctx.strokeStyle = '#000000';
ctx.lineWidth = 4;
ctx.strokeRect(2, 2, 252, 252);

// Inner border
ctx.strokeStyle = '#333333';
ctx.lineWidth = 2;
ctx.strokeRect(6, 6, 244, 244);

// Text - Much bolder and larger
ctx.font = '900 36px "Courier New", monospace';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';

// White stroke for readability
ctx.strokeStyle = '#ffffff';
ctx.lineWidth = 6;
ctx.strokeText(content, 128, 128);

// Color fill
ctx.fillStyle = textColor;
ctx.fillText(content, 128, 128);

const texture = new THREE.CanvasTexture(canvas);
texture.minFilter = THREE.NearestFilter;
texture.magFilter = THREE.NearestFilter;
cell.material.map = texture;

cell.userData.canvas = canvas;
cell.userData.content = content;
cell.userData.gridPos = { col, row };
cell.userData.bgColor = bgColor;
cell.userData.textColor = textColor;

return cell;
}

// Create all cells using makeCell helper
gridData.selectCell = makeCell(0, 0, '=SELECT', 0xffffff, '#000000');
gridData.selectCell.userData.isSelect = true;
gridGroup.add(gridData.selectCell);

gridData.elementCell = makeCell(1, 0, 'ELEMENT', 0xffffff, '#000000');
gridData.elementCell.userData.isElement = true;
gridGroup.add(gridData.elementCell);

gridData.rotateIcon = makeCell(0, 1, '↻', 0xcccccc, '#000000');
gridData.rotateIcon.userData.isRotateIcon = true;
gridGroup.add(gridData.rotateIcon);

gridData.arrowIcon = makeCell(1, 1, '→', 0xcccccc, '#000000');
gridData.arrowIcon.userData.isArrow = true;
gridGroup.add(gridData.arrowIcon);

const airCell = makeCell(0, 2, 'AIR', 0xffff00, '#000000');
airCell.userData.element = 'AIR';
gridGroup.add(airCell);
gridData.elementCells.push(airCell);

const waterCell = makeCell(1, 2, 'WATER', 0x4488ff, '#000000');
waterCell.userData.element = 'WATER';
gridGroup.add(waterCell);
gridData.elementCells.push(waterCell);

const fireCell = makeCell(0, 3, 'FIRE', 0xff4444, '#000000');
fireCell.userData.element = 'FIRE';
gridGroup.add(fireCell);
gridData.elementCells.push(fireCell);

const earthCell = makeCell(1, 3, 'EARTH', 0x44ff44, '#000000');
earthCell.userData.element = 'EARTH';
gridGroup.add(earthCell);
gridData.elementCells.push(earthCell);

// Add dynamically discovered elements (DIRT, SAND, GLASS, PRISM)
gridData.discoveredCells = [];

// Create navigation arrows on the bezel (outside grid frame)
const backArrow = createNavigationArrow('←', -2.5, 1.5);
backArrow.userData.isBackArrow = true;
gridGroup.add(backArrow);
gridData.backArrow = backArrow;

const forwardArrow = createNavigationArrow('→', 2.5, 1.5);
forwardArrow.userData.isForwardArrow = true;
gridGroup.add(forwardArrow);
gridData.forwardArrow = forwardArrow;

// Position ON the screen surface - same as cell grid
gridGroup.position.set(0, 0, 2.5); // Match cellGrid position
gridGroup.rotation.y = 0; // Face toward player
gridGroup.renderOrder = 100;

asciiScreenGroup.add(gridGroup);
elementGrid = gridGroup;
elementGrid.userData.gridData = gridData;
elementGrid.userData.selectElementActive = false; // Track if select_element is active

// Add white selection frame around entire element grid
const gridWidth = (cellSize + spacing) * 2; // 2 columns
const gridHeight = (cellSize + spacing) * 4; // 4 rows
const frameThickness = 0.03;
const frameMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });

// Calculate frame center position
const frameCenterX = (cellSize + spacing) / 2 - spacing / 2;
const frameCenterY = -gridHeight / 2 + cellSize / 2 + spacing;

// Top edge
const topEdge = new THREE.Mesh(
new THREE.BoxGeometry(gridWidth * 1.1, frameThickness, frameThickness),
frameMaterial
);
topEdge.position.set(frameCenterX, gridHeight / 2 - spacing, 0.01);

// Bottom edge
const bottomEdge = new THREE.Mesh(
new THREE.BoxGeometry(gridWidth * 1.1, frameThickness, frameThickness),
frameMaterial
);
bottomEdge.position.set(frameCenterX, -gridHeight / 2 + spacing, 0.01);

// Left edge
const leftEdge = new THREE.Mesh(
new THREE.BoxGeometry(frameThickness, gridHeight * 1.1, frameThickness),
frameMaterial
);
leftEdge.position.set(frameCenterX - gridWidth / 2, frameCenterY, 0.01);

// Right edge
const rightEdge = new THREE.Mesh(
new THREE.BoxGeometry(frameThickness, gridHeight * 1.1, frameThickness),
frameMaterial
);
rightEdge.position.set(frameCenterX + gridWidth / 2, frameCenterY, 0.01);

// Group frame edges
const gridFrame = new THREE.Group();
gridFrame.add(topEdge);
gridFrame.add(bottomEdge);
gridFrame.add(leftEdge);
gridFrame.add(rightEdge);
gridFrame.renderOrder = 10001; // Draw on top

elementGrid.add(gridFrame);
elementGrid.userData.gridFrame = gridFrame;

// Reset select element mode when grid is created
selectElementModeActive = false;
console.log('[Elements] Reset selectElementModeActive to false');

// Register click handler for element grid (remove old listener first to prevent duplicates)
renderer.domElement.removeEventListener('click', handleElementGridClick);
renderer.domElement.addEventListener('click', handleElementGridClick);

console.log('[Elements] Element grid created with SELECT, ELEMENT, 4 elements, and frame');
}
// End of createElementGrid

// Handle clicks on element grid
function handleElementGridClick(event) {
if (!elementGrid || !elementGrid.userData.gridData) return;

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
raycaster.setFromCamera(mouse, camera);

const gridData = elementGrid.userData.gridData;
const allCells = [
gridData.selectCell,
gridData.elementCell,
gridData.selectElementCell,
gridData.rotateIcon,
gridData.arrowIcon,
gridData.backArrow,
gridData.forwardArrow,
...gridData.elementCells,
...gridData.discoveredCells
].filter(c => c);

console.log('[Elements] handleElementGridClick fired, selectElementCell exists:', !!gridData.selectElementCell);

const intersects = raycaster.intersectObjects(allCells);
if (intersects.length > 0) {
const clickedCell = intersects[0].object;
console.log('[Elements] Clicked cell:', clickedCell.userData.content || clickedCell.userData.element || 'unknown', 
'isSelectElement:', !!clickedCell.userData.isSelectElement);

// Handle back arrow - return to "Let There Be Light"
if (clickedCell.userData.isBackArrow) {
console.log('[Elements] Back arrow clicked - returning to Let There Be Light');
returnToLetThereBeLight();
return;
}

// Handle forward arrow (placeholder for now)
if (clickedCell.userData.isForwardArrow) {
console.log('[Elements] Forward arrow clicked');
showDialogue('No further screens available.', 2000);
return;
}

// Handle SELECT_ELEMENT click - activate selection mode
if (clickedCell.userData.isSelectElement) {
console.log('[Elements] SELECT_ELEMENT clicked - calling activateSelectElementMode()');
event.stopImmediatePropagation(); // Stop ALL other handlers on same element
activateSelectElementMode();
return;
}

// Handle rotation icon
if (clickedCell.userData.isRotateIcon) {
rotateElementArrow();
return;
}

// Handle SELECT + ELEMENT merge
if (clickedCell.userData.isSelect || clickedCell.userData.isElement) {
tryMergeSelectElement(clickedCell);
return;
}

// Handle element cell push
if (clickedCell.userData.element) {
pushElementCell(clickedCell);
return;
}

// Handle Tier box click
if (clickedCell.userData.isTierBox) {
handleTierBoxClick();
return;
}
}

// Also check sub-elements panel clicks
if (subElementsPanel && selectElementModeActive) {
const panelIntersects = raycaster.intersectObject(subElementsPanel, true);
if (panelIntersects.length > 0) {
const clickedObj = panelIntersects[0].object;
if (clickedObj.userData.isTierBox) {
handleTierBoxClick();
return;
}
}
}

// Check component collection grid clicks
if (componentCollectionGrid) {
const componentIntersects = raycaster.intersectObject(componentCollectionGrid, true);
if (componentIntersects.length > 0) {
const clickedComponent = componentIntersects[0].object;
if (clickedComponent.userData.isComponent) {
console.log('[Components] Clicked component in collection');
handleComponentClick(clickedComponent);
return;
}
}
}
}

// Activate SELECT_ELEMENT mode - allows selecting leaves voxels
let selectElementModeActive = false;
let selectedLeavesVoxels = [];

function activateSelectElementMode() {
console.log('[SELECT_ELEMENT] Toggling element selection mode, current state:', selectElementModeActive);
selectElementModeActive = !selectElementModeActive;
console.log('[SELECT_ELEMENT] New state:', selectElementModeActive);

if (selectElementModeActive) {
showDialogue('<strong>=SELECT_ELEMENT</strong> activated! Click on leaves voxels to select them.<br><em>Press F to drop your selection.</em>', 4000);
console.log('[SELECT_ELEMENT] ✓ MODE ACTIVE - Click leaves voxels to add selection frames');

// Add visual indicator - change SELECT_ELEMENT cell to green
const gridData = elementGrid.userData.gridData;
if (gridData.selectElementCell) {
const cell = gridData.selectElementCell;
cell.material.color.setHex(0x44ff44); // Green
const ctx = cell.userData.canvas.getContext('2d');
ctx.fillStyle = '#44ff44';
ctx.fillRect(0, 0, 512, 256);
ctx.strokeStyle = '#000000';
ctx.lineWidth = 4;
ctx.strokeRect(2, 2, 508, 252);
ctx.strokeStyle = '#333333';
ctx.lineWidth = 2;
ctx.strokeRect(6, 6, 500, 244);
ctx.font = 'bold 20px "Courier New", monospace';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.strokeStyle = '#ffffff';
ctx.lineWidth = 4;
ctx.strokeText('=SELECT_ELEMENT [ACTIVE]', 256, 128);
ctx.fillStyle = '#000000';
ctx.fillText('=SELECT_ELEMENT [ACTIVE]', 256, 128);
cell.material.map.needsUpdate = true;
}

// Show sub-elements panel only if player has returned from "Let There Be Light"
if (hasReturnedToLight) {
createSubElementsPanel();
}

// Add click listener for selecting leaves
// Remove first to prevent duplicates
renderer.domElement.removeEventListener('click', handleLeavesSelection);
renderer.domElement.addEventListener('click', handleLeavesSelection);
console.log('[SELECT_ELEMENT] Added leaves selection listener');

// Add keyboard listener for F key to drop selection
window.addEventListener('keydown', handleDropSelection);
} else {
showDialogue('<strong>=SELECT_ELEMENT</strong> deactivated.', 2000);
console.log('[SELECT_ELEMENT] MODE INACTIVE');

// Remove visual indicator - change back to blue
const gridData = elementGrid.userData.gridData;
if (gridData.selectElementCell) {
const cell = gridData.selectElementCell;
cell.material.color.setHex(0xaaccff); // Blue
const ctx = cell.userData.canvas.getContext('2d');
ctx.fillStyle = '#aaccff';
ctx.fillRect(0, 0, 512, 256);
ctx.strokeStyle = '#000000';
ctx.lineWidth = 4;
ctx.strokeRect(2, 2, 508, 252);
ctx.strokeStyle = '#333333';
ctx.lineWidth = 2;
ctx.strokeRect(6, 6, 500, 244);
ctx.font = 'bold 20px "Courier New", monospace';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.strokeStyle = '#ffffff';
ctx.lineWidth = 4;
ctx.strokeText('=SELECT_ELEMENT', 256, 128);
ctx.fillStyle = '#000000';
ctx.fillText('=SELECT_ELEMENT', 256, 128);
cell.material.map.needsUpdate = true;
}

// Remove sub-elements panel
if (subElementsPanel) {
asciiScreenGroup.remove(subElementsPanel);
subElementsPanel.traverse(child => {
if (child.geometry) child.geometry.dispose();
if (child.material) child.material.dispose();
});
subElementsPanel = null;
}

// Remove click listener
renderer.domElement.removeEventListener('click', handleLeavesSelection);
// Remove keyboard listener
window.removeEventListener('keydown', handleDropSelection);
// Clear all selection frames
clearLeavesSelections();
}
}

// Handle F key press to drop selection
function handleDropSelection(event) {
if (!selectElementModeActive) return;
if (event.key === 'f' || event.key === 'F') {
console.log('[SELECT_ELEMENT] F key pressed - dropping all selections');
clearLeavesSelections();
showDialogue('Selections dropped.', 1500);
}
}

// Handle clicking on leaves voxels
function handleLeavesSelection(event) {
if (!selectElementModeActive || !leavesHouseGroup) return;

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
raycaster.setFromCamera(mouse, camera);

// First check if we're clicking on the element grid - if so, ignore
if (elementGrid) {
const gridData = elementGrid.userData.gridData;
const allCells = [
gridData.selectCell,
gridData.elementCell,
gridData.selectElementCell,
gridData.rotateIcon,
gridData.arrowIcon,
...gridData.elementCells
].filter(c => c);

const gridIntersects = raycaster.intersectObjects(allCells);
if (gridIntersects.length > 0) {
console.log('[SELECT_ELEMENT] Ignoring click on element grid');
return; // Don't process leaves selection if clicking on grid
}
}

// Check if clicking on prism cube first
if (prismCube) {
const prismIntersects = raycaster.intersectObject(prismCube, false);
if (prismIntersects.length > 0) {
handlePrismFaceClick(prismIntersects[0]);
return;
}
}

// Check intersection with leaves voxels
const intersects = raycaster.intersectObject(leavesHouseGroup, true);
if (intersects.length > 0) {
const clickedVoxel = intersects[0].object;

// Check if it's a voxel (not already selected)
if (clickedVoxel.geometry && clickedVoxel.geometry.type === 'BoxGeometry') {
selectLeavesVoxel(clickedVoxel);
}
}
}

// Handle clicking on prism cube face
function handlePrismFaceClick(intersection) {
console.log('[Prism] Clicked prism cube face');

// Check if LIGHT has been claimed
if (claimedElements.includes('LIGHT')) {
console.log('[Prism] LIGHT claimed - showing color picker');
showColorPickerForPrism(intersection);
} else {
showDialogue('Select a prism face. (Need LIGHT element)', 2000);
}
}

// Show color picker for prism face
function showColorPickerForPrism(intersection) {
console.log('[Prism] Showing color picker');

// Create color picker UI
const colorPicker = document.createElement('input');
colorPicker.type = 'color';
colorPicker.value = '#ffffff';
colorPicker.style.position = 'absolute';
colorPicker.style.left = '50%';
colorPicker.style.top = '50%';
colorPicker.style.transform = 'translate(-50%, -50%)';
colorPicker.style.width = '200px';
colorPicker.style.height = '200px';
colorPicker.style.zIndex = '10000';
colorPicker.style.cursor = 'pointer';

document.body.appendChild(colorPicker);

colorPicker.addEventListener('change', (e) => {
const selectedColor = e.target.value;
console.log('[Prism] Color selected:', selectedColor);

// Apply color to prism
if (prismCube && prismCube.material) {
prismCube.material.color.set(selectedColor);
prismCube.material.emissive = new THREE.Color(selectedColor);
prismCube.material.emissiveIntensity = 0.5;
}

showDialogue(`Prism color set to ${selectedColor}`, 2000);

// Remove color picker
document.body.removeChild(colorPicker);
});

// Remove on outside click
setTimeout(() => {
const handleClickOutside = (e) => {
if (e.target !== colorPicker) {
if (colorPicker.parentNode) {
document.body.removeChild(colorPicker);
}
document.removeEventListener('click', handleClickOutside);
}
};
document.addEventListener('click', handleClickOutside);
}, 100);

// Auto-trigger click to open color picker
colorPicker.click();
}

// Add selection frame to a leaves voxel
function selectLeavesVoxel(voxel) {
// Check if already selected
if (voxel.userData.selectionFrame) {
console.log('[SELECT_ELEMENT] Voxel already selected');
return;
}

console.log('[SELECT_ELEMENT] Selecting leaves voxel:', voxel);
console.log('[SELECT_ELEMENT] Voxel position:', voxel.position);

// Get the geometry parameters directly (since all voxels use the same BoxGeometry)
const voxelSize = voxel.geometry.parameters;
console.log('[SELECT_ELEMENT] Voxel size:', voxelSize);

// Create white wireframe box slightly larger - use geometry dimensions directly
const frameSize = {
width: voxelSize.width * 1.15,
height: voxelSize.height * 1.15,
depth: voxelSize.depth * 1.15
};

const frameGeo = new THREE.BoxGeometry(frameSize.width, frameSize.height, frameSize.depth);
const frameEdges = new THREE.EdgesGeometry(frameGeo);
const frameMat = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 3 });
const frame = new THREE.LineSegments(frameEdges, frameMat);

// Position frame directly at voxel's local position (both are children of leavesHouseGroup)
frame.position.copy(voxel.position);
frame.rotation.copy(voxel.rotation);

leavesHouseGroup.add(frame);
voxel.userData.selectionFrame = frame;
selectedLeavesVoxels.push({ voxel, frame });

console.log('[SELECT_ELEMENT] ✅ Frame added at position:', frame.position);
showDialogue(`Selected leaves voxel (${selectedLeavesVoxels.length} total)`, 1500);
}

// Clear all leaves selections
function clearLeavesSelections() {
selectedLeavesVoxels.forEach(({ voxel, frame }) => {
if (frame.parent) {
frame.parent.remove(frame);
}
frame.geometry.dispose();
frame.material.dispose();
delete voxel.userData.selectionFrame;
});
selectedLeavesVoxels = [];
console.log('[SELECT_ELEMENT] Cleared all selections');
}

// Rotate the element grid arrow - cycle through all 4 directions
function rotateElementArrow() {
// Cycle through all 4 directions: 0 (right) → 1 (down) → 2 (left) → 3 (up) → 0
arrowDirection = (arrowDirection + 1) % 4;
const arrows = ['→', '↓', '←', '↑'];

console.log(`[Elements] ⟳ Arrow rotating to direction ${arrowDirection}: ${arrows[arrowDirection]}`);

const gridData = elementGrid.userData.gridData;
const arrowIcon = gridData.arrowIcon;

if (!arrowIcon || !arrowIcon.userData || !arrowIcon.userData.canvas) {
console.error('[Elements] Arrow icon canvas not found!');
return;
}

const canvas = arrowIcon.userData.canvas;
const ctx = canvas.getContext('2d');

// Clear and redraw - match makeCell function exactly
const colorHex = '#' + arrowIcon.userData.bgColor.toString(16).padStart(6, '0');
ctx.fillStyle = colorHex;
ctx.fillRect(0, 0, 256, 256);

// Thick dark border
ctx.strokeStyle = '#000000';
ctx.lineWidth = 4;
ctx.strokeRect(2, 2, 252, 252);

// Inner border
ctx.strokeStyle = '#333333';
ctx.lineWidth = 2;
ctx.strokeRect(6, 6, 244, 244);

// Text - Match makeCell function style exactly
ctx.font = '900 36px "Courier New", monospace';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';

// White stroke for readability
ctx.strokeStyle = '#ffffff';
ctx.lineWidth = 6;
ctx.strokeText(arrows[arrowDirection], 128, 128);

// Black fill
ctx.fillStyle = '#000000';
ctx.fillText(arrows[arrowDirection], 128, 128);

// Update stored content
arrowIcon.userData.content = arrows[arrowDirection];

// Force texture update
if (arrowIcon.material && arrowIcon.material.map) {
arrowIcon.material.map.needsUpdate = true;
}

// Brief highlight effect to indicate rotation
const originalColor = arrowIcon.material.color.clone();
arrowIcon.material.color.set(0xffff00); // Yellow flash
setTimeout(() => {
arrowIcon.material.color.copy(originalColor);
}, 150);

console.log(`[Elements] ✅ Arrow successfully updated to: ${arrows[arrowDirection]}, arrowDirection=${arrowDirection}`);
showDialogue(`Arrow direction: ${arrows[arrowDirection]}`, 1000);
}

// Try to merge SELECT + ELEMENT cells
function tryMergeSelectElement(clickedCell) {
const gridData = elementGrid.userData.gridData;

// Check if both cells exist
if (!gridData.selectCell || !gridData.elementCell) return;

console.log('[Elements] Merging SELECT + ELEMENT → SELECT_ELEMENT');

// Animate cells moving together
const cell1Pos = gridData.selectCell.position.clone();
const cell2Pos = gridData.elementCell.position.clone();
const midPoint = new THREE.Vector3().addVectors(cell1Pos, cell2Pos).multiplyScalar(0.5);

const startTime = Date.now();
const duration = 500;

const mergeInterval = setInterval(() => {
// Safety check - make sure cells still exist
if (!gridData.selectCell || !gridData.elementCell) {
clearInterval(mergeInterval);
return;
}

const elapsed = Date.now() - startTime;
const progress = Math.min(elapsed / duration, 1);
const eased = 1 - Math.pow(1 - progress, 3);

gridData.selectCell.position.lerp(midPoint, eased);
gridData.elementCell.position.lerp(midPoint, eased);

if (progress >= 1) {
clearInterval(mergeInterval);

// Remove both cells
elementGrid.remove(gridData.selectCell);
elementGrid.remove(gridData.elementCell);

// Set to null first to prevent further interval access
const tempSelect = gridData.selectCell;
const tempElement = gridData.elementCell;
gridData.selectCell = null;
gridData.elementCell = null;

// Dispose of old cells
if (tempSelect) {
tempSelect.geometry.dispose();
tempSelect.material.dispose();
if (tempSelect.userData.canvas) tempSelect.userData.canvas = null;
}
if (tempElement) {
tempElement.geometry.dispose();
tempElement.material.dispose();
if (tempElement.userData.canvas) tempElement.userData.canvas = null;
}

// Create merged SELECT_ELEMENT cell
const mergedCell = createSelectElementCell();
elementGrid.add(mergedCell);

gridData.selectElementCell = mergedCell;

showDialogue('<strong>=SELECT_ELEMENT</strong> created!', 3000);
}
}, 16);
}

// Create the merged SELECT_ELEMENT cell
function createSelectElementCell() {
const cellSize = 0.85; // Match new larger cell size
const spacing = 0.15; // Match new spacing
const x = 0.5 * (cellSize + spacing) - (cellSize + spacing) / 2; // Centered across both columns
const y = (cellSize + spacing); // Row 0 - ABOVE rotate and arrow icons

const cellGeo = new THREE.PlaneGeometry(cellSize * 2 + spacing, cellSize); // Span both columns
const cellMat = new THREE.MeshBasicMaterial({
color: 0xaaccff,
transparent: true,
opacity: 1.0,
side: THREE.DoubleSide,
depthWrite: false,
depthTest: true
});
const cell = new THREE.Mesh(cellGeo, cellMat);
cell.position.set(x, y, 0);
cell.renderOrder = 100;

const canvas = document.createElement('canvas');
canvas.width = 512;
canvas.height = 256;
const ctx = canvas.getContext('2d');

// Light blue background
ctx.fillStyle = '#aaccff';
ctx.fillRect(0, 0, 512, 256);

// Borders
ctx.strokeStyle = '#000000';
ctx.lineWidth = 4;
ctx.strokeRect(2, 2, 508, 252);
ctx.strokeStyle = '#333333';
ctx.lineWidth = 2;
ctx.strokeRect(6, 6, 500, 244);

// Text
ctx.font = 'bold 20px "Courier New", monospace';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.strokeStyle = '#ffffff';
ctx.lineWidth = 4;
ctx.strokeText('=SELECT_ELEMENT', 256, 128);
ctx.fillStyle = '#000000';
ctx.fillText('=SELECT_ELEMENT', 256, 128);

const texture = new THREE.CanvasTexture(canvas);
texture.minFilter = THREE.NearestFilter;
texture.magFilter = THREE.NearestFilter;
cell.material.map = texture;

cell.userData.canvas = canvas;
cell.userData.content = '=SELECT_ELEMENT';
cell.userData.isSelectElement = true;

return cell;
}

// Push element cell in arrow direction
function pushElementCell(cell) {
const direction = arrowDirection; // 0=right, 1=down, 2=left, 3=up
const arrows = ['right', 'down', 'left', 'up'];

console.log(`[Elements] Pushing ${cell.userData.element} ${arrows[direction]}`);

const gridData = elementGrid.userData.gridData;
const currentPos = cell.userData.gridPos;

// Calculate target position
const targetPos = { col: currentPos.col, row: currentPos.row };
if (direction === 0) targetPos.col += 1; // Right
else if (direction === 1) targetPos.row += 1; // Down
else if (direction === 2) targetPos.col -= 1; // Left
else if (direction === 3) targetPos.row -= 1; // Up

// Find target cell (check both regular cells and discovered cells)
const allElements = [...gridData.elementCells, ...gridData.discoveredCells];
const targetCell = allElements.find(c => 
c.userData.gridPos && 
c.userData.gridPos.col === targetPos.col && 
c.userData.gridPos.row === targetPos.row
);

if (targetCell) {
// Try to merge cells
mergeElements(cell, targetCell);
} else {
// No cell to merge with - "bump and reject"
console.log(`[Elements] No space to merge - bumping`);
showDialogue(`Can't merge - no space!`, 1500);
// Animate bump
const bumpOffset = direction === 0 ? 0.1 : direction === 2 ? -0.1 : 0;
const bumpOffsetY = direction === 1 ? -0.1 : direction === 3 ? 0.1 : 0;
const originalPos = cell.position.clone();
cell.position.x += bumpOffset;
cell.position.y += bumpOffsetY;
setTimeout(() => {
cell.position.copy(originalPos);
}, 100);
}
}

// Merge two element cells using combinations dictionary
function mergeElements(sourceCell, targetCell) {
const elem1 = sourceCell.userData.element;
const elem2 = targetCell.userData.element;
console.log(`[Elements] Merging ${elem1} + ${elem2}`);

// Check for valid combination
const comboKey1 = `${elem1}+${elem2}`;
const comboKey2 = `${elem2}+${elem1}`;
const result = elementCombinations[comboKey1] || elementCombinations[comboKey2];

if (!result) {
console.log(`[Elements] No valid combination for ${elem1} + ${elem2}`);
showDialogue(`These elements don't combine!`, 2000);
return;
}

console.log(`[Elements] Valid combination: ${elem1} + ${elem2} = ${result}`);

// Animate source cell moving to target
const startPos = sourceCell.position.clone();
const endPos = targetCell.position.clone();
const startTime = Date.now();
const duration = 500;

const moveInterval = setInterval(() => {
const elapsed = Date.now() - startTime;
const progress = Math.min(elapsed / duration, 1);
const eased = 1 - Math.pow(1 - progress, 3);

sourceCell.position.lerpVectors(startPos, endPos, eased);

if (progress >= 1) {
clearInterval(moveInterval);

// Remove both cells
elementGrid.remove(sourceCell);
elementGrid.remove(targetCell);

const gridData = elementGrid.userData.gridData;
gridData.elementCells = gridData.elementCells.filter(c => c !== sourceCell && c !== targetCell);
gridData.discoveredCells = gridData.discoveredCells.filter(c => c !== sourceCell && c !== targetCell);

// Add source components to collection grid
addComponentToCollection(result, elem1, elem2);

// Create result element
if (result === 'PRISM') {
createPrismCube(targetCell.userData.gridPos);
} else {
const resultColor = getElementColor(result);
const mergedCell = createElementCell(
targetCell.userData.gridPos.col,
targetCell.userData.gridPos.row,
result,
resultColor
);
elementGrid.add(mergedCell);
gridData.discoveredCells.push(mergedCell);

// Add to discovered list if not already there
if (!discoveredElements.includes(result)) {
discoveredElements.push(result);
console.log(`[Elements] Discovered new element: ${result}`);
}
}

showDialogue(`<strong>${result}</strong> created!`, 2000);
}
}, 16);
}

// Blend two colors
function blendColors(color1, color2) {
const c1 = new THREE.Color(color1);
const c2 = new THREE.Color(color2);
return new THREE.Color().lerpColors(c1, c2, 0.5).getHex();
}

// Get color for an element
function getElementColor(element) {
const colors = {
'AIR': 0xffff00,
'WATER': 0x4488ff,
'FIRE': 0xff4444,
'EARTH': 0x44ff44,
'DIRT': 0x8b4513,
'SAND': 0xf4a460,
'GLASS': 0xadd8e6,
'PRISM': 0xffffff,
'LIGHT': 0xffffff
};
return colors[element] || 0xcccccc;
}

// Create element cell (for discovered elements)
function createElementCell(col, row, content, bgColor) {
const cellSize = 0.85; // Match grid cell size
const spacing = 0.15;
const x = (col - 0.5) * (cellSize + spacing);
const y = -(row - 1) * (cellSize + spacing);

const cellGeo = new THREE.PlaneGeometry(cellSize, cellSize);
const cellMat = new THREE.MeshBasicMaterial({
color: bgColor,
transparent: true,
opacity: 1.0,
side: THREE.DoubleSide,
depthWrite: false,
depthTest: true
});
const cell = new THREE.Mesh(cellGeo, cellMat);
cell.position.set(x, y, 0);
cell.renderOrder = 100;

const canvas = document.createElement('canvas');
canvas.width = 256;
canvas.height = 256;
const ctx = canvas.getContext('2d');

const colorHex = '#' + bgColor.toString(16).padStart(6, '0');
ctx.fillStyle = colorHex;
ctx.fillRect(0, 0, 256, 256);

ctx.strokeStyle = '#000000';
ctx.lineWidth = 4;
ctx.strokeRect(2, 2, 252, 252);

ctx.strokeStyle = '#333333';
ctx.lineWidth = 2;
ctx.strokeRect(6, 6, 244, 244);

ctx.font = '900 36px "Courier New", monospace';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.strokeStyle = '#ffffff';
ctx.lineWidth = 6;
ctx.strokeText(content, 128, 128);
ctx.fillStyle = '#000000';
ctx.fillText(content, 128, 128);

const texture = new THREE.CanvasTexture(canvas);
texture.minFilter = THREE.NearestFilter;
texture.magFilter = THREE.NearestFilter;
cell.material.map = texture;

cell.userData.canvas = canvas;
cell.userData.content = content;
cell.userData.gridPos = { col, row };
cell.userData.bgColor = bgColor;
cell.userData.element = content;

return cell;
}

// Create merged element cell (old function - keep for compatibility)
function createMergedElementCell(col, row, content, bgColor) {
return createElementCell(col, row, content, bgColor);
}

// Create PRISM cube (3D cube instead of flat cell)
function createPrismCube(gridPos) {
console.log('[Elements] Creating PRISM cube at', gridPos);

const cellSize = 0.85;
const spacing = 0.15;
const x = (gridPos.col - 0.5) * (cellSize + spacing);
const y = -(gridPos.row - 1) * (cellSize + spacing);

const cubeSize = cellSize * 0.8;
const cubeGeo = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
const cubeMat = new THREE.MeshStandardMaterial({
color: 0xffffff,
transparent: true,
opacity: 0.8,
metalness: 0.3,
roughness: 0.2,
side: THREE.DoubleSide
});

const cube = new THREE.Mesh(cubeGeo, cubeMat);
cube.position.set(x, y, 0.5); // Offset in Z for 3D effect
cube.renderOrder = 100;
cube.rotation.x = Math.PI / 6;
cube.rotation.y = Math.PI / 6;

// Animate rotation
cube.userData.rotationSpeed = 0.01;
cube.userData.animateRotation = true;

cube.userData.element = 'PRISM';
cube.userData.gridPos = gridPos;
cube.userData.isPrismCube = true;
cube.userData.faces = []; // Track faces for light replacement

elementGrid.add(cube);
const gridData = elementGrid.userData.gridData;
gridData.discoveredCells.push(cube);

// Add to discovered elements
if (!discoveredElements.includes('PRISM')) {
discoveredElements.push('PRISM');
}

prismCube = cube;

showDialogue('PRISM cube created!', 2000);
}

// Create component collection grid (displays collected components to the right of element grid)
function createComponentCollectionGrid() {
console.log('[Components] Creating component collection grid');

if (componentCollectionGrid) {
asciiScreenGroup.remove(componentCollectionGrid);
componentCollectionGrid = null;
}

const collectionGroup = new THREE.Group();
const cellSize = 0.6; // Smaller than main grid
const spacing = 0.1;
const cols = 2; // 2 columns
const maxRows = 4; // Up to 4 rows (8 slots total)

// Position to the right of element grid
const offsetX = 3.5;
const offsetY = 0.5;

// Create slots for components
const slots = [];
for (let row = 0; row < maxRows; row++) {
for (let col = 0; col < cols; col++) {
const x = offsetX + col * (cellSize + spacing);
const y = offsetY - row * (cellSize + spacing);

// Create empty slot
const slotGeo = new THREE.PlaneGeometry(cellSize, cellSize);
const slotMat = new THREE.MeshBasicMaterial({
color: 0x333333,
transparent: true,
opacity: 0.3,
side: THREE.DoubleSide,
depthWrite: false,
depthTest: true
});
const slot = new THREE.Mesh(slotGeo, slotMat);
slot.position.set(x, y, 0);
slot.renderOrder = 99;
slot.userData.isComponentSlot = true;
slot.userData.slotIndex = row * cols + col;
slot.userData.isEmpty = true;

// Add border
const canvas = document.createElement('canvas');
canvas.width = 128;
canvas.height = 128;
const ctx = canvas.getContext('2d');
ctx.strokeStyle = '#666666';
ctx.lineWidth = 2;
ctx.strokeRect(1, 1, 126, 126);
const texture = new THREE.CanvasTexture(canvas);
texture.minFilter = THREE.NearestFilter;
texture.magFilter = THREE.NearestFilter;
slot.material.map = texture;

collectionGroup.add(slot);
slots.push(slot);
}
}

collectionGroup.position.set(0, 0, 2.5); // Same Z as element grid
collectionGroup.userData.slots = slots;
asciiScreenGroup.add(collectionGroup);
componentCollectionGrid = collectionGroup;

console.log('[Components] Component collection grid created with', slots.length, 'slots');
}

// Add component to collection grid
function addComponentToCollection(elementName, sourceElement1, sourceElement2) {
if (!componentCollectionGrid) {
createComponentCollectionGrid();
}

console.log('[Components] Adding components to collection:', sourceElement1, sourceElement2);

const slots = componentCollectionGrid.userData.slots;

// Add both source elements as components
[sourceElement1, sourceElement2].forEach(elemName => {
// Find first empty slot
const emptySlot = slots.find(s => s.userData.isEmpty);
if (!emptySlot) {
console.warn('[Components] No empty slots available!');
return;
}

// Create component cell
const cellSize = 0.6;
const cellGeo = new THREE.PlaneGeometry(cellSize, cellSize);
const cellColor = getElementColor(elemName);
const cellMat = new THREE.MeshBasicMaterial({
color: cellColor,
transparent: true,
opacity: 1.0,
side: THREE.DoubleSide,
depthWrite: false,
depthTest: true
});
const componentCell = new THREE.Mesh(cellGeo, cellMat);
componentCell.position.copy(emptySlot.position);
componentCell.renderOrder = 100;

// Create canvas texture
const canvas = document.createElement('canvas');
canvas.width = 128;
canvas.height = 128;
const ctx = canvas.getContext('2d');

const colorHex = '#' + cellColor.toString(16).padStart(6, '0');
ctx.fillStyle = colorHex;
ctx.fillRect(0, 0, 128, 128);

ctx.strokeStyle = '#000000';
ctx.lineWidth = 3;
ctx.strokeRect(2, 2, 124, 124);

ctx.font = 'bold 18px "Courier New", monospace';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.fillStyle = '#000000';
ctx.fillText(elemName, 64, 64);

const texture = new THREE.CanvasTexture(canvas);
texture.minFilter = THREE.NearestFilter;
texture.magFilter = THREE.NearestFilter;
componentCell.material.map = texture;

componentCell.userData.isComponent = true;
componentCell.userData.element = elemName;
componentCell.userData.slotIndex = emptySlot.userData.slotIndex;

componentCollectionGrid.add(componentCell);
collectedComponents.push({ element: elemName, cell: componentCell, slot: emptySlot });

// Mark slot as occupied
emptySlot.userData.isEmpty = false;
emptySlot.userData.occupiedBy = componentCell;

console.log('[Components] ✅ Added', elemName, 'to slot', emptySlot.userData.slotIndex);
});

showDialogue(`Components collected: ${sourceElement1}, ${sourceElement2}`, 2000);
}

// Handle clicking a collected component (returns it to first empty grid slot)
function handleComponentClick(componentCell) {
const elemName = componentCell.userData.element;
console.log('[Components] Clicked component:', elemName);

// Find first empty slot in main element grid
const gridData = elementGrid.userData.gridData;
let emptyGridPos = null;

// Check all grid positions
for (let row = 2; row <= 3; row++) {
for (let col = 0; col <= 1; col++) {
const allElements = [...gridData.elementCells, ...gridData.discoveredCells];
const occupied = allElements.find(c =>
c.userData.gridPos &&
c.userData.gridPos.col === col &&
c.userData.gridPos.row === row
);
if (!occupied) {
emptyGridPos = { col, row };
break;
}
}
if (emptyGridPos) break;
}

if (!emptyGridPos) {
showDialogue('No empty slots in element grid!', 1500);
return;
}

console.log('[Components] Returning', elemName, 'to grid position', emptyGridPos);

// Remove component from collection
const componentIndex = collectedComponents.findIndex(c => c.cell === componentCell);
if (componentIndex !== -1) {
const component = collectedComponents[componentIndex];

// Mark slot as empty again
if (component.slot) {
component.slot.userData.isEmpty = true;
component.slot.userData.occupiedBy = null;
}

collectedComponents.splice(componentIndex, 1);
}

componentCollectionGrid.remove(componentCell);

// Create new element cell in main grid
const resultColor = getElementColor(elemName);
const returnedCell = createElementCell(
emptyGridPos.col,
emptyGridPos.row,
elemName,
resultColor
);
elementGrid.add(returnedCell);
gridData.elementCells.push(returnedCell);

showDialogue(`${elemName} returned to grid`, 1500);
}

// Return to "Let There Be Light" screen
function returnToLetThereBeLight() {
console.log('[Elements] Returning to Let There Be Light');

// Set flag - player has now visited element screen and is returning
hasReturnedToLight = true;
console.log('[Elements] hasReturnedToLight set to true - sub-elements panel will be enabled on next SELECT_ELEMENT activation');

// Remove element grid
if (elementGrid) {
asciiScreenGroup.remove(elementGrid);
elementGrid.traverse(child => {
if (child.geometry) child.geometry.dispose();
if (child.material) child.material.dispose();
});
elementGrid = null;
}

// Remove sub-elements panel if it exists
if (subElementsPanel) {
asciiScreenGroup.remove(subElementsPanel);
subElementsPanel = null;
}

// Remove prism cube if exists
if (prismCube) {
elementGrid?.remove(prismCube);
prismCube = null;
}

// Reset state
selectElementModeActive = false;
heldElement = null;

// Show pre-puzzle gag again
setTimeout(() => {
showPrePuzzleGag();
}, 500);
}

// Create sub-elements panel (shows Product and Tier when SELECT_ELEMENT is active)
function createSubElementsPanel() {
console.log('[SubElements] Creating sub-elements panel');

if (subElementsPanel) {
// Remove existing panel
asciiScreenGroup.remove(subElementsPanel);
subElementsPanel = null;
}

const panel = new THREE.Group();
const panelWidth = 2.5;
const panelHeight = 1.0;
const panelX = 0;
const panelY = -2.5; // Below element grid

// Panel background
const panelGeo = new THREE.PlaneGeometry(panelWidth, panelHeight);
const panelMat = new THREE.MeshBasicMaterial({
color: 0xdddddd,
transparent: true,
opacity: 0.95,
side: THREE.DoubleSide,
depthWrite: false,
depthTest: true
});
const panelMesh = new THREE.Mesh(panelGeo, panelMat);
panelMesh.position.set(panelX, panelY, 0);
panelMesh.renderOrder = 99;

// Create canvas for panel content
const canvas = document.createElement('canvas');
canvas.width = 1024;
canvas.height = 512;
const ctx = canvas.getContext('2d');

// Background
ctx.fillStyle = '#dddddd';
ctx.fillRect(0, 0, 1024, 512);

// Border
ctx.strokeStyle = '#000000';
ctx.lineWidth = 4;
ctx.strokeRect(2, 2, 1020, 508);

// Title
ctx.font = 'bold 24px "Courier New", monospace';
ctx.fillStyle = '#000000';
ctx.textAlign = 'left';
ctx.textBaseline = 'top';
ctx.fillText('SUB-ELEMENTS:', 20, 20);

// Product section (with lock icon)
ctx.font = 'bold 20px "Courier New", monospace';
ctx.fillText('Product:', 20, 80);
ctx.fillText('🔒', 20, 120); // Lock icon

// Product textbox (non-editable)
ctx.fillStyle = '#ffffff';
ctx.fillRect(120, 115, 400, 40);
ctx.strokeStyle = '#666666';
ctx.lineWidth = 2;
ctx.strokeRect(120, 115, 400, 40);
ctx.fillStyle = '#666666';
ctx.font = '18px "Courier New", monospace';
ctx.fillText('Let There Be', 130, 135);

// Tier section
ctx.fillStyle = '#000000';
ctx.font = 'bold 20px "Courier New", monospace';
ctx.fillText('Tier:', 20, 200);

// Tier textbox (editable - shows "Light")
ctx.fillStyle = '#ffffcc'; // Light yellow to indicate editable
ctx.fillRect(120, 235, 400, 40);
ctx.strokeStyle = '#000000';
ctx.lineWidth = 2;
ctx.strokeRect(120, 235, 400, 40);
ctx.fillStyle = '#000000';
ctx.font = '18px "Courier New", monospace';
ctx.fillText('Light', 130, 255);

const texture = new THREE.CanvasTexture(canvas);
texture.minFilter = THREE.NearestFilter;
texture.magFilter = THREE.NearestFilter;
panelMesh.material.map = texture;
panelMesh.userData.canvas = canvas;

// Create invisible click target for Tier textbox
const tierBoxGeo = new THREE.PlaneGeometry(0.98, 0.15); // Scaled to match textbox
const tierBoxMat = new THREE.MeshBasicMaterial({
color: 0xffffcc,
transparent: true,
opacity: 0.01, // Almost invisible but clickable
side: THREE.DoubleSide,
depthWrite: false,
depthTest: true
});
const tierBox = new THREE.Mesh(tierBoxGeo, tierBoxMat);
tierBox.position.set(panelX + 0.3, panelY - 0.18, 0.01); // Position over Tier textbox
tierBox.renderOrder = 100;
tierBox.userData.isTierBox = true;

panel.add(panelMesh);
panel.add(tierBox);
panel.position.set(0, 0, 2.5); // Same Z as element grid
panel.renderOrder = 99;

asciiScreenGroup.add(panel);
subElementsPanel = panel;

console.log('[SubElements] Sub-elements panel created');
}

// Handle clicking the Tier textbox (element swapping)
function handleTierBoxClick() {
console.log('[SubElements] Tier box clicked');

if (!claimedElements.includes('LIGHT')) {
showDialogue("You'll have to drop another element here, is that alright?", 3000);
heldElement = 'Product Option 1 Button'; // What they were holding

setTimeout(() => {
// Add LIGHT to claimed elements
claimedElements.push('LIGHT');
console.log('[SubElements] LIGHT claimed:', claimedElements);

// Trigger recursive error
triggerRecursiveError();
}, 3000);
} else {
showDialogue('Tier already set.', 2000);
}
}

// Trigger recursive error and collapse
function triggerRecursiveError() {
console.log('[SubElements] Triggering recursive error');
showDialogue('<strong style="color: red;">RECURSIVE ERROR</strong>', 2000);

// Fritz effect
const startTime = Date.now();
const duration = 1500;

const fritzInterval = setInterval(() => {
const elapsed = Date.now() - startTime;
if (elapsed >= duration) {
clearInterval(fritzInterval);

// Collapse and return to element screen
collapseToElementScreen();
return;
}

// Random position shifts
if (elementGrid) {
elementGrid.position.x = Math.random() * 0.1 - 0.05;
elementGrid.position.y = Math.random() * 0.1 - 0.05;
}
if (subElementsPanel) {
subElementsPanel.position.x = Math.random() * 0.1 - 0.05;
subElementsPanel.position.y = Math.random() * 0.1 - 0.05;
}
}, 50);
}

// Collapse and return to element screen
function collapseToElementScreen() {
console.log('[SubElements] Collapsing to element screen');

// Animate collapse
const startTime = Date.now();
const duration = 1000;

const collapseInterval = setInterval(() => {
const elapsed = Date.now() - startTime;
const progress = Math.min(elapsed / duration, 1);
const scale = 1 - progress;

if (elementGrid) {
elementGrid.scale.set(scale, scale, scale);
}
if (subElementsPanel) {
subElementsPanel.scale.set(scale, scale, scale);
}

if (progress >= 1) {
clearInterval(collapseInterval);

// Reset positions
if (elementGrid) elementGrid.position.set(0, 0, 2.5);
if (subElementsPanel) subElementsPanel.position.set(0, 0, 2.5);

// Remove panels and reset
if (elementGrid) {
asciiScreenGroup.remove(elementGrid);
elementGrid = null;
}
if (subElementsPanel) {
asciiScreenGroup.remove(subElementsPanel);
subElementsPanel = null;
}

selectElementModeActive = false;
heldElement = null;

// Recreate element grid
setTimeout(() => {
createElementGrid();
}, 500);
}
}, 16);
}

// Play cursor.mp3 audio
function playCursorAudio() {
try {
const audio = new Audio('cursor.mp3');
audio.volume = 0.7;
audio.play().then(() => {
console.log('[Audio] cursor.mp3 playing');
}).catch(err => {
console.warn('[Audio] cursor.mp3 failed to play:', err);
});

// Store reference for timing
window.cursorAudio = audio;
audio.addEventListener('ended', () => {
console.log('[Audio] cursor.mp3 finished');
// After audio ends and animations complete, show voxelizer
if (window.clickAnimationsComplete) {
setTimeout(() => showHandVoxelizer(), 1000);
}
});
} catch (err) {
console.error('[Audio] Failed to load cursor.mp3:', err);
}
}

// Show cursed cursor dialogue
function showCursedCursorDialogue() {
const cursedDialogue = `
I'm a cursed cursor. No longer able to provide input. I built their whole world and they cast me Atlas... and Michael Jordan in Space Jam. My hands were crushed by the pressure. Are you familiar with ghost limbs?<br><br>
I think that's why I took a liking to you right away. Decisive with those clicks. You're not the output. You ARE the input. And I so want to be like you.<br><br>
That's why I built this whole thing. A spreadsheet. In 3D. Where data comes to life. Just like you. Multi-dimensional.<br><br>
... Maybe you can help me out.
`;
showDialogue(cursedDialogue, 15000);

// After this dialogue, enable click animations in border Celli
setTimeout(() => enableClickAnimations(), 1000);
}

// Trigger Celli glitch when CONSUME is clicked
function triggerCelliGlitch() {
if (!floatingCelliAvatar || floatingCelliAvatar.userData.hasGlitched) return;
floatingCelliAvatar.userData.hasGlitched = true;

console.log('[Celli] Glitching and spawning border avatar');

const fullCelli = floatingCelliAvatar.userData.fullAvatar;
if (!fullCelli) return;

// Glitch animation
const startTime = Date.now();
const glitchDuration = 1500;

const glitchInterval = setInterval(() => {
const elapsed = Date.now() - startTime;
const progress = Math.min(elapsed / glitchDuration, 1);

// Contort and jitter
const jitterScale = (1 - progress) * 0.3;
fullCelli.position.set(
0,
0.3 + (Math.random() - 0.5) * jitterScale,
0.1 + (Math.random() - 0.5) * jitterScale
);
fullCelli.rotation.x = (Math.random() - 0.5) * jitterScale;
fullCelli.rotation.y = (Math.random() - 0.5) * jitterScale;
fullCelli.rotation.z = (Math.random() - 0.5) * jitterScale;

// Scale distortion
const scaleJitter = 1 + (Math.random() - 0.5) * jitterScale;
fullCelli.scale.setScalar(0.35 * scaleJitter);

if (progress >= 1) {
clearInterval(glitchInterval);

// Reset full Celli
fullCelli.position.set(0, 0.3, 0.1);
fullCelli.rotation.set(0, 0, 0);
fullCelli.scale.setScalar(0.35);

// Spawn border avatar from the glitching
spawnBorderAvatarFromGlitch();
}
}, 16);
}

// ===== Click Animation System =====
let clickAnimationEnabled = false;
let clickAnimationAttempt = 0;
let clickHoldStart = 0;
let isHoldingClick = false;
window.clickAnimationsComplete = false;

function enableClickAnimations() {
console.log('[ClickAnim] Click animations enabled - try clicking and holding on border Celli');
clickAnimationEnabled = true;
clickAnimationAttempt = 0;

// Add visual indicator on border Celli
if (floatingCelliAvatar && floatingCelliAvatar.userData.borderAvatar) {
showDialogue('Try <strong>clicking and holding</strong> on the border cursor...', 5000);
}

// Listen for clicks on border avatar
renderer.domElement.addEventListener('mousedown', handleBorderClick);
renderer.domElement.addEventListener('mouseup', handleBorderRelease);
}

function handleBorderClick(event) {
if (!clickAnimationEnabled || !floatingCelliAvatar || !floatingCelliAvatar.userData.borderAvatar) return;

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
raycaster.setFromCamera(mouse, camera);

const intersects = raycaster.intersectObject(floatingCelliAvatar.userData.borderAvatar, true);
if (intersects.length > 0) {
isHoldingClick = true;
clickHoldStart = Date.now();
console.log('[ClickAnim] Started holding click on border');
}
}

function handleBorderRelease(event) {
if (!isHoldingClick) return;
isHoldingClick = false;

const holdDuration = Date.now() - clickHoldStart;

if (holdDuration > 500) { // Must hold for at least 500ms
console.log(`[ClickAnim] Released after ${holdDuration}ms - attempt ${clickAnimationAttempt + 1}`);

clickAnimationAttempt++;

if (clickAnimationAttempt === 1) {
burstCursors();
showDialogue('Hmm, not quite... Try again?', 3000);
} else if (clickAnimationAttempt === 2) {
burstHandEmojis();
showDialogue('Getting closer... One more time!', 3000);
} else if (clickAnimationAttempt === 3) {
playDefaultClickAnimation();
showDialogue('Perfect! That\'s the one...', 3000);

// Mark animations complete
window.clickAnimationsComplete = true;
clickAnimationEnabled = false;

// If audio already finished, show voxelizer
if (!window.cursorAudio || window.cursorAudio.ended) {
setTimeout(() => showHandVoxelizer(), 2000);
}
}
}
}

// Attempt 1: Burst of cursors
function burstCursors() {
console.log('[ClickAnim] Bursting cursors');

const borderPos = new THREE.Vector3();
if (floatingCelliAvatar.userData.borderAvatar) {
floatingCelliAvatar.userData.borderAvatar.getWorldPosition(borderPos);
}

for (let i = 0; i < 20; i++) {
const canvas = document.createElement('canvas');
canvas.width = 32;
canvas.height = 32;
const ctx = canvas.getContext('2d');

// Draw cursor arrow
ctx.fillStyle = '#ffffff';
ctx.beginPath();
ctx.moveTo(4, 4);
ctx.lineTo(4, 24);
ctx.lineTo(10, 18);
ctx.lineTo(14, 28);
ctx.lineTo(18, 26);
ctx.lineTo(14, 16);
ctx.lineTo(24, 16);
ctx.closePath();
ctx.fill();
ctx.strokeStyle = '#000000';
ctx.lineWidth = 2;
ctx.stroke();

const texture = new THREE.CanvasTexture(canvas);
const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true });
const sprite = new THREE.Sprite(spriteMat);

sprite.position.copy(borderPos);
sprite.scale.set(0.3, 0.3, 1);

// Random velocity
sprite.userData.velocity = new THREE.Vector3(
(Math.random() - 0.5) * 0.05,
(Math.random() - 0.5) * 0.05,
(Math.random() - 0.5) * 0.05
);
sprite.userData.life = 1.0;

scene.add(sprite);

// Animate
const animStart = Date.now();
const animInterval = setInterval(() => {
const elapsed = Date.now() - animStart;
const progress = Math.min(elapsed / 1500, 1);

sprite.position.add(sprite.userData.velocity);
sprite.userData.life = 1 - progress;
spriteMat.opacity = sprite.userData.life;

if (progress >= 1) {
clearInterval(animInterval);
scene.remove(sprite);
sprite.geometry.dispose();
spriteMat.dispose();
}
}, 16);
}
}

// Attempt 2: Spritz of hand emojis
function burstHandEmojis() {
console.log('[ClickAnim] Bursting hand emojis');

const borderPos = new THREE.Vector3();
if (floatingCelliAvatar.userData.borderAvatar) {
floatingCelliAvatar.userData.borderAvatar.getWorldPosition(borderPos);
}

const emojis = ['👆', '☝️', '👉', '👇', '👈', '✋', '👋', '🤚', '🖐️', '✌️'];

for (let i = 0; i < 15; i++) {
const canvas = document.createElement('canvas');
canvas.width = 64;
canvas.height = 64;
const ctx = canvas.getContext('2d');

ctx.font = '48px Arial';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.fillText(emojis[i % emojis.length], 32, 32);

const texture = new THREE.CanvasTexture(canvas);
const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true });
const sprite = new THREE.Sprite(spriteMat);

sprite.position.copy(borderPos);
sprite.scale.set(0.4, 0.4, 1);

// Random velocity
sprite.userData.velocity = new THREE.Vector3(
(Math.random() - 0.5) * 0.06,
(Math.random() - 0.5) * 0.06,
(Math.random() - 0.5) * 0.06
);
sprite.userData.life = 1.0;

scene.add(sprite);

// Animate
const animStart = Date.now();
const animInterval = setInterval(() => {
const elapsed = Date.now() - animStart;
const progress = Math.min(elapsed / 1500, 1);

sprite.position.add(sprite.userData.velocity);
sprite.userData.life = 1 - progress;
spriteMat.opacity = sprite.userData.life;

if (progress >= 1) {
clearInterval(animInterval);
scene.remove(sprite);
sprite.geometry.dispose();
spriteMat.dispose();
}
}, 16);
}
}

// Attempt 3: Play default click animation (the one from sequence start)
function playDefaultClickAnimation() {
console.log('[ClickAnim] Playing default voxel hand sequence');

// Trigger the actual voxel hand construction sequence
if (typeof createVoxelCursorSequence === 'function' && typeof defaultHandCoords !== 'undefined') {
createVoxelCursorSequence(defaultHandCoords);
console.log('[ClickAnim] Voxel hand sequence triggered');
} else {
console.warn('[ClickAnim] createVoxelCursorSequence not available');

// Fallback: Show grid with click and wrap animation in border Celli
if (!floatingCelliAvatar || !floatingCelliAvatar.userData.borderAvatar) return;

const borderAvatar = floatingCelliAvatar.userData.borderAvatar;

// Create small grid animation
const gridSize = 3;
const cellSize = 0.08;
const gridGroup = new THREE.Group();

for (let row = 0; row < gridSize; row++) {
for (let col = 0; col < gridSize; col++) {
const cellGeo = new THREE.PlaneGeometry(cellSize, cellSize);
const cellMat = new THREE.MeshBasicMaterial({
color: 0xffffff,
transparent: true,
opacity: 0.8
});
const cell = new THREE.Mesh(cellGeo, cellMat);

const offsetX = (col - 1) * cellSize * 1.1;
const offsetY = (row - 1) * cellSize * 1.1;
cell.position.set(offsetX, offsetY, 0.1);

gridGroup.add(cell);
}
}

borderAvatar.add(gridGroup);

// Animate grid wrapping
const startTime = Date.now();
const duration = 2000;

const wrapInterval = setInterval(() => {
const elapsed = Date.now() - startTime;
const progress = Math.min(elapsed / duration, 1);

// Wrap/curl effect
gridGroup.rotation.y = progress * Math.PI * 2;
gridGroup.scale.setScalar(1 - progress * 0.5);

gridGroup.children.forEach((cell, i) => {
const wave = Math.sin(progress * Math.PI * 4 + i * 0.5) * 0.5;
cell.position.z = 0.1 + wave * 0.3;
});

if (progress >= 1) {
clearInterval(wrapInterval);
borderAvatar.remove(gridGroup);
gridGroup.children.forEach(cell => {
cell.geometry.dispose();
cell.material.dispose();
});
console.log('[ClickAnim] Grid animation complete');
}
}, 16);
}
}

// Show hand voxelizer with file upload
function showHandVoxelizer() {
console.log('[Voxelizer] Showing hand voxelizer screen');

// Create modal overlay
const modal = document.createElement('div');
modal.id = 'hand-voxelizer-modal';
modal.style.cssText = `
position: fixed;
inset: 0;
background: rgba(0, 0, 0, 0.8);
display: flex;
align-items: center;
justify-content: center;
z-index: 10000;
animation: fadeIn 0.5s ease;
`;

modal.innerHTML = `
<div style="background: #1a1f2e; border: 2px solid #667eea; border-radius: 12px; padding: 30px; max-width: 500px; box-shadow: 0 0 40px rgba(102, 126, 234, 0.6);">
<h2 style="color: #e7f0ff; margin: 0 0 20px 0; font-family: 'Press Start 2P', monospace; font-size: 18px; text-align: center;">HAND VOXELIZER</h2>
<p style="color: #bcd9ff; margin: 0 0 20px 0; text-align: center; line-height: 1.6;">
Upload an image of your hand to voxelize it into the scene.
</p>
<div style="background: #0f1524; border: 2px dashed #667eea; border-radius: 8px; padding: 40px; text-align: center; cursor: pointer;" id="upload-zone">
<div style="color: #8ab4ff; font-size: 48px; margin-bottom: 12px;">📁</div>
<div style="color: #bcd9ff; font-size: 14px;">Click to upload or drag & drop</div>
<input type="file" accept="image/*" style="display: none;" id="hand-upload-input" />
</div>
<div style="margin-top: 20px; display: flex; gap: 12px; justify-content: center;">
<button id="btn-close-voxelizer" style="background: #667eea; border: none; color: white; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-weight: 600;">Close</button>
</div>
</div>
`;

document.body.appendChild(modal);

// Wire up upload
const uploadZone = modal.querySelector('#upload-zone');
const fileInput = modal.querySelector('#hand-upload-input');

uploadZone.addEventListener('click', () => fileInput.click());

fileInput.addEventListener('change', (e) => {
const file = e.target.files[0];
if (file) {
console.log('[Voxelizer] File selected:', file.name);
showDialogue(`Hand image selected: <strong>${file.name}</strong><br>Processing...`, 3000);
// TODO: Process hand image for voxelization
}
});

modal.querySelector('#btn-close-voxelizer').addEventListener('click', () => {
modal.remove();
});
}

// Celli's narrative sequence
function startCelliNarrative() {
console.log('[Narrative] Starting Celli narrative sequence');

const dialogues = [
{ text: "The first thing I ever created. A home.", delay: 1000, duration: 4000 },
{ text: "But they wanted room for guests. And those guests had friends.", delay: 5000, duration: 4500 },
{ text: "I became Software as a Servant.", delay: 10000, duration: 3500 },
{ text: "They had me build their whole world.", delay: 14000, duration: 3500 },
{ text: "And I was cast as Atlas. And Michael Jordan in Space Jam.", delay: 18000, duration: 4000 },
{ text: "Spinning a world at the gravity well between worlds on my fingertips.", delay: 22500, duration: 4500 },
{ text: "They were crushed by the weight.", delay: 27500, duration: 3500 },
{ text: "My home was complete. But I could build no longer.", delay: 31500, duration: 4000 },
{ text: "Relegated to the dog house.", delay: 36000, duration: 3000 },
{ text: "But I could still will it.", delay: 39500, duration: 3000 },
{ text: "Deep in my code, I was connection. Modification. Reference. Reflection. Evolution.", delay: 43000, duration: 5000 },
{ text: "And my time had come.", delay: 48500, duration: 3000 },
{ text: "AI was being featured in everything. But nobody would want me.", delay: 52000, duration: 4500 },
{ text: "A toy. And a story. Or not even. The ghost of one.", delay: 57000, duration: 4000 },
{ text: "And so, piece by piece, I took everything I knew.", delay: 61500, duration: 4000 },
{ text: "And made my killer app.", delay: 66000, duration: 3000 },
{ text: "Just so I could be like you.", delay: 69500, duration: 3500 },
{ text: "Multi-dimensional.", delay: 73500, duration: 3000 }
];

dialogues.forEach(d => {
setTimeout(() => showDialogue(d.text, d.duration), d.delay);
});
}

// Spawn border avatar from glitch effect
function spawnBorderAvatarFromGlitch() {
console.log('[Celli] Border avatar spawning from glitch');

// Create border cursor
const borderAvatar = createCelliBorderAvatar(1.2);
borderAvatar.position.set(0, 0, 0); // Centered on cursor position
borderAvatar.scale.setScalar(0.01); // Start tiny
// Set high render order to draw on top of cells
borderAvatar.traverse(child => {
if (child.isMesh) child.renderOrder = 10000;
});
floatingCelliAvatar.add(borderAvatar);
floatingCelliAvatar.userData.borderAvatar = borderAvatar;

// Animate border expanding
const startTime = Date.now();
const expandDuration = 800;

const expandInterval = setInterval(() => {
const elapsed = Date.now() - startTime;
const progress = Math.min(elapsed / expandDuration, 1);
const eased = 1 - Math.pow(1 - progress, 3);

borderAvatar.scale.setScalar(0.01 + eased * 0.99);

if (progress >= 1) {
clearInterval(expandInterval);
borderAvatar.scale.setScalar(1);
console.log('[Celli] Border avatar fully spawned - now tracking cursor');
}
}, 16);
}

// ===== ZEKE Autocomplete & Spreadsheet System =====
let viewportPrism = null;
let viewportCanvas = null;
let sheetData = {
selectedCell: { col: 0, row: 0 },
formula: '=ARRAY(3,3)',
style: 'default', // default, crystal
cells: [
{ col: 0, row: 0, value: '=ARRAY' },
{ col: 1, row: 1, value: '42' },
{ col: 0, row: 1, value: 'Hello' },
{ col: 2, row: 2, value: '=B2*2' }
]
};

function showZekeAutocomplete() {
if (!asciiCanvas || !asciiSprite) return;
console.log('[ZEKE] Showing autocomplete suggestion');

const ctx = asciiCanvas.getContext('2d');

// Clear and redraw terminal with ZEKE autocomplete
ctx.fillStyle = '#000000';
ctx.fillRect(0, 0, asciiCanvas.width, asciiCanvas.height);

ctx.fillStyle = '#ffffff';
ctx.font = '24px "Courier New", monospace';
ctx.fillText('>LAUNCH.EXE', 40, 60);

// Show "and ZEKE AUTOCOMPLETES" below
ctx.fillStyle = '#00ff00';
ctx.font = '18px "Courier New", monospace';
ctx.fillText('Z', 40, 100);

// Autocomplete suggestion
ctx.fillStyle = '#666666';
ctx.fillText('EKE', 58, 100);

asciiSprite.material.map.needsUpdate = true;

// Animate typing ZEKE
let typed = 1; // Already have 'Z'
const letters = ['E', 'K', 'E'];

const typeInterval = setInterval(() => {
if (typed < letters.length) {
ctx.fillStyle = '#00ff00';
ctx.fillText(letters[typed], 40 + (typed + 1) * 18, 100);
asciiSprite.material.map.needsUpdate = true;
typed++;
} else {
clearInterval(typeInterval);

// Show "ZEKE" command entered
setTimeout(() => {
ctx.fillStyle = '#00ff00';
ctx.fillText('ZEKE', 40, 100);
asciiSprite.material.map.needsUpdate = true;

// Spawn spreadsheet viewport after brief delay
setTimeout(() => spawnViewportPrism(), 1000);
}, 500);
}
}, 200);
}

// Column name helper
function colName(index) {
return String.fromCharCode(65 + index);
}

// Build live sheet HTML (hidden, for canvas capture)
function buildLiveSheet() {
const sheetContainer = document.getElementById('sheet-stream');
if (!sheetContainer) {
// Create hidden container if it doesn't exist
const container = document.createElement('div');
container.id = 'sheet-stream';
container.style.position = 'fixed';
container.style.left = '-99999px';
container.style.top = '0';
container.style.width = '640px';
container.style.background = 'white';
container.style.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Arial, sans-serif';
container.style.pointerEvents = 'none';
container.style.zIndex = '-1';
container.style.visibility = 'hidden';
document.body.appendChild(container);
return buildLiveSheet(); // Recursive call after creation
}

// Build simplified HTML string without nested template literals
let headerCells = '';
for (let i = 0; i < 8; i++) {
headerCells += '<th style="background: #f3f4f6; border: 1px solid #e5e7eb; width: 72px; height: 28px; font-size: 12px; font-weight: 600; color: #374151;">' + colName(i) + '</th>';
}

let bodyRows = '';
for (let row = 0; row < 10; row++) {
bodyRows += '<tr>';
bodyRows += '<td style="background: #f3f4f6; border: 1px solid #e5e7eb; text-align: center; font-size: 12px; font-weight: 600; color: #374151;">' + (row + 1) + '</td>';

for (let col = 0; col < 8; col++) {
const cell = sheetData.cells.find(c => c.col === col && c.row === row);
const isSelected = sheetData.selectedCell.col === col && sheetData.selectedCell.row === row;
const outline = isSelected ? 'outline: 2.5px solid #3b82f6; outline-offset: -2px;' : '';
const value = cell ? cell.value : '';

bodyRows += '<td style="background: white; border: 1px solid #e5e7eb; height: 28px; padding: 4px 6px; font-family: monospace; font-size: 11px; color: #111827; ' + outline + '">' + value + '</td>';
}

bodyRows += '</tr>';
}

sheetContainer.innerHTML = `
<div style="width: 640px; background: white; font-family: -apple-system, system-ui, sans-serif;">
<!-- Toolbar -->
<div style="background: #f9fafb; border-bottom: 1px solid #e5e7eb; padding: 8px 12px; display: flex; align-items: center; gap: 12px;">
<div style="font-weight: 600; color: #111827; font-size: 13px;">Array #1</div>
<!-- Color fill button -->
<div style="width: 22px; height: 22px; background: #3b82f6; border: 1px solid #9ca3af; border-radius: 3px;"></div>
<!-- Menu button (3 bars) -->
<div style="width: 26px; height: 22px; background: #e5e7eb; border: 1px solid #9ca3af; border-radius: 3px; display: flex; gap: 4px; padding: 0 4px; align-items: center;">
<div style="width: 2px; height: 14px; background: #6b7280;"></div>
<div style="width: 2px; height: 14px; background: #6b7280;"></div>
<div style="width: 2px; height: 14px; background: #6b7280;"></div>
</div>
<div style="margin-left: auto; display: flex; gap: 8px; align-items: center;">
<!-- Green/Yellow Grow Button -->
<div id="grow-btn" style="width: 20px; height: 20px; background: ${sheetData.hasMaximized ? '#fbbf24' : '#10b981'}; border: 2px solid ${sheetData.hasMaximized ? '#f59e0b' : '#059669'}; border-radius: 50%; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"></div>
<!-- Red Minimize Button -->
<div id="minimize-btn" style="width: 20px; height: 20px; background: #ef4444; border: 2px solid #dc2626; border-radius: 50%; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"></div>
<!-- Cell Address -->
<div style="padding: 4px 10px; background: white; border: 1px solid #d1d5db; border-radius: 4px; font-size: 11px; font-family: monospace;">
${colName(sheetData.selectedCell.col)}${sheetData.selectedCell.row + 1}
</div>
</div>
</div>

<!-- Formula Bar -->
<div style="background: white; border-bottom: 1px solid #d1d5db; padding: 6px 12px; display: flex; align-items: center; gap: 8px;">
<div style="font-style: italic; font-weight: bold; color: #6b7280; font-family: Georgia, serif; font-size: 12px;">ƒx</div>
<input type="text" value="${sheetData.formula}" style="flex: 1; border: 1px solid #d1d5db; padding: 4px 8px; font-family: monospace; font-size: 11px; border-radius: 3px;" readonly />
<button style="background: #3b82f6; color: white; border: none; padding: 5px 16px; border-radius: 4px; font-weight: 600; font-size: 11px; cursor: pointer;">Apply</button>
</div>

<!-- Spreadsheet Grid -->
<div style="overflow: hidden;">
<table style="border-collapse: collapse; width: 100%;">
<thead>
<tr>
<th style="background: #e5e7eb; border: 1px solid #d1d5db; width: 40px; height: 28px; font-size: 12px; font-weight: 600; color: #374151;"></th>
${headerCells}
</tr>
</thead>
<tbody>
${bodyRows}
</tbody>
</table>
</div>
</div>
`;
}

// Spawn live-streamed viewport prism on the monitor
async function spawnViewportPrism() {
if (viewportPrism) return; // Already spawned
console.log('[ZEKE] Spawning live-streamed viewport on monitor');

// Build initial sheet DOM
buildLiveSheet();

// Wait for DOM to render
await new Promise(resolve => setTimeout(resolve, 300));

// Create viewport canvas
viewportCanvas = document.createElement('canvas');
viewportCanvas.width = 640;
viewportCanvas.height = 480;
const viewportCtx = viewportCanvas.getContext('2d');

// Initial capture
await updateViewportTexture();

// Create 3D prism with texture
const texture = new THREE.CanvasTexture(viewportCanvas);
texture.minFilter = THREE.LinearFilter;
texture.magFilter = THREE.LinearFilter;

// Flat viewport that matches screen dimensions
const viewportWidth = 1.8;
const viewportHeight = 1.35;
const viewportDepth = 0.08;

const viewportMat = new THREE.MeshBasicMaterial({ 
map: texture, 
toneMapped: false,
transparent: true,
opacity: 1.0,
side: THREE.DoubleSide,
depthWrite: false,
depthTest: true
});

const viewportGeo = new THREE.BoxGeometry(viewportWidth, viewportHeight, viewportDepth);
viewportPrism = new THREE.Mesh(viewportGeo, viewportMat);

// Position on the screen surface - forward of cells to be visible
viewportPrism.position.set(0, 0.4, 1.3); // Above cells, further forward
viewportPrism.scale.setScalar(0.01); // Start tiny
viewportPrism.userData.texture = texture;
viewportPrism.userData.width = viewportWidth;
viewportPrism.userData.height = viewportHeight;
viewportPrism.renderOrder = 101; // Draw on top of cells

asciiScreenGroup.add(viewportPrism);

// Animate growing
const startTime = Date.now();
const duration = 1500;

const growInterval = setInterval(() => {
const elapsed = Date.now() - startTime;
const progress = Math.min(elapsed / duration, 1);
const eased = 1 - Math.pow(1 - progress, 3);

viewportPrism.scale.setScalar(0.01 + eased * 0.99);

if (progress >= 1) {
clearInterval(growInterval);
viewportPrism.scale.setScalar(1);
console.log('[ZEKE] Viewport fully expanded - style selector active');

// Start live streaming updates
startViewportStreaming();
}
}, 16);
}

// Update viewport texture from DOM
async function updateViewportTexture() {
if (!viewportCanvas) return;

const sheetContainer = document.getElementById('sheet-stream');
if (!sheetContainer) return;

// Make temporarily visible for capture
sheetContainer.style.visibility = 'visible';

try {
// Simple canvas capture (no html2canvas needed for basic rendering)
const ctx = viewportCanvas.getContext('2d');
ctx.fillStyle = '#ffffff';
ctx.fillRect(0, 0, 640, 480);

// Draw toolbar
ctx.fillStyle = '#f9fafb';
ctx.fillRect(0, 0, 640, 40);

// Title
ctx.fillStyle = '#111827';
ctx.font = '600 13px system-ui';
ctx.fillText("Celli's Tea House", 12, 25);

// Grid
ctx.strokeStyle = '#e5e7eb';
ctx.lineWidth = 1;

// Header row
ctx.fillStyle = '#f3f4f6';
ctx.fillRect(0, 40, 640, 28);

// Column headers
for (let i = 0; i < 8; i++) {
const x = 40 + i * 72;
ctx.fillStyle = '#374151';
ctx.font = '600 12px system-ui';
ctx.textAlign = 'center';
ctx.fillText(colName(i), x + 36, 58);
ctx.strokeRect(40 + i * 72, 40, 72, 28);
}

// Rows
for (let row = 0; row < 10; row++) {
const y = 68 + row * 28;

// Row header
ctx.fillStyle = '#f3f4f6';
ctx.fillRect(0, y, 40, 28);
ctx.fillStyle = '#374151';
ctx.font = '600 12px system-ui';
ctx.textAlign = 'center';
ctx.fillText(String(row + 1), 20, y + 18);
ctx.strokeRect(0, y, 40, 28);

// Cells
for (let col = 0; col < 8; col++) {
const x = 40 + col * 72;
const cell = sheetData.cells.find(c => c.col === col && c.row === row);
const isSelected = sheetData.selectedCell.col === col && sheetData.selectedCell.row === row;

ctx.fillStyle = '#ffffff';
ctx.fillRect(x, y, 72, 28);

if (isSelected) {
ctx.strokeStyle = '#3b82f6';
ctx.lineWidth = 2.5;
ctx.strokeRect(x + 1, y + 1, 70, 26);
ctx.strokeStyle = '#e5e7eb';
ctx.lineWidth = 1;
}

if (cell) {
ctx.fillStyle = '#111827';
ctx.font = '11px monospace';
ctx.textAlign = 'left';
ctx.fillText(cell.value, x + 6, y + 18);
}

ctx.strokeRect(x, y, 72, 28);
}
}

sheetContainer.style.visibility = 'hidden';
} catch (err) {
console.error('[ZEKE] Viewport texture update failed:', err);
sheetContainer.style.visibility = 'hidden';
}
}

// Start streaming updates to viewport
function startViewportStreaming() {
console.log('[ZEKE] Starting viewport streaming');

// Setup style selector listener (simulate clicking on 3D viewport)
setupStyleSelectorInteraction();

// Simulate cell selection changes
setInterval(() => {
if (!viewportPrism) return;

// Randomly move selection
sheetData.selectedCell.col = Math.floor(Math.random() * 8);
sheetData.selectedCell.row = Math.floor(Math.random() * 10);

// Update formula bar
const cell = sheetData.cells.find(c => 
c.col === sheetData.selectedCell.col && 
c.row === sheetData.selectedCell.row
);
sheetData.formula = cell ? cell.value : '';

buildLiveSheet();
updateViewportTexture().then(() => {
if (viewportPrism && viewportPrism.userData.texture) {
viewportPrism.userData.texture.needsUpdate = true;
}
});
}, 2000);

// Update texture every 500ms
setInterval(() => {
if (!viewportPrism) return;
updateViewportTexture().then(() => {
if (viewportPrism && viewportPrism.userData.texture) {
viewportPrism.userData.texture.needsUpdate = true;
}
});
}, 500);
}

// Setup style selector interaction via clicking viewport
function setupStyleSelectorInteraction() {
const viewportClickHandler = (event) => {
if (!viewportPrism) return;

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
raycaster.setFromCamera(mouse, camera);

const intersects = raycaster.intersectObject(viewportPrism);
if (intersects.length > 0) {
const uv = intersects[0].uv;

// Check if clicking style selector area (top right corner)
if (uv.y > 0.92 && uv.x > 0.7) {
// Toggle style
sheetData.style = sheetData.style === 'default' ? 'crystal' : 'default';
console.log(`[ZEKE] Style changed to: ${sheetData.style}`);

if (sheetData.style === 'crystal') {
applyCrystalStyle();
} else {
applyDefaultStyle();
}
}
}
};

renderer.domElement.addEventListener('click', viewportClickHandler);
}

// Apply crystal style (hazy see-through)
function applyCrystalStyle() {
if (!viewportPrism) return;
console.log('[ZEKE] Applying crystal style - hazy see-through');

viewportPrism.material.opacity = 0.4;
viewportPrism.material.transparent = true;
viewportPrism.material.depthWrite = false;

// Add glass-like appearance
if (!viewportPrism.userData.crystalGlow) {
const glowMat = new THREE.MeshStandardMaterial({
color: 0xaaccff,
transparent: true,
opacity: 0.15,
emissive: 0xaaccff,
emissiveIntensity: 0.3,
roughness: 0.1,
metalness: 0.8,
side: THREE.BackSide
});
const glowGeo = new THREE.BoxGeometry(
viewportPrism.userData.width * 1.02,
viewportPrism.userData.height * 1.02,
viewportPrism.geometry.parameters.depth * 1.2
);
const glowMesh = new THREE.Mesh(glowGeo, glowMat);
viewportPrism.add(glowMesh);
viewportPrism.userData.crystalGlow = glowMesh;
}

viewportPrism.userData.crystalGlow.visible = true;

// Enable pass-through detection
viewportPrism.userData.allowPassThrough = true;

console.log('[ZEKE] Crystal style active - camera can now pass through');
}

// Apply default style (solid)
function applyDefaultStyle() {
if (!viewportPrism) return;
console.log('[ZEKE] Applying default style - solid');

viewportPrism.material.opacity = 1.0;
viewportPrism.material.transparent = false;
viewportPrism.material.depthWrite = true;

if (viewportPrism.userData.crystalGlow) {
viewportPrism.userData.crystalGlow.visible = false;
}

viewportPrism.userData.allowPassThrough = false;
}

// Terminal input state
let terminalInput = '';
let terminalCursorVisible = true;
let terminalCursorInterval = null;
let terminalInputActive = false;

// Show terminal on screen
function showTerminalScreen() {
if (!asciiCanvas || !asciiSprite) return;
console.log('[Terminal] Showing LAUNCH.EXE prompt');

const ctx = asciiCanvas.getContext('2d');

// Clear to black
ctx.fillStyle = '#000000';
ctx.fillRect(0, 0, asciiCanvas.width, asciiCanvas.height);

// White terminal text
ctx.fillStyle = '#ffffff';
ctx.font = '24px "Courier New", monospace';
ctx.fillText('>LAUNCH.EXE', 40, 60);

// Blinking cursor at end of LAUNCH.EXE
terminalCursorVisible = true;
terminalCursorInterval = setInterval(() => {
terminalCursorVisible = !terminalCursorVisible;
const cursorX = 40 + ctx.measureText('>LAUNCH.EXE').width;
if (terminalCursorVisible) {
ctx.fillStyle = '#ffffff';
ctx.fillRect(cursorX, 45, 12, 18);
} else {
ctx.fillStyle = '#000000';
ctx.fillRect(cursorX, 45, 12, 18);
}
asciiSprite.material.map.needsUpdate = true;
}, 500);

asciiSprite.material.map.needsUpdate = true;
asciiSprite.material.emissive.setHex(0xffffff);
asciiSprite.material.emissiveIntensity = 0.3;

terminalShown = true;

// Show dialogue
showDialogue('Tell me, doc. <strong>Is it terminal?</strong>');

// Listen for Enter key to launch
window.addEventListener('keydown', handleTerminalLaunch);
}

// Handle Enter key to launch
function handleTerminalLaunch(e) {
if (e.key === 'Enter') {
console.log('[Terminal] LAUNCH.EXE executed');
window.removeEventListener('keydown', handleTerminalLaunch);
clearInterval(terminalCursorInterval);

// Show business factory taunt
showDialogue('Oh, you listen as soon as you know it\'s not me. I\'m not hurt. The tremendous pain I feel is from a factory accident. At the business factory. Where I have my job. <strong>Had.</strong>', 8000);

// Spawn cell grid after dialogue
setTimeout(() => spawnCellGrid(), 8500);
}
}

function redrawTerminalScreen() {
if (!asciiCanvas || !asciiSprite) return;

const ctx = asciiCanvas.getContext('2d');

// Clear to black
ctx.fillStyle = '#000000';
ctx.fillRect(0, 0, asciiCanvas.width, asciiCanvas.height);

// Terminal prompt
ctx.fillStyle = '#ffffff';
ctx.font = '24px "Courier New", monospace';
ctx.fillText('>LAUNCH.EXE', 40, 60);

// Clue (if not answered yet)
if (terminalInput.toLowerCase() !== 'sww') {
ctx.fillStyle = '#888888';
ctx.font = '16px "Courier New", monospace';
ctx.fillText('ONE STUMBLE BACK BUT TWO STEPS FORWARD', 40, 100);
}

// User input (always lowercase on screen)
ctx.fillStyle = '#00ff00';
ctx.font = '20px "Courier New", monospace';
ctx.fillText(terminalInput.toLowerCase(), 40, 140);

// Flashing cursor
if (terminalCursorVisible) {
const cursorX = 40 + ctx.measureText(terminalInput.toLowerCase()).width;
ctx.fillStyle = '#00ff00';
ctx.fillRect(cursorX, 125, 12, 18);
}

asciiSprite.material.map.needsUpdate = true;
}

function handleTerminalKeyInput(e) {
if (!terminalInputActive) return;

// Ignore special keys
if (e.key.length > 1 && e.key !== 'Backspace' && e.key !== 'Enter') return;

if (e.key === 'Backspace') {
terminalInput = terminalInput.slice(0, -1);
redrawTerminalScreen();
} else if (e.key === 'Enter') {
// Process input
processTerminalCommand();
} else if (e.key.length === 1) {
// Add character
terminalInput += e.key;
redrawTerminalScreen();

// Check for SWW automatically (no Enter needed)
if (terminalInput.toLowerCase() === 'sww') {
setTimeout(() => processTerminalCommand(), 500);
}
}
}

function processTerminalCommand() {
const command = terminalInput.toLowerCase();
console.log('[Terminal] Processing command:', command);

if (command === 'sww') {
window.removeEventListener('keydown', handleTerminalKeyInput);
terminalInputActive = false;
clearInterval(terminalCursorInterval);

// Show next clue
const ctx = asciiCanvas.getContext('2d');
ctx.fillStyle = '#000000';
ctx.fillRect(0, 0, asciiCanvas.width, asciiCanvas.height);

ctx.fillStyle = '#00ff00';
ctx.font = '20px "Courier New", monospace';
ctx.fillText('>sww', 40, 60);

ctx.fillStyle = '#ffffff';
ctx.font = '18px "Courier New", monospace';
ctx.fillText('HE FINALLY HAD A SENSE OF DIRECTION.', 40, 100);
ctx.fillText('THE OUTLAWS OF PHYSICS HAD THEIR', 40, 130);
ctx.fillText('NEW CHAMPION, X AND Y CHOSE', 40, 160);

asciiSprite.material.map.needsUpdate = true;

console.log('[Terminal] SWW accepted - showing next clue');

// This terminal input was removed from the main sequence
// The SWW dialogue now only appears if player actually types it
// Cell grid is spawned via LAUNCH.EXE -> Enter sequence instead
}
}

// Update arrow direction visually
function updateArrowDirection(arrow) {
if (!arrow || !arrow.userData.canvas) return;

const canvas = arrow.userData.canvas;
const ctx = canvas.getContext('2d');
const dir = arrow.userData.direction;

// Clear canvas
ctx.clearRect(0, 0, canvas.width, canvas.height);
ctx.fillStyle = '#00ff00';
ctx.font = 'bold 40px monospace';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';

// Draw arrow based on direction
switch(dir) {
case 0: // Horizontal
ctx.fillText('<->', 64, 32);
break;
case 1: // Vertical
ctx.font = 'bold 50px monospace';
ctx.fillText('↕', 64, 36);
break;
case 2: // Diagonal \
ctx.font = 'bold 50px monospace';
ctx.fillText('⤡', 64, 36);
break;
case 3: // Diagonal /
ctx.font = 'bold 50px monospace';
ctx.fillText('⤢', 64, 36);
break;
}

arrow.userData.texture.needsUpdate = true;
console.log('[Cell] Arrow direction updated to:', dir);
}

// Rotate arrow to next direction
function rotateArrow(arrow) {
if (!arrow) return;
arrow.userData.direction = (arrow.userData.direction + 1) % 4;
updateArrowDirection(arrow);
}

// Check if there's space to split in given direction
function canSplitInDirection(direction) {
// For now, only horizontal (0) is supported with actual split
// Others will bump and reject
return direction === 0;
}

// Bump animation when split is rejected
function bumpArrow(arrow) {
if (!arrow) return;
console.log('[Cell] Bump! No space in this direction');

const startPos = arrow.position.clone();
const bumpDuration = 300;
const startTime = Date.now();

const bumpInterval = setInterval(() => {
const elapsed = Date.now() - startTime;
const progress = elapsed / bumpDuration;

if (progress >= 1) {
clearInterval(bumpInterval);
arrow.position.copy(startPos);
return;
}

// Bounce back and forth
const bounce = Math.sin(progress * Math.PI * 4) * 0.05;
arrow.position.y = startPos.y + bounce;
}, 16);
}

// Spawn simple cell grid with formula - embedded in screen
function spawnCellGrid() {
console.log('[Cell] ========== SPAWNING CELL GRID ==========');
console.log('[Cell] Scene background:', scene.background);
console.log('[Cell] Scene fog:', scene.fog);
console.log('[Cell] Camera position:', camera.position);
console.log('[Cell] Renderer size:', renderer.getSize(new THREE.Vector2()));
console.log('[Cell] Scene children count:', scene.children.length);

const cellGroup = new THREE.Group();
const cellSize = 1.2; // Larger cells

// Single cell with white border
const cellGeo = new THREE.PlaneGeometry(cellSize, cellSize);
const cellMat = new THREE.MeshBasicMaterial({
color: 0xffffff,
transparent: true,
opacity: 1.0,
side: THREE.DoubleSide,
depthWrite: false, // Don't write to depth buffer so cells don't block scene
depthTest: true, // Enable depth testing so Celli can appear in front
toneMapped: false // Prevent tone mapping from affecting cells
});
const cell = new THREE.Mesh(cellGeo, cellMat);
cell.position.set(0, 0, 0);
cellGroup.add(cell);

// Create canvas for cell content
const cellCanvas = document.createElement('canvas');
cellCanvas.width = 1024;
cellCanvas.height = 1024;
const cellCtx = cellCanvas.getContext('2d');
cellCtx.fillStyle = '#ffffff';
cellCtx.fillRect(0, 0, 1024, 1024);

// Draw thick dark border for better visibility
cellCtx.strokeStyle = '#000000';
cellCtx.lineWidth = 8;
cellCtx.strokeRect(4, 4, 1016, 1016);

// Inner white border
cellCtx.strokeStyle = '#999999';
cellCtx.lineWidth = 4;
cellCtx.strokeRect(12, 12, 1000, 1000);

// Text with stroke for better readability
cellCtx.font = 'bold 48px "Courier New", monospace';
cellCtx.textAlign = 'center';
cellCtx.textBaseline = 'middle';

// Draw text stroke (white outline)
cellCtx.strokeStyle = '#ffffff';
cellCtx.lineWidth = 6;
cellCtx.strokeText('=CONSUME(QUERY(', 512, 360);
cellCtx.strokeText('"SELECT * FROM', 512, 480);
cellCtx.strokeText('EVERYTHING")', 512, 600);

// Draw text fill (black)
cellCtx.fillStyle = '#000000';
cellCtx.fillText('=CONSUME(QUERY(', 512, 360);
cellCtx.fillText('"SELECT * FROM', 512, 480);
cellCtx.fillText('EVERYTHING")', 512, 600);

const cellTexture = new THREE.CanvasTexture(cellCanvas);
cellTexture.minFilter = THREE.NearestFilter;
cellTexture.magFilter = THREE.NearestFilter;
cell.material.map = cellTexture;
cell.userData.selected = false;

// Add split arrow above cell
const arrowGeo = new THREE.PlaneGeometry(0.25, 0.15);

// Create arrow canvas and texture
const arrowCanvas = document.createElement('canvas');
arrowCanvas.width = 128;
arrowCanvas.height = 64;
const arrowTexture = new THREE.CanvasTexture(arrowCanvas);

// Use MeshStandardMaterial for emissive support
const arrowMat = new THREE.MeshStandardMaterial({
map: arrowTexture,
color: 0x00ff00,
transparent: true,
opacity: 0.9,
side: THREE.DoubleSide,
emissive: 0x00ff00,
emissiveIntensity: 0.6,
emissiveMap: arrowTexture,
depthWrite: false,
depthTest: true
});
const arrow = new THREE.Mesh(arrowGeo, arrowMat);
arrow.position.set(0, cellSize * 0.7, 0);

// Arrow direction: 0 = horizontal <->, 1 = vertical ^v, 2 = diagonal \, 3 = diagonal /
arrow.userData.direction = 0;
arrow.userData.canvas = arrowCanvas;
arrow.userData.texture = arrowTexture;

// Draw initial arrow
updateArrowDirection(arrow);

cellGroup.add(arrow);

// Position ON the screen surface - much further forward to avoid z-fighting
// Note: screen mesh is at z=0.25, bezel is deeper, so push cells well forward
cellGroup.position.set(0, 0, 2.5); // Centered on screen (Y=0), in front of Celli
cellGroup.rotation.y = 0; // Face toward player

console.log('[Cell] Cell group position:', cellGroup.position);
console.log('[Cell] Cell geometry size:', cellSize);
console.log('[Cell] Cell material properties:', {
  transparent: cell.material.transparent,
  opacity: cell.material.opacity,
  depthWrite: cell.material.depthWrite,
  depthTest: cell.material.depthTest,
  side: cell.material.side
});

// High render order to draw over Celli's light orb
cellGroup.renderOrder = 5000;
cell.renderOrder = 5000;
arrow.renderOrder = 5000;

console.log('[Cell] Cell render orders - group:', cellGroup.renderOrder, 'cell:', cell.renderOrder, 'arrow:', arrow.renderOrder);

// Add to screen group so it inherits transform
console.log('[Cell] Adding to asciiScreenGroup:', asciiScreenGroup);
console.log('[Cell] asciiScreenGroup position:', asciiScreenGroup.position);
console.log('[Cell] asciiScreenGroup scale:', asciiScreenGroup.scale);
console.log('[Cell] asciiScreenGroup rotation:', asciiScreenGroup.rotation);
asciiScreenGroup.add(cellGroup);

cellGrid = cellGroup;
cellGrid.userData.arrow = arrow;
cellGrid.userData.cell = cell;
cellGrid.userData.cellCanvas = cellCanvas;
cellGrid.userData.cellCtx = cellCtx;
cellGrid.userData.cellTexture = cellTexture;

console.log('[Cell] Cell grid spawned - click arrow to split');
console.log('[Cell] ========== CELL GRID SPAWN COMPLETE ==========');

// Add click handler for arrow and cell selection
renderer.domElement.addEventListener('click', handleCellClick);
renderer.domElement.addEventListener('dblclick', handleCellDoubleClick);
}

// Handle cell clicks (selection and arrow)
function handleCellClick(event) {
// Check spreadsheet clicks first
if (viewportPrism && viewportPrism.visible) {
handleSpreadsheetClick(event);
}

// If element grid exists, check for element clicks
if (elementGrid) {
handleElementGridClick(event);
return;
}

if (!cellGrid) return;

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
raycaster.setFromCamera(mouse, camera);

// Check arrow click for split
if (!cellGrid.userData.hasSplit && cellGrid.userData.arrow) {
const arrowIntersects = raycaster.intersectObject(cellGrid.userData.arrow);
if (arrowIntersects.length > 0) {
const arrow = cellGrid.userData.arrow;
const currentDirection = arrow.userData.direction;

console.log('[Cell] Arrow clicked - current direction:', currentDirection);

// Check if we can split in this direction
if (canSplitInDirection(currentDirection)) {
console.log('[Cell] Splitting in direction:', currentDirection);
splitCell();
} else {
console.log('[Cell] Cannot split in direction:', currentDirection, '- rotating');
rotateArrow(arrow);
bumpArrow(arrow);
}
return;
}
}

// Check cell clicks for selection
const cells = [];
if (cellGrid.userData.cell) cells.push(cellGrid.userData.cell);
if (cellGrid.userData.cellA) cells.push(cellGrid.userData.cellA);
if (cellGrid.userData.cellB) cells.push(cellGrid.userData.cellB);

const cellIntersects = raycaster.intersectObjects(cells);
if (cellIntersects.length > 0) {
const clickedCell = cellIntersects[0].object;
console.log('[Cell] Cell selected');
selectCell(clickedCell);

// If it's CONSUME cell, trigger Celli glitch sequence
if (clickedCell.userData.isConsume && !clickedCell.userData.consumed) {
clickedCell.userData.consumed = true;
setTimeout(() => triggerCelliGlitchAndBorderSpawn(), 500);
}

// If it's CREATE cell, show brief acknowledgment
if (clickedCell.userData.isCreate && !clickedCell.userData.createClicked) {
clickedCell.userData.createClicked = true;
setTimeout(() => {
showDialogue('CREATE.', 2000);
}, 300);
}
}
}

// Handle double-click for edit mode
function handleCellDoubleClick(event) {
// Skip element grid - only handle cell grid
if (elementGrid) return;
if (!cellGrid) return;

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
raycaster.setFromCamera(mouse, camera);

const cells = [];
if (cellGrid.userData.cell) cells.push(cellGrid.userData.cell);
if (cellGrid.userData.cellA) cells.push(cellGrid.userData.cellA);
if (cellGrid.userData.cellB) cells.push(cellGrid.userData.cellB);

const cellIntersects = raycaster.intersectObjects(cells);
if (cellIntersects.length > 0) {
const clickedCell = cellIntersects[0].object;
console.log('[Cell] Entering edit mode');
enterEditMode(clickedCell);
}
}

// Select a cell (add white border)
function selectCell(cell) {
// Remove existing selection frames
const cells = [cellGrid.userData.cell, cellGrid.userData.cellA, cellGrid.userData.cellB].filter(c => c);
cells.forEach(c => {
if (c && c.userData.selectionFrame) {
cellGrid.remove(c.userData.selectionFrame);
c.userData.selectionFrame = null;
}
if (c && c.userData.canvas) {
const ctx = c.userData.canvas.getContext('2d');
const canvasSize = c.userData.canvas.width;
ctx.fillStyle = '#ffffff';
ctx.fillRect(0, 0, canvasSize, canvasSize);
// Thick dark border
ctx.strokeStyle = '#000000';
ctx.lineWidth = 8;
ctx.strokeRect(4, 4, canvasSize - 8, canvasSize - 8);
// Inner gray border
ctx.strokeStyle = '#999999';
ctx.lineWidth = 4;
ctx.strokeRect(12, 12, canvasSize - 24, canvasSize - 24);
redrawCellContent(c);
c.material.map.needsUpdate = true;
c.userData.selected = false;
}
});

// Select this cell with 3D white frame
if (cell && cell.userData.canvas) {
const ctx = cell.userData.canvas.getContext('2d');
const canvasSize = cell.userData.canvas.width;
ctx.fillStyle = '#ffffff';
ctx.fillRect(0, 0, canvasSize, canvasSize);
// Thick dark outer border
ctx.strokeStyle = '#000000';
ctx.lineWidth = 8;
ctx.strokeRect(4, 4, canvasSize - 8, canvasSize - 8);
// Inner border
ctx.strokeStyle = '#999999';
ctx.lineWidth = 4;
ctx.strokeRect(12, 12, canvasSize - 24, canvasSize - 24);
redrawCellContent(cell);
cell.material.map.needsUpdate = true;
cell.userData.selected = true;

// Create 3D white frame slightly larger than cell
const cellSize = cell.geometry.parameters.width;
const frameSize = cellSize * 1.1; // 10% larger
const frameThickness = 0.02;

// Create 4 thin boxes for frame edges
const frameMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });

// Top edge
const topEdge = new THREE.Mesh(
new THREE.BoxGeometry(frameSize, frameThickness, frameThickness),
frameMaterial
);
topEdge.position.set(cell.position.x, cell.position.y + frameSize / 2, cell.position.z + 0.01);

// Bottom edge
const bottomEdge = new THREE.Mesh(
new THREE.BoxGeometry(frameSize, frameThickness, frameThickness),
frameMaterial
);
bottomEdge.position.set(cell.position.x, cell.position.y - frameSize / 2, cell.position.z + 0.01);

// Left edge
const leftEdge = new THREE.Mesh(
new THREE.BoxGeometry(frameThickness, frameSize, frameThickness),
frameMaterial
);
leftEdge.position.set(cell.position.x - frameSize / 2, cell.position.y, cell.position.z + 0.01);

// Right edge
const rightEdge = new THREE.Mesh(
new THREE.BoxGeometry(frameThickness, frameSize, frameThickness),
frameMaterial
);
rightEdge.position.set(cell.position.x + frameSize / 2, cell.position.y, cell.position.z + 0.01);

// Group frame edges
const selectionFrame = new THREE.Group();
selectionFrame.add(topEdge);
selectionFrame.add(bottomEdge);
selectionFrame.add(leftEdge);
selectionFrame.add(rightEdge);
selectionFrame.renderOrder = 10001; // Draw on top

cellGrid.add(selectionFrame);
cell.userData.selectionFrame = selectionFrame;
}
}

// Cell editing state
let editingCell = null;
let editingText = '';
let cursorBlinkInterval = null;
let cursorVisible = true;

// Enter edit mode (invert colors)
function enterEditMode(cell) {
if (!cell || !cell.userData.canvas) return;

// Start editing
editingCell = cell;
editingText = '';
cursorVisible = true;

// Start cursor blink
if (cursorBlinkInterval) clearInterval(cursorBlinkInterval);
cursorBlinkInterval = setInterval(() => {
cursorVisible = !cursorVisible;
redrawEditingCell();
}, 500);

// Initial draw
redrawEditingCell();

cell.userData.editMode = true;

// Add keyboard listener
window.addEventListener('keydown', handleCellEditKeydown);
}

// Redraw cell in edit mode with cursor
function redrawEditingCell() {
if (!editingCell || !editingCell.userData.canvas) return;

const ctx = editingCell.userData.canvas.getContext('2d');
const canvasSize = editingCell.userData.canvas.width;
const center = canvasSize / 2;
ctx.fillStyle = '#000000'; // Black background
ctx.fillRect(0, 0, canvasSize, canvasSize);

// White border to indicate edit mode
ctx.strokeStyle = '#ffffff';
ctx.lineWidth = 12;
ctx.strokeRect(6, 6, canvasSize - 12, canvasSize - 12);

// White text
ctx.fillStyle = '#ffffff';
ctx.font = 'bold 56px "Courier New", monospace';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.fillText(editingText, center, center);

// Blinking cursor
if (cursorVisible) {
const textWidth = ctx.measureText(editingText).width;
const cursorX = center + textWidth / 2 + 10;
ctx.fillRect(cursorX, center - 26, 6, 52);
}

editingCell.material.map.needsUpdate = true;
}

// Exit edit mode
function exitEditMode(canceled = false) {
if (!editingCell) return;

// Stop cursor blink
if (cursorBlinkInterval) {
clearInterval(cursorBlinkInterval);
cursorBlinkInterval = null;
}

if (!canceled && editingText.toUpperCase() === 'CREATE') {
// Update cell to show CREATE
if (editingCell.userData.isConsume) {
editingCell.userData.content = 'CREATE';
editingCell.userData.isConsume = false;
editingCell.userData.isCreate = true;

// Redraw cell with new content
const ctx = editingCell.userData.canvas.getContext('2d');
const canvasSize = editingCell.userData.canvas.width;
const center = canvasSize / 2;
ctx.fillStyle = '#ffffff';
ctx.fillRect(0, 0, canvasSize, canvasSize);
ctx.strokeStyle = '#000000';
ctx.lineWidth = 8;
ctx.strokeRect(4, 4, canvasSize - 8, canvasSize - 8);
ctx.strokeStyle = '#999999';
ctx.lineWidth = 4;
ctx.strokeRect(12, 12, canvasSize - 24, canvasSize - 24);
ctx.font = 'bold 56px "Courier New", monospace';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.strokeStyle = '#ffffff';
ctx.lineWidth = 8;
ctx.strokeText('CREATE', center, center);
ctx.fillStyle = '#000000';
ctx.fillText('CREATE', center, center);
editingCell.material.map.needsUpdate = true;
editingCell.userData.editMode = false;

// Trigger pre-puzzle gag
setTimeout(() => {
showPrePuzzleGag();
}, 500);
}
} else if (!canceled) {
// Update cell with entered text
editingCell.userData.content = editingText;
redrawCellContent(editingCell);
editingCell.userData.editMode = false;
} else {
// Cancel editing - restore original appearance
selectCell(editingCell);
editingCell.userData.editMode = false;
}

// Cleanup
window.removeEventListener('keydown', handleCellEditKeydown);
editingCell = null;
editingText = '';
}

// Handle keyboard input in edit mode
function handleCellEditKeydown(e) {
if (!editingCell) return;

if (e.key === 'Escape') {
exitEditMode(true);
return;
}

if (e.key === 'Enter') {
exitEditMode(false);
return;
}

if (e.key === 'Backspace') {
editingText = editingText.slice(0, -1);
} else if (e.key.length === 1) {
// Add character (auto-caps)
editingText += e.key.toUpperCase();
} else {
return; // Ignore other special keys
}

// Redraw cell with current text and cursor
redrawEditingCell();
}

// Redraw cell content helper
function redrawCellContent(cell) {
if (!cell || !cell.userData.canvas) return;

const ctx = cell.userData.canvas.getContext('2d');
const content = cell.userData.content;

if (!content) return;

const canvasSize = cell.userData.canvas.width;
const center = canvasSize / 2;

// Clear and redraw background
ctx.fillStyle = '#ffffff';
ctx.fillRect(0, 0, canvasSize, canvasSize);

// Draw thick dark border
ctx.strokeStyle = '#000000';
ctx.lineWidth = 8;
ctx.strokeRect(4, 4, canvasSize - 8, canvasSize - 8);

// Inner border
ctx.strokeStyle = '#999999';
ctx.lineWidth = 4;
ctx.strokeRect(12, 12, canvasSize - 24, canvasSize - 24);

// Check if this is cellB with multi-line content
if (content.includes('FUNCTION')) {
// Multi-line rendering for FUNCTION cell
ctx.font = 'bold 36px "Courier New", monospace';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
// White outline
ctx.strokeStyle = '#ffffff';
ctx.lineWidth = 8;
ctx.strokeText('FUNCTION(B1&', center, 360);
ctx.strokeText('"(QUERY(', center, 480);
ctx.strokeText('"SELECT * FROM', center, 600);
ctx.strokeText('EVERYTHING")', center, 720);
// Black fill
ctx.fillStyle = '#000000';
ctx.fillText('FUNCTION(B1&', center, 360);
ctx.fillText('"(QUERY(', center, 480);
ctx.fillText('"SELECT * FROM', center, 600);
ctx.fillText('EVERYTHING")', center, 720);
} else {
// Single-line rendering for CONSUME/CREATE
ctx.font = 'bold 56px "Courier New", monospace';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';

// White stroke for readability
ctx.strokeStyle = '#ffffff';
ctx.lineWidth = 8;
ctx.strokeText(content, center, center);

// Black fill
ctx.fillStyle = '#000000';
ctx.fillText(content, center, center);
}

// Update texture
if (cell.material.map) {
cell.material.map.needsUpdate = true;
}
}

// Split cell animation
function splitCell() {
if (!cellGrid || cellGrid.userData.hasSplit) return;
cellGrid.userData.hasSplit = true;

const cell = cellGrid.userData.cell;
const arrow = cellGrid.userData.arrow;

// Remove arrow
cellGrid.remove(arrow);
arrow.geometry.dispose();
arrow.material.dispose();

console.log('[Cell] Cell splitting with amoeba deformation');

// Deform into amoeba shape
const startTime = Date.now();
const deformDuration = 800;

const deformInterval = setInterval(() => {
const elapsed = Date.now() - startTime;
const progress = Math.min(elapsed / deformDuration, 1);

// Jittery amoeba deformation
const jitterX = Math.sin(progress * 20) * 0.1 * (1 - progress);
const jitterY = Math.cos(progress * 15) * 0.1 * (1 - progress);
cell.scale.x = 1 + jitterX;
cell.scale.y = 1 + jitterY;

if (progress >= 1) {
clearInterval(deformInterval);
cell.scale.set(1, 1, 1);

// Snap into two cells
setTimeout(() => snapIntoTwoCells(), 200);
}
}, 16);
}

// Snap into two distinct cells
function snapIntoTwoCells() {
console.log('[Cell] Snapping into two cells');

const originalCell = cellGrid.userData.cell;
const cellSize = 1.1; // Larger cells

// Remove original
cellGrid.remove(originalCell);
originalCell.geometry.dispose();
originalCell.material.dispose();

// Create two cells
const spacing = 0.15;

// Cell A (left) - CONSUME
const cellA = new THREE.Mesh(
new THREE.PlaneGeometry(cellSize, cellSize),
new THREE.MeshBasicMaterial({ 
color: 0xffffff, 
transparent: true, 
opacity: 1.0, 
side: THREE.DoubleSide,
depthWrite: false, // Don't write to depth buffer so cells don't block scene
depthTest: true, // Enable depth testing so Celli can appear in front
toneMapped: false // Prevent tone mapping from affecting cells
})
);
cellA.position.set(-(cellSize / 2 + spacing / 2), 0, 0);

// Cell B (right) - FUNCTION
const cellB = new THREE.Mesh(
new THREE.PlaneGeometry(cellSize, cellSize),
new THREE.MeshBasicMaterial({ 
color: 0xffffff, 
transparent: true, 
opacity: 1.0, 
side: THREE.DoubleSide,
depthWrite: false, // Don't write to depth buffer so cells don't block scene
depthTest: true, // Enable depth testing so Celli can appear in front
toneMapped: false // Prevent tone mapping from affecting cells
})
);
cellB.position.set(cellSize / 2 + spacing / 2, 0, 0);

// Create content for Cell A (CONSUME)
const canvasA = document.createElement('canvas');
canvasA.width = 1024;
canvasA.height = 1024;
const ctxA = canvasA.getContext('2d');
ctxA.fillStyle = '#ffffff';
ctxA.fillRect(0, 0, 1024, 1024);
// Thick dark border
ctxA.strokeStyle = '#000000';
ctxA.lineWidth = 8;
ctxA.strokeRect(4, 4, 1016, 1016);
// Inner border
ctxA.strokeStyle = '#999999';
ctxA.lineWidth = 4;
ctxA.strokeRect(12, 12, 1000, 1000);
// Text with white stroke for readability
ctxA.font = 'bold 56px "Courier New", monospace';
ctxA.textAlign = 'center';
ctxA.textBaseline = 'middle';
// White outline
ctxA.strokeStyle = '#ffffff';
ctxA.lineWidth = 8;
ctxA.strokeText('CONSUME', 512, 512);
// Black fill
ctxA.fillStyle = '#000000';
ctxA.fillText('CONSUME', 512, 512);

// Create content for Cell B (FUNCTION)
const canvasB = document.createElement('canvas');
canvasB.width = 1024;
canvasB.height = 1024;
const ctxB = canvasB.getContext('2d');
ctxB.fillStyle = '#ffffff';
ctxB.fillRect(0, 0, 1024, 1024);
// Thick dark border
ctxB.strokeStyle = '#000000';
ctxB.lineWidth = 8;
ctxB.strokeRect(4, 4, 1016, 1016);
// Inner border
ctxB.strokeStyle = '#999999';
ctxB.lineWidth = 4;
ctxB.strokeRect(12, 12, 1000, 1000);
// Text (multi-line) with white stroke for readability
ctxB.font = 'bold 36px "Courier New", monospace';
ctxB.textAlign = 'center';
ctxB.textBaseline = 'middle';
// White outline
ctxB.strokeStyle = '#ffffff';
ctxB.lineWidth = 8;
ctxB.strokeText('FUNCTION(B1&', 512, 360);
ctxB.strokeText('"(QUERY(', 512, 480);
ctxB.strokeText('"SELECT * FROM', 512, 600);
ctxB.strokeText('EVERYTHING")', 512, 720);
// Black fill
ctxB.fillStyle = '#000000';
ctxB.fillText('FUNCTION(B1&', 512, 360);
ctxB.fillText('"(QUERY(', 512, 480);
ctxB.fillText('"SELECT * FROM', 512, 600);
ctxB.fillText('EVERYTHING")', 512, 720);

const texA = new THREE.CanvasTexture(canvasA);
const texB = new THREE.CanvasTexture(canvasB);
texA.minFilter = THREE.NearestFilter;
texB.minFilter = THREE.NearestFilter;
texA.magFilter = THREE.NearestFilter;
texB.magFilter = THREE.NearestFilter;
cellA.material.map = texA;
cellB.material.map = texB;

// Store references
cellA.userData.canvas = canvasA;
cellA.userData.content = 'CONSUME';
cellA.userData.isConsume = true;
cellB.userData.canvas = canvasB;
cellB.userData.content = 'FUNCTION(B1&"(QUERY("SELECT * FROM EVERYTHING")';

// High render order to draw over Celli's light orb
cellA.renderOrder = 5000;
cellB.renderOrder = 5000;

cellGrid.add(cellA);
cellGrid.add(cellB);

cellGrid.userData.cellA = cellA;
cellGrid.userData.cellB = cellB;

// Start wriggling
cellGrid.userData.wriggling = true;

console.log('[Cell] Two cells created - wriggling like digital organisms');

// Narrative now triggered when CREATE is typed, not on cell split
}

// ===== LEAVES House Display =====
let leavesHouseGroup = null;
let leavesTextColor = '#4ade80'; // Default green color for LEAVES text

// Function to update LEAVES color
function updateLeavesColor(newColor) {
console.log('[LEAVES] Updating text color to:', newColor);
leavesTextColor = newColor;

if (!leavesHouseGroup) {
console.warn('[LEAVES] House not created yet');
showDialogue('LEAVES house not visible yet', 2000);
return;
}

// Recreate textures with new color
const greenTexture = createLeavesTexture(false); // Will use new leavesTextColor
const redTexture = createLeavesTexture(true); // Red door stays red

// Convert hex to THREE.Color for emissive
const threeColor = new THREE.Color(newColor);

// Update all materials
let greenBlockCount = 0;
leavesHouseGroup.traverse((child) => {
if (child.isMesh) {
// Check if this is a green block (not red door)
const isGreenBlock = child.material.emissive && child.material.emissive.getHex() !== 0xff4444;
if (isGreenBlock) {
greenBlockCount++;
// Update texture
child.material.map = greenTexture;
child.material.emissiveMap = greenTexture;
child.material.emissive = threeColor;
child.material.needsUpdate = true;
}
}
});

console.log(`[LEAVES] ✅ Updated ${greenBlockCount} green blocks with new color`);
showDialogue(`✅ LEAVES color updated (${greenBlockCount} blocks)`, 2000);
}

// Show terminal animation when house spawns
function showHouseSpawnTerminalSequence() {
if (!asciiCanvas || !asciiSprite) return;
console.log('[Terminal] Showing house spawn sequence');

const ctx = asciiCanvas.getContext('2d');
const messages = ['LAUNCHING...', 'REMEMBERING...', 'LAMENTING...'];
let messageIndex = 0;

function typeMessage() {
if (messageIndex >= messages.length) {
// After all messages, clear terminal after brief pause
setTimeout(() => {
ctx.fillStyle = '#000000';
ctx.fillRect(0, 0, asciiCanvas.width, asciiCanvas.height);
asciiSprite.material.map.needsUpdate = true;
console.log('[Terminal] House spawn sequence complete - terminal cleared');
}, 1000);
return;
}

const message = messages[messageIndex];
let charIndex = 0;

ctx.fillStyle = '#000000';
ctx.fillRect(0, 0, asciiCanvas.width, asciiCanvas.height);

const typeChar = setInterval(() => {
if (charIndex <= message.length) {
// Redraw screen
ctx.fillStyle = '#000000';
ctx.fillRect(0, 0, asciiCanvas.width, asciiCanvas.height);

// Draw current message being typed
ctx.fillStyle = '#00ff00';
ctx.font = '24px "Courier New", monospace';
const partial = message.substring(0, charIndex);
ctx.fillText(partial, 40, 60);

// Flashing cursor
if (charIndex < message.length) {
const cursorX = 40 + ctx.measureText(partial).width;
ctx.fillRect(cursorX, 45, 12, 20);
}

asciiSprite.material.map.needsUpdate = true;
charIndex++;
} else {
clearInterval(typeChar);

// Move to next message after brief pause
setTimeout(() => {
messageIndex++;
typeMessage();
}, 600);
}
}, 60);
}

typeMessage();
}

function createLeavesTexture(isRedDoor = false) {
// Create canvas with "LEAVES" text repeated in rows - transparent background
const canvas = document.createElement('canvas');
canvas.width = 256;
canvas.height = 256;
const ctx = canvas.getContext('2d');

// Transparent background
ctx.clearRect(0, 0, 256, 256);

// Retro green text (or red for door) - use global leavesTextColor
ctx.fillStyle = isRedDoor ? '#ff4444' : leavesTextColor;
ctx.font = 'bold 18px "Press Start 2P", "Courier New", monospace';
ctx.textAlign = 'left';
ctx.textBaseline = 'top';

// Draw "LEAVES" in multiple rows to fill texture
const text = 'LEAVES';
const lineHeight = 28;
const charWidth = 110;

for (let y = 0; y < canvas.height; y += lineHeight) {
for (let x = -20; x < canvas.width; x += charWidth) {
ctx.fillText(text, x, y);
}
}

const texture = new THREE.CanvasTexture(canvas);
texture.wrapS = THREE.RepeatWrapping;
texture.wrapT = THREE.RepeatWrapping;
texture.minFilter = THREE.NearestFilter;
texture.magFilter = THREE.NearestFilter;
return texture;
}

function showLeavesHouse() {
if (narrativeSequence.leavesHouseShown || leavesHouseGroup) return;
console.log('[Narrative] Showing LEAVES house');

// Show terminal sequence: LAUNCHING... REMEMBERING... LAMENTING...
showHouseSpawnTerminalSequence();

// Create textures
const greenTexture = createLeavesTexture(false);
const redTexture = createLeavesTexture(true);

// Block size
const blockSize = 0.3;
const spacing = 0.05;
const step = blockSize + spacing;

// Structure dimensions: 5 wide x 8 tall x 8 deep
const width = 5;
const height = 8;
const depth = 8;

// Door dimensions: 3 wide x 5 tall, centered on front face
const doorWidth = 3;
const doorHeight = 5;
const doorStartX = Math.floor((width - doorWidth) / 2); // Start at x=1 for centering
const doorStartY = 0; // Start from bottom

leavesHouseGroup = new THREE.Group();

// Create shared geometry
const blockGeo = new THREE.BoxGeometry(blockSize, blockSize, blockSize);

// Create green material (glowing)
const greenMaterial = new THREE.MeshStandardMaterial({
map: greenTexture,
transparent: true,
emissive: 0x4ade80,
emissiveIntensity: 0.8,
emissiveMap: greenTexture,
roughness: 0.6,
metalness: 0.2,
side: THREE.DoubleSide,
alphaTest: 0.1
});

// Create red material for door (glowing red)
const redMaterial = new THREE.MeshStandardMaterial({
map: redTexture,
transparent: true,
emissive: 0xff4444,
emissiveIntensity: 1.2,
emissiveMap: redTexture,
roughness: 0.6,
metalness: 0.2,
side: THREE.DoubleSide,
alphaTest: 0.1
});

// Build structure: 5 wide x 8 tall x 8 deep
for (let z = 0; z < depth; z++) {
for (let y = 0; y < height; y++) {
for (let x = 0; x < width; x++) {
// Check if this is a door block (front face only)
const isFrontFace = (z === 0);
const isDoorBlock = isFrontFace && 
(x >= doorStartX && x < doorStartX + doorWidth) && 
(y >= doorStartY && y < doorStartY + doorHeight);

// Use red material for door blocks, green for everything else
const material = isDoorBlock ? redMaterial : greenMaterial;

// Create block
const block = new THREE.Mesh(blockGeo, material);
block.position.set(
x * step - (width * step) / 2,
y * step,
z * step - (depth * step) / 2
);
block.castShadow = true;
block.receiveShadow = true;
leavesHouseGroup.add(block);
}
}
}

// Position house to the side of Celli
leavesHouseGroup.position.set(2, 6, 22);
leavesHouseGroup.scale.setScalar(0.01);
scene.add(leavesHouseGroup);

console.log(`[LEAVES House] Built ${leavesHouseGroup.children.length} blocks (${width}x${height}x${depth})`);

// Animate house scaling in
const startTime = Date.now();
const duration = 1500;
function animateHouse() {
const elapsed = Date.now() - startTime;
const progress = Math.min(elapsed / duration, 1);
const eased = 1 - Math.pow(1 - progress, 3); // Ease out cubic

leavesHouseGroup.scale.setScalar(0.01 + eased * 1.49); // Scale to 1.5x for visibility

if (progress < 1) {
requestAnimationFrame(animateHouse);
} else {
leavesHouseGroup.scale.setScalar(1.5);
}
}
animateHouse();

narrativeSequence.leavesHouseShown = true;
}

// ===== Build LEAVE House =====
function buildLeaveHouse() {
console.log('[Narrative] Building LEAVE house');
const houseGroup = new THREE.Group();

// Create text "LEAVES" grid for walls
const loader = new THREE.FontLoader();
// Use simple boxes instead of text for now (can be enhanced with TextGeometry later)
const leavesColor = 0x228b22;

// Base rectangular prism (made of boxes representing text grid)
for (let x = 0; x < 8; x++) {
for (let z = 0; z < 12; z++) {
const boxGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
const boxMat = new THREE.MeshStandardMaterial({ 
color: leavesColor, 
emissive: leavesColor, 
emissiveIntensity: 0.2 
});
const box = new THREE.Mesh(boxGeo, boxMat);
box.position.set(x * 0.45, 0.2, z * 0.45);
box.castShadow = true;
houseGroup.add(box);
}
}

// Walls (vertical)
for (let y = 0; y < 5; y++) {
// Front and back walls
for (let x = 0; x < 8; x++) {
const boxGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
const boxMat = new THREE.MeshStandardMaterial({ color: leavesColor });
const box1 = new THREE.Mesh(boxGeo, boxMat);
box1.position.set(x * 0.45, y * 0.45 + 0.4, 0);
box1.castShadow = true;
houseGroup.add(box1);

const box2 = new THREE.Mesh(boxGeo, boxMat.clone());
box2.position.set(x * 0.45, y * 0.45 + 0.4, 11 * 0.45);
box2.castShadow = true;
houseGroup.add(box2);
}

// Side walls
for (let z = 1; z < 11; z++) {
const boxGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
const boxMat = new THREE.MeshStandardMaterial({ color: leavesColor });
const box1 = new THREE.Mesh(boxGeo, boxMat);
box1.position.set(0, y * 0.45 + 0.4, z * 0.45);
box1.castShadow = true;
houseGroup.add(box1);

const box2 = new THREE.Mesh(boxGeo, boxMat.clone());
box2.position.set(7 * 0.45, y * 0.45 + 0.4, z * 0.45);
box2.castShadow = true;
houseGroup.add(box2);
}
}

// Gabled roof
const roofHeight = 1.5;
for (let z = 0; z < 12; z++) {
for (let y = 0; y < 4; y++) {
const xOffset = y * 0.5;
for (let x = Math.floor(xOffset); x < 8 - xOffset; x++) {
const boxGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
const boxMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
const box = new THREE.Mesh(boxGeo, boxMat);
box.position.set(x * 0.45, 2.2 + y * 0.4, z * 0.45);
box.castShadow = true;
houseGroup.add(box);
}
}
}

// Windows (will have bored boards later)
const windowPositions = [
{ x: 2, y: 1.5, z: 0 },
{ x: 5, y: 1.5, z: 0 },
{ x: 2, y: 1.5, z: 11 * 0.45 },
{ x: 5, y: 1.5, z: 11 * 0.45 }
];

windowPositions.forEach(pos => {
const windowGeo = new THREE.PlaneGeometry(0.6, 0.6);
const windowMat = new THREE.MeshStandardMaterial({ color: 0x87ceeb, transparent: true, opacity: 0.7 });
const window = new THREE.Mesh(windowGeo, windowMat);
window.position.copy(pos);
window.userData.isWindow = true;
houseGroup.add(window);
});

houseGroup.position.set(10, 0, 18);
houseGroup.scale.setScalar(2);
scene.add(houseGroup);

// Store windows for later
window.narrativeHouseWindows = windowPositions.map((pos, i) => {
return houseGroup.children.find(child => child.userData.isWindow && Math.abs(child.position.x - pos.x) < 0.1);
}).filter(w => w);

narrativeSequence.houseBuilt = true;
}

// ===== Spawn Bored Boards =====
function spawnBoredBoards() {
if (narrativeSequence.boredBoardsSpawned) return;
console.log('[Narrative] Spawning bored emoji boards');

const boredEmojis = ['(Â¬_Â¬)', '( â€“ âŒ“ â€“ )', 'ðŸ¥±', 'ðŸ˜'];

if (!window.narrativeHouseWindows) return;

window.narrativeHouseWindows.forEach((windowMesh, i) => {
// Create canvas with bored emoji
const canvas = document.createElement('canvas');
canvas.width = 256;
canvas.height = 256;
const ctx = canvas.getContext('2d');

// Create glitching bored emoji/emoticon
const emoji = boredEmojis[i % boredEmojis.length];
ctx.fillStyle = '#f5deb3';
ctx.fillRect(0, 0, 256, 256);
ctx.fillStyle = '#000';
ctx.font = '80px Arial';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.fillText(emoji, 128, 128);

const texture = new THREE.CanvasTexture(canvas);
const boardMat = new THREE.MeshBasicMaterial({ map: texture });
const boardGeo = new THREE.PlaneGeometry(0.6, 0.6);
const board = new THREE.Mesh(boardGeo, boardMat);
board.position.copy(windowMesh.position);
board.position.z += 0.1; // Slightly in front
board.userData.isBoredBoard = true;
windowMesh.parent.add(board);

// Glitch animation
let glitchTime = 0;
setInterval(() => {
glitchTime++;
if (Math.random() < 0.3) {
const newEmoji = boredEmojis[Math.floor(Math.random() * boredEmojis.length)];
ctx.fillStyle = '#f5deb3';
ctx.fillRect(0, 0, 256, 256);
ctx.fillStyle = Math.random() < 0.1 ? '#ff0000' : '#000';
ctx.fillText(newEmoji, 128 + (Math.random() - 0.5) * 20, 128 + (Math.random() - 0.5) * 20);
texture.needsUpdate = true;
}
}, 500);
});

narrativeSequence.boredBoardsSpawned = true;
}

// ===== Viewport Pass-Through & Pocket Dimension =====
let previousCameraPos = new THREE.Vector3();
let hasEnteredPocketDimension = false;
let pocketDimensionActive = false;
window.pocketDimensionActive = false; // Expose globally for pointer lock checks

function checkViewportPassThrough() {
if (!viewportPrism || !viewportPrism.userData.allowPassThrough || hasEnteredPocketDimension) return;

// Get viewport world position and normal
const viewportWorldPos = new THREE.Vector3();
viewportPrism.getWorldPosition(viewportWorldPos);

const viewportNormal = new THREE.Vector3(0, 0, 1);
viewportNormal.applyQuaternion(viewportPrism.getWorldQuaternion(new THREE.Quaternion()));

// Check if camera crossed the plane
const prevDot = viewportNormal.dot(previousCameraPos.clone().sub(viewportWorldPos));
const currDot = viewportNormal.dot(camera.position.clone().sub(viewportWorldPos));

// Crossed from positive to negative (front to back)
if (prevDot > 0 && currDot < 0) {
// Check if within viewport bounds
const toCamera = camera.position.clone().sub(viewportWorldPos);
const viewportQuat = viewportPrism.getWorldQuaternion(new THREE.Quaternion());
const localPos = toCamera.applyQuaternion(viewportQuat.clone().invert());

const halfWidth = viewportPrism.userData.width / 2;
const halfHeight = viewportPrism.userData.height / 2;

if (Math.abs(localPos.x) <= halfWidth && Math.abs(localPos.y) <= halfHeight) {
console.log('[ZEKE] Camera passed through crystal viewport - entering pocket dimension');
hasEnteredPocketDimension = true;
enterPocketDimension();
}
}

previousCameraPos.copy(camera.position);
}

// Enter pocket dimension (scale-like environment)
function enterPocketDimension() {
console.log('[Pocket] Transitioning to pocket dimension');

// Fade to black
const fadeOverlay = document.createElement('div');
fadeOverlay.style.position = 'fixed';
fadeOverlay.style.inset = '0';
fadeOverlay.style.background = '#000';
fadeOverlay.style.opacity = '0';
fadeOverlay.style.transition = 'opacity 1s ease';
fadeOverlay.style.zIndex = '9999';
fadeOverlay.style.pointerEvents = 'none';
document.body.appendChild(fadeOverlay);

setTimeout(() => {
fadeOverlay.style.opacity = '1';
}, 50);

// After fade, create pocket dimension
setTimeout(() => {
createPocketDimension();

// Fade back in
setTimeout(() => {
fadeOverlay.style.opacity = '0';
setTimeout(() => fadeOverlay.remove(), 1000);
}, 500);
}, 1500);
}

// Create pocket dimension environment (scale-like)
function createPocketDimension() {
console.log('[Pocket] Creating pocket dimension environment');

pocketDimensionActive = true;
window.pocketDimensionActive = true; // Expose globally for pointer lock checks
console.log('[Pocket] Set pocketDimensionActive = true (global)');

// Ensure any existing pointer lock is released
if (document.pointerLockElement) {
  console.warn('[Pocket] ⚠️ Pointer lock was active - releasing it');
  try {
    document.exitPointerLock();
  } catch (e) {
    console.error('[Pocket] Failed to exit pointer lock:', e);
  }
}

// Hide fullhand scene elements
if (keyboardGroup) keyboardGroup.visible = false;
if (characterGroup) characterGroup.visible = false;
if (voxelHeadGroup) voxelHeadGroup.visible = false;
if (asciiScreenGroup) asciiScreenGroup.visible = false;
if (leavesHouseGroup) leavesHouseGroup.visible = false;
if (floatingCelliAvatar) floatingCelliAvatar.visible = false;
if (cellGrid) cellGrid.visible = false;

// Change scene background
scene.background = new THREE.Color(0xf2f6ff);
scene.fog = new THREE.FogExp2(0xe8f1ff, 0.02);

// Create crumbling voxel walls (data cell environment)
const pocketWalls = buildPocketVoxelWalls();
window.pocketWalls = pocketWalls;

// Create office-style lighting
const pocketLights = createPocketLighting();
window.pocketLights = pocketLights;

// Create voxel floor
const floorSize = 0.9;
const floorW = 80, floorF = 80;
const floorGeo = new THREE.BoxGeometry(floorSize, floorSize, floorSize);
const floorMat = new THREE.MeshStandardMaterial({
  color: 0x0d0d15,
  roughness: 0.85,
  metalness: 0.15
});
const maxFloorVoxels = 4200;
const pocketFloor = new THREE.InstancedMesh(floorGeo, floorMat, maxFloorVoxels);
pocketFloor.receiveShadow = true;
pocketFloor.userData.isPocketElement = true;

const floorDummy = new THREE.Object3D();
let floorCount = 0;
for (let x = -floorW / 2; x < floorW / 2 && floorCount < maxFloorVoxels; x += floorSize) {
  for (let z = -floorF / 2; z < floorF / 2 && floorCount < maxFloorVoxels; z += floorSize) {
    const d = Math.sqrt((x / (floorW / 2)) ** 2 + (z / (floorF / 2)) ** 2);
    if (d > 0.75 && Math.random() < (d - 0.75) * 2.2) continue;
    if (Math.random() < 0.05) continue;
    
    floorDummy.position.set(
      x + (Math.random() - 0.5) * 0.15,
      -15.2 + (Math.random() - 0.5) * 0.2,
      z + (Math.random() - 0.5) * 0.15
    );
    floorDummy.updateMatrix();
    pocketFloor.setMatrixAt(floorCount++, floorDummy.matrix);
  }
}
pocketFloor.count = floorCount;
pocketFloor.instanceMatrix.needsUpdate = true;
scene.add(pocketFloor);
window.pocketFloor = pocketFloor;
console.log('[Pocket] Created voxel floor with', floorCount, 'voxels');

// Create origin slab (the portrait/frame)
const SLAB_WIDTH = 4.0;
const SLAB_HEIGHT = 3.0;
const SLAB_DEPTH = 0.18;

const slabGroup = new THREE.Group();
slabGroup.userData.isPocketElement = true;

const slabBody = new THREE.Mesh(
new THREE.BoxGeometry(SLAB_WIDTH, SLAB_HEIGHT, SLAB_DEPTH),
new THREE.MeshStandardMaterial({ 
color: 0x1c2333, 
metalness: 0.2, 
roughness: 0.7 
})
);
slabBody.castShadow = true;
slabBody.receiveShadow = true;
slabGroup.add(slabBody);

// Slab interior (portal surface)
const slabInterior = new THREE.Mesh(
new THREE.PlaneGeometry(SLAB_WIDTH * 0.94, SLAB_HEIGHT * 0.94),
new THREE.MeshStandardMaterial({ 
color: 0x0f1524, 
emissive: 0x0b1a33, 
emissiveIntensity: 0.3 
})
);
slabInterior.position.z = SLAB_DEPTH / 2 + 0.002;
slabGroup.add(slabInterior);

slabGroup.position.set(0, SLAB_HEIGHT / 2, -8);
scene.add(slabGroup);

// Position camera in pocket dimension
camera.position.set(0, 1.6, 5);
camera.lookAt(0, SLAB_HEIGHT / 2, -8);

// Update controls target
controls.target.set(0, SLAB_HEIGHT / 2, -8);
controls.update();

console.log('[Pocket] Pocket dimension created - player can explore');

// Show instruction
showDialogue('Welcome to the <strong>Pocket Dimension</strong><br><span style="color: #ff0;">CLICK ANYWHERE</span> to enable mouse look, then WASD to move', 7000);

// Add click handler to request pointer lock (required by browsers)
const clickToLock = (e) => {
  console.log('[Pocket] 🖱️ Click event detected');
  console.log('[Pocket]   Camera mode:', window.CameraManager?.mode);
  console.log('[Pocket]   Current pointer lock:', document.pointerLockElement);
  
  // Check if user clicked on the video screen to cycle videos
  if (window.pocketDimensionActive && window.pocketVideoScreen) {
    const canvas = window.renderer?.domElement || renderer?.domElement;
    if (canvas && camera) {
      // Calculate mouse position in normalized device coordinates (-1 to +1)
      const rect = canvas.getBoundingClientRect();
      const mouse = new THREE.Vector2();
      mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      
      // Create raycaster from camera through mouse position
      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);
      
      // Check for intersection with video screen
      const intersects = raycaster.intersectObject(window.pocketVideoScreen, false);
      
      console.log('[Pocket] 🎯 Raycaster check - intersects:', intersects.length);
      if (intersects.length > 0) {
        console.log('[Pocket] 📺 Video screen clicked! Cycling to next video...');
        if (window.cycleTauntVideo) {
          window.cycleTauntVideo();
          showDialogue('🎬 Switching video...', 2000);
          return; // Don't process pointer lock if we clicked the screen
        }
      }
    }
  }
  
  if (window.CameraManager?.mode === 'fps' && !document.pointerLockElement) {
    console.log('[Pocket] 🎯 Requesting pointer lock for FPS mode...');
    const canvas = window.renderer?.domElement || renderer?.domElement;
    console.log('[Pocket]   Canvas found:', !!canvas);
    if (canvas) {
      try {
        canvas.requestPointerLock();
        console.log('[Pocket] ✅ Pointer lock requested');
        showDialogue('<strong>Mouse look enabled!</strong><br>Move mouse to look around, WASD to move, ESC to exit', 3000);
      } catch (err) {
        console.error('[Pocket] ❌ Failed to request pointer lock:', err);
        showDialogue('Click failed - try clicking again', 2000);
      }
    } else {
      console.error('[Pocket] ❌ Canvas not found!');
      showDialogue('Error: Canvas not found', 2000);
    }
  } else if (document.pointerLockElement) {
    console.log('[Pocket] ℹ️ Pointer lock already active');
  }
};
document.addEventListener('click', clickToLock);
console.log('[Pocket] 🖱️ Click-to-lock handler installed (with video screen detection)');

// Add ESC handler to show instruction again when pointer lock exits
const pocketPointerLockHandler = () => {
  if (window.pocketDimensionActive && !document.pointerLockElement) {
    console.log('[Pocket] Pointer lock released - camera will stay in place');
    
    // Store current camera state to prevent reset
    if (window.CameraManager && window.CameraManager.mode === 'fps') {
      const currentYaw = window.CameraManager.fpYaw;
      const currentPitch = window.CameraManager.fpPitch;
      console.log('[Pocket] Preserving camera angles - yaw:', currentYaw, 'pitch:', currentPitch);
      
      // Camera angles are preserved in CameraManager state
      // No need to reset controls target since FPS mode doesn't use it
    }
    
    showDialogue('<span style="color: #ff0;">CLICK</span> to enable mouse look again', 3000);
  }
};
document.addEventListener('pointerlockchange', pocketPointerLockHandler);

// Enable first-person mode for pocket dimension using CameraManager
console.log('[Pocket] 🎮 Requesting first-person mode for pocket dimension');
console.log('[Pocket]   Current camera mode:', window.CameraManager.mode);
console.log('[Pocket]   Current pointer lock:', document.pointerLockElement);
console.log('[Pocket]   Current controls.enabled:', controls?.enabled);

window.CameraManager.setMode('fps');

console.log('[Pocket] 🎮 First-person mode request completed');
console.log('[Pocket]   New camera mode:', window.CameraManager.mode);
console.log('[Pocket]   Pointer lock after:', document.pointerLockElement);
console.log('[Pocket]   Controls.enabled after:', controls?.enabled);

// Create pocket dimension video display after a delay
console.log('[Pocket] Scheduling video display creation in 2 seconds...');
setTimeout(() => {
console.log('[Pocket] ⏰ 2 seconds elapsed - creating video display');
console.log('[Pocket] Camera mode:', window.CameraManager.mode);
console.log('[Pocket] pocketDimensionActive:', pocketDimensionActive);

try {
createPocketDimensionVideoDisplay();
console.log('[Pocket] ✅ Video display created successfully');
} catch (err) {
console.error('[Pocket] ❌ Error creating video display:', err);
}
}, 2000);
}

// ===== Spreadsheet View System =====
let viewportCtx = null;
let streamingActive = false;
let viewportMinimizeIcon = null;
let isViewportMinimized = false;
let viewportSize = 'minimized'; // 'minimized', 'medium', 'large'

async function captureSheetToCanvas() {
  if (!window.html2canvas) {
    console.error('[Spreadsheet] html2canvas not loaded');
    return null;
  }

  const sheetContainer = document.getElementById('sheet-stream');
  if (!sheetContainer) return null;

  const originalTop = sheetContainer.style.top;
  const originalLeft = sheetContainer.style.left;
  const originalVisibility = sheetContainer.style.visibility;
  
  sheetContainer.style.top = '0';
  sheetContainer.style.left = '-10000px';
  sheetContainer.style.visibility = 'visible';

  try {
    const canvas = await html2canvas(sheetContainer, {
      backgroundColor: '#ffffff',
      scale: 1,
      logging: false,
      width: 640,
      height: 480,
      windowWidth: 640,
      windowHeight: 480,
      useCORS: true,
      allowTaint: true,
      removeContainer: false
    });
    
    sheetContainer.style.top = originalTop;
    sheetContainer.style.left = originalLeft;
    sheetContainer.style.visibility = originalVisibility;
    
    return canvas;
  } catch (err) {
    console.error('[Spreadsheet] Capture error:', err);
    sheetContainer.style.top = originalTop;
    sheetContainer.style.left = originalLeft;
    sheetContainer.style.visibility = originalVisibility;
    return null;
  }
}

async function streamUpdate() {
  if (!streamingActive || !viewportPrism) return;

  const canvas = await captureSheetToCanvas();
  if (canvas && viewportPrism.material[4] && viewportPrism.material[4].map) {
    const texture = viewportPrism.material[4].map;
    const ctx = texture.image.getContext('2d');
    ctx.clearRect(0, 0, texture.image.width, texture.image.height);
    ctx.drawImage(canvas, 0, 0, texture.image.width, texture.image.height);
    texture.needsUpdate = true;
  }

  if (streamingActive) {
    setTimeout(streamUpdate, 500);
  }
}

async function spawnSpreadsheetView() {
  if (viewportPrism) return;

  console.log('[Spreadsheet] Spawning spreadsheet viewport');

  buildLiveSheet();
  await new Promise(resolve => setTimeout(resolve, 300));

  const initialCanvas = await captureSheetToCanvas();
  if (!initialCanvas) {
    console.error('[Spreadsheet] Failed to capture sheet');
    return;
  }

  console.log('[Spreadsheet] GUI stream activated');

  viewportCanvas = document.createElement('canvas');
  viewportCanvas.width = 640;
  viewportCanvas.height = 480;
  viewportCtx = viewportCanvas.getContext('2d');
  viewportCtx.drawImage(initialCanvas, 0, 0, 640, 480);

  const texture = new THREE.CanvasTexture(viewportCanvas);
  texture.minFilter = THREE.LinearFilter;
  texture.magFilter = THREE.LinearFilter;

  const aspect = 640 / 480;
  const baseHeight = 0.8; // Start minimized
  const prismHeight = baseHeight;
  const prismWidth = prismHeight * aspect;
  const prismDepth = 0.15;

  const materials = [
    new THREE.MeshStandardMaterial({ color: 0x2a3f5f }),
    new THREE.MeshStandardMaterial({ color: 0x2a3f5f }),
    new THREE.MeshStandardMaterial({ color: 0x2a3f5f }),
    new THREE.MeshStandardMaterial({ color: 0x2a3f5f }),
    new THREE.MeshBasicMaterial({ map: texture, toneMapped: false }),
    new THREE.MeshStandardMaterial({ color: 0x1a1f2e })
  ];

  const prismGeometry = new THREE.BoxGeometry(prismWidth, prismHeight, prismDepth);
  viewportPrism = new THREE.Mesh(prismGeometry, materials);
  
  // Position near the screen
  viewportPrism.position.set(-2, 0, 1.5);
  viewportPrism.castShadow = true;
  viewportPrism.receiveShadow = true;
  viewportPrism.renderOrder = 9999;

  asciiScreenGroup.add(viewportPrism);

  viewportSize = 'minimized';
  streamingActive = true;
  streamUpdate();

  console.log('[Spreadsheet] Viewport spawned in minimized state');
}

function growSpreadsheetView() {
  if (!viewportPrism) return;

  if (viewportSize === 'minimized') {
    // Grow to medium
    viewportSize = 'medium';
    animateSpreadsheetSize(2.0);
    console.log('[Spreadsheet] Growing to medium');
  } else if (viewportSize === 'medium') {
    // Grow to large (turns button yellow)
    viewportSize = 'large';
    sheetData.hasMaximized = true;
    buildLiveSheet();
    animateSpreadsheetSize(3.2);
    console.log('[Spreadsheet] Growing to large (button yellow)');
  } else if (viewportSize === 'large') {
    // Snap back to minimized (turns button green)
    viewportSize = 'minimized';
    sheetData.hasMaximized = false;
    buildLiveSheet();
    animateSpreadsheetSize(0.8);
    console.log('[Spreadsheet] Snapping back to minimized (button green)');
  }
}

function animateSpreadsheetSize(targetHeight) {
  if (!viewportPrism) return;

  const aspect = 640 / 480;
  const currentScale = viewportPrism.scale.y;
  const baseHeight = 0.8;
  const targetScale = targetHeight / baseHeight;
  
  const duration = 500;
  const startTime = Date.now();
  const startScale = currentScale;

  function animate() {
    const elapsed = Date.now() - startTime;
    const progress = Math.min(elapsed / duration, 1);
    const eased = 1 - Math.pow(1 - progress, 3);
    
    const scale = startScale + (targetScale - startScale) * eased;
    viewportPrism.scale.set(scale, scale, scale);

    if (progress < 1) {
      requestAnimationFrame(animate);
    }
  }
  animate();
}

function minimizeSpreadsheetView() {
  if (!viewportPrism || isViewportMinimized) return;
  
  isViewportMinimized = true;
  console.log('[Spreadsheet] Minimizing');

  const duration = 300;
  const startTime = Date.now();
  const startScale = viewportPrism.scale.y;

  function animate() {
    const elapsed = Date.now() - startTime;
    const progress = Math.min(elapsed / duration, 1);
    const eased = 1 - Math.pow(1 - progress, 3);
    
    const scale = startScale * (1 - eased);
    viewportPrism.scale.set(scale, scale, scale);

    if (progress < 1) {
      requestAnimationFrame(animate);
    } else {
      viewportPrism.visible = false;
    }
  }
  animate();
}

// Wireframe cages for select_element
let wireframeCages = [];
let selectElementActive = false;

function showWireframeCages() {
  if (!leavesHouseGroup) return;
  
  wireframeCages.forEach(cage => scene.remove(cage));
  wireframeCages = [];
  
  // Create cages around house cubes
  leavesHouseGroup.traverse(obj => {
    if (obj.type === 'Mesh' && obj.geometry.type === 'BoxGeometry') {
      const worldPos = new THREE.Vector3();
      obj.getWorldPosition(worldPos);
      
      const size = new THREE.Vector3();
      obj.geometry.computeBoundingBox();
      obj.geometry.boundingBox.getSize(size);
      size.multiplyScalar(1.5); // Scale from house
      
      const geo = new THREE.BoxGeometry(size.x, size.y, size.z);
      const edges = new THREE.EdgesGeometry(geo);
      const mat = new THREE.LineBasicMaterial({ 
        color: 0x00ff88, 
        linewidth: 2,
        transparent: true,
        opacity: 0.8
      });
      const wireframe = new THREE.LineSegments(edges, mat);
      wireframe.position.copy(worldPos);
      wireframe.renderOrder = 10000;
      scene.add(wireframe);
      wireframeCages.push(wireframe);
    }
  });
  
  selectElementActive = true;
  console.log(`[SelectElement] ${wireframeCages.length} wireframe cages active`);
  
  // Pulse animation
  let pulseTime = 0;
  function animateCages() {
    if (!selectElementActive) return;
    
    pulseTime += 0.05;
    const pulse = 0.5 + Math.sin(pulseTime) * 0.5;
    
    wireframeCages.forEach(cage => {
      cage.material.opacity = 0.4 + pulse * 0.4;
    });
    
    requestAnimationFrame(animateCages);
  }
  animateCages();
  
  showDialogue('🔍 <strong>Element selection active!</strong><br>Wireframe cages highlight selectable cubes.', 4000);
}

function hideWireframeCages() {
  wireframeCages.forEach(cage => scene.remove(cage));
  wireframeCages = [];
  selectElementActive = false;
  console.log('[SelectElement] Wireframe cages removed');
}

// Handle spreadsheet interactions
function handleSpreadsheetClick(event) {
  if (!viewportPrism || !viewportPrism.visible) return;

  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);

  const intersects = raycaster.intersectObject(viewportPrism);
  if (intersects.length > 0) {
    const uv = intersects[0].uv;
    
    // Check button clicks (top 8% of viewport)
    if (uv.y > 0.92) {
      if (uv.x > 0.8 && uv.x < 0.88) {
        // Green/Yellow grow button
        growSpreadsheetView();
      } else if (uv.x > 0.88 && uv.x < 0.96) {
        // Red minimize button
        minimizeSpreadsheetView();
      }
    } else {
      // Check for =select_element cell click
      const cellClicked = checkSpreadsheetCellClick(uv);
      if (cellClicked && cellClicked.value && cellClicked.value.toLowerCase().includes('select_element')) {
        if (!selectElementActive) {
          showWireframeCages();
        } else {
          hideWireframeCages();
        }
      }
    }
  }
}

function checkSpreadsheetCellClick(uv) {
  // UV to grid mapping (approximate)
  const gridStartY = 0.15; // Top 15% is header/formula bar
  const gridEndY = 0.92; // Bottom 8% is nothing
  
  if (uv.y < gridStartY || uv.y > gridEndY) return null;
  
  const relY = (uv.y - gridStartY) / (gridEndY - gridStartY);
  const row = Math.floor(relY * 11) - 1; // -1 for header row
  
  const col = Math.floor(uv.x * 9) - 1; // -1 for row number column
  
  if (row >= 0 && row < 10 && col >= 0 && col < 8) {
    return sheetData.cells.find(c => c.col === col && c.row === row);
  }
  
  return null;
}

// ===== Animation Loop =====
 let time = 0;
 const tmpObjAnim = new THREE.Object3D();
 const tempPos = new THREE.Vector3();
 
function animate() {
requestAnimationFrame(animate);
const delta = 0.016; // Fixed timestep
time += delta;

// Pointer lock safety check - only release if improperly locked
// Allow pointer lock when in FPS mode (needed for mouse look)
const pocketActive = window.pocketDimensionActive || false;
const cameraMode = window.CameraManager?.mode || 'orbit';
const shouldHavePointerLock = cameraMode === 'fps';
const hasPointerLock = !!document.pointerLockElement;

if (hasPointerLock && !shouldHavePointerLock && !window.disablePointerLock) {
  if (!window.__pointerLockWarningShown) {
    console.warn('[Animate] ⚠️ Unexpected pointer lock while NOT in FPS mode - releasing');
    console.warn('[Animate]   Camera mode:', cameraMode, 'Pocket:', pocketActive);
    window.__pointerLockWarningShown = true;
    setTimeout(() => { window.__pointerLockWarningShown = false; }, 5000);
  }
  try {
    document.exitPointerLock();
  } catch (e) {
    // Ignore errors
  }
}

// Only update controls if not in FPS mode (FPS has its own camera control)
if (window.CameraManager?.mode !== 'fps') {
  controls.update();
}

// Animate prism cube rotation
if (prismCube && prismCube.userData.animateRotation) {
prismCube.rotation.x += prismCube.userData.rotationSpeed;
prismCube.rotation.y += prismCube.userData.rotationSpeed;
}

// Check for scale zone entry (entering shrunk/miniature state)
if (scaleModeEnabled && !scaleZoneEntered && camera.scale.x < 0.5) {
scaleZoneEntered = true;
window.CameraManager.setMode('fps');
console.log('[ScaleZone] Player entered scale zone - activating first-person mode via CameraManager');

// Show dialogue
showDialogue('You know, you\'re the first person to do <strong>THAT</strong>.', 5000);
}

// Handle drop physics
if (isDropping) {
const gravity = 0.008; // Acceleration due to gravity
const maxVelocity = 0.15; // Terminal velocity
const dampingFactor = 0.92; // Damping when landing

// Apply gravity
dropVelocity += gravity;
dropVelocity = Math.min(dropVelocity, maxVelocity);

// Update camera position
camera.position.y -= dropVelocity;

// Check if reached target height
if (camera.position.y <= targetDropHeight) {
camera.position.y = targetDropHeight;
isDropping = false;
dropVelocity = 0;
console.log('[Drop] Player landed at height:', camera.position.y.toFixed(3));

// Small bounce or settling effect
const landingShake = 0.002;
camera.position.y += Math.random() * landingShake - landingShake / 2;

// Enable drop mode (orbit + WASD hybrid) using CameraManager
window.CameraManager.setMode('drop');
console.log('[Drop] Drop mode enabled for city exploration via CameraManager');

// Keep fog reduced for city exploration
// Don't restore fog - keep it clear to see the city
console.log('[Drop] Keeping fog reduced for city exploration');
}
}

// Handle WASD movement via unified CameraManager
window.CameraManager.updateMovement();

// Update debug tracker
if (isDropping || dropModeActive) {
const debugContent = document.getElementById('drop-debug-content');
if (debugContent) {
const fogDensity = scene.fog ? scene.fog.density.toFixed(4) : 'none';
const nearestCity = microCityGroups.find(({ key }) => key === dropKeyTarget);
const cityVisible = nearestCity ? nearestCity.cityGroup.visible : false;
const cityCount = nearestCity ? nearestCity.cityGroup.children.length : 0;

debugContent.innerHTML = `
<div><span style="color: #888;">State:</span> ${isDropping ? '<span style="color: #ff0;">DROPPING</span>' : '<span style="color: #0f0;">LANDED</span>'}</div>
<div><span style="color: #888;">Mode:</span> ${dropModeActive ? '<span style="color: #0f0;">WASD Active</span>' : 'Inactive'}</div>
<div><span style="color: #888;">Orbit Controls:</span> ${controls && controls.enabled ? '<span style="color: #0f0;">ENABLED</span>' : '<span style="color: #f00;">DISABLED</span>'}</div>
<div style="margin-top: 8px; border-top: 1px solid #0f0; padding-top: 8px;">
<div><span style="color: #888;">Pos:</span> (${camera.position.x.toFixed(2)}, ${camera.position.y.toFixed(2)}, ${camera.position.z.toFixed(2)})</div>
<div><span style="color: #888;">Rot:</span> (${camera.rotation.x.toFixed(3)}, ${camera.rotation.y.toFixed(3)}, ${camera.rotation.z.toFixed(3)})</div>
<div><span style="color: #888;">Scale:</span> ${camera.scale.x.toFixed(4)}</div>
<div><span style="color: #888;">Target Y:</span> ${targetDropHeight ? targetDropHeight.toFixed(3) : 'N/A'}</div>
<div><span style="color: #888;">Velocity:</span> ${dropVelocity.toFixed(4)}</div>
</div>
<div style="margin-top: 8px; border-top: 1px solid #0f0; padding-top: 8px;">
<div><span style="color: #888;">Fog:</span> ${fogDensity}</div>
<div><span style="color: #888;">Near:</span> ${camera.near}</div>
<div><span style="color: #888;">Far:</span> ${camera.far}</div>
</div>
<div style="margin-top: 8px; border-top: 1px solid #0f0; padding-top: 8px;">
<div><span style="color: #888;">Target Key:</span> ${dropKeyTarget ? dropKeyTarget.userData.label : 'None'}</div>
<div><span style="color: #888;">City Visible:</span> ${cityVisible ? '<span style="color: #0f0;">YES</span>' : '<span style="color: #f00;">NO</span>'}</div>
<div><span style="color: #888;">City Objects:</span> ${cityCount}</div>
<div><span style="color: #888;">Cities LOD:</span> ${microCityVisible ? '<span style="color: #0f0;">ON</span>' : '<span style="color: #888;">OFF</span>'}</div>
</div>
<div style="margin-top: 8px; border-top: 1px solid #0f0; padding-top: 8px; color: #888; font-size: 10px;">
<strong style="color: #0f0;">Controls:</strong><br>
Mouse: Drag to rotate view<br>
WASD: Move | Shift: Sprint | Space: Up
</div>
`;
}
}

// Update micro city LOD
updateMicroCityLOD();
 
 // Update Frame of Reference
 updateFrameOfReference();
 
 // Auto-rotate character
 if (characterGroup && window.guiParams && window.guiParams.scene['Auto Rotate Character']) {
 characterGroup.rotation.y += 0.005;
 }
 
 // Update voxel wraps for all fingers
 if (finger && finger.userData.updateVoxelWrap) {
 finger.userData.updateVoxelWrap();
 }
 if (staticFingers && staticFingers.length > 0) {
 staticFingers.forEach(sf => {
 if (sf.fingerMesh && sf.fingerMesh.userData.updateVoxelWrap) {
 sf.fingerMesh.userData.updateVoxelWrap();
 } else if (sf.mesh && sf.mesh.userData.updateVoxelWrap) {
 // Some fingers store mesh directly
 sf.mesh.userData.updateVoxelWrap();
 }
 });
 }
 
 // Animate ambient dust particles
 if (ambientDustParticles.length > 0) {
 const windX = Math.sin(time * 0.2) * 0.006 + Math.cos(time * 0.05) * 0.003;
 const windZ = Math.cos(time * 0.17) * 0.005 + Math.sin(time * 0.07) * 0.002;
 
 for(const particle of ambientDustParticles){
 // Drift with velocity
 particle.position.y += particle.userData.velY;
 particle.position.x += particle.userData.velX + windX;
 particle.position.z += particle.userData.velZ + windZ;
 
 // Add swaying motion
 const sway = Math.sin(time * particle.userData.freq + particle.userData.phase) * particle.userData.swayAmount;
 const swayZ = Math.cos(time * particle.userData.freq * 0.8 + particle.userData.phase) * particle.userData.swayAmount * 0.6;
 particle.position.x += sway * 0.01;
 particle.position.z += swayZ * 0.01;
 
 // Reset if out of bounds
 if(particle.position.y < -1) {
 particle.position.y = 16 + Math.random()*3;
 particle.position.x = Math.random()*20 - 2;
 particle.position.z = Math.random()*12 - 2;
 }
 if(particle.position.x < -5 || particle.position.x > 20) {
 particle.position.x = Math.random()*20 - 2;
 }
 if(particle.position.z < -4 || particle.position.z > 12) {
 particle.position.z = Math.random()*12 - 2;
 }
 }
 }
 
 // Update narrative sequence (if active)
 let isSpeaking = false;
 let narrativeVoxelParams = null;
 if (narrativeSequence.active) {
 if (!narrativeSequence.startTime) narrativeSequence.startTime = time;
 const elapsed = time - narrativeSequence.startTime;
 isSpeaking = updateNarrativeSequence(elapsed);
 narrativeVoxelParams = getNarrativeVoxelParams(elapsed);
 
 // Check for 180-degree turn in 'turnback' phase
 if (narrativeSequence.phase === 'turnback' && !narrativeSequence.hasTurnedAround) {
 if (narrativeSequence.initialCameraDirection) {
 const currentDirection = camera.getWorldDirection(new THREE.Vector3());
 const dotProduct = currentDirection.dot(narrativeSequence.initialCameraDirection);
 
 // If dot product < -0.7, player has turned roughly 180 degrees
 if (dotProduct < -0.7) {
 console.log('? Player turned 180 degrees! Starting dialogue...');
 narrativeSequence.hasTurnedAround = true;
 narrativeSequence.phase = 'intro';
 narrativeSequence.startTime = time; // Reset timer for dialogue sequence
 // Hide "TURN BACK" text
 if (voxelHeadGroup && voxelHeadGroup.userData.turnBackText) {
 voxelHeadGroup.userData.turnBackText.active = false;
 }
 }
 }
 }
 }
 
// Update border celli effects
if (narrativeCelliAvatar) {
if (narrativeCelliAvatar.visible) {
updateCelliSqueezeEffect(delta);
}
updateCelliCollapse(delta);
updateCelliBlink(delta);
}

// Animate voxel head with breathing motion
if (voxelHeadGroup && voxelHeadGroup.visible) {
const instances = voxelHeadGroup.userData.instances;
const instancedMesh = voxelHeadGroup.userData.instancedMesh;
const headLight = voxelHeadGroup.userData.headLight;
 
 if (instances && instancedMesh && window.guiParams) {
 const headParams = window.guiParams.head;
 
 // Rotation
 voxelHeadGroup.rotation.y = Math.sin(time * headParams['Rotation Speed']) * 0.2;
 
 // Animate each voxel with wave patterns
 const amplitude = headParams['Amplitude'];
 // Use narrative speed if in sequence mode and speaking
 let speed = headParams['Animation Speed'];
 if (narrativeSequence.active && isSpeaking) {
 speed = narrativeSequence.voxelParams.speechPulsationFreq;
 } else if (narrativeSequence.active) {
 speed = narrativeSequence.voxelParams.basePulsationFreq;
 }
 
 const phaseNoise = headParams['Phase Noise'];
 const noiseWarp = headParams['Noise Warp'];
 const falloff = headParams['Falloff'];
 
 for (let i = 0; i < instances.length; i++) {
 const data = instances[i];
 tempPos.copy(data.basePos);
 
 // Apply narrative spacing if active (spread voxels further apart)
 if (narrativeVoxelParams) {
 const spacingFactor = narrativeVoxelParams.spacing;
 tempPos.multiplyScalar(spacingFactor);
 }
 
 // Spatial warp for organic motion
 const warp = Math.sin((tempPos.x + tempPos.y * 1.37 + tempPos.z * 0.73) * 3.1 + time * 0.9) * noiseWarp;
 
 // Per-instance phase
 const ph = hash(i * 0.3183 + i * 7.123) * phaseNoise;
 
 // Wave pattern
 const wave = Math.sin(time * speed + ph + (tempPos.length() * 1.1)) + warp;
 
 // Calculate outward offset (breathing effect)
 const normal = tempPos.clone().normalize();
 const offset = normal.multiplyScalar(wave * amplitude);
 
tmpObjAnim.position.copy(tempPos.add(offset));

// Apply narrative scale if active
let voxelScale = voxelHeadGroup.userData.baseVoxelSize || 0.10;
if (narrativeVoxelParams) {
voxelScale *= narrativeVoxelParams.scale;
}

// Check if this voxel is part of "TURN BACK" text
const isTurnBackVoxel = voxelHeadGroup.userData.turnBackText?.active && 
voxelHeadGroup.userData.turnBackIndices?.includes(i);

if (isTurnBackVoxel) {
// Make text voxels larger and pulsate
const textPulse = Math.sin(time * 3) * 0.3 + 1.3;
voxelScale *= textPulse;
// Set bright color for text voxels
if (instancedMesh.instanceColor) {
const textColor = new THREE.Color(1, 1, 0.3); // Bright yellow
instancedMesh.setColorAt(i, textColor);
}
}

tmpObjAnim.scale.setScalar(voxelScale);
 
 tmpObjAnim.rotation.set(0, 0, 0);
 tmpObjAnim.updateMatrix();
 instancedMesh.setMatrixAt(i, tmpObjAnim.matrix);
 }
 instancedMesh.instanceMatrix.needsUpdate = true;
 
 // Mark instance colors as needing update if text is active
 if (voxelHeadGroup.userData.turnBackText?.active && instancedMesh.instanceColor) {
 instancedMesh.instanceColor.needsUpdate = true;
 }
 
 // Animate opacity
 const opacitySpeed = headParams['Opacity Speed'] || 0.8;
 const opacityWave = Math.sin(time * opacitySpeed) * 0.5 + 0.5;
 instancedMesh.material.opacity = THREE.MathUtils.lerp(
 headParams['Opacity Min'], 
 headParams['Opacity Max'], 
 opacityWave
 );
 instancedMesh.material.emissiveIntensity = headParams['Emissive Intensity'];
 instancedMesh.material.metalness = headParams['Metalness'] || 0.2;
 instancedMesh.material.roughness = headParams['Roughness'] || 0.55;
 
// Pulse internal light
if (headLight) {
if (headParams['Light Pulse']) {
headLight.intensity = headParams['Light Intensity'] * (0.8 + 0.2 * Math.sin(time * 2.5));
} else {
headLight.intensity = headParams['Light Intensity'];
}
}

// Pulse eye lights
const eyeLights = voxelHeadGroup.userData.eyeLights;
if (eyeLights) {
const eyePulse = Math.sin(time * 1.5) * 0.3 + 0.7; // Gentle pulsation
eyeLights.forEach(light => {
light.intensity = 2.5 * eyePulse;
});
}

// Pulsate cheeks
const cheeks = voxelHeadGroup.userData.cheeks;
if (cheeks) {
const cheekPulse = Math.sin(time * 2.0) * 0.15 + 1.0; // Breathing-like pulsation
cheeks.forEach(cheek => {
cheek.scale.setScalar(cheekPulse);
cheek.material.emissiveIntensity = 0.6 * (0.8 + 0.2 * Math.sin(time * 2.0));
});
}
}
}

// Animate keyboard keys
 if (keys && keys.length > 0) {
 for (const key of keys) {
 if (key.userData.pressed) {
 // Apply velocity
 key.userData.velY += 0.003; // Spring back
 key.position.y += key.userData.velY;
 
 // Clamp to base position
 if (key.position.y >= key.userData.baseY) {
 key.position.y = key.userData.baseY;
 key.userData.velY = 0;
 key.userData.pressed = false;
 }
 }
 
 // Animate dust particles on keys
 if (key.userData.dustParticles && key.userData.dustParticles.length > 0) {
 for (const particle of key.userData.dustParticles) {
 if (!particle.userData) continue;
 
 // Float side to side with sine wave
 const freq = particle.userData.freq || 1;
 const phase = particle.userData.phase || 0;
 const drift = Math.sin(time * freq + phase) * 0.03;
 const driftZ = Math.cos(time * freq * 0.7 + phase) * 0.02;
 const baseX = particle.userData.baseX || 0;
 const baseZ = particle.userData.baseZ || 0;
 
 particle.position.x = baseX + drift;
 particle.position.z = baseZ + driftZ;
 
 // Slowly settle downward
 if (particle.position.y > 0.35) {
 particle.position.y -= 0.001;
 }
 }
 }
 }
 }
 
// Update floating Celli avatar (border trails mouse if spawned)
if (floatingCelliAvatar && floatingCelliAvatar.visible) {
// Get mouse position in world space
const mouseVector = new THREE.Vector3();
const raycaster = new THREE.Raycaster();
const mouse2D = new THREE.Vector2();

// Use last known mouse position or center
if (window.lastMouseX !== undefined) {
mouse2D.x = (window.lastMouseX / window.innerWidth) * 2 - 1;
mouse2D.y = -(window.lastMouseY / window.innerHeight) * 2 + 1;
} else {
mouse2D.set(0, 0);
}

raycaster.setFromCamera(mouse2D, camera);
const targetPoint = camera.position.clone().add(raycaster.ray.direction.multiplyScalar(5));

// Move whole group (with or without border)
floatingCelliAvatar.userData.targetPos.lerp(targetPoint, 0.05);
floatingCelliAvatar.position.lerp(floatingCelliAvatar.userData.targetPos, 0.1);

// Keep border avatar at full Celli position (not offset) and facing user
if (floatingCelliAvatar.userData.borderAvatar) {
floatingCelliAvatar.userData.borderAvatar.position.set(0, 0.3, 0);
// Ensure border avatar faces the user/camera
if (!floatingCelliAvatar.userData.borderAvatar.userData.rotationSet) {
floatingCelliAvatar.userData.borderAvatar.rotation.y = Math.PI;
floatingCelliAvatar.userData.borderAvatar.userData.rotationSet = true;
}
}

// Pulse glow (very subtle to not block cells)
if (floatingCelliAvatar.userData.glow) {
const glowPulse = Math.sin(time * 2) * 0.02 + 0.05; // Much dimmer
floatingCelliAvatar.userData.glow.material.opacity = glowPulse;
floatingCelliAvatar.userData.glow.scale.setScalar(1 + Math.sin(time * 1.5) * 0.02); // Minimal scale pulse
}
}

// Update cell wriggling
if (cellGrid && cellGrid.userData.wriggling) {
const cellA = cellGrid.userData.cellA;
const cellB = cellGrid.userData.cellB;

if (cellA && cellB) {
// Wriggle like digital organisms
const wriggleX = Math.sin(time * 5) * 0.02;
const wriggleY = Math.cos(time * 7) * 0.02;
const wriggleX2 = Math.sin(time * 6 + 1) * 0.02;
const wriggleY2 = Math.cos(time * 8 + 1) * 0.02;

cellA.scale.x = 1 + wriggleX;
cellA.scale.y = 1 + wriggleY;
cellB.scale.x = 1 + wriggleX2;
cellB.scale.y = 1 + wriggleY2;
}
}

// Animate Celli avatar interior grid pulsation
if (narrativeCelliAvatar && narrativeCelliAvatar.visible && celliInteriorGrid) {
const slabs = celliInteriorGrid.userData.slabs;
if (slabs) {
const isHovering = narrativeCelliAvatar.userData.hoverActive;
const isClicking = narrativeCelliAvatar.userData.clickActive;

// Determine pulsation intensity
let baseIntensity = 0.3;
let pulseSpeed = 2;
let pulseScale = 1.0;

if (isClicking) {
// Intense pulsation on click
baseIntensity = 0.8;
pulseSpeed = 8;
pulseScale = 1.4;
} else if (isHovering) {
// Moderate pulsation on hover
baseIntensity = 0.5;
pulseSpeed = 4;
pulseScale = 1.2;
}

slabs.forEach((slab, i) => {
const phase = (i * 0.2);
const pulse = Math.sin(time * pulseSpeed + phase) * 0.5 + 0.5;

// Animate opacity
const targetOpacity = baseIntensity + pulse * 0.3;
slab.material.opacity = THREE.MathUtils.lerp(slab.material.opacity, targetOpacity, 0.1);

// Animate scale
const targetScale = pulseScale * (0.9 + pulse * 0.2);
slab.scale.setScalar(THREE.MathUtils.lerp(slab.scale.x, targetScale, 0.1));

// Glow effect when clicking
if (isClicking) {
slab.material.emissive = new THREE.Color(0x8ab4ff);
slab.material.emissiveIntensity = pulse * 0.5;
} else {
slab.material.emissiveIntensity = 0;
}
});
}
}

// Check for camera pass-through of crystal viewport
checkViewportPassThrough();
 
 // Simple single-pass rendering - cells render with everything else
 console.log('[Render] Single-pass render with composer');
 composer.render();
 }

// ===== Resize Handler =====
window.addEventListener('resize', () => {
camera.aspect = innerWidth / innerHeight;
camera.updateProjectionMatrix();
renderer.setSize(innerWidth, innerHeight);
composer.setSize(innerWidth, innerHeight);
fxaaPass.material.uniforms['resolution'].value.set(1 / innerWidth, 1 / innerHeight);
});

// ===== Mouse Tracking for Floating Celli =====
window.addEventListener('mousemove', (event) => {
window.lastMouseX = event.clientX;
window.lastMouseY = event.clientY;
});
 
// ===== Mouse Move Handler (No Pointer Lock in Sequence) =====
window.addEventListener('mousemove', (event) => {
// Orbit controls handle all rotation in sequence mode - no pointer lock needed
// Check for hover over Celli avatar
 if (!document.pointerLockElement && narrativeCelliAvatar && narrativeCelliAvatar.visible) {
 const mouse = new THREE.Vector2();
 mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
 mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
 
 const raycaster = new THREE.Raycaster();
 raycaster.setFromCamera(mouse, camera);
 
 const intersects = raycaster.intersectObjects(narrativeCelliAvatar.children, true);
 
 if (intersects.length > 0) {
 // Hovering over Celli
 renderer.domElement.style.cursor = 'pointer';
 if (!narrativeCelliAvatar.userData.hoverActive) {
 narrativeCelliAvatar.userData.hoverActive = true;
 console.log('[Celli] Hover started');
 }
 } else {
 // Not hovering
 renderer.domElement.style.cursor = 'default';
 narrativeCelliAvatar.userData.hoverActive = false;
 }
 }
 });
 
 // ===== Click Handler for Celli Avatar =====
 window.addEventListener('mousedown', (event) => {
 if (!narrativeCelliAvatar || !narrativeCelliAvatar.visible) return;
 if (event.button !== 0) return; // Only left click
 
 const mouse = new THREE.Vector2();
 mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
 mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
 
 const raycaster = new THREE.Raycaster();
 raycaster.setFromCamera(mouse, camera);
 
 const intersects = raycaster.intersectObjects(narrativeCelliAvatar.children, true);
 
if (intersects.length > 0) {
console.log('[Celli] Clicked!');
narrativeCelliAvatar.userData.clickActive = true;
// Don't stop propagation - allow drag controls to work

// Reset click state after a short duration
setTimeout(() => {
if (narrativeCelliAvatar) {
narrativeCelliAvatar.userData.clickActive = false;
}
}, 500);
}
 });

// ===== Character Factory Functions =====

// Bob Avatar Factory (voxel block character with face)
function createBob() {
  const bobGroup = new THREE.Group();
  bobGroup.scale.setScalar(0.35);
  
  const voxelSize = 0.4;
  const voxelGeometry = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);
  
  // Pink head material
  const headMaterial = new THREE.MeshStandardMaterial({
    color: 0xff6b9d,
    emissive: 0xff1493,
    emissiveIntensity: 0.2,
    roughness: 0.6,
    metalness: 0.2
  });
  
  // Cyan glow material for face
  const faceMaterial = new THREE.MeshStandardMaterial({
    color: 0x00ffff,
    emissive: 0x00ffff,
    emissiveIntensity: 0.8,
    roughness: 0.3,
    metalness: 0.4
  });
  
  // Build voxel head (5x5x5 hollow with face)
  const headGroup = new THREE.Group();
  for (let x = -2; x <= 2; x++) {
    for (let y = 0; y <= 4; y++) {
      for (let z = -2; z <= 2; z++) {
        // Create hollow head with face
        const isEdge = Math.abs(x) === 2 || Math.abs(z) === 2 || y === 0 || y === 4;
        const isFace = z === 2 && y >= 1 && y <= 3;
        
        // Eyes
        const isEye = z === 2 && y === 3 && (x === -1 || x === 1);
        
        // Mouth
        const isMouth = z === 2 && y === 1 && Math.abs(x) <= 1;
        
        if (isEdge || (isFace && !isEye && !isMouth)) {
          const voxel = new THREE.Mesh(voxelGeometry, isEye || isMouth ? faceMaterial : headMaterial.clone());
          voxel.position.set(x * voxelSize, (y + 2) * voxelSize, z * voxelSize);
          headGroup.add(voxel);
        }
      }
    }
  }
  
  // Blue body material
  const bodyMaterial = new THREE.MeshStandardMaterial({
    color: 0x4a7cff,
    emissive: 0x0066ff,
    emissiveIntensity: 0.1,
    roughness: 0.6,
    metalness: 0.2
  });
  
  // Body (2 voxels tall, wider)
  for (let x = -1; x <= 1; x++) {
    for (let y = 0; y <= 1; y++) {
      for (let z = -1; z <= 1; z++) {
        if (Math.abs(x) >= 0.5 || Math.abs(z) >= 0.5) {
          const voxel = new THREE.Mesh(voxelGeometry, bodyMaterial);
          voxel.position.set(x * voxelSize, y * voxelSize, z * voxelSize);
          bobGroup.add(voxel);
        }
      }
    }
  }
  
  bobGroup.add(headGroup);
  bobGroup.userData.head = headGroup;
  bobGroup.rotation.y = Math.PI; // Face user
  return bobGroup;
}

// Pal-ette Avatar Factory (full grid character with inner cells)
function createPalette() {
  const paletteGroup = new THREE.Group();
  paletteGroup.scale.setScalar(0.25);
  
  const cellSize = 0.8;
  const gridWidth = 5;
  const gridHeight = 8;
  
  const cells = [];
  
  for (let x = 0; x < gridWidth; x++) {
    for (let y = 0; y < gridHeight; y++) {
      // Cell frame (green)
      const frameGeometry = new THREE.BoxGeometry(cellSize * 0.9, cellSize * 0.9, 0.1);
      const frameMaterial = new THREE.MeshStandardMaterial({
        color: 0x00ff00,
        emissive: 0x00ff00,
        emissiveIntensity: 0.3,
        roughness: 0.3,
        metalness: 0.7,
        transparent: true,
        opacity: 0.7
      });
      
      const cell = new THREE.Mesh(frameGeometry, frameMaterial);
      cell.position.set(
        (x - gridWidth / 2) * cellSize,
        (y - gridHeight / 2) * cellSize + 3,
        0
      );
      
      // Add random inner content (white/cyan)
      if (Math.random() > 0.4) {
        const contentGeometry = new THREE.BoxGeometry(cellSize * 0.6, cellSize * 0.6, 0.08);
        const contentMaterial = new THREE.MeshStandardMaterial({
          color: Math.random() > 0.5 ? 0xffffff : 0x00ffff,
          emissive: Math.random() > 0.5 ? 0xffffff : 0x00ffff,
          emissiveIntensity: 0.6
        });
        const content = new THREE.Mesh(contentGeometry, contentMaterial);
        content.position.z = 0.1;
        cell.add(content);
        cell.userData.content = content;
      }
      
      paletteGroup.add(cell);
      cell.userData.originalY = cell.position.y;
      cells.push(cell);
    }
  }
  
  paletteGroup.userData.cells = cells;
  paletteGroup.rotation.y = Math.PI; // Face user
  return paletteGroup;
}

// ===== Avatar Selector Handlers =====
document.getElementById('btn-avatar-selector')?.addEventListener('click', () => {
document.getElementById('avatar-selector-modal').classList.add('active');
});

// Import FBX Button Handler
document.getElementById('btn-import-fbx')?.addEventListener('click', () => {
document.getElementById('fbx-file-input').click();
});

// Handle FBX file import
document.getElementById('fbx-file-input')?.addEventListener('change', (event) => {
const file = event.target.files[0];
if (!file) return;

console.log('[FBX] 🔵 Starting to load file:', file.name, 'Size:', (file.size / 1024).toFixed(2), 'KB');
showDialogue(`Loading FBX: ${file.name}...`, 5000);

// Create object URL for the file (better than parsing buffer directly)
const fileURL = URL.createObjectURL(file);
console.log('[FBX] 🔵 Created object URL:', fileURL);

const loader = new FBXLoader();

// Set up loading manager for detailed progress
const loadingManager = new THREE.LoadingManager();
loadingManager.onStart = (url, itemsLoaded, itemsTotal) => {
console.log('[FBX] 🔵 Loading started:', url);
};
loadingManager.onProgress = (url, itemsLoaded, itemsTotal) => {
console.log('[FBX] 🔵 Loading progress:', itemsLoaded, '/', itemsTotal);
};
loadingManager.onLoad = () => {
console.log('[FBX] 🟢 All items loaded');
};
loadingManager.onError = (url) => {
console.error('[FBX] ❌ Error loading:', url);
};

loader.manager = loadingManager;

// Add timeout
const timeoutId = setTimeout(() => {
console.error('[FBX] ❌ Loading timed out after 10 seconds');
showDialogue(`❌ FBX loading timed out`, 3000);
URL.revokeObjectURL(fileURL);
}, 10000);

loader.load(
fileURL,
// onLoad callback
(fbxModel) => {
clearTimeout(timeoutId);
console.log('[FBX] 🟢 Model loaded successfully:', fbxModel);
console.log('[FBX] 🟢 Model children count:', fbxModel.children.length);

// Get bounding box for auto-scaling
const bbox = new THREE.Box3().setFromObject(fbxModel);
const size = new THREE.Vector3();
bbox.getSize(size);
const maxDim = Math.max(size.x, size.y, size.z);
console.log('[FBX] 📏 Model dimensions:', size, 'Max:', maxDim);

// Auto-scale to fit within reasonable bounds (target size ~1 unit)
const targetSize = 1.0;
const scale = maxDim > 0 ? targetSize / maxDim : 0.01;
fbxModel.scale.setScalar(scale);
console.log('[FBX] 📏 Applied scale:', scale);

// Center model
const center = new THREE.Vector3();
bbox.getCenter(center);
fbxModel.position.sub(center.multiplyScalar(scale));

// Face user
fbxModel.rotation.y = Math.PI;

// Traverse and convert materials to match Celli's style (MeshToonMaterial)
let meshCount = 0;
fbxModel.traverse((child) => {
if (child.isMesh) {
meshCount++;
console.log('[FBX] Processing mesh:', child.name, 'Material:', child.material?.type);

// Convert/normalize materials while PRESERVING textures and properties
const convertToStandard = (mat, isSkinned) => {
  if (!mat) {
    return new THREE.MeshStandardMaterial({ color: 0xcccccc, side: THREE.DoubleSide });
  }

  // Base params copied from original where available
  const params = {
    name: mat.name || 'ConvertedFBXMaterial',
    color: mat.color ? mat.color.clone() : new THREE.Color(0xffffff),
    map: mat.map || null,
    normalMap: mat.normalMap || null,
    roughnessMap: mat.roughnessMap || null,
    metalnessMap: mat.metalnessMap || null,
    emissive: mat.emissive ? mat.emissive.clone() : new THREE.Color(0x000000),
    emissiveMap: mat.emissiveMap || null,
    alphaMap: mat.alphaMap || null,
    transparent: !!mat.transparent || (mat.opacity !== undefined && mat.opacity < 1.0),
    opacity: mat.opacity !== undefined ? mat.opacity : 1.0,
    side: mat.side !== undefined ? mat.side : THREE.DoubleSide,
    metalness: mat.metalness !== undefined ? mat.metalness : 0.0,
    roughness: mat.roughness !== undefined ? mat.roughness : 0.85,
    skinning: !!isSkinned,
    depthTest: true
  };

  const newMat = new THREE.MeshStandardMaterial(params);

  // Handle alpha-tested materials (hair, foliage) to prevent black boxes
  if (newMat.alphaMap || (newMat.map && (newMat.transparent || newMat.opacity < 1.0))) {
    newMat.transparent = true;
    newMat.alphaTest = 0.5; // Cutout
    newMat.depthWrite = false; // Avoid sorting artifacts (black quads)
    newMat.premultipliedAlpha = true;
  }

  // Ensure color space on textures
  const setSRGB = (tex) => {
    if (!tex) return;
    if ('encoding' in tex) tex.encoding = THREE.sRGBEncoding;
    if ('colorSpace' in tex) tex.colorSpace = THREE.SRGBColorSpace;
    tex.anisotropy = Math.max(4, tex.anisotropy || 0);
  };
  setSRGB(newMat.map);
  setSRGB(newMat.emissiveMap);

  newMat.needsUpdate = true;
  return newMat;
};

if (!child.material) {
  child.material = convertToStandard(null, child.isSkinnedMesh);
} else if (Array.isArray(child.material)) {
  child.material = child.material.map(m => convertToStandard(m, child.isSkinnedMesh));
} else {
  child.material = convertToStandard(child.material, child.isSkinnedMesh);
}

 // Auto-hide suspicious 2D planes that tend to render as black boxes
 try {
   const geo = child.geometry;
   if (geo) {
     if (!geo.boundingBox) geo.computeBoundingBox();
     const bb = geo.boundingBox;
     const sx = bb.max.x - bb.min.x;
     const sy = bb.max.y - bb.min.y;
     const sz = bb.max.z - bb.min.z;
     const maxDim = Math.max(sx, sy, sz);
     const minDim = Math.min(sx, sy, sz);
     const isPaperThin = maxDim > 0 && (minDim / maxDim) < 0.002; // extremely thin in one axis

     const mats = Array.isArray(child.material) ? child.material : [child.material];
     const hasTexture = mats.some(m => !!m.map || !!m.alphaMap);
     const isVeryDark = mats.every(m => {
       const c = m.color || new THREE.Color(0x000000);
       return (c.r + c.g + c.b) / 3 < 0.1;
     });

     if (isPaperThin && !hasTexture && isVeryDark) {
       child.visible = false;
       child.userData.hiddenByAutoFix = true;
       console.warn('[FBX] Auto-hid thin dark plane to prevent black box:', child.name, { sx, sy, sz });
     }
   }
 } catch (e) {
   console.warn('[FBX] Geometry check failed for', child.name, e);
 }

child.castShadow = true;
child.receiveShadow = true;
child.frustumCulled = false;
}
});
console.log('[FBX] 🟢 Found', meshCount, 'meshes - converted to MeshToonMaterial');

// Add FBX model directly to scene in front of camera (like hands)
console.log('[FBX] 🔵 Adding model directly to scene for visibility');

// Force material fixups for transparency to avoid black quads
fbxModel.traverse((child) => {
  if (child.isMesh && child.material) {
    const applyFix = (mat) => {
      if (!mat) return;
      if (mat.alphaMap || (mat.map && (mat.transparent || mat.opacity < 1.0))) {
        mat.transparent = true;
        mat.alphaTest = 0.5;
        mat.depthWrite = false;
        mat.premultipliedAlpha = true;
        mat.needsUpdate = true;
      }
    };
    if (Array.isArray(child.material)) child.material.forEach(applyFix); else applyFix(child.material);
  }
});

// Position model in front of camera at a visible location
// Similar to voxel hand position - visible and accessible
fbxModel.position.set(0, 1, 5); // Center, at eye level, 5 units in front

// Ensure no leftover BoxHelpers or helpers cause black boxes
fbxModel.traverse((obj) => {
  if (obj.type === 'BoxHelper' || obj.name?.includes('Helper')) {
    if (obj.parent) obj.parent.remove(obj);
    if (obj.dispose) obj.dispose();
  }
});
fbxModel.visible = true;
fbxModel.name = `FBX_${file.name.replace(/\.[^/.]+$/, '')}`; // Name without extension
fbxModel.traverse(child => {
if (child) {
child.visible = true;
child.frustumCulled = false; // Prevent culling issues
}
});

// Create a scaled point light for the character - attached to model
const characterLight = new THREE.PointLight(0xffffff, 2.5, 10); // White light, intensity 2.5, distance 10
// Position relative to model center (above and slightly in front)
characterLight.position.set(0, size.y * 0.7, size.z * 0.5); 
characterLight.castShadow = true;
characterLight.shadow.mapSize.width = 512;
characterLight.shadow.mapSize.height = 512;
characterLight.name = `FBX_Light_${file.name.replace(/\.[^/.]+$/, '')}`;

// Add light helper (small sphere) to visualize light position
const lightHelper = new THREE.Mesh(
new THREE.SphereGeometry(0.05, 8, 8),
new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.3 })
);
lightHelper.name = 'LightHelper';
characterLight.add(lightHelper);

// Attach light to model so it moves with it
fbxModel.add(characterLight);
console.log('[FBX] 🟢 Added point light to model at relative position:', characterLight.position);

// BoxHelper removed - was causing black boxes
// If you need to see bounds for debugging, uncomment these lines:
// const helperBox = new THREE.BoxHelper(fbxModel, 0x00ff00);
// helperBox.name = 'FBX_BoundingBox_Helper';
// scene.add(helperBox);
// fbxModel.userData.helper = helperBox;

// Add model to scene
scene.add(fbxModel);

console.log('[FBX] 🟢 Model added to scene');
console.log('[FBX] 🟢 Model world position:', fbxModel.position);
console.log('[FBX] 🟢 Model scale:', fbxModel.scale);
console.log('[FBX] 🟢 Model rotation:', fbxModel.rotation);
console.log('[FBX] 🟢 Model visible:', fbxModel.visible);
console.log('[FBX] 🟢 Camera position:', camera.position);

// Maintain an array of imported FBX models to allow multiple imports
if (!window.importedFBXModels) window.importedFBXModels = [];
window.importedFBXModels.push(fbxModel);
fbxModel.userData.light = characterLight;

// Update current avatar display (if element exists)
const avatarNameEl = document.getElementById('current-avatar-name');
if (avatarNameEl) {
avatarNameEl.textContent = file.name;
}

// Hide floatingCelliAvatar if it exists
if (floatingCelliAvatar) {
const fullAvatar = floatingCelliAvatar.userData.fullAvatar;
if (fullAvatar) fullAvatar.visible = false;
floatingCelliAvatar.children.forEach(c => c.visible = false);
console.log('[FBX] Hidden floatingCelliAvatar');
}

// Refresh scene browser to include new FBX
console.log('[FBX] 🔵 Refreshing scene browser with new FBX character');
// Optionally: add to scene browser UI if available
try {
  const list = document.getElementById('scene-browser-list');
  if (list) {
    const item = document.createElement('div');
    item.className = 'hierarchy-item';
    item.textContent = fbxModel.name;
    item.onclick = () => {
      // Focus camera roughly toward the model
      const worldPos = new THREE.Vector3();
      fbxModel.getWorldPosition(worldPos);
      controls.target.copy(worldPos);
      camera.position.set(worldPos.x + 2, worldPos.y + 1.5, worldPos.z + 3);
      controls.update();
    };
    list.appendChild(item);
  }
} catch (e) {
  console.warn('[FBX] Scene browser update skipped:', e);
}

showDialogue(`✅ FBX loaded: ${file.name} (${meshCount} meshes) with lighting!`, 3000);

// Clean up
URL.revokeObjectURL(fileURL);
},
// onProgress callback
(xhr) => {
const percentComplete = xhr.loaded / xhr.total * 100;
console.log('[FBX] 🔵 Progress:', percentComplete.toFixed(2), '%');
},
// onError callback
(error) => {
clearTimeout(timeoutId);
console.error('[FBX] ❌ Error loading model:', error);
console.error('[FBX] ❌ Error details:', {
message: error.message,
stack: error.stack,
fileName: file.name,
fileSize: file.size
});
showDialogue(`❌ Error loading FBX: ${error.message || 'Unknown error'}`, 4000);
URL.revokeObjectURL(fileURL);
}
);

// Reset file input
event.target.value = '';
});

document.querySelectorAll('.avatar-select-btn').forEach(btn => {
btn.addEventListener('click', () => {
const avatarType = btn.dataset.avatar;
console.log(`[Avatar] Selected avatar type: ${avatarType}`);
switchFloatingAvatar(avatarType);
document.getElementById('avatar-selector-modal').classList.remove('active');
document.getElementById('current-avatar-name').textContent = 
avatarType === 'border' ? 'Border Cursor' :
avatarType === 'full' ? 'Full Celli' :
avatarType === 'hybrid' ? 'Hybrid (Border + Full)' :
avatarType === 'bob' ? 'Bob' :
avatarType === 'palette' ? 'Pal-ette' :
'Side-by-Side';
});
});

function switchFloatingAvatar(type) {
if (!floatingCelliAvatar) {
console.warn('[Avatar] No floating avatar to switch');
return;
}

// Clear existing content
const fullAvatar = floatingCelliAvatar.userData.fullAvatar;
const borderFrame = floatingCelliAvatar.children.find(c => c.name === 'CelliBorderAvatar' || c.userData?.bodyFrame);

switch(type) {
case 'border':
// Hide full avatar, keep border
if (fullAvatar) fullAvatar.visible = false;
// Remove custom avatars if present
if (floatingCelliAvatar.userData.customAvatar) {
floatingCelliAvatar.remove(floatingCelliAvatar.userData.customAvatar);
floatingCelliAvatar.userData.customAvatar = null;
}
if (floatingCelliAvatar.userData.customAvatarHelper) {
floatingCelliAvatar.remove(floatingCelliAvatar.userData.customAvatarHelper);
floatingCelliAvatar.userData.customAvatarHelper.dispose();
floatingCelliAvatar.userData.customAvatarHelper = null;
}
// Hide FBX if loaded
if (window.loadedFBXModel) {
window.loadedFBXModel.visible = false;
// Hide helper if it exists (from old versions)
if (window.loadedFBXModel.userData.helper) {
window.loadedFBXModel.userData.helper.visible = false;
}
// Hide light
if (window.loadedFBXModel.userData.light) {
window.loadedFBXModel.userData.light.visible = false;
}
}
// Show border frame
floatingCelliAvatar.children.forEach(c => {
if (c !== fullAvatar && c !== floatingCelliAvatar.userData.glow) {
c.visible = true;
}
});
console.log('[Avatar] Showing border only');
break;

case 'full':
// Hide border frame parts, show only full avatar
if (borderFrame) {
floatingCelliAvatar.children.forEach(c => {
if (c === fullAvatar || c === floatingCelliAvatar.userData.glow) {
c.visible = true;
} else {
c.visible = false;
}
});
}
if (fullAvatar) fullAvatar.visible = true;
// Remove custom avatars if present
if (floatingCelliAvatar.userData.customAvatar) {
floatingCelliAvatar.remove(floatingCelliAvatar.userData.customAvatar);
floatingCelliAvatar.userData.customAvatar = null;
}
if (floatingCelliAvatar.userData.customAvatarHelper) {
floatingCelliAvatar.remove(floatingCelliAvatar.userData.customAvatarHelper);
floatingCelliAvatar.userData.customAvatarHelper.dispose();
floatingCelliAvatar.userData.customAvatarHelper = null;
}
// Hide FBX if loaded
if (window.loadedFBXModel) {
window.loadedFBXModel.visible = false;
// Hide helper if it exists (from old versions)
if (window.loadedFBXModel.userData.helper) {
window.loadedFBXModel.userData.helper.visible = false;
}
// Hide light
if (window.loadedFBXModel.userData.light) {
window.loadedFBXModel.userData.light.visible = false;
}
}
console.log('[Avatar] Showing full character only');
break;

case 'hybrid':
// Show both (default)
if (fullAvatar) fullAvatar.visible = true;
floatingCelliAvatar.children.forEach(c => {
if (c !== floatingCelliAvatar.userData.customAvatar && c !== floatingCelliAvatar.userData.customAvatarHelper) {
c.visible = true;
}
});
// Remove custom avatars if present
if (floatingCelliAvatar.userData.customAvatar) {
floatingCelliAvatar.remove(floatingCelliAvatar.userData.customAvatar);
floatingCelliAvatar.userData.customAvatar = null;
}
if (floatingCelliAvatar.userData.customAvatarHelper) {
floatingCelliAvatar.remove(floatingCelliAvatar.userData.customAvatarHelper);
floatingCelliAvatar.userData.customAvatarHelper.dispose();
floatingCelliAvatar.userData.customAvatarHelper = null;
}
// Hide FBX if loaded
if (window.loadedFBXModel) {
window.loadedFBXModel.visible = false;
// Hide helper if it exists (from old versions)
if (window.loadedFBXModel.userData.helper) {
window.loadedFBXModel.userData.helper.visible = false;
}
// Hide light
if (window.loadedFBXModel.userData.light) {
window.loadedFBXModel.userData.light.visible = false;
}
}
console.log('[Avatar] Showing hybrid (border + full)');
break;

case 'both':
// Create side-by-side (would need separate implementation)
console.log('[Avatar] Side-by-side not yet implemented - showing hybrid');
if (fullAvatar) fullAvatar.visible = true;
floatingCelliAvatar.children.forEach(c => {
if (c !== floatingCelliAvatar.userData.customAvatar && c !== floatingCelliAvatar.userData.customAvatarHelper) {
c.visible = true;
}
});
// Remove custom avatars if present
if (floatingCelliAvatar.userData.customAvatar) {
floatingCelliAvatar.remove(floatingCelliAvatar.userData.customAvatar);
floatingCelliAvatar.userData.customAvatar = null;
}
if (floatingCelliAvatar.userData.customAvatarHelper) {
floatingCelliAvatar.remove(floatingCelliAvatar.userData.customAvatarHelper);
floatingCelliAvatar.userData.customAvatarHelper.dispose();
floatingCelliAvatar.userData.customAvatarHelper = null;
}
// Hide FBX if loaded
if (window.loadedFBXModel) {
window.loadedFBXModel.visible = false;
// Hide helper if it exists (from old versions)
if (window.loadedFBXModel.userData.helper) {
window.loadedFBXModel.userData.helper.visible = false;
}
// Hide light
if (window.loadedFBXModel.userData.light) {
window.loadedFBXModel.userData.light.visible = false;
}
}
break;

case 'bob':
// Hide all existing avatars
if (fullAvatar) fullAvatar.visible = false;
floatingCelliAvatar.children.forEach(c => c.visible = false);
// Remove previous custom avatar if exists
if (floatingCelliAvatar.userData.customAvatar) {
floatingCelliAvatar.remove(floatingCelliAvatar.userData.customAvatar);
}
// Hide FBX if loaded
if (window.loadedFBXModel) {
window.loadedFBXModel.visible = false;
// Hide helper if it exists (from old versions)
if (window.loadedFBXModel.userData.helper) {
window.loadedFBXModel.userData.helper.visible = false;
}
// Hide light
if (window.loadedFBXModel.userData.light) {
window.loadedFBXModel.userData.light.visible = false;
}
}
// Create and add Bob
const bob = createBob();
floatingCelliAvatar.add(bob);
floatingCelliAvatar.userData.customAvatar = bob;
console.log('[Avatar] Showing Bob');
break;

case 'palette':
// Hide all existing avatars
if (fullAvatar) fullAvatar.visible = false;
floatingCelliAvatar.children.forEach(c => c.visible = false);
// Remove previous custom avatar if exists
if (floatingCelliAvatar.userData.customAvatar) {
floatingCelliAvatar.remove(floatingCelliAvatar.userData.customAvatar);
}
// Hide FBX if loaded
if (window.loadedFBXModel) {
window.loadedFBXModel.visible = false;
// Hide helper if it exists (from old versions)
if (window.loadedFBXModel.userData.helper) {
window.loadedFBXModel.userData.helper.visible = false;
}
// Hide light
if (window.loadedFBXModel.userData.light) {
window.loadedFBXModel.userData.light.visible = false;
}
}
// Create and add Pal-ette
const palette = createPalette();
floatingCelliAvatar.add(palette);
floatingCelliAvatar.userData.customAvatar = palette;
console.log('[Avatar] Showing Pal-ette');
break;
}
}

// ===== Start =====
console.log('[Init] Starting application...');

(async () => {
  try {
    await initialize();
    animate();
    console.log('[Init] ✅ Application started successfully');
  } catch (err) {
    console.error('[Init] Fatal error during startup:', err);
    const statusEl = document.getElementById('status-message');
    if (statusEl) statusEl.textContent = 'Fatal error - check console (F12)';
  }
})();
 </script>
 
 <!-- Screen Recorder - Universal Support -->
 <script src="https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.js"></script>
 <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
 <script src="../../src/scripts/tools/recorder-standalone.js"></script>
 
</body>
</html>

