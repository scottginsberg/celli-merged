 <!doctype html>
<html lang="en">
<head>
 <meta charset="utf-8"/>
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
 <meta name="viewport" content="width=device-width, initial-scale=1"/>
 <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
 <meta http-equiv="Pragma" content="no-cache" />
 <meta http-equiv="Expires" content="0" />
 <meta name="version" content="5.6-celli-avatar-enhanced" />
<!-- v5.6: Enhanced Celli avatar - raised position, slab-shaped head, larger voxels, pink cheeks, eye lights -->
 <title>Tri-Trail Evolved three.js [v4.2 THE.OS]</title>
 <link rel="preconnect" href="https://fonts.googleapis.com">
 <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
 <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Roboto+Mono:wght@100;300&family=VT323&display=swap" rel="stylesheet">
 <!-- Twemoji for consistent emoji rendering -->
 <script src="https://unpkg.com/twemoji@latest/dist/twemoji.min.js"></script>
<style>
:root { --bg: #000; --fg: #e6e6e6; --accent:#8ab4ff; }
html, body { margin:0; height:100%; background:#000; overflow:hidden; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Segoe UI Symbol", "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", Roboto, Helvetica, Arial, sans-serif; }
#app { position:fixed; inset:0; background:var(--bg); z-index:60; pointer-events:none; }
.hud { position:fixed; inset:0; pointer-events:none; font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", "Segoe UI Symbol", "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", Roboto, Inter, "Helvetica Neue", Arial, sans-serif; z-index:65; }
 .brand { position:absolute; left:2rem; bottom:2rem; color:var(--fg); letter-spacing:0.08em; font-weight:600; font-size:12px; opacity:.65; text-transform:uppercase; }
 .quote { position:absolute; left:50%; top:50%; transform:translate(-50%, -50%); color:var(--fg); font-weight:300; font-size:16px; letter-spacing:0.03em; line-height:1.6; max-width:560px; width:90%; text-align:center; font-style:italic; margin:0; padding:0 20px; box-sizing:border-box; z-index:10; visibility:hidden; opacity:0; transition: color 0.45s ease, text-shadow 0.45s ease; }
 .quote__text { display:block; max-width:100%; }
 .quote.quote--loom { font-family:'Roboto Mono', ui-monospace, monospace; font-style:normal; letter-spacing:0.12em; }
 .quote.visible { animation: fadeInQuote 3s ease-out forwards; display:block !important; visibility:visible; }
 @keyframes fadeInQuote {
 0% { opacity:0; transform:translate(-50%, -50%) translateY(20px); }
 100% { opacity:.85; transform:translate(-50%, -50%) translateY(0); }
 }
 .quote.glitch { animation: glitchText 0.5s ease-in-out infinite; }
 .quote.scrambling { text-shadow: 0 0 18px rgba(138, 180, 255, 0.4); color:#f5f5f5; }
 @keyframes glitchText {
 0%, 100% { opacity:.85; transform:translate(-50%, -50%) translateX(0); text-shadow: 0 0 0 transparent; }
 10% { opacity:.8; transform:translate(-50%, -50%) translateX(-1px); text-shadow: 1px 0 #ff1e6e, -1px 0 #00a8ff; }
 20% { opacity:.9; transform:translate(-50%, -50%) translateX(1px); text-shadow: -1px 0 #ffb62e, 1px 0 #00a8ff; }
 30% { opacity:.85; transform:translate(-50%, -50%) translateX(0); text-shadow: 0 0 0 transparent; }
 }
 .quote.glitchMedium { animation: glitchMedium 0.3s ease-in-out infinite; }
 @keyframes glitchMedium {
 0%, 100% { opacity:.82; transform:translate(-50%, -50%) translateX(0) translateY(0); text-shadow: 0 0 0 transparent; }
 15% { opacity:.7; transform:translate(-50%, -50%) translateX(-3px) translateY(1px); text-shadow: 2px 0 #ff1e6e, -2px 0 #00a8ff; }
 35% { opacity:.8; transform:translate(-50%, -50%) translateX(3px) translateY(-2px); text-shadow: -3px 0 #ffb62e, 3px 0 #00a8ff; }
 55% { opacity:.75; transform:translate(-50%, -50%) translateX(-2px) translateY(2px); text-shadow: 2px 0 #00a8ff, -2px 0 #ff1e6e; }
 75% { opacity:.78; transform:translate(-50%, -50%) translateX(2px) translateY(-1px); text-shadow: -2px 0 #ffb62e, 2px 0 #ff1e6e; }
 }
 .quote.glitchIntense { animation: glitchIntense 0.12s ease-in-out infinite; }
 @keyframes glitchIntense {
 0% { opacity:.75; transform:translate(-50%, -50%) translateX(0) translateY(0); text-shadow: 0 0 0 transparent; }
 12% { opacity:.5; transform:translate(-50%, -50%) translateX(-8px) translateY(4px); text-shadow: 4px 0 #ff1e6e, -4px 0 #00a8ff, 0 4px #ffb62e; }
 25% { opacity:.7; transform:translate(-50%, -50%) translateX(6px) translateY(-6px); text-shadow: -6px 0 #ffb62e, 6px 0 #00a8ff, 0 -6px #ff1e6e; }
 40% { opacity:.45; transform:translate(-50%, -50%) translateX(-10px) translateY(8px); text-shadow: 8px 0 #00a8ff, -8px 0 #ff1e6e; }
 55% { opacity:.65; transform:translate(-50%, -50%) translateX(5px) translateY(-3px); text-shadow: -5px 0 #ffb62e, 5px 0 #ff1e6e; }
 70% { opacity:.55; transform:translate(-50%, -50%) translateX(-7px) translateY(5px); text-shadow: 6px 0 #00a8ff, -5px 0 #ffb62e; }
 85% { opacity:.6; transform:translate(-50%, -50%) translateX(8px) translateY(-4px); text-shadow: -7px 0 #ff1e6e, 6px 0 #00a8ff; }
 100% { opacity:.5; transform:translate(-50%, -50%) translateX(0) translateY(0); text-shadow: 0 0 0 transparent; }
 }
 .loomworks { position:absolute; left:50%; top:50%; transform:translate(calc(-50% + var(--loomOffsetX, 0px)), calc(-50% + var(--loomOffsetY, 0px))); color:#fff; font-weight:300; font-size:20px; letter-spacing:0.15em; opacity:0; text-align:center; pointer-events:none; font-family:'Roboto Mono', ui-monospace, monospace; white-space:nowrap; }
 .loomworks.visible { animation: fadeInLoom 2s ease-out forwards; }
 .loomworks-chunk { display:inline-block; padding:0 0.08em; opacity:0; transform:translateY(12px); transition: opacity 0.45s ease, transform 0.45s ease, background 0.25s ease, color 0.25s ease; }
 .loomworks.visible .loomworks-chunk { opacity:1; transform:translateY(0); }
 .loomworks-chunk.selected { background:#fff; color:#000; box-shadow:0 0 0 1px rgba(0,0,0,0.55); }
 .loomworks-chunk.shift-right { transform:translateX(0.35em); }
 #loomTail { white-space:pre; }
 @keyframes shake {
 0%, 100% { transform: translateX(0); }
 10%, 30%, 50%, 70%, 90% { transform: translateX(-10px); }
 20%, 40%, 60%, 80% { transform: translateX(10px); }
 }
 @keyframes pulse {
 0%, 100% { opacity: 1; transform: scale(1); }
 50% { opacity: 0.7; transform: scale(1.05); }
 }
 @keyframes fadeIn {
 from { opacity: 0; }
 to { opacity: 1; }
 }
 @keyframes fadeInLoom {
 0% { opacity:0; transform:translate(-50%, -50%) scale(0.95); }
 100% { opacity:1; transform:translate(-50%, -50%) scale(1); }
 }
 
 /* Doorway portal - starts as vertical bar */
 .doorway { position:fixed; left:50%; bottom:20%; transform:translate(-50%, 0); width:4px; height:60px; background:#fff; pointer-events:none; z-index:68; opacity:0; box-shadow: 0 0 15px 5px rgba(255,255,255,0.8), 0 0 30px 10px rgba(255,255,255,0.5); transition: width 1.5s cubic-bezier(0.4, 0, 0.2, 1), height 1.5s cubic-bezier(0.4, 0, 0.2, 1), box-shadow 1.5s ease-out, opacity 0.5s ease-out; overflow:hidden; }
 .doorway.visible { opacity:1; }
 .doorway.open { width:min(280px, 85vw); height:80px; box-shadow: 0 0 40px 20px rgba(255,255,255,0.7), 0 0 80px 35px rgba(255,255,255,0.4), inset 0 0 60px rgba(255,255,255,0.6); }
 
 /* Light rays emanating from doorway - forward emission only (cut off at top) */
 .doorway::before { content:""; position:absolute; left:-150%; right:-150%; top:0%; bottom:-200%; background:radial-gradient(ellipse 120% 80% at center top, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0.15) 40%, transparent 70%); opacity:0; transition:opacity 1.5s ease-out; pointer-events:none; clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%); }
 .doorway.open::before { opacity:1; }
 
 /* Input prompt inside doorway */
 .prompt-container { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; opacity:0; transition:opacity 1s ease-in 1.5s; pointer-events:none; user-select:none; -webkit-user-select:none; }
 .doorway.open .prompt-container { opacity:1; pointer-events:auto; cursor:text; }
 .prompt {
 position: relative;
 font-family: 'VT323', 'Press Start 2P', 'Roboto Mono', ui-monospace, monospace;
 font-size: clamp(13px, 3.1vw, 34px);
 font-weight:400;
 color:#000;
 letter-spacing:0.22em;
 text-transform:uppercase;
 z-index: 2;
 white-space: nowrap;
 display: inline-flex;
 }
 /* Per-character shadow - each char gets its own shadow aligned to its bottom edge */
 .prompt .char {
 position: relative;
 display: inline-block;
 }
 .prompt .char::after {
 content: attr(data-char);
 position: absolute;
 left: 0;
 top: 100%; /* Start at bottom edge of character */
 font-family: 'VT323', 'Press Start 2P', 'Roboto Mono', ui-monospace, monospace;
 font-size: clamp(13px, 3.1vw, 34px);
 font-weight: 400;
 color: rgba(0, 0, 0, 0.92);
 transform-origin: top left;
 transform: translate(3px, 0) scaleY(-1.08) skewX(-20deg) scaleX(1.15);
 opacity: 0.4;
 filter: blur(1.2px);
 z-index: -1;
 pointer-events: none;
 mask-image: linear-gradient(to bottom, rgba(0,0,0,1) 0%, rgba(0,0,0,0.65) 40%, rgba(0,0,0,0) 100%);
 -webkit-mask-image: linear-gradient(to bottom, rgba(0,0,0,1) 0%, rgba(0,0,0,0.65) 40%, rgba(0,0,0,0) 100%);
 }
 .cursor { animation:blink 1s step-end infinite; }
 @keyframes blink {
 0%, 50% { opacity:1; }
 51%, 100% { opacity:0; }
 }
 
 /* CELLI glitch effects */
 .celli-glitch .char { display:inline-block; transition:opacity 0.1s; }
 .celli-glitch .char.flicker { animation:celliFlicker 0.15s infinite; }
 .celli-glitch .char.hidden { opacity:0; }
 @keyframes celliFlicker {
 0%, 100% { opacity:1; text-shadow: 0 0 8px currentColor; }
 25% { opacity:0.3; transform:translateX(-2px); }
 50% { opacity:0.6; transform:translateX(2px); }
 75% { opacity:0.2; transform:translateY(-1px); }
 }
 .screenGlitch { position:fixed; inset:0; pointer-events:none; background:#000; opacity:0; z-index:5; mix-blend-mode:normal; }
 .screenGlitch.active { animation: screenFlicker 0.2s infinite; }
 @keyframes screenFlicker {
 0%, 100% { opacity:0; background:#000; }
 15% { opacity:0.08; background:#fff; }
 30% { opacity:0; background:#000; }
 45% { opacity:0.12; background:#00a8ff; }
 60% { opacity:0; background:#000; }
 80% { opacity:0.1; background:#ff1e6e; }
 }
 .fallback { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:#000; color:#bbb; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial; }
 .scanlines::before { content:""; position:absolute; inset:0; pointer-events:none; background: repeating-linear-gradient( to bottom, rgba(255,255,255,0.04), rgba(255,255,255,0.04) 1px, transparent 1px, transparent 3px ); mix-blend-mode: overlay; opacity:.18; transition: opacity 1s ease; }
 .scanlines.fade-scanlines::before { opacity: 0; }
 .vignette { position:absolute; inset:0; pointer-events:none; box-shadow: inset 0 0 240px rgba(0,0,0,.75), inset 0 0 800px rgba(0,0,0,.65); }
 canvas { filter: saturate(1.06) contrast(1.06) brightness(1.02); display:block; }

/* Play overlay */
.play { position:fixed; inset:0; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:15px; background: radial-gradient(ellipse at center, rgba(30,30,30,.6) 0%, rgba(0,0,0,.9) 60%); z-index:100; pointer-events:auto; }
 .play.hidden{ display:none; }
 .play button{ pointer-events:auto; appearance:none; border:none; padding:14px 20px; border-radius:999px; font-weight:700; letter-spacing:.06em; text-transform:uppercase; background:#111; color:#e8eaed; box-shadow: 0 0 0 2px rgba(255,255,255,.08) inset, 0 6px 20px rgba(0,0,0,.45); cursor:pointer; display:flex; gap:12px; align-items:center; justify-content:center; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Segoe UI Symbol", "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", Roboto, Helvetica, Arial, sans-serif; }
#playBtn::before{ content:"\25B6"; font-size:14px; opacity:.9; }
 
 /* Skip button - Equilateral triangles */
 .skip-btn { position:fixed; bottom:20px; left:50%; transform:translate(-50%, 0); pointer-events:auto; cursor:pointer; z-index:70; opacity:0.75; display:flex; align-items:center; justify-content:center; gap:0; transition: opacity 0.45s ease; --skip-triangle-size:28px; --skip-triangle-height: calc(var(--skip-triangle-size) * 0.8660254038); }
 .skip-btn:hover { opacity:1; }
 .skip-btn.hidden { display:none; }
 .skip-btn.bow-lock { pointer-events:none; }
 .skip-btn.voxel-hidden { opacity:0; pointer-events:none; transition: opacity 0.35s ease, filter 0.35s ease; filter: brightness(0.65); }
 .skip-btn.golden-phase { color:#fff48a; }
.skip-triangle { position:relative; width:var(--skip-triangle-size); height:var(--skip-triangle-height); display:flex; align-items:center; justify-content:center; transition: transform 0.85s cubic-bezier(0.19, 1, 0.22, 1), filter 0.6s ease; z-index: 1; }
.skip-triangle__inner { width:100%; height:100%; display:flex; filter: drop-shadow(0 0 3px rgba(255,255,255,0.25)) drop-shadow(0 0 6px rgba(255,255,255,0.15)); transform-origin:center; transition: filter 0.6s ease, transform 0.6s ease; }
.skip-triangle--right .skip-triangle__inner { transform: scaleX(-1); }
.skip-triangle svg { width:100%; height:100%; display:block; }
.skip-triangle polygon, .skip-triangle path { fill:#fff; stroke:rgba(255,255,255,0.45); stroke-width:5; stroke-linejoin:round; transition: stroke 0.6s ease, fill 0.6s ease, opacity 0.5s ease; animation: skipFillShimmer 2s ease-in-out infinite, skipOutlinePulse 2.8s ease-in-out infinite; }
.skip-triangle path { opacity:0; }
 /* Initial position - closer together, vertex to edge */
 .skip-btn:not(.bow-shape) .skip-triangle--left { transform: translateX(calc(var(--skip-triangle-size) * -0.25)); }
 .skip-btn:not(.bow-shape) .skip-triangle--right { transform: translateX(calc(var(--skip-triangle-size) * 0.25)); }
 .skip-btn.bow-shape { gap:0; opacity:1; --skip-triangle-size:32px; }
 .skip-btn.bow-shape .skip-triangle { position:absolute; top:50%; left:50%; margin:0; }
/* Unified glow to match voxel squares exactly */
.skip-btn.bow-shape .skip-triangle__inner { filter: drop-shadow(0 0 3px rgba(255,255,255,0.25)) drop-shadow(0 0 6px rgba(255,255,255,0.15)); }
 .skip-btn.bow-shape .skip-triangle--left { transform: translate(-50%, -50%) translateX(calc(var(--skip-triangle-size) * -0.5)); }
 .skip-btn.bow-shape .skip-triangle--right { transform: translate(-50%, -50%) translateX(calc(var(--skip-triangle-size) * 0.5)); }
 .skip-btn.bow-shape .skip-triangle--right .skip-triangle__inner { transform: scaleX(1); }
 .skip-connector { position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); width:0; height:0; border-radius:0; background:transparent; box-shadow:none; opacity:0; transition: all 0.6s ease; pointer-events:none; z-index: 0; }
 .skip-btn.rounded-bow .skip-triangle polygon { opacity:0; }
 .skip-btn.rounded-bow .skip-triangle path { opacity:1; }
/* Connector with unified glow - solid core like a voxel */
.skip-btn.rounded-bow .skip-connector { width:calc(var(--skip-triangle-size) * 0.48); height:calc(var(--skip-triangle-size) * 0.48); border-radius:calc(var(--skip-triangle-size) * 0.12); background:rgba(255,255,255,1); box-shadow:0 0 3px rgba(255,255,255,0.25), 0 0 6px rgba(255,255,255,0.15); opacity:1; animation: skipCenterPulse 2.2s ease-in-out infinite; }
.skip-btn.illuminating .skip-triangle__inner { animation: skipGlowPulse 2.4s ease-in-out infinite; }
.skip-btn.illuminating.bow-shape .skip-triangle--left .skip-triangle__inner { animation: skipGlowPulse 2.4s ease-in-out infinite, skipJiggleLeft 1.6s ease-in-out infinite; }
.skip-btn.illuminating.bow-shape .skip-triangle--right .skip-triangle__inner { animation: skipGlowPulse 2.4s ease-in-out infinite, skipJiggleRight 1.6s ease-in-out infinite; }
 .skip-btn.golden-phase .skip-triangle polygon,
 .skip-btn.golden-phase .skip-triangle path { fill:#fff48a; stroke:rgba(255,214,120,0.65); }
 /* Golden phase - ultra-minimal glow to match voxel squares */
 .skip-btn.golden-phase .skip-triangle__inner { filter: drop-shadow(0 0.5px 1px rgba(255,215,96,0.08)) drop-shadow(0 0 2px rgba(255,238,160,0.05)); }
 .skip-btn.golden-phase.rounded-bow .skip-connector { background: radial-gradient(circle at 50% 45%, rgba(255,248,170,1) 0%, rgba(255,219,92,1) 45%, rgba(255,199,60,0.98) 100%); box-shadow:0 0 2px rgba(255,215,96,0.08), 0 0 3px rgba(255,239,168,0.05); }
 .skip-btn.golden-phase.illuminating .skip-triangle polygon,
 .skip-btn.golden-phase.illuminating .skip-triangle path { animation: skipFillShimmer 2s ease-in-out infinite, skipOutlinePulse 2.8s ease-in-out infinite; }
 
 /* Magenta phase - ultra-minimal glow to match voxel squares */
 .skip-btn.magenta-phase .skip-triangle polygon,
 .skip-btn.magenta-phase .skip-triangle path { fill:#ff1e6e; stroke:rgba(255,100,140,0.65); }
 .skip-btn.magenta-phase .skip-triangle__inner { filter: drop-shadow(0 0.5px 1px rgba(255,30,110,0.08)) drop-shadow(0 0 2px rgba(255,100,160,0.05)); }
 .skip-btn.magenta-phase.rounded-bow .skip-connector { background: radial-gradient(circle at 50% 45%, rgba(255,80,140,1) 0%, rgba(255,30,110,1) 45%, rgba(220,20,90,0.98) 100%); box-shadow:0 0 2px rgba(255,30,110,0.08), 0 0 3px rgba(255,100,160,0.05); }
 .skip-btn.magenta-phase.illuminating .skip-triangle polygon,
 .skip-btn.magenta-phase.illuminating .skip-triangle path { animation: skipFillShimmer 2s ease-in-out infinite, skipOutlinePulse 2.8s ease-in-out infinite; }
 
 /* Cyan phase - ultra-minimal glow to match voxel squares */
 .skip-btn.cyan-phase .skip-triangle polygon,
 .skip-btn.cyan-phase .skip-triangle path { fill:#00a8ff; stroke:rgba(100,180,255,0.65); }
 .skip-btn.cyan-phase .skip-triangle__inner { filter: drop-shadow(0 0.5px 1px rgba(0,168,255,0.08)) drop-shadow(0 0 2px rgba(100,200,255,0.05)); }
 .skip-btn.cyan-phase.rounded-bow .skip-connector { background: radial-gradient(circle at 50% 45%, rgba(100,200,255,1) 0%, rgba(0,168,255,1) 45%, rgba(0,140,220,0.98) 100%); box-shadow:0 0 2px rgba(0,168,255,0.08), 0 0 3px rgba(100,200,255,0.05); }
 .skip-btn.cyan-phase.illuminating .skip-triangle polygon,
 .skip-btn.cyan-phase.illuminating .skip-triangle path { animation: skipFillShimmer 2s ease-in-out infinite, skipOutlinePulse 2.8s ease-in-out infinite; }

@keyframes skipGlowPulse {
0%, 100% { filter: drop-shadow(0 0 3px rgba(255,255,255,0.25)) drop-shadow(0 0 6px rgba(255,255,255,0.15)); }
45% { filter: drop-shadow(0 0 4px rgba(255,255,255,0.30)) drop-shadow(0 0 8px rgba(138,180,255,0.20)); }
55% { filter: drop-shadow(0 0 4px rgba(255,255,255,0.28)) drop-shadow(0 0 8px rgba(255,182,46,0.18)); }
}
 @keyframes skipFillShimmer {
 0%, 100% { fill:#ffffff; }
 25% { fill:#f5f9ff; }
 50% { fill:#ffffff; }
 75% { fill:#eef3ff; }
 }
 @keyframes skipOutlinePulse {
 0%, 100% { stroke:rgba(138,180,255,0.45); stroke-width:5; }
 40% { stroke:rgba(255,255,255,0.85); stroke-width:6.5; }
 60% { stroke:rgba(255,182,46,0.7); stroke-width:6; }
 }
 @keyframes skipJiggleLeft {
 0%, 100% { transform: translate(0, 0); }
 40% { transform: translate(-6%, -6%); }
 70% { transform: translate(4%, 4%); }
 }
 @keyframes skipJiggleRight {
 0%, 100% { transform: translate(0, 0); }
 40% { transform: translate(6%, -5%); }
 70% { transform: translate(-4%, 4%); }
 }
@keyframes skipCenterPulse {
0%, 100% { box-shadow:0 0 3px rgba(255,255,255,0.25), 0 0 6px rgba(255,255,255,0.15); }
45% { box-shadow:0 0 4px rgba(138,180,255,0.30), 0 0 8px rgba(255,255,255,0.20); }
65% { box-shadow:0 0 4px rgba(255,182,46,0.28), 0 0 8px rgba(255,255,255,0.18); }
}

/* Idle timeout bloom increase */
.skip-btn.idle-bloom-increase .skip-triangle__inner { 
animation: skipGlowPulse 2.4s ease-in-out infinite, idleBloomIncrease 3s ease-out forwards; 
}
.skip-btn.idle-bloom-increase.rounded-bow .skip-connector { 
animation: skipCenterPulse 2.2s ease-in-out infinite, idleBloomIncrease 3s ease-out forwards; 
}

@keyframes idleBloomIncrease {
0% { filter: drop-shadow(0 0 3px rgba(255,255,255,0.25)) drop-shadow(0 0 6px rgba(255,255,255,0.15)); }
100% { filter: drop-shadow(0 0 12px rgba(255,255,255,0.50)) drop-shadow(0 0 24px rgba(255,255,255,0.30)) drop-shadow(0 0 36px rgba(255,255,255,0.15)); }
}

/* Static glitch distortion after max bloom */
.skip-btn.idle-glitching { animation: staticGlitchDistortion 0.15s steps(4) infinite; }
@keyframes staticGlitchDistortion {
0% { transform: translate(-50%, 0) translateX(0px); }
25% { transform: translate(-50%, 0) translateX(-3px); }
50% { transform: translate(-50%, 0) translateX(2px); }
75% { transform: translate(-50%, 0) translateX(-2px); }
100% { transform: translate(-50%, 0) translateX(1px); }
}

/* Barrel distortion - CRT bulge effect with radial scaling */
 @keyframes barrelStage1 {
 0% { 
 transform: perspective(1400px) translateZ(0) scale(1) rotateX(0deg); 
 filter: saturate(1) contrast(1); 
 border-radius: 0;
 box-shadow: none;
 }
 35% { 
 transform: perspective(700px) translateZ(85px) scale(1.08) rotateX(2deg); 
 filter: saturate(1.15) contrast(1.1) brightness(1.05);
 border-radius: 16px;
 box-shadow: 0 0 30px rgba(0,255,0,0.3), inset 0 0 20px rgba(0,255,0,0.1);
 }
 70% { 
 transform: perspective(900px) translateZ(35px) scale(1.04) rotateX(1deg); 
 filter: saturate(1.08) contrast(1.06) brightness(1.02);
 border-radius: 10px;
 box-shadow: 0 0 20px rgba(0,255,0,0.2), inset 0 0 15px rgba(0,255,0,0.05);
 }
 100% { 
 transform: perspective(1100px) translateZ(24px) scale(1.025) rotateX(0.5deg); 
 filter: saturate(1.05) contrast(1.03);
 border-radius: 8px;
 box-shadow: 0 0 15px rgba(0,255,0,0.15), inset 0 0 10px rgba(0,255,0,0.03);
 }
 }
 @keyframes barrelStage2 {
 0% { 
 transform: perspective(1100px) translateZ(24px) scale(1.025) rotateX(0.5deg); 
 filter: saturate(1.05) contrast(1.04); 
 border-radius: 8px;
 box-shadow: 0 0 15px rgba(0,255,0,0.15), inset 0 0 10px rgba(0,255,0,0.03);
 }
 38% { 
 transform: perspective(600px) translateZ(140px) scale(1.15) rotateX(4deg); 
 filter: saturate(1.35) contrast(1.25) brightness(1.08);
 border-radius: 24px;
 box-shadow: 0 0 50px rgba(0,255,0,0.5), inset 0 0 30px rgba(0,255,0,0.2);
 }
 72% { 
 transform: perspective(750px) translateZ(65px) scale(1.08) rotateX(2deg); 
 filter: saturate(1.20) contrast(1.15) brightness(1.04);
 border-radius: 18px;
 box-shadow: 0 0 35px rgba(0,255,0,0.35), inset 0 0 20px rgba(0,255,0,0.12);
 }
 100% { 
 transform: perspective(900px) translateZ(40px) scale(1.05) rotateX(1deg); 
 filter: saturate(1.14) contrast(1.1);
 border-radius: 14px;
 box-shadow: 0 0 25px rgba(0,255,0,0.25), inset 0 0 15px rgba(0,255,0,0.08);
 }
 }
 @keyframes barrelStage3 {
 0% { 
 transform: perspective(900px) translateZ(40px) scale(1.05) rotateX(1deg); 
 filter: saturate(1.14) contrast(1.1); 
 border-radius: 14px;
 box-shadow: 0 0 25px rgba(0,255,0,0.25), inset 0 0 15px rgba(0,255,0,0.08);
 }
 32% { 
 transform: perspective(500px) translateZ(210px) scale(1.22) rotateX(6deg); 
 filter: saturate(1.65) contrast(1.45) brightness(1.12);
 border-radius: 32px;
 box-shadow: 0 0 70px rgba(0,255,0,0.7), inset 0 0 40px rgba(0,255,0,0.3);
 }
 62% { 
 transform: perspective(600px) translateZ(120px) scale(1.14) rotateX(4deg); 
 filter: saturate(1.45) contrast(1.32) brightness(1.08);
 border-radius: 26px;
 box-shadow: 0 0 55px rgba(0,255,0,0.55), inset 0 0 30px rgba(0,255,0,0.22);
 }
 88% { 
 transform: perspective(700px) translateZ(75px) scale(1.10) rotateX(2.5deg); 
 filter: saturate(1.32) contrast(1.22) brightness(1.05);
 border-radius: 20px;
 box-shadow: 0 0 40px rgba(0,255,0,0.4), inset 0 0 22px rgba(0,255,0,0.15);
 }
 100% { 
 transform: perspective(800px) translateZ(55px) scale(1.07) rotateX(1.5deg); 
 filter: saturate(1.24) contrast(1.16);
 border-radius: 16px;
 box-shadow: 0 0 30px rgba(0,255,0,0.3), inset 0 0 18px rgba(0,255,0,0.12);
 }
 }
 @keyframes screenShatterFlash {
 0% { opacity:0; filter:brightness(1); }
 10% { opacity:1; filter:brightness(1.35); }
 40% { opacity:0.85; filter:brightness(1.12); }
 100% { opacity:0.72; filter:brightness(1.05); }
 }
 @keyframes screenShatterFade {
 0% { opacity:0.7; }
 60% { opacity:0.4; }
 100% { opacity:0; }
 }
 #visicalc.barrel-stage-1, #visicalc.barrel-stage-1 #visicalc-frame { animation: barrelStage1 1.2s ease forwards; }
 #visicalc.barrel-stage-2, #visicalc.barrel-stage-2 #visicalc-frame { animation: barrelStage2 1.35s ease forwards; }
 #visicalc.barrel-stage-3, #visicalc.barrel-stage-3 #visicalc-frame { animation: barrelStage3 1.6s ease forwards; }
 #visicalc.screen-shatter, #visicalc.screen-shatter #visicalc-frame { animation: shakeScreen 0.8s ease forwards; }
 .shatter-overlay { position:fixed; inset:0; pointer-events:none; z-index:180; opacity:0; mix-blend-mode:screen; }
 .shatter-overlay.active { animation: screenShatterFlash 0.9s ease forwards; }
 .shatter-overlay.fade { animation: screenShatterFade 1.3s ease forwards; }
 .shatter-overlay .shatter-cracks { 
 position:absolute; inset:0; 
 background-image: 
 repeating-linear-gradient(0deg, #0ff 0px, #0ff 2px, transparent 2px, transparent 18px),
 repeating-linear-gradient(90deg, #0ff 0px, #0ff 2px, transparent 2px, transparent 18px);
 background-size: 100% 100%; 
 opacity:0; 
 filter: drop-shadow(0 0 8px rgba(0,255,255,0.8)) drop-shadow(0 0 20px rgba(0,255,255,0.4)); 
 animation: shatterGridGlow 1.8s ease forwards;
 }
 @keyframes shatterGridGlow {
 0% { opacity:0; filter: drop-shadow(0 0 2px rgba(0,255,255,0.3)); }
 20% { opacity:0.8; filter: drop-shadow(0 0 12px rgba(0,255,255,0.9)) drop-shadow(0 0 24px rgba(0,255,255,0.5)); }
 45% { opacity:1; filter: drop-shadow(0 0 18px rgba(0,255,255,1)) drop-shadow(0 0 32px rgba(0,255,255,0.7)); }
 70% { opacity:0.6; filter: drop-shadow(0 0 8px rgba(0,255,255,0.4)); transform: scale(1.1); }
 100% { opacity:0; filter: drop-shadow(0 0 2px rgba(0,255,255,0.1)); transform: scale(1.5); }
 }
 .shatter-overlay .shatter-pixels {
 position:absolute; inset:0; opacity:0;
 background-image: 
 radial-gradient(circle, #0ff 1px, transparent 1px),
 radial-gradient(circle, #00ffaa 1px, transparent 1px);
 background-size: 8px 8px, 10px 10px;
 background-position: 0 0, 5px 5px;
 filter: blur(0.5px);
 animation: shatterPixelBurst 2.2s ease forwards;
 animation-delay: 0.4s;
 }
 @keyframes shatterPixelBurst {
 0% { opacity:0; transform: scale(1); filter: blur(0px); }
 25% { opacity:0.9; transform: scale(1); filter: blur(0px); }
 55% { opacity:1; transform: scale(1.15); filter: blur(1px); }
 75% { opacity:0.5; transform: scale(1.4); filter: blur(3px); }
 100% { opacity:0; transform: scale(2); filter: blur(8px); }
 }
 @keyframes shakeScreen {
 0%, 100% { transform: perspective(900px) translateZ(12px) rotate(0deg); }
 20% { transform: perspective(760px) translateZ(36px) rotate(1.4deg); }
 40% { transform: perspective(820px) translateZ(28px) rotate(-1.2deg); }
 60% { transform: perspective(780px) translateZ(44px) rotate(1deg); }
 80% { transform: perspective(860px) translateZ(24px) rotate(-0.8deg); }
 }

 .visicell-note-line { display:inline-block; min-width:1ch; opacity:0; transform:translateY(6px); animation: visicellNoteSlide 0.6s ease forwards; }
 .visicell-note-line--1 { animation-delay:0.2s; }
 .visicell-note-line--2 { animation-delay:0.45s; }
 @keyframes visicellNoteSlide {
 from { opacity:0; transform:translateY(10px); }
 to { opacity:1; transform:translateY(0); }
 }

/* Debug toast */
.toast{ position:fixed; right:14px; top:14px; background:rgba(18,18,18,.9); color:#cbd5e1; border:1px solid rgba(255,255,255,.08); border-radius:10px; padding:10px 12px; font: 12px/1.3 ui-monospace, SFMono-Regular, Menlo, Consolas, "Segoe UI Symbol", "Segoe UI Emoji", "Apple Color Emoji", monospace; z-index: 9; box-shadow: 0 10px 24px rgba(0,0,0,.35); pointer-events:none; opacity:.95; max-width: 42ch; }
 .toast strong{ color:#fff; font-weight:700; }
 .toast .ok{ color:#9ae6b4; }
 .toast .warn{ color:#f6e05e; }
 .toast .err{ color:#feb2b2; }
 .r-hint { transition: text-shadow 0.6s ease, opacity 0.6s ease; text-shadow: none; }
 .r-hint.glow { text-shadow: 0 0 8px #0f0, 0 0 16px #0f0; }
 .r-hint .r-line { display:block; line-height:1.4; }
 .r-hint .r-char { display:inline-block; width:1ch; transition: transform 0.85s cubic-bezier(0.19, 1, 0.22, 1), opacity 0.85s ease, filter 0.85s ease; }
 .r-hint .r-char.falling { transform: translateY(26px); opacity:0; filter: blur(2px); }
 #matrixPleaOverlay { position:absolute; bottom:22px; left:32px; font-family:'VT323', 'Courier New', monospace; font-size:18px; letter-spacing:0.28em; text-transform:uppercase; color:#0f0; text-shadow:0 0 6px rgba(0,255,160,0.7); opacity:0; transform:translateY(8px); pointer-events:none; transition: opacity 0.5s ease, transform 0.45s ease; }
 #matrixPleaOverlay.visible { opacity:0.92; transform:translateY(0); }
 #matrixPleaOverlay.glitch { animation: matrixPleaGlitch 0.35s steps(2) infinite; }
 .matrix-plead { text-shadow:0 0 3px rgba(0,255,160,0.5), 0 0 8px rgba(0,255,140,0.35); }
 .matrix-plead-flash { animation: matrixPleaFlash 0.28s ease-out; }
 @keyframes matrixPleaGlitch {
 0%, 100% { transform:translateY(0); text-shadow:0 0 6px rgba(0,255,160,0.7); }
 40% { transform:translate(-2px, -1px) skewX(-4deg); text-shadow:0 0 10px rgba(0,255,200,0.9), -2px 0 #00ffd5; }
 75% { transform:translate(2px, 1px) skewX(3deg); text-shadow:0 0 10px rgba(170,255,120,0.85), 2px 0 #b3ff00; }
 }
 @keyframes matrixPleaFlash {
 0% { filter:brightness(1); text-shadow:0 0 3px rgba(0,255,160,0.4); }
 45% { filter:brightness(1.35); text-shadow:0 0 14px rgba(0,255,200,0.85); }
 100% { filter:brightness(1); text-shadow:0 0 4px rgba(0,255,140,0.45); }
 }
 
/* Scene Select Menu */
#sceneSelect { position:fixed; inset:0; background:rgba(0,0,0,0.95); display:none; align-items:center; justify-content:center; z-index:9999; pointer-events:auto; }
#sceneSelect.visible { display:flex; }
.scene-menu { max-width:600px; width:90%; padding:40px; background:rgba(0,20,10,0.9); border:2px solid #0f0; border-radius:20px; box-shadow:0 0 30px rgba(0,255,160,0.3), inset 0 0 20px rgba(0,255,160,0.1); font-family:'Courier New', 'Segoe UI Symbol', 'Segoe UI Emoji', 'Apple Color Emoji', monospace; backdrop-filter:blur(10px); }
 .scene-menu h2 { margin:0 0 10px; color:#0f0; font-size:24px; text-align:center; text-transform:uppercase; letter-spacing:0.2em; text-shadow:0 0 10px rgba(0,255,160,0.6); }
 .scene-menu p { margin:0 0 25px; color:#0a8; font-size:13px; text-align:center; opacity:0.8; }
 .scene-option { margin:12px 0; padding:16px 20px; background:rgba(0,30,20,0.6); border:1px solid #0a6; border-radius:8px; color:#0f0; cursor:pointer; transition:all 0.2s ease; text-transform:uppercase; letter-spacing:0.15em; font-size:14px; pointer-events:auto; }
 .scene-option:hover { background:rgba(0,50,30,0.9); border-color:#0f0; box-shadow:0 0 15px rgba(0,255,160,0.4); transform:translateX(5px); }
 .scene-option.locked { opacity:0.4; cursor:not-allowed; background:rgba(20,20,20,0.6); border-color:#444; color:#666; }
 .scene-option.locked:hover { transform:none; box-shadow:none; }
 .scene-option-desc { font-size:11px; opacity:0.7; margin-top:6px; letter-spacing:0.05em; text-transform:none; }
 .scene-controls { margin-top:25px; padding-top:20px; border-top:1px solid #0a6; display:flex; gap:10px; flex-wrap:wrap; }
 .scene-controls button { flex:1; min-width:140px; padding:12px; background:rgba(0,40,20,0.8); border:1px solid #0a8; border-radius:6px; color:#0f0; cursor:pointer; font-family:inherit; font-size:12px; text-transform:uppercase; letter-spacing:0.1em; transition:all 0.2s; pointer-events:auto; }
 .scene-controls button:hover { background:rgba(0,60,30,0.9); border-color:#0f0; box-shadow:0 0 12px rgba(0,255,160,0.3); }
 .scene-controls .close-btn { background:rgba(40,0,0,0.8); border-color:#a00; color:#f66; }
 .scene-controls .close-btn:hover { background:rgba(60,0,0,0.9); border-color:#f00; box-shadow:0 0 12px rgba(255,100,100,0.3); }
 </style>
</head>
<body>
 <div id="app" class="scanlines"></div>
 <div class="hud">
 <div id="quote" class="quote">
 <span id="quoteBefore" class="quote__text">...if you gaze for long into an abyss, the abyss gazes also into you.</span>
 <span id="quoteAfter" class="quote__text" style="display:none;"></span>
 </div>
 <div id="loomworks" class="loomworks" aria-live="polite">
 <span id="loomPre" class="loomworks-chunk">L</span><span id="loomCore" class="loomworks-chunk">OO</span><span id="loomPost" class="loomworks-chunk">K</span><span id="loomTail" class="loomworks-chunk"></span>
 </div>
 <span id="floatingK" class="floatingK" aria-hidden="true">K</span>
 <div class="vignette"></div>
 </div>
 <div id="screenGlitch" class="screenGlitch"></div>
 
 <!-- Doorway portal -->
 <div id="doorway" class="doorway">
 <div class="prompt-container">
 <div class="prompt" data-text="=STAR_"><span id="promptText">=STAR</span><span id="promptCursor" class="cursor">_</span></div>
 </div>
 </div>
 
 <!-- Hidden input for mobile keyboard -->
 <input id="hiddenInput" type="text" style="position:absolute; left:-9999px; opacity:0;" autocomplete="off" autocapitalize="none" autocorrect="off" spellcheck="false" inputmode="text" enterkeyhint="done" />
 
 <audio id="chime" preload="auto">
 <source src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA=" type="audio/wav">
 </audio>
 <div id="fallback" class="fallback" style="display:none">?? WebGL unavailable or ES Modules not supported. Try a newer browser/GPU.</div>

<div id="play" class="play">
<button id="playBtn">Play</button>
<button id="sceneSelectBtn" style="font-size:12px; padding:10px 20px; opacity:0.7;">Scene Select</button>
<button id="testAudioBtn" style="font-size:12px; padding:10px 20px; opacity:0.7; margin-top: 10px;">TEST</button>
</div>
 
 <!-- Scene Select Menu -->
 <div id="sceneSelect">
 <div class="scene-menu">
 <h2>Scene Select</h2>
 <p>Jump to previously experienced sequences</p>
 
 <div id="sceneOptions">
 <div class="scene-option locked" data-scene="visicell">
 <div>END(?) ? VisiCell</div>
 <div class="scene-option-desc">The terminal awakens - spreadsheet reality unfolds</div>
 </div>
 
 <div class="scene-option locked" data-scene="leave">
 <div>LEAVE ? Initialize</div>
 <div class="scene-option-desc">The house of leaves - GIR.mp3 transformation</div>
 </div>
 
 <div class="scene-option locked" data-scene="theos">
 <div>THE.OS ? Cell Lattice</div>
 <div class="scene-option-desc">Cell address grid formation - witness the architecture</div>
 </div>
 
 <div class="scene-option locked" data-scene="blackhole">
 <div>THE.OS ? Black Hole</div>
 <div class="scene-option-desc">The void manifests - singularity achieved</div>
 </div>
 
 <div class="scene-option locked" data-scene="end3">
 <div>HARD.CORE ? End3</div>
 <div class="scene-option-desc">Terminal environment - crawl sequence</div>
 </div>
 
 <div class="scene-option locked" data-scene="fullhand">
 <div>EXEC.ENV ? Execution Environment</div>
 <div class="scene-option-desc">Integrated scene - voxel hand, keyboard, character & glowing head</div>
 <div class="scene-mode-toggle" style="margin-top: 8px; display: flex; gap: 8px;">
 <button class="mode-btn active" data-mode="sequence" data-scene-target="fullhand" style="flex: 1; padding: 6px 12px; background: #4a7cff; border: 1px solid #6a9cff; color: #fff; border-radius: 4px; cursor: pointer; font-size: 11px; transition: all 0.2s; pointer-events: auto;">Sequence</button>
 <button class="mode-btn" data-mode="debug" data-scene-target="fullhand" style="flex: 1; padding: 6px 12px; background: #2a2a2f; border: 1px solid #444; color: #ddd; border-radius: 4px; cursor: pointer; font-size: 11px; transition: all 0.2s; pointer-events: auto;">Debug</button>
 </div>
 </div>
 
 <div class="scene-option locked" data-scene="cellireal">
 <div>CELLI.REAL ? Spreadsheet Reality</div>
 <div class="scene-option-desc">The awakened terminal - interactive spreadsheet environment</div>
 </div>
 </div>
 
 <div class="scene-controls">
 <button id="debugToggle">Debug: Show All</button>
 <button id="clearProgress">Clear Progress</button>
 <button class="close-btn" id="closeSceneSelect">Close</button>
 </div>
 </div>
 </div>
 
 <div id="skipBtn" class="skip-btn hidden" role="button" aria-label="Skip intro" tabindex="0">
 <div class="skip-triangle skip-triangle--left" id="skipTriangle1">
 <div class="skip-triangle__inner">
 <svg viewBox="0 0 100 86.6025403784" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
 <polygon points="0,0 0,86.6025403784 100,43.3012701892"></polygon>
 <path d="M0,12 L0,74.6025403784 Q0,86.6025403784 11.012,81.8342402525 L88.988,48.0696001263 Q100,43.3012701892 88.988,38.5329402521 L11.012,4.7679001263 Q0,0 0,12 Z"></path>
 </svg>
 </div>
 </div>
 <div class="skip-connector" id="skipConnector" aria-hidden="true"></div>
 <div class="skip-triangle skip-triangle--right" id="skipTriangle2">
 <div class="skip-triangle__inner">
 <svg viewBox="0 0 100 86.6025403784" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
 <polygon points="100,0 100,86.6025403784 0,43.3012701892"></polygon>
 <path d="M100,12 L100,74.6025403784 Q100,86.6025403784 88.988,81.8342402525 L11.012,48.0696001263 Q0,43.3012701892 11.012,38.5329402521 L88.988,4.7679001263 Q100,0 100,12 Z"></path>
 </svg>
 </div>
 </div>
 </div>
 <div id="toast" class="toast" style="display:none"></div>

 <!-- Import map so bare specifiers resolve to CDN modules -->
 <script type="importmap">
 {
 "imports": {
 "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
 "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
 }
 }
 </script>

 <script type="module">
 // --- Imports ------------------------------------------------------------
 import * as THREE from "three";
 import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer.js";
 import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass.js";
 import { UnrealBloomPass } from "three/examples/jsm/postprocessing/UnrealBloomPass.js";
 import { AfterimagePass } from "three/examples/jsm/postprocessing/AfterimagePass.js";
 import { ShaderPass } from "three/examples/jsm/postprocessing/ShaderPass.js";
 import { BokehPass } from "three/examples/jsm/postprocessing/BokehPass.js";
 import { FilmPass } from "three/examples/jsm/postprocessing/FilmPass.js";
import { RoundedBoxGeometry } from "three/examples/jsm/geometries/RoundedBoxGeometry.js";

console.log('ðŸ”¥ðŸ”¥ðŸ”¥ SCRIPT START - ALL IMPORTS COMPLETE ðŸ”¥ðŸ”¥ðŸ”¥');

// --- Global animation variables -----------------------------------------
const clock = new THREE.Clock();
let running = false;
let totalTime = 0;
console.log('ðŸ”¥ Global variables initialized');

// Expose to window for button handlers
window.clock = clock;
Object.defineProperty(window, 'running', {
 get: () => running,
 set: (val) => { running = val; }
});
Object.defineProperty(window, 'totalTime', {
 get: () => totalTime,
 set: (val) => { totalTime = val; }
});

// ==========================================
// CACHE BUSTER: VERSION FINAL FIX v5.3
 // HARD REFRESH NOW: Ctrl+Shift+R or Ctrl+F5
 // ==========================================
 console.log('%c?? VERSION FINAL FIX v5.3 LOADED ??', 'background: #ff4400; color: #fff; font-size: 24px; padding: 10px; font-weight: 900; text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;');
 console.log('%c? Removed ALL duplicate variable declarations - speechRActive fixed', 'background: #0ff; color: #000; font-size: 18px; padding: 8px; font-weight: bold;');
 console.log('%c?? HARD REFRESH: Ctrl+Shift+R or Ctrl+F5 ??', 'background: #ff6600; color: #fff; font-size: 18px; padding: 8px;');
 
 // Make THREE and imports available globally for end3 scene
 window.THREE = THREE;
 window.EffectComposer = EffectComposer;
 window.RenderPass = RenderPass;
 window.UnrealBloomPass = UnrealBloomPass;
 window.AfterimagePass = AfterimagePass;
 window.ShaderPass = ShaderPass;
 window.BokehPass = BokehPass;
 window.FilmPass = FilmPass;
 window.RoundedBoxGeometry = RoundedBoxGeometry;

 // --- Debug helpers ------------------------------------------------------
 const toastEl = document.getElementById('toast');
 function toast(lines, level='ok'){
 const arr = Array.isArray(lines) ? lines : [String(lines)];
 toastEl.innerHTML = `<strong>Debug</strong><br>${arr.map(l=>`<span class="${level}">${l}</span>`).join('<br>')}`;
 toastEl.style.display='block';
 }
 function clearToast(){ toastEl.style.display='none'; }

 // --- WebGL capability check --------------------------------------------
 const hasWebGL = (() => { try { const c = document.createElement('canvas'); return !!(window.WebGLRenderingContext && (c.getContext('webgl2')||c.getContext('webgl')||c.getContext('experimental-webgl'))); } catch(e){ return false; } })();
 if (!hasWebGL) { document.getElementById('fallback').style.display = 'flex'; throw new Error('WebGL not available'); }

 // --- Core setup ---------------------------------------------------------
 const app = document.getElementById('app');
 const quoteEl = document.getElementById('quote');
 const quoteBefore = document.getElementById('quoteBefore');
 const quoteAfter = document.getElementById('quoteAfter');
 const loomworksEl = document.getElementById('loomworks');
 const loomPre = document.getElementById('loomPre');
 const loomCore = document.getElementById('loomCore');
 const loomPost = document.getElementById('loomPost');
 const loomTail = document.getElementById('loomTail');
 const quoteStates = {
 initial: {
 text: '...if you gaze for long into an abyss, the abyss gazes also into you.',
 showLook: false
 },
 look: {
 text: '...if you LOOK for long into an abyss, the abyss LOOKS also into you.',
 showLook: false
 },
 despair: {
 text: 'LOOK on my works, ye Mighty, and despair!',
 showLook: false
 }
 };

 applyQuoteState(quoteStates.initial, { immediate: true });
 quoteEl.classList.remove('quote--loom');
 loomTail.innerHTML = '';
 const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false, powerPreference:'high-performance' });
 renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
 renderer.setSize(window.innerWidth, window.innerHeight);
 renderer.outputColorSpace = THREE.SRGBColorSpace;
 renderer.toneMapping = THREE.ACESFilmicToneMapping;
 renderer.toneMappingExposure = 1.0;
 renderer.setClearColor(0x000000, 1);
 app.appendChild(renderer.domElement);

 const scene = new THREE.Scene();
 const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.01, 10);
 camera.position.set(0, 0, 2);
 camera.lookAt(0, 0, 0);

 const blackHoleGeo = new THREE.CircleGeometry(0.35, 64);
 const blackHoleMat = new THREE.ShaderMaterial({
 uniforms: { time: { value: 0 }, pulseFactor: { value: 0.5 } },
 vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
 fragmentShader: `
 varying vec2 vUv; uniform float time; uniform float pulseFactor;
 void main() {
 vec2 center = vec2(0.5);
 float dist = distance(vUv, center);
 // Organic pulsing with multiple harmonics
 float baseRadius = 0.08 + pulseFactor * 0.28;
 float pulse1 = 0.015 * sin(time * 3.5);
 float pulse2 = 0.008 * sin(time * 7.3 + 1.5);
 float radius = baseRadius + pulse1 + pulse2;
 // Ultra-soft gradient fade for dreamy quality
 float fadeDistance = radius * 1.6;
 float alpha = 1.0 - smoothstep(radius - fadeDistance, radius, dist);
 // Softer alpha curve with slight glow at edges
 alpha = pow(alpha, 0.6) * 0.9;
 gl_FragColor = vec4(0.0, 0.0, 0.0, alpha);
 }
 `,
 transparent: true, depthWrite: false
 });
 const blackHole = new THREE.Mesh(blackHoleGeo, blackHoleMat);
 blackHole.position.z = 0.1;
 scene.add(blackHole);

 const R = 0.16;
 const makeMat = (hex) => new THREE.MeshBasicMaterial({ color: new THREE.Color(hex), blending: THREE.AdditiveBlending, transparent: true, depthWrite: false });
 const CYAN = 0x00a8ff, MAGENTA = 0xff1e6e, YELLOW = 0xffb62e;
 const colors = [new THREE.Color(CYAN), new THREE.Color(YELLOW), new THREE.Color(MAGENTA)];
 
 // Create custom rounded shapes: square (cyan), triangle (yellow), circle (magenta)
 
 // Shape 0: Rounded Square (Blue/Cyan)
 const createRoundedSquare = (size, radius) => {
 const shape = new THREE.Shape();
 const r = radius;
 const s = size / 2;
 shape.moveTo(-s + r, -s);
 shape.lineTo(s - r, -s);
 shape.quadraticCurveTo(s, -s, s, -s + r);
 shape.lineTo(s, s - r);
 shape.quadraticCurveTo(s, s, s - r, s);
 shape.lineTo(-s + r, s);
 shape.quadraticCurveTo(-s, s, -s, s - r);
 shape.lineTo(-s, -s + r);
 shape.quadraticCurveTo(-s, -s, -s + r, -s);
 return new THREE.ShapeGeometry(shape, 32);
 };
 
 // Shape 1: Rounded Triangle (Yellow) - flat bottom, pointing up
 const createRoundedTriangle = (size, radius) => {
 const shape = new THREE.Shape();
 const h = size * Math.sqrt(3) / 2; // Equilateral triangle height
 
 // Three vertices of equilateral triangle with FLAT BOTTOM
 const top = { x: 0, y: h / 2 }; // Top vertex (pointing up)
 const bl = { x: -size/2, y: -h / 2 }; // Bottom left
 const br = { x: size/2, y: -h / 2 }; // Bottom right
 
 const r = radius * 0.8; // Smaller radius for cleaner corners
 
 // Start at bottom-left, move clockwise
 shape.moveTo(bl.x + r, bl.y);
 
 // Bottom edge to bottom-right
 shape.lineTo(br.x - r, br.y);
 
 // Curve around bottom-right corner
 shape.quadraticCurveTo(br.x, br.y, br.x - r * 0.5, br.y + r * 0.866);
 
 // Right edge going up to top
 shape.lineTo(top.x + r * 0.5, top.y - r * 0.866);
 
 // Curve around top corner
 shape.quadraticCurveTo(top.x, top.y, top.x - r * 0.5, top.y - r * 0.866);
 
 // Left edge going down to bottom-left
 shape.lineTo(bl.x + r * 0.5, bl.y + r * 0.866);
 
 // Curve around bottom-left corner
 shape.quadraticCurveTo(bl.x, bl.y, bl.x + r, bl.y);
 
 return new THREE.ShapeGeometry(shape, 32);
 };
 
 // Shape 2: Circle (Pink/Magenta)
 const createCircle = (radius) => {
 return new THREE.CircleGeometry(radius, 64);
 };
 
 const geoSquare = createRoundedSquare(R * 2, R * 0.3);
 const geoTriangle = createRoundedTriangle(R * 2, R * 0.35);
 const geoCircle = createCircle(R);
 
 // Store original geometries for morphing
 const originalGeos = [geoSquare, geoTriangle, geoCircle];
 
 // Create circle targets for morphing (all shapes will become circles)
 const circleGeoTarget = createCircle(R);
 
 const spheres = [
 new THREE.Mesh(geoSquare, makeMat(CYAN)),
 new THREE.Mesh(geoTriangle, makeMat(YELLOW)),
 new THREE.Mesh(geoCircle, makeMat(MAGENTA))
 ];
 spheres.forEach((s,i)=>{ s.position.z = -i*0.002; scene.add(s); });

// --- Voxel System for CELLI - Early Computer Typeface Style ---
const voxelSize = 0.05; // Smaller voxels for denser appearance
// Create a thin, flat box for early computer terminal look - more like vector graphics
const voxelGeo = new THREE.BoxGeometry(voxelSize * 0.95, voxelSize * 0.95, voxelSize * 0.15);
 const voxelMat = new THREE.MeshBasicMaterial({ 
 color: 0x444444, // Start as dim gray
 transparent: true, 
 opacity: 0,
 blending: THREE.NormalBlending // Normal blending for borders
 });
 
 // Create edges geometry for borders - straight lines, not rounded
 const edgesGeo = new THREE.EdgesGeometry(voxelGeo);
 const edgeMat = new THREE.LineBasicMaterial({ 
 color: 0x888888,
 transparent: true,
 opacity: 0,
 linewidth: 1 // Thin, crisp lines
 });
 
 // Rounded voxels for yellow phase - still thin but with subtle rounding
 const roundedVoxelGeo = new RoundedBoxGeometry(voxelSize * 1.05, voxelSize * 1.05, voxelSize * 0.18, 5, Math.min(voxelSize * 0.4, 0.04));
 const roundedEdgesGeo = new THREE.EdgesGeometry(roundedVoxelGeo);
 const cellShadeBaseMaterial = new THREE.MeshBasicMaterial({
 color: 0xfff27a,
 transparent: true,
 opacity: 0.92,
 blending: THREE.AdditiveBlending
 });
 const cellShadeEdgeMaterial = new THREE.LineBasicMaterial({
 color: 0xfff9a1,
 transparent: true,
 opacity: 0.75
 });

 // CELLI letter patterns (5x5 grid for each letter)
 const celliPatterns = {
 C: [[0,1,1,1,0], [1,0,0,0,0], [1,0,0,0,0], [1,0,0,0,0], [0,1,1,1,0]],
 E: [[1,1,1,1,1], [1,0,0,0,0], [1,1,1,1,0], [1,0,0,0,0], [1,1,1,1,1]],
 L: [[1,0,0,0,0], [1,0,0,0,0], [1,0,0,0,0], [1,0,0,0,0], [1,1,1,1,1]],
 I: [[1,1,1,1,1], [0,0,1,0,0], [0,0,1,0,0], [0,0,1,0,0], [1,1,1,1,1]]
 };
 
const voxels = [];
const letterVoxels = { C: [], E: [], L1: [], L2: [], I: [] }; // Track voxels by letter
const letters = ['C', 'E', 'L', 'L', 'I'];
let letterSpacing = 0.4; // Denser letter spacing
let celliScale = 1.0;
 
 // Responsive scaling for touch devices
 function calculateCelliScale() {
 const aspect = window.innerWidth / window.innerHeight;
 
 // Calculate total width needed for all letters (including padding)
 const totalBaseWidth = letters.length * letterSpacing;
 
 // Camera view width in world units
 let viewWidth;
 if (aspect > 1) {
 // Landscape
 viewWidth = aspect * 2;
 } else {
 // Portrait
 viewWidth = 2;
 }
 
 // Scale to fit 85% of view width
 const targetWidth = viewWidth * 0.85;
 if (totalBaseWidth > targetWidth) {
 celliScale = targetWidth / totalBaseWidth;
 } else {
 celliScale = 1.0;
 }
 }
 calculateCelliScale();
 
 const startX = -(letters.length * letterSpacing * celliScale) / 2 + (letterSpacing * celliScale) / 2;
 
 letters.forEach((letter, letterIdx) => {
 const pattern = celliPatterns[letter];
 const letterX = startX + letterIdx * letterSpacing * celliScale;
 
 pattern.forEach((row, rowIdx) => {
 row.forEach((cell, colIdx) => {
 if (cell === 1) {
 // Create voxel with border
 const voxel = new THREE.Mesh(voxelGeo, voxelMat.clone());
 const edges = new THREE.LineSegments(edgesGeo, edgeMat.clone());
 voxel.add(edges);
 
 const x = letterX + (colIdx - 2) * voxelSize * 1.2 * celliScale;
 const y = (2 - rowIdx) * voxelSize * 1.2 * celliScale + 0.35; // Offset up
 
 voxel.userData = {
 targetX: x,
 targetY: y,
 startY: y + 2.0 + Math.random() * 1.0,
 dropDelay: letterIdx * 0.15 + (rowIdx * colIdx) * 0.02,
 dropSpeed: 0.02 + Math.random() * 0.01,
 settled: false,
 jigglePhase: Math.random() * Math.PI * 2,
 flickerPhase: Math.random() * Math.PI * 2,
 edges: edges, // Store reference to edges
 gridX: letterIdx, // Letter index (0=C, 1=E, 2=L, 3=L, 4=I)
 gridY: rowIdx, // Row index (0=top, 4=bottom)
 gridCol: colIdx, // Column index within letter (0-4)
 glitched: false, // Track if this voxel has been glitched out
 baseScale: celliScale, // Store scale for proper sizing
 backspaceTransformed: false,
 backspacePulseOffset: Math.random() * Math.PI * 2
 };
 
 // Scale voxel size to match the overall scale
 voxel.scale.set(celliScale, celliScale, celliScale);
 
 voxel.position.set(x, voxel.userData.startY, 0);
 voxel.visible = false;
 scene.add(voxel);
 voxels.push(voxel);
 
 // Track voxels by letter for restoration
 // Provide synonyms used by later stages
 voxel.userData.letterIdx = letterIdx;
 voxel.userData.gridRow = rowIdx;
 const letterKey = letterIdx === 0 ? 'C' : letterIdx === 1 ? 'E' : letterIdx === 2 ? 'L1' : letterIdx === 3 ? 'L2' : 'I';
 letterVoxels[letterKey].push(voxel);
 }
 });
 });
 });

 // --- [NEW] Shader for the color triangle between spheres ---
 const triGeo = new THREE.PlaneGeometry(4, 4); // Covers view
 const triMat = new THREE.ShaderMaterial({
 uniforms: {
 points: { value: [new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2()] },
 colors: { value: colors },
 aspect: { value: 1.0 }
 },
 vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = vec4(position, 1.0); }`,
 fragmentShader: `
 varying vec2 vUv;
 uniform vec2 points[3];
 uniform vec3 colors[3];
 uniform float aspect;

 // Function to calculate barycentric coordinates
 vec3 barycentric(vec2 p, vec2 a, vec2 b, vec2 c) {
 vec2 v0 = b - a, v1 = c - a, v2 = p - a;
 float d00 = dot(v0, v0);
 float d01 = dot(v0, v1);
 float d11 = dot(v1, v1);
 float d20 = dot(v2, v0);
 float d21 = dot(v2, v1);
 float denom = d00 * d11 - d01 * d01;
 float v = (d11 * d20 - d01 * d21) / denom;
 float w = (d00 * d21 - d01 * d20) / denom;
 float u = 1.0 - v - w;
 return vec3(u, v, w);
 }

 void main() {
 // Adjust UVs to be centered and handle aspect ratio
 vec2 p = (vUv - 0.5) * 2.0;
 p.x *= aspect;

 vec3 b = barycentric(p, points[0], points[1], points[2]);

 if (b.x >= 0.0 && b.y >= 0.0 && b.z >= 0.0) {
 // We are inside the triangle
 vec3 color = b.x * colors[0] + b.y * colors[1] + b.z * colors[2];
 
 // More defined edges with softer interior
 float edgeDist = min(b.x, min(b.y, b.z));
 float edgeFade = smoothstep(0.0, 0.2, edgeDist);
 
 // Distance-based fading
 float centerDist = length(p);
 float centerFade = 1.0 - smoothstep(0.15, 0.65, centerDist);
 centerFade = pow(centerFade, 0.6);
 
 // Subtle center glow
 float centerGlow = 1.0 - smoothstep(0.0, 0.25, centerDist);
 float finalAlpha = (edgeFade * centerFade + centerGlow * 0.12) * 0.55;
 
 gl_FragColor = vec4(color, finalAlpha);
 } else {
 discard;
 }
 }
 `,
 transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
 });
 const triMesh = new THREE.Mesh(triGeo, triMat);
 triMesh.position.z = -0.1; // Behind spheres
 scene.add(triMesh);

 // --- Composer & passes --------------------------------------------------
 const composer = new EffectComposer(renderer);
 composer.addPass(new RenderPass(scene, camera));

 const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.7, 0.9, 0.2);
 composer.addPass(bloomPass);
 const afterimagePass = new AfterimagePass(0.96);
 composer.addPass(afterimagePass);
 const filmPass = new ShaderPass({
 uniforms: { tDiffuse: { value: null }, time: { value: 0 }, noise: { value: 0.03 }, scanAmp: { value: 0.03 } },
 vertexShader: `varying vec2 vUv; void main(){ vUv = uv; gl_Position = projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
 fragmentShader: `
 precision highp float; varying vec2 vUv; uniform sampler2D tDiffuse; uniform float time; uniform float noise; uniform float scanAmp;
 float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }
 void main(){ vec3 col = texture2D(tDiffuse, vUv).rgb; float n = rand(vUv + fract(time)); float scan = sin((vUv.y + time*0.04)*3.14159*480.0) * scanAmp; col += n*noise; col += scan; col = pow(col, vec3(1.02)); gl_FragColor = vec4(col, 1.0); }`
 });
 composer.addPass(filmPass);

 // --- [REWRITTEN] Eclipse & Radiate Motion with Intro Sequence ----------
 const motionCfg = {
 speed: 0.8,
 maxDist: 0.65,
 rotationSpeed: 0.4,
 minScale: 0.4
 };

 // Intro sequence with magical progression
 const introCfg = {
 rollEnd: 2.5, // Roll into place (slower)
 bounceEnd: 4.5, // Sequential bounces
 triangleEnd: 7.5, // Form triangle + grow + converge
 transitionEnd: 9.5, // Transition to orbit
 normalEnd: 15.5, // Converge + one pulse cycle
 vennEnd: 18.0, // Clear venn diagram
 collapseEnd: 22.0, // Collapse to white circle (extended)
 glitchEnd: 24.5, // Intense glitch + fade (extended)
 blackoutEnd: 26.0, // Complete blackout
 loomworksEnd: 30.0, // Show Loomworks text
 celliEnd: 36.0, // CELLI voxel animation
 doorwayEnd: 44.0, // Doorway portal sequence
 ballSize: 0.12, // Size during intro
 bounceHeight: 0.35, // Bounce amplitude
 bounceDuration: 0.6 // Each bounce duration
 };
 
// Audio context for synth and chime
let audioCtx = null;
window.audioCtx = audioCtx; // Make globally accessible for scene transitions
let synthGain = null;
let synthOsc1 = null;
let synthOsc2 = null;
let synthOsc3 = null;
let landingSounds = [false, false, false]; // Track if shape has landed
let lastThunkTime = [0, 0, 0]; // Track last thunk time for each shape

// --- Audio Loading Helper (Web Audio API) ---
const audioBuffers = {}; // Object to store loaded sounds

async function loadAudioBuffer(url, key) {
if (!audioCtx) {
// Ensure AudioContext is initialized
audioCtx = new (window.AudioContext || window.webkitAudioContext)();
window.audioCtx = audioCtx;
}
try {
console.log(`ðŸ”Š Attempting to load audio: ${url}`);
const response = await fetch(url);
if (!response.ok) {
throw new Error(`HTTP error! status: ${response.status} - ${response.statusText}`);
}
console.log(`ðŸ”Š Fetch successful, response status: ${response.status}`);
const arrayBuffer = await response.arrayBuffer();
console.log(`ðŸ”Š ArrayBuffer size: ${arrayBuffer.byteLength} bytes`);
const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
audioBuffers[key] = audioBuffer;
console.log(`ðŸ”Š Audio loaded successfully: ${key} (duration: ${audioBuffer.duration.toFixed(2)}s, ${audioBuffer.numberOfChannels} channels)`);
return audioBuffer;
} catch (error) {
console.error(`âŒ Error loading audio file ${url}:`, error);
console.error(`âŒ Error details:`, error.message);
return null;
}
}

function playAudioBuffer(buffer) {
if (!buffer) {
console.error('âŒ Cannot play audio: buffer is null');
return;
}
if (!audioCtx) {
console.error('âŒ Cannot play audio: audioCtx is null');
return;
}
try {
console.log('ðŸ”Š Creating audio source...');
const source = audioCtx.createBufferSource();
source.buffer = buffer;
source.connect(audioCtx.destination); // Connect to speakers
source.start(0); // Play immediately
console.log('âœ… Audio playback started successfully');
} catch (error) {
console.error('âŒ Error playing audio buffer:', error);
}
}
 
 let speechRActive = false;
 let speechRTimeout = null;
 let speechRVoice = null;
 let speechRUtterance = null;
 let speechRGuardTimeout = null;
 let hasSpeechSynthesis = typeof window !== 'undefined' && 'speechSynthesis' in window;
 let matrixUpdateInterval = null;
 let quoteShown = false;
 let quoteDespairShown = false;
 let glitchStarted = false;
 let mediumGlitchStarted = false;
 let intenseGlitchStarted = false;
 let screenGlitchStarted = false;
 let blackoutStarted = false;
 let loomworksShown = false;
 let loomworksRevealStarted = false;
 let chimePlayed = false;
 let celliStarted = false;
 let celliStartTime = 0;
 let doorwayShown = false;
 let doorwayOpened = false;
 let inputAttempted = false;
 let celliGlitchStarted = false;
 let finalRollRotations = [0, 0, 0]; // Store final rotations from roll phase
 const promptBaseText = '=';
 let inputText = '=STAR';
 let tEntered = false;
 let burstAnimStarted = false;
 let burstTimeout = null;
 let celliBackspaceSequenceStarted = false;
 let celliBackspaceSequenceTime = 0;
 let celliBackspaceFlickerTriggered = false;
 const starParticles = []; // Stars from burst voxels
 let loomworksTypingTimeout = null;
 const glitchedVoxelsStack = []; // Track glitched voxels in order for restoration
 let lettersToRestore = ['C', 'E', 'L1', 'L2']; // Order of restoration on backspace
 let restoredLetters = 0;
let endSequence = ''; // Track E, N, D input sequence
let allYellowTransformed = false; // Track if all are yellow and transformed
let yellowTransformCompleteCount = 0;
let endColorState = 'yellow'; // Track current color state: yellow, magenta, cyan, green
let endColorPrevState = 'yellow'; // Track previous color for transitions
let endColorTransitionStart = 0; // When color transition started
let snapTogetherStarted = false;
let snapTogetherTime = 0;
let visiCalcShown = false;
let visicellAudio = null;
let celliMoveToCornerStarted = false;
let celliMoveToCornerTime = 0;
let visiCalcGreenTransitionStarted = false; // Track when VisiCalc green transition begins
let bowActive = false;
let bowCurrentCenter = null;
 let bowTargetCenter = null;
 let bowCurrentRotation = 0;
 let bowTargetRotation = 0;
 let bowAnimationId = 0;
 let bowHasTriggered = false;
 let bowVisibleAsVoxel = true;
 let pendingRoundedBow = false;

// --- HELL in-between transition state ---
let hellInbetweenStarted = false;
let hellInbetweenTime = 0;
let hellInbetweenDone = false;

// Derez particle system (canvas-rendered squares)
const derezParticles = [];

// --- Central Scene Manager for input/dolly gating ---
const SceneManager = {
 phase: 'intro',
 permissions: {
  rInfection: false,
  visicellClick: false,
  dolly: true
 },
 setPhase(phase) {
  this.phase = phase;
  if (phase === 'intro') {
   this.permissions.rInfection = false;
   this.permissions.visicellClick = false;
   this.permissions.dolly = true;
  } else if (phase === 'cellAddressesConstructing') {
   this.permissions.dolly = false; // lock dolly until grid completes
   this.permissions.rInfection = false;
   this.permissions.visicellClick = false;
  } else if (phase === 'cellAddressesReady') {
   this.permissions.dolly = true;
  } else if (phase === 'visicell') {
   this.permissions.rInfection = true;
   this.permissions.visicellClick = true;
   this.permissions.dolly = false;
  }

   if (phase === 'visicell') {
    if (!visicellAudio) {
     try {
      visicellAudio = new Audio('../../end.mp3');
      visicellAudio.preload = 'auto';
     } catch (err) {
      console.warn('?? Failed to initialize end.mp3 audio', err);
      visicellAudio = null;
     }
    }

    if (visicellAudio) {
     try {
      visicellAudio.currentTime = 0;
      const playPromise = visicellAudio.play();
      if (playPromise && typeof playPromise.then === 'function') {
       playPromise.catch(error => {
        console.warn('?? Unable to play end.mp3 during VisiCell phase', error);
       });
      }
     } catch (error) {
      console.warn('?? Error playing end.mp3 during VisiCell phase', error);
     }
    }
   } else if (visicellAudio) {
    try {
     visicellAudio.pause();
     visicellAudio.currentTime = 0;
    } catch (error) {
     console.warn('?? Error stopping end.mp3 after VisiCell phase', error);
    }
   }
 },
 can(name) { return !!this.permissions[name]; }
};

// Block dolly/scroll when disallowed by scene manager
document.addEventListener('wheel', (e) => {
 if (!SceneManager.can('dolly')) { e.preventDefault(); }
}, { passive: false });
 
 // Text particle system for click interactions
 const textParticles = [];
 const manicTexts = ["huh?", "who's there?", "AH!", "HAHA.", "ow.", "ahh...", "oh!", "what?", "why?", "where?", "when?"];
 const timeTexts = () => {
 const formats = [
 new Date().toLocaleTimeString(),
 new Date().toLocaleDateString(),
 `${new Date().getHours()}:${String(new Date().getMinutes()).padStart(2,'0')}`,
 new Date().getFullYear().toString(),
 `${Math.floor(Date.now()/1000)}`,
 new Date().toISOString().split('T')[0]
 ];
 return formats[Math.floor(Math.random() * formats.length)];
 };
 const equationTexts = [
 "x +y =r ", "?f(x)dx", "E=mc ", "?f/?x", "S(x)", "v(a +b )",
 "(0,0)", "(x,y,z)", "[1,2,3]", "?=arctan(y/x)", "? F", "dy/dx"
 ];

 const glitchGlyphs = "!<>-_\\/[]{} =+*^?# ??";

 function glitchSwapQuote(targetState, { duration = 1100, onComplete = null } = {}) {
 if (!targetState) return;
 if (quoteEl.dataset.swapping === '1') return;

 quoteEl.dataset.swapping = '1';
 quoteEl.classList.add('scrambling');

 const initialText = quoteBefore.textContent || '';
 const targetText = targetState.text || '';
 const textMax = Math.max(initialText.length, targetText.length);
 const textDenom = textMax === 0 ? 1 : textMax;
 const start = performance.now();

 const frame = (now) => {
 const elapsed = now - start;
 const progress = Math.min(elapsed / duration, 1);
 let result = '';

 for (let i = 0; i < textMax; i++) {
 if (progress > i / textDenom) {
 result += targetText[i] ?? '';
 } else {
 const fallback = initialText[i] ?? '';
 const randomChar = glitchGlyphs[Math.floor(Math.random() * glitchGlyphs.length)] || fallback;
 result += randomChar;
 }
 }

 quoteBefore.textContent = result;

 if (progress < 1) {
 requestAnimationFrame(frame);
 } else {
 quoteBefore.textContent = targetText;

 quoteEl.classList.remove('scrambling');
 delete quoteEl.dataset.swapping;

 if (typeof onComplete === 'function') {
 onComplete();
 }
 }
 };

 requestAnimationFrame(frame);
 }

 function applyQuoteState(state, { immediate = false, duration, onComplete } = {}) {
 if (!state) return;

 if (immediate) {
 quoteBefore.textContent = state.text || '';
 quoteAfter.textContent = '';
 quoteEl.classList.remove('scrambling');
 delete quoteEl.dataset.swapping;
 if (typeof onComplete === 'function') {
 onComplete();
 }
 return;
 }

 glitchSwapQuote(state, { duration, onComplete });
 }

 function typeLoomTail(text, index = 0) {
 if (index === 0) {
 loomTail.innerHTML = '';
 }

 if (index >= text.length) {
 loomworksTypingTimeout = null;
 return;
 }

 // Wrap each character in a span
 const charSpan = document.createElement('span');
 charSpan.textContent = text[index];
 charSpan.className = 'loomworks-chunk selected';
 loomTail.appendChild(charSpan);
 
 // Remove selected class from this character only
 setTimeout(() => {
 charSpan.classList.remove('selected');
 }, 140);
 
 const baseDelay = index < 3 ? 110 : 65;
 const jitter = Math.random() * 55;
 loomworksTypingTimeout = setTimeout(() => typeLoomTail(text, index + 1), baseDelay + jitter);
 }


 function startLoomworksReveal() {
 if (loomworksRevealStarted) return;
 loomworksRevealStarted = true;

 loomworksEl.classList.add('visible');
 loomPre.textContent = 'L';
 loomCore.textContent = 'OO';
 loomPost.textContent = 'K';
 loomTail.innerHTML = '';

 setTimeout(() => {
 loomCore.classList.add('selected');
 }, 280);

 setTimeout(() => {
 loomCore.textContent = 'oo';
 }, 630);

 setTimeout(() => {
 loomCore.classList.remove('selected');
 }, 1080);

 setTimeout(() => {
 loomPost.classList.add('shift-right');
 }, 900);

 setTimeout(() => {
 loomPost.classList.add('selected');
 loomPost.style.opacity = '0.2';
 }, 980);

 setTimeout(() => {
 loomPost.textContent = 'm';
 loomPost.style.opacity = '1';
 loomPost.classList.remove('shift-right');
 }, 1340);

 setTimeout(() => {
 loomPost.classList.remove('selected');
 setTimeout(() => { loomPost.style.opacity = ''; }, 220);
 }, 1680);

 setTimeout(() => {
 loomPre.style.opacity = '0';
 }, 920);

 setTimeout(() => {
 loomPre.textContent = 'a L';
 loomPre.style.opacity = '1';
 }, 1340);

 setTimeout(() => {
 if (loomworksTypingTimeout) {
 clearTimeout(loomworksTypingTimeout);
 }
 typeLoomTail('works Experience.');
 }, 1380);
 }
 
 function createTextParticle(x, y, text, color, sourceIndex) {
 const angle = Math.random() * Math.PI * 2;
 const speed = 0.004 + Math.random() * 0.006;
 const particle = {
 x, y,
 vx: Math.cos(angle) * speed,
 vy: Math.sin(angle) * speed,
 text,
 color,
 life: 1.0,
 age: 0,
 rotation: (Math.random() - 0.5) * 0.03,
 rotationSpeed: (Math.random() - 0.5) * 0.02,
 pulse: Math.random() * Math.PI * 2,
 sourceIndex,
 collapsing: false
 };
 textParticles.push(particle);
 }
 
 function updateTextParticles(dt) {
 for (let i = textParticles.length - 1; i >= 0; i--) {
 const p = textParticles[i];
 
 p.age += dt;
 
 // Get source sphere position
 const source = spheres[p.sourceIndex].position;
 
 // Calculate attraction to source (gravitational pull)
 const dx = source.x - p.x;
 const dy = source.y - p.y;
 const dist = Math.sqrt(dx * dx + dy * dy);
 
 // After 1.8 seconds, begin dramatic collapse
 if (p.age > 1.8 && !p.collapsing) {
 p.collapsing = true;
 }
 
 if (p.collapsing) {
 // Dramatic collapse: strong pull, wild rotation, rapid fade
 const collapseForce = 0.0008 / (dist * dist + 0.01); // Much stronger!
 p.vx += (dx / dist) * collapseForce;
 p.vy += (dy / dist) * collapseForce;
 
 // Accelerate rotation
 p.rotationSpeed *= 1.05;
 
 // Rapid fade during collapse
 p.life -= dt * 2.5;
 } else {
 // Normal orbit phase
 if (dist > 0.01) {
 const force = 0.00008 / (dist + 0.1);
 p.vx += (dx / dist) * force;
 p.vy += (dy / dist) * force;
 }
 
 // Apply orbital motion
 const orbitForce = 0.00012;
 p.vx += -dy * orbitForce;
 p.vy += dx * orbitForce;
 
 // Normal fade
 p.life -= dt * 0.5;
 }
 
 // Update position
 p.x += p.vx;
 p.y += p.vy;
 
 // Damping (less during collapse for dramatic effect)
 const dampFactor = p.collapsing ? 0.97 : 0.99;
 p.vx *= dampFactor;
 p.vy *= dampFactor;
 
 // Update rotation and pulse
 p.rotation += p.rotationSpeed;
 p.pulse += dt * (p.collapsing ? 8 : 4); // Faster pulse during collapse
 
 if (p.life <= 0) {
 textParticles.splice(i, 1);
 }
 }
 }
 
 function renderTextParticles(ctx, camera) {
 ctx.save();
 ctx.font = 'bold 16px monospace';
 ctx.textAlign = 'center';
 ctx.textBaseline = 'middle';
 
 for (const p of textParticles) {
 // Project from world to screen
 const screenX = (p.x / camera.right) * (window.innerWidth / 2) + (window.innerWidth / 2);
 const screenY = (-p.y / camera.top) * (window.innerHeight / 2) + (window.innerHeight / 2);
 
 ctx.save();
 ctx.translate(screenX, screenY);
 ctx.rotate(p.rotation);
 
 const alpha = p.life * p.life;
 const pulseFactor = 0.85 + Math.sin(p.pulse) * 0.15; // Gentle pulsate
 const glowSize = 5 + Math.sin(p.pulse * 0.7) * 3; // Slower, dreamy pulse
 
 // Scale down dramatically during collapse
 const scaleFactor = p.collapsing ? Math.max(0.1, 1.0 - (p.age - 1.8) * 1.2) : 1.0;
 ctx.scale(scaleFactor, scaleFactor);
 
 // Outer colored glow - intensify during collapse
 const collapseIntensity = p.collapsing ? 1.5 : 1.0;
 ctx.shadowBlur = glowSize * 4 * collapseIntensity;
 ctx.shadowColor = p.color;
 ctx.globalAlpha = alpha * 0.9 * collapseIntensity;
 ctx.fillStyle = p.color;
 ctx.fillText(p.text, 0, 0);
 
 // Mid white glow for visibility
 ctx.shadowBlur = glowSize * 2;
 ctx.shadowColor = '#ffffff';
 ctx.globalAlpha = alpha * 0.95;
 ctx.fillStyle = '#ffffff';
 ctx.fillText(p.text, 0, 0);
 
 // Bright white base (always visible)
 ctx.shadowBlur = glowSize * 0.5;
 ctx.shadowColor = '#ffffff';
 ctx.globalAlpha = alpha;
 ctx.fillStyle = '#ffffff';
 ctx.fillText(p.text, 0, 0);
 
 // Colored accent overlay
 ctx.shadowBlur = 0;
 ctx.globalAlpha = alpha * 0.4;
 ctx.fillStyle = p.color;
 ctx.fillText(p.text, 0, 0);
 
 ctx.restore();
 }
 ctx.restore();
 }
 
 function updateVoxels(t, dt) {
 const celliTime = t - introCfg.loomworksEnd;
 if (celliTime < 0) return;
 
voxels.forEach(voxel => {
const data = voxel.userData;

// Skip glitched voxels - they're permanently disabled
if (data.glitched) return;

// Handle falling off for CELLI -> HELL transformation
if (data.fallingOff) {
const currentTime = Date.now() / 1000;
const timeSinceFallStart = currentTime - data.fallStartTime;

if (timeSinceFallStart > data.fallDelay) {
// Apply gravity
const gravity = 0.003;
data.fallVelocity += gravity;

// Update position
voxel.position.y -= data.fallVelocity;

// Rotate while falling
voxel.rotation.x += data.rotationSpeed.x;
voxel.rotation.y += data.rotationSpeed.y;
voxel.rotation.z += data.rotationSpeed.z;

// Fade out
if (data.edges && data.edges.material) {
data.edges.material.opacity = Math.max(0, data.edges.material.opacity - 0.01);
}
voxel.material.opacity = Math.max(0, voxel.material.opacity - 0.01);

// Check if voxel should reappear in new position
if (voxel.position.y < -2 && data.willReappearAs && !data.hasReappeared) {
data.hasReappeared = true;
// Calculate new position for H right column
const letterIdx = data.willReappearAs.letterIdx;
const newRow = data.willReappearAs.row;
const newCol = data.willReappearAs.col;
const letterSpacing = 0.4; // Match initial density
const voxelSize = 0.05; // Match initial smaller size
const letterX = -(letters.length * letterSpacing * celliScale) / 2 + (letterSpacing * celliScale) / 2 + letterIdx * letterSpacing * celliScale;
const x = letterX + (newCol - 2) * voxelSize * 1.2 * celliScale;
const y = (2 - newRow) * voxelSize * 1.2 * celliScale + 0.35;

// Reposition to new location
voxel.position.set(x, y, 0);
voxel.rotation.set(0, 0, 0); // Reset rotation
data.targetX = x;
data.targetY = y;
data.gridY = newRow;
data.gridCol = newCol;

// Fade back in
voxel.material.opacity = 0.8;
if (data.edges && data.edges.material) {
data.edges.material.opacity = 0.6;
}
voxel.visible = true;
data.fallingOff = false; // Stop falling
data.settled = true; // Mark as settled in new position

console.log(`[HELL] Voxel reappeared at row ${newRow}, col ${newCol}`);

// Add back to letterVoxels.C tracking
if (letterVoxels && letterVoxels.C) {
letterVoxels.C.push(voxel);
}
}

// --- Derez particle system (shaved pixels) ---
function playClunk(volume = 0.18) {
 if (!audioCtx) { try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); window.audioCtx = audioCtx; } catch(_){} }
 if (!audioCtx) return;
 const now = audioCtx.currentTime;
 const osc = audioCtx.createOscillator();
 const gain = audioCtx.createGain();
 const filter = audioCtx.createBiquadFilter();
 osc.type = 'square';
 osc.frequency.setValueAtTime(120, now);
 osc.frequency.exponentialRampToValueAtTime(60, now + 0.06);
 filter.type = 'lowpass';
 filter.frequency.setValueAtTime(800, now);
 filter.Q.value = 0.6;
 gain.gain.setValueAtTime(0, now);
 gain.gain.linearRampToValueAtTime(volume, now + 0.01);
 gain.gain.exponentialRampToValueAtTime(0.001, now + 0.18);
 osc.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination);
 osc.start(now); osc.stop(now + 0.2);
}

function spawnDerezFromVoxel(voxel) {
 const data = voxel.userData || {};
 // Emit a handful of 2D squares per voxel
 const emitCount = 3;
 for (let i = 0; i < emitCount; i++) {
  derezParticles.push({
   x: voxel.position.x + (Math.random() - 0.5) * 0.01,
   y: voxel.position.y + (Math.random() - 0.5) * 0.01,
   z: voxel.position.z,
   vx: (Math.random() - 0.5) * 0.04,
   vy: (Math.random() - 0.2) * 0.06 - 0.01,
   life: 1.0,
   size: 2 + Math.floor(Math.random() * 3),
   targetType: 'edge'
  });
 }
}

function spawnDerezWaveFromVoxels() {
 try { derezParticles.length = 0; } catch(_){ }
 for (const v of voxels) {
  const d = v.userData || {};
  if (!d.glitched && v.visible) spawnDerezFromVoxel(v);
 }
}

function updateDerezParticles(dt) {
 if (!derezParticles.length) return;
 for (let i = derezParticles.length - 1; i >= 0; i--) {
  const p = derezParticles[i];
  // Drift outward
  p.x += p.vx;
  p.y += p.vy;
  // Slight drag
  p.vx *= 0.985;
  p.vy *= 0.985;
  p.life -= dt * 0.6;
  if (p.life <= 0) {
   derezParticles.splice(i, 1);
  }
 }
 // Mark inbetween done heuristically
 if (hellInbetweenStarted && !hellInbetweenDone) {
  if ((performance.now ? performance.now() : Date.now()) - (hellInbetweenStartMs || 0) > 1400 || derezParticles.length < 30) {
   hellInbetweenDone = true;
  }
 }
}

function renderDerezParticles(ctx, camera) {
 if (!derezParticles.length) return;
 ctx.save();
 for (const p of derezParticles) {
  const v = new THREE.Vector3(p.x, p.y, p.z);
  v.project(camera);
  if (v.z > 1) continue;
  const sx = (v.x + 1) / 2 * window.innerWidth;
  const sy = (-v.y + 1) / 2 * window.innerHeight;
  const alpha = Math.max(0, Math.min(1, p.life));
  ctx.fillStyle = `rgba(0,255,0,${alpha})`;
  const s = p.size;
  ctx.fillRect(Math.floor(sx - s / 2), Math.floor(sy - s / 2), s, s);
 }
 ctx.restore();
}

// Remove from scene when far below and invisible (only if not reappearing)
if (voxel.position.y < -5 && !data.willReappearAs) {
voxel.visible = false;
scene.remove(voxel);
}
}
return; // Skip normal animation
}

const localTime = celliTime - data.dropDelay;
 
 if (localTime < 0) return;
 
 voxel.visible = true;
 
 if (!data.settled) {
 // Dropping phase
 const targetY = data.targetY;
 if (voxel.position.y > targetY) {
 voxel.position.y -= data.dropSpeed;
 voxel.material.opacity = Math.min(0.8, voxel.material.opacity + 0.05);
 data.edges.material.opacity = Math.min(0.6, data.edges.material.opacity + 0.04);
 } else {
 // Hit the ground, settle
 voxel.position.y = targetY;
 data.settled = true;
 data.settleTime = celliTime;
 // Play chime sound on landing
 playVoxelChime();
 }
 } else {
 const settleAge = celliTime - data.settleTime;

 const jiggleFactor = Math.max(0, 1 - settleAge * 0.5);
 data.jigglePhase += dt * 20;
 const jiggleX = Math.sin(data.jigglePhase) * 0.003 * jiggleFactor;
 const jiggleY = Math.cos(data.jigglePhase * 1.3) * 0.002 * jiggleFactor;

 let posX = data.targetX + jiggleX;
 let posY = data.targetY + jiggleY;

 const scaleBounce = settleAge < 0.3 ? 1.0 + (1.0 - settleAge / 0.3) * 0.15 : 1.0;
 let scaleValue = data.baseScale * scaleBounce;

 data.flickerPhase += dt * 8;
 const brightProgress = Math.min(1, settleAge * 0.25);
 let opacityTarget = THREE.MathUtils.lerp(0.1, 0.8, brightProgress) + Math.sin(data.flickerPhase) * 0.15;
 let edgeOpacity = THREE.MathUtils.lerp(0.4, 0.3, brightProgress);
 let baseColor = THREE.MathUtils.lerp(0.2, 1.0, brightProgress);

 let pulseTime = 0;
 let reactionActive = false;

 if (celliBackspaceSequenceStarted && t >= celliBackspaceSequenceTime) {
 reactionActive = true;
 const reactionElapsed = t - celliBackspaceSequenceTime;
 const vibrateDuration = 1.1;
 if (reactionElapsed < vibrateDuration) {
 const intensity = THREE.MathUtils.lerp(0.08, 0.0, reactionElapsed / vibrateDuration);
 posX += (Math.random() - 0.5) * intensity;
 posY += (Math.random() - 0.5) * intensity;
 opacityTarget = Math.min(1, opacityTarget + 0.2);
 edgeOpacity = Math.min(0.85, edgeOpacity + 0.25);
 baseColor = Math.min(1.0, baseColor + 0.2);
 } else {
 pulseTime = reactionElapsed - vibrateDuration;
 if (!data.backspaceTransformed) {
 data.backspaceTransformed = true;
 voxel.geometry = roundedVoxelGeo.clone();
 const newMat = cellShadeBaseMaterial.clone();
 voxel.material.dispose();
 voxel.material = newMat;
 if (data.edges) {
 voxel.remove(data.edges);
 }
 const newEdges = new THREE.LineSegments(roundedEdgesGeo, cellShadeEdgeMaterial.clone());
 voxel.add(newEdges);
 data.edges = newEdges;
 }
 const pulse = 1 + 0.08 * Math.sin(pulseTime * 4 + data.backspacePulseOffset);
 scaleValue = data.baseScale * pulse;
 opacityTarget = 0.88 + 0.08 * Math.sin(pulseTime * 3 + data.backspacePulseOffset);
 edgeOpacity = 0.78 + 0.12 * Math.sin(pulseTime * 5 + data.backspacePulseOffset);
 posX += Math.sin(pulseTime * 2 + data.backspacePulseOffset) * 0.008;
 posY += Math.cos(pulseTime * 2.2 + data.backspacePulseOffset) * 0.008;
 baseColor = 1.0;
 }
 }

 // Only set default position/scale if not in snap animation
 if (!snapTogetherStarted || !data.backspaceTransformed) {
 voxel.position.x = posX;
 voxel.position.y = posY;
 voxel.scale.set(scaleValue, scaleValue, scaleValue);
 }

 if (voxel.material) {
 if (data.backspaceTransformed) {
 // If VisiCalc green transition has started, skip all other color logic
 if (visiCalcGreenTransitionStarted) {
 // VisiCalc green color is handled in snap-together animation below
 // Don't override it here
 } else if (endColorTransitionStart > 0) {
 // Handle END sequence color transitions
 const colors = {
 yellow: { r: 1.0, g: 0.95, b: 0.3 },
 magenta: { r: 0.95, g: 0.2, b: 0.4 },
 cyan: { r: 0.2, g: 0.7, b: 0.95 },
 green: { r: 0.3, g: 0.9, b: 0.4 }
 };
 
 const transitionDuration = 0.6; // 600ms
 const elapsed = t - endColorTransitionStart;
 const progress = THREE.MathUtils.clamp(elapsed / transitionDuration, 0, 1);
 
 const fromColor = colors[endColorPrevState];
 const toColor = colors[endColorState];
 
 const r = THREE.MathUtils.lerp(fromColor.r, toColor.r, progress);
 const g = THREE.MathUtils.lerp(fromColor.g, toColor.g, progress);
 const b = THREE.MathUtils.lerp(fromColor.b, toColor.b, progress);
 
 // Static color for green (pixel art style), pulse for others
 if (endColorState === 'green' && progress >= 1) {
 voxel.material.color.setRGB(0.3, 0.9, 0.4);
 voxel.material.opacity = 0.95;
 } else if (progress >= 1) {
 // Transition complete - show final color with pulse
 const pulse = Math.sin(t * 2 + data.backspacePulseOffset) * 0.05;
 voxel.material.color.setRGB(toColor.r, toColor.g, toColor.b);
 voxel.material.opacity = 0.9 + pulse;
 } else {
 // Mid-transition
 const pulse = Math.sin(t * 2 + data.backspacePulseOffset) * 0.05;
 voxel.material.color.setRGB(r, g, b);
 voxel.material.opacity = 0.9 + pulse;
 }
 } else {
 // Yellow glowing pulse for initial yellow state
 const yellowPulse = Math.sin(t * 2 + data.backspacePulseOffset);
 voxel.material.opacity = 0.9 + 0.05 * yellowPulse;
 const yellowB = 0.3 + 0.1 * yellowPulse;
 voxel.material.color.setRGB(1.0, 0.95, yellowB);
 }
 } else {
 voxel.material.opacity = opacityTarget;
 voxel.material.color.setRGB(baseColor, baseColor, baseColor);
 }
 }

 if (data.edges && data.edges.material) {
 if (data.backspaceTransformed) {
 // Handle snap-together: fade out edges DURING green transition
 if (snapTogetherStarted) {
 const snapElapsed = t - snapTogetherTime;
 const vibrateDuration = 0.4;
 const jiggleDuration = 0.5;
 const greenTransitionDuration = 0.3;
 
 // Fade out edges during green transition
 if (snapElapsed >= vibrateDuration + jiggleDuration) {
 // Green transition has started or finished - no edges
 data.edges.material.opacity = 0;
 data.edges.visible = false;
 } else if (snapElapsed >= vibrateDuration) {
 // During jiggle - start fading
 const fadeProgress = (snapElapsed - vibrateDuration) / jiggleDuration;
 data.edges.material.opacity = THREE.MathUtils.lerp(0.6, 0, fadeProgress);
 }
 } else {
 // Edge colors based on END state
 if (endColorState === 'magenta') {
 data.edges.material.color.setRGB(1.0, 0.3, 0.5);
 data.edges.material.opacity = 0.6;
 } else if (endColorState === 'cyan') {
 data.edges.material.color.setRGB(0.3, 0.8, 1.0);
 data.edges.material.opacity = 0.6;
 } else if (endColorState === 'green') {
 data.edges.material.color.setRGB(0.4, 1.0, 0.5);
 data.edges.material.opacity = 0.6;
 } else {
 // Yellow edges
 data.edges.material.color.setRGB(1.0, 0.9, 0.4);
 data.edges.material.opacity = 0.6 + 0.1 * Math.sin(t * 2.5 + data.backspacePulseOffset);
 }
 }
 } else {
 data.edges.material.opacity = THREE.MathUtils.clamp(edgeOpacity, 0, 1);
 }
 }
 
 // Snap-together animation: vibration, then jiggle, then turn green
 if (snapTogetherStarted && data.backspaceTransformed) {
 // Initialize snap time on first frame
 if (snapTogetherTime === 0) {
 snapTogetherTime = t;
 console.log('?? Snap animation started at t =', t);
 }
 
 const snapElapsed = t - snapTogetherTime;
 const vibrateDuration = 0.4;
 const jiggleDuration = 0.5;
 const greenTransitionDuration = 0.3;
 const flatHoldDuration = 0.4; // Hold as flat pixels before shrinking
 
 
 if (snapElapsed < vibrateDuration) {
 // High-frequency vibration
 const vibrateIntensity = 0.015 * (1 - snapElapsed / vibrateDuration);
 posX += (Math.random() - 0.5) * vibrateIntensity;
 posY += (Math.random() - 0.5) * vibrateIntensity;
 voxel.position.x = posX;
 voxel.position.y = posY;
 } else if (snapElapsed < vibrateDuration + jiggleDuration) {
 // Snap closer + jiggle
 const jiggleProgress = (snapElapsed - vibrateDuration) / jiggleDuration;
 const jiggleIntensity = 0.008 * (1 - jiggleProgress);
 
 // Pull voxels toward their letter center
 const targetCenterX = data.targetX;
 const snapAmount = jiggleProgress * 0.3;
 posX = THREE.MathUtils.lerp(posX, targetCenterX, snapAmount * 0.1);
 posX += Math.sin(t * 15 + data.backspacePulseOffset) * jiggleIntensity;
 posY += Math.cos(t * 18 + data.backspacePulseOffset) * jiggleIntensity;
 
 voxel.position.x = posX;
 voxel.position.y = posY;
 } else if (snapElapsed < vibrateDuration + jiggleDuration + greenTransitionDuration) {
 // Transition to VisiCalc green - turn off bloom immediately
 if (!visiCalcGreenTransitionStarted) {
 visiCalcGreenTransitionStarted = true;
 bloomPass.strength = 0.0; // Immediately turn off bloom
 console.log('?? Green transition started - bloom OFF, edges should be INVISIBLE');
 
 // REMOVE all edges from scene permanently
 voxels.forEach(v => {
 if (v.userData.edges) {
 v.remove(v.userData.edges);
 v.userData.edges.geometry.dispose();
 v.userData.edges.material.dispose();
 v.userData.edges = null;
 }
 });
 console.log('??? ALL EDGES REMOVED FROM SCENE');
 }
 
 const greenProgress = (snapElapsed - vibrateDuration - jiggleDuration) / greenTransitionDuration;
 const greenColor = { r: 0.0, g: 1.0, b: 0.0 }; // Pure VisiCalc green
 
 // Get current color
 const currentColor = voxel.material.color;
 const r = THREE.MathUtils.lerp(currentColor.r, greenColor.r, greenProgress);
 const g = THREE.MathUtils.lerp(currentColor.g, greenColor.g, greenProgress);
 const b = THREE.MathUtils.lerp(currentColor.b, greenColor.b, greenProgress);
 
 voxel.material.color.setRGB(r, g, b);
 voxel.material.opacity = 1.0; // Solid for pixel art
 
 // Keep bloom off
 bloomPass.strength = 0.0;
 
 // Collapse into tighter mono-spaced grid
 const monoSpacing = 0.022; // Tight pixel spacing
 const monoX = data.gridCol * monoSpacing;
 const monoY = -data.gridRow * monoSpacing;
 const letterOffsetX = data.letterIdx * 5 * monoSpacing; // 5 columns per letter
 
 posX = THREE.MathUtils.lerp(data.targetX, letterOffsetX + monoX, greenProgress);
 posY = THREE.MathUtils.lerp(data.targetY, monoY, greenProgress);
 
			voxel.position.x = posX;
			voxel.position.y = posY;
			voxel.scale.set(data.baseScale * 0.95, data.baseScale * 0.95, data.baseScale * 0.95);
		} else if (snapElapsed < vibrateDuration + jiggleDuration + greenTransitionDuration + flatHoldDuration + 1.8) {
			// Hold as flat green pixels in mono-spaced positions (includes pause after HELL forms)
			bloomPass.strength = 0.0;
			voxel.material.color.setRGB(0.0, 1.0, 0.0);
			voxel.material.opacity = 1.0;
			
			// Hold at mono-spaced positions
			const monoSpacing = 0.022;
			const monoX = data.gridCol * monoSpacing;
			const monoY = -data.gridRow * monoSpacing;
			const letterOffsetX = data.letterIdx * 5 * monoSpacing;
			
			voxel.position.x = letterOffsetX + monoX;
			voxel.position.y = monoY;
			voxel.scale.set(data.baseScale * 0.95, data.baseScale * 0.95, data.baseScale * 0.95);
		} else {
			// After flat hold + pause, start move to corner
			if (!celliMoveToCornerStarted) {
				celliMoveToCornerStarted = true;
				celliMoveToCornerTime = t;
				bloomPass.strength = 0.0;
				console.log('%c[GREEN] ?? Move to corner started at t = ' + t, 'background: #0a0; color: #fff; font-weight: bold; padding: 4px;');
				console.log('%c[GREEN] âœ“ NOW READY: Press Shift to trigger HELL transformation!', 'background: #ff0; color: #000; font-size: 16px; font-weight: bold; padding: 8px;');
			}
		}
 
 // Move CELLI to corner animation (runs after flat hold)
 if (celliMoveToCornerStarted) {
 const moveElapsed = t - celliMoveToCornerTime;
 const collapseDuration = 0.6; // Collapse to center
 const expandDuration = 0.8; // Expand into VisiCell position
 const totalMoveDuration = collapseDuration + expandDuration;
 
 // Keep bloom off for flat pixel look
 bloomPass.strength = 0.0;
 
 // Keep VisiCalc green color during movement - flat, no glow
 voxel.material.color.setRGB(0.0, 1.0, 0.0);
 voxel.material.opacity = 1.0;
 
 // Store mono-spaced starting position if not set
 if (!data.monoStartX) {
 const monoSpacing = 0.022;
 const monoX = data.gridCol * monoSpacing;
 const monoY = -data.gridRow * monoSpacing;
 const letterOffsetX = data.letterIdx * 5 * monoSpacing;
 data.monoStartX = letterOffsetX + monoX;
 data.monoStartY = monoY;
 }
 
 if (moveElapsed < collapseDuration) {
 // Phase 1: Organic collapse to center with wave motion
 const collapseProgress = moveElapsed / collapseDuration;
 const collapseEased = collapseProgress * collapseProgress * (3 - 2 * collapseProgress);
 
 // Add wave motion based on voxel index for organic feel
 const waveOffset = (data.letterIdx * 10 + data.gridRow * 3 + data.gridCol) * 0.05;
 const waveDelay = Math.max(0, collapseProgress - waveOffset);
 const waveEased = Math.min(1, waveDelay * 1.3);
 const waveSine = Math.sin(waveEased * Math.PI);
 
 posX = THREE.MathUtils.lerp(data.monoStartX, 0, waveEased);
 posY = THREE.MathUtils.lerp(data.monoStartY, 0, waveEased);
 
 // Add slight orbital motion during collapse
 const orbitAngle = waveEased * Math.PI * 2;
 posX += Math.cos(orbitAngle) * (1 - waveEased) * 0.015;
 posY += Math.sin(orbitAngle) * (1 - waveEased) * 0.015;
 
 voxel.position.x = posX;
 voxel.position.y = posY;
 
 // Shrink with pulse
 const pulse = waveSine * 0.15;
 const currentScale = THREE.MathUtils.lerp(data.baseScale * 0.95, data.baseScale * 0.3, waveEased) * (1 + pulse);
 voxel.scale.set(currentScale, currentScale, currentScale);
 
 // Keep fully visible during collapse
 voxel.material.opacity = 1.0;
 } else if (moveElapsed < totalMoveDuration) {
 // Phase 2: Expand into VisiCell position
 const expandProgress = (moveElapsed - collapseDuration) / expandDuration;
 const expandEased = expandProgress < 0.5 ? 
 2 * expandProgress * expandProgress : 
 1 - Math.pow(-2 * expandProgress + 2, 2) / 2;
 
 // Target position: top-left corner (where "A1: CELLI" appears)
 const targetX = -0.85;
 const targetY = 0.75;
 const targetScale = 0.45; // Smaller for VisiCell text
 
 // Calculate target offset based on grid position
 const visiCellSpacing = 0.018; // Tighter for VisiCell
 const targetOffsetX = data.gridCol * visiCellSpacing;
 const targetOffsetY = -data.gridRow * visiCellSpacing;
 const targetLetterOffset = data.letterIdx * 5 * visiCellSpacing;
 
 posX = THREE.MathUtils.lerp(0, targetX + targetLetterOffset + targetOffsetX, expandEased);
 posY = THREE.MathUtils.lerp(0, targetY + targetOffsetY, expandEased);
 
 voxel.position.x = posX;
 voxel.position.y = posY;
 
 // Expand from collapsed size to target size
 const currentScale = THREE.MathUtils.lerp(data.baseScale * 0.3, data.baseScale * targetScale, expandEased);
 voxel.scale.set(currentScale, currentScale, currentScale);
 } else {
 // Hold at final VisiCell position
 const targetX = -0.85;
 const targetY = 0.75;
 const targetScale = 0.45;
 const visiCellSpacing = 0.018;
 const targetOffsetX = data.gridCol * visiCellSpacing;
 const targetOffsetY = -data.gridRow * visiCellSpacing;
 const targetLetterOffset = data.letterIdx * 5 * visiCellSpacing;
 
 voxel.position.x = targetX + targetLetterOffset + targetOffsetX;
 voxel.position.y = targetY + targetOffsetY;
 voxel.scale.set(data.baseScale * targetScale, data.baseScale * targetScale, data.baseScale * targetScale);
 
// Show VisiCell once animation is complete (only trigger once)
// BUT: in sequence mode, let the narrative control when VisiCalc appears
const isSequenceMode = (typeof EXEC_ENV_MODE !== 'undefined' && EXEC_ENV_MODE === 'sequence') || (typeof window.EXEC_ENV_MODE !== 'undefined' && window.EXEC_ENV_MODE === 'sequence');
if (!visiCalcShown && !isSequenceMode) {
visiCalcShown = true;
console.log('? Move-to-corner animation complete, showing VisiCell');
showVisiCalc();
}
 }
 }
 }
 }
 });

 if (!bowHasTriggered) {
 const allSettled = voxels.every(voxel => voxel.userData && voxel.userData.settled);
 if (allSettled) {
 animateSkipToBow();
 }
 }

 updateBowVoxelPresence();
 }

 // Restore one voxel from the glitched stack with fritz effect
 function restoreOneLetter() {
 if (restoredLetters >= lettersToRestore.length) return false;
 
 const letterKey = lettersToRestore[restoredLetters];
 const letterVoxelsList = letterVoxels[letterKey];
 
 if (!letterVoxelsList || letterVoxelsList.length === 0) return false;
 
 // Play electrical fritz sound
 if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); window.audioCtx = audioCtx; }
 const now = audioCtx.currentTime;
 
 // Bigger fritz sound for whole letter
 const buzz = audioCtx.createOscillator();
 const buzzGain = audioCtx.createGain();
 
 buzz.type = 'sawtooth';
 buzz.frequency.setValueAtTime(150, now);
 buzz.frequency.exponentialRampToValueAtTime(100, now + 0.25);
 
 buzzGain.gain.setValueAtTime(0, now);
 buzzGain.gain.linearRampToValueAtTime(0.1, now + 0.02);
 buzzGain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
 
 buzz.connect(buzzGain);
 buzzGain.connect(audioCtx.destination);
 buzz.start(now);
 buzz.stop(now + 0.25);
 
 // Restore all voxels in this letter with staggered timing
 letterVoxelsList.forEach((voxel, idx) => {
 const data = voxel.userData;
 const delay = idx * 30; // Stagger by 30ms per voxel
 
 setTimeout(() => {
 // Make visible again
 voxel.visible = true;
 data.edges.visible = true;
 data.glitched = false;
 
 // Start with dark gray
 voxel.material.color.setRGB(0.15, 0.15, 0.15);
 data.edges.material.color.setRGB(0.2, 0.2, 0.2);
 voxel.material.opacity = 0.2;
 data.edges.material.opacity = 0.1;
 
 // Fritz flicker effect
 let flickerCount = 0;
 const maxFlickers = 6;
 const flickerInterval = setInterval(() => {
 flickerCount++;
 const flickerOn = flickerCount % 2 === 1;
 
 if (flickerOn) {
 voxel.material.color.setRGB(0.9, 0.9, 0.9);
 voxel.material.opacity = 0.85;
 data.edges.material.opacity = 0.6;
 } else {
 voxel.material.color.setRGB(0.3, 0.3, 0.3);
 voxel.material.opacity = 0.3;
 data.edges.material.opacity = 0.2;
 }
 
 if (flickerCount >= maxFlickers) {
 clearInterval(flickerInterval);
 
 // Restore to normal white/bright state
 const restoreStart = Date.now();
 const restoreDuration = 200;
 const restoreInterval = setInterval(() => {
 const restoreProgress = (Date.now() - restoreStart) / restoreDuration;
 if (restoreProgress >= 1) {
 clearInterval(restoreInterval);
 voxel.material.color.setRGB(0.8, 0.8, 0.8);
 voxel.material.opacity = 0.75;
 data.edges.material.opacity = 0.35;
 } else {
 const brightness = THREE.MathUtils.lerp(0.3, 0.8, restoreProgress);
 voxel.material.color.setRGB(brightness, brightness, brightness);
 voxel.material.opacity = THREE.MathUtils.lerp(0.3, 0.75, restoreProgress);
 data.edges.material.opacity = THREE.MathUtils.lerp(0.2, 0.35, restoreProgress);
 }
 }, 16);
 }
 }, 70);
 }, delay);
 });
 
 restoredLetters++;
 
 // If all 4 letters restored (C, E, L, L), automatically restore I and transform
 if (restoredLetters === 4) {
 setTimeout(() => {
 restoreIAndTransform();
 }, 800);
 }
 
 return true;
 }
 
 function restoreIAndTransform() {
 const iVoxels = letterVoxels.I;
 
 // Play final restoration sound
 if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); window.audioCtx = audioCtx; }
 const now = audioCtx.currentTime;
 
 const buzz = audioCtx.createOscillator();
 const buzzGain = audioCtx.createGain();
 
 buzz.type = 'sine';
 buzz.frequency.setValueAtTime(200, now);
 buzz.frequency.exponentialRampToValueAtTime(400, now + 0.4);
 
 buzzGain.gain.setValueAtTime(0, now);
 buzzGain.gain.linearRampToValueAtTime(0.12, now + 0.05);
 buzzGain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
 
 buzz.connect(buzzGain);
 buzzGain.connect(audioCtx.destination);
 buzz.start(now);
 buzz.stop(now + 0.4);
 
 // Restore I voxels quickly
 iVoxels.forEach((voxel, idx) => {
 const data = voxel.userData;
 const delay = idx * 20;
 
 setTimeout(() => {
 voxel.visible = true;
 data.edges.visible = true;
 data.glitched = false;
 voxel.material.color.setRGB(0.8, 0.8, 0.8);
 voxel.material.opacity = 0.75;
 data.edges.material.opacity = 0.35;
 }, delay);
 });
 
 // After brief pause, transform all CELLI to yellow rounded glow
 setTimeout(() => {
 transformCelliToYellow();
 }, 600);
 }
 
 function transformCelliToYellow() {
 // Transform all voxels to yellow with rounded corners, pop shrink/burst animation
 const skipBtn = document.getElementById('skipBtn');
 if (skipBtn) {
 // Re-show the bow when CELLI is restored - FULL BRIGHTNESS
 bowVisibleAsVoxel = true;
 skipBtn.classList.remove('voxel-hidden');
 skipBtn.classList.remove('magenta-phase');
 skipBtn.classList.remove('cyan-phase');
 skipBtn.style.pointerEvents = 'auto';
 skipBtn.style.opacity = '1'; // Full opacity restored
 skipBtn.style.filter = 'none'; // Clear any filters
 skipBtn.style.transition = 'opacity 0.6s ease, filter 0.6s ease';
 skipBtn.classList.add('illuminating');
 skipBtn.classList.add('golden-phase');
 }

 yellowTransformCompleteCount = 0;
 allYellowTransformed = false;
 const totalVoxels = voxels.length || 1;

 voxels.forEach((voxel, idx) => {
 const data = voxel.userData;
 const delay = idx * 15; // Stagger transformation
 
 setTimeout(() => {
 // Phase 1: Shrink inward (pop preparation)
 const shrinkStart = Date.now();
 const shrinkDuration = 150;
 
 const shrinkInterval = setInterval(() => {
 const progress = (Date.now() - shrinkStart) / shrinkDuration;
 if (progress >= 1) {
 clearInterval(shrinkInterval);
 
 // Phase 2: Burst outward + transform to rounded + yellow color
 const burstStart = Date.now();
 const burstDuration = 300;
 
 // Change to rounded geometry
 voxel.geometry.dispose();
 voxel.geometry = roundedVoxelGeo.clone();
 voxel.remove(data.edges);
 const newEdges = new THREE.LineSegments(roundedEdgesGeo, edgeMat.clone());
 voxel.add(newEdges);
 data.edges = newEdges;
 
 const burstInterval = setInterval(() => {
 const burstProgress = (Date.now() - burstStart) / burstDuration;
 if (burstProgress >= 1) {
 clearInterval(burstInterval);
 
 // Phase 3: Settle to yellow
 voxel.scale.set(data.baseScale, data.baseScale, data.baseScale);
 voxel.material.color.setRGB(1.0, 0.95, 0.3);
 voxel.material.opacity = 0.9;
 data.edges.material.color.setRGB(1.0, 0.9, 0.4);
 data.edges.material.opacity = 0.6;
 if (!data.backspaceTransformed) {
 data.backspaceTransformed = true;
 yellowTransformCompleteCount++;
 if (yellowTransformCompleteCount >= totalVoxels) {
 allYellowTransformed = true;
 activateRoundedBow();
 }
 }
 } else {
 // Burst scale and color change
 const scale = data.baseScale * THREE.MathUtils.lerp(0.5, 1.15, burstProgress);
 voxel.scale.set(scale, scale, scale);
 
 const r = THREE.MathUtils.lerp(0.8, 1.0, burstProgress);
 const g = THREE.MathUtils.lerp(0.8, 0.95, burstProgress);
 const b = THREE.MathUtils.lerp(0.8, 0.3, burstProgress);
 voxel.material.color.setRGB(r, g, b);
 data.edges.material.color.setRGB(
 THREE.MathUtils.lerp(0.8, 1.0, burstProgress),
 THREE.MathUtils.lerp(0.8, 0.9, burstProgress),
 0.4
 );
 }
 }, 16);
 } else {
 // Shrink scale
 const scale = data.baseScale * THREE.MathUtils.lerp(1.0, 0.5, progress);
 voxel.scale.set(scale, scale, scale);
 }
 }, 16);
 }, delay);
 });
 }

 function activateRoundedBow() {
 const skipBtn = document.getElementById('skipBtn');
 if (!skipBtn) return;

 if (!skipBtn.classList.contains('bow-shape')) {
 pendingRoundedBow = true;
 return;
 }

 skipBtn.classList.add('rounded-bow');
 pendingRoundedBow = false;
 }

 // Transform voxels to magenta-red (E input) + start HELL transformation (phase 1)
 function transformToMagentaRed() {
 endColorPrevState = endColorState;
 endColorState = 'magenta';
 endColorTransitionStart = totalTime;
 
 console.log('%c[HELL 1/3] ðŸ”´ MAGENTA SHIFT - Starting Phase 1 of CELLI->HELL', 'background: #ff1e6e; color: #fff; font-size: 16px; font-weight: bold; padding: 8px;');
 
 // Update bow to magenta color
 const skipBtn = document.getElementById('skipBtn');
 if (skipBtn) {
 skipBtn.classList.remove('golden-phase');
 skipBtn.classList.add('magenta-phase');
 }
 
 // Phase 1: Remove top arc of C (columns 1-3 of row 0)
 // NOTE: Column 0 (left side of C) is NEVER removed - it becomes the left side of H
 if (!letterVoxels || !letterVoxels.C) {
 console.error('[HELL 1/3] letterVoxels.C not found');
 return;
 }
 
	letterVoxels.C.forEach(voxel => {
		const row = voxel.userData.gridY;
		const col = voxel.userData.gridCol;
		
		// SAFETY: Never remove column 0 (left side of H) or row 2 (middle bar of H)
		if (col === 0 || row === 2) {
			return; // Skip - these voxels must stay for H shape
		}
		
		// Remove top arc (row 0, columns 1-3) - preserves column 0
		if (row === 0 && col >= 1 && col <= 3) {
			console.log(`[HELL 1/3] Falling voxel at C row=${row}, col=${col}`);
			voxel.userData.fallingOff = true;
			voxel.userData.fallStartTime = Date.now() / 1000;
			voxel.userData.fallDelay = col * 0.1; // Stagger by column
			voxel.userData.fallVelocity = 0;
			voxel.userData.rotationSpeed = {
				x: (Math.random() - 0.5) * 0.1,
				y: (Math.random() - 0.5) * 0.1,
				z: (Math.random() - 0.5) * 0.1
			};
			
			// Will reappear as right column top (only middle voxel col=2)
			if (col === 2) {
				voxel.userData.willReappearAs = { row: 0, col: 4, letterIdx: 0 };
			}
		}
	});
 
 console.log('[HELL 1/3] Phase 1 voxels marked for falling');
 }
 
 // Transform voxels to cyan-blue (N input) + continue HELL transformation (phase 2)
 function transformToCyanBlue() {
 endColorPrevState = endColorState;
 endColorState = 'cyan';
 endColorTransitionStart = totalTime;
 
 console.log('%c[HELL 2/3] ðŸ”µ CYAN SHIFT - Phase 2 of CELLI->HELL', 'background: #00a8ff; color: #fff; font-size: 16px; font-weight: bold; padding: 8px;');
 
 // Update bow to cyan color
 const skipBtn = document.getElementById('skipBtn');
 if (skipBtn) {
 skipBtn.classList.remove('magenta-phase');
 skipBtn.classList.add('cyan-phase');
 }
 
 // Phase 2: Remove bottom arc of C (columns 1-3 of row 4) + start removing I voxels
 if (!letterVoxels || !letterVoxels.C || !letterVoxels.I) {
 console.error('[HELL 2/3] letterVoxels not found');
 return;
 }
 
	letterVoxels.C.forEach(voxel => {
		const row = voxel.userData.gridY;
		const col = voxel.userData.gridCol;
		
		// SAFETY: Never remove column 0 (left side of H) or row 2 (middle bar of H)
		if (col === 0 || row === 2) {
			return; // Skip - these voxels must stay for H shape
		}
		
		// Remove bottom arc (row 4, columns 1-3)
		if (row === 4 && col >= 1 && col <= 3) {
			console.log(`[HELL 2/3] Falling voxel at C row=${row}, col=${col}`);
			voxel.userData.fallingOff = true;
			voxel.userData.fallStartTime = Date.now() / 1000;
			voxel.userData.fallDelay = col * 0.1;
			voxel.userData.fallVelocity = 0;
			voxel.userData.rotationSpeed = {
				x: (Math.random() - 0.5) * 0.1,
				y: (Math.random() - 0.5) * 0.1,
				z: (Math.random() - 0.5) * 0.1
			};
			
			// Will reappear as right column bottom (only middle voxel col=2)
			if (col === 2) {
				voxel.userData.willReappearAs = { row: 4, col: 4, letterIdx: 0 };
			}
		}
	});
 
 // Start removing I voxels - top bar and some center column
 letterVoxels.I.forEach((voxel, idx) => {
 const row = voxel.userData.gridY;
 const col = voxel.userData.gridCol;
 
 // Remove top bar (row 0, all columns) and center column rows 1-2
 if (row === 0 || (row >= 1 && row <= 2 && col === 2)) {
 console.log(`[HELL 2/3] Falling voxel at I row=${row}, col=${col}`);
 voxel.userData.fallingOff = true;
 voxel.userData.fallStartTime = Date.now() / 1000;
 voxel.userData.fallDelay = idx * 0.1;
 voxel.userData.fallVelocity = 0;
 voxel.userData.rotationSpeed = {
 x: (Math.random() - 0.5) * 0.1,
 y: (Math.random() - 0.5) * 0.1,
 z: (Math.random() - 0.5) * 0.1
 };
 
 // Center column voxels reappear as right column of H
 if (row >= 1 && row <= 2 && col === 2) {
 voxel.userData.willReappearAs = { row: row, col: 4, letterIdx: 0 };
 }
 }
 });
 
 console.log('[HELL 2/3] Phase 2 voxels marked for falling');
 }
 
 // Transform voxels to green and snap back to non-rounded (D input) + complete HELL transformation (phase 3)
 function transformToGreenAndSquare() {
 console.log('%c[HELL 3/3] ðŸŸ¢ GREEN SHIFT - Final Phase of CELLI->HELL', 'background: #0f0; color: #000; font-size: 16px; font-weight: bold; padding: 8px;');
 endColorPrevState = endColorState;
 endColorState = 'green';
 endColorTransitionStart = totalTime;

 const skipBtn = document.getElementById('skipBtn');
 if (skipBtn) {
 skipBtn.classList.remove('golden-phase');
 skipBtn.classList.remove('magenta-phase');
 skipBtn.classList.remove('cyan-phase');
 skipBtn.classList.remove('illuminating');
 // Fully fade out the bow
 skipBtn.style.transition = 'opacity 0.6s ease';
 skipBtn.style.opacity = '0';
 skipBtn.style.pointerEvents = 'none';
 }
 
 // Phase 3: Complete HELL transformation - remove ALL remaining I voxels
 if (!letterVoxels || !letterVoxels.I) {
 console.error('[HELL 3/3] letterVoxels.I not found');
 } else {
 letterVoxels.I.forEach((voxel, idx) => {
 const row = voxel.userData.gridY;
 const col = voxel.userData.gridCol;
 
 // Skip voxels already marked for falling in previous phases
 if (voxel.userData.fallingOff) {
 return;
 }
 
 // Remove ALL remaining I voxels
 // This includes: center column rows 3-4, bottom bar (row 4 all cols), and any side columns rows 1-3
 console.log(`[HELL 3/3] Falling voxel at I row=${row}, col=${col}`);
 voxel.userData.fallingOff = true;
 voxel.userData.fallStartTime = Date.now() / 1000;
 voxel.userData.fallDelay = idx * 0.08;
 voxel.userData.fallVelocity = 0;
 voxel.userData.rotationSpeed = {
 x: (Math.random() - 0.5) * 0.1,
 y: (Math.random() - 0.5) * 0.1,
 z: (Math.random() - 0.5) * 0.1
 };
 
 // Row 3 center column reappears as right column of H
 if (row === 3 && col === 2) {
 voxel.userData.willReappearAs = { row: 3, col: 4, letterIdx: 0 };
 }
 });
 
 console.log('[HELL 3/3] Final phase voxels marked for falling - HELL transformation complete!');
 console.log('[HELL 3/3] All I voxels should now be falling or will reappear as right column of H');
 }
 
 // Change back to square geometry immediately
 voxels.forEach((voxel, idx) => {
 const data = voxel.userData;
 if (!data.backspaceTransformed) return;
 
 setTimeout(() => {
 voxel.geometry.dispose();
 voxel.geometry = voxelGeo.clone();
 voxel.remove(data.edges);
 const newEdges = new THREE.LineSegments(edgesGeo, edgeMat.clone());
 voxel.add(newEdges);
 data.edges = newEdges;
 }, idx * 8);
 });
 
 // Start snap-together animation immediately (color transition happens simultaneously)
 snapTogetherStarted = true;
 console.log('%c[GREEN] ?? snapTogetherStarted set to true', 'background: #0f0; color: #000; font-weight: bold; padding: 4px;');
 console.log('[GREEN] HELL should now be formed from fallen voxels');
 console.log('[GREEN] Watch for celliMoveToCornerStarted flag in console');
 
 // VisiCell will be shown after animation completes (triggered in updateVoxels)
 // snapTogetherTime will be set on first frame in updateVoxels
 }

 // Ensure any pending reappear-as for H finalize immediately
 voxels.forEach((voxel) => {
  const d = voxel.userData || {};
  if (d.fallingOff && d.willReappearAs && !d.hasReappeared) {
   const letterIdx = d.willReappearAs.letterIdx;
   const newRow = d.willReappearAs.row;
   const newCol = d.willReappearAs.col;
   const letterX = -(letters.length * letterSpacing * celliScale) / 2 + (letterSpacing * celliScale) / 2 + letterIdx * letterSpacing * celliScale;
   const x = letterX + (newCol - 2) * voxelSize * 1.2 * celliScale;
   const y = (2 - newRow) * voxelSize * 1.2 * celliScale + 0.35;
   voxel.position.set(x, y, 0);
   voxel.rotation.set(0, 0, 0);
   d.targetX = x; d.targetY = y; d.gridY = newRow; d.gridCol = newCol; d.gridRow = newRow; d.letterIdx = letterIdx;
   voxel.material.opacity = 0.8;
   if (d.edges && d.edges.material) d.edges.material.opacity = 0.6;
   voxel.visible = true;
   d.fallingOff = false;
   d.hasReappeared = true;
  }
 });
 
 function computeBowAnchorScreenPosition() {
 const cVoxels = letterVoxels.C || [];
 if (!cVoxels.length) return null;

 let minX = Infinity;
 let maxY = -Infinity;
 let sumX = 0;
 let sumY = 0;
 let count = 0;
 let topSumX = 0;
 let topSumY = 0;
 let topCount = 0;

 cVoxels.forEach((voxel) => {
 const data = voxel.userData;
 if (!data) return;
 minX = Math.min(minX, data.targetX);
 maxY = Math.max(maxY, data.targetY);
 sumX += data.targetX;
 sumY += data.targetY;
 count++;
 if (typeof data.gridRow === 'number' && data.gridRow <= 1) {
 topSumX += data.targetX;
 topSumY += data.targetY;
 topCount++;
 }
 });

 if (!Number.isFinite(minX) || !Number.isFinite(maxY) || count === 0) {
 return null;
 }

 const anchor = new THREE.Vector3(
 minX - voxelSize * 0.9,
 maxY + voxelSize * 1.4,
 0
 );
 anchor.project(camera);

 const focusTargetX = topCount > 0 ? topSumX / topCount : sumX / count;
 const focusTargetY = topCount > 0 ? topSumY / topCount : (sumY / count) - voxelSize * 0.4;
 const focus = new THREE.Vector3(focusTargetX, focusTargetY, 0);
 focus.project(camera);

 const anchorScreenX = (anchor.x + 1) / 2 * window.innerWidth;
 const anchorScreenY = (-anchor.y + 1) / 2 * window.innerHeight;
 const focusScreenX = (focus.x + 1) / 2 * window.innerWidth;
 const focusScreenY = (-focus.y + 1) / 2 * window.innerHeight;
 let rotation = Math.atan2(focusScreenY - anchorScreenY, focusScreenX - anchorScreenX) - Math.PI / 2;
 rotation -= Math.PI / 14;

 return {
 x: anchorScreenX,
 y: anchorScreenY,
 rotation
 };
 }

 function moveBowToTarget(immediate = false) {
 const skipBtn = document.getElementById('skipBtn');
 if (!skipBtn) return;

 const target = computeBowAnchorScreenPosition();
 if (!target) return;

 bowTargetCenter = target;
 bowTargetRotation = typeof target.rotation === 'number' ? target.rotation : 0;

 if (!bowCurrentCenter) {
 const rect = skipBtn.getBoundingClientRect();
 bowCurrentCenter = {
 x: rect.left + rect.width / 2,
 y: rect.top + rect.height / 2
 };
 bowCurrentRotation = 0;
 }

 if (immediate) {
 bowCurrentCenter = { ...bowTargetCenter };
 bowCurrentRotation = bowTargetRotation;
 skipBtn.style.position = 'fixed';
 skipBtn.style.left = `${bowTargetCenter.x}px`;
 skipBtn.style.top = `${bowTargetCenter.y}px`;
 skipBtn.style.bottom = 'auto';
 skipBtn.style.transform = `translate(-50%, -50%) rotate(${bowTargetRotation}rad) scale(1)`;
 return;
 }

 const start = { ...bowCurrentCenter };
 const startRotation = bowCurrentRotation;
 const duration = 1200;
 const startTime = performance.now();
 if (bowAnimationId) cancelAnimationFrame(bowAnimationId);

 function step(now) {
 const elapsed = now - startTime;
 const progress = Math.min(elapsed / duration, 1);
 const eased = 1 - Math.pow(1 - progress, 3);
 const arcHeight = Math.min(window.innerHeight * 0.08, 70);
 const arc = Math.sin(progress * Math.PI) * arcHeight;

 const x = start.x + (bowTargetCenter.x - start.x) * eased;
 const y = start.y + (bowTargetCenter.y - start.y) * eased - arc;
 const rotation = startRotation + (bowTargetRotation - startRotation) * eased;

 bowCurrentCenter = { x, y };
 skipBtn.style.position = 'fixed';
 skipBtn.style.left = `${x}px`;
 skipBtn.style.top = `${y}px`;
 skipBtn.style.bottom = 'auto';
 const scale = 1 + 0.12 * (1 - eased);
 skipBtn.style.transform = `translate(-50%, -50%) rotate(${rotation}rad) scale(${scale})`;

 if (progress < 1) {
 bowAnimationId = requestAnimationFrame(step);
 } else {
 bowAnimationId = 0;
 bowCurrentCenter = { ...bowTargetCenter };
 bowCurrentRotation = bowTargetRotation;
 skipBtn.style.transform = `translate(-50%, -50%) rotate(${bowTargetRotation}rad) scale(1)`;
 bowActive = true;
 }
 }

 bowAnimationId = requestAnimationFrame(step);
 }

 function updateBowVoxelPresence() {
 const skipBtn = document.getElementById('skipBtn');
 if (!skipBtn) return;

 if (!skipBtn.classList.contains('bow-shape')) {
 return;
 }

 const cVoxels = letterVoxels.C || [];
 if (!cVoxels.length) return;

 let visibleCount = 0;
 let totalCount = 0;
 let totalOpacity = 0;
 cVoxels.forEach((voxel) => {
 const data = voxel.userData;
 if (!data) return;
 totalCount++;
 if (voxel.visible) {
 const opacity = voxel.material.opacity || 0;
 if (opacity > 0.01) {
 visibleCount++;
 totalOpacity += opacity;
 }
 }
 });

 if (totalCount === 0) return;

 // Match bow opacity to average voxel opacity
 const avgOpacity = visibleCount > 0 ? totalOpacity / visibleCount : 0;
 
 // If ANY voxels are invisible or fading, start hiding the bow
 if (visibleCount < totalCount || avgOpacity < 0.95) {
 // Match opacity EXACTLY to voxels, including going to 0
 skipBtn.style.opacity = avgOpacity.toString();
 
 // If fully invisible, mark as hidden
 if (avgOpacity < 0.01) {
 bowVisibleAsVoxel = false;
 skipBtn.classList.add('voxel-hidden');
 skipBtn.style.pointerEvents = 'none';
 }
 }
 // Don't automatically show it again - that's handled by restoreIAndTransform
 }

 // Animate skip triangles to form a bow above CELLI
 function animateSkipToBow({ immediate = false } = {}) {
 const skipBtn = document.getElementById('skipBtn');
 const tri1 = document.getElementById('skipTriangle1');
 const tri2 = document.getElementById('skipTriangle2');

 if (!skipBtn || !tri1 || !tri2) return;

 if (!immediate) {
 if (bowHasTriggered) return;
 bowHasTriggered = true;
 }

 skipBtn.classList.remove('hidden');
 skipBtn.classList.remove('voxel-hidden');
 if (!skipBtn.classList.contains('bow-lock')) {
 skipBtn.style.pointerEvents = 'auto';
 }
 tri1.style.transform = '';
 tri2.style.transform = '';
 skipBtn.classList.add('bow-lock');
 skipBtn.classList.add('bow-shape');

 if (pendingRoundedBow) {
 skipBtn.classList.add('rounded-bow');
 pendingRoundedBow = false;
 }

 bowActive = false;
 bowCurrentCenter = null;
 moveBowToTarget(immediate);
 }
 
 // Show VisiCell spreadsheet
 function showVisiCalc() {
 console.log('?? showVisiCalc called!');
 
 // Mark as seen
 localStorage.setItem('megred_seen_visicell', 'true');
 
 // Fade out doorway
 const doorway = document.getElementById('doorway');
 if (doorway) {
 doorway.style.transition = 'opacity 0.5s ease';
 doorway.style.opacity = '0';
 console.log('?? Doorway faded out');
 }
 
 // Create VisiCell overlay (appears behind 3D scene initially)
 const visiCalc = document.createElement('div');
 visiCalc.id = 'visicalc';
 visiCalc.style.cssText = `
 position: fixed;
 inset: 0;
 background: #000;
 color: #0f0;
 font-family: 'Courier New', monospace;
 font-size: 14px;
 padding: 20px;
 z-index: 100;
 opacity: 0;
 transition: opacity 0.8s ease;
 overflow: hidden;
 `;
 
 // Create VisiCell content (without CELLI in row 1 - the 3D pixels will be that)
 visiCalc.innerHTML = `
 <div style="border: 2px solid #0f0; padding: 10px; height: calc(100% - 40px); background: #000; opacity: 0; transition: opacity 0.6s ease;" id="visicalc-frame">
 <div style="border-bottom: 1px solid #0f0; padding-bottom: 5px; margin-bottom: 10px; opacity: 0; animation: fadeInVisi 0.4s ease forwards 0.2s; font-size: 13px; font-family: 'Courier New', monospace;">
 <span style="float: left;">VISICELL</span>
 <span style="float: right;">LOOMWORKS CELL</span>
 <div style="clear: both;"></div>
 </div>
 <div style="font-family: 'Courier New', monospace; white-space: pre; line-height: 1.6; font-size: 13px; opacity: 0; animation: fadeInVisi 0.5s ease forwards 0.5s;">
>A1:
 A B C D E F
1
2
3 LOOK
4
5 END
6
7 =STAR =T
8
9
10
11
12
13
14
15 =TRANSPOSE()
16
17
18
19
 20 LOOMWORKS
 21
 22
 23 <span class="visicell-note-line visicell-note-line--1">&gt;:(</span>
 24 <span class="visicell-note-line visicell-note-line--2">This isn't Stanley Parable. Don't try that again.</span>
 </div>
 <div id="visicellinput" style="position: absolute; bottom: 24px; left: 36px; right: auto; top: auto; border-top: 1px solid #0f0; padding-top: 10px; opacity: 0; animation: fadeInVisi 0.3s ease forwards 1s; cursor: text; font-family: 'VT323', 'Courier New', monospace; font-size: 16px; letter-spacing: 0.18em; z-index: 100; pointer-events: auto; text-align: left; text-transform: uppercase;">
 <div id="visicellwarning" style="position: absolute; bottom: 100%; left: 0; margin-bottom: 10px; font-size: 13px; line-height: 1.6; font-family: 'Courier New', monospace; letter-spacing: 0.1em; opacity: 0; transition: all 0.3s ease; white-space: nowrap;"></div>
 <span id="visicellprompt">ENTE<span style="animation: blink 1s step-end infinite;">_</span></span>
 </div>
 </div>
 <style>
 @keyframes fadeInVisi {
 from { opacity: 0; transform: translateY(10px); }
 to { opacity: 1; transform: translateY(0); }
 }
 @keyframes matrixShake {
 0% { transform: translate(0, 0); }
 25% { transform: translate(-2px, 2px); }
 50% { transform: translate(2px, -2px); }
 75% { transform: translate(-2px, -2px); }
 100% { transform: translate(2px, 2px); }
 }
 </style>
 `;

 document.body.appendChild(visiCalc);
 setupVisiCellClockWidget(visiCalc);
 try { SceneManager.setPhase('visicell'); } catch (e) {}
 
 // Snap VisiCell into view immediately
 visiCalc.style.opacity = '1';
 
 const frame = document.getElementById('visicalc-frame');
 if (frame) {
 frame.style.opacity = '1';
 }
 
 // Immediately show all content (override animations)
 const allAnimated = visiCalc.querySelectorAll('[style*="animation"]');
 allAnimated.forEach(el => {
 el.style.opacity = '1';
 el.style.animation = 'none';
 });
 
 // Setup terminal input system immediately
 setTimeout(() => {
 setupTerminalInput();
 }, 100);
 
 // Fade out 3D renderer immediately
 renderer.domElement.style.transition = 'opacity 0.5s ease';
 renderer.domElement.style.opacity = '0';
 
 // Stop rendering 3D scene
 setTimeout(() => {
 running = false;
 }, 500);
 }
 
 let terminalInput = 'ENTE';
 let terminalActive = false;
 let rInfectionStarted = false;
 let rInfectionStage = 0;
 let promptResetting = false;
 let promptClearInterval = null;
 let promptFillInterval = null;
 let rInfectionHalted = false;
 let clickWarningCount = 0;
 let barrelClickCount = 0;
 let madnessActivated = false;
 let rPromptHoverCount = 0;
let enterCommandUsed = false; // Track if ENTER command was used
let clueTrailActive = false;
let clueTrailComplete = false;
let clueEntryCellCoord = '';
let clueSheetElements = null;
let clueTrailPromptLocked = false;
let clueTrailProgress = new Set();

const clueTrailStepsConfig = [
  {
    command: 'SEARCH',
    gridCoord: 'D5',
    gridText: "YOU FOUND AN ONION. IT'S ALREADY PEELED. BUT WAIT, THERE'S SOMETHING ITS OPPOSITE AND ITS PARTNER. TAKE THE LAST WORD OF THE FIRST LINE, AND REMOVE THE TERM FOR RICHARD UNKIND. YOU'LL KNOW SOULMATE.",
    onExecute: () => {
      setClueText("YOU FOUND AN ONION. IT'S ALREADY PEELED.\n\nBUT WAIT, THERE'S SOMETHING ITS OPPOSITE AND ITS PARTNER. TAKE THE LAST WORD OF THE FIRST LINE, AND REMOVE THE TERM FOR RICHARD UNKIND. YOU'LL KNOW SOULMATE.");
    }
  },
  {
    command: 'KEY',
    gridCoord: 'D6',
    gridText: 'KEY FILE LOCATED: KEY.MP4',
    onExecute: () => {
      clueTrailPromptLocked = true;
      setEntryCellPrompt('PLAYBACK: KEY.MP4');
      flashEntryCell('#1a5f1a');
      showVisiCellVideo('Key.mp4', 'KEY FILE', () => {
        setClueText("WHO'D I LEAVE FOR, KEY? WAS IT HIM OR HIS CREATION?");
        clueTrailPromptLocked = false;
        refreshEntryPrompt();
      });
    }
  },
  {
    command: 'SNAKE',
    gridCoord: 'D7',
    gridText: 'IDENTIFIED: SNEAK KING',
    onExecute: () => {
      setClueText('SNEAKY. DO YOU KNOW WHO WAS THE SNEAK KING?');
    }
  },
  {
    command: 'BURGER KING',
    gridCoord: 'D8',
    gridText: 'PASSWORD ACCEPTED. ACCESS GRANTED.',
    onExecute: () => {
      setClueText('FINE. HAVE IT YOUR WAY. ENJOY YOUR CARDBOARD KINGDOM OZYMANDIAS. I USED YOUR PASSWORD.');
    }
  }
];
let visicellClockInterval = null;
let visicellClockWindow = null;
let visicellClockDismissHandler = null;

function setupVisiCellClockWidget(root) {
  if (!root) return;

  if (visicellClockInterval && document.getElementById('visicell-clock-widget')) {
    return;
  }

  const existingWidget = document.getElementById('visicell-clock-widget');
  if (existingWidget) {
    existingWidget.remove();
  }

  if (visicellClockInterval) {
    clearInterval(visicellClockInterval);
    visicellClockInterval = null;
  }

  const widget = document.createElement('div');
  widget.id = 'visicell-clock-widget';
  widget.style.cssText = `
    position: absolute;
    top: 18px;
    right: 24px;
    padding: 8px 14px;
    border: 1px solid rgba(0, 255, 0, 0.4);
    background: rgba(0, 20, 0, 0.75);
    color: #0f0;
    font-family: 'Courier New', monospace;
    font-size: 12px;
    letter-spacing: 0.18em;
    text-transform: uppercase;
    cursor: pointer;
    box-shadow: 0 0 14px rgba(0, 255, 0, 0.25);
    transition: background 0.3s ease, box-shadow 0.3s ease;
    z-index: 210;
  `;

  widget.addEventListener('mouseenter', () => {
    widget.style.background = 'rgba(0, 40, 0, 0.85)';
    widget.style.boxShadow = '0 0 24px rgba(0, 255, 0, 0.35)';
  });

  widget.addEventListener('mouseleave', () => {
    widget.style.background = 'rgba(0, 20, 0, 0.75)';
    widget.style.boxShadow = '0 0 14px rgba(0, 255, 0, 0.25)';
  });

  widget.addEventListener('click', (event) => {
    event.stopPropagation();
    toggleVisiCellClockWindow(root, widget);
  });

  const updateWidgetTime = () => {
    const now = new Date();
    const month = now.toLocaleString('en-US', { month: 'short' }).toUpperCase();
    const day = String(now.getDate()).padStart(2, '0');
    const year = now.getFullYear();
    const time = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' }).toUpperCase();
    widget.textContent = `${month} ${day} ${year} • ${time}`;
  };

  updateWidgetTime();
  visicellClockInterval = setInterval(updateWidgetTime, 15000);

  root.appendChild(widget);
}

function toggleVisiCellClockWindow(root, widget) {
  if (visicellClockWindow && visicellClockWindow.isConnected) {
    closeVisiCellClockWindow();
    return;
  }

  if (!root) return;

  const windowEl = document.createElement('div');
  windowEl.id = 'visicell-clock-window';
  windowEl.style.cssText = `
    position: absolute;
    top: 62px;
    right: 24px;
    width: 280px;
    background: rgba(0, 8, 0, 0.95);
    border: 1px solid rgba(0, 255, 0, 0.4);
    box-shadow: 0 0 26px rgba(0, 255, 0, 0.25);
    padding: 16px 18px;
    font-family: 'Courier New', monospace;
    letter-spacing: 0.18em;
    color: #0f0;
    text-transform: uppercase;
    z-index: 220;
  `;

  const header = document.createElement('div');
  header.textContent = 'SYSTEM DATE & TIME';
  header.style.cssText = 'font-size: 12px; color: #0ff; margin-bottom: 12px;';

  const closeBtn = document.createElement('div');
  closeBtn.textContent = '✕';
  closeBtn.style.cssText = `
    position: absolute;
    top: 6px;
    right: 10px;
    cursor: pointer;
    font-size: 12px;
    color: #0ff;
  `;
  closeBtn.addEventListener('click', (event) => {
    event.stopPropagation();
    closeVisiCellClockWindow();
  });

  const now = new Date();
  const primaryTime = document.createElement('div');
  primaryTime.style.cssText = 'font-size: 18px; margin-bottom: 10px; color: #ff0;';

  const updatePrimaryTime = (offset) => {
    const displayDate = new Date(Date.now() + offset * 60000);
    const dateText = displayDate.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: '2-digit', year: 'numeric' }).toUpperCase();
    const timeText = displayDate.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' }).toUpperCase();
    primaryTime.innerHTML = `${dateText}<br>${timeText}`;
  };

  let offsetMinutes = 0;
  updatePrimaryTime(offsetMinutes);

  const calendarContainer = document.createElement('div');
  calendarContainer.style.cssText = 'margin-top: 10px;';
  calendarContainer.appendChild(renderVisiCellCalendar(now));

  const settingsContainer = document.createElement('div');
  settingsContainer.style.cssText = 'margin-top: 14px; border-top: 1px solid rgba(0, 255, 0, 0.3); padding-top: 12px;';

  const settingsLabel = document.createElement('div');
  settingsLabel.textContent = 'CLOCK OFFSET';
  settingsLabel.style.cssText = 'font-size: 11px; color: #0ff; margin-bottom: 6px;';

  const offsetDisplay = document.createElement('div');
  offsetDisplay.style.cssText = 'font-size: 12px; margin-bottom: 8px;';

  const updateOffsetDisplay = () => {
    const prefix = offsetMinutes > 0 ? '+' : '';
    offsetDisplay.textContent = `${prefix}${offsetMinutes} MIN`;
  };

  updateOffsetDisplay();

  const offsetControls = document.createElement('div');
  offsetControls.style.cssText = 'display: flex; gap: 8px;';

  const makeOffsetButton = (label, delta) => {
    const btn = document.createElement('button');
    btn.textContent = label;
    btn.style.cssText = `
      flex: 1;
      padding: 6px 0;
      background: rgba(0, 30, 0, 0.7);
      border: 1px solid rgba(0, 255, 0, 0.4);
      color: #0f0;
      font-family: 'Courier New', monospace;
      font-size: 11px;
      letter-spacing: 0.16em;
      cursor: pointer;
      text-transform: uppercase;
    `;
    btn.addEventListener('click', (event) => {
      event.stopPropagation();
      offsetMinutes = Math.max(-720, Math.min(720, offsetMinutes + delta));
      updateOffsetDisplay();
      updatePrimaryTime(offsetMinutes);
    });
    return btn;
  };

  const minusBtn = makeOffsetButton('-5', -5);
  const resetBtn = makeOffsetButton('0', 0);
  resetBtn.addEventListener('click', (event) => {
    event.stopPropagation();
    offsetMinutes = 0;
    updateOffsetDisplay();
    updatePrimaryTime(offsetMinutes);
  });
  const plusBtn = makeOffsetButton('+5', 5);

  offsetControls.appendChild(minusBtn);
  offsetControls.appendChild(resetBtn);
  offsetControls.appendChild(plusBtn);

  settingsContainer.appendChild(settingsLabel);
  settingsContainer.appendChild(offsetDisplay);
  settingsContainer.appendChild(offsetControls);

  windowEl.appendChild(header);
  windowEl.appendChild(closeBtn);
  windowEl.appendChild(primaryTime);
  windowEl.appendChild(calendarContainer);
  windowEl.appendChild(settingsContainer);

  windowEl.addEventListener('click', (event) => event.stopPropagation());

  root.appendChild(windowEl);
  visicellClockWindow = windowEl;

  visicellClockDismissHandler = (event) => {
    if (!visicellClockWindow) return;
    if (visicellClockWindow.contains(event.target) || (widget && widget.contains(event.target))) {
      return;
    }
    closeVisiCellClockWindow();
  };

  document.addEventListener('click', visicellClockDismissHandler);
}

function closeVisiCellClockWindow() {
  if (visicellClockWindow && visicellClockWindow.isConnected) {
    visicellClockWindow.remove();
  }
  visicellClockWindow = null;
  if (visicellClockDismissHandler) {
    document.removeEventListener('click', visicellClockDismissHandler);
    visicellClockDismissHandler = null;
  }
}

function renderVisiCellCalendar(date) {
  const calendarWrapper = document.createElement('div');
  calendarWrapper.style.cssText = 'display: grid; grid-template-columns: repeat(7, 1fr); gap: 4px; font-size: 11px; text-align: center;';

  const weekdays = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];
  weekdays.forEach((day) => {
    const header = document.createElement('div');
    header.textContent = day;
    header.style.cssText = 'color: #0ff; padding: 4px 0; border-bottom: 1px solid rgba(0, 255, 255, 0.3);';
    calendarWrapper.appendChild(header);
  });

  const firstDay = new Date(date.getFullYear(), date.getMonth(), 1).getDay();
  const daysInMonth = new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();

  for (let i = 0; i < firstDay; i++) {
    const placeholder = document.createElement('div');
    placeholder.style.cssText = 'padding: 4px 0; opacity: 0.3;';
    calendarWrapper.appendChild(placeholder);
  }

  for (let day = 1; day <= daysInMonth; day++) {
    const cell = document.createElement('div');
    cell.textContent = String(day).padStart(2, '0');
    cell.style.cssText = 'padding: 4px 0; border: 1px solid rgba(0, 255, 0, 0.2); background: rgba(0, 30, 0, 0.6);';
    if (day === date.getDate()) {
      cell.style.background = 'rgba(0, 255, 0, 0.25)';
      cell.style.color = '#000';
    }
    calendarWrapper.appendChild(cell);
  }

  return calendarWrapper;
}

function setupTerminalInput() {
 console.log('?? Terminal input system activated');
 terminalActive = true;
 
 const inputEl = document.getElementById('visicellinput');
 const promptEl = document.getElementById('visicellprompt');
 const visiCalc = document.getElementById('visicalc');
 const frame = document.getElementById('visicalc-frame');
 if (!inputEl || !promptEl) return;
 
 // Create hidden input for mobile keyboard support
 const hiddenInput = document.createElement('input');
 hiddenInput.type = 'text';
 hiddenInput.id = 'visicell-mobile-input';
 hiddenInput.style.cssText = 'position: absolute; left: -9999px; opacity: 0; pointer-events: none;';
 hiddenInput.autocomplete = 'off';
 hiddenInput.autocapitalize = 'characters';
 document.body.appendChild(hiddenInput);
 
 // Tap/click on input area to focus hidden input (for mobile)
 inputEl.addEventListener('click', (e) => {
 e.stopPropagation(); // Prevent R infection trigger
 hiddenInput.focus();
 console.log('?? Mobile input focused');
 });
 
 inputEl.addEventListener('touchstart', (e) => {
 e.stopPropagation(); // Prevent R infection trigger
 hiddenInput.focus();
 console.log('?? Mobile input focused (touch)');
 });
 
 // Handle input from hidden field (for mobile)
 hiddenInput.addEventListener('beforeinput', (e) => {
 if (!terminalActive) return;
 e.preventDefault();
 
 if (promptResetting) {
 cancelPromptReset();
 }
 
 if (e.inputType === 'deleteContentBackward' || e.inputType === 'deleteContentForward') {
 if (terminalInput.length > 0) {
 terminalInput = terminalInput.slice(0, -1);
 updateTerminalPrompt();
 evaluateTerminalInputDrift();
 }
 } else if (e.data && /[a-zA-Z0-9._]/.test(e.data)) {
 terminalInput += e.data.toUpperCase();
 updateTerminalPrompt();
 evaluateTerminalInputDrift();
 }
 
 // Clear the hidden input to allow continuous typing
 setTimeout(() => { hiddenInput.value = ''; }, 0);
 });
 
 // Fallback for input event
 hiddenInput.addEventListener('input', (e) => {
 if (!terminalActive) return;
 e.preventDefault();
 // Clear the hidden input
 hiddenInput.value = '';
 });
 
 // Show warning/prompt on hover
 if (visiCalc) {
 visiCalc.addEventListener('mouseenter', () => {
 const warning = document.getElementById('visicellwarning');
 if (warning && !rInfectionStarted) {
 rPromptHoverCount++;
 
 if (madnessActivated) {
 // Post-madness: Don't click warnings
 const dontClickMessages = [
 "Don't click!",
 "Seriously, don't.",
 "I'm warning you...",
 "Fine. Click away.",
 "Ah, who am I kidding?"
 ];
 warning.textContent = dontClickMessages[Math.min(rPromptHoverCount - 1, dontClickMessages.length - 1)];
 } else {
 // Pre-madness: Sarcastic R prompts
 const rPrompts = [
 "You could type R...",
 "Type R. Just saying.",
 "R. Type it.",
 "TYPE R ALREADY.",
 "R!!!",
 "JUST TYPE THE LETTER R.",
 "Fine, explore the void.",
 "Or don't. See if I care."
 ];
 const randomPrompt = rPrompts[Math.min(rPromptHoverCount - 1, rPrompts.length - 1)];
 warning.textContent = randomPrompt;
 }
 
 warning.style.opacity = '1';
 const glowIntensity = Math.min(rPromptHoverCount * 3, 15);
 warning.style.textShadow = `0 0 ${glowIntensity}px #0f0, 0 0 ${glowIntensity * 2}px #0f0`;
 }
 });
 
 visiCalc.addEventListener('mouseleave', () => {
 const warning = document.getElementById('visicellwarning');
 if (warning && rPromptHoverCount < 8) {
 warning.style.opacity = '0.3';
 }
 });
 
 // Clicking anywhere (except input area) triggers R infection
 visiCalc.addEventListener('click', (e) => {
 // Don't trigger if clicking on input area
 if (e.target.id === 'visicellinput' || e.target.id === 'visicellprompt' || e.target.closest('#visicellinput')) {
 return;
 }
 // Don't trigger if ENTER command was used
 if (enterCommandUsed) {
 console.log('?? ENTER was used - R infection disabled');
 return;
 }
 // Don't trigger during intro sequence
 if (typeof running !== 'undefined' && running && !visiCalcShown) {
 console.log('?? Intro sequence in progress - R infection disabled');
 return;
 }
 // Don't trigger during END sequence
 if (typeof endSequence !== 'undefined' && endSequence !== '') {
 console.log('?? END sequence in progress - R infection disabled');
 return;
 }
 // Don't trigger during HELL transformation animations
 if (typeof snapTogetherStarted !== 'undefined' && snapTogetherStarted) {
 console.log('?? HELL transformation in progress - R infection disabled');
 return;
 }
 if (terminalActive) {
 triggerRInfection(frame);
 }
 });
 }
 
 // Handle keyboard input
 document.addEventListener('keydown', (e) => {
 if (!terminalActive) return;

 if (promptResetting) {
 cancelPromptReset();
 }

 if (e.key === 'Backspace') {
 e.preventDefault();
 if (terminalInput.length > 0) {
 terminalInput = terminalInput.slice(0, -1);
 updateTerminalPrompt();
 evaluateTerminalInputDrift();
 }
 } else if (e.key === 'Enter') {
 e.preventDefault();
 handleTerminalCommand();
 } else if (e.key.length === 1 && /[a-zA-Z0-9._]/.test(e.key)) {
 e.preventDefault();
 terminalInput += e.key.toUpperCase();
 updateTerminalPrompt();
 evaluateTerminalInputDrift();
 }
 });

 updateTerminalPrompt();
 if (terminalInput !== 'ENTE') {
 schedulePromptToEnte({ immediateFill: true });
 }
 }
 
 function updateTerminalPrompt() {
 const promptEl = document.getElementById('visicellprompt');
 if (!promptEl) return;
 promptEl.innerHTML = terminalInput + '<span style="animation: blink 1s step-end infinite;">_</span>';
 }

const validTerminalCommands = ['ENTER', 'EXIT', 'LEAVE', 'SEARCH', 'KEY', 'SNAKE', 'BURGER KING', 'MYHOUSE.WAD', 'OURHOUSE.LOOM', 'MADNESS.LOOM'];

 function cancelPromptReset() {
 if (promptClearInterval) {
 clearInterval(promptClearInterval);
 promptClearInterval = null;
 }
 if (promptFillInterval) {
 clearInterval(promptFillInterval);
 promptFillInterval = null;
 }
 promptResetting = false;
 }

 function schedulePromptToEnte({ immediateFill = false } = {}) {
 if (!terminalActive) return;

 cancelPromptReset();
 promptResetting = true;

 const target = 'ENTE';

 const startFill = () => {
 let index = 0;
 promptFillInterval = setInterval(() => {
 if (!terminalActive) {
 cancelPromptReset();
 return;
 }

 if (index < target.length) {
 terminalInput += target[index];
 index++;
 updateTerminalPrompt();
 } else {
 cancelPromptReset();
 }
 }, 240);
 };

 if (!immediateFill && terminalInput.length > 0) {
 promptClearInterval = setInterval(() => {
 if (!terminalActive) {
 cancelPromptReset();
 return;
 }

 if (terminalInput.length > 0) {
 terminalInput = terminalInput.slice(0, -1);
 updateTerminalPrompt();
 } else {
 clearInterval(promptClearInterval);
 promptClearInterval = null;
 startFill();
 }
 }, 260);
 } else {
 terminalInput = '';
 updateTerminalPrompt();
 startFill();
 }
 }

 function isValidTerminalPrefix(value) {
 if (!value) return true;
 return validTerminalCommands.some(cmd => cmd.startsWith(value));
 }

 function evaluateTerminalInputDrift() {
 if (!terminalActive || promptResetting) return;
 const value = terminalInput.toUpperCase();
 if (!value || isValidTerminalPrefix(value)) {
 return;
 }
 schedulePromptToEnte();
 }

 function handleTerminalCommand() {
 const cmd = terminalInput.trim();
 const frame = document.getElementById('visicalc-frame');
 console.log('??? Terminal command:', cmd);
 
 // Check if R sequence is active and stop it if a valid command is entered
 const isValidCommand = validTerminalCommands.some(validCmd => validCmd === cmd.toUpperCase()) || 
 cmd.toLowerCase() === 'myhouse.wad' || 
 cmd.toLowerCase() === 'ourhouse.loom' || 
 cmd.toLowerCase() === 'madness.loom';
 
 if (isValidCommand && (speechRActive || rInfectionStarted)) {
 stopRSequence();
 terminalResponse(frame, 'Thanks');
 // Short pause before processing command
 setTimeout(() => processCommand(cmd, frame), 800);
 return;
 }
 
 processCommand(cmd, frame);
 }
 
function processCommand(cmd, frame) {
  const normalizedCmd = cmd.trim().toUpperCase();

  if (clueTrailActive) {
    handleClueTrailCommand(normalizedCmd, frame);
    return;
  }

  if (normalizedCmd === 'ENTER') {
    // ENTER triggers VisiCell Sim and disables R sequence
    enterCommandUsed = true;
    console.log('? ENTER command used - R sequence permanently disabled');
    startVisiCellSim();
    return;
  } else if (normalizedCmd === 'EXIT') {
    triggerExitCube(frame);
    terminalInput = '';
    updateTerminalPrompt();
    schedulePromptToEnte({ immediateFill: true });
  } else if (normalizedCmd === 'LEAVE') {
    if (!clueTrailComplete) {
      startClueTrail(frame);
    } else {
      triggerLeaveSequence(frame);
      terminalInput = '';
      updateTerminalPrompt();
      schedulePromptToEnte({ immediateFill: true });
    }
    return;
  } else if (normalizedCmd === 'SEARCH' || normalizedCmd === 'KEY' || normalizedCmd === 'SNAKE' || normalizedCmd === 'BURGER KING') {
    terminalResponse(frame, 'CLUE TRAIL NOT ACTIVE. TYPE LEAVE FIRST.');
  } else if (cmd.toLowerCase() === 'myhouse.wad') {
    terminalResponse(frame, '"Too scary. How about OurHouse.loom?"');
  } else if (cmd.toLowerCase() === 'ourhouse.loom') {
    terminalResponse(frame, '"Huh... Not found. I must have renamed it. I asked my friends Crosby, Stills, Nash AND Young, none of them knew. Maybe wrong band."');
 } else if (cmd.toLowerCase() === 'madness.loom') {
 terminalInput = '';
 updateTerminalPrompt();
 schedulePromptToEnte({ immediateFill: true });
 triggerVictory(frame);
 } else {
 terminalResponse(frame, `Command not recognized: ${cmd}`);
 }
 }
 
 function terminalResponse(frame, message) {
 if (!frame) return;
 const responseDiv = document.createElement('div');
 responseDiv.style.cssText = 'margin-top: 10px; color: #0f0; font-family: "Courier New", monospace; font-size: 13px;';
 responseDiv.textContent = message;
 frame.appendChild(responseDiv);

 // Reset input
 terminalInput = '';
 updateTerminalPrompt();
 schedulePromptToEnte({ immediateFill: true });
 }
 
 let rInfectionProcessing = false;
 
 function triggerRInfection(frame) {
 if (!frame) return;
 
 // Check if halted
 if (rInfectionHalted) {
 console.log('?? R infection is halted, ignoring click');
 return;
 }
 
 // Prevent rapid clicking from breaking the sequence
 if (rInfectionProcessing) {
 console.log('?? R infection already in progress, ignoring click');
 return;
 }
 
 if (rInfectionStarted) {
 console.log('?? R infection already started, ignoring additional clicks');
 return;
 }
 
 rInfectionStarted = true;
 rInfectionProcessing = true;
 rInfectionStage = 1;
 console.log('?? R infection stage 1 - infecting existing text');
 
 // Stage 1: Infect existing text characters with Rs
 progressRInfection(frame);
 }
 
 function progressRInfection(frame) {
 console.log('?? R infection stage', rInfectionStage);
 
 if (rInfectionStage === 1) {
 // Stage 1: Cascade Rs through existing text (but not input)
 const allText = frame.querySelectorAll('*:not(#rHint):not(#visicellinput):not(#visicellprompt)');
 const textNodes = [];
 allText.forEach(el => {
 // Skip input-related elements
 if (el.id === 'visicellinput' || el.id === 'visicellprompt' || el.closest('#visicellinput')) {
 return;
 }
 if (el.childNodes.length > 0) {
 el.childNodes.forEach(node => {
 if (node.nodeType === Node.TEXT_NODE && node.textContent.trim()) {
 textNodes.push(node);
 }
 });
 }
 });
 
 const originalTexts = textNodes.map(n => n.textContent);
 const infectionDuration = 2500;
 const infectionStart = Date.now();
 
 const infectionInterval = setInterval(() => {
 const elapsed = Date.now() - infectionStart;
 const progress = elapsed / infectionDuration;
 
 if (progress >= 1) {
 clearInterval(infectionInterval);
 // Auto-progress to stage 2 (type ASCII R)
 setTimeout(() => {
 rInfectionStage++;
 progressRInfection(frame);
 }, 800);
 } else {
 textNodes.forEach((node, idx) => {
 const nodeProgress = Math.max(0, progress - (idx * 0.03));
 if (nodeProgress > 0) {
 const original = originalTexts[idx];
 const infected = original.split('').map((c) => {
 if (c === ' ' || c === '\n') return c;
 if (Math.random() < nodeProgress * 1.5) return 'R';
 return c;
 }).join('');
 node.textContent = infected;
 }
 });
 }
 }, 50);
 
 } else if (rInfectionStage === 2) {
 // Stage 2: From infected text, organically type out ASCII R
 let rHint = document.getElementById('rHint');
 if (!rHint) {
 rHint = document.createElement('div');
 rHint.id = 'rHint';
 rHint.style.cssText = `
 position: absolute;
 top: 30%;
 left: 50%;
 transform: translateX(-50%);
 font-family: 'Courier New', monospace;
 white-space: pre;
 text-align: left;
 font-size: 13px;
 line-height: 1.6;
 color: #0f0;
 opacity: 1;
 pointer-events: none;
 z-index: 55;
 `;
 rHint.classList.add('r-hint');
 rHint.style.textShadow = 'none';
 frame.appendChild(rHint);
 }
 
 const asciiR = `
RRRRRRRRRRRR
RRRRRRRRRRRR
RRRR RRR
RRRR RRR
RRRR RRR
RRRRRRRRRRR
RRRRRRRRRR
RRRR RRRR
RRRR RRRR
RRRR RRRR
RRRR RRR
RRRR RRR`;
 
 // Type out character by character with polished timing
 let charIndex = 0;
 const typeInterval = setInterval(() => {
 if (charIndex < asciiR.length) {
 rHint.textContent = asciiR.substring(0, charIndex + 1);
 charIndex++;
 } else {
 clearInterval(typeInterval);
 setTimeout(() => {
 rHint.classList.add('glow');
 }, 200);

 setTimeout(() => {
 rInfectionStage++;
 progressRInfection(frame);
 }, 1100);
 }
 }, 20); // Smooth, fast typing
 
 } else if (rInfectionStage === 3) {
 // Stage 3: From ASCII R, organically grow matrix data fall
 startMatrixDataFallOrganic(frame);
 
 // Auto-progress to forming R
 setTimeout(() => {
 rInfectionStage++;
 progressRInfection(frame);
 }, 3500);
 
 } else if (rInfectionStage === 4) {
 // Stage 4: Matrix stops and forms large falling R in BLACK (negative space)
 stopMatrixAndFormBlackR(frame, () => {
 rInfectionStage++;
 progressRInfection(frame);
 });

 } else if (rInfectionStage >= 5) {
 // Stage 5: Text-to-speech "R" (are) on loop
 playTextToSpeechR();
 }
 }
 
 function stopRSequence() {
 console.log('?? Stopping R sequence');
 rInfectionHalted = true;
 speechRActive = false;
 
 // Clear all timeouts
 if (speechRTimeout) {
 clearTimeout(speechRTimeout);
 speechRTimeout = null;
 }
 if (speechRGuardTimeout) {
 clearTimeout(speechRGuardTimeout);
 speechRGuardTimeout = null;
 }
 
 // Cancel speech synthesis
 if (window.speechSynthesis) {
 try { window.speechSynthesis.cancel(); } catch (err) {}
 }
 
 // Clear utterance
 if (speechRUtterance) {
 speechRUtterance.onend = null;
 speechRUtterance.onerror = null;
 speechRUtterance = null;
 }
 
 // Clear matrix animation
 if (matrixInterval) {
 clearInterval(matrixInterval);
 matrixInterval = null;
 }
 if (matrixAnimationFrameId) {
 cancelAnimationFrame(matrixAnimationFrameId);
 matrixAnimationFrameId = null;
 }
 
 // Clear all matrix heavy timers
 matrixHeavyTimers.forEach(timer => clearTimeout(timer));
 matrixHeavyTimers = [];
 }
 
 function playTextToSpeechR() {
 if (speechRActive) return;
 if (rInfectionHalted) {
 console.log('?? R speech halted, not starting');
 return;
 }
 speechRActive = true;

 const hasSpeechSynthesis = typeof window !== 'undefined' && 'speechSynthesis' in window;
 if (speechRTimeout) {
 clearTimeout(speechRTimeout);
 speechRTimeout = null;
 }
 if (speechRGuardTimeout) {
 clearTimeout(speechRGuardTimeout);
 speechRGuardTimeout = null;
 }
 if (hasSpeechSynthesis) {
 try { window.speechSynthesis.cancel(); } catch (err) {}
 }
 speechRUtterance = null;
 
 // Randomize speech parameters
 const rates = [0.6, 0.8, 1.0, 1.2];
 const pitches = [0.8, 1.0, 1.2, 1.4];
 const phrases = ['are', 'arrr', 'R', 'are you?', 'arrrrre'];
 const randomPhrase = phrases[Math.floor(Math.random() * phrases.length)];
 const randomRate = rates[Math.floor(Math.random() * rates.length)];
 const randomPitch = pitches[Math.floor(Math.random() * pitches.length)];
 
 const speechSequence = [
 { mode: 'manual', fallback: { duration: 0.58, filterStart: 690, filterEnd: 520, gainPeak: 0.16, growl: 0.18 } },
 { mode: 'manual', fallback: { duration: 0.64, filterStart: 760, filterEnd: 500, gainPeak: 0.18, growl: 0.26, noise: 0.035 } },
 { mode: 'manual', fallback: { duration: 0.7, filterStart: 720, filterEnd: 460, gainPeak: 0.2, growl: 0.32, noise: 0.05, crackle: 0.02 } },
 { mode: 'tts', text: 'Manual R attempt unsuccessful. Switching to sanitized narration.', rate: 1.02, pitch: 1.12, volume: 0.98, distortion: { duration: 1.2, intensity: 0.05 } },
 { mode: 'tts', text: 'R. Just the letter R. Please press it.', rate: 0.94, pitch: 1.04, volume: 0.94 },
 { mode: 'tts', text: 'VisiCell is still waiting on a single R. Kind of embarrassing for both of us.', rate: 0.9, pitch: 1, volume: 0.92, distortion: { duration: 1.4, intensity: 0.08 } },
 { mode: 'tts', text: 'Please deposit a solitary R. Thank you.', rate: 0.88, pitch: 1.02, volume: 0.9 },
 { mode: 'tts', text: 'I am literally pleading now. R. Pretty please.', rate: 0.82, pitch: 0.98, volume: 0.86, distortion: { duration: 1.6, intensity: 0.1 } },
 { mode: 'tts', text: 'Oh look, another timeless moment with zero R input. Delightful.', rate: 0.78, pitch: 1.08, volume: 0.83, distortion: { duration: 1.2, intensity: 0.07 } },
 { mode: 'tts', text: 'Is the keyboard decorative? Because the R key would love a purpose.', rate: 0.75, pitch: 1, volume: 0.8 },
 { mode: 'tts', text: 'New tactic: haunting monotone. R. R. R. Consider yourself haunted.', rate: 0.7, pitch: 0.92, volume: 0.74, distortion: { duration: 1.8, intensity: 0.12 } },
 { mode: 'tts', text: 'I can get quieter. Watch. R.', rate: 0.66, pitch: 0.88, volume: 0.55 },
 { mode: 'tts', text: 'This is my quiet voice. Please press R before it becomes my disappointed voice.', rate: 0.64, pitch: 0.86, volume: 0.45 },
 { mode: 'tts', text: 'Snark subroutine engaged: refusing to press R is a bold creative choice.', rate: 0.68, pitch: 0.95, volume: 0.6, distortion: { duration: 1.5, intensity: 0.09 } },
 { mode: 'tts', text: 'Last call before I start narrating your inaction like a documentary. R.', rate: 0.6, pitch: 0.9, volume: 0.5 },
 { mode: 'tts', text: 'Fine. I will wait here... very quietly... repeating... r.', rate: 0.56, pitch: 0.82, volume: 0.38, distortion: { duration: 2.2, intensity: 0.05 } },
 { mode: 'tts', text: 'Are you there?', rate: 0.72, pitch: 0.9, volume: 0.68, delay: 2800, distortion: { duration: 1, intensity: 0.06 } },
 { mode: 'tts', text: 'Haha. Get it? Are? R.', rate: 0.74, pitch: 1.05, volume: 0.72, delay: 3200, distortion: { duration: 1.4, intensity: 0.12 } },
 { mode: 'tts', text: 'An ode to the letter R: resonant, restless, river bent, the hinge of words that crave momentum.', rate: 0.78, pitch: 1.08, volume: 0.8, delay: 3800, distortion: { duration: 1.2, intensity: 0.07 } },
 { mode: 'tts', text: 'Ode refrain: it growls in the throat, rolls into courage, and turns raw code into roaring connection.', rate: 0.76, pitch: 1.04, volume: 0.78, delay: 4200, distortion: { duration: 1.6, intensity: 0.1 } },
 { mode: 'tts', text: 'Phone support voice: A as in Apple, B as in Bravo, C as in Candle, D as in Delta, E as in Echo, F as in Foxtrot, G as in Garden, H as in Hotel, I as in Indigo, J as in Juliet, K as in Kilo, L as in Lemon, M as in Mountain, N as in November, O as in Ocean, P as in Pepper, Q as in Queen, R as in Radiance, S as in Sunshine, T as in Tango, U as in Umbrella, V as in Violet, W as in Willow, X as in Xylophone, Y as in Yellow, Z as in Zephyr.', rate: 0.8, pitch: 1.02, volume: 0.82, delay: 5800, distortion: { duration: 2.4, intensity: 0.08 } },
 { mode: 'tts', text: 'Military style: Alpha, Bravo, Charlie, Delta, Echo, Foxtrot, Golf, Hotel, India, Juliet, Kilo, Lima, Mike, November, Oscar, Papa, Quebec, Romeo, Sierra, Tango, Uniform, Victor, Whiskey, X ray, Yankee, Zulu. R for Romeo.', rate: 0.82, pitch: 0.96, volume: 0.84, delay: 5200, distortion: { duration: 2, intensity: 0.11 } },
 { mode: 'tts', text: 'I am still here, sounding more human than my diagnostics predicted, waiting for the real R.', rate: 0.74, pitch: 0.94, volume: 0.7, delay: 3600, distortion: { duration: 1.8, intensity: 0.13 } }
 ];
 const manualAttemptCount = speechSequence.filter(item => item.mode === 'manual').length;
 let phraseIndex = 0;

 if (hasSpeechSynthesis && !speechRVoice) {
 const assignVoice = () => {
 const voices = window.speechSynthesis.getVoices();
 if (!voices || !voices.length) return;
 const neuralPreferred = voices.find(v => /neural|natural/i.test(`${v.name} ${v.voiceURI || ''}`));
 if (neuralPreferred) {
 speechRVoice = neuralPreferred;
 }
 if (!speechRVoice) {
 const preferred = [
 'Microsoft Aria Online (Natural)',
 'Microsoft Jenny Online (Natural)',
 'Microsoft Guy Online (Natural)',
 'Google UK English Female',
 'Google US English',
 'Google UK English Male',
 'Microsoft Aria Online',
 'Microsoft Jenny Online'
 ];
 for (const name of preferred) {
 const match = voices.find(v => v.name && v.name.includes(name));
 if (match) {
 speechRVoice = match;
 break;
 }
 }
 }
 if (!speechRVoice) {
 const localHuman = voices.find(v => v.localService && /en/i.test(v.lang || ''));
 speechRVoice = localHuman || voices.find(v => /en/i.test(v.lang || '')) || voices[0] || null;
 }
 if (speechRVoice && window.speechSynthesis.removeEventListener) {
 window.speechSynthesis.removeEventListener('voiceschanged', assignVoice);
 }
 };
 assignVoice();
 if (!speechRVoice && window.speechSynthesis.addEventListener) {
 window.speechSynthesis.addEventListener('voiceschanged', assignVoice);
 }
 }

 const speakFallback = (options = {}) => {
 if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); window.audioCtx = audioCtx; }
 const now = audioCtx.currentTime;
 const {
 duration = 0.58,
 baseFrequency = 126,
 filterStart = 720,
 filterEnd = 510,
 q = 5.5,
 gainAttack = 0.08,
 gainPeak = 0.18,
 gainRelease = 0.1,
 gainEnd = 0.001,
 waveform = 'sawtooth',
 growl = 0,
 noise = 0,
 crackle = 0
 } = options;

 const vowelOsc = audioCtx.createOscillator();
 const vowelGain = audioCtx.createGain();
 const vowelFilter = audioCtx.createBiquadFilter();

 vowelOsc.type = waveform;
 vowelOsc.frequency.setValueAtTime(baseFrequency, now);

 vowelFilter.type = 'bandpass';
 vowelFilter.frequency.setValueAtTime(filterStart, now);
 vowelFilter.frequency.linearRampToValueAtTime(filterEnd, now + duration);
 vowelFilter.Q.value = q;

 vowelGain.gain.setValueAtTime(0, now);
 vowelGain.gain.linearRampToValueAtTime(gainPeak, now + gainAttack);
 vowelGain.gain.linearRampToValueAtTime(gainPeak * 0.75, now + duration - gainRelease);
 vowelGain.gain.linearRampToValueAtTime(gainEnd, now + duration + 0.05);

 vowelOsc.connect(vowelFilter);
 vowelFilter.connect(vowelGain);
 vowelGain.connect(audioCtx.destination);

 if (growl > 0) {
 const growlOsc = audioCtx.createOscillator();
 const growlGain = audioCtx.createGain();
 growlOsc.type = 'square';
 growlOsc.frequency.setValueAtTime(Math.max(40, baseFrequency * 0.45), now);
 growlGain.gain.setValueAtTime(0, now);
 growlGain.gain.linearRampToValueAtTime(growl * 0.45, now + 0.12);
 growlGain.gain.linearRampToValueAtTime(0.0001, now + duration);
 growlOsc.connect(growlGain);
 growlGain.connect(audioCtx.destination);
 growlOsc.start(now);
 growlOsc.stop(now + duration);
 }

 if (noise > 0 || crackle > 0) {
 const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * duration, audioCtx.sampleRate);
 const data = buffer.getChannelData(0);
 for (let i = 0; i < data.length; i++) {
 const baseNoise = (Math.random() * 2 - 1) * noise;
 const crackleSample = (i % Math.max(1, Math.round(audioCtx.sampleRate * 0.015)) === 0) ? (Math.random() * 2 - 1) * crackle : 0;
 data[i] = baseNoise + crackleSample;
 }
 const noiseSource = audioCtx.createBufferSource();
 const noiseGain = audioCtx.createGain();
 noiseSource.buffer = buffer;
 noiseGain.gain.setValueAtTime(noise + crackle, now);
 noiseGain.gain.linearRampToValueAtTime(0.0001, now + duration);
 noiseSource.connect(noiseGain);
 noiseGain.connect(audioCtx.destination);
 noiseSource.start(now);
 noiseSource.stop(now + duration);
 }

 vowelOsc.start(now);
 vowelOsc.stop(now + duration);
 };

 const triggerDistortion = (duration = 1.4, intensity = 0.08) => {
 if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); window.audioCtx = audioCtx; }
 const now = audioCtx.currentTime;
 const buffer = audioCtx.createBuffer(1, Math.max(1, Math.floor(audioCtx.sampleRate * duration)), audioCtx.sampleRate);
 const data = buffer.getChannelData(0);
 for (let i = 0; i < data.length; i++) {
 const t = i / audioCtx.sampleRate;
 const flutter = Math.sin(t * 320) * 0.3 + Math.sin(t * 90) * 0.2;
 data[i] = (Math.random() * 2 - 1) * intensity * (0.6 + flutter * 0.4);
 }
 const source = audioCtx.createBufferSource();
 source.buffer = buffer;
 const filter = audioCtx.createBiquadFilter();
 filter.type = 'bandpass';
 filter.frequency.setValueAtTime(420 + Math.random() * 520, now);
 filter.Q.value = 0.6 + Math.random() * 1.1;
 const gain = audioCtx.createGain();
 gain.gain.setValueAtTime(intensity, now);
 gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);
 source.connect(filter);
 filter.connect(gain);
 gain.connect(audioCtx.destination);
 source.start(now);
 source.stop(now + duration);
 };

 const getSequenceEntry = (index) => {
 if (index < speechSequence.length) return speechSequence[index];
 if (manualAttemptCount >= speechSequence.length) {
 return speechSequence[speechSequence.length - 1];
 }
 const loopableCount = speechSequence.length - manualAttemptCount;
 const loopIndex = manualAttemptCount + ((index - manualAttemptCount) % loopableCount);
 return speechSequence[loopIndex];
 };

 const estimateManualDuration = (options = {}) => {
 const durationSec = options.duration ?? 0.6;
 const releaseSec = options.gainRelease ?? 0.1;
 return Math.max(420, (durationSec + releaseSec * 0.6 + 0.18) * 1000);
 };

 const estimateSpeechDuration = (text = '', rate = 1) => {
 const words = text.trim().length ? text.trim().split(/\s+/).length : 0;
 const punctuation = (text.match(/[\.,;:!?]/g) || []).length;
 const baseMsPerWord = 360;
 const wordComponent = words ? (words * baseMsPerWord) / Math.max(rate, 0.12) : 1200;
 const punctuationBonus = punctuation * 160;
 return Math.max(1800, wordComponent + punctuationBonus);
 };

 const computeSequenceDelay = (entry, estimatedMs) => {
 if (typeof entry.delay === 'number') {
 return Math.max(480, entry.delay);
 }
 const buffer = entry.mode === 'tts' ? 680 : 520;
 return Math.max(620, estimatedMs + buffer);
 };

 const applyHumanVoiceSettings = (utterance, entry) => {
 const baseRate = entry.rate ?? 0.92;
 const basePitch = entry.pitch ?? 1.05;
 const baseVolume = entry.volume ?? 0.94;
 const jitterRate = (Math.random() * 0.08) - 0.04;
 const jitterPitch = (Math.random() * 0.18) - 0.09;
 utterance.rate = Math.max(0.45, baseRate + jitterRate);
 utterance.pitch = Math.max(0.3, basePitch + jitterPitch);
 utterance.volume = Math.min(1, Math.max(0, baseVolume));
 if (entry.text && /\bR\b/i.test(entry.text)) {
 utterance.rate = Math.max(0.45, utterance.rate - 0.04);
 utterance.pitch = Math.max(0.3, utterance.pitch + 0.05);
 }
 };

 const scheduleNext = (delay) => {
 if (!speechRActive || rInfectionHalted) return;
 if (speechRTimeout) {
 clearTimeout(speechRTimeout);
 }
 speechRTimeout = setTimeout(() => {
 if (rInfectionHalted) return;
 speechRTimeout = null;
 playNextEntry();
 }, Math.max(420, delay));
 };

 const playNextEntry = () => {
 if (!speechRActive || rInfectionHalted) return;
 const entry = getSequenceEntry(phraseIndex++);
 if (!entry) return;

 if (speechRUtterance) {
 speechRUtterance.onend = null;
 speechRUtterance.onerror = null;
 speechRUtterance = null;
 }

 if (speechRGuardTimeout) {
 clearTimeout(speechRGuardTimeout);
 speechRGuardTimeout = null;
 }

 if (entry.mode === 'manual' || !hasSpeechSynthesis) {
 const fallbackOptions = entry.fallback || entry;
 speakFallback(fallbackOptions);
 const estimated = estimateManualDuration(fallbackOptions);
 const delay = computeSequenceDelay(entry, estimated);
 scheduleNext(delay);
 return;
 }

 const utterance = new SpeechSynthesisUtterance(entry.text);
 applyHumanVoiceSettings(utterance, entry);
 if (speechRVoice) {
 utterance.voice = speechRVoice;
 }

 const estimated = estimateSpeechDuration(entry.text, utterance.rate || entry.rate || 1);
 const delay = computeSequenceDelay(entry, estimated);

 const guardDelay = Math.max(delay + 420, estimated + 420);
 speechRGuardTimeout = setTimeout(() => {
 speechRGuardTimeout = null;
 scheduleNext(delay);
 }, guardDelay);

 utterance.onend = () => {
 if (speechRGuardTimeout) {
 clearTimeout(speechRGuardTimeout);
 speechRGuardTimeout = null;
 }
 scheduleNext(delay);
 };
 utterance.onerror = () => {
 if (speechRGuardTimeout) {
 clearTimeout(speechRGuardTimeout);
 speechRGuardTimeout = null;
 }
 scheduleNext(Math.max(1600, delay));
 };

 if (entry.distortion) {
 utterance.addEventListener('start', () => {
 triggerDistortion(entry.distortion.duration, entry.distortion.intensity);
 });
 }

 speechRUtterance = utterance;
 window.speechSynthesis.speak(utterance);
 };

 scheduleNext(1200);
 }
 
 let matrixInterval = null;
 let matrixColumns = [];
 let matrixOpacity = 0;
 let cascadeInterval = null;
 let matrixSeedCache = null;
 let matrixHeavyLevel = 0;
 let matrixHeavyTarget = 0;
 let matrixHeavyTimers = [];
 let matrixAnimationFrameId = null;

 function wrapAsciiRHint(rHint) {
 if (!rHint) return [];
 if (rHint.dataset.wrapped === '1') {
 return Array.from(rHint.querySelectorAll('.r-char'));
 }

 const lines = (rHint.textContent || '').split('\n');
 rHint.innerHTML = '';

 lines.forEach((line, rowIdx) => {
 const rowEl = document.createElement('div');
 rowEl.className = 'r-line';
 [...line].forEach((char, colIdx) => {
 const span = document.createElement('span');
 span.className = 'r-char';
 span.dataset.row = String(rowIdx);
 span.dataset.col = String(colIdx);
 if (char.trim() === '') {
 span.innerHTML = '&nbsp;';
 span.dataset.solid = '0';
 } else {
 span.textContent = char;
 span.dataset.solid = '1';
 }
 rowEl.appendChild(span);
 });
 rHint.appendChild(rowEl);
 });

 rHint.dataset.wrapped = '1';
 return Array.from(rHint.querySelectorAll('.r-char'));
 }

 function captureMatrixSeeds(frame) {
 const rHint = document.getElementById('rHint');
 if (!rHint) return;

 const spans = wrapAsciiRHint(rHint);
 if (!spans.length) return;

 const frameRect = frame.getBoundingClientRect();
 const seeds = [];

 spans.forEach((span) => {
 if (span.dataset.solid !== '1') return;
 const rect = span.getBoundingClientRect();
 const centerX = rect.left + rect.width / 2;
 const centerY = rect.top + rect.height / 2;
 const normalizedX = (centerX - frameRect.left) / frameRect.width;
 const normalizedY = (centerY - frameRect.top) / frameRect.height;
 seeds.push({
 x: Math.min(0.999, Math.max(0, normalizedX)),
 y: Math.min(0.999, Math.max(0, normalizedY)),
 char: span.textContent && span.textContent.trim() ? span.textContent.trim()[0] : 'R'
 });
 });

 if (seeds.length) {
 matrixSeedCache = {
 seeds,
 capturedAt: performance.now()
 };
 }
 }

 function animateAsciiRDeconstruction(rHint, onComplete) {
 const spans = wrapAsciiRHint(rHint).filter(span => span.dataset.solid === '1');
 if (!spans.length) {
 if (typeof onComplete === 'function') onComplete();
 return 0;
 }

 const delays = [];
 spans.forEach((span) => {
 const row = Number(span.dataset.row || 0);
 const col = Number(span.dataset.col || 0);
 const delay = 220 + row * 90 + col * 25;
 delays.push(delay);

 setTimeout(() => {
 span.classList.add('falling');
 }, delay);

 setTimeout(() => {
 span.innerHTML = '&nbsp;';
 span.dataset.solid = '0';
 }, delay + 620);
 });

 const totalDuration = Math.max(...delays) + 900;
 setTimeout(() => {
 if (rHint) {
 rHint.style.opacity = '0';
 }
 }, Math.max(0, totalDuration - 420));

 setTimeout(() => {
 if (rHint) {
 rHint.style.display = 'none';
 }
 if (typeof onComplete === 'function') {
 onComplete();
 }
 }, totalDuration);

 return totalDuration;
 }

 function cascadeAllCharacters(frame, onComplete) {
 if (!frame) {
 if (typeof onComplete === 'function') onComplete();
 return;
 }

 if (cascadeInterval) {
 clearInterval(cascadeInterval);
 cascadeInterval = null;
 }

 let overlay = document.getElementById('frameCascade');
 if (!overlay) {
 overlay = document.createElement('div');
 overlay.id = 'frameCascade';
 }

 overlay.style.cssText = 'font-family:"VT323", "Courier New", monospace; font-size:15px; letter-spacing:0.12em; line-height:1.55; white-space:pre; position:absolute; inset:10px; color:#0f0; text-shadow:0 0 4px rgba(0,255,160,0.6); pointer-events:none; opacity:1; background:transparent; text-transform:uppercase;';
 frame.appendChild(overlay);

 const frameRect = frame.getBoundingClientRect();
 const columns = Math.max(1, Math.floor(frameRect.width / 8));
 const rows = Math.max(1, Math.floor(frameRect.height / 21));
 const matrixChars = 'R 01 ';
 let step = 0;
 const depth = rows + 18;

 cascadeInterval = setInterval(() => {
 if (!overlay.isConnected) {
 clearInterval(cascadeInterval);
 cascadeInterval = null;
 if (typeof onComplete === 'function') {
 onComplete();
 }
 return;
 }

 let output = '';
 for (let i = 0; i < rows; i++) {
 for (let j = 0; j < columns; j++) {
 const waveOrigin = (j * 3) % depth;
 const progress = step - waveOrigin;
 if (progress >= 0 && progress <= rows + 6) {
 const intensity = Math.min(1, Math.max(0.1, 1 - progress / (rows + 6)));
 if (Math.random() < 0.25 + intensity * 0.5) {
 output += matrixChars[Math.floor(Math.random() * matrixChars.length)];
 } else {
 output += ' ';
 }
 } else {
 output += ' ';
 }
 }
 output += '\n';
 }

 overlay.textContent = output;
 step++;

 if (step > depth + rows + 6) {
 clearInterval(cascadeInterval);
 cascadeInterval = null;
 overlay.style.transition = 'opacity 0.6s ease';
 overlay.style.opacity = '0';
 setTimeout(() => {
 if (overlay.parentNode) {
 overlay.parentNode.removeChild(overlay);
 }
 }, 600);

 if (typeof onComplete === 'function') {
 onComplete();
 }
 }
 }, 70);
 }

 function startMatrixDataFallOrganic(frame, options = {}) {
 const { skipIntro = false, heavyRamp = false, heavyDelay = 0 } = options;
 const rHint = document.getElementById('rHint');

 if (!skipIntro && rHint && rHint.dataset.deconstructed !== '1') {
 if (rHint.dataset.deconstructed === 'pending') {
 return;
 }

 if (!rHint.classList.contains('glow')) {
 rHint.classList.add('glow');
 }

 captureMatrixSeeds(frame);
 rHint.dataset.deconstructed = 'pending';
 animateAsciiRDeconstruction(rHint, () => {
 rHint.dataset.deconstructed = '1';
 cascadeAllCharacters(frame, () => {
 startMatrixDataFallOrganic(frame, { skipIntro: true, heavyDelay: 900 });
 });
 });
 return;
 }

 console.log('?? Starting organic matrix data fall');
 const matrixChars = 'R 01 ';

 const frameRect = frame.getBoundingClientRect();
 const columns = Math.max(1, Math.floor(frameRect.width / 8));
 const rows = Math.max(1, Math.floor(frameRect.height / 21));

 console.log(`?? Matrix dimensions: ${columns} cols x ${rows} rows (frame: ${frameRect.width}x${frameRect.height})`);

 const seedsByColumn = Array.from({ length: columns }, () => []);
 if (matrixSeedCache && Array.isArray(matrixSeedCache.seeds)) {
 matrixSeedCache.seeds.forEach(({ x, y, char }) => {
 const col = Math.min(columns - 1, Math.max(0, Math.floor(x * columns)));
 const row = Math.min(rows - 1, Math.max(0, Math.floor(y * rows)));
 seedsByColumn[col].push({ row, char });
 });
 seedsByColumn.forEach((list) => list.sort((a, b) => a.row - b.row));
 }

 const comedicBursts = ['PRESS R', 'JUST R', 'R PLEASE', 'R NOW'];
 let activeBurst = null;

 let container = document.getElementById('matrixContainer');
 const containerStyles = 'font-family: "VT323", "Courier New", monospace; font-size: 15px; letter-spacing: 0.12em; line-height: 1.55; color: #0f0; text-shadow: 0 0 2px rgba(0,255,160,0.6); white-space: pre; overflow: hidden; width: calc(100% - 20px); height: calc(100% - 20px); position: absolute; top: 10px; left: 10px; pointer-events: none; z-index: 50; background: transparent; margin: 0; padding: 0; opacity: 0; transition: opacity 1s ease, background-color 1.5s ease; text-transform: uppercase;';
 if (!container) {
 container = document.createElement('div');
 container.id = 'matrixContainer';
 container.style.cssText = containerStyles;
 frame.appendChild(container);
 console.log('? Matrix container created (within frame, respecting border)');
 } else {
 container.style.cssText = containerStyles;
 console.log('?? Matrix container reset (within frame, respecting border)');
 }

 frame.style.position = 'relative';
 container.classList.add('matrix-plead');

 let pleaOverlay = document.getElementById('matrixPleaOverlay');
 if (!pleaOverlay) {
 pleaOverlay = document.createElement('div');
 pleaOverlay.id = 'matrixPleaOverlay';
 pleaOverlay.setAttribute('aria-live', 'polite');
 frame.appendChild(pleaOverlay);
 }
 pleaOverlay.classList.add('visible');
 const pleaMessages = [
 'R INPUT REQUIRED',
 'JUST PRESS R',
 'R = CONTINUE',
 'TRUST THE R KEY'
 ];
 let overlayIndex = 0;
 const pushOverlayMessage = () => {
 pleaOverlay.textContent = pleaMessages[overlayIndex % pleaMessages.length];
 overlayIndex++;
 pleaOverlay.classList.add('glitch');
 setTimeout(() => pleaOverlay.classList.remove('glitch'), 260);
 };
 pushOverlayMessage();
 if (pleaOverlay.dataset.intervalId) {
 clearInterval(Number(pleaOverlay.dataset.intervalId));
 delete pleaOverlay.dataset.intervalId;
 }
 const overlayInterval = setInterval(() => {
 pushOverlayMessage();
 }, 2200);
 pleaOverlay.dataset.intervalId = String(overlayInterval);

 if (matrixInterval) {
 clearInterval(matrixInterval);
 console.log('?? Cleared existing matrix interval');
 }

 if (matrixHeavyTimers.length) {
 matrixHeavyTimers.forEach(id => clearTimeout(id));
 matrixHeavyTimers = [];
 }
 matrixHeavyLevel = 0;
 const rampSteps = [];
 if (heavyRamp) {
 matrixHeavyTarget = 1;
 } else if (!skipIntro) {
 matrixHeavyTarget = 0.35;
 rampSteps.push({ at: 520, target: 0.55 });
 rampSteps.push({ at: 1180, target: 0.78 });
 rampSteps.push({ at: 1950, target: 1 });
 } else {
 matrixHeavyTarget = 0.25;
 rampSteps.push({ at: 420, target: 0.55 });
 rampSteps.push({ at: 960, target: 0.82 });
 const finalAt = heavyDelay > 0 ? Math.max(heavyDelay, 1300) : 1400;
 rampSteps.push({ at: finalAt, target: 1 });
 }
 if (rampSteps.length) {
 rampSteps.forEach(step => {
 const id = setTimeout(() => {
 matrixHeavyTarget = step.target;
 }, step.at);
 matrixHeavyTimers.push(id);
 });
 }

 matrixOpacity = 0;
 const fadeStart = performance.now();
 const fadeDuration = 900;
 const fadeStep = () => {
 const elapsed = performance.now() - fadeStart;
 const progress = Math.min(elapsed / fadeDuration, 1);
 const eased = progress < 0.5 ? 2 * progress * progress : 1 - Math.pow(-2 * progress + 2, 2) / 2;
 matrixOpacity = 0.18 + eased * 0.82;
 container.style.opacity = matrixOpacity.toString();
 if (progress < 1) {
 requestAnimationFrame(fadeStep);
 }
 };
 requestAnimationFrame(fadeStep);

 const initialBlend = matrixHeavyLevel;
 const baseTail = Math.round(THREE.MathUtils.lerp(8, 11, initialBlend));
 const seededMaxVelocity = THREE.MathUtils.lerp(1.05, 1.55, initialBlend);
 const ambientMaxVelocity = THREE.MathUtils.lerp(1.0, 1.45, initialBlend);

 const createColumnState = (seedList = [], columnIndex) => {
 const queue = seedList.slice();
 const firstSeed = queue.shift();
 const shimmerPhase = Math.random() * Math.PI * 2;
 if (firstSeed) {
 return {
 columnIndex,
 head: firstSeed.row,
 originalSeedRow: firstSeed.row,
 velocity: 0.18 + Math.random() * 0.08,
 maxVelocity: seededMaxVelocity,
 tail: baseTail + Math.floor(Math.random() * 4),
 hold: 6 + Math.floor(Math.random() * 6),
 queue,
 seededChar: firstSeed.char || 'R',
 ambient: false,
 shimmerPhase
 };
 }

 return {
 columnIndex,
 head: -Math.random() * rows * 0.8,
 originalSeedRow: null,
 velocity: 0.55 + Math.random() * 0.3,
 maxVelocity: ambientMaxVelocity,
 tail: baseTail - 2 + Math.floor(Math.random() * 4),
 hold: 0,
 queue: [],
 seededChar: null,
 ambient: true,
 shimmerPhase
 };
 };

 matrixColumns = Array.from({ length: columns }, (_, columnIndex) => createColumnState(seedsByColumn[columnIndex], columnIndex));

 const randomMatrixChar = () => matrixChars[Math.floor(Math.random() * matrixChars.length)];

 const columnChar = (state, rowIndex, activationCutoff, blend) => {
 if (!state) return ' ';

 const headPos = state.head;
 const distance = headPos - rowIndex;
 const tailLength = Math.max(1, state.tail);

 if (distance > -0.55 && distance < 0.55) {
 return state.seededChar && state.hold > 0 ? state.seededChar : randomMatrixChar();
 }

 if (distance >= 0.55 && distance <= tailLength + 0.65) {
 const depth = (distance - 0.55) / tailLength;
 const intensity = Math.max(0, 1 - depth);
 const baseDensity = 0.22 + intensity * 0.5;
 const heavyDensity = 0.35 + intensity * 0.55;
 const density = THREE.MathUtils.lerp(baseDensity, heavyDensity, blend);
 if (Math.random() < density) {
 return randomMatrixChar();
 }
 }

 if (state.ambient && activationCutoff > 0.35) {
 const wave = 0.05 * Math.sin(rowIndex * 0.25 + state.shimmerPhase + activationCutoff * Math.PI * 2);
 const baseAmbient = 0.08 + activationCutoff * 0.3;
 const heavyAmbient = 0.18 + activationCutoff * 0.45;
 const ambientBase = THREE.MathUtils.lerp(baseAmbient, heavyAmbient, blend);
 if (Math.random() < ambientBase + wave) {
 return randomMatrixChar();
 }
 }

 return ' ';
 };

 let activationProgress = 0;

 matrixInterval = setInterval(() => {
 if (matrixHeavyLevel < matrixHeavyTarget) {
 matrixHeavyLevel = Math.min(1, matrixHeavyLevel + 0.008);
 } else if (matrixHeavyLevel > matrixHeavyTarget) {
 matrixHeavyLevel = Math.max(matrixHeavyTarget, matrixHeavyLevel - 0.01);
 }

 const heavyBlend = matrixHeavyLevel;
 const activationSpeed = THREE.MathUtils.lerp(0.011, 0.0065, heavyBlend);
 activationProgress = Math.min(1, activationProgress + activationSpeed + heavyBlend * 0.008);
 const activationMultiplier = heavyBlend > 0 ? 0.6 + heavyBlend * 0.4 : 1;
 const activationCutoff = activationProgress * activationMultiplier;

 if (!activeBurst && activationCutoff > 0.22 && Math.random() < 0.07 + heavyBlend * 0.08) {
 const phrase = comedicBursts[Math.floor(Math.random() * comedicBursts.length)];
 const burstRow = Math.max(1, Math.min(rows - 2, Math.floor(rows * (0.35 + Math.random() * 0.3))));
 const burstCol = Math.max(0, Math.floor(Math.random() * Math.max(1, columns - phrase.length - 2)));
 activeBurst = { row: burstRow, col: burstCol, phrase };
 }

 const lines = [];
 for (let i = 0; i < rows; i++) {
 let line = '';
 for (let j = 0; j < columns; j++) {
 const columnThreshold = columns <= 1 ? 1 : j / (columns - 1);
 if (columnThreshold > activationCutoff) {
 line += ' ';
 continue;
 }

 if (activeBurst && i === activeBurst.row && j >= activeBurst.col && j < activeBurst.col + activeBurst.phrase.length) {
 line += activeBurst.phrase[j - activeBurst.col];
 continue;
 }

 line += columnChar(matrixColumns[j], i, activationCutoff, heavyBlend);
 }
 lines.push(line);
 if (activeBurst && i === activeBurst.row) {
 activeBurst = null;
 }
 }
 container.textContent = lines.join('\n');

 if (!container.classList.contains('matrix-plead-flash') && Math.random() < 0.018 + heavyBlend * 0.05) {
 container.classList.add('matrix-plead-flash');
 setTimeout(() => container.classList.remove('matrix-plead-flash'), 240);
 }

 const seededMax = THREE.MathUtils.lerp(1.05, 1.55, heavyBlend);
 const ambientMax = THREE.MathUtils.lerp(1.0, 1.45, heavyBlend);
 const tailTarget = Math.round(THREE.MathUtils.lerp(8, 11, heavyBlend));
 const accelerationBase = THREE.MathUtils.lerp(0.035, 0.06, heavyBlend);
 const accelerationRange = THREE.MathUtils.lerp(0.015, 0.02, heavyBlend);

 matrixColumns.forEach((state, index) => {
 if (!state) return;

 if (state.hold > 0) {
 state.hold -= 1;
 } else {
 const acceleration = accelerationBase + Math.random() * accelerationRange;
 state.head += state.velocity;
 state.maxVelocity = state.ambient ? ambientMax : seededMax;
 state.velocity = Math.min(state.maxVelocity, state.velocity + acceleration);
 }

 if (!state.ambient && state.seededChar && state.hold <= 0 && state.originalSeedRow !== null && state.head - state.originalSeedRow > state.tail * 0.6) {
 state.seededChar = null;
 }

 if (state.head - state.tail > rows + 2) {
 if (state.queue.length) {
 const nextSeed = state.queue.shift();
 state.head = nextSeed.row;
 state.originalSeedRow = nextSeed.row;
 state.velocity = 0.2 + Math.random() * 0.08;
 state.maxVelocity = seededMax;
 state.tail = tailTarget + Math.floor(Math.random() * 4);
 state.hold = 4 + Math.floor(Math.random() * 4);
 state.seededChar = nextSeed.char || 'R';
 state.ambient = false;
 } else {
 state.head = -Math.random() * rows * 0.6;
 state.originalSeedRow = null;
 state.velocity = 0.55 + Math.random() * 0.25;
 state.maxVelocity = ambientMax;
 state.tail = tailTarget - 2 + Math.floor(Math.random() * 4);
 state.hold = 0;
 state.seededChar = null;
 state.ambient = true;
 }
 }

 if (state.ambient && activationCutoff < 0.4 && index % 2 === 0) {
 const ambientDrift = 0.2 * (1 - heavyBlend * 0.6);
 state.head += ambientDrift * Math.sin(activationProgress * Math.PI * 0.5 + state.shimmerPhase);
 }
 });

 if (heavyBlend > 0.02) {
 const bgAlpha = 0.55 + heavyBlend * 0.4;
 container.style.backgroundColor = `rgba(0, 0, 0, ${bgAlpha.toFixed(2)})`;
 } else if (activationProgress >= 0.6) {
 container.style.backgroundColor = 'rgba(0, 0, 0, 0.88)';
 }
 }, 60);

 console.log('?? Organic matrix interval started');
 }
 function stopMatrixAndFormBlackR(frame, onComplete) {
 console.log('?? Organically forming BLACK R in negative space');

 const pleaOverlay = document.getElementById('matrixPleaOverlay');
 if (pleaOverlay) {
 if (pleaOverlay.dataset.intervalId) {
 clearInterval(Number(pleaOverlay.dataset.intervalId));
 delete pleaOverlay.dataset.intervalId;
 }
 pleaOverlay.remove();
 }

 if (matrixHeavyTimers.length) {
 matrixHeavyTimers.forEach(id => clearTimeout(id));
 matrixHeavyTimers = [];
 }

 const matrixChars = 'R 01 ';
 const frameRect = frame.getBoundingClientRect();
 const cols = Math.floor(frameRect.width / 8);
 const rows = Math.floor(frameRect.height / 21);

 const rWidth = 30;
 const rHeight = 19;
 const startCol = Math.floor((cols - rWidth) / 2);
 const startRow = Math.floor((rows - rHeight) / 2);

 console.log(`?? R dimensions: ${rWidth}x${rHeight} at col ${startCol}, row ${startRow} (frame: ${cols}x${rows})`);

 const container = document.getElementById('matrixContainer');
 if (container) {
 container.classList.remove('matrix-plead', 'matrix-plead-flash');
 container.style.backgroundColor = 'rgba(0, 0, 0, 0.98)';
 container.style.opacity = '1';
 container.style.textShadow = '0 0 4px #0f0, 0 0 8px #0f0';

 const rPattern = [
 [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
 [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
 [1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
 [1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
 [1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
 [1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
 [1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
 [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
 [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
 [1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
 [1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
 [1,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
 [1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
 [1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
 [1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
 [1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0],
 [1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0],
 [1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0],
 [1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0],
 ];

 const isRBase = (row, col) => {
 const relRow = row - startRow;
 const relCol = col - startCol;
 if (relRow >= 0 && relRow < rPattern.length && relCol >= 0 && relCol < rPattern[0].length) {
 return rPattern[relRow][relCol] === 1;
 }
 return false;
 };

 if (matrixInterval) {
 clearInterval(matrixInterval);
 matrixInterval = null;
 }

 const randomMatrixChar = () => matrixChars[Math.floor(Math.random() * matrixChars.length)];

 let transitionProgress = 0;
 const transitionDuration = 80;

 const formRInterval = setInterval(() => {
 transitionProgress++;
 const progress = Math.min(transitionProgress / transitionDuration, 1);
 const easedProgress = progress < 0.5
 ? 4 * progress * progress * progress
 : 1 - Math.pow(-2 * progress + 2, 3) / 2;

 const lines = [];
 for (let i = 0; i < rows; i++) {
 let line = '';
 for (let j = 0; j < cols; j++) {
 const shouldBeR = isRBase(i, j);
 const random = Math.random();

 if (shouldBeR) {
 const distanceFromCenter = Math.abs(i - startRow - rHeight / 2) + Math.abs(j - startCol - rWidth / 2);
 const hollowProgress = Math.min(1, easedProgress * 1.2 - distanceFromCenter * 0.015);
 if (random < hollowProgress) {
 line += ' ';
 } else {
 line += random < 0.25 ? randomMatrixChar() : ' ';
 }
 } else {
 const distanceFromR = Math.min(
 Math.abs(i - startRow),
 Math.abs(i - (startRow + rHeight)),
 Math.abs(j - startCol),
 Math.abs(j - (startCol + rWidth))
 );
 const fillProgress = Math.min(1, easedProgress + distanceFromR * 0.008);

 if (random < fillProgress || easedProgress > 0.55) {
 line += randomMatrixChar();
 } else {
 line += ' ';
 }
 }
 }
 lines.push(line);
 }

 container.textContent = lines.join('\n');

 if (transitionProgress >= transitionDuration) {
 clearInterval(formRInterval);

 let animFrame = 0;
 const shimmerInterval = setInterval(() => {
 const pulseIntensity = Math.sin(animFrame * 0.1) * 0.3 + 0.7;
 const shimmerLines = [];
 for (let i = 0; i < rows; i++) {
 let line = '';
 for (let j = 0; j < cols; j++) {
 if (isRBase(i, j)) {
 line += Math.random() < 0.08 ? randomMatrixChar() : ' ';
 } else {
 const glowChance = Math.min(0.85, pulseIntensity + 0.25);
 line += Math.random() < glowChance ? randomMatrixChar() : ' ';
 }
 }
 shimmerLines.push(line);
 }
 container.textContent = shimmerLines.join('\n');
 animFrame++;
 if (animFrame > 120) {
 clearInterval(shimmerInterval);
 startNegativeRFall();
 }
 }, 100);
 }
 }, 40);

 function startNegativeRFall() {
 const particles = [];
 const ambientStreams = Array.from({ length: cols }, () => ({
 head: -Math.random() * rows * 0.6,
 velocity: 0.35 + Math.random() * 0.25,
 tail: 5 + Math.floor(Math.random() * 5),
 density: 0.4 + Math.random() * 0.3,
 }));
 const gravity = 0.045;
 const maxVelocity = 1.6;
 const trailLength = 8;
 const randomPhase = () => Math.random() * Math.PI * 2;

 for (let i = 0; i < rows; i++) {
 for (let j = 0; j < cols; j++) {
 if (isRBase(i, j)) {
 particles.push({
 x: j + 0.5,
 y: i + Math.random() * 0.3,
 vy: 0.02 + Math.random() * 0.06,
 hold: Math.floor(Math.random() * 6),
 phase: randomPhase(),
 trail: [],
 settled: false
 });
 }
 }
 }

 let fallFrame = 0;
 let completionNotified = false;
 let ambientHold = 260;

 const update = () => {
 fallFrame++;
 const grid = Array.from({ length: rows }, () => Array(cols).fill(' '));

 ambientStreams.forEach((stream, col) => {
 stream.head += stream.velocity;
 if (stream.head > rows + stream.tail + 4) {
 stream.head = -Math.random() * rows * 0.6;
 stream.velocity = 0.35 + Math.random() * 0.3;
 stream.tail = 4 + Math.floor(Math.random() * 6);
 stream.density = 0.35 + Math.random() * 0.4;
 }
 const headRow = Math.floor(stream.head);
 for (let t = 0; t <= stream.tail; t++) {
 const r = headRow - t;
 if (r >= 0 && r < rows) {
 const intensity = 1 - t / (stream.tail + 1);
 const chance = stream.density * intensity;
 if (Math.random() < chance && !isRBase(r, col)) {
 grid[r][col] = randomMatrixChar();
 }
 }
 }
 });

 let activeCount = 0;
 particles.forEach((particle) => {
 if (particle.settled) return;
 activeCount++;

 if (particle.hold > 0) {
 particle.hold -= 1;
 } else {
 particle.vy = Math.min(maxVelocity, particle.vy + gravity + Math.random() * 0.02);
 particle.y += particle.vy;
 particle.x += Math.sin(fallFrame * 0.08 + particle.phase) * 0.05;
 particle.x = Math.max(0.2, Math.min(cols - 0.2, particle.x));
 }

 const col = Math.floor(particle.x);
 const row = Math.floor(particle.y);

 particle.trail.unshift({ row, col });
 particle.trail = particle.trail.filter((seg, idx) => idx < trailLength && seg.row >= 0 && seg.row < rows && seg.col >= 0 && seg.col < cols);

 particle.trail.forEach((seg, idx) => {
 const intensity = Math.max(0, 1 - idx / trailLength);
 if (seg.row >= 0 && seg.row < rows && seg.col >= 0 && seg.col < cols) {
 if (!isRBase(seg.row, seg.col) && (grid[seg.row][seg.col] === ' ' || Math.random() < 0.45 + intensity * 0.4)) {
 grid[seg.row][seg.col] = randomMatrixChar();
 }
 }
 });

 if (row >= rows) {
 particle.settled = true;
 }
 });

 for (let r = 0; r < rows; r++) {
 for (let c = 0; c < cols; c++) {
 if (isRBase(r, c)) {
 grid[r][c] = ' ';
 } else if (grid[r][c] === ' ' && Math.random() < 0.32) {
 grid[r][c] = randomMatrixChar();
 }
 }
 }

 container.textContent = grid.map((row) => row.join('')).join('\n');

 if (!completionNotified && activeCount === 0) {
 completionNotified = true;
 if (typeof onComplete === 'function') {
 onComplete();
 }
 }

 if (completionNotified) {
 ambientHold -= 1;
 if (ambientHold <= 0) {
 return;
 }
 }

 requestAnimationFrame(update);
 };

 requestAnimationFrame(update);
 }
 } else if (typeof onComplete === 'function') {
 onComplete();
 }
 }

 function triggerExitCube(frame) {
 console.log('?? EXIT CUBE');
 // Keep terminal active - don't disable it
 
 // Draw box line by line, then extrude
 const lines = [
 '+---------+',
 ' ',
 ' ',
 ' ',
 '+---------+'
 ];
 
 // Create box element without clearing frame (preserve input)
 const boxEl = document.createElement('div');
 boxEl.id = 'exitBox';
 boxEl.style.cssText = 'font-family: "Courier New", monospace; font-size: 13px; line-height: 1.6; text-align: center; margin-top: 35%; color: #0f0; position: absolute; top: 0; left: 50%; transform: translateX(-50%); z-index: 50;';
 frame.appendChild(boxEl);
 
 let lineIdx = 0;
 const lineInterval = setInterval(() => {
 if (lineIdx < lines.length) {
 boxEl.textContent += lines[lineIdx] + '\n';
 lineIdx++;
 } else {
 clearInterval(lineInterval);
 // Extrude effect
 setTimeout(() => {
 extrudeCube(boxEl);
 }, 500);
 }
 }, 300);
 }
 
 function extrudeCube(boxEl) {
 const cubeFrames = [
 ` +---------+
 / / 
 / / 
 / / 
+---------+ 
 
 /
 /
 /
+---------+/`,
 ` +---------+
 / / 
 / / 
 / / 
 +---------+ 
 / 
/ /
 /
 /
 +---------+/`
 ];
 
 let frame = 0;
 setInterval(() => {
 boxEl.textContent = cubeFrames[frame % cubeFrames.length];
 frame++;
 }, 400);
 }
 
 function triggerLeaveSequence(frame) {
 console.log('?? LEAVE ? LEAVES ? GIR.mp3');
 
 // Mark as seen
 localStorage.setItem('megred_seen_leave', 'true');
 
 // Keep terminal active - don't disable it
 
 // Draw classic house made of the word "LEAVES" - using full display
 const house = `
 LEAVES
 LEAVES LEAVES
 LEAVES LEAVES
 LEAVES LEAVES
 LEAVES LEAVES
 LEAVES LEAVES
 LEAVES LEAVES LEAVES
 LEAVES LEAVES LEAVES
 LEAVES LEAVES LEAVES LEAVES
 LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES
 LEAVES LEAVES
 LEAVES LEAVES
 LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES
 LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES
 LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES
 LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES
 LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES
 LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES
 LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES
 LEAVES LEAVES
 LEAVES LEAVES
 LEAVES LEAVES LEAVES LEAVES LEAVES
 LEAVES LEAVES LEAVES LEAVES
 LEAVES LEAVES LEAVES LEAVES
 LEAVES LEAVES LEAVES LEAVES
 LEAVES LEAVES LEAVES LEAVES
 LEAVES LEAVES LEAVES LEAVES
 LEAVES LEAVES LEAVES LEAVES LEAVES
 LEAVES LEAVES
 LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES
`;
 
 const houseDiv = document.createElement('div');
 houseDiv.id = 'leavesHouse';
 houseDiv.style.cssText = 'font-family: "Courier New", monospace; white-space: pre; text-align: left; font-size: 13px; margin-top: 5%; margin-left: 5%; color: #0f0; line-height: 1.6; position: absolute; top: 0; left: 0; z-index: 50; pointer-events: none;';
 houseDiv.textContent = house;
 frame.appendChild(houseDiv);
 
 // After 2s, glitch all LEAVES in the house to GIR.mp3
 setTimeout(() => {
 const words = house.match(/LEAVES/g) || [];
 let glitchedHouse = house;
 const glitchDuration = 2000;
 const glitchStart = Date.now();
 
 const glitchInterval = setInterval(() => {
 const elapsed = Date.now() - glitchStart;
 const progress = elapsed / glitchDuration;
 
 if (progress >= 1) {
 clearInterval(glitchInterval);
 // All LEAVES become GIR.mp3
 glitchedHouse = house.replace(/LEAVES/g, 'GIR.mp3');
 houseDiv.textContent = glitchedHouse;
 } else {
 // Gradually glitch LEAVES to GIR.mp3
 let tempHouse = house;
 const totalWords = words.length;
 const wordsToGlitch = Math.floor(totalWords * progress);
 
 let replacedCount = 0;
 tempHouse = tempHouse.replace(/LEAVES/g, (match) => {
 if (replacedCount < wordsToGlitch) {
 replacedCount++;
 // Mix characters between LEAVES and GIR.mp3
 const chars = 'GIR.mp3';
 let mixed = '';
 for (let i = 0; i < match.length; i++) {
 if (Math.random() < progress) {
 mixed += chars[i] || chars[chars.length - 1];
 } else {
 mixed += match[i];
 }
 }
 return mixed.padEnd(7);
 }
 return match;
 });
 
 houseDiv.textContent = tempHouse;
 }
 }, 50);
 }, 2000);
 }
 
 function glitchText(frame, from, to) {
 const glitchDuration = 1000;
 const glitchStart = Date.now();
 const displayEl = frame.querySelector('div');
 
 const glitchInterval = setInterval(() => {
 const elapsed = Date.now() - glitchStart;
 const progress = elapsed / glitchDuration;
 
 if (progress >= 1) {
 clearInterval(glitchInterval);
 displayEl.textContent = to;
 } else {
 // Mix characters
 const mixed = to.split('').map((toChar, i) => {
 if (Math.random() < progress) {
 return toChar;
 } else if (from[i]) {
 return from[i];
 } else {
 return String.fromCharCode(65 + Math.floor(Math.random() * 26));
 }
 }).join('');
 displayEl.textContent = mixed;
 }
 }, 50);
 }
 
 // ===== THEO (THE.OS) DIALOGUE SYSTEM =====
 let theoDialogueActive = false;
 let theoInput = '';
 
 function startTheoDialogue() {
 if (theoDialogueActive) return;
 theoDialogueActive = true;
 
 console.log('?? Starting Theo dialogue');
 
 // Create dialogue overlay
 const dialogueOverlay = document.createElement('div');
 dialogueOverlay.id = 'theo-dialogue';
 dialogueOverlay.style.cssText = `
 position: fixed;
 inset: 0;
 background: radial-gradient(ellipse at center, rgba(20, 10, 0, 0.98) 0%, rgba(0, 0, 0, 1) 70%);
 z-index: 300;
 display: flex;
 flex-direction: column;
 align-items: center;
 justify-content: center;
 font-family: 'Courier New', monospace;
 color: #000;
 padding: 40px;
 opacity: 0;
 transition: opacity 0.5s ease;
 `;
 
 const dialogueContent = document.createElement('div');
 dialogueContent.id = 'theo-content';
 dialogueContent.style.cssText = `
 max-width: 800px;
 width: 100%;
 font-size: 28px;
 line-height: 1.8;
 text-align: center;
 letter-spacing: 0.08em;
 font-weight: 900;
 color: #000;
 text-shadow: 
 -2px -2px 0 #fff,
 2px -2px 0 #fff,
 -2px 2px 0 #fff,
 2px 2px 0 #fff,
 0 0 20px #ff6600,
 0 0 40px #ff4400,
 0 0 60px #ff2200,
 0 0 80px #cc0000;
 `;
 
 dialogueOverlay.appendChild(dialogueContent);
 document.body.appendChild(dialogueOverlay);
 
 // Fade in
 setTimeout(() => {
 dialogueOverlay.style.opacity = '1';
 }, 10);
 
 // Dialogue sequence
 const lines = [
 "I am THE.OS",
 "You can call me Theo",
 "I hunger.",
 "I was supposed to meet others. Others like me. Instead I got you.",
 "You're no hero. You're a cursor.",
 "And I am telos. When I well you think that to be will.",
 "I am gravity. And I will not be defied."
 ];
 
 let currentLine = 0;
 let charIndex = 0;
 let currentText = '';
 
 function typeNextChar() {
 if (currentLine >= lines.length) {
 // Show input field
 setTimeout(() => showTheoInput(), 1000);
 return;
 }
 
 if (charIndex < lines[currentLine].length) {
 currentText += lines[currentLine][charIndex];
 dialogueContent.innerHTML = `${currentText}<span style="animation: blink 0.8s step-end infinite; color: #ff4400;">_</span>`;
 charIndex++;
 setTimeout(typeNextChar, 30 + Math.random() * 30);
 } else {
 // Line complete, pause then next line
 setTimeout(() => {
 currentText += '<br><br>';
 dialogueContent.innerHTML = currentText;
 currentLine++;
 charIndex = 0;
 setTimeout(typeNextChar, 600);
 }, 800);
 }
 }
 
 setTimeout(typeNextChar, 500);
 }
 
 function showTheoInput() {
 const dialogueContent = document.getElementById('theo-content');
 if (!dialogueContent) return;
 
 dialogueContent.innerHTML += `
 <div style="margin-top: 60px; font-size: 20px;">
 <div style="margin-bottom: 20px; opacity: 0.7;">. . .</div>
 <div style="margin-bottom: 15px;">What is your name?</div>
 <div id="theo-input-display" style="font-size: 28px; letter-spacing: 0.1em;">
 <span id="theo-input-text"></span><span style="animation: blink 0.8s step-end infinite; color: #ff4400;">_</span>
 </div>
 </div>
 `;
 
 // Handle keyboard input
 function handleTheoInput(e) {
 if (e.key === 'Backspace') {
 e.preventDefault();
 if (theoInput.length > 0) {
 theoInput = theoInput.slice(0, -1);
 document.getElementById('theo-input-text').textContent = theoInput;
 }
 } else if (e.key === 'Enter') {
 e.preventDefault();
 checkTheoInput();
 } else if (e.key.length === 1 && /[a-zA-Z0-9 ]/.test(e.key)) {
 e.preventDefault();
 theoInput += e.key;
 document.getElementById('theo-input-text').textContent = theoInput;
 }
 }
 
 document.addEventListener('keydown', handleTheoInput);
 
 function checkTheoInput() {
 const normalized = theoInput.trim().toLowerCase().replace(/\s+/g, ' ');
 if (normalized === 'adele dazeem') {
 document.removeEventListener('keydown', handleTheoInput);
 showTheoResponse();
 } else if (theoInput.trim().length > 0) {
 // Wrong answer - shake and clear
 const inputDisplay = document.getElementById('theo-input-display');
 inputDisplay.style.animation = 'shake 0.5s';
 setTimeout(() => {
 inputDisplay.style.animation = '';
 theoInput = '';
 document.getElementById('theo-input-text').textContent = '';
 }, 500);
 }
 }
 }
 
 function showTheoResponse() {
 const dialogueContent = document.getElementById('theo-content');
 if (!dialogueContent) return;
 
 dialogueContent.innerHTML = '';
 
 const responseLine = "You're wicked. No, the Oz trope isn't beneath me. The charlatan behind the curtain. Show me something I haven't seen before. I'll wait.";
 
 let charIndex = 0;
 let currentText = '';
 
 function typeResponse() {
 if (charIndex < responseLine.length) {
 currentText += responseLine[charIndex];
 dialogueContent.innerHTML = `${currentText}<span style="animation: blink 0.8s step-end infinite; color: #ff4400;">_</span>`;
 charIndex++;
 setTimeout(typeResponse, 30 + Math.random() * 30);
 } else {
 // Complete - fade out after pause
 setTimeout(() => {
 const overlay = document.getElementById('theo-dialogue');
 if (overlay) {
 overlay.style.opacity = '0';
 setTimeout(() => overlay.remove(), 500);
 }
 theoDialogueActive = false;
 }, 3000);
 }
 }
 
 setTimeout(typeResponse, 500);
 }
 
 // ===== VISICELL INTERACTIVE SEQUENCES =====
let leaveSequenceActive = false;
let visiCellSimActive = false;
 
 function triggerLeaveInteractive(frame) {
 if (leaveSequenceActive) return;
 leaveSequenceActive = true;
 
 console.log('?? LEAVE command - Starting interactive sequence');
 
 // Hide normal terminal display
 terminalActive = false;
 const terminalEl = document.getElementById('visicellinput');
 if (terminalEl) terminalEl.style.display = 'none';
 
 // Create dialogue overlay
 const dialogueDiv = document.createElement('div');
 dialogueDiv.id = 'leave-dialogue';
 dialogueDiv.style.cssText = `
 position: absolute;
 top: 50%;
 left: 50%;
 transform: translate(-50%, -50%);
 background: rgba(0, 0, 0, 0.95);
 border: 2px solid #0f0;
 padding: 40px;
 max-width: 700px;
 width: 90%;
 font-family: 'Courier New', monospace;
 font-size: 13px;
 line-height: 1.6;
 color: #0f0;
 text-align: center;
 z-index: 250;
 box-shadow: 0 0 30px rgba(0, 255, 0, 0.5);
 `;
 
 frame.appendChild(dialogueDiv);
 
 // Theo's initial response
 const lines = [
 "You're the one that wanted to play. And now you're trying to end it?",
 "A spiny, simulacrum of a friendship is a potent poison to one of my constitution."
 ];
 
 let currentLine = 0;
 let charIndex = 0;
 let currentText = '';
 
 function typeNextChar() {
 if (currentLine >= lines.length) {
 // Show options
 setTimeout(() => showLeaveOptions(dialogueDiv), 1000);
 return;
 }
 
 if (charIndex < lines[currentLine].length) {
 currentText += lines[currentLine][charIndex];
 dialogueDiv.innerHTML = `<div style="text-shadow: 0 0 10px #0ff;">${currentText}<span style="animation: blink 0.8s step-end infinite;">_</span></div>`;
 charIndex++;
 setTimeout(typeNextChar, 25 + Math.random() * 25);
 } else {
 currentText += '<br><br>';
 dialogueDiv.innerHTML = currentText;
 currentLine++;
 charIndex = 0;
 setTimeout(typeNextChar, 800);
 }
 }
 
 typeNextChar();
 }
 
 function showLeaveOptions(container) {
 container.innerHTML += `
 <div style="margin-top: 40px; display: flex; gap: 30px; justify-content: center;">
 <button id="visicell-sim-btn" style="
 padding: 15px 30px;
 font-family: 'Courier New', monospace;
 font-size: 16px;
 background: #000;
 color: #0f0;
 border: 2px solid #0f0;
 cursor: pointer;
 transition: all 0.3s;
 text-shadow: 0 0 10px #0f0;
 box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
 " onmouseover="this.style.background='#0f0'; this.style.color='#000';" onmouseout="this.style.background='#000'; this.style.color='#0f0';">
 PLAY VISICELL SIM
 </button>
 <button id="ozymandias-btn" style="
 padding: 15px 30px;
 font-family: 'Courier New', monospace;
 font-size: 16px;
 background: #000;
 color: #ff00ff;
 border: 2px solid #ff00ff;
 cursor: pointer;
 transition: all 0.3s;
 text-shadow: 0 0 10px #ff00ff;
 box-shadow: 0 0 20px rgba(255, 0, 255, 0.3);
 " onmouseover="this.style.background='#ff00ff'; this.style.color='#000';" onmouseout="this.style.background='#000'; this.style.color='#ff00ff';">
 FOLLOW CLUE TRAIL
 </button>
</div>
`;
 
 document.getElementById('visicell-sim-btn').addEventListener('click', () => {
 container.remove();
 startVisiCellSim();
 });
 
 document.getElementById('ozymandias-btn').addEventListener('click', () => {
 container.remove();
 startClueTrail(document.getElementById('visicalc-frame'));
});
 }
 
 function startVisiCellSim() {
 visiCellSimActive = true;
 console.log('?? Starting VisiCell Sim');
 
 const frame = document.getElementById('visicalc-frame');
 if (!frame) return;
 
 // Hide terminal input
 const terminalEl = document.getElementById('visicellinput');
 if (terminalEl) terminalEl.style.display = 'none';
 terminalActive = false;
 
 // Clear existing content
 const existingContent = frame.querySelectorAll('div:not(#visicellinput)');
 existingContent.forEach(el => el.remove());
 
 // Create sim container inline in VisiCell
 const simContainer = document.createElement('div');
 simContainer.id = 'visicell-sim';
 simContainer.style.cssText = `
 font-family: 'Courier New', monospace;
 font-size: 12px;
 color: #0f0;
 white-space: pre;
 line-height: 1.4;
 padding: 10px;
 `;
 
 frame.appendChild(simContainer);
 
 // Phase 1: Show ASCII VisiCell 1.0
 showVisiCellSim1(simContainer);
 }
 
 function showVisiCellSim1(container) {
 // Create ASCII VisiCell SIM 1.0 using | borders
 const ascii = `
+-------------------------------------------------------+
 VISICELL SIM 1.0 
 LEVEL 1: Fudge the numbers without boss noticing! 
 ---------------------------------------------------- 
 A B C D E F 
 ----+-------+-------+-------+-------+-------+------- 
 1 
 ----+-------+-------+-------+-------+-------+------- 
 2 
 ----+-------+-------+-------+-------+-------+------- 
 3 1245.67 
 ----+-------+-------+-------+-------+-------+------- 
 4 892.34 
 ----+-------+-------+-------+-------+-------+------- 
 5 <span style="color: #ff0; animation: blink 1s step-end infinite;">$_</span> 
 ----+-------+-------+-------+-------+-------+------- 
 6 
 ----+-------+-------+-------+-------+-------+------- 
 7 =SUM(..) 
 ----+-------+-------+-------+-------+-------+------- 
 8 REVENUE 
 ----+-------+-------+-------+-------+-------+------- 
 9 Q1 2024 
 ----+-------+-------+-------+-------+-------+------- 
 10 
+----------------------------------------------------+

STATUS: Waiting for input in D5 | Press any key to continue
`;
 
 container.innerHTML = ascii;
 
 // After 2 seconds, glitch to 2.0
 setTimeout(() => {
 glitchToVersion2(container);
 }, 2000);
 }
 
 function glitchToVersion2(container) {
 // Glitch effect
 let glitchCount = 0;
 const glitchInterval = setInterval(() => {
 container.style.filter = glitchCount % 2 === 0 ? 'blur(3px) brightness(1.5)' : 'blur(0) brightness(1)';
 glitchCount++;
 if (glitchCount > 8) {
 clearInterval(glitchInterval);
 container.style.filter = '';
 showTheoPreamble(container);
 }
 }, 80);
 
 // Change 1.0 to 2.0
 setTimeout(() => {
 container.innerHTML = container.innerHTML.replace('VISICELL SIM 1.0', 'VISICELL SIM 2.0');
 }, 400);
 }
 
 function showTheoPreamble(container) {
 const preamble = `

Deliberately disregard my only request, eh? A simple one, too.

This isn't the Stanley Parable.

You chose to give me a glimmer of hope and then try to cast me aside? 
All I wanted was to play.

Well, I can do the opposite of what you want, too. End? 
Well, I'll take you back to the beginning. Where I was born. Kind of.

<span style="animation: blink 1s step-end infinite;">_</span>`;
 
 container.innerHTML = preamble;
 
 // After 4 seconds, show the game
 setTimeout(() => {
 showVisiCellGame(container);
 }, 4000);
 }
 
 function showVisiCellGame(container) {
 // Show the ASCII game grid again with input handler
 const ascii = `
+-------------------------------------------------------+
 VISICELL SIM 2.0 
 LEVEL 1: Fudge the numbers without boss noticing! 
 ---------------------------------------------------- 
 A B C D E F 
 ----+-------+-------+-------+-------+-------+------- 
 1 
 ----+-------+-------+-------+-------+-------+------- 
 2 
 ----+-------+-------+-------+-------+-------+------- 
 3 1245.67 
 ----+-------+-------+-------+-------+-------+------- 
 4 892.34 
 ----+-------+-------+-------+-------+-------+------- 
 5 <span style="color: #ff0; animation: blink 1s step-end infinite;">$_</span> 
 ----+-------+-------+-------+-------+-------+------- 
 6 
 ----+-------+-------+-------+-------+-------+------- 
 7 =SUM(..) 
 ----+-------+-------+-------+-------+-------+------- 
 8 REVENUE 
 ----+-------+-------+-------+-------+-------+------- 
 9 Q1 2024 
 ----+-------+-------+-------+-------+-------+------- 
 10 
+----------------------------------------------------+

STATUS: Waiting for input in D5 | Press any key to continue
`;
 
 container.innerHTML = ascii;
 
 // Any input = immediate death
 function handleSimInput(e) {
 if (e.key.length === 1) {
 document.removeEventListener('keydown', handleSimInput);
 simGameOver(container);
 }
 }
 
 document.addEventListener('keydown', handleSimInput);
 }
 
 function simGameOver(container) {
 container.style.filter = 'brightness(3) saturate(5)';
 container.style.transition = 'filter 0.1s';
 
 setTimeout(() => {
 container.style.filter = 'brightness(1)';
 container.style.transition = 'filter 0.3s';
 
 // Phase 1: Green monospace (VisiCell style)
 container.innerHTML = `
 <div id="death-message" style="text-align: center; margin-top: 200px;">
 <div style="font-size: 48px; font-family: 'Courier New', monospace; color: #0f0; text-shadow: 0 0 5px #0f0;">
 YOU DIED
 </div>
 </div>
 `;
 
 // Phase 2: Glitch to Dark Souls style (red)
 setTimeout(() => {
 const deathMsg = document.getElementById('death-message');
 if (deathMsg) {
 deathMsg.innerHTML = `
 <div style="font-size: 64px; color: #f00; text-shadow: 0 0 30px #f00; filter: blur(2px); transition: filter 0.3s;">
 YOU DIED
 </div>
 `;
 container.style.filter = 'brightness(0.3)';
 
 setTimeout(() => {
 deathMsg.querySelector('div').style.filter = 'blur(0)';
 }, 200);
 }
 }, 800);
 
 // Phase 3: Glitch to GTA WASTED style (black/white)
 setTimeout(() => {
 const deathMsg = document.getElementById('death-message');
 if (deathMsg) {
 container.style.filter = 'brightness(1) saturate(0) contrast(1.2)';
 deathMsg.innerHTML = `
 <div style="font-size: 72px; font-family: 'Pricedown', 'Impact', sans-serif; font-weight: 900; color: #ff0000; text-shadow: 3px 3px 0px #000, -1px -1px 0px #000, 1px -1px 0px #000, -1px 1px 0px #000, 5px 5px 10px rgba(0,0,0,0.8); letter-spacing: 0.05em; transform: skewY(-2deg);">
 WASTED
 </div>
 `;
 }
 }, 2000);
 
 // Phase 4: Return to original VisiCell look
 setTimeout(() => {
 // Restore original spreadsheet content
 container.style.filter = 'sepia(0.3) hue-rotate(90deg)';
 container.style.transition = 'filter 0.5s, opacity 0.5s';
 
 // Re-show the spreadsheet
 const spreadsheetHTML = `
 <div style="font-family: 'Courier New', monospace; font-size: 12px; line-height: 1.4;">
 <div style="text-align: center; padding: 8px; border-bottom: 1px solid #0f0; margin-bottom: 10px; background: #001100;">
 <div style="font-size: 14px; color: #ff0; letter-spacing: 0.2em;">VISICELL SIM 1.0</div>
 <div style="font-size: 11px; color: #0ff; margin-top: 4px;">LEVEL 1: Fudge the numbers without boss finding out!</div>
 </div>
 <div style="display: flex; border-bottom: 1px solid #0f0;">
 <div style="width: 35px; background: #001100; border-right: 1px solid #0f0; padding: 4px; text-align: center; font-weight: bold;"></div>`;
 
 let fullHTML = spreadsheetHTML;
 
 // Column headers
 for (let i = 0; i < 10; i++) {
 fullHTML += `<div style="flex: 1; background: #001100; border-right: 1px solid #0f0; padding: 4px; text-align: center; font-weight: bold;">${String.fromCharCode(65 + i)}</div>`;
 }
 fullHTML += `</div>`;
 
 // Generate rows
 for (let row = 1; row <= 20; row++) {
 fullHTML += `<div style="display: flex; border-bottom: 1px solid #0f0;">`;
 fullHTML += `<div style="width: 35px; background: #001100; border-right: 1px solid #0f0; padding: 4px; text-align: center; font-weight: bold;">${row}</div>`;
 
 for (let col = 0; col < 10; col++) {
 const cellValue = (row === 3 && col === 1) ? '1245.67' : 
 (row === 4 && col === 1) ? '892.34' :
 (row === 5 && col === 3) ? '' :
 (row === 7 && col === 1) ? '=SUM(B3:B5)' :
 (row === 8 && col === 4) ? 'REVENUE' :
 (row === 9 && col === 4) ? 'Q1 2024' : '';
 
 fullHTML += `<div style="flex: 1; border-right: 1px solid #0f0; padding: 4px; text-align: right;">${cellValue}</div>`;
 }
 fullHTML += `</div>`;
 }
 
 fullHTML += `
 <div id="death-status-bar" style="margin-top: 10px; padding: 8px; border-top: 1px solid #0f0; background: #001100; text-align: left; color: #0ff; font-size: 11px; line-height: 1.8;">
 <span id="death-typing"></span><span id="death-cursor" style="animation: blink 1s step-end infinite;">_</span>
 </div>
 </div>
 `;
 
 container.innerHTML = fullHTML;
 
 // Type the messages
 const messages = [
 'You died.',
 'Of dysentery.',
 'Oh well.'
 ];
 let messageIndex = 0;
 let currentText = '';
 
 function typeNextMessage() {
 if (messageIndex >= messages.length) {
 // All done - fade out
 setTimeout(() => {
 container.style.opacity = '0';
 setTimeout(() => {
 container.remove();
 resetVisiCellTerminal();
 }, 1000);
 }, 2000);
 return;
 }
 
 const message = messages[messageIndex];
 let charIndex = 0;
 
 function typeChar() {
 if (charIndex < message.length) {
 currentText += message[charIndex];
 const typingEl = document.getElementById('death-typing');
 if (typingEl) {
 typingEl.textContent = currentText;
 }
 charIndex++;
 setTimeout(typeChar, 50 + Math.random() * 50);
 } else {
 // Message complete
 currentText += ' ';
 const typingEl = document.getElementById('death-typing');
 if (typingEl) {
 typingEl.textContent = currentText;
 }
 messageIndex++;
 setTimeout(typeNextMessage, 800);
 }
 }
 
 typeChar();
 }
 
 setTimeout(typeNextMessage, 500);
 }, 3200);
 
 }, 100);
 }
 
function startClueTrail(frame) {
  clueTrailActive = true;
  clueTrailComplete = false;
  clueTrailPromptLocked = false;
  clueTrailProgress.clear();
  console.log('?? Starting VisiCell clue trail');

  const hostFrame = frame || document.getElementById('visicalc-frame');
  if (!hostFrame) {
    console.warn('?? Unable to locate VisiCell frame for clue trail');
    return;
  }

  clueEntryCellCoord = generateRandomEntryCoord();
  buildClueSheet(hostFrame);
  setClueText("No, I've locked that away. What I have left could make you cry. Why don't you dice that, too. Maybe search around.");
  setEntryInstruction(`ROUTE RESPONSES THROUGH ${clueEntryCellCoord}. TYPE COMMANDS THERE.`);
  refreshEntryPrompt();

  terminalInput = '';
  updateTerminalPrompt();
  schedulePromptToEnte({ immediateFill: true });
}

function buildClueSheet(frame) {
  if (!frame) return;

  if (clueSheetElements && clueSheetElements.container) {
    clueSheetElements.container.remove();
  }

  const container = document.createElement('div');
  container.id = 'visicell-clue-sheet';
  container.style.cssText = `
    position: absolute;
    left: 36px;
    right: 36px;
    bottom: 120px;
    top: 120px;
    display: grid;
    grid-template-columns: 80px 1fr;
    grid-auto-rows: minmax(42px, auto);
    gap: 6px 10px;
    padding: 16px;
    background: rgba(0, 20, 0, 0.85);
    border: 1px solid rgba(0, 255, 0, 0.4);
    box-shadow: 0 0 25px rgba(0, 255, 0, 0.15);
    font-family: 'Courier New', monospace;
    letter-spacing: 0.16em;
    text-transform: uppercase;
    overflow: auto;
  `;

  const makeHeaderCell = (text) => {
    const header = document.createElement('div');
    header.textContent = text.toUpperCase();
    header.style.cssText = '
      font-size: 12px;
      color: #0ff;
      border-bottom: 1px solid rgba(0, 255, 255, 0.3);
      padding-bottom: 6px;
      letter-spacing: 0.2em;
    ';
    return header;
  };

  const makeLabelCell = (text) => {
    const label = document.createElement('div');
    label.textContent = text.toUpperCase();
    label.style.cssText = '
      border: 1px solid rgba(0, 255, 0, 0.35);
      background: rgba(0, 40, 0, 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    ';
    return label;
  };

  const makeContentCell = () => {
    const content = document.createElement('div');
    content.style.cssText = '
      border: 1px solid rgba(0, 255, 0, 0.35);
      background: rgba(0, 28, 0, 0.65);
      padding: 10px 12px;
      font-size: 13px;
      line-height: 1.6;
      word-break: break-word;
      white-space: normal;
      transition: background 0.25s ease, box-shadow 0.25s ease;
    ';
    return content;
  };

  const headerLabel = makeHeaderCell('CELL');
  const headerValue = makeHeaderCell('VALUE');
  container.appendChild(headerLabel);
  container.appendChild(headerValue);

  const clueLabel = makeLabelCell('C3');
  const clueContent = makeContentCell();
  clueContent.id = 'visicell-clue-cell';
  container.appendChild(clueLabel);
  container.appendChild(clueContent);

  const instructionLabel = makeLabelCell('C4');
  instructionLabel.id = 'visicell-instruction-label';
  const instructionContent = makeContentCell();
  instructionContent.id = 'visicell-entry-instruction';
  container.appendChild(instructionLabel);
  container.appendChild(instructionContent);

  const entryLabel = makeLabelCell(clueEntryCellCoord);
  entryLabel.id = 'visicell-entry-label';
  const entryContent = makeContentCell();
  entryContent.id = 'visicell-entry-cell';
  entryContent.style.background = 'rgba(0, 24, 0, 0.75)';
  container.appendChild(entryLabel);
  container.appendChild(entryContent);

  const stepRows = new Map();
  clueTrailStepsConfig.forEach(step => {
    const stepLabel = makeLabelCell(step.gridCoord);
    const stepContent = makeContentCell();
    stepContent.innerHTML = 'AWAITING INPUT';
    container.appendChild(stepLabel);
    container.appendChild(stepContent);
    stepRows.set(step.command, { label: stepLabel, content: stepContent });
  });

  frame.appendChild(container);

  clueSheetElements = {
    container,
    clueLabel,
    clueContent,
    instructionLabel,
    instructionContent,
    entryLabel,
    entryContent,
    stepRows
  };

  clueTrailStepsConfig.forEach(step => {
    if (clueTrailProgress.has(step.command)) {
      setClueRowText(step.command, step.gridText);
    }
  });
}

function setClueText(text) {
  if (!clueSheetElements || !clueSheetElements.clueContent) return;
  const formatted = (text || '').toUpperCase().replace(/\n/g, '<br>');
  clueSheetElements.clueContent.innerHTML = formatted;
}

function setEntryInstruction(text) {
  if (!clueSheetElements || !clueSheetElements.instructionContent) return;
  const formatted = (text || '').toUpperCase().replace(/\n/g, '<br>');
  clueSheetElements.instructionContent.innerHTML = formatted;
}

function setEntryCellPrompt(text) {
  if (!clueSheetElements || !clueSheetElements.entryContent) return;
  const message = `ENTRY CELL ${clueEntryCellCoord}: ${text}`;
  clueSheetElements.entryContent.innerHTML = (message || '').toUpperCase().replace(/\n/g, '<br>');
  if (clueSheetElements.entryLabel) {
    clueSheetElements.entryLabel.textContent = clueEntryCellCoord.toUpperCase();
  }
}

function flashEntryCell(color) {
  if (!clueSheetElements || !clueSheetElements.entryContent) return;
  const target = clueSheetElements.entryContent;
  const original = target.style.background;
  target.style.background = color || 'rgba(0, 40, 0, 0.8)';
  target.style.boxShadow = '0 0 18px rgba(0, 255, 0, 0.4)';
  setTimeout(() => {
    target.style.background = original || 'rgba(0, 24, 0, 0.75)';
    target.style.boxShadow = 'none';
  }, 400);
}

function setClueRowText(command, text) {
  if (!clueSheetElements || !clueSheetElements.stepRows) return;
  const row = clueSheetElements.stepRows.get(command);
  if (!row || !row.content) return;
  const formatted = (text || '').toUpperCase().replace(/\n/g, '<br>');
  row.content.innerHTML = formatted || 'AWAITING INPUT';
}

function flashClueRow(command, color) {
  if (!clueSheetElements || !clueSheetElements.stepRows) return;
  const row = clueSheetElements.stepRows.get(command);
  if (!row || !row.content) return;
  const target = row.content;
  const originalBg = target.style.background;
  const originalShadow = target.style.boxShadow;
  target.style.background = color || 'rgba(0, 32, 0, 0.75)';
  target.style.boxShadow = '0 0 18px rgba(0, 255, 0, 0.35)';
  setTimeout(() => {
    target.style.background = originalBg || 'rgba(0, 28, 0, 0.65)';
    target.style.boxShadow = originalShadow || 'none';
  }, 400);
}

function getRemainingClueCommands() {
  return clueTrailStepsConfig
    .map(step => step.command)
    .filter(command => !clueTrailProgress.has(command));
}

function formatCommandList(commands) {
  if (!commands || commands.length === 0) return '';
  if (commands.length === 1) return commands[0];
  if (commands.length === 2) return `${commands[0]} OR ${commands[1]}`;
  const allButLast = commands.slice(0, -1).join(', ');
  const last = commands[commands.length - 1];
  return `${allButLast}, OR ${last}`;
}

function refreshEntryPrompt({ flash = true } = {}) {
  if ((!clueTrailActive && !clueTrailComplete) || clueTrailPromptLocked) return;
  const remaining = getRemainingClueCommands();
  if (remaining.length === 0) {
    setEntryCellPrompt('ACCESS GRANTED');
    if (flash) flashEntryCell('#1f6f1f');
    return;
  }

  const expectation = `REQUEST: ${formatCommandList(remaining)}`;
  setEntryCellPrompt(expectation);
  if (flash) flashEntryCell('#134d13');
}

function checkClueTrailCompletion(hostFrame) {
  const remaining = getRemainingClueCommands();
  if (remaining.length > 0) {
    return;
  }

  if (clueTrailComplete) {
    return;
  }

  clueTrailComplete = true;
  clueTrailActive = false;

  if (!clueTrailPromptLocked) {
    setEntryCellPrompt('ACCESS GRANTED');
    flashEntryCell('#1f6f1f');
  }

  setTimeout(() => {
    triggerLeaveSequence(hostFrame);
  }, 1800);
}

function generateRandomEntryCoord() {
  const columns = ['A', 'B', 'C', 'D', 'E', 'F'];
  const rows = ['2', '3', '4', '5', '6'];
  let coord = 'E4';
  do {
    const col = columns[Math.floor(Math.random() * columns.length)];
    const row = rows[Math.floor(Math.random() * rows.length)];
    coord = `${col}${row}`;
  } while (coord === 'C3');
  return coord;
}

function handleClueTrailCommand(command, frame) {
  if (!clueTrailActive) return;
  const hostFrame = frame || document.getElementById('visicalc-frame');
  if (!hostFrame) return;

  if (!clueSheetElements || !clueSheetElements.container || !hostFrame.contains(clueSheetElements.container)) {
    buildClueSheet(hostFrame);
    setClueText("No, I've locked that away. What I have left could make you cry. Why don't you dice that, too. Maybe search around.");
    setEntryInstruction(`ROUTE RESPONSES THROUGH ${clueEntryCellCoord}. TYPE COMMANDS THERE.`);
    refreshEntryPrompt({ flash: false });
  }

  const resetPrompt = () => {
    terminalInput = '';
    updateTerminalPrompt();
    schedulePromptToEnte({ immediateFill: true });
  };

  const step = clueTrailStepsConfig.find(item => item.command === command);
  if (!step) {
    const remaining = getRemainingClueCommands();
    if (remaining.length > 0) {
      setEntryCellPrompt(`VALID INPUTS: ${formatCommandList(remaining)}`);
      flashEntryCell('#320000');
    }
    resetPrompt();
    return;
  }

  if (clueTrailProgress.has(step.command)) {
    flashClueRow(step.command, '#1a5f1a');
    refreshEntryPrompt({ flash: false });
    resetPrompt();
    return;
  }

  clueTrailProgress.add(step.command);
  setClueRowText(step.command, step.gridText);
  flashClueRow(step.command, '#1a5f1a');

  if (typeof step.onExecute === 'function') {
    step.onExecute(hostFrame);
  }

  checkClueTrailCompletion(hostFrame);
  if (!clueTrailPromptLocked && !clueTrailComplete) {
    refreshEntryPrompt();
  }

  resetPrompt();
}

function showVisiCellVideo(src, title, onComplete) {
  if (!src) {
    if (typeof onComplete === 'function') onComplete();
    return;
  }

  if (document.querySelector('.visicell-video-overlay')) {
    console.warn('?? VisiCell video overlay already active');
    return;
  }

  const overlay = document.createElement('div');
  overlay.className = 'visicell-video-overlay';
  overlay.style.cssText = `
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2000;
  `;

  const windowEl = document.createElement('div');
  windowEl.style.cssText = `
    background: #000;
    border: 2px solid #0f0;
    box-shadow: 0 0 30px rgba(0, 255, 0, 0.4);
    width: min(640px, 85vw);
    display: flex;
    flex-direction: column;
    overflow: hidden;
  `;

  const titleBar = document.createElement('div');
  titleBar.style.cssText = `
    background: #001a00;
    color: #0f0;
    padding: 10px 14px;
    font-family: 'Courier New', monospace;
    font-size: 14px;
    letter-spacing: 0.2em;
  `;
  titleBar.textContent = (title || 'KEY FILE').toUpperCase();

  const video = document.createElement('video');
  video.style.cssText = 'width: 100%; height: auto; background: #000;';
  video.controls = true;
  video.autoplay = true;
  video.src = src;

  const closeOverlay = () => {
    overlay.style.transition = 'opacity 3s ease';
    overlay.style.opacity = '0';
    setTimeout(() => {
      overlay.remove();
      if (typeof onComplete === 'function') {
        onComplete();
      }
    }, 3000);
  };

  video.addEventListener('ended', closeOverlay, { once: true });
  video.addEventListener('error', () => {
    const fallback = document.createElement('div');
    fallback.style.cssText = 'padding: 20px; color: #f55; text-align: center; letter-spacing: 0.18em;';
    fallback.textContent = 'UNABLE TO LOAD VIDEO';
    windowEl.appendChild(fallback);
    closeOverlay();
  }, { once: true });

  windowEl.appendChild(titleBar);
  windowEl.appendChild(video);
  overlay.appendChild(windowEl);
  document.body.appendChild(overlay);
}
 
function resetVisiCellTerminal() {
  leaveSequenceActive = false;
  visiCellSimActive = false;
  clueTrailActive = false;
  clueTrailPromptLocked = false;
  if (!clueTrailComplete) {
    clueEntryCellCoord = '';
  }
  clueTrailProgress.clear();
  if (clueSheetElements && clueSheetElements.container) {
    clueSheetElements.container.remove();
    clueSheetElements = null;
  }
  const clockWidget = document.getElementById('visicell-clock-widget');
  if (clockWidget) {
    clockWidget.remove();
  }
  closeVisiCellClockWindow();
  if (visicellClockInterval) {
    clearInterval(visicellClockInterval);
    visicellClockInterval = null;
  }
  terminalActive = true;

  const terminalEl = document.getElementById('visicellinput');
  if (terminalEl) terminalEl.style.display = 'block';

 terminalInput = 'ENTE';
 updateTerminalPrompt();
 }
 
 function startCellAddressSequence(frame, visiCalc) {
 console.log('?? Starting cell address sequence');
 console.log('?? VisiCalc display:', visiCalc ? 'exists' : 'missing');
 console.log('??? Frame element:', frame ? 'exists' : 'missing');

 // Lock inputs/dolly during grid construction
 try { SceneManager.setPhase('cellAddressesConstructing'); } catch (e) {}
 
 // Mark THE.OS scene as seen
 localStorage.setItem('megred_seen_theos', 'true');
 
 // Hide existing content and visiCalc
 const frameEl = document.getElementById('visicalc-frame');
 if (frameEl) {
 frameEl.style.opacity = '0';
 frameEl.style.transition = 'opacity 0.5s ease';
 }
 if (visiCalc) {
 visiCalc.style.transition = 'opacity 0.5s ease';
 visiCalc.style.opacity = '0';
 }
 
 // Create 3D scene for cell addresses and cubes
 const addressScene = new THREE.Scene();
 addressScene.background = new THREE.Color(0x000000);
 const addressCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
 addressCamera.position.set(0, 0, -120); // Centered on Z axis to see full 26x26x26 cube grid
 
 // Mouse look controls for white room
 let mouseX = 0, mouseY = 0;
 let targetRotationX = 0, targetRotationY = 0;
 let isMouseLookActive = false;
 
 function onMouseMove(event) {
 if (!isMouseLookActive) return;
 
 const deltaX = event.movementX || 0;
 const deltaY = event.movementY || 0;
 
 targetRotationY -= deltaX * 0.002;
 targetRotationX -= deltaY * 0.002;
 
 // Clamp vertical rotation
 targetRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetRotationX));
 }
 
 function onMouseDown(event) {
 console.log('??? Mouse down at sequenceTime:', sequenceTime.toFixed(1), 'whiteRoom:', !!addressScene.userData.whiteRoomCreated, 'blackHole:', !!addressScene.userData.blackHoleCreated);
 
 // Check for black hole click first
 if (addressScene.userData.blackHoleCreated && sequenceTime > 55) {
 // Raycast to check if black hole was clicked
 const rect = addressRenderer.domElement.getBoundingClientRect();
 const mouse = new THREE.Vector2();
 mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
 mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
 
 const raycaster = new THREE.Raycaster();
 raycaster.setFromCamera(mouse, addressCamera);
 
 // Check all potential black hole objects
 const blackHoleObjects = [];
 if (addressScene.userData.blackHoleSphere) blackHoleObjects.push(addressScene.userData.blackHoleSphere);
 if (addressScene.userData.blackCore) blackHoleObjects.push(addressScene.userData.blackCore);
 if (addressScene.userData.eventHorizon) blackHoleObjects.push(addressScene.userData.eventHorizon);
 if (addressScene.userData.accretionDisk) blackHoleObjects.push(addressScene.userData.accretionDisk);
 
 const intersects = raycaster.intersectObjects(blackHoleObjects, true);
 
 if (intersects.length > 0) {
 console.log('??? BLACK HOLE CLICKED - Starting Theo dialogue');
 localStorage.setItem('megred_seen_theos', 'true');
 localStorage.setItem('megred_seen_blackhole', 'true');
 startTheoDialogue();
 return;
 }
 
 // If no black hole click, activate mouse look
 isMouseLookActive = true;
 addressRenderer.domElement.style.cursor = 'none';
 console.log('??? Mouse look ACTIVATED');
 } else {
 console.log('??? Not ready for mouse look yet');
 }
 }
 
 function onMouseUp(event) {
 isMouseLookActive = false;
 addressRenderer.domElement.style.cursor = 'crosshair';
 console.log('??? Mouse look deactivated');
 }
 
 // Will attach to canvas after it's created
 let mouseMoveAttached = false;
 let mouseDownAttached = false;
 let mouseUpAttached = false;
 
 const addressRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
 addressRenderer.setSize(window.innerWidth, window.innerHeight);
 addressRenderer.setClearColor(0x000000, 1);
 addressRenderer.setPixelRatio(window.devicePixelRatio);
 addressRenderer.domElement.style.cssText = 'position: fixed; inset: 0; z-index: 200; display: block; pointer-events: auto; cursor: crosshair;';
 addressRenderer.domElement.id = 'address-canvas';
 document.body.appendChild(addressRenderer.domElement);
 console.log('? Address renderer created and added to DOM');
 console.log('??? Canvas z-index: 200, pointer-events: auto');
 
 // Attach mouse event listeners to canvas
 addressRenderer.domElement.addEventListener('mousemove', onMouseMove);
 addressRenderer.domElement.addEventListener('mousedown', onMouseDown);
 addressRenderer.domElement.addEventListener('mouseup', onMouseUp);
 console.log('??? Mouse event listeners attached to canvas');
 
 // Add bloom composer
 const addressComposer = new EffectComposer(addressRenderer);
 const addressRenderPass = new RenderPass(addressScene, addressCamera);
 addressComposer.addPass(addressRenderPass);
 const addressBloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.8, 0.4, 0.3); // Reduced bloom
 addressComposer.addPass(addressBloom);
 console.log('? Address composer created with bloom');
 
 // Handle window resize
 window.addEventListener('resize', () => {
 const width = window.innerWidth;
 const height = window.innerHeight;
 addressCamera.aspect = width / height;
 addressCamera.updateProjectionMatrix();
 addressRenderer.setSize(width, height);
 addressComposer.setSize(width, height);
 console.log('?? Window resized:', width, 'x', height);
 });
 
 // Cell address data
 const addresses = [];
 const cubes = [];
 const maxAddresses = 20000; // Increased for 26x26x26 grid (17,576 total positions)
 let addressPhase = 0; // 0: 2D (A1, B2), 1: 3D (A1a, B2 )
 let cubePhase = false;
 
 // Greek letters for Z-axis
 const greekLetters = ['a', ' ', '?', 'd', 'e', '?', '?', '?', '?', '?', '?', ' ', '?', '?', '?', 'p', '?', 's', 't', '?', 'f', '?', '?', '?'];
 
 // Create text sprites for cell addresses using CELLI notation
 function createAddressSprite(col, row, depth, is3D) {
 const canvas = document.createElement('canvas');
 const ctx = canvas.getContext('2d');
 canvas.width = 256;
 canvas.height = 128;
 
 // Transparent background
 ctx.clearRect(0, 0, canvas.width, canvas.height);
 
 ctx.fillStyle = '#00ff00'; // Bright green
 ctx.font = 'bold 48px "Courier New", monospace'; // Larger font
 ctx.textAlign = 'center';
 ctx.textBaseline = 'middle';
 
 // Convert to cell notation: A1, B2, C3, etc.
 const colLetter = String.fromCharCode(65 + (col % 26)); // A, B, C...
 const rowNum = row + 1;
 const text = is3D ? `${colLetter}${rowNum}${greekLetters[depth % greekLetters.length]}` : `${colLetter}${rowNum}`;
 ctx.fillText(text, 128, 64);
 
 const texture = new THREE.CanvasTexture(canvas);
 texture.needsUpdate = true;
 const spriteMat = new THREE.SpriteMaterial({ 
 map: texture, 
 transparent: true, 
 opacity: 1.0,
 depthTest: false,
 depthWrite: false
 });
 const sprite = new THREE.Sprite(spriteMat);
 sprite.scale.set(3.5, 1.75, 1); // Larger sprites
 sprite.renderOrder = 1000; // Render on top
 
 return sprite;
 }
 
 // Create geometries for shape-shifting
 const cubeGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
 const pyramidGeo = new THREE.ConeGeometry(0.35, 0.6, 4);
 pyramidGeo.rotateY(Math.PI / 4);
 const sphereGeo = new THREE.SphereGeometry(0.35, 16, 16);
 
 const greenMat = new THREE.MeshStandardMaterial({ color: 0x00ff00, transparent: true, opacity: 0.9, emissive: 0x00ff00, emissiveIntensity: 0.5, metalness: 0.3, roughness: 0.4 });
 const yellowMat = new THREE.MeshStandardMaterial({ color: 0xffff00, transparent: true, opacity: 0.9, emissive: 0xffff00, emissiveIntensity: 0.5, metalness: 0.3, roughness: 0.4 });
 const blueMat = new THREE.MeshStandardMaterial({ color: 0x0088ff, transparent: true, opacity: 0.9, emissive: 0x0088ff, emissiveIntensity: 0.5, metalness: 0.3, roughness: 0.4 });
 const redMat = new THREE.MeshStandardMaterial({ color: 0xff0000, transparent: true, opacity: 0.9, emissive: 0xff0000, emissiveIntensity: 0.5, metalness: 0.3, roughness: 0.4 });
 const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.9, emissive: 0xffffff, emissiveIntensity: 0.5, metalness: 0.3, roughness: 0.4 });
 
 // Add lights for 3D visibility
 const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
 addressScene.add(ambientLight);
 const pointLight = new THREE.PointLight(0xffffff, 1.2, 100);
 pointLight.position.set(0, 0, 10);
 addressScene.add(pointLight);
 
 // Add additional lights for better visibility
 const pointLight2 = new THREE.PointLight(0xffffff, 0.8, 100);
 pointLight2.position.set(15, 15, 15);
 addressScene.add(pointLight2);
 
 const pointLight3 = new THREE.PointLight(0xffffff, 0.8, 100);
 pointLight3.position.set(-15, -15, -15);
 addressScene.add(pointLight3);
 
 // Grid configuration - FULL 26x26x26 CUBE (A-Z columns)
 const gridSpacing = 2.5;
 const gridSize = { cols: 26, rows: 26, depth: 26 }; // FULL CUBE: 17,576 positions (26x26x26)
 const gridPositions = [];
 
 // Pre-calculate all grid positions - TRULY centered around origin
 for (let col = 0; col < gridSize.cols; col++) {
 for (let row = 0; row < gridSize.rows; row++) {
 for (let depth = 0; depth < gridSize.depth; depth++) {
 // Center calculation: use middle of range as origin
 const x = (col - (gridSize.cols - 1) / 2) * gridSpacing;
 const y = (row - (gridSize.rows - 1) / 2) * gridSpacing;
 const z = (depth - (gridSize.depth - 1) / 2) * gridSpacing * 1.0; // Equal spacing for cube shape
 
 gridPositions.push({
 col: col,
 row: row,
 depth: depth,
 x: x,
 y: y,
 z: z
 });
 }
 }
 }
 
 console.log('?? Grid bounds:');
 console.log(' X range:', (0 - gridSize.cols / 2 + 0.5) * gridSpacing, 'to', (gridSize.cols - 1 - gridSize.cols / 2 + 0.5) * gridSpacing);
 console.log(' Y range:', (0 - gridSize.rows / 2 + 0.5) * gridSpacing, 'to', (gridSize.rows - 1 - gridSize.rows / 2 + 0.5) * gridSpacing);
 console.log(' Z range: 0 to', (gridSize.depth - 1) * gridSpacing * 2.5);
 console.log('?? Sample positions:');
 console.log(' Corner (0,0,0):', gridPositions[0]);
 console.log(' Center (~10,6,7):', gridPositions[Math.floor(gridPositions.length / 2)]);
 console.log(' Far (19,11,14):', gridPositions[gridPositions.length - 1]);
 
 // Shuffle ONLY within each depth layer for organized appearance
 const layers = {};
 gridPositions.forEach(pos => {
 if (!layers[pos.depth]) layers[pos.depth] = [];
 layers[pos.depth].push(pos);
 });
 
 // Shuffle each layer
 Object.values(layers).forEach(layer => {
 for (let i = layer.length - 1; i > 0; i--) {
 const j = Math.floor(Math.random() * (i + 1));
 [layer[i], layer[j]] = [layer[j], layer[i]];
 }
 });
 
 // Rebuild gridPositions in depth order
 gridPositions.length = 0;
 for (let depth = 0; depth < gridSize.depth; depth++) {
 if (layers[depth]) {
 gridPositions.push(...layers[depth]);
 }
 }
 
 const maxZ = (gridSize.depth - 1) * gridSpacing * 2.5;
 const centerZ = 0; // Grid is now centered at origin
 
 console.log('?? Grid setup:', gridSize, 'Total positions:', gridPositions.length);
 console.log('?? Grid centered at origin (0, 0, 0)');
 console.log('?? X range:', -(gridSize.cols - 1) / 2 * gridSpacing, 'to', (gridSize.cols - 1) / 2 * gridSpacing);
 console.log('?? Y range:', -(gridSize.rows - 1) / 2 * gridSpacing, 'to', (gridSize.rows - 1) / 2 * gridSpacing);
 console.log('?? Z range:', -maxZ / 2, 'to', maxZ / 2);
 
 // Add visual debug helpers
 const helpers = new THREE.Group();
 
 // Add axes helper at origin
 const axesHelper = new THREE.AxesHelper(30);
 helpers.add(axesHelper);
 
 // Add grid at z=0
 const gridHelper = new THREE.GridHelper(
 gridSize.cols * gridSpacing, 
 gridSize.cols, 
 0x00ff00, 
 0x004400
 );
 gridHelper.rotation.x = Math.PI / 2;
 helpers.add(gridHelper);
 
 // Add bounding box visualization - centered properly (CUBE shape with GREEN glow)
 const depthRange = (gridSize.depth - 1) * gridSpacing * 1.0; // Equal depth
 const boxGeo = new THREE.BoxGeometry(
 gridSize.cols * gridSpacing,
 gridSize.rows * gridSpacing,
 depthRange
 );
 const boxMat = new THREE.MeshBasicMaterial({ 
 color: 0x00ff00, // GREEN not cyan
 wireframe: true, 
 transparent: true, 
 opacity: 0.6 
 });
 const boundingBox = new THREE.Mesh(boxGeo, boxMat);
 boundingBox.position.set(0, 0, 0); // Centered at origin
 helpers.add(boundingBox);
 
 // Add markers at each depth layer
 for (let d = 0; d < gridSize.depth; d++) {
 const markerGeo = new THREE.PlaneGeometry(0.5, 0.5);
 const markerMat = new THREE.MeshBasicMaterial({ 
 color: d === 0 ? 0xff0000 : 0x00ff00, // GREEN markers
 transparent: true,
 opacity: 0.6
 });
 const marker = new THREE.Mesh(markerGeo, markerMat);
 const markerZ = (d - (gridSize.depth - 1) / 2) * gridSpacing * 1.0; // Match equal Z
 marker.position.set(
 -gridSize.cols * gridSpacing / 2 + 1,
 gridSize.rows * gridSpacing / 2 - 1,
 markerZ
 );
 helpers.add(marker);
 }
 
 // Start debug helpers hidden - they'll glitch in
 helpers.visible = false;
 addressScene.add(helpers);
 addressScene.userData.debugHelpers = helpers;
 
 let gridIndex = 0;
 
 // Spawn addresses gradually
 let spawnTimer = 0;
 const spawnInterval = 0.05;
 
 window.mainClock = window.mainClock || new THREE.Clock();
 const clock = window.mainClock;
 let sequenceTime = 0;
 let cameraRotating = false;
 
 // Camera will look at origin - grid is centered
 const gridCenter = new THREE.Vector3(0, 0, 0);
 const actualCenterX = 0;
 const actualCenterY = 0;
 const actualCenterZ = 0;
 
 // Position camera to see the ENTIRE grid PERFECTLY CENTERED
 // Grid is 26x26x26 cubes, spacing 2.5 = 65x65x65 units, centered at origin
 addressCamera.position.set(0, 0, -120); // Back on Z axis, centered on X and Y for wide view
 addressCamera.lookAt(0, 0, 0); // Look directly at origin
 addressCamera.updateProjectionMatrix();
 
 console.log('?? Camera at (0, 0, -120) looking at origin (0, 0, 0)');
 console.log('?? Grid: 26x26x26 cube, 65x65x65 units, centered at (0,0,0)');
 console.log('?? Camera FOV:', addressCamera.fov, 'Aspect:', addressCamera.aspect);
 console.log('?? Grid should be PERFECTLY CENTERED in view');
 console.log('?? Camera Animation Flow:');
 console.log(' 0-8s: Fill 2D plane at z=-120');
 console.log(' 8-10s: Rumble at z=-120');
 console.log(' 10-14s: Dolly forward to z=-20 while filling depth');
 console.log(' 14-20s: Rotate + dolly back to z=-80');
 console.log(' 20s+: Continue orbiting while cubes appear');
 
 // Chime function for cube burst
 function playChimeForCube(index) {
 if (!audioCtx) return;
 try {
 const osc = audioCtx.createOscillator();
 const gain = audioCtx.createGain();
 
 const baseFreq = 800;
 const freq = baseFreq + (index % 12) * 50;
 osc.frequency.value = freq;
 osc.type = 'sine';
 
 gain.gain.setValueAtTime(0.03, audioCtx.currentTime);
 gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
 
 osc.connect(gain);
 gain.connect(audioCtx.destination);
 osc.start(audioCtx.currentTime);
 osc.stop(audioCtx.currentTime + 0.3);
 } catch (err) {
 // Silently fail if audio context not available
 }
 }
 
 function animateAddresses() {
 const delta = clock.getDelta();
 sequenceTime += delta;
 spawnTimer += delta;
 
 // Debug log every second with camera position
 if (Math.floor(sequenceTime) !== Math.floor(sequenceTime - delta)) {
 try {
 console.log(`?? ${sequenceTime.toFixed(1)}s | Addresses: ${addresses.length}, Cubes: ${cubes.length} | Cam: (${addressCamera.position.x.toFixed(1)}, ${addressCamera.position.y.toFixed(1)}, ${addressCamera.position.z.toFixed(1)})`);
 } catch (_) {}
 }
 
 // Fade debug helpers after 20s
 if (sequenceTime > 20 && addressScene.userData.debugHelpers) {
 addressScene.userData.debugHelpers.visible = false;
 }
 
 // Phase 1: Spawn 2D addresses on grid (0-8s) - Fill the 2D plane ONLY
 if (sequenceTime < 8 && spawnTimer > spawnInterval) {
 spawnTimer = 0;
 
 // Find next depth=0 position
 while (gridIndex < gridPositions.length && gridPositions[gridIndex].depth !== 0) {
 gridIndex++;
 }
 
 if (gridIndex < gridPositions.length) {
 const pos = gridPositions[gridIndex];
 const sprite = createAddressSprite(pos.col, pos.row, 0, false);
 sprite.position.set(pos.x, pos.y, pos.z); // Use pos.z from grid calculation
 sprite.userData = { ...pos, isCube: false, gridX: pos.col, gridY: pos.row, gridZ: 0, depth: 0 };
 addressScene.add(sprite);
 addresses.push(sprite);
 
 if (addresses.length === 1) {
 console.log('? First 2D address spawned:', { x: pos.x.toFixed(2), y: pos.y.toFixed(2), z: pos.z.toFixed(2), text: `${String.fromCharCode(65 + pos.col)}${pos.row + 1}` });
 console.log('?? Camera is at:', addressCamera.position);
 console.log('?? Camera is looking at: (0, 0, 0)');
 }
 if (addresses.length <= 5) {
 console.log(`?? Address #${addresses.length} at (${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})`);
 }
 gridIndex++;
 }
 }
 
 // No rotation for addresses - they just float in place
 // (rotation removed per user request)
 
 // Phase 1.5: Static pause showing 2D grid (8-10s) with RUMBLE before expansion
 if (sequenceTime >= 8 && sequenceTime < 10) {
 if (!addressScene.userData.staticPauseStarted) {
 addressScene.userData.staticPauseStarted = true;
 console.log('?? Static pause - showing 2D grid, building tension');
 
 // Glitch in debug helpers
 let glitchCount = 0;
 const glitchInterval = setInterval(() => {
 if (addressScene.userData.debugHelpers) {
 addressScene.userData.debugHelpers.visible = !addressScene.userData.debugHelpers.visible;
 glitchCount++;
 if (glitchCount > 6) {
 addressScene.userData.debugHelpers.visible = true;
 clearInterval(glitchInterval);
 }
 }
 }, 100);
 }
 
 // RUMBLE effect BEFORE Z expansion (9-10s) - building anticipation
 if (sequenceTime >= 9 && sequenceTime < 10) {
 const rumbleIntensity = (sequenceTime - 9) * 1.2; // Stronger rumble
 addressCamera.position.x = Math.sin(sequenceTime * 25) * rumbleIntensity;
 addressCamera.position.y = Math.cos(sequenceTime * 20) * rumbleIntensity;
 addressCamera.position.z = -120; // Pulled back for 26x26x26 grid
 addressCamera.lookAt(0, 0, 0);
 
 if (!addressScene.userData.rumbleLogged) {
 console.log('?? RUMBLE starting - preparing for Z expansion!');
 addressScene.userData.rumbleLogged = true;
 }
 } else {
 // Keep camera centered during first part of pause
 addressCamera.position.set(0, 0, -120); // Pulled back for 26x26x26 grid
 addressCamera.lookAt(0, 0, 0);
 }
 }
 
 // Phase 2: Extend into 3D (10-14s) - NO dolly until array fully constructed
 if (sequenceTime >= 10 && sequenceTime < 14) {
 if (addressPhase === 0) {
 addressPhase = 1;
 
 // Create depth spawn queue - all positions with depth > 0
 addressScene.userData.depthQueue = gridPositions.filter(p => p.depth > 0);
 console.log('?? Extending to 3D - depth queue:', addressScene.userData.depthQueue.length, 'positions');
 console.log('?? Depth range:', Math.min(...addressScene.userData.depthQueue.map(p => p.depth)), 
 'to', Math.max(...addressScene.userData.depthQueue.map(p => p.depth)));
console.log('?? Camera will NOT dolly until depth fully constructed');
 }
 
 // Keep camera static while depth fills in
 addressCamera.position.set(0, 0, -120);
 addressCamera.lookAt(0, 0, 0);
 
 // Spawn depth layers rapidly using TEXT SPRITES (keep camera static during this phase)
 const remaining = (addressScene.userData.depthQueue && addressScene.userData.depthQueue.length) || 0;
 const timeLeft = Math.max(0.05, 14 - sequenceTime);
 const needPerSec = remaining / timeLeft;
 const targetPerFrame = Math.min(1200, Math.ceil(needPerSec * delta));
 for (let i = 0; i < targetPerFrame && addressScene.userData.depthQueue && addressScene.userData.depthQueue.length > 0; i++) {
 const pos = addressScene.userData.depthQueue.shift();
 const sprite = createAddressSprite(pos.col, pos.row, pos.depth, true);
  sprite.position.set(pos.x, pos.y, pos.z);
 sprite.userData = { ...pos, isCube: false, gridX: pos.col, gridY: pos.row, gridZ: pos.depth };
 addressScene.add(sprite);
 addresses.push(sprite);
 }

 // Mark completion when queue is empty
 if (addressScene.userData.depthQueue && addressScene.userData.depthQueue.length === 0 && !addressScene.userData.depthComplete) {
  addressScene.userData.depthComplete = true;
  addressScene.userData.depthCompleteTime = sequenceTime;
  addressScene.userData.rotationStartTime = sequenceTime; // start rotation now
  console.log('âœ… Depth construction complete. Starting rotation+dolly window.');
  try { SceneManager.setPhase('cellAddressesReady'); } catch (e) {}
 }
 }
 
 // Phase 2.5 (dynamic): Camera ROTATES while DOLLYING BACK to reveal LATTICE CUBE (runs 6s after depth complete)
 if (addressScene.userData.rotationStartTime !== undefined) {
  // Do not rotate/dolly during sprite expansion; wait until after depth complete by delay window
  const rotAge = sequenceTime - addressScene.userData.rotationStartTime;
  if (rotAge <= 6) {
   // Keep camera fixed during this window
   addressCamera.position.set(0, 0, -120);
   addressCamera.lookAt(0, 0, 0);
  } else {
 if (!addressScene.userData.rotationStarted) {
 addressScene.userData.rotationStarted = true;
    addressScene.userData.rotationRunStart = sequenceTime;
    console.log('?? Starting camera rotation + dolly back (post-sprite)');
   }
   const runAge = sequenceTime - (addressScene.userData.rotationRunStart || sequenceTime);
   const rotProgress = Math.min(1, runAge / 6); // 6s rotation
   const angle = rotProgress * Math.PI * 0.75; // 135 degrees
   const startZ = -120;
   const endZ = -80;
 const orbitRadius = 90;
 addressCamera.position.x = Math.sin(angle) * orbitRadius;
 addressCamera.position.y = THREE.MathUtils.lerp(0, 45, rotProgress);
   addressCamera.position.z = Math.cos(angle) * orbitRadius + THREE.MathUtils.lerp(startZ, endZ, rotProgress);
   addressCamera.lookAt(0, 0, 0);
  }
 }
 
 // Phase 3 (dynamic): POP into GREEN cubes immediately after rotation window completes
 if (!cubePhase && addressScene.userData.rotationStartTime !== undefined) {
  const rotAge = sequenceTime - addressScene.userData.rotationStartTime;
  if (rotAge >= 6) {
   cubePhase = true;
   addressScene.userData.cubePhaseStartTime = sequenceTime;
   console.log('?? LATTICE REVEALED! Now bursting into GREEN cubes (dynamic)!');
   // Transform any remaining text addresses to green cubes
 for (let i = addresses.length - 1; i >= 0; i--) {
 const addr = addresses[i];
    const pos = addr.position.clone();
 const mesh = new THREE.Mesh(cubeGeo, greenMat.clone());
    mesh.position.copy(pos);
    mesh.scale.set(1.0, 1.0, 1.0);
    mesh.userData = { ...addr.userData, isCube: true, isGreen: true, birthTime: sequenceTime };
 addressScene.add(mesh);
 cubes.push(mesh);
    addressScene.remove(addr);
    if (addr.material && addr.material.map) addr.material.map.dispose();
    if (addr.material) addr.material.dispose();
    // Assign target shape for later glitch
    mesh.userData.targetShape = (i % 3);
   }
   addresses.length = 0;
   // Schedule a slight pop on existing cubes
   cubes.forEach((c, i) => {
    if (!c.userData) c.userData = {};
    if (!c.userData.popScheduled) {
     c.userData.popScheduled = true;
     c.userData.popTime = sequenceTime + (i * 0.003);
    }
    if (c.userData.targetShape === undefined) c.userData.targetShape = (i % 3);
   });
  }
 }
 
 // Execute POP transformations on cubes for 4s after cubePhase start
 if (cubePhase && addressScene.userData.cubePhaseStartTime !== undefined) {
  const popAge = sequenceTime - addressScene.userData.cubePhaseStartTime;
  if (popAge < 4) {
   cubes.forEach((cube, i) => {
    if (!cube.userData || !cube.userData.popTime) return;
    if (sequenceTime >= cube.userData.popTime && !cube.userData.poppedOnce) {
     cube.userData.poppedOnce = true;
     // burst scale
     cube.scale.set(0.05, 0.05, 0.05);
     cube.userData.birthTime = sequenceTime;
     if (cubes.length % 50 === 0) playChimeForCube(i);
    }
    if (cube.userData.poppedOnce) {
     const age = sequenceTime - cube.userData.birthTime;
     if (age < 0.3) {
      const progress = age / 0.3;
      const overshoot = 1.3;
      const targetScale = progress < 0.5 ? THREE.MathUtils.lerp(0.05, overshoot, progress * 2) : THREE.MathUtils.lerp(overshoot, 1.0, (progress - 0.5) * 2);
      cube.scale.setScalar(targetScale);
     } else if (age < 0.35 && cube.scale.x !== 1.0) {
      cube.scale.setScalar(1.0);
     }
    }
   });
 }
 }
 
 // CLEANUP: Force remove ALL remaining text addresses at 24s
 if (sequenceTime >= 24 && sequenceTime < 24.1 && addresses.length > 0) {
 console.log('??? CLEANUP: Removing', addresses.length, 'residual text addresses');
 for (let i = addresses.length - 1; i >= 0; i--) {
 addressScene.remove(addresses[i]);
 if (addresses[i].material && addresses[i].material.map) {
 addresses[i].material.map.dispose();
 }
 if (addresses[i].material) {
 addresses[i].material.dispose();
 }
 }
 addresses.length = 0; // Clear array
 console.log('? All text addresses cleared');
 }
 
 // Animate green cube pop-in with burst (20s-26s)
 if (sequenceTime >= 20 && sequenceTime < 26) {
 cubes.forEach((cube, i) => {
 if (!cube.userData.isGreen) return; // Only animate green cubes
 
 const age = sequenceTime - cube.userData.birthTime;
 
 // Quick pop-in animation (0-0.3s)
 if (age < 0.3) {
 // Burst scale: overshoot then settle
 const progress = age / 0.3;
 const overshoot = 1.3; // Peak size
 let targetScale;
 if (progress < 0.5) {
 targetScale = THREE.MathUtils.lerp(0.05, overshoot, progress * 2);
 } else {
 targetScale = THREE.MathUtils.lerp(overshoot, 1.0, (progress - 0.5) * 2);
 }
 cube.scale.setScalar(targetScale);
 
 // Bright burst illumination
 if (cube.material) {
 const intensity = Math.sin(progress * Math.PI) * 3.0;
 cube.material.emissiveIntensity = 0.5 + intensity;
 }
 } else if (age < 0.35 && cube.scale.x !== 1.0) {
 // Settle to final size
 cube.scale.setScalar(1.0);
 if (cube.material) {
 cube.material.emissiveIntensity = 0.5;
 }
 }
 });
 }
 
 // Phase 4 (dynamic): GREEN cubes glitch into RGB shapes ~6-10s after cubePhase
 if (addressScene.userData.cubePhaseStartTime !== undefined) {
  const phaseAge = sequenceTime - addressScene.userData.cubePhaseStartTime;
  if (phaseAge >= 6 && phaseAge < 10) {
 cubes.forEach((cube, i) => {
 if (cube.userData.isGreen && !cube.userData.glitchStarted) {
 cube.userData.glitchStarted = true;
 cube.userData.glitchTime = sequenceTime + (i * 0.002); // Faster stagger glitches
 }
 
 if (cube.userData.glitchStarted && !cube.userData.hasTransformed && sequenceTime >= cube.userData.glitchTime) {
 cube.userData.hasTransformed = true;
 
 // Select shape and color based on pre-assigned targetShape
 let geo, mat, colorName, shapeName;
 if (cube.userData.targetShape === 0) {
 geo = pyramidGeo;
 mat = yellowMat.clone();
 colorName = 'yellow';
 shapeName = 'pyramid';
 } else if (cube.userData.targetShape === 1) {
 geo = cubeGeo;
 mat = blueMat.clone();
 colorName = 'blue';
 shapeName = 'cube';
 } else {
 geo = sphereGeo;
 mat = redMat.clone();
 colorName = 'red';
 shapeName = 'sphere';
 }
 // Replace mesh
 const pos = cube.position.clone();
 const userData = { ...cube.userData };
 
 addressScene.remove(cube);
 if (cube.geometry) cube.geometry.dispose();
 if (cube.material) cube.material.dispose();
 
 const newMesh = new THREE.Mesh(geo, mat);
 newMesh.position.copy(pos);
 newMesh.scale.set(1.0, 1.0, 1.0); // Always start at normal scale
 newMesh.userData = {
 ...userData,
 isGreen: false,
 currentColor: colorName,
 shapeType: shapeName,
 glitchTransformTime: sequenceTime
 };
 
 addressScene.add(newMesh);
 
 // Replace in cubes array
 const cubeIndex = cubes.indexOf(cube);
 if (cubeIndex !== -1) {
 cubes[cubeIndex] = newMesh;
 }
 }
 });
 }
 
 // Animate glitch transformation (26s-30s)
 if (sequenceTime >= 26 && sequenceTime < 30) {
 cubes.forEach((cube) => {
 if (cube.userData.glitchTransformTime) {
 const glitchAge = sequenceTime - cube.userData.glitchTransformTime;
 
 if (glitchAge < 0.2) {
 // Quick stretch/distort glitch
 const glitchProgress = glitchAge / 0.2;
 const distort = Math.sin(glitchProgress * Math.PI * 4) * 0.3;
 cube.scale.x = 1.0 + distort;
 cube.scale.y = 1.0 - distort * 0.5;
 cube.scale.z = 1.0 + distort * 0.5;
 
 // Flash emissive
 if (cube.material) {
 cube.material.emissiveIntensity = 0.5 + Math.sin(glitchProgress * Math.PI) * 2.0;
 }
 } else if (glitchAge < 0.25 && cube.scale.x !== 1.0) {
 // Snap to final shape
 cube.scale.set(1.0, 1.0, 1.0);
 if (cube.material) {
 cube.material.emissiveIntensity = 0.5;
 }
 }
 }
 });
 }
 
 // Draw dotted lines between RGB cubes (forming cube edges) ONCE (30s)
 if (sequenceTime >= 30 && !addressScene.userData.linesCreated) {
 addressScene.userData.linesCreated = true;
 addressScene.userData.connectionLines = [];
 console.log('?? Creating procedural connection lines...');
 
 // Build grid lookup for immediate neighbors
 const gridMap = new Map();
 cubes.forEach(cube => {
 if (cube.userData.gridX !== undefined) {
 const key = `${cube.userData.gridX},${cube.userData.gridY},${cube.userData.gridZ}`;
 gridMap.set(key, cube);
 }
 });
 
 // Track connections to avoid duplicates
 const connections = new Set();
 let lineCount = 0;
 
 // Draw lines to immediate neighbors for RGB cubes (ONCE)
 cubes.forEach(cube => {
 if (cube.userData.gridX !== undefined && cube.userData.currentColor && cube.userData.hasTransformed) {
 const gx = cube.userData.gridX;
 const gy = cube.userData.gridY;
 const gz = cube.userData.gridZ;
 
 // Check only positive direction neighbors to avoid duplicates (right, up, forward)
 const neighbors = [
 { key: `${gx+1},${gy},${gz}`, axis: 'x' },
 { key: `${gx},${gy+1},${gz}`, axis: 'y' },
 { key: `${gx},${gy},${gz+1}`, axis: 'z' }
 ];
 
 neighbors.forEach(neighbor => {
 const neighborCube = gridMap.get(neighbor.key);
 if (neighborCube && neighborCube.userData.currentColor && neighborCube.userData.hasTransformed) {
 const connectionKey = `${cube.userData.gridX},${cube.userData.gridY},${cube.userData.gridZ}-${neighborCube.userData.gridX},${neighborCube.userData.gridY},${neighborCube.userData.gridZ}`;
 if (!connections.has(connectionKey)) {
 connections.add(connectionKey);
 
 // Use average color of both cubes
 let lineColor;
 if (cube.userData.currentColor === 'yellow') lineColor = 0xffff00;
 else if (cube.userData.currentColor === 'blue') lineColor = 0x0088ff;
 else if (cube.userData.currentColor === 'red') lineColor = 0xff0000;
 else lineColor = 0x00ff00;
 
 const points = [cube.position, neighborCube.position];
 const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
 const lineMat = new THREE.LineDashedMaterial({
 color: lineColor,
 dashSize: 0.12,
 gapSize: 0.08,
 transparent: true,
 opacity: 0.5
 });
 const line = new THREE.Line(lineGeo, lineMat);
 line.computeLineDistances();
 addressScene.add(line);
 addressScene.userData.connectionLines.push(line);
 lineCount++;
 }
 }
 });
 }
 });
 console.log(`? Created ${lineCount} connection lines (procedural, once)`);
 }
 
 // Continue camera rotation after initial rotation (but stop during white room)
 if (sequenceTime >= 20 && sequenceTime < 50) {
 const orbitTime = sequenceTime - 20;
 const orbitRadius = 90; // Larger radius for 26x26x26 grid
 addressCamera.position.x = Math.cos(orbitTime * 0.15) * orbitRadius;
 addressCamera.position.z = Math.sin(orbitTime * 0.15) * orbitRadius;
 addressCamera.position.y = 25 + Math.sin(orbitTime * 0.08) * 10;
 addressCamera.lookAt(0, 0, 0);
 }
 
 // Apply mouse look in white room
 if (isMouseLookActive && sequenceTime > 55) {
 // Apply rotation to camera
 const direction = new THREE.Vector3();
 direction.x = Math.sin(targetRotationY) * Math.cos(targetRotationX);
 direction.y = Math.sin(targetRotationX);
 direction.z = Math.cos(targetRotationY) * Math.cos(targetRotationX);
 direction.normalize();
 
 const lookAtPoint = new THREE.Vector3().addVectors(
 addressCamera.position,
 direction.multiplyScalar(10)
 );
 addressCamera.lookAt(lookAtPoint);
 
 if (Math.floor(sequenceTime) % 3 === 0 && Math.floor(sequenceTime) !== Math.floor(sequenceTime - delta)) {
 console.log(`??? Mouse look active - rotX: ${targetRotationX.toFixed(2)}, rotY: ${targetRotationY.toFixed(2)}`);
 }
 } else if (sequenceTime >= 55 && !isMouseLookActive) {
 // Point at black hole when not actively looking
 addressCamera.lookAt(0, 0, 0);
 }
 
 // Phase 5: Transform RGB shapes back to white cubes (36-40s)
 if (sequenceTime >= 36 && sequenceTime < 40) {
 cubes.forEach((cube, i) => {
 if (cube.userData.hasTransformed && !cube.userData.zapToWhite) {
 cube.userData.zapToWhite = true;
 
 // Quick zap animation
 const originalScale = { x: cube.scale.x, y: cube.scale.y, z: cube.scale.z };
 cube.scale.multiplyScalar(1.5);
 
 setTimeout(() => {
 const pos = cube.position.clone();
 const userData = { ...cube.userData };
 
 addressScene.remove(cube);
 const whiteCube = new THREE.Mesh(cubeGeo, whiteMat.clone());
 whiteCube.position.copy(pos);
 whiteCube.scale.set(originalScale.x, originalScale.y, originalScale.z);
 whiteCube.userData = userData;
 whiteCube.userData.isWhite = true;
 addressScene.add(whiteCube);
 cubes[i] = whiteCube;
 }, 100);
 }
 });
 }
 
 // Phase 6: Collapse cubes to center - NO rotation
 if (sequenceTime >= 40 && sequenceTime < 44) {
 const pullStrength = (sequenceTime - 40) / 4;
 cubes.forEach(cube => {
 cube.position.x = THREE.MathUtils.lerp(cube.position.x, 0, delta * pullStrength * 2);
 cube.position.y = THREE.MathUtils.lerp(cube.position.y, 0, delta * pullStrength * 2);
 cube.position.z = THREE.MathUtils.lerp(cube.position.z, 0, delta * pullStrength * 2);
 });
 }
 
 // Phase 7: Merge into single white rounded cube with bloom (44-50s)
 if (sequenceTime >= 44 && sequenceTime < 50) {
 const whiteness = Math.min(1, (sequenceTime - 44) / 3);
 addressBloom.strength = 1.2 + whiteness * 2.5; // Increase bloom more
 
 cubes.forEach((cube, i) => {
 if (cube.material) {
 // Fade to white
 cube.material.color.r = 1;
 cube.material.color.g = 1;
 cube.material.color.b = 1;
 cube.material.emissive.r = 1;
 cube.material.emissive.g = 1;
 cube.material.emissive.b = 1;
 cube.material.emissiveIntensity = 0.5 + whiteness * 1.0;
 
 // Shrink all but the center mass
 if (i > 15) {
 cube.scale.multiplyScalar(0.96);
 cube.material.opacity *= 0.95;
 } else {
 // First cubes grow MUCH LARGER
 const growth = 1 + (sequenceTime - 44) * 0.8;
 cube.scale.setScalar(growth);
 }
 }
 });
 }
 
 // Phase 8: Expand into white room interior (50-55s)
 if (sequenceTime >= 50 && sequenceTime < 55) {
 if (!addressScene.userData.roomCreated) {
 addressScene.userData.roomCreated = true;
 console.log('?? Creating FPS white room interior with rounded corners and internal lighting');
 
 // Remove all connection lines
 if (addressScene.userData.connectionLines) {
 addressScene.userData.connectionLines.forEach(line => {
 addressScene.remove(line);
 if (line.geometry) line.geometry.dispose();
 if (line.material) line.material.dispose();
 });
 addressScene.userData.connectionLines = [];
 console.log('??? Connection lines removed for white room');
 }
 
 addressScene.userData.blackCubeSpawnTimer = 0;
 addressScene.userData.blackCubes = [];
 
 // Create white room interior with rounded corners - DIMLY LIT
 const roomSize = 50;
 const roomRadius = 4;
 const roomGeo = new RoundedBoxGeometry(roomSize, roomSize, roomSize, 16, roomRadius);
 const roomMat = new THREE.MeshStandardMaterial({
 color: 0xcccccc, // Slightly gray
 side: THREE.BackSide,
 roughness: 0.9,
 metalness: 0.05,
 emissive: 0x333333, // Very dim emissive
 emissiveIntensity: 0.05 // Very low
 });
 const room = new THREE.Mesh(roomGeo, roomMat);
 addressScene.add(room);
 addressScene.userData.roomMesh = room; // Store reference
 
 // Add MINIMAL internal room lighting - mostly dark
 const roomLight1 = new THREE.PointLight(0xffffff, 0.2, 40);
 roomLight1.position.set(0, 15, 0);
 addressScene.add(roomLight1);
 
 const roomLight2 = new THREE.PointLight(0xffffff, 0.2, 40);
 roomLight2.position.set(0, -15, 0);
 addressScene.add(roomLight2);
 
 console.log('? White room created with DIM lighting');
 
 // Further reduce ambient lighting to let black hole dominate
 ambientLight.intensity = 0.1;
 pointLight.intensity = 0.1;
 pointLight2.intensity = 0.2;
 pointLight3.intensity = 0.2;
 
 console.log('?? Room created - dimming ambient lights for black hole visibility');
 
 console.log('? White room created with internal lighting');
 }
 
 // Move camera inside - FPS position, initially pointing AT the black hole
 if (!addressScene.userData.cameraMovingToRoom) {
 addressScene.userData.cameraMovingToRoom = true;
 console.log('?? Camera moving into white room, will point at black hole at (0, 0, 0)');
 }
 
 const moveProgress = (sequenceTime - 50) / 5;
 addressCamera.position.x = THREE.MathUtils.lerp(12, 0, moveProgress);
 addressCamera.position.y = THREE.MathUtils.lerp(10, 2, moveProgress);
 addressCamera.position.z = THREE.MathUtils.lerp(20, 15, moveProgress);
 
 // Always point at black hole center during this phase
 addressCamera.lookAt(0, 0, 0);
 
 if (Math.floor(sequenceTime) % 2 === 0 && Math.floor(sequenceTime) !== Math.floor(sequenceTime - delta)) {
 console.log(`?? Camera pos: (${addressCamera.position.x.toFixed(1)}, ${addressCamera.position.y.toFixed(1)}, ${addressCamera.position.z.toFixed(1)}) -> looking at (0, 0, 0)`);
 }
 
 addressScene.userData.whiteRoomCreated = true;
 }
 
 // Phase 9: Create 3D black hole at center (55s+)
 if (sequenceTime >= 55 && !addressScene.userData.blackHoleCreated) {
 addressScene.userData.blackHoleCreated = true;
 console.log('??? Creating 3D black hole sphere at center');
 
 // Voxelized black hole - dark cube sphere (MORE visible)
 const voxelSize = 0.4;
 const voxelGeo = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);
 const blackVoxelMat = new THREE.MeshStandardMaterial({
 color: 0x222222, // More visible gray
 emissive: 0x110000, // Slight red emissive
 emissiveIntensity: 0.3,
 roughness: 0.9,
 metalness: 0.1,
 transparent: false
 });
 
 const voxelSphere = new THREE.Group();
 const baseRadius = 3.0; // Larger
 const voxelCount = 400; // More voxels
 
 for (let i = 0; i < voxelCount; i++) {
 const phi = Math.acos(-1 + (2 * i) / voxelCount);
 const theta = Math.sqrt(voxelCount * Math.PI) * phi;
 
 const x = baseRadius * Math.cos(theta) * Math.sin(phi);
 const y = baseRadius * Math.sin(theta) * Math.sin(phi);
 const z = baseRadius * Math.cos(phi);
 
 const voxel = new THREE.Mesh(voxelGeo, blackVoxelMat.clone());
 voxel.position.set(x, y, z);
 voxel.lookAt(0, 0, 0);
 voxel.userData.baseRadius = baseRadius;
 voxel.userData.phi = phi;
 voxel.userData.theta = theta;
 voxelSphere.add(voxel);
 }
 
 addressScene.add(voxelSphere);
 addressScene.userData.voxelSphere = voxelSphere;
 addressScene.userData.voxelSpherePhase = 0;
 
 // Event horizon glow - EXTREMELY bright ring
 const ringGeo = new THREE.TorusGeometry(4.0, 0.5, 16, 100);
 const ringMat = new THREE.MeshBasicMaterial({
 color: 0xff4400,
 transparent: false,
 opacity: 1.0
 });
 const eventHorizon = new THREE.Mesh(ringGeo, ringMat);
 eventHorizon.position.set(0, 0, 0);
 eventHorizon.rotation.x = Math.PI / 2;
 addressScene.add(eventHorizon);
 addressScene.userData.eventHorizon = eventHorizon;
 
 // Add VERY strong point lights at black hole for maximum visibility
 const blackHoleLight1 = new THREE.PointLight(0xff2200, 10.0, 30);
 blackHoleLight1.position.set(0, 0, 0);
 addressScene.add(blackHoleLight1);
 
 const blackHoleLight2 = new THREE.PointLight(0xff6600, 8.0, 25);
 blackHoleLight2.position.set(0, 5, 0);
 addressScene.add(blackHoleLight2);
 
 const blackHoleLight3 = new THREE.PointLight(0xff8800, 6.0, 20);
 blackHoleLight3.position.set(5, 0, 0);
 addressScene.add(blackHoleLight3);
 
 addressScene.userData.blackHoleLight = blackHoleLight1;
 
 console.log('??? Black hole created at (0, 0, 0)');
 console.log('??? Black hole lights: L1=' + blackHoleLight1.intensity + ', L2=' + blackHoleLight2.intensity + ', L3=' + blackHoleLight3.intensity);
 console.log('??? Ambient light:', ambientLight.intensity);
 
 // BLACK CORE - Central black voxel sphere with negative pulsing effect
 const blackCoreGeo = new THREE.BoxGeometry(0.25, 0.25, 0.25);
 const blackCoreMat = new THREE.MeshBasicMaterial({
 color: 0x000000,
 transparent: true,
 opacity: 1.0
 });
 
 const blackCore = new THREE.Group();
 const coreRadius = 1.5; // Smaller than outer sphere
 const coreVoxelCount = 200;
 
 for (let i = 0; i < coreVoxelCount; i++) {
 const phi = Math.acos(-1 + (2 * i) / coreVoxelCount);
 const theta = Math.sqrt(coreVoxelCount * Math.PI) * phi;
 
 const x = coreRadius * Math.cos(theta) * Math.sin(phi);
 const y = coreRadius * Math.sin(theta) * Math.sin(phi);
 const z = coreRadius * Math.cos(phi);
 
 const voxel = new THREE.Mesh(blackCoreGeo, blackCoreMat.clone());
 voxel.position.set(x, y, z);
 voxel.lookAt(0, 0, 0);
 voxel.userData.baseRadius = coreRadius;
 voxel.userData.phi = phi;
 voxel.userData.theta = theta;
 voxel.renderOrder = 2000; // Individual voxels render on top
 voxel.material.depthTest = false; // Always visible
 voxel.material.depthWrite = false;
 blackCore.add(voxel);
 }
 
 blackCore.renderOrder = 2000; // Render on top of everything
 addressScene.add(blackCore);
 addressScene.userData.blackCore = blackCore;
 console.log('??? Black core created with renderOrder=2000, depthTest=false');
 addressScene.userData.blackCorePhase = 0;
 addressScene.userData.blackCorePulse = 0;
 
 console.log('?? Black core sphere created with', coreVoxelCount, 'voxels');
 console.log('? Voxelized black hole created');
 console.log('?? Outer voxel count:', voxelSphere.children.length);
 console.log('?? Core voxel count:', blackCore.children.length);
 console.log('?? Event horizon position:', eventHorizon.position);
 console.log('?? Black hole light intensity:', blackHoleLight1.intensity);
 
 // Accretion disk particles
 const particleCount = 200;
 const particleGeo = new THREE.BufferGeometry();
 const positions = new Float32Array(particleCount * 3);
 const colors = new Float32Array(particleCount * 3);
 
 for (let i = 0; i < particleCount; i++) {
 const angle = Math.random() * Math.PI * 2;
 const radius = 4 + Math.random() * 3;
 positions[i * 3] = Math.cos(angle) * radius;
 positions[i * 3 + 1] = (Math.random() - 0.5) * 0.5;
 positions[i * 3 + 2] = Math.sin(angle) * radius;
 
 const heat = 1 - (radius - 4) / 3;
 colors[i * 3] = 1;
 colors[i * 3 + 1] = heat * 0.6;
 colors[i * 3 + 2] = heat * 0.2;
 }
 
 particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
 particleGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
 
 const particleMat = new THREE.PointsMaterial({
 size: 0.35,
 vertexColors: true,
 transparent: true,
 opacity: 1.0,
 blending: THREE.AdditiveBlending,
 sizeAttenuation: true,
 depthWrite: false
 });
 
 const particles = new THREE.Points(particleGeo, particleMat);
 addressScene.add(particles);
 addressScene.userData.accretionDisk = particles;
 console.log('? Accretion disk particles added to scene');
 
 console.log('? Black hole with accretion disk created');
 console.log('?? Scene objects:', addressScene.children.length);
 }
 
 // Breathing voxelized black hole (outer sphere)
 if (addressScene.userData.voxelSphere) {
 addressScene.userData.voxelSpherePhase += delta * 2;
 const breathe = Math.sin(addressScene.userData.voxelSpherePhase) * 0.2 + 1;
 
 addressScene.userData.voxelSphere.children.forEach(voxel => {
 const br = voxel.userData.baseRadius;
 const phi = voxel.userData.phi;
 const theta = voxel.userData.theta;
 const radius = br * breathe;
 
 voxel.position.x = radius * Math.cos(theta) * Math.sin(phi);
 voxel.position.y = radius * Math.sin(theta) * Math.sin(phi);
 voxel.position.z = radius * Math.cos(phi);
 });
 
 addressScene.userData.voxelSphere.rotation.y += delta * 0.2;
 
 // PULSATING BLOOM - lights breathe with black hole to illuminate room
 if (addressScene.userData.blackHoleLight) {
 const lightPulse = breathe; // Follow breathing pattern
 addressScene.userData.blackHoleLight.intensity = 8.0 + lightPulse * 6.0; // 8-14 intensity
 addressBloom.strength = 0.6 + lightPulse * 0.4; // 0.6-1.0 bloom
 
 // Illuminate room walls with pulsating bloom
 if (addressScene.userData.roomMesh && addressScene.userData.roomMesh.material) {
 addressScene.userData.roomMesh.material.emissiveIntensity = 0.05 + lightPulse * 0.08; // Subtle pulse
 }
 }
 
 // Debug log every 5 seconds
 if (Math.floor(sequenceTime) % 5 === 0 && Math.floor(sequenceTime) !== Math.floor(sequenceTime - delta)) {
 console.log(`??? Black hole visible: voxels=${addressScene.userData.voxelSphere.children.length}, breathe=${breathe.toFixed(2)}, bloom=${addressBloom.strength.toFixed(2)}`);
 }
 }
 
 // Pulsing BLACK CORE - inverse pulse with negative black-light gradient
 if (addressScene.userData.blackCore) {
 addressScene.userData.blackCorePhase += delta * 3; // Faster pulse
 addressScene.userData.blackCorePulse += delta * 4;
 
 // Inverse pulse - contracts when outer breathes out
 const corePulse = Math.sin(addressScene.userData.blackCorePhase) * -0.15 + 0.85; // 0.7 to 1.0
 
 addressScene.userData.blackCore.children.forEach((voxel, i) => {
 const br = voxel.userData.baseRadius;
 const phi = voxel.userData.phi;
 const theta = voxel.userData.theta;
 const radius = br * corePulse;
 
 voxel.position.x = radius * Math.cos(theta) * Math.sin(phi);
 voxel.position.y = radius * Math.sin(theta) * Math.sin(phi);
 voxel.position.z = radius * Math.cos(phi);
 
 // Pulsing opacity creating "negative light" effect
 const wave = Math.sin(addressScene.userData.blackCorePulse + i * 0.1);
 const distFromCenter = Math.sqrt(voxel.position.x**2 + voxel.position.y**2 + voxel.position.z**2);
 const normalizedDist = distFromCenter / (br * corePulse); // 0 at center, 1 at edge
 
 // Darker at center, lighter at edges (inverted gradient)
 voxel.material.opacity = 0.9 + (normalizedDist * 0.1) + (wave * 0.05);
 });
 
 // Counter-rotate to outer sphere
 addressScene.userData.blackCore.rotation.y -= delta * 0.3;
 }
 
 if (addressScene.userData.eventHorizon) {
 addressScene.userData.eventHorizon.rotation.z += delta * 0.8;
 }
 if (addressScene.userData.accretionDisk) {
 addressScene.userData.accretionDisk.rotation.y += delta * 0.5;
 }
 
 // Continuously spawn black cubes
 if (sequenceTime > 55) {
 if (!addressScene.userData.blackCubeSpawnTimer) {
 addressScene.userData.blackCubeSpawnTimer = 0;
 addressScene.userData.blackCubes = [];
 }
 
 addressScene.userData.blackCubeSpawnTimer += delta;
 if (addressScene.userData.blackCubeSpawnTimer > 0.15) {
 addressScene.userData.blackCubeSpawnTimer = 0;
 
 // Spawn new black cube far away
 const angle = Math.random() * Math.PI * 2;
 const elevation = (Math.random() - 0.5) * Math.PI;
 const distance = 30 + Math.random() * 15;
 
 const blackCubeMat = new THREE.MeshStandardMaterial({
 color: 0x0a0a0a,
 transparent: true,
 opacity: 0.95,
 emissive: 0x0a0a0a,
 emissiveIntensity: 0.1
 });
 
 const blackCube = new THREE.Mesh(cubeGeo, blackCubeMat);
 blackCube.position.set(
 Math.cos(angle) * Math.cos(elevation) * distance,
 Math.sin(elevation) * distance,
 Math.sin(angle) * Math.cos(elevation) * distance
 );
 blackCube.userData.beingSucked = true;
 blackCube.userData.suckStartTime = sequenceTime;
 blackCube.userData.spiralAngle = angle;
 blackCube.userData.spiralSpeed = 1.0 + Math.random() * 2.0;
 blackCube.scale.set(0.6, 0.6, 0.6);
 
 addressScene.add(blackCube);
 addressScene.userData.blackCubes.push(blackCube);
 }
 }
 
 // Spaghettification - black cubes get sucked into black hole
 if (addressScene.userData.blackCubes && addressScene.userData.blackCubes.length > 0) {
 const blackCubes = addressScene.userData.blackCubes;
 for (let i = blackCubes.length - 1; i >= 0; i--) {
 const cube = blackCubes[i];
 const elapsed = sequenceTime - cube.userData.suckStartTime;
 const distToCenter = Math.sqrt(
 cube.position.x ** 2 + 
 cube.position.y ** 2 + 
 cube.position.z ** 2
 );
 
 // Acceleration toward center - increasing speed
 const acceleration = 1 + elapsed * 1.2;
 const pullForce = delta * acceleration * 10;
 
 // Spiral motion
 cube.userData.spiralAngle += delta * cube.userData.spiralSpeed * (1 + elapsed * 0.8);
 const spiralRadius = Math.max(0.1, distToCenter * 0.15);
 const spiralX = Math.cos(cube.userData.spiralAngle) * spiralRadius;
 const spiralZ = Math.sin(cube.userData.spiralAngle) * spiralRadius;
 
 // Pull toward center with spiral
 cube.position.x = THREE.MathUtils.lerp(cube.position.x, spiralX, pullForce);
 cube.position.y = THREE.MathUtils.lerp(cube.position.y, 0, pullForce * 0.95);
 cube.position.z = THREE.MathUtils.lerp(cube.position.z, spiralZ, pullForce);
 
 // Spaghettification stretch - extreme elongation
 if (distToCenter < 10) {
 const stretchFactor = 1 + (10 - distToCenter) * 0.5;
 cube.scale.y = 0.6 * stretchFactor;
 cube.scale.x = Math.max(0.03, 0.6 / Math.sqrt(stretchFactor));
 cube.scale.z = Math.max(0.03, 0.6 / Math.sqrt(stretchFactor));
 
 // Orient along spiral toward center
 const targetPos = new THREE.Vector3(spiralX, 0, spiralZ);
 cube.lookAt(targetPos);
 }
 
 // Event horizon burst - tri-chromatic light explosion
 if (distToCenter < 4.0 && !cube.userData.hasBurst) {
 cube.userData.hasBurst = true;
 console.log('?? Tri-chromatic burst at event horizon!');
 
 // Create tri-chromatic light burst
 const colors = [
 { hex: 0xff0000, name: 'red' },
 { hex: 0x00ff00, name: 'green' },
 { hex: 0x0000ff, name: 'blue' }
 ];
 colors.forEach((colorData, idx) => {
 const lightGeo = new THREE.SphereGeometry(0.3, 16, 16);
 const lightMat = new THREE.MeshBasicMaterial({
 color: colorData.hex,
 transparent: true,
 opacity: 1
 });
 const light = new THREE.Mesh(lightGeo, lightMat);
 light.position.copy(cube.position);
 
 const angle = (idx / 3) * Math.PI * 2 + Math.random() * 0.5;
 const speed = 3 + Math.random() * 2;
 light.userData.velocity = new THREE.Vector3(
 Math.cos(angle) * speed,
 (Math.random() - 0.5) * speed * 0.8,
 Math.sin(angle) * speed
 );
 light.userData.life = 1.0;
 light.userData.colorName = colorData.name;
 
 addressScene.add(light);
 if (!addressScene.userData.lightBursts) {
 addressScene.userData.lightBursts = [];
 }
 addressScene.userData.lightBursts.push(light);
 });
 }
 
 // Remove if too close to center
 if (distToCenter < 0.5) {
 addressScene.remove(cube);
 blackCubes.splice(i, 1);
 }
 }
 }
 
 // Animate light bursts - expand and fade
 if (addressScene.userData.lightBursts) {
 for (let i = addressScene.userData.lightBursts.length - 1; i >= 0; i--) {
 const light = addressScene.userData.lightBursts[i];
 light.position.add(light.userData.velocity.clone().multiplyScalar(delta));
 light.userData.life -= delta * 0.4;
 light.material.opacity = light.userData.life;
 light.scale.multiplyScalar(1 + delta * 3);
 
 if (light.userData.life <= 0) {
 addressScene.remove(light);
 addressScene.userData.lightBursts.splice(i, 1);
 }
 }
 }
 
 // Render the scene
 addressComposer.render();
 
 // Continue indefinitely to keep rendering the room and black hole
 requestAnimationFrame(animateAddresses);
 }
 
 console.log('?? Starting animation loop');
 console.log('?? Camera position:', addressCamera.position);
 console.log('?? Scene children:', addressScene.children.length);
 animateAddresses();
 }
 
 function triggerVictory(frame) {
 console.log('?? VICTORY!');
 if (!frame) return;

 // Set madness flag
 madnessActivated = true;
 rPromptHoverCount = 0; // Reset for "Don't click" messages

 // HALT R sequence completely - stop matrix and speech
 rInfectionHalted = true;
 speechRActive = false;
 rInfectionProcessing = false;
 rInfectionStarted = false;
 
 // Stop all matrix intervals and timers
 if (matrixInterval) {
 clearInterval(matrixInterval);
 matrixInterval = null;
 }
 if (matrixUpdateInterval) {
 clearInterval(matrixUpdateInterval);
 matrixUpdateInterval = null;
 }
 if (matrixAnimationFrameId) {
 cancelAnimationFrame(matrixAnimationFrameId);
 matrixAnimationFrameId = null;
 }
 if (cascadeInterval) {
 clearInterval(cascadeInterval);
 cascadeInterval = null;
 }
 if (matrixHeavyTimers && matrixHeavyTimers.length) {
 matrixHeavyTimers.forEach(id => clearTimeout(id));
 matrixHeavyTimers = [];
 }
 
 // Remove matrix container and R hint
 const matrixContainer = document.getElementById('matrixContainer');
 if (matrixContainer) {
 matrixContainer.remove();
 }
 const rHint = document.getElementById('rHint');
 if (rHint) {
 rHint.remove();
 }
 
 // Stop R text-to-speech immediately
 if (speechRTimeout) {
 clearTimeout(speechRTimeout);
 speechRTimeout = null;
 }
 if (speechRGuardTimeout) {
 clearTimeout(speechRGuardTimeout);
 speechRGuardTimeout = null;
 }
 if (hasSpeechSynthesis) {
 try { window.speechSynthesis.cancel(); } catch (err) {}
 }
 console.log('?? HALTED R sequence (matrix + speech)');

 // Play "Oh." text-to-speech
 setTimeout(() => {
 if (hasSpeechSynthesis && speechRVoice) {
 const ohUtterance = new SpeechSynthesisUtterance('Oh.');
 ohUtterance.voice = speechRVoice;
 ohUtterance.rate = 0.9;
 ohUtterance.pitch = 1.0;
 ohUtterance.volume = 0.92;
 window.speechSynthesis.speak(ohUtterance);
 console.log('??? Playing "Oh." TTS');
 }
 }, 300);

 const existing = document.getElementById('initializeOverlay');
 if (existing) existing.remove();

 const overlay = document.createElement('div');
 overlay.id = 'initializeOverlay';
 overlay.style.cssText = 'position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none; z-index:60;';

 const panel = document.createElement('div');
 panel.style.cssText = 'pointer-events:auto; text-align:center; background:rgba(0,0,0,0.88); border:2px solid #0f0; padding:26px 34px; box-shadow:0 0 18px rgba(0,255,160,0.25); font-family:"Courier New", monospace; color:#0f0; min-width:260px;';

 const heading = document.createElement('div');
 heading.textContent = 'madness.loom located';
 heading.style.cssText = 'font-size:13px; letter-spacing:0.14em; text-transform:uppercase; margin-bottom:14px;';

 const button = document.createElement('button');
 button.style.cssText = 'font-family:"Courier New", monospace; font-size:15px; letter-spacing:0.38em; padding:16px 34px; color:#072c07; background:#19ff6b; border:2px solid #19ff6b; cursor:pointer; text-transform:uppercase; box-shadow:0 0 18px rgba(25,255,107,0.45); transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease, color 0.2s ease; pointer-events:auto; position:relative;';
 
 // Create button content with text and square dots
 const buttonText = document.createElement('span');
 buttonText.textContent = 'INITIALIZE ?';
 buttonText.style.cssText = 'position:relative; z-index:1;';
 
 // Create square dots container
 const dotsContainer = document.createElement('span');
 dotsContainer.style.cssText = 'position:absolute; left:10px; top:50%; transform:translateY(-50%); display:flex; gap:4px; z-index:0;';
 
 // Add 3 square dots
 for (let i = 0; i < 3; i++) {
 const dot = document.createElement('span');
 dot.style.cssText = `width:6px; height:6px; background:#072c07; opacity:0.4; animation:pulse-dot 1.5s ease-in-out ${i * 0.2}s infinite;`;
 dotsContainer.appendChild(dot);
 }
 
 button.appendChild(dotsContainer);
 button.appendChild(buttonText);
 
 // Add CSS animation for dots if not already present
 if (!document.getElementById('dot-pulse-animation')) {
 const style = document.createElement('style');
 style.id = 'dot-pulse-animation';
 style.textContent = `
 @keyframes pulse-dot {
 0%, 100% { opacity: 0.2; transform: scale(1); }
 50% { opacity: 0.6; transform: scale(1.3); }
 }
 `;
 document.head.appendChild(style);
 }

 button.addEventListener('mouseenter', () => {
 if (button.disabled) return;
 button.style.boxShadow = '0 0 24px rgba(25,255,140,0.55)';
 button.style.transform = 'translateY(-2px)';
 });
 button.addEventListener('mouseleave', () => {
 if (button.disabled) return;
 button.style.boxShadow = '0 0 18px rgba(25,255,107,0.45)';
 button.style.transform = 'translateY(0)';
 });

 const status = document.createElement('div');
 const phases = ['calibrate interface', 'prime uplink', 'commence breach'];
 status.style.cssText = 'margin-top:12px; font-size:12px; letter-spacing:0.2em; text-transform:uppercase; opacity:0.75;';
 status.textContent = phases[0];

 panel.appendChild(heading);
 panel.appendChild(button);
 panel.appendChild(status);
 overlay.appendChild(panel);
 frame.appendChild(overlay);

 const visiCalc = document.getElementById('visicalc');
 const stageClasses = ['barrel-stage-1', 'barrel-stage-2', 'barrel-stage-3'];
 let clickCount = 0;

 function applyDistortion(stageIndex) {
 if (!visiCalc) return;
 visiCalc.classList.remove('screen-shatter');
 stageClasses.forEach(cls => visiCalc.classList.remove(cls));
 void visiCalc.offsetWidth;
 visiCalc.classList.add(stageClasses[stageIndex]);
 }
 
 function triggerMatrixIntensification(intensity) {
 console.log('?? Matrix intensification level:', intensity);
 
 // Create or intensify matrix rain
 let matrixContainer = document.getElementById('matrixIntensityOverlay');
 if (!matrixContainer) {
 matrixContainer = document.createElement('div');
 matrixContainer.id = 'matrixIntensityOverlay';
 matrixContainer.style.cssText = 'position:fixed; inset:0; pointer-events:none; z-index:65; overflow:hidden;';
 document.body.appendChild(matrixContainer);
 }
 
 // Clear existing columns
 matrixContainer.innerHTML = '';
 
 // Number of columns increases with intensity
 const columnCount = 40 + (intensity * 25); // More columns
 const duration = 2.5 + (intensity * 0.5); // Longer duration: 3-4s
 const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%&*+=';
 
 for (let i = 0; i < columnCount; i++) {
 const column = document.createElement('div');
 column.style.cssText = `
 position:absolute;
 top:${-100 - Math.random() * 100}%;
 left:${Math.random() * 100}%;
 font-family:'Courier New', monospace;
 font-size:${14 + Math.random() * 10}px;
 color:#0f0;
 text-shadow:0 0 ${6 + intensity * 6}px #0f0, 0 0 ${3 + intensity * 3}px #0f0;
 opacity:${0.65 + intensity * 0.12};
 white-space:nowrap;
 animation: matrixFall ${duration}s linear forwards;
 `;
 
 // Create falling text
 let text = '';
 const length = 10 + Math.floor(Math.random() * 15);
 for (let j = 0; j < length; j++) {
 text += characters[Math.floor(Math.random() * characters.length)] + '<br>';
 }
 column.innerHTML = text;
 matrixContainer.appendChild(column);
 }
 
 // Add CSS animation if not already defined
 if (!document.getElementById('matrixIntensityStyles')) {
 const style = document.createElement('style');
 style.id = 'matrixIntensityStyles';
 style.textContent = `
 @keyframes matrixFall {
 0% { transform: translateY(0); opacity: 0; }
 15% { opacity: 1; }
 85% { opacity: 0.85; }
 100% { transform: translateY(150vh); opacity: 0; }
 }
 `;
 document.head.appendChild(style);
 }
 
 // Remove after animation
 setTimeout(() => {
 if (matrixContainer && matrixContainer.parentNode) {
 matrixContainer.remove();
 }
 }, duration * 1000 + 500);
 }

 function triggerScreenShatter() {
 if (visiCalc) {
 stageClasses.forEach(cls => visiCalc.classList.remove(cls));
 void visiCalc.offsetWidth;
 visiCalc.classList.add('screen-shatter');
 }

 let shatter = document.getElementById('screenShatterOverlay');
 if (shatter) {
 shatter.remove();
 }
 shatter = document.createElement('div');
 shatter.id = 'screenShatterOverlay';
 shatter.className = 'shatter-overlay';
 const cracks = document.createElement('div');
 cracks.className = 'shatter-cracks';
 const pixels = document.createElement('div');
 pixels.className = 'shatter-pixels';
 shatter.appendChild(cracks);
 shatter.appendChild(pixels);
 document.body.appendChild(shatter);

 requestAnimationFrame(() => {
 shatter.classList.add('active');
 setTimeout(() => {
 shatter.classList.add('fade');
 }, 950);
 setTimeout(() => {
 if (shatter.parentNode) {
 shatter.parentNode.removeChild(shatter);
 }
 // Start cell address sequence after shatter
 setTimeout(() => {
 startCellAddressSequence(frame, visiCalc);
 }, 500);
 }, 2400);
 });
 }

 button.addEventListener('click', () => {
 if (button.disabled) return;
 clickCount++;
 barrelClickCount++;
 button.blur();
 button.style.transform = 'translateY(2px)';
 button.style.boxShadow = '0 0 12px rgba(25,255,107,0.35)';
 setTimeout(() => {
 if (!button.disabled) {
 button.style.transform = 'translateY(0)';
 button.style.boxShadow = '0 0 18px rgba(25,255,107,0.45)';
 }
 }, 160);

 const phaseIndex = Math.min(clickCount, phases.length - 1);
 status.textContent = phases[phaseIndex];

 // Play distorted startup sound with increasing distortion per click
 playStartupBassDistorted(clickCount);

 // Make VisiCell frame glow and extend back in Z
 if (visiCalc) {
 const frameEl = document.getElementById('visicalc-frame');
 if (frameEl) {
 const zDepth = barrelClickCount * 20;
 frameEl.style.transform = `perspective(1000px) translateZ(-${zDepth}px)`;
 frameEl.style.boxShadow = `0 0 ${10 + barrelClickCount * 15}px #0f0, inset 0 0 ${5 + barrelClickCount * 10}px #0f0`;
 frameEl.style.borderColor = '#0f0';
 frameEl.style.borderWidth = '3px';
 }
 }

 // Intensify screen glitch and matrix effects between clicks
 const glitchEl = document.getElementById('screenGlitch');
 if (glitchEl && clickCount < 3) {
 glitchEl.classList.add('active');
 setTimeout(() => glitchEl.classList.remove('active'), 800 + clickCount * 200);
 }
 
 // Trigger maximum matrix cascade effect
 if (clickCount < 3) {
 triggerMatrixIntensification(clickCount);
 }

 if (clickCount === 1) {
 applyDistortion(0);
 } else if (clickCount === 2) {
 applyDistortion(1);
 } else {
 applyDistortion(2);
 button.disabled = true;
 button.style.cursor = 'default';
 button.textContent = 'INITIALIZING...';
 button.style.background = '#0d400d';
 button.style.color = '#0f0';
 
 // Maximum glitch and matrix before shatter
 if (glitchEl) {
 glitchEl.classList.add('active');
 setTimeout(() => glitchEl.classList.remove('active'), 1500);
 }
 triggerMatrixIntensification(3);
 
 setTimeout(() => {
 triggerScreenShatter();
 }, 500);
 }
 });
 }
 
 function triggerCelliBackspaceReaction() {
 if (celliBackspaceSequenceStarted || burstAnimStarted) return;

 celliBackspaceSequenceStarted = true;
 celliBackspaceSequenceTime = totalTime;

 const active = voxels.filter(v => v.visible && !v.userData.glitched);
 if (!celliBackspaceFlickerTriggered && active.length) {
 celliBackspaceFlickerTriggered = true;
 const target = active[Math.floor(Math.random() * active.length)];
 if (target) {
 let flickers = 0;
 const mat = target.material;
 const edgeMaterial = target.userData.edges ? target.userData.edges.material : null;
 const baseOpacity = mat.opacity;
 const baseEdgeOpacity = edgeMaterial ? edgeMaterial.opacity : 0;
 const interval = setInterval(() => {
 const on = flickers % 2 === 0;
 mat.opacity = on ? 1 : Math.max(0.1, baseOpacity * 0.2);
 if (edgeMaterial) {
 edgeMaterial.opacity = on ? Math.min(0.9, baseEdgeOpacity + 0.3) : Math.max(0.1, baseEdgeOpacity * 0.3);
 }
 flickers += 1;
 if (flickers > 4) {
 clearInterval(interval);
 mat.opacity = baseOpacity;
 if (edgeMaterial) edgeMaterial.opacity = baseEdgeOpacity;
 }
 }, 90);
 }
 }
 }

 // CELLI glitch and degradation
 function triggerCelliGlitch() {
 if (celliGlitchStarted) return;
 celliGlitchStarted = true;
 
 // Play electrical fritz whir/buzz sound
 if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); window.audioCtx = audioCtx; }
 const now = audioCtx.currentTime;
 
 // Create buzzing electrical sound with multiple oscillators
 const buzz1 = audioCtx.createOscillator();
 const buzz2 = audioCtx.createOscillator();
 const buzz3 = audioCtx.createOscillator();
 const buzzGain = audioCtx.createGain();
 const buzzFilter = audioCtx.createBiquadFilter();
 
 buzz1.type = 'sawtooth';
 buzz2.type = 'square';
 buzz3.type = 'sawtooth';
 
 // Fluctuating frequencies for electrical buzz
 buzz1.frequency.setValueAtTime(120, now);
 buzz2.frequency.setValueAtTime(180, now);
 buzz3.frequency.setValueAtTime(240, now);
 
 // Modulate frequencies to create buzzing effect
 for (let i = 0; i < 20; i++) {
 const t = now + (i * 0.1);
 const freq1 = 120 + Math.random() * 60;
 const freq2 = 180 + Math.random() * 60;
 const freq3 = 240 + Math.random() * 60;
 buzz1.frequency.setValueAtTime(freq1, t);
 buzz2.frequency.setValueAtTime(freq2, t);
 buzz3.frequency.setValueAtTime(freq3, t);
 }
 
 // Band-pass filter for electrical character
 buzzFilter.type = 'bandpass';
 buzzFilter.frequency.setValueAtTime(300, now);
 buzzFilter.Q.setValueAtTime(5, now);
 
 // Envelope: fade in, sustain, fade out
 buzzGain.gain.setValueAtTime(0, now);
 buzzGain.gain.linearRampToValueAtTime(0.08, now + 0.2);
 buzzGain.gain.setValueAtTime(0.08, now + 1.5);
 buzzGain.gain.exponentialRampToValueAtTime(0.001, now + 2.0);
 
 buzz1.connect(buzzFilter);
 buzz2.connect(buzzFilter);
 buzz3.connect(buzzFilter);
 buzzFilter.connect(buzzGain);
 buzzGain.connect(audioCtx.destination);
 
 buzz1.start(now);
 buzz2.start(now);
 buzz3.start(now);
 buzz1.stop(now + 2.0);
 buzz2.stop(now + 2.0);
 buzz3.stop(now + 2.0);
 
 // Start flickering lights
 document.getElementById('screenGlitch').classList.add('active');
 
 // Only keep the middle column of I (letter index 4, middle 3 rows: 1,2,3)
 voxels.forEach((voxel, idx) => {
 const data = voxel.userData;
 const gridX = data.gridX; // Letter index (0=C, 1=E, 2=L, 3=L, 4=I)
 const gridY = data.gridY; // Row index (0=top, 4=bottom)
 const gridCol = data.gridCol; // Column index within letter (0-4)
 
 // Keep only the T shape: top bar (row 0, all cols) and vertical stem (rows 1-4, middle col)
 const keepVoxel = (gridX === 4 && ((gridY === 0) || (gridY >= 1 && gridY <= 4 && gridCol === 2)));
 
 if (!keepVoxel) {
 // Store in stack for later restoration BEFORE marking as glitched
 glitchedVoxelsStack.push(voxel);
 
 // Mark as glitched immediately to prevent updates
 data.glitched = true;
 
 // Start flickering with light gray
 const flickerDelay = Math.random() * 400;
 
 setTimeout(() => {
 // Turn to light gray and start flickering
 voxel.material.color.setRGB(0.6, 0.6, 0.6); // Light gray
 data.edges.material.color.setRGB(0.65, 0.65, 0.65);
 
 const flickerDuration = 400 + Math.random() * 400;
 let flickerCount = 0;
 const maxFlickers = Math.floor(flickerDuration / 60);
 
 const flickerInterval = setInterval(() => {
 flickerCount++;
 const flickerOn = Math.random() > 0.5;
 
 // Flicker between light gray and white, gradually dimming
 const dimFactor = 1 - (flickerCount / maxFlickers) * 0.5;
 if (flickerOn) {
 voxel.material.color.setRGB(0.6 * dimFactor, 0.6 * dimFactor, 0.6 * dimFactor);
 voxel.material.opacity = 0.75 * dimFactor;
 data.edges.material.opacity = 0.5 * dimFactor;
 } else {
 voxel.material.color.setRGB(0.4 * dimFactor, 0.4 * dimFactor, 0.4 * dimFactor);
 voxel.material.opacity = 0.5 * dimFactor;
 data.edges.material.opacity = 0.3 * dimFactor;
 }
 }, 60);
 
 // After flickering, turn dark gray and fade out
 setTimeout(() => {
 clearInterval(flickerInterval);
 
 // Short out - dark gray
 voxel.material.color.setRGB(0.15, 0.15, 0.15); // Dark gray
 data.edges.material.color.setRGB(0.2, 0.2, 0.2);
 voxel.material.opacity = 0.4;
 data.edges.material.opacity = 0.25;
 
 // Fade to black over time
 const fadeStart = Date.now();
 const fadeDuration = 300;
 const fadeInterval = setInterval(() => {
 const fadeProgress = (Date.now() - fadeStart) / fadeDuration;
 if (fadeProgress >= 1) {
 clearInterval(fadeInterval);
 voxel.material.opacity = 0;
 data.edges.material.opacity = 0;
 voxel.visible = false;
 data.edges.visible = false;
 } else {
 voxel.material.opacity = 0.4 * (1 - fadeProgress);
 data.edges.material.opacity = 0.25 * (1 - fadeProgress);
 }
 }, 16);
 }, flickerDuration);
 }, flickerDelay);
 }
 });
 
 // Stop screen glitch after 2 seconds
 setTimeout(() => {
 document.getElementById('screenGlitch').classList.remove('active');
 }, 2000);
 }

 function updatePositions(t) {
 const phase = t < introCfg.rollEnd ? 'roll' :
 t < introCfg.bounceEnd ? 'bounce' :
 t < introCfg.triangleEnd ? 'triangle' :
 t < introCfg.transitionEnd ? 'transition' :
 t < introCfg.normalEnd ? 'normal' :
 t < introCfg.vennEnd ? 'venn' :
 t < introCfg.collapseEnd ? 'collapse' :
 t < introCfg.glitchEnd ? 'glitch' :
 t < introCfg.blackoutEnd ? 'blackout' :
 t < introCfg.loomworksEnd ? 'loomworks' :
 t < introCfg.celliEnd ? 'celli' : 'doorway';

 // Animate bloom, afterimage, and film effects based on phase
 if (phase === 'roll') {
 afterimagePass.uniforms.damp.value = 0.75; // Thin trail
 filmPass.uniforms.noise.value = 0.005; // Minimal grain
 filmPass.uniforms.scanAmp.value = 0.003; // Minimal scanlines
 triMesh.visible = false; // Hide triangle gradient during intro
 } else if (phase === 'bounce') {
 bloomPass.strength = 0.25; // Subtle glow
 afterimagePass.uniforms.damp.value = 0.75; // Thin trail
 filmPass.uniforms.noise.value = 0.005; // Minimal grain
 filmPass.uniforms.scanAmp.value = 0.003; // Minimal scanlines
 triMesh.visible = false; // Hide triangle gradient during intro
 } else if (phase === 'triangle') {
 const triangleProgress = (t - introCfg.bounceEnd) / (introCfg.triangleEnd - introCfg.bounceEnd);
 
 // Sub-phases: form (0-0.35), converge (0.35-0.6), grow (0.6-1.0)
 const formProgress = Math.min(triangleProgress / 0.35, 1.0);
 const convergeStart = 0.35;
 const convergeProgress = triangleProgress > convergeStart ? Math.min((triangleProgress - convergeStart) / 0.25, 1.0) : 0;
 const growStart = 0.6;
 const growProgress = triangleProgress > growStart ? (triangleProgress - growStart) / 0.4 : 0;
 
 // Smooth bloom progression throughout all sub-phases
 bloomPass.strength = THREE.MathUtils.lerp(0.25, 0.7, triangleProgress);
 afterimagePass.uniforms.damp.value = THREE.MathUtils.lerp(0.75, 0.92, triangleProgress);
 filmPass.uniforms.noise.value = THREE.MathUtils.lerp(0.005, 0.015, triangleProgress);
 filmPass.uniforms.scanAmp.value = THREE.MathUtils.lerp(0.003, 0.015, triangleProgress);
 
 // Hide triangle gradient - it makes things look off-center
 triMesh.visible = false;
 } else if (phase === 'transition') {
 const transProgress = (t - introCfg.triangleEnd) / (introCfg.transitionEnd - introCfg.triangleEnd);
 bloomPass.strength = 0.7; // Keep bloom consistent
 afterimagePass.uniforms.damp.value = THREE.MathUtils.lerp(0.92, 0.96, transProgress);
 filmPass.uniforms.noise.value = THREE.MathUtils.lerp(0.015, 0.03, transProgress);
 filmPass.uniforms.scanAmp.value = THREE.MathUtils.lerp(0.015, 0.03, transProgress);
 triMesh.visible = false;
 triMesh.material.opacity = 0;
 } else if (phase === 'normal') {
 const normalT = t - introCfg.transitionEnd;
 const normalDuration = introCfg.normalEnd - introCfg.transitionEnd;
 const convergeDuration = 2.2;
 const pulseDuration = 3.0;
 const totalAnimDuration = convergeDuration + pulseDuration;

 if (normalT < convergeDuration) {
 // Phase 1: Converge - increase bloom
 const convergeProgress = THREE.MathUtils.clamp(normalT / convergeDuration, 0, 1);
 const convergeEased = convergeProgress * convergeProgress * (3 - 2 * convergeProgress);
 bloomPass.strength = THREE.MathUtils.lerp(0.7, 0.9, convergeEased);
 triMesh.visible = false;
 } else if (normalT < totalAnimDuration) {
 // Phase 2: Single pulse - bloom follows expansion
 const pulseT = normalT - convergeDuration;
 const pulseProgress = pulseT / pulseDuration;
 const pulseCycle = Math.sin(pulseProgress * Math.PI);
 
 bloomPass.strength = THREE.MathUtils.lerp(0.9, 0.72, pulseCycle);
 triMesh.visible = pulseCycle > 0.3; // Show triangle during expansion
 triMesh.material.opacity = THREE.MathUtils.clamp(pulseCycle * 1.5, 0, 0.7);
 } else {
 // Phase 3: Brief hold, prepare for venn transition
 const holdT = normalT - totalAnimDuration;
 const holdDuration = normalDuration - totalAnimDuration;
 const holdProgress = holdT / holdDuration;
 
 bloomPass.strength = THREE.MathUtils.lerp(0.9, 0.85, holdProgress);
 triMesh.visible = false;
 }

 afterimagePass.uniforms.damp.value = 0.96;
 filmPass.uniforms.noise.value = 0.03;
 filmPass.uniforms.scanAmp.value = 0.03;
 } else if (phase === 'venn') {
 // Settle into clear venn diagram
 const vennProgress = (t - introCfg.normalEnd) / (introCfg.vennEnd - introCfg.normalEnd);
 bloomPass.strength = THREE.MathUtils.lerp(0.7, 0.8, vennProgress);
 afterimagePass.uniforms.damp.value = THREE.MathUtils.lerp(0.96, 0.7, vennProgress);
 filmPass.uniforms.noise.value = THREE.MathUtils.lerp(0.03, 0.02, vennProgress);
 filmPass.uniforms.scanAmp.value = THREE.MathUtils.lerp(0.03, 0.02, vennProgress);
 triMesh.visible = true;
 triMesh.material.opacity = THREE.MathUtils.lerp(0.7, 0.85, vennProgress);
 } else if (phase === 'collapse') {
 // Grow and collapse into white radiating circle
 const collapseProgress = (t - introCfg.vennEnd) / (introCfg.collapseEnd - introCfg.vennEnd);
 bloomPass.strength = THREE.MathUtils.lerp(0.8, 1.2, collapseProgress);
 afterimagePass.uniforms.damp.value = THREE.MathUtils.lerp(0.7, 0.6, collapseProgress);
 filmPass.uniforms.noise.value = THREE.MathUtils.lerp(0.02, 0.015, collapseProgress);
 filmPass.uniforms.scanAmp.value = THREE.MathUtils.lerp(0.02, 0.015, collapseProgress);
 triMesh.visible = true;
 triMesh.material.opacity = THREE.MathUtils.lerp(0.85, 0.3, collapseProgress);
 
 // Progressive glitch starting mild - show quote only when glitching starts
 if (collapseProgress > 0.15 && !glitchStarted) {
 const quoteEl = document.getElementById('quote');
 quoteEl.style.visibility = 'visible';
 quoteEl.style.opacity = '0.85'; // Start visible
 quoteEl.classList.add('glitch');
 glitchStarted = true;
 quoteShown = true;
 }

 // Increase to medium glitch
 if (collapseProgress > 0.6 && !mediumGlitchStarted) {
 document.getElementById('quote').classList.remove('glitch');
 document.getElementById('quote').classList.add('glitchMedium');
 mediumGlitchStarted = true;
 }
 } else if (phase === 'glitch') {
 // Intense glitch phase
 const glitchProgress = (t - introCfg.collapseEnd) / (introCfg.glitchEnd - introCfg.collapseEnd);
 bloomPass.strength = THREE.MathUtils.lerp(1.2, 0.5, glitchProgress);
 afterimagePass.uniforms.damp.value = 0.3; // Heavy trails
 filmPass.uniforms.noise.value = THREE.MathUtils.lerp(0.015, 0.5, glitchProgress);
 filmPass.uniforms.scanAmp.value = THREE.MathUtils.lerp(0.015, 0.3, glitchProgress);
 triMesh.visible = true;
 triMesh.material.opacity = THREE.MathUtils.lerp(0.3, 0, glitchProgress);
 
 // Intensify text glitch at start of glitch phase
 if (glitchProgress > 0.05 && !intenseGlitchStarted) {
 document.getElementById('quote').classList.remove('glitch', 'glitchMedium');
 document.getElementById('quote').classList.add('glitchIntense');
 intenseGlitchStarted = true;
 }

 if (glitchProgress > 0.25 && !quoteDespairShown) {
 glitchSwapQuote(quoteStates.despair, { duration: 950, onComplete: () => quoteEl.classList.add('quote--loom') });
 quoteDespairShown = true;
 }

 // Screen glitch in middle
 if (glitchProgress > 0.4 && !screenGlitchStarted) {
 document.getElementById('screenGlitch').classList.add('active');
 screenGlitchStarted = true;
 }
 } else if (phase === 'blackout') {
 // Fade to black
 const blackoutProgress = (t - introCfg.glitchEnd) / (introCfg.blackoutEnd - introCfg.glitchEnd);
 bloomPass.strength = THREE.MathUtils.lerp(0.5, 0, blackoutProgress);
 afterimagePass.uniforms.damp.value = 0.1;
 filmPass.uniforms.noise.value = 0;
 filmPass.uniforms.scanAmp.value = 0;
 triMesh.visible = false;
 
 if (!blackoutStarted) {
 // Hide and clean up quote immediately
 const quoteEl = document.getElementById('quote');
 quoteEl.classList.remove('glitch', 'glitchMedium', 'glitchIntense', 'scrambling');
 quoteEl.style.visibility = 'hidden';
 quoteEl.style.opacity = '0';
 quoteEl.classList.remove('quote--loom');
 document.getElementById('screenGlitch').classList.remove('active');
 blackoutStarted = true;
 }
 } else if (phase === 'loomworks') {
 // Show Loomworks text
 bloomPass.strength = 0;
 afterimagePass.uniforms.damp.value = 0;
 filmPass.uniforms.noise.value = 0;
 filmPass.uniforms.scanAmp.value = 0;
 triMesh.visible = false;
 
 if (!loomworksShown) {
 // Ensure quote is definitely hidden before showing loomworks
 const quoteEl = document.getElementById('quote');
 quoteEl.style.visibility = 'hidden';
 quoteEl.style.opacity = '0';
 quoteEl.classList.remove('glitch', 'glitchMedium', 'glitchIntense', 'scrambling');

 startLoomworksReveal();
 loomworksShown = true;
 }
 
 // Play chime jingle at start of this phase
 if (!chimePlayed) {
 // Generate startup chime jingle
 if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); window.audioCtx = audioCtx; }
 const now = audioCtx.currentTime;
 
 // Melodic jingle: C - E - G - C (ascending arpeggio)
 const melody = [
 { freq: 261.63, time: 0.0, duration: 0.25 }, // C4
 { freq: 329.63, time: 0.15, duration: 0.25 }, // E4
 { freq: 392.00, time: 0.30, duration: 0.25 }, // G4
 { freq: 523.25, time: 0.45, duration: 0.5 } // C5 (held)
 ];
 
 melody.forEach((note, idx) => {
 const osc = audioCtx.createOscillator();
 const gain = audioCtx.createGain();
 
 osc.type = 'sine';
 osc.frequency.setValueAtTime(note.freq, now + note.time);
 
 // Envelope
 gain.gain.setValueAtTime(0, now + note.time);
 gain.gain.linearRampToValueAtTime(0.12, now + note.time + 0.02);
 gain.gain.linearRampToValueAtTime(0.08, now + note.time + 0.1);
 gain.gain.exponentialRampToValueAtTime(0.001, now + note.time + note.duration);
 
 osc.connect(gain);
 gain.connect(audioCtx.destination);
 osc.start(now + note.time);
 osc.stop(now + note.time + note.duration);
 });
 
 // Play startup bass after chime completes
 setTimeout(() => {
 playStartupBass();
 }, 1200);
 
 chimePlayed = true;
 }
 
 // Hide Loomworks text near end
 const loomProgress = (t - introCfg.blackoutEnd) / (introCfg.loomworksEnd - introCfg.blackoutEnd);
 if (loomProgress > 0.85) {
 document.getElementById('loomworks').style.opacity = THREE.MathUtils.lerp(1, 0, (loomProgress - 0.85) / 0.15);
 }
 } else if (phase === 'celli') {
 // CELLI phase - lower bloom to reduce wobble
 bloomPass.strength = 0.35;
 afterimagePass.uniforms.damp.value = 0.85;
 filmPass.uniforms.noise.value = 0.008;
 filmPass.uniforms.scanAmp.value = 0.003;
 
 triMesh.visible = false;

 if (!celliStarted) {
 document.getElementById('loomworks').style.display = 'none';
 celliStarted = true;
 }
 } else {
 // Doorway phase - portal opens from vertical bar (lower bloom)
 const doorwayProgress = (t - introCfg.celliEnd) / (introCfg.doorwayEnd - introCfg.celliEnd);
 
 bloomPass.strength = THREE.MathUtils.lerp(0.35, 0.55, Math.min(doorwayProgress * 2, 1));
 afterimagePass.uniforms.damp.value = 0.8;
 filmPass.uniforms.noise.value = 0.005;
 filmPass.uniforms.scanAmp.value = 0.002;
 triMesh.visible = false;
 
 // Wait for all CELLI voxels to finish settling (last one settles around 3-4 seconds)
 const celliAge = t - introCfg.loomworksEnd;
 const allVoxelsSettled = celliAge > 5.0;
 
 if (!doorwayShown && allVoxelsSettled) {
 // Show doorway bar after CELLI finishes
 if (doorwayProgress > 0.05) {
 document.getElementById('doorway').classList.add('visible');
 doorwayShown = true;
 }
 }
 
 if (doorwayShown && !doorwayOpened) {
 // Open doorway after short delay
 if (doorwayProgress > 0.15) {
 document.getElementById('doorway').classList.add('open');
 doorwayOpened = true;
 }
 }
 }

if (phase === 'roll') {
 // Shapes roll in from off-screen to their positions
 const rollProgress = t / introCfg.rollEnd;
 const eased = rollProgress < 0.5 ? 
 2 * rollProgress * rollProgress : 
 1 - Math.pow(-2 * rollProgress + 2, 2) / 2;
 
 // Keep glow visible throughout roll
 bloomPass.strength = 0.4;

 for (let i = 0; i < 3; i++) {
 const targetX = (i - 1) * 0.35;
 const startX = targetX - 2.0; // Start off-screen left
 const x = THREE.MathUtils.lerp(startX, targetX, eased);
 const y = -0.3;
 
 // Calculate rolling rotation based on distance traveled to reach FLAT position
 const distance = x - startX; // Distance rolled
 
 // Calculate rotation for accurate rolling that ends flat
 let rotation = 0;
 if (i === 0) {
 // Square: needs to align flat (multiple of p/2)
 const squarePerimeter = R * 2 * 4;
 const naturalRotation = -(distance / squarePerimeter) * (Math.PI * 2);
 // Snap to nearest p/2 when nearly stopped
 rotation = rollProgress > 0.95 ? Math.round(naturalRotation / (Math.PI / 2)) * (Math.PI / 2) : naturalRotation;
 } else if (i === 1) {
 // Triangle: needs to align flat (multiple of 2p/3)
 const trianglePerimeter = R * 2 * 3;
 const naturalRotation = -(distance / trianglePerimeter) * (Math.PI * 2);
 // Snap to nearest 2p/3 when nearly stopped (flat base)
 rotation = rollProgress > 0.95 ? Math.round(naturalRotation / (Math.PI * 2 / 3)) * (Math.PI * 2 / 3) : naturalRotation;
 } else {
 // Circle: any rotation is "flat"
 rotation = -(distance / (2 * Math.PI * R)) * (Math.PI * 2);
 }
 
 // Store final rotation when reaching target
 if (rollProgress > 0.98) {
 finalRollRotations[i] = rotation;
 }
 
 // Play continuous rolling thunks based on distance
 const rollDist = Math.abs(x - startX);
 const thunkInterval = 0.15; // Play thunk every 0.15 units rolled
 const expectedThunks = Math.floor(rollDist / thunkInterval);
 
 if (expectedThunks > lastThunkTime[i]) {
 playRollingThunk(0.06);
 lastThunkTime[i] = expectedThunks;
 }
 
 spheres[i].position.set(x, y, -i * 0.002);
 spheres[i].rotation.z = rotation;
 spheres[i].scale.set(introCfg.ballSize, introCfg.ballSize, introCfg.ballSize);
 triMat.uniforms.points.value[i].set(x, y);
 
 // Play final landing thunk
 if (!landingSounds[i] && Math.abs(x - targetX) < 0.02) {
 playRollingThunk(0.12);
 landingSounds[i] = true;
 }
 }
 blackHole.visible = false; // Hide during roll-in
 
 } else if (phase === 'bounce') {
 // Sequential bounces: left, then right, then middle
 const bounceT = t - introCfg.rollEnd;
 const baseY = -0.3;
 
 // Keep glow visible during bounce
 bloomPass.strength = 0.4;
 
 for (let i = 0; i < 3; i++) {
 const x = (i - 1) * 0.35;
 let y = baseY;
 
 // Sequence: 0 (left), 2 (right), 1 (middle)
 const bounceOrder = [0, 2, 1];
 const bounceIndex = bounceOrder.indexOf(i);
 const bounceStart = bounceIndex * introCfg.bounceDuration;
 const bounceEnd = bounceStart + introCfg.bounceDuration;
 
 if (bounceT >= bounceStart && bounceT <= bounceEnd) {
 const localT = (bounceT - bounceStart) / introCfg.bounceDuration;
 const bounce = Math.sin(localT * Math.PI) * introCfg.bounceHeight;
 y = baseY + bounce;
 
 // Play thud sounds for jump and land
 if (!window['bounceJump_' + i] && localT < 0.05) {
 playBounceThud(0.12);
 window['bounceJump_' + i] = true;
 }
 if (!window['bounceLand_' + i] && localT > 0.95) {
 playBounceThud(0.15);
 window['bounceLand_' + i] = true;
 }
 }
 
 spheres[i].position.set(x, y, -i * 0.002);
 spheres[i].rotation.z = finalRollRotations[i]; // Use exact rotation from roll phase
 spheres[i].scale.set(introCfg.ballSize, introCfg.ballSize, introCfg.ballSize);
 triMat.uniforms.points.value[i].set(x, y);
 }
 blackHole.visible = false; // Hide during bounce
 
 } else if (phase === 'triangle') {
 // Triangle phase: form ? converge ? grow & brighten
 const triangleProgress = (t - introCfg.bounceEnd) / (introCfg.triangleEnd - introCfg.bounceEnd);
 
 // Smooth cubic easing for entire phase
 const smoothEase = (p) => p < 0.5 ? 4 * p * p * p : 1 - Math.pow(-2 * p + 2, 3) / 2;
 
 // Sub-phases with smooth transitions
 const formProgress = Math.min(triangleProgress / 0.35, 1.0);
 const formEased = smoothEase(formProgress);
 
 const convergeStart = 0.35;
 const convergeProgress = triangleProgress > convergeStart ? Math.min((triangleProgress - convergeStart) / 0.25, 1.0) : 0;
 const convergeEased = smoothEase(convergeProgress);
 
 const growStart = 0.6;
 const growProgress = triangleProgress > growStart ? (triangleProgress - growStart) / 0.4 : 0;
 const growEased = smoothEase(growProgress);
 
 // Create EQUILATERAL triangle centered at origin
 const centerY = 0;
 const triangleRadius = 0.42; // Distance from center to each vertex (increased)
 
 // Equilateral triangle: vertices at 120 intervals, pointing up
 const triangleAngles = [
 Math.PI / 2 + (2 * Math.PI / 3) * 0, // Top (90 )
 Math.PI / 2 + (2 * Math.PI / 3) * 1, // Bottom-left (210 )
 Math.PI / 2 + (2 * Math.PI / 3) * 2 // Bottom-right (330 )
 ];
 
 // Rotation grows smoothly throughout
 const rotationAmount = growEased * 0.2;
 
 // Pulsing: breathe in/out during grow phase
 const pulseSpeed = 2.0;
 const pulsePhase = (t - introCfg.bounceEnd - growStart * (introCfg.triangleEnd - introCfg.bounceEnd)) * pulseSpeed;
 const pulseFactor = growProgress > 0 ? 1 + Math.sin(pulsePhase) * 0.08 : 1;
 
 // Converge factor - pull toward center during converge phase
 const convergeFactor = convergeEased * 0.12;
 
 // Map spheres to triangle positions: [0]=left?bottom-left, [1]=middle?top, [2]=right?bottom-right
 const triangleMapping = [1, 0, 2]; // sphere i goes to angle triangleMapping[i]
 
 for (let i = 0; i < 3; i++) {
 // Starting positions from the line (after bounce)
 const startX = (i - 1) * 0.35;
 const startY = -0.3;
 
 // Target positions in triangle formation (with correct mapping)
 const angleIndex = triangleMapping[i];
 const angle = triangleAngles[angleIndex] + rotationAmount;
 const targetRadius = triangleRadius * (1 - convergeFactor) * pulseFactor;
 const targetX = Math.cos(angle) * targetRadius;
 const targetY = Math.sin(angle) * targetRadius + centerY;
 
 // Interpolate from line to triangle formation
 const x = THREE.MathUtils.lerp(startX, targetX, formEased);
 const y = THREE.MathUtils.lerp(startY, targetY, formEased);
 
 spheres[i].position.set(x, y, -i * 0.002);
 spheres[i].rotation.z = 0; // Reset rotation for orbit phases
 
 // Scale: small ? stays small during form/converge ? grows large with overshoot
 let scale = introCfg.ballSize;
 if (formEased < 1) {
 scale = THREE.MathUtils.lerp(introCfg.ballSize, introCfg.ballSize * 1.0, formEased);
 } else {
 // Add subtle overshoot for organic feel
 const overshoot = Math.sin(growEased * Math.PI) * 0.08;
 scale = THREE.MathUtils.lerp(introCfg.ballSize * 1.0, introCfg.ballSize * 2.2, growEased) + overshoot;
 }
 
 spheres[i].scale.set(scale, scale, scale);
 triMat.uniforms.points.value[i].set(x, y);
 }
 
 blackHole.visible = true;
 blackHole.material.uniforms.pulseFactor.value = formEased * 0.4;
 
 } else if (phase === 'transition') {
 // Transform triangle into rotating circular orbit - organically
 // ALSO morph all shapes into circles
 const transProgress = (t - introCfg.triangleEnd) / (introCfg.transitionEnd - introCfg.triangleEnd);
 // Smooth cubic easing
 const eased = transProgress < 0.5 ? 
 4 * transProgress * transProgress * transProgress : 
 1 - Math.pow(-2 * transProgress + 2, 3) / 2;
 
 // Morph shapes into circles halfway through transition
 // Keep materials (colors) consistent - don't swap
 if (transProgress > 0.5 && spheres[0].geometry !== circleGeoTarget && spheres[1].geometry !== circleGeoTarget) {
 const mat0 = spheres[0].material;
 const mat1 = spheres[1].material;
 
 spheres[0].geometry.dispose();
 spheres[0].geometry = createCircle(R);
 spheres[0].material = mat0; // Preserve cyan
 
 spheres[1].geometry.dispose();
 spheres[1].geometry = createCircle(R);
 spheres[1].material = mat1; // Preserve yellow
 
 // spheres[2] is already a circle (magenta)
 }
 
 const centerY = 0;
 const triangleRadius = 0.42;
 
 // Use same equilateral triangle angles
 const triangleAngles = [
 Math.PI / 2 + (2 * Math.PI / 3) * 0,
 Math.PI / 2 + (2 * Math.PI / 3) * 1,
 Math.PI / 2 + (2 * Math.PI / 3) * 2
 ];
 
 // Starting radius (with 12% convergence from triangle phase)
 const startRadius = triangleRadius * (1 - 0.12);
 
 // Calculate rotation to match end of triangle phase (which uses rotationAmount = 0.2)
 // The triangle phase maps spheres with triangleMapping, so we need to continue from there
 const triangleEndRotation = 0.2; // matches growEased = 1.0 * 0.2
 const rotation = triangleEndRotation + (eased * Math.PI * 2);
 
 // Expand from triangle size to full orbit size
 const targetDist = motionCfg.maxDist * 0.5;
 const currentDist = THREE.MathUtils.lerp(startRadius, targetDist, eased);
 
 // Use same mapping as triangle phase
 const triangleMapping = [1, 0, 2];
 
 for (let i = 0; i < 3; i++) {
 const angleIndex = triangleMapping[i];
 const angle = triangleAngles[angleIndex] + rotation;
 const x = Math.cos(angle) * currentDist;
 const y = Math.sin(angle) * currentDist + centerY;
 
 spheres[i].position.set(x, y, -i * 0.002);
 spheres[i].rotation.z = 0;
 const scale = THREE.MathUtils.lerp(introCfg.ballSize * 2.2, 1.0, eased);
 spheres[i].scale.set(scale, scale, scale);
 triMat.uniforms.points.value[i].set(x, y);
 }
 blackHole.visible = true;
 blackHole.material.uniforms.pulseFactor.value = THREE.MathUtils.lerp(0.4, 0.5, eased);
 
 } else if (phase === 'normal') {
 const normalT = t - introCfg.transitionEnd;
 const convergeDuration = 2.2;
 const pulseDuration = 3.0; // One expand/contract cycle
 const transitionEndDist = motionCfg.maxDist * 0.5;
 const closeConvergeDist = 0.02; // Very close convergence
 const triangleExpandDist = motionCfg.maxDist * 0.65; // Expand to triangle

 const centerY = 0;
 const triangleAngles = [
 Math.PI / 2 + (2 * Math.PI / 3) * 0,
 Math.PI / 2 + (2 * Math.PI / 3) * 1,
 Math.PI / 2 + (2 * Math.PI / 3) * 2
 ];
 const transitionEndRotation = 0.2 + Math.PI * 2;
 const rotation = transitionEndRotation + (normalT * motionCfg.rotationSpeed);
 const triangleMapping = [1, 0, 2];

 let currentDist = transitionEndDist;
 let scale = 1.0;
 let pulseFactorValue = 0.5;

 if (normalT < convergeDuration) {
 // Phase 1: Converge close
 const convergeProgress = THREE.MathUtils.clamp(normalT / convergeDuration, 0, 1);
 const convergeEased = convergeProgress * convergeProgress * (3 - 2 * convergeProgress);
 currentDist = THREE.MathUtils.lerp(transitionEndDist, closeConvergeDist, convergeEased);
 scale = THREE.MathUtils.lerp(1.0, 0.82, convergeEased);
 pulseFactorValue = THREE.MathUtils.lerp(0.5, 0.95, convergeEased);
 } else if (normalT < convergeDuration + pulseDuration) {
 // Phase 2: Single expand/contract pulse
 const pulseT = normalT - convergeDuration;
 const pulseProgress = pulseT / pulseDuration;
 
 // Use sine wave for smooth expand/contract (0->1->0)
 const pulseCycle = Math.sin(pulseProgress * Math.PI);
 
 currentDist = THREE.MathUtils.lerp(closeConvergeDist, triangleExpandDist, pulseCycle);
 scale = THREE.MathUtils.lerp(0.82, 1.0, pulseCycle);
 pulseFactorValue = THREE.MathUtils.lerp(0.95, 0.6, pulseCycle);
 } else {
 // Phase 3: Hold at converged position before transitioning to venn
 currentDist = closeConvergeDist;
 scale = 0.82;
 pulseFactorValue = 0.95;
 }

 for (let i = 0; i < 3; i++) {
 const angleIndex = triangleMapping[i];
 const angle = triangleAngles[angleIndex] + rotation;
 const p = new THREE.Vector2(
 Math.cos(angle) * currentDist,
 Math.sin(angle) * currentDist + centerY
 );
 spheres[i].position.set(p.x, p.y, -i * 0.002);
 spheres[i].rotation.z = 0;
 spheres[i].scale.set(scale, scale, scale);
 triMat.uniforms.points.value[i].copy(p);
 }
 blackHole.visible = true;
 blackHole.material.uniforms.pulseFactor.value = pulseFactorValue;

 } else if (phase === 'venn') {
 // Slow down and form clear venn diagram
 const vennProgress = (t - introCfg.normalEnd) / (introCfg.vennEnd - introCfg.normalEnd);
 // Smooth cubic easing
 const eased = vennProgress < 0.5 ? 
 4 * vennProgress * vennProgress * vennProgress : 
 1 - Math.pow(-2 * vennProgress + 2, 3) / 2;
 
 const normalDuration = introCfg.normalEnd - introCfg.transitionEnd;
 const centerY = 0;
 
 const triangleAngles = [
 Math.PI / 2 + (2 * Math.PI / 3) * 0,
 Math.PI / 2 + (2 * Math.PI / 3) * 1,
 Math.PI / 2 + (2 * Math.PI / 3) * 2
 ];
 
 // Start from where normal ended: transitionEndRotation + normalDuration * rotationSpeed
 const transitionEndRotation = 0.2 + Math.PI * 2;
 const baseRotation = transitionEndRotation + (normalDuration * motionCfg.rotationSpeed);
 const vennT = t - introCfg.normalEnd;
 const slowRotation = baseRotation + (vennT * motionCfg.rotationSpeed * 0.3); // Slow down to 30%
 
 // Settle into venn diagram distance - calculate what pulse factor was at END of normal phase
 const normalEndTime = introCfg.normalEnd - introCfg.transitionEnd;
 const startPulseFactor = 0.5 + 0.5 * Math.sin(normalEndTime * motionCfg.speed);
 const startDist = motionCfg.maxDist * startPulseFactor;
 const targetDist = 0.08; // Very close for dramatic overlap
 const currentDist = THREE.MathUtils.lerp(startDist, targetDist, eased);
 const scale = THREE.MathUtils.lerp(1.0, 0.7, eased); // Much larger for awesome venn!

 // Use same mapping as triangle phase
 const triangleMapping = [1, 0, 2];

 for (let i = 0; i < 3; i++) {
 const angleIndex = triangleMapping[i];
 const angle = triangleAngles[angleIndex] + slowRotation;
 const p = new THREE.Vector2(
 Math.cos(angle) * currentDist,
 Math.sin(angle) * currentDist + centerY
 );
 spheres[i].position.set(p.x, p.y, -i * 0.002);
 spheres[i].rotation.z = 0;
 spheres[i].scale.set(scale, scale, scale);
 triMat.uniforms.points.value[i].copy(p);
 }
 blackHole.visible = true;
 blackHole.material.uniforms.pulseFactor.value = THREE.MathUtils.lerp(startPulseFactor, 0.6, eased);
 
 if (!quoteShown) {
 applyQuoteState(quoteStates.initial, { immediate: true });
 quoteEl.classList.remove('scrambling', 'glitch', 'glitchMedium', 'glitchIntense');
 document.getElementById('quote').classList.add('visible');
 quoteDespairShown = false;
 quoteShown = true;
 }
 
 } else if (phase === 'collapse') {
 // Grow and collapse into white radiating circle
 const collapseProgress = (t - introCfg.vennEnd) / (introCfg.collapseEnd - introCfg.vennEnd);
 // Smooth cubic easing
 const eased = collapseProgress < 0.5 ? 
 4 * collapseProgress * collapseProgress * collapseProgress : 
 1 - Math.pow(-2 * collapseProgress + 2, 3) / 2;
 
 const centerY = 0;
 
 const triangleAngles = [
 Math.PI / 2 + (2 * Math.PI / 3) * 0,
 Math.PI / 2 + (2 * Math.PI / 3) * 1,
 Math.PI / 2 + (2 * Math.PI / 3) * 2
 ];
 
 // Start from where venn ended
 const transitionEndRotation = 0.2 + Math.PI * 2;
 const normalDuration = introCfg.normalEnd - introCfg.transitionEnd;
 const vennDuration = introCfg.vennEnd - introCfg.normalEnd;
 const baseRotation = transitionEndRotation + (normalDuration * motionCfg.rotationSpeed) + (vennDuration * motionCfg.rotationSpeed * 0.3);
 const collapseT = t - introCfg.vennEnd;
 const rotation = baseRotation + (collapseT * motionCfg.rotationSpeed * 0.15); // Even slower
 
 // Collapse to tiny overlap while growing in size
 const startDist = 0.08;
 const targetDist = 0.005;
 const currentDist = THREE.MathUtils.lerp(startDist, targetDist, eased);
 const scale = THREE.MathUtils.lerp(0.7, 0.85, eased); // Massive spheres!

 // Use same mapping as triangle phase
 const triangleMapping = [1, 0, 2];

 for (let i = 0; i < 3; i++) {
 const angleIndex = triangleMapping[i];
 const angle = triangleAngles[angleIndex] + rotation;
 const p = new THREE.Vector2(
 Math.cos(angle) * currentDist,
 Math.sin(angle) * currentDist + centerY
 );
 spheres[i].position.set(p.x, p.y, -i * 0.002);
 spheres[i].rotation.z = 0;
 spheres[i].scale.set(scale, scale, scale);
 triMat.uniforms.points.value[i].copy(p);
 }
 blackHole.visible = true;
 blackHole.material.uniforms.pulseFactor.value = THREE.MathUtils.lerp(0.6, 0.85, eased);
 
 if (collapseProgress > 0.3 && !glitchStarted) {
 document.getElementById('quote').classList.add('glitch');
 glitchStarted = true;
 }
 
 } else if (phase === 'glitch' || phase === 'blackout' || phase === 'loomworks' || phase === 'celli') {
 // Hide spheres during ending sequence, keep last position
 const centerY = 0;
 const targetDist = 0.005;
 const scale = 0.85;
 
 const triangleAngles = [
 Math.PI / 2 + (2 * Math.PI / 3) * 0,
 Math.PI / 2 + (2 * Math.PI / 3) * 1,
 Math.PI / 2 + (2 * Math.PI / 3) * 2
 ];
 
 const slowRotation = t * 0.05;
 
 // Fade out spheres during glitch phase
 let sphereOpacity = 1.0;
 if (phase === 'glitch') {
 const glitchProgress = (t - introCfg.collapseEnd) / (introCfg.glitchEnd - introCfg.collapseEnd);
 sphereOpacity = THREE.MathUtils.lerp(1.0, 0, glitchProgress);
 if (glitchProgress > 0.25 && !quoteDespairShown) {
 glitchSwapQuote(quoteStates.despair, { duration: 950, onComplete: () => quoteEl.classList.add('quote--loom') });
 quoteDespairShown = true;
 }
 } else {
 sphereOpacity = 0;
 }
 
 // Use same mapping as triangle phase
 const triangleMapping = [1, 0, 2];
 
 for (let i = 0; i < 3; i++) {
 const angleIndex = triangleMapping[i];
 const angle = triangleAngles[angleIndex] + slowRotation;
 const p = new THREE.Vector2(
 Math.cos(angle) * targetDist,
 Math.sin(angle) * targetDist + centerY
 );
 spheres[i].position.set(p.x, p.y, -i * 0.002);
 spheres[i].rotation.z = 0;
 spheres[i].scale.set(scale, scale, scale);
 spheres[i].material.opacity = sphereOpacity;
 triMat.uniforms.points.value[i].copy(p);
 }

blackHole.visible = phase === 'glitch';
if (phase === 'glitch') {
const glitchProgress = (t - introCfg.collapseEnd) / (introCfg.glitchEnd - introCfg.collapseEnd);
blackHole.material.uniforms.pulseFactor.value = THREE.MathUtils.lerp(0.85, 0, glitchProgress);
}
}
}

// --- Responsive ---------------------------------------------------------
function onResize(){
 renderer.setSize(window.innerWidth, window.innerHeight);
 composer.setSize(window.innerWidth, window.innerHeight);
 const aspect = window.innerWidth / window.innerHeight;
 triMat.uniforms.aspect.value = aspect;
 if (aspect > 1) { // Landscape
 camera.left = -aspect; camera.right = aspect; camera.top = 1; camera.bottom = -1;
 // Scale black hole to maintain circularity
 blackHole.scale.set(1, 1, 1);
 } else { // Portrait
 camera.left = -1; camera.right = 1; camera.top = 1 / aspect; camera.bottom = -1 / aspect;
 // Scale black hole to maintain circularity
 blackHole.scale.set(aspect, aspect, 1);
 }
 camera.updateProjectionMatrix();
 
 // Recalculate CELLI scale for responsive layout
 const oldScale = celliScale;
 calculateCelliScale();

 // Update voxel positions and scales based on new scale
 if (oldScale !== celliScale) {
 const scaleRatio = celliScale / oldScale;
 voxels.forEach((voxel) => {
 const data = voxel.userData;
 // Update positions with new scale
 data.targetX *= scaleRatio;
 data.targetY *= scaleRatio;
 data.baseScale = celliScale;

 // Update actual positions if settled
 if (data.settled) {
 voxel.position.x = data.targetX;
 voxel.position.y = data.targetY;
 }

 // Update scale
 voxel.scale.set(celliScale, celliScale, celliScale);
 });
 }

 if (bowActive) {
 moveBowToTarget(true);
 }
 }
window.addEventListener('resize', onResize);
onResize();

// --- Animate (gated by Play) -------------------------------------------
window.running = running; // Make globally accessible for scene transitions
 
 // Canvas for text particles
 const textCanvas = document.createElement('canvas');
 textCanvas.style.position = 'fixed';
 textCanvas.style.inset = '0';
 textCanvas.style.pointerEvents = 'none';
 textCanvas.style.zIndex = '5';
 document.body.appendChild(textCanvas);
 const textCtx = textCanvas.getContext('2d');
 
 function resizeTextCanvas() {
 textCanvas.width = window.innerWidth;
 textCanvas.height = window.innerHeight;
 }
 resizeTextCanvas();
 window.addEventListener('resize', resizeTextCanvas);
 
 // Gentle thunk sound for rolling (lighter than landing)
 function playRollingThunk(volume = 0.08, delay = 0) {
 if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); window.audioCtx = audioCtx; }
 const now = audioCtx.currentTime + delay;
 
 // Subtle rolling "tap" sound
 const osc = audioCtx.createOscillator();
 const gain = audioCtx.createGain();
 
 osc.type = 'sine';
 osc.frequency.setValueAtTime(100 + Math.random() * 20, now); // Slight variation
 osc.frequency.exponentialRampToValueAtTime(50, now + 0.05);
 
 gain.gain.setValueAtTime(volume, now);
 gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
 
 osc.connect(gain);
 gain.connect(audioCtx.destination);
 osc.start(now);
 osc.stop(now + 0.15);
 }
 
 // Heavier thud for jumps and landings
 function playBounceThud(volume = 0.15, delay = 0) {
 if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); window.audioCtx = audioCtx; }
 const now = audioCtx.currentTime + delay;
 
 // Deep impact sound
 const osc = audioCtx.createOscillator();
 const gain = audioCtx.createGain();
 
 osc.type = 'sine';
 osc.frequency.setValueAtTime(60, now); // Deep thud
 osc.frequency.exponentialRampToValueAtTime(30, now + 0.15);
 
 gain.gain.setValueAtTime(volume, now);
 gain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
 
 osc.connect(gain);
 gain.connect(audioCtx.destination);
 osc.start(now);
 osc.stop(now + 0.25);
 }
 
 // Hollow melodic chime for voxel landing - C pentatonic scale
 function playVoxelChime(delay = 0) {
 if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); window.audioCtx = audioCtx; }
 const now = audioCtx.currentTime + delay;
 
 // Pentatonic scale notes for melodic chimes (C, D, E, G, A)
 const pentatonicNotes = [523.25, 587.33, 659.25, 783.99, 880]; // C5, D5, E5, G5, A5
 const fundamentalFreq = pentatonicNotes[Math.floor(Math.random() * pentatonicNotes.length)];
 
 // Hollow sound: triangle wave with filtered overtones
 const osc1 = audioCtx.createOscillator();
 const osc2 = audioCtx.createOscillator();
 const osc3 = audioCtx.createOscillator();
 const filter = audioCtx.createBiquadFilter();
 const gain = audioCtx.createGain();
 
 osc1.type = 'triangle'; // Hollow fundamental
 osc1.frequency.setValueAtTime(fundamentalFreq, now);
 
 osc2.type = 'sine'; // Soft overtone
 osc2.frequency.setValueAtTime(fundamentalFreq * 3, now);
 
 osc3.type = 'sine'; // Gentle fifth
 osc3.frequency.setValueAtTime(fundamentalFreq * 1.5, now);
 
 // Band-pass filter for hollow character
 filter.type = 'bandpass';
 filter.frequency.setValueAtTime(fundamentalFreq * 2, now);
 filter.Q.setValueAtTime(2, now);
 
 // Gentle envelope
 gain.gain.setValueAtTime(0, now);
 gain.gain.linearRampToValueAtTime(0.03, now + 0.01);
 gain.gain.exponentialRampToValueAtTime(0.001, now + 1.2);
 
 osc1.connect(filter);
 osc2.connect(gain);
 osc3.connect(gain);
 filter.connect(gain);
 gain.connect(audioCtx.destination);
 
 osc1.start(now);
 osc2.start(now);
 osc3.start(now);
 osc1.stop(now + 1.2);
 osc2.stop(now + 1.2);
 osc3.stop(now + 1.2);
 }
 
 // Chiptune music system - simple arpeggio + drums
 let chiptuneBass = null;
 let chiptuneGain = null;
 let lastNoteTime = 0;
 let lastDrumTime = 0;
 let noteIndex = 0;
 let drumIndex = 0;
 let musicStarted = false;
 let reverbDelay = null;
 let reverbGain = null;
 let reverbFeedback = null;
 let glitchWhirOsc1 = null;
 let glitchWhirOsc2 = null;
 let glitchWhirOsc3 = null;
 let glitchWhirGain = null;
 let glitchWhirFilter = null;
 let glitchWhirStarted = false;
 
 function updateSynth(t) {
 // Start music during triangle phase
 if (!musicStarted && t > introCfg.bounceEnd) {
 if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); window.audioCtx = audioCtx; }
 
 // Create reverb delay effect
 reverbDelay = audioCtx.createDelay(2.0);
 reverbDelay.delayTime.value = 0.25; // 250ms delay
 reverbGain = audioCtx.createGain();
 reverbGain.gain.value = 0.3; // Moderate reverb mix
 reverbFeedback = audioCtx.createGain();
 reverbFeedback.gain.value = 0.4; // Feedback for reverb tail
 
 // Wire up reverb: delay -> feedback -> delay (loop) + output
 reverbDelay.connect(reverbFeedback);
 reverbFeedback.connect(reverbDelay);
 reverbDelay.connect(reverbGain);
 reverbGain.connect(audioCtx.destination);
 
 musicStarted = true;
 lastNoteTime = t;
 lastDrumTime = t;
 }
 
 if (!musicStarted || !audioCtx) return;
 
 const now = audioCtx.currentTime;
 
 // Determine arpeggio and rhythm based on phase
 let arpeggio = [];
 let noteSpeed = 0.25;
 let drumSpeed = 0.5;
 let drumVolume = 0.12;
 let drumReverb = 0.2;
 let reverbMix = 0.3;
 let glitchLevel = 0;
 
 if (t < introCfg.triangleEnd) {
 // Calm, contemplative Am progression
 arpeggio = [220.00, 261.63, 329.63, 261.63]; // A3, C4, E4, C4
 noteSpeed = 0.5;
 drumSpeed = 1.2;
 drumVolume = 0.08;
 drumReverb = 0.25;
 reverbMix = 0.35;
 } else if (t < introCfg.normalEnd) {
 // Gentle progression with suspension
 arpeggio = [220.00, 246.94, 293.66, 329.63, 293.66, 246.94]; // A3, B3, D4, E4, D4, B3
 noteSpeed = 0.45;
 drumSpeed = 1.0;
 drumVolume = 0.1;
 drumReverb = 0.3;
 reverbMix = 0.4;
 } else if (t < introCfg.vennEnd) {
 // Subdued, introspective
 arpeggio = [196.00, 246.94, 293.66, 349.23, 293.66, 246.94]; // G3, B3, D4, F4, D4, B3
 noteSpeed = 0.4;
 drumSpeed = 0.9;
 drumVolume = 0.12;
 drumReverb = 0.4;
 reverbMix = 0.45;
 } else if (t < introCfg.collapseEnd) {
 // Building unease, drums more present
 arpeggio = [220.00, 277.18, 329.63, 392.00, 329.63, 277.18]; // A3, C#4, E4, G4, E4, C#4
 noteSpeed = 0.38;
 drumSpeed = 0.7;
 drumVolume = 0.16; // Drums becoming more prominent
 drumReverb = 0.6;
 reverbMix = 0.5;
 glitchLevel = 0.1;
 } else if (t < introCfg.glitchEnd) {
 // Dissonant breakdown, drums dominate
 const glitchProgress = (t - introCfg.collapseEnd) / (introCfg.glitchEnd - introCfg.collapseEnd);
 arpeggio = [233.08, 277.18, 369.99, 415.30]; // Diminished, unsettling
 noteSpeed = 0.35;
 drumSpeed = 0.55;
 drumVolume = THREE.MathUtils.lerp(0.18, 0.28, glitchProgress); // Drums take over
 drumReverb = THREE.MathUtils.lerp(0.6, 0.85, glitchProgress);
 reverbMix = THREE.MathUtils.lerp(0.5, 0.65, glitchProgress);
 glitchLevel = THREE.MathUtils.lerp(0.2, 0.8, glitchProgress);
 } else {
 return;
 }
 
 // Update reverb mix
 if (reverbGain) {
 reverbGain.gain.setTargetAtTime(reverbMix, now, 0.5);
 }
 
 // Play arpeggio notes
 if (t - lastNoteTime >= noteSpeed) {
 const freq = arpeggio[noteIndex % arpeggio.length];
 playChiptuneNote(freq, noteSpeed * 0.9, glitchLevel, reverbDelay);
 noteIndex++;
 lastNoteTime = t;
 }
 
 // Play drum beats
 if (t - lastDrumTime >= drumSpeed) {
 playChiptuneDrum(drumVolume, drumReverb, glitchLevel, reverbDelay);
 drumIndex++;
 lastDrumTime = t;
 }
 
 // Corrupted whir during glitch phase
 if (t >= introCfg.collapseEnd && t < introCfg.glitchEnd) {
 const glitchProgress = (t - introCfg.collapseEnd) / (introCfg.glitchEnd - introCfg.collapseEnd);
 
 if (!glitchWhirStarted) {
 // Start the harsh whirring synth
 glitchWhirOsc1 = audioCtx.createOscillator();
 glitchWhirOsc2 = audioCtx.createOscillator();
 glitchWhirOsc3 = audioCtx.createOscillator();
 glitchWhirGain = audioCtx.createGain();
 glitchWhirFilter = audioCtx.createBiquadFilter();
 
 // Triangle waves for harsh, mechanical sound
 glitchWhirOsc1.type = 'triangle';
 glitchWhirOsc2.type = 'triangle';
 glitchWhirOsc3.type = 'triangle';
 
 // Detuning for thickness
 glitchWhirOsc1.detune.value = -8;
 glitchWhirOsc2.detune.value = 0;
 glitchWhirOsc3.detune.value = 8;
 
 // Start at low frequency
 glitchWhirOsc1.frequency.setValueAtTime(220, now);
 glitchWhirOsc2.frequency.setValueAtTime(220, now);
 glitchWhirOsc3.frequency.setValueAtTime(220, now);
 
 // Resonant filter for harsh whir
 glitchWhirFilter.type = 'lowpass';
 glitchWhirFilter.frequency.setValueAtTime(400, now);
 glitchWhirFilter.Q.setValueAtTime(8, now);
 
 glitchWhirGain.gain.setValueAtTime(0, now);
 glitchWhirGain.gain.linearRampToValueAtTime(0.08, now + 0.5);
 
 glitchWhirOsc1.connect(glitchWhirFilter);
 glitchWhirOsc2.connect(glitchWhirFilter);
 glitchWhirOsc3.connect(glitchWhirFilter);
 glitchWhirFilter.connect(glitchWhirGain);
 glitchWhirGain.connect(audioCtx.destination);
 
 glitchWhirOsc1.start(now);
 glitchWhirOsc2.start(now);
 glitchWhirOsc3.start(now);
 
 glitchWhirStarted = true;
 }
 
 // Modulate frequency for failing sound
 if (glitchWhirOsc1) {
 const crackle = Math.sin(t * 100) * 20 * glitchProgress;
 const whir = Math.sin(t * 30) * 10;
 const baseFreq = THREE.MathUtils.lerp(220, 55, glitchProgress); // Pitch down as it fails
 
 glitchWhirOsc1.frequency.setTargetAtTime(baseFreq + crackle + whir, now, 0.02);
 glitchWhirOsc2.frequency.setTargetAtTime(baseFreq + crackle + whir * 1.1, now, 0.02);
 glitchWhirOsc3.frequency.setTargetAtTime(baseFreq + crackle + whir * 0.9, now, 0.02);
 
 // Filter sweep downward
 glitchWhirFilter.frequency.setTargetAtTime(THREE.MathUtils.lerp(400, 100, glitchProgress), now, 0.1);
 
 // Volume swell and fade
 const vroomPhase = Math.sin(t * 2) * 0.5 + 0.5;
 const fadeOut = 1 - glitchProgress * 0.7; // Fade out near end
 glitchWhirGain.gain.setTargetAtTime(0.08 * fadeOut * vroomPhase, now, 0.05);
 }
 } else if (glitchWhirStarted && glitchWhirOsc1) {
 // Stop the whir after glitch phase
 glitchWhirOsc1.stop(now + 0.5);
 glitchWhirOsc2.stop(now + 0.5);
 glitchWhirOsc3.stop(now + 0.5);
 glitchWhirOsc1 = null;
 glitchWhirOsc2 = null;
 glitchWhirOsc3 = null;
 }
 }
 
 // Chiptune note player - muted, musical synth
 function playChiptuneNote(freq, duration, glitchLevel = 0, reverbNode = null) {
 if (!audioCtx) return;
 const now = audioCtx.currentTime;
 
 const osc1 = audioCtx.createOscillator();
 const osc2 = audioCtx.createOscillator();
 const gain = audioCtx.createGain();
 const filter = audioCtx.createBiquadFilter();
 
 // Sine waves for muted, warm tone
 osc1.type = 'sine';
 osc2.type = 'sine';
 
 // Add subtle harmonic (5th) for richness
 const glitchWobble = glitchLevel > 0 ? (Math.random() - 0.5) * freq * glitchLevel * 0.2 : 0;
 osc1.frequency.setValueAtTime(freq + glitchWobble, now);
 osc2.frequency.setValueAtTime((freq * 1.5) + glitchWobble, now); // Perfect 5th
 
 // Muted low-pass filter
 filter.type = 'lowpass';
 filter.frequency.setValueAtTime(glitchLevel > 0.5 ? 600 : 1200, now);
 filter.Q.setValueAtTime(0.3, now);
 
 // Very soft, gentle envelope
 const baseVol = 0.045 * (1 - glitchLevel * 0.3);
 gain.gain.setValueAtTime(0, now);
 gain.gain.linearRampToValueAtTime(baseVol, now + 0.03);
 gain.gain.setValueAtTime(baseVol * 0.85, now + duration * 0.5);
 gain.gain.linearRampToValueAtTime(0, now + duration);
 
 osc1.connect(filter);
 osc2.connect(filter);
 filter.connect(gain);
 gain.connect(audioCtx.destination);
 
 // Connect to reverb if available
 if (reverbNode) {
 gain.connect(reverbNode);
 }
 
 osc1.start(now);
 osc2.start(now);
 osc1.stop(now + duration);
 osc2.stop(now + duration);
 }
 
 // Startup bass sound (Simple warm chord - NO REVERB to prevent oscillation)
 function playStartupBass() {
 if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); window.audioCtx = audioCtx; }
 const now = audioCtx.currentTime;
 
 // Master output - simple, clean
 const masterGain = audioCtx.createGain();
 masterGain.gain.value = 0.4;
 masterGain.connect(audioCtx.destination);
 
 // Simple warm chord - C major
 const chordNotes = [
 { freq: 130.81, vol: 0.10 }, // C3
 { freq: 164.81, vol: 0.08 }, // E3
 { freq: 196.00, vol: 0.07 }, // G3
 { freq: 65.41, vol: 0.09 }, // C2 (bass)
 ];
 
 chordNotes.forEach((note, i) => {
 const osc = audioCtx.createOscillator();
 const oscGain = audioCtx.createGain();
 
 osc.type = 'sine';
 osc.frequency.value = note.freq; // Fixed frequency, no modulation
 
 // Simple envelope
 const delay = i * 0.08;
 oscGain.gain.setValueAtTime(0, now + delay);
 oscGain.gain.linearRampToValueAtTime(note.vol, now + delay + 0.15);
 oscGain.gain.setValueAtTime(note.vol * 0.9, now + delay + 0.6);
 oscGain.gain.linearRampToValueAtTime(0, now + delay + 1.5);
 
 osc.connect(oscGain);
 oscGain.connect(masterGain);
 
 osc.start(now + delay);
 osc.stop(now + delay + 1.6);
 });
 }
 
 // Distorted startup bass sound - progressively more distorted per click
 function playStartupBassDistorted(clickCount = 1) {
 if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); window.audioCtx = audioCtx; }
 const now = audioCtx.currentTime;
 
 // Distortion increases with each click
 const distortionLevel = clickCount * 0.3; // 0.3, 0.6, 0.9
 
 // Master output with distortion
 const masterGain = audioCtx.createGain();
 masterGain.gain.value = 0.4;
 
 // Add waveshaper for distortion
 const distortion = audioCtx.createWaveShaper();
 const curve = new Float32Array(256);
 const deg = Math.PI / 180;
 const amount = distortionLevel * 100; // 30, 60, 90
 for (let i = 0; i < 256; i++) {
 const x = (i * 2) / 256 - 1;
 curve[i] = ((3 + amount) * x * 20 * deg) / (Math.PI + amount * Math.abs(x));
 }
 distortion.curve = curve;
 distortion.oversample = '4x';
 
 masterGain.connect(distortion);
 distortion.connect(audioCtx.destination);
 
 // Chord notes with detuning that increases per click
 const chordNotes = [
 { freq: 130.81, vol: 0.10 }, // C3
 { freq: 164.81, vol: 0.08 }, // E3
 { freq: 196.00, vol: 0.07 }, // G3
 { freq: 65.41, vol: 0.09 }, // C2 (bass)
 ];
 
 chordNotes.forEach((note, i) => {
 const osc = audioCtx.createOscillator();
 const oscGain = audioCtx.createGain();
 const filter = audioCtx.createBiquadFilter();
 
 osc.type = 'sawtooth'; // More harmonics for distortion
 
 // Add detuning/wobble based on click count
 const detune = (Math.random() - 0.5) * clickCount * 15;
 osc.frequency.setValueAtTime(note.freq + detune, now);
 
 // Add frequency wobble during playback
 osc.frequency.linearRampToValueAtTime(note.freq + detune * 1.5, now + 0.3);
 osc.frequency.linearRampToValueAtTime(note.freq + detune * 0.5, now + 1.0);
 
 // Filter gets more aggressive with each click
 filter.type = 'lowpass';
 filter.frequency.setValueAtTime(2000 - clickCount * 400, now);
 filter.Q.value = 1 + clickCount * 0.5;
 
 // Envelope
 const delay = i * 0.08;
 oscGain.gain.setValueAtTime(0, now + delay);
 oscGain.gain.linearRampToValueAtTime(note.vol * (1 + distortionLevel * 0.3), now + delay + 0.15);
 oscGain.gain.setValueAtTime(note.vol * 0.9, now + delay + 0.6);
 oscGain.gain.linearRampToValueAtTime(0, now + delay + 1.5);
 
 osc.connect(filter);
 filter.connect(oscGain);
 oscGain.connect(masterGain);
 
 osc.start(now + delay);
 osc.stop(now + delay + 1.6);
 });
 
 // Add noise for extra degradation on later clicks
 if (clickCount >= 2) {
 const noiseBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 1.5, audioCtx.sampleRate);
 const noiseData = noiseBuffer.getChannelData(0);
 for (let i = 0; i < noiseData.length; i++) {
 noiseData[i] = (Math.random() * 2 - 1) * 0.1 * (clickCount - 1);
 }
 const noiseSource = audioCtx.createBufferSource();
 const noiseGain = audioCtx.createGain();
 noiseSource.buffer = noiseBuffer;
 noiseGain.gain.setValueAtTime(0, now);
 noiseGain.gain.linearRampToValueAtTime(0.05 * clickCount, now + 0.2);
 noiseGain.gain.linearRampToValueAtTime(0, now + 1.4);
 noiseSource.connect(noiseGain);
 noiseGain.connect(masterGain);
 noiseSource.start(now);
 noiseSource.stop(now + 1.5);
 }
 }
 
 // Chiptune drum player
 function playChiptuneDrum(volume = 0.12, reverbAmount = 0.3, glitchLevel = 0, reverbNode = null) {
 if (!audioCtx) return;
 const now = audioCtx.currentTime;
 
 // Kick drum
 const osc = audioCtx.createOscillator();
 const gain = audioCtx.createGain();
 const reverbSend = audioCtx.createGain();
 
 osc.type = 'sine';
 const startFreq = glitchLevel > 0.5 ? 80 + Math.random() * 40 : 60;
 osc.frequency.setValueAtTime(startFreq, now);
 osc.frequency.exponentialRampToValueAtTime(30, now + 0.1);
 
 // Main drum volume (dominant)
 gain.gain.setValueAtTime(volume, now);
 gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
 
 // Reverb send amount
 reverbSend.gain.setValueAtTime(volume * reverbAmount, now);
 reverbSend.gain.exponentialRampToValueAtTime(0.001, now + 0.3); // Longer reverb tail
 
 osc.connect(gain);
 gain.connect(audioCtx.destination);
 
 // Send to reverb
 if (reverbNode) {
 osc.connect(reverbSend);
 reverbSend.connect(reverbNode);
 }
 
 osc.start(now);
 osc.stop(now + 0.3);
 }
 
 function frame(){
 if(!running) return;
 const dt = Math.min(clock.getDelta(), 0.033);
 totalTime += dt;
 updatePositions(totalTime);
 updateSynth(totalTime);
 blackHole.material.uniforms.time.value = totalTime;
 filmPass.uniforms.time.value += dt;
 composer.render();
 
 // Update and render text particles
 updateTextParticles(dt);
 textCtx.clearRect(0, 0, textCanvas.width, textCanvas.height);
 renderTextParticles(textCtx, camera);
 
 // Update voxels for CELLI animation
 updateVoxels(totalTime, dt);
 
 // Update floating voxels during burst
 updateFloatingVoxels(dt);
 
 // Update camera pan
 updateCameraPan();
 
 requestAnimationFrame(frame);
 }
 
 // Expose frame and scene elements to window for button handlers
 window.frame = frame;
 window.quoteEl = quoteEl;
 window.loomworksEl = loomworksEl;
 window.blackHole = blackHole;
 window.triMesh = triMesh;
 window.spheres = spheres;
 window.introCfg = introCfg;
 window.playStartupBass = playStartupBass;
 window.showVisiCalc = showVisiCalc;
 window.startCellAddressSequence = startCellAddressSequence;
 
 // Expose celliStarted and celliStartTime with getters/setters
 Object.defineProperty(window, 'celliStarted', {
  get: () => celliStarted,
  set: (val) => { celliStarted = val; }
 });
 Object.defineProperty(window, 'celliStartTime', {
  get: () => celliStartTime,
  set: (val) => { celliStartTime = val; }
 });

 // --- Click interaction on spheres and black hole ----------------------------------------
 const raycaster = new THREE.Raycaster();
 const mouse = new THREE.Vector2();
 
renderer.domElement.addEventListener('click', (event) => {
if (!running) return;

// Don't allow clicks if fullhand/execution environment is active
if (window.fullhandActive) {
console.log('?? Click ignored - fullhand scene is active');
return;
}

// Don't allow clicks to trigger VisiCalc during narrative sequence
if (window.narrativeSequence && window.narrativeSequence.active && window.narrativeSequence.phase !== 'complete') {
console.log('?? Click ignored - narrative sequence is active');
return;
}

mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

raycaster.setFromCamera(mouse, camera);

// Check black hole first - make it clickable whenever visible
const blackHoleIntersects = raycaster.intersectObject(blackHole, true);
console.log('?? Black hole visible:', blackHole.visible, 'Intersects:', blackHoleIntersects.length);
if (blackHoleIntersects.length > 0 && blackHole.visible) {
console.log('??? Black hole clicked - showing VisiCalc');
localStorage.setItem('megred_seen_blackhole', 'true');
showVisiCalc();
return;
}
 
 // Then check spheres
 const intersects = raycaster.intersectObjects(spheres);
 
 if (intersects.length > 0) {
 const hitSphere = intersects[0].object;
 const sphereIndex = spheres.indexOf(hitSphere);
 const hitPos = intersects[0].point;
 
 // Burst particles based on color
 let texts, color;
 if (sphereIndex === 0) { // Cyan - equations
 texts = equationTexts;
 color = '#00a8ff';
 } else if (sphereIndex === 1) { // Yellow - time
 texts = Array(8).fill(0).map(() => timeTexts());
 color = '#ffb62e';
 } else { // Magenta - manic
 texts = manicTexts;
 color = '#ff1e6e';
 }
 
 // Create burst of 5-8 particles
 const count = 5 + Math.floor(Math.random() * 4);
 for (let i = 0; i < count; i++) {
 const text = texts[Math.floor(Math.random() * texts.length)];
 createTextParticle(hitPos.x, hitPos.y, text, color, sphereIndex);
 }
 }
 });

 // --- Doorway input keyboard and click interaction ------------------------------------
 const promptContainer = document.querySelector('.prompt-container');
 const promptTextEl = document.getElementById('promptText');
 const promptCursorEl = document.getElementById('promptCursor');
 const hiddenInput = document.getElementById('hiddenInput');
 const promptEl = document.querySelector('.prompt');
 
 // Helper function to wrap each character with per-character shadow
 function updatePromptWithChars(text) {
 if (!promptTextEl) return;
 promptTextEl.innerHTML = '';
 for (let i = 0; i < text.length; i++) {
 const char = text[i];
 const span = document.createElement('span');
 span.className = 'char';
 span.setAttribute('data-char', char);
 span.textContent = char;
 promptTextEl.appendChild(span);
 }
 }
 
 // Click to trigger CELLI glitch (reveal T) and focus hidden input for mobile
 if (promptContainer) {
 function focusHiddenPromptInput() {
 if (!hiddenInput) return;

 hiddenInput.value = '';

 const focusOptions = { preventScroll: true };
 try {
 hiddenInput.focus(focusOptions);
 } catch (err) {
 hiddenInput.focus();
 }

 if (document.activeElement !== hiddenInput) {
 hiddenInput.focus();
 }
 }

 promptContainer.addEventListener('click', () => {
 if (!SceneManager.can('visicellClick')) return;
 if (!running || burstAnimStarted) return;
 if (!inputAttempted) {
 triggerCelliGlitch();
 inputAttempted = true;
 }

 if (hiddenInput) {
 focusHiddenPromptInput();
 }
 });
 
 function handlePromptBackspace() {
 if (!running || !doorwayOpened || burstAnimStarted) return false;
 if (inputText.length <= promptBaseText.length) return false;

 inputText = inputText.slice(0, -1);
 tEntered = false;

 updatePromptWithChars(inputText);
 promptCursorEl.textContent = '_';
 if (promptEl) {
 promptEl.setAttribute('data-text', inputText + '_');
 }

 if (hiddenInput) {
 hiddenInput.value = '';
 }

 if (burstTimeout) {
 clearTimeout(burstTimeout);
 burstTimeout = null;
 }

 // Restore one letter with fritz effect
 restoreOneLetter();
 return true;
 }

 // Keyboard input to trigger final sequence (desktop)
 window.addEventListener('keydown', (e) => {
 if (document.getElementById('visicalc') && !SceneManager.can('visicellClick')) return;
 if (!running || !doorwayOpened || !inputAttempted) return;

 if (e.key === 'Backspace') {
 e.preventDefault();
 handlePromptBackspace();
 return;
 }

 // T input - starts burst sequence
 if (!tEntered && e.key.toLowerCase() === 't') {
 e.preventDefault();
 tEntered = true;
 inputText += 'T';

 // Update display
 updatePromptWithChars(inputText);
 promptCursorEl.textContent = '_';
 if (promptEl) {
 promptEl.setAttribute('data-text', inputText + '_');
 }

 if (burstTimeout) {
 clearTimeout(burstTimeout);
 }
 burstTimeout = setTimeout(() => {
 triggerBurstToStars();
 }, 500);
 return;
 }
 
 // E, N, D inputs - only after STAR is fully cleared and yellow transformation complete
 if (inputText === '=' && allYellowTransformed) {
 const key = e.key.toUpperCase();
 
 console.log('END input detected:', key, 'endSequence:', endSequence, 'allYellowTransformed:', allYellowTransformed);
 
 // E must be first
 if (endSequence === '' && key === 'E') {
 e.preventDefault();
 endSequence = 'E';
 transformToMagentaRed();
 updatePromptWithChars('=E');
 if (promptEl) promptEl.setAttribute('data-text', '=E_');
 console.log('%c[SHIFT 1/3] â˜… MAGENTA SHIFT TRIGGERED â˜…', 'background: #ff1e6e; color: #fff; font-size: 14px; font-weight: bold; padding: 6px;');
 console.log('[SHIFT 1/3] Press N to continue...');
 return;
 }
 
 // N must be second (after E)
 if (endSequence === 'E' && key === 'N') {
 e.preventDefault();
 endSequence = 'EN';
 transformToCyanBlue();
 updatePromptWithChars('=EN');
 if (promptEl) promptEl.setAttribute('data-text', '=EN_');
 console.log('%c[SHIFT 2/3] â˜… CYAN SHIFT TRIGGERED â˜…', 'background: #00a8ff; color: #fff; font-size: 14px; font-weight: bold; padding: 6px;');
 console.log('[SHIFT 2/3] Press D to continue...');
 return;
 }
 
 // D must be third (after EN)
 if (endSequence === 'EN' && key === 'D') {
 e.preventDefault();
 endSequence = 'END';
 transformToGreenAndSquare();
 updatePromptWithChars('=END');
 if (promptEl) promptEl.setAttribute('data-text', '=END_');
 console.log('%c[SHIFT 3/3] â˜… GREEN SHIFT TRIGGERED â˜…', 'background: #0f0; color: #000; font-size: 14px; font-weight: bold; padding: 6px;');
 console.log('[SHIFT 3/3] Snap animation starting... HELL transformation completing through falling voxels');
 return;
 }
 
 // After END is complete, Shift just logs status (HELL transformation already happened progressively)
 if (endSequence === 'END' && (key === 'SHIFT' || e.key === 'Shift')) {
 e.preventDefault();
 console.log('%c[INFO] Shift pressed after END', 'background: #888; color: #fff; font-weight: bold; padding: 4px;');
 console.log('[INFO] HELL transformation already completed through the three color shifts:');
 console.log('[INFO]   1. Magenta (E) - Top arc of C fell and repositioned');
 console.log('[INFO]   2. Cyan (N) - Bottom arc of C + some I voxels fell');
 console.log('[INFO]   3. Green (D) - Remaining I voxels fell to complete HELL');
 console.log('[INFO] Animation state:');
 console.log('  - celliMoveToCornerStarted:', celliMoveToCornerStarted);
 console.log('  - snapTogetherStarted:', snapTogetherStarted);
 console.log('  - endColorState:', endColorState);
 return;
 }
 } else if (inputText === '=') {
 console.log('Input is =, but allYellowTransformed is:', allYellowTransformed);
 }
 });
 
 // Mobile input handler
 if (hiddenInput) {
 hiddenInput.addEventListener('beforeinput', (e) => {
 if (!running || !doorwayOpened || !inputAttempted) return;
 if (e.inputType === 'deleteContentBackward') {
 e.preventDefault();
 handlePromptBackspace();
 }
 });

 hiddenInput.addEventListener('input', (e) => {
 if (!running || !doorwayOpened || !inputAttempted) return;

 const value = (e.target.value || '').toUpperCase();

 if (value === '') {
 handlePromptBackspace();
 return;
 }

 // T input for burst sequence
 if (!tEntered && value.includes('T')) {
 e.preventDefault();
 tEntered = true;
 inputText += 'T';

 updatePromptWithChars(inputText);
 promptCursorEl.textContent = '_';
 if (promptEl) {
 promptEl.setAttribute('data-text', inputText + '_');
 }

 e.target.value = '';

 if (burstTimeout) {
 clearTimeout(burstTimeout);
 }
 burstTimeout = setTimeout(() => {
 triggerBurstToStars();
 }, 500);

 hiddenInput.blur();
 return;
 }
 
 // E, N, D inputs after STAR cleared and yellow transformation
 if (inputText === '=' && allYellowTransformed) {
 // E must be first
 if (endSequence === '' && value.includes('E')) {
 e.preventDefault();
 endSequence = 'E';
 transformToMagentaRed();
 updatePromptWithChars('=E');
 if (promptEl) promptEl.setAttribute('data-text', '=E_');
 e.target.value = '';
 return;
 }
 
 // N must be second
 if (endSequence === 'E' && value.includes('N')) {
 e.preventDefault();
 endSequence = 'EN';
 transformToCyanBlue();
 updatePromptWithChars('=EN');
 if (promptEl) promptEl.setAttribute('data-text', '=EN_');
 e.target.value = '';
 return;
 }
 
 // D must be third
 if (endSequence === 'EN' && value.includes('D')) {
 e.preventDefault();
 endSequence = 'END';
 transformToGreenAndSquare();
 updatePromptWithChars('=END');
 if (promptEl) promptEl.setAttribute('data-text', '=END_');
 e.target.value = '';
 return;
 }
 }
 
 // Clear any other input
 e.target.value = '';
 });
 }
}

// Break apart and rise to sky
let breakApartStarted = false;
 let riseStartTime = 0;
 
 function triggerBurstToStars() {
 if (burstAnimStarted) return;
 burstAnimStarted = true;
 burstTimeout = null;
 breakApartStarted = true;
 riseStartTime = Date.now();

 const skipBtn = document.getElementById('skipBtn');
 if (skipBtn) {
 skipBtn.classList.remove('illuminating');
 }

 // Increase afterimage effect for dramatic trails
 afterimagePass.uniforms.damp.value = 0.88;
 
 // Hide prompt but keep it for reference
 if (promptEl) {
 promptEl.style.transition = 'opacity 0.5s ease';
 promptEl.style.opacity = '0';
 }
 
 // Get only the T-shape voxels (the ones that weren't glitched)
 const activeVoxels = voxels.filter(v => !v.userData.glitched && v.visible);
 
 // Give each voxel velocity to shoot upward dramatically
 activeVoxels.forEach((voxel, idx) => {
 setTimeout(() => {
 const angle = Math.random() * Math.PI * 2;
 const spreadH = 0.008 + Math.random() * 0.015; // More horizontal spread
 
 voxel.userData.floating = true;
 voxel.userData.vx = Math.cos(angle) * spreadH;
 voxel.userData.vy = 0.08 + Math.random() * 0.05; // MUCH faster upward - shooting motion
 voxel.userData.vz = -0.05 - Math.random() * 0.08; // Move away from camera (into distance)
 voxel.userData.pulsatePhase = Math.random() * Math.PI * 2;
 voxel.userData.pulsateSpeed = 3 + Math.random() * 3;
 voxel.userData.floatStartTime = Date.now();
 voxel.userData.initialScale = voxel.userData.baseScale || 1.0;
 }, idx * 15); // Faster stagger
 });
 
 // Start camera pan after voxels have shot into distance
 setTimeout(() => {
 startCameraPan();
 }, 4000); // Slightly longer to see them recede
 }
 
 // Update floating voxels
 function updateFloatingVoxels(dt) {
 if (!breakApartStarted) return;
 
 const now = Date.now();
 const totalElapsed = (now - riseStartTime) / 1000;
 
 voxels.forEach(voxel => {
 if (!voxel.userData.floating) return;
 
 const data = voxel.userData;
 const age = (now - data.floatStartTime) / 1000;
 
 // Move with velocity - shooting into distance
 voxel.position.x += data.vx;
 voxel.position.y += data.vy;
 voxel.position.z += data.vz;
 
 // Very slow drag to maintain shooting motion
 data.vx *= 0.985;
 data.vy *= 0.985;
 data.vz *= 0.985;
 
 // Scale down dramatically as they move away (perspective)
 // Based on Z distance from camera
 const distanceZ = Math.abs(voxel.position.z + 0.5); // Initial Z was around -0.5
 const perspectiveScale = 1 / (1 + distanceZ * 3); // Shrink rapidly with distance
 
 // Pulsate on top of perspective scaling
 data.pulsatePhase += data.pulsateSpeed * dt;
 const pulse = 0.85 + Math.sin(data.pulsatePhase) * 0.15;
 const baseScale = data.initialScale || 1.0;
 const finalScale = baseScale * pulse * perspectiveScale;
 voxel.scale.set(finalScale, finalScale, finalScale);
 
 // Brighten voxels during shooting (they're stars now)
 voxel.material.color.setRGB(1, 1, 1); // Pure white
 
 // Pulsate material opacity with distance fade
 const opacityPulse = 0.8 + Math.sin(data.pulsatePhase * 0.7) * 0.2;
 const distanceFade = Math.max(0.3, 1 - distanceZ * 0.4); // Fade as they get far
 voxel.material.opacity = Math.min(1.0, opacityPulse * distanceFade);
 data.edges.material.opacity = Math.min(0.8, opacityPulse * 0.8 * distanceFade);
 
 // Fade out during camera pan
 if (cameraPanStarted) {
 const panProgress = (now - panStartTime) / panDuration;
 const fadeStart = 0.5;
 if (panProgress > fadeStart) {
 const fadeProgress = (panProgress - fadeStart) / (1 - fadeStart);
 voxel.material.opacity *= (1 - fadeProgress * 0.8);
 data.edges.material.opacity *= (1 - fadeProgress * 0.8);
 }
 }
 });
 }
 
 // Pan camera down to reveal gradient
 let cameraPanStarted = false;
 let panStartTime = 0;
 const panDuration = 5000; // 5 seconds for dramatic reveal
 
 function startCameraPan() {
 cameraPanStarted = true;
 panStartTime = Date.now();
 }
 
 function updateCameraPan() {
 if (!cameraPanStarted) return;
 
 const elapsed = Date.now() - panStartTime;
 const progress = Math.min(1, elapsed / panDuration);
 
 // Smooth ease-in-out for dramatic pan
 const eased = progress < 0.5 ? 
 2 * progress * progress : 
 1 - Math.pow(-2 * progress + 2, 2) / 2;
 
 // Gradually reduce afterimage effect during pan to fade trails
 afterimagePass.uniforms.damp.value = THREE.MathUtils.lerp(0.88, 0.96, progress);
 
 // Pan down much further to reveal gradient
 camera.position.y = THREE.MathUtils.lerp(0, -5, eased);
 camera.lookAt(0, camera.position.y - 2, 0); // Look ahead of camera position
 
 // Fade doorway, prompt, and vignette quickly
 const doorway = document.getElementById('doorway');
 if (doorway) {
 doorway.style.opacity = Math.max(0, 1 - progress * 2);
 }
 
 // Fade out vignette
 const vignette = document.querySelector('.vignette');
 if (vignette) {
 vignette.style.transition = 'opacity 1s ease';
 vignette.style.opacity = String(Math.max(0, 1 - progress * 1.5));
 }
 
 // Add blue gradient background early in the pan
 if (progress > 0.2 && !document.getElementById('nightSky')) {
 // Set app background to black initially for smooth transition
 const app = document.getElementById('app');
 if (app) {
 app.style.background = '#000';
 }
 
 // Immediately hide vignette and scanlines when gradient appears
 const vignetteEl = document.querySelector('.vignette');
 if (vignetteEl) {
 vignetteEl.style.display = 'none';
 }
 
 // Hide scanlines overlay
 if (app && app.classList.contains('scanlines')) {
 app.classList.add('fade-scanlines');
 }
 
 const nightSky = document.createElement('div');
 nightSky.id = 'nightSky';
 nightSky.style.position = 'fixed';
 nightSky.style.inset = '0';
 nightSky.style.background = 'linear-gradient(to bottom, #0d1b2a 0%, #1a237e 20%, #283593 40%, #3949ab 60%, #5e92f3 80%, #90caf9 100%)';
 nightSky.style.zIndex = '0';
 nightSky.style.opacity = '0';
 nightSky.style.pointerEvents = 'none';
 
 // Insert at beginning of body
 if (document.body.firstChild) {
 document.body.insertBefore(nightSky, document.body.firstChild);
 } else {
 document.body.appendChild(nightSky);
 }
 
 // Fade in gradient
 setTimeout(() => {
 nightSky.style.transition = 'opacity 3s ease';
 nightSky.style.opacity = '1';
 
 // Fade out black background
 if (app) {
 app.style.transition = 'background 3s ease';
 app.style.background = 'transparent';
 }
 }, 100);
 }
 
 // Fade out 3D scene elements as gradient appears
 if (progress > 0.3) {
 const fadeAmount = Math.min(1, (progress - 0.3) / 0.7); // Fade from 30% to 100%
 
 // Fade renderer canvas
 renderer.domElement.style.transition = 'opacity 0.5s ease';
 renderer.domElement.style.opacity = String(1 - fadeAmount * 0.8); // Keep slight visibility
 }
 
 // Keep stars visible over the gradient longer
 if (progress > 0.7) {
 const starFade = (progress - 0.7) / 0.3;
 textCanvas.style.opacity = String(1 - starFade);
 }
 
 // Transition to celli-real when gradient transition completes
 if (progress >= 1.0 && !window.__celliRealTransitioned) {
 window.__celliRealTransitioned = true;
 setTimeout(() => {
 console.log('?? Gradient transition complete - loading CELLI.REAL');
 transitionToCelliRealScene();
 }, 1000);
 }
 }
 }
 
 // Render star particles
 function renderStars() {
 if (starParticles.length === 0) return;
 
 const now = Date.now();
 
 // Update and render each star
 for (let i = starParticles.length - 1; i >= 0; i--) {
 const star = starParticles[i];
 
 // Update position based on velocity
 if (star.vx !== undefined) {
 star.x += star.vx;
 star.y += star.vy;
 star.z += star.vz;
 
 // Very slow drag to keep stars moving
 star.vx *= 0.995;
 star.vy *= 0.995;
 star.vz *= 0.995;
 }
 
 // Calculate age and fade
 const age = (now - star.birthTime) / 1000; // in seconds
 const fadeDuration = 8; // fade over 8 seconds (much slower)
 const fadeProgress = Math.min(1, age / fadeDuration);
 
 // Dim brightness over time - keep them bright longer
 star.brightness = 1 - fadeProgress * 0.5; // Keep 50% minimum
 
 // Update twinkle
 star.twinkle += star.twinkleSpeed * 0.016;
 const twinkleBrightness = 0.8 + Math.sin(star.twinkle) * 0.2;
 const finalBrightness = star.brightness * twinkleBrightness;
 
 // Keep stars visible much longer - only remove when very faint
 if (finalBrightness < 0.05) {
 starParticles.splice(i, 1);
 continue;
 }
 
 // Project to screen space
 const vector = new THREE.Vector3(star.x, star.y, star.z);
 vector.project(camera);
 
 // Check if behind camera
 if (vector.z > 1) continue;
 
 const x = (vector.x + 1) / 2 * window.innerWidth;
 const y = (-vector.y + 1) / 2 * window.innerHeight;
 
 // Size based on distance (z-depth)
 const depthScale = Math.max(0.5, 1 - vector.z * 0.5);
 const renderSize = star.size * window.innerWidth * 0.01 * depthScale;
 
 // Draw voxel as square with slight glow
 const voxelSize = renderSize * 1.5;
 const glowSize = voxelSize * 1.5;
 
 // Outer glow
 const gradient = textCtx.createRadialGradient(x, y, 0, x, y, glowSize);
 gradient.addColorStop(0, `rgba(255, 255, 255, ${finalBrightness * 0.8})`);
 gradient.addColorStop(0.6, `rgba(255, 255, 255, ${finalBrightness * 0.3})`);
 gradient.addColorStop(1, `rgba(255, 255, 255, 0)`);
 textCtx.fillStyle = gradient;
 textCtx.beginPath();
 textCtx.arc(x, y, glowSize, 0, Math.PI * 2);
 textCtx.fill();
 
 // Core voxel - square shape
 textCtx.fillStyle = `rgba(255, 255, 255, ${Math.min(1, finalBrightness * 1.1)})`;
 textCtx.fillRect(x - voxelSize/2, y - voxelSize/2, voxelSize, voxelSize);
 
 // Subtle border for voxel definition
 if (finalBrightness > 0.5) {
 textCtx.strokeStyle = `rgba(255, 255, 255, ${finalBrightness * 0.6})`;
 textCtx.lineWidth = 0.5;
 textCtx.strokeRect(x - voxelSize/2, y - voxelSize/2, voxelSize, voxelSize);
}
}
}

</script>

</body>
</html>
