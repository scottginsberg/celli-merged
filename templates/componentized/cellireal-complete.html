<title>Celli</title>
<script type="module" src="../../src/scripts/systems/PuzzleStateManager.js"></script>
window.Store = Store;

const puzzleTrackerRegistry = new Map();

function announcePuzzleSolved(puzzleId, context = {}) {
  let recorded = false;
  try {
    if (window.celliPuzzleState && typeof window.celliPuzzleState.markSolved === 'function') {
      window.celliPuzzleState.markSolved(puzzleId, { source: 'cellireal', ...context });
      recorded = true;
    }
  } catch (error) {
    console.warn(`[PuzzleTracker] Unable to persist ${puzzleId} completion:`, error);
  }

  if (!recorded && typeof window !== 'undefined') {
    try {
      window.dispatchEvent(
        new CustomEvent('celli:puzzle-solved', {
          detail: {
            puzzleId,
            status: 'solved',
            metadata: { source: 'cellireal', ...context }
          }
        })
      );
    } catch (error) {
      console.warn(`[PuzzleTracker] Unable to dispatch fallback event for ${puzzleId}:`, error);
    }
  }

  try {
    const globalState = Store.getState().globalState;
    if (globalState && typeof globalState.set === 'function') {
      globalState.set(`puzzle.${puzzleId}.solved`, 1);
      if (puzzleId === 'sokoban') {
        globalState.set('sokoban.win', 1);
      } else if (puzzleId === 'galaxy') {
        globalState.set('galaxy.win', 1);
      } else if (puzzleId === 'sokoban-rules') {
        globalState.set('sokoban.win', 1);
      }
    }
  } catch (error) {
    console.warn(`[PuzzleTracker] Unable to flag global state for ${puzzleId}:`, error);
  }
}

function registerPuzzleTracker(puzzleId, checkFn, context = {}) {
  if (!puzzleId || typeof checkFn !== 'function') {
    return () => {};
  }

  if (puzzleTrackerRegistry.has(puzzleId)) {
    const existing = puzzleTrackerRegistry.get(puzzleId);
    try { existing.unsubscribe?.(); } catch (_) {}
    puzzleTrackerRegistry.delete(puzzleId);
  }

  let lastSolved = false;
  let unsubscribe = null;

  const evaluate = () => {
    let solved = false;
    try {
      solved = Boolean(checkFn());
    } catch (error) {
      console.warn(`[PuzzleTracker] ${puzzleId} check failed:`, error);
    }

    if (solved && !lastSolved) {
      lastSolved = true;
      announcePuzzleSolved(puzzleId, context);
      if (unsubscribe) {
        try { unsubscribe(); } catch (_) {}
      }
      puzzleTrackerRegistry.delete(puzzleId);
    } else if (!solved) {
      lastSolved = false;
    }
    return solved;
  };

  unsubscribe = Store.subscribe(() => evaluate());
  puzzleTrackerRegistry.set(puzzleId, { unsubscribe, evaluate, context });
  evaluate();

  return () => {
    try { unsubscribe?.(); } catch (_) {}
    puzzleTrackerRegistry.delete(puzzleId);
  };
}

function getCellValue(arrId, coord) {
  try {
    return UI.getCell(arrId, coord)?.value ?? '';
  } catch (error) {
    console.warn('[PuzzleTracker] Unable to read cell value:', error);
    return '';
  }
}

function checkSokobanGoal(boardId, goal) {
  if (!boardId || !goal) {
    return false;
  }
  const value = getCellValue(boardId, goal);
  return value === '??';
}

function trackSokobanBoard(boardId, goal, context = {}) {
  if (!boardId || !goal) {
    return;
  }
  registerPuzzleTracker('sokoban', () => checkSokobanGoal(boardId, goal), {
    boardId,
    goal,
    ...context
  });
}

function trackGalaxyPuzzle(context = {}) {
  registerPuzzleTracker('galaxy', () => {
    try {
      const globalState = Store.getState().globalState;
      return globalState && globalState.get('galaxy.win') === 1;
    } catch (error) {
      console.warn('[PuzzleTracker] Unable to inspect GALAXY state:', error);
      return false;
    }
  }, context);
}
tag('GALAXY',['GAME'],(anchor,arr,ast)=>{
 // Initialize GALAXY puzzle game
 Actions.begin();

 // Set up game state
 Store.getState().globalState.set('galaxy.active', 1);
 Store.getState().globalState.set('galaxy.gravityWell', `@[${anchor.x+1},${anchor.y+2},${anchor.z},${arr.id}]`);
 Store.getState().globalState.set('galaxy.win', 0);

 // Create gravity well
 Actions.setCell(arr.id, anchor, '?? GALAXY PUZZLE', ast.raw, true);
 Actions.setCell(arr.id, {x:anchor.x+1,y:anchor.y+2,z:anchor.z}, '??', null, true);

 // Set up physics system
 Actions.setCell(arr.id, {x:anchor.x,y:anchor.y-1,z:anchor.z}, '=ON_EVENT("TICK","=SET_GLOBAL(\\"galaxy.gravityVector\\",VECTOR_TO(GET_PLAYER_FOCUS(),GET_GLOBAL(\\"galaxy.gravityWell\\")))")', null, true);
 Actions.setCell(arr.id, {x:anchor.x+1,y:anchor.y-1,z:anchor.z}, '=GET_GLOBAL("galaxy.gravityVector")', null, true);

 // Goal condition
 Actions.setCell(arr.id, {x:anchor.x,y:anchor.y-2,z:anchor.z}, '=IF(EQ(GET_PLAYER_FOCUS(),GET_GLOBAL("galaxy.gravityWell")),"?? WIN!","Navigate to ??")', null, true);
 Actions.setCell(
  arr.id,
  {x:anchor.x+1,y:anchor.y-2,z:anchor.z},
  'Victory Monitor',
  '=ON_EVENT("TICK","=IF(AND(EQ(GET_PLAYER_FOCUS(),GET_GLOBAL(\\"galaxy.gravityWell\\")),NE(GET_GLOBAL(\\"galaxy.win\\"),1)),DO(\"=SET_GLOBAL(\\"galaxy.win\\",1)\"))")',
  true
 );

 Actions.end();
 trackGalaxyPuzzle({ anchor: { ...anchor, arrId: arr.id }, arrayId: arr.id });
});
 const t1 = at(nx,ny);
 if(t1===WALL) return;
 if(t1===BOX){
  const t2 = at(nnx,nny);
  if(t2!==EMPTY) return; // cannot push
  // push box
  Write.set(tx, boardId, {x:nnx,y:nny,z:pz}, { value: BOX, formula:null });
  Write.set(tx, boardId, {x:nx ,y:ny ,z:pz}, { value: PLAYER, formula:null });
  Write.set(tx, boardId, {x:px ,y:py ,z:pz}, { value: EMPTY, formula:null });
  // update memory
  const newRef = `@[${nx},${ny},${pz},${boardId}]`;
  Write.set(tx, memRef.arrId, {x:memRef.x,y:memRef.y,z:memRef.z}, { value:newRef, formula:null });
  return;
 }
 // simple move into empty
 if(t1===EMPTY){
  Write.set(tx, boardId, {x:nx ,y:ny ,z:pz}, { value: PLAYER, formula:null });
  Write.set(tx, boardId, {x:px ,y:py ,z:pz}, { value: EMPTY, formula:null });
  const newRef = `@[${nx},${ny},${pz},${boardId}]`;
  Write.set(tx, memRef.arrId, {x:memRef.x,y:memRef.y,z:memRef.z}, { value:newRef, formula:null });
 }
 try{
  const goal = Store.getState().arrays[boardId]?.params?.sokoGoal;
  if(goal && checkSokobanGoal(boardId, goal) && Store.getState().globalState.get('sokoban.win') !== 1){
   Store.getState().globalState.set('sokoban.win', 1);
  }
 }catch(e){ console.warn('SOKO_STEP victory check failed', e); }
});
 const memVal = Formula.getCellValue(memRef);
 const pos = parseAlt(String(memVal)||''); if(!pos) return;
 const boardId = pos.arrId; const pz = pos.z||0;
 // Find Rules array by convention: same board name + " Rules" or first array with params.sokoRules
 const rulesArr = Object.values(Store.getState().arrays).find(a=>a.params?.sokoRules && a.params?.boardId===boardId);
 if(!rulesArr) { Actions.setCell(arr.id, anchor, '!ERR:No Rules', ast.raw, true); return; }
 // MOVE anchor stored in params
 const mv = rulesArr.params?.moveAnchor || {x:0,y:rulesArr.size.y-1,z:0,arrId:rulesArr.id};
 Formula.executeAt({arrId:mv.arrId,x:mv.x,y:mv.y,z:mv.z}, undefined, tx);
 Actions.setCell(arr.id, anchor, 'SOKO:STEP', ast.raw, true);
 try{
  const goal = Store.getState().arrays[boardId]?.params?.sokoGoal;
  if(goal && checkSokobanGoal(boardId, goal) && Store.getState().globalState.get('sokoban.win') !== 1){
   Store.getState().globalState.set('sokoban.win', 1);
  }
 }catch(e){ console.warn('SOKO_STEP2 victory check failed', e); }
});
tag('SOKOBAN2',['GAME','META'],(anchor,arr,ast)=>{
 try{
  const size = {x:10,y:8,z:1};
  const board = Actions.createArray({name:'Sokoban2', size, hidden:false});
  const mem = Actions.createArray({name:'SokoMem2', size:{x:2,y:1,z:1}, hidden:true});
  const rules = Actions.createArray({name:'SokoRules', size:{x:4,y:6,z:1}, hidden:true});
  const ctrl = Actions.createArray({name:'SokoCtrl2', size:{x:3,y:3,z:1}, hidden:false});
  const PSTART = {x:2,y:2,z:0};
  const BOX='??', WALL=' ', PLAYER='??', GOAL=' ';
  const GOAL_COORD = {x:7,y:2,z:0};
  Actions.begin();
  // walls border
  for(let x=0;x<size.x;x++){ Actions.setCell(board.id,{x,y:size.y-1,z:0},WALL,null,true); Actions.setCell(board.id,{x,y:0,z:0},WALL,null,true); }
  for(let y=0;y<size.y;y++){ Actions.setCell(board.id,{x:0,y,z:0},WALL,null,true); Actions.setCell(board.id,{x:size.x-1,y,z:0},WALL,null,true); }
  // place player, box and goal
  Actions.setCell(board.id,PSTART,PLAYER,null,true);
  Actions.setCell(board.id,{x:4,y:2,z:0},BOX,null,true);
  Actions.setCell(board.id,GOAL_COORD,GOAL,null,true);
  board.params = { ...(board.params||{}), sokoGoal: GOAL_COORD };
  // memory: player ref string at (0,0)
  Actions.setCell(mem.id,{x:0,y:0,z:0},`@[${PSTART.x},${PSTART.y},${PSTART.z},${board.id}]`,null,true);
  Scene.setArrayOffset(ctrl,pos);
  Actions.setCell(arr.id, anchor, `Sokoban2:#${board.id}`, ast.raw, true);
  Store.getState().globalState.set('sokoban.win', 0);
  registerPuzzleTracker('sokoban-rules', () => checkSokobanGoal(board.id, GOAL_COORD), {
   boardId: board.id,
   goal: GOAL_COORD,
   anchor: { ...anchor, arrId: arr.id },
   arrayId: arr.id
  });
  }catch(e){ Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true); }
 });
tag('SOKOBAN',['GAME','META'],(anchor,arr,ast)=>{
 // Generate a tiny Sokoban board, memory, and controller
 try{
  const size = {x:10,y:8,z:1};
  const board = Actions.createArray({name:'Sokoban', size, hidden:false});
  const mem = Actions.createArray({name:'SokoMem', size:{x:2,y:1,z:1}, hidden:true});
  const ctrl = Actions.createArray({name:'SokoCtrl', size:{x:3,y:3,z:1}, hidden:false});
  const PSTART = {x:2,y:2,z:0};
  const BOX='??', WALL=' ', PLAYER='??', GOAL=' ';
  const GOAL_COORD = {x:7,y:2,z:0};
  Actions.begin();
  // walls border
  for(let x=0;x<size.x;x++){ Actions.setCell(board.id,{x,y:size.y-1,z:0},WALL,null,true); Actions.setCell(board.id,{x,y:0,z:0},WALL,null,true); }
  for(let y=0;y<size.y;y++){ Actions.setCell(board.id,{x:0,y,z:0},WALL,null,true); Actions.setCell(board.id,{x:size.x-1,y,z:0},WALL,null,true); }
  // place player, box and goal
  Actions.setCell(board.id,PSTART,PLAYER,null,true);
  Actions.setCell(board.id,{x:4,y:2,z:0},BOX,null,true);
  Actions.setCell(board.id,GOAL_COORD,GOAL,null,true);
  board.params = { ...(board.params||{}), sokoGoal: GOAL_COORD };
  // memory: player ref string at (0,0)
  Actions.setCell(mem.id,{x:0,y:0,z:0},`@[${PSTART.x},${PSTART.y},${PSTART.z},${board.id}]`,null,true);
  // controller arrows with ON_SELECT to call SOKO_STEP(memRef,dx,dy)
  const mref = `@[0,0,0,${mem.id}]`;
  Actions.setCell(ctrl.id,{x:1,y:2,z:0},'?',null,true);
  Actions.setCell(ctrl.id,{x:0,y:1,z:0},'?',null,true);
  Actions.setCell(ctrl.id,{x:2,y:1,z:0},'?',null,true);
  // Dock controller near board
  const pos = dockOffsetFor(board,'east',1.0);
  Scene.setArrayOffset(ctrl,pos);
  // Write to anchor without triggering immediate recompute loop
  const tx=Write.start('sokoban.status','SOKOBAN status');
  Write.set(tx, arr.id, anchor, { value:`Sokoban:#${board.id}`, formula: ast.raw, meta:{skip_recompute:true} });
  Write.commit(tx);
  Store.getState().globalState.set('sokoban.win', 0);
  trackSokobanBoard(board.id, GOAL_COORD, { anchor: { ...anchor, arrId: arr.id }, arrayId: arr.id });
  }catch(e){ Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true); }
 });
