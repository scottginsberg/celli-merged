<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>Celli</title>
<script type="importmap">
{
 "imports": {
 "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
 "three/": "https://cdn.jsdelivr.net/npm/three@0.160.0/"
 }
}
</script>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Rubik:wght@400;600;800&family=Roboto+Mono:wght@400;600;700&display=swap" rel="stylesheet">
<script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
<!-- Twemoji for consistent emoji rendering -->
<script src="https://unpkg.com/twemoji@latest/dist/twemoji.min.js"></script>
<!-- TanStack Virtual for 2D sheet virtualization -->
<script src="https://unpkg.com/@tanstack/virtual-core@latest/dist/index.umd.js"></script>
<style>
:root{
 /* Reference palette */
 --bg:#f0f2f5; --ink:#1f2937; --muted:#5b6170; --panel:#ffffff; --line:#e5e7eb;
 --accent:#3b82f6; --accent-2:#22c55e; --accent-3:#f59e0b; --chip:#eef2ff;
 --shadow:0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
}
/* Background world gradient + optional spiral intensifier */
#world{ position:fixed; inset:0; background:radial-gradient(1200px 800px at 20% 10%, #93c5fd 0, transparent 70%), linear-gradient(135deg,#1e3a8a 0%,#3b82f6 50%,#93c5fd 100%); pointer-events:none; z-index:0 }
#world::after{ content:""; position:absolute; inset:-10%; opacity:0; pointer-events:none; mix-blend-mode:screen; background:conic-gradient(from 0deg at 50% 50%, rgba(59,130,246,.00) 0%, rgba(59,130,246,.08) 10%, rgba(147,197,253,.06) 20%, transparent 30%, rgba(59,130,246,.08) 40%, transparent 55%, rgba(147,197,253,.06) 70%, transparent 85%, rgba(59,130,246,.08) 100%); transform-origin:center; }
@keyframes swirl{ to{ transform:rotate(360deg); } }
.spiral #world::after{ opacity:.7; animation:swirl 8s linear infinite; }

/* Narrative icons */
.ui-icon{ position:fixed; width:50px; height:50px; background:#1f2937; border-radius:10px; box-shadow:var(--shadow); display:flex; align-items:center; justify-content:center; cursor:pointer; z-index:10002; transition:transform .2s ease; color:#e5e7eb; }
.ui-icon:hover{ transform:scale(1.1); }
.ui-icon svg{ pointer-events:none; }
#terminal-icon{ bottom:24px; right:24px; }
#notepad-icon{ bottom:108px; right:24px; }

/* Narrative windows */
#terminal{ position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); width:90vw; max-width:700px; height:460px; background:rgba(17,24,39,.95); border:1px solid rgba(255,255,255,.12); border-radius:12px; box-shadow:0 25px 50px -12px rgb(0 0 0 / .5); z-index:10002; display:none; flex-direction:column; color:#e5e7eb; font-family:'Roboto Mono',monospace; }
.win-header{ background:rgba(255,255,255,.06); padding:8px 12px; border-bottom:1px solid rgba(255,255,255,.12); display:flex; justify-content:space-between; align-items:center; user-select:none; cursor:move; }
.close{ width:20px; height:20px; background:#ef4444; border-radius:50%; cursor:pointer; }
#term{ flex-grow:1; padding:12px; overflow-y:auto; white-space:pre-wrap; word-break:break-word; overflow-wrap:break-word; line-height:1.35; }
#term .cursor::after{ content:' '; animation:blink .8s step-end infinite; }
#term .underscore::after{ content:'_'; animation:blink .75s step-end infinite; }
@keyframes blink{ 50%{ opacity:0; } }
/* Lanes for multi-processing thoughts */
#term .lane-wrap{ display:flex; gap:10px; }
#term .lane{ flex:1 1 0; min-width:0; }
/* Mood styles */
.soft{ opacity:.95; }
.artifact{ filter:saturate(0) contrast(1.2); opacity:.9; }
.catharsis{ color:#e5f2ff; text-shadow:0 0 10px rgba(147,197,253,.6), 0 0 24px rgba(59,130,246,.35); }
/* Glitch effect */
.glitch{ position:relative; display:inline-block; }
.glitch::before,.glitch::after{ content:attr(data-text); position:absolute; left:0; top:0; width:100%; pointer-events:none; }
.glitch::before{ color:rgba(59,130,246,.95); transform:translate(1px,0); animation:glitchA .55s steps(2,end) infinite; }
.glitch::after{ color:rgba(239,68,68,.9); transform:translate(-1px,0); animation:glitchB .5s steps(2,end) infinite; }
@keyframes glitchA{ 0%{clip-path:inset(0 0 70% 0)} 50%{clip-path:inset(30% 0 40% 0)} 100%{clip-path:inset(60% 0 0 0)} }
@keyframes glitchB{ 0%{clip-path:inset(60% 0 0 0)} 50%{clip-path:inset(30% 0 40% 0)} 100%{clip-path:inset(0 0 70% 0)} }
#pad{ position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); width:480px; height:360px; background:rgba(17,24,39,.95); border:1px solid rgba(255,255,255,.12); border-radius:20px; box-shadow:0 25px 50px -12px rgb(0 0 0 / .5); z-index:10002; display:none; color:#e5e7eb; overflow:hidden; flex-direction:column; backdrop-filter:blur(14px); }
#pad textarea{ width:100%; flex:1; background:inherit; color:inherit; border:none; padding:18px 18px 36px; font-family:'Roboto Mono',monospace; outline:none; resize:none; border-radius:16px; }
#pad .win-header{border-top-left-radius:20px; border-top-right-radius:20px;}
#pad .pad-resizer{position:absolute; right:10px; bottom:10px; width:18px; height:18px; background:linear-gradient(135deg, rgba(59,130,246,0.4), rgba(59,130,246,0.9)); border-radius:6px; cursor:nwse-resize; box-shadow:0 6px 14px rgba(15,23,42,0.2); border:1px solid rgba(255,255,255,0.4);}
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0;background:var(--bg);color:var(--ink);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;overscroll-behavior:none}
canvas#view{position:fixed;inset:0;width:100vw;height:100vh;display:block}
/* Intro overlay gradient that sits above 3D and behind sheet */
#introOverlay{position:fixed;inset:0;z-index:10000;pointer-events:none;
 background:linear-gradient(135deg, #1e3a8a 0%, #3b82f6 50%, #93c5fd 100%);
 opacity:1; transition:opacity .8s ease}
#introOverlay.hidden{opacity:0; pointer-events:none}

/* Panels */
.panel{position:fixed;z-index:10;background:var(--panel);border:1px solid var(--line);border-radius:16px;box-shadow:var(--shadow);padding:12px}
.panel#hud{z-index:10002}
.panel .title{font-weight:800;letter-spacing:.2px}
.row{display:flex;gap:8px;align-items:center}
.stack{display:flex;flex-direction:column;gap:8px}
.chip{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--line);padding:6px 10px;border-radius:999px;background:var(--chip);font-size:12px}
.btn{appearance:none;border:1px solid var(--line);background:#fff;padding:8px 12px;border-radius:10px;font-weight:600;cursor:pointer}
.btn:hover{border-color:#d1d5e4}
.btn:active{transform:translateY(1px)}
.btn.primary{background:var(--accent);border-color:#2162df;color:#fff}
.btn.good{background:var(--accent-2);border-color:#15a34a;color:#fff}
.btn.warn{background:var(--accent-3);border-color:#c0790a;color:#fff}
.kbd{font-family:Rubik,ui-monospace,Menlo,Consolas,monospace;border:1px solid var(--line);padding:1px 6px;border-radius:6px;background:#fff}
.code{font-family:Rubik,ui-monospace,Menlo,Consolas,monospace;background:#0b1220;color:#eaeefb;border-radius:10px;padding:10px 12px;font-size:12px;white-space:pre-wrap}
input[type=text]{width:100%;padding:8px 10px;border-radius:10px;border:1px solid var(--line);font-family:Rubik,ui-monospace,Menlo,Consolas,monospace;font-size:12px;white-space:pre}

/* Formula input highlighting (fx) */
.fx-wrap{position:relative;flex:1}
#fxHighlight{position:absolute;inset:0;padding:8px 10px;border-radius:10px;background:#fff;pointer-events:none;white-space:pre;overflow:hidden;font-family:Rubik,ui-monospace,Menlo,Consolas,monospace;font-size:12px;color:var(--ink)}
#fx{background:transparent;color:transparent;caret-color:var(--ink);position:relative}
.tok-str{color:#16a34a}
.tok-range{color:#f59e0b}
.tok-num{color:#1d4ed8}

/* HUD positions */
#hud{top:16px;left:16px;width:420px;display:none}
#right{top:16px;right:16px;width:380px;display:none}
#footer{display:none}
.sub{color:var(--muted);font-size:12px}

/* 2D Sheet + merged Fx UI */
.intro-centered{width:860px !important; height:520px !important; left:50% !important; top:50% !important; bottom:auto !important; transform:translate(-50%,-50%) !important}
#sheet{position:fixed; left:16px; bottom:16px; width:760px; height:440px; background:var(--panel); border:1px solid var(--line); border-radius:16px; box-shadow:var(--shadow); padding:12px; z-index:10001; display:flex; flex-direction:column; transition:all .9s cubic-bezier(0.34,1.56,0.64,1); overflow:hidden}
.intro-max{width:95vw !important; height:95vh !important; left:50% !important; top:50% !important; bottom:auto !important; transform:translate(-50%,-50%) !important}
body.crystal-2d #sheet{background:linear-gradient(150deg, rgba(255,255,255,0.22) 0%, rgba(221,238,255,0.28) 42%, rgba(236,233,255,0.18) 100%); border:1px solid rgba(255,255,255,0.58); box-shadow:0 30px 60px rgba(15,23,42,0.25), inset 0 1px 0 rgba(255,255,255,0.75); backdrop-filter:blur(26px) saturate(185%); -webkit-backdrop-filter:blur(26px) saturate(185%); position:fixed;}
body.crystal-2d #sheet::before{content:""; position:absolute; inset:-12% -18%; border-radius:28px; background:radial-gradient(120% 140% at 12% 8%, rgba(255,255,255,0.65) 0%, rgba(255,255,255,0.05) 55%), radial-gradient(140% 140% at 88% 92%, rgba(147,197,253,0.35) 0%, rgba(147,197,253,0.0) 65%); opacity:0.7; pointer-events:none; filter:blur(4px);}
body.crystal-2d #sheet::after{content:""; position:absolute; inset:-2px; border-radius:inherit; border:1px solid rgba(255,255,255,0.4); mix-blend-mode:soft-light; opacity:0.7; pointer-events:none;}
body.crystal-2d #sheet .sheet-head{background:rgba(255,255,255,0.22); border-bottom:1px solid rgba(255,255,255,0.45); box-shadow:inset 0 1px 0 rgba(255,255,255,0.6); backdrop-filter:blur(12px); -webkit-backdrop-filter:blur(12px);}
body.crystal-2d #sheet .sheet-title{color:#0f172a; text-shadow:0 1px 12px rgba(148,163,209,0.45);}
body.crystal-2d #sheet .sheet-ctrls .btn{background:rgba(255,255,255,0.55); border-color:rgba(148,163,209,0.45); color:#1f2937; box-shadow:0 12px 24px rgba(15,23,42,0.18); backdrop-filter:blur(8px); -webkit-backdrop-filter:blur(8px);}
body.crystal-2d #sheet .sheet-ctrls .btn:hover{border-color:rgba(59,130,246,0.55);}
body.crystal-2d table.sheet th{background:linear-gradient(180deg, rgba(255,255,255,0.5) 0%, rgba(229,240,255,0.28) 100%); border:1px solid rgba(255,255,255,0.45); color:#0f172a; text-shadow:0 1px 10px rgba(255,255,255,0.55); backdrop-filter:blur(10px); -webkit-backdrop-filter:blur(10px);}
body.crystal-2d table.sheet td{background:rgba(255,255,255,0.58); border:1px solid rgba(255,255,255,0.38); color:#0b1220; backdrop-filter:blur(12px); -webkit-backdrop-filter:blur(12px);}
body.crystal-2d table.sheet td.sel{background:rgba(96,165,250,0.32) !important; box-shadow:0 0 0 1px rgba(59,130,246,0.5) inset;}
body.crystal-2d table.sheet td.hovered{background:rgba(147,197,253,0.28) !important; border-color:rgba(96,165,250,0.5) !important;}
body.crystal-2d table.sheet td.cell:hover{background:rgba(191,219,254,0.33) !important;}
body.crystal-2d .note-tooltip{background:rgba(59,130,246,0.82); box-shadow:0 10px 22px rgba(59,130,246,0.28); backdrop-filter:blur(8px); -webkit-backdrop-filter:blur(8px);}
body.crystal-2d #sheetHeaderCard{background:rgba(241,245,255,0.52); border:1px solid rgba(255,255,255,0.58); box-shadow:0 26px 48px rgba(15,23,42,0.22); backdrop-filter:blur(28px) saturate(175%); -webkit-backdrop-filter:blur(28px) saturate(175%);}
body.crystal-2d #sheetHeaderCard.wipe{background:rgba(229,239,255,0.58);}
/* No body fade; overlay handles it */
.sheet-resizer{position:absolute; right:6px; bottom:6px; width:12px; height:12px; background:var(--accent); border-radius:3px; cursor:nwse-resize}
.sheet-head{display:flex;flex-direction:column;gap:8px; padding:8px; border-bottom:1px solid var(--line)}
/* Disable old floating chip header */
.app-header-float{ display:none }
/* Behind-sheet header card that expands to wipe */
#sheetHeaderCard{ position:fixed; z-index:10000; display:none; background:rgba(255,255,255,0.92); border:1px solid rgba(0,0,0,0.08); border-radius:18px; box-shadow:0 10px 30px rgba(0,0,0,0.18), inset 0 1px 0 rgba(255,255,255,0.65); backdrop-filter:saturate(150%) blur(8px); transition: all .6s cubic-bezier(.34,1.56,.64,1) }
#sheetHeaderCard.visible{ display:block }
#sheetHeaderCard.wipe{ left:0 !important; top:0 !important; width:100vw !important; height:100vh !important; border-radius:0 !important }
.sheet-title-row{display:flex;justify-content:space-between;align-items:center}
.sheet-title{font-weight:800}
.sheet-ctrls{display:flex;gap:6px;align-items:center}
.sheet-fx{display:flex; gap:6px; align-items:center; flex-wrap:wrap}
.sheet-fx input{flex:1}
/* Touch-only minimize (yellow dot) */
#minDot{ position:absolute; right:12px; top:12px; width:16px; height:16px; background:#facc15; border:1px solid #eab308; border-radius:50%; box-shadow:0 2px 6px rgba(0,0,0,.15); transform:scale(0); opacity:0; transition: transform .35s cubic-bezier(.34,1.56,.64,1), opacity .25s ease; z-index:5; display:none }
body.touch #minDot.show{ display:block; transform:scale(1); opacity:1 }
.sheet-body{flex:1; display:flex; overflow:hidden}
.col-headers{position:relative; margin-left:48px; height:60px; display:flex; gap:0}
.row-headers{width:48px; overflow:auto hidden; border-right:1px solid var(--line)}
.grid-wrap{flex:1; overflow:auto}
table.sheet{border-collapse:collapse; table-layout:fixed; width:max-content}
table.sheet td, table.sheet th{border:1px solid #e6e8ef; padding:0; height:60px; font-size:14px; font-family:'Roboto Mono', monospace}
/* Match reference code: use Roboto Mono for both headers and cells */
td.cell{width:92px; background:#fff; padding:0 6px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; cursor:pointer; text-align:left; font-family:'Roboto Mono', monospace}
/* Axes/header cells: soft gray */
table.sheet th{ background:#f9fafb; text-align:center; font-weight:600 }
/* Row header (Y labels) padding/width for non-touch */
table.sheet tr th:first-child{ min-width:56px; padding:0 10px }

/* Ensure compatibility with reference-style selector */
.sheet-table th,.sheet-table td{ border:1px solid var(--line); padding:6px 8px; min-width:60px; text-align:left; font-family:'Roboto Mono', monospace; font-size:14px }
.sheet-table th{ background:#f9fafb; text-align:center; font-weight:600 }
td.cell[data-generated="true"]{background:#f0fdf4} /* Light green for formula-emitted cells */
td.cell[data-anchor="true"]{background:#dcfce7} /* Darker green for anchor cells */
td.sel{outline:2px solid var(--accent); outline-offset:-2px; background:#eef5ff}
.cell.clickable{ cursor:pointer; }
.cell.pending{ background:#fef08a !important; }
.layer-chip{display:none}
.layer-btn{border:1px solid var(--line); background:#fff; border-radius:8px; padding:2px 6px; cursor:pointer}
#directEdit{position:fixed; z-index:30; padding:6px 8px; border-radius:8px; border:1px solid var(--line); font-family:Rubik,ui-monospace,Menlo,Consolas,monospace; display:none}

/* Header alignment fix: ensure headers match cell size exactly */
.col-headers .chip{height:60px; line-height:60px; min-width:80px; padding:0; text-align:center}
.row-headers .chip{height:60px; line-height:60px; width:48px; padding:0; text-align:center}

/* Cell hover like reference code */
td.cell:hover{background-color: #eff6ff !important}
/* Programmatic hover sync class for 2D */
td.cell.hovered{background-color:#e0f2ff !important; border:1px solid #93c5fd !important}
/* Note tooltip - simple blue card on hover */
.note-tooltip{position:absolute; top:-30px; left:10px; background:#3b82f6; color:white; padding:4px 8px; border-radius:6px; font-size:11px; white-space:nowrap; opacity:0; transform:translateY(4px); transition:opacity .2s ease, transform .2s ease; pointer-events:none; z-index:200}
.cell:hover .note-tooltip{opacity:1; transform:translateY(0)}
.note-visible{opacity:1 !important; transform:translateY(0) !important}
/* Special styling for intro cell */
.intro-cell{position:relative; background:#e0e7ff !important; font-weight:600; overflow:visible !important}

/* Touch mode scaling */
body.touch #sheet{ width:86vw; height:40vh }
body.touch table.sheet td, body.touch table.sheet th{ height:34px; font-size:14px }
body.touch td.cell{ width:120px }
body.touch .ui-icon{ width:64px; height:64px }
body.touch #dpad{ --dp:64px; gap:8px; right:16px; bottom:16px }
body.touch .desktop-only{ display:none !important }
body.touch .mobile-only{ display:flex !important }
body:not(.touch) .mobile-only{ display:none !important }
body:not(.touch) .desktop-only{ display:flex !important }
/* Touch-friendly sheet sizing: full device width card at bottom */
body.touch #sheet{ left:50%; right:auto; width:min(92vw, 680px); height:40vh; bottom:12px; top:auto; transform:translateX(-50%) }
body.touch #graphicsSettingsPanel,
body.touch #oceanSettingsPanel{
 position:fixed !important;
 left:50% !important;
 top:50% !important;
 transform:translate(-50%,-50%) !important;
 right:auto !important;
 bottom:auto !important;
 width:min(92vw, 420px) !important;
 max-height:80vh !important;
 z-index:10004 !important;
}
body.touch .sheet-body .sheet td, body.touch .sheet-body .sheet th{ height:36px; font-size:15px }
/* Make cells scale to ~8 columns (minus row header) */
body.touch .sheet-body .sheet td.cell{ width:calc((100vw - 24px - 150px)/8) }

/* Touch-friendly sheet sizing: full device width with small gutters */
body.touch #sheet{ left:50%; right:auto; width:min(92vw, 680px); height:40vh; transform:translateX(-50%) }
body.touch .sheet-body .sheet td, body.touch .sheet-body .sheet th{ height:36px; font-size:15px }
/* Make cells scale to roughly 8 visible columns minus row header */
body.touch .sheet-body .sheet td.cell{ width:calc((100vw - 24px - 140px)/8) }
/* Touch: opening (intro-centered) should be a centered card with mobile dimensions */
body.touch #sheet.intro-centered{ width:min(92vw, 680px) !important; height:40vh !important; left:50% !important; top:50% !important; bottom:auto !important; transform:translate(-50%,-50%) !important }
/* Hide debug console by default on touch; allow button to show it */
body.touch #hud{ display:none }
#debug-icon{ position:fixed; left:24px; bottom:24px; z-index:10003 }

/* Fx panel (docs) */
#fxPanel{position:relative; flex:0 0 340px; height:100%; background:var(--panel); border:1px solid var(--line); border-radius:16px; box-shadow:var(--shadow); display:none; flex-direction:column; z-index:11; opacity:0; transform:translateX(12px); transition:opacity .25s ease, transform .25s ease, box-shadow .25s ease}
.fx-visible{display:flex !important; opacity:1 !important; transform:translateX(0) !important}
.fx-panel{margin-left:12px; border-left:1px solid var(--line)}
.fx-head{display:flex; align-items:center; justify-content:space-between; padding:8px 12px; border-bottom:1px solid var(--line)}
.fx-body{flex:1; overflow:auto; padding:8px 12px}
.fx-item{border:1px solid var(--line); border-radius:12px; padding:8px 10px; margin-bottom:8px}
.fx-name{font-weight:800}
.fx-syntax{font-family:Rubik,ui-monospace,Menlo,Consolas,monospace; background:#0b1220; color:#eaeefb; padding:6px 8px; border-radius:8px; font-size:12px; margin-top:6px}
.fx-desc{font-size:12px; color:var(--muted); margin-top:6px}
.fx-copy{font-size:12px; border:1px solid var(--line); padding:4px 8px; border-radius:8px; cursor:pointer}
.fx-category-header{transition: background-color 0.2s;}
.fx-category-header:hover{background-color: rgba(0,0,0,0.05) !important;}
.fx-category-body{overflow:hidden; transition: all 0.3s ease;}
.fx-item{border:1px solid var(--line); border-radius:8px; padding:6px 8px; margin-bottom:4px; background:#fff;}

/* Toast */
#toast{position:fixed; left:50%; transform:translateX(-50%); top:16px; padding:8px 12px; border-radius:10px; background:#111827; color:#fff; font-size:12px; display:none; z-index:50}

/* Brand card on intro overlay */
#introBrand{position:absolute; left:24px; top:24px; transform:none; z-index:10001; display:flex; flex-direction:column; align-items:center; justify-content:center; padding:16px 28px; border-radius:28px; color:#0b1320; font-weight:700; font-size:22px; letter-spacing:.2px; box-shadow:0 10px 30px rgba(0,0,0,0.20), inset 0 1px 0 rgba(255,255,255,0.75); border:1px solid rgba(255,255,255,0.35); background:linear-gradient(180deg, rgba(255,255,255,0.52), rgba(255,255,255,0.30)); backdrop-filter:blur(20px) saturate(180%)}
#introBrand::before{content:""; position:absolute; inset:0; border-radius:28px; background:radial-gradient(120px 80px at 20% 30%, rgba(59,130,246,0.35), transparent 60%), radial-gradient(140px 100px at 80% 70%, rgba(236,72,153,0.28), transparent 60%); pointer-events:none; filter:blur(8px)}
#introBrand .brand-ver{font-weight:400; font-size:12px; opacity:.8; margin-top:3px}

/* D-Pad HUD (soft lab style) */
#dpad{
 --dp:56px;
 position:fixed; right:24px; bottom:24px; z-index:20;
 display:grid;
 grid-template-columns: var(--dp) var(--dp) var(--dp);
 grid-template-rows: var(--dp) var(--dp) var(--dp);
 grid-template-areas:
 "grab up depthUp"
 "left center right"
 "present down depthDown";
 gap:10px;
}
#dpad .dp{
 width:var(--dp); height:var(--dp);
 border:1px solid #2162df;
 border-radius:12px; 
 background:var(--accent);
 color:#fff; 
 display:flex; align-items:center; justify-content:center; 
 cursor:pointer; font-weight:800; font-size:18px; 
 box-shadow: var(--shadow);
}
#dpad .dp:hover{filter:brightness(1.06)}
#dpad .dp:active{transform:translateY(1px)}
#dpad .up{grid-area:up}
#dpad .left{grid-area:left}
#dpad .right{grid-area:right}
#dpad .down{grid-area:down}
#dpad .depthUp{grid-area:depthUp}
#dpad .depthDown{grid-area:depthDown}
#dpad .jump{grid-area:depthUp; background:#22c55e; border-color:#16a34a}
#dpad .center{grid-area:center; visibility:visible; font-size:14px}
#dpad .present{grid-area:present; background:#fff; color:#1f2937; border:1px solid #d1d5e4; font-weight:700; display:flex; align-items:center; justify-content:center;}
#dpad .present.active{background:var(--accent-2); border-color:#15803d; color:#fff;}
#dpad .grab{grid-area:grab; width:calc(var(--dp)*0.7); height:calc(var(--dp)*0.7); align-self:center; justify-self:center; border:1px dashed #e5e7eb; background:#ffffffaa; color:#1f2937; font-size:14px; display:flex; align-items:center; justify-content:center; cursor:grab}
#dpad .grab:active{cursor:grabbing}
body.touch #dpad .grab{pointer-events:none; opacity:0.3}

/* Visible focus for keyboard users */
:where(button,[role="button"],a,input,select,textarea,[tabindex]):focus-visible{
 outline: 2px solid rgba(59,130,246,0.8);
 outline-offset: 2px;
}
@media (prefers-contrast: more){
 :where(button,[role="button"],a,input,select,textarea,[tabindex]):focus-visible{
 outline-width: 3px;
 }
}







/* Respect reduced motion preferences */
@media (prefers-reduced-motion: reduce){
 .anim-spin, .anim-pulse, #world::after{
 animation: none !important;
 transition-duration: 0.001ms !important;
 }
}

/* Twemoji styling */
img.emoji {
 height: 1em;
 width: 1em;
 margin: 0 0.05em 0 0.1em;
 vertical-align: -0.1em;
}
</style>

</head>
<body>

<script>
(function(){
 var reduce = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
 if(reduce){ document.documentElement.classList.add('reduced-motion'); }
 if(reduce && !window.__rafPatched){
 window.__rafPatched = true;
 var _raf = window.requestAnimationFrame;
 window.requestAnimationFrame = function(cb){
 return setTimeout(function(){ try{ cb(performance.now()); }catch(e){} }, 250);
 };
 }
})();
</script>
<script>
document.addEventListener('click', function(e){
 try{
 var btn = e.target && e.target.closest && e.target.closest('button[aria-pressed]');
 if(!btn) return;
 var next = (btn.getAttribute('aria-pressed') !== 'true').toString();
 btn.setAttribute('aria-pressed', next);
 }catch{}
}, {capture:true});
</script>
<script>
(function(){
 try{
 var canvas=document.createElement('canvas');
 var ok = !!(window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
 if(!ok){
 var wrap=document.createElement('div');
 wrap.setAttribute('role','alert');
 wrap.style.cssText='position:fixed;inset:0;display:flex;align-items:center;justify-content:center;padding:24px;background:rgba(0,0,0,0.6);z-index:99999;';
 wrap.innerHTML='<div style="max-width:640px;background:#fff;color:#111;border-radius:12px;padding:20px;box-shadow:0 10px 30px rgba(0,0,0,.2)"><h2 style="margin:0 0 8px">WebGL not available</h2><p>The 3D view is unavailable. You can still work with the sheet. Try updating your browser or enable hardware acceleration.</p></div>';
 document.body.appendChild(wrap);
 document.documentElement.classList.add('no-webgl');
 }
 }catch(e){ console.warn('WebGL check failed', e); }
})();
</script>
<div id="introOverlay"><div id="introBrand">celli.os<div class="brand-ver">v.0.0.1</div></div></div>
<div id="world"></div>
<canvas id="view"></canvas>

<!-- Debug/builder card -->
<div class="panel stack" id="hud" style="padding:0; overflow:hidden">
 <div class="win-header" style="background:rgba(255,255,255,.06);display:flex;align-items:center;justify-content:space-between;padding:8px 12px;border-bottom:1px solid rgba(255,255,255,.12)"><span>DEBUG CONSOLE</span><div id="debug-close" class="close" title="Hide"></div></div>
 <div class="sub" style="padding:0 12px 8px;">Click cells <span class="kbd">? ? ? ?</span> move <span class="kbd">Enter</span> edit <span class="kbd">P</span> physics <span class="kbd">F</span> functions</div>
 
 <!-- Navigation & View Controls -->
 <div class="row" style="padding:0 12px 6px;">
 <button class="btn primary" id="centerHome">?? Home</button>
 <button class="btn" id="viewMainframe">??? Mainframe</button>
 <button class="btn" id="toggleGrid">Grid</button>
 <button class="btn" id="toggleAxes">Axes</button>
 </div>
 
 <!-- Scene & Physics Controls -->
  <div class="row" style="padding:0 12px 6px;">
  <button class="btn good" id="physicsBtn">? Physics</button>
  <button class="btn" id="toggleChunks">?? Chunks</button>
  <button class="btn warn" id="reset">?? Reset</button>
  </div>

  <div class="row" style="padding:0 12px 6px;">
  <button class="btn" id="celliCollapseBtn">?? Multi-Wrap Collapse</button>
  </div>

 <div class="row" style="padding:0 12px 6px;">
 <button class="btn" id="presentToggleBtn">?? Present: OFF</button>
 <button class="btn" id="graphicsSettingsBtn">??? Graphic Settings</button>
 <button class="btn" id="oceanSettingsBtn">?? Ocean Backdrop</button>
 <button class="btn" id="oceanSpottedBtn">🔦 Spotted</button>
 </div>

 <label class="row" style="padding:0 12px 6px; justify-content:space-between; align-items:center; font-weight:600;">
 <span>Crystal 2D Style</span>
 <input type="checkbox" id="crystal2DToggle">
 </label>

 <!-- Data Import/Export -->
 <div class="row" style="padding:0 12px 6px;">
 <button class="btn" id="importFileBtn">?? Import File</button>
 <button class="btn" id="pasteDataBtn">?? Paste Data</button>
 </div>
 
 <!-- Save System -->
 <div class="row" style="padding:0 12px 6px;">
 <button class="btn good" id="saveStateBtn">?? Save</button>
 <button class="btn" id="loadStateBtn">?? Load</button>
 <button class="btn warn" id="clearSaveBtn">??? Clear Save</button>
 </div>
 
 <!-- Save Status -->
 <div style="padding:0 12px 12px; font-size:11px; color:var(--muted);">
 <span id="saveStatus">Auto-save: Ready</span>
 </div>
</div>

<div class="panel stack" id="graphicsSettingsPanel" style="display:none; position:absolute; left:440px; top:16px; width:320px; max-height:80vh; overflow:auto;">
 <div class="win-header" style="background:rgba(255,255,255,.06);display:flex;align-items:center;justify-content:space-between;padding:8px 12px;border-bottom:1px solid rgba(255,255,255,.12)">
 <span>Graphic Settings</span>
 <div id="graphicsSettingsClose" class="close" title="Hide"></div>
 </div>
 <div class="stack" style="padding:12px; gap:12px;">
 <div class="sub" id="graphicsSettingsHint">Enable Present mode to tweak fancy rendering.</div>

 <div class="stack" style="gap:6px;">
 <div class="title" style="font-size:14px;">Environment</div>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Studio HDRI</span>
 <input type="checkbox" id="gfxHdri">
 </label>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>3-Point Lighting</span>
 <input type="checkbox" id="gfxLights">
 </label>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Dark Background</span>
 <input type="checkbox" id="gfxDarkBg">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Light Rotation <span id="gfxLightRotationValue"></span></span>
 <input type="range" id="gfxLightRotation" min="0" max="360" step="1">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Light Strength <span id="gfxLightStrengthValue"></span></span>
 <input type="range" id="gfxLightStrength" min="0" max="2" step="0.05">
 </label>
 </div>

 <div class="stack" style="gap:6px;">
 <div class="title" style="font-size:14px;">Cinematic</div>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Bloom</span>
 <input type="checkbox" id="gfxBloom">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Bloom Strength <span id="gfxBloomStrengthValue"></span></span>
 <input type="range" id="gfxBloomStrength" min="0" max="1" step="0.01">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Bloom Radius <span id="gfxBloomRadiusValue"></span></span>
 <input type="range" id="gfxBloomRadius" min="0" max="1" step="0.05">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Exposure <span id="gfxExposureValue"></span></span>
 <input type="range" id="gfxExposure" min="0.4" max="2" step="0.05">
 </label>
 </div>

 <div class="stack" style="gap:6px;">
 <div class="title" style="font-size:14px;">Depth of Field</div>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Depth of Field</span>
 <input type="checkbox" id="gfxDof">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Aperture <span id="gfxDofApertureValue"></span></span>
 <input type="range" id="gfxDofAperture" min="0" max="0.02" step="0.0005">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Max Blur <span id="gfxDofMaxBlurValue"></span></span>
 <input type="range" id="gfxDofMaxBlur" min="0" max="0.02" step="0.0005">
 </label>
 </div>

 <div class="stack" style="gap:6px;">
 <div class="title" style="font-size:14px;">Visual Extras</div>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Frosted Glass</span>
 <input type="checkbox" id="gfxTransmission">
 </label>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Reflective Ground</span>
 <input type="checkbox" id="gfxMirror">
 </label>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Solid Ground</span>
 <input type="checkbox" id="gfxGround">
 </label>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Deforming Grid</span>
 <input type="checkbox" id="gfxWaveGrid">
 </label>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>FXAA</span>
 <input type="checkbox" id="gfxFxaa">
 </label>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Fog</span>
 <input type="checkbox" id="gfxFog">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Fog Density <span id="gfxFogDensityValue"></span></span>
 <input type="range" id="gfxFogDensity" min="0" max="0.05" step="0.001">
 </label>
 </div>

 <div class="stack" style="gap:6px;">
 <div class="title" style="font-size:14px;">Stylization</div>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Selection Outline</span>
 <input type="checkbox" id="gfxOutline">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Outline Strength <span id="gfxOutlineStrengthValue"></span></span>
 <input type="range" id="gfxOutlineStrength" min="0" max="5" step="0.1">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Outline Thickness <span id="gfxOutlineThicknessValue"></span></span>
 <input type="range" id="gfxOutlineThickness" min="0" max="4" step="0.1">
 </label>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Motion Blur</span>
 <input type="checkbox" id="gfxMotion">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Blur Damping <span id="gfxMotionDampingValue"></span></span>
 <input type="range" id="gfxMotionDamping" min="0.7" max="0.99" step="0.005">
 </label>
 </div>
 </div>
</div>

<div class="panel stack" id="oceanSettingsPanel" style="display:none; position:absolute; left:440px; top:340px; width:360px; max-height:80vh; overflow:auto;">
 <div class="win-header" style="background:rgba(255,255,255,.06);display:flex;align-items:center;justify-content:space-between;padding:8px 12px;border-bottom:1px solid rgba(255,255,255,.12)">
 <span>Ocean Backdrop</span>
 <div id="oceanSettingsClose" class="close" title="Hide"></div>
 </div>
 <div class="stack" style="padding:12px; gap:12px;">
 <div class="sub" id="oceanSettingsHint">Enable Present mode and toggle on the ocean backdrop to adjust these settings.</div>

 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Enable Ocean</span>
 <input type="checkbox" id="oceanEnable">
 </label>

 <div class="stack" style="gap:10px;">
 <div class="title" style="font-size:14px;">General</div>
 <label class="stack" style="gap:4px;">
 <span class="sub">Env Intensity <span id="oceanEnvIntensityValue"></span></span>
 <input type="range" id="oceanEnvIntensity" min="0" max="4" step="0.05">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Key Light Intensity <span id="oceanLightIntensityValue"></span></span>
 <input type="range" id="oceanLightIntensity" min="0" max="5" step="0.05">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Exposure <span id="oceanExposureValue"></span></span>
 <input type="range" id="oceanExposure" min="0.3" max="2.5" step="0.01">
 </label>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Grid Overlay</span>
 <input type="checkbox" id="oceanShowGrid">
 </label>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Buoy Sphere</span>
 <input type="checkbox" id="oceanShowSphere">
 </label>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Dead Towers</span>
 <input type="checkbox" id="oceanShowTowers">
 </label>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Floating Lights</span>
 <input type="checkbox" id="oceanShowFloaters">
 </label>
 <button class="btn" id="oceanScreenshotBtn">?? Capture Screenshot</button>
 </div>

 <div class="stack" style="gap:10px;">
 <div class="title" style="font-size:14px;">Sky &amp; Sun</div>
 <label class="stack" style="gap:4px;">
 <span class="sub">Sun Elevation <span id="oceanSunElevationValue"></span></span>
 <input type="range" id="oceanSunElevation" min="0" max="90" step="1">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Sun Azimuth <span id="oceanSunAzimuthValue"></span></span>
 <input type="range" id="oceanSunAzimuth" min="0" max="360" step="1">
 </label>
 <label class="stack" style="gap:4px;">
 <span>Sky Top</span>
 <input type="color" id="oceanSkyTop" value="#8ec1ea">
 </label>
 <label class="stack" style="gap:4px;">
 <span>Sky Mid</span>
 <input type="color" id="oceanSkyMid" value="#63aee3">
 </label>
 <label class="stack" style="gap:4px;">
 <span>Sky Bottom</span>
 <input type="color" id="oceanSkyBot" value="#092c4d">
 </label>
 </div>

 <div class="stack" style="gap:10px;">
 <div class="title" style="font-size:14px;">Waves</div>
 <label class="stack" style="gap:4px;">
 <span class="sub">Time Scale <span id="oceanTimeScaleValue"></span></span>
 <input type="range" id="oceanTimeScale" min="0.1" max="3" step="0.01">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Choppiness <span id="oceanChoppinessValue"></span></span>
 <input type="range" id="oceanChoppiness" min="0" max="2" step="0.01">
 </label>
 <div class="sub" style="font-weight:600;">Gerstner Bands</div>
 <div class="stack" style="gap:6px;">
 <div class="stack" style="gap:4px;" data-wave="0">
 <span class="sub">Band 0 Amplitude <span id="oceanAmp0Value"></span></span>
 <input type="range" id="oceanAmp0" min="0" max="2" step="0.01">
 <span class="sub">Band 0 Wavelength <span id="oceanLen0Value"></span></span>
 <input type="range" id="oceanLen0" min="1" max="50" step="0.1">
 <span class="sub">Band 0 Speed <span id="oceanSpeed0Value"></span></span>
 <input type="range" id="oceanSpeed0" min="0.1" max="3" step="0.01">
 </div>
 <div class="stack" style="gap:4px;" data-wave="1">
 <span class="sub">Band 1 Amplitude <span id="oceanAmp1Value"></span></span>
 <input type="range" id="oceanAmp1" min="0" max="2" step="0.01">
 <span class="sub">Band 1 Wavelength <span id="oceanLen1Value"></span></span>
 <input type="range" id="oceanLen1" min="1" max="50" step="0.1">
 <span class="sub">Band 1 Speed <span id="oceanSpeed1Value"></span></span>
 <input type="range" id="oceanSpeed1" min="0.1" max="3" step="0.01">
 </div>
 <div class="stack" style="gap:4px;" data-wave="2">
 <span class="sub">Band 2 Amplitude <span id="oceanAmp2Value"></span></span>
 <input type="range" id="oceanAmp2" min="0" max="2" step="0.01">
 <span class="sub">Band 2 Wavelength <span id="oceanLen2Value"></span></span>
 <input type="range" id="oceanLen2" min="1" max="50" step="0.1">
 <span class="sub">Band 2 Speed <span id="oceanSpeed2Value"></span></span>
 <input type="range" id="oceanSpeed2" min="0.1" max="3" step="0.01">
 </div>
 <div class="stack" style="gap:4px;" data-wave="3">
 <span class="sub">Band 3 Amplitude <span id="oceanAmp3Value"></span></span>
 <input type="range" id="oceanAmp3" min="0" max="2" step="0.01">
 <span class="sub">Band 3 Wavelength <span id="oceanLen3Value"></span></span>
 <input type="range" id="oceanLen3" min="1" max="50" step="0.1">
 <span class="sub">Band 3 Speed <span id="oceanSpeed3Value"></span></span>
 <input type="range" id="oceanSpeed3" min="0.1" max="3" step="0.01">
 </div>
 <div class="stack" style="gap:4px;" data-wave="4">
 <span class="sub">Band 4 Amplitude <span id="oceanAmp4Value"></span></span>
 <input type="range" id="oceanAmp4" min="0" max="2" step="0.01">
 <span class="sub">Band 4 Wavelength <span id="oceanLen4Value"></span></span>
 <input type="range" id="oceanLen4" min="1" max="50" step="0.1">
 <span class="sub">Band 4 Speed <span id="oceanSpeed4Value"></span></span>
 <input type="range" id="oceanSpeed4" min="0.1" max="3" step="0.01">
 </div>
 <div class="stack" style="gap:4px;" data-wave="5">
 <span class="sub">Band 5 Amplitude <span id="oceanAmp5Value"></span></span>
 <input type="range" id="oceanAmp5" min="0" max="2" step="0.01">
 <span class="sub">Band 5 Wavelength <span id="oceanLen5Value"></span></span>
 <input type="range" id="oceanLen5" min="1" max="50" step="0.1">
 <span class="sub">Band 5 Speed <span id="oceanSpeed5Value"></span></span>
 <input type="range" id="oceanSpeed5" min="0.1" max="3" step="0.01">
 </div>
 </div>
 </div>

 <div class="stack" style="gap:10px;">
 <div class="title" style="font-size:14px;">Ocean Shader</div>
 <label class="stack" style="gap:4px;">
 <span>Deep Water</span>
 <input type="color" id="oceanDeepColor" value="#0b345a">
 </label>
 <label class="stack" style="gap:4px;">
 <span>Shallow Water</span>
 <input type="color" id="oceanShallowColor" value="#1e6aa2">
 </label>
 <label class="stack" style="gap:4px;">
 <span>Foam Color</span>
 <input type="color" id="oceanFoamColor" value="#ffffff">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Foam Amount <span id="oceanFoamAmountValue"></span></span>
 <input type="range" id="oceanFoamAmount" min="0" max="5" step="0.1">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Foam Threshold <span id="oceanFoamBiasValue"></span></span>
 <input type="range" id="oceanFoamBias" min="-1" max="3" step="0.05">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Foam Sharpness <span id="oceanFoamScaleValue"></span></span>
 <input type="range" id="oceanFoamScale" min="0.1" max="5" step="0.1">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Max Gloss <span id="oceanMaxGlossValue"></span></span>
 <input type="range" id="oceanMaxGloss" min="0" max="1" step="0.01">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Roughness Scale <span id="oceanRoughnessScaleValue"></span></span>
 <input type="range" id="oceanRoughnessScale" min="0.0001" max="0.02" step="0.0001">
 </label>
 <label class="stack" style="gap:4px;">
 <span>Horizon Color</span>
 <input type="color" id="oceanHorizonColor" value="#cfeaff">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Horizon Fade Start <span id="oceanHorizonStartValue"></span></span>
 <input type="range" id="oceanHorizonStart" min="10" max="400" step="1">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Horizon Fade End <span id="oceanHorizonEndValue"></span></span>
 <input type="range" id="oceanHorizonEnd" min="50" max="900" step="1">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Horizon Boost <span id="oceanHorizonBoostValue"></span></span>
 <input type="range" id="oceanHorizonBoost" min="0" max="2" step="0.01">
 </label>
 </div>

 <div class="stack" style="gap:10px;">
 <div class="title" style="font-size:14px;">Micro Ripples</div>
 <label class="stack" style="gap:4px;">
 <span class="sub">Ripple Strength <span id="oceanMicroScaleValue"></span></span>
 <input type="range" id="oceanMicroScale" min="0" max="0.15" step="0.005">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Ripple Frequency <span id="oceanMicroFreqValue"></span></span>
 <input type="range" id="oceanMicroFreq" min="5" max="50" step="0.5">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Ripple Size Scale <span id="oceanMicroWaveScaleValue"></span></span>
 <input type="range" id="oceanMicroWaveScale" min="0.1" max="2" step="0.05">
 </label>
 </div>

 <div class="stack" style="gap:10px;">
 <div class="title" style="font-size:14px;">Post Processing</div>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Enable Bloom</span>
 <input type="checkbox" id="oceanEnableBloom">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Bloom Strength <span id="oceanBloomStrengthValue"></span></span>
 <input type="range" id="oceanBloomStrength" min="0" max="2" step="0.01">
 </label>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Enable Vignette</span>
 <input type="checkbox" id="oceanEnableVignette">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Vignette Strength <span id="oceanVignetteStrengthValue"></span></span>
 <input type="range" id="oceanVignetteStrength" min="0" max="2" step="0.01">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Film Grain <span id="oceanGrainAmountValue"></span></span>
 <input type="range" id="oceanGrainAmount" min="0" max="0.1" step="0.001">
 </label>
 </div>

 <div class="stack" style="gap:10px;">
 <div class="title" style="font-size:14px;">God Rays</div>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Enable Rays</span>
 <input type="checkbox" id="oceanEnableRays">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Ray Strength <span id="oceanRayStrengthValue"></span></span>
 <input type="range" id="oceanRayStrength" min="0" max="4" step="0.01">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Ray Decay <span id="oceanRayDecayValue"></span></span>
 <input type="range" id="oceanRayDecay" min="0.6" max="1" step="0.001">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Ray Exposure <span id="oceanRayExposureValue"></span></span>
 <input type="range" id="oceanRayExposure" min="0" max="2.5" step="0.01">
 </label>
 </div>

 <div class="stack" style="gap:10px;">
 <div class="title" style="font-size:14px;">Lighthouse Beams</div>
 <label class="row" style="justify-content:space-between; align-items:center;">
 <span>Enable Beams</span>
 <input type="checkbox" id="oceanEnableLighthouse">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Beam Strength <span id="oceanLighthouseStrengthValue"></span></span>
 <input type="range" id="oceanLighthouseStrength" min="0" max="2.5" step="0.01">
 </label>
 </div>

 <div class="stack" style="gap:10px;">
 <div class="title" style="font-size:14px;">Depth of Field &amp; Fog</div>
 <label class="stack" style="gap:4px;">
 <span class="sub">Focus Distance <span id="oceanFocusDistanceValue"></span></span>
 <input type="range" id="oceanFocusDistance" min="5" max="1000" step="1">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">DOF Strength <span id="oceanDofStrengthValue"></span></span>
 <input type="range" id="oceanDofStrength" min="0" max="3" step="0.01">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Focus Range <span id="oceanFocusRangeValue"></span></span>
 <input type="range" id="oceanFocusRange" min="10" max="500" step="1">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Fog Start <span id="oceanFogStartValue"></span></span>
 <input type="range" id="oceanFogStart" min="50" max="1000" step="1">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Fog End <span id="oceanFogEndValue"></span></span>
 <input type="range" id="oceanFogEnd" min="200" max="3000" step="10">
 </label>
 <label class="stack" style="gap:4px;">
 <span>Fog Color</span>
 <input type="color" id="oceanFogColor" value="#5aaee3">
 </label>
 </div>

 <div class="stack" style="gap:10px;">
 <div class="title" style="font-size:14px;">Grid Overlay</div>
 <label class="stack" style="gap:4px;">
 <span class="sub">Grid Density <span id="oceanGridDensityValue"></span></span>
 <input type="range" id="oceanGridDensity" min="32" max="256" step="32">
 </label>
 <label class="stack" style="gap:4px;">
 <span class="sub">Grid Opacity <span id="oceanGridOpacityValue"></span></span>
 <input type="range" id="oceanGridOpacity" min="0" max="1" step="0.01">
 </label>
 </div>
 </div>
</div>

<div class="panel stack" id="right" style="display:none"></div>

<div class="panel" id="footer">
 <span class="chip" id="statusChip">Booting </span>
 <span class="chip">Chunked</span>
 <span class="chip">Deps</span>
 <span class="chip" id="physChip">Physics: OFF</span>
 <span class="chip">Fn-Tags</span>
 <span class="chip" id="countChip">Counts: </span>
</div>

<!-- Screen-space D-Pad (bottom-right) -->
 <div id="dpad" aria-label="D-Pad">
 <div class="dp grab" title="Drag">?</div>
 <div class="dp up" data-dir="up">?</div>
 <div class="dp depthUp desktop-only" data-dir="depthUp">?</div>
 <div class="dp jump mobile-only" data-action="jump" style="display:none" title="Jump">?</div>
 <div class="dp left" data-dir="left">?</div>
 <div class="dp center desktop-only" title="Arrow mapping"><span style="display:inline-block;width:16px;height:12px;border:2px solid #fff;border-radius:3px"></span>&nbsp;<span id="depthMode">H</span></div>
 <div class="dp center mobile-only" style="display:none;cursor:default;pointer-events:none;opacity:0.3">?</div>
 <div class="dp depthDown desktop-only" data-dir="depthDown">?</div>
 <div class="dp present" role="button" data-action="present" aria-pressed="false" title="Enter Present Mode">?</div>
 <div class="dp down" data-dir="down">?</div>
 <div class="dp right" data-dir="right">?</div>
 </div>

<!-- 2D Sheet with merged Fx UI -->
<div id="sheetHeaderCard"></div>
<div id="sheet" class="intro-centered" aria-label="2D Sheet">
 <div class="sheet-head">
 <div class="sheet-title-row" style="display:flex;align-items:center;justify-content:space-between;">
 <div style="display:flex;align-items:center;gap:8px;">
 <button class="layer-btn" id="prevArray" style="display:none">?</button>
 <div class="sheet-title" id="sheetTitle" style="font-family:Inter, system-ui; font-weight:600;"></div>
 <button class="layer-btn" id="nextArray" style="display:none">?</button>
 </div>
 <div class="sheet-ctrls" style="display:flex;gap:6px;align-items:center;">
 <button class="btn" id="copyAddress" title="Copy Address" aria-label="Copy Address">@</button>
 <button class="btn" id="toggleAddressMode" title="Toggle Local/Absolute">A1a</button>
 <div id="color-picker-wrapper" title="Fill Color" style="display:flex; flex-direction:column; width:120px; gap:6px;">
 <input type="color" id="fillColorPicker" value="#ffffff" style="width:36px; height:36px; border-radius:8px; cursor:pointer; border:none; padding:0; background:transparent" />
 <div id="fillColorPreview" style="width:100%; height:12px; border:1px solid var(--line); border-radius:6px; pointer-events:none;"></div>
 <div style="display:flex; gap:6px; align-items:center;">
 <label class="kbd" style="display:flex; align-items:center; gap:6px;">
 <input type="checkbox" id="fillColorLive" checked /> Live
 </label>
 <button class="btn" id="fillColorApply" title="Apply color to selection">Apply</button>
 <button class="btn" id="fillColorClear" title="Clear cell color">Clear</button>
 </div>
 </div>
 <button class="btn" id="viewToggleBtn" title="Toggle 3D View Mode" style="width: 36px; height: 36px; padding: 6px;">
 <svg id="viewToggleIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
 <path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"></path>
 <circle cx="12" cy="12" r="3"></circle>
 </svg>
 </button>
 <button class="btn" id="toggleFxPanel" title="Functions" aria-label="Toggle formula panel" aria-pressed="false">Fx</button>
 </div>
 </div>
 <!-- Formula row placed beneath label/buttons -->
 <div class="sheet-fx" style="display:flex; gap:6px; align-items:center; margin-top:6px;">
 <div class="fx-wrap" style="flex:1;">
 <div id="fxHighlight" aria-hidden="true"></div>
 <input type="text" id="fx" placeholder='=ARRAY("Hello","World")'>
 </div>
 <button class="btn primary" id="applyFx" title="Apply">?</button>
 </div>
 <div id="minDot" title="Minimize"></div>
 </div>
 <div class="sheet-body" style="position:relative; display:flex; align-items:stretch">
 <div class="grid-wrap" style="flex:1; overflow:auto">
 <table class="sheet">
 <thead><tr id="cols"><th></th></tr></thead>
 <tbody id="rows"></tbody>
 </table>
</div>
 </div>
 <div class="sheet-resizer" id="sheetResizer" title="Resize"></div>
<div id="fxPanel" class="fx-panel">
 <div class="fx-head">
 <div class="title">Functions</div>
 <button class="btn" id="fxClose">Close</button>
 </div>
 <div class="fx-body" id="fxBody"></div>
</div>
</div>
<input id="directEdit" />

<div id="toast"></div>
<input type="file" id="fileImporter" style="display:none;" accept=".csv,.tsv,.txt,.xlsx,.xls" />
<div id="pasteModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.5); z-index:10005; align-items:center; justify-content:center;">
 <div style="background:white; padding:20px; border-radius:12px; width:90vw; max-width:600px; display:flex; flex-direction:column; gap:12px;">
 <h3 style="margin:0;">Paste Spreadsheet Data</h3>
 <p style="margin:0; font-size:14px; color:#555;">Paste data from Excel, Google Sheets, or CSV/TSV.</p>
 <textarea id="pasteDataInput" style="width:100%; height:200px; font-family:monospace; border:1px solid #ccc; border-radius:8px; padding:8px;"></textarea>
 <div>
 <button class="btn primary" id="processPasteBtn">Import</button>
 <button class="btn" id="cancelPasteBtn">Cancel</button>
 </div>
 </div>
 </div>

<!-- Narrative icons and windows -->
<div id="terminal-icon" class="ui-icon" title="Open Celli_Log.txt">
 <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-gray-300"><polyline points="4 17 10 11 4 5"></polyline><line x1="12" y1="19" x2="20" y2="19"></line></svg>
</div>
<div id="notepad-icon" class="ui-icon" title="ty.txt">
 <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-gray-300"><path d="M8 2v4"></path><path d="M12 2v4"></path><path d="M16 2v4"></path><rect x="4" y="4" width="16" height="18" rx="2"></rect><path d="M12 12h.01"></path><path d="M16 16h.01"></path><path d="M8 12h.01"></path><path d="M8 16h.01"></path></svg>
</div>
<div id="terminal">
 <div class="win-header"><span>Terminal</span><div id="term-close" class="close" title="Close"></div></div>
 <pre id="term"></pre>
</div>
<div id="pad" style="background:#fafafc; color:#1f2937; border:1px solid #e5e7eb;">
 <div class="win-header" style="background:#f2f4f8; color:#111827"><span>ty.txt Notepad</span><div id="pad-close" class="close" title="Close"></div></div>
 <textarea id="note" style="background:#ffffff; color:#111827">special thanks:
- Stephen Lavelle (Increpare)
- Arvi Teikari (Hempuli)
- Jonathan Blow
- Hideo Kojima
- Alan Moore

Synthesize what you love, make what you can.

"I don't love all of you, but I would if I could." increpare, 'Stephen's Sausage Roll'</textarea>
 <div class="pad-resizer" aria-hidden="true"></div>
</div>
<div id="crash" style="display:none; position:fixed; inset:0; background:#0b1220; color:#eaeefb; padding:24px; white-space:pre-wrap; z-index:1000; overflow:auto"></div>

<!-- Settings gear and panel removed -->

<!-- Direct CDN ESM imports (no shims/importmap) to avoid sourcemap noise under file:// -->

<script>
 // Error handler for import failures
 window.addEventListener('error', function(e) {
 console.error('Script error:', e.error || e.message);
 const statusEl = document.getElementById('statusChip');
 if (statusEl) statusEl.textContent = 'Import Error: ' + (e.error?.message || e.message);
 });
</script>
<script type="module">
// Guard against duplicate boot/RAF chains
if (window.__CELL_REWORK_BOOTED__) {
 console.warn('Duplicate boot blocked');
 throw new Error('Duplicate boot');
}
window.__CELL_REWORK_BOOTED__ = true;
// Debug: global render-order controls (defaults)
// Shells behind fills by default; array frame behind all
window.__RO = window.__RO || { ghostFill:350, solidFill:360, solidShell:340, ghostShell:300, frameCore:295, frameShell:300 };
/* ===========================
 Imports
=========================== */
// Try multiple import strategies to bypass caching issues
let THREE, OrbitControls, RoundedBoxGeometry, BufferGeometryUtils;
let EffectComposer, RenderPass, UnrealBloomPass, BokehPass, ShaderPass, FXAAShader, OutlinePass, AfterimagePass, OutputPass;
let RGBELoader, Reflector;

try {
 // Strategy 1: Use CDN with proper module paths
 const baseUrl = 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
 const examplesBase = 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm';
 const [threeModule, controlsModule, geometryModule, utilsModule,
 effectComposerModule, renderPassModule, bloomPassModule, bokehPassModule,
 shaderPassModule, fxaaModule, outlineModule, afterimageModule, outputModule,
 rgbeModule, reflectorModule
 ] = await Promise.all([
 import(baseUrl),
 import(`${examplesBase}/controls/OrbitControls.js`),
 import(`${examplesBase}/geometries/RoundedBoxGeometry.js`),
 import(`${examplesBase}/utils/BufferGeometryUtils.js`),
 import(`${examplesBase}/postprocessing/EffectComposer.js`),
 import(`${examplesBase}/postprocessing/RenderPass.js`),
 import(`${examplesBase}/postprocessing/UnrealBloomPass.js`),
 import(`${examplesBase}/postprocessing/BokehPass.js`),
 import(`${examplesBase}/postprocessing/ShaderPass.js`),
 import(`${examplesBase}/shaders/FXAAShader.js`),
 import(`${examplesBase}/postprocessing/OutlinePass.js`),
 import(`${examplesBase}/postprocessing/AfterimagePass.js`),
 import(`${examplesBase}/postprocessing/OutputPass.js`),
 import(`${examplesBase}/loaders/RGBELoader.js`),
 import(`${examplesBase}/objects/Reflector.js`)
 ]);

 THREE = threeModule.default || threeModule;
 OrbitControls = controlsModule.OrbitControls || controlsModule.default;
 RoundedBoxGeometry = geometryModule.RoundedBoxGeometry || geometryModule.default;
 BufferGeometryUtils = utilsModule.default || utilsModule;
 EffectComposer = effectComposerModule.EffectComposer || effectComposerModule.default;
 RenderPass = renderPassModule.RenderPass || renderPassModule.default;
 UnrealBloomPass = bloomPassModule.UnrealBloomPass || bloomPassModule.default;
 BokehPass = bokehPassModule.BokehPass || bokehPassModule.default;
 ShaderPass = shaderPassModule.ShaderPass || shaderPassModule.default;
 FXAAShader = fxaaModule.FXAAShader || fxaaModule.default;
 OutlinePass = outlineModule.OutlinePass || outlineModule.default;
 AfterimagePass = afterimageModule.AfterimagePass || afterimageModule.default;
 OutputPass = outputModule.OutputPass || outputModule.default;
 RGBELoader = rgbeModule.RGBELoader || rgbeModule.default;
 Reflector = reflectorModule.Reflector || reflectorModule.default;
 
 console.log('Three.js imports successful:', !!THREE.Scene, !!OrbitControls, !!RoundedBoxGeometry);
 document.getElementById('statusChip').textContent = 'Modules loaded successfully';
} catch(e) {
 console.error('Import failed:', e);
 document.getElementById('statusChip').textContent = 'Import failed: ' + e.message;
 throw e;
}
// Fancy mode removed; keep only core Three.js imports
// Removed heavy AO/Vignette to keep the look clean and modern
// Dynamic Rapier loader (optional)
let RAPIER = null; let RAP_READY = false;
let rapierLoadPromise = null;
let rapierInitPromise = null;
// Global intro flag to guarantee onboarding runs exactly once across handlers
window.__INTRO_FIRED = window.__INTRO_FIRED || false;

// Initialize Twemoji for consistent emoji rendering
if(typeof twemoji !== 'undefined'){
 twemoji.parse(document.body, {
 folder: 'svg',
 ext: '.svg',
 className: 'emoji'
 });
}
const playClickSound = (()=>{
 try{
 const audio = new Audio('https://threejs.org/examples/sounds/ping_pong.mp3');
 audio.preload = 'auto';
 audio.volume = 0.55;
 return ()=>{ try{ audio.currentTime = 0; audio.play(); }catch{} };
 }catch{
 return ()=>{};
 }
})();
let lastCellClickSound = 0;
function playCellClick(){
 const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
 if(now - lastCellClickSound < 260) return;
 lastCellClickSound = now;
 playClickSound();
}

function formulaHasChime(formula){
 if(!formula) return false;
 try{
 return /\bCHIME\s*\(/i.test(String(formula));
 }catch{
 return false;
 }
}

function warmChimeIfNeeded(formula){
 if(!formulaHasChime(formula)) return;
 try{
 if(typeof ChimeSystem !== 'undefined' && ChimeSystem && typeof ChimeSystem.ensureContext === 'function'){
 ChimeSystem.ensureContext();
 return;
 }
 }catch(e){ console.warn('Chime warm-up failed', e); }
 try{
 if(typeof window !== 'undefined' && window.CelliChimes && typeof window.CelliChimes.ensureContext === 'function'){
 window.CelliChimes.ensureContext();
 }
 }catch{}
}

const ChimeSystem = (()=>{
 const NOTE_BASE = { C:-9, D:-7, E:-5, F:-4, G:-2, A:0, B:2 };
 let ctx = null;
 let master = null;

 function ensureContext(){
 if(typeof window === 'undefined') return null;
 const AudioCtx = window.AudioContext || window.webkitAudioContext;
 if(!AudioCtx) return null;
 if(!ctx){
 try{
 ctx = new AudioCtx();
 master = ctx.createGain();
 master.gain.value = 0.22;
 master.connect(ctx.destination);
 }catch{ ctx = null; master = null; return null; }
 }
 if(ctx && ctx.state === 'suspended'){
 try{ ctx.resume(); }catch{}
 }
 return ctx && master ? { ctx, master } : null;
 }

 function parseNote(raw){
 if(raw == null) return null;
 const str = String(raw).trim();
 if(!str) return null;
 const letter = str[0].toUpperCase();
 if(!NOTE_BASE.hasOwnProperty(letter)) return null;
 let accidental = '';
 const rest = str.slice(1).trim();
 if(rest.startsWith('#')) accidental = '#';
 else if(rest.startsWith('b') || rest.startsWith('B')) accidental = 'b';
 let offset = NOTE_BASE[letter];
 if(accidental === '#') offset += 1;
 if(accidental === 'b') offset -= 1;
 return { label: `${letter}${accidental}`, offset };
 }

 function toOctave(raw){
 if(raw == null || raw === '') return 4;
 const n = parseInt(raw, 10);
 return Number.isFinite(n) ? n : 4;
 }

 function toFrequency(offset, octave){
 const semitones = offset + (octave - 4) * 12;
 return 440 * Math.pow(2, semitones / 12);
 }

 function play(offset, octave, duration = 0.65){
 const ctxData = ensureContext();
 if(!ctxData) return;
 const { ctx, master: masterGain } = ctxData;
 try{
 const osc = ctx.createOscillator();
 const env = ctx.createGain();
 const now = ctx.currentTime;
 const freq = toFrequency(offset, octave);
 osc.type = 'triangle';
 osc.frequency.setValueAtTime(freq, now);
 env.gain.setValueAtTime(0, now);
 env.gain.linearRampToValueAtTime(1, now + 0.018);
 env.gain.exponentialRampToValueAtTime(0.0001, now + Math.max(0.2, duration));
 osc.connect(env);
 env.connect(masterGain);
 osc.start(now);
 osc.stop(now + Math.max(0.25, duration) + 0.12);
 }catch(e){ console.warn('Chime playback failed', e); }
 }

 return { ensureContext, parseNote, toOctave, toFrequency, play };
})();
try{ window.CelliChimes = ChimeSystem; }catch{}
// Early touch detection so initial sizing uses correct mode (coarse pointer or small screen with touch)
try{
 const coarse = (window.matchMedia && window.matchMedia('(pointer: coarse)').matches);
 const many = ((navigator.maxTouchPoints||0) > 0) || ((navigator.msMaxTouchPoints||0) > 0);
 const small = Math.min(window.innerWidth, window.innerHeight) <= 820;
 if(coarse || (many && small)) document.body.classList.add('touch');
}catch{}
async function loadRapier(){
 if(RAPIER){ return RAPIER; }
 if(rapierLoadPromise){ return rapierLoadPromise; }

 rapierLoadPromise = (async ()=>{
 // Prefer ESM builds to avoid CommonJS globals like `exports`
 const candidates = [
 'https://cdn.jsdelivr.net/npm/@dimforge/rapier3d-compat@0.12.0/+esm',
 'https://unpkg.com/@dimforge/rapier3d-compat@0.12.0/rapier.js',
 'https://cdn.skypack.dev/@dimforge/rapier3d-compat'
 ];
 for(const url of candidates){
 try{
 const mod = await import(url);
 RAPIER = mod?.default || mod;
 if(RAPIER){
 RAP_READY = true;
 return RAPIER;
 }
 }catch(e){ console.warn('Rapier load failed', url, e); }
 }
 console.warn('Rapier unavailable, continuing without physics');
 RAPIER = null;
 RAP_READY = false;
 return null;
 })();

 try{
 return await rapierLoadPromise;
 }finally{
 if(!RAPIER){
 // Allow future attempts if the load failed
 rapierLoadPromise = null;
 }
 }
}

/* ===========================
 Constants & Utils
=========================== */
const CHUNK_SIZE = 16;
const INACTIVE_GREEDY_THRESHOLD = 4096; // switch non-focused large arrays to shell + greedy
const WINDOW_CHUNK_RADIUS = 1; // detailed window radius (in chunk units) around selection
const greekChars = ['α','β','γ','δ','ε','ζ','η','θ','ι','κ','λ','μ','ν','ξ','ο','π','ρ','σ','τ','υ','φ','χ','ψ','ω'];
const greek = (i)=>greekChars[i%greekChars.length];
const A1 = (n)=>{ let s=''; let v=n+1; while(v>0){ const r=(v-1)%26; s=String.fromCharCode(65+r)+s; v=Math.floor((v-1)/26); } return s; };
const chunkOf = (x,y,z)=>({x:Math.floor(x/CHUNK_SIZE),y:Math.floor(y/CHUNK_SIZE),z:Math.floor(z/CHUNK_SIZE)});
const keyChunk = (cx,cy,cz)=>`${cx}_${cy}_${cz}`;
const aKey = ({arrId,x,y,z})=>`${arrId}:${x},${y},${z}`;
const isTouchDevice = (('ontouchstart' in window) || (navigator.maxTouchPoints>0) || (navigator.msMaxTouchPoints>0));
// Simple helpers for Map/Set <-> POJO
const toObject = (m)=> Object.fromEntries(m || new Map());
const toMap = (o)=> new Map(Object.entries(o || {}));
// Absolute refs are 1-based: @[1,1,1,ID] is the first cell. A literal 0 means "same as executing cell component".
// Missing coordinate defaults to 1.
const parseAlt = (s, anchor)=>{
 const m=/^@\[(\-?\d+)?,(\-?\d+)?,(\-?\d+)?,(-?\d+)\]$/.exec(String(s).trim());
 if(!m) return null;
 const cur = anchor || {x:0,y:0,z:0,arrId:0};
 const raw = [m[1], m[2], m[3]].map(v=> (v===undefined || v===null) ? '' : String(v));
 const toOneBased = (val, curComp)=>{
 if(val==='' ) return 1; // missing -> first cell
 const n = +val;
 if(n===0) return (curComp|0)+1; // 0 => same as executing cell (convert to 1-based)
 return n; // already 1-based or negative
 };
 const xb = toOneBased(raw[0], cur.x);
 const yb = toOneBased(raw[1], cur.y);
 const zb = toOneBased(raw[2], cur.z);
 return { x: xb-1, y: yb-1, z: zb-1, arrId: +m[4] };
};
const formatLocalAddress = (arrId, coord)=>{ const row = coord.y + 1; return `${A1(coord.x)}${row}${greek(coord.z)}`; };
const debugCoord = (label, arrId, coord) => { console.log(`${label}: 3D(${coord.x},${coord.y},${coord.z}) ? 2D(${formatLocalAddress(arrId, coord)}) ? @[${coord.x+1},${coord.y+1},${coord.z+1},${arrId}]`); };
const parseA1g = (s,defId)=>{const m=/^([A-Z]+)(\d+)([\u03b1-\u03c9])?(?:\^(-?\d+))?$/.exec(s.trim()); if(!m) return null; let x=0; for(let i=0;i<m[1].length;i++) x=x*26+(m[1].charCodeAt(i)-64); x--; const y=+m[2]-1; const G='αβγδεζηθικλμνξοπρστυφχψω'; const z=m[3]?G.indexOf(m[3]):null; const arrId=m[4]!==undefined?+m[4]:defId; return {x,y,z,arrId};};
const showToast=(t)=>{const el=document.getElementById('toast'); el.textContent=t; el.style.display='block'; setTimeout(()=>el.style.display='none',1200);};

const META_KEY_ALIASES = {
 on_click: ['onClick'],
 on_hold: ['onHold'],
 on_touch: ['onTouch'],
 on_land: ['onLand']
};
const META_KEY_CANONICAL = {};
Object.entries(META_KEY_ALIASES).forEach(([canonical, aliases])=>{
 META_KEY_CANONICAL[canonical] = canonical;
 aliases.forEach(alias=>{ META_KEY_CANONICAL[alias] = canonical; });
});
function canonicalMetaKey(key){
 return META_KEY_CANONICAL[key] || key;
}
function normalizeMetaKeys(meta){
 if(!meta) return {};
 let changed=false;
 const result={};
 Object.entries(meta).forEach(([key,value])=>{
 if(value===undefined) return;
 const canonical = canonicalMetaKey(key);
 if(canonical!==key) changed=true;
 if(result[canonical]===undefined) result[canonical]=value;
 });
 if(!changed && Object.keys(result).length===Object.keys(meta).length){
 return meta;
 }
 return result;
}
function getMetaAction(meta, canonical){
 if(!meta) return undefined;
 const canonicalKey = canonicalMetaKey(canonical);
 if(meta[canonicalKey] !== undefined) return meta[canonicalKey];
 const aliases = META_KEY_ALIASES[canonicalKey] || [];
 for(const alias of aliases){
 if(meta[alias] !== undefined){
 const val = meta[alias];
 meta[canonicalKey] = val;
 delete meta[alias];
 return val;
 }
 }
 return undefined;
}
function ensureOnSelectHooks(arr){
 if(!arr) return [];
 if(Array.isArray(arr.on_select_hooks)) return arr.on_select_hooks;
 if(Array.isArray(arr.onSelectHooks)){
 arr.on_select_hooks = arr.onSelectHooks;
 delete arr.onSelectHooks;
 return arr.on_select_hooks;
 }
 arr.on_select_hooks = [];
 return arr.on_select_hooks;
}

/* ===========================
 Tiny Store (Zustand-ish)
=========================== */
const createStore = (init)=>{
 let state; const listeners=new Set();
 const setState = (partial)=>{ const next=typeof partial==='function'?partial(state):partial; const prev=state; state={...state,...next}; listeners.forEach(l=>l(state,prev)); };
 const getState = ()=>state;
 const subscribe = (fn)=> (listeners.add(fn), ()=>listeners.delete(fn));
 state = init(setState,getState);
 return {getState,setState,subscribe};
};
const PHYSICS_DEBUG_STORAGE_KEY = 'celli.physicsDebugAll';

function parseArrayIdFromKey(key){
 if(key === undefined || key === null) return null;
 const str = typeof key === 'string' ? key : String(key);
 const idx = str.indexOf(':');
 if(idx <= 0) return null;
 const id = Number(str.slice(0, idx));
 return Number.isFinite(id) ? id : null;
}

function computeFormulaActiveArrayIds(sourceByCell, depsByAnchor, extraIds=[]){
 const active = new Set();
 try{
 if(Array.isArray(extraIds)){
 extraIds.forEach(id=>{
 const num = Number(id);
 if(Number.isFinite(num)) active.add(num);
 });
 }
 }catch{}
 try{
 if(sourceByCell && typeof sourceByCell.forEach === 'function'){
 sourceByCell.forEach((_src, cellKey)=>{
 const id = parseArrayIdFromKey(cellKey);
 if(id!=null) active.add(id);
 });
 }
 }catch{}
 try{
 if(depsByAnchor && typeof depsByAnchor.forEach === 'function'){
 depsByAnchor.forEach((_deps, anchorKey)=>{
 const id = parseArrayIdFromKey(anchorKey);
 if(id!=null) active.add(id);
 });
 }
 }catch{}
 return active;
}

function gatherFormulaActiveArrayIds(sourceByCell, depsByAnchor, extraIds=[]){
 return computeFormulaActiveArrayIds(sourceByCell, depsByAnchor, extraIds);
}

let _gatherFormulaFallbackWarned = false;
function resolveFormulaActiveArrayIds(sourceByCell, depsByAnchor, extraIds=[]){
 try{
 return gatherFormulaActiveArrayIds(sourceByCell, depsByAnchor, extraIds);
 }catch(err){
 if(!_gatherFormulaFallbackWarned){
 console.warn('gatherFormulaActiveArrayIds unavailable, using fallback computation', err);
 _gatherFormulaFallbackWarned = true;
 }
 return computeFormulaActiveArrayIds(sourceByCell, depsByAnchor, extraIds);
 }
}

function getFormulaActiveArrayIds(){
 try{
 if(typeof Store === 'undefined' || !Store?.getState) return new Set();
 const state = Store.getState();
 return resolveFormulaActiveArrayIds(state.sourceByCell, state.depsByAnchor);
 }catch{
 return new Set();
 }
}

function determineCollisionMode(arr, cell=null, opts={}){
 if(!arr) return 'edit';
 const debugMode = Object.prototype.hasOwnProperty.call(opts, 'debugMode')
 ? !!opts.debugMode
 : (typeof Store !== 'undefined' && Store?.getState) ? !!Store.getState().scene?.physicsDebugAll : false;
 
 // In debug mode, ALL arrays with physics.enabled are physics mode
 if(debugMode && arr.params?.physics?.enabled) return 'physics';
 
 // Check if array has formulas (formula-active arrays are physics mode)
 const hostedSet = opts.formulaHostedSet || getFormulaActiveArrayIds();
 if(hostedSet.has(arr.id)) return 'physics';
 if(cell && (cell.formula || (cell.meta && (cell.meta.generated || cell.meta.emitter)))){
 return 'physics';
 }
 
 // Non-formula arrays are always 'edit' mode (they get colliders but trigger exit)
 return 'edit';
}

function cameraBasisForSelection(arr){
 let major='Z', sign=1, signX=1, signY=1, signZ=1;
 if(!arr) return {major, sign, signX, signY, signZ};
 try{
 if(typeof THREE === 'undefined' || !window.Scene) return {major, sign, signX, signY, signZ};
 const frame = arr._frame || null;
 const cam = Scene?.getCamera ? Scene.getCamera() : null;
 if(frame && cam && cam.position && typeof cam.position.clone === 'function'){
 const arrPos = new THREE.Vector3().setFromMatrixPosition(frame.matrixWorld);
 const camPos = cam.position.clone();
 const toCamW = camPos.sub(arrPos).normalize();
 const inv = new THREE.Matrix4().copy(frame.matrixWorld).invert();
 const toCamL = toCamW.clone().applyMatrix3(new THREE.Matrix3().setFromMatrix4(inv)).normalize();
 const ax=Math.abs(toCamL.x), ay=Math.abs(toCamL.y), az=Math.abs(toCamL.z);
 if(ay>ax && ay>az){ major='Y'; sign=Math.sign(toCamL.y)||1; }
 else if(ax>ay && ax>az){ major='X'; sign=Math.sign(toCamL.x)||1; }
 else { major='Z'; sign=Math.sign(toCamL.z)||1; }
 signX = Math.sign(toCamL.x)||1;
 signY = Math.sign(toCamL.y)||1;
 signZ = Math.sign(toCamL.z)||1;
 }
 }catch{}
 return {major, sign, signX, signY, signZ};
}

function resolveViewRelativeStep(arr, direction, opts={}){
 const depthMode = opts.depthMode || false;
 if(!arr || !direction) return {dx:0,dy:0,dz:0};
 
 // D-pad depth buttons ALWAYS control Z axis toward/away from camera
 if(direction === 'depthUp' || direction === 'depthDown'){
 const basis = cameraBasisForSelection(arr);
 const dz = (direction === 'depthUp') 
 ? (basis.signZ > 0 ? +1 : -1) // toward camera
 : (basis.signZ > 0 ? -1 : +1); // away from camera
 return {dx:0, dy:0, dz};
 }
 
 // D-pad up/down ALWAYS control Y (height) moving upward/downward in visual space
 // In array coords: higher Y = physically higher in 3D space
 if(direction === 'up') return {dx:0, dy:+1, dz:0};
 if(direction === 'down') return {dx:0, dy:-1, dz:0};
 
 // Left/Right are view-relative
 const basis = cameraBasisForSelection(arr);
 let dx=0, dy=0, dz=0;
 
 if(depthMode){
 // Depth mode: left/right control X, but still relative to camera
 if(direction==='left') dx = (basis.signX>0 ? -1 : +1);
 if(direction==='right') dx = (basis.signX>0 ? +1 : -1);
 return {dx,dy,dz};
 }
 
 // Standard mode: left/right are screen-space left/right relative to camera
 if(basis.major==='X'){
 // Viewing along X axis (from east +X or west -X)
 // Left/right control Z axis (north/south)
 // From east (+X): left=north=+Z, right=south=-Z
 // From west (-X): left=south=-Z, right=north=+Z
 if(direction==='left') dz = (basis.sign>0 ? +1 : -1);
 if(direction==='right') dz = (basis.sign>0 ? -1 : +1);
 } else if(basis.major==='Z'){
 // Viewing along Z axis (from south +Z or north -Z)
 // Left/right control X axis (east/west)
 // From south (+Z): left=west=-X, right=east=+X
 // From north (-Z): left=east=+X, right=west=-X
 if(direction==='left') dx = (basis.sign>0 ? -1 : +1);
 if(direction==='right') dx = (basis.sign>0 ? +1 : -1);
 } else { // basis.major === 'Y' (top/bottom view)
 // Viewing from top (+Y) or bottom (-Y)
 // Left/right control X axis (east/west)
 // From top: left=west=-X, right=east=+X
 if(direction==='left') dx = -1;
 if(direction==='right') dx = +1;
 }
 return {dx,dy,dz};
}

function readPersistedPhysicsDebug(){
 try{
 return typeof localStorage !== 'undefined' && localStorage.getItem(PHYSICS_DEBUG_STORAGE_KEY) === '1';
 }catch(e){
 console.warn('Physics debug persistence read failed', e);
 return false;
 }
}
function persistPhysicsDebugFlag(enabled){
 try{
 if(typeof localStorage === 'undefined') return;
 if(enabled){
 localStorage.setItem(PHYSICS_DEBUG_STORAGE_KEY, '1');
 } else {
 localStorage.removeItem(PHYSICS_DEBUG_STORAGE_KEY);
 }
 }catch(e){
 console.warn('Physics debug persistence write failed', e);
 }
}

const Store = createStore((set,get)=>{
 console.log('[STORE INIT] Creating store with physics:false by default');
 return {
 arrays: {}, nextArrayId:1, lastCreatedArrayId:null,
 selection:{arrayId:null, focus:null, anchor:null, range:null, faceHint:null},
 scene:{physics:false, showGrid:true, showAxes:true, physicsDebugAll:false, ocean:{enabled:false}},
 ui:{zLayer:0, fxOpen:false, addressMode:'local', lastInteraction:'3d', viewMode:'standard', crystal2D:false},
 gridPhase:{x:null,y:null,z:null},
 namedBlocks:new Map(), // name -> {x,y,z, data: [layers[z][y][x]] }
 hidden:new Set(), // aKey(cell) -> hidden (per-cell visual mask)
 namedMacros:new Map(), // name -> formula
 // Deferred/meta binding queue for robust late resolution
 pendingMeta: [], // {kind:'on_click'|'note', target:{arrId,x,y,z}, meta:{...}}
 // Global state and event system
 globalState: new Map(), // key -> value
 eventListeners: new Map(), // eventName -> [listenerObjects]
 anchorsByGlobalKey: new Map(), // globalKey -> Set<anchorKey>
 globalKeysByAnchor: new Map(), // anchorKey -> Set<globalKey>
 // Emission tracking for generated values (e.g., ARRAY)
 emittedByAnchor: new Map(), // anchorKey -> Set<cellKey>
 sourceByCell: new Map(), // cellKey -> anchorKey
 // Projectile and collision system
 activeProjectiles: [], // Each item: {id, pos, vel, sourceArrId, payload}
 collisionHandlers: new Map(), // cellKey -> formulaString
 nextProjectileId: 0,
 // Interactions
 interactions:{ gobblingEnabled:false },
 // Game state system
 gameState: { goals: new Map(), winCallbacks: [], hasWon: false },
 // Embedding system
 embeddedMeshes: new Map(), // anchorKey -> { mesh, sourceArrId }
 worldState: { mode: 'normal', parentArr: null, childArr: null },
 // Docking system
 dockGroups: new Map(), // groupId -> {mode:'parent'|'all', members:number[], parentId:number}
 dockGroupsByAnchor: new Map(), // anchorKey -> groupId
 // Avatar + physics camera preferences
 avatarPhysics:{ enabled:true, jumpCount:1, runMultiplier:1, momentumMode:0 },
 physicsCamera:{ mode:'free', distance:10, allowRotation:false },
 // Track active 3D_ROTATE applications and suppressions for revert logic
 activeRotations: new Map(), // anchorKey -> {targetId, ids:number[], pivot:{arrId,x,y,z}, steps:{sx,sy,sz}}
 suppress3DRotateRevert: new Set(), // Set<anchorKey>
 // Persisted reverts after refresh
 // (3D translate persisted meta is read at revert time; no store change needed here)
 // Track active 3D_TRANSLATE applications and suppressions for revert logic
 activeTranslations: new Map(), // anchorKey -> {targetId, from:{x,y,z}, delta:{dx,dy,dz}}
 suppress3DTranslateRevert: new Set(), // Set<anchorKey>
 // Track active SCALE applications so manual clears/changes can restore defaults
 activeScales: new Map(), // anchorKey -> {targets:[{id, prevLevel, prevUnits}]}
 // Signal system
 bufferedWrites: [], // { tick, anchor, value, formula }
 currentTick: 0,
 // dependency graph
 depsByAnchor:new Map(), anchorsByDep:new Map(),
 // helpers
 utils:{
 A1, greek,
 key:(arrId,x,y,z)=>`${arrId}:${x},${y},${z}`,
 },
 actions:{
 saveState: ()=>{
 try{
 const s = get();
 console.log('Saving state with', Object.keys(s.arrays).length, 'arrays...');

 const sanitizeTimedParams=(timed)=>{
 if(!timed) return undefined;
 const clone={
 ticks: Number.isFinite(+timed.ticks) ? (+timed.ticks|0) : 60,
 repeat: !!timed.repeat,
 reverse: !!timed.reverse,
 reverseTicks: (timed.reverseTicks==null) ? null : ((+timed.reverseTicks|0) || (+timed.ticks|0) || 60),
 t: 0,
 dir: (timed.dir===-1)?-1:1,
 previewInArray: !!timed.previewInArray,
 smooth: !!timed.smooth
 };
 if(Array.isArray(timed.plan)){
 clone.plan = timed.plan.map(op=>{
 const out={...op};
 if(op.anchor){ out.anchor = { ...op.anchor }; }
 return out;
 });
 } else {
 clone.plan = [];
 }
 if(timed.baseOffset){
 clone.baseOffset = {
 x: Number.isFinite(+timed.baseOffset.x) ? +timed.baseOffset.x : 0,
 y: Number.isFinite(+timed.baseOffset.y) ? +timed.baseOffset.y : 0,
 z: Number.isFinite(+timed.baseOffset.z) ? +timed.baseOffset.z : 0
 };
 }
 if(timed.baseQuat){
 try{
 if(Array.isArray(timed.baseQuat)) clone.baseQuat = timed.baseQuat.slice(0,4);
 else if(typeof timed.baseQuat.toArray==='function') clone.baseQuat = timed.baseQuat.toArray();
 else if(timed.baseQuat && typeof timed.baseQuat.x==='number') clone.baseQuat = [timed.baseQuat.x, timed.baseQuat.y, timed.baseQuat.z, timed.baseQuat.w];
 }catch{}
 }
 if(typeof timed.waitStart==='number') clone.waitStart = timed.waitStart|0;
 if(typeof timed.waitEnd==='number') clone.waitEnd = timed.waitEnd|0;
 return clone;
 };
 const cloneParamValue=(val)=>{
 if(val===undefined) return undefined;
 if(val===null) return null;
 if(typeof val==='function') return undefined;
 if(typeof val!=='object') return val;
 try{ return JSON.parse(JSON.stringify(val)); }
 catch{ return undefined; }
 };
 const sanitizeTimed3D=(timed)=>{
 if(!timed) return null;
 const scope = timed.scope ? {
 mode: timed.scope.mode || 'all',
 ids: Array.isArray(timed.scope.ids) ? timed.scope.ids.map(n=> Number.isFinite(+n)?(+n|0):null).filter(n=>n!=null) : []
 } : null;
 return {
 configured: !!timed.configured,
 ticks: Number.isFinite(+timed.ticks) ? (+timed.ticks|0) : 60,
 repeat: !!timed.repeat,
 reverse: !!timed.reverse,
 reverseTicks: (timed.reverseTicks==null) ? null : ((+timed.reverseTicks|0) || ((+timed.ticks|0)||60)),
 smooth: !!timed.smooth,
 preview: !!timed.preview,
 waitStart: Number.isFinite(+timed.waitStart) ? (+timed.waitStart|0) : 0,
 waitEnd: Number.isFinite(+timed.waitEnd) ? (+timed.waitEnd|0) : 0,
 hostId: Number.isFinite(+timed.hostId) ? (+timed.hostId|0) : null,
 scope,
 activeHostIds: Array.isArray(timed.activeHostIds) ? timed.activeHostIds.map(n=> Number.isFinite(+n)?(+n|0):null).filter(n=>n!=null) : [],
 t: 0,
 dir: (timed.dir===-1)?-1:1
 };
 };

 // Enhanced state preservation - keep ALL meaningful data
 const hostedByFormula = resolveFormulaActiveArrayIds(s.sourceByCell, s.depsByAnchor);
 const debugMode = !!s.scene?.physicsDebugAll;
 const arrays = {};
 Object.values(s.arrays).forEach(a=>{
 const outA = {
 id:a.id, name:a.name, size:a.size, hidden:a.hidden, sealed:a.sealed, offset:a.offset,
 collisionMode: determineCollisionMode(a, null, { debugMode, formulaHostedSet: hostedByFormula }),
 fnPolicy: a.fnPolicy ? {
 mode: a.fnPolicy.mode,
 allow: Array.from(a.fnPolicy.allow || []),
 deny: Array.from(a.fnPolicy.deny || []),
 tags: Array.from(a.fnPolicy.tags || [])
 } : undefined,
 params: (()=>{
 if(!a.params) return undefined;
 const paramsOut={};
 Object.entries(a.params).forEach(([key,val])=>{
 if(key==='timed'){
 const clean = sanitizeTimedParams(val);
 if(clean) paramsOut.timed = clean;
 } else {
 const cloned = cloneParamValue(val);
 if(cloned!==undefined) paramsOut[key]=cloned;
 }
 });
 return Object.keys(paramsOut).length ? paramsOut : undefined;
 })(),
 locks: Array.from(a.locks || []),
 chunks:{} 
 };
 // Transform and per-array knobs
 try{
 const quat = (a._frame?.quaternion?.toArray?.()) || a.rotationQuat || [0,0,0,1];
 outA.transform = {
 offset: a.offset || {x:0,y:0,z:0},
 rotationQuat: quat,
 rotationSteps: a.rotationSteps || {x:0,y:0,z:0}
 };
 }catch{}
 if(a.axesVisible !== undefined) outA.axesVisible = !!a.axesVisible;
 const selectHooks = ensureOnSelectHooks(a);
 if(selectHooks.length) outA.on_select_hooks = selectHooks;
 if(a.uiControls) outA.uiControls = a.uiControls;
 if(a.cameraLock) outA.cameraLock = a.cameraLock;
 if(a.viewMode) outA.viewMode = a.viewMode;
 
 Object.entries(a.chunks).forEach(([k,ch])=>{
 const cells = [];
 for(const c of ch.cells){
 const hasVal = !(c.value===''||c.value==null||c.value===undefined);
 const hasFx = !!c.formula;
 const hasMeta = c.meta && Object.keys(c.meta).length > 0;
 
 // Save ALL cells with content, formulas, or metadata
 if(hasVal || hasFx || hasMeta){
 const normalizedMeta = c.meta ? normalizeMetaKeys(c.meta) : null;
 if(normalizedMeta && normalizedMeta !== c.meta) c.meta = normalizedMeta;
 const metaOut = normalizedMeta && Object.keys(normalizedMeta).length ? {...normalizedMeta} : undefined;
 cells.push({
 x:c.x, y:c.y, z:c.z,
 value: c.value, // preserve exact value including empty strings
 formula: c.formula, // preserve exact formula including null
 meta: metaOut
 });
 }
 }
 if(cells.length>0) outA.chunks[k] = { coord: ch.coord, cells };
 });
 arrays[a.id] = outA;
 });
 
 // Save comprehensive state including dependencies and global state
 // Filter out platformer.active from globalState to ensure it always starts false
 const globalStateEntries = Array.from(s.globalState.entries()).filter(([k]) => k !== 'platformer.active' && k !== 'platformer.pos');
 
 const serializable = {
 version: '1.1',
 timestamp: Date.now(),
 arrays,
 nextArrayId: s.nextArrayId,
 globalState: Object.fromEntries(globalStateEntries),
 selection: s.selection,
 ui: s.ui,
 scene: {
 physics: false, // Never save physics as enabled
 showGrid: s.scene.showGrid,
 showAxes: s.scene.showAxes,
 arrowMapDepth: s.scene.arrowMapDepth,
 timed3D: sanitizeTimed3D(s.scene?.timed3D)
 },
 avatarPhysics: s.avatarPhysics,
 physicsCamera: s.physicsCamera,
 camera: (Scene && Scene.captureCamera) ? Scene.captureCamera() : undefined,
 gridPhase: s.gridPhase,
 docks: {
 groups: Object.fromEntries([...(s.dockGroups||new Map()).entries()].map(([id,g])=> [id, {mode:g.mode, members:[...g.members], parentId:g.parentId??null}] )),
 byAnchor: Object.fromEntries((s.dockGroupsByAnchor||new Map()).entries())
 },
 chunking: { enabled: !!(Scene.ChunkManager && Scene.ChunkManager.enabled) },
 interactions: s.interactions,
 namedBlocks: Object.fromEntries(s.namedBlocks.entries()),
 namedMacros: Object.fromEntries(s.namedMacros.entries())
 };
 
 const data = JSON.stringify(serializable);
 console.log('Serialized state size:', Math.round(data.length/1024), 'KB');
 
 try{
 localStorage.setItem('celliOsState', data);
 showToast(`?? State Saved (${Math.round(data.length/1024)}KB)`);
 }catch(e){
 if(e.name === 'QuotaExceededError'){
 // Try compressing by removing some metadata
 const compressed = { 
 arrays: Object.fromEntries(Object.entries(arrays).map(([id, a]) => [id, {
 ...a,
 chunks: Object.fromEntries(Object.entries(a.chunks).map(([k, ch]) => [k, {
 ...ch,
 cells: ch.cells.map(c => {
 const metaNorm = c.meta ? normalizeMetaKeys(c.meta) : null;
 if(metaNorm && metaNorm !== c.meta) c.meta = metaNorm;
 const compressedMeta = metaNorm ? {
 ...(metaNorm.on_click ? {on_click: metaNorm.on_click} : {}),
 ...(metaNorm.noteText ? {noteText: metaNorm.noteText} : {}),
 ...(metaNorm.color ? {color: metaNorm.color} : {})
 } : undefined;
 return {
 x: c.x, y: c.y, z: c.z,
 value: c.value,
 formula: c.formula,
 meta: compressedMeta
 };
 })
 }]))
 }]))
 };
 const compressedData = JSON.stringify(compressed);
 localStorage.setItem('celliOsState', compressedData);
 showToast(`?? State Saved (Compressed: ${Math.round(compressedData.length/1024)}KB)`);
 } else {
 throw e;
 }
 }
 }catch(e){ 
 console.error('saveState failed', e); 
 showToast('? Save failed: ' + e.message); 
 }
 },
 loadState: ()=>{
 try{
 const json = localStorage.getItem('celliOsState'); 
 if(!json){ showToast('?? No saved state found'); return; }
 
 const data = JSON.parse(json);
 const rehydrateTimedParams=(timed)=>{
 if(!timed) return undefined;
 const out={
 ticks: Number.isFinite(+timed.ticks) ? (+timed.ticks|0) : 60,
 repeat: !!timed.repeat,
 reverse: !!timed.reverse,
 reverseTicks: (timed.reverseTicks==null) ? null : ((+timed.reverseTicks|0) || ((+timed.ticks|0)||60)),
 t: Number.isFinite(+timed.t) ? (+timed.t|0) : 0,
 dir: (timed.dir===-1)?-1:1,
 previewInArray: !!timed.previewInArray,
 smooth: !!timed.smooth,
 plan: Array.isArray(timed.plan) ? timed.plan.map(op=>{
 const copy={...op};
 if(op.anchor) copy.anchor={...op.anchor};
 return copy;
 }) : []
 };
 if(timed.baseOffset){
 out.baseOffset={
 x: Number.isFinite(+timed.baseOffset.x) ? +timed.baseOffset.x : 0,
 y: Number.isFinite(+timed.baseOffset.y) ? +timed.baseOffset.y : 0,
 z: Number.isFinite(+timed.baseOffset.z) ? +timed.baseOffset.z : 0
 };
 }
 if(timed.baseQuat){
 try{
 const arrQuat = Array.isArray(timed.baseQuat) ? timed.baseQuat : [timed.baseQuat.x, timed.baseQuat.y, timed.baseQuat.z, timed.baseQuat.w];
 if(Array.isArray(arrQuat) && arrQuat.length===4){
 const quat=new THREE.Quaternion();
 quat.fromArray(arrQuat);
 out.baseQuat=quat;
 }
 }catch{ out.baseQuat=null; }
 }
 if(typeof timed.waitStart==='number') out.waitStart = timed.waitStart|0;
 if(typeof timed.waitEnd==='number') out.waitEnd = timed.waitEnd|0;
 return out;
 };
 const rehydrateParams=(params)=>{
 if(!params) return {};
 const out={};
 Object.entries(params).forEach(([key,val])=>{
 if(key==='timed'){
 const t = rehydrateTimedParams(val);
 if(t) out.timed = t;
 } else {
 out[key] = val;
 }
 });
 return out;
 };
 const rehydrateTimed3D=(timed)=>{
 if(!timed) return null;
 const scope = timed.scope ? {
 mode: timed.scope.mode || 'all',
 ids: Array.isArray(timed.scope.ids) ? timed.scope.ids.map(n=> Number.isFinite(+n)?(+n|0):null).filter(n=>n!=null) : []
 } : null;
 return {
 configured: !!timed.configured,
 ticks: Number.isFinite(+timed.ticks) ? (+timed.ticks|0) : 60,
 repeat: !!timed.repeat,
 reverse: !!timed.reverse,
 reverseTicks: (timed.reverseTicks==null) ? null : ((+timed.reverseTicks|0) || ((+timed.ticks|0)||60)),
 smooth: !!timed.smooth,
 preview: !!timed.preview,
 waitStart: Number.isFinite(+timed.waitStart) ? (+timed.waitStart|0) : 0,
 waitEnd: Number.isFinite(+timed.waitEnd) ? (+timed.waitEnd|0) : 0,
 hostId: Number.isFinite(+timed.hostId) ? (+timed.hostId|0) : null,
 scope,
 t: Number.isFinite(+timed.t) ? (+timed.t|0) : 0,
 dir: (timed.dir===-1)?-1:1,
 _waitCounter: 0,
 activeHostIds: Array.isArray(timed.activeHostIds) ? timed.activeHostIds.map(n=> Number.isFinite(+n)?(+n|0):null).filter(n=>n!=null) : []
 };
 };
 const restoreTimedPreviewState=()=>{
 try{
 const S=Store.getState();
 const arrays=Object.values(S.arrays||{});
 const globalPreviewActive = !!(S.scene?.timed3D?.preview);
 const ensurePlan=(arr)=>{ try{ Scene.buildTimedPlanFromArray?.(arr); }catch{} };
 arrays.forEach(arr=>{
 if(!arr) return;
 const timed=arr.params?.timed;
 if(!timed) return;
 timed.t = 0;
 timed.dir = 1;
 const shouldResetBase = !!timed.previewInArray || globalPreviewActive;
 if(shouldResetBase){
 if(timed.baseOffset){
 setArrayOffset(arr, {x:timed.baseOffset.x,y:timed.baseOffset.y,z:timed.baseOffset.z}, {interactive:true});
 } else {
 timed.baseOffset = { ...(arr.offset||{x:0,y:0,z:0}) };
 }
 }
 if(timed.baseQuat && !(timed.baseQuat instanceof THREE.Quaternion)){
 try{
 const qArr = Array.isArray(timed.baseQuat) ? timed.baseQuat : [timed.baseQuat.x, timed.baseQuat.y, timed.baseQuat.z, timed.baseQuat.w];
 if(Array.isArray(qArr) && qArr.length===4){ const q=new THREE.Quaternion(); q.fromArray(qArr); timed.baseQuat=q; }
 }catch{}
 }
 if(timed.previewInArray){
 ensurePlan(arr);
 if(!timed.overlay){
 try{
 timed.overlay = { group:new THREE.Group(), cells:new Map() };
 if(arr._frame) arr._frame.add(timed.overlay.group); else Scene.addToScene?.(timed.overlay.group);
 }catch{ timed.overlay=null; }
 }
 try{ Scene.maskArrayForPreview?.(arr, true); }catch{}
 } else {
 if(globalPreviewActive){ ensurePlan(arr); }
 try{ Scene.maskArrayForPreview?.(arr, false); }catch{}
 }
 });
 const savedTimed = S.scene?.timed3D;
 if(savedTimed){
 try{
 const G = Scene.ensureTimed3D ? Scene.ensureTimed3D() : null;
 if(G){
 G.configured = !!savedTimed.configured;
 G.ticks = Number.isFinite(+savedTimed.ticks) ? (+savedTimed.ticks|0) : 60;
 G.repeat = !!savedTimed.repeat;
 G.reverse = !!savedTimed.reverse;
 G.reverseTicks = (savedTimed.reverseTicks==null) ? null : ((+savedTimed.reverseTicks|0) || ((+savedTimed.ticks|0)||60));
 G.smooth = !!savedTimed.smooth;
 G.preview = !!savedTimed.preview;
 G.waitStart = Number.isFinite(+savedTimed.waitStart) ? (+savedTimed.waitStart|0) : 0;
 G.waitEnd = Number.isFinite(+savedTimed.waitEnd) ? (+savedTimed.waitEnd|0) : 0;
 G._waitCounter = 0;
 G.t = Number.isFinite(+savedTimed.t) ? (+savedTimed.t|0) : 0;
 G.dir = (savedTimed.dir===-1)?-1:1;
 G.hostId = Number.isFinite(+savedTimed.hostId) ? (+savedTimed.hostId|0) : null;
 if(savedTimed.scope){
 G.scope = {
 mode: savedTimed.scope.mode || 'all',
 ids: Array.isArray(savedTimed.scope.ids) ? savedTimed.scope.ids.map(n=> Number.isFinite(+n)?(+n|0):null).filter(n=>n!=null) : []
 };
 } else {
 G.scope = null;
 }
 }
 }catch(e){ console.warn('Timed3D restore failed', e); }
 }
 }catch(e){ console.warn('restoreTimedPreviewState error', e); }
 };
 try{ Scene.restoreTimedPreviewState = restoreTimedPreviewState; }catch{}
 console.log('Loading state version:', data.version, 'from:', new Date(data.timestamp));
 
 // Clear existing scene visuals
 Object.values(get().arrays).forEach(arr=>{ try{ Scene.removeArrayGraphics(arr); }catch{} });
 
 // Restore grid phase early for snapping
 if(data.gridPhase){
 try{ Store.setState({ gridPhase: { x:+data.gridPhase.x||0, y:+data.gridPhase.y||0, z:+data.gridPhase.z||0 } }); }catch{}
 }
 // Restore dock groups
 try{
 const docks = data.docks || {};
 Store.setState({
 dockGroups: toMap(docks.groups || {}),
 dockGroupsByAnchor: toMap(docks.byAnchor || {})
 });
 }catch{}
 // Restore ChunkManager flag
 try{ if(data.chunking && data.chunking.enabled===true && Scene.ChunkManager) Scene.ChunkManager.enabled = true; }catch{}
 // Restore camera later via Scene.restoreCamera
 const cameraSnapshot = data.camera;

 const arrays={};
 Object.values(data.arrays||{}).forEach(a=>{
 arrays[a.id] = {
 id:a.id, name:a.name, size:{...a.size}, hidden:a.hidden, sealed:a.sealed, offset:{...a.offset},
 state:'ACTIVE', stableCount:0, lastHash:null, lastDepSig:null,
 collisionMode: a.collisionMode === 'physics' ? 'physics' : 'edit',
 fnPolicy: a.fnPolicy ? {
 mode: a.fnPolicy.mode || 'ALLOW_ALL',
 allow: new Set(a.fnPolicy.allow || []),
 deny: new Set(a.fnPolicy.deny || []),
 tags: new Set(a.fnPolicy.tags || [])
 } : {mode:'ALLOW_ALL', allow:new Set(), deny:new Set(), tags:new Set()},
 params: rehydrateParams(a.params),
 locks: new Set(a.locks || []),
 chunks:{}, labels:[], _frame:null, _colliders:[], _occluders:null
 };
 // Hydrate added fields (back-compat: prefer transform)
 const T = a.transform || {};
 arrays[a.id].offset = T.offset || a.offset || {x:0,y:0,z:0};
 arrays[a.id].rotationQuat = T.rotationQuat || a.rotationQuat || [0,0,0,1];
 arrays[a.id].rotationSteps = T.rotationSteps || a.rotationSteps || {x:0,y:0,z:0};
 if(a.axesVisible !== undefined) arrays[a.id].axesVisible = !!a.axesVisible;
 const loadedHooks = a.on_select_hooks || a.onSelectHooks;
 if(loadedHooks) arrays[a.id].on_select_hooks = loadedHooks;
 if(a.uiControls) arrays[a.id].uiControls = a.uiControls;
 if(a.cameraLock) arrays[a.id].cameraLock = a.cameraLock;
 if(a.viewMode) arrays[a.id].viewMode = a.viewMode;
 // Reserved arrays default hidden if not explicitly saved as visible
 if((a.id===-1) && arrays[a.id].hidden !== true){ arrays[a.id].hidden = true; }
 
 const savedMode = (a.collisionMode === 'physics') ? 'physics' : (a.collisionMode === 'edit' ? 'edit' : null);
 if(savedMode){
 arrays[a.id].collisionMode = savedMode;
 }
 if(arrays[a.id].collisionMode !== 'physics' && arrays[a.id].params?.physics?.enabled){
 arrays[a.id].collisionMode = 'physics';
 }

 let hasFormulaCell = false;
 Object.entries(a.chunks||{}).forEach(([k,ch])=>{
 const C = new Scene.Chunk(arrays[a.id], ch.coord);
 C.cells = (ch.cells||[]).map(c=>{
 const meta = normalizeMetaKeys(c.meta||{});
 if(c.formula) hasFormulaCell = true;
 return {
 x:c.x, y:c.y, z:c.z,
 value:c.value,
 formula:c.formula,
 meta
 };
 });
 // Rebuild cellMap for O(1) access
 C.cellMap = new Map();
 C.cells.forEach(cell => C.cellMap.set(`${cell.x},${cell.y},${cell.z}`, cell));
 arrays[a.id].chunks[k] = C;
 // Backfill missing empties within existing chunk bounds
 try{
 const arrRef = arrays[a.id];
 const minX=C.coord.x*CHUNK_SIZE, minY=C.coord.y*CHUNK_SIZE, minZ=C.coord.z*CHUNK_SIZE;
 const maxX=Math.min(minX+CHUNK_SIZE, arrRef.size.x), maxY=Math.min(minY+CHUNK_SIZE, arrRef.size.y), maxZ=Math.min(minZ+CHUNK_SIZE, arrRef.size.z);
 for(let z=minZ; z<maxZ; z++)
 for(let y=minY; y<maxY; y++)
 for(let x=minX; x<maxX; x++){
 const key=`${x},${y},${z}`;
 if(!C.cellMap.has(key)){
 const cell={x,y,z,value:'',formula:null,meta:{}};
 C.cells.push(cell);
 C.cellMap.set(key, cell);
 }
 }
 }catch{}
 });
 arrays[a.id]._hasFormulaCell = hasFormulaCell;
 // Ensure chunks exist for all regions and are populated with empties where missing
 try{
 const arrRef = arrays[a.id];
 const cDims={x:Math.ceil(arrRef.size.x/CHUNK_SIZE), y:Math.ceil(arrRef.size.y/CHUNK_SIZE), z:Math.ceil(arrRef.size.z/CHUNK_SIZE)};
 for(let cz=0; cz<cDims.z; cz++)
 for(let cy=0; cy<cDims.y; cy++)
 for(let cx=0; cx<cDims.x; cx++){
 const key = keyChunk(cx,cy,cz);
 let C = arrRef.chunks[key];
 if(!C){
 C = new Scene.Chunk(arrRef, {x:cx,y:cy,z:cz});
 arrRef.chunks[key] = C;
 C.cellMap = new Map();
 }
 const minX=cx*CHUNK_SIZE, minY=cy*CHUNK_SIZE, minZ=cz*CHUNK_SIZE;
 const maxX=Math.min(minX+CHUNK_SIZE, arrRef.size.x), maxY=Math.min(minY+CHUNK_SIZE, arrRef.size.y), maxZ=Math.min(minZ+CHUNK_SIZE, arrRef.size.z);
 for(let z=minZ; z<maxZ; z++)
 for(let y=minY; y<maxY; y++)
 for(let x=minX; x<maxX; x++){
 const k2=`${x},${y},${z}`;
 if(!C.cellMap.has(k2)){
 const cell={x,y,z,value:'',formula:null,meta:{}};
 C.cells.push(cell);
 C.cellMap.set(k2, cell);
 }
 }
 }
 }catch{}
 });
 
 // Rebuild emission tracking maps from loaded metadata
 const emittedByAnchor = new Map();
 const sourceByCell = new Map();
 try{
 Object.values(arrays).forEach(a=>{
 Object.values(a.chunks||{}).forEach(ch=>{
 (ch.cells||[]).forEach(cell=>{
 const src = cell?.meta?.emitter;
 if(src){
 const ck = `${a.id}:${cell.x},${cell.y},${cell.z}`;
 sourceByCell.set(ck, src);
 const set = emittedByAnchor.get(src) || new Set();
 set.add(ck);
 emittedByAnchor.set(src, set);
 }
 });
 });
 });
 }catch{}

 const extraFormulaIds = [];
 Object.values(arrays).forEach(arr=>{
 if(arr && arr._hasFormulaCell){
 extraFormulaIds.push(arr.id);
 }
 });
 const combinedHosted = resolveFormulaActiveArrayIds(sourceByCell, null, extraFormulaIds);
 Object.values(arrays).forEach(arr=>{
 if(!arr) return;
 const mode = determineCollisionMode(arr, null, { debugMode:false, formulaHostedSet: combinedHosted });
 arr.collisionMode = mode;
 if(Object.prototype.hasOwnProperty.call(arr, '_hasFormulaCell')){
 delete arr._hasFormulaCell;
 }
 });

 // Restore full state (including rebuilt emission maps)
 const restoredUi = {...get().ui, ...(data.ui||{})};
 if(restoredUi.crystal2D !== true){ restoredUi.crystal2D = false; }
 // ALWAYS restore physics as FALSE to prevent auto-enable
 const restoredScene = {...get().scene, ...(data.scene||{}), physics: false};
 if(data.scene?.timed3D){ restoredScene.timed3D = rehydrateTimed3D(data.scene.timed3D); }
 console.log('[LOAD STATE] Forcing physics to false, ignoring saved state');
 
 // Restore globalState but ensure platformer.active is false
 const restoredGlobalState = new Map(Object.entries(data.globalState||{}));
 restoredGlobalState.set('platformer.active', false);
 // Remove stale platformer.pos to prevent false positives
 restoredGlobalState.delete('platformer.pos');
 console.log('[LOAD STATE] Platformer explicitly set to false');
 
 set({
 arrays,
 nextArrayId: data.nextArrayId||get().nextArrayId,
 globalState: restoredGlobalState,
 selection: data.selection||get().selection,
 ui: restoredUi,
 scene: restoredScene,
 avatarPhysics: data.avatarPhysics ? {...get().avatarPhysics, ...data.avatarPhysics} : get().avatarPhysics,
 physicsCamera: data.physicsCamera ? {...get().physicsCamera, ...data.physicsCamera} : get().physicsCamera,
 interactions: {...get().interactions, ...(data.interactions||{})},
 namedBlocks: new Map(Object.entries(data.namedBlocks||{})),
 namedMacros: new Map(Object.entries(data.namedMacros||{})),
 emittedByAnchor,
 sourceByCell,
 activeScales: new Map()
 });
 try{ Scene.setOceanEnabled?.(!!restoredScene?.ocean?.enabled); }catch{}

 // Restore selection early so focused array renders with shells/LOD correctly
 try{
 const sel0 = data.selection || {};
 const arrMap = Store.getState().arrays;
 let targetSel = null;
 if(sel0.arrayId && sel0.focus && arrMap[sel0.arrayId] && !arrMap[sel0.arrayId].hidden){
 targetSel = sel0;
 } else {
 const firstVisible = Object.values(arrMap).find(a=>a && !a.hidden && a.id>0);
 if(firstVisible) targetSel = { arrayId:firstVisible.id, focus:{x:0,y:0,z:0} };
 }
 if(targetSel){
 Actions.setSelection(targetSel.arrayId, targetSel.focus);
 try{
 const arrF = Store.getState().arrays[targetSel.arrayId];
 if(arrF){ 
 Scene.renderArray(arrF); 
 // Position camera properly after loading
 if(Scene.getCamera && Scene.getControls){
 const cam = Scene.getCamera();
 const ctrl = Scene.getControls();
 if(cam && ctrl){
 const off = arrF.offset || {x:0, y:0, z:0};
 const centerY = off.y + arrF.size.y / 2;
 ctrl.target.set(off.x, centerY, off.z);
 cam.position.set(8, 10, 14);
 ctrl.update();
 }
 }
 }
 }catch{}
 }
 }catch{}

 // Force-reserve arrays (id<0) hidden before first render to prevent any flash/overlap
 try{
 const S0 = Store.getState();
 Object.values(S0.arrays).forEach(A=>{ if((A.id|0) < 0){ A.hidden = true; } });
 }catch{}

 // Rebuild visuals and restore UI state
 Scene.reconcileAllArrays();
 restoreTimedPreviewState();
 try{
 const camCfg = Store.getState().physicsCamera;
 if(camCfg && Scene.setPhysicsCamera){
 Scene.setPhysicsCamera(camCfg.mode, camCfg.distance, camCfg.allowRotation);
 }
 }catch{}
 // Apply saved rotations and offsets explicitly
 try{
 Object.values(Store.getState().arrays).forEach(A=>{
 if(A._frame){
 if(Array.isArray(A.rotationQuat) && A.rotationQuat.length===4){ A._frame.quaternion.fromArray(A.rotationQuat); }
 const off=A.offset||{x:0,y:0,z:0}; A._frame.position.set(off.x,off.y,off.z);
 // Apply visibility as saved (e.g., Mainframe/Library hidden)
 try{ Scene.syncVisibility(A); }catch{}
 }
 });
 }catch{}
 // Don't restore camera - use proper positioning instead
 // try{ if(cameraSnapshot && Scene.restoreCamera) Scene.restoreCamera(cameraSnapshot); }catch{}
 // Force render all arrays to show loaded cells and shells
 try{
 const Sx = Store.getState();
 Object.values(Sx.arrays).forEach(A=>{ Scene.renderArray(A); });
 // After arrays are rendered, apply occlusion for focused selection once
 const sf = Sx.selection;
 if(sf && sf.arrayId && sf.focus){
 try{ Scene.updateFocus(sf); }catch{}
 }
 }catch{}
 window.UI?.init?.(); // Re-initialize UI event handlers
 window.UI?.renderSheet?.();
 // Defer a final focus/apply to the next frame to honor all rebuilt visuals
 try{
 requestAnimationFrame(()=>{
 try{
 const selD = Store.getState().selection || {};
 if(selD.arrayId && selD.focus){
 Scene.updateFocus(selD);
 const arrD = Store.getState().arrays[selD.arrayId];
 if(arrD) Scene.renderArray(arrD);
 }
 // Ensure camera is positioned well after everything loads
 if(Scene.getCamera && Scene.getControls){
 const cam = Scene.getCamera();
 const ctrl = Scene.getControls();
 if(cam && ctrl){
 cam.position.set(8, 10, 14);
 ctrl.target.set(0, 3, 0);
 ctrl.update();
 console.log('[LOAD STATE FINAL] Camera forced to good position');
 }
 }
 }catch{}
 });
 }catch{}
 // Finalize by re-applying focus and re-rendering focused array to honor shells/cutaway
 try{
 const selF = Store.getState().selection || {};
 if(selF.arrayId && selF.focus){
 Scene.updateFocus(selF);
 const arrF = Store.getState().arrays[selF.arrayId];
 if(arrF) Scene.renderArray(arrF);
 }
 }catch{}
 // Recreate text sprites for visible cell values after scene reconcile
 try{ Scene.hydrateAll?.(); }catch(e){ console.warn('Hydrate on load failed', e); }
 // One more pass next tick to cover late async mesh/frame attaches
 try{ setTimeout(()=>{ try{ Scene.hydrateAll?.(); }catch{} }, 0); }catch{}
 
 showToast(`?? State Loaded (${Object.keys(arrays).length} arrays)`);
 console.log('Load complete, arrays restored:', Object.keys(arrays));
 }catch(e){ 
 console.error('loadState failed', e); 
 showToast('? Load failed: ' + e.message); 
 }
 },
 resetSave: ()=>{
 try{
 const confirmed = confirm('??? Clear saved state and restart?\n\nThis will delete all saved arrays and formulas.');
 if(!confirmed) return;
 
 localStorage.removeItem('celliOsState');
 // Reset visibility settings as well
 try{ localStorage.removeItem('VisibilitySettings'); window.VisibilitySettings = JSON.parse(JSON.stringify(DEFAULT_VISIBILITY)); }catch{}
 showToast('??? Save cleared - restarting...');
 setTimeout(()=> location.reload(), 800);
 }catch(e){ 
 console.warn('resetSave failed', e); 
 showToast('? Clear failed: ' + e.message);
 }
 },
 init: async ()=>{
 await Scene.init(document.getElementById('view'));
 
 // Ensure platformer starts disabled
 try{
 const g = Store.getState().globalState;
 if(g && typeof g.set === 'function'){
 g.set('platformer.active', false);
 console.log('[INIT] Platformer explicitly set to false');
 }
 }catch(e){ console.warn('Platformer init failed', e); }

 // Mainframe (#-1) ? Library (#0) ? Sandbox (#2) ? Celli's Home (#1)
 const sp = Actions.createArray({id:-1,name:'Mainframe', size:{x:5,y:5,z:5}, hidden:true, sealed:true, offset:{x:-15,y:0,z:-15}});
 // No Library in this build

 console.log('Arrays created');
 
 // Create home array directly (avoid formulas during init)
 const home = Actions.createArray({id:1,name:"Celli's Home", size:{x:8,y:4,z:8}, hidden:false, offset:{x:0,y:1,z:0}});
 
 // Simple content setup matching reference spreadsheet
 console.log('Setting up content...');
 // Top-down sheet: y=0 is first row (A1)
 Actions.setCell(1, {x:0,y:0,z:0}, 'Hello', null, true); // A1
 Actions.setCell(1, {x:0,y:1,z:0}, 'World!', null, true); // A2 (note will be on A3)
 
 // Direct meta setup for A3 intro (bypass diegetic complexity during init)
 console.log('Setting up A3 intro meta directly...');
 try{
 // Ensure A3 exists
 Actions.resizeArrayIfNeeded(home, {x:0,y:2,z:0});
 const chKey = keyChunk(...Object.values(chunkOf(0,2,0)));
 let ch = home.chunks[chKey];
 if(!ch){ console.warn('A3 chunk missing after resize'); return; }
 let cell = ch.cells.find(c=>c.x===0&&c.y===2&&c.z===0);
 if(!cell){ ch.cells.push({x:0,y:2,z:0,value:'',formula:null,meta:{}}); cell = ch.cells[ch.cells.length-1]; }
 // Set meta directly with proper formula prefix
 const introMeta = normalizeMetaKeys(cell.meta||{});
 introMeta.noteText = 'Click Me!';
 introMeta.on_click = '=STARTINTROEXPERIENCE()';
 cell.meta = introMeta;
 console.log('A3 meta set:', cell.meta);
 }catch(e){ console.warn('Direct A3 setup failed', e); }
 

 try {
 // Focus home array and render it immediately for interaction
 Actions.setSelection(1, {x:0,y:0,z:0});
 Scene.renderArray(home);
 // Position camera to show the array nicely from front-above
 // Home array has offset {x:0, y:1, z:0} and size 8x4x8
 if(Scene.getCamera && Scene.getControls){
 const cam = Scene.getCamera();
 const ctrl = Scene.getControls();
 if(cam && ctrl){
 // Array center is at offset (0, 1, 0), look at middle of array
 const arrayCenter = {x: 0, y: 3, z: 0}; // y: 1 (offset) + 2 (half of height 4)
 ctrl.target.set(arrayCenter.x, arrayCenter.y, arrayCenter.z);
 // Camera positioned high and in front to see array well
 cam.position.set(8, 10, 14);
 ctrl.update();
 console.log('[INIT] Camera positioned at', cam.position, 'looking at', ctrl.target);
 }
 }
 } catch(e) {
 console.error('Home focus failed:', e);
 }


 try {
 UI.init();
 console.log('UI init done');
 // Onboarding: start maximized; collapse only when triggered
 const sheetEl=document.getElementById('sheet');
 const intro=document.getElementById('introOverlay');
 // Block interactions with overlay initially; start centered small
 sheetEl.classList.add('intro-centered');
 intro.classList.remove('hidden');
 // Ensure overlay actually sits above canvas and accepts pointer for safety-net
 intro.style.zIndex = '10000';

 UI.renderSheet();
 console.log('Sheet rendered');
 // Ensure intro note and wiring after DOM paints; re-render sheet to bind on_click eagerly
 requestAnimationFrame(()=>{ requestAnimationFrame(()=>{ 
 try{ UI.ensureIntroNote?.(); }catch{}
 try{ UI.renderSheet?.(); }catch{}
 
 }); });
 
 // Skip full reconcile during intro to avoid duplicate viewports
 
 // Final camera positioning to ensure good view
 if(Scene.getCamera && Scene.getControls){
 const cam = Scene.getCamera();
 const ctrl = Scene.getControls();
 if(cam && ctrl){
 cam.position.set(8, 10, 14);
 ctrl.target.set(0, 3, 0);
 ctrl.update();
 console.log('[INIT FINAL] Camera set to', cam.position, 'target', ctrl.target);
 }
 }

 window.__APP_READY = true;
 } catch(e) {
 console.error('Init failed:', e);
 }
 },
 }
 }; // Close return object
});
window.Store = Store;

/* ===========================
 Array actions (chunked)
=========================== */
// Transaction ledger for undo/redo and provenance (dual-mode)
const History = {
 dataPast: [], dataFuture: [], dataMax: 100, // cell value/formula changes
 uiPast: [], uiFuture: [], uiMax: 50 // selection/view changes
};

/* ===========================
 Goal/Win System
=========================== */
let checkingWinConditions = false; // Guard against recursion

function checkWinConditions() {
 if (checkingWinConditions) return; // Prevent recursive calls
 const S = Store.getState();
 if (!S.gameState || S.gameState.goals.size === 0 || S.gameState.hasWon) return;

 checkingWinConditions = true;
 try {
 let allGoalsMet = true;
 for (const [key, conditionRef] of S.gameState.goals.entries()) {
 const val = Formula.getCellValue(conditionRef);
 if (val !== 1 && val !== '1' && val !== true) {
 allGoalsMet = false;
 break;
 }
 }

 if (allGoalsMet) {
 S.gameState.hasWon = true; // Prevent re-triggering
 S.gameState.winCallbacks.forEach(cb => {
 try {
 const tx = Write.start('game.onwin', 'Triggering ONWIN');
 Formula.executeAt(cb.anchor, cb.callback, tx);
 Write.commit(tx);
 } catch(e) {
 console.error('ONWIN callback error:', e);
 }
 });
 showToast("? You Win! ?");
 }
 } finally {
 checkingWinConditions = false;
 }
}
const Write = (() => {
 let nextId = 1;
 
 function start(origin, reason) {
 return { id: nextId++, ops: [], reason, time: Date.now(), origin };
 }
 
 function set(tx, arrId, coord, next) {
 const arr = Store.getState().arrays[arrId];
 if(!arr) return;
 
 // Ensure array is large enough
 Actions.resizeArrayIfNeeded(arr, coord);
 
 const prevCell = UI.getCell(arrId, coord);
 const prev = { 
 value: prevCell.value, 
 formula: prevCell.formula, 
 meta: prevCell.meta || {} 
 };
 
 // If formula is being changed/removed, revert any 3D_ROTATE and clean up any emitted cells
 const ak = aKey({arrId, ...coord});
 const skipCleanup = !!(next && next.meta && next.meta.skip_cleanup);
 if(!skipCleanup && prev.formula && (next.formula === null || next.formula === '' || next.formula !== prev.formula)) {
 // Attempt 3D_ROTATE auto-revert for this anchor unless suppressed
 try{
 const S=Store.getState();
 const rec=(S.activeRotations||new Map()).get(ak);
 const suppressed=(S.suppress3DRotateRevert||new Set()).has(ak);
 if(rec && !suppressed){
 const targ=S.arrays[rec.targetId];
 if(targ){
 const pivotWorld = Scene.cellWorldPos(targ, rec.pivot.x, rec.pivot.y, rec.pivot.z);
 const rx=-(rec.steps.sx||0), ry=-(rec.steps.sy||0), rz=-(rec.steps.sz||0);
 (rec.ids||[rec.targetId]).map(id=>S.arrays[id]).filter(Boolean).forEach(a=> Scene.rotateArrayAround(a, pivotWorld, rx, ry, rz));
 (rec.ids||[rec.targetId]).map(id=>S.arrays[id]).filter(Boolean).forEach(a=>{ if(a._frame){ a.offset={ x:Math.round(a._frame.position.x), y:Math.round(a._frame.position.y), z:Math.round(a._frame.position.z) }; }});
 }
 const map=new Map(S.activeRotations); map.delete(ak); Store.setState({activeRotations:map});
 }
 if(suppressed){ const sup=new Set(Store.getState().suppress3DRotateRevert); sup.delete(ak); Store.setState({suppress3DRotateRevert:sup}); }
 }catch{}
 const S = Store.getState();
 const emitted = S.emittedByAnchor.get(ak);
 if(emitted) {
 // Guard re-entrancy within a single tx
 tx._clearVisited = tx._clearVisited || new Set();
 emitted.forEach(ck => {
 const [eArrId, coords] = ck.split(':');
 const [x, y, z] = coords.split(',').map(Number);
 const childKey = `${eArrId}:${x},${y},${z}`;
 if(tx._clearVisited.has(childKey)) { S.sourceByCell.delete(ck); return; }
 tx._clearVisited.add(childKey);
 // Clear the emitted cell (avoid self and skip cleanup in nested call)
 if(eArrId !== arrId || x !== coord.x || y !== coord.y || z !== coord.z) {
 Write.set(tx, +eArrId, {x, y, z}, { value: '', formula: null, meta: { skip_cleanup: true } });
 }
 S.sourceByCell.delete(ck);
 });
 S.emittedByAnchor.delete(ak);
 }
 }
 
 let merged = {
 value: next.value !== undefined ? next.value : prevCell.value,
 formula: next.formula !== undefined ? next.formula : prevCell.formula,
 meta: { ...prev.meta, ...(next.meta || {}), from: tx.origin }
 };
 // If clearing a cell (no value and no formula), strip visual-emission metadata
 const clearingCell = ((merged.formula==null || merged.formula==='') && (merged.value==='' || merged.value==null || merged.value===undefined));
 if (clearingCell) {
 const mm = {...(merged.meta||{})};
 delete mm.generated; delete mm.emitter; // remove flags that cause 2D color fill
 merged = { ...merged, meta: mm };
 }
 
 // Emission tracking for generated blocks
 const S = Store.getState();
 if(merged.meta && merged.meta.emitter){
 const srcAk = merged.meta.emitter;
 const ck = `${arrId}:${coord.x},${coord.y},${coord.z}`;
 if(ck !== srcAk){
 const set = S.emittedByAnchor.get(srcAk) || new Set();
 set.add(ck);
 S.emittedByAnchor.set(srcAk, set);
 S.sourceByCell.set(ck, srcAk);
 }
 }
 
 // Apply to in-memory model immediately
 Actions._setCellRaw(arrId, coord, merged);
 tx.ops.push({ arrId, x: coord.x, y: coord.y, z: coord.z, prev, next: merged });
 }
 function commit(tx) {
 // Store transaction in data history
 History.dataPast.push(tx);
 if(History.dataPast.length > History.dataMax) History.dataPast.shift();
 History.dataFuture = [];
 
 // Gather changed anchors for recompute
 const changedAnchors = new Set();
 const affectedArrays = new Set();
 
 for (const op of tx.ops) {
 // Skip recompute for anchors explicitly marked to avoid re-entry
 const skip = !!(op.next?.meta && op.next.meta.skip_recompute);
 if(!skip){
 const key = `${op.arrId}:${op.x},${op.y},${op.z}`;
 changedAnchors.add(key);
 }
 affectedArrays.add(op.arrId);
 }
 
 // Trigger dependency recompute unless we're already inside a recompute pass
 if(!(Formula.isRecomputing && Formula.isRecomputing())){
 Formula.recomputeAnchors(Array.from(changedAnchors));
 }
 
 // Collect emitted cells that became empty to restore them after commit
 const toRestore = [];
 try{
 const S = Store.getState();
 for(const op of tx.ops){
 const becameEmpty = (op.next.formula==null || op.next.formula==='') && (op.next.value==='' || op.next.value===null || op.next.value===undefined);
 if(!becameEmpty) continue;
 const ck = `${op.arrId}:${op.x},${op.y},${op.z}`;
 const srcAk = S.sourceByCell.get(ck);
 if(!srcAk) continue;
 const [aId, rest] = srcAk.split(':');
 const [sx, sy, sz] = rest.split(',').map(Number);
 const sc = Formula.getCell({arrId:+aId, x:sx, y:sy, z:sz});
 if(sc && sc.formula) toRestore.push({arrId:+aId,x:sx,y:sy,z:sz});
 }
 }catch{ /* ignore */ }
 
 // Update visuals for affected arrays with immediate layer re-rendering
 affectedArrays.forEach(id => {
 const arr = Store.getState().arrays[id];
 if(arr) {
 // Force immediate layer re-render for all affected layers
 const affectedLayers = new Set();
 for (const op of tx.ops) {
 if(op.arrId === id) {
 affectedLayers.add(op.z);
 Scene.updateValueSprite(arr, op.x, op.y, op.z, op.next);
 }
 }
 
 // Re-render each affected layer immediately to update voxel colors
 affectedLayers.forEach(z => {
 // Force complete layer rebuild by marking as not rendered
 const layerKey = `${arr.id}:${z}`;
 ['empty','ghost','filled','formula','edges'].forEach(type => {
 const rec = Scene.getLayerMesh(`${layerKey}:${type}`);
 if(rec && rec.mesh) {
 rec.mesh.count = 0; // Reset count to force rebuild
 }
 });
 Scene.renderLayer(arr, z);
 });
 
 // Full array render for any structural changes
 Scene.renderArray(arr);
 
 if(id === Store.getState().selection.arrayId && window.UI?.renderSheet) window.UI.renderSheet();
 }
 });
 
 // Persist after commit for seamless resume (debounced to avoid quota thrash)
 try{
 clearTimeout(window.__AUTO_SAVE_T);
 // Update save status
 const statusEl = document.getElementById('saveStatus');
 if(statusEl) statusEl.textContent = 'Auto-save: Pending...';
 
 window.__AUTO_SAVE_T = setTimeout(()=>{ 
 try{ 
 Store.getState().actions.saveState(); 
 const statusEl = document.getElementById('saveStatus');
 if(statusEl) statusEl.textContent = `Auto-save: ${new Date().toLocaleTimeString()}`;
 }catch{
 const statusEl = document.getElementById('saveStatus');
 if(statusEl) statusEl.textContent = 'Auto-save: Failed';
 } 
 }, 600);
 }catch{}
 // Check win conditions after any state change (async to break call stack)
 setTimeout(checkWinConditions, 0);
 
 // Restore cleared emitted cells by re-executing their source anchors
 if(toRestore.length>0 && !Actions._repairing){
 setTimeout(()=>{
 if(Actions._repairing) return;
 Actions._repairing = true;
 try{
 const rtx = Write.start('emit.restore','Restore cleared emitted cells');
 const uniq = new Set(toRestore.map(r=>`${r.arrId}:${r.x},${r.y},${r.z}`));
 uniq.forEach(k=>{ const [aid,coords]=k.split(':'); const [x,y,z]=coords.split(',').map(Number);
 Formula.executeAt({arrId:+aid,x,y,z}, undefined, rtx);
 });
 Write.commit(rtx);
 }catch(e){ console.warn('Restore emitted failed', e); }
 finally{ Actions._repairing = false; }
 },0);
 }
 }
 
 function rollback(tx) {
 for (const op of tx.ops.reverse()) {
 Actions._setCellRaw(op.arrId, {x:op.x, y:op.y, z:op.z}, op.prev);
 }
 }
 
 return { start, set, commit, rollback };
})();

function computeSelectionFaceHint(anchor, focus, range){
 try{
 if(!anchor || !focus || !range) return null;
 // For multi-cell selections, always use camera direction to show border facing viewer
 try{
 if(window.Scene && typeof window.Scene.getCamera === 'function'){
 const camera = window.Scene.getCamera();
 if(camera){
 const camDir = new THREE.Vector3();
 camera.getWorldDirection(camDir);
 // Reverse direction (we want the face pointing toward camera)
 const vec = { x: -camDir.x, y: -camDir.y, z: -camDir.z };
 const abs = { x: Math.abs(vec.x), y: Math.abs(vec.y), z: Math.abs(vec.z) };
 let axis = 'x';
 let axisIndex = 0;
 let best = abs.x;
 if(abs.y > best){ axis = 'y'; axisIndex = 1; best = abs.y; }
 if(abs.z > best){ axis = 'z'; axisIndex = 2; best = abs.z; }
 const sign = vec[axis] >= 0 ? 1 : -1;
 return { axis, axisIndex, sign };
 }
 }
 }catch{}
 // Fallback: use anchor relative to center (shouldn't normally reach here)
 const center = {
 x: (range.x1 + range.x2) / 2,
 y: (range.y1 + range.y2) / 2,
 z: (range.z1 != null && range.z2 != null) ? ((range.z1 + range.z2) / 2) : ((anchor.z + focus.z) / 2)
 };
 const vec = {
 x: anchor.x - center.x,
 y: anchor.y - center.y,
 z: anchor.z - center.z
 };
 const abs = { x: Math.abs(vec.x), y: Math.abs(vec.y), z: Math.abs(vec.z) };
 let axis = 'x';
 let axisIndex = 0;
 let best = abs.x;
 if(abs.y > best){ axis = 'y'; axisIndex = 1; best = abs.y; }
 if(abs.z > best){ axis = 'z'; axisIndex = 2; best = abs.z; }
 if(best < 1e-5) return null;
 const sign = vec[axis] >= 0 ? 1 : -1;
 return { axis, axisIndex, sign };
 }catch(e){ console.warn('computeSelectionFaceHint failed', e); return null; }
}

const Actions = {
 // Batch write system for dependency propagation
 _batch: null,
 _repairing: false, // Guard for emission auto-repair
 begin: function() { if(!this._batch) this._batch = { changed:new Set(), tx: Write.start('actions.batch','Grouped setCell') }; },
 end: function() {
 if(!this._batch) return;
 try{
 // Commit once to trigger recompute/renders once at the end of the chain
 if(this._batch.tx){ Write.commit(this._batch.tx); }
 // Consolidated visuals after recompute
 const affectedArrays = new Set();
 for (const k of this._batch.changed) {
 const [arrId, rest] = k.split(':');
 const [x,y,z] = rest.split(',').map(Number);
 const numArrId = +arrId;
 affectedArrays.add(numArrId);
 const arr = Store.getState().arrays[numArrId];
 if(arr && window.UI?.renderSheetCell) window.UI.renderSheetCell(arr, x, y, z);
 }
 const currentArrayId = Store.getState().selection.arrayId;
 if(affectedArrays.has(currentArrayId) && window.UI?.renderSheet) window.UI.renderSheet();
 affectedArrays.forEach(id=>{ const arr=Store.getState().arrays[id]; if(arr) Scene.renderArray(arr); });
 } finally {
 this._batch = null;
 }
 },

 createArray: ({id,name='Array',size={x:6,y:4,z:6},hidden=false,sealed=false,offset={x:0,y:0,z:0}})=>{
 // Determine a stable, unique array ID
 const S0 = Store.getState();
 let arrId;
 if(id !== undefined){
 if(!Number.isInteger(id)) throw new Error('Array ID must be an integer');
 if(id>0 && S0.arrays[id]) throw new Error(`Array with ID ${id} already exists.`);
 // Allow non-positive IDs for reserved/system arrays only (e.g., boot-time arrays)
 arrId = id;
 } else {
 const used = Object.values(S0.arrays).map(a=>a.id).filter(n=>Number.isInteger(n) && n>0);
 const sorted = [...new Set(used)].sort((a,b)=>a-b);
 let next = 1;
 for(const n of sorted){ if(n===next) next++; else if(n>next) break; }
 arrId = next;
 }
 const arr = {
 id:arrId, name, size:{...size}, hidden, sealed,
 state:'ACTIVE', stableCount:0, lastHash:null, lastDepSig:null,
 collisionMode:'edit',
 fnPolicy:{mode:'ALLOW_ALL', allow:new Set(), deny:new Set(), tags:new Set()},
 params:{}, locks:new Set(),
 chunks:{}, labels:[], _frame:null, _colliders:[], offset:{...offset}, _occluders:null
 };
 // build chunks sparsely
 const cDims={x:Math.ceil(size.x/CHUNK_SIZE), y:Math.ceil(size.y/CHUNK_SIZE), z:Math.ceil(size.z/CHUNK_SIZE)};
 for(let cz=0;cz<cDims.z;cz++)
 for(let cy=0;cy<cDims.y;cy++)
 for(let cx=0;cx<cDims.x;cx++){
 const ch = new Scene.Chunk(arr, {x:cx,y:cy,z:cz});
 for(let z=0;z<CHUNK_SIZE;z++)
 for(let y=0;y<CHUNK_SIZE;y++)
 for(let x=0;x<CHUNK_SIZE;x++){
 const wx=cx*CHUNK_SIZE+x, wy=cy*CHUNK_SIZE+y, wz=cz*CHUNK_SIZE+z;
 if(wx<size.x&&wy<size.y&&wz<size.z){
 const cell={x:wx,y:wy,z:wz,value:'',formula:null,meta:{}};
 ch.cells.push(cell);
 ch.cellMap.set(`${wx},${wy},${wz}`, cell);
 }
 }
 arr.chunks[keyChunk(cx,cy,cz)] = ch;
 }

 const S=Store.getState();
 // Initialize global grid phase on first array: align its origin cell center to world integer
 if(!S.gridPhase.x&&S.gridPhase.x!==0){
 const phase={x:Math.round(offset.x), y:Math.round(offset.y), z:Math.round(offset.z)};
 Store.setState({gridPhase:phase});
 }
 // Snap offset to global grid phase so cell centers line up across arrays
 const arrScale = arrayVoxelScale(arr);
 const snapAxis=(axis,val,sz)=>{
 const phase = Store.getState().gridPhase[axis]||0;
 const half = (sz * arrScale) / 2;
 const base = (axis==='z') ? (half - arrScale/2) : (-(half) + arrScale/2);
 return Math.round((val - base - phase)/arrScale) * arrScale + base + phase;
 };
 arr.offset={ x:snapAxis('x', offset.x, size.x), y:snapAxis('y', offset.y, size.y), z:snapAxis('z', offset.z, size.z) };
 Store.setState({ arrays:{...S.arrays,[arrId]:arr}, nextArrayId:Math.max(S.nextArrayId, arrId+1), lastCreatedArrayId:arrId });
 Scene.renderArray(arr);
 // Immediately construct LOD1 meshes and rehydrate so new arrays appear without extra interactions
 try{
 Object.values(arr.chunks).forEach(ch=>{ ch.ensureMesh?.(); ch.setLOD?.(1); rehydrateChunkInstances(arr, ch); });
 // Keep this array fully hydrated for a few frames so it is clickable before focus
 arr._warmupFrames = 6;
 // Do NOT apply ghost mask immediately; default new arrays to SOLID (no ghosting)
 try{ forceRenderOrderRefresh?.(false); }catch{}
 }catch{}
 // Snap this array just beyond the max extent of existing arrays with a 1-cell gap
 try{
 const arrays = Object.values(Store.getState().arrays).filter(a=>a && a.id!==arr.id);
 if(arrays.length){
 let maxX=-Infinity;
 arrays.forEach(a=>{
 const x=a.offset?.x||0;
 const s=arrayVoxelScale(a);
 maxX=Math.max(maxX, x + (a.size.x*s)/2);
 });
 const desired = {
 x: Math.round(maxX + arrScale + (arr.size.x*arrScale)/2),
 y: arr.offset.y,
 z: arr.offset.z
 };
 setArrayOffset(arr, desired, {interactive:true});
 }
 }catch{}
 // Force shell creation by triggering focus if this becomes the active array
 try{
 const currentSel = Store.getState().selection;
 if(!currentSel.arrayId || !Store.getState().arrays[currentSel.arrayId] || Store.getState().arrays[currentSel.arrayId].hidden){
 Actions.setSelection(arrId, {x:0,y:0,z:0});
 }
 }catch{}
 // Apply any pending meta queued for this array (e.g., late on_click/note bindings)
 try{
 const St=Store.getState();
 if(Array.isArray(St.pendingMeta) && St.pendingMeta.length){
 const remain=[]; const ptx=Write.start('pending.meta','Apply pending meta');
 St.pendingMeta.forEach(item=>{
 if(item?.target?.arrId===arrId){
 try{
 const t=item.target; const prior=Formula.getCell({arrId:arrId,x:t.x,y:t.y,z:t.z})||{};
 const mergedMeta = normalizeMetaKeys({...(prior.meta||{}), ...(item.meta||{})});
 Write.set(ptx, arrId, {x:t.x,y:t.y,z:t.z}, { value: prior.value??'', formula: prior.formula??null, meta:mergedMeta });
 }catch(e){ remain.push(item); }
 } else { remain.push(item); }
 });
 Write.commit(ptx);
 Store.setState({pendingMeta:remain});
 if(remain.length !== St.pendingMeta.length){ try{ UI.renderSheet?.(); }catch{} }
 }
 }catch{}
 try{
 if(Store.getState().scene?.physicsDebugAll){
 Scene.setPhysicsDebugAll(true);
 }
 }catch(e){ console.warn('Reapplying physics debug overrides for new array failed', e); }
 return arr;
 },

 deleteArray: (arrId, opts={})=>{
 const S = Store.getState();
 const arr = S.arrays[arrId];
 if(!arr) return false;

 // Hide immediately in both 3D and 2D
 arr.hidden = true;
 Scene.syncVisibility(arr);

 // Remove 3D graphics and sprites
 try{ Scene.removeArrayGraphics?.(arr); }catch{}

 // Clean emitted tracking
 try{
 const emitted = S.emittedByAnchor;
 const source = S.sourceByCell;
 [...emitted.keys()].forEach(ak=>{
 if(ak.startsWith(`${arrId}:`)) emitted.delete(ak);
 });
 [...source.keys()].forEach(ck=>{
 if(ck.startsWith(`${arrId}:`)) source.delete(ck);
 });
 }catch{}

 // Clean dependency graph for this array
 try{
 const newDepsByAnchor = new Map();
 S.depsByAnchor.forEach((deps, ak)=>{
 if(!ak.startsWith(`${arrId}:`)) newDepsByAnchor.set(ak, deps);
 });
 const newAnchorsByDep = new Map();
 S.anchorsByDep.forEach((anchors, dk)=>{
 if(dk.startsWith(`${arrId}:`)) return;
 const filtered = new Set([...anchors].filter(a => !String(a).startsWith(`${arrId}:`)));
 if(filtered.size) newAnchorsByDep.set(dk, filtered);
 });
 Store.setState({ depsByAnchor:newDepsByAnchor, anchorsByDep:newAnchorsByDep });
 }catch{}

 // Remove from dock groups
 try{
 const ng = new Map(S.dockGroups||new Map());
 ng.forEach((g,k)=>{
 g.members = g.members.filter(id=> id!==arrId);
 if(g.members.length === 0) ng.delete(k);
 });
 Store.setState({ dockGroups: ng });
 }catch{}

 // Clean up any embedded meshes tied to this array
 try{
 const map = __cloneEmbeddedMap(Store.getState().embeddedMeshes);
 let changed=false;
 map.forEach((rec, key)=>{
 if(rec?.hostArrId===arrId || rec?.sourceArrId===arrId){
 __disposeEmbeddedRecord(rec);
 map.delete(key);
 changed=true;
 }
 });
 if(changed) Store.setState({ embeddedMeshes: map });
 }catch{}

 // Remove from array registry
 const arrays = { ...S.arrays };
 delete arrays[arrId];
 Store.setState({ arrays });

 // Reroute selection if necessary
 try{
 const sel = Store.getState().selection;
 if(sel.arrayId === arrId){
 const next = Object.values(Store.getState().arrays).find(a=>!a.hidden) || null;
 if(next) Actions.setSelection(next.id, {x:0,y:Math.max(0,next.size.y-1),z:0}, null, '3d');
 else Store.setState(s=>({ selection:{ arrayId:null, focus:null, anchor:null, range:null, faceHint:null } }));
 }
 window.UI?.renderSheet?.();
 }catch{}

 showToast(`Deleted #${arrId}`);
 return true;
 },

 // Raw cell update without notifications or rendering (used by Write system)
 _setCellRaw: (arrayId, coord, cellData)=>{
 const S=Store.getState();
 const arr=S.arrays[arrayId]; if(!arr) return;
 Actions.resizeArrayIfNeeded(arr, coord);
 const c = chunkOf(coord.x,coord.y,coord.z); const k=keyChunk(c.x,c.y,c.z);
 const ch=arr.chunks[k]; if(!ch) return;
 let cell = ch.cellMap?.get(`${coord.x},${coord.y},${coord.z}`);
 if(!cell){
 cell = {x:coord.x, y:coord.y, z:coord.z, value:'', formula:null, meta:{}};
 ch.cells.push(cell);
 ch.cellMap?.set(`${coord.x},${coord.y},${coord.z}`, cell);
 }
 // Auto-revert 3D_ROTATE on clear without requiring execution
 try{
 const beforeFormula = ch.cells[idx]?.formula || null;
 const ak = `${arrayId}:${coord.x},${coord.y},${coord.z}`;
 const clearing = (cellData.formula===null || cellData.formula==='');
 if(clearing && beforeFormula){
 const rec=(S.activeRotations||new Map()).get(ak);
 const suppressed=(S.suppress3DRotateRevert||new Set()).has(ak);
 if(rec && !suppressed){
 const targ=S.arrays[rec.targetId];
 if(targ){
 const ids=rec.ids||[rec.targetId];
 ids.map(id=>S.arrays[id]).filter(Boolean).forEach(a=>{ if(!a._frame) Scene.renderArray(a); });
 const pivotWorld = Scene.cellWorldPos(targ, rec.pivot.x, rec.pivot.y, rec.pivot.z);
 const rx=-(rec.steps.sx||0), ry=-(rec.steps.sy||0), rz=-(rec.steps.sz||0);
 ids.map(id=>S.arrays[id]).filter(Boolean).forEach(a=> Scene.rotateArrayAround(a, pivotWorld, rx, ry, rz));
 ids.map(id=>S.arrays[id]).filter(Boolean).forEach(a=>{ if(a._frame){ a.offset={ x:Math.round(a._frame.position.x), y:Math.round(a._frame.position.y), z:Math.round(a._frame.position.z) }; }});
 }
 const map=new Map(S.activeRotations); map.delete(ak); Store.setState({activeRotations:map});
 if(suppressed){ const sup=new Set(S.suppress3DRotateRevert); sup.delete(ak); Store.setState({suppress3DRotateRevert:sup}); }
 }
 }
 }catch{}
 Object.assign(cell, cellData);
 try{ ch.markDirty?.(); }catch{}
 arr.state='ACTIVE'; arr.stableCount=0;
 },

 setCell: (arrayId, coord, value, formula=null, noRender=false)=>{
 // Prefer active batch transaction for coherence
 const activeTx = Actions._batch?.tx;
 if(activeTx){
 try{
 Write.set(activeTx, arrayId, coord, { value, formula });
 // Track changed for consolidated post-commit render
 Actions._batch.changed.add(aKey({arrId:arrayId, ...coord}));
 // Defer visuals during batch to avoid mid-chain flicker and wrong states
 return;
 } catch(e){ console.error('batched setCell failed, falling back', e); }
 }
 // Fallback: single-op transaction to preserve dependency semantics
 const tx = Write.start('actions.setCell','single op');
 Write.set(tx, arrayId, coord, { value, formula });
 Write.commit(tx);
 },

 resizeArrayIfNeeded: (arr, coord)=>{
 let changed=false; const newSize={...arr.size};
 if(coord.x>=arr.size.x){ newSize.x=coord.x+1; changed=true; }
 if(coord.y>=arr.size.y){ newSize.y=coord.y+1; changed=true; }
 if(coord.z>=arr.size.z){ newSize.z=coord.z+1; changed=true; }
 if(!changed) return;
 
 // expand chunks
 const oldSize={...arr.size}; arr.size=newSize;
 const cDims={x:Math.ceil(newSize.x/CHUNK_SIZE), y:Math.ceil(newSize.y/CHUNK_SIZE), z:Math.ceil(newSize.z/CHUNK_SIZE)};
 for(let cz=0;cz<cDims.z;cz++)
 for(let cy=0;cy<cDims.y;cy++)
 for(let cx=0;cx<cDims.x;cx++){
 const k=keyChunk(cx,cy,cz); if(arr.chunks[k]) continue;
 const ch = new Scene.Chunk(arr, {x:cx,y:cy,z:cz});
 for(let z=0;z<CHUNK_SIZE;z++)
 for(let y=0;y<CHUNK_SIZE;y++)
 for(let x=0;x<CHUNK_SIZE;x++){
 const wx=cx*CHUNK_SIZE+x, wy=cy*CHUNK_SIZE+y, wz=cz*CHUNK_SIZE+z;
 if(wx<newSize.x&&wy<newSize.y&&wz<newSize.z) ch.cells.push({x:wx,y:wy,z:wz,value:'',formula:null,meta:{}});
 }
 arr.chunks[k] = ch;
 }
 // render new layers if Z grew
 for(let z=0; z<arr.size.z; z++){ Scene.renderLayer(arr,z); }
 Scene.renderArray(arr);
 
 // Update all global references when array expands
 if(changed) {
 Actions.offsetGlobalReferences(arr.id, oldSize, newSize);
 }
 
 // Trigger auto-repair for any emitted cells that might need refilling in the expanded area
 if(!Actions._repairing) {
 const S = Store.getState();
 // Check all source anchors that emit into this array
 S.emittedByAnchor.forEach((emittedSet, sourceAk) => {
 const hasEmptyInExpansion = Array.from(emittedSet).some(ck => {
 const [eArrId, coords] = ck.split(':');
 if(+eArrId !== arr.id) return false;
 const [x, y, z] = coords.split(',').map(Number);
 // Check if this emitted cell is in the newly expanded area and is empty
 const isInExpansion = x >= oldSize.x || y >= oldSize.y || z >= oldSize.z;
 if(isInExpansion) {
 const cell = UI.getCell(arr.id, {x, y, z});
 return cell.value === '' || cell.value === null || cell.value === undefined;
 }
 return false;
 });
 
 if(hasEmptyInExpansion) {
 // Re-execute the source to refill the expansion
 const [aId, rest] = sourceAk.split(':');
 const [sx, sy, sz] = rest.split(',').map(Number);
 setTimeout(() => {
 if(!Actions._repairing) {
 Actions._repairing = true;
 try {
 const tx = Write.start('expand.refill', 'Refill after array expansion');
 Formula.executeAt({arrId: +aId, x: sx, y: sy, z: sz}, undefined, tx);
 Write.commit(tx);
 } finally {
 Actions._repairing = false;
 }
 }
 }, 10); // Small delay to avoid recursion
 }
 });
 }
 },
 // Update all global references when an array expands
 offsetGlobalReferences: (arrayId, oldSize, newSize) => {
 const S = Store.getState();
 const dx = newSize.x - oldSize.x;
 const dy = newSize.y - oldSize.y; 
 const dz = newSize.z - oldSize.z;
 
 if(dx === 0 && dy === 0 && dz === 0) return; // No expansion
 
 console.log(`Offsetting references for array ${arrayId}: expansion (${dx},${dy},${dz})`);
 
 // Update all formulas that reference cells in the expanded array
 Object.values(S.arrays).forEach(arr => {
 Object.values(arr.chunks).forEach(chunk => {
 chunk.cells.forEach(cell => {
 if(cell.formula) {
 // Check if formula contains references to the expanded array
 const refs = cell.formula.match(/@\[(-?\d+),(-?\d+),(-?\d+),(-?\d+)\]/g);
 if(refs) {
 let newFormula = cell.formula;
 refs.forEach(ref => {
 const match = ref.match(/@\[(-?\d+),(-?\d+),(-?\d+),(-?\d+)\]/);
 if(match && +match[4] === arrayId) {
 const refX = +match[1], refY = +match[2], refZ = +match[3];
 // Only offset if reference is beyond the original bounds
 if(refX >= oldSize.x || refY >= oldSize.y || refZ >= oldSize.z) {
 const newRef = `@[${refX + (refX >= oldSize.x ? dx : 0)},${refY + (refY >= oldSize.y ? dy : 0)},${refZ + (refZ >= oldSize.z ? dz : 0)},${arrayId}]`;
 newFormula = newFormula.replace(ref, newRef);
 }
 }
 });
 
 if(newFormula !== cell.formula) {
 cell.formula = newFormula;
 console.log(`Updated formula: ${cell.formula}`);
 }
 }
 }
 });
 });
 });
 
 // Update dependency graph keys
 const newDepsByAnchor = new Map();
 const newAnchorsByDep = new Map();
 
 S.depsByAnchor.forEach((deps, anchorKey) => {
 const [aId, coords] = anchorKey.split(':');
 if(+aId === arrayId) {
 const [x, y, z] = coords.split(',').map(Number);
 if(x >= oldSize.x || y >= oldSize.y || z >= oldSize.z) {
 const newX = x + (x >= oldSize.x ? dx : 0);
 const newY = y + (y >= oldSize.y ? dy : 0);
 const newZ = z + (z >= oldSize.z ? dz : 0);
 const newKey = `${aId}:${newX},${newY},${newZ}`;
 newDepsByAnchor.set(newKey, deps);
 } else {
 newDepsByAnchor.set(anchorKey, deps);
 }
 } else {
 newDepsByAnchor.set(anchorKey, deps);
 }
 });
 
 S.anchorsByDep.forEach((anchors, depKey) => {
 const [aId, coords] = depKey.split(':');
 if(+aId === arrayId) {
 const [x, y, z] = coords.split(',').map(Number);
 if(x >= oldSize.x || y >= oldSize.y || z >= oldSize.z) {
 const newX = x + (x >= oldSize.x ? dx : 0);
 const newY = y + (y >= oldSize.y ? dy : 0);
 const newZ = z + (z >= oldSize.z ? dz : 0);
 const newKey = `${aId}:${newX},${newY},${newZ}`;
 newAnchorsByDep.set(newKey, anchors);
 } else {
 newAnchorsByDep.set(depKey, anchors);
 }
 } else {
 newAnchorsByDep.set(depKey, anchors);
 }
 });
 
 Store.setState({ depsByAnchor: newDepsByAnchor, anchorsByDep: newAnchorsByDep });
 },

 setSelection:(arrayId, focus, anchor=null, interactionSource='3d')=>{
 console.log(`[ACTIONS.setSelection] Called with: arrayId=${arrayId}, focus=(${focus.x}, ${focus.y}, ${focus.z}), source=${interactionSource}`);
 Store.setState(s=>({ selection:{arrayId, focus, anchor:anchor||focus, range:null, faceHint:null}, ui:{...s.ui, zLayer:focus.z, lastInteraction:interactionSource} }));
 const actualSelection = Store.getState().selection;
 console.log(`[ACTIONS.setSelection] After setState, actual focus=(${actualSelection.focus.x}, ${actualSelection.focus.y}, ${actualSelection.focus.z})`);
 Scene.updateFocus(Store.getState().selection);
 Scene.resetContactCache?.();
 UI.updateFocusChip();
 UI.renderSheet();

 // ---- ON_SELECT dispatch (no-stamp, single tx, recursion-guard) ----
 try {
 const arr=Store.getState().arrays[arrayId];
 const hooks = ensureOnSelectHooks(arr);
 if(!hooks.length) return;

 if(Actions._handlingOnSelect) return; // guard against re-entrancy
 Actions._handlingOnSelect = true;

 const {x,y,z}=focus; 
 const addr=formatLocalAddress(arrayId,{x,y,z});
 const tx=Write.start('hook.on_select','ON_SELECT actions');
 for(const h of hooks){
 if(h.cells.has(`${x},${y},${z}`)){
 const action = String(h.action||'').replaceAll('$ADDR',addr);
 Formula.runOnceAt({arrId:arrayId, x:h.anchor.x, y:h.anchor.y, z:h.anchor.z}, action, tx);
 }
 }
 Write.commit(tx);
 } catch(e) {
 console.warn('ON_SELECT hooks failed', e);
 } finally {
 Actions._handlingOnSelect = false;
 }
 },

 setSelectionRange:(arrayId, anchor, focus, interactionSource='3d')=>{
 const xs=[anchor.x,focus.x].map(v=>Number.isFinite(v)?v:0).sort((a,b)=>a-b);
 const ys=[anchor.y,focus.y].map(v=>Number.isFinite(v)?v:0).sort((a,b)=>a-b);
 const zs=[anchor.z,focus.z].map(v=>Number.isFinite(v)?v:0).sort((a,b)=>a-b);
 const focusZ = Number.isFinite(focus.z) ? focus.z : (Number.isFinite(anchor.z) ? anchor.z : 0);
 const range={x1:xs[0],y1:ys[0],x2:xs[1],y2:ys[1],z:focusZ,z1:zs[0],z2:zs[1]};
 const faceHint = computeSelectionFaceHint(anchor, focus, range);
 Store.setState(s=>({ selection:{arrayId, focus, anchor, range, faceHint}, ui:{...s.ui, zLayer:focusZ, lastInteraction:interactionSource} }));
 Scene.updateFocus(Store.getState().selection);
 UI.updateFocusChip();
 UI.renderSheet();
 },

 moveSelection:(dx,dy,dz=0)=>{
 const s=Store.getState().selection; if(!s.arrayId||!s.focus) return;
 const arr=Store.getState().arrays[s.arrayId]; if(!arr) return;
 const lastInteraction = Store.getState().ui?.lastInteraction || '3d';
 const newFocus={x:Math.max(0,Math.min(arr.size.x-1,s.focus.x+dx)), y:Math.max(0,Math.min(arr.size.y-1,s.focus.y+dy)), z:Math.max(0,Math.min(arr.size.z-1,s.focus.z+dz))};
 if(s.range){
 const newAnchor={x:Math.max(0,Math.min(arr.size.x-1,s.anchor.x+dx)), y:Math.max(0,Math.min(arr.size.y-1,s.anchor.y+dy)), z:Math.max(0,Math.min(arr.size.z-1,s.anchor.z+dz))};
 Actions.setSelectionRange(s.arrayId, newAnchor, newFocus, lastInteraction);
 } else {
 Actions.setSelection(s.arrayId, newFocus);
 }
 },

 togglePhysics: ()=>{
 try{
 const result = Scene.togglePhysicsMode?.();
 if(result && typeof result.catch === 'function'){
 result.catch(e=>console.warn('[PHYSICS] togglePhysics failed', e));
 }
 }catch(e){ console.warn('[PHYSICS] togglePhysics threw', e); }
 },
 toggleGrid: ()=>{ Store.setState(s=>({scene:{...s.scene, showGrid:!s.scene.showGrid}})); Scene.setGridVisible(Store.getState().scene.showGrid); },
 toggleAxes: ()=>{ Store.setState(s=>({scene:{...s.scene, showAxes:!s.scene.showAxes}})); Scene.setAxesVisible(Store.getState().scene.showAxes); },
 setCrystal2D: (enabled)=>{
 const next = !!enabled;
 Store.setState(s=>({ ui:{...s.ui, crystal2D: next} }));
 window.UI?.applyCrystalStyle?.(next);
 return next;
 },
 toggleCrystal2D: ()=>{
 const prev = !!Store.getState().ui?.crystal2D;
 const next = !prev;
 Actions.setCrystal2D(next);
 window.UI?.renderSheet?.();
 return next;
 },
 togglePresentMode: ()=> Scene.togglePresentMode(),
 updateGraphicsSettings: (patch)=> Scene.updateGraphicsSettings(patch || {}),
 setOceanEnabled: (enabled)=> Scene.setOceanEnabled(enabled),
 updateOceanSettings: (patch)=> Scene.updateOceanSettings(patch || {}),
 // Render mode removed - always use simple mode
 // Undo/Redo system
 // Data history (undo/redo)
 undoData: ()=>{
 if(History.dataPast.length === 0) return;
 const tx = History.dataPast.pop();
 History.dataFuture.push(tx);
 Write.rollback(tx);
 const changed = tx.ops.map(op => `${op.arrId}:${op.x},${op.y},${op.z}`);
 Formula.recomputeAnchors(changed);
 const affectedArrays = new Set(tx.ops.map(op => op.arrId));
 affectedArrays.forEach(id => { const arr = Store.getState().arrays[id]; if(arr){ Scene.renderArray(arr); if(id===Store.getState().selection.arrayId) UI.renderSheet(); } });
 },

 redoData: ()=>{
 if(History.dataFuture.length === 0) return;
 const tx = History.dataFuture.pop();
 History.dataPast.push(tx);
 tx.ops.forEach(op => { Actions._setCellRaw(op.arrId, {x:op.x, y:op.y, z:op.z}, op.next); });
 const changed = tx.ops.map(op => `${op.arrId}:${op.x},${op.y},${op.z}`);
 Formula.recomputeAnchors(changed);
 const affectedArrays = new Set(tx.ops.map(op => op.arrId));
 affectedArrays.forEach(id => { const arr = Store.getState().arrays[id]; if(arr){ Scene.renderArray(arr); if(id===Store.getState().selection.arrayId) UI.renderSheet(); } });
 },
};

/* ===========================
 Function Registry + Policy
=========================== */
const ALWAYS = new Set([
 'FUNCTIONS','LOCK','CREATE','ARRAY','PARAMETERS','ADDRESS','ALT_ADDRESS','COMBINE','COLOR','GETCOLOR',
 'ON_SELECT','ON_EVENT','FIRE_EVENT','SET_GLOBAL','GET_GLOBAL','FOCUS_SET','COPY',
 'SOKOBAN','SOKO_STEP','SOKOBAN2','SOKO_STEP2','SSR','SSR_STEP','DEP_VIS','GET_ARRAY_POS','SET_ARRAY_POS','TRANSLATE_ARRAY','ROTATE_ARRAY',
 'INVENTORY','3D_TRANSLATE','3D_ROTATE','DELETE','DEL','REMOVE','LIGHT','CHIME'
]);
const Fn = {}; // name -> {tags:[...], impl(anchor, arr, ast)}
const tag = (name,tags,impl)=>{ Fn[name]={tags:new Set(tags),impl}; };
function ensureTransaction(tx, origin='auto', reason='Formula mutation'){
 if(tx) return { tx, owned:false };
 return { tx: Write.start(origin, reason), owned:true };
}
function finalizeTransaction(info){
 if(info && info.owned && info.tx){
 Write.commit(info.tx);
 }
}
function collectTargetCells(arg, anchor){
 const out = [];
 if(arg && arg.kind === 'range'){
 arg.cells.forEach(cell=>{
 out.push({
 arrId: cell.arrId ?? anchor.arrId,
 x: cell.x,
 y: cell.y,
 z: cell.z
 });
 });
 } else if(arg && arg.kind === 'ref'){
 out.push({
 arrId: arg.arrId ?? anchor.arrId,
 x: arg.x,
 y: arg.y,
 z: arg.z
 });
 } else if(anchor){
 out.push({
 arrId: anchor.arrId,
 x: anchor.x,
 y: anchor.y,
 z: anchor.z
 });
 }
 return out;
}

const ARRAY_SCOPE_TOKEN = '__arrayScope';
function makeArrayScope(mode='host', ids=[]){
 const uniq = new Set();
 (ids||[]).forEach(id=>{
 const n = Number(id);
 if(Number.isFinite(n)) uniq.add(Math.trunc(n));
 });
 return { [ARRAY_SCOPE_TOKEN]: true, mode, ids: Array.from(uniq) };
}
function normalizeScopeDescriptor(raw, hostId=null){
 if(!raw || typeof raw !== 'object') return null;
 if(raw[ARRAY_SCOPE_TOKEN]){
 const mode = (raw.mode === 'all' || raw.mode === 'limit') ? raw.mode : 'host';
 const ids = Array.isArray(raw.ids) ? raw.ids.map(n=>Math.trunc(Number(n)||0)).filter(n=>Number.isFinite(n)) : [];
 if(mode === 'host' && ids.length === 0 && hostId != null) ids.push(Math.trunc(hostId));
 return { mode, ids };
 }
 if(typeof raw.mode === 'string' && raw.mode.toLowerCase() === 'all'){
 return { mode:'all', ids:[] };
 }
 if(Number.isFinite(raw.arrId)){
 return { mode:'limit', ids:[Math.trunc(raw.arrId)] };
 }
 if(Number.isFinite(raw.id)){
 return { mode:'limit', ids:[Math.trunc(raw.id)] };
 }
 return null;
}
function gatherArrayIdsFromValue(value, hostId, idsOut, flags){
 if(!idsOut) idsOut = new Set();
 if(!flags) flags = { all:false };
 if(value == null) return { ids: idsOut, flags };
 if(typeof value === 'object'){
 const normalized = normalizeScopeDescriptor(value, hostId);
 if(normalized){
 if(normalized.mode === 'all'){ flags.all = true; }
 normalized.ids.forEach(id=> idsOut.add(id));
 return { ids: idsOut, flags };
 }
 if(Array.isArray(value)){
 value.forEach(v=>{
 const res = gatherArrayIdsFromValue(v, hostId, idsOut, flags);
 idsOut = res.ids; flags = res.flags;
 });
 return { ids: idsOut, flags };
 }
 if(Number.isFinite(value.arrId)){ idsOut.add(Math.trunc(value.arrId)); }
 if(Number.isFinite(value.id)){ idsOut.add(Math.trunc(value.id)); }
 return { ids: idsOut, flags };
 }
 if(typeof value === 'string'){
 const trimmed = value.trim();
 if(trimmed.toLowerCase() === 'all'){ flags.all = true; return { ids: idsOut, flags }; }
 const addr = /^@\[(.*)\]$/.exec(trimmed);
 if(addr){
 const parts = addr[1].split(',').map(s=>s.trim()).filter(Boolean);
 if(parts.length >= 4){
 const arrPart = Number(parts[3]);
 if(Number.isFinite(arrPart)) idsOut.add(Math.trunc(arrPart));
 }
 return { ids: idsOut, flags };
 }
 const cleaned = trimmed.replace(/[\[\]\{\}]/g,'');
 cleaned.split(/[,\s]+/).forEach(part=>{
 if(!part) return;
 const n = Number(part);
 if(Number.isFinite(n)) idsOut.add(Math.trunc(n));
 });
 return { ids: idsOut, flags };
 }
 if(typeof value === 'number' && Number.isFinite(value)){
 idsOut.add(Math.trunc(value));
 }
 return { ids: idsOut, flags };
}
function extractScopeFromArgs(args, anchor, hostId){
 const ids = new Set();
 const flags = { all:false };
 (args||[]).forEach(arg=>{
 if(!arg) return;
 if(arg.kind === 'ref'){
 const id = arg.arrId ?? anchor?.arrId ?? hostId;
 if(Number.isFinite(id)) ids.add(Math.trunc(id));
 return;
 }
 if(arg.kind === 'range'){
 arg.cells.forEach(cell=>{
 const id = cell.arrId ?? anchor?.arrId ?? hostId;
 if(Number.isFinite(id)) ids.add(Math.trunc(id));
 });
 return;
 }
 try{
 const val = Formula.valOf(arg);
 const res = gatherArrayIdsFromValue(val, hostId, ids, flags);
 res.ids.forEach(id=> ids.add(id));
 if(res.flags?.all) flags.all = true;
 }catch{}
 });
 if(flags.all) return { mode:'all', ids:[] };
 if(ids.size === 0 && Number.isFinite(hostId)) ids.add(Math.trunc(hostId));
 return { mode:'limit', ids: Array.from(ids) };
}
function parseArrayScopeArg(scopeArg, anchor, hostArr){
 const hostId = hostArr?.id ?? anchor?.arrId ?? null;
 if(scopeArg == null){
 const ids = Number.isFinite(hostId) ? [Math.trunc(hostId)] : [];
 return { mode:'host', ids };
 }
 if(scopeArg && typeof scopeArg === 'object' && scopeArg[ARRAY_SCOPE_TOKEN]){
 return normalizeScopeDescriptor(scopeArg, hostId) || { mode:'host', ids:Number.isFinite(hostId)?[Math.trunc(hostId)]:[] };
 }
 if(scopeArg.kind === 'ref' || scopeArg.kind === 'range'){
 return extractScopeFromArgs([scopeArg], anchor, hostId);
 }
 let val;
 try{ val = Formula.valOf(scopeArg); }catch{}
 if(val && typeof val === 'object' && val[ARRAY_SCOPE_TOKEN]){
 return normalizeScopeDescriptor(val, hostId) || { mode:'host', ids:Number.isFinite(hostId)?[Math.trunc(hostId)]:[] };
 }
 if(typeof val === 'string' && val.trim().toLowerCase() === 'all'){
 return { mode:'all', ids:[] };
 }
 const res = gatherArrayIdsFromValue(val, hostId);
 if(res.flags?.all) return { mode:'all', ids:[] };
 const ids = Array.from(res.ids||[]);
 if(ids.length === 0 && Number.isFinite(hostId)) ids.push(Math.trunc(hostId));
 if(ids.length === 1 && ids[0] === Math.trunc(hostId)) return { mode:'host', ids };
 return ids.length ? { mode:'limit', ids } : { mode:'host', ids:Number.isFinite(hostId)?[Math.trunc(hostId)]:[] };
}
function resolveArrayScopeTargets(hostArr, anchor, scopeArg){
 const scope = parseArrayScopeArg(scopeArg, anchor, hostArr);
 const arrays = Store.getState().arrays || {};
 let targets = [];
 if(scope.mode === 'all'){
 targets = Object.values(arrays).filter(Boolean);
 } else if(scope.mode === 'limit'){
 const uniq = new Set(scope.ids||[]);
 targets = Array.from(uniq).map(id=>arrays[id]).filter(Boolean);
 } else {
 if(hostArr) targets = [hostArr];
 }
 if(!targets.length && hostArr) targets = [hostArr];
 return { scope, targets };
}
function mutateCellMeta(tx, target, updater){
 if(!target) return;
 const coord = {x: target.x, y: target.y, z: target.z};
 const arrId = target.arrId;
 const existing = Formula.getCell({arrId, ...coord}) || { value:'', formula:null, meta:{} };
 const baseMeta = {...(existing.meta || {})};
 const nextMeta = normalizeMetaKeys(updater ? updater(baseMeta, existing) || baseMeta : baseMeta) || {};
 Write.set(tx, arrId, coord, {
 value: existing.value,
 formula: existing.formula,
 meta: nextMeta
 });
}
function parseVectorArg(arg){
 if(!arg) return null;
 const raw = Formula.valOf(arg);
 if(Array.isArray(raw)){
 const nums = raw.map(v=> Number(v));
 if(nums.length >= 3 && nums.every(n=> Number.isFinite(n))){
 return { x: nums[0], y: nums[1], z: nums[2] };
 }
 }
 if(typeof raw === 'string'){
 const vecMatch = raw.match(/@\s*\[\s*([\-0-9.]+)\s*,\s*([\-0-9.]+)\s*,\s*([\-0-9.]+)\s*(?:,\s*[\-0-9.]+\s*)?\]/);
 if(vecMatch){
 const [ , sx, sy, sz ] = vecMatch;
 const vx = parseFloat(sx), vy = parseFloat(sy), vz = parseFloat(sz);
 if([vx,vy,vz].every(n=> Number.isFinite(n))){
 return { x: vx, y: vy, z: vz };
 }
 }
 }
 if(typeof raw === 'object' && raw && Number.isFinite(raw.x) && Number.isFinite(raw.y) && Number.isFinite(raw.z)){
 return { x: Number(raw.x), y: Number(raw.y), z: Number(raw.z) };
 }
 return null;
}

function arrayScaleUnitsFromLevel(level){
 const lvl = Math.max(1, Math.round(Number(level)||1));
 return Math.pow(2, Math.max(0, lvl-1));
}

function arrayVoxelScale(arr){
 if(!arr || typeof arr !== 'object') return 1;
 const params = arr.params || {};
 const direct = Number(params.voxelScale);
 if(Number.isFinite(direct) && direct > 0) return direct;
 const level = Number(params.voxelScaleLevel);
 if(Number.isFinite(level) && level >= 1) return arrayScaleUnitsFromLevel(level);
 return 1;
}

const BASE_VOXEL_GEOMETRY_SIZE = 0.9;
const BASE_VOXEL_MARGIN = (1 - BASE_VOXEL_GEOMETRY_SIZE) / 2;

function voxelMargin(scale){
 if(!Number.isFinite(scale) || scale <= 0) return BASE_VOXEL_MARGIN;
 return Math.min(scale * BASE_VOXEL_MARGIN, BASE_VOXEL_MARGIN);
}

function clampedScaleOffset(scale, coefficient){
 if(!Number.isFinite(scale) || scale <= 0) return coefficient;
 return Math.min(scale * coefficient, coefficient);
}

function voxelDisplayScale(scale){
 if(!Number.isFinite(scale) || scale <= 0) return 1;
 const spacing = scale;
 const margin = voxelMargin(spacing);
 const width = Math.max(spacing - 2 * margin, spacing * BASE_VOXEL_GEOMETRY_SIZE);
 return width / BASE_VOXEL_GEOMETRY_SIZE;
}

function voxelHalfExtent(scale, cells=1){
 if(!Number.isFinite(scale) || scale <= 0) return (BASE_VOXEL_GEOMETRY_SIZE * cells) / 2;
 const spacing = scale;
 const margin = voxelMargin(spacing);
 const total = Math.max(cells * spacing - 2 * margin, cells * spacing * BASE_VOXEL_GEOMETRY_SIZE);
 return total / 2;
}

function avatarPerchOffset(scale){
 const half = voxelHalfExtent(scale, 1);
 const hover = clampedScaleOffset(scale, 0.25);
 return half + hover;
}
// helper: policy check with proper tag filtering
function isAllowed(arr, fnName){
 if(ALWAYS.has(fnName)) return true;
 const pol=arr.fnPolicy||{mode:'ALLOW_ALL', allow:new Set(), deny:new Set(), tags:new Set()};
 const fnTags = Fn[fnName]?.tags || new Set();

 if(pol.mode==='ALLOW_ONLY'){
 if(pol.allow?.has(fnName)) return true;
 if(pol.tags?.size && [...pol.tags].some(t => fnTags.has(t))) return true;
 return false;
 }
 // ALLOW_ALL with optional deny / tag filter
 if(pol.deny?.has(fnName)) return false;
 if(pol.tags?.size) return [...pol.tags].some(t => fnTags.has(t));
 return true;
}

// Utility tags (registered after policy init)
// 3D_TRANSLATE(target, dx, dy, dz[, originRef])
// - target: array id (number) or ref within target array; if ref, its arrId is used
// - dx,dy,dz: integer notch offsets (snap grid)
// - originRef: optional ref used only for semantic symmetry; translation is uniform so origin isn't needed, but kept for API parity
tag('3D_TRANSLATE',["SCENE"],(anchor,arr,ast)=>{
 // Args: target (arrId | ref | "@[x,y,z,id]" | SELF()), dx, dy, dz[, continuous]
 const targetArg = ast.args[0];
 const toInt = (a)=>{ try{ const v = Formula.valOf(a); const s = String(v==null? a : v); const n = parseFloat(s.replace(/[^0-9\-+.]/g,'')); return Number.isFinite(n)? (n|0) : 0; }catch{ return 0; } };
 const dx = toInt(ast.args[1]);
 const dy = toInt(ast.args[2]);
 const dz = toInt(ast.args[3]);
 const cont = !!toInt(ast.args[4]||0);

 const S = Store.getState();
 let targetArr = null;
 let queueAnchor = anchor; // default to the calling cell if no explicit ref provided

 if(targetArg && targetArg.kind==='ref'){
 targetArr = S.arrays[targetArg.arrId];
 queueAnchor = { x:targetArg.x, y:targetArg.y, z:targetArg.z, arrId: targetArg.arrId };
 } else {
 const raw = Formula.valOf(targetArg);
 // Try parsing absolute ref strings like SELF() => "@[x,y,z,id]"
 if(typeof raw === 'string'){
 try{
 const parsed = parseAlt(raw, anchor);
 if(parsed && S.arrays[parsed.arrId]){
 targetArr = S.arrays[parsed.arrId];
 queueAnchor = { x:parsed.x, y:parsed.y, z:parsed.z, arrId: parsed.arrId };
 }
 }catch{}
 }
 if(!targetArr){
 const id = +raw;
 if(Number.isFinite(id) && S.arrays[id]){
 targetArr = S.arrays[id];
 // If only an ID was provided, anchor defaults to A1a of the target for preview semantics
 queueAnchor = { x:0, y:0, z:0, arrId:id };
 }
 }
 }

 if(!targetArr){ Actions.setCell(arr.id, anchor, '!ERR:TARGET', ast.raw, true); return; }

 const ak = aKey(anchor);
 let existingTranslateRec = null;
 try{ existingTranslateRec = (S.activeTranslations||new Map()).get(ak); }catch{}

 // If PREVIEW is on (in-array or 3D), do not apply now; animation system will read formulas
 let timed = null; try{ if(typeof Scene!=='undefined' && Scene.ensureTimedState) timed = Scene.ensureTimedState(targetArr); }catch{}
 const G0 = (Store.getState().scene||{}).timed3D;
 if((timed && timed.previewInArray) || (G0 && G0.preview)){
 return;
 }

 // Immediate translation respecting docking/parentage (apply to group as a unit)
 const group = [...(S.dockGroups||new Map()).values()].find(g=>g.members.includes(targetArr.id));
 const ids = group
 ? (group.mode==='parent'
 ? [targetArr.id, ...group.members.filter(id=> id!==targetArr.id && group.members.indexOf(id) > group.members.indexOf(targetArr.id))]
 : [...group.members])
 : [targetArr.id];
 const arrays = ids.map(id=>S.arrays[id]).filter(Boolean);

 const cloneOffset=(src)=>({
 x: Number.isFinite(+src?.x) ? Math.round(+src.x) : 0,
 y: Number.isFinite(+src?.y) ? Math.round(+src.y) : 0,
 z: Number.isFinite(+src?.z) ? Math.round(+src.z) : 0
 });
 const captureBases=(list)=> list.map(a=>({ id:a.id, offset:cloneOffset(a.offset||{x:0,y:0,z:0}) }));

 let baseRecords=null;
 if(existingTranslateRec && !cont){
 const baseMap=new Map();
 if(Array.isArray(existingTranslateRec.bases)){
 existingTranslateRec.bases.forEach(entry=>{
 if(entry==null) return;
 const id=Number.isFinite(+entry.id)?(+entry.id|0):null;
 if(id==null) return;
 const src=entry.offset||entry.base||entry;
 baseMap.set(id, cloneOffset(src));
 });
 }
 if(existingTranslateRec.from){
 const base=cloneOffset(existingTranslateRec.from);
 const targetId=Number.isFinite(+existingTranslateRec.targetId)?(+existingTranslateRec.targetId|0):targetArr.id;
 if(!baseMap.has(targetId)) baseMap.set(targetId, base);
 }
 arrays.forEach(a=>{
 const base=baseMap.get(a.id);
 if(base){ Scene.setArrayOffset(a, base, {interactive:true, _skipDock:true, _skipConnections:true}); }
 });
 baseRecords=captureBases(arrays);
 } else if(existingTranslateRec && cont){
 if(Array.isArray(existingTranslateRec.bases) && existingTranslateRec.bases.length){
 baseRecords=existingTranslateRec.bases.map(entry=>({
 id:Number.isFinite(+entry.id)?(+entry.id|0):targetArr.id,
 offset:cloneOffset(entry.offset||entry.base||entry)
 }));
 } else {
 baseRecords=captureBases(arrays);
 if(existingTranslateRec.from){
 const base=cloneOffset(existingTranslateRec.from);
 const targetId=Number.isFinite(+existingTranslateRec.targetId)?(+existingTranslateRec.targetId|0):targetArr.id;
 baseRecords=baseRecords.map(rec=> rec.id===targetId ? {id:rec.id, offset:base} : rec);
 }
 }
 } else {
 baseRecords=captureBases(arrays);
 }

 arrays.forEach(a=>{
 const offA = a.offset||{x:0,y:0,z:0};
 const nextA = { x: Math.round((offA.x||0) + dx), y: Math.round((offA.y||0) + dy), z: Math.round((offA.z||0) + dz) };
 Scene.setArrayOffset(a, nextA, {interactive:true, _skipDock:true, _skipConnections:true});
 });
 try{
 arrays.forEach(a=>{
 if(!a) return;
 const timedLocal = a.params?.timed;
 if(timedLocal){
 timedLocal.baseOffset = { ...(a.offset||{x:0,y:0,z:0}) };
 if(a._frame && a._frame.quaternion){
 try{ timedLocal.baseQuat = a._frame.quaternion.clone(); }catch{}
 }
 }
 });
 }catch{}
 Actions.setCell(arr.id, anchor, `Moved:${dx},${dy},${dz}`, ast.raw, true);
 // Record for revert when this anchor's formula is cleared; suppress repeat execution
 try{
 const S=Store.getState();
 const map=new Map(S.activeTranslations||new Map());
 const basesCloned = (baseRecords||[]).map(rec=>({ id:rec.id, offset:{...rec.offset} }));
 const targetBase = basesCloned.find(rec=>rec.id===targetArr.id)?.offset || cloneOffset(targetArr.offset||{x:0,y:0,z:0});
 map.set(ak, { targetId: targetArr.id, from:{...targetBase}, delta:{dx,dy,dz}, bases:basesCloned });
 Store.setState({activeTranslations:map});
 // Persist revert info in meta so refresh can restore revert behavior
 const txw = Write.start('mark.3d.translate','mark');
 const cell = Formula.getCell(anchor) || {value:'',formula:null,meta:{}};
 Write.set(txw, arr.id, {x:anchor.x,y:anchor.y,z:anchor.z}, { value: cell.value, formula: cell.formula, meta:{...(cell.meta||{}), appliedTranslate:{ targetId: targetArr.id, from: targetBase, delta:{dx,dy,dz}, bases:basesCloned } } });
 Write.commit(txw);
 }catch{}
});
// 3D_ROTATE(targetOrPivot, stepsX[, stepsY[, stepsZ]])
// - First arg: array ID or cell address (pivot + derives array ID). If ID, pivot defaults to A1a.
// - If ref has no ^arrId, it uses the host array (anchor's array).
// - Rotates entire docked structure (Parent or All modes) atomically around the pivot.
tag('3D_ROTATE',["SCENE"],(anchor,arr,ast)=>{
 const targetArg = ast.args[0];
 const sx = ast.args[2]!==undefined ? ((+Formula.valOf(ast.args[1])|0) || 0) : ((+Formula.valOf(ast.args[1]||0)|0));
 const sy = ast.args[2]!==undefined ? ((+Formula.valOf(ast.args[2])|0) || 0) : 0;
 const sz = ast.args[3]!==undefined ? ((+Formula.valOf(ast.args[3])|0) || 0) : 0;

 const S=Store.getState();
 let targetId=null, pivotRef=null;
 if(targetArg && targetArg.kind==='ref'){
 targetId = targetArg.arrId ?? arr.id;
 pivotRef = {x:targetArg.x,y:targetArg.y,z:targetArg.z,arrId:targetId};
 } else if(targetArg!==undefined){
 const id=+Formula.valOf(targetArg); if(!isNaN(id)) targetId=id;
 }
 if(targetId==null) targetId = arr.id;
 const targetArr = S.arrays[targetId];
 if(!targetArr){ Actions.setCell(arr.id, anchor, '!ERR:TARGET', ast.raw, true); return; }
 // If no explicit pivot, default to A1a (0,0,0)
 if(!pivotRef) pivotRef={x:0,y:0,z:0,arrId:targetId};

 // Resolve dock group membership
 const group = [...(S.dockGroups||new Map()).values()].find(g=>g.members.includes(targetArr.id));
 const ids = group
 ? (group.mode==='parent'
 ? [targetArr.id, ...group.members.filter(id=> id!==targetArr.id && group.members.indexOf(id) > group.members.indexOf(targetArr.id))]
 : [...group.members])
 : [targetArr.id];
 const arrays = ids.map(id=>S.arrays[id]).filter(Boolean);
 const ak=aKey(anchor);

 let existingRotationRec=null;
 try{ existingRotationRec = (S.activeRotations||new Map()).get(ak); }catch{}
 if(existingRotationRec){
 const revertIds = Array.isArray(existingRotationRec.ids) && existingRotationRec.ids.length
 ? existingRotationRec.ids
 : [existingRotationRec.targetId ?? targetArr.id];
 const revertArrays = revertIds.map(id=>S.arrays[id]).filter(Boolean);
 revertArrays.forEach(a=>{ if(a && !a._frame) Scene.renderArray(a); });
 const pivotArrPrev = S.arrays[existingRotationRec.targetId] || targetArr;
 if(pivotArrPrev){
 const pivotPrev = Scene.cellWorldPos(pivotArrPrev, existingRotationRec.pivot?.x||0, existingRotationRec.pivot?.y||0, existingRotationRec.pivot?.z||0);
 revertArrays.forEach(a=> Scene.rotateArrayAround(a, pivotPrev, -(existingRotationRec.steps?.sx||0), -(existingRotationRec.steps?.sy||0), -(existingRotationRec.steps?.sz||0)));
 revertArrays.forEach(a=>{ if(a?._frame){ a.offset={ x:Math.round(a._frame.position.x), y:Math.round(a._frame.position.y), z:Math.round(a._frame.position.z) }; } });
 }
 }

 // Timed preview queue (in-array or 3D)
 const timed0 = (typeof Scene!=='undefined' && Scene.ensureTimedState) ? Scene.ensureTimedState(arr) : (arr.params&&arr.params.timed);
 const G0 = (typeof Scene!=='undefined' && Scene.ensureTimed3D) ? Scene.ensureTimed3D() : ((Store.getState().scene||{}).timed3D);
 if(timed0?.previewInArray || (G0&&G0.preview)){
 queueTimedOp(arr, pivotRef||anchor, { type:'rotate', sx, sy, sz });
 Actions.setCell(arr.id, anchor, `Queued:Rot ${sx},${sy},${sz}`,(ast.raw||`=3D_ROTATE(${sx},${sy},${sz})`));
 return;
 }
 // Ensure frames
 arrays.forEach(a=>{ if(!a._frame) Scene.renderArray(a); });
 // Compute pivot in world space at time of rotation
 const pivotWorld = Scene.cellWorldPos(targetArr, pivotRef.x, pivotRef.y, pivotRef.z);

 // Apply atomic rotation
 arrays.forEach(a=> Scene.rotateArrayAround(a, pivotWorld, sx, sy, sz));
 arrays.forEach(a=>{ if(a._frame){ a.offset={ x:Math.round(a._frame.position.x), y:Math.round(a._frame.position.y), z:Math.round(a._frame.position.z) }; }});
 try{
 arrays.forEach(a=>{
 if(!a) return;
 const timedLocal = a.params?.timed;
 if(timedLocal){
 timedLocal.baseOffset = { ...(a.offset||{x:0,y:0,z:0}) };
 if(a._frame && a._frame.quaternion){
 try{ timedLocal.baseQuat = a._frame.quaternion.clone(); }catch{}
 }
 }
 });
 }catch{}

 // Track for revert when this anchor formula is removed
 try{
 const rec={targetId:targetArr.id, ids:[...ids], pivot:{...pivotRef}, steps:{sx,sy,sz}};
 const map=new Map(S.activeRotations||new Map()); map.set(ak, rec); Store.setState({activeRotations:map});
 }catch{}

 Actions.setCell(arr.id, anchor, `3D_Rotate:${targetArr.id};${sx},${sy},${sz}`, ast.raw, true);
});

// Backward-compatible alias: ROTATE_ARRAY delegates to 3D_ROTATE
tag('ROTATE_ARRAY',["SCENE"],(anchor,arr,ast)=> Fn['3D_ROTATE'].impl(anchor,arr,ast));
tag('PRIORITY',['META'], (anchor,arr,ast)=>{
 const target = ast.args[0];
 const level = (+Formula.valOf(ast.args[1])|0) || 0;
 const mode = (String(Formula.valOf(ast.args[2]||'value')).toLowerCase()==='coord')?'coord':'value';
 const sort = (()=>{ try{ return JSON.parse(String(Formula.valOf(ast.args[3]||'{}'))||'{}'); }catch{ return {}; }})();

 const items=[]; const push=(x,y,z)=>items.push({x,y,z, arrId:target?.arrId ?? arr.id});
 if(target && target.kind==='range') target.cells.forEach(c=>push(c.x,c.y,c.z));
 else if(target && target.kind==='ref') push(target.x,target.y,target.z);
 else push(anchor.x,anchor.y,anchor.z);

 arr.priority = arr.priority || [];
 arr.priority.push({level, mode, sort, items});
});

tag('FORMULA_TEXT',['PURE'], (anchor,arr,ast)=>{
 const t = (ast.args[0] && ast.args[0].kind==='ref') ? ast.args[0] : anchor;
 const c = Formula.getCell({arrId:t.arrId||arr.id, x:t.x, y:t.y, z:t.z});
 const f = c?.formula ?? '';
 Actions.setCell(arr.id, anchor, f, ast.raw, true);
});

// CREATE(x,y,z[, "Name"[, "Id"]]) optional explicit ID supported
tag('CREATE',["ACTION"],(anchor,arr,ast)=>{
 try{
 const args = ast.args.map(a => Formula.valOf(a));

 let sx = 6, sy = 4, sz = 6, name = 'Array', explicitId = null;
 let argOffset = 0;

 if (args.length > 0 && typeof args[0] === 'string') {
 name = args[0];
 argOffset = 1;
 }

 if (args.length >= argOffset + 1 && Number.isFinite(+args[argOffset])) sx = Math.max(1, (+args[argOffset] | 0));
 if (args.length >= argOffset + 2 && Number.isFinite(+args[argOffset + 1])) sy = Math.max(1, (+args[argOffset + 1] | 0));
 if (args.length >= argOffset + 3 && Number.isFinite(+args[argOffset + 2])) sz = Math.max(1, (+args[argOffset + 2] | 0));

 if (argOffset === 0 && args.length >= 4) name = String(args[3]);
 const idArgIndex = 4;
 if (args.length > idArgIndex && args[idArgIndex] != null) {
 const n = +args[idArgIndex];
 if (Number.isFinite(n)) explicitId = Math.trunc(n);
 }

 const opts = { name, size: {x: sx, y: sy, z: sz} };
 if(explicitId !== null) opts.id = explicitId;

 const created = Actions.createArray(opts);
 if (!created) throw new Error('Array creation failed internally.');

 const host = arr, newArr = created, gap = 1.0;
 const hostOff = host.offset || {x:0, y:0, z:0};
 const newX = hostOff.x + (host.size.x / 2) + (newArr.size.x / 2) + gap;
 Scene.setArrayOffset(newArr, {x: newX, y: hostOff.y, z: hostOff.z});

 Actions.setCell(arr.id, anchor, created.id, null, true);

 } catch(e) {
 Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true);
 }
});

// GET_NEXT_ID(): returns the lowest available positive integer ID
tag('GET_NEXT_ID',["META","PURE"],(anchor,arr,ast)=>{
 const ids = Object.values(Store.getState().arrays).map(a=>a.id).filter(id=>Number.isInteger(id) && id>0);
 const sorted = [...new Set(ids)].sort((a,b)=>a-b);
 let next=1; for(const n of sorted){ if(n===next) next++; else if(n>next) break; }
 Actions.setCell(arr.id, anchor, next, ast.raw, true);
});
// FORMULIZE(targetRef): builds a kickoff DO formula capturing arrays reachable from target
tag('FORMULIZE',["META","ACTION"],(anchor,arr,ast)=>{
 try{
 const target = ast.args[0] && ast.args[0].kind==='ref' ? ast.args[0] : anchor;
 const startId = target.arrId || arr.id;
 const S = Store.getState();
 if(!S.arrays[startId]){ Actions.setCell(arr.id, anchor, '!ERR:TARGET', ast.raw, true); return; }
 // BFS through formulas to find referenced array IDs
 const q=[startId]; const seen=new Set([startId]);
 while(q.length){
 const id=q.shift(); const A=S.arrays[id]; if(!A) continue;
 Object.values(A.chunks).forEach(ch=>{
 ch.cells.forEach(cell=>{
 if(!cell.formula) return;
 const matches = cell.formula.match(/@\[(-?\d+),(-?\d+),(-?\d+),(-?\d+)\]/g) || [];
 matches.forEach(m=>{ const mm=m.match(/@\[(-?\d+),(-?\d+),(-?\d+),(-?\d+)\]/); const refId=+mm[4]; if(refId>0 && !seen.has(refId) && S.arrays[refId]){ seen.add(refId); q.push(refId);} });
 const carats = cell.formula.match(/\^[0-9]+/g) || [];
 carats.forEach(tk=>{ const refId=+(tk.slice(1)); if(refId>0 && !seen.has(refId) && S.arrays[refId]){ seen.add(refId); q.push(refId);} });
 });
 });
 }
 const ids = Array.from(seen).sort((a,b)=>a-b);
 const idMap = new Map(ids.map((id,i)=>[id, `temp.id_${i+1}`]));
 const esc=(s)=> String(s).replace(/"/g,'\\\"');
 const lines=[];
 // Reserve IDs
 ids.forEach(id=>{ const key=idMap.get(id); lines.push(`"=SET_GLOBAL(\\\"${key}\\\", GET_NEXT_ID())"`); });
 // CREATE arrays (with proper escaping inside outer string)
 ids.forEach(id=>{
 const A=S.arrays[id]; const nm=esc(A.name||'Array');
 const size=`${A.size.x}, ${A.size.y}, ${A.size.z}`;
 lines.push(`"=CREATE(${size}, \\\"${nm}\\\", GET_GLOBAL(\\\"${idMap.get(id)}\\\"))"`);
 });
 // Populate values and formulas efficiently by aggregating contiguous 3D blocks
 ids.forEach(id=>{
 const A=S.arrays[id];
 const idExpr = `GET_GLOBAL(\\\"${idMap.get(id)}\\\")`;
 // Build occupancy and value hash per cell
 const W=A.size.x,H=A.size.y,D=A.size.z;
 const occ=new Map(); // key x,y,z -> {v, f}
 Object.values(A.chunks).forEach(ch=>{ ch.cells.forEach(c=>{ const k=`${c.x},${c.y},${c.z}`; occ.set(k,{v:c.value,f:c.formula}); }); });
 const visited=new Set();
 const key=(x,y,z)=>`${x},${y},${z}`;
 const inb=(x,y,z)=> x>=0&&y>=0&&z>=0&&x<W&&y<H&&z<D;
 // Helper to emit a fill block via EXEC_AT to avoid dynamic A1^id refs
 const emitFill=(x1,y1,z1,x2,y2,z2,val)=>{
 const w=x2-x1+1,h=y2-y1+1,d=z2-z1+1;
 const v = typeof val==='string' ? `\"${esc(val)}\"` : `${val}`;
 // Use EXEC_AT with ARRAY("fill",...) at (x1,y1,z1) inside target array idExpr
 lines.push(`"=EXEC_AT(${x1},${y1},${z1}, ${idExpr}, \"=ARRAY(\\\"fill\\\", ${w}, ${h}, ${d}, ${v})\")"`);
 };
 // Greedy 3D block aggregation for identical scalar values
 for(let z=0;z<D;z++) for(let y=0;y<H;y++) for(let x=0;x<W;x++){
 const k=key(x,y,z); if(visited.has(k)) continue; const cell=occ.get(k)||{v:'',f:null};
 if(cell.f || cell.v==='' || cell.v===null || cell.v===undefined){ continue; }
 // grow in X
 let x2=x; while(inb(x2+1,y,z)){ const c=occ.get(key(x2+1,y,z))||{v:'',f:null}; if(visited.has(key(x2+1,y,z)) || c.f || c.v!==cell.v) break; x2++; }
 // grow in Y
 let y2=y; outerY: while(inb(x,y2+1,z)){
 for(let xi=x; xi<=x2; xi++){ const c=occ.get(key(xi,y2+1,z))||{v:'',f:null}; if(visited.has(key(xi,y2+1,z)) || c.f || c.v!==cell.v){ break outerY; } }
 y2++;
 }
 // grow in Z
 let z2=z; outerZ: while(inb(x,y,z2+1)){
 for(let yi=y; yi<=y2; yi++) for(let xi=x; xi<=x2; xi++){ const c=occ.get(key(xi,yi,z2+1))||{v:'',f:null}; if(visited.has(key(xi,yi,z2+1)) || c.f || c.v!==cell.v){ break outerZ; } }
 z2++;
 }
 // mark visited and emit
 for(let zz=z; zz<=z2; zz++) for(let yy=y; yy<=y2; yy++) for(let xx=x; xx<=x2; xx++) visited.add(key(xx,yy,zz));
 emitFill(x,y,z,x2,y2,z2,cell.v);
 }
 // Emit formulas with ID remapping using EXEC_AT for precise stamping
 Object.values(A.chunks).forEach(ch=>{
 ch.cells.forEach(c=>{
 if(!c.formula) return;
 let f=String(c.formula);
 ids.forEach(oldId=>{ const keyVar=idMap.get(oldId); f=f.replace(new RegExp(`\\^${oldId}\\b`,'g'), `^" & GET_GLOBAL(\\\"${keyVar}\\\") & "`); f=f.replace(new RegExp(`@\\[(-?\\d+),(-?\\d+),(-?\\d+),${oldId}\\]`,'g'), `@[" & $1 & "," & $2 & "," & $3 & "," & GET_GLOBAL(\\\"${keyVar}\\\") & "]`); });
 const tx = `=EXEC_AT(${c.x},${c.y},${c.z}, ${idExpr}, \"${esc(f)}\")`;
 lines.push(`"${tx}"`);
 });
 });
 // Set positions
 const off=A.offset||{x:0,y:0,z:0};
 lines.push(`"=SET_ARRAY_POS(${idExpr}, ${Math.round(off.x)}, ${Math.round(off.y)}, ${Math.round(off.z)})"`);
 });
 // Self cleanup
 lines.push(`"=SET(SELF(), \"\")"`);
 const out = `=DO(\n ${lines.join(',\n ')}\n)`;
 Actions.setCell(arr.id, anchor, out, ast.raw, true);
 }catch(e){ Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true); }
});

// SPLIT(text, delimiter[, splitByEach]) -> array of tokens (vertical list starting at anchor)
tag('SPLIT',['PURE','BLOCK'], (anchor,arr,ast,tx)=>{
 if(!tx) throw new Error('SPLIT requires active transaction');
 const text = String(Formula.valOf(ast.args[0] ?? ''));
 const delimRaw = Formula.valOf(ast.args[1] ?? '');
 const splitByEach = !!Formula.valOf(ast.args[2] ?? 0);
 const delims = String(delimRaw);
 let parts;
 if(splitByEach){
 const re = new RegExp(`[${delims.replace(/[.*+?^${}()|[\]\\]/g,'\\$&')}]`, 'g');
 parts = text.split(re);
 } else {
 parts = delims==='' ? [text] : text.split(delims);
 }
 for(let i=0;i<parts.length;i++){
 Write.set(tx, arr.id, {x:anchor.x, y:anchor.y-i, z:anchor.z}, { value: parts[i], formula: i===0?ast.raw:null, meta:{generated:true, emitter:aKey(anchor)} });
 }
});
// INDEX(rangeOrRef, row[, col[, depth]]) 1-based; supports 3D offsets
tag('INDEX',['PURE'], (anchor,arr,ast)=>{
 const tgt = ast.args[0];
 const r = (+Formula.valOf(ast.args[1])|0) || 1;
 const c = (+Formula.valOf(ast.args[2])|0) || 1;
 const d = ast.args[3]!==undefined ? ((+Formula.valOf(ast.args[3])|0) || 1) : 1;
 let ref;
 if(tgt && tgt.kind==='range'){
 const xs=[...new Set(tgt.cells.map(t=>t.x))].sort((a,b)=>a-b);
 const ys=[...new Set(tgt.cells.map(t=>t.y))].sort((a,b)=>a-b);
 const zs=[...new Set(tgt.cells.map(t=>t.z))].sort((a,b)=>a-b);
 const x=xs[Math.min(xs.length-1, Math.max(0, c-1))];
 const y=ys[Math.min(ys.length-1, Math.max(0, r-1))];
 const z=zs[Math.min(zs.length-1, Math.max(0, d-1))];
 ref = {x,y,z,arrId:tgt.cells[0].arrId,kind:'ref'};
 } else if(tgt && tgt.kind==='ref'){
 ref = {x:tgt.x+(c-1), y:tgt.y+(r-1), z:tgt.z+(d-1), arrId:tgt.arrId, kind:'ref'};
 } else {
 ref = anchor;
 }
 const v = Formula.getCellValue(ref);
 Actions.setCell(arr.id, anchor, v, ast.raw, true);
});

// MATCH(lookup, range[, matchType]) returns 1-based position along linearized order
tag('MATCH',['PURE'], (anchor,arr,ast)=>{
 const lookup = Formula.valOf(ast.args[0]);
 const tgt = ast.args[1];
 const matchType = (+Formula.valOf(ast.args[2] ?? 0))|0; // 0 exact
 let cells = [];
 if(tgt && tgt.kind==='range') cells = tgt.cells;
 else if(tgt && tgt.kind==='ref') cells = [{x:tgt.x,y:tgt.y,z:tgt.z,arrId:tgt.arrId}];
 let pos = 0;
 for(let i=0;i<cells.length;i++){
 const v = Formula.getCellValue(cells[i]);
 if(matchType===0){ if(String(v)===String(lookup)){ pos=i+1; break; } }
 else { const nv=(+v)||0, nl=(+lookup)||0; if((matchType>0 && nv<=nl) || (matchType<0 && nv>=nl)){ pos=i+1; } }
 }
 Actions.setCell(arr.id, anchor, pos, ast.raw, true);
});

// XLOOKUP(lookup, rangeKeys, rangeVals[, ifNotFound])
tag('XLOOKUP',['PURE'], (anchor,arr,ast)=>{
 const lookup = Formula.valOf(ast.args[0]);
 const keys = ast.args[1];
 const vals = ast.args[2];
 const ifNotFound = ast.args[3]!==undefined ? Formula.valOf(ast.args[3]) : '';
 const toList=(arg)=> (arg && arg.kind==='range') ? arg.cells : (arg && arg.kind==='ref') ? [arg] : [];
 const keyCells = toList(keys);
 const valCells = toList(vals);
 let out = ifNotFound;
 for(let i=0;i<keyCells.length;i++){
 if(String(Formula.getCellValue(keyCells[i]))===String(lookup)){
 const vc = valCells[i] || valCells[0];
 out = vc ? Formula.getCellValue(vc) : ifNotFound;
 break;
 }
 }
 Actions.setCell(arr.id, anchor, out, ast.raw, true);
});

// Matrix utilities + TRANSPOSE
function toMatrix(anchor, arr, arg){
 const val=(r)=> Formula.getCellValue({arrId:r.arrId||arr.id,x:r.x,y:r.y,z:r.z});
 try{
 if(arg && arg.kind==='range'){
 const cells=arg.cells||[]; if(cells.length===0) return [[""]];
 const xs=[...new Set(cells.map(c=>c.x))].sort((a,b)=>a-b);
 const ys=[...new Set(cells.map(c=>c.y))].sort((a,b)=>a-b);
 const z0=cells[0].z; const map=new Map();
 cells.forEach(c=>{ if(c.z===z0) map.set(`${c.x},${c.y}`, val(c)); });
 const M=[]; for(let yi=0; yi<ys.length; yi++){ const row=[]; for(let xi=0; xi<xs.length; xi++){ const k=`${xs[xi]},${ys[yi]}`; row.push(map.has(k)? map.get(k) : ""); } M.push(row);} return M;
 }
 if(arg && arg.kind==='ref') return [[ val(arg) ]];
 if(arg && arg.type==='FunctionCall' && String(arg.name||'').toUpperCase()==='ARRAY'){
 const mode= String(Formula.valOf(arg.arguments[0]||'list')||'list').toLowerCase();
 if(mode==='list'){ const items = arg.arguments.slice(1).map(a=> Formula.valOf(a)); return items.map(v=>[v]); }
 if(mode==='fill'){ const w=(+Formula.valOf(arg.arguments[1]||1))|0, h=(+Formula.valOf(arg.arguments[2]||1))|0; const v=Formula.valOf(arg.arguments[4]||""); const M=[]; for(let y=0;y<Math.max(1,h);y++){ const row=[]; for(let x=0;x<Math.max(1,w);x++) row.push(v); M.push(row);} return M; }
 return [[ String(Formula.valOf(arg.arguments[1]||'')) ]];
 }
 const maybeId=+Formula.valOf(arg);
 if(Number.isFinite(maybeId)){
 const A=Store.getState().arrays[maybeId]; if(A){ const z=Math.max(0,Math.min(A.size.z-1,anchor.z|0)); const M=[]; for(let y=0;y<A.size.y;y++){ const row=[]; for(let x=0;x<A.size.x;x++){ row.push(Formula.getCellValue({arrId:A.id,x,y,z})); } M.push(row);} return M; }
 }
 }catch{}
 return [[ Formula.valOf(arg) ]];
}

console.log('Registering TRANSPOSE function...');
tag('TRANSPOSE',['PURE','BLOCK'], (anchor,arr,ast,tx)=>{
 const __ownsTx = !tx; if(__ownsTx) tx = Write.start('transpose.auto','TRANSPOSE');
 console.log('=== TRANSPOSE DEBUG START ===');
 console.log('TRANSPOSE called with:', {
 anchor: `${anchor.x},${anchor.y},${anchor.z}`,
 arrayId: arr.id,
 astRaw: ast.raw,
 astFn: ast.fn,
 astArgs: ast.args,
 argCount: ast.args?.length,
 hasTx: !!tx,
 ownsTx: __ownsTx
 });
 // Debug: check if we have _astArgs (raw AST arguments)
 if(ast._astArgs) console.log('Raw AST args:', ast._astArgs);
 try{
 // Clear previously emitted cells from this anchor
 const S=Store.getState(); const ak=aKey(anchor);
 const prev=S.emittedByAnchor?.get?.(ak);
 if(prev){
 prev.forEach(ck=>{ try{ const [aid,rest]=ck.split(':'); const [cx,cy,cz]=rest.split(',').map(Number); Write.set(tx,+aid,{x:cx,y:cy,z:cz},{ value:'', formula:null, meta:{} }); S.sourceByCell?.delete?.(ck); }catch{} });
 S.emittedByAnchor?.delete?.(ak);
 }

 // Track emissions for proper cleanup and visuals
 const emitted = new Set();
 const recordEmit = (x,y,z)=>{ const ck=`${arr.id}:${x},${y},${z}`; emitted.add(ck); if(!S.sourceByCell) S.sourceByCell=new Map(); S.sourceByCell.set(ck,ak); };
 // Ensure array can hold target then write & record
 const ensureAndWrite = (x,y,z,v,isAnchorWrite)=>{
 if(z<0){ try{ Actions.expandZFront?.(arr, -z); }catch{} }
 try{ Actions.resizeArrayIfNeeded(arr, {x,y,z}); }catch{}
 const isAnchor=(x===anchor.x && y===anchor.y && z===anchor.z);
 if(!isAnchor || isAnchorWrite){
 Write.set(tx, arr.id, {x,y,z}, { value:v, formula:(isAnchor?ast.raw:null), meta:{generated:true, emitter:ak} });
 recordEmit(x,y,z);
 }
 };

 // Check if we have any arguments
 if(!ast.args || ast.args.length === 0){
 console.log('No arguments provided to TRANSPOSE, trying to parse raw formula');
 // Try to parse the raw formula string as fallback
 const raw = ast.raw || '';
 const match = raw.match(/transpose\s*\(\s*(.+)\s*\)/i);
 if(match){
 const argStr = match[1];
 console.log('Found raw argument string:', argStr);
 // Try to parse ARRAY(...) from string
 const arrayMatch = argStr.match(/array\s*\(\s*(.+)\s*\)/i);
 if(arrayMatch){
 const arrayContent = arrayMatch[1];
 console.log('Found ARRAY content:', arrayContent);
 // Split by comma and evaluate each part
 const parts = arrayContent.split(',').map(s => s.trim());
 console.log('ARRAY parts:', parts);
 const values = parts.map(p => {
 // Remove quotes if present
 const clean = p.replace(/^["']|["']$/g, '');
 const num = +clean;
 return Number.isNaN(num) ? clean : num;
 });
 console.log('Parsed values:', values);
 // Create column matrix
 const M = values.map(v => [v]);
 console.log('Created matrix from raw parsing:', M);
 
 // Skip to transpose logic
 const H=M.length; const W=M[0].length;
 console.log('Raw parse matrix dimensions:', {H, W, M});
 
 // Optional axis & dir 
 const axis = 0; // default XY
 const dir = 0; // default positive
 
 // The destination matrix has dimensions WxH (transpose)
 for(let r=0;r<W;r++){
 for(let c=0;c<H;c++){
 const v=(M[c]&&M[c][r]!==undefined)?M[c][r]:"";
 
 let txX=anchor.x + (dir ? -c : c);
 let txY=anchor.y + r; 
 let txZ=anchor.z;
 
 console.log(`Raw parse writing cell [${r},${c}]: value="${v}" to (${txX},${txY},${txZ})`);
 ensureAndWrite(txX,txY,txZ, v, (r===0&&c===0));
 }
 }
 
 // Record all emissions for cleanup
 if(emitted.size > 0){
 if(!S.emittedByAnchor) S.emittedByAnchor = new Map();
 S.emittedByAnchor.set(ak, emitted);
 }
 
 console.log('Raw parse TRANSPOSE completed, emitted:', emitted.size, 'cells');
 if(__ownsTx) Write.commit(tx);
 return;
 }
 }
 
 Write.set(tx, arr.id, anchor, { value: '!ERR:TRANSPOSE needs an argument', formula: ast.raw, meta: { emitter: ak } });
 if(__ownsTx) Write.commit(tx);
 return;
 }

 // Try to get matrix from input - handle both ranges and ARRAY() calls
 let M = null;
 let srcArg = ast.args[0];
 console.log('srcArg from ast.args[0]:', srcArg);
 
 // If ast.args[0] is undefined but we have _astArgs, use that instead
 if(!srcArg && ast._astArgs && ast._astArgs.length > 0) {
 srcArg = ast._astArgs[0];
 console.log('Using _astArgs[0] instead:', srcArg);
 }
 
 console.log('Final srcArg:', srcArg);
 
 // First try the toMatrix helper
 try { M = toMatrix(anchor,arr,srcArg); console.log('toMatrix result:', M); } catch(e){ console.log('toMatrix failed:', e); }
 
 // If that fails, handle ARRAY() calls manually
 // Also check for [object Object] which indicates toMatrix failed to parse the AST
 const isEmptyOrBadMatrix = !M || M.length === 0 || 
 (M.length === 1 && M[0].length === 1 && (M[0][0] === '' || String(M[0][0]).includes('[object Object]')));
 
 if(isEmptyOrBadMatrix) {
 console.log('toMatrix failed, trying manual parsing');
 // Check for AST-style ARRAY call
 if(srcArg && (srcArg.type === 'FunctionCall' || srcArg.fn) && String(srcArg.name || srcArg.fn || '').toUpperCase()==='ARRAY'){
 try{
 console.log('Handling ARRAY() call, srcArg:', srcArg);
 // Handle both AST-style (srcArg.arguments) and legacy-style (srcArg.args)
 const argList = srcArg.arguments || srcArg.args || [];
 console.log('ARRAY argList:', argList);
 const values = argList.map(a=> {
 // Handle different argument formats
 if(a && typeof a === 'object' && 'value' in a) return a.value;
 if(a && typeof a === 'object' && a.type === 'Literal') return a.value;
 return Formula.valOf(a);
 });
 console.log('ARRAY values:', values);
 M = values.map(v => [v]); // Convert to column matrix
 console.log('Created matrix:', M);
 }catch(e){ console.log('ARRAY parsing failed:', e); }
 } else if(srcArg && srcArg.kind==='range'){
 console.log('Handling range directly');
 // Handle range directly
 const cells = srcArg.cells||[];
 if(cells.length > 0){
 const xs=[...new Set(cells.map(c=>c.x))].sort((a,b)=>a-b);
 const ys=[...new Set(cells.map(c=>c.y))].sort((a,b)=>a-b);
 const z0=cells[0].z; const map=new Map();
 cells.forEach(c=>{ if(c.z===z0) map.set(`${c.x},${c.y}`, Formula.getCellValue({arrId:c.arrId||arr.id,x:c.x,y:c.y,z:c.z})); });
 M=[]; for(let yi=0; yi<ys.length; yi++){ const row=[]; for(let xi=0; xi<xs.length; xi++){ const k=`${xs[xi]},${ys[yi]}`; row.push(map.has(k)? map.get(k) : ""); } M.push(row);}
 console.log('Range matrix:', M);
 }
 } else {
 console.log('Fallback: treating as single value');
 const val = Formula.valOf(srcArg);
 M = [[val]];
 console.log('Single value matrix:', M);
 }
 }

 if (!M || M.length === 0 || M[0].length === 0) {
 console.log('No valid matrix, stamping anchor with empty value');
 // If still no valid input, stamp anchor with formula and empty value
 Write.set(tx, arr.id, anchor, { value: '', formula: ast.raw, meta: { emitter: ak } });
 if(__ownsTx) Write.commit(tx);
 return;
 }
 
 const H=M.length; const W=M[0].length;
 console.log('Final matrix dimensions:', {H, W, M});

 // Optional axis & dir - check both legacy args and _astArgs
 let axisRaw = 0, dirRaw = 0;
 if(ast.args && ast.args[1] !== undefined) {
 axisRaw = Formula.valOf(ast.args[1]);
 } else if(ast._astArgs && ast._astArgs[1]) {
 axisRaw = Formula.valOf(ast._astArgs[1]);
 }
 if(ast.args && ast.args[2] !== undefined) {
 dirRaw = Formula.valOf(ast.args[2]);
 } else if(ast._astArgs && ast._astArgs[2]) {
 dirRaw = Formula.valOf(ast._astArgs[2]);
 }
 
 const axisStr = String(axisRaw||'0').toUpperCase();
 // Axis: 0=XY (swap X<->Y, default), 1=XZ (swap X<->Z), 2=YZ (swap Y<->Z)
 const axis = (axisStr==='XY'||axisStr==='0') ? 0 : (axisStr==='XZ'||axisStr==='1') ? 1 : (axisStr==='YZ'||axisStr==='2') ? 2 : (+axisStr|0);
 // Direction: 0 positive (default), 1 negative (reversed)
 const dir = ((+dirRaw|0)===1) ? 1 : 0;
 console.log('Transpose params:', {axisRaw, dirRaw, axis, dir});

 // The destination matrix has dimensions WxH (transpose)
 for(let r=0;r<W;r++){ // r = destination row index (0 to W-1)
 for(let c=0;c<H;c++){ // c = destination col index (0 to H-1)
 const v=(M[c]&&M[c][r]!==undefined)?M[c][r]:""; // Value from source matrix at (row c, col r)

 let txX=anchor.x, txY=anchor.y, txZ=anchor.z;

 if(axis===0){ // XY: X <- c, Y <- r
 txX = anchor.x + (dir ? -c : c);
 txY = anchor.y + r;
 txZ = anchor.z;
 } else if(axis===1){ // XZ: X <- r, Z from anchor moving opposite when reversed
 txX = anchor.x + r;
 txY = anchor.y;
 txZ = dir ? (anchor.z - r) : (anchor.z + r);
 } else { // YZ: Y <- r, Z from anchor moving opposite when reversed
 txX = anchor.x;
 txY = anchor.y + r;
 txZ = dir ? (anchor.z - r) : (anchor.z + r);
 }
 
 console.log(`Writing cell [${r},${c}]: value="${v}" to (${txX},${txY},${txZ})`);
 // Write cell. Formula is only on the anchor cell itself.
 ensureAndWrite(txX,txY,txZ, v, (r===0&&c===0));
 }
 }
 
 // Record all emissions for cleanup
 if(emitted.size > 0){
 if(!S.emittedByAnchor) S.emittedByAnchor = new Map();
 S.emittedByAnchor.set(ak, emitted);
 }
 
 console.log('TRANSPOSE completed, emitted:', emitted.size, 'cells');
 if(__ownsTx) {
 console.log('Committing transaction');
 Write.commit(tx);
 }
 console.log('=== TRANSPOSE DEBUG END ===');
 }catch(e){ 
 console.error('TRANSPOSE error:', e); 
 console.log('=== TRANSPOSE DEBUG END (ERROR) ===');
 Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true); 
 }
});

/* ===========================
 Formula Parser v2.0 - Lexer/Parser/AST System
=========================== */
// Token types for the lexer
const TokenTypes = {
 ILLEGAL: 'ILLEGAL',
 EOF: 'EOF',
 NUMBER: 'NUMBER',
 STRING: 'STRING',
 IDENTIFIER: 'IDENTIFIER',
 CELL_REF: 'CELL_REF', // A1a, B2 ^1
 RANGE_REF: 'RANGE_REF', // @[0,0,0,1]
 EQUALS: '=',
 LPAREN: '(',
 RPAREN: ')',
 COMMA: ',',
 COLON: ':',
 LBRACE: '{',
 RBRACE: '}',
 SEMICOLON: ';'
};
// Lexer: converts formula text into tokens
class FormulaLexer {
 constructor(input) {
 this.input = input;
 this.position = 0;
 this.readPosition = 0;
 this.ch = '';
 this.readChar();
 }

 readChar() {
 if (this.readPosition >= this.input.length) {
 this.ch = null;
 } else {
 this.ch = this.input[this.readPosition];
 }
 this.position = this.readPosition;
 this.readPosition += 1;
 }

 peekChar() {
 if (this.readPosition >= this.input.length) {
 return null;
 }
 return this.input[this.readPosition];
 }

 nextToken() {
 this.skipWhitespace();
 let tok;

 switch (this.ch) {
 case '=': tok = { type: TokenTypes.EQUALS, value: this.ch }; break;
 case '(': tok = { type: TokenTypes.LPAREN, value: this.ch }; break;
 case ')': tok = { type: TokenTypes.RPAREN, value: this.ch }; break;
 case ',': tok = { type: TokenTypes.COMMA, value: this.ch }; break;
 case ':': tok = { type: TokenTypes.COLON, value: this.ch }; break;
 case '{': tok = { type: TokenTypes.LBRACE, value: this.ch }; break;
 case '}': tok = { type: TokenTypes.RBRACE, value: this.ch }; break;
 case ';': tok = { type: TokenTypes.SEMICOLON, value: this.ch }; break;
 case '"':
 tok = { type: TokenTypes.STRING, value: this.readString() };
 break;
 case '`':
 tok = { type: TokenTypes.STRING, value: this.readRawString('`') };
 break;
 case '<':
 if (this.peekSequence('<<<')) {
 tok = { type: TokenTypes.STRING, value: this.readHeredoc() };
 return tok;
 }
 tok = { type: TokenTypes.ILLEGAL, value: this.ch };
 break;
 case '@':
 tok = { type: TokenTypes.RANGE_REF, value: this.readRangeRef() };
 break;
 case null:
 tok = { type: TokenTypes.EOF, value: "" };
 break;
 default:
 if (this.isLetter(this.ch)) {
 const literal = this.readIdentifier();
 // After reading letters, current char holds the next symbol
 if (this.isDigit(this.ch)) {
 const number = this.readNumber();
const greek = 'αβγδεζηθικλμνξοπρστυφχψω';
 let greekChar = '';
 let arrayId = '';
 // Greek Z-suffix at current char
 if (this.ch && greek.includes(this.ch)) {
 const g = this.ch; this.readChar(); greekChar = g;
 }
 // Array id suffix ^n at current char
 if (this.ch === '^') {
 this.readChar();
 arrayId = '^' + this.readNumber();
 }
 tok = { type: TokenTypes.CELL_REF, value: literal + number + greekChar + arrayId };
 } else {
 tok = { type: TokenTypes.IDENTIFIER, value: literal };
 }
 return tok;
 } else if (this.isDigit(this.ch)) {
 // Support identifiers that start with a digit when followed by letters/underscore (e.g., 3D_TRANSLATE)
 const start = this.position;
 let i = this.position; let hasAlpha=false; let ch=this.input[i];
 while (ch && ((ch>='a'&&ch<='z')||(ch>='A'&&ch<='Z')||(ch>='0'&&ch<='9')||ch==='_' )){ if((ch>='a'&&ch<='z')||(ch>='A'&&ch<='Z')||ch==='_') hasAlpha=true; i++; ch=this.input[i]; }
 if(hasAlpha){
 // consume to i
 while(this.position < i) this.readChar();
 tok = { type: TokenTypes.IDENTIFIER, value: this.input.substring(start, i) };
 } else {
 tok = { type: TokenTypes.NUMBER, value: this.readNumber() };
 }
 return tok;
 } else {
 tok = { type: TokenTypes.ILLEGAL, value: this.ch };
 }
 }

 this.readChar();
 return tok;
 }

 readString() {
 // Consume characters until the matching quote, honoring backslash escapes
 let out = '';
 // Start after opening quote
 while (true) {
 this.readChar();
 if (this.ch === null) {
 break;
 }
 if (this.ch === '"') {
 // End of string token
 break;
 }
 if (this.ch === '\\') {
 const next = this.peekChar();
 if (next === null) { out += '\\'; continue; }
 this.readChar();
 switch (this.ch) {
 case 'n': out += '\n'; break;
 case 'r': out += '\r'; break;
 case 't': out += '\t'; break;
 case '"': out += '"'; break;
 case '\\': out += '\\'; break;
 default: out += this.ch; break;
 }
 continue;
 }
 out += this.ch;
 }
 return out;
 }

 readRawString(delimiter) {
 let out = '';
 while (true) {
 this.readChar();
 if (this.ch === null) break;
 if (this.ch === delimiter) break;
 out += this.ch;
 }
 return out;
 }

 readHeredoc() {
 const start = this.position + 3;
 const end = this.input.indexOf('>>>', start);
 const value = end === -1 ? this.input.slice(start) : this.input.slice(start, end);
 const after = end === -1 ? this.input.length : end + 3;
 if (after >= this.input.length) {
 this.position = this.input.length;
 this.readPosition = this.input.length;
 this.ch = null;
 } else {
 this.position = after;
 this.ch = this.input[this.position];
 this.readPosition = this.position + 1;
 }
 return value;
 }

 peekSequence(seq) {
 if (!seq || !seq.length) return false;
 return this.input.substr(this.position, seq.length) === seq;
 }

 readIdentifier() {
 const position = this.position;
 while (this.isLetter(this.ch) || this.ch === '_') {
 this.readChar();
 }
 return this.input.substring(position, this.position);
 }
 
 readNumber() {
 const position = this.position;
 while (this.isDigit(this.ch) || this.ch === '.') {
 this.readChar();
 }
 return this.input.substring(position, this.position);
 }

 readRangeRef() {
 const position = this.position;
 while (this.ch !== null && this.ch !== ']') {
 this.readChar();
 }
 if (this.ch === ']') this.readChar(); // consume ']'
 return this.input.substring(position, this.position);
 }

 isLetter(ch) {
 return ch && (('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z'));
 }

 isDigit(ch) {
 return ch && ('0' <= ch && ch <= '9');
 }
 skipWhitespace() {
 while (this.ch === ' ' || this.ch === '\t' || this.ch === '\n' || this.ch === '\r') {
 this.readChar();
 }
 }
}
// Parser: converts tokens into Abstract Syntax Tree
class FormulaParser {
 constructor(lexer, anchor) {
 this.lexer = lexer;
 this.anchor = anchor;
 this.errors = [];
 this.currentToken = null;
 this.peekToken = null;
 this.nextToken();
 this.nextToken();
 }

 nextToken() {
 this.currentToken = this.peekToken;
 this.peekToken = this.lexer.nextToken();
 }

 parseFormula() {
 if (this.currentToken.type !== TokenTypes.EQUALS) {
 return {
 type: 'Literal',
 value: this.lexer.input
 };
 }
 this.nextToken(); // consume '='
 return this.parseExpression();
 }

 parseExpression() {
 // Function call when IDENTIFIER followed by '('
 if (this.currentToken.type === TokenTypes.IDENTIFIER && this.peekToken.type === TokenTypes.LPAREN) {
 return this.parseFunctionCall();
 }
 if (this.currentToken.type === TokenTypes.IDENTIFIER && this.peekToken.type === TokenTypes.LBRACE) {
 const name = this.currentToken.value.toUpperCase();
 if (name === 'DO' || name === 'SEQ') {
 return this.parseFunctionBlockCall(name);
 }
 }
 // Otherwise parse primary (numbers, strings, refs, identifiers)
 return this.parsePrimary();
 }

 parseFunctionCall() {
 const node = {
 type: 'FunctionCall',
 name: this.currentToken.value.toUpperCase(),
 arguments: [],
 raw: this.lexer.input
 };
 this.nextToken(); // consume IDENTIFIER
 this.nextToken(); // consume '('
 // currentToken now points at first arg token or ')'
 node.arguments = this.parseArgumentList();
 // Recovery: advance until ')' if not currently on ')'
 if (this.currentToken.type !== TokenTypes.RPAREN) {
 while (this.currentToken && this.currentToken.type !== TokenTypes.RPAREN && this.currentToken.type !== TokenTypes.EOF) {
 this.nextToken();
 }
 if (this.currentToken.type !== TokenTypes.RPAREN) {
 this.errors.push(`Expected ')', got ${this.currentToken ? this.currentToken.type : 'EOF'}`);
 return null;
 }
 }
 this.nextToken(); // consume ')'
 return node;
 }

 parseFunctionBlockCall(name) {
 const node = {
 type: 'FunctionCall',
 name,
 arguments: [],
 raw: this.lexer.input,
 block: true,
 withOptions: null
 };
 this.nextToken(); // consume IDENTIFIER
 this.nextToken(); // consume '{'
 node.arguments = this.parseActionBlock();
 if (this.currentToken.type !== TokenTypes.RBRACE) {
 this.errors.push(`Expected '}', got ${this.currentToken ? this.currentToken.type : 'EOF'}`);
 } else {
 this.nextToken(); // consume '}'
 }
 if (this.currentToken && this.currentToken.type === TokenTypes.IDENTIFIER && this.currentToken.value.toUpperCase() === 'WITH') {
 this.nextToken(); // consume WITH
 node.withOptions = this.parseWithOptions();
 }
 return node;
 }

 parseActionBlock() {
 const statements = [];
 while (this.currentToken && this.currentToken.type !== TokenTypes.RBRACE && this.currentToken.type !== TokenTypes.EOF) {
 if (this.currentToken.type === TokenTypes.SEMICOLON) {
 this.nextToken();
 continue;
 }
 const stmt = this.parseExpression();
 if (stmt) statements.push(stmt);
 if (this.currentToken && this.currentToken.type === TokenTypes.SEMICOLON) {
 this.nextToken();
 }
 }
 return statements;
 }

 parseWithOptions() {
 const opts = {};
 while (this.currentToken && this.currentToken.type !== TokenTypes.EOF) {
 if (this.currentToken.type !== TokenTypes.IDENTIFIER) break;
 const key = this.currentToken.value;
 this.nextToken();
 if (this.currentToken && this.currentToken.type === TokenTypes.COLON) {
 this.nextToken();
 }
 const value = this.parseExpression();
 if (value !== undefined) opts[key] = value;
 if (this.currentToken && this.currentToken.type === TokenTypes.COMMA) {
 this.nextToken();
 continue;
 }
 break;
 }
 return opts;
 }
 parseArgumentList() {
 const args = [];
 // Handle empty argument list
 if (this.currentToken.type === TokenTypes.RPAREN) {
 return args;
 }

 while (this.currentToken && this.currentToken.type !== TokenTypes.RPAREN && this.currentToken.type !== TokenTypes.EOF) {
 const expr = this.parseExpression();
 if (expr !== undefined && expr !== null) args.push(expr);
 if (this.currentToken && this.currentToken.type === TokenTypes.COMMA) {
 this.nextToken();
 continue;
 }
 if (this.currentToken && this.currentToken.type === TokenTypes.RPAREN) break;
 // If the current token is neither comma nor RPAREN, parser will let parseExpression advance or we break for recovery
 if (this.currentToken && this.currentToken.type !== TokenTypes.COMMA) {
 break;
 }
 }
 return args;
 }

 parsePrimary() {
 switch (this.currentToken.type) {
 case TokenTypes.LPAREN:
 // Grouping: ( expr )
 this.nextToken();
 const inner = this.parseExpression();
 if (this.currentToken.type !== TokenTypes.RPAREN) {
 // Recover by advancing until ')'
 while (this.currentToken && this.currentToken.type !== TokenTypes.RPAREN && this.currentToken.type !== TokenTypes.EOF) {
 this.nextToken();
 }
 }
 if (this.currentToken.type === TokenTypes.RPAREN) this.nextToken();
 return inner;
 case TokenTypes.NUMBER:
 const num = parseFloat(this.currentToken.value);
 this.nextToken();
 return { type: 'Number', value: num };
 case TokenTypes.STRING:
 // String literals may contain embedded quotes and parentheses intended for downstream eval
 // Allow nested function-like strings e.g., "=EXEC_AT(..., \"=ssr()\")"
 const str = this.currentToken.value;
 this.nextToken();
 return { type: 'String', value: str };
 case TokenTypes.CELL_REF:
 const cellRef = this.parseCellRef(this.currentToken.value);
 this.nextToken();
 // Check for range syntax (A1:B2)
 if (this.currentToken && this.currentToken.type === TokenTypes.COLON) {
 this.nextToken(); // consume ':'
 if (this.currentToken.type === TokenTypes.CELL_REF) {
 const endRef = this.parseCellRef(this.currentToken.value);
 this.nextToken();
 return { type: 'Range', start: cellRef, end: endRef, kind: 'range' };
 }
 }
 return { type: 'CellRef', ...cellRef, kind: 'ref' };
 case TokenTypes.RANGE_REF:
 const rangeRef = this.parseRangeRef(this.currentToken.value);
 this.nextToken();
 return { type: 'RangeRef', ...rangeRef, kind: 'ref' };
 case TokenTypes.IDENTIFIER:
 // Handle nested function calls
 if (this.peekToken && this.peekToken.type === TokenTypes.LPAREN) {
 return this.parseFunctionCall();
 }
 // Check for named macros
 const name = this.currentToken.value.toUpperCase();
 const macro = Store.getState().namedMacros.get(name);
 this.nextToken();
 if (macro) {
 return { type: 'Macro', value: macro };
 }
 return { type: 'Identifier', value: name };
 default:
 this.errors.push(`Unexpected token: ${this.currentToken.type}`);
 const val = this.currentToken.value;
 this.nextToken();
 return { type: 'Literal', value: val };
 }
 }

 parseCellRef(s) {
 const t = String(s||'').trim();
 const m = /^([A-Za-z]+)(\d+)([\u03b1-\u03c9])?(?:\^(-?\d+))?$/.exec(t);
 if (!m) return null;
 let x = 0;
 const letters = m[1].toUpperCase();
 for (let i = 0; i < letters.length; i++) x = x * 26 + (letters.charCodeAt(i) - 64);
 x--;
 const y = +m[2] - 1;
const G = 'αβγδεζηθικλμνξοπρστυφχψω';
 const z = m[3] ? G.indexOf(m[3]) : this.anchor.z;
 const arrId = m[4] !== undefined ? (+m[4]) : this.anchor.arrId;
 return { x, y, z, arrId, raw: t };
 }

 parseRangeRef(s) {
 const cur = this.anchor || {x:0,y:0,z:0,arrId:0};
 const m = /^@\[(\-?\d+)?,(\-?\d+)?,(\-?\d+)?,(-?\d+)\]$/.exec(String(s).trim());
 if (!m) return null;
 const raw = [m[1], m[2], m[3]].map(v=> (v===undefined || v===null) ? '' : String(v));
 const toOneBased = (val, curComp)=>{
 if(val==='') return 1;
 const n=+val; if(n===0) return (curComp|0)+1; return n;
 };
 const xb = toOneBased(raw[0], cur.x);
 const yb = toOneBased(raw[1], cur.y);
 const zb = toOneBased(raw[2], cur.z);
 return { x: xb-1, y: yb-1, z: zb-1, arrId: +m[4], raw: String(s).trim() };
 }
}

const GREEK_SUFFIXES = 'αβγδεζηθικλμνξοπρστυφχψω';

function columnLabelFromIndex(x) {
 let n = (Number.isFinite(x) ? x : 0) + 1;
 if (n <= 0) return 'A';
 let label = '';
 while (n > 0) {
 const rem = (n - 1) % 26;
 label = String.fromCharCode(65 + rem) + label;
 n = Math.floor((n - 1) / 26);
 }
 return label;
}

function stringifyCellRef(node) {
 if (!node) return '';
 if (node.raw) return node.raw;
 const col = columnLabelFromIndex(node.x ?? 0);
 const row = ((node.y ?? 0) + 1);
 const greek = (node.z !== undefined && node.z !== null && node.z >= 0) ? (GREEK_SUFFIXES[node.z] ?? '') : '';
 const arr = (node.arrId !== undefined && node.arrId !== null) ? `^${node.arrId}` : '';
 return `${col}${row}${greek}${arr}`;
}

function stringifyRangeRef(node) {
 if (!node) return '';
 if (node.raw) return node.raw;
 const x = (node.x ?? 0) + 1;
 const y = (node.y ?? 0) + 1;
 const z = (node.z ?? 0) + 1;
 const arr = node.arrId ?? 0;
 return `@[${x},${y},${z},${arr}]`;
}

function stringifyRange(node) {
 if (!node) return '';
 const start = stringifyCellRef(node.start);
 const end = stringifyCellRef(node.end);
 return `${start}:${end}`;
}

function stringifyAstExpression(node, topLevel = false) {
 if (!node) return topLevel ? '=' : '';
 switch (node.type) {
 case 'FunctionCall': {
 const args = (node.arguments || []).map(arg => stringifyAstExpression(arg, false));
 return (topLevel ? '=' : '') + `${node.name}(${args.join(', ')})`;
 }
 case 'Number': {
 const text = Number.isFinite(node.value) ? String(node.value) : '0';
 return topLevel ? `=${text}` : text;
 }
 case 'String': {
 const escaped = typeof escForStringLiteral === 'function' ? escForStringLiteral(node.value ?? '') : String(node.value ?? '').replace(/"/g, '\\"');
 const text = `"${escaped}"`;
 return topLevel ? `=${text}` : text;
 }
 case 'CellRef': {
 const ref = stringifyCellRef(node);
 return topLevel ? `=${ref}` : ref;
 }
 case 'RangeRef': {
 const ref = stringifyRangeRef(node);
 return topLevel ? `=${ref}` : ref;
 }
 case 'Range': {
 const text = stringifyRange(node);
 return topLevel ? `=${text}` : text;
 }
 case 'Identifier':
 case 'Macro': {
 const text = node.value || '';
 return topLevel ? `=${text}` : text;
 }
 case 'Literal': {
 const v = node.value;
 const text = (v === undefined || v === null) ? '""' : String(v);
 return topLevel ? `=${text}` : text;
 }
 default: {
 const text = String(node.value ?? '');
 return topLevel ? `=${text}` : text;
 }
 }
}
// Evaluator: walks AST and computes values
class FormulaEvaluator {
 constructor(formulaAPI) {
 this.formulaAPI = formulaAPI;
 }

 evaluate(node) {
 if (!node) return null;

 switch (node.type) {
 case 'Literal':
 return node.value;
 case 'Number':
 return node.value;
 case 'String':
 return node.value;
 case 'Identifier':
 return node.value;
 case 'Macro':
 // Simple macro expansion - could be enhanced
 return node.value;
 case 'CellRef':
 return this.formulaAPI.getCellValue(node);
 case 'RangeRef':
 return this.formulaAPI.getCellValue(node);
 case 'Range':
 // Expand range into cells array
 const cells = [];
 const start = node.start, end = node.end;
 const xs = [start.x, end.x].sort((a,b) => a-b);
 const ys = [start.y, end.y].sort((a,b) => a-b);
 const zs = [start.z, end.z].sort((a,b) => a-b);
 for(let z = zs[0]; z <= zs[1]; z++) {
 for(let y = ys[0]; y <= ys[1]; y++) {
 for(let x = xs[0]; x <= xs[1]; x++) {
 cells.push({x, y, z, arrId: start.arrId, kind: 'ref'});
 }
 }
 }
 return { kind: 'range', cells };
 case 'FunctionCall':
 const fn = this.formulaAPI.Fn[node.name];
 if (!fn) {
 throw new Error(`Unknown function ${node.name}`);
 }
 
 // Convert args without auto-injecting modes; functions decide internally
 let convertedArgs = node.arguments.map(arg => this.convertAstToLegacy(arg));
 const lname = String(node.name||'').toUpperCase();

 // Create compatibility bridge with old function system
 const mockAst = {
 fn: node.name,
 args: convertedArgs,
 raw: node.raw || this.formulaAPI.rawFormula
 };
 
 // Call original function implementation
 const anchor = this.formulaAPI.currentAnchor;
 const arr = this.formulaAPI.currentArray;
 const tx = this.formulaAPI.currentTx;
 
 return fn.impl(anchor, arr, mockAst, tx);
 }
 return null;
 }

 // Convert new AST nodes to legacy format for backward compatibility
 convertAstToLegacy(node) {
 switch (node.type) {
 case 'Number':
 return node.value;
 case 'String':
 return node.value;
 case 'Literal':
 return node.value;
 case 'CellRef':
 case 'RangeRef':
 return { ...node, kind: 'ref' };
 case 'Range':
 return this.evaluate(node); // Returns {kind:'range', cells:[...]}
 case 'FunctionCall':
 // For nested function calls, evaluate them
 return this.evaluate(node);
 default:
 return node.value || '';
 }
 }

 // Extract dependencies from AST
 findDependencies(node) {
 const deps = new Set();
 const aKey = ({arrId, x, y, z}) => `${arrId}:${x},${y},${z}`;

 const walk = (n) => {
 if (!n) return;

 switch (n.type) {
 case 'CellRef':
 case 'RangeRef':
 deps.add(aKey(n));
 break;
 case 'Range':
 deps.add(aKey(n.start));
 deps.add(aKey(n.end));
 break;
 case 'FunctionCall':
 n.arguments.forEach(walk);
 break;
 }
 };

 walk(node);
 return deps;
 }
}

/* ===========================
 Formula Engine (deep deps)
=========================== */
const Formula = (()=>{
 // Create evaluator instance
 const evaluator = new FormulaEvaluator({
 getCellValue: null, // Will be set below
 Fn: Fn,
 currentAnchor: null,
 currentArray: null, 
 currentTx: null,
 rawFormula: ''
 });

 // New AST-based parse function
 const parse = (text, anchor) => {
 try {
 const lexer = new FormulaLexer(text);
 const parser = new FormulaParser(lexer, anchor);
 const ast = parser.parseFormula();
 
 if (parser.errors.length > 0) {
 console.warn('Parser errors:', parser.errors);
 // Treat as literal to avoid hard failure
 return { fn: null, args: [], raw: text };
 }
 
 // Convert AST to legacy format for compatibility
 if(ast.type === 'Literal') {
 const lit = String(ast.value||'').trim();
 if(/^([A-Za-z_][A-Za-z0-9_]*)\s*\(/.test(lit)){
 // Treat bare function-looking literals as calls by auto-injecting '='
 const retry = '=' + lit;
 const lx = new FormulaLexer(retry);
 const px = new FormulaParser(lx, anchor);
 const node2 = px.parseFormula();
 if(px.errors.length===0 && node2 && node2.type==='FunctionCall'){
 let args = node2.arguments.map(arg => evaluator.convertAstToLegacy(arg));
 return { fn: node2.name, args, raw: retry };
 }
 }
 return { fn: null, args: [], raw: text };
 }
 
 if(ast.type === 'FunctionCall') {
 const fnName = ast.name;
 if((fnName === 'DO' || fnName === 'SEQ') && ast.block) {
 const blockArgs = (ast.arguments || [])
 .map(arg => stringifyAstExpression(arg, true))
 .filter(s => typeof s === 'string' && s.trim().length > 1);
 const optsRaw = {};
 if(ast.withOptions) {
 Object.entries(ast.withOptions).forEach(([k,v]) => {
 try {
 const norm = String(k || '').toLowerCase();
 optsRaw[norm] = evaluator.convertAstToLegacy(v);
 } catch(e) {
 console.warn('Failed to convert DO option', k, e);
 }
 });
 }
 return { fn: fnName, args: blockArgs, raw: text, block: true, blockOptions: optsRaw, _astArgs: ast.arguments };
 }
 if(fnName === 'PIPE') {
 const initialNode = ast.arguments && ast.arguments.length ? ast.arguments[0] : null;
 const stageNodes = ast.arguments ? ast.arguments.slice(1) : [];
 const initialExpr = initialNode ? stringifyAstExpression(initialNode, false) : '';
 const stageExprs = stageNodes.map(arg => stringifyAstExpression(arg, false)).filter(Boolean);
 return { fn: fnName, args: [], raw: text, pipeInitial: initialExpr, pipeStages: stageExprs, _pipeAstStages: stageNodes };
 }

 // Convert AST to legacy-expected args WITHOUT auto-injecting modes
 let args = ast.arguments.map(arg => evaluator.convertAstToLegacy(arg));
 const legacy = { fn: ast.name, args, raw: text };
 if(ast.block) legacy.block = true;
 if(ast.withOptions) legacy.blockOptions = ast.withOptions;
 legacy._astArgs = ast.arguments;
 return legacy;
 }
 
 // Fallback for other types
 return { fn: null, args: [], raw: text };
 } catch (e) {
 console.warn('AST parser failed, no legacy fallback:', e);
 return { fn: null, args: [], raw: text };
 }
 };
 // Enhanced dependency recording with AST support
 const recordDeps=(anchor, args, formula, ast=null)=>{
 const S=Store.getState(); const ak=aKey(anchor);
 let deps = new Set();
 
 // Use AST-based dependency extraction if available
 if(ast && evaluator) {
 try {
 deps = evaluator.findDependencies(ast);
 } catch(e) {
 console.warn('AST dependency extraction failed, using legacy:', e);
 }
 }
 
 // Fallback to legacy dependency extraction
 if(deps.size === 0) {
 const visit=a=>{ if(!a) return; if(Array.isArray(a)) return a.forEach(visit); if(a.kind==='ref') deps.add(aKey(a)); if(a.kind==='range') a.cells.forEach(c=>deps.add(aKey(c))); };
 args.forEach(visit);
 }
 
 // Track global state dependencies by parsing formula text for GET_GLOBAL calls
 const globalKeys = new Set();
 if(formula) {
 const globalMatches = formula.match(/GET_GLOBAL\s*\(\s*['"](.*?)['"]/g);
 if(globalMatches) {
 globalMatches.forEach(match => {
 const keyMatch = match.match(/GET_GLOBAL\s*\(\s*['"]([^'"]+)['"]/);
 if(keyMatch) globalKeys.add(keyMatch[1]);
 });
 }
 }
 
 // Clean up old dependencies
 const old=S.depsByAnchor.get(ak)||new Set();
 old.forEach(k=>{const s=S.anchorsByDep.get(k); if(s){s.delete(ak); if(!s.size) S.anchorsByDep.delete(k);}});
 
 // Clean up old global dependencies
 const oldGlobals = S.globalKeysByAnchor.get(ak) || new Set();
 oldGlobals.forEach(key => {
 const anchors = S.anchorsByGlobalKey.get(key);
 if(anchors) {
 anchors.delete(ak);
 if(anchors.size === 0) S.anchorsByGlobalKey.delete(key);
 }
 });
 
 // Set new cell dependencies
 S.depsByAnchor.set(ak,deps);
 deps.forEach(k=>{ if(!S.anchorsByDep.has(k)) S.anchorsByDep.set(k,new Set()); S.anchorsByDep.get(k).add(ak); });
 
 // Set new global dependencies
 S.globalKeysByAnchor.set(ak, globalKeys);
 globalKeys.forEach(key => {
 if(!S.anchorsByGlobalKey.has(key)) S.anchorsByGlobalKey.set(key, new Set());
 S.anchorsByGlobalKey.get(key).add(ak);
 });

 // Mark anchor dirty if its dependency set changed (edge change)
 try{
 const old = old || new Set(); // (defensive; old cleaned above)
 const now = deps;
 let changed = (old.size!==now.size);
 if(!changed){ for(const k of old){ if(!now.has(k)){ changed=true; break; } } }
 if(changed){
 const akStr = ak;
 // eslint-disable-next-line no-undef
 if(typeof markDirty==='function') markDirty(akStr);
 }
 }catch{}
 };

 const getCellValue=({arrId,x,y,z})=>{
 const arr=Store.getState().arrays[arrId]; if(!arr) return '';
 const key=keyChunk(...Object.values(chunkOf(x,y,z)));
 const ch=arr.chunks && arr.chunks[key]; if(!ch) return '';
 const c=ch.cells && ch.cells.find(t=>t.x===x&&t.y===y&&t.z===z); return c? (c.value ?? '') : '';
 };
 const getCell=({arrId,x,y,z})=>{
 const arr=Store.getState().arrays[arrId]; if(!arr) return {value:'',formula:null};
 const key=keyChunk(...Object.values(chunkOf(x,y,z)));
 const ch=arr.chunks && arr.chunks[key]; if(!ch) return {value:'',formula:null};
 const c=ch.cells && ch.cells.find(t=>t.x===x&&t.y===y&&t.z===z); return c||{value:'',formula:null};
 };
 const getCellNote=({arrId,x,y,z})=>{
 const c = getCell({arrId,x,y,z});
 return (c && c.meta && c.meta.noteText) ? c.meta.noteText : '';
 };
 
 // Wire up evaluator with formula API
 evaluator.formulaAPI.getCellValue = getCellValue;
 const valOf=(a)=>{ 
 if(a&&a.kind==='ref') {
 // Check if cell is protected by CANT_TARGET
 const cell = getCell(a);
 if(cell.meta && cell.meta.isTargetable === false) {
 return '!ERR:TARGET_PROTECTED';
 }
 return getCellValue(a); 
 } 
 if(a&&a.kind==='range') return a.cells.map(c=>getCellValue(c)); 
 return a; 
 };
 function setFormula(anchor,text){
 const arr=Store.getState().arrays[anchor.arrId]; if(!arr) return;
 // Normalize: auto-close missing ')' and allow bare =FN to map to =FN()
 if(text && text[0]==='='){
 const body = text.slice(1).trim();
 const m = body.match(/^([A-Za-z_][A-Za-z0-9_]*)\s*\(?\s*\)?$/);
 if(m){ text = `=${m[1]}()`; }
 else {
 // naive paren balance: if more '(' than ')', pad closers at end
 const open=(text.match(/\(/g)||[]).length, close=(text.match(/\)/g)||[]).length;
 if(open>close) text += ')'.repeat(open-close);
 }
 } else if(text && /^[A-Za-z_][A-Za-z0-9_]*\s*\(/.test(text.trim())){
 // Auto-inject '=' for function-like inputs without leading '=' (e.g., create(1,1,1))
 text = '=' + text.trim();
 }
 const ch=arr.chunks[keyChunk(...Object.values(chunkOf(anchor.x,anchor.y,anchor.z)))];
 const cell=ch.cells.find(c=>c.x===anchor.x&&c.y===anchor.y&&c.z===anchor.z);
 const prevFormula = cell ? cell.formula : null;
 if(cell) {
 // Revert previously applied 3D_ROTATE if this anchor was controlling one and not suppressed
 try{
 const ak=aKey(anchor);
 const S=Store.getState();
 let rec = (S.activeRotations||new Map()).get(ak);
 // Fallback to meta if after refresh
 if(!rec){
 const cell = Formula.getCell(anchor);
 if(cell && cell.meta && cell.meta.appliedRotate){ rec = cell.meta.appliedRotate; }
 }
 const suppressed = (S.suppress3DRotateRevert||new Set()).has(ak);
 const newFormulaStr = text || '';
 const prevFormulaStr = prevFormula || '';
 const clearing = newFormulaStr==='';
 const formulaChanged = (prevFormula!==null && newFormulaStr!==prevFormulaStr);
 if(rec && (clearing || formulaChanged) && !suppressed){
 const targ=S.arrays[rec.targetId];
 if(targ){
 const ids = rec.ids||[rec.targetId];
 // Ensure frames exist
 ids.map(id=>S.arrays[id]).filter(Boolean).forEach(a=>{ if(!a._frame) Scene.renderArray(a); });
 // Rotate back by negative steps around the same pivot at current time
 const pivotWorld = Scene.cellWorldPos(targ, rec.pivot.x, rec.pivot.y, rec.pivot.z);
 const sx = -(rec.steps.sx||0), sy=-(rec.steps.sy||0), sz=-(rec.steps.sz||0);
 ids.map(id=>S.arrays[id]).filter(Boolean).forEach(a=> Scene.rotateArrayAround(a, pivotWorld, sx, sy, sz));
 ids.map(id=>S.arrays[id]).filter(Boolean).forEach(a=>{ if(a._frame){ a.offset={ x:Math.round(a._frame.position.x), y:Math.round(a._frame.position.y), z:Math.round(a._frame.position.z) }; }});
 }
 const map=new Map(S.activeRotations); map.delete(ak); Store.setState({activeRotations:map});
 }
 if(suppressed){ const sup=new Set(S.suppress3DRotateRevert); sup.delete(ak); Store.setState({suppress3DRotateRevert:sup}); }
 }catch{}
 // Revert previously applied 3D_TRANSLATE if this anchor controlled one and is now cleared
 try{
 const ak=aKey(anchor);
 const S=Store.getState();
 let recT = (S.activeTranslations||new Map()).get(ak);
 // Fallback to meta on refresh: read persisted appliedTranslate
 if(!recT){
 const cell = Formula.getCell(anchor);
 if(cell && cell.meta && cell.meta.appliedTranslate){ recT = cell.meta.appliedTranslate; }
 }
 const suppressedT = (S.suppress3DTranslateRevert||new Set()).has(ak);
 const newFormulaStr = text || '';
 const prevFormulaStr = prevFormula || '';
 const clearing = newFormulaStr==='';
 const formulaChanged = (prevFormula!==null && newFormulaStr!==prevFormulaStr);
 if(recT && (clearing || formulaChanged) && !suppressedT){
 const stateNow = Store.getState();
 const baseEntries = Array.isArray(recT.bases) ? recT.bases : [];
 let restored=false;
 if(baseEntries.length){
 const seen=new Set();
 baseEntries.forEach(entry=>{
 if(!entry) return;
 const id = Number.isFinite(+entry.id) ? (+entry.id|0) : null;
 if(id==null || seen.has(id)) return;
 const arrTarget = stateNow.arrays?.[id];
 if(!arrTarget) return;
 const src = entry.offset || entry.base || entry;
 const base={
 x: Number.isFinite(+src?.x) ? Math.round(+src.x) : 0,
 y: Number.isFinite(+src?.y) ? Math.round(+src.y) : 0,
 z: Number.isFinite(+src?.z) ? Math.round(+src.z) : 0
 };
 setArrayOffset(arrTarget, base, {interactive:true, _skipDock:true, _skipConnections:true});
 seen.add(id);
 restored=true;
 });
 }
 if(!restored){
 const targ=stateNow.arrays?.[recT.targetId];
 if(targ){
 const base = recT.from || {x:0,y:0,z:0};
 const nx = Number.isFinite(+base.x) ? Math.round(+base.x) : 0;
 const ny = Number.isFinite(+base.y) ? Math.round(+base.y) : 0;
 const nz = Number.isFinite(+base.z) ? Math.round(+base.z) : 0;
 setArrayOffset(targ, {x:nx,y:ny,z:nz}, {interactive:true});
 restored=true;
 }
 }
 const map=new Map(S.activeTranslations); map.delete(ak); Store.setState({activeTranslations:map});
 }
 if(suppressedT){ const sup=new Set(S.suppress3DTranslateRevert); sup.delete(ak); Store.setState({suppress3DTranslateRevert:sup}); }
 }catch{}
 // Revert previously applied SCALE if this anchor controlled one
 try{
 const ak=aKey(anchor);
 const S=Store.getState();
 let recS = (S.activeScales||new Map()).get(ak);
 if(!recS){
 const cellMeta = Formula.getCell(anchor);
 if(cellMeta && cellMeta.meta && cellMeta.meta.appliedScale){ recS = cellMeta.meta.appliedScale; }
 }
 const newFormulaStr = text || '';
 const prevFormulaStr = prevFormula || '';
 const clearing = newFormulaStr==='';
 const formulaChanged = (prevFormula!==null && newFormulaStr!==prevFormulaStr);
 if(recS && (clearing || formulaChanged)){
 const stateNow = Store.getState();
 (recS.targets||[]).forEach(t=>{
 const target = stateNow.arrays?.[t.id];
 if(!target) return;
 target.params = target.params || {};
 target.params.voxelScaleLevel = t.prevLevel ?? 1;
 target.params.voxelScale = t.prevUnits ?? arrayScaleUnitsFromLevel(t.prevLevel ?? 1);
 try{ refreshArrayScale(target); }catch{}
 });
 const map=new Map(S.activeScales||new Map()); map.delete(ak); Store.setState({activeScales:map});
 }
 }catch{}
 cell.formula=text;
 // Use new AST-based dependency tracking
 try {
 const lexer = new FormulaLexer(text);
 const parser = new FormulaParser(lexer, anchor);
 const ast = parser.parseFormula();
 recordDeps(anchor, [], text, ast);
 } catch(e) {
 console.warn('AST dependency tracking failed; recording minimal deps');
 recordDeps(anchor, [], text, null);
 }
 }
 }
 function executeAt(anchor,text,tx){
 // Make tx optional - use legacy Actions.setCell if no transaction
 const useLegacy = !tx;
 if(text) setFormula(anchor,text);
 const arr=Store.getState().arrays[anchor.arrId]; if(!arr) return;
 const chKey = keyChunk(...Object.values(chunkOf(anchor.x,anchor.y,anchor.z)));
 let ch=arr.chunks[chKey];
 if(!ch){
 // Ensure the array has this chunk (e.g., expansion or first write)
 Actions.resizeArrayIfNeeded(arr, anchor);
 ch = arr.chunks[chKey];
 if(!ch) return; // still missing, abort gracefully
 }
 const cell=ch.cells.find(c=>c.x===anchor.x&&c.y===anchor.y&&c.z===anchor.z) || {value:'',formula:null};
 const src=(cell?.formula)||text||(cell?.value??'');
 warmChimeIfNeeded(src);

 // Try new AST parser first, fallback to legacy
 let ast, useAST = false, astRoot = null;
 try {
 const lexer = new FormulaLexer(src);
 const parser = new FormulaParser(lexer, anchor);
 const astNode = parser.parseFormula();
 astRoot = astNode;
 
 if(parser.errors.length === 0 && astNode) {
 // Set up evaluator context
 evaluator.formulaAPI.currentAnchor = anchor;
 evaluator.formulaAPI.currentArray = arr;
 evaluator.formulaAPI.currentTx = tx;
 evaluator.formulaAPI.rawFormula = src;
 
 // Convert to legacy format for function compatibility
 if(astNode.type === 'Literal') {
 // If the literal looks like a function call without '=', auto-inject '=' and reparse
 const lit = String(astNode.value||'').trim();
 if(/^([A-Za-z_][A-Za-z0-9_]*)\s*\(/.test(lit)){
 const retry = '=' + lit;
 const lx = new FormulaLexer(retry);
 const px = new FormulaParser(lx, anchor);
 const node2 = px.parseFormula();
 if(px.errors.length===0 && node2 && node2.type==='FunctionCall'){
 ast = { fn: node2.name, args: node2.arguments.map(arg => evaluator.convertAstToLegacy(arg)), raw: retry };
 } else {
 ast = { fn: null, args: [], raw: src };
 }
 } else {
 ast = { fn: null, args: [], raw: src };
 }
 useAST = true;
 } else if(astNode.type === 'FunctionCall') {
 // Convert AST to legacy-expected args for all functions
 ast = {
 fn: astNode.name,
 args: astNode.arguments.map(arg => evaluator.convertAstToLegacy(arg)),
 raw: src
 };
 // Preserve raw AST args for special-case handling (e.g., ARRAY call with range)
 ast._astArgs = astNode.arguments;
 useAST = true;
 } else {
 ast = { fn: null, args: [], raw: src };
 useAST = true;
 }
 }
 } catch(e) {
 console.warn('AST parsing failed, using legacy:', e);
 }
 
 // Fallback to legacy parser
 if(!useAST) {
 const errorMsg = '!ERR:PARSE';
 if(useLegacy) Actions.setCell(arr.id, anchor, errorMsg, cell?.formula||null, true);
 else Write.set(tx, arr.id, anchor, { value: errorMsg, formula: cell?.formula||src });
 return;
 }

 if(!ast.fn) { 
 // Evaluate simple expressions like =A2 or =(A2) to their scalar value
 try{
 let result = evaluator.evaluate(astRoot);
 // If a range was produced, reduce to its first cell value
 if(result && typeof result==='object' && result.kind==='range'){
 const first = result.cells && result.cells[0];
 result = first ? Formula.getCellValue(first) : '';
 }
 if(useLegacy) Actions.setCell(arr.id, anchor, result, cell?.formula||src, true);
 else Write.set(tx, arr.id, anchor, { value: result, formula: cell?.formula||src });
 }catch{
 // Fall back to literal behavior
 if(useLegacy) Actions.setCell(arr.id, anchor, src, null, true);
 else Write.set(tx, arr.id, anchor, { value: src, formula: null });
 }
 return; 
 }
 if(!isAllowed(arr, ast.fn)) { 
 const errorMsg = `!ERR:FN_DENIED ${ast.fn}`;
 if(useLegacy) Actions.setCell(arr.id, anchor, errorMsg, cell?.formula||null, true);
 else Write.set(tx, arr.id, anchor, { value: errorMsg, formula: cell?.formula||ast.raw });
 return; 
 }

 try{ 
 if(!Fn[ast.fn]) { 
 // Check for macro expansion
 const macro = Store.getState().namedMacros.get(ast.fn.toUpperCase());
 if(macro) {
 // Simple positional expansion: $1, $2 ... replaced by evaluated args
 const args = ast.args.map(a => {
 const v = valOf(a);
 return (typeof v === 'string') ? `"${v}"` : `${v}`;
 });
 const expanded = macro.replace(/\$(\d+)/g, (_,i)=> args[(+i)-1] ?? '');
 return executeAt(anchor, expanded, tx); // re-enter with expanded text and same tx
 }
 const errorMsg = `!ERR:Unknown ${ast.fn}`;
 if(useLegacy) Actions.setCell(arr.id, anchor, errorMsg, ast.raw, true);
 else Write.set(tx, arr.id, anchor, { value: errorMsg, formula: cell?.formula||ast.raw });
 return; 
 }
 // Determine if function is pure or mutating by tags
 const tags = Fn[ast.fn]?.tags || new Set();
 const isPure = tags.has('PURE');
 if(isPure){
 // Special-case: TRANSPOSE should treat ARRAY(...) with a range child as a range input
 if(ast.fn==='TRANSPOSE' && Array.isArray(ast._astArgs) && ast._astArgs.length>0){
 try{
 const firstArg = ast._astArgs[0];
 // Pattern: ARRAY(call) where child is range or cell-ref range
 const isArrayCall = firstArg && firstArg.type==='FunctionCall' && String(firstArg.name||'').toUpperCase()==='ARRAY';
 const hasRangeChild = isArrayCall && firstArg.arguments && firstArg.arguments.some(a=> a && (a.type==='Range' || a.type==='CellRef' || a.type==='RangeRef'));
 if(hasRangeChild){
 // Rebuild a legacy range arg from the child's first range-like argument
 const child = firstArg.arguments.find(a=> a && (a.type==='Range' || a.type==='CellRef' || a.type==='RangeRef'));
 let legacy;
 if(child.type==='Range'){
 // Expand to cells in legacy format
 const xs=[child.start.x,child.end.x].sort((a,b)=>a-b);
 const ys=[child.start.y,child.end.y].sort((a,b)=>a-b);
 const zs=[child.start.z,child.end.z].sort((a,b)=>a-b);
 const cells=[]; for(let z=zs[0]; z<=zs[1]; z++) for(let y=ys[0]; y<=ys[1]; y++) for(let x=xs[0]; x<=xs[1]; x++) cells.push({x,y,z,arrId:child.start.arrId,kind:'ref'});
 legacy = {kind:'range', cells};
 } else {
 legacy = { arrId: child.arrId, x:child.x, y:child.y, z:child.z, kind:'ref' };
 }
 const ast2 = { ...ast, args:[legacy, ...ast.args.slice(1)] };
 Fn[ast.fn].impl(anchor,arr,ast2,tx);
 return; // already wrote
 }
 }catch{}
 }
 // Evaluate pure function via implementation but capture returned value
 const result = Fn[ast.fn].impl(anchor,arr,ast,tx);
 // Some pure functions already write; only write when result is scalar
 if(result !== undefined){
 let adtx = tx;
 if(!adtx) adtx = Write.start('auto.pure','auto');
 Write.set(adtx, arr.id, anchor, { value: result, formula: cell?.formula||ast.raw });
 if(!tx) Write.commit(adtx);
 }
 } else {
 // Mutating/action functions use their implementation with tx
 if(!tx){ const adtx = Write.start(`auto.${ast.fn.toLowerCase()}`,'Auto-started tx'); Fn[ast.fn].impl(anchor,arr,ast,adtx); Write.commit(adtx); }
 else { Fn[ast.fn].impl(anchor,arr,ast,tx); }
 }
 }
 catch(e){ 
 const errorMsg = `!ERR:${e.message}`;
 if(useLegacy) Actions.setCell(arr.id, anchor, errorMsg, cell?.formula||null, true);
 else Write.set(tx, arr.id, anchor, { value: errorMsg, formula: cell?.formula||ast.raw });
 } finally {
 // Clean up evaluator context
 if(useAST) {
 evaluator.formulaAPI.currentAnchor = null;
 evaluator.formulaAPI.currentArray = null;
 evaluator.formulaAPI.currentTx = null;
 evaluator.formulaAPI.rawFormula = '';
 }
 }
 }

 // --- runOnceAt: execute a formula at an anchor without stamping ---
 function runOnceAt(anchor, text, tx){
 const arr = Store.getState().arrays[anchor.arrId]; if(!arr) return;
 if(text){ warmChimeIfNeeded(text); }
 const chKey = keyChunk(...Object.values(chunkOf(anchor.x,anchor.y,anchor.z)));
 let ch = arr.chunks[chKey];
 if(!ch){ Actions.resizeArrayIfNeeded(arr, anchor); ch = arr.chunks[chKey]; if(!ch) return; }
 const idx = ch.cells.findIndex(c=>c.x===anchor.x&&c.y===anchor.y&&c.z===anchor.z);
 if(idx<0){ ch.cells.push({x:anchor.x,y:anchor.y,z:anchor.z,value:'',formula:null}); }
 const cell = ch.cells.find(c=>c.x===anchor.x&&c.y===anchor.y&&c.z===anchor.z);
 const prevFormula = cell.formula;
 try{
 cell.formula = text; // temporary set
 executeAt(anchor, undefined, tx); // execute without stamping
 } finally {
 cell.formula = prevFormula; // restore
 }
 }

 function notifyCellChanged(dep){
 const depK=aKey(dep);
 // Defer to recompute engine with proper batching
 recomputeAnchors([depK]);
 }

 // Incremental SCC-based recompute with fingerprint short-circuit
 let recomputeDepth = 0; let inRecompute = false;
 const NodeMeta = { byKey:new Map(), dirtyQ:new Set() };
 function metaOf(ak){ let m=NodeMeta.byKey.get(ak); if(!m){ m={version:0,inputFP:'',dirty:false}; NodeMeta.byKey.set(ak,m);} return m; }
 function markDirty(ak){ const m=metaOf(ak); m.dirty=true; NodeMeta.dirtyQ.add(ak); }
 function bumpVersion(ak){ const m=metaOf(ak); m.version++; const users=Store.getState().anchorsByDep.get(ak)||new Set(); users.forEach(u=>markDirty(u)); }
 function fingerprintFor(ak){ const deps=Store.getState().depsByAnchor.get(ak)||new Set(); if(deps.size===0) return '0'; let s=''; deps.forEach(d=>{ s+=d+'@'+(metaOf(d).version||0)+';'; }); return s; }

 // Wrap Write.set once to bump versions on actual value change
 if(!Write.__versionWrapped){
 Write.__versionWrapped = true;
 const __set = Write.set.bind(Write);
 Write.set = function(tx, arrId, coord, next){
 const ak = `${arrId}:${coord.x},${coord.y},${coord.z}`;
 const arr = Store.getState().arrays[arrId];
 const ch = arr && arr.chunks && arr.chunks[keyChunk(...Object.values(chunkOf(coord.x,coord.y,coord.z)))];
 const prevCell = ch && ch.cells.find(c=>c.x===coord.x&&c.y===coord.y&&c.z===coord.z);
 const prevVal = prevCell ? prevCell.value : undefined;
 __set(tx, arrId, coord, next);
 const arr2 = Store.getState().arrays[arrId];
 const ch2 = arr2 && arr2.chunks && arr2.chunks[keyChunk(...Object.values(chunkOf(coord.x,coord.y,coord.z)))];
 const c2 = ch2 && ch2.cells.find(c=>c.x===coord.x&&c.y===coord.y&&c.z===coord.z);
 const newVal = c2 ? c2.value : undefined;
 if(!Object.is(prevVal, newVal)) bumpVersion(ak);
 };
 }

 function recomputeAnchors(startKeys){
 if(recomputeDepth>10){ console.warn('Recompute depth exceeded'); return; }
 recomputeDepth++;
 try{
 inRecompute = true;
 startKeys.forEach(k=> NodeMeta.dirtyQ.add(k));
 const affected = collectAffected(NodeMeta.dirtyQ);
 NodeMeta.dirtyQ.clear(); if(affected.size===0){ return; }
 const { sccs, dagOrder } = buildSCCs(affected);
 const rtx = Write.start('recompute','dependency propagation');
 for(const compId of dagOrder){
 const scc = sccs[compId];
 if(scc.length===1 && !hasSelfLoop(scc[0])){ evalNodeIfNeeded(scc[0], rtx); }
 else{ const MAX=1000; for(let i=0;i<MAX;i++){ let any=false; for(const ak of scc) any = evalNodeIfNeeded(ak, rtx) || any; if(!any) break; } }
 }
 Write.commit(rtx);
 } finally { recomputeDepth--; inRecompute=(recomputeDepth>0); }
 }

 function evalNodeIfNeeded(ak, tx){
 const m=metaOf(ak); if(!m.dirty) return false;
 const fp=fingerprintFor(ak); if(fp===m.inputFP){ m.dirty=false; return false; }
 const [arrId,rest]=ak.split(':'); const [x,y,z]=rest.split(',').map(Number);
 executeAt({arrId:+arrId,x,y,z}, undefined, tx);
 m.inputFP=fp; m.dirty=false; return true;
 }
 function hasSelfLoop(ak){ const deps=Store.getState().depsByAnchor.get(ak)||new Set(); return deps.has(ak); }
 function collectAffected(seed){
 const seen=new Set(seed); const stack=[...seed]; const usersMap=Store.getState().anchorsByDep;
 while(stack.length){ const k=stack.pop(); const users=usersMap.get(k)||new Set(); users.forEach(u=>{ if(!seen.has(u)){ seen.add(u); stack.push(u); } }); }
 return seen;
 }
 function buildSCCs(affected){
 const adj=new Map(); affected.forEach(k=> adj.set(k, []));
 const usersMap=Store.getState().anchorsByDep;
 affected.forEach(k=>{ const outs=adj.get(k); (usersMap.get(k)||new Set()).forEach(u=>{ if(affected.has(u)) outs.push(u); }); });
 const ids=new Map(), low=new Map(), onStack=new Map(), stack=[]; let time=0; const comps=[];
 function dfs(v){ ids.set(v,time); low.set(v,time); time++; stack.push(v); onStack.set(v,true);
 for(const w of adj.get(v)){ if(!ids.has(w)){ dfs(w); low.set(v, Math.min(low.get(v), low.get(w))); } else if(onStack.get(w)){ low.set(v, Math.min(low.get(v), ids.get(w))); } }
 if(low.get(v)===ids.get(v)){ const comp=[]; let w=null; do{ w=stack.pop(); onStack.set(w,false); comp.push(w); }while(w!==v); comps.push(comp); }
 }
 affected.forEach(v=>{ if(!ids.has(v)) dfs(v); });
 const compIndex=new Map(); comps.forEach((c,i)=> c.forEach(v=> compIndex.set(v,i)));
 const dagAdj=new Map(); comps.forEach((_,i)=> dagAdj.set(i,new Set()));
 affected.forEach(v=>{ const i=compIndex.get(v); for(const w of adj.get(v)){ const j=compIndex.get(w); if(i!==j) dagAdj.get(i).add(j); } });
 const indeg=new Map(); comps.forEach((_,i)=> indeg.set(i,0)); dagAdj.forEach((outs,i)=> outs.forEach(j=> indeg.set(j, indeg.get(j)+1)));
 const q=[]; indeg.forEach((d,i)=>{ if(d===0) q.push(i); }); const order=[]; while(q.length){ const i=q.shift(); order.push(i); dagAdj.get(i).forEach(j=>{ indeg.set(j, indeg.get(j)-1); if(indeg.get(j)===0) q.push(j); }); }
 return { sccs: comps, dagOrder: order };
 }
 return {parse,setFormula,executeAt,notifyCellChanged,recomputeAnchors,valOf,getCellValue,getCell,getCellNote, isRecomputing:()=>inRecompute, runOnceAt};
})();
/* ===========================
 Docking Utility
=========================== */
function dockOffsetFor(host, port='east', pad=1.0){
 const scale = arrayVoxelScale(host);
 const {x:W,y:H,z:D} = host.size;
 const halfW = (W * scale) / 2;
 const halfH = (H * scale) / 2;
 const halfD = (D * scale) / 2;
 const gap = pad * scale;
 const o = host.offset || {x:0,y:0,z:0};
 const P = String(port||'east').toLowerCase();
 const offs = (P==='north') ? {x:0, y:0, z: (halfD + gap)} :
 (P==='south') ? {x:0, y:0, z: -(halfD + gap)} :
 (P==='east') ? {x:(halfW + gap), y:0, z:0} :
 (P==='west') ? {x:-(halfW + gap), y:0, z:0} :
 (P==='top') ? {x:0, y:(halfH + gap), z:0} :
 {x:0, y:-(halfH + gap), z:0}; // bottom
 return {x:o.x+offs.x, y:o.y+offs.y, z:o.z+offs.z};
}

/* ===========================
 Function Implementations
=========================== */
// Provide a shared alias for Formula.valOf so all function impls can access it
const valOf = Formula.valOf;
let creditsSongAudio = null;

function ensureCreditsSongAudio() {
 if (creditsSongAudio) return creditsSongAudio;
 try {
  creditsSongAudio = new Audio('../../credits.mp3');
  creditsSongAudio.preload = 'auto';
 } catch (err) {
  console.warn('SONG(): Failed to initialize credits.mp3 audio', err);
  creditsSongAudio = null;
 }
 return creditsSongAudio;
}
// PURE BLOCK
tag('ARRAY',["ACTION","BLOCK"], (anchor,arr,ast,tx)=>{
 if(!tx) throw new Error('ARRAY requires active transaction');
 const S = Store.getState();
 const ak = aKey(anchor);

 const prevEmitted = S.emittedByAnchor.get(ak);
 if(prevEmitted) {
 prevEmitted.forEach(ck => {
 const [arrId, coords] = ck.split(':');
 const [x, y, z] = coords.split(',').map(Number);
 Write.set(tx, +arrId, {x, y, z}, { value: '', formula: null, meta: {} });
 S.sourceByCell.delete(ck);
 });
 S.emittedByAnchor.delete(ak);
 }

 const args = ast.args;
 // Accept ranges: if first arg is a range or ref, treat as list data
 if(args.length>0 && (args[0]?.kind==='range' || args[0]?.kind==='ref')){
 const src = args[0];
 // Clear previous emissions
 const prevEmitted2 = S.emittedByAnchor.get(ak);
 if(prevEmitted2){
 prevEmitted2.forEach(ck => { try{ const [arrId, coords]=ck.split(':'); const [x,y,z]=coords.split(',').map(Number); Write.set(tx, +arrId, {x,y,z}, { value:'', formula:null, meta:{} }); S.sourceByCell.delete(ck); }catch{} });
 S.emittedByAnchor.delete(ak);
 }
 const cells = src.kind==='range' ? src.cells : [src];
 // Determine bounds to emit compactly preserving relative order (row-major by y then x within each z)
 const xs=[...new Set(cells.map(c=>c.x))].sort((a,b)=>a-b);
 const ys=[...new Set(cells.map(c=>c.y))].sort((a,b)=>a-b);
 const zs=[...new Set(cells.map(c=>c.z))].sort((a,b)=>a-b);
 let wrote=false;
 for(let zi=0; zi<zs.length; zi++){
 for(let yi=0; yi<ys.length; yi++){
 for(let xi=0; xi<xs.length; xi++){
 const x=xs[xi], y=ys[yi], z=zs[zi];
 const v = Formula.getCellValue({arrId:cells[0].arrId,x,y,z});
 const dx = xi, dy = yi, dz = zi;
 const isAnchor=(dx===0&&dy===0&&dz===0);
 Write.set(tx, arr.id, {x:anchor.x+dx, y:anchor.y+dy, z:anchor.z+dz}, { value:v, formula:isAnchor?ast.raw:null, meta:{generated:true, emitter:ak} });
 wrote=true;
 }
 }
 }
 return;
 }
 const firstVal = args.length>0 ? valOf(args[0]) : undefined;
 const isModeString = typeof firstVal === 'string';
 let mode = isModeString ? String(firstVal).trim().toLowerCase() : 'list';
 let dataArgs = isModeString ? args.slice(1) : args;

 const knownModes = ['fill','set','csv','list'];
 if(isModeString && !knownModes.includes(mode) && !S.namedBlocks.has(mode.toUpperCase())){
 mode = 'list';
 dataArgs = args;
 }

 switch(mode){
 case 'fill':{
 const w=+valOf(dataArgs[0])||1, h=+valOf(dataArgs[1])||1, d=+valOf(dataArgs[2]||1)||1;
 const fillValue = (dataArgs[3]!==undefined)? valOf(dataArgs[3]) : 1;
 for(let z=0;z<d;z++) for(let y=0;y<h;y++) for(let x=0;x<w;x++){
 const coord={x:anchor.x+x, y:anchor.y+y, z:anchor.z+z};
 const isAnchor=(x===0&&y===0&&z===0);
 Write.set(tx, arr.id, coord, { value: fillValue, formula:isAnchor?ast.raw:null, meta:{generated:true, emitter:ak} });
 }
 break;
 }
 case 'csv':{
 const raw=String(valOf(dataArgs[0]||''));
 const rows=raw.split(/\r?\n/); let wroteAnchor=false, ry=0;
 for(const line of rows){
 const cols=line.split(',');
 for(let i=0;i<cols.length;i++){
 const isFirst=!wroteAnchor;
 Write.set(tx, arr.id, {x:anchor.x+i, y:anchor.y+ry, z:anchor.z}, { value: cols[i], formula:isFirst?ast.raw:null, meta:{generated:true, emitter:ak} });
 wroteAnchor=true;
 }
 ry++;
 }
 break;
 }
 case 'set':
 case 'list':
 default:{
 const named=S.namedBlocks.get(String(mode).toUpperCase());
 if(named){
 const values=named.data[0].flat();
 for(let i=0;i<values.length;i++){
 Write.set(tx, arr.id, {x:anchor.x,y:anchor.y+i,z:anchor.z}, { value:values[i], formula:i===0?ast.raw:null, meta:{generated:true, emitter:ak} });
 }
 } else {
 const values = dataArgs.map(valOf);
 for(let i=0;i<values.length;i++){
 const coord={x:anchor.x, y:anchor.y+i, z:anchor.z};
 Write.set(tx, arr.id, coord, { value: values[i], formula: i===0?ast.raw:null, meta:{generated:true, emitter:ak} });
 }
 }
 }
 }
});
tag('STORE_ARRAY',['PURE'],(anchor,arr,ast)=>{
 // Collect values then produce nested formula: =STORE_ARRAY(ARRAY("list", ...))[,"name"]
 let name='Block', data=[], size={x:1,y:1,z:1}, flat=[];
 const esc=(s)=> String(s).replace(/\\/g,'\\\\').replace(/"/g,'\\\"');
 const pushFlat=(v)=>{ flat.push((typeof v==='string')?`"${esc(v)}"`:`${v}`); };
 const arg0=ast.args[0];
 if(typeof arg0==='number'){
 const w=+valOf(ast.args[0])||1, h=+valOf(ast.args[1])||1, d=+valOf(ast.args[2])||1;
 name=ast.args[3]?String(valOf(ast.args[3])):'Block';
 size={x:w,y:h,z:d};
 for(let zz=0; zz<d; zz++) for(let yy=0; yy<h; yy++) for(let xx=0; xx<w; xx++){
 const cell=Formula.getCell({arrId:arr.id,x:anchor.x+xx,y:anchor.y-yy,z:anchor.z+zz});
 pushFlat(cell.value||'');
 }
 } else if(arg0&&arg0.kind==='range'){
 const src=arg0; name=ast.args[1]?String(valOf(ast.args[1])):'Block';
 const xs=src.cells.map(c=>c.x), ys=src.cells.map(c=>c.y), zs=src.cells.map(c=>c.z);
 const minX=Math.min(...xs), minY=Math.min(...ys), minZ=Math.min(...zs), maxX=Math.max(...xs), maxY=Math.max(...ys), maxZ=Math.max(...zs);
 size={x:maxX-minX+1,y:maxY-minY+1,z:maxZ-minZ+1};
 for(let z=minZ; z<=maxZ; z++) for(let y=minY; y<=maxY; y++) for(let x=minX; x<=maxX; x++){
 const cell=Formula.getCell({arrId:src.cells[0].arrId,x,y,z}); pushFlat(cell.value||'');
 }
 } else {
 // Inline values: =STORE_ARRAY(v1,v2,...[,"name"]) -> flatten inputs
 const raw=ast.args.slice();
 if(typeof raw[raw.length-1]==='string' || (typeof raw[raw.length-1]==='object' && raw[raw.length-1]?.kind!==undefined)){
 const last = raw[raw.length-1];
 const nm = String(valOf(last));
 if(nm) { name = nm; raw.pop(); }
 }
 const values=raw.map(valOf);
 size={x:1,y:values.length,z:1};
 values.forEach(pushFlat);
 }
 // Save to library as before
 const lib=new Map(Store.getState().namedBlocks); 
 // Rebuild data cube from flat for persistence (row-major per layer)
 data=[]; { let i=0; for(let z=0; z<size.z; z++){ const layer=[]; for(let y=0; y<size.y; y++){ const row=[]; for(let x=0; x<size.x; x++){ row.push((flat[i++]||'').toString().replace(/^"|"$/g,'')); } layer.push(row); } data.push(layer);} }
 lib.set(name.toUpperCase(),{size,data}); 
 Store.setState({namedBlocks:lib});
 // Emit nested formula string into anchor
 const nested = `=STORE_ARRAY(ARRAY(\"list\", ${flat.join(', ')}), \"${esc(name)}\")`;
 Actions.setCell(arr.id, anchor, nested, ast.raw, true);
});
// DOCK(modeOrList, list...)
// Usage:
// =DOCK("Parent", @[x,y,z,id], id2, ...)
// =DOCK(@[x,y,z,id], id2, ...) // default mode "Children" (parent mode)
// Mode "Parent": treat first as parent; moves/rotations of a parent apply to later members; a child does not affect parents.
// Mode "All": any member's transform applies to all members.
tag('DOCK',["SCENE","ACTION"], (anchor,arr,ast,tx)=>{
 const S=Store.getState();
 let mode='parent';
 let args = ast.args.slice();
 const first = Formula.valOf(args[0]);
 if(typeof first==='string'){
 const m = String(first||'').toLowerCase();
 mode = (m==='all')?'all':'parent';
 args = args.slice(1);
 }
 const toArrId = (a)=>{
 if(a && a.kind==='ref') return a.arrId;
 const v = Formula.valOf(a);
 if(typeof v==='string'){
 const p = v.match(/@\[(-?\d+),(-?\d+),(-?\d+),(-?\d+)\]/);
 if(p) return +p[4];
 const n = +v; if(!isNaN(n)) return n;
 }
 const n = +v; if(!isNaN(n)) return n;
 return null;
 };
 const members = args.map(toArrId).filter(id=> id!=null);
 if(members.length===0){ Actions.setCell(arr.id,anchor,'!ERR:DOCK:EMPTY',ast.raw,true); return; }
 const groupId = `g:${Date.now()}:${Math.random().toString(36).slice(2)}`;
 const group = {mode, members:[...new Set(members)], parentId: members[0]};
 const newGroups = new Map(S.dockGroups||new Map());
 newGroups.forEach((g,k)=>{ if(g.members.some(id=>group.members.includes(id))) newGroups.delete(k); });
 newGroups.set(groupId, group);
 const ak = aKey(anchor);
 const newByAnchor = new Map(S.dockGroupsByAnchor||new Map());
 newByAnchor.set(ak, groupId);
 Store.setState({dockGroups:newGroups, dockGroupsByAnchor:newByAnchor});
 Actions.setCell(arr.id, anchor, `Dock:${mode} ${group.members.join(',')}`, ast.raw, true);
});
// Removed TRANSPONSe alias to avoid confusion
tag('SHIFT',['PURE','BLOCK'], (anchor,arr,ast,tx)=>{
 if(!tx) throw new Error('SHIFT requires an active transaction');
 const input=ast.args[0]; const dx=+Formula.valOf(ast.args[1])|0, dy=ast.args[2]!==undefined?(+Formula.valOf(ast.args[2])|0):0, dz=ast.args[3]!==undefined?(+Formula.valOf(ast.args[3])|0):0;
 const values=(input&&input.kind==='range')?input.cells.map(c=>Formula.valOf(c)):[Formula.valOf(input)];
 values.forEach((v,i)=> {
 Write.set(tx, arr.id, {x:anchor.x+dx,y:anchor.y+dy+i,z:anchor.z+dz}, { value: v, formula: null, meta:{generated:true, emitter:aKey(anchor)} });
 });
 Write.set(tx, arr.id, anchor, { value: 'SHIFT:OK', formula: ast.raw });
});

// ROTATE(rangeOrArray, axis)
// axis: 0=XY, 1=YZ, 2=XZ. Rotates 90 around anchor on that plane.
console.log('Registering ROTATE function...');
tag('ROTATE',['PURE','BLOCK'], (anchor,arr,ast,tx)=>{
 const __ownsTx = !tx; if(__ownsTx) tx = Write.start('rotate.auto','ROTATE');
 console.log('=== ROTATE DEBUG START ===');
 console.log('ROTATE called with:', {
 anchor: `${anchor.x},${anchor.y},${anchor.z}`,
 arrayId: arr.id,
 astRaw: ast.raw,
 astFn: ast.fn,
 astArgs: ast.args,
 argCount: ast.args?.length,
 hasTx: !!tx,
 ownsTx: __ownsTx
 });
 if(ast._astArgs) console.log('Raw AST args:', ast._astArgs);
 
 // Handle AST parsing issues like TRANSPOSE
 let srcArg = ast.args[0];
 console.log('srcArg from ast.args[0]:', srcArg);
 
 // If ast.args[0] is undefined but we have _astArgs, use that instead
 if(!srcArg && ast._astArgs && ast._astArgs.length > 0) {
 srcArg = ast._astArgs[0];
 console.log('Using _astArgs[0] instead:', srcArg);
 }
 
 // Handle axis parameter from both sources
 let axisRaw = 0;
 if(ast.args && ast.args[1] !== undefined) {
 axisRaw = Formula.valOf(ast.args[1]);
 } else if(ast._astArgs && ast._astArgs[1]) {
 axisRaw = Formula.valOf(ast._astArgs[1]);
 }
 
 const axisStr = String(axisRaw||'0').toUpperCase();
 const axis = (axisStr==='XY'||axisStr==='0') ? 0 : (axisStr==='YZ'||axisStr==='1') ? 1 : (axisStr==='XZ'||axisStr==='2') ? 2 : (+axisStr|0);
 console.log('ROTATE params:', {axisRaw, axis});
 const S=Store.getState(); const ak=aKey(anchor);
 // Clear previously emitted from this anchor
 try{ const prev=S.emittedByAnchor?.get?.(ak); if(prev){ prev.forEach(ck=>{ try{ const [aid,rest]=ck.split(':'); const [cx,cy,cz]=rest.split(',').map(Number); Write.set(tx,+aid,{x:cx,y:cy,z:cz},{value:'',formula:null,meta:{}}); S.sourceByCell?.delete?.(ck);}catch{} }); S.emittedByAnchor?.delete?.(ak);} }catch{}

 // Track new emissions similar to TRANSPOSE
 const emittedKeys = new Set();
 const recordEmission = (x,y,z)=>{ const ck=`${arr.id}:${x},${y},${z}`; try{ if(!S.sourceByCell || !S.sourceByCell.set){ S.sourceByCell = new Map(S.sourceByCell||[]); } S.sourceByCell.set(ck, ak); emittedKeys.add(ck); }catch{} };
 const finalizeEmissions = ()=>{ try{ if(emittedKeys.size){ if(!S.emittedByAnchor || !S.emittedByAnchor.set){ S.emittedByAnchor = new Map(S.emittedByAnchor||[]); } S.emittedByAnchor.set(ak, emittedKeys); } }catch{} };

 const writeAt=(x,y,z,v,isAnchorWrite)=>{ 
 // If writing in front of alpha (z<0), request a front expansion by shifting all layers forward
 if(z<0){ try{ Actions.expandZFront?.(arr, -z); }catch{} }
 try{ Actions.resizeArrayIfNeeded(arr, {x,y,z}); }catch{}
 const isAnchor=(x===anchor.x&&y===anchor.y&&z===anchor.z); 
 if(!isAnchor||isAnchorWrite){ 
 Write.set(tx, arr.id, {x,y,z}, { value:v, formula:(isAnchor?ast.raw:null), meta:{generated:true, emitter:ak} }); 
 recordEmission(x,y,z);
 } 
 };
 if(srcArg && srcArg.kind==='range'){
 const cells=srcArg.cells; const xs=cells.map(c=>c.x), ys=cells.map(c=>c.y), zs=cells.map(c=>c.z);
 const minX=Math.min(...xs), maxX=Math.max(...xs), minY=Math.min(...ys), maxY=Math.max(...ys), minZ=Math.min(...zs), maxZ=Math.max(...zs);
 let first=null;
 for(let z=minZ; z<=maxZ; z++){
 for(let y=minY; y<=maxY; y++){
 for(let x=minX; x<=maxX; x++){
 const v=Formula.getCellValue({arrId:cells[0].arrId,x,y,z}); if(first===null) first=v;
 let nx=anchor.x, ny=anchor.y, nz=anchor.z;
 if(axis===0){ // XY plane: (x,y)->(y', -x') relative swap around anchor
 const dx=x-minX, dy=y-minY;
 nx = anchor.x + dy;
 ny = anchor.y + (maxX-minX - dx);
 nz = anchor.z + (z-minZ);
 } else if(axis===1){ // YZ plane: (y,z)->(z', -y')
 const dy=y-minY, dz=z-minZ;
 nx = anchor.x + (x-minX);
 ny = anchor.y + dz;
 nz = anchor.z + (maxY-minY - dy);
 } else { // XZ plane: (x,z)->(z', -x')
 const dx=x-minX, dz=z-minZ;
 nx = anchor.x + dz;
 ny = anchor.y + (y-minY);
 nz = anchor.z + (maxX-minX - dx);
 }
 writeAt(nx,ny,nz,v,false);
 }
 }
 }
 writeAt(anchor.x,anchor.y,anchor.z,(first??''),true);
 finalizeEmissions();
 if(__ownsTx) Write.commit(tx);
 return;
 }
 // Handle ARRAY() calls manually (like TRANSPOSE)
 let values = [];
 if(srcArg && (srcArg.type === 'FunctionCall' || srcArg.fn) && String(srcArg.name || srcArg.fn || '').toUpperCase()==='ARRAY'){
 try{
 console.log('Handling ARRAY() call in ROTATE, srcArg:', srcArg);
 // Handle both AST-style (srcArg.arguments) and legacy-style (srcArg.args)
 const argList = srcArg.arguments || srcArg.args || [];
 console.log('ROTATE ARRAY argList:', argList);
 values = argList.map(a=> {
 // Handle different argument formats
 if(a && typeof a === 'object' && 'value' in a) return a.value;
 if(a && typeof a === 'object' && a.type === 'Literal') return a.value;
 return Formula.valOf(a);
 });
 console.log('ROTATE ARRAY values:', values);
 }catch(e){ console.log('ROTATE ARRAY parsing failed:', e); }
 } else {
 // Fallback: rotate a 1D list along axis
 const raw=Formula.valOf(srcArg); 
 values = Array.isArray(raw)?raw.flat():[raw];
 console.log('ROTATE fallback values:', values);
 }
 
 for(let i=0;i<values.length;i++){
 let nx=anchor.x, ny=anchor.y, nz=anchor.z;
 if(axis===0){ ny = anchor.y + i; }
 else if(axis===1){ nz = anchor.z + i; }
 else { nx = anchor.x + i; }
 console.log(`ROTATE writing cell [${i}]: value="${values[i]}" to (${nx},${ny},${nz})`);
 writeAt(nx,ny,nz,values[i], i===0);
 }
 
 finalizeEmissions();
 console.log('ROTATE completed, values written:', values.length);
 if(__ownsTx) {
 console.log('ROTATE committing transaction');
 Write.commit(tx);
 }
 console.log('=== ROTATE DEBUG END ===');
});

tag('OFFSET',['PURE'], (anchor,arr,ast)=>{
 // Excel-style OFFSET: retrieve value from relative position.
 // y increases downward (top-down grid, flipped 3D Y), so +dy moves down.
 const baseRef=ast.args[0]; // reference cell or default to anchor
 const dx=+valOf(ast.args[1])|0, dy=+valOf(ast.args[2])|0, dz=+valOf(ast.args[3])|0;
 
 // Determine start position
 let startPos = {x:anchor.x, y:anchor.y, z:anchor.z, arrId:anchor.arrId};
 if(baseRef && baseRef.kind==='ref'){
 startPos = {x:baseRef.x, y:baseRef.y, z:baseRef.z, arrId:baseRef.arrId};
 } else {
 const maybe = typeof baseRef==='string' ? parseAlt(String(baseRef)) : null;
 if(maybe){ startPos = {x:maybe.x,y:maybe.y,z:maybe.z,arrId:maybe.arrId}; }
 }
 
 // Apply offsets
 const targetCoord = { x:startPos.x+dx, y:startPos.y+dy, z:startPos.z+dz, arrId:startPos.arrId };
 const value = Formula.getCellValue(targetCoord);
 return value;
});
tag('GET',['PURE'], (anchor,arr,ast)=>{
 // GET reads a ref or first of range; writes scalar to anchor.
 const ref=ast.args[0]; if(ref&&ref.kind==='ref'){ const v=valOf(ref); Actions.setCell(arr.id,anchor, v, ast.raw, true); return; }
 throw new Error('GET needs a ref');
});
tag('ADDRESS',['PURE'],(anchor,arr,ast)=>{
 const t=(ast.args[0]&&ast.args[0].kind==='ref')?ast.args[0]:anchor;
 Actions.setCell(arr.id,anchor, `${A1(t.x)}${t.y+1}${greek(t.z)}`, ast.raw,true);
});
// SELF: returns anchor's absolute ref coordinates
tag('SELF',['PURE'],(anchor,arr,ast)=>{
 // Return absolute reference string so it works as an argument (e.g., DELETE(SELF()))
 return `@[${anchor.x},${anchor.y},${anchor.z},${anchor.arrId}]`;
});
// IS_SELECTED([ref]): 1 if the provided ref (or self) is the focused cell
tag('IS_SELECTED',['PURE'],(anchor,arr,ast)=>{
 const s=Store.getState().selection; if(!s?.arrayId||!s.focus){ Actions.setCell(arr.id,anchor,0,ast.raw,true); return; }
 const t=(ast.args[0]&&ast.args[0].kind==='ref')?ast.args[0]:anchor;
 const v=(s.arrayId===t.arrId && s.focus.x===t.x && s.focus.y===t.y && s.focus.z===t.z)?1:0;
 Actions.setCell(arr.id,anchor, v, ast.raw, true);
});
tag('ALT_ADDRESS',['PURE'],(anchor,arr,ast)=>{
 const t=(ast.args[0]&&ast.args[0].kind==='ref')?ast.args[0]:anchor;
 Actions.setCell(arr.id,anchor, `@[${t.x},${t.y},${t.z},${t.arrId}]`, ast.raw,true);
});
tag('IF',['PURE'],(anchor,arr,ast)=>{
 const evalArg = (a)=> Formula.valOf(a);
 const isTruthy=(v)=>{
 if (v===null || v===undefined) return false;
 if (typeof v==='boolean') return v;
 if (Array.isArray(v)) return v.some(isTruthy);
 const n = Number(v);
 if(!Number.isNaN(n) && String(v).trim()!=='') return n!==0;
 const s = String(v).trim().toLowerCase();
 return !(s==='' || s==='false' || s==='0');
 };
 const cond = evalArg(ast.args[0]);
 const out = isTruthy(cond) ? evalArg(ast.args[1]) : (ast.args[2]!==undefined ? evalArg(ast.args[2]) : '');
 return out;
});
tag('REVERSE',['PURE'],(anchor,arr,ast)=>{

 const a=valOf(ast.args[0]); const out=Array.isArray(a)?[...a].reverse():String(a).split('').reverse().join('');
 Actions.setCell(arr.id,anchor, Array.isArray(out)?`[${out.join(',')}]`:out, ast.raw,true);
});
tag('ADD',['PURE'],(anchor,arr,ast)=>{

 const sum=(ast.args.map(valOf).flat()).reduce((a,b)=>a+(+b||0),0);
 Actions.setCell(arr.id,anchor,sum,ast.raw,true);
});
tag('MUL',['PURE'],(anchor,arr,ast)=>{

 const prod=(ast.args.map(valOf).flat()).reduce((a,b)=>a*(+b||1),1);
 Actions.setCell(arr.id,anchor,prod,ast.raw,true);
});
// LOGICALS & COMPARISONS & MATH
tag('AND',['PURE'],(anchor,arr,ast)=>{ const valOf=Formula.valOf; const v=ast.args.map(valOf).flat().every(x=>!!x)?1:0; Actions.setCell(arr.id,anchor,v,ast.raw,true); });
tag('OR',['PURE'],(anchor,arr,ast)=>{ const valOf=Formula.valOf; const v=ast.args.map(valOf).flat().some(x=>!!x)?1:0; Actions.setCell(arr.id,anchor,v,ast.raw,true); });
tag('NOT',['PURE'],(anchor,arr,ast)=>{ const valOf=Formula.valOf; const v=!valOf(ast.args[0]); Actions.setCell(arr.id,anchor,v?1:0,ast.raw,true); });
tag('EQ',['PURE'],(anchor,arr,ast)=>{ const valOf=Formula.valOf; const [a,b]=ast.args.map(valOf); Actions.setCell(arr.id,anchor,(a==b)?1:0,ast.raw,true); });
tag('NEQ',['PURE'],(anchor,arr,ast)=>{ const valOf=Formula.valOf; const [a,b]=ast.args.map(valOf); Actions.setCell(arr.id,anchor,(a!=b)?1:0,ast.raw,true); });
tag('GT',['PURE'],(anchor,arr,ast)=>{ const valOf=Formula.valOf; const [a,b]=ast.args.map(valOf).map(Number); Actions.setCell(arr.id,anchor,(a>b)?1:0,ast.raw,true); });
tag('GTE',['PURE'],(anchor,arr,ast)=>{ const valOf=Formula.valOf; const [a,b]=ast.args.map(valOf).map(Number); Actions.setCell(arr.id,anchor,(a>=b)?1:0,ast.raw,true); });
tag('LT',['PURE'],(anchor,arr,ast)=>{ const valOf=Formula.valOf; const [a,b]=ast.args.map(valOf).map(Number); Actions.setCell(arr.id,anchor,(a<b)?1:0,ast.raw,true); });
tag('LTE',['PURE'],(anchor,arr,ast)=>{ const valOf=Formula.valOf; const [a,b]=ast.args.map(valOf).map(Number); Actions.setCell(arr.id,anchor,(a<=b)?1:0,ast.raw,true); });
tag('CLAMP',['PURE'],(anchor,arr,ast)=>{ const valOf=Formula.valOf; const x=+valOf(ast.args[0])||0, mn=(+valOf(ast.args[1])||0), mx=(+valOf(ast.args[2])||0); Actions.setCell(arr.id,anchor, Math.min(mx,Math.max(mn,x)), ast.raw,true); });

const __dirMap = {
 north:{dx:0,dy:-1,dz:0}, south:{dx:0,dy:1,dz:0},
 east:{dx:1,dy:0,dz:0}, west:{dx:-1,dy:0,dz:0},
 front:{dx:0,dy:0,dz:-1}, back:{dx:0,dy:0,dz:1}
};
function __parseDirectionToken(token){
 if(token===undefined||token===null) return null;
 const str=String(token).trim();
 if(!str) return null;
 const lower=str.toLowerCase();
 if(__dirMap[lower]) return __dirMap[lower];
 switch(str.toUpperCase()){
 case 'N': case '-Y': return __dirMap.north;
 case 'S': case '+Y': case 'Y': return __dirMap.south;
 case 'E': case '+X': case 'X': return __dirMap.east;
 case 'W': case '-X': return __dirMap.west;
 case 'F': case 'FRONT': case '-Z': return __dirMap.front;
 case 'B': case 'BACK': case '+Z': case 'Z': return __dirMap.back;
 default: return null;
 }
}

tag('ADJACENT',['PURE'],(anchor,arr,ast)=>{
 const values=[];
 const dirs=[];
 const addTokens=(val)=>{
 if(val==null) return;
 if(Array.isArray(val)) return val.forEach(addTokens);
 String(val).split(/[\s,]+/).filter(Boolean).forEach(tok=>{
 const parsed=__parseDirectionToken(tok);
 if(parsed) dirs.push(parsed);
 });
 };
 if(ast.args.length){ ast.args.forEach(arg=> addTokens(Formula.valOf(arg))); }
 if(!dirs.length){ dirs.push(__dirMap.north,__dirMap.south,__dirMap.east,__dirMap.west,__dirMap.front,__dirMap.back); }
 dirs.forEach(vec=>{
 const coord={x:anchor.x+vec.dx,y:anchor.y+vec.dy,z:anchor.z+vec.dz};
 values.push(Formula.getCellValue({arrId:anchor.arrId||arr.id, ...coord}));
 });
 if(values.length===0) return '';
 return values.length===1 ? values[0] : values;
});

tag('DETECT',['PURE'],(anchor,arr,ast)=>{
 const lookup=Formula.valOf(ast.args[0]);
 const target=String(lookup??'');
 const maxRange=ast.args[1]!==undefined ? Math.max(1, Math.abs((+Formula.valOf(ast.args[1])|0))) : Math.max(arr.size?.x||1, arr.size?.y||1, arr.size?.z||1);
 const dirs=[
 {axis:'X',dx:1,dy:0,dz:0},
 {axis:'X',dx:-1,dy:0,dz:0},
 {axis:'Y',dx:0,dy:1,dz:0},
 {axis:'Y',dx:0,dy:-1,dz:0},
 {axis:'Z',dx:0,dy:0,dz:1},
 {axis:'Z',dx:0,dy:0,dz:-1}
 ];
 const bounds={x:arr.size?.x??0,y:arr.size?.y??0,z:arr.size?.z??0};
 for(const dir of dirs){
 for(let step=1; step<=maxRange; step++){
 const x=anchor.x+dir.dx*step;
 const y=anchor.y+dir.dy*step;
 const z=anchor.z+dir.dz*step;
 if(x<0||y<0||z<0||x>=bounds.x||y>=bounds.y||z>=bounds.z) break;
 const val=Formula.getCellValue({arrId:anchor.arrId||arr.id,x,y,z});
 if(String(val)===target){
 const sign=(dir.dx+dir.dy+dir.dz)>0?step:-step;
 return `${dir.axis}:${sign}`;
 }
 }
 }
 return '';
});

tag('ISNUMBER',['PURE'],(anchor,arr,ast)=>{
 const value = ast.args.length ? Formula.valOf(ast.args[0]) : '';
 let isNum=false;
 if(typeof value==='number'){ isNum=Number.isFinite(value); }
 else if(typeof value==='string'){ const trimmed=value.trim(); if(trimmed){ const num=Number(trimmed); isNum=Number.isFinite(num); } }
 else if(value!=null){ const num=Number(value); isNum=Number.isFinite(num); }
 return isNum?1:0;
});

tag('SEARCH',['PURE'],(anchor,arr,ast)=>{
 const find=String(Formula.valOf(ast.args[0]??''));
 const within=String(Formula.valOf(ast.args[1]??''));
 const startRaw=ast.args[2]!==undefined ? (+Formula.valOf(ast.args[2])|0) : 1;
 const start=Math.max(1,startRaw);
 if(start>within.length) throw new Error('SEARCH:OUT_OF_RANGE');
 const idx=within.toLowerCase().indexOf(find.toLowerCase(),start-1);
 if(idx===-1) throw new Error('SEARCH:NOT_FOUND');
 return idx+1;
});

// WRITE HELPERS
tag('SET',['ACTION'],(anchor,arr,ast,tx)=>{ 
 if(!tx) throw new Error('SET requires an active transaction');
 const target=ast.args[0]; const value=ast.args[1]; const overwrite=ast.args[2]!==undefined?!!valOf(ast.args[2]):true;
 let tref=null;
 if(target&&target.kind==='ref'){ 
 tref = {x:target.x,y:target.y,z:target.z,arrId:target.arrId};
 } else if(typeof target==='string'){
 const parsed = parseAlt(String(target));
 if(parsed) tref = {x:parsed.x,y:parsed.y,z:parsed.z,arrId:parsed.arrId};
 } else {
 const sval = valOf(target);
 if(typeof sval==='string'){
 const parsed = parseAlt(String(sval));
 if(parsed) tref = {x:parsed.x,y:parsed.y,z:parsed.z,arrId:parsed.arrId};
 }
 }
 if(tref){
 const v=valOf(value); 
 const cell=Formula.getCell({arrId:tref.arrId,x:tref.x,y:tref.y,z:tref.z});
 const isEmpty = (val) => val === '' || val === null || val === undefined;
 if(overwrite || isEmpty(cell.value)){
 Write.set(tx, tref.arrId, {x:tref.x,y:tref.y,z:tref.z}, { value: v, formula: null });
 }
 return; 
 } 
 throw new Error('SET needs target ref'); 
});
// DISPLAY_AS(displayText[, refOrSelf]) set display-only text in meta without changing value
tag('DISPLAY_AS',['ACTION'],(anchor,arr,ast)=>{
 const text = String(valOf(ast.args[0]||''));
 const t = (ast.args[1]&&ast.args[1].kind==='ref')?ast.args[1]:anchor;
 const ch=arr.chunks[keyChunk(...Object.values(chunkOf(t.x,t.y,t.z)))];
 const idx=ch?.cells.findIndex(c=>c.x===t.x&&c.y===t.y&&c.z===t.z) ?? -1;
 if(idx<0||!ch){ Actions.setCell(arr.id,anchor,'DISPLAY_AS:FAIL',ast.raw,true); return; }
 const prev=ch.cells[idx];
 ch.cells[idx] = {...prev, meta:{...(prev.meta||{}), displayText:text}};
 // trigger re-render of 2D and 3D sprites
 UI.renderSheetCell(arr, t.x, t.y, t.z);
 Scene.updateValueSprite(arr, t.x, t.y, t.z, ch.cells[idx]);
 // silent: do not stamp anchor
});
tag('BOUNCE',['ACTION'],(anchor,arr,ast,tx)=>{
 const valOf = Formula.valOf;
 const modeRaw = Math.round(Number(valOf(ast.args[0] ?? 0)) || 0);
 const bounceType = modeRaw === 1 ? 'land' : 'walk';
 const heightRaw = Number(valOf(ast.args[1] ?? 0));
 const height = Number.isFinite(heightRaw) ? Math.max(0, heightRaw) : 0;
 const targets = collectTargetCells(ast.args[2], anchor);
 const info = ensureTransaction(tx, 'scene.bounce', 'Configure bounce pads');
 const formatHeight = (value)=>{
 const num = Number(value);
 if(!Number.isFinite(num) || num <= 0) return 'OFF';
 const precision = Math.abs(num) >= 10 ? 1 : 2;
 return num.toFixed(precision).replace(/\.0+$/,'').replace(/(\.[0-9]*?)0+$/,'$1');
 };
 targets.forEach(target=>{
 mutateCellMeta(info.tx, target, meta=>{
 const next = {...meta};
 let rawConfig = next.bounceConfig ?? next.bounce ?? null;
 if(typeof rawConfig === 'string'){
 try{ rawConfig = JSON.parse(rawConfig); }catch{}
 }
 const config = {};
 if(rawConfig && typeof rawConfig === 'object'){
 if(Array.isArray(rawConfig)){
 if(Number.isFinite(+rawConfig[0])) config.walk = +rawConfig[0];
 if(Number.isFinite(+rawConfig[1])) config.land = +rawConfig[1];
 } else {
 if(Number.isFinite(+rawConfig.walk)) config.walk = +rawConfig.walk;
 if(Number.isFinite(+rawConfig.land)) config.land = +rawConfig.land;
 if(Number.isFinite(+rawConfig.onWalk)) config.walk = +rawConfig.onWalk;
 if(Number.isFinite(+rawConfig.onLand)) config.land = +rawConfig.onLand;
 }
 }
 if(height > 0){
 config[bounceType] = height;
 } else {
 delete config[bounceType];
 }
 ['walk','land'].forEach(key=>{
 const val = config[key];
 if(!Number.isFinite(val) || val <= 0){
 delete config[key];
 } else {
 config[key] = Number(val);
 }
 });
 if(Object.keys(config).length){
 next.bounceConfig = config;
 } else {
 delete next.bounceConfig;
 }
 if(next.bounce !== undefined) delete next.bounce;
 const labelParts = [];
 if(Number.isFinite(config.walk) && config.walk > 0){
 labelParts.push(`W:${formatHeight(config.walk)}`);
 }
 if(Number.isFinite(config.land) && config.land > 0){
 labelParts.push(`L:${formatHeight(config.land)}`);
 }
 if(labelParts.length){
 next.displayText = `?? ${labelParts.join(' ')}`;
 next.bounceLabel = true;
 } else if(next.bounceLabel){
 delete next.displayText;
 delete next.bounceLabel;
 }
 return next;
 });
 });
 finalizeTransaction(info);
 targets.forEach(target=>{
 try{
 const targetArr = Store.getState().arrays[target.arrId];
 if(!targetArr) return;
 if(window.UI?.renderSheetCell) window.UI.renderSheetCell(targetArr, target.x, target.y, target.z);
 const updated = Formula.getCell({arrId:target.arrId,x:target.x,y:target.y,z:target.z});
 if(updated) Scene.updateValueSprite(targetArr, target.x, target.y, target.z, updated);
 }catch{}
 });
 const summary = height > 0 ? formatHeight(height) : 'OFF';
 const suffix = targets.length > 1 ? ` ${targets.length}` : '';
 Actions.setCell(arr.id, anchor, `bounce:${bounceType}:${summary}${suffix}`, ast.raw, true);
});

function __collectMetaTargets(rangeArg, anchor, arr){
 if(rangeArg && rangeArg.kind==='range'){
 return rangeArg.cells.map(c=>({arrId:c.arrId??arr.id, x:c.x, y:c.y, z:c.z}));
 }
 if(rangeArg && rangeArg.kind==='ref'){
 return [{arrId:rangeArg.arrId??arr.id, x:rangeArg.x, y:rangeArg.y, z:rangeArg.z}];
 }
 return [{arrId:arr.id, x:anchor.x, y:anchor.y, z:anchor.z}];
}

function __applyMetaAction(cells, key, action){
 const canonicalKey = canonicalMetaKey(key);
 const tx = Write.start(`meta.${canonicalKey}`,'Meta binding');
 cells.forEach(target=>{
 const existing = Formula.getCell({arrId:target.arrId, x:target.x, y:target.y, z:target.z});
 let meta = normalizeMetaKeys(existing.meta||{});
 const aliases = META_KEY_ALIASES[canonicalKey] || [];
 if(action===null){
 delete meta[canonicalKey];
 aliases.forEach(alias=>delete meta[alias]);
 }
 else {
 meta[canonicalKey] = action;
 aliases.forEach(alias=>delete meta[alias]);
 }
 Write.set(tx, target.arrId, {x:target.x,y:target.y,z:target.z}, { value: existing.value, formula: existing.formula, meta });
 });
 Write.commit(tx);
}

tag('ON_HOLD',['META'],(anchor,arr,ast)=>{
 if(ast.args.length===1 && typeof ast.args[0]==='string'){
 const t=ast.args[0].trim().toLowerCase();
 if(['off','none','false','0'].includes(t)){
 __applyMetaAction([{arrId:arr.id,x:anchor.x,y:anchor.y,z:anchor.z}], 'on_hold', null);
 Actions.setCell(arr.id, anchor, 'on_hold:OFF', ast.raw, true);
 return;
 }
 }
 let rangeArg=null, actionArgIndex=0;
 if(ast.args.length>=2){ rangeArg=ast.args[0]; actionArgIndex=1; }
 const raw = ast.args[actionArgIndex];
 let action = (typeof raw==='string')? raw : String(Formula.valOf(raw)||'');
 if(action && action[0] !== '=') action = `=${action}`;
 const targets = __collectMetaTargets(rangeArg, anchor, arr);
 __applyMetaAction(targets, 'on_hold', action||null);
 Actions.setCell(arr.id, anchor, `on_hold:${targets.length}`, ast.raw, true);
});

tag('ON_TOUCH',['META'],(anchor,arr,ast)=>{
 if(ast.args.length===1 && typeof ast.args[0]==='string'){
 const t=ast.args[0].trim().toLowerCase();
 if(['off','none','false','0'].includes(t)){
 __applyMetaAction([{arrId:arr.id,x:anchor.x,y:anchor.y,z:anchor.z}], 'on_touch', null);
 Actions.setCell(arr.id, anchor, 'on_touch:OFF', ast.raw, true);
 return;
 }
 }
 let rangeArg=null, actionIdx=0;
 if(ast.args.length>=2){ rangeArg=ast.args[0]; actionIdx=1; }
 const raw = ast.args[actionIdx];
 let action = (typeof raw==='string')? raw : String(Formula.valOf(raw)||'');
 if(action && action[0] !== '=') action = `=${action}`;
 const targets = __collectMetaTargets(rangeArg, anchor, arr);
 __applyMetaAction(targets, 'on_touch', action||null);
 Actions.setCell(arr.id, anchor, `on_touch:${targets.length}`, ast.raw, true);
});

tag('ON_LAND',['META'],(anchor,arr,ast)=>{
 if(ast.args.length===1 && typeof ast.args[0]==='string'){
 const t=ast.args[0].trim().toLowerCase();
 if(['off','none','false','0'].includes(t)){
 __applyMetaAction([{arrId:arr.id,x:anchor.x,y:anchor.y,z:anchor.z}], 'on_land', null);
 Actions.setCell(arr.id, anchor, 'on_land:OFF', ast.raw, true);
 return;
 }
 }
 let rangeArg=null, actionIdx=0;
 if(ast.args.length>=2){ rangeArg=ast.args[0]; actionIdx=1; }
 const raw = ast.args[actionIdx];
 let action = (typeof raw==='string')? raw : String(Formula.valOf(raw)||'');
 if(action && action[0] !== '=') action = `=${action}`;
 const targets = __collectMetaTargets(rangeArg, anchor, arr);
 __applyMetaAction(targets, 'on_land', action||null);
 Actions.setCell(arr.id, anchor, `on_land:${targets.length}`, ast.raw, true);
});

const ACTION_TICK_MS = 1000/60;
function normalizeActionFormula(raw){
 let formula = String(raw==null?'':raw).trim();
 if(!formula) return '';
 if(formula.startsWith('B64:')){
 try{ formula = atob(formula.slice(4)); }catch{}
 } else {
 const colon = formula.indexOf(':');
 if(colon>0 && /^\d+$/.test(formula.slice(0,colon))){
 const enc=formula.slice(colon+1);
 try{ formula = atob(enc); }catch{}
 }
 }
 formula = String(formula||'').trim();
 if(!formula) return '';
 if(!formula.startsWith('=')) formula = `=${formula}`;
 return formula;
}

function executeActionFormula(anchor, action, label){
 const formula = normalizeActionFormula(action);
 if(!formula) return;
 warmChimeIfNeeded(formula);
 const tx = Write.start(`meta.${label||'action'}`, `${label||'action'} handler`);
 try{
 Formula.runOnceAt(anchor, formula, tx);
 Write.commit(tx);
 }catch(err){
 console.warn(`${label||'Action'} execution failed`, err);
 try{ Write.rollback(tx); }catch{}
 }
}
// ONCLICK([targetRefOrRange], actionFormulaOrBlock) bind click to execute nested action(s)
tag('ONCLICK',['ACTION'],(anchor,arr,ast)=>{
 const parseRawArgs=(raw)=>{
 if(!raw || typeof raw!=='string') return [];
 const open=raw.indexOf('(');
 const close=raw.lastIndexOf(')');
 if(open<0||close<=open) return [];
 const inner=raw.slice(open+1, close);
 const args=[];
 let current='';
 let depth=0;
 let quote=null;
 let escape=false;
 for(let i=0;i<inner.length;i++){
 const ch=inner[i];
 if(escape){ current+=ch; escape=false; continue; }
 if(quote){
 current+=ch;
 if(ch==='\\'){ escape=true; continue; }
 if(ch===quote){ quote=null; }
 continue;
 }
 if(ch==='"' || ch==="'"){ quote=ch; current+=ch; continue; }
 if(ch==='('){ depth++; current+=ch; continue; }
 if(ch===')'){
 if(depth>0){ depth--; current+=ch; continue; }
 }
 if(ch===',' && depth===0){ args.push(current.trim()); current=''; continue; }
 current+=ch;
 }
 if(current.trim().length || inner.trim().length===0){ args.push(current.trim()); }
 return args;
 };
 const normalizeActionString=(raw)=>{
 if(!raw) return '';
 let trimmed=String(raw).trim();
 if(!trimmed) return '';
 if((trimmed.startsWith('"') && trimmed.endsWith('"'))){
 try{ trimmed = JSON.parse(trimmed); }
 catch{}
 }
 trimmed = String(trimmed||'').trim();
 if(!trimmed) return '';
 if(trimmed.startsWith('=') || /^B64:/i.test(trimmed) || /^\d+:/.test(trimmed)) return trimmed;
 return `=${trimmed}`;
 };
 const resolveTargetArg=(arg)=>{
 if(!arg) return null;
 if(arg.kind==='range' || arg.kind==='ref') return arg;
 try{
 const raw = Formula.valOf(arg);
 if(raw==null) return null;
 const text = String(raw).trim();
 if(!text) return null;
 if(text.toLowerCase()==='self') return anchor;
 const parsed = parseAlt(text, anchor) || parseA1g(text, arr.id);
 if(parsed) return parsed;
 }catch{}
 return null;
 };

 const rawArgs = parseRawArgs(ast?.raw||'');
 const actionRawStr = rawArgs.length>=2 ? rawArgs[1] : (rawArgs[0]||'');
 const actionFormula = normalizeActionString(actionRawStr);
 if(!actionFormula){ return; }

 const targetArg = ast.args.length>=2 ? ast.args[0] : null;
 const resolvedTarget = resolveTargetArg(targetArg) || anchor;

 const register = (t)=>{
 const arrId = t.arrId ?? arr.id;
 const targetArr = Store.getState().arrays[arrId];
 if(!targetArr) return;
 const coord = {x:t.x, y:t.y, z:t.z};
 const chKey = keyChunk(...Object.values(chunkOf(coord.x,coord.y,coord.z)));
 const ch=targetArr.chunks[chKey];
 const idx=ch?.cells.findIndex(c=>c.x===coord.x&&c.y===coord.y&&c.z===coord.z) ?? -1;
 if(idx<0||!ch) return;
 const prev=ch.cells[idx];
 const meta = normalizeMetaKeys(prev.meta||{});
 meta.on_click = actionFormula;
 meta.onClickBusy = false;
 ch.cells[idx] = {...prev, meta};
 UI.renderSheetCell(targetArr, coord.x, coord.y, coord.z);
 try{ ch.markDirty?.(); Scene.renderArray(targetArr); }catch{}
 };

 const markClickable=(coord)=>{
 const td=document.querySelector(`td.cell[data-x="${coord.x}"][data-y="${coord.y}"][data-z="${coord.z}"]`);
 if(td) td.classList.add('clickable');
 };

 if(resolvedTarget && resolvedTarget.kind==='range'){
 const xs=resolvedTarget.cells.map(c=>c.x), ys=resolvedTarget.cells.map(c=>c.y);
 const minX=Math.min(...xs), maxY=Math.max(...ys);
 resolvedTarget.cells.forEach(c=> markClickable(c));
 register({x:minX,y:maxY,z:resolvedTarget.cells[0].z, arrId: resolvedTarget.cells[0].arrId});
 } else if(resolvedTarget && resolvedTarget.kind==='ref'){
 markClickable(resolvedTarget);
 register(resolvedTarget);
 } else {
 if(resolvedTarget && resolvedTarget!==anchor){ markClickable(resolvedTarget); }
 register({...resolvedTarget, arrId: resolvedTarget.arrId ?? arr.id});
 }
 // Silent registration
});
// TOAST(message[, duration]) show toast notification (diegetic, 2D-only)
tag('TOAST',['ACTION'],(anchor,arr,ast)=>{
 const message = String(valOf(ast.args[0]||''));
 const duration = (+valOf(ast.args[1])||3000);
 showToast(message);
 setTimeout(()=>{ const toast=document.getElementById('toast'); if(toast) toast.style.display='none'; }, duration);
 // Silent: do not stamp anchor
});
tag('SONG',['ACTION'],()=>{
 const audio = ensureCreditsSongAudio();
 if(!audio) return;
 try {
  audio.currentTime = 0;
  const playPromise = audio.play();
  if(playPromise && typeof playPromise.then === 'function'){
   playPromise.catch(err=>{ console.warn('SONG(): Unable to play credits.mp3', err); });
  }
 } catch(err){
  console.warn('SONG(): Error playing credits.mp3', err);
 }
});
// ONCLICK_WRAPPER(actionFormulaOrBlock, targetRef?) helper to add on_click meta easily
tag('ONCLICK_WRAPPER',['ACTION'],(anchor,arr,ast)=>{
 const action = String(valOf(ast.args[0]||''));
 const target = ast.args[1] || anchor;
 const t = (target&&target.kind)? target : anchor;
 const targetArr = Store.getState().arrays[t.arrId || arr.id];
 if(!targetArr) return;
 // Attach meta.on_click and refresh cell rendering in target array
 const ch=targetArr.chunks[keyChunk(...Object.values(chunkOf(t.x,t.y,t.z)))]; if(!ch) return;
 const idx=ch.cells.findIndex(c=>c.x===t.x&&c.y===t.y&&c.z===t.z); if(idx<0) return;
 const prev=ch.cells[idx];
 const meta = normalizeMetaKeys(prev.meta||{});
 meta.on_click = action;
 ch.cells[idx] = {...prev, meta};
 const s=Store.getState().selection; const currentId = s.arrayId ?? (Store.getState().arrays[1]?1:-1);
 if(currentId === (t.arrId||arr.id) && window.UI?.renderSheetCell) window.UI.renderSheetCell(targetArr, t.x, t.y, t.z);
});
// NOTE(text[, targetRefOrRange]) add note visible only in 2D; highlights range and stores note at top-left
 tag('NOTE',['ACTION'],(anchor,arr,ast)=>{
 const noteText = String(valOf(ast.args[0]||''));
 const target = ast.args[1] || anchor;
 const applyNote = (t)=>{
 const targetArr = Store.getState().arrays[t.arrId || arr.id];
 if(!targetArr){ console.warn('NOTE: target array missing', t); return; }
 const chKey = keyChunk(...Object.values(chunkOf(t.x,t.y,t.z)));
 let ch = targetArr.chunks[chKey];
 if(!ch){
 Actions.resizeArrayIfNeeded(targetArr, t);
 ch = targetArr.chunks[chKey];
 if(!ch){ console.warn('NOTE: chunk still missing', t); return; }
 }
 let idx = ch.cells.findIndex(c=>c.x===t.x&&c.y===t.y&&c.z===t.z);
 if(idx<0){ ch.cells.push({x:t.x, y:t.y, z:t.z, value:'', formula:null, meta:{}}); idx = ch.cells.length - 1; }
 const prev = ch.cells[idx];
 ch.cells[idx] = {...prev, meta:{...(prev.meta||{}), noteText}};
 console.log('NOTE: set meta', {arrId:targetArr.id, x:t.x, y:t.y, z:t.z, meta:ch.cells[idx].meta});
 const s=Store.getState().selection; const currentId = s.arrayId ?? (Store.getState().arrays[1]?1:-1);
 if(currentId === (t.arrId||arr.id) && window.UI?.renderSheetCell) window.UI.renderSheetCell(targetArr, t.x, t.y, t.z);
 };
 if(target && target.kind==='range'){
 target.cells.forEach(c=>{
 const td=document.querySelector(`td.cell[data-x="${c.x}"][data-y="${c.y}"][data-z="${c.z}"]`);
 if(td) td.classList.add('note-hl');
 });
 const xs=target.cells.map(c=>c.x), ys=target.cells.map(c=>c.y);
 const minX=Math.min(...xs), maxY=Math.max(...ys);
 applyNote({x:minX,y:maxY,z:target.cells[0].z, arrId:target.cells[0].arrId});
 } else if(target && target.kind==='ref'){
 const td=document.querySelector(`td.cell[data-x="${target.x}"][data-y="${target.y}"][data-z="${target.z}"]`);
 if(td) td.classList.add('note-hl');
 applyNote(target);
 } else {
 applyNote({...anchor});
 }
 // Silent: do not stamp anchor
 });

// META (legacy helper) renamed to avoid overriding ACTION CREATE
tag('CREATE_META',['META'],(anchor,arr,ast)=>{
 // Defaults if omitted: 6x4x6 at origin
 const x=(ast.args[0]!==undefined)?(+valOf(ast.args[0])|0):6;
 const y=(ast.args[1]!==undefined)?(+valOf(ast.args[1])|0):4;
 const z=(ast.args[2]!==undefined)?(+valOf(ast.args[2])|0):6;
 const name=ast.args[3]!==undefined?String(valOf(ast.args[3])):'Array';
 const explicitId=ast.args[4]!==undefined?(+valOf(ast.args[4])|0):undefined;
 const newArr=Actions.createArray({size:{x,y,z},name,id:explicitId,offset:{x:0,y:0,z:0}});
 // Write a minimal confirmation; do not overwrite anchor with header text
 Actions.setCell(arr.id,anchor,`${name} #${newArr.id}`,null,true);
});
tag('NAME',['META'],(anchor,arr,ast)=>{

 if(ast.args.length===1){ arr.name=String(valOf(ast.args[0])); Scene.refreshArray?.(arr); Actions.setCell(arr.id,anchor,`Name:${arr.name}`,ast.raw,true); return; }
 // =NAME(alias, formula) - store macro
 const alias=String(valOf(ast.args[0])); const formula=String(valOf(ast.args[1]));
 Store.setState(s=>({namedMacros:new Map([...s.namedMacros,[alias,formula]])}));
 Actions.setCell(arr.id,anchor,`Macro:${alias}`,ast.raw,true);
});
tag('PARAMETERS',['META'],(anchor,arr,ast)=>{

 if(ast.args.length===1){ const j=JSON.parse(String(valOf(ast.args[0])||'{}')); arr.params={...(arr.params||{}), ...j}; Actions.setCell(arr.id,anchor,'PARAMETERS:OK',ast.raw,true); return; }
 // =PARAMETERS(formula, arg1, arg2, ...) - pre-bind args
 const formula=String(valOf(ast.args[0])); const boundArgs=ast.args.slice(1).map(valOf);
 const prebound=`${formula}(${boundArgs.map(a=>typeof a==='string'?`"${a}"`:a).join(',')})`;
 Actions.setCell(arr.id,anchor,prebound,ast.raw,true);
});
tag('FUNCTIONS',['META'],(anchor,arr,ast)=>{

 // =FUNCTIONS(mode, ...items) items can be names or tags like ":PURE"
 const mode=(String(valOf(ast.args[0])||'ALLOW_ALL')).toUpperCase();
 const pol={mode, allow:new Set(), deny:new Set(), tags:new Set()};
 const items=ast.args.slice(1).map(valOf).flat().map(String);
 items.forEach(it=>{ if(it.startsWith(':')) pol.tags.add(it.slice(1).toUpperCase()); else (mode==='ALLOW_ONLY'?pol.allow:pol.deny).add(it.toUpperCase()); });
 arr.fnPolicy=pol;
 Actions.setCell(arr.id,anchor,'FUNCTIONS:OK',ast.raw,true);
});
tag('LOCK',['META'],(anchor,arr,ast)=>{

 const state=!!valOf(ast.args[0]); if(!state){arr.locks.clear(); Actions.setCell(arr.id,anchor,'LOCK:OFF',ast.raw,true); return;}
 const add=(r)=>{ if(r.kind==='ref') arr.locks.add(aKey(r)); if(r.kind==='range') r.cells.forEach(c=>arr.locks.add(aKey(c))); };
 ast.args.slice(1).forEach(a=>{ if(a?.kind) add(a); });
 Actions.setCell(arr.id,anchor,`LOCK:${arr.locks.size}`,ast.raw,true);
});
// CA (toy)
tag('CA',['PURE'],(anchor,arr,ast)=>{
 const type=String(valOf(ast.args[0])||'life').toLowerCase();
 const steps=+valOf(ast.args[1])||1; const axis=String(valOf(ast.args[2])||'Y').toUpperCase(); const index=+valOf(ast.args[3])|0;
 if(type!=='life') throw new Error('Only life supported');
 CA.runLife2D(arr,{axis,index,steps});
 Actions.setCell(arr.id,anchor,`CA:life ${steps} ${axis}=${index}`,ast.raw,true);
});
// NAVIGATION CONTROL FUNCTIONS
tag('OCCLUDE',['SCENE'],(anchor,arr,ast)=>{
 const mode=String(valOf(ast.args[0])||'auto').toLowerCase(); // 'auto', 'array', 'cell', 'off'
 const style=String(valOf(ast.args[1])||'translucent').toLowerCase(); // 'translucent', 'solid', 'wireframe'
 const intensity=+valOf(ast.args[2])||0.4; // 0.0-1.0 opacity
 arr.occlusionMode={mode,style,intensity};
 Actions.setCell(arr.id,anchor,`Occlude:${mode}/${style}/${intensity}`,ast.raw,true);
});
tag('CAMERA_LOCK',['SCENE'],(anchor,arr,ast)=>{
 const axis=String(valOf(ast.args[0])||'').toUpperCase(); // 'X', 'Y', 'Z', or '' for free
 const angle=+valOf(ast.args[1])||0; // fixed angle in degrees
 Scene.setCameraLock(arr,{axis,angle});
 Actions.setCell(arr.id,anchor,`CameraLock:${axis||'free'}/${angle} `,ast.raw,true);
});

// GLOBAL STATE FUNCTIONS
tag('GET_GLOBAL',['PURE'],(anchor,arr,ast)=>{
 const key = String(valOf(ast.args[0]) || '');
 if(!key) throw new Error('GET_GLOBAL requires a key');
 const value = Store.getState().globalState.get(key);
 Actions.setCell(arr.id, anchor, value !== undefined ? value : '', ast.raw, true);
});

tag('SET_GLOBAL',['ACTION'],(anchor,arr,ast)=>{
 const key = String(valOf(ast.args[0]) || '');
 const value = valOf(ast.args[1]);
 if(!key) throw new Error('SET_GLOBAL requires a key');
 
 // Write to global state
 Store.getState().globalState.set(key, value);
 
 // Trigger re-computation for all dependent anchors
 const dependents = Store.getState().anchorsByGlobalKey.get(key) || new Set();
 if(dependents.size > 0) {
 Formula.recomputeAnchors([...dependents]);
 }
 
 Actions.setCell(arr.id, anchor, `Global[${key}] = ${value}`, ast.raw, true);
});

// GET_NEXT_ID(): returns the next array id (does not allocate by itself)
tag('GET_NEXT_ID',["PURE"],(anchor,arr,ast)=>{
 const S=Store.getState();
 return S.nextArrayId || 1;
});

// VALUE_AT(x,y,z, arrIdExpr): returns the value at absolute coordinates without writing
tag('VALUE_AT',["PURE"],(anchor,arr,ast)=>{
 const ax = Number(Formula.valOf(ast.args[0]));
 const ay = Number(Formula.valOf(ast.args[1]));
 const az = Number(Formula.valOf(ast.args[2]));
 const a4 = Formula.valOf(ast.args[3]);
 const arrId = Number(a4);
 if(!Number.isFinite(arrId)) return '';
 const x = (ax===0) ? (anchor?.x|0) : (Number.isFinite(ax) ? (ax-1) : (anchor?.x|0));
 const y = (ay===0) ? (anchor?.y|0) : (Number.isFinite(ay) ? (ay-1) : (anchor?.y|0));
 const z = (az===0) ? (anchor?.z|0) : (Number.isFinite(az) ? (az-1) : (anchor?.z|0));
 return Formula.getCellValue({arrId, x, y, z});
});

// --- Tiny Formula-AST helpers for FORMULIZE ---
function V(v){ return { value:v }; }
function F(name){ return { fn:String(name||'').toUpperCase(), args:[...Array.prototype.slice.call(arguments,1)] }; }
function escForStringLiteral(s){ return String(s).replace(/\\/g,'\\\\').replace(/"/g,'\\\"'); }
function astToString(node, top=true){
 if(node && Object.prototype.hasOwnProperty.call(node,'value')){
 const v=node.value;
 if(typeof v==='string') return `"${escForStringLiteral(v)}"`;
 if(v===true) return 'TRUE';
 if(v===false) return 'FALSE';
 if(v===null || v===undefined) return '""';
 if(Number.isFinite(+v)) return String(+v);
 return `"${escForStringLiteral(String(v))}"`;
 }
 if(node && node.fn){
 const args=(node.args||[]).map(n=>astToString(n,false)).join(', ');
 return (top? '=' : '') + `${node.fn}(${args})`;
 }
 return '""';
}
function remapFormulaIds(f, idMap){
 let out=String(f||'');
 idMap.forEach((newId, oldId)=>{
 const escOld = String(oldId).replace(/[.*+?^${}()|[\]\\]/g,'\\$&');
 out = out.replace(new RegExp(`\\^${escOld}\\b`,'g'), `^${newId}`);
 out = out.replace(new RegExp(`@\\[(-?\\d+),(-?\\d+),(-?\\d+),${escOld}\\]`,'g'), `@[$1,$2,$3,${newId}]`);
 });
 return out;
}

// FORMULIZE: Build a DO{ ... } program that clones reachable arrays
tag('FORMULIZE',["ACTION"],(anchor,arr,ast)=>{
 try{
 const S=Store.getState();

 const resolveRef=(arg)=>{
 if(!arg) return null;
 if(arg.kind==='ref') return arg;
 if(arg.kind==='range' && Array.isArray(arg.cells) && arg.cells.length) return arg.cells[0];
 try{
 const raw = Formula.valOf(arg);
 if(raw && typeof raw==='string'){
 const parsed = parseAlt(raw, anchor) || parseA1g(raw, arr.id);
 if(parsed) return parsed;
 const n = +raw; if(Number.isFinite(n)) return {arrId:n,x:0,y:0,z:0};
 } else {
 const n = +raw; if(Number.isFinite(n)) return {arrId:n,x:0,y:0,z:0};
 }
 }catch{}
 return null;
 };

 const startRef = resolveRef(ast.args?.[0]) || anchor;
 const startId = startRef.arrId ?? arr.id;
 if(!Number.isInteger(startId) || startId<=0 || !S.arrays[startId]){
 Actions.setCell(arr.id, anchor, '!ERR:TARGET', ast.raw, true);
 return;
 }

 const seen=new Set([startId]);
 const queue=[startId];
 const refRe = /@\[(-?\d+),(-?\d+),(-?\d+),(-?\d+)\]/g;
 const caretRe = /\^(\-?\d+)\b/g;
 while(queue.length){
 const aid=queue.shift();
 const A=S.arrays[aid];
 if(!A) continue;
 Object.values(A.chunks||{}).forEach(ch=>{
 (ch.cells||[]).forEach(cell=>{
 const text=cell.formula||'';
 let m;
 while((m=refRe.exec(text))){ const id=+m[4]; if(Number.isInteger(id) && id>0 && !seen.has(id) && S.arrays[id]){ seen.add(id); queue.push(id);} }
 while((m=caretRe.exec(text))){ const id=+m[1]; if(Number.isInteger(id) && id>0 && !seen.has(id) && S.arrays[id]){ seen.add(id); queue.push(id);} }
 });
 });
 }

 const ids=[...seen].filter(id=>Number.isInteger(id) && id>0 && S.arrays[id]).sort((a,b)=>a-b);
 if(ids.length===0){
 Actions.setCell(arr.id, anchor, '!ERR:FORMULIZE_EMPTY', ast.raw, true);
 return;
 }

 const usedIds=new Set(Object.values(S.arrays).map(a=>a.id).filter(id=>Number.isInteger(id)));
 let nextId=Math.max(1, S.nextArrayId || 1);
 const allocateId=()=>{
 while(nextId<=0 || usedIds.has(nextId)) nextId++;
 const assigned=nextId;
 usedIds.add(assigned);
 nextId++;
 return assigned;
 };

 const idMap=new Map();
 ids.forEach(oldId=>{ idMap.set(oldId, allocateId()); });

 const commands=[];

 ids.forEach(oldId=>{
 const A=S.arrays[oldId]; if(!A) return;
 const newId=idMap.get(oldId);
 commands.push( F('CREATE', V(A.size.x), V(A.size.y), V(A.size.z), V(A.name||'Array'), V(newId)) );
 });

 const valueFillAst=(val)=>{
 if(val && typeof val==='object' && !Array.isArray(val)){
 try{ return V(JSON.stringify(val)); }
 catch(_){ return V(String(val)); }
 }
 return V(val);
 };

 ids.forEach(oldId=>{
 const A=S.arrays[oldId]; if(!A) return;
 const newId=idMap.get(oldId);
 const W=A.size.x, H=A.size.y, D=A.size.z;
 const occ=new Map();
 Object.values(A.chunks||{}).forEach(ch=>{
 (ch.cells||[]).forEach(c=>{ occ.set(`${c.x},${c.y},${c.z}`, {v:c.value, f:c.formula}); });
 });
 const visited=new Set();
 const key=(x,y,z)=>`${x},${y},${z}`;
 const inBounds=(x,y,z)=> x>=0&&y>=0&&z>=0&&x<W&&y<H&&z<D;

 const emitFill=(x1,y1,z1,x2,y2,z2,val)=>{
 const fillAst = F('ARRAY', V('fill'), V(x2-x1+1), V(y2-y1+1), V(z2-z1+1), valueFillAst(val));
 const fillText = astToString(fillAst);
 commands.push( F('EXEC_AT', V(x1), V(y1), V(z1), V(newId), V(fillText)) );
 };

 for(let z=0; z<D; z++){
 for(let y=0; y<H; y++){
 for(let x=0; x<W; x++){
 const k=key(x,y,z);
 if(visited.has(k)) continue;
 const cell=occ.get(k)||{v:'',f:null};
 if(cell.f || cell.v==='' || cell.v===null || cell.v===undefined){ continue; }
 let x2=x;
 while(inBounds(x2+1,y,z)){
 const c=occ.get(key(x2+1,y,z))||{v:'',f:null};
 if(visited.has(key(x2+1,y,z)) || c.f || c.v!==cell.v) break;
 x2++;
 }
 let y2=y;
 outerY: while(inBounds(x,y2+1,z)){
 for(let xi=x; xi<=x2; xi++){
 const c=occ.get(key(xi,y2+1,z))||{v:'',f:null};
 if(visited.has(key(xi,y2+1,z)) || c.f || c.v!==cell.v){ break outerY; }
 }
 y2++;
 }
 let z2=z;
 outerZ: while(inBounds(x,y,z2+1)){
 for(let yi=y; yi<=y2; yi++){
 for(let xi=x; xi<=x2; xi++){
 const c=occ.get(key(xi,yi,z2+1))||{v:'',f:null};
 if(visited.has(key(xi,yi,z2+1)) || c.f || c.v!==cell.v){ break outerZ; }
 }
 }
 z2++;
 }
 for(let zz=z; zz<=z2; zz++) for(let yy=y; yy<=y2; yy++) for(let xx=x; xx<=x2; xx++) visited.add(key(xx,yy,zz));
 emitFill(x,y,z,x2,y2,z2,cell.v);
 }
 }
 }
 });

 ids.forEach(oldId=>{
 const A=S.arrays[oldId]; if(!A) return;
 const newId=idMap.get(oldId);
 Object.values(A.chunks||{}).forEach(ch=>{
 (ch.cells||[]).forEach(c=>{
 if(!c.formula) return;
 const remapped = remapFormulaIds(c.formula, idMap);
 const formulaText = remapped.startsWith('=') ? remapped : `=${remapped}`;
 commands.push( F('EXEC_AT', V(c.x), V(c.y), V(c.z), V(newId), V(formulaText)) );
 });
 });
 });

 ids.forEach(oldId=>{
 const A=S.arrays[oldId]; if(!A) return;
 const newId=idMap.get(oldId);
 Object.values(A.chunks||{}).forEach(ch=>{
 (ch.cells||[]).forEach(c=>{
 const color = c?.meta?.color;
 if(!color) return;
 const colorText = astToString( F('COLOR', V(String(color))) );
 commands.push( F('EXEC_AT', V(c.x), V(c.y), V(c.z), V(newId), V(colorText)) );
 });
 });
 });

 ids.forEach(oldId=>{
 const A=S.arrays[oldId]; if(!A) return;
 const newId=idMap.get(oldId);
 const off=A.offset||{x:0,y:0,z:0};
 commands.push( F('SET_ARRAY_POS', V(newId), V(Math.round(off.x||0)), V(Math.round(off.y||0)), V(Math.round(off.z||0))) );
 });

 commands.push( F('SET', F('SELF'), V('')) );

 const statements = commands.map(cmd=>{
 const text = astToString(cmd, true);
 return text.startsWith('=') ? text.slice(1) : text;
 });
 const body = statements.length ? ` ${statements.join(';\n ')};\n` : '';
 const out = `=DO{\n${body}} WITH atomic:1`;
 Actions.setCell(arr.id, anchor, out, ast.raw, true);
 }catch(e){
 Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true);
 }
});

function __cloneEmbeddedMap(existing){
 if(existing instanceof Map) return new Map(existing);
 if(!existing) return new Map();
 try{ return new Map(existing); }
 catch(_){ try{ return new Map(Object.entries(existing)); }catch(__){ return new Map(); } }
}

function __getEmbeddedRecord(key){
 const existing = Store.getState().embeddedMeshes;
 if(existing instanceof Map) return existing.get(key) || null;
 if(!existing) return null;
 try{ return new Map(existing).get(key) || null; }
 catch(_){ try{ return new Map(Object.entries(existing)).get(key) || null; }catch(__){ return null; } }
}

function __setEmbeddedRecord(key, record){
 Store.setState(s=>{
 const map = __cloneEmbeddedMap(s.embeddedMeshes);
 if(record){ map.set(key, record); }
 else { map.delete(key); }
 return { embeddedMeshes: map };
 });
}

function __disposeEmbeddedRecord(record){
 if(!record) return;
 try{
 const mesh = record.mesh;
 if(mesh){
 mesh.parent?.remove(mesh);
 mesh.traverse?.(node=>{
 if(node.isMesh){
 node.geometry?.dispose?.();
 node.material?.dispose?.();
 }
 });
 }
 }catch{}
}

tag('EMBED',['ACTION'],(anchor,arr,ast)=>{
 const sourceArg = ast.args[0];
 if(!sourceArg){ Actions.setCell(arr.id, anchor, '!ERR:EMBED:NO_SOURCE', ast.raw, true); return; }
 const nickname = ast.args[1]!==undefined ? String(Formula.valOf(ast.args[1])||'') : '';
 const state = Store.getState();
 let targetArr=null;
 if(sourceArg && sourceArg.kind==='ref'){
 targetArr = state.arrays[sourceArg.arrId];
 } else if(sourceArg && sourceArg.kind==='range'){
 const first = sourceArg.cells && sourceArg.cells[0];
 if(first) targetArr = state.arrays[first.arrId];
 } else {
 const raw = Formula.valOf(sourceArg);
 if(typeof raw==='string'){
 const parsed = parseAlt(raw) || parseA1g(raw, arr.id);
 if(parsed) targetArr = state.arrays[parsed.arrId];
 if(!targetArr){
 const id = +raw; if(Number.isFinite(id)) targetArr = state.arrays[id];
 }
 } else {
 const id = +raw; if(Number.isFinite(id)) targetArr = state.arrays[id];
 }
 }
 if(!targetArr){ Actions.setCell(arr.id, anchor, '!ERR:EMBED:NOT_FOUND', ast.raw, true); return; }
 try{
 const scene = Scene.getScene?.();
 if(!scene){ Actions.setCell(arr.id, anchor, '!ERR:EMBED:NO_SCENE', ast.raw, true); return; }
 const snapshot = Scene.createArraySnapshot?.(targetArr);
 if(!snapshot){ Actions.setCell(arr.id, anchor, '!ERR:EMBED:EMPTY', ast.raw, true); return; }
 snapshot.scale.setScalar(0.28);
 const anchorRef = {arrId:arr.id, x:anchor.x, y:anchor.y, z:anchor.z};
 const key = aKey(anchorRef);
 const prior = __getEmbeddedRecord(key);
 if(prior) __disposeEmbeddedRecord(prior);

 const parentFrame = arr._frame;
 if(parentFrame){
 const local = Scene.localPos?.(arr, anchor.x, anchor.y, anchor.z) || new THREE.Vector3();
 snapshot.position.copy(local);
 snapshot.position.y += 0.6;
 parentFrame.add(snapshot);
 } else {
 const pos = Scene.cellWorldPos(arr, anchor.x, anchor.y, anchor.z);
 snapshot.position.copy(pos);
 snapshot.position.y += 0.6;
 scene.add(snapshot);
 }
 snapshot.name = `Embed:${targetArr.id}`;
 snapshot.userData = {...(snapshot.userData||{}), embedFor:key, sourceArrId:targetArr.id};

 __setEmbeddedRecord(key, {
 mesh: snapshot,
 sourceArrId: targetArr.id,
 hostArrId: arr.id,
 anchor: {x:anchor.x, y:anchor.y, z:anchor.z},
 name: nickname||'',
 createdAt: Date.now()
 });

 const label = nickname || `Embed:${targetArr.id}`;
 Actions.setCell(arr.id, anchor, label, ast.raw, true);
 }catch(e){ Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true); }
});

tag('UNPACK',['ACTION'],(anchor,arr,ast)=>{
 const refArg = ast.args[0];
 let target = null;
 if(refArg && refArg.kind==='ref'){ target = {arrId:refArg.arrId,x:refArg.x,y:refArg.y,z:refArg.z}; }
 else if(typeof refArg==='string'){ const parsed = parseAlt(refArg)||parseA1g(refArg,arr.id); if(parsed) target=parsed; }
 else if(refArg!==undefined){
 const parsed = parseAlt(String(Formula.valOf(refArg)||'')) || null;
 if(parsed) target=parsed;
 }
 const anchorRef = target ? target : {arrId:arr.id, x:anchor.x, y:anchor.y, z:anchor.z};
 const key = aKey(anchorRef);
 const rec = __getEmbeddedRecord(key);
 if(!rec){ Actions.setCell(arr.id, anchor, '!ERR:UNPACK:NOT_FOUND', ast.raw, true); return; }
 const sourceArr = Store.getState().arrays[rec.sourceArrId];
 if(!sourceArr){
 __disposeEmbeddedRecord(rec);
 __setEmbeddedRecord(key, null);
 Actions.setCell(arr.id, anchor, '!ERR:UNPACK:NO_SOURCE', ast.raw, true);
 return;
 }
 try{
 const baseName = rec.name || sourceArr.name || `Embed ${sourceArr.id}`;
 const cloneName = `${baseName} Copy`;
 const newArr = Actions.createArray({ name: cloneName, size:{...sourceArr.size} });
 const tx = Write.start('embed.unpack','UNPACK build');
 try{
 Object.values(sourceArr.chunks||{}).forEach(ch=>{
 (ch.cells||[]).forEach(cell=>{
 Write.set(tx, newArr.id, {x:cell.x,y:cell.y,z:cell.z}, {
 value: cell.value,
 formula: cell.formula,
 meta: cell.meta ? {...cell.meta} : undefined
 });
 });
 });
 Write.commit(tx);
 }catch(err){
 try{ Write.rollback(tx); }catch{}
 throw err;
 }

 __disposeEmbeddedRecord(rec);
 __setEmbeddedRecord(key, null);

 try{
 const hostArr = Store.getState().arrays[rec.hostArrId] || arr;
 const pad = Math.max(1.5, Math.ceil(Math.max(newArr.size.x||1, newArr.size.z||1)/2));
 const offset = hostArr ? Scene.dockOffsetFor?.(hostArr, 'east', pad) : null;
 if(offset) Scene.setArrayOffset?.(newArr, offset);
 }catch{}

 Actions.setSelection(newArr.id, {x:0,y:0,z:0});
 Actions.setCell(arr.id, anchor, `Unpack:${newArr.id}`, ast.raw, true);
 }catch(e){
 Actions.setCell(arr.id, anchor, `!ERR:UNPACK:${e.message}`, ast.raw, true);
 }
});

tag('ENTER',['ACTION'],(anchor,arr,ast)=>{
 const refArg = ast.args[0];
 let target = null;
 if(refArg && refArg.kind==='ref'){ target = {arrId:refArg.arrId,x:refArg.x,y:refArg.y,z:refArg.z}; }
 else if(typeof refArg==='string'){ const parsed = parseAlt(refArg)||parseA1g(refArg,arr.id); if(parsed) target=parsed; }
 else if(refArg!==undefined){
 const parsed = parseAlt(String(Formula.valOf(refArg)||'')) || null;
 if(parsed) target=parsed;
 }
 const anchorRef = target ? target : {arrId:arr.id, x:anchor.x, y:anchor.y, z:anchor.z};
 const key = aKey(anchorRef);
 const rec = __getEmbeddedRecord(key);
 if(rec && Store.getState().arrays[rec.sourceArrId]){
 const targetArr = Store.getState().arrays[rec.sourceArrId];
 Actions.setSelection(rec.sourceArrId, {x:0,y:0,z:0});
 try{ Scene.centerOnArray?.(targetArr); }catch{}
 try{ Store.setState(s=>({ worldState:{ ...(s.worldState||{}), parentArr: arr.id, childArr: rec.sourceArrId } })); }catch{}
 Actions.setCell(arr.id, anchor, `Enter:${targetArr.name||rec.sourceArrId}`, ast.raw, true);
 } else {
 if(rec){ __disposeEmbeddedRecord(rec); __setEmbeddedRecord(key, null); }
 Actions.setCell(arr.id, anchor, '!ERR:ENTER:NOT_FOUND', ast.raw, true);
 }
});
// COMBINE(0|1): toggle global gobbling interactions
tag('COMBINE',["ACTION","META"],(anchor,arr,ast)=>{
 const enable = !!Formula.valOf(ast.args[0]);
 const S=Store.getState();
 Store.setState(s=>({ interactions:{ ...(s.interactions||{}), gobblingEnabled: enable } }));
 Actions.setCell(arr.id, anchor, `Combine Mode: ${enable?'ON':'OFF'}`, ast.raw, true);
});

// Import handler for CSV/TSV/XLSX (using SheetJS)
async function handleImportedData(data, fileName = 'PastedData'){
 try{
 const S = Store.getState();
 let workbook;
 if (typeof data === 'string') {
 workbook = XLSX.read(data, { type: 'string' });
 } else {
 workbook = XLSX.read(data, { type: 'array' });
 }
 const sheetNames = workbook.SheetNames||[]; if(sheetNames.length===0){ showToast('Import failed: No sheets'); return; }
 const sheets = sheetNames.map(name=> XLSX.utils.sheet_to_json(workbook.Sheets[name], { header:1, defval:'' }));
 let maxX=0,maxY=0; const maxZ=sheets.length;
 sheets.forEach(sh=>{ maxY=Math.max(maxY, sh.length); sh.forEach(r=>{ maxX=Math.max(maxX, r.length); }); });
 if(maxX===0||maxY===0){ showToast('Import failed: Empty'); return; }
 const baseName = String(fileName||'Data').split('.')[0].replace(/_/g,' ');
 const dataArray = Actions.createArray({ name: baseName, size:{x:maxX,y:maxY,z:maxZ} });
 const labelArray = Actions.createArray({ name: `${baseName} Labels`, size:{x:1,y:1,z:maxZ} });
 const tx = Write.start('importer.create', `Import ${fileName}`);
 sheets.forEach((sheetData, z)=>{
 Write.set(tx, labelArray.id, {x:0,y:0,z}, { value: sheetNames[z], formula:null });
 sheetData.forEach((row,y)=>{
 row.forEach((val,x)=>{
 if(val!=='' && val!=null){ Write.set(tx, dataArray.id, {x,y,z}, { value:String(val), formula:null }); }
 });
 });
 });
 Write.commit(tx);
 // Position near host
 const host = (typeof UI!=='undefined' && UI.currentArray) ? UI.currentArray() : Object.values(Store.getState().arrays)[0];
 try{
 const pos = dockOffsetFor(host||dataArray,'east',2.0);
 Scene.setArrayOffset(dataArray,pos);
 const labelPos = dockOffsetFor(dataArray,'top',1.0);
 Scene.setArrayOffset(labelArray,labelPos);
 }catch{}
 Actions.setSelection(dataArray.id,{x:0,y:0,z:0},null,'3d');
 Scene.centerOnArray?.(dataArray);
 showToast(`Imported ${sheetNames.length} sheet(s)`);
 }catch(e){ console.error('Import Error', e); showToast(`Import failed: ${e.message}`); }
}

// COLOR(hexColor, [targetRefOrRange]) - sets the background color of cells.
tag('COLOR',["ACTION"], (anchor, arr, ast, tx) => {
 if (!tx) throw new Error('COLOR requires an active transaction');
 const colorValRaw = Formula.valOf(ast.args[0] || '#ffffff');
 const colorVal = String(colorValRaw==null?'#ffffff':colorValRaw).trim();
 if (!/^#[0-9a-fA-F]{6}$/.test(colorVal)) {
 Actions.setCell(arr.id, anchor, '!ERR:COLOR_FORMAT', ast.raw, true);
 return;
 }

 const targetArg = ast.args[1] || anchor;
 const targets = [];
 if (targetArg && targetArg.kind === 'range') {
 targets.push(...targetArg.cells);
 } else if (targetArg && targetArg.kind === 'ref') {
 targets.push(targetArg);
 } else {
 targets.push(anchor);
 }

 targets.forEach(t => {
 const cell = Formula.getCell(t);
 Write.set(tx, t.arrId, { x: t.x, y: t.y, z: t.z }, {
 value: cell.value,
 formula: (t.arrId===anchor.arrId && t.x === anchor.x && t.y === anchor.y && t.z === anchor.z) ? (cell.formula ?? ast.raw) : cell.formula,
 meta: { ...(cell.meta||{}), color: colorVal }
 });
 });
 // Silent: no stamp
});

// GETCOLOR([targetRef]) - returns the hex color of a cell.
tag('GETCOLOR',["PURE"], (anchor, arr, ast) => {
 const target = (ast.args[0] && ast.args[0].kind === 'ref') ? ast.args[0] : anchor;
 const cell = Formula.getCell(target);
 return (cell && cell.meta && cell.meta.color) ? cell.meta.color : '#3b82f6';
});

// PIVOT(range) flag cells as hinge pivots for grouped rigid bodies
tag('PIVOT',["PHYSICS"], (anchor, arr, ast, tx) => {
 const cells = collectTargetCells(ast.args[0], anchor);
 const info = ensureTransaction(tx, 'physics.pivot', 'Mark physics pivots');
 cells.forEach(target => {
 mutateCellMeta(info.tx, target, meta => ({ ...meta, physicsPivot: true }));
 });
 finalizeTransaction(info);
 try{
 const affected = new Set(cells.map(c=>c.arrId));
 affected.forEach(id=>{ const targetArr = Store.getState().arrays[id]; if(targetArr) Scene.debounceColliderRebuild?.(targetArr); });
 }catch{}
});

// GROUP(range, id) assign cells to shared rigid body groups
tag('GROUP',["PHYSICS"], (anchor, arr, ast, tx) => {
 const cells = collectTargetCells(ast.args[0], anchor);
 const rawId = ast.args[1] !== undefined ? Formula.valOf(ast.args[1]) : undefined;
 const normalized = rawId == null ? '' : String(rawId).trim();
 const info = ensureTransaction(tx, 'physics.group', 'Assign physics group');
 cells.forEach(target => {
 mutateCellMeta(info.tx, target, meta => {
 const next = { ...meta };
 if(!normalized){ delete next.physicsGroupId; }
 else next.physicsGroupId = normalized;
 return next;
 });
 });
 finalizeTransaction(info);
 try{
 const affected = new Set(cells.map(c=>c.arrId));
 affected.forEach(id=>{ const targetArr = Store.getState().arrays[id]; if(targetArr) Scene.debounceColliderRebuild?.(targetArr); });
 }catch{}
});

// LIMIT(range, state[, duration]) encode temporary physics bounds
tag('LIMIT',["PHYSICS"], (anchor, arr, ast, tx) => {
 if(ast.args.length <= 1){
 const hostId = arr?.id ?? anchor?.arrId ?? null;
 const scopeDesc = extractScopeFromArgs(ast.args, anchor, hostId);
 if(scopeDesc.mode === 'all') return makeArrayScope('all');
 return makeArrayScope('limit', scopeDesc.ids);
 }
 const cells = collectTargetCells(ast.args[0], anchor);
 const stateRaw = ast.args[1] !== undefined ? Formula.valOf(ast.args[1]) : 1;
 const durationRaw = ast.args[2] !== undefined ? Formula.valOf(ast.args[2]) : null;
 const stateNorm = typeof stateRaw === 'string' ? stateRaw.trim().toLowerCase() : stateRaw;
 const enabled = stateNorm === 'enable' || stateNorm === 'enabled' || stateNorm === 'on' || stateNorm === '1' || stateNorm === 1 || stateNorm === true;
 const info = ensureTransaction(tx, 'physics.limit', 'Apply physics limit');
 const duration = durationRaw == null ? null : Math.max(0, Math.round(Number(durationRaw) || 0));
 cells.forEach(target => {
 mutateCellMeta(info.tx, target, meta => {
 const next = { ...meta };
 next.physicsLimit = {
 state: enabled ? 'enable' : 'disable',
 duration,
 requestedAt: Date.now()
 };
 return next;
 });
 });
 finalizeTransaction(info);
});

// ALL() scope helper targeting every array
tag('ALL',["SCENE"], () => makeArrayScope('all'));

// CELL_PHYS(enabled[, jumpCount[, gravityVec[, boundByArrayFloor[, respawnRef[, scope]]]]]) per-array physics configuration
tag('CELL_PHYS',["PHYSICS"], (anchor, arr, ast) => {
 const enabled = !!Formula.valOf(ast.args[0] ?? 0);
 const jumpCountArg = ast.args[1];
 const gravityArg = ast.args[2];
 const floorArg = ast.args[3];
 const respawnArg = ast.args[4];
 const scopeArg = ast.args[5];
 const jumpCount = jumpCountArg !== undefined ? Math.max(0, Math.round(Number(Formula.valOf(jumpCountArg)) || 0)) : undefined;
 const gravityVec = parseVectorArg(gravityArg);
 const boundByFloor = floorArg !== undefined ? !!Formula.valOf(floorArg) : undefined;
 const respawnProvided = respawnArg !== undefined;
 let respawnDescriptor = null;
 if(respawnProvided){
 if(respawnArg && typeof respawnArg === 'object' && (respawnArg.kind === 'ref' || respawnArg.kind === 'range')){
 const ref = respawnArg.kind === 'ref' ? respawnArg : (respawnArg.cells && respawnArg.cells[0]);
 if(ref) respawnDescriptor = { type:'ref', ref };
 }
 if(!respawnDescriptor){
 let value;
 try{ value = Formula.valOf(respawnArg); }catch{}
 respawnDescriptor = { type:'value', value };
 }
 }

 const { targets, scope } = resolveArrayScopeTargets(arr, anchor, scopeArg);
 const debugForceAll = !!Store.getState().scene?.physicsDebugAll;
 
 console.log(`[CELL_PHYS] called on array #${arr?.id}, enabled=${enabled}, scope.mode=${scope.mode}, debugForceAll=${debugForceAll}`);
 
 let targetList = targets.filter(Boolean);
 if(!targetList.length && arr){
 targetList = [arr];
 }
 if(debugForceAll && scope.mode === 'all'){
 targetList = Object.values(Store.getState().arrays || {}).filter(Boolean);
 }
 const seenTargets = new Set();
 targetList = targetList.filter(targetArr => {
 if(!targetArr || !Number.isFinite(targetArr.id)) return false;
 if(seenTargets.has(targetArr.id)) return false;
 seenTargets.add(targetArr.id);
 return true;
 });
 if(!targetList.length && arr) targetList = [arr];
 console.log(`[CELL_PHYS] targeting ${targetList.length} arrays: [${targetList.map(a=>a.id).join(', ')}]`);
 const respawnUpdates = {};

 const resolveRespawn = (targetArr)=>{
 if(!respawnDescriptor) return null;
 const arrays = Store.getState().arrays || {};
 const hostId = targetArr?.id ?? arr?.id ?? anchor?.arrId ?? null;
 let targetArrId = hostId;
 let cellCoord = null;
 let worldOverride = null;
 if(respawnDescriptor.type === 'ref' && respawnDescriptor.ref){
 const ref = respawnDescriptor.ref;
 targetArrId = Number.isFinite(ref.arrId) ? Math.trunc(ref.arrId) : hostId;
 cellCoord = { x: Math.trunc(ref.x ?? 0), y: Math.trunc(ref.y ?? 0), z: Math.trunc(ref.z ?? 0) };
 } else if(respawnDescriptor.type === 'value'){
 const val = respawnDescriptor.value;
 const normalized = normalizeScopeDescriptor(val, hostId);
 if(normalized && normalized.mode === 'all'){ return null; }
 if(val && typeof val === 'object'){
 if(Number.isFinite(val.arrId)) targetArrId = Math.trunc(val.arrId);
 else if(Number.isFinite(val.array)) targetArrId = Math.trunc(val.array);
 if(val.world && Number.isFinite(val.world.x) && Number.isFinite(val.world.y) && Number.isFinite(val.world.z)){
 worldOverride = { x:Number(val.world.x), y:Number(val.world.y), z:Number(val.world.z) };
 }
 if(Number.isFinite(val.x) && Number.isFinite(val.y) && Number.isFinite(val.z)){
 cellCoord = { x: Math.trunc(val.x), y: Math.trunc(val.y), z: Math.trunc(val.z) };
 }
 }
 if(!cellCoord && Array.isArray(val) && val.length >= 3){
 cellCoord = {
 x: Math.trunc(Number(val[0]) || 0),
 y: Math.trunc(Number(val[1]) || 0),
 z: Math.trunc(Number(val[2]) || 0)
 };
 if(val.length >= 4 && Number.isFinite(Number(val[3]))){
 targetArrId = Math.trunc(Number(val[3]));
 }
 }
 if(!cellCoord && typeof val === 'string'){
 const trimmed = val.trim();
 const addr = /^@\[(.*)\]$/.exec(trimmed);
 if(addr){
 const parts = addr[1].split(',').map(s=>s.trim()).filter(Boolean);
 if(parts.length >= 3){
 cellCoord = {
 x: Math.trunc(Number(parts[0]) || 0),
 y: Math.trunc(Number(parts[1]) || 0),
 z: Math.trunc(Number(parts[2]) || 0)
 };
 if(parts.length >= 4 && Number.isFinite(Number(parts[3]))){
 targetArrId = Math.trunc(Number(parts[3]));
 }
 }
 } else {
 const pieces = trimmed.replace(/[\[\]\{\}]/g,'').split(/[,\s]+/).filter(Boolean);
 if(pieces.length >= 3){
 cellCoord = {
 x: Math.trunc(Number(pieces[0]) || 0),
 y: Math.trunc(Number(pieces[1]) || 0),
 z: Math.trunc(Number(pieces[2]) || 0)
 };
 if(pieces.length >= 4 && Number.isFinite(Number(pieces[3]))){
 targetArrId = Math.trunc(Number(pieces[3]));
 }
 }
 }
 }
 }
 const arrTarget = arrays[targetArrId] || targetArr || arr;
 if(worldOverride && arrTarget){
 return {
 arrId: arrTarget.id,
 cell: cellCoord,
 world: { x: worldOverride.x, y: worldOverride.y, z: worldOverride.z }
 };
 }
 if(!cellCoord || !arrTarget) return null;
 let pos = null;
 try{
 if(Scene.cellWorldPos) pos = Scene.cellWorldPos(arrTarget, cellCoord.x, cellCoord.y, cellCoord.z);
 if(!pos && Scene.worldPos) pos = Scene.worldPos(arrTarget, cellCoord.x, cellCoord.y, cellCoord.z);
 }catch{}
 if(!pos) return null;
 return {
 arrId: arrTarget.id,
 cell: { ...cellCoord },
 world: { x: pos.x, y: pos.y, z: pos.z }
 };
 };

 // Mutate arrays directly in Store to ensure changes persist
 Store.setState(state => {
 const arrays = { ...state.arrays };
 targetList.forEach(targetArr => {
 if(!targetArr) return;
 // Get fresh reference from Store
 const storeArr = arrays[targetArr.id];
 if(!storeArr) return;
 
 const nextParams = { ...(storeArr.params || {}) };
 nextParams.physics = { ...(nextParams.physics || { enabled:false }) };
 const phys = nextParams.physics;
 const debugLocked = !!phys.__debugOverride;
 const sources = { ...(phys.__sources || {}) };
 
 if(debugLocked){
 console.log(`[CELL_PHYS] Array #${storeArr.id} is debug-locked, skipping`);
 phys.__sources = sources;
 if(respawnProvided){
 const respawnInfo = resolveRespawn(storeArr);
 respawnUpdates[storeArr.id] = respawnInfo || null;
 }
 return;
 }
 const priority = (()=>{
 if(scope.mode === 'host') return 2;
 if(scope.mode === 'limit'){
 return (storeArr.id === arr.id) ? 2 : 1;
 }
 return 0;
 })();
 const claim = (key, provided=true)=>{
 if(!provided) return false;
 const prev = sources[key] ?? -Infinity;
 if(priority >= prev){
 sources[key] = priority;
 return true;
 }
 return false;
 };
 if(claim('enabled', true)){
 phys.enabled = enabled;
 console.log(`[CELL_PHYS] Set array #${storeArr.id} physics.enabled = ${enabled}, priority=${priority}, scope.mode=${scope.mode}`);
 }
 if(claim('jumpCount', jumpCount !== undefined)) phys.jumpCount = jumpCount;
 if(claim('gravity', !!gravityVec)) phys.gravity = gravityVec ? { x:gravityVec.x, y:gravityVec.y, z:gravityVec.z } : undefined;
 if(claim('boundByArrayFloor', boundByFloor !== undefined)) phys.boundByArrayFloor = boundByFloor;
 phys.__sources = sources;
 if(respawnProvided && claim('respawn', true)){
 const respawnInfo = resolveRespawn(storeArr);
 respawnUpdates[storeArr.id] = respawnInfo || null;
 }
 
 // Update the array in Store with new physics params
 arrays[storeArr.id] = { ...storeArr, params: nextParams };
 });
 
 return { arrays };
 });
 
 if(enabled){
 const arraysById = Store.getState().arrays || {};
 targetList.forEach(targetArr=>{
 const latest = arraysById[targetArr.id] || null;
 console.log(`[CELL_PHYS] Rebuilding colliders for array #${targetArr.id} with enabled=${latest?.params?.physics?.enabled}`);
 if(!latest) return;
 try{ Scene.debounceColliderRebuild(latest); }catch{}
 });
 }

 const updateRespawns = Object.keys(respawnUpdates).length > 0;
 if(updateRespawns){
 Store.setState(state => {
 const scene = { ...(state.scene || {}) };
 const existing = { ...(scene.physicsRespawns || {}) };
 Object.entries(respawnUpdates).forEach(([id, info])=>{
 if(info){ existing[id] = info; }
 else delete existing[id];
 });
 scene.physicsRespawns = existing;
 return { scene };
 });
 const selArrId = Store.getState().selection?.arrayId;
 if(selArrId != null && Object.prototype.hasOwnProperty.call(respawnUpdates, selArrId)){
 const world = respawnUpdates[selArrId]?.world;
 if(world) try{ Scene.setPhysicsSpawn?.(world); }catch{}
 else try{ Scene.setPhysicsSpawn?.(null); }catch{}
 }
 if(Object.prototype.hasOwnProperty.call(respawnUpdates, arr.id)){
 const world = respawnUpdates[arr.id]?.world;
 if(world) try{ Scene.setPhysicsSpawn?.(world); }catch{}
 else try{ Scene.setPhysicsSpawn?.(null); }catch{}
 }
 }

 const stamp = enabled ? '?? Physics ON' : '?? Physics OFF';
 Actions.setCell(arr.id, anchor, stamp, ast.raw, true);
});

// CELLI_PHYS(enabled[, jumpCount[, runMultiplier[, momentumMode]]]) avatar controller wrapper
tag('CELLI_PHYS',["PHYSICS","AVATAR"], (anchor, arr, ast) => {
 const enabled = !!Formula.valOf(ast.args[0] ?? 1);
 const jumpCountArg = ast.args[1];
 const runArg = ast.args[2];
 const momentumArg = ast.args[3];
 const stateBefore = Store.getState();
 const prevEnabled = !!stateBefore.avatarPhysics?.enabled;
 const physicsActiveBefore = !!stateBefore.scene?.physics;
 const debugOverrideActive = !!stateBefore.scene?.physicsDebugAll && !!stateBefore.avatarPhysics?.__debugOverride;
 const effectiveEnabled = debugOverrideActive ? true : enabled;
 const updates = {};
 if(debugOverrideActive){
 updates.enabled = stateBefore.avatarPhysics?.enabled !== false;
 } else {
 updates.enabled = effectiveEnabled;
 }
 if(jumpCountArg !== undefined){
 const jc = Math.max(0, Math.round(Number(Formula.valOf(jumpCountArg)) || 0));
 if(!debugOverrideActive){
 updates.jumpCount = jc;
 } else if(stateBefore.avatarPhysics && stateBefore.avatarPhysics.jumpCount !== undefined){
 updates.jumpCount = stateBefore.avatarPhysics.jumpCount;
 }
 }
 if(runArg !== undefined){
 let rm = Number(Formula.valOf(runArg));
 if(!Number.isFinite(rm)) rm = 1;
 updates.runMultiplier = Math.max(0.1, rm);
 }
 if(momentumArg !== undefined){
 const mm = Math.round(Number(Formula.valOf(momentumArg)) || 0);
 updates.momentumMode = mm === 1 ? 1 : 0;
 }

 Store.setState(state => ({
 avatarPhysics: { ...state.avatarPhysics, ...updates }
 }));

 // Mark this array as the physics host so colliders are built for it
 try{
 Store.setState(state => {
 const arrays = { ...state.arrays };
 if(arrays[arr.id]){
 arrays[arr.id] = {
 ...arrays[arr.id],
 collisionMode: effectiveEnabled ? 'physics' : 'edit',
 params: {
 ...arrays[arr.id].params,
 physics: {
 ...arrays[arr.id].params?.physics,
 enabled: effectiveEnabled
 }
 }
 };
 }
 return { arrays };
 });
 console.log(`[PHYSICS] Set array #${arr.id} "${arr.name}" physics.enabled=${effectiveEnabled}`);
 // Trigger collider rebuild for this array if physics is being enabled
 if(effectiveEnabled && Scene?.debounceColliderRebuild){
 const updatedArr = Store.getState().arrays[arr.id];
 if(updatedArr) Scene.debounceColliderRebuild(updatedArr);
 }
 }catch(e){ console.warn('[PHYSICS] Failed to set array physics params', e); }

 try{
 const g = Store.getState().globalState;
 if(g && typeof g.set === 'function'){
 g.set('platformer.active', !!effectiveEnabled);
 g.set('platformer.input', 'none');
 g.set('platformer.jump', 0);
 }
 }catch{}

 let spawnTarget = null;
 if(effectiveEnabled && !prevEnabled){
 try{
 const sel = stateBefore.selection;
 const arrays = stateBefore.arrays || {};
 if(sel?.arrayId != null && sel.focus){
 const arrSel = arrays[sel.arrayId];
 if(arrSel){
 const pos = Scene.worldPos ? Scene.worldPos(arrSel, sel.focus.x, sel.focus.y, sel.focus.z) : null;
 if(pos){
 const scale = arrayVoxelScale(arrSel);
 const perch = avatarPerchOffset(scale);
 spawnTarget = { x: pos.x, y: pos.y + perch, z: pos.z };
 }
 }
 }
 }catch{}
 }

 if(effectiveEnabled && !physicsActiveBefore){
 try{
 const toggle = Scene.togglePhysicsMode;
 if(typeof toggle === 'function'){
 const res = toggle();
 if(res && typeof res.catch === 'function'){
 res.catch(err=>console.warn('[PHYSICS] CELLI_PHYS enable failed', err));
 }
 }
 }catch(e){ console.warn('[PHYSICS] CELLI_PHYS enable threw', e); }
 }

 if(spawnTarget){
 try{ Scene.spawnPlayerAt?.(spawnTarget.x, spawnTarget.y, spawnTarget.z); }catch{}
 try{ Scene.setPhysicsSpawn?.(spawnTarget); }catch{}
 }

 if(!effectiveEnabled && Store.getState().scene.physics){
 try{
 const toggle = Scene.togglePhysicsMode;
 if(typeof toggle === 'function'){
 const res = toggle();
 if(res && typeof res.catch === 'function'){
 res.catch(err=>console.warn('[PHYSICS] CELLI_PHYS disable failed', err));
 }
 }
 }catch(e){ console.warn('[PHYSICS] CELLI_PHYS disable threw', e); }
 }

 const stamp = effectiveEnabled ? '?? Avatar' : '?? Classic';
 Actions.setCell(arr.id, anchor, stamp, ast.raw, true);
});

// PHYS_CAMERA(mode, distance?, allowRotation=0) configure physics-friendly camera rigs
tag('PHYS_CAMERA',["SCENE","CAMERA"], (anchor, arr, ast) => {
 const modeRaw = String(Formula.valOf(ast.args[0] ?? 'free') || 'free').toLowerCase();
 const distanceRaw = ast.args[1] !== undefined ? Number(Formula.valOf(ast.args[1])) : NaN;
 const allowRotation = !!Formula.valOf(ast.args[2] ?? 0);
 const distance = Number.isFinite(distanceRaw) ? Math.max(2, distanceRaw) : undefined;

 Store.setState(state => ({
 physicsCamera: {
 mode: modeRaw || 'free',
 distance: distance !== undefined ? distance : state.physicsCamera.distance,
 allowRotation
 }
 }));

 try{
 const cfg = Store.getState().physicsCamera;
 if(cfg && Scene.setPhysicsCamera){
 Scene.setPhysicsCamera(cfg.mode, cfg.distance, cfg.allowRotation);
 }
 }catch{}

 Actions.setCell(arr.id, anchor, `?? ${modeRaw.toUpperCase()}`, ast.raw, true);
});

// EVENT BUS FUNCTIONS
tag('ON_EVENT',['META'],(anchor,arr,ast)=>{
 const eventName = String(valOf(ast.args[0]) || '');
 const actionFormula = String(valOf(ast.args[1]) || '');
 if(!eventName || !actionFormula) throw new Error('ON_EVENT requires eventName and actionFormula');
 
 const listeners = Store.getState().eventListeners;
 if(!listeners.has(eventName)) listeners.set(eventName, []);
 
 const listenerObj = {
 anchor: {...anchor}, // Store anchor location
 actionFormula,
 arrId: arr.id
 };
 
 listeners.get(eventName).push(listenerObj);
 Actions.setCell(arr.id, anchor, `Listen[${eventName}]: ${actionFormula}`, ast.raw, true);
});
tag('FIRE_EVENT',['ACTION'],(anchor,arr,ast,tx)=>{
 const eventName = String(valOf(ast.args[0]) || '');
 const payload = ast.args[1] !== undefined ? valOf(ast.args[1]) : null;
 if(!eventName) throw new Error('FIRE_EVENT requires eventName');
 
 // Store payload in global state temporarily for listeners to access
 if(payload !== null) {
 Store.getState().globalState.set(`event.payload.${eventName}`, payload);
 }
 
 const listeners = Store.getState().eventListeners.get(eventName) || [];
 
 // Execute all listener formulas
 listeners.forEach(listener => {
 try {
 const targetAnchor = {arrId: listener.arrId, ...listener.anchor};
 // Reuse provided tx if present; otherwise create a scoped one per event
 if(tx){
 Formula.executeAt(targetAnchor, listener.actionFormula, tx);
 } else {
 const etx = Write.start(`event.${eventName}`,'Event dispatch');
 Formula.executeAt(targetAnchor, listener.actionFormula, etx);
 Write.commit(etx);
 }
 } catch(e) {
 console.error(`Event listener error for ${eventName}:`, e);
 }
 });
 
 Actions.setCell(arr.id, anchor, `Fired[${eventName}]${payload ? ` with ${payload}` : ''}`, ast.raw, true);
});

// INFORMATION & INTERACTION CONTROL
tag('GET_PLAYER_FOCUS',['PURE'],(anchor,arr,ast)=>{
 const selection = Store.getState().selection;
 if(!selection.focus || !selection.arrayId) {
 Actions.setCell(arr.id, anchor, '', ast.raw, true);
 return;
 }
 
 const address = `@[${selection.focus.x},${selection.focus.y},${selection.focus.z},${selection.arrayId}]`;
 Actions.setCell(arr.id, anchor, address, ast.raw, true);
});
tag('CANT_TARGET',['META'],(anchor,arr,ast)=>{
 const target = ast.args[0];
 if(!target) throw new Error('CANT_TARGET requires a range or reference');
 
 const markUntargetable = (x, y, z, arrId) => {
 const targetArr = Store.getState().arrays[arrId];
 if(!targetArr) return;
 const ch = targetArr.chunks[keyChunk(...Object.values(chunkOf(x, y, z)))];
 if(!ch) return;
 const cell = ch.cells.find(c => c.x === x && c.y === y && c.z === z);
 if(cell) {
 if(!cell.meta) cell.meta = {};
 cell.meta.isTargetable = false;
 }
 };
 
 if(target.kind === 'ref') {
 markUntargetable(target.x, target.y, target.z, target.arrId);
 } else if(target.kind === 'range') {
 target.cells.forEach(cell => {
 markUntargetable(cell.x, cell.y, cell.z, cell.arrId);
 });
 }
 
 Actions.setCell(arr.id, anchor, 'Protected cells marked', ast.raw, true);
});

// GAME HELPER FUNCTIONS
tag('GET_ARRAY_POS',["PURE"],(anchor,arr,ast)=>{
 const target=ast.args[0]&&ast.args[0].kind==='ref'? Store.getState().arrays[ast.args[0].arrId] : arr;
 if(!target){ Actions.setCell(arr.id,anchor,'',ast.raw,true); return; }
 const o = target.offset||{x:0,y:0,z:0};
 Actions.setCell(arr.id, anchor, `{"x":${o.x},"y":${o.y},"z":${o.z}}`, ast.raw, true);
});
tag('SET_ARRAY_POS',["SCENE","ACTION"],(anchor,arr,ast)=>{
 let target=null;
 if(ast.args[0] && ast.args[0].kind==='ref'){
 target = Store.getState().arrays[ast.args[0].arrId];
 } else {
 const maybeId = +Formula.valOf(ast.args[0]);
 if(Number.isInteger(maybeId)) target = Store.getState().arrays[maybeId];
 if(!target) target = arr;
 }
 const x=(+Formula.valOf(ast.args[1])||0), y=(+Formula.valOf(ast.args[2])||0), z=(+Formula.valOf(ast.args[3])||0);
 if(!target) { Actions.setCell(arr.id,anchor,'!ERR:ARR',ast.raw,true); return; }
 Scene.setArrayOffset(target,{x,y,z});
 Actions.setCell(arr.id,anchor,`Pos:${x},${y},${z}`,ast.raw,true);
});
function refreshArrayScale(targetArr){
 if(!targetArr) return;
 try{
 targetArr._viewSig = '';
 renderArray(targetArr);
 try{
 const off = targetArr.offset ? { x: targetArr.offset.x, y: targetArr.offset.y, z: targetArr.offset.z } : { x:0,y:0,z:0 };
 Scene.setArrayOffset?.(targetArr, off, { interactive:true, _skipDock:true, _skipConnections:true });
 }catch{}
 Object.values(targetArr.chunks||{}).forEach(ch=>{ try{ ch.ensureMesh?.(); ch.setLOD?.(1); rehydrateChunkInstances(targetArr, ch); }catch{} });
 updateArrayLabelPlacement(targetArr);
 updateArrayValueSpritePlacement(targetArr);
 debounceColliderRebuild(targetArr);
 }catch(e){ console.warn('SCALE refresh failed', e); }
}
tag('SCALE',["SCENE","VOXEL"],(anchor,arr,ast)=>{
 const rawFactor = ast.args[0] !== undefined ? Number(Formula.valOf(ast.args[0])) : NaN;
 const level = Number.isFinite(rawFactor) ? Math.max(1, Math.round(rawFactor)) : 1;
 const units = arrayScaleUnitsFromLevel(level);
 const scopeArg = ast.args[1];
 const { targets } = resolveArrayScopeTargets(arr, anchor, scopeArg);
 const touched = [];
 const prevStates = [];
 targets.forEach(targetArr => {
 if(!targetArr) return;
 targetArr.params = targetArr.params || {};
 const prevLevel = Number.isFinite(+targetArr.params.voxelScaleLevel) ? (+targetArr.params.voxelScaleLevel|0) : 1;
 const prevUnits = Number.isFinite(+targetArr.params.voxelScale) ? +targetArr.params.voxelScale : arrayScaleUnitsFromLevel(prevLevel);
 prevStates.push({ id: targetArr.id, prevLevel, prevUnits });
 targetArr.params.voxelScaleLevel = level;
 targetArr.params.voxelScale = units;
 touched.push(targetArr);
 });
 touched.forEach(targetArr => {
 refreshArrayScale(targetArr);
 });
 if(prevStates.length){
 try{
 const ak=aKey(anchor);
 const S=Store.getState();
 const map=new Map(S.activeScales||new Map());
 map.set(ak, { targets: prevStates });
 Store.setState({ activeScales: map });
 const txw = Write.start('mark.scale','mark');
 const cell = Formula.getCell(anchor) || {value:'',formula:null,meta:{}};
 Write.set(txw, arr.id, {x:anchor.x,y:anchor.y,z:anchor.z}, { value: cell.value, formula: cell.formula, meta:{...(cell.meta||{}), appliedScale:{ targets: prevStates }} });
 Write.commit(txw);
 }catch{}
 }
 const stamp = `Scale ${units}`;
 Actions.setCell(arr.id, anchor, stamp, ast.raw, true);
});
// Backward-compatible alias: TRANSLATE_ARRAY delegates to 3D_TRANSLATE
tag('TRANSLATE_ARRAY',["SCENE"],(anchor,arr,ast)=> Fn['3D_TRANSLATE'].impl(anchor,arr,ast));
// 3D_ROTATE(stepsY) or 3D_ROTATE(stepsX,stepsY,stepsZ)
tag('3D_ROTATE',["SCENE"],(anchor,arr,ast)=>{
 // Parse args
 const sx = ast.args[1]!==undefined ? ((+Formula.valOf(ast.args[0])||0)|0) : 0;
 const sy = ast.args[1]!==undefined ? ((+Formula.valOf(ast.args[1])||0)|0) : ((+Formula.valOf(ast.args[0])||0)|0);
 const sz = ast.args[2]!==undefined ? ((+Formula.valOf(ast.args[2])||0)|0) : 0;
 const cont = !!((+Formula.valOf(ast.args[3]||0))|0);

 const S=Store.getState();
 const group = [...(S.dockGroups||new Map()).values()].find(g=>g.members.includes(arr.id));
 const ids = group
 ? (group.mode==='parent'
 ? [arr.id, ...group.members.filter(id=> id!==arr.id && group.members.indexOf(id) > group.members.indexOf(arr.id))]
 : [...group.members])
 : [arr.id];
 const arrays = ids.map(id=>S.arrays[id]).filter(Boolean);

 // If timed gamestate is active on the host, queue high-level rotate and exit
 let timed0 = null; try{ if(typeof Scene!=='undefined' && Scene.ensureTimedState) timed0 = Scene.ensureTimedState(arr); }catch{}
 if(!timed0){ try{ arr.params = arr.params || {}; arr.params.timed = arr.params.timed || { ticks:60, reverse:false, reverseTicks:null, repeat:false, t:0, dir:1, previewInArray:false, plan:[], baseOffset:null, baseQuat:null, overlay:null }; timed0 = arr.params.timed; }catch{} }
 const G0=(Store.getState().scene||{}).timed3D;
 if((timed0 && timed0.previewInArray) || (G0&&G0.preview)){
 // In preview, do not apply or stamp; animation system will parse formulas and animate
 return;
 }
 // Non-repeat executable: if this anchor already applied a rotation, skip
 try{
 const ak=aKey(anchor);
 const existing=(Store.getState().activeRotations||new Map()).get(ak);
 if(existing && !cont){ Actions.setCell(arr.id, anchor, `3D_Rotate:skip`, (ast.raw||`=3D_ROTATE(${sx},${sy},${sz})`)); return; }
 }catch{}
 // Ensure frames exist for all arrays so transforms apply
 arrays.forEach(a=>{ if(!a._frame) Scene.renderArray(a); });

 // Compute world-space pivot at the CENTER of the anchor cell
 const pivotWorld = Scene.cellWorldPos(arr, anchor.x, anchor.y, anchor.z);

 // Optional: compute group bounds from extreme cell centers (min/max per axis)
 const boundsOf = (a)=>{
 const xs=[0,Math.max(0,a.size.x-1)], ys=[0,Math.max(0,a.size.y-1)], zs=[0,Math.max(0,a.size.z-1)];
 let minX= Infinity,minY= Infinity,minZ= Infinity,maxX=-Infinity,maxY=-Infinity,maxZ=-Infinity;
 xs.forEach(ix=> ys.forEach(iy=> zs.forEach(iz=>{
 const p=Scene.cellWorldPos(a, ix, iy, iz);
 if(p.x<minX)minX=p.x; if(p.y<minY)minY=p.y; if(p.z<minZ)minZ=p.z;
 if(p.x>maxX)maxX=p.x; if(p.y>maxY)maxY=p.y; if(p.z>maxZ)maxZ=p.z;
 })));
 return {minX,minY,minZ,maxX,maxY,maxZ};
 };
 const pre = arrays.reduce((acc,a)=>{ const b=boundsOf(a); return {
 minX:Math.min(acc.minX,b.minX), minY:Math.min(acc.minY,b.minY), minZ:Math.min(acc.minZ,b.minZ),
 maxX:Math.max(acc.maxX,b.maxX), maxY:Math.max(acc.maxY,b.maxY), maxZ:Math.max(acc.maxZ,b.maxZ)
 }; }, {minX:Infinity,minY:Infinity,minZ:Infinity,maxX:-Infinity,maxY:-Infinity,maxZ:-Infinity});

 // Apply atomic rotation around pivot to all arrays
 arrays.forEach(a=> Scene.rotateArrayAround(a, pivotWorld, sx, sy, sz));

 // After rotation, do a light snap and ensure offsets are consistent
 arrays.forEach(a=>{
 if(a._frame){
 a.offset = { x: Math.round(a._frame.position.x), y: Math.round(a._frame.position.y), z: Math.round(a._frame.position.z) };
 }
 });

 // Recompute bounds post-rotation (for correctness/visual sanity)
 const post = arrays.reduce((acc,a)=>{ const b=boundsOf(a); return {
 minX:Math.min(acc.minX,b.minX), minY:Math.min(acc.minY,b.minY), minZ:Math.min(acc.minZ,b.minZ),
 maxX:Math.max(acc.maxX,b.maxX), maxY:Math.max(acc.maxY,b.maxY), maxZ:Math.max(acc.maxZ,b.maxZ)
 }; }, {minX:Infinity,minY:Infinity,minZ:Infinity,maxX:-Infinity,maxY:-Infinity,maxZ:-Infinity});

 const clampSteps=(n)=>(((n%4)+4)%4);
 const degX = clampSteps(sx)*90, degY = clampSteps(sy)*90, degZ = clampSteps(sz)*90;
 Actions.setCell(arr.id,anchor,`3D_Rotate:${sx},${sy},${sz}`,(ast.raw||`=3D_ROTATE(${sx},${sy},${sz})`));
 // Persist for refresh-time revert
 try{
 const ak=aKey(anchor);
 const S=Store.getState();
 const rec={targetId:targetArr.id, ids:[...ids], pivot:{...anchor, arrId:arr.id}, steps:{sx,sy,sz}};
 const map=new Map(S.activeRotations||new Map()); map.set(ak, rec); Store.setState({activeRotations:map});
 const txw = Write.start('mark.3d.rotate','mark');
 const cell = Formula.getCell(anchor) || {value:'',formula:null,meta:{}};
 Write.set(txw, arr.id, {x:anchor.x,y:anchor.y,z:anchor.z}, { value: cell.value, formula: cell.formula, meta:{...(cell.meta||{}), appliedRotate: rec } });
 Write.commit(txw);
 }catch{}
});
// Backward-compatible alias: ROTATE_ARRAY delegates to 3D_ROTATE
tag('ROTATE_ARRAY',["SCENE"],(anchor,arr,ast)=>{
 return Fn['3D_ROTATE'].impl(anchor,arr,ast);
});
tag('VECTOR_TO',['PURE'],(anchor,arr,ast)=>{
 const fromAddr = String(valOf(ast.args[0]) || '');
 const toAddr = String(valOf(ast.args[1]) || '');
 
 // Parse addresses like @[x,y,z,arrId] or cell references
 const parseAddr = (addr) => {
 const m = /@\[(-?\d+)?,(-?\d+)?,(-?\d+)?,(-?\d+)\]/.exec(String(addr).trim());
 if(!m) return null;
 // Use 0 => current component; missing => 1
 const toOneBased=(val,cur)=>{ if(val===undefined||val===null||val==='') return 1; const n=+val; return n===0? (cur+1) : n; };
 const xb=toOneBased(m[1], from.x), yb=toOneBased(m[2], from.y), zb=toOneBased(m[3], from.z);
 return {x: xb-1, y: yb-1, z: zb-1, arrId:+m[4]};
 };
 
 const from = parseAddr(fromAddr);
 const to = parseAddr(toAddr);
 
 if(!from || !to) {
 Actions.setCell(arr.id, anchor, '{"gravity":[0,0,0]}', ast.raw, true);
 return;
 }
 
 const dx = to.x - from.x;
 const dy = to.y - from.y;
 const dz = to.z - from.z;
 const mag = Math.sqrt(dx*dx + dy*dy + dz*dz);
 
 if(mag === 0) {
 Actions.setCell(arr.id, anchor, '{"gravity":[0,0,0]}', ast.raw, true);
 return;
 }
 
 const nx = dx / mag;
 const ny = dy / mag;
 const nz = dz / mag;
 
 const vector = `{"gravity":[${nx.toFixed(3)},${ny.toFixed(3)},${nz.toFixed(3)}]}`;
 Actions.setCell(arr.id, anchor, vector, ast.raw, true);
});
tag('PLATFORMER_PHYSICS',['ACTION'],(anchor,arr,ast)=>{
 // Simple platformer physics implementation
 const currentPos = Store.getState().globalState.get('platformer.pos') || '@[4,3,0,1]';
 const input = Store.getState().globalState.get('platformer.input') || 'none';
 
 const parsePos = (pos) => {
 const m = /@\[(-?\d+)?,(-?\d+)?,(-?\d+)?,(-?\d+)\]/.exec(String(pos).trim());
 if(m){
 const toOneBased=(v,cur)=>{ if(v===undefined||v===null||v==='') return 1; const n=+v; return n===0? (cur+1) : n; };
 const xb=toOneBased(m[1], 4), yb=toOneBased(m[2], 3), zb=toOneBased(m[3], 0); // defaults if 0 used outside anchor
 return {x: xb-1, y: yb-1, z: zb-1, arrId:+m[4]};
 }
 return {x: 4, y: 3, z: 0, arrId: 1};
 };
 
 const pos = parsePos(currentPos);
 let newPos = {...pos};
 
 // Handle input
 switch(input) {
 case 'left': newPos.x = Math.max(0, pos.x - 1); break;
 case 'right': newPos.x = Math.min(7, pos.x + 1); break;
 case 'up': newPos.y = Math.min(3, pos.y + 1); break;
 case 'down': newPos.y = Math.max(0, pos.y - 1); break;
 }
 
 // Clear old position and set new position
 if(newPos.x !== pos.x || newPos.y !== pos.y) {
 try {
 Actions.setCell(pos.arrId, {x: pos.x, y: pos.y, z: pos.z}, '', null, true);
 Actions.setCell(newPos.arrId, {x: newPos.x, y: newPos.y, z: newPos.z}, '??', null, true);
 Store.getState().globalState.set('platformer.pos', `@[${newPos.x},${newPos.y},${newPos.z},${newPos.arrId}]`);
 } catch(e) {
 console.error('Platformer physics error:', e);
 }
 }
 
 Actions.setCell(arr.id, anchor, `Player: ${newPos.x},${newPos.y}`, ast.raw, true);
});
// GAME FUNCTIONS
tag('FISH',['GAME'],(anchor,arr,ast)=>{
 // Initialize FISH game state and setup
 Actions.begin();
 
 // Set up game state
 Store.getState().globalState.set('fish.state', 'IDLE');
 Store.getState().globalState.set('fish.timer', 0);
 Store.getState().globalState.set('player.score', 0);
 
 // Create game UI at anchor
 Actions.setCell(arr.id, anchor, '?? FISH GAME', ast.raw, true);
 Actions.setCell(arr.id, {x:anchor.x+1,y:anchor.y,z:anchor.z}, '=ON_SELECT(SELF(),"=FIRE_EVENT(\\"CAST\\")")', null, true);
 Actions.setCell(arr.id, {x:anchor.x+2,y:anchor.y,z:anchor.z}, '=ON_SELECT(SELF(),"=IF(GET_GLOBAL(\\"fish.state\\")=\\"BITING\\",FIRE_EVENT(\\"CATCH\\"))")', null, true);
 Actions.setCell(arr.id, {x:anchor.x,y:anchor.y-1,z:anchor.z}, '=GET_GLOBAL("fish.state")', null, true);
 Actions.setCell(arr.id, {x:anchor.x+1,y:anchor.y-1,z:anchor.z}, '=GET_GLOBAL("fish.timer")', null, true);
 Actions.setCell(arr.id, {x:anchor.x+2,y:anchor.y-1,z:anchor.z}, '=GET_GLOBAL("player.score")', null, true);
 
 // Set up event listeners
 Actions.setCell(arr.id, {x:anchor.x,y:anchor.y-2,z:anchor.z}, '=ON_EVENT("CAST","=SET_GLOBAL(\\"fish.state\\",\\"WAITING\\")")', null, true);
 Actions.setCell(arr.id, {x:anchor.x+1,y:anchor.y-2,z:anchor.z}, '=ON_EVENT("TICK","=IF(AND(GET_GLOBAL(\\"fish.state\\")=\\"WAITING\\",GT(GET_GLOBAL(\\"fish.timer\\"),0)),SET_GLOBAL(\\"fish.timer\\",ADD(GET_GLOBAL(\\"fish.timer\\"),-1)))")', null, true);
 Actions.setCell(arr.id, {x:anchor.x+2,y:anchor.y-2,z:anchor.z}, '=ON_EVENT("CATCH","=SET_GLOBAL(\\"player.score\\",ADD(GET_GLOBAL(\\"player.score\\"),1))")', null, true);
 
 Actions.end();
});
tag('GALAXY',['GAME'],(anchor,arr,ast)=>{
 // Initialize GALAXY puzzle game
 Actions.begin();
 
 // Set up game state
 Store.getState().globalState.set('galaxy.active', 1);
 Store.getState().globalState.set('galaxy.gravityWell', `@[${anchor.x+1},${anchor.y+2},${anchor.z},${arr.id}]`);
 
 // Create gravity well
 Actions.setCell(arr.id, anchor, '?? GALAXY PUZZLE', ast.raw, true);
 Actions.setCell(arr.id, {x:anchor.x+1,y:anchor.y+2,z:anchor.z}, '??', null, true);
 
 // Set up physics system
 Actions.setCell(arr.id, {x:anchor.x,y:anchor.y-1,z:anchor.z}, '=ON_EVENT("TICK","=SET_GLOBAL(\\"galaxy.gravityVector\\",VECTOR_TO(GET_PLAYER_FOCUS(),GET_GLOBAL(\\"galaxy.gravityWell\\")))")', null, true);
 Actions.setCell(arr.id, {x:anchor.x+1,y:anchor.y-1,z:anchor.z}, '=GET_GLOBAL("galaxy.gravityVector")', null, true);
 
 // Goal condition
 Actions.setCell(arr.id, {x:anchor.x,y:anchor.y-2,z:anchor.z}, '=IF(EQ(GET_PLAYER_FOCUS(),GET_GLOBAL("galaxy.gravityWell")),"?? WIN!","Navigate to ??")', null, true);
 
 Actions.end();
});
// SOKOBAN puzzle generator and step logic
tag('SOKO_STEP',['GAME','ACTION'],(anchor,arr,ast,tx)=>{
 if(!tx) throw new Error('SOKO_STEP requires an active transaction');
 const memRefArg = ast.args[0];
 const dx = (+Formula.valOf(ast.args[1])|0) || 0;
 const dy = (+Formula.valOf(ast.args[2])|0) || 0;
 if(!memRef || memRef.kind !== 'ref') throw new Error('SOKO_STEP needs memory ref');
 const memVal = Formula.getCellValue(memRef);
 const pos = parseAlt(String(memVal)||'');
 if(!pos) return; // nothing to do
 const boardId = pos.arrId; const px = pos.x; const py = pos.y; const pz = pos.z||0;
 const board = Store.getState().arrays[boardId]; if(!board) return;
 const inBounds=(x,y)=> x>=0 && y>=0 && x<board.size.x && y<board.size.y;
 const at=(x,y)=> inBounds(x,y)? Formula.getCellValue({arrId:boardId,x,y,z:pz}) : ' ';
 const WALL=' ', BOX='??', PLAYER='??', EMPTY='';
 const nx=px+dx, ny=py+dy; const nnx=px+dx*2, nny=py+dy*2;
 const t1 = at(nx,ny);
 if(t1===WALL) return;
 if(t1===BOX){
 const t2 = at(nnx,nny);
 if(t2!==EMPTY) return; // cannot push
 // push box
 Write.set(tx, boardId, {x:nnx,y:nny,z:pz}, { value: BOX, formula:null });
 Write.set(tx, boardId, {x:nx ,y:ny ,z:pz}, { value: PLAYER, formula:null });
 Write.set(tx, boardId, {x:px ,y:py ,z:pz}, { value: EMPTY, formula:null });
 // update memory
 const newRef = `@[${nx},${ny},${pz},${boardId}]`;
 Write.set(tx, memRef.arrId, {x:memRef.x,y:memRef.y,z:memRef.z}, { value:newRef, formula:null });
 return;
 }
 // simple move into empty
 if(t1===EMPTY){
 Write.set(tx, boardId, {x:nx ,y:ny ,z:pz}, { value: PLAYER, formula:null });
 Write.set(tx, boardId, {x:px ,y:py ,z:pz}, { value: EMPTY, formula:null });
 const newRef = `@[${nx},${ny},${pz},${boardId}]`;
 Write.set(tx, memRef.arrId, {x:memRef.x,y:memRef.y,z:memRef.z}, { value:newRef, formula:null });
 }
});

// SOKOBAN2: Diegetic rules via Rules array and dispatcher
tag('SOKO_STEP2',['GAME','ACTION'],(anchor,arr,ast,tx)=>{
 if(!tx) throw new Error('SOKO_STEP2 requires an active transaction');
 const memRefArg = ast.args[0];
 const dx = (+Formula.valOf(ast.args[1])|0) || 0;
 const dy = (+Formula.valOf(ast.args[2])|0) || 0;
 if(!memRef || memRef.kind !== 'ref') throw new Error('SOKO_STEP2 needs memory ref');
 // Set global context for rules
 Store.getState().globalState.set('soko.dx', dx);
 Store.getState().globalState.set('soko.dy', dy);
 Store.getState().globalState.set('soko.memRef', `@[${memRef.x},${memRef.y},${memRef.z},${memRef.arrId}]`);
 // Execute the MOVE rule at the MOVE anchor (stored at Rules[0,0])
 const memVal = Formula.getCellValue(memRef);
 const pos = parseAlt(String(memVal)||''); if(!pos) return;
 const boardId = pos.arrId; const pz = pos.z||0;
 // Find Rules array by convention: same board name + " Rules" or first array with params.sokoRules
 const rulesArr = Object.values(Store.getState().arrays).find(a=>a.params?.sokoRules && a.params?.boardId===boardId);
 if(!rulesArr) { Actions.setCell(arr.id, anchor, '!ERR:No Rules', ast.raw, true); return; }
 // MOVE anchor stored in params
 const mv = rulesArr.params?.moveAnchor || {x:0,y:rulesArr.size.y-1,z:0,arrId:rulesArr.id};
 Formula.executeAt({arrId:mv.arrId,x:mv.x,y:mv.y,z:mv.z}, undefined, tx);
 Actions.setCell(arr.id, anchor, 'SOKO:STEP', ast.raw, true);
});
// Stephen's Sausage Roll (SSR) minimal PoC
// Board movement in depth; avatar is 2 1 footprint aligned along facing
// SSR(boardMem, dir) where dir in {"left","right","forward","back"}
tag('SSR_STEP',['GAME','ACTION'],(anchor,arr,ast,tx)=>{
 if(!tx) throw new Error('SSR_STEP requires an active transaction');
 const memRefArg = ast.args[0];
 // Robust direction parsing: handle identifiers, numbers, quoted strings, or missing arg
 let dirRaw;
 try{ dirRaw = Formula.valOf(ast.args[1]||''); }catch{ dirRaw=''; }
 let dir = String(dirRaw==null? '': dirRaw).trim().toLowerCase().replace(/^['"]|['"]$/g,'');
 if(dir==='0') dir='forward';
 else if(dir==='1') dir='back';
 else if(dir==='2') dir='left';
 else if(dir==='3') dir='right';
 // Fallback: infer direction from controller button position if arg missing/malformed
 if(!['forward','back','left','right'].includes(dir)){
 try{
 const cx = anchor.x, cy = anchor.y; // controller grid is 3x3 with center at (1,1)
 if(cx===1 && cy===2) dir='forward';
 else if(cx===1 && cy===0) dir='back';
 else if(cx===0 && cy===1) dir='left';
 else if(cx===2 && cy===1) dir='right';
 }catch{}
 }
 // Accept ref or absolute address string for memory pointer
 let memRef;
 if(memRefArg && memRefArg.kind==='ref'){
 memRef = memRefArg;
 } else {
 const addrStr = String(Formula.valOf(memRefArg)||'').trim();
 const parsed = parseAlt(addrStr);
 if(parsed){ memRef = {x:parsed.x,y:parsed.y,z:parsed.z,arrId:parsed.arrId, kind:'ref'}; }
 }
 if(!memRef) throw new Error('SSR_STEP needs memory ref');
 const memVal = Formula.getCellValue(memRef);
 const m = /^@\[(\d+),(\d+),(\d+),(\-?\d+)\]\|(\w+)$/i.exec(String(memVal||''));
 if(!m) return; // memory format: @[x,y,z,boardId]|FACING
 let x=+m[1], y=0, z=+m[3], boardId=+m[4]; let facing=String(m[5]||'north').toLowerCase();
 const board = Store.getState().arrays[boardId]; if(!board) return;
 const rotateLeft = f=> ({north:'west', west:'south', south:'east', east:'north'})[f];
 const rotateRight= f=> ({north:'east', east:'south', south:'west', west:'north'})[f];
 const dirVec = f=> ({north:{dx:0,dy:0,dz:-1}, east:{dx:1,dy:0,dz:0}, south:{dx:0,dy:0,dz:1}, west:{dx:-1,dy:0,dz:0}})[f] || {dx:0,dy:0,dz:-1};
 // Sausage registry lives on board.params.sausages: [{id, ax, az, bx, bz, orient:'x'|'z', side:'A'|'B'}]
 board.params = board.params||{}; board.params.sausages = board.params.sausages||[];
 const findSausAt=(qx,qz)=> board.params.sausages.find(s=> (s.ax===qx&&s.az===qz) || (s.bx===qx&&s.bz===qz));
 const occupy=(qx,qz)=> Formula.getCellValue({arrId:boardId,x:qx,y:0,z:qz})!=='';
 const drawBoard=()=>{
 // clear all then redraw sausages and avatar
 // lightweight: only update sausage cells
 board.params.sausages.forEach(s=>{
 Write.set(tx, boardId, {x:s.ax,y:0,z:s.az}, { value:'?', formula:null });
 Write.set(tx, boardId, {x:s.bx,y:0,z:s.bz}, { value:(s.side==='A'?'?':'?'), formula:null });
 });
 };
 if(dir==='left' || dir==='right'){
 // Tank-style rotation around the HEAD (player) cell.
 // Head stays fixed; tail moves to the orthogonal cell based on new facing.
 const newFacing = (dir==='left') ? rotateLeft(facing) : rotateRight(facing);
 const vnew = dirVec(newFacing);
 const ntx = x - vnew.dx, ntz = z - vnew.dz; // new tail position relative to head
 // bounds check for new tail
 if(ntx<0||ntx>=board.size.x||ntz<0||ntz>=board.size.z){ return; }
 // block rotation if target tail cell is occupied (simple rule)
 if(occupy(ntx,ntz)){
 const hit = findSausAt(ntx,ntz);
 // For now, do not push/roll on rotation; require free orthogonal cell
 if(hit){ return; }
 return;
 }
 facing = newFacing; // keep head at (x,z)
 }
 else if(dir==='forward' || dir==='back'){
 const v = dirVec(facing); const step = (dir==='forward'?1:-1);
 // Check interaction with sausages
 const nx=x+v.dx*step, nz=z+v.dz*step;
 const hit = findSausAt(nx,nz);
 if(hit){
 // Determine hit from side or short end
 const alongX = (hit.orient==='x');
 const sideHit = (alongX && v.dx===0) || (!alongX && v.dz===0);
 if(sideHit){
 // roll perpendicular by one cell and flip side
 const pdx = alongX? 0 : v.dx|| (step>0?1:-1); // if facing north/south roll in x
 const pdz = alongX? (v.dz|| (step>0?1:-1)) : 0;
 const tx1 = hit.ax+pdx, tz1 = hit.az+pdz;
 const tx2 = hit.bx+pdx, tz2 = hit.bz+pdz;
 if(tx1>=0&&tx1<board.size.x&&tz1>=0&&tz1<board.size.z&&tx2>=0&&tx2<board.size.x&&tz2>=0&&tz2<board.size.z && !occupy(tx1,tz1) && !occupy(tx2,tz2)){
 // apply roll
 Write.set(tx, boardId, {x:hit.ax,y:0,z:hit.az}, { value:'', formula:null });
 Write.set(tx, boardId, {x:hit.bx,y:0,z:hit.bz}, { value:'', formula:null });
 hit.ax=tx1; hit.az=tz1; hit.bx=tx2; hit.bz=tz2; hit.side = (hit.side==='A'?'B':'A');
 drawBoard();
 }
 } else {
 // push along its orientation (short-end push)
 const odx = alongX? (v.dx!==0? v.dx*step : (hit.bx>hit.ax?1:-1)) : 0;
 const odz = !alongX? (v.dz!==0? v.dz*step : (hit.bz>hit.az?1:-1)) : 0;
 const nx1=hit.ax+odx, nz1=hit.az+odz, nx2=hit.bx+odx, nz2=hit.bz+odz;
 if(nx1>=0&&nx1<board.size.x&&nz1>=0&&nz1<board.size.z&&nx2>=0&&nx2<board.size.x&&nz2>=0&&nz2<board.size.z && !occupy(nx1,nz1) && !occupy(nx2,nz2)){
 Write.set(tx, boardId, {x:hit.ax,y:0,z:hit.az}, { value:'', formula:null });
 Write.set(tx, boardId, {x:hit.bx,y:0,z:hit.bz}, { value:'', formula:null });
 hit.ax=nx1; hit.az=nz1; hit.bx=nx2; hit.bz=nz2;
 drawBoard();
 }
 }
 // avatar advances into previously occupied spot only if now clear
 if(!occupy(nx,nz)){ x=nx; z=nz; }
 } else {
 x = nx; z = nz;
 }
 }
 // Constrain to board
 x=Math.max(0,Math.min(board.size.x-1,x)); y=Math.max(0,Math.min(board.size.y-1,y)); z=Math.max(0,Math.min(board.size.z-1,z));
 // Clear previous avatar footprint (both head and tail regardless of turn or move)
 try{
 const old = /^@\[(\d+),(\d+),(\d+),(\-?\d+)\]/.exec(String(memVal))||[];
 const ox=+old[1], oy=+old[2], oz=+old[3];
 if(Number.isFinite(ox)){
 // Remove old head cell
 Write.set(tx, boardId, {x:ox,y:0,z:oz}, { value:'', formula:null });
 // Remove old tail cell; determine old facing from previous memory
 const mf = /^@\[(\d+),(\d+),(\d+),(\-?\d+)\]\|(\w+)$/i.exec(String(memVal||''));
 const prevF = mf ? String(mf[5]||'north').toLowerCase() : 'north';
 const pv = dirVec(prevF);
 Write.set(tx, boardId, {x:ox - pv.dx, y:0, z:oz - pv.dz}, { value:'', formula:null });
 }
 }catch{}
 // Draw 2 1 avatar: head at (x,y,z), tail one cell behind facing
 const v2 = dirVec(facing);
 Write.set(tx, boardId, {x:x,y:0,z:z}, { value:'??', formula:null });
 Write.set(tx, boardId, {x:x - v2.dx, y:0, z:z - v2.dz}, { value:'-', formula:null });
 // Update memory
 const newRef = `@[${x},${y},${z},${boardId}]|${facing}`;
 Write.set(tx, memRef.arrId, {x:memRef.x,y:memRef.y,z:memRef.z}, { value:newRef, formula:null });
 Actions.setCell(arr.id, anchor, `SSR:${facing}`, ast.raw, true);
});

tag('SSR',['GAME','META'],(anchor,arr,ast)=>{
 try{
 // Build a compact 3D board with depth emphasis
 const size = {x:8,y:1,z:8};
 const board = Actions.createArray({name:'SSR Board', size, hidden:false});
 const mem = Actions.createArray({name:'SSR Mem', size:{x:2,y:1,z:1}, hidden:true});
 const ctrl = Actions.createArray({name:'SSR Ctrl', size:{x:3,y:3,z:1}, hidden:false});
 Actions.begin();
 // Seed avatar at center facing north
 const start = {x:Math.floor(size.x/2), y:0, z:Math.floor(size.z/2)};
 Actions.setCell(board.id, start, '??', null, true);
 Actions.setCell(board.id, {x:start.x, y:start.y, z:start.z+1}, '-', null, true); // tail behind (south when facing north)
 Actions.setCell(mem.id, {x:0,y:0,z:0}, `@[${start.x},0,${start.z},${board.id}]|north`, null, true);
 // Place a demo sausage (2x1) horizontal, side A
 board.params = board.params||{}; board.params.sausages=[{id:1, ax:start.x+2, az:start.z, bx:start.x+3, bz:start.z, orient:'x', side:'A'}];
 // draw sausage
 Actions.setCell(board.id, {x:start.x+2,y:0,z:start.z}, '?', null, true);
 Actions.setCell(board.id, {x:start.x+3,y:0,z:start.z}, '?', null, true);
 // Controller arrows (depth-oriented)
 Actions.setCell(ctrl.id,{x:1,y:2,z:0},'?',null,true);
 Actions.setCell(ctrl.id,{x:0,y:1,z:0},'?',null,true);
 Actions.setCell(ctrl.id,{x:1,y:1,z:0},'??',null,true);
 Actions.setCell(ctrl.id,{x:2,y:1,z:0},'?',null,true);
 Actions.setCell(ctrl.id,{x:1,y:0,z:0},'?',null,true);
 // Memory ref stored at [1,1,1] within mem array by convention
 const mref = `@[1,1,1,${mem.id}]`;
 // Bind ONCLICK actions directly so interactivity is immediate
 const bind = (x,y,dir)=>{
 const call = `=SSR_STEP(${mref},"${dir}")`;
 const enc = btoa(call);
 const txBind = Write.start('ssr.onclick','bind');
 const prev = Formula.getCell({arrId:ctrl.id,x,y,z:0});
 const prevMeta = normalizeMetaKeys(prev?.meta||{});
 prevMeta.on_click = `B64:${enc}`;
 Write.set(txBind, ctrl.id, {x,y,z:0}, { value: prev?.value ?? (dir==='forward'?'?':dir==='back'?'?':dir==='left'?'?':'?'), formula: null, meta:prevMeta });
 Write.commit(txBind);
 };
 bind(1,2,'forward');
 bind(1,0,'back');
 bind(0,1,'left');
 bind(2,1,'right');
 // remove extra ONCLICK clones; handled in bind()
 Actions.end();
 // Smart docking relative to source array with 1-cell gap (right of source)
 (function smartDock(){
 const src = Store.getState().arrays[anchor.arrId] || arr;
 const gap = 1;
 const srcOff = src.offset||{x:0,y:0,z:0};
 // Align Z centers and Y centers; place board to the right of source with one cell gap
 const boardX = srcOff.x + (src.size.x + board.size.x)/2 + gap;
 const boardY = srcOff.y;
 const boardZ = srcOff.z;
 Scene.setArrayOffset(board,{x:boardX,y:boardY,z:boardZ});
 // Place controller to the right of board with the same gap, z-aligned
 const ctrlX = boardX + (board.size.x + ctrl.size.x)/2 + gap;
 Scene.setArrayOffset(ctrl,{x:ctrlX,y:boardY,z:boardZ});
 })();
 // Finalize: mark clickable now and force render/refresh without needing a reload
 try{
 Object.values(ctrl.chunks||{}).forEach(ch=> ch.cells.forEach(c=>{
 if(c.value){
 const meta = normalizeMetaKeys(c.meta||{});
 meta.on_click = meta.on_click || '';
 c.meta = meta;
 }
 }));
 }catch{}
 Scene.renderArray(board); Scene.renderArray(ctrl);
 // Stamp anchor without triggering immediate recompute loop (prevents duplicate creation)
 const tx=Write.start('ssr.status','SSR status');
 Write.set(tx, arr.id, anchor, { value:`SSR:#${board.id}`, formula: ast.raw, meta:{skip_recompute:true} });
 Write.commit(tx);
 }catch(e){ Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true); }
});
tag('SOKOBAN2',['GAME','META'],(anchor,arr,ast)=>{
 try{
 const size = {x:10,y:8,z:1};
 const board = Actions.createArray({name:'Sokoban2', size, hidden:false});
 const mem = Actions.createArray({name:'SokoMem2', size:{x:2,y:1,z:1}, hidden:true});
 const rules = Actions.createArray({name:'SokoRules', size:{x:4,y:6,z:1}, hidden:true});
 const ctrl = Actions.createArray({name:'SokoCtrl2', size:{x:3,y:3,z:1}, hidden:false});
 const PSTART = {x:2,y:2,z:0};
 const BOX='??', WALL=' ', PLAYER='??', GOAL=' ';
 Actions.begin();
 // walls border
 for(let x=0;x<size.x;x++){ Actions.setCell(board.id,{x,y:size.y-1,z:0},WALL,null,true); Actions.setCell(board.id,{x,y:0,z:0},WALL,null,true); }
 for(let y=0;y<size.y;y++){ Actions.setCell(board.id,{x:0,y,z:0},WALL,null,true); Actions.setCell(board.id,{x:size.x-1,y,z:0},WALL,null,true); }
 // place player, box and goal
 Actions.setCell(board.id,PSTART,PLAYER,null,true);
 Actions.setCell(board.id,{x:4,y:2,z:0},BOX,null,true);
 Actions.setCell(board.id,{x:7,y:2,z:0},GOAL,null,true);
 // memory: player ref string at (0,0)
 Actions.setCell(mem.id,{x:0,y:0,z:0},`@[${PSTART.x},${PSTART.y},${PSTART.z},${board.id}]`,null,true);
 // Rules array params and MOVE rule (diegetic formulas)
 rules.params = { ...(rules.params||{}), sokoRules:true, boardId:board.id };
 const mvAnchor = {x:0,y:rules.size.y-1,z:0};
 rules.params.moveAnchor = {arrId:rules.id, ...mvAnchor};
 const memStr = `@[0,0,0,${mem.id}]`;
 // Compute current and next positions
 const curRef = `=OFFSET(${memStr},0,0,0)`;
 const dxRef = `=GET_GLOBAL("soko.dx")`;
 const dyRef = `=GET_GLOBAL("soko.dy")`;
 Actions.setCell(rules.id, {x:0,y:rules.size.y-1,z:0}, 'MOVE', `=DO(
 "=SET_GLOBAL(\"soko.pos\", ${curRef})",
 "=SET_GLOBAL(\"soko.next\", OFFSET(GET_GLOBAL(\\\"soko.pos\\\"), ${dxRef}, ${dyRef}, 0))",
 "=SET_GLOBAL(\"soko.nnext\", OFFSET(GET_GLOBAL(\\\"soko.pos\\\"), MUL(${dxRef},2), MUL(${dyRef},2), 0))",
 "=IF(EQ(GET_GLOBAL(\"soko.next\"), \" \"), \"BLOCK\", \"OK\")",
 "=IF(EQ(GET_GLOBAL(\"soko.next\"), \"??\"), IF(EQ(GET_GLOBAL(\"soko.nnext\"), \"\"), DO(\"=SET(GET_GLOBAL(\\\"soko.nnext\\\"), \"??\")\", \"=SET(GET_GLOBAL(\\\"soko.next\\\"), \"??\")\", \"=SET(GET_GLOBAL(\\\"soko.pos\\\"), \"\" )\", \"=SET(${memStr}, GET_GLOBAL(\\\"soko.next\\\"))\"), \"BLOCK\"), \"OK\")",
 "=IF(EQ(GET_GLOBAL(\"soko.next\"), \"\"), DO(\"=SET(GET_GLOBAL(\\\"soko.next\\\"), \"??\")\", \"=SET(GET_GLOBAL(\\\"soko.pos\\\"), \"\" )\", \"=SET(${memStr}, GET_GLOBAL(\\\"soko.next\\\"))\"), \"OK\")"
 )`, true);
 // controller arrows using SOKO_STEP2(memRef,dx,dy)
 const mref = memStr;
 Actions.setCell(ctrl.id,{x:1,y:2,z:0},'?',null,true);
 Actions.setCell(ctrl.id,{x:0,y:1,z:0},'?',null,true);
 Actions.setCell(ctrl.id,{x:2,y:1,z:0},'?',null,true);
 Actions.setCell(ctrl.id,{x:1,y:0,z:0},'?',null,true);
 Actions.setCell(ctrl.id,{x:1,y:2,z:0}, '?', `=ON_SELECT(SELF(), "=SOKO_STEP2(${mref},0,1)")`, true);
 Actions.setCell(ctrl.id,{x:0,y:1,z:0}, '?', `=ON_SELECT(SELF(), "=SOKO_STEP2(${mref},-1,0)")`, true);
 Actions.setCell(ctrl.id,{x:2,y:1,z:0}, '?', `=ON_SELECT(SELF(), "=SOKO_STEP2(${mref},1,0)")`, true);
 Actions.setCell(ctrl.id,{x:1,y:0,z:0}, '?', `=ON_SELECT(SELF(), "=SOKO_STEP2(${mref},0,-1)")`, true);
 Actions.end();
 // Dock controller near board
 const pos = dockOffsetFor(board,'east',1.0);
 Scene.setArrayOffset(ctrl,pos);
 Actions.setCell(arr.id, anchor, `Sokoban2:#${board.id}`, ast.raw, true);
 }catch(e){ Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true); }
});
tag('SOKOBAN',['GAME','META'],(anchor,arr,ast)=>{
 // Generate a tiny Sokoban board, memory, and controller
 try{
 const size = {x:10,y:8,z:1};
 const board = Actions.createArray({name:'Sokoban', size, hidden:false});
 const mem = Actions.createArray({name:'SokoMem', size:{x:2,y:1,z:1}, hidden:true});
 const ctrl = Actions.createArray({name:'SokoCtrl', size:{x:3,y:3,z:1}, hidden:false});
 const PSTART = {x:2,y:2,z:0};
 const BOX='??', WALL=' ', PLAYER='??', GOAL=' ';
 Actions.begin();
 // walls border
 for(let x=0;x<size.x;x++){ Actions.setCell(board.id,{x,y:size.y-1,z:0},WALL,null,true); Actions.setCell(board.id,{x,y:0,z:0},WALL,null,true); }
 for(let y=0;y<size.y;y++){ Actions.setCell(board.id,{x:0,y,z:0},WALL,null,true); Actions.setCell(board.id,{x:size.x-1,y,z:0},WALL,null,true); }
 // place player, box and goal
 Actions.setCell(board.id,PSTART,PLAYER,null,true);
 Actions.setCell(board.id,{x:4,y:2,z:0},BOX,null,true);
 Actions.setCell(board.id,{x:7,y:2,z:0},GOAL,null,true);
 // memory: player ref string at (0,0)
 Actions.setCell(mem.id,{x:0,y:0,z:0},`@[${PSTART.x},${PSTART.y},${PSTART.z},${board.id}]`,null,true);
 // controller arrows with ON_SELECT to call SOKO_STEP(memRef,dx,dy)
 const mref = `@[0,0,0,${mem.id}]`;
 Actions.setCell(ctrl.id,{x:1,y:2,z:0},'?',null,true);
 Actions.setCell(ctrl.id,{x:0,y:1,z:0},'?',null,true);
 Actions.setCell(ctrl.id,{x:2,y:1,z:0},'?',null,true);
 Actions.setCell(ctrl.id,{x:1,y:0,z:0},'?',null,true);
 Actions.setCell(ctrl.id,{x:1,y:2,z:0}, '?', `=ON_SELECT(SELF(), "=SOKO_STEP(${mref},0,1)")`, true);
 Actions.setCell(ctrl.id,{x:0,y:1,z:0}, '?', `=ON_SELECT(SELF(), "=SOKO_STEP(${mref},-1,0)")`, true);
 Actions.setCell(ctrl.id,{x:2,y:1,z:0}, '?', `=ON_SELECT(SELF(), "=SOKO_STEP(${mref},1,0)")`, true);
 Actions.setCell(ctrl.id,{x:1,y:0,z:0}, '?', `=ON_SELECT(SELF(), "=SOKO_STEP(${mref},0,-1)")`, true);
 Actions.end();
 // Dock controller near board
 const pos = dockOffsetFor(board,'east',1.0);
 Scene.setArrayOffset(ctrl,pos);
 // Write to anchor without triggering immediate recompute loop
 const tx=Write.start('sokoban.status','SOKOBAN status');
 Write.set(tx, arr.id, anchor, { value:`Sokoban:#${board.id}`, formula: ast.raw, meta:{skip_recompute:true} });
 Write.commit(tx);
 }catch(e){ Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true); }
});

tag('VIEW_MODE',['SCENE'],(anchor,arr,ast)=>{
 const mode=String(valOf(ast.args[0])||'3d').toLowerCase(); // '3d', '2d', 'ortho', 'isometric'
 const distance=+valOf(ast.args[1])||10; // camera distance
 Scene.setViewMode(arr,{mode,distance});
 Actions.setCell(arr.id,anchor,`View:${mode}/${distance}`,ast.raw,true);
});
tag('SANDBOX',['META'],(anchor,arr,ast)=>{
 if(Store.getState().arrays[2]){
 Actions.setCell(arr.id,anchor,'Sandbox:EXISTS',ast.raw,true);
 return;
 }
 const sb = Actions.createArray({id:2,name:'Sandbox', size:{x:12,y:8,z:12}, hidden:false});
 Actions.setCell(arr.id,anchor,`Sandbox:OK (#${sb.id})`,ast.raw,true);
 Scene.centerOnArray(sb);
});

// UI Control Functions
tag('UI_CONTROL',['META'],(anchor,arr,ast)=>{
 const controlType=String(valOf(ast.args[0])||'').toLowerCase(); // 'insert_buttons', 'function_drawer', etc.
 const state=!!valOf(ast.args[1]); // true/false
 arr.uiControls = arr.uiControls || {};
 arr.uiControls[controlType] = state;
 Actions.setCell(arr.id,anchor,`UI:${controlType}=${state}`,ast.raw,true);
});

// MINIMIZE(flag): 1 to minimize the 2D viewport, 0 to restore to previous position
tag('MINIMIZE',["ACTION"],(anchor,arr,ast)=>{
 try{
 const flag = !!Formula.valOf(ast.args[0]);
 const sheet = document.getElementById('sheet');
 if(!sheet){ Actions.setCell(arr.id,anchor,'!ERR:NO_SHEET',ast.raw,true); return; }
 if(flag){
 if(!sheet.dataset.prevTransform){
 sheet.dataset.prevLeft = sheet.style.left||'';
 sheet.dataset.prevTop = sheet.style.top||'';
 sheet.dataset.prevBottom = sheet.style.bottom||'';
 sheet.dataset.prevTransform = sheet.style.transform||'';
 sheet.dataset.prevOpacity = sheet.style.opacity||'';
 sheet.dataset.prevPointer = sheet.style.pointerEvents||'';
 }
 const base=(document.body.classList.contains('touch') && sheet.dataset.touchFreed!=='1')?'translateX(-50%) ':'';
 sheet.style.transform = `${base}translateY(12px) scale(0.92)`;
 sheet.style.opacity='0.0';
 sheet.style.pointerEvents='none';
 } else {
 if(sheet.dataset.prevTransform!==undefined){
 sheet.style.left = sheet.dataset.prevLeft;
 sheet.style.top = sheet.dataset.prevTop;
 sheet.style.bottom = sheet.dataset.prevBottom;
 sheet.style.transform = sheet.dataset.prevTransform;
 sheet.style.opacity = sheet.dataset.prevOpacity;
 sheet.style.pointerEvents = sheet.dataset.prevPointer;
 delete sheet.dataset.prevLeft; delete sheet.dataset.prevTop; delete sheet.dataset.prevBottom;
 delete sheet.dataset.prevTransform; delete sheet.dataset.prevOpacity; delete sheet.dataset.prevPointer;
 } else {
 sheet.style.opacity='1'; sheet.style.pointerEvents='auto';
 if(document.body.classList.contains('touch')){
 sheet.style.transform = (sheet.dataset.touchFreed==='1') ? 'none' : 'translateX(-50%)';
 } else {
 sheet.style.transform='';
 }
 }
 }
 Actions.setCell(arr.id, anchor, `Minimize:${flag?1:0}`, ast.raw, true);
 }catch(e){ Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true); }
});
// ON_SELECT: register a per-cell (or range) selection hook
// =ON_SELECT([rangeOrRef], actionFormulaString)
// The action must be a *string* and should start with '='.
tag('ON_SELECT',['META'],(anchor,arr,ast)=>{
 // Turn off hook for this anchor
 if(ast.args.length===1 && typeof ast.args[0]==='string'){
 const t=String(ast.args[0]||'').toLowerCase();
 if(t==='off'||t==='none'||t==='0'||t==='false'){
 arr.on_select_hooks = ensureOnSelectHooks(arr).filter(h=>!(h.anchor.x===anchor.x && h.anchor.y===anchor.y && h.anchor.z===anchor.z));
 Actions.setCell(arr.id, anchor, 'on_select:OFF', ast.raw, true);
 return;
 }
 }

 let rangeArg=null;
 // We DO NOT valOf() the action; we store it as a literal formula string.
 const rawAction = (ast.args.length>=2 ? ast.args[1] : ast.args[0]);
 let action = (typeof rawAction === 'string') ? rawAction : String(rawAction||'');
 if(action && action[0] !== '=') action = `=${action}`; // normalize to formula string

 // Build cell set for matching
 const cells = new Set();
 if(ast.args.length>=2) rangeArg = ast.args[0];
 if(rangeArg && rangeArg.kind==='range'){
 rangeArg.cells.forEach(c=>cells.add(`${c.x},${c.y},${c.z}`));
 } else if(rangeArg && rangeArg.kind==='ref'){
 cells.add(`${rangeArg.x},${rangeArg.y},${rangeArg.z}`);
 } else {
 cells.add(`${anchor.x},${anchor.y},${anchor.z}`); // default self
 }

 // replace any existing hook at this anchor
 const hooks = ensureOnSelectHooks(arr).filter(h=>!(h.anchor.x===anchor.x && h.anchor.y===anchor.y && h.anchor.z===anchor.z));
 hooks.push({ anchor:{x:anchor.x,y:anchor.y,z:anchor.z}, cells, action });
 arr.on_select_hooks = hooks;

 // Silent registration; do not stamp the cell
});
tag('OVERLAP',['SCENE'],(anchor,arr,ast)=>{
 const targetArr=ast.args[0]; // array ref or ID
 const mode=String(valOf(ast.args[1])||'detect').toLowerCase(); // 'detect', 'count', 'list'
 // Placeholder: check if this array's cells overlap with target array's cells in 3D space
 const overlaps = 0; // TODO: implement actual overlap detection
 Actions.setCell(arr.id,anchor,`Overlap:${overlaps}`,ast.raw,true);
});
tag('EVALUATE',['META'],(anchor,arr,ast)=>{
 const condition=String(valOf(ast.args[0])); // formula to evaluate
 const result=!!valOf(ast.args[1]); // expected result
 // Simple condition evaluator for UI state control
 Actions.setCell(arr.id,anchor,result?'EVAL:TRUE':'EVAL:FALSE',ast.raw,true);
});

tag('IS_FOCUS_ARRAY',['PURE'],(anchor,arr,ast)=>{
 const targetId=ast.args[0] ? +valOf(ast.args[0]) : arr.id;
 const s=Store.getState().selection;
 const isFocused = s.arrayId === targetId;
 Actions.setCell(arr.id, anchor, isFocused?1:0, ast.raw, true);
});

// Diegetic UI Functions
// Note: A single TOAST(action) exists above (ACTION tag). Remove duplicate META variant to avoid override.
tag('AXES',['SCENE'],(anchor,arr,ast)=>{
 const m = String(Formula.valOf(ast.args[0] ?? '1')).toLowerCase();
 arr.axesVisible = (m==='1'||m==='true'||m==='on') ? true :
 (m==='0'||m==='false'||m==='off') ? false : undefined; // "auto"
 Scene.syncVisibility(arr);
 Actions.setCell(arr.id, anchor, 
 `Axes:${arr.axesVisible===undefined?'AUTO':(arr.axesVisible?'ON':'OFF')}`,
 ast.raw, true
 );
});
tag('FOCUS_SET',['ACTION'],(anchor,arr,ast)=>{
 const s = Store.getState().selection;
 if(!s?.arrayId || !s.focus) throw new Error('No focus');
 
 // Support both old and new syntax: FOCUS_SET(content) or FOCUS_SET(mode, content)
 let mode = 'text', content = '';
 if(ast.args.length === 1){
 content = String(Formula.valOf(ast.args[0]||''));
 mode = content.startsWith('=') ? 'formula' : 'text';
 } else {
 mode = String(Formula.valOf(ast.args[0]||'text')).toLowerCase();
 content = String(Formula.valOf(ast.args[1]||''));
 }
 
 if(mode === 'clipboard'){
 // Copy content to clipboard
 try {
 navigator.clipboard.writeText(content);
 Actions.setCell(arr.id, anchor, `?? Copied: ${content.slice(0,20)}`, ast.raw, true);
 showToast('Copied to clipboard');
 } catch(e) {
 Actions.setCell(arr.id, anchor, '?? Copy failed', ast.raw, true);
 showToast('Copy failed');
 }
 return;
 }
 
 if(mode === 'formula' || content.startsWith('=')){
 Formula.setFormula({arrId:s.arrayId, ...s.focus}, content);
 Formula.executeAt({arrId:s.arrayId, ...s.focus});
 } else {
 Actions.setCell(s.arrayId, s.focus, content, null, true);
 }
 
 Actions.setCell(arr.id, anchor, 'OK', ast.raw, true);
});

// COPY(text): write text to clipboard (callable, composable)
tag('COPY',['IO','ACTION'],(anchor,arr,ast)=>{
 const text = String(Formula.valOf(ast.args[0]||''));
 try{
 navigator.clipboard.writeText(text);
 showToast('Copied to clipboard');
 }catch(e){
 showToast('Copy failed');
 }
});

// PREVIEW(inArray[, overworld[, scope]]) binary toggles for enabling animations
// inArray: 1/0 to show per-cell overlays and drive in-array timed plans
// overworld: 1/0 to enable global (3D) array movement
tag('PREVIEW',["SCENE"],(anchor,arr,ast)=>{
 try{
 const enableIn = !!Formula.valOf(ast.args[0]||0);
 const enable3D = !!Formula.valOf(ast.args[1]||0);
 let scopeConfig = null;
 try{ scopeConfig = parseArrayScopeArg(ast.args[2], anchor, arr); }
 catch{}
 let T = (typeof Scene!=='undefined' && Scene.ensureTimedState) ? Scene.ensureTimedState(arr) : null;
 if(!T){
 try{
 arr.params = arr.params || {};
 arr.params.timed = arr.params.timed || { ticks:60, reverse:false, reverseTicks:null, repeat:false, t:0, dir:1, previewInArray:false, plan:[], baseOffset:null, baseQuat:null, overlay:null };
 T = arr.params.timed;
 }catch{}
 }
 if(T){
 // Build plan first, but always enable local preview; show placeholder if plan empty
 if(enableIn){
 try{ T.plan = []; }catch{}
 try{ Scene.buildTimedPlanFromArray?.(arr); }catch{}
 try{ arr._previewBursts = new Set(); }catch{}
 T.previewInArray = true;
 // Default looping animation if not configured by TIMED_TRANSLATION
 if(!(T.ticks>0)){ T.ticks = 120; }
 if(T.repeat==null) T.repeat = true;
 if(T.reverse==null) T.reverse = false;
 T.t = 0; T.dir = 1;
 } else {
 T.previewInArray = false;
 if(arr._previewBursts){ try{ arr._previewBursts.clear(); }catch{} arr._previewBursts = null; }
 }
 }
 // The rest: overlay/mask handling unchanged
 if(enableIn && T){
 if(!T.overlay){
 T.overlay = { group:new THREE.Group(), cells:new Map() };
 try{ if(arr._frame){ arr._frame.add(T.overlay.group); } else { Scene.addToScene?.(T.overlay.group); } }catch{ try{ Scene.addToScene?.(T.overlay.group); }catch{} }
 }
 try{ if(typeof Scene!=='undefined' && Scene.maskArrayForPreview) Scene.maskArrayForPreview(arr, true); }catch{}
 } else if(T) {
 if(T.overlay){ try{ T.overlay.group.parent?.remove(T.overlay.group); }catch{ try{ Scene.removeFromScene?.(T.overlay.group); }catch{} } T.overlay=null; }
 try{ if(typeof Scene!=='undefined' && Scene.maskArrayForPreview) Scene.maskArrayForPreview(arr, false); }catch{}
 }
 const G = (typeof Scene!=='undefined' && Scene.ensureTimed3D) ? Scene.ensureTimed3D() : ((Store.getState().scene.timed3D=Store.getState().scene.timed3D||{configured:false,preview:false}), Store.getState().scene.timed3D);
 const was3DPreviewing = !!G?.preview;
 const arrIdRaw = Number.isFinite(arr?.id) ? arr.id : (Number.isFinite(anchor?.arrId) ? anchor.arrId : null);
 const arrId = Number.isFinite(arrIdRaw) ? Math.trunc(arrIdRaw) : null;
 const normalizedScope = scopeConfig ? {
 mode: scopeConfig.mode || 'host',
 ids: Array.isArray(scopeConfig.ids) ? scopeConfig.ids.map(n=> Number.isFinite(+n)?(Math.trunc(+n)):null).filter(n=>n!=null) : []
 } : null;
 if(G){
 const sanitizeIds=(list)=> Array.from(new Set((Array.isArray(list)?list:[]).map(n=> Number.isFinite(+n)?(Math.trunc(+n)):null).filter(n=>n!=null)));
 let activeIds = sanitizeIds(G.activeHostIds);
 if(enable3D){
 if(arrId!=null && !activeIds.includes(arrId)) activeIds.push(arrId);
 G.activeHostIds = activeIds;
 if(normalizedScope){
 G.scope = normalizedScope;
 } else if(G.scope && G.scope.mode === 'all'){
 // keep existing 'all' scope
 } else {
 const merged = new Set(activeIds);
 if(G.scope && (G.scope.mode === 'limit' || G.scope.mode === 'host')){
 sanitizeIds(G.scope.ids).forEach(id=>merged.add(id));
 }
 if(merged.size===0 && arrId!=null) merged.add(arrId);
 G.scope = { mode:'limit', ids:Array.from(merged) };
 }
 if(arrId!=null){ G.hostId = arrId; }
 else if(Number.isFinite(+G.hostId)){ G.hostId = Math.trunc(+G.hostId); }
 else if(activeIds.length){ G.hostId = activeIds[0]; }
 G.preview = true;
 } else {
 if(arrId!=null){
 activeIds = activeIds.filter(id=>id!==arrId);
 }
 G.activeHostIds = activeIds;
 if(normalizedScope){
 G.scope = normalizedScope;
 } else if(G.scope && G.scope.mode === 'all'){
 // keep existing 'all' scope
 } else {
 G.scope = activeIds.length ? { mode:'limit', ids:[...activeIds] } : null;
 }
 if(activeIds.length){
 const currentHost = Number.isFinite(+G.hostId) ? Math.trunc(+G.hostId) : null;
 if(currentHost!=null && activeIds.includes(currentHost)){ G.hostId = currentHost; }
 else { G.hostId = activeIds[0]; }
 G.preview = true;
 } else {
 G.hostId = null;
 G.preview = false;
 }
 }
 }
 const previewStillActive = !!G?.preview;
 // If global preview transitioned to OFF, immediately restore arrays to their captured base transforms
 if(G && was3DPreviewing && !previewStillActive){
 try{
 const arrays = Object.values(Store.getState().arrays||{});
 arrays.forEach(a=>{
 try{
 const T = (typeof Scene!=='undefined' && Scene.ensureTimedState) ? Scene.ensureTimedState(a) : (a.params&&a.params.timed);
 if(T){
 // Restore base transforms if captured during preview
 if(T.baseOffset){ try{ Scene.setArrayOffset?.(a, {x:T.baseOffset.x,y:T.baseOffset.y,z:T.baseOffset.z}, {interactive:true}); }catch{} }
 if(a._frame && T.baseQuat){ try{ a._frame.quaternion.copy(T.baseQuat); }catch{} }
 T.t = 0; T.dir = 1;
 // Remove overlays and unmask content
 try{ if(T.overlay){ T.overlay.group.parent?.remove(T.overlay.group); T.overlay=null; } }catch{}
 }
 try{ if(typeof Scene!=='undefined' && Scene.maskArrayForPreview) Scene.maskArrayForPreview(a, false); }catch{}
 }catch{}
 });
 // Reset wait counter so next enable starts fresh
 try{ G._waitCounter = 0; }catch{}
 try{ G.activeHostIds = []; }catch{}
 }catch{}
 }
 Actions.setCell(arr.id, anchor, `Preview:${enableIn?1:0}/${enable3D?1:0}`, ast.raw, true);
 }catch(e){ Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true); }
});

// TIMED_TRANSLATION(ticks, repeat, reverse?, reverseTicks?) config only, no animation
tag('TIMED_TRANSLATION',["SCENE"],(anchor,arr,ast)=>{
 try{
 const ticks = (+Formula.valOf(ast.args[0]||60))|0;
 const repeat = !!Formula.valOf(ast.args[1]||0);
 const reverse = !!Formula.valOf(ast.args[2]||0);
 const reverseTicks = (ast.args[3]!==undefined) ? ((+Formula.valOf(ast.args[3])|0) || ticks) : null;
 const smooth = !!((+Formula.valOf(ast.args[4]||0))|0);
 const cfgFn = (typeof Scene!=='undefined' && Scene.configTimed) ? Scene.configTimed : (a,c)=>{ try{ /* fallback no-op */ }catch{} };
 cfgFn(arr, { ticks, repeat, reverse, reverseTicks, smooth });
 Actions.setCell(arr.id, anchor, `Timed:cfg(${ticks})`, ast.raw, true);
 }catch(e){ Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true); }
});

// 3D_TIMED_TRANSLATION(ticks, repeat, reverse?, reverseTicks?, smooth?, scope?) global config
tag('3D_TIMED_TRANSLATION',["SCENE"],(anchor,arr,ast)=>{
 try{
 const ticks = (+Formula.valOf(ast.args[0]||60))|0;
 const repeat = !!Formula.valOf(ast.args[1]||0);
 const reverse = !!Formula.valOf(ast.args[2]||0);
 const reverseTicks = (ast.args[3]!==undefined) ? ((+Formula.valOf(ast.args[3])|0) || ticks) : null;
 const smooth = !!((+Formula.valOf(ast.args[4]||0))|0);
 let scopeConfig;
 try{ scopeConfig = parseArrayScopeArg(ast.args[5], anchor, arr); }
 catch{ scopeConfig = parseArrayScopeArg(null, anchor, arr); }
 // Robust ensure timed3D state
 let G = null;
 try{ if(typeof Scene!=='undefined' && Scene.ensureTimed3D) G = Scene.ensureTimed3D(); }catch{}
 if(!G){
 const S = Store.getState();
 const sceneState = S.scene || {};
 if(!sceneState.timed3D){ sceneState.timed3D = { configured:false, ticks:60, repeat:false, reverse:false, reverseTicks:null, t:0, dir:1, preview:false, smooth:false }; }
 Store.setState(s=>({ scene: { ...s.scene, timed3D: sceneState.timed3D } }));
 G = sceneState.timed3D;
 }
 G.configured = true; G.ticks=Math.max(1,ticks|0); G.repeat=repeat; G.reverse=reverse; G.reverseTicks=reverseTicks; G.t=0; G.dir=1; G.smooth = smooth;
 G.hostId = arr?.id ?? anchor?.arrId ?? null;
 if(scopeConfig){
 G.scope = { mode: scopeConfig.mode, ids: Array.from(scopeConfig.ids||[]) };
 }
 Actions.setCell(arr.id, anchor, `3D_Timed:cfg(${ticks})`, ast.raw, true);
 }catch(e){ Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true); }
});

// OVERLAP(sortAscDesc, metric, mergeMode, alwaysExec)
// sortAscDesc: 0 asc, 1 desc (default 1)
// metric: 0 by value, 1 by array size (default 0)
// mergeMode: 0 then() wrap, 1 overwrite (default 1)
// alwaysExec: 0 only on combine, 1 on any overlap (default 0)
tag('OVERLAP',["ACTION"],(anchor,arr,ast,tx)=>{
 // Executed by InteractionManager with context in globalState.temp.overlap_target
 const S=Store.getState();
 const cfg={
 sort:(+Formula.valOf(ast.args[0])|0)||1,
 metric:(+Formula.valOf(ast.args[1])|0)||0,
 merge:(+Formula.valOf(ast.args[2])|0)||1,
 always:(+Formula.valOf(ast.args[3])|0)||0
 };
 const t=S.globalState.get('temp.overlap_target');
 if(!t) return;
 const own={ ref:anchor, arr:arr, cell: Formula.getCell(anchor) };
 const other={ ref:t, arr: S.arrays[t.arrId], cell: Formula.getCell(t) };
 let ownScore, otherScore;
 if(cfg.metric===1){
 ownScore = own.arr.size.x*own.arr.size.y*own.arr.size.z;
 otherScore = other.arr.size.x*other.arr.size.y*other.arr.size.z;
 } else {
 ownScore = parseFloat(own.cell.value)||0;
 otherScore = parseFloat(other.cell.value)||0;
 }
 let winner=own, loser=other;
 const cmp = cfg.sort===1 ? (ownScore>=otherScore) : (ownScore<=otherScore);
 if(!cmp){ winner=other; loser=own; }
 const ownsTx = !tx; if(ownsTx) tx=Write.start('overlap.resolve','OVERLAP');
 const esc=(s)=> String(s??'').replace(/"/g,'\\"');
 if(cfg.merge===0){ // then wrap
 const wC = winner.cell.formula || winner.cell.value; const lC = loser.cell.formula || loser.cell.value;
 const f=`=THEN("${esc(lC)}", "${esc(wC)}")`;
 Write.set(tx, winner.ref.arrId, {x:winner.ref.x,y:winner.ref.y,z:winner.ref.z}, { value:'', formula:f });
 } else {
 // overwrite with winner's existing content (no change)
 Write.set(tx, winner.ref.arrId, {x:winner.ref.x,y:winner.ref.y,z:winner.ref.z}, { value: winner.cell.value, formula: winner.cell.formula });
 }
 if(ownsTx) Write.commit(tx);
});

// THEN(refs...): sequentially executes refs/ranges and returns last result into anchor
tag('THEN',["ACTION"],(anchor,arr,ast,tx)=>{
 const ownsTx = !tx; if(ownsTx) tx = Write.start('then.sequence','THEN wrapper');
 let last='';
 const processRef=(ref)=>{
 const c = Formula.getCell(ref);
 const content = (c && c.formula) ? c.formula : (c ? c.value : '');
 if(String(content||'').startsWith('=')){
 Formula.runOnceAt(ref, content, tx);
 last = Formula.getCellValue(ref);
 } else { last = content; }
 };
 ast.args.forEach(a=>{
 if(a && a.kind==='ref') processRef(a);
 else if(a && a.kind==='range') a.cells.sort((a,b)=> a.y-b.y || a.x-b.x || a.z-b.z).forEach(processRef);
 else last = Formula.valOf(a);
 });
 Write.set(tx, arr.id, anchor, { value: last, formula: ast.raw });
 if(ownsTx) Write.commit(tx);
});

// HUSK(range): copy values, delete source array, leave remnants at anchor block
tag('HUSK',["ACTION","BLOCK"],(anchor,arr,ast,tx)=>{
 if(!tx) throw new Error('HUSK requires an active transaction');
 const src=ast.args[0]; if(!src||src.kind!=='range') throw new Error('HUSK requires a range');
 const aid=src.cells[0].arrId; if(aid===arr.id) throw new Error('HUSK source must differ');
 const xs=[...new Set(src.cells.map(c=>c.x))].sort((a,b)=>a-b);
 const ys=[...new Set(src.cells.map(c=>c.y))].sort((a,b)=>a-b);
 const zs=[...new Set(src.cells.map(c=>c.z))].sort((a,b)=>a-b);
 const minX=xs[0], minY=ys[0], minZ=zs[0];
 const ak=aKey(anchor);
 zs.forEach(z=> ys.forEach(y=> xs.forEach(x=>{
 const v=Formula.getCellValue({arrId:aid,x,y,z});
 const dx=x-minX, dy=y-minY, dz=z-minZ;
 const tgt={x:anchor.x+dx,y:anchor.y+dy,z:anchor.z+dz};
 const isAnchor=(dx===0&&dy===0&&dz===0);
 Write.set(tx, arr.id, tgt, { value: v, formula: isAnchor? ast.raw : null, meta:{generated:true, emitter:ak} });
 })));
 setTimeout(()=>{ try{ Actions.deleteArray(aid); }catch{} }, 50);
});

// DO(f1[, f2[, ...]]): sequence multiple sub-formulas in order, return last
// Accepts legacy string arguments or block form (DO{ ... }).
tag('DO',['ACTION'],(anchor,arr,ast,tx)=>{
 const boolish = (value)=>{
 if(typeof value === 'boolean') return value;
 if(typeof value === 'number') return value !== 0;
 if(typeof value === 'string'){
 const trimmed = value.trim().toLowerCase();
 if(trimmed === '' || trimmed === '0' || trimmed === 'false' || trimmed === 'no') return false;
 return true;
 }
 return !!value;
 };

 const isBlock = !!ast.block;
 const options = ast.blockOptions || {};
 const atomicOpt = options.atomic;
 const errorModeRaw = options['on_error'] ?? options['onerror'] ?? '';
 const errorMode = String(errorModeRaw || '').trim().toLowerCase();
 const continueOnError = (errorMode === 'continue' || errorMode === 'next' || errorMode === 'skip');

 const wantsAtomic = tx ? true : (atomicOpt !== undefined ? boolish(atomicOpt) : !isBlock);
 let innerTx = tx;
 let ownsTx = false;
 if(!innerTx && wantsAtomic){
 innerTx = Write.start('do.sequence','DO wrapper');
 ownsTx = true;
 }

 const execTx = tx ? tx : (wantsAtomic ? innerTx : null);
 const steps = Array.isArray(ast.args) ? ast.args : [];
 let shouldAbort = false;

 for(const step of steps){
 let formulaText = '';
 if(typeof step === 'string'){
 formulaText = step;
 } else {
 formulaText = String(Formula.valOf(step) ?? '');
 }
 if(!formulaText) continue;
 if(formulaText[0] !== '=') formulaText = `=${formulaText}`;
 warmChimeIfNeeded(formulaText);
 try{
 Formula.executeAt(anchor, formulaText, execTx);
 } catch(e){
 console.warn('DO step error', e);
 if(!continueOnError){
 shouldAbort = true;
 break;
 }
 }
 }

 if(ownsTx){
 if(!shouldAbort){
 try{ Write.commit(innerTx); }
 catch(e){ console.warn('Failed to commit DO transaction', e); }
 }
 }
 // silent: do not stamp the cell
});

// SEQ(...) is an alias for DO(...)
tag('SEQ',['ACTION'],(anchor,arr,ast,tx)=>{
 const proxyAst = { ...ast, fn: 'DO' };
 return Fn['DO'].impl(anchor, arr, proxyAst, tx);
});

// PIPE(value, step1, step2, ...): compose expressions sequentially using '_' placeholder
tag('PIPE',['ACTION'],(anchor,arr,ast,tx)=>{
 const initialExpr = typeof ast.pipeInitial === 'string' ? ast.pipeInitial.trim() : '';
 const stages = Array.isArray(ast.pipeStages) ? [...ast.pipeStages] : [];
 const composeStage = (stage, prev)=>{
 if(!stage) return prev;
 const trimmed = stage.trim();
 if(!trimmed) return prev;
 if(/\b_\b/.test(trimmed)){
 return trimmed.replace(/\b_\b/g, prev);
 }
 const idx = trimmed.lastIndexOf(')');
 if(idx === -1){
 return `${trimmed}(${prev})`;
 }
 const openIdx = trimmed.indexOf('(');
 if(openIdx === -1 || idx < openIdx){
 return `${trimmed}(${prev})`;
 }
 const beforeArgs = trimmed.slice(0, openIdx + 1);
 const argsContent = trimmed.slice(openIdx + 1, idx);
 const after = trimmed.slice(idx);
 const prefix = argsContent.trim().length ? `${argsContent}, ` : '';
 return `${beforeArgs}${prefix}${prev}${after}`;
 };

 let current = initialExpr;
 if(!current && stages.length){
 current = stages.shift().trim();
 }
 if(!current) return;
 for(const stage of stages){
 current = composeStage(stage, current);
 }
 if(!current) return;
 const finalFormula = `=${current}`;
 warmChimeIfNeeded(finalFormula);
 try{
 Formula.runOnceAt(anchor, finalFormula, tx || null);
 } catch(e){
 console.warn('PIPE execution error', e);
 }
});

tag('DELAY',['ACTION'],(anchor,arr,ast)=>{
 const ticks = Math.max(0, (+Formula.valOf(ast.args[0]??0)|0));
 const raw = ast.args[1];
 let action = (typeof raw==='string')? raw : String(Formula.valOf(raw)||'');
 if(!action){ Actions.setCell(arr.id, anchor, '!ERR:DELAY:NO_ACTION', ast.raw, true); return; }
 warmChimeIfNeeded(action);
 const ms = ticks * ACTION_TICK_MS;
 const target = {arrId:anchor.arrId||arr.id, x:anchor.x, y:anchor.y, z:anchor.z};
 setTimeout(()=>{
 warmChimeIfNeeded(action);
 executeActionFormula(target, action, 'delay');
 }, ms);
 Actions.setCell(arr.id, anchor, `Delay:${ticks}`, ast.raw, true);
});

tag('REPEAT',['ACTION'],(anchor,arr,ast)=>{
 const raw = ast.args[0];
 let action = (typeof raw==='string')? raw : String(Formula.valOf(raw)||'');
 if(!action){ Actions.setCell(arr.id, anchor, '!ERR:REPEAT:NO_ACTION', ast.raw, true); return; }
 let count = ast.args[1]!==undefined ? (+Formula.valOf(ast.args[1])|0) : 1;
 if(count === 0){ console.warn('REPEAT infinite mode not supported outside continuous triggers; defaulting to 1'); count = 1; }
 const intervalTicks = ast.args[2]!==undefined ? Math.max(1, (+Formula.valOf(ast.args[2])|0)) : 1;
 const target = {arrId:anchor.arrId||arr.id, x:anchor.x, y:anchor.y, z:anchor.z};
 const run = ()=>{ warmChimeIfNeeded(action); executeActionFormula(target, action, 'repeat'); };
 run();
 let remaining = count-1;
 if(remaining>0){
 const intervalMs = intervalTicks * ACTION_TICK_MS;
 const id = setInterval(()=>{
 run();
 remaining--;
 if(remaining<=0) clearInterval(id);
 }, intervalMs);
 }
 Actions.setCell(arr.id, anchor, `Repeat:${count}`, ast.raw, true);
});

// EXEC_AT(x, y, z, arrId, formulaText) or EXEC_AT(ref, formulaText)
// Executes the provided formula text at the target anchor without stamping current cell
tag('EXEC_AT',["ACTION"],(anchor,arr,ast,tx)=>{
 if(!tx) throw new Error('EXEC_AT requires an active transaction (use inside DO)');
 const a0 = ast.args[0];
 const a1 = ast.args[1];
 let target=null, formula='';
 if(a1===undefined){
 throw new Error('EXEC_AT needs target and formula');
 }
 // Form 1: EXEC_AT(ref, formula)
 if(a0 && a0.kind==='ref'){
 target = {arrId:a0.arrId, x:a0.x, y:a0.y, z:a0.z};
 formula = String(Formula.valOf(a1)||'');
 } else if(ast.args.length>=5){
 // Form 2: EXEC_AT(x, y, z, arrIdExpr, formula)
 const x=(+Formula.valOf(ast.args[0])|0), y=(+Formula.valOf(ast.args[1])|0), z=(+Formula.valOf(ast.args[2])|0);
 const id = (+Formula.valOf(ast.args[3])|0);
 if(!Store.getState().arrays[id]) throw new Error('EXEC_AT: target array not found');
 target = {arrId:id, x, y, z};
 formula = String(Formula.valOf(ast.args[4])||'');
 } else if(typeof a0==='string' || typeof a0==='number'){
 // Allow dynamic absolute string like "@[x,y,z,id]"
 const parsed = parseAlt(String(Formula.valOf(a0)));
 if(!parsed) throw new Error('EXEC_AT: invalid target');
 target = {arrId:parsed.arrId, x:parsed.x, y:parsed.y, z:parsed.z};
 formula = String(Formula.valOf(a1)||'');
 } else {
 throw new Error('EXEC_AT: invalid arguments');
 }
 if(!formula || formula[0] !== '=') formula = `=${formula}`;
 warmChimeIfNeeded(formula);
 Formula.executeAt(target, formula, tx);
});

// DELETE(...targets) delete arrays by id or ref; default self
tag('DELETE',["ACTION"], (anchor,arr,ast)=>{
 try{
 const toArrId = (a)=>{
 if(a && a.kind==='ref') return a.arrId ?? arr.id;
 const v = Formula.valOf(a);
 if(v===undefined || v===null || v==='') return null;
 if(typeof v === 'string'){
 const lower = v.trim().toLowerCase();
 if(lower === 'self') return arr.id;
 // Accept A1-style without array id by defaulting to host
 const parsed = parseAlt(v) || parseA1g(v, arr.id);
 if(parsed) return parsed.arrId;
 const n = +v; if(Number.isFinite(n)) return Math.trunc(n);
 return null;
 }
 const n = +v; if(Number.isFinite(n)) return Math.trunc(n);
 return null;
 };

 let targets = ast.args.length ? ast.args.map(toArrId).filter(id=>id!=null) : [arr.id];
 // Unique and skip reserved (0, -1)
 targets = [...new Set(targets)].filter(id => id!=null && id !== 0 && id !== -1);

 if(targets.length === 0){
 Actions.setCell(arr.id, anchor, '!ERR:DELETE:NoTarget', ast.raw, true);
 return;
 }

 let ok = 0;
 targets.forEach(id=>{
 try{
 const A = Store.getState().arrays[id];
 if(A){ try{ Scene.startDatafallDelete?.(A); }catch{} }
 ok++;
 }catch{}
 });

 Actions.setCell(arr.id, anchor, `Deleted:${ok}`, ast.raw, true);
 }catch(e){
 Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true);
 }
});

// Short aliases
tag('DEL',["ACTION"], (anchor,arr,ast)=> Fn['DELETE'].impl(anchor,arr,ast));
tag('REMOVE',["ACTION"], (anchor,arr,ast)=> Fn['DELETE'].impl(anchor,arr,ast));

// CONNECT(ref1, ref2[, style[, dimensionMode]]) => creates traversal connectors
tag('CONNECT',['SCENE', 'ACTION'],(anchor,arr,ast)=>{
 const normalizeRef = (ref)=>{
 if(!ref || ref.kind !== 'ref') return null;
 return { ...ref, arrId: ref.arrId ?? arr.id };
 };
 const ref1 = normalizeRef(ast.args[0]);
 const ref2 = normalizeRef(ast.args[1]);

 // Validate inputs
 if(!ref1 || !ref2){
 Actions.setCell(arr.id, anchor, '!ERR:Requires 2 cell refs', ast.raw, true);
 Scene.removeConnection(anchor); // Clean up any old line
 return;
 }

 let style = '';
 let dimensionMode = 'line';
 let dimensionExplicit = false;
 if(ast.args[2] !== undefined){
 const raw = Formula.valOf(ast.args[2]);
 if(raw != null){
 const text = String(raw).trim();
 if(['line','platform','zipline','grind'].includes(text.toLowerCase())){
 dimensionMode = text.toLowerCase();
 dimensionExplicit = true;
 } else {
 style = text;
 }
 }
 }
 if(ast.args[3] !== undefined){
 const modeRaw = String(Formula.valOf(ast.args[3]) || '').trim().toLowerCase();
 if(modeRaw){
 dimensionMode = modeRaw;
 dimensionExplicit = true;
 }
 }

 // Pass to the Scene module to handle rendering and physics state
 Scene.addConnection(anchor, ref1, ref2, { style, dimensionMode, dimensionExplicit });
 const statusParts = ['??', dimensionMode.toUpperCase()];
 if(style) statusParts.push(`(${style})`);
 Actions.setCell(arr.id, anchor, statusParts.join(' '), ast.raw, true);
});

// GOAL(conditionRef) => register a goal condition
tag('GOAL',['META'],(anchor,arr,ast)=>{
 const conditionRef = ast.args[0];
 if(!conditionRef || conditionRef.kind !== 'ref') {
 Actions.setCell(arr.id, anchor, '!ERR:Requires condition ref', ast.raw, true);
 return;
 }
 
 const S = Store.getState();
 const goalKey = aKey(anchor);
 S.gameState.goals.set(goalKey, conditionRef);
 Actions.setCell(arr.id, anchor, '?? Goal Set', ast.raw, true);
});
// ONWIN(actionFormula) => register callback for when all goals are met
tag('ONWIN',['META'],(anchor,arr,ast)=>{
 const actionFormula = String(valOf(ast.args[0] || '')) || '';
 if(!actionFormula) {
 Actions.setCell(arr.id, anchor, '!ERR:Requires action formula', ast.raw, true);
 return;
 }
 
 const S = Store.getState();
 S.gameState.winCallbacks.push({
 anchor: {...anchor},
 callback: actionFormula
 });
 Actions.setCell(arr.id, anchor, '?? Win Handler Set', ast.raw, true);
});

function listAllowedFunctionsFor(arr){
 const names = Object.keys(Fn);
 const pol = arr.fnPolicy || {mode:'ALLOW_ALL', allow:new Set(), deny:new Set(), tags:new Set()};
 const has = (set, n)=> set && (set.has?.(n) || set.has?.(n.toUpperCase?.()||n));
 const matchesTags = (n)=> {
 if(!pol.tags || !pol.tags.size) return true;
 const tags = Fn[n]?.tags || new Set();
 for(const t of pol.tags) if(tags.has(t)) return true;
 return false;
 };

 let allowed = [];
 if(pol.mode==='ALLOW_ONLY'){
 const base = names.filter(n => has(pol.allow,n) || ALWAYS.has(n));
 allowed = base.filter(matchesTags);
 } else {
 allowed = names.filter(n => !has(pol.deny,n) || ALWAYS.has(n)).filter(matchesTags);
 }
 return [...new Set(allowed)].sort();
}
tag('FUNCTION_UI',['META'],(anchor,arr,ast)=>{
 // Batch to coalesce all writes into a single transaction
 Actions.begin();
 const port = String(Formula.valOf(ast.args[0] ?? 'east')).toLowerCase();
 const filterSub = String(Formula.valOf(ast.args[1] ?? '')||'').toLowerCase();
 const page = Math.max(0, (+Formula.valOf(ast.args[2] ?? 0)|0));
 const perPage = Math.max(5, (+Formula.valOf(ast.args[3] ?? 12)|0));

 const host = Store.getState().arrays[anchor.arrId];
 // Idempotence guard: reuse an existing Function Browser mount if present
 const existingMount = (host._uiMounts||[]).find(m=>m.name==='Function Browser');
 if(existingMount && Store.getState().arrays[existingMount.id]){
 const ui=Store.getState().arrays[existingMount.id];
 ui.hidden=false; Scene.syncVisibility(ui);
 const p = dockOffsetFor(host, port, 1.0);
 Scene.setArrayOffset(ui, p);
 Actions.end();
 return;
 }
 const full = listAllowedFunctionsFor(host);
 const list = filterSub ? full.filter(n=>n.toLowerCase().includes(filterSub)) : full;

 // Group functions by category for collapsible interface
 const categories = {};
 const categoryInfo = {
 'GLOBAL': {icon: '??', name: 'Global State'},
 'EVENTS': {icon: '?', name: 'Events'},
 'GAMES': {icon: '??', name: 'Games'},
 'DATA': {icon: '??', name: 'Data'},
 'LOGIC': {icon: '??', name: 'Logic'},
 'MATH': {icon: '??', name: 'Math'},
 'NAVIGATION': {icon: '??', name: 'Nav'},
 'INTERACTION': {icon: '??', name: 'Input'},
 'SCENE': {icon: '??', name: 'Scene'},
 'IO': {icon: '??', name: 'I/O'},
 'ADVANCED': {icon: '??', name: 'Advanced'}
 };
 
 list.forEach(name => {
 const tags = [...(Fn[name]?.tags || [])];
 let category = 'OTHER';
 if(tags.includes('GLOBAL')) category = 'GLOBAL';
 else if(tags.includes('EVENT') || name.includes('EVENT')) category = 'EVENTS';
 else if(tags.includes('GAME') || name.includes('FISH') || name.includes('GALAXY')) category = 'GAMES';
 else if(tags.includes('PURE') && (name.includes('ARRAY') || name.includes('GET') || name.includes('SET') || name.includes('BLIT'))) category = 'DATA';
 else if(tags.includes('LOGIC') || name.includes('IF') || name.includes('AND') || name.includes('OR')) category = 'LOGIC';
 else if(tags.includes('MATH') || name.includes('ADD') || name.includes('MUL') || name.includes('CLAMP')) category = 'MATH';
 else if(name.includes('ADDRESS') || name.includes('SELF') || name.includes('OFFSET') || name.includes('SELECT')) category = 'NAVIGATION';
 else if(name.includes('ON_SELECT') || name.includes('SELECTED') || name.includes('TARGET')) category = 'INTERACTION';
 else if(tags.includes('SCENE') || name.includes('PHYSICS') || name.includes('HIGHLIGHT')) category = 'SCENE';
 else if(tags.includes('IO') || name.includes('COPY') || name.includes('EXPORT') || name.includes('IMPORT')) category = 'IO';
 else if(name.includes('VECTOR') || name.includes('FORMULA') || name.includes('PRIORITY')) category = 'ADVANCED';
 
 if(!categories[category]) categories[category] = [];
 categories[category].push(name);
 });

 // Calculate total rows needed: category headers + functions + some padding
 const categoryCount = Object.keys(categories).length;
 const functionCount = list.length;
 const totalRows = categoryCount * 2 + functionCount + 3; // headers + functions + padding
 
 const cols = 4;
 const ui = Actions.createArray({name:'Function Browser', size:{x:cols,y:totalRows, z:1}, hidden:false});

 let currentY = ui.size.y - 1;
 
 // Create collapsible category structure with ON_SELECT chains
 Object.entries(categories).forEach(([catName, funcs]) => {
 const info = categoryInfo[catName] || {icon: '??', name: catName};
 
 // Store previous functions below using temporary storage approach
 const tempStorageY = currentY - funcs.length - 10; // Store below visible area
 
 // Category header with collapse/expand functionality 
 Actions.setCell(ui.id, {x:0,y:currentY,z:0}, info.icon, null, true);
 Actions.setCell(ui.id, {x:1,y:currentY,z:0}, info.name, null, true);
 Actions.setCell(ui.id, {x:2,y:currentY,z:0}, `${funcs.length} functions`, null, true);
 
 // Expand/Collapse toggle with sophisticated temporary array manipulation 
 const collapseState = `collapse_${catName}_${ui.id}`;
 const toggle = `=ON_SELECT(SELF(), DO(
 "=SET_GLOBAL(\\\"${collapseState}\\\", IF(GET_GLOBAL(\\\"${collapseState}\\\"), 0, 1))",
 "=IF(GET_GLOBAL(\\\"${collapseState}\\\"), ARRAY(\\\"set\\\", ${funcs.map(f => `\\\\\"${f}\\\\\"`).join(',')}), ARRAY(\\\"set\\\", \\\"\\\\\\\\\\\\\\\", \\\"\\\\\\\\\\\\\\\", \\\"\\\\\\\\\\\\\\\", \\\"\\\\\\\\\\\\\\\") )"
 ))`;
 
 Actions.setCell(ui.id, {x:3,y:currentY,z:0}, '?', toggle, true);
 
 currentY--;
 
 // Function rows (initially collapsed)
 funcs.forEach((name, i) => {
 const y = currentY - i;
 const tags = [...(Fn[name]?.tags || [])].join(',');
 
 // Function name with insert action
 Actions.setCell(ui.id, {x:1,y,z:0}, name, null, true);
 Actions.setCell(ui.id, {x:2,y,z:0}, tags.slice(0,15), null, true);
 
 // Copy button
 const call = `=${name}()`;
 const copyAction = `=ON_SELECT(SELF(), DO("=COPY(\\\"${call}\\\")", "=TOAST(\\\"Copied ${name}()\\\")"))`;
 Actions.setCell(ui.id, {x:0,y,z:0}, '??', copyAction, true);
 
 // Insert button that writes to focus
 const insertAction = `=ON_SELECT(SELF(), DO("=FOCUS_SET(\\\"formula\\\",\\\"${call}\\\")", "=TOAST(\\\"Inserted ${name}()\\\")"))`;
 Actions.setCell(ui.id, {x:3,y,z:0}, '?', insertAction, true);
 });
 
 currentY -= funcs.length + 1; // Space between categories
 });
 // Force complete re-render after all cells are written (batched)
 console.log(`FUNCTION_UI: forcing render for array #${ui.id} with ${categoryCount} categories`);
 ui._layersRendered = false;
 Scene.renderArray(ui);
 
 // Then position it
 const p = dockOffsetFor(host, port, 1.0);
 Scene.setArrayOffset(ui, p);

 host._uiMounts = host._uiMounts || [];
 host._uiMounts.push({id:ui.id, name:'Function Browser', port});

 // Silent registration: do not stamp anchor to avoid re-evaluation loops
 Actions.end();
});
tag('INVENTORY',['META'],(anchor,arr,ast)=>{
 Actions.begin();
 const port = String(Formula.valOf(ast.args[0] ?? 'north')).toLowerCase();
 const title = String(Formula.valOf(ast.args[1] ?? 'Inventory'));

 const host = Store.getState().arrays[anchor.arrId];
 // Idempotence guard: reuse existing inventory mount
 const existing = (host._uiMounts||[]).find(m=>m.name==='Inventory');
 if(existing && Store.getState().arrays[existing.id]){
 const inv = Store.getState().arrays[existing.id];
 inv.hidden=false; Scene.syncVisibility(inv);
 const p = dockOffsetFor(host, port, 1.0);
 Scene.setArrayOffset(inv, p);
 Actions.end();
 return;
 }
 const rows = 6;
 const inv = Actions.createArray({name:title, size:{x:5, y:rows, z:1}, hidden:false});

 // Use Actions.setCell for immediate visibility like FUNCTION_UI
 const YT = inv.size.y-1;
 Actions.setCell(inv.id, {x:0,y:YT,z:0}, title, null, true);
 Actions.setCell(inv.id, {x:1,y:YT,z:0}, 'Item', null, true);
 Actions.setCell(inv.id, {x:2,y:YT,z:0}, 'Qty', null, true);
 Actions.setCell(inv.id, {x:3,y:YT,z:0}, '+1', null, true);
 Actions.setCell(inv.id, {x:4,y:YT,z:0}, '-1', null, true);

 const example = ['Iron','Water','Wood','Gears'];
 for(let i=0;i<example.length && i<rows-1;i++){
 const y = YT-1-i;
 const name = example[i];
 Actions.setCell(inv.id, {x:1,y,z:0}, name, null, true);
 Actions.setCell(inv.id, {x:2,y,z:0}, 0, null, true);

 // Working +/- buttons using ON_SELECT with SET to keep label stable
 const qtyRef = `@[2,${y},0,${inv.id}]`;
 const plus = `=ON_SELECT(SELF(), "=DO(\\"=SET(${qtyRef}, ADD(OFFSET(${qtyRef},0,0,0),1))\\", \\"=DISPLAY_AS(\\"+\\", SELF())\\")")`;
 const minus = `=ON_SELECT(SELF(), "=DO(\\"=SET(${qtyRef}, CLAMP(ADD(OFFSET(${qtyRef},0,0,0),-1),0,999))\\", \\"=DISPLAY_AS(\\"-\\", SELF())\\")")`;
 Actions.setCell(inv.id, {x:3,y,z:0}, '+', plus, true);
 Actions.setCell(inv.id, {x:4,y,z:0}, '-', minus, true);

 // Enhanced use button with clipboard option
 const useIt = `=FOCUS_SET("text","${name}")`;
 const copyIt = `=FOCUS_SET("clipboard","${name}")`;
 Actions.setCell(inv.id, {x:0,y,z:0}, '?', useIt, true);
 }

 // Force complete re-render after all cells are written (batched)
 console.log(`INVENTORY: forcing render for array #${inv.id}`);
 inv._layersRendered = false;
 Scene.renderArray(inv);
 
 // Then position it
 const p = dockOffsetFor(host, port, 1.0);
 Scene.setArrayOffset(inv, p);
 
 // Focus the inventory so it's selectable
 Actions.setSelection(inv.id, {x:1, y:YT-1, z:0}, null, '3d');

 host._uiMounts = host._uiMounts || [];
 host._uiMounts.push({id:inv.id, name:'Inventory', port});

 // Silent registration: do not stamp anchor to avoid re-evaluation loops
 Actions.end();
});
tag('UI_UNMOUNT',['META'],(anchor,arr,ast)=>{
 const host = Store.getState().arrays[anchor.arrId];
 const key = String(Formula.valOf(ast.args[0] ?? '')).toLowerCase();
 if(!host?._uiMounts?.length){ 
 Actions.setCell(arr.id, anchor, 'UI:None', ast.raw, true); 
 return; 
 }
 const matches = (m)=> !key || (String(m.id)===key || String(m.name||'').toLowerCase().includes(key));
 const toHide = host._uiMounts.filter(matches);
 toHide.forEach(m=>{
 const a = Store.getState().arrays[m.id];
 if(a){ a.hidden = true; Scene.syncVisibility(a); }
 });
 host._uiMounts = host._uiMounts.filter(m=>!matches(m));
 Actions.setCell(arr.id, anchor, `UI:Unmounted ${toHide.length}`, ast.raw, true);
});
// 2D Platformer System
tag('SET_SELECTED',['ACTION'],(anchor,arr,ast)=>{
 const direction = String(Formula.valOf(ast.args[0]||'none')).toLowerCase();
 const s = Store.getState().selection;
 if(!s?.arrayId || !s.focus) throw new Error('No focus for movement');
 
 const currentArr = Store.getState().arrays[s.arrayId];
 if(!currentArr) throw new Error('Current array not found');
 
 // Calculate offset based on direction from joystick
 let dx=0, dy=0, dz=0;
 if(direction==='up') dy=1;
 else if(direction==='down') dy=-1;
 else if(direction==='left') dx=-1;
 else if(direction==='right') dx=1;
 else if(direction==='forward') dz=-1;
 else if(direction==='back') dz=1;
 
 // Get target screen array (look for array with 'screen' in name or use next array)
 const screenArr = Object.values(Store.getState().arrays).find(a => 
 a.name.toLowerCase().includes('screen') || a.params?.isScreen
 );
 
 if(screenArr){
 // Find current avatar position (cell with "Hero" or similar)
 let avatarPos = null;
 Object.values(screenArr.chunks).forEach(ch => {
 ch.cells.forEach(c => {
 if(c.value === 'Hero' || c.value === '??' || c.value === '@'){
 avatarPos = {x:c.x, y:c.y, z:c.z};
 }
 });
 });
 
 if(avatarPos){
 const newPos = {x:avatarPos.x+dx, y:avatarPos.y+dy, z:avatarPos.z+dz};
 // Check bounds
 if(newPos.x>=0 && newPos.x<screenArr.size.x && newPos.y>=0 && newPos.y<screenArr.size.y && newPos.z>=0 && newPos.z<screenArr.size.z){
 // Clear old position
 Actions.setCell(screenArr.id, avatarPos, '', null, true);
 // Set new position
 Actions.setCell(screenArr.id, newPos, 'Hero', null, true);
 // Focus the new position
 Actions.setSelection(screenArr.id, newPos, null, '3d');
 }
 }
 }
 
 Actions.setCell(arr.id, anchor, `Move:${direction}`, ast.raw, true);
});

// SET_SELECT(ref): force jump to selection
tag('SET_SELECT',['ACTION'],(anchor,arr,ast)=>{
 const t=ast.args[0];
 if(!t || t.kind!=='ref') throw new Error('SET_SELECT needs a ref');
 Actions.setSelection(t.arrId,{x:t.x,y:t.y,z:t.z},null,'3d');
 Actions.setCell(arr.id, anchor, `Select:${A1(t.x)}${t.y+1}${greek(t.z)}`, ast.raw, true);
});
tag('LIGHT',['SCENE'],(anchor,arr,ast)=>{
 const toBool = (v)=>{
 if(v == null) return false;
 if(typeof v === 'boolean') return v;
 if(typeof v === 'number') return v !== 0;
 const s = String(v).trim().toLowerCase();
 if(!s) return false;
 return !['0','false','off','no'].includes(s);
 };
 try{
 const stateVal = Formula.valOf(ast.args[0]);
 const enabled = toBool(stateVal);
 const targetRef = (ast.args[1] && ast.args[1].kind==='ref') ? ast.args[1] : null;
 const lumensRaw = ast.args[2] ? Formula.valOf(ast.args[2]) : null;
 let lumens = (lumensRaw==null || lumensRaw==='') ? 800 : parseFloat(lumensRaw);
 if(!Number.isFinite(lumens)) lumens = 800;
 lumens = Math.max(0, lumens);
 const source = { arrId:arr.id, x:anchor.x, y:anchor.y, z:anchor.z };
 if(!enabled || lumens<=0){
 try{ Scene.removeCellLight?.(source); }catch{}
 Actions.setCell(arr.id, anchor, 'LIGHT:OFF', ast.raw, true);
 return;
 }
 const cell = Formula.getCell({arrId:arr.id, x:anchor.x, y:anchor.y, z:anchor.z}) || {};
 const color = cell?.meta?.color || '#ffffff';
 try{
 Scene.upsertCellLight?.(source, {
 enabled:true,
 mode: targetRef ? 'spot' : 'point',
 targetRef,
 lumens,
 color
 });
 }catch(e){ console.warn('LIGHT() upsert failed', e); }
 Actions.setCell(arr.id, anchor, targetRef ? 'LIGHT:SPOT' : 'LIGHT:POINT', ast.raw, true);
 }catch(e){
 console.warn('LIGHT() failed', e);
 Actions.setCell(arr.id, anchor, `!ERR:${e.message||'LIGHT'}`, ast.raw, true);
 }
});
tag('CHIME',['AUDIO'],(anchor,arr,ast)=>{
 try{
 const noteVal = Formula.valOf(ast.args[0]);
 const parsed = ChimeSystem.parseNote(noteVal);
 if(!parsed){ Actions.setCell(arr.id, anchor, '!ERR:NOTE', ast.raw, true); return; }
 const octVal = ast.args[1] ? Formula.valOf(ast.args[1]) : null;
 const octave = ChimeSystem.toOctave(octVal);
 const durVal = ast.args[2] ? Number(Formula.valOf(ast.args[2])) : null;
 const duration = Number.isFinite(durVal) && durVal>0 ? durVal : 0.65;
 try{ ChimeSystem.play(parsed.offset, octave, duration); }catch(e){ console.warn('Chime playback error', e); }
 Actions.setCell(arr.id, anchor, `CHIME:${parsed.label}${octave}`, ast.raw, true);
 }catch(e){
 console.warn('CHIME() failed', e);
 Actions.setCell(arr.id, anchor, '!ERR:CHIME', ast.raw, true);
 }
});
tag('2D_PLATFORMER',['META'],(anchor,arr,ast)=>{
 console.log('2D_PLATFORMER: Starting execution...', anchor, arr.id);
 try {
 const port = String(Formula.valOf(ast.args[0] ?? 'east')).toLowerCase();
 const screenSize = {x:12, y:8, z:1}; // 2D screen dimensions
 
 const host = Store.getState().arrays[anchor.arrId];
 console.log(`2D_PLATFORMER: Host array #${host.id}`);
 
 // Create controller array (3x3 directional pad)
 const controller = Actions.createArray({name:'Controller', size:{x:3, y:3, z:1}, hidden:false});
 console.log(`2D_PLATFORMER: Created controller #${controller.id}`);

 // Stash init params on controller so chained init knows where to dock and host id
 controller.params = {
 ...(controller.params||{}),
 platformer: true,
 hostId: host.id,
 port,
 screenSize
 };
 
 // Set up controller layout with ON_SELECT hooks
 Actions.setCell(controller.id, {x:1,y:2,z:0}, '?', null, true);
 Actions.setCell(controller.id, {x:0,y:1,z:0}, '?', null, true);
 // Center joystick doubles as locked init cell that spawns the screen (once, idempotent)
 Actions.setCell(controller.id, {x:1,y:1,z:0}, '??', null, true);
 Actions.setCell(controller.id, {x:2,y:1,z:0}, '?', null, true);
 Actions.setCell(controller.id, {x:1,y:0,z:0}, '?', null, true);

 // Register ON_SELECT for each control cell
 Formula.executeAt({arrId:controller.id,x:1,y:2,z:0}, '=ON_SELECT("=SET_SELECTED(\"up\")")');
 Formula.executeAt({arrId:controller.id,x:0,y:1,z:0}, '=ON_SELECT("=SET_SELECTED(\"left\")")');
 Formula.executeAt({arrId:controller.id,x:2,y:1,z:0}, '=ON_SELECT("=SET_SELECTED(\"right\")")');
 Formula.executeAt({arrId:controller.id,x:1,y:0,z:0}, '=ON_SELECT("=SET_SELECTED(\"down\")")');
 Formula.executeAt({arrId:controller.id,x:1,y:1,z:0}, `=PLATFORMER_SPAWN_SCREEN()`);
 
 // Add some action buttons
 Actions.setCell(controller.id, {x:2,y:2,z:0}, 'A', '=FOCUS_SET("text","Action!")', true);
 Actions.setCell(controller.id, {x:0,y:0,z:0}, 'B', '=FOCUS_SET("text","Jump!")', true);

 // Lock the center cell so it can't be edited away
 controller.locks = controller.locks || new Set();
 controller.locks.add(`${controller.id}:1,1,0`);

 // Trigger chained init now so the screen is created immediately
 try { Formula.executeAt({arrId:controller.id, x:1, y:1, z:0}); } catch(e) { console.warn('Init cell eval failed', e); }

 // Force render controller only (screen will be spawned by the chained formula)
 controller._layersRendered = false;
 Scene.renderArray(controller);

 // Position controller relative to host
 const controllerPos = dockOffsetFor(host, port, 1.5);
 Scene.setArrayOffset(controller, controllerPos);

 // Remember mount
 host._uiMounts = host._uiMounts || [];
 host._uiMounts.push({id:controller.id, name:'Controller', port});

 // Focus the controller center by default
 Actions.setSelection(controller.id, {x:1,y:1,z:0}, null, '3d');

 Actions.setCell(arr.id, anchor, `2D Platformer: Controller #${controller.id}`, ast.raw, true);
 console.log('2D_PLATFORMER: Controller created and init cell armed.');
 } catch(e) {
 console.error('2D_PLATFORMER: Error during execution:', e);
 Actions.setCell(arr.id, anchor, `!ERR: ${e.message}`, ast.raw, true);
 }
});
// Add lowercase alias for easier typing
tag('2d_platformer',['META'],(anchor,arr,ast)=>{
 console.log('2d_platformer: Redirecting to 2D_PLATFORMER...');
 return Fn['2D_PLATFORMER'].impl(anchor,arr,ast);
});
// Chained initializer: runs inside the controller's locked cell to spawn the screen idempotently
tag('PLATFORMER_SPAWN_SCREEN',['META'],(anchor,arr,ast)=>{
 try{
 const ctrl = Store.getState().arrays[anchor.arrId];
 const p = ctrl?.params?.platformer ? ctrl.params : (ctrl.params||{});
 const hostId = p?.hostId ?? (Object.values(Store.getState().arrays).find(a=>a.id!==ctrl.id)?.id ?? arr.id);
 const port = (p?.port || 'east');
 const screenSize = p?.screenSize || {x:12,y:8,z:1};

 let screen = Object.values(Store.getState().arrays).find(a => a.params?.isScreen && a.params?.ownerCtrlId===ctrl.id);
 if(!screen){
 screen = Actions.createArray({name:'Game Screen', size:screenSize, hidden:false});
 screen.params = { ...(screen.params||{}), isScreen:true, ownerCtrlId:ctrl.id };
 const Y = screen.size.y-1;
 Actions.begin();
 for(let x=0;x<screen.size.x;x++) Actions.setCell(screen.id, {x, y:0, z:0}, '?', null, true);
 const hero = {x:Math.floor(screen.size.x/2), y:1, z:0};
 Actions.setCell(screen.id, hero, 'Hero', null, true);
 Actions.end();
 }

 const host = Store.getState().arrays[hostId] || arr;
 const offset = dockOffsetFor(host, port, 1.0);
 Scene.setArrayOffset(screen, offset);
 Actions.setSelection(screen.id, {x:Math.floor(screen.size.x/2), y:1, z:0}, null, '3d');
 Actions.setCell(arr.id, anchor, '??', ast.raw, true);
 }catch(e){
 Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true);
 }
});
// DEP_VIS(flag): toggle dependency curve visibility (simple straight lines for now)
tag('DEP_VIS',['SCENE'],(anchor,arr,ast)=>{
 const flag = !!Formula.valOf(ast.args[0]);
 try{
 // Toggle scene overlay
 const S = Store.getState();
 const sc = Scene.getScene?.();
 if(!sc){ Actions.setCell(arr.id, anchor, '!ERR:Scene', ast.raw, true); return; }
 // Store on global for quick access
 if(flag===true || flag===false){
 // Toggle global state so UI can reflect
 S.globalState.set('dep.vis', flag?1:0);
 }
 // Build dependency curves from current dependency graph
 const want = !!flag;
 let group = sc.children.find?.(c=>c.userData && c.userData.kind==='depGroup');
 if(!group){ group = new THREE.Group(); group.userData.kind='depGroup'; sc.add(group); }
 group.visible = want;
 // Rebuild contents every toggle or when enabling
 while(group.children.length){ const ch=group.children.pop(); ch.geometry?.dispose?.(); ch.material?.dispose?.(); }
 if(want){
 const deps = Store.getState().anchorsByDep;
 const arrays = Store.getState().arrays;
 const mat = new THREE.LineBasicMaterial({color:0x06b6d4, transparent:true, opacity:0.5});
 deps.forEach((dependents, depKey)=>{
 dependents.forEach(toKey=>{
 const [a1, r1] = depKey.split(':'); const [x1,y1,z1]=r1.split(',').map(Number);
 const [a2, r2] = toKey.split(':'); const [x2,y2,z2]=r2.split(',').map(Number);
 const arr1=arrays[+a1], arr2=arrays[+a2]; if(!arr1||!arr2) return;
 const p1 = Scene.worldPos(arr1,x1,y1,z1);
 const p2 = Scene.worldPos(arr2,x2,y2,z2);
 const geom = new THREE.BufferGeometry().setFromPoints([p1,p2]);
 const line = new THREE.Line(geom, mat);
 group.add(line);
 });
 });
 }
 Actions.setCell(arr.id, anchor, want? 'Deps:ON' : 'Deps:OFF', ast.raw, true);
 }catch(e){ Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true); }
});

// Global intro trigger function (must be defined before tag registration)
window.startIntroExperience = function(){
 console.log('startIntroExperience: global function called (delegating to UI)');
 try{ window.UI?.startIntroExperience?.(); }catch(e){
 console.warn('startIntroExperience: UI path failed, applying inline fallback', e);
 const io = document.getElementById('introOverlay');
 const sheet = document.getElementById('sheet');
 if(io){ io.classList.add('hidden'); }
 if(sheet){ sheet.classList.remove('intro-centered'); sheet.style.left='16px'; sheet.style.bottom='16px'; sheet.style.top=''; sheet.style.transform=''; }
 }
};

tag('STARTINTROEXPERIENCE',['ACTION'],(anchor,arr,ast)=>{ 
 console.log('STARTINTROEXPERIENCE formula called');
 try{
 // Hide overlay and trigger layout collapse first, then run any extra UI logic
 try{ window.UI?.hideIntroOverlay?.(); }catch{}
 try{ window.UI?.triggerIntroCollapse?.(); }catch{}
 window.UI?.startIntroExperience?.();
 }catch(e){ console.warn('STARTINTROEXPERIENCE failed', e); } 
});

/* ===========================
 Cellular Automata (Life)
=========================== */
const CA = (()=> {
 const alive=(v)=> v===1||v==='1'||v===true||v==='X'||v==='x'||v===' ';
 const runLife2D=(arr,{axis='Y',index=0,steps=1})=>{
 const {x:W,y:H,z:D}=arr.size;
 const get=(x,y,z)=>{const ch=arr.chunks[keyChunk(...Object.values(chunkOf(x,y,z)))]; const c=ch.cells.find(t=>t.x===x&&t.y===y&&t.z===z); return c?.value;};
 const set=(x,y,z,v)=>Actions.setCell(arr.id,{x,y,z},v,null,true);
 const clamp=(n,min,max)=> ((n-min)%(max-min+1)+max-min+1)%(max-min+1)+min;
 const stepPlane=(A,B,fix,read)=>{ const cur=[]; for(let b=0;b<B;b++){cur[b]=[]; for(let a=0;a<A;a++){const [x,y,z]=read(a,b,fix); cur[b][a]=alive(get(x,y,z))?1:0;}}
 const nxt=cur.map(r=>r.slice());
 for(let b=0;b<B;b++)for(let a=0;a<A;a++){let n=0; for(let db=-1;db<=1;db++)for(let da=-1;da<=1;da++) if(da||db){const aa=clamp(a+da,0,A-1), bb=clamp(b+db,0,B-1); n+=cur[bb][aa];} nxt[b][a]=(cur[b][a]?(n===2||n===3):(n===3))?1:0;}
 for(let b=0;b<B;b++)for(let a=0;a<A;a++){const [x,y,z]=read(a,b,fix); set(x,y,z,nxt[b][a]);}
 };
 for(let s=0;s<steps;s++){
 if(axis==='Y') stepPlane(W,D,index,(a,b,f)=>[a,f,b]);
 if(axis==='Z') stepPlane(W,H,index,(a,b,f)=>[a,b,f]);
 if(axis==='X') stepPlane(D,H,index,(a,b,f)=>[f,b,a]);
 }
 };
 return {runLife2D};
})();

/* ===========================
 Scene (Three.js + Rapier)
=========================== */
const Boot = {
 step(t){ const el=document.getElementById('statusChip'); if(el) el.textContent=t; },
 ok(){ this.step('Ready'); },
 crash(e){ const el=document.getElementById('crash'); if(!el) return; el.style.display='block'; el.textContent=`Initialization failed\n\n${(e&&e.stack)||e}`; this.step('Crashed'); },
 log:(...a)=>{ try{ console.debug('[Toybox]',...a);}catch{} }
};
const Scene = (()=>{
 let scene, camera, renderer, controls, grid, axesHelper;
 let baseLightsGroup = null;

 const OceanDefaults = Object.freeze({
 enabled:false,
 envIntensity:0.8,
 lightIntensity:0.55,
 exposure:1.25,
 showGrid:true,
 showSphere:true,
 showTowers:true,
 showFloaters:true,
 timeScale:0.2,
 gridDensity:64,
 choppiness:2.0,
 amplitude0:0.85,
 amplitude1:0.45,
 amplitude2:0.28,
 amplitude3:0.18,
 amplitude4:0.12,
 amplitude5:0.08,
 wavelength0:35.0,
 wavelength1:16.5,
 wavelength2:8.2,
 wavelength3:4.5,
 wavelength4:2.8,
 wavelength5:1.8,
 speed0:0.95,
 speed1:1.15,
 speed2:1.3,
 speed3:1.45,
 speed4:1.6,
 speed5:1.8,
 deepColor:'#0b345a',
 shallowColor:'#1e6aa2',
 foamColor:'#ffffff',
 foamAmount:2.5,
 foamBias:0.5,
 foamScale:1.5,
 maxGloss:0.91,
 roughnessScale:0.0044,
 horizonColor:'#cfeaff',
 horizonZStart:60.0,
 horizonZEnd:260.0,
 horizonBoost:1.10,
 microScale:0.035,
 microFreq:18.0,
 microWaveScale:0.3,
 enableBloom:true,
 bloomStrength:0.25,
 enableVignette:true,
 vignetteStrength:0.85,
 grainAmount:0.015,
 enableRays:true,
 rayStrength:1.8,
 rayDecay:0.965,
 rayExposure:1.15,
 enableLighthouse:true,
 lighthouseStrength:0.8,
 focusDistance:21.0,
 dofStrength:0.95,
 focusRange:10.0,
 fogStart:50.0,
 fogEnd:200.0,
 fogColor:'#5aaee3',
 gridOpacity:0.35,
 sunElevation:22,
 sunAzimuth:25,
 skyTopColor:'#8ec1ea',
 skyMidColor:'#63aee3',
 skyBotColor:'#092c4d'
 });

 const OceanBackdrop = (()=>{
 const dirs = [
 new THREE.Vector2(1.0, 0.2).normalize(),
 new THREE.Vector2(-0.6, 0.8).normalize(),
 new THREE.Vector2(0.2, -1.0).normalize(),
 new THREE.Vector2(0.8, 0.4).normalize(),
 new THREE.Vector2(-1.0, -0.2).normalize(),
 new THREE.Vector2(0.4, 0.9).normalize()
 ];
 const waveParams={
 A:[0.85,0.45,0.28,0.18,0.12,0.08],
 L:[35.0,16.5,8.2,4.5,2.8,1.8],
 S:[0.95,1.15,1.3,1.45,1.6,1.8]
 };
 // Temporary vectors for calculations
 const tmpVec3 = new THREE.Vector3();
 const tmpVec2 = new THREE.Vector2();
 const state={
 settings:{...OceanDefaults},
 group:null,
 sky:null,
 skyUniforms:null,
 water:null,
 waterUniforms:null,
 grid:null,
 gridAttr:null,
 gridConfig:null,
 ball:null,
 structures:[],
 floaters:[],
 voxelStructures:[],
 lighthousePositions:[],
 beamSequence:null,
 baseHeight:-6,
 time:0,
 presentActive:false
 };

 const L_OCCLUSION=1;
 const towerParams={ count:16, minRadius:120, maxRadius:600, azimuthSpread:0.6 };
 const MAX_LIGHTHOUSE_BEACONS=4;

 function ensureGroup(){
 if(state.group) return;
 state.group=new THREE.Group();
 state.group.name='OceanBackdrop';
 state.group.visible=false;
 createSky();
 createWater();
 createGrid();
 createBuoy();
 createStructures();
 createOceanLights();
 if(scene) scene.add(state.group);
 }
 
 function createOceanLights(){
 // Dedicated lighting for ocean scene (matches data-lake.html)
 const lights = new THREE.Group();
 lights.name = 'OceanLights';
 
 // Ambient light for base illumination
 const ambient = new THREE.AmbientLight(0xbfdfff, 0.25);
 lights.add(ambient);
 
 // Main directional light (key light)
 const dir = new THREE.DirectionalLight(0xffffff, 0.55);
 dir.position.set(-3, 7, -4);
 dir.castShadow = false;
 lights.add(dir);
 
 state.oceanLights = { ambient, directional: dir };
 state.group.add(lights);
 }

 function createSky(){
 const geo = new THREE.SphereGeometry(1200, 32, 16);
 const uniforms = {
 top:{value:new THREE.Color(0x8ec1ea)},
 mid:{value:new THREE.Color(0x63aee3)},
 bot:{value:new THREE.Color(0x092c4d)}
 };
 const mat = new THREE.ShaderMaterial({
 side:THREE.BackSide,
 uniforms,
 vertexShader:`varying vec3 v; void main(){ v=position; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.); }`,
 fragmentShader:`varying vec3 v; uniform vec3 top,mid,bot; void main(){ float h=normalize(v).y*.5+.5; vec3 c=mix(bot,mid,smoothstep(0.,.45,h)); c=mix(c,top,smoothstep(.45,1.,h)); gl_FragColor=vec4(c,1.); }`
 });
 const sky = new THREE.Mesh(geo, mat);
 sky.name='OceanSky';
 state.sky = sky;
 state.skyUniforms = uniforms;
 state.group.add(sky);
 }

 function createWater(){
 const SIZE = 120;
 const SEG = 256;
 const STEP = SIZE / SEG;
 const HALF = SIZE / 2;
 state.gridConfig = { SIZE, SEG, STEP, HALF };
 const geo = new THREE.PlaneGeometry(SIZE, SIZE, SEG, SEG);
 geo.rotateX(-Math.PI/2);
 const uniforms = {
 uTime:{value:0},
 sunDir:{value:new THREE.Vector3(0.5,0.6,0.3).normalize()},
 deep:{value:new THREE.Color(0x0b345a)},
 shallow:{value:new THREE.Color(0x1e6aa2)},
 foamColor:{value:new THREE.Color(0xffffff)},
 Q:{value:state.settings.choppiness},
 foamAmt:{value:state.settings.foamAmount},
 foamBias:{value:state.settings.foamBias},
 foamScale:{value:state.settings.foamScale},
 maxGloss:{value:state.settings.maxGloss},
 roughnessScale:{value:state.settings.roughnessScale},
 microScale:{value:state.settings.microScale},
 microFreq:{value:state.settings.microFreq},
 microWaveScale:{value:state.settings.microWaveScale},
 nearFade:{value:20.0},
 farFade:{value:200.0},
 horizonCol:{value:new THREE.Color(0xcfeaff)},
 horizonZStart:{value:60.0},
 horizonZEnd:{value:260.0},
 horizonBoost:{value:state.settings.horizonBoost},
 A0:{value:waveParams.A[0]}, A1:{value:waveParams.A[1]}, A2:{value:waveParams.A[2]},
 A3:{value:waveParams.A[3]}, A4:{value:waveParams.A[4]}, A5:{value:waveParams.A[5]},
 L0:{value:waveParams.L[0]}, L1:{value:waveParams.L[1]}, L2:{value:waveParams.L[2]},
 L3:{value:waveParams.L[3]}, L4:{value:waveParams.L[4]}, L5:{value:waveParams.L[5]},
 S0:{value:waveParams.S[0]}, S1:{value:waveParams.S[1]}, S2:{value:waveParams.S[2]},
 S3:{value:waveParams.S[3]}, S4:{value:waveParams.S[4]}, S5:{value:waveParams.S[5]}
 };
 const mat = new THREE.ShaderMaterial({
 transparent:true,
 uniforms,
 vertexShader:`
 uniform float uTime; uniform float Q;
 uniform float A0,A1,A2,A3,A4,A5, L0,L1,L2,L3,L4,L5, S0,S1,S2,S3,S4,S5;
 uniform float microScale, microFreq, microWaveScale;
 varying vec3 vN; varying vec3 vP; varying float vSlope; varying float vHeight;
 varying float vViewZ; varying float vBreak;
 const int N=6; vec2 D[N];
 void setup(){ D[0]=normalize(vec2( 1.0, 0.2)); D[1]=normalize(vec2(-0.6, 0.8)); D[2]=normalize(vec2( 0.2,-1.0));
 D[3]=normalize(vec2( 0.8, 0.4)); D[4]=normalize(vec2(-1.0,-0.2)); D[5]=normalize(vec2( 0.4, 0.9)); }
 float A[N]; float L[N]; float S[N];
 void params(){ A[0]=A0;A[1]=A1;A[2]=A2;A[3]=A3;A[4]=A4;A[5]=A5;
 L[0]=L0;L[1]=L1;L[2]=L2;L[3]=L3;L[4]=L4;L[5]=L5;
 S[0]=S0;S[1]=S1;S[2]=S2;S[3]=S3;S[4]=S4;S[5]=S5; }
 void main(){
 setup(); params();
 vec3 p = position, disp=vec3(0.);
 vec3 grad = vec3(0.);
 float jac=0.0;
 for(int i=0;i<N;i++){
 float k=6.28318/L[i], w=sqrt(9.8*k), a=k*dot(D[i], p.xz) - (w*S[i])*uTime;
 float s=sin(a), c=cos(a);
 disp.x += Q*A[i]*D[i].x*c;
 disp.z += Q*A[i]*D[i].y*c;
 disp.y += A[i]*s;
 grad.x += -A[i]*D[i].x*k*c;
 grad.z += -A[i]*D[i].y*k*c;
 jac += k*A[i]*c;
 }
 p += disp;
 float scaledFreq = microFreq * microWaveScale;
 float micro1 = sin(p.x * scaledFreq + uTime * 3.2) * cos(p.z * scaledFreq * 0.8 + uTime * 2.8);
 float micro2 = sin(p.x * scaledFreq * 2.3 + p.z * scaledFreq * 1.7 + uTime * 4.5) *
 cos(p.z * scaledFreq * 2.1 + p.x * scaledFreq * 0.9 + uTime * 3.8);
 float microDisp = (micro1 + micro2 * 0.6) * microScale;
 p.y += microDisp;
 float eps = 0.05;
 vec3 pRight = p + vec3(eps, 0.0, 0.0);
 vec3 pFront = p + vec3(0.0, 0.0, eps);
 float microRight1 = sin(pRight.x * scaledFreq + uTime * 3.2) * cos(pRight.z * scaledFreq * 0.8 + uTime * 2.8);
 float microRight2 = sin(pRight.x * scaledFreq * 2.3 + pRight.z * scaledFreq * 1.7 + uTime * 4.5) *
 cos(pRight.z * scaledFreq * 2.1 + pRight.x * scaledFreq * 0.9 + uTime * 3.8);
 pRight.y += (microRight1 + microRight2 * 0.6) * microScale;
 float microFront1 = sin(pFront.x * scaledFreq + uTime * 3.2) * cos(pFront.z * scaledFreq * 0.8 + uTime * 2.8);
 float microFront2 = sin(pFront.x * scaledFreq * 2.3 + pFront.z * scaledFreq * 1.7 + uTime * 4.5) *
 cos(pFront.z * scaledFreq * 2.1 + pFront.x * scaledFreq * 0.9 + uTime * 3.8);
 pFront.y += (microFront1 + microFront2 * 0.6) * microScale;
 vec3 tangentX = pRight - p;
 vec3 tangentZ = pFront - p;
 vec3 microNormal = normalize(cross(tangentZ, tangentX));
 vec3 mainNormal = normalize(vec3(-grad.x, 1.0, -grad.z));
 vN = normalize(mainNormal * 0.7 + microNormal * 0.3);
 vSlope = length(grad);
 vHeight = disp.y + microDisp;
 vec4 vp = modelViewMatrix * vec4(p,1.0);
 vViewZ = -vp.z;
 vP = (modelMatrix*vec4(p,1.0)).xyz;
 vBreak = jac;
 gl_Position = projectionMatrix * vp;
 }`,
 fragmentShader:`
 uniform vec3 deep, shallow, foamColor, sunDir;
 uniform float foamAmt, foamBias, foamScale, nearFade, farFade, uTime;
 uniform float maxGloss, roughnessScale;
 uniform vec3 horizonCol; uniform float horizonZStart, horizonZEnd, horizonBoost;
 varying vec3 vN; varying vec3 vP; varying float vSlope; varying float vHeight;
 varying float vViewZ; varying float vBreak;
 float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }
 float noise(vec2 p){
 vec2 i = floor(p);
 vec2 f = fract(p);
 f = f * f * (3.0 - 2.0 * f);
 float a = hash(i);
 float b = hash(i + vec2(1.0, 0.0));
 float c = hash(i + vec2(0.0, 1.0));
 float d = hash(i + vec2(1.0, 1.0));
 return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
 }
 void main(){
 vec3 N = normalize(vN);
 vec3 V = normalize(cameraPosition - vP);
 float fres = pow(1.0 - max(dot(V, N), 0.0), 4.0);
 vec3 base = mix(deep, shallow, smoothstep(-0.6, 0.95, vHeight));
 vec3 col = base*(0.72+0.28*fres);
 float distanceFade = smoothstep(horizonZStart, horizonZEnd, vViewZ);
 float viewAngle = abs(dot(normalize(V), N));
 float grazingMask = smoothstep(0.35, 0.01, viewAngle);
 float distBoost = pow(distanceFade, 0.6);
 float horizonMix = distBoost * grazingMask * horizonBoost * 1.5;
 col = mix(col, horizonCol * 1.3, clamp(horizonMix, 0.0, 0.95));
 float jacobian = vBreak;
 float turbulence = clamp((jacobian - foamBias) * foamScale, 0.0, 1.0);
 vec2 foamUV = vP.xz * 0.5 + uTime * 0.15;
 float foamTex = noise(foamUV * 4.0) * 0.5 + noise(foamUV * 8.0) * 0.3 + noise(foamUV * 16.0) * 0.2;
 foamTex = smoothstep(0.4, 0.7, foamTex);
 float foam = foamTex * turbulence * foamAmt;
 col = mix(col, foamColor, clamp(foam, 0.0, 1.0));
 float viewDist = length(cameraPosition - vP);
 float distanceGloss = mix(0.09, maxGloss, 1.0 / (1.0 + viewDist * roughnessScale));
 float roughness = 1.0 - mix(distanceGloss, 0.0, clamp(turbulence * 0.8, 0.0, 1.0));
 vec3 L = normalize(sunDir);
 vec3 H = normalize(L + V);
 float NdotH = max(dot(N, H), 0.0);
 float specPower = mix(16.0, 512.0, distanceGloss);
 float spec = pow(NdotH, specPower) * (1.0 - roughness) * distanceGloss;
 col += vec3(spec * 2.5);
 float depthAlpha = 0.95 - smoothstep(nearFade, farFade, vViewZ) * 0.45;
 gl_FragColor = vec4(col, depthAlpha);
 }`
 });
 mat.depthWrite = false;
 const water = new THREE.Mesh(geo, mat);
 water.position.y = state.baseHeight;
 water.renderOrder = -10;
 water.name='OceanWater';
 state.water = water;
 state.waterUniforms = uniforms;
 state.group.add(water);
 }

 function createGrid(){
 const baseConfig = state.gridConfig || {};
 const GRID_SEG = state.settings.gridDensity ?? 64;
 const SIZE = baseConfig.SIZE ?? 120;
 const STEP = SIZE / GRID_SEG;
 const HALF = SIZE / 2;
 state.gridConfig = { ...baseConfig, GRID_SEG, GRID_STEP:STEP, HALF };
 const lineCount = ((GRID_SEG+1)*GRID_SEG + (GRID_SEG+1)*GRID_SEG);
 const positions = new Float32Array(lineCount * 2 * 3);
 let ptr = 0;
 for(let z=0; z<=GRID_SEG; z++) for(let x=0; x<GRID_SEG; x++){
 const ax = -HALF + x*STEP, az = -HALF + z*STEP, bx = ax + STEP, bz = az;
 positions[ptr++] = ax; positions[ptr++] = state.baseHeight; positions[ptr++] = az;
 positions[ptr++] = bx; positions[ptr++] = state.baseHeight; positions[ptr++] = bz;
 }
 for(let x=0; x<=GRID_SEG; x++) for(let z=0; z<GRID_SEG; z++){
 const ax = -HALF + x*STEP, az = -HALF + z*STEP, bx = ax, bz = az + STEP;
 positions[ptr++] = ax; positions[ptr++] = state.baseHeight; positions[ptr++] = az;
 positions[ptr++] = bx; positions[ptr++] = state.baseHeight; positions[ptr++] = bz;
 }
 const geo = new THREE.BufferGeometry();
 geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
 const mat = new THREE.LineBasicMaterial({
 color:0xbfe7ff,
 transparent:true,
 opacity:0.35,
 depthWrite:false,
 depthTest:true
 });
 const grid = new THREE.LineSegments(geo, mat);
 grid.renderOrder = 999;
 grid.name='OceanGrid';
 state.grid = grid;
 state.gridAttr = geo.getAttribute('position');
 state.group.add(grid);
 }

 function createBuoy(){
 const ball = new THREE.Mesh(
 new THREE.SphereGeometry(0.5, 24, 16),
 new THREE.MeshStandardMaterial({ color:0xffffff, emissive:0x88aaff, emissiveIntensity:1.05, roughness:0.25 })
 );
 ball.position.set(0, state.baseHeight + 0.7, -2.5);
 ball.userData.base = { x:0, z:-2.5, height:0.55 };
 ball.name='OceanBuoy';
 state.ball = ball;
 state.group.add(ball);
 }

 function createStructures(){
 state.voxelStructures.length = 0;
 state.lighthousePositions.length = 0;
 const voxel = new THREE.BoxGeometry(4.5, 4.5, 4.5);
 const towerGroup = new THREE.Group();
 towerGroup.name='OceanTowers';
 state.group.add(towerGroup);
 const towers = [];
 for(let c=0; c<towerParams.count; c++){
 const instances = 450;
 const mat = new THREE.MeshStandardMaterial({
 color:0x4a7a9f,
 metalness:0.15,
 roughness:0.85,
 emissive:0x000000
 });
 const mesh = new THREE.InstancedMesh(voxel, mat, instances);
 mesh.name=`OceanTowerCluster${c}`;
 mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
 const radius = THREE.MathUtils.randFloat(towerParams.minRadius, towerParams.maxRadius);
 const baseAng = (c / towerParams.count) * Math.PI * 2;
 const jitter = THREE.MathUtils.randFloat(-towerParams.azimuthSpread, towerParams.azimuthSpread);
 const ang = baseAng + jitter;
 const baseY = THREE.MathUtils.randFloat(-10, 30) + state.baseHeight;
 const base = new THREE.Vector3(Math.sin(ang)*radius, baseY, Math.cos(ang)*radius);
 const tilt = new THREE.Euler(
 THREE.MathUtils.degToRad(THREE.MathUtils.randFloat(3,12)),
 THREE.MathUtils.degToRad(THREE.MathUtils.randFloat(0,360)),
 THREE.MathUtils.degToRad(THREE.MathUtils.randFloat(-8,8))
 );
 let i = 0;
 const W = THREE.MathUtils.randInt(12,20);
 const H = THREE.MathUtils.randInt(30,60);
 const D = THREE.MathUtils.randInt(12,20);
 for(let x=0; x<W; x++) for(let y=0; y<H; y++) for(let z=0; z<D; z++){
 if(i>=instances) break;
 if(Math.random() < 0.80) continue;
 const matrix = new THREE.Matrix4();
 const scale = THREE.MathUtils.randFloat(0.9, 1.3);
 const pos = new THREE.Vector3((x-W*0.5)*5.5, (y-H*0.5)*5.5, (z-D*0.5)*5.5);
 pos.applyEuler(tilt);
 pos.add(base);
 matrix.compose(pos, new THREE.Quaternion(), new THREE.Vector3(scale, scale, scale));
 mesh.setMatrixAt(i++, matrix);
 }
 mesh.count = Math.min(i, instances);
 mesh.layers.enable(L_OCCLUSION);
 towerGroup.add(mesh);
 towers.push(mesh);
 state.voxelStructures.push(mesh);
 if(state.lighthousePositions.length < MAX_LIGHTHOUSE_BEACONS && Math.random() < 0.5){
 const topY = baseY + (H * 2.75);
 state.lighthousePositions.push(new THREE.Vector3(base.x, topY, base.z));
 }
 }
 state.structures = towers;

 const floatGroup = new THREE.Group();
 floatGroup.name='OceanFloaters';
 state.group.add(floatGroup);
 const floatGeom = new THREE.BoxGeometry(3, 3, 3);
 const floaters = [];
 for(let i=0; i<60; i++){
 const glow = THREE.MathUtils.randFloat(2.5, 4.5);
 const mat = new THREE.MeshStandardMaterial({
 color:new THREE.Color(0.8,0.95,1.0),
 emissive:new THREE.Color(0.7,0.85,1.0),
 emissiveIntensity:glow,
 metalness:0.1,
 roughness:0.15,
 toneMapped:false
 });
 const mesh = new THREE.Mesh(floatGeom, mat);
 const radius = THREE.MathUtils.randFloat(80, 600);
 const ang = Math.random() * Math.PI * 2;
 const height = THREE.MathUtils.randFloat(15, 120) + state.baseHeight;
 mesh.position.set(Math.sin(ang)*radius, height, Math.cos(ang)*radius);
 mesh.rotation.set(Math.random()*Math.PI*2, Math.random()*Math.PI*2, Math.random()*Math.PI*2);
 mesh.userData.baseY = height;
 const intensity = THREE.MathUtils.randFloat(15, 30);
 const light = new THREE.PointLight(new THREE.Color(0.6,0.85,1.0), intensity, 50);
 light.userData.baseIntensity = intensity;
 light.position.copy(mesh.position);
 light.castShadow = false;
 floatGroup.add(mesh);
 floatGroup.add(light);
 const record = { mesh, light, floatSpeed:THREE.MathUtils.randFloat(0.3,0.7), floatOffset:Math.random()*Math.PI*2 };
 floaters.push(record);
 state.voxelStructures.push(record);
 }
 state.floaters = floaters;
 }

 // Ocean Post-Processing Pipeline (matches data-lake.html exactly)
 function initPostProcessing(){
 if(state.post) return;
 const w = window.innerWidth;
 const h = window.innerHeight;
 const rtScene = new THREE.WebGLRenderTarget(w, h, { 
 depthTexture: new THREE.DepthTexture(), 
 depthBuffer: true,
 stencilBuffer: false,
 samples: 4 // MSAA antialiasing
 });
 const rtHalfA = new THREE.WebGLRenderTarget(Math.max(1, w/2), Math.max(1, h/2));
 const rtHalfB = new THREE.WebGLRenderTarget(Math.max(1, w/2), Math.max(1, h/2));
 const rtOcc = new THREE.WebGLRenderTarget(Math.max(1, w/2), Math.max(1, h/2));
 const rtOccBlur = new THREE.WebGLRenderTarget(Math.max(1, w/2), Math.max(1, h/2));
 const rtLighthouse = new THREE.WebGLRenderTarget(Math.max(1, w/2), Math.max(1, h/2));
 const fsQuad = new THREE.PlaneGeometry(2, 2);
 
 // Blur shader for bloom
 const blurFrag = `
 varying vec2 vUv; uniform sampler2D t; uniform vec2 res;
 void main(){
 vec2 px = 1.0/res; float w[5];
 w[0]=0.204164; w[1]=0.304005; w[2]=0.193783; w[3]=0.072184; w[4]=0.017864;
 vec3 c = texture2D(t, vUv).rgb * w[0];
 for(int i=1;i<5;i++){
 c += texture2D(t, vUv + vec2(float(i)*px.x,0.)).rgb*w[i];
 c += texture2D(t, vUv - vec2(float(i)*px.x,0.)).rgb*w[i];
 }
 gl_FragColor = vec4(c,1.0);
 }`;
 const blurH = new THREE.ShaderMaterial({
 uniforms: { t:{value:null}, res:{value:new THREE.Vector2(w,h)} },
 vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=vec4(position,1.); }`,
 fragmentShader: blurFrag,
 depthTest: false, depthWrite: false
 });
 const blurV = new THREE.ShaderMaterial({
 uniforms: { t:{value:null}, res:{value:new THREE.Vector2(w,h)} },
 vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=vec4(position,1.); }`,
 fragmentShader: blurFrag.replace('vec2(float(i)*px.x,0.)','vec2(0.,float(i)*px.y)'),
 depthTest: false, depthWrite: false
 });
 
 // God rays shader
 const raysMat = new THREE.ShaderMaterial({
 uniforms: {
 t:{value:null}, 
 res:{value:new THREE.Vector2(w/2,h/2)},
 sunPos:{value:new THREE.Vector2(0.5,0.2)},
 rayDecay:{value:state.settings.rayDecay},
 rayExposure:{value:state.settings.rayExposure}
 },
 vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=vec4(position,1.); }`,
 fragmentShader: `
 varying vec2 vUv; uniform sampler2D t; uniform vec2 res;
 uniform vec2 sunPos; uniform float rayDecay; uniform float rayExposure;
 float sampleOcclusion(vec2 uv) {
 vec2 px = 1.0 / res;
 float c = texture2D(t, uv).r;
 c += texture2D(t, uv + vec2(px.x, 0.0)).r * 0.5;
 c += texture2D(t, uv - vec2(px.x, 0.0)).r * 0.5;
 c += texture2D(t, uv + vec2(0.0, px.y)).r * 0.5;
 c += texture2D(t, uv - vec2(0.0, px.y)).r * 0.5;
 return c / 3.0;
 }
 void main(){
 vec2 delta = sunPos - vUv;
 float dist = length(delta);
 vec2 stepv = delta / 96.0;
 vec2 uv = vUv;
 float illum = 0.0;
 float decay = 1.0;
 for(int i=0;i<96;i++){
 uv += stepv;
 float light = sampleOcclusion(uv);
 illum += light * decay;
 decay *= rayDecay;
 }
 float col = illum * rayExposure / (1.0 + dist*1.5);
 gl_FragColor = vec4(vec3(col), 1.0);
 }`,
 depthTest: false, depthWrite: false
 });
 
 // Lighthouse beams shader
 const lighthouseMat = new THREE.ShaderMaterial({
 uniforms: {
 lighthousePos:{value:[new THREE.Vector3(),new THREE.Vector3(),new THREE.Vector3(),new THREE.Vector3()]},
 lighthouseCount:{value:0},
 beamSize:{value:0.08}
 },
 vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=vec4(position,1.); }`,
 fragmentShader: `
 varying vec2 vUv;
 uniform vec3 lighthousePos[4];
 uniform int lighthouseCount;
 uniform float beamSize;
 void main(){
 float brightness = 0.0;
 for(int i=0; i<4; i++){
 if(i >= lighthouseCount) break;
 vec2 pos = lighthousePos[i].xy;
 float dist = length(vUv - pos);
 brightness += smoothstep(beamSize, beamSize * 0.3, dist);
 }
 gl_FragColor = vec4(vec3(brightness), 1.0);
 }`,
 depthTest: false, depthWrite: false
 });
 
 // Composite shader (DOF + fog + bloom + vignette + grain + rays + lighthouse)
 const compMat = new THREE.ShaderMaterial({
 uniforms: {
 t:{value:null}, t2:{value:null}, t3:{value:null}, t4:{value:null},
 depthTex:{value:null},
 res:{value:new THREE.Vector2(w,h)},
 strength:{value:state.settings.bloomStrength},
 time:{value:0},
 vig:{value:state.settings.vignetteStrength},
 grain:{value:state.settings.grainAmount},
 enableBloom:{value:state.settings.enableBloom ? 1 : 0},
 enableVig:{value:state.settings.enableVignette ? 1 : 0},
 focusDist:{value:state.settings.focusDistance},
 dofStrength:{value:state.settings.dofStrength},
 focusRange:{value:state.settings.focusRange},
 camNear:{value:0.1},
 camFar:{value:5000},
 fogStart:{value:state.settings.fogStart},
 fogEnd:{value:state.settings.fogEnd},
 fogCol:{value:new THREE.Color(state.settings.fogColor)},
 enableRays:{value:state.settings.enableRays ? 1 : 0},
 rayStrength:{value:state.settings.rayStrength},
 rayColor:{value:new THREE.Color(0xcde9ff)},
 enableLighthouse:{value:state.settings.enableLighthouse ? 1 : 0},
 lighthouseStrength:{value:state.settings.lighthouseStrength},
 lighthouseColor:{value:new THREE.Color(0xffd89a)}
 },
 vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=vec4(position,1.); }`,
 fragmentShader: `
 varying vec2 vUv;
 uniform sampler2D t; uniform sampler2D t2; uniform sampler2D t3; uniform sampler2D t4;
 uniform sampler2D depthTex; uniform vec2 res;
 uniform float strength, time, vig, grain; uniform int enableBloom, enableVig;
 uniform float focusDist, dofStrength, focusRange, camNear, camFar, fogStart, fogEnd;
 uniform vec3 fogCol;
 uniform int enableRays; uniform float rayStrength; uniform vec3 rayColor;
 uniform int enableLighthouse; uniform float lighthouseStrength; uniform vec3 lighthouseColor;
 
 float linearizeDepth(float z){
 float ndc = z*2.0 - 1.0;
 return (2.0*camNear*camFar) / (camFar + camNear - ndc*(camFar - camNear));
 }
 
 float rnd(vec2 p){
 return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453);
 }
 
 vec3 dofBlur(sampler2D tex, float radius){
 vec2 px = 1.0/res;
 vec3 c = texture2D(tex, vUv).rgb * 0.28;
 c += texture2D(tex, vUv + px*vec2( radius, 0.0)).rgb * 0.12;
 c += texture2D(tex, vUv + px*vec2(-radius, 0.0)).rgb * 0.12;
 c += texture2D(tex, vUv + px*vec2(0.0, radius)).rgb * 0.12;
 c += texture2D(tex, vUv + px*vec2(0.0, -radius)).rgb * 0.12;
 c += texture2D(tex, vUv + px*vec2( radius, radius)).rgb * 0.09;
 c += texture2D(tex, vUv + px*vec2(-radius, radius)).rgb * 0.09;
 c += texture2D(tex, vUv + px*vec2( radius, -radius)).rgb * 0.09;
 c += texture2D(tex, vUv + px*vec2(-radius, -radius)).rgb * 0.09;
 return c;
 }
 
 void main(){
 float z = texture2D(depthTex, vUv).r;
 float depth = linearizeDepth(z);
 
 // DOF - only apply to far objects (ocean), keep near objects (arrays) sharp
 // Near threshold: objects closer than 40 units are always sharp
 float nearThreshold = 40.0;
 float dofMask = smoothstep(nearThreshold, nearThreshold + 20.0, depth);
 float coc = smoothstep(0.0, focusRange, abs(depth - focusDist)) * dofMask;
 float rad = coc * dofStrength * 6.0;
 vec3 base = dofBlur(t, rad);
 
 // Layered atmospheric fog
 float ff1 = smoothstep(fogStart, fogEnd * 0.5, depth);
 float ff2 = smoothstep(fogEnd * 0.5, fogEnd, depth);
 float ff3 = smoothstep(fogEnd, fogEnd * 1.8, depth);
 vec3 fogLayer1 = fogCol * 0.45;
 vec3 fogLayer2 = fogCol * 0.75;
 vec3 fogLayer3 = fogCol * 0.95;
 base = mix(base, fogLayer1, ff1 * 0.4);
 base = mix(base, fogLayer2, ff2 * 0.5);
 base = mix(base, fogLayer3, ff3 * 0.7);
 
 // Bloom
 vec3 bloom = texture2D(t2, vUv).rgb * strength;
 if(enableBloom==1) base += bloom;
 
 // God rays
 if(enableRays==1){
 float r = texture2D(t3, vUv).r;
 base += rayColor * r * rayStrength;
 }
 
 // Lighthouse beams
 if(enableLighthouse==1){
 float lh = texture2D(t4, vUv).r;
 base += lighthouseColor * lh * lighthouseStrength;
 }
 
 // Vignette
 vec2 uv = vUv*2.0-1.0;
 float v = smoothstep(1.4, 0.2/vig, dot(uv,uv));
 if(enableVig==1) base *= v;
 
 // Film grain
 float g = (rnd(vUv*res + time)-0.5) * (grain*2.0);
 base += g;
 
 gl_FragColor = vec4(base, 1.0);
 }`,
 depthTest: false, depthWrite: false
 });
 
 const screenScene = new THREE.Scene();
 const screenCam = new THREE.OrthographicCamera(-1,1,1,-1,0,1);
 const screenMesh = new THREE.Mesh(fsQuad, compMat);
 screenScene.add(screenMesh);
 
 state.post = {
 rtScene, rtHalfA, rtHalfB, rtOcc, rtOccBlur, rtLighthouse,
 blurH, blurV, raysMat, lighthouseMat, compMat,
 screenScene, screenCam, fsQuad
 };
 }
 
 function resizePostTargets(w, h){
 if(!state.post) return;
 state.post.rtScene.setSize(w, h);
 state.post.rtScene.depthTexture = new THREE.DepthTexture();
 state.post.rtHalfA.setSize(Math.max(1, w/2), Math.max(1, h/2));
 state.post.rtHalfB.setSize(Math.max(1, w/2), Math.max(1, h/2));
 state.post.rtOcc.setSize(Math.max(1, w/2), Math.max(1, h/2));
 state.post.rtOccBlur.setSize(Math.max(1, w/2), Math.max(1, h/2));
 state.post.rtLighthouse.setSize(Math.max(1, w/2), Math.max(1, h/2));
 [state.post.blurH, state.post.blurV, state.post.compMat].forEach(m=>{
 if(m.uniforms.res) m.uniforms.res.value.set(w, h);
 });
 if(state.post.raysMat.uniforms.res){
 state.post.raysMat.uniforms.res.value.set(Math.max(1,w/2), Math.max(1,h/2));
 }
 }
 
 function syncPostSettings(){
 if(!state.post) return;
 const c = state.post.compMat.uniforms;
 const mainCam = Scene?.getCamera?.();
 if(mainCam){
 c.camNear.value = mainCam.near;
 c.camFar.value = mainCam.far;
 }
 c.enableBloom.value = state.settings.enableBloom ? 1 : 0;
 c.enableVig.value = state.settings.enableVignette ? 1 : 0;
 c.strength.value = state.settings.bloomStrength;
 c.vig.value = state.settings.vignetteStrength;
 c.grain.value = state.settings.grainAmount;
 c.focusDist.value = state.settings.focusDistance;
 c.dofStrength.value = state.settings.dofStrength;
 c.focusRange.value = state.settings.focusRange;
 c.fogStart.value = state.settings.fogStart;
 c.fogEnd.value = state.settings.fogEnd;
 c.fogCol.value.set(state.settings.fogColor);
 c.enableRays.value = state.settings.enableRays ? 1 : 0;
 c.rayStrength.value = state.settings.rayStrength;
 c.enableLighthouse.value = state.settings.enableLighthouse ? 1 : 0;
 c.lighthouseStrength.value = state.settings.lighthouseStrength;
 state.post.raysMat.uniforms.rayDecay.value = state.settings.rayDecay;
 state.post.raysMat.uniforms.rayExposure.value = state.settings.rayExposure;
 }
 
 function renderOceanWithPost(time){
 if(!state.presentActive || !state.post) return false;
 const mainRenderer = renderer;
 const mainCamera = camera;
 const mainScene = scene;
 if(!mainRenderer || !mainCamera || !mainScene) return false;
 
 try{
 const post = state.post;
 
 // Render FULL SCENE (ocean + arrays together) with ocean post-processing
 // Ocean is positioned far back, so proper depth testing ensures arrays show in front
 
 // Render entire scene to texture with depth
 mainRenderer.setRenderTarget(post.rtScene);
 mainRenderer.setClearColor(0x000000, 1);
 mainRenderer.clear();
 mainRenderer.render(mainScene, mainCamera);
 
 // Bloom (horizontal blur)
 post.blurH.uniforms.t.value = post.rtScene.texture;
 post.blurH.uniforms.res.value.set(post.rtHalfA.width, post.rtHalfA.height);
 mainRenderer.setRenderTarget(post.rtHalfA);
 mainRenderer.render(new THREE.Scene().add(new THREE.Mesh(post.fsQuad, post.blurH)), post.screenCam);
 
 // Bloom (horizontal blur again)
 post.blurH.uniforms.t.value = post.rtHalfA.texture;
 mainRenderer.setRenderTarget(post.rtHalfB);
 mainRenderer.render(new THREE.Scene().add(new THREE.Mesh(post.fsQuad, post.blurH)), post.screenCam);
 
 // Bloom (vertical blur)
 post.blurV.uniforms.t.value = post.rtHalfB.texture;
 post.blurV.uniforms.res.value.set(post.rtHalfA.width, post.rtHalfA.height);
 mainRenderer.setRenderTarget(post.rtHalfA);
 mainRenderer.render(new THREE.Scene().add(new THREE.Mesh(post.fsQuad, post.blurV)), post.screenCam);
 
 // God rays occlusion pass
 const sunWorld = tmpVec3.copy(state.waterUniforms.sunDir.value).multiplyScalar(1000);
 const proj = sunWorld.project(mainCamera);
 const sunUV = tmpVec2.set(proj.x*0.5+0.5, proj.y*0.5+0.5);
 
 mainRenderer.setRenderTarget(post.rtOcc);
 mainRenderer.setClearColor(0x000000, 1);
 mainRenderer.clear();
 
 if(proj.z < 1.0){
 // Draw sun disk
 const sunDiskMat = new THREE.ShaderMaterial({
 uniforms: { sunPos:{value:sunUV.clone()}, sunSize:{value:0.15} },
 vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=vec4(position,1.); }`,
 fragmentShader: `
 varying vec2 vUv; uniform vec2 sunPos; uniform float sunSize;
 void main(){
 float dist = length(vUv - sunPos);
 float circle = smoothstep(sunSize, sunSize * 0.5, dist);
 gl_FragColor = vec4(vec3(circle), 1.0);
 }`,
 depthTest: false, depthWrite: false
 });
 mainRenderer.render(new THREE.Scene().add(new THREE.Mesh(post.fsQuad, sunDiskMat)), post.screenCam);
 
 // Render ocean towers as occluders (black)
 const oldMaterials = [];
 const testLayer = new THREE.Layers();
 testLayer.set(L_OCCLUSION);
 state.group.traverse(obj=>{
 if((obj.isMesh || obj.isInstancedMesh) && obj.layers.test(testLayer)){
 oldMaterials.push({obj, mat:obj.material});
 obj.material = new THREE.MeshBasicMaterial({color:0x000000});
 }
 });
 mainRenderer.render(mainScene, mainCamera);
 oldMaterials.forEach(({obj,mat})=> obj.material = mat);
 }
 
 // Blur occlusion map
 post.blurH.uniforms.t.value = post.rtOcc.texture;
 post.blurH.uniforms.res.value.set(post.rtOcc.width, post.rtOcc.height);
 mainRenderer.setRenderTarget(post.rtOccBlur);
 mainRenderer.render(new THREE.Scene().add(new THREE.Mesh(post.fsQuad, post.blurH)), post.screenCam);
 
 post.blurV.uniforms.t.value = post.rtOccBlur.texture;
 post.blurV.uniforms.res.value.set(post.rtOcc.width, post.rtOcc.height);
 mainRenderer.setRenderTarget(post.rtOcc);
 mainRenderer.render(new THREE.Scene().add(new THREE.Mesh(post.fsQuad, post.blurV)), post.screenCam);
 
 // Generate god rays
 post.raysMat.uniforms.t.value = post.rtOcc.texture;
 post.raysMat.uniforms.sunPos.value.copy(sunUV);
 mainRenderer.setRenderTarget(post.rtHalfB);
 mainRenderer.render(new THREE.Scene().add(new THREE.Mesh(post.fsQuad, post.raysMat)), post.screenCam);
 
 // Generate lighthouse beams
 const seq = state.beamSequence && state.beamSequence.active ? state.beamSequence : null;
 const sourceList = seq && seq.overrides ? seq.overrides : state.lighthousePositions;
 const beamCount = Math.min(sourceList ? sourceList.length : 0, 4);
 post.lighthouseMat.uniforms.lighthouseCount.value = beamCount;
 for(let i=0; i<beamCount; i++){
 const worldPos = (seq && seq.overrides && seq.overrides[i]) ? seq.overrides[i] : state.lighthousePositions[i];
 if(!worldPos){
  post.lighthouseMat.uniforms.lighthousePos.value[i].set(0.5, 0.5, 0);
  continue;
 }
 const proj = worldPos.clone().project(mainCamera);
 post.lighthouseMat.uniforms.lighthousePos.value[i].set(proj.x*0.5+0.5, proj.y*0.5+0.5, proj.z);
 }
 mainRenderer.setRenderTarget(post.rtLighthouse);
 mainRenderer.render(new THREE.Scene().add(new THREE.Mesh(post.fsQuad, post.lighthouseMat)), post.screenCam);
 
 // Final composite to screen
 post.compMat.uniforms.t.value = post.rtScene.texture;
 post.compMat.uniforms.t2.value = post.rtHalfA.texture;
 post.compMat.uniforms.t3.value = post.rtHalfB.texture;
 post.compMat.uniforms.t4.value = post.rtLighthouse.texture;
 post.compMat.uniforms.depthTex.value = post.rtScene.depthTexture;
 post.compMat.uniforms.time.value = time * 60.0;
 
 mainRenderer.setRenderTarget(null);
 mainRenderer.render(post.screenScene, post.screenCam);
 
 return true;
 }catch(e){
 console.warn('[OCEAN] Post-processing error:', e);
 return false;
 }
 }

 function getWaveParams(){
 return waveParams;
 }

 function sampleChoppy(x,z,t,Q){
 const params = getWaveParams();
 let dx=0,dz=0,y=0;
 for(let i=0;i<dirs.length;i++){
 const k = 2*Math.PI/params.L[i];
 const w = Math.sqrt(9.8*k);
 const a = k*(dirs[i].x*x+dirs[i].y*z) - (w*params.S[i])*t;
 const s = Math.sin(a), c = Math.cos(a);
 dx += Q*params.A[i]*dirs[i].x*c;
 dz += Q*params.A[i]*dirs[i].y*c;
 y += params.A[i]*s;
 }
 return {x:x+dx, y:y, z:z+dz};
 }

 function sampleMicroRipples(x,z,t){
 const microScale = state.settings.microScale;
 const microFreq = state.settings.microFreq;
 const microWaveScale = state.settings.microWaveScale;
 const scaledFreq = microFreq * microWaveScale;
 const micro1 = Math.sin(x * scaledFreq + t * 3.2) * Math.cos(z * scaledFreq * 0.8 + t * 2.8);
 const micro2 = Math.sin(x * scaledFreq * 2.3 + z * scaledFreq * 1.7 + t * 4.5) *
 Math.cos(z * scaledFreq * 2.1 + x * scaledFreq * 0.9 + t * 3.8);
 return (micro1 + micro2 * 0.6) * microScale;
 }

 function updateFloaters(dt){
 const active = state.settings.showFloaters && state.presentActive;
 state.floaters.forEach(item=>{
 const vis = active;
 if(item.mesh) item.mesh.visible = vis;
 if(item.light) item.light.visible = vis;
 if(!vis) return;
 const bob = Math.sin(state.time * item.floatSpeed + item.floatOffset) * 2.5;
 const baseY = item.mesh?.userData?.baseY ?? item.baseY ?? state.baseHeight;
 const y = baseY + bob;
 if(item.mesh){
 item.mesh.position.y = y;
 item.mesh.rotation.y += 0.003 * item.floatSpeed;
 item.mesh.rotation.x += 0.002 * item.floatSpeed;
 }
 if(item.light){
 item.light.position.y = y;
 const pulse = 0.85 + Math.sin(state.time * 2.0 + item.floatOffset) * 0.15;
 const baseIntensity = item.light.userData?.baseIntensity ?? item.baseIntensity ?? item.light.intensity;
 item.light.intensity = baseIntensity * pulse;
 }
 });
 }

 function updateGrid(){
 if(!state.gridAttr || !state.presentActive || !state.settings.showGrid) return;
 const pos = state.gridAttr.array;
 const cfg = state.gridConfig || {};
 const SEG = cfg.GRID_SEG ?? cfg.SEG ?? 0;
 const STEP = cfg.GRID_STEP ?? ((cfg.SIZE && SEG) ? (cfg.SIZE/SEG) : 1);
 const HALF = cfg.HALF ?? ((cfg.SIZE||600)/2);
 let p = 0;
 const Q = state.settings.choppiness;
 for(let z=0; z<=SEG; z++) for(let x=0; x<SEG; x++){
 const ax=-HALF + x*STEP, az=-HALF + z*STEP, bx=ax+STEP, bz=az;
 const A=sampleChoppy(ax,az,state.time,Q);
 const B=sampleChoppy(bx,bz,state.time,Q);
 const microA = sampleMicroRipples(A.x, A.z, state.time);
 const microB = sampleMicroRipples(B.x, B.z, state.time);
 pos[p++]=A.x; pos[p++]=state.baseHeight + A.y + microA + 0.01; pos[p++]=A.z;
 pos[p++]=B.x; pos[p++]=state.baseHeight + B.y + microB + 0.01; pos[p++]=B.z;
 }
 for(let x=0; x<=SEG; x++) for(let z=0; z<SEG; z++){
 const ax=-HALF + x*STEP, az=-HALF + z*STEP, bx=ax, bz=az+STEP;
 const A=sampleChoppy(ax,az,state.time,Q);
 const B=sampleChoppy(bx,bz,state.time,Q);
 const microA = sampleMicroRipples(A.x, A.z, state.time);
 const microB = sampleMicroRipples(B.x, B.z, state.time);
 pos[p++]=A.x; pos[p++]=state.baseHeight + A.y + microA + 0.01; pos[p++]=A.z;
 pos[p++]=B.x; pos[p++]=state.baseHeight + B.y + microB + 0.01; pos[p++]=B.z;
 }
 state.gridAttr.needsUpdate = true;
 if(state.grid) state.grid.visible = state.presentActive && state.settings.showGrid;
 }

 function updateBuoy(){
 if(!state.ball || !state.presentActive) return;
 const base = state.ball.userData.base || {x:state.ball.position.x, z:state.ball.position.z, height:0.55};
 const Q = state.settings.choppiness;
 const sample = sampleChoppy(base.x, base.z, state.time, Q);
 const micro = sampleMicroRipples(sample.x, sample.z, state.time);
 state.ball.position.set(sample.x, state.baseHeight + sample.y + micro + base.height, sample.z);
 }

 function updateSunDir(){
 if(!state.waterUniforms) return;
 let dir=null;
 try{
 if(FancyGraphics?.lights?.key){
 dir=FancyGraphics.lights.key.position.clone().normalize();
 }else if(baseLightsGroup){
 const light=baseLightsGroup.children?.find?.(c=>c.isDirectionalLight);
 if(light){
 dir=light.position.clone().normalize();
 }
 }
 }catch{}
 if(!dir){ dir=new THREE.Vector3(0.5,0.6,0.3).normalize(); }
 state.waterUniforms.sunDir.value.copy(dir);
 }

 function applySettings(){
 if(state.waterUniforms){
 state.waterUniforms.Q.value = state.settings.choppiness;
 state.waterUniforms.foamAmt.value = state.settings.foamAmount;
 state.waterUniforms.foamBias.value = state.settings.foamBias;
 state.waterUniforms.foamScale.value = state.settings.foamScale;
 state.waterUniforms.microScale.value = state.settings.microScale;
 state.waterUniforms.microFreq.value = state.settings.microFreq;
 state.waterUniforms.microWaveScale.value = state.settings.microWaveScale;
 state.waterUniforms.horizonBoost.value = state.settings.horizonBoost;
 state.waterUniforms.maxGloss.value = state.settings.maxGloss;
 state.waterUniforms.roughnessScale.value = state.settings.roughnessScale;
 }
 if(state.grid) state.grid.visible = state.presentActive && state.settings.showGrid;
 state.structures.forEach(mesh=>{ if(mesh) mesh.visible = state.presentActive && state.settings.showTowers; });
 state.floaters.forEach(item=>{
 const vis = state.presentActive && state.settings.showFloaters;
 if(item.mesh) item.mesh.visible = vis;
 if(item.light) item.light.visible = vis;
 });
 }


 function startSpotlightSweep(targetProvider, options={}){
 ensureGroup();
 const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() * 0.001 : Date.now() / 1000;
 const focusDelay = Math.max(0, options.focusDelay ?? 10);
 const lockDuration = Math.max(0.5, options.lockDuration ?? 2.5);
 const count = Math.min(state.lighthousePositions.length || 0, MAX_LIGHTHOUSE_BEACONS);
 const beams = [];
 for(let i=0; i<count; i++){
  const origin = state.lighthousePositions[i] ? state.lighthousePositions[i].clone() : new THREE.Vector3();
  beams.push({
   origin,
   radius: THREE.MathUtils.randFloat(60, 140),
   height: THREE.MathUtils.randFloat(12, 32),
   speed: THREE.MathUtils.randFloat(0.25, 0.55) + i * 0.05,
   phase: Math.random() * Math.PI * 2,
   verticalSpeed: THREE.MathUtils.randFloat(0.2, 0.5),
   verticalAmp: THREE.MathUtils.randFloat(3, 12),
   lastPos: origin.clone()
  });
 }
 state.beamSequence = {
  active: true,
  start: now,
  focusDelay,
  lockDuration,
  beams,
  overrides: new Array(count).fill(null),
  targetProvider: typeof targetProvider === 'function' ? targetProvider : null,
  lockOffsets: beams.map((_, idx)=> new THREE.Vector3((idx - (count-1)/2) * 5, 12 + idx * 3, (idx % 2 === 0 ? -4 : 4))),
  focusStart: null,
  locked: false
 };
 needsRender = true;
 return state.beamSequence;
}

function updateSpotlightSequence(){
 const seq = state.beamSequence;
 if(!seq || !seq.active) return;
 const count = seq.beams?.length || 0;
 if(count === 0){
  seq.overrides = [];
  return;
 }
 const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() * 0.001 : Date.now() / 1000;
 if(seq.locked){
  if(seq.targetProvider){
   const target = seq.targetProvider();
   if(target){
    seq.overrides = seq.overrides || new Array(count);
    for(let i=0; i<count; i++){
     const offset = seq.lockOffsets?.[i] || new THREE.Vector3();
     seq.overrides[i] = target.clone().add(offset);
    }
   }
  }
  needsRender = true;
  return;
 }
 const elapsed = now - seq.start;
 seq.overrides = seq.overrides || new Array(count);
 if(elapsed >= seq.focusDelay){
  if(!seq.focusStart){
   seq.focusStart = now;
   seq.startOverrides = seq.overrides.map(o=> o ? o.clone() : null);
  }
  const t = seq.lockDuration > 0 ? Math.min(1, (now - seq.focusStart) / seq.lockDuration) : 1;
  const target = seq.targetProvider ? seq.targetProvider() : null;
  for(let i=0; i<count; i++){
   const beam = seq.beams[i];
   const startPos = seq.startOverrides?.[i] || beam.lastPos || beam.origin.clone();
   const offset = seq.lockOffsets?.[i] || new THREE.Vector3();
   const endPos = target ? target.clone().add(offset) : beam.origin.clone();
   const pos = startPos.clone().lerp(endPos, t);
   seq.overrides[i] = pos;
   beam.lastPos = pos;
  }
  if(t >= 1){
   seq.locked = true;
  }
 } else {
  for(let i=0; i<count; i++){
   const beam = seq.beams[i];
   const ang = beam.phase + elapsed * beam.speed;
   const vert = Math.sin(elapsed * beam.verticalSpeed + beam.phase) * beam.verticalAmp;
   const pos = beam.origin.clone();
   pos.x += Math.cos(ang) * beam.radius;
   pos.z += Math.sin(ang) * beam.radius;
   pos.y += beam.height + vert;
   seq.overrides[i] = pos;
   beam.lastPos = pos;
  }
 }
 needsRender = true;
}

function update(dt){
 if(!state.group) return;
 if(!state.settings.enabled) {
 state.presentActive=false;
 state.group.visible=false;
 state.beamSequence = null;
 return;
 }
 const active=updateVisibility();
 if(!active) return;
 const delta=Number.isFinite(dt) ? dt : 0.016;
 const speed=Math.max(0, state.settings.timeScale||0);
 state.time += delta * (speed || 0);
 if(state.waterUniforms){ state.waterUniforms.uTime.value = state.time; }
 updateSunDir();
 updateBuoy();
 updateGrid();
 updateFloaters(delta);
 updateSpotlightSequence();
 }

 function updateVisibility(){
 if(!state.group) return false;
 state.presentActive = !!(state.settings.enabled && FancyGraphics?.enabled);
 state.group.visible = state.presentActive;
 if(!state.presentActive) return false;
 // Initialize post-processing on first activation
 if(state.presentActive && !state.post){
 initPostProcessing();
 }
 // Add atmospheric fog when ocean is active
 if(scene && state.presentActive && !scene.fog){
 scene.fog = new THREE.FogExp2(0x5aaee3, 0.0008);
 } else if(scene && !state.presentActive && scene.fog){
 scene.fog = null;
 }
 applySettings();
 syncPostSettings();
 return true;
 }

 function setEnabled(flag){
 state.settings.enabled = !!flag;
 updateVisibility();
 return state.settings.enabled;
 }

 function updateSettings(patch){
 if(!patch) return;
 Object.entries(patch).forEach(([key, val])=>{
 if(!(key in state.settings)) return;
 const current = state.settings[key];
 if(typeof current === 'number'){
 const num = Number(val);
 if(Number.isFinite(num)) state.settings[key] = num;
 }else if(typeof current === 'boolean'){
 state.settings[key] = !!val;
 }else{
 state.settings[key] = String(val);
 }
 });
 applySettings();
 }

 function getSettings(){
 return { ...state.settings, active: state.presentActive };
 }

 function recreateGrid(){
 try{
 // Remove old grid
 if(state.grid){
 state.group.remove(state.grid);
 state.grid.geometry?.dispose?.();
 state.grid.material?.dispose?.();
 state.grid = null;
 state.gridAttr = null;
 }
 // Rebuild with new density
 createGrid();
 console.log('[OCEAN] Grid recreated with density:', state.settings.gridDensity);
 }catch(e){
 console.warn('[OCEAN] recreateGrid failed:', e);
 }
 }

 return {
 init:ensureGroup,
 update,
 setEnabled,
 updateSettings,
 getSettings,
 applySettings,
 refreshVisibility:updateVisibility,
 renderWithPost:renderOceanWithPost,
 resizePost:resizePostTargets,
 startSpotlightSweep,
 recreateGrid
 };
 })();
let rapierWorld=null, controller=null, playerBody=null, playerCollider=null, staticPhysicsBody=null;
let physicsActivationPending = false;
let physicsInputCaptured = false;

function syncPhysicsInputCapture(reason){
 try{
 const active = physicsActivationPending || !!Store.getState().scene.physics;
 if(active !== physicsInputCaptured){
 physicsInputCaptured = active;
 console.log(`[PHYSICS] Input capture ${active ? 'ENABLED' : 'RELEASED'}${reason ? ` (${reason})` : ''}`);
 }
 return physicsInputCaptured;
 }catch(e){
 physicsInputCaptured = physicsActivationPending;
 return physicsInputCaptured;
 }
}

function setPhysicsActivationPending(next, reason){
 physicsActivationPending = !!next;
 syncPhysicsInputCapture(reason);
}

function updatePhysicsStatusChip(text){
 try{
 const chip = document.getElementById('physChip');
 if(chip) chip.textContent = text;
 }catch{}
}

async function ensureRapierWorld(){
 if(rapierWorld && RAPIER){
 return { success:true };
 }

 try{
 const mod = await loadRapier();
 if(!mod){
 return { success:false, reason:'unavailable' };
 }

 if(typeof RAPIER.init === 'function'){
 if(!rapierInitPromise){
 rapierInitPromise = RAPIER.init().catch(err=>{
 rapierInitPromise = null;
 throw err;
 });
 }
 await rapierInitPromise;
 }

 rapierWorld = new RAPIER.World({x:0,y:-20,z:0});
 try{
 staticPhysicsBody = rapierWorld.createRigidBody(RAPIER.RigidBodyDesc.fixed());
 }catch(e){
 console.warn('[PHYSICS] Failed creating static world body', e);
 staticPhysicsBody = null;
 }
 playerBody = null;
 playerCollider = null;
 cachedPlayerPos.set(0, 0, 0);
 updatePhysicsStatusChip('Physics: OFF');
 return { success:true };
 }catch(error){
 console.warn('[PHYSICS] Failed to initialize Rapier world', error);
 rapierWorld = null;
 staticPhysicsBody = null;
 playerBody = null;
 playerCollider = null;
 rapierInitPromise = null;
 return { success:false, reason:'error', error };
 }
}
 const chunkMeshes=new Map(); // legacy chunk meshes (still used for some visuals)
 const layerMeshes=new Map(); // `${arr.id}:${z}` -> {mesh, capacity, used, index2cell}
 const connections = new Map(); // aKey(anchor) -> { line, start, end, ... }
 const isZiplineConnection = (con)=>{
 if(!con) return false;
 if(con.mode === 'zipline') return true;
 if((!con.dimensionExplicit) && (!con.mode || con.mode === 'line')) return true;
 return false;
 };
 let depGroup=null, depVis=false; // dependency graph overlay
let ziplineState = { active: false, line: null, direction: new THREE.Vector3(), progress: 0, velocity: 0, length: 1, accel: 0.002, start: new THREE.Vector3(), end: new THREE.Vector3() };
let spottedState = null;
let physicsCameraConfig = { mode:'free', distance:10, allowRotation:false };
 let wasGroundedLastFrame = false;
 let cachedPlayerPos = new THREE.Vector3(0, 0, 0); // Cache to avoid Rapier aliasing issues - initialize with valid coords
 let lastTouchKey = null;
 let lastLandKey = null;
 let landingCellKey = null;
let landingCellAnim = null;
let surfaceBounceState = { key:null, depression:0, intensity:1 };
let skipWalkBounceUntil = 0;
const BOUNCE_GAG_THRESHOLD = 9;
const bounceGagState = {
 active: false,
 phase: null,
 startTime: 0,
 durationMs: 0,
 holdMs: 0,
 triggeredHeight: 0,
 originalControls: null,
 originalPosition: new THREE.Vector3(),
 originalTarget: new THREE.Vector3(),
 followOffset: new THREE.Vector3(),
 cameraLift: 0,
 recoverFromPosition: new THREE.Vector3(),
 recoverFromTarget: new THREE.Vector3()
};

function finishBounceGag(){
 bounceGagState.active = false;
 bounceGagState.phase = null;
 const restore = bounceGagState.originalControls;
 if(controls && restore){
  controls.enabled = restore.enabled;
  controls.enableRotate = restore.enableRotate;
  controls.enablePan = restore.enablePan;
  try{ controls.update(); }catch{}
 }
 bounceGagState.originalControls = null;
 needsRender = true;
}

function startBounceGag(height){
 if(bounceGagState.active) return;
 if(!camera) return;
 const physicsActive = !!Store.getState().scene?.physics;
 if(!physicsActive) return;
 const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
 const playerPos = new THREE.Vector3(cachedPlayerPos.x, cachedPlayerPos.y, cachedPlayerPos.z);

 bounceGagState.active = true;
 bounceGagState.phase = 'launch';
 bounceGagState.startTime = now;
 const baseDuration = 3200;
 const extraDuration = Math.min(2600, Math.max(0, height - 6) * 220);
 bounceGagState.durationMs = baseDuration + extraDuration;
 bounceGagState.holdMs = 700;
 bounceGagState.triggeredHeight = height;
 bounceGagState.cameraLift = Math.min(40, 10 + height * 1.4);

 bounceGagState.originalPosition.copy(camera.position);
 if(controls){
  bounceGagState.originalTarget.copy(controls.target);
  bounceGagState.originalControls = {
   enabled: controls.enabled,
   enableRotate: controls.enableRotate,
   enablePan: controls.enablePan
  };
  controls.enabled = false;
  controls.enableRotate = false;
  controls.enablePan = false;
 } else {
  bounceGagState.originalTarget.copy(playerPos);
  bounceGagState.originalControls = null;
 }

 const horizontal = camera.position.clone().sub(playerPos);
 horizontal.y = 0;
 if(horizontal.lengthSq() < 1e-4){
  horizontal.set(0, 0, 1);
 }
 horizontal.normalize().multiplyScalar(6);
 bounceGagState.followOffset.copy(horizontal);

 console.log(`[BOUNCE] High-energy bounce triggered (h=${height.toFixed(2)})`);
 needsRender = true;
}

function updateBounceGag(deltaSeconds){
 if(!bounceGagState.active) return;
 if(!camera){
  finishBounceGag();
  return;
 }
 const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
 const playerPos = new THREE.Vector3(cachedPlayerPos.x, cachedPlayerPos.y, cachedPlayerPos.z);

 if(bounceGagState.phase === 'launch'){
  const elapsed = now - bounceGagState.startTime;
  const clamped = Math.min(elapsed, bounceGagState.durationMs);
  const progress = bounceGagState.durationMs > 0 ? clamped / bounceGagState.durationMs : 1;
  const smooth = 1 - Math.pow(1 - progress, 3);

  const horizontal = bounceGagState.followOffset.clone().multiplyScalar(THREE.MathUtils.lerp(1, 0.35, smooth));
  const desiredPos = playerPos.clone().add(horizontal);
  desiredPos.y += THREE.MathUtils.lerp(2.4, bounceGagState.cameraLift, smooth);

  const desiredTarget = playerPos.clone();
  desiredTarget.y += THREE.MathUtils.lerp(1.2, bounceGagState.cameraLift * 0.85, smooth);

  camera.position.lerp(desiredPos, 0.18);
  if(controls){
   controls.target.lerp(desiredTarget, 0.18);
   try{ controls.update(); }catch{}
  } else {
   camera.lookAt(desiredTarget);
  }

  needsRender = true;

  if(elapsed >= bounceGagState.durationMs + bounceGagState.holdMs){
   bounceGagState.phase = 'recover';
   bounceGagState.startTime = now;
   bounceGagState.recoverFromPosition.copy(camera.position);
   const currentTarget = controls ? controls.target.clone() : desiredTarget;
   bounceGagState.recoverFromTarget.copy(currentTarget);
   bounceGagState.durationMs = 1200;
  }
  return;
 }

 if(bounceGagState.phase === 'recover'){
  const elapsed = now - bounceGagState.startTime;
  const clamped = Math.min(elapsed, bounceGagState.durationMs);
  const progress = bounceGagState.durationMs > 0 ? clamped / bounceGagState.durationMs : 1;
  const smooth = 1 - Math.pow(1 - progress, 3);

  const desiredPos = bounceGagState.recoverFromPosition.clone().lerp(bounceGagState.originalPosition, smooth);
  const desiredTarget = bounceGagState.recoverFromTarget.clone().lerp(bounceGagState.originalTarget, smooth);

  camera.position.copy(desiredPos);
  if(controls){
   controls.target.copy(desiredTarget);
   try{ controls.update(); }catch{}
  } else {
   camera.lookAt(desiredTarget);
  }

  needsRender = true;

  if(progress >= 1){
   finishBounceGag();
  }
 }
}

 function resetContactCache(){
 lastTouchKey = null;
 lastLandKey = null;
 wasGroundedLastFrame = false;
 cancelLandingCellAnimation();
 surfaceBounceState = { key:null, depression:0, intensity:1 };
 skipWalkBounceUntil = 0;
 }

 const FancyDefaults = {
 hdri: true,
 lights: true,
 lightRotation: 0,
 lightStrength: 1,
 darkBg: false,
 bloomEnabled: true,
 bloomStrength: 0.15,
 bloomRadius: 0.10,
 exposure: 0.5,
 dofEnabled: true,
 dofAperture: 0.002,
 dofMaxBlur: 0.001,
 transmission: true,
 mirror: true,
 solidGround: false,
 waveGrid: true,
 fogEnabled: false,
 fogDensity: 0.012,
 outlineEnabled: true,
 outlineStrength: 2.4,
 outlineThickness: 0.9,
 motionEnabled: false,
 motionDamping: 0.94,
 fxaa: true
 };

 const FancyGraphics = {
 enabled: false,
 settings: { ...FancyDefaults },
 composer: null,
 passes: {},
 groups: { lights: null, mirror: null, waveGrid: null, ground: null },
 lightDefaults: { key: 3.2, fill: 1.4, rim: 2.6, hemi: 0.6 },
 lights: { key: null, fill: null, rim: null, hemi: null },
 shadowLights: [],
 decor: null,
 hdriTexture: null,
 hdriPromise: null,
 base: {
 gridVisible: true,
 background: null,
 environment: null,
 fog: null,
 toneMapping: null,
 exposure: 1,
 shadowMap: false,
 shadowAutoUpdate: true,
 physicallyCorrectLights: false,
 clearColor: null,
 clearAlpha: 1
 },
 clock: null,
 mirrorUniforms: null
 };

 const billboardObjects = new Set();
 let debugPhysicsSnapshot = null;

 function clonePhysicsConfig(cfg){
 if(cfg == null || typeof cfg !== 'object') return cfg;
 if(Array.isArray(cfg)) return cfg.map(item=> clonePhysicsConfig(item));
 const out = {};
 Object.keys(cfg).forEach(key=>{
 const val = cfg[key];
 if(val && typeof val === 'object'){
 out[key] = clonePhysicsConfig(val);
 } else {
 out[key] = val;
 }
 });
 return out;
 }
 const REFLECTION_FLIP_AXIS = 'y';

 function markBillboard(obj){
 if(!obj) return obj;
 try{
 obj.userData = obj.userData || {};
 obj.userData.billboard = true;
 }catch{}
 billboardObjects.add(obj);
 return obj;
 }

 function unmarkBillboard(obj){
 if(!obj) return;
 billboardObjects.delete(obj);
 if(obj.userData){
 delete obj.userData.__mirrorFlipped;
 delete obj.userData.__mirrorOrigScale;
 }
 }

 function applyMirrorBillboardFlip(active){
 const axis = REFLECTION_FLIP_AXIS;
 billboardObjects.forEach(obj=>{
 if(!obj || !obj.userData || !obj.userData.billboard){
 billboardObjects.delete(obj);
 return;
 }
 if(!obj.parent){
 billboardObjects.delete(obj);
 return;
 }
 if(active){
 if(obj.userData.__mirrorFlipped) return;
 if(obj.userData.__mirrorOrigScale){
 obj.userData.__mirrorOrigScale.copy(obj.scale);
 } else {
 obj.userData.__mirrorOrigScale = obj.scale.clone();
 }
 const s = obj.scale;
 if(axis === 'x'){
 s.x = (s.x === 0 ? 0 : -s.x);
 } else if(axis === 'y'){
 s.y = (s.y === 0 ? 0 : -s.y);
 } else {
 s.z = (s.z === 0 ? 0 : -s.z);
 }
 obj.userData.__mirrorFlipped = true;
 } else {
 if(!obj.userData.__mirrorFlipped) return;
 if(obj.userData.__mirrorOrigScale){
 obj.scale.copy(obj.userData.__mirrorOrigScale);
 } else {
 const s = obj.scale;
 if(axis === 'x'){
 s.x = (s.x === 0 ? 0 : -s.x);
 } else if(axis === 'y'){
 s.y = (s.y === 0 ? 0 : -s.y);
 } else {
 s.z = (s.z === 0 ? 0 : -s.z);
 }
 }
 obj.userData.__mirrorFlipped = false;
 }
 });
 }

 const PRESENT_LIGHT_BG = new THREE.Color(0xf6f7fb);
 const PRESENT_DARK_BG = new THREE.Color(0x0f172a);

 function capturePlatformerGlobals(){
 try{
 const g = Store.getState().globalState;
 if(!g) return {};
 if(typeof g.get !== 'function') return {};
 return {
 active: g.get('platformer.active'),
 input: g.get('platformer.input'),
 jump: g.get('platformer.jump')
 };
 }catch{ return {}; }
 }
 function ensurePlatformerActiveState(active){
 try{
 const g = Store.getState().globalState;
 if(!g || typeof g.set !== 'function') return;
 g.set('platformer.active', !!active);
 if(typeof g.set === 'function'){
 g.set('platformer.input', 'none');
 g.set('platformer.jump', 0);
 }
 }catch(e){ console.warn('Platformer state update failed', e); }
 }
 function restorePlatformerGlobals(snapshot){
 try{
 const g = Store.getState().globalState;
 if(!g || typeof g.set !== 'function') return;
 if(snapshot && Object.prototype.hasOwnProperty.call(snapshot, 'active')){
 g.set('platformer.active', snapshot.active);
 } else if(typeof g.delete === 'function'){
 g.delete('platformer.active');
 }
 if(snapshot && Object.prototype.hasOwnProperty.call(snapshot, 'input')){
 g.set('platformer.input', snapshot.input);
 } else if(typeof g.delete === 'function'){
 g.delete('platformer.input');
 } else {
 g.set('platformer.input', 'none');
 }
 if(snapshot && Object.prototype.hasOwnProperty.call(snapshot, 'jump')){
 g.set('platformer.jump', snapshot.jump);
 } else if(typeof g.delete === 'function'){
 g.delete('platformer.jump');
 } else {
 g.set('platformer.jump', 0);
 }
 }catch(e){ console.warn('Platformer state restore failed', e); }
 }

 function applyDebugPhysicsOverrides(enable){
 if(enable){
 const arraysToRebuild = [];
 if(!debugPhysicsSnapshot){
 const snapshot = {
 avatar: clonePhysicsConfig(Store.getState().avatarPhysics) || null,
 arrays: new Map(),
 collisionModes: new Map(),
 global: capturePlatformerGlobals()
 };
 Store.setState(state=>{
 const arrays = { ...state.arrays };
 Object.entries(arrays).forEach(([id, arr])=>{
 if(!arr) return;
 const nextParams = { ...(arr.params || {}) };
 const prevPhysics = clonePhysicsConfig(nextParams.physics);
 snapshot.arrays.set(id, prevPhysics ?? null);
 if(!snapshot.collisionModes.has(id)){
 snapshot.collisionModes.set(id, arr.collisionMode === 'physics' ? 'physics' : 'edit');
 }
 const debugPhysics = { ...(nextParams.physics || {}), enabled:true, __debugOverride:true };
 const sources = { ...(debugPhysics.__sources || {}) };
 sources.enabled = Number.POSITIVE_INFINITY;
 debugPhysics.__sources = sources;
 nextParams.physics = debugPhysics;
 const nextArr = { ...arr, collisionMode: 'physics', params: nextParams };
 arrays[id] = nextArr;
 arraysToRebuild.push(nextArr);
 console.log(`[PHYSICS] Debug override set for array #${id}: enabled=${debugPhysics.enabled}, __debugOverride=${debugPhysics.__debugOverride}`);
 });
 debugPhysicsSnapshot = snapshot;
 const avatarPhysics = {
 ...state.avatarPhysics,
 enabled:true,
 jumpCount: Number.POSITIVE_INFINITY,
 __debugOverride:true
 };
 return { arrays, avatarPhysics };
 });
 } else {
 Store.setState(state=>{
 const arrays = { ...state.arrays };
 let arraysChanged = false;
 Object.entries(arrays).forEach(([id, arr])=>{
 if(!arr) return;
 const alreadyLocked = arr.params?.physics?.__debugOverride;
 if(alreadyLocked && debugPhysicsSnapshot.arrays.has(id)) return;
 const nextParams = { ...(arr.params || {}) };
 const prevPhysics = clonePhysicsConfig(nextParams.physics);
 if(!debugPhysicsSnapshot.arrays.has(id)){
 debugPhysicsSnapshot.arrays.set(id, prevPhysics ?? null);
 }
 if(!debugPhysicsSnapshot.collisionModes.has(id)){
 debugPhysicsSnapshot.collisionModes.set(id, arr.collisionMode === 'physics' ? 'physics' : 'edit');
 }
 const debugPhysics = { ...(nextParams.physics || {}), enabled:true, __debugOverride:true };
 const sources = { ...(debugPhysics.__sources || {}) };
 sources.enabled = Number.POSITIVE_INFINITY;
 debugPhysics.__sources = sources;
 nextParams.physics = debugPhysics;
 const nextArr = { ...arr, collisionMode: 'physics', params: nextParams };
 arrays[id] = nextArr;
 arraysToRebuild.push(nextArr);
 arraysChanged = true;
 });
 const avatarPhysics = {
 ...state.avatarPhysics,
 enabled:true,
 jumpCount: Number.POSITIVE_INFINITY,
 __debugOverride:true
 };
 if(arraysChanged){
 return { arrays, avatarPhysics };
 }
 return { avatarPhysics };
 });
 }
 arraysToRebuild.forEach(arr=>{
 try{ debounceColliderRebuild(arr); }catch{}
 });
 resetJumpBudget();
 ensurePlatformerActiveState(true);
 return;
 }

 if(!debugPhysicsSnapshot) return;
 const snapshot = debugPhysicsSnapshot;
 Store.setState(state=>{
 const arrays = { ...state.arrays };
 Object.entries(arrays).forEach(([id, arr])=>{
 if(!arr) return;
 const hasSnapshot = snapshot.arrays.has(id);
 const prev = hasSnapshot ? snapshot.arrays.get(id) : undefined;
 const nextParams = { ...(arr.params || {}) };
 const savedMode = (snapshot.collisionModes && snapshot.collisionModes.has(id))
 ? snapshot.collisionModes.get(id)
 : (prev && prev.enabled ? 'physics' : arr.collisionMode);
 const restoredMode = savedMode === 'physics' ? 'physics' : 'edit';
 if(prev != null){
 nextParams.physics = clonePhysicsConfig(prev);
 arrays[id] = { ...arr, collisionMode: restoredMode, params: nextParams };
 return;
 }
 delete nextParams.physics;
 if(Object.keys(nextParams).length){
 arrays[id] = { ...arr, collisionMode: restoredMode, params: nextParams };
 } else {
 const clone = { ...arr, collisionMode: restoredMode };
 delete clone.params;
 arrays[id] = clone;
 }
 });
 let avatarPhysics = snapshot.avatar ? clonePhysicsConfig(snapshot.avatar) : { ...state.avatarPhysics };
 if(avatarPhysics && typeof avatarPhysics === 'object'){
 delete avatarPhysics.__debugOverride;
 }
 debugPhysicsSnapshot = null;
 return { arrays, avatarPhysics };
 });
 resetJumpBudget();
 restorePlatformerGlobals(snapshot.global || {});
 }

 function setPhysicsDebugAll(enable){
 const next = !!enable;
 console.log(`[PHYSICS] setPhysicsDebugAll called: enable=${enable}, next=${next}`);
 Store.setState(state=>({ scene:{ ...state.scene, physicsDebugAll: next } }));
 console.log(`[PHYSICS] scene.physicsDebugAll now set to: ${Store.getState().scene.physicsDebugAll}`);
 if(next){
 console.log('[PHYSICS] Applying debug overrides (enabling all arrays)');
 applyDebugPhysicsOverrides(true);
 } else {
 console.log('[PHYSICS] Removing debug overrides (restoring original state)');
 applyDebugPhysicsOverrides(false);
 }
 persistPhysicsDebugFlag(next);
 }

 function cloneColorOrNull(color){
 if(!color) return null;
 try{ return color.clone ? color.clone() : color; }catch{ return color || null; }
 }

 function makeWaveGridMaterial(){
 const uniforms = {
 time:{value:0}, amp:{value:0.04}, freq:{value:1.2}, speed:{value:1.1},
 cell:{value:3.2}, width:{value:0.04}, color:{value:new THREE.Color(0x9fbfe8)}, alpha:{value:0.3}
 };
 const vertexShader = `uniform float time,amp,freq,speed; varying vec2 vXZ; void main(){
 vXZ = position.xz;
 float a = sin(vXZ.x*freq + time*speed);
 float b = sin((vXZ.y + vXZ.x*0.5)*freq*0.78 - time*0.83*speed);
 float c = sin((vXZ.x - vXZ.y*0.6)*freq*0.62 + time*1.21*speed);
 float h = (a*0.5 + b*0.3 + c*0.2)*amp;
 vec3 p = position; p.y += h; gl_Position = projectionMatrix * modelViewMatrix * vec4(p,1.0);
 }`;
 const fragmentShader = `precision highp float; uniform float cell,width,alpha; uniform vec3 color; varying vec2 vXZ;
 void main(){ vec2 g=abs(fract(vXZ/cell)-0.5)*cell; float d=min(g.x,g.y); float line=1.0 - smoothstep(width,width*1.6,d);
 gl_FragColor=vec4(color,line*alpha); }`;
 return new THREE.ShaderMaterial({ uniforms, vertexShader, fragmentShader, transparent:true, depthWrite:false });
 }

 function ensureFancyDecor(){
 if(FancyGraphics.decor) return;
 FancyGraphics.decor = new THREE.Group();
 FancyGraphics.decor.visible = false;
 scene.add(FancyGraphics.decor);
 FancyGraphics.shadowLights = [];

 const mirror = new Reflector(new THREE.PlaneGeometry(400,400), {
 textureWidth: Math.max(256, window.innerWidth),
 textureHeight: Math.max(256, window.innerHeight),
 clipBias: 0.003
 });
 mirror.rotation.x = -Math.PI/2;
 mirror.position.y = -0.52;
 mirror.material.onBeforeCompile = (shader)=>{
 shader.uniforms.time = { value: 0 };
 shader.uniforms.amp = { value: 0.02 };
 shader.uniforms.freq = { value: 8.0 };
 shader.uniforms.speed = { value: 1.2 };
 shader.fragmentShader = shader.fragmentShader.replace(
 'vec4 base = texture2D( tDiffuse, vUv );',
 `vec2 dv = vec2(
 sin((vUv.x + time*speed) * freq),
 sin((vUv.y - time*0.8*speed) * freq)
 ) * amp;
 vec4 base = texture2D( tDiffuse, vUv + dv );`
 );
 FancyGraphics.mirrorUniforms = shader.uniforms;
 };
 FancyGraphics.decor.add(mirror);
 FancyGraphics.groups.mirror = mirror;

 const originalMirrorBefore = mirror.onBeforeRender ? mirror.onBeforeRender.bind(mirror) : null;
 const originalMirrorAfter = mirror.onAfterRender ? mirror.onAfterRender.bind(mirror) : null;

 mirror.onBeforeRender = function(...args){
 applyMirrorBillboardFlip(true);
 if(originalMirrorBefore){
 try{
 originalMirrorBefore(...args);
 }catch(err){
 applyMirrorBillboardFlip(false);
 throw err;
 }
 }
 };

 mirror.onAfterRender = function(...args){
 try{
 if(originalMirrorAfter){
 originalMirrorAfter(...args);
 }
 }finally{
 applyMirrorBillboardFlip(false);
 }
 };

 const solidGround = new THREE.Mesh(
 new THREE.PlaneGeometry(400,400),
 new THREE.MeshStandardMaterial({ color: 0xe6e9ef, roughness: 0.85, metalness: 0.1 })
 );
 solidGround.rotation.x = -Math.PI/2;
 solidGround.position.y = -0.51;
 solidGround.receiveShadow = true;
 solidGround.visible = false;
 FancyGraphics.decor.add(solidGround);
 FancyGraphics.groups.ground = solidGround;

 const waveGrid = new THREE.Mesh(new THREE.PlaneGeometry(400,400,180,180), makeWaveGridMaterial());
 waveGrid.rotation.x = -Math.PI/2;
 waveGrid.position.y = -0.48;
 FancyGraphics.decor.add(waveGrid);
 FancyGraphics.groups.waveGrid = waveGrid;

 const lights = new THREE.Group();
 const defaults = FancyGraphics.lightDefaults;
 const strength = FancyGraphics.settings.lightStrength ?? 1;
 const key = new THREE.DirectionalLight(0xffffff, defaults.key * strength); key.position.set(-8, 14, 10);
 const fill = new THREE.DirectionalLight(0xffffff, defaults.fill * strength); fill.position.set(10, 6, 12);
 const rim = new THREE.DirectionalLight(0xffffff, defaults.rim * strength); rim.position.set(0, 8, -14);
 const ambient = new THREE.AmbientLight(0xffffff, 0.4 * strength); // Add ambient light to prevent pure black
 const hemi = new THREE.HemisphereLight(0xdbeafe, 0x0f172a, defaults.hemi * strength);
 key.castShadow = false;
 key.shadow.mapSize.set(2048,2048);
 key.shadow.camera.near = 0.5;
 key.shadow.camera.far = 200;
 key.shadow.camera.left = -80;
 key.shadow.camera.right = 80;
 key.shadow.camera.top = 80;
 key.shadow.camera.bottom = -80;
 key.shadow.bias = -0.0008;
 FancyGraphics.shadowLights.push(key);
 lights.add(key);

 [ambient, fill, rim, hemi].forEach(light=>{
 light.castShadow = false;
 lights.add(light);
 });
 FancyGraphics.decor.add(lights);
 FancyGraphics.groups.lights = lights;
 FancyGraphics.lights = { key, fill, rim, hemi, ambient };
 applyFancyLightingAdjustments();
 }

 function applyFancyLightingAdjustments(){
 try{
 const rotation = THREE.MathUtils.degToRad(FancyGraphics.settings.lightRotation || 0);
 if(FancyGraphics.groups.lights){
 FancyGraphics.groups.lights.rotation.y = rotation;
 }
 if(baseLightsGroup){
 baseLightsGroup.rotation.y = rotation;
 }
 const strength = Math.max(0, FancyGraphics.settings.lightStrength ?? 1);
 const defaults = FancyGraphics.lightDefaults;
 const lights = FancyGraphics.lights || {};
 if(lights.key) lights.key.intensity = defaults.key * strength;
 if(lights.fill) lights.fill.intensity = defaults.fill * strength;
 if(lights.rim) lights.rim.intensity = defaults.rim * strength;
 if(lights.hemi) lights.hemi.intensity = defaults.hemi * strength;
 if(lights.ambient) lights.ambient.intensity = 0.4 * strength;
 if(scene){
 try{ scene.environmentIntensity = strength; }catch{}
 const env = scene.environment;
 if(env && env.isTexture){
 try{
 if(env.center && env.center.set){ env.center.set(0.5, 0.5); }
 else if(env.center){ env.center.x = 0.5; env.center.y = 0.5; }
 env.rotation = rotation;
 env.needsUpdate = true;
 }catch{}
 }
 }
 }catch(e){ console.warn('applyFancyLightingAdjustments failed', e); }
 }

 function ensureFancyComposer(){
 if(FancyGraphics.composer) return;
 if(!renderer || !scene || !camera) return; // Wait for init
 try{
 const fancyTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, {
 depthBuffer: true,
 stencilBuffer: true
 });
 FancyGraphics.composer = new EffectComposer(renderer, fancyTarget);
 if(FancyGraphics.composer.renderTarget1) FancyGraphics.composer.renderTarget1.stencilBuffer = true;
 if(FancyGraphics.composer.renderTarget2) FancyGraphics.composer.renderTarget2.stencilBuffer = true;
 FancyGraphics.passes.render = new RenderPass(scene, camera);
 FancyGraphics.composer.addPass(FancyGraphics.passes.render);

 const bokeh = new BokehPass(scene, camera, {
 focus: camera.position.distanceTo(controls?.target || new THREE.Vector3()),
 aperture: FancyGraphics.settings.dofAperture,
 maxblur: FancyGraphics.settings.dofMaxBlur,
 width: window.innerWidth,
 height: window.innerHeight
 });
 FancyGraphics.composer.addPass(bokeh);
 FancyGraphics.passes.bokeh = bokeh;

 const outline = new OutlinePass(new THREE.Vector2(window.innerWidth, window.innerHeight), scene, camera);
 outline.edgeStrength = FancyGraphics.settings.outlineStrength;
 outline.edgeThickness = FancyGraphics.settings.outlineThickness;
 outline.visibleEdgeColor.set(0x3b82f6);
 outline.hiddenEdgeColor.set(0x0f172a);
 FancyGraphics.composer.addPass(outline);
 FancyGraphics.passes.outline = outline;

 const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), FancyGraphics.settings.bloomStrength, 0.4, 0.85);
 bloom.radius = FancyGraphics.settings.bloomRadius;
 FancyGraphics.composer.addPass(bloom);
 FancyGraphics.passes.bloom = bloom;

 const afterimage = new AfterimagePass();
 FancyGraphics.composer.addPass(afterimage);
 FancyGraphics.passes.afterimage = afterimage;

 const fxaa = new ShaderPass(FXAAShader);
 FancyGraphics.composer.addPass(fxaa);
 FancyGraphics.passes.fxaa = fxaa;

 const output = new OutputPass();
 FancyGraphics.composer.addPass(output);
 FancyGraphics.passes.output = output;

 updateFancyComposerSize();
 }catch(e){
 console.warn('Failed to create fancy composer:', e);
 FancyGraphics.composer = null;
 }
 }

 function ensureFancyHDRI(){
 if(FancyGraphics.hdriTexture) return Promise.resolve(FancyGraphics.hdriTexture);
 if(FancyGraphics.hdriPromise) return FancyGraphics.hdriPromise;
 FancyGraphics.hdriPromise = new Promise((resolve, reject)=>{
 try{
 const loader = new RGBELoader();
 loader.load('https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/studio_small_03_1k.hdr', (tex)=>{
 tex.mapping = THREE.EquirectangularReflectionMapping;
 FancyGraphics.hdriTexture = tex;
 resolve(tex);
 }, undefined, reject);
 }catch(e){ reject(e); }
 });
 return FancyGraphics.hdriPromise.catch((e)=>{ console.warn('HDRI load failed', e); FancyGraphics.hdriPromise=null; throw e; });
 }

 function updateFancyComposerSize(){
 if(!FancyGraphics.composer) return;
 try{
 const dpr = Math.min(window.devicePixelRatio||1, 2);
 if(FancyGraphics.composer.setPixelRatio) FancyGraphics.composer.setPixelRatio(dpr);
 if(FancyGraphics.composer.setSize) FancyGraphics.composer.setSize(window.innerWidth, window.innerHeight);
 if(FancyGraphics.passes.fxaa){
 FancyGraphics.passes.fxaa.material.uniforms.resolution.value.set(1/(window.innerWidth*dpr), 1/(window.innerHeight*dpr));
 }
 if(FancyGraphics.passes.bloom){ FancyGraphics.passes.bloom.setSize(window.innerWidth, window.innerHeight); }
 if(FancyGraphics.passes.outline){ FancyGraphics.passes.outline.setSize(window.innerWidth, window.innerHeight); }
 if(FancyGraphics.passes.bokeh && FancyGraphics.passes.bokeh.renderTargetDepth && FancyGraphics.passes.bokeh.renderTargetColor){
 FancyGraphics.passes.bokeh.renderTargetDepth.setSize(window.innerWidth*dpr, window.innerHeight*dpr);
 FancyGraphics.passes.bokeh.renderTargetColor.setSize(window.innerWidth*dpr, window.innerHeight*dpr);
 }
 }catch(e){
 console.warn('Failed to update composer size:', e);
 }
 }

 function applyFancyRuntimeSettings(){
 if(!FancyGraphics.enabled) return;
 renderer.toneMappingExposure = FancyGraphics.settings.exposure;
 renderer.setClearColor(FancyGraphics.settings.darkBg ? PRESENT_DARK_BG : PRESENT_LIGHT_BG, 1);
 scene.background = (FancyGraphics.settings.darkBg ? PRESENT_DARK_BG : PRESENT_LIGHT_BG).clone();

 if(FancyGraphics.passes.bloom){
 FancyGraphics.passes.bloom.enabled = FancyGraphics.settings.bloomEnabled;
 FancyGraphics.passes.bloom.strength = FancyGraphics.settings.bloomStrength;
 FancyGraphics.passes.bloom.radius = FancyGraphics.settings.bloomRadius;
 }
 if(FancyGraphics.passes.bokeh){
 FancyGraphics.passes.bokeh.enabled = FancyGraphics.settings.dofEnabled;
 FancyGraphics.passes.bokeh.uniforms.aperture.value = FancyGraphics.settings.dofAperture;
 FancyGraphics.passes.bokeh.uniforms.maxblur.value = FancyGraphics.settings.dofMaxBlur;
 }
 if(FancyGraphics.passes.fxaa){ FancyGraphics.passes.fxaa.enabled = FancyGraphics.settings.fxaa; }
 if(FancyGraphics.passes.outline){
 FancyGraphics.passes.outline.enabled = FancyGraphics.settings.outlineEnabled;
 FancyGraphics.passes.outline.edgeStrength = FancyGraphics.settings.outlineStrength;
 FancyGraphics.passes.outline.edgeThickness = FancyGraphics.settings.outlineThickness;
 }
 if(FancyGraphics.passes.afterimage){
 FancyGraphics.passes.afterimage.enabled = FancyGraphics.settings.motionEnabled;
 FancyGraphics.passes.afterimage.uniforms['damp'].value = FancyGraphics.settings.motionDamping;
 }
 if(FancyGraphics.groups.lights){ FancyGraphics.groups.lights.visible = FancyGraphics.settings.lights; }
 updateBaseLightingVisibility();
 if(FancyGraphics.groups.waveGrid){ FancyGraphics.groups.waveGrid.visible = FancyGraphics.settings.waveGrid; }
 refreshShadowCasting();
 if(FancyGraphics.settings.hdri){
 ensureFancyHDRI().then((tex)=>{
 if(FancyGraphics.enabled && FancyGraphics.settings.hdri){
 scene.environment = tex;
 applyFancyLightingAdjustments();
 }
 }).catch(()=>{});
 } else {
 scene.environment = null;
 }

 if(FancyGraphics.settings.fogEnabled){
 scene.fog = new THREE.FogExp2((FancyGraphics.settings.darkBg ? PRESENT_DARK_BG : PRESENT_LIGHT_BG).clone(), FancyGraphics.settings.fogDensity);
 } else {
 scene.fog = null;
 }
 applyFancyLightingAdjustments();
 OceanBackdrop.applySettings();
 OceanBackdrop.refreshVisibility();
 }

 function setPresentMode(force){
 const next = force == null ? !FancyGraphics.enabled : !!force;
 if(next === FancyGraphics.enabled) return FancyGraphics.enabled;
 if(next){
 FancyGraphics.base.gridVisible = grid?.visible ?? true;
 FancyGraphics.base.background = cloneColorOrNull(scene?.background || null);
 FancyGraphics.base.environment = scene?.environment || null;
 FancyGraphics.base.fog = scene?.fog || null;
 FancyGraphics.base.toneMapping = renderer?.toneMapping ?? null;
 FancyGraphics.base.exposure = renderer?.toneMappingExposure ?? 1;
 FancyGraphics.base.shadowMap = renderer?.shadowMap?.enabled ?? false;
 FancyGraphics.base.shadowAutoUpdate = renderer?.shadowMap?.autoUpdate ?? true;
 FancyGraphics.base.physicallyCorrectLights = renderer?.physicallyCorrectLights ?? false;
 FancyGraphics.base.clearColor = cloneColorOrNull(renderer?.getClearColor ? renderer.getClearColor(new THREE.Color()) : new THREE.Color(0xf6f7fb));
 FancyGraphics.base.clearAlpha = renderer?.getClearAlpha ? renderer.getClearAlpha() : 1;

 ensureFancyDecor();
 ensureFancyComposer();
 FancyGraphics.decor.visible = FancyGraphics.settings.waveGrid || FancyGraphics.settings.mirror || FancyGraphics.settings.solidGround;
 grid.visible = false;
 renderer.physicallyCorrectLights = true;
 renderer.shadowMap.enabled = FancyGraphics.settings.solidGround;
 if(renderer.shadowMap.enabled){ renderer.shadowMap.type = THREE.PCFSoftShadowMap; }
 renderer.toneMapping = THREE.ACESFilmicToneMapping;
 FancyGraphics.clock = new THREE.Clock();
 FancyGraphics.enabled = true;
 applyFancyRuntimeSettings();
 } else {
 FancyGraphics.enabled = false;
 refreshShadowCasting();
 if(FancyGraphics.decor) FancyGraphics.decor.visible = false;
 grid.visible = !!FancyGraphics.base.gridVisible;
 setupRenderer();
 renderer.setClearColor(FancyGraphics.base.clearColor || new THREE.Color(0xf6f7fb), FancyGraphics.base.clearAlpha ?? 1);
 renderer.shadowMap.enabled = FancyGraphics.base.shadowMap ?? false;
 renderer.shadowMap.autoUpdate = FancyGraphics.base.shadowAutoUpdate ?? true;
 renderer.physicallyCorrectLights = FancyGraphics.base.physicallyCorrectLights ?? false;
 renderer.toneMapping = FancyGraphics.base.toneMapping ?? THREE.NoToneMapping;
 renderer.toneMappingExposure = FancyGraphics.base.exposure ?? 1;
 scene.environment = FancyGraphics.base.environment || null;
 scene.background = FancyGraphics.base.background ? cloneColorOrNull(FancyGraphics.base.background) : PRESENT_LIGHT_BG.clone();
 scene.fog = FancyGraphics.base.fog || null;
 if(FancyGraphics.passes.outline) FancyGraphics.passes.outline.selectedObjects = [];
 updateBaseLightingVisibility();
 }
 OceanBackdrop.refreshVisibility();
 updateShellVisibilityGlobal();
 refreshCellMaterials();
 return FancyGraphics.enabled;
 }

 function togglePresentMode(force){
 console.log('[PRESENT] togglePresentMode called, force:', force, 'current:', FancyGraphics.enabled);
 const state = setPresentMode(force);
 console.log('[PRESENT] togglePresentMode result:', state);
 needsRender = true; // Force a render update
 return state;
 }

 function getGraphicsSettings(){
 return { ...FancyGraphics.settings };
 }

 function updateGraphicsSettings(patch){
 const incoming = patch || {};
 Object.keys(incoming).forEach(key=>{
 if(key in FancyGraphics.settings){ FancyGraphics.settings[key] = incoming[key]; }
 });
 if(Object.prototype.hasOwnProperty.call(incoming, 'solidGround') && incoming.solidGround){
 FancyGraphics.settings.mirror = false;
 }
 if(FancyGraphics.settings.solidGround){
 FancyGraphics.settings.mirror = false;
 }
 const affectsMaterials = Object.prototype.hasOwnProperty.call(incoming, 'transmission');
 const affectsLights = Object.prototype.hasOwnProperty.call(incoming, 'lightRotation') || Object.prototype.hasOwnProperty.call(incoming, 'lightStrength');
 if(FancyGraphics.enabled){
 applyFancyRuntimeSettings();
 if(affectsMaterials) refreshCellMaterials();
 } else {
 if(affectsMaterials) refreshCellMaterials();
 if(affectsLights) applyFancyLightingAdjustments();
 }
 // Update Celli render order when transmission (frosted glass) changes
 if(affectsMaterials){
 try{
 const avatars = Store.getState().avatars || {};
 Object.values(avatars).forEach(av=>{
 if(av?.root?.userData?.updateRenderOrder){
 av.root.userData.updateRenderOrder();
 }
 });
 }catch{}
 }
 }

 function isPresentEnabled(){ return FancyGraphics.enabled; }
 // Hover highlight state (2D/3D sync)
 let hoverKey = null; // `${arrId}:${x},${y},${z}`
 const HIGHLIGHT_FILL_HEX = 0xe0f2ff; // light blue fill
 function applyHoverColor(arrId, coord){
 try{
 const arr = Store.getState().arrays[arrId]; if(!arr) return;
 const ch = arr.chunks[keyChunk(...Object.values(chunkOf(coord.x,coord.y,coord.z)))]; if(!ch) return;
 if(!ch.index2cell) return;
 const idx = ch.index2cell.findIndex(c=>c && c.x===coord.x && c.y===coord.y && c.z===coord.z);
 if(idx<0) return;
 const col = new THREE.Color(HIGHLIGHT_FILL_HEX); col.convertSRGBToLinear();
 if(ch.meshLOD1){ ch.meshLOD1.setColorAt(idx, col); if(ch.meshLOD1.instanceColor) ch.meshLOD1.instanceColor.needsUpdate = true; }
 if(ch.meshGhost){ ch.meshGhost.setColorAt(idx, col); if(ch.meshGhost.instanceColor) ch.meshGhost.instanceColor.needsUpdate = true; }
 if(ch.meshShell){ const sc = new THREE.Color(HIGHLIGHT_FILL_HEX); sc.offsetHSL(0,0,-0.22); sc.convertSRGBToLinear(); ch.meshShell.setColorAt(idx, sc); if(ch.meshShell.instanceColor) ch.meshShell.instanceColor.needsUpdate = true; }
 needsRender = true;
 }catch{}
 }
 function setHoverCell(target){
 try{
 const k = target ? `${target.arrId}:${target.x},${target.y},${target.z}` : null;
 if(k===hoverKey) return;
 // clear previous
 if(hoverKey){
 const [aid, rest] = hoverKey.split(':'); const [x,y,z] = rest.split(',').map(Number);
 updateCellColor(+aid, {x,y,z});
 }
 hoverKey = k;
 if(target){ applyHoverColor(target.arrId, target); }
 try{ window.UI?.setHoveredCell?.(target?.arrId || null, target || null); }catch{}
 }catch{}
 }
 function clearHoverCell(){ setHoverCell(null); }
 const temp=new THREE.Object3D(), tempM=new THREE.Matrix4();
 let needsRender = false;
 function refreshShadowCasting(){
 const enable = FancyGraphics.enabled && FancyGraphics.settings.solidGround;
 renderer.shadowMap.enabled = enable;
 renderer.shadowMap.autoUpdate = enable;
 if(enable){
 renderer.shadowMap.type = THREE.PCFSoftShadowMap;
 renderer.shadowMap.autoUpdate = true;
 }
 if(FancyGraphics.groups.ground){ FancyGraphics.groups.ground.visible = enable; }
 if(FancyGraphics.groups.mirror){
 FancyGraphics.groups.mirror.visible = FancyGraphics.settings.mirror && !FancyGraphics.settings.solidGround;
 }
 if(FancyGraphics.decor){
 const decorActive = FancyGraphics.enabled && (FancyGraphics.settings.waveGrid || FancyGraphics.settings.solidGround || FancyGraphics.settings.mirror);
 FancyGraphics.decor.visible = decorActive;
 }
 FancyGraphics.shadowLights.forEach(light=>{ light.castShadow = enable; });
 try{
 Object.values(Store.getState().arrays||{}).forEach(arr=>{
 Object.values(arr.chunks||{}).forEach(ch=>{
 if(ch.meshLOD1) ch.meshLOD1.castShadow = enable;
 if(ch.meshLOD2) ch.meshLOD2.castShadow = enable;
 if(ch.meshGhost) ch.meshGhost.castShadow = false;
 if(ch.meshShell) ch.meshShell.castShadow = false;
 });
 });
 }catch{}
 needsRender = true;
 }

 function setOceanEnabled(flag){
 const actual = OceanBackdrop.setEnabled(flag);
 try{
 const settings = OceanBackdrop.getSettings();
 const stored = { ...settings };
 delete stored.active;
 Store.setState(s=>({ scene:{ ...s.scene, ocean:{ ...(s.scene?.ocean||{}), ...stored } } }));
 try{ UI?.syncOceanSettings?.(); }catch{}
 }catch{}
 // Auto-configure FancyGraphics for optimal ocean atmosphere
 if(flag && FancyGraphics?.settings){
 FancyGraphics.settings.mirror = false;
 FancyGraphics.settings.bloomEnabled = true;
 FancyGraphics.settings.bloomStrength = 0.25;
 FancyGraphics.settings.bloomRadius = 0.5;
 FancyGraphics.settings.fogEnabled = true;
 FancyGraphics.settings.fogDensity = 0.008;
 try{ applyFancyRuntimeSettings?.(); }catch{}
 try{ UI?.syncGraphicsSettings?.(); }catch{}
 }
 needsRender = true;
 return actual;
 }

 function updateOceanSettings(patch){
 OceanBackdrop.updateSettings(patch);
 try{
 const settings = OceanBackdrop.getSettings();
 const stored = { ...settings };
 delete stored.active;
 Store.setState(s=>({ scene:{ ...s.scene, ocean:{ ...(s.scene?.ocean||{}), ...stored } } }));
 try{ UI?.syncOceanSettings?.(); }catch{}
 }catch{}
 needsRender = true;
 return OceanBackdrop.getSettings();
 }

 function getOceanSettings(){
 return OceanBackdrop.getSettings();
 }

 function updateShellVisibilityGlobal(){
 const showShells = !FancyGraphics.enabled;
 try{
 const arrays = Store.getState().arrays || {};
 Object.values(arrays).forEach(arr=>{
 if(!arr) return;
 const arrVisible = !arr.hidden;
 Object.values(arr.chunks||{}).forEach(ch=>{
 if(!ch?.meshShell) return;
 const lod = (ch.currentLOD == null) ? 1 : ch.currentLOD;
 ch.meshShell.visible = showShells && arrVisible && (lod === 1);
 });
 });
 }catch{}
 }
 // Instance bounce store
 const activeInstanceAnims = new Map(); // key `${arrId}:${z}:${type}:${idx}` -> {cancel,busy:true}
 // InteractionManager: transient overlaps and gobble checks
 const InteractionManager = (()=>{
 function getCellWorldBounds(arr,x,y,z){
 const c=cellWorldPos(arr,x,y,z);
 const min=c.clone().add(new THREE.Vector3(-0.5,-0.5,-0.5));
 const max=c.clone().add(new THREE.Vector3( 0.5, 0.5, 0.5));
 return new THREE.Box3(min,max);
 }
 function runChecks(moved){
 try{ checkTransient(moved); }catch{}
 const S=Store.getState();
 if(S?.interactions?.gobblingEnabled){ try{ checkGobble(moved); }catch{} }
 }
 function checkTransient(moved){
 const S=Store.getState(); const tx=Write.start('interaction.transient','overlaps');
 const others=Object.values(S.arrays).filter(a=>!a.hidden && a.id!==moved.id);
 Object.values(moved.chunks).forEach(ch=> ch.cells.forEach(ca=>{
 const bA=getCellWorldBounds(moved,ca.x,ca.y,ca.z);
 const fA=String(Formula.getCell({arrId:moved.id,x:ca.x,y:ca.y,z:ca.z})?.formula||'');
 others.forEach(b=> Object.values(b.chunks).forEach(chb=> chb.cells.forEach(cb=>{
 const bB=getCellWorldBounds(b,cb.x,cb.y,cb.z);
 if(!bA.intersectsBox(bB)) return;
 const fB=String(Formula.getCell({arrId:b.id,x:cb.x,y:cb.y,z:cb.z})?.formula||'');
 // naive check: always_exec flag present if last arg is 1 ... defer strict parsing
 if(/^=\s*OVERLAP\(/i.test(fA) && /\)\s*$/.test(fA) && fA.trim().endsWith('1)')){
 S.globalState.set('temp.overlap_target',{arrId:b.id,x:cb.x,y:cb.y,z:cb.z});
 Formula.executeAt({arrId:moved.id,x:ca.x,y:ca.y,z:ca.z}, undefined, tx);
 }
 if(/^=\s*OVERLAP\(/i.test(fB) && /\)\s*$/.test(fB) && fB.trim().endsWith('1)')){
 S.globalState.set('temp.overlap_target',{arrId:moved.id,x:ca.x,y:ca.y,z:ca.z});
 Formula.executeAt({arrId:b.id,x:cb.x,y:cb.y,z:cb.z}, undefined, tx);
 }
 })));
 }));
 S.globalState.delete('temp.overlap_target');
 if(tx.ops.length) Write.commit(tx);
 }
 function canGobble(gobbler,gobblee){
 // require every gobblee filled/formula cell to intersect at least one gobbler cell bounds
 const filled = [];
 Object.values(gobbler.chunks).forEach(ch=> ch.cells.forEach(c=>{ const fc=Formula.getCell({arrId:gobbler.id,x:c.x,y:c.y,z:c.z}); if(fc.value!==''||fc.formula){ filled.push(getCellWorldBounds(gobbler,c.x,c.y,c.z)); } }));
 if(!filled.length) return false;
 let ok=true;
 outer: for(const ch of Object.values(gobblee.chunks)){
 for(const c of ch.cells){ const fc=Formula.getCell({arrId:gobblee.id,x:c.x,y:c.y,z:c.z}); if(!(fc.value!==''||fc.formula)) continue; const bb=getCellWorldBounds(gobblee,c.x,c.y,c.z); let covered=false; for(const b of filled){ if(b.intersectsBox(bb)){ covered=true; break; } } if(!covered){ ok=false; break outer; } }
 }
 return ok;
 }
 function combineArrays(winner,loser){
 showToast(`Array #${winner.id} combined with #${loser.id}`);
 const tx=Write.start('interaction.combine',`Combine ${winner.id}+${loser.id}`);
 Object.values(loser.chunks).forEach(ch=> ch.cells.forEach(cL=>{
 const vL=Formula.getCell({arrId:loser.id,x:cL.x,y:cL.y,z:cL.z}); if(!(vL.value!==''||vL.formula)) return;
 // find any intersecting winner cell
 let target=null; for(const chw of Object.values(winner.chunks)){ for(const cW of chw.cells){ const bW=getCellWorldBounds(winner,cW.x,cW.y,cW.z); const bL=getCellWorldBounds(loser,cL.x,cL.y,cL.z); if(bW.intersectsBox(bL)){ target={x:cW.x,y:cW.y,z:cW.z}; break; } } if(target) break; }
 if(!target) return;
 const cellW=Formula.getCell({arrId:winner.id,x:target.x,y:target.y,z:target.z});
 const isEmptyW = (cellW.value===''||cellW.value==null) && !cellW.formula;
 // default mode: fill empty
 if(isEmptyW){ Write.set(tx, winner.id, target, { value: vL.value, formula: vL.formula }); }
 }));
 Write.commit(tx);
 try{ Actions.deleteArray(loser.id); }catch{}
 }
 function checkGobble(moved){
 const S=Store.getState(); const arrays=Object.values(S.arrays).filter(a=>!a.hidden);
 for(const other of arrays){ if(other.id===moved.id) continue; if(canGobble(moved,other)){ combineArrays(moved,other); return; } if(canGobble(other,moved)){ combineArrays(other,moved); return; } }
 }
 return { runChecks };
 })();

 function easeOutBack(t, s=1.70158){ const tt=t-1; return (tt*tt*((s+1)*tt + s) + 1); }

 function pulseCell(arr, cell, z){
 // Collect candidate records: core types + any edges overlays for this array/z
 const wantedKeys=[`${arr.id}:${z}:empty`,`$${arr.id}:${z}:ghost`,`$${arr.id}:${z}:filled`,`$${arr.id}:${z}:formula`];
 const recs=[];
 ['empty','ghost','filled','formula'].forEach(type=>{
 const rec=layerMeshes.get(`${arr.id}:${z}:${type}`); if(rec) recs.push({type,rec});
 });
 // Include all edge overlays for this array/z regardless of base group key
 layerMeshes.forEach((val,key)=>{
 if(val?.mesh?.userData?.type==='edges' && val.mesh?.userData?.arrayId===arr.id && val.mesh?.userData?.z===z){
 recs.push({type:'edges',rec:val});
 }
 });

 recs.forEach(({type,rec})=>{
 if(!rec||!rec.mesh||!rec.index2cell) return;
 const idx=rec.index2cell.findIndex(c=>c && c.x===cell.x && c.y===cell.y && c.z===cell.z);
 if(idx<0) return;
 const mesh=rec.mesh; const key=`${arr.id}:${z}:${type}:${idx}`;
 const running=activeInstanceAnims.get(key);
 // Guard: if running, ignore this click completely to prevent inflation
 if(running && running.busy){ return; }
 // capture base matrix
 const base=new THREE.Matrix4(); mesh.getMatrixAt(idx, base);
 let start=undefined; const duration=180; const amp=(type==='edges'?0.12:0.06);
 const state={cancel:false,busy:true}; activeInstanceAnims.set(key,state);
 const step=(ts)=>{
 if(state.cancel) { mesh.setMatrixAt(idx, base); mesh.instanceMatrix.needsUpdate=true; activeInstanceAnims.delete(key); return; }
 if(start===undefined) start=ts; const t=Math.min(1,(ts-start)/duration);
 const s=1 + amp*easeOutBack(t);
 const m=base.clone().multiply(new THREE.Matrix4().makeScale(s,s,s));
 mesh.setMatrixAt(idx,m); mesh.instanceMatrix.needsUpdate=true;
 if(t<1) requestAnimationFrame(step); else { // return to base for precision
 mesh.setMatrixAt(idx, base); mesh.instanceMatrix.needsUpdate=true; activeInstanceAnims.delete(key);
 }
 };
 requestAnimationFrame(step);
 });
 }

 // Text sprite creation for cell values
 function makeValueSprite(text, isFormula=false){
 const renderMode = Store.getState().scene.renderMode;
 
 if(renderMode === 'fancy') {
 // Rounded backdrop with drop shadow
 const padX = 12, padY = 8, fs = 28, r = 8;
 const font = `600 ${fs}px 'Roboto Mono', monospace`;

 // First measure
 const mCanvas = document.createElement('canvas');
 const mCtx = mCanvas.getContext('2d');
 mCtx.font = font;
 const w = Math.max(48, Math.ceil(mCtx.measureText(text).width) + padX * 2);
 const h = fs + padY * 2;

 // Draw
 const c = document.createElement('canvas');
 c.width = w; c.height = h;
 const ctx = c.getContext('2d');

 // Backdrop with rounded corners
 ctx.fillStyle = 'rgba(17, 24, 39, 0.66)'; // slate-900 @ ~66%
 ctx.strokeStyle = 'rgba(255,255,255,0.18)';
 ctx.lineWidth = 1;
 ctx.beginPath();
 const rr = (x, y, w, h, r) => {
 ctx.moveTo(x + r, y);
 ctx.arcTo(x + w, y, x + w, y + h, r);
 ctx.arcTo(x + w, y + h, x, y + h, r);
 ctx.arcTo(x, y + h, x, y, r);
 ctx.arcTo(x, y, x + w, y, r);
 };
 rr(0.5, 0.5, w - 1, h - 1, r);
 ctx.fill();
 ctx.stroke();

 // Text with subtle shadow
 ctx.font = font;
 ctx.textAlign = 'center';
 ctx.textBaseline = 'middle';
 ctx.shadowColor = 'rgba(0,0,0,0.35)';
 ctx.shadowBlur = 4;
 ctx.fillStyle = isFormula ? '#cfe0ff' : '#ffffff';
 ctx.fillText(text, w / 2, h / 2);

 const tex = new THREE.CanvasTexture(c);
 tex.anisotropy = 4;
 const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false });
 const spr = new THREE.Sprite(mat);
 spr.scale.set(0.9, 0.44, 1);
 spr.renderOrder = 2000;
 return markBillboard(spr);
 } else {
 // Simple mode (current behavior)
 const canvas=document.createElement('canvas');
 const ctx=canvas.getContext('2d');
 const fontSize=28; const padding=4;
 ctx.font=`600 ${fontSize}px 'Roboto Mono', monospace`;
 const metrics=ctx.measureText(text);
 canvas.width=Math.max(48, metrics.width+padding*2);
 canvas.height=fontSize+padding*2;
 
 // Draw text only (no backdrop card). Billboarded sprite will sit on cell face.
 ctx.clearRect(0,0,canvas.width,canvas.height);
 const fg = isFormula ? '#e6ffef' : '#ffffff';
 ctx.fillStyle = fg;
 ctx.font=`600 ${fontSize}px 'Roboto Mono', monospace`;
 ctx.textAlign='center'; ctx.textBaseline='middle';
 ctx.fillText(text, canvas.width/2, canvas.height/2);
 
 const texture=new THREE.CanvasTexture(canvas);
 // Place label on cell face (depth tested), slightly lifted to avoid z-fighting
 const material=new THREE.SpriteMaterial({map:texture, transparent:true, depthTest:true, depthWrite:false});
 material.toneMapped=false;
 const sprite=new THREE.Sprite(material);
 sprite.scale.set(0.5, 0.32, 1);
 sprite.renderOrder=2; // above solids, below edge overlays
 return markBillboard(sprite);
 }
 }
 // 3D label sprite for arrays (ID and name) - improved with depth testing
 function makeArrayLabelSprite(arr){
 const text = `#${arr.id}${arr.name ? ` "${arr.name}"` : ''}`;
 const canvas = document.createElement('canvas');
 const ctx = canvas.getContext('2d');
 const fontSize = 32, padding = 8, r = 12;
 ctx.font = `700 ${fontSize}px 'Inter', sans-serif`;
 const metrics = ctx.measureText(text);
 const w = Math.ceil(metrics.width + padding*2);
 const h = fontSize + padding*2;
 // Render at device pixel ratio for sharper text
 const dpr = Math.min(2, window.devicePixelRatio || 1);
 canvas.width = Math.max(1, Math.floor(w * dpr));
 canvas.height = Math.max(1, Math.floor(h * dpr));
 ctx.scale(dpr, dpr);

 // Check if present mode is active
 const isPresentMode = Scene.isPresentEnabled ? Scene.isPresentEnabled() : false;

 if(isPresentMode){
 // Crystal background for present mode (matches other UI elements)
 ctx.fillStyle = 'rgba(17, 24, 39, 0.66)'; // slate-900 @ ~66%
 ctx.strokeStyle = 'rgba(255,255,255,0.18)';
 ctx.lineWidth = 1;
 ctx.beginPath();
 ctx.moveTo(r,0.5);
 ctx.arcTo(w-0.5,0.5,w-0.5,h-0.5,r); 
 ctx.arcTo(w-0.5,h-0.5,0.5,h-0.5,r); 
 ctx.arcTo(0.5,h-0.5,0.5,0.5,r); 
 ctx.arcTo(0.5,0.5,w-0.5,0.5,r);
 ctx.closePath(); 
 ctx.fill(); 
 ctx.stroke();
 ctx.fillStyle = '#cfe0ff'; // Light blue text for dark background
 } else {
 // rounded white pill for normal mode
 ctx.fillStyle = 'rgba(255,255,255,0.85)';
 ctx.strokeStyle = 'rgba(0,0,0,0.10)';
 ctx.lineWidth = 2;
 ctx.beginPath();
 ctx.moveTo(r,0);
 ctx.arcTo(w,0,w,h,r); ctx.arcTo(w,h,0,h,r); ctx.arcTo(0,h,0,0,r); ctx.arcTo(0,0,w,0,r);
 ctx.closePath(); ctx.fill(); ctx.stroke();
 ctx.fillStyle = '#1f2937';
 }
 
 ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
 ctx.font = `700 ${fontSize}px 'Inter', sans-serif`;
 ctx.fillText(text, w/2, h/2);

 const tex = new THREE.CanvasTexture(canvas);
 tex.colorSpace = THREE.SRGBColorSpace; // correct gamma for UI texture
 tex.anisotropy = renderer?.capabilities?.getMaxAnisotropy?.() || 1;
 tex.minFilter = THREE.LinearMipMapLinearFilter;
 tex.magFilter = THREE.LinearFilter;
 tex.generateMipmaps = true;

 const mat = new THREE.SpriteMaterial({
 map: tex,
 transparent: true,
 depthTest: true,
 depthWrite: false
 });
 mat.toneMapped = false;

 const mesh = new THREE.Sprite(mat);
 const aspect = w/h;
 // Slightly reduce width/height to avoid a stretched look while preserving aspect
 mesh.scale.set(1.0*aspect, 1.0, 1); // world-unit size
 // Proper render order: above voxels (100-300) but below transparent UI (2000+)
 mesh.renderOrder = 500; 
 mesh.userData.isLabel = true;
 return markBillboard(mesh);
 }
 const COLORS = {
 empty: 0xffffff, // empty cells: clean white
 emptyBorder: 0xe5e7eb, // empty border: light gray
 filled: 0x3b82f6, // data cells: vibrant blue
 formula: 0x16a34a, // formulas: dark green
 emitted: 0x86efac, // emitted values: light green
 ghost: 0xf3f4f6, // ghost layers: very light gray
 ghostBorder: 0xd1d5db, // ghost border: medium gray
 focus: 0xf59e0b, // focus highlight: amber
 frame: 0x374151, // array frame: dark gray
 grab: 0x06b6d4 // grab handle: cyan
 };
 // Fixed visibility settings (UI removed)
 const DEFAULT_VISIBILITY = {
 empty: { color: COLORS.empty, outlineColor: 0xe5e7eb, outlineThickness: 1.0, outlineOpacity: 0.35 },
 value: { color: COLORS.filled, outlineColor: null, outlineThickness: 1.0, outlineOpacity: 0.35 },
 formula: { color: COLORS.formula, outlineColor: null, outlineThickness: 1.0, outlineOpacity: 0.35 },
 emitted: { color: COLORS.emitted, outlineColor: null, outlineThickness: 1.0, outlineOpacity: 0.35 }
 };
 window.VisibilitySettings = DEFAULT_VISIBILITY;
 function typeKeyFrom(raw){
 let t = String(raw||'value');
 if(t.startsWith('ghost_')) t = t.slice(6);
 if(t==='filled') t='value';
 return t;
 }
 function baseHexForTypeKey(tk){
 const vs = window.VisibilitySettings || {}; const s = vs[tk];
 return (s && typeof s.color==='number') ? s.color : (tk==='empty'?COLORS.empty: tk==='formula'?COLORS.formula: tk==='emitted'?COLORS.emitted: COLORS.filled);
 }
 function ghostBaseHex(){
 const vs = window.VisibilitySettings || {};
 const setting = vs.ghost;
 if(setting && typeof setting.color === 'number') return setting.color;
 return COLORS.ghost;
 }
 const ghostBaseLinearCache = { hex:null, color:null };
 function ghostBaseLinearColor(){
 const hex = ghostBaseHex();
 if(ghostBaseLinearCache.color && ghostBaseLinearCache.hex === hex) return ghostBaseLinearCache.color;
 const col = new THREE.Color(hex);
 col.convertSRGBToLinear();
 ghostBaseLinearCache.hex = hex;
 ghostBaseLinearCache.color = col;
 return col;
 }
 function tintGhostColorFrom(colLinear){
 try{
 const base = ghostBaseLinearColor().clone();
 return base.lerp(colLinear, 0.65);
 }catch{}
 return colLinear.clone();
 }
 // Make default outlines subtler: 1.01 instead of 1.04
 const BASE_OUTLINE_SCALE = 1.01;
 function outlineParamsForTypeKey(tk){
 const vs = window.VisibilitySettings || {}; const s = vs[tk]||{};
 const setting = Number(s.outlineThickness||1.0);
 const actual = BASE_OUTLINE_SCALE * (isFinite(setting)?setting:1.0);
 const thickness = Math.max(0.98, Math.min(1.12, actual));
 const colorHex = (typeof s.outlineColor==='number' ? s.outlineColor : null);
 const opacity = (typeof s.outlineOpacity==='number' ? s.outlineOpacity : 0.35);
 return { thickness, colorHex, opacity };
 }
const focusMarker=new THREE.Mesh(new THREE.BoxGeometry(1.06,1.06,1.06),new THREE.MeshBasicMaterial({color:COLORS.focus,wireframe:true}));
const selectionCelli = createSelectionCelliHighlight();

const selectionCollapseState = {
 active: false,
 recovering: false,
 velocity: 0,
 gravity: 6.4,
 waddlePhase: 0,
 horizontalAmplitude: 0.4,
 rotationAmplitude: 0.24,
 bounceDamping: 0.58,
 minBounceVelocity: 0.18,
 settleTimer: 0,
 settleHold: 0.35,
 startPosition: null,
 startQuaternion: null,
 groundY: 0,
 currentOffset: 0,
 recoverProgress: 0,
 recoverDuration: 0.9,
 recoverStartPosition: null,
 recoverStartQuaternion: null,
 clones: [],
 clonesGroup: null,
 startRight: new THREE.Vector3(1,0,0),
 startForward: new THREE.Vector3(0,0,1),
 forwardAxis: new THREE.Vector3(0,0,1),
 queuedUpdate: null,
 waddleSpeed: 7.6
};

const selectionCollapseScratch = {
 offset: new THREE.Vector3(),
 tmp: new THREE.Vector3(),
 wobbleQuat: new THREE.Quaternion()
};

function ensureSelectionCollapseGroup(){
 if(selectionCollapseState.clonesGroup){
  const existing = selectionCollapseState.clonesGroup;
  if(scene && existing.parent !== scene){
   scene.add(existing);
  }
  return existing;
 }
 const group = new THREE.Group();
 group.name = 'SelectionCollapseGroup';
 group.visible = false;
 if(scene && group.parent !== scene){
  scene.add(group);
 }
 selectionCollapseState.clonesGroup = group;
 return group;
}

function clearSelectionCollapseClones(){
 const group = selectionCollapseState.clonesGroup;
 if(group){
  while(group.children.length){
  const child = group.children[group.children.length - 1];
  group.remove(child);
  try{ child.material?.map?.dispose?.(); }catch{}
  try{ child.material?.dispose?.(); }catch{}
  child.geometry?.dispose?.();
  }
  group.visible = false;
 }
 selectionCollapseState.clones.length = 0;
 needsRender = true;
}

function updateSelectionCelliBlink(deltaSeconds){
 if(!selectionCelli?.userData) return;
 const data = selectionCelli.userData;
 if(typeof data.updateBlink !== 'function') return;
 const changed = data.updateBlink(deltaSeconds || 0.016);
 if(changed) needsRender = true;
}

function computeCollapseHorizontalOffset(state, amplitudeFactor){
 const offset = selectionCollapseScratch.offset;
 offset.set(0,0,0);
 if(state.startRight){
 offset.addScaledVector(state.startRight, Math.sin(state.waddlePhase) * state.horizontalAmplitude * amplitudeFactor);
 }
 if(state.startForward){
 offset.addScaledVector(state.startForward, Math.sin(state.waddlePhase * 0.6) * state.horizontalAmplitude * 0.45 * amplitudeFactor);
 }
 return offset;
}

function triggerSelectionCollapse(){
 try{
 const sel = Store.getState().selection;
 if(!sel?.arrayId || !sel.range){
 showToast?.('Select multiple cells first');
 console.warn('[CELLI] Collapse requires a multi-selection');
 return;
 }
 const arr = Store.getState().arrays[sel.arrayId];
 if(!arr){
 console.warn('[CELLI] Collapse target array missing');
 return;
 }
 const focus = sel.focus || {x:0,y:0,z:0};
 const x1 = Number.isFinite(sel.range.x1) ? sel.range.x1 : (sel.range.x ?? focus.x);
 const x2 = Number.isFinite(sel.range.x2) ? sel.range.x2 : (sel.range.x ?? focus.x);
 const y1 = Number.isFinite(sel.range.y1) ? sel.range.y1 : (sel.range.y ?? focus.y);
 const y2 = Number.isFinite(sel.range.y2) ? sel.range.y2 : (sel.range.y ?? focus.y);
 const z1 = Number.isFinite(sel.range.z1) ? sel.range.z1 : (sel.range.z ?? focus.z);
 const z2 = Number.isFinite(sel.range.z2) ? sel.range.z2 : (sel.range.z ?? focus.z);

 const counts = { x: x2 - x1 + 1, y: y2 - y1 + 1, z: z2 - z1 + 1 };
 const multi = counts.x > 1 || counts.y > 1 || counts.z > 1;
 if(!multi){
 showToast?.('Select multiple cells first');
 console.warn('[CELLI] Collapse requires multi-wrap selection');
 return;
 }

 const center = {
 x: x1 + (counts.x - 1) / 2,
 y: y1 + (counts.y - 1) / 2,
 z: z1 + (counts.z - 1) / 2
 };

 const scale = arrayVoxelScale(arr);
 const faceHint = sel.faceHint ? { ...sel.faceHint } : null;

 updateSelectionCelliHighlight(arr, center, counts, scale, faceHint);

 const group = ensureSelectionCollapseGroup();
 clearSelectionCollapseClones();

 const baseGeo = new THREE.BoxGeometry(scale * 0.92, scale * 0.92, scale * 0.92);
 const clones = [];
 let minY = Infinity;
 let maxY = -Infinity;

 for(let z = z1; z <= z2; z++){
 for(let y = y1; y <= y2; y++){
 for(let x = x1; x <= x2; x++){
 const pos = worldPos(arr, x, y, z);
 if(!pos) continue;
 const cell = getCellFast(arr.id, {x,y,z}) || {};
 const hasValue = cell.value !== '' && cell.value !== null && cell.value !== undefined;
 const isFormula = !!cell.formula;
 const key = `${arr.id}:${x},${y},${z}`;
 const emitted = !!Store.getState().sourceByCell?.get?.(key);
 let colorHex = COLORS.empty;
 if(hasValue) colorHex = COLORS.filled;
 if(isFormula) colorHex = COLORS.formula;
 if(emitted) colorHex = COLORS.emitted;
 if(cell.meta?.color != null) colorHex = cell.meta.color;
 const material = new THREE.MeshStandardMaterial({
 color: new THREE.Color(colorHex),
 roughness: 0.48,
 metalness: 0.18,
 transparent: true,
 opacity: 0.92,
 depthWrite: false
 });
 material.toneMapped = false;
 const geometry = baseGeo.clone();
 const mesh = new THREE.Mesh(geometry, material);
 mesh.position.copy(pos);
 mesh.castShadow = false;
 mesh.receiveShadow = false;
 group.add(mesh);
 clones.push({
 mesh,
 startPosition: pos.clone(),
 phase: Math.random() * Math.PI * 2,
 amplitude: THREE.MathUtils.randFloat(0.12, Math.max(scale * 0.32, 0.18)),
 baseOpacity: material.opacity,
 groundY: 0
 });
 minY = Math.min(minY, pos.y);
 maxY = Math.max(maxY, pos.y);
 }
 }
 }

 baseGeo.dispose();

 if(!clones.length){
 showToast?.('No voxels to collapse');
 return;
 }

 selectionCollapseState.clones = clones;
 group.visible = true;

 const data = selectionCelli.userData || {};
 const startPos = data.basePosition ? data.basePosition.clone() : selectionCelli.position.clone();
 const startQuat = data.baseQuaternion ? data.baseQuaternion.clone() : selectionCelli.quaternion.clone();
 const rightDir = (data.rightDir ? data.rightDir.clone() : new THREE.Vector3(1,0,0));
 const forwardDir = (data.forwardDir ? data.forwardDir.clone() : new THREE.Vector3(0,0,1));

 rightDir.y = 0; if(rightDir.lengthSq() < 1e-6) rightDir.set(1,0,0); rightDir.normalize();
 forwardDir.y = 0; if(forwardDir.lengthSq() < 1e-6){ forwardDir.set(-rightDir.z, 0, rightDir.x); } forwardDir.normalize();

 selectionCollapseState.startPosition = startPos;
 selectionCollapseState.startQuaternion = startQuat;
 selectionCollapseState.startRight = rightDir;
 selectionCollapseState.startForward = forwardDir;
 selectionCollapseState.forwardAxis = new THREE.Vector3(0,0,1).applyQuaternion(startQuat).normalize();
 selectionCollapseState.horizontalAmplitude = Math.max(scale * 0.45, Math.min(counts.x + counts.z, 6) * scale * 0.12);
 selectionCollapseState.rotationAmplitude = 0.2 + Math.min(0.35, counts.x * 0.04 + counts.y * 0.03);
 selectionCollapseState.gravity = 5.8 + counts.y * 0.6;
 selectionCollapseState.waddleSpeed = 6.6 + Math.min(8, counts.x + counts.z) * 0.6;
 selectionCollapseState.minBounceVelocity = 0.16 + counts.y * 0.05;
 selectionCollapseState.velocity = 0;
 selectionCollapseState.currentOffset = 0;
 selectionCollapseState.settleTimer = 0;
 selectionCollapseState.recoverProgress = 0;
 selectionCollapseState.queuedUpdate = null;

 const dropDistance = Math.max(scale * (counts.y + 0.8), scale * 1.2);
 const computedGround = startPos.y - dropDistance;
 selectionCollapseState.groundY = Math.min(computedGround, minY - scale * 0.4);

 clones.forEach(entry=>{
 entry.groundY = entry.startPosition.y - (startPos.y - selectionCollapseState.groundY);
 });

 selectionCollapseState.active = true;
 selectionCollapseState.recovering = false;
 selectionCollapseState.waddlePhase = 0;
 selectionCollapseState.clonesGroup = group;
 selectionCelli.userData.collapseActive = true;
 selectionCelli.visible = true;
 selectionCelli.userData.applyBlink?.(0);

 needsRender = true;
 showToast?.('Multi-wrap collapse engaged');
 }catch(err){
 console.warn('[CELLI] Failed to trigger collapse', err);
 }
}

function updateCollapseClones(state, sharedOffset, amplitudeFactor){
 const tmp = selectionCollapseScratch.tmp;
 state.clones.forEach(entry=>{
 const mesh = entry.mesh;
 tmp.copy(sharedOffset);
 if(state.startRight){
 tmp.addScaledVector(state.startRight, Math.sin(state.waddlePhase + entry.phase) * entry.amplitude * 0.35 * amplitudeFactor);
 }
 if(state.startForward){
 tmp.addScaledVector(state.startForward, Math.sin(state.waddlePhase * 0.8 + entry.phase * 0.6) * entry.amplitude * 0.25 * amplitudeFactor);
 }
 const target = entry.startPosition.clone().add(tmp);
 const candidateY = entry.startPosition.y - state.currentOffset;
 const floorY = entry.groundY;
 target.y = candidateY < floorY ? floorY : candidateY;
 mesh.position.copy(target);
 mesh.rotation.x = Math.sin(state.waddlePhase + entry.phase) * 0.35 * amplitudeFactor;
 mesh.rotation.z = Math.sin(state.waddlePhase * 0.75 + entry.phase * 0.4) * 0.25 * amplitudeFactor;
 if(mesh.material && mesh.material.transparent){
 const base = entry.baseOpacity ?? mesh.material.opacity ?? 1;
 const fade = target.y <= floorY + 0.001 ? 0.85 : 1;
 mesh.material.opacity = THREE.MathUtils.clamp(base * fade, 0, 1);
 }
 });
 if(selectionCollapseState.clonesGroup){
 selectionCollapseState.clonesGroup.visible = true;
 }
}

function updateSelectionCollapse(deltaSeconds){
 const state = selectionCollapseState;
 if(!state.active && !state.recovering) return;
 if(!selectionCelli){
 clearSelectionCollapseClones();
 state.active = false;
 state.recovering = false;
 return;
 }
 const dt = deltaSeconds || 0.016;
 if(state.active){
 state.velocity += state.gravity * dt;
 state.currentOffset += state.velocity * dt;
 state.waddlePhase += state.waddleSpeed * dt;
 const amplitudeFactor = Math.min(1, 0.3 + Math.abs(state.velocity) * 0.18);
 let newY = (state.startPosition?.y ?? selectionCelli.position.y) - state.currentOffset;
 if(newY <= state.groundY){
 newY = state.groundY;
 state.currentOffset = (state.startPosition?.y ?? selectionCelli.position.y) - state.groundY;
 state.velocity = -state.velocity * state.bounceDamping;
 if(Math.abs(state.velocity) < state.minBounceVelocity){
 state.velocity = 0;
 state.settleTimer += dt;
 if(state.settleTimer >= state.settleHold){
 state.settleTimer = 0;
 state.active = false;
 state.recovering = true;
 state.recoverProgress = 0;
 state.recoverStartPosition = selectionCelli.position.clone();
 state.recoverStartQuaternion = selectionCelli.quaternion.clone();
 }
 } else {
 state.settleTimer = 0;
 }
 }
 const offset = computeCollapseHorizontalOffset(state, amplitudeFactor);
 const basePos = state.startPosition ? state.startPosition.clone() : selectionCelli.position.clone();
 basePos.add(offset);
 basePos.y = newY;
 selectionCelli.position.copy(basePos);
 if(state.startQuaternion){
 const wobbleQuat = selectionCollapseScratch.wobbleQuat;
 wobbleQuat.setFromAxisAngle(state.forwardAxis, Math.sin(state.waddlePhase) * state.rotationAmplitude * amplitudeFactor);
 selectionCelli.quaternion.copy(state.startQuaternion).multiply(wobbleQuat);
 }
 updateCollapseClones(state, offset, amplitudeFactor);
 needsRender = true;
 } else if(state.recovering){
 state.recoverProgress += dt / Math.max(0.001, state.recoverDuration);
 const t = Math.min(1, state.recoverProgress);
 const eased = 1 - Math.pow(1 - t, 3);
 if(state.recoverStartPosition && state.startPosition){
 selectionCelli.position.lerpVectors(state.recoverStartPosition, state.startPosition, eased);
 }
 if(state.recoverStartQuaternion && state.startQuaternion){
 selectionCelli.quaternion.copy(state.recoverStartQuaternion).slerp(state.startQuaternion, eased);
 }
 selectionCollapseState.clones.forEach(entry=>{
 const mesh = entry.mesh;
 mesh.position.lerpVectors(mesh.position, entry.startPosition, eased);
 mesh.rotation.x *= (1 - eased);
 mesh.rotation.z *= (1 - eased);
 if(mesh.material && mesh.material.transparent){
 mesh.material.opacity = THREE.MathUtils.lerp(entry.baseOpacity ?? mesh.material.opacity ?? 1, 0, eased);
 }
 });
 if(selectionCollapseState.clonesGroup){
 selectionCollapseState.clonesGroup.visible = selectionCollapseState.clones.length > 0 && eased < 1;
 }
 if(t >= 1){
 clearSelectionCollapseClones();
 state.recovering = false;
 state.active = false;
 state.startPosition = null;
 state.startQuaternion = null;
 selectionCelli.userData.collapseActive = false;
 if(state.queuedUpdate){
 const pending = state.queuedUpdate;
 const arr = Store.getState().arrays[pending.arrId];
 if(arr){
 const rescale = arrayVoxelScale(arr);
 updateSelectionCelliHighlight(arr, pending.center, pending.counts, rescale, pending.faceHint);
 }
 state.queuedUpdate = null;
 }
 }
 needsRender = true;
 }
}

function createSelectionCelliHighlight(){
 const group = new THREE.Group();
 group.name = 'SelectionCelliHighlight';

 const MAT_BODY = new THREE.MeshBasicMaterial({ color: 0xf59e0b, transparent: true, opacity: 0.92 });
 const MAT_MOUTH = new THREE.MeshBasicMaterial({ color: 0x111827, transparent: true, opacity: 0.95, side: THREE.DoubleSide });
 const MAT_EYE = new THREE.MeshBasicMaterial({ color: 0x111827, transparent: false });
 const MAT_CHEEK = new THREE.MeshBasicMaterial({ color: 0xec4899, transparent: true, opacity: 0.9 });
 const MAT_BOW = new THREE.MeshBasicMaterial({ color: 0xfbbf24, transparent: true, opacity: 0.92, side: THREE.DoubleSide });
 MAT_BODY.toneMapped = false;
 MAT_MOUTH.toneMapped = false;
 MAT_EYE.toneMapped = false;
 MAT_CHEEK.toneMapped = false;
 MAT_BOW.toneMapped = false;

 const bodyFrame = new THREE.Mesh(new THREE.BufferGeometry(), MAT_BODY);
 bodyFrame.material.side = THREE.DoubleSide;
 bodyFrame.name = 'CelliBodyFrame';
 group.add(bodyFrame);

 const mouthFrame = new THREE.Mesh(new THREE.BufferGeometry(), MAT_MOUTH);
 mouthFrame.name = 'CelliMouthFrame';
 group.add(mouthFrame);

 const eyeGeo = new THREE.CircleGeometry(0.12, 24);
 const eyeLeft = new THREE.Mesh(eyeGeo, MAT_EYE);
 const eyeRight = eyeLeft.clone();
 eyeLeft.name = 'CelliEyeLeft';
 eyeRight.name = 'CelliEyeRight';
 group.add(eyeLeft, eyeRight);

 const cheekGeo = new THREE.CircleGeometry(0.16, 24);
 const cheekLeft = new THREE.Mesh(cheekGeo, MAT_CHEEK);
 const cheekRight = cheekLeft.clone();
 cheekLeft.name = 'CelliCheekLeft';
 cheekRight.name = 'CelliCheekRight';
 group.add(cheekLeft, cheekRight);

 const bowGroup = new THREE.Group();
 bowGroup.name = 'CelliBow';
 const bowWingGeo = new THREE.ShapeGeometry(new THREE.Shape([
  new THREE.Vector2(0.18,0),
  new THREE.Vector2(-0.1,0.18),
  new THREE.Vector2(-0.1,-0.18)
 ]));
 const bowWingLeft = new THREE.Mesh(bowWingGeo, MAT_BOW);
 bowWingLeft.position.set(-0.12, 0, 0);
 const bowWingRight = bowWingLeft.clone();
 bowWingRight.scale.x = -1;
 bowWingRight.position.set(0.12, 0, 0);
 const bowKnot = new THREE.Mesh(new THREE.CircleGeometry(0.08, 20), MAT_BOW);
 bowKnot.position.set(0,0,0.005);
 bowGroup.add(bowWingLeft, bowWingRight, bowKnot);
 group.add(bowGroup);

 const eyes = [eyeLeft, eyeRight];
 const blinkState = {
 countdown: THREE.MathUtils.randFloat(2.6, 5.4),
 minDelay: 2.6,
 maxDelay: 5.4,
 blinkDuration: 0.18,
 minScale: 0.2,
 progress: 0,
 blinking: false,
 baseScales: eyes.map(eye => eye.scale.y)
 };

 const applyBlinkAmount = (amount = 0)=>{
 eyes.forEach((eye, index)=>{
 const base = blinkState.baseScales[index] ?? 1;
 eye.scale.y = THREE.MathUtils.lerp(base, base * blinkState.minScale, amount);
 });
 };

 const resetBlink = ()=>{
 blinkState.countdown = THREE.MathUtils.randFloat(blinkState.minDelay, blinkState.maxDelay);
 blinkState.progress = 0;
 blinkState.blinking = false;
 blinkState.baseScales = eyes.map(eye => eye.scale.y);
 applyBlinkAmount(0);
 };

 const updateBlink = (delta = 0.016)=>{
 if(!blinkState) return;
 if(blinkState.blinking){
 blinkState.progress += delta / blinkState.blinkDuration;
 const progress = Math.min(blinkState.progress, 1);
 const amount = Math.sin(progress * Math.PI);
 applyBlinkAmount(amount);
 if(progress >= 1){
 blinkState.blinking = false;
 blinkState.progress = 0;
 }
 return true;
 }
 blinkState.countdown -= delta;
 if(blinkState.countdown <= 0){
 blinkState.blinking = true;
 blinkState.progress = 0;
 blinkState.countdown = THREE.MathUtils.randFloat(blinkState.minDelay, blinkState.maxDelay);
 }
 applyBlinkAmount(0);
 return false;
 };

 applyBlinkAmount(0);

 group.userData = {
 bodyFrame,
 mouthFrame,
 eyeLeft,
 eyeRight,
 cheekLeft,
 cheekRight,
 bowGroup,
 eyes,
 blinkState,
 applyBlink: applyBlinkAmount,
 updateBlink,
 resetBlink,
 lastSignature: null,
 stretchState: null,
 lastStretchSignature: null,
 collapseActive: false,
 basePosition: new THREE.Vector3(),
 baseQuaternion: new THREE.Quaternion(),
 rightDir: new THREE.Vector3(1,0,0),
 forwardDir: new THREE.Vector3(0,0,1)
 };

 return group;
}

function startSelectionCelliStretch(counts, center){
 if(!selectionCelli) return;
 if(selectionCollapseState.active || selectionCollapseState.recovering) return;
 const data = selectionCelli.userData || {};
 const signature = `${counts.x||1}:${counts.y||1}:${counts.z||1}:${Math.round((center?.x||0)*10)}:${Math.round((center?.y||0)*10)}:${Math.round((center?.z||0)*10)}`;
 if(data.lastStretchSignature === signature) return;
 const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
 const from = new THREE.Vector3(
 (counts.x||1) > 1 ? 0.4 : 1,
 (counts.y||1) > 1 ? 0.4 : 1,
 (counts.z||1) > 1 ? 0.7 : 1
 );
 const to = new THREE.Vector3(1,1,1);
 data.stretchState = { start: now, duration: 320, from, to };
 data.lastStretchSignature = signature;
 selectionCelli.userData = data;
 selectionCelli.scale.copy(from);
 needsRender = true;
 }

 function drawRoundedRectPath(path, width, height, radius){
 const hw = width / 2;
 const hh = height / 2;
 const r = Math.min(radius, hw, hh);
 path.moveTo(-hw + r, -hh);
 path.lineTo(hw - r, -hh);
 path.quadraticCurveTo(hw, -hh, hw, -hh + r);
 path.lineTo(hw, hh - r);
 path.quadraticCurveTo(hw, hh, hw - r, hh);
 path.lineTo(-hw + r, hh);
 path.quadraticCurveTo(-hw, hh, -hw, hh - r);
 path.lineTo(-hw, -hh + r);
 path.quadraticCurveTo(-hw, -hh, -hw + r, -hh);
 path.closePath();
 }

 function createRoundedFrameGeometry({ outerWidth, outerHeight, innerWidth, innerHeight, outerRadius, innerRadius, depth }){
 const shape = new THREE.Shape();
 drawRoundedRectPath(shape, outerWidth, outerHeight, outerRadius);
 const hole = new THREE.Path();
 drawRoundedRectPath(hole, innerWidth, innerHeight, innerRadius);
 shape.holes.push(hole);
 const geo = new THREE.ExtrudeGeometry(shape, { depth, bevelEnabled:false, steps:1 });
 geo.center();
 return geo;
 }

 function planeAxesForFace(axis){
 // Returns which axes form the plane perpendicular to the given axis
 // horizontal and vertical are the two axes that span the visible face
 if(axis===0) return {horizontal:2, vertical:1}; // X face: Z is horizontal, Y is vertical
 if(axis===1) return {horizontal:0, vertical:2}; // Y face (top/bottom): X is horizontal, Z is vertical
 return {horizontal:0, vertical:1}; // Z face (front/back): X is horizontal, Y is vertical
 }

function updateSelectionCelliHighlight(arr, center, counts, scale, faceHint){
 if(!selectionCelli || !arr) return;
 const data = selectionCelli.userData || {};
 if(!data.bodyFrame || !data.mouthFrame) return;
 if(selectionCollapseState.active || selectionCollapseState.recovering){
 selectionCollapseState.queuedUpdate = {
 arrId: arr.id,
 center: { x: center?.x ?? 0, y: center?.y ?? 0, z: center?.z ?? 0 },
 counts: { x: counts?.x ?? 1, y: counts?.y ?? 1, z: counts?.z ?? 1 },
 faceHint: faceHint ? { ...faceHint } : null
 };
 return;
 }

 const axisKeys = ['x','y','z'];
 let axis = null;
 let sign = null;
 if(faceHint){
 if(Number.isInteger(faceHint.axisIndex)){
 axis = Math.max(0, Math.min(2, faceHint.axisIndex|0));
 } else if(faceHint.axis && axisKeys.includes(faceHint.axis)){
 axis = axisKeys.indexOf(faceHint.axis);
 }
 const hintedSign = Number(faceHint.sign);
 if(Number.isFinite(hintedSign) && hintedSign !== 0){
 sign = hintedSign > 0 ? 1 : -1;
 }
 }
 if(axis===null || sign===null){
 const facing = facingFromCamera(arr._frame || { matrixWorld:new THREE.Matrix4() });
 if(axis===null) axis = Number.isFinite(facing.axis) ? facing.axis : 2;
 if(sign===null) sign = (facing.sign===0) ? 1 : (facing.sign||1);
 }

 const planeAxes = planeAxesForFace(axis);
 const axisKey = axisKeys[axis];
 const horizontalCount = counts[axisKeys[planeAxes.horizontal]] || 1;
 const verticalCount = counts[axisKeys[planeAxes.vertical]] || 1;
 const depthCount = Math.max(1, counts[axisKey] || 1);

 // Calculate dimensions to cover the full visible extent of selection
 // Width and height should match the actual cell counts in those directions
 const cellWidth = horizontalCount * scale;
 const cellHeight = verticalCount * scale;
 
 console.log(`[CELLI] Border sizing: axis=${axis} (${axisKey}), horizontal=${axisKeys[planeAxes.horizontal]}:${horizontalCount}, vertical=${axisKeys[planeAxes.vertical]}:${verticalCount}, depth=${axisKey}:${depthCount}, w=${cellWidth.toFixed(2)}, h=${cellHeight.toFixed(2)}`);
 const cellDepth = Math.max(scale, scale * 0.9);
 const pad = Math.max(scale * 0.08, 0.06);
 const bodyBorder = Math.max(scale * 0.22, Math.min(cellWidth, cellHeight) * 0.09);
 const mouthBorder = Math.max(scale * 0.10, Math.min(cellWidth, cellHeight) * 0.05);

 const innerWidth = cellWidth + pad * 2;
 const innerHeight = cellHeight + pad * 2;
 const mouthOuterWidth = innerWidth + mouthBorder * 2;
 const mouthOuterHeight = innerHeight + mouthBorder * 2;
 const outerWidth = mouthOuterWidth + bodyBorder * 2;
 const outerHeight = mouthOuterHeight + bodyBorder * 2;

 // Frame depth should cover the entire selection depth
 const thicknessBase = Math.max(depthCount * scale, 1.05);
 const depth = thicknessBase;
 const bodyDepth = depth;
 const mouthDepth = Math.max(thicknessBase * 0.58, 0.62);

 const radiusRatio = 0.12;
 const outerRadius = Math.min(outerWidth, outerHeight) * radiusRatio;
 const mouthOuterRadius = Math.min(mouthOuterWidth, mouthOuterHeight) * radiusRatio;
 const mouthInnerRadius = Math.min(innerWidth, innerHeight) * (radiusRatio * 0.85);

 data.bodyFrame.geometry?.dispose?.();
 data.bodyFrame.geometry = createRoundedFrameGeometry({
 outerWidth,
 outerHeight,
 innerWidth: mouthOuterWidth,
 innerHeight: mouthOuterHeight,
 outerRadius,
 innerRadius: mouthOuterRadius,
 depth: bodyDepth
 });
 data.bodyFrame.position.set(0,0,0);

 data.mouthFrame.geometry?.dispose?.();
 data.mouthFrame.geometry = createRoundedFrameGeometry({
 outerWidth: mouthOuterWidth,
 outerHeight: mouthOuterHeight,
 innerWidth,
 innerHeight,
 outerRadius: mouthOuterRadius,
 innerRadius: mouthInnerRadius,
 depth: mouthDepth
 });
 data.mouthFrame.position.set(0,0,(bodyDepth - mouthDepth)/2);

 const faceZ = bodyDepth/2 + 0.02;
 const totalWidth = innerWidth;
 const totalHeight = innerHeight;
 const halfWidth = totalWidth / 2;
 const halfHeight = totalHeight / 2;
 const featureSpan = Math.min(innerWidth, innerHeight);

 const eyeSpacing = Math.min(halfWidth - scale * 0.02, totalWidth * (0.12 / 0.8));
 const eyeHeight = Math.min(halfHeight - scale * 0.02, totalHeight * (0.13 / 0.8));
 const eyeScale = Math.max(0.85, Math.min(1.3, featureSpan * 0.32));
 data.eyeLeft.scale.set(eyeScale, eyeScale, 1);
 data.eyeRight.scale.copy(data.eyeLeft.scale);
 data.eyeLeft.position.set(-eyeSpacing, eyeHeight, faceZ);
 data.eyeRight.position.set(eyeSpacing, eyeHeight, faceZ);

 const cheekSpacing = Math.min(halfWidth - scale * 0.015, totalWidth * (0.25 / 0.8));
 const cheekHeight = -Math.min(halfHeight - scale * 0.015, totalHeight * (0.08 / 0.8));
 const cheekScale = Math.max(0.9, Math.min(1.35, featureSpan * 0.34));
 data.cheekLeft.scale.set(cheekScale, cheekScale, 1);
 data.cheekRight.scale.copy(data.cheekLeft.scale);
 data.cheekLeft.position.set(-cheekSpacing, cheekHeight, faceZ - 0.01);
 data.cheekRight.position.set(cheekSpacing, cheekHeight, faceZ - 0.01);

 const bowHeight = outerHeight/2 + Math.max(scale * 0.16, 0.22);
 const bowScale = Math.max(0.6, Math.min(1.45, outerWidth / 3.4));
 data.bowGroup.position.set(0, bowHeight, bodyDepth/2 - mouthDepth/2 + 0.04);
 data.bowGroup.rotation.x = -0.25;
 data.bowGroup.scale.setScalar(bowScale);

 startSelectionCelliStretch(counts, center);

 const frameQuat = arr._frame ? arr._frame.getWorldQuaternion(new THREE.Quaternion()) : new THREE.Quaternion();
 const basisX = new THREE.Vector3(1,0,0).applyQuaternion(frameQuat);
 const basisY = new THREE.Vector3(0,1,0).applyQuaternion(frameQuat);
 const basisZ = new THREE.Vector3(0,0,1).applyQuaternion(frameQuat);
 const bases = [basisX, basisY, basisZ];

 // Forward points out from the face (toward camera)
 const forward = bases[axis].clone().multiplyScalar(sign).normalize();
 
 // Build right and up vectors that align with the cell grid
 // Use world coordinates and project onto the plane perpendicular to forward
 const worldRight = new THREE.Vector3();
 const worldUp = new THREE.Vector3();
 
 // Choose right and up based on which axis we're facing
 if(axis === 0){ // X face
 worldRight.copy(bases[2]); // Z axis 
 worldUp.copy(bases[1]); // Y axis
 } else if(axis === 1){ // Y face 
 worldRight.copy(bases[0]); // X axis
 worldUp.copy(bases[2]); // Z axis
 // When looking from below, flip up to keep Celli upright
 if(sign < 0) worldUp.multiplyScalar(-1);
 } else { // Z face
 worldRight.copy(bases[0]); // X axis
 worldUp.copy(bases[1]); // Y axis
 // When looking from back (negative Z), flip up to keep Celli upright
 if(sign < 0) worldUp.multiplyScalar(-1);
 }
 
 console.log(`[CELLI] Border: axis=${axis} (${axisKey}), sign=${sign}, counts=(${counts.x},${counts.y},${counts.z}), h=${horizontalCount}, v=${verticalCount}, d=${depthCount}`);
 console.log(`[CELLI] Vectors: fwd=(${forward.x.toFixed(2)},${forward.y.toFixed(2)},${forward.z.toFixed(2)}), right=(${worldRight.x.toFixed(2)},${worldRight.y.toFixed(2)},${worldRight.z.toFixed(2)}), up=(${worldUp.x.toFixed(2)},${worldUp.y.toFixed(2)},${worldUp.z.toFixed(2)})`);

 // Position the border to span the entire selection depth
 // The border mesh has depth equal to the selection depth
 // Position it at the selection center so it covers from back edge to front edge
 const pos = worldPos(arr, center.x, center.y, center.z);
 // Offset slightly toward camera so border front face appears in front
 const offsetTowardCamera = forward.clone().multiplyScalar(0.02);
 const adjustedPos = pos.clone().add(offsetTowardCamera);
 selectionCelli.position.copy(adjustedPos);

 // Snap rotation to align with the viewing axis
 const rotMatrix = new THREE.Matrix4().makeBasis(worldRight, worldUp, forward);
 selectionCelli.rotation.setFromRotationMatrix(rotMatrix);

 const horizontalRight = worldRight.clone();
 horizontalRight.y = 0;
 if(horizontalRight.lengthSq() < 1e-6) horizontalRight.set(1,0,0);
 horizontalRight.normalize();

 const horizontalForward = forward.clone();
 horizontalForward.y = 0;
 if(horizontalForward.lengthSq() < 1e-6){
 horizontalForward.set(-horizontalRight.z, 0, horizontalRight.x);
 }
 horizontalForward.normalize();

 if(data){
 data.basePosition = adjustedPos.clone();
 data.baseQuaternion = selectionCelli.quaternion.clone();
 if(!data.rightDir) data.rightDir = new THREE.Vector3();
 if(!data.forwardDir) data.forwardDir = new THREE.Vector3();
 data.rightDir.copy(horizontalRight);
 data.forwardDir.copy(horizontalForward);
 if(data.blinkState){
  data.blinkState.baseScales = [data.eyeLeft.scale.y, data.eyeRight.scale.y];
 }
 if(typeof data.applyBlink === 'function'){
  data.applyBlink(0);
 }
 if(typeof data.resetBlink === 'function'){
  data.resetBlink();
 }
}

 if(!selectionCollapseState.active && !selectionCollapseState.recovering){
 selectionCollapseState.startPosition = adjustedPos.clone();
 selectionCollapseState.startQuaternion = selectionCelli.quaternion.clone();
 selectionCollapseState.startRight = horizontalRight.clone();
 selectionCollapseState.startForward = horizontalForward.clone();
 selectionCollapseState.forwardAxis = forward.clone().normalize();
 }

 selectionCelli.userData.collapseActive = selectionCollapseState.active || selectionCollapseState.recovering;

 selectionCelli.visible = true;
 selectionCelli.userData.lastSignature = `${arr.id}:${center.x},${center.y},${center.z}:${counts.x},${counts.y},${counts.z}:${axis}:${sign}`;
 
 console.log(`[CELLI] Border placed: pos=(${adjustedPos.x.toFixed(2)},${adjustedPos.y.toFixed(2)},${adjustedPos.z.toFixed(2)}), axis=${axis}, sign=${sign}, visible=${selectionCelli.visible}`);

 if(selectionCollapseState.clonesGroup && !selectionCollapseState.active && !selectionCollapseState.recovering){
  selectionCollapseState.clonesGroup.visible = false;
 }

 needsRender = true;
 }
 
 // Singleton geometries and materials for performance
 const GEO_VOXEL = new RoundedBoxGeometry(0.9, 0.9, 0.9, 2, 0.1);
 const SHELL_SCALE = 1.08; // shells slightly larger than fills
 const GEO_SHELL = new RoundedBoxGeometry(0.9*SHELL_SCALE, 0.9*SHELL_SCALE, 0.9*SHELL_SCALE, 2, 0.1);
 function addWhiteVertexColors(geo){
 try{
 const n = geo.getAttribute('position')?.count|0;
 if(!geo.getAttribute('color') && n>0){ const arr = new Float32Array(n*3); arr.fill(1.0); geo.setAttribute('color', new THREE.BufferAttribute(arr, 3)); }
 }catch{}
 }
 addWhiteVertexColors(GEO_VOXEL);
 addWhiteVertexColors(GEO_SHELL);
 const cellMaterialCache = new Map();
 function materialKeyFor(type){
 const base = String(type||'').startsWith('ghost') ? 'ghost' : String(type||'filled');
 const mode = FancyGraphics.enabled ? 'present' : 'simple';
 const frosted = FancyGraphics.enabled && FancyGraphics.settings.transmission ? 'frosted' : 'solid';
 return `${mode}:${frosted}:${base}`;
 }
 function createCellMaterial(type='filled'){
 const baseType = String(type||'').startsWith('ghost') ? 'ghost' : String(type||'filled');
 const key = materialKeyFor(baseType);
 if(cellMaterialCache.has(key)) return cellMaterialCache.get(key);

 let material;
 if(baseType === 'ghost'){
 if(FancyGraphics.enabled){
 material = new THREE.MeshPhysicalMaterial({
 color: new THREE.Color(0xffffff),
 vertexColors: true,
 transparent: true,
 opacity: 0.28,
 depthWrite: false,
 depthTest: true,
 roughness: 0.85,
 metalness: 0.05,
 envMapIntensity: 0.35,
 transmission: 0.0,
 clearcoat: 0.0
 });
 material.blending = THREE.NormalBlending;
 material.toneMapped = true;
 }else{
 // Standard mode: use unlit BasicMaterial for ghost
 material = new THREE.MeshBasicMaterial({
 color: 0xffffff,
 transparent: true,
 opacity: 0.35,
 blending: THREE.NormalBlending,
 depthWrite: false,
 depthTest: true,
 vertexColors: true
 });
 material.toneMapped = false;
 }
 }else{
 if(FancyGraphics.enabled){
 const frosted = !!FancyGraphics.settings.transmission;
 const params = {
 color: new THREE.Color(0xffffff),
 vertexColors: true,
 roughness: frosted ? 0.78 : 0.32,
 metalness: frosted ? 0.06 : 0.22,
 envMapIntensity: frosted ? 1.3 : 1.2,
 clearcoat: 0.35,
 clearcoatRoughness: frosted ? 0.55 : 0.2,
 reflectivity: 0.5,
 depthWrite: true,
 depthTest: true
 };
 if(frosted){
 Object.assign(params, {
 transparent: true,
 opacity: 0.9,
 transmission: 0.58,
 thickness: 1.4,
 ior: 1.18,
 attenuationColor: new THREE.Color(0xcfe3ff),
 attenuationDistance: 1.25
 });
 }else{
 Object.assign(params, {
 transparent: false,
 transmission: 0.0
 });
 }
 material = new THREE.MeshPhysicalMaterial(params);
 material.toneMapped = true;
 }else{
 // Standard mode: use unlit BasicMaterial for flat appearance
 const isEmpty = (baseType === 'empty');
 material = new THREE.MeshBasicMaterial({
 color: isEmpty ? COLORS.empty : 0xffffff,
 transparent: false,
 depthWrite: true,
 vertexColors: true
 });
 material.toneMapped = false;
 }
 }

 material.userData = { ...(material.userData||{}), pass: baseType === 'ghost' ? 'ghost' : 'solid' };
 cellMaterialCache.set(key, material);
 return material;
 }

 function rebuildCellMaterialRefs(){
 try{
 const arrays = Store.getState().arrays || {};
 Object.values(arrays).forEach(arr=>{
 const collected = new Set();
 Object.values(arr.chunks||{}).forEach(ch=>{
 if(ch?.meshLOD1?.material) collected.add(ch.meshLOD1.material);
 if(ch?.meshGhost?.material) collected.add(ch.meshGhost.material);
 });
 arr._cellMaterials = Array.from(collected);
 });
 }catch{}
 }

 function refreshCellMaterials(){
 try{
 const visited = new Set();
 const oldMaterials = new Set();
 cellMaterialCache.clear();

 const assign = (mesh, type)=>{
 if(!mesh || visited.has(mesh.uuid)) return;
 visited.add(mesh.uuid);
 if(mesh.material) oldMaterials.add(mesh.material);
 mesh.material = createCellMaterial(type);
 mesh.material.needsUpdate = true;
 };

 try{
 Object.values(Store.getState().arrays||{}).forEach(arr=>{
 Object.values(arr.chunks||{}).forEach(ch=>{
 assign(ch.meshLOD1, 'filled');
 assign(ch.meshGhost, 'ghost');
 if(ch.meshLOD2) assign(ch.meshLOD2, 'filled');
 });
 });
 }catch{}

 try{
 layerMeshes.forEach(rec=>{
 const mesh = rec?.mesh;
 if(!mesh) return;
 if(mesh.userData?.isGhost) return;
 const base = mesh.userData?.type || 'filled';
 const want = String(base).startsWith('ghost') ? 'ghost' : base;
 assign(mesh, want);
 });
 }catch{}
 try{ chunkMeshes.forEach(mesh=> assign(mesh, 'filled')); }catch{}

 oldMaterials.forEach(mat=>{ try{ mat?.dispose?.(); }catch{} });
 rebuildCellMaterialRefs();
 updateShellVisibilityGlobal();
 needsRender = true;
 }catch(e){ console.warn('refreshCellMaterials failed', e); }
 }
 
 // Debounced collider rebuilds
 const colliderRebuildQueue = new Map(); // arrayId -> timeout
 
 // Animation and physics guards
 let isAnimating = false;
 let physicsStepping = false;
 let __rafId = 0, __animating = false;
 // Value sprites for per-cell text labels (declared earlier in Scene scope)
 function startLoop(){ if(__animating) return; __animating = true; __rafId = requestAnimationFrame(animate); }
 function stopLoop(){ if(!__animating) return; cancelAnimationFrame(__rafId); __animating = false; }
 // Global map for value label sprites (persist across rebuilds)
 window.valueSprites = window.valueSprites || new Map();
 const valueSprites = window.valueSprites;
 window.cellLights = window.cellLights || new Map();
 const cellLights = window.cellLights;
 window.cellLightTargets = window.cellLightTargets || new Map();
 const cellLightTargets = window.cellLightTargets;
 const LIGHT_GLOW_GEOMETRY = new THREE.SphereGeometry(0.42, 20, 20);
 let lastCamSig = '';
 const SPRITE_FACE_OFFSET = 0.58; // push label fully outside cell face (avoid z-fight/inside look)
 function axisCharToNum(ch){ return ch==='X'?0 : ch==='Y'?1 : 2; }
 function getPreferredFacing(arr){
 // Prefer occlusion axis for consistency with d-pad/occlusion; fallback to camera-facing state
 let axisNum = null;
 const selection = Store.getState().selection;
 const oc = (selection?.arrayId === arr?.id) ? (arr?._occlusionData || {}) : null;
 if(oc && (oc.facing || oc.axis)){
 const ch = oc.facing || oc.axis; // may be 'X'|'Y'|'Z'
 if(typeof ch === 'string') axisNum = axisCharToNum(ch);
 else if(typeof ch === 'number') axisNum = ch|0;
 }
 try{ updateFacingState(arr); }catch{}
 const st = arr._facingState || {axis:(axisNum??2), sign:1};
 if(axisNum==null) axisNum = st.axis;
 const sign = (st.sign||1) >= 0 ? 1 : -1;
 return { axis: axisNum, sign };
 }
 function camSig(){ try{ const p=camera?.position||{x:0,y:0,z:0}; const t=controls?.target||{x:0,y:0,z:0}; return `${p.x.toFixed(2)},${p.y.toFixed(2)},${p.z.toFixed(2)}|${t.x.toFixed(2)},${t.y.toFixed(2)},${t.z.toFixed(2)}`; }catch{ return ''; } }
 function maybeUpdateLabels(){ const sig=camSig(); if(sig===lastCamSig) return; lastCamSig=sig; try{ const arrays=Object.values(Store.getState().arrays); for(const arr of arrays){ if(!arr.hidden && arr._frame){ updateArrayLabelPlacement(arr); updateArrayValueSpritePlacement(arr); } } }catch{} }
 // Reposition value sprites on camera-facing changes as well, per array
 function updateArrayValueSpritePlacement(arr){
 try{
 if(!arr || !arr._frame) return;
 // Use the same face as occlusion/arrow mapping for consistency
 const face = getPreferredFacing(arr);
 const scale = arrayVoxelScale(arr);
 const cellScale = voxelDisplayScale(scale);
 const sign = face.sign;
 const offsetBase = SPRITE_FACE_OFFSET * scale;
 const faceOffset = offsetBase * sign;
 // Iterate value sprites for this array only
 valueSprites.forEach((sprite, key)=>{
 if(!String(key).startsWith(`${arr.id}:`)) return;
 const parts = String(key).split(':'); const coords = parts[1]||'';
 const [sx, sy, sz] = coords.split(',').map(Number);
 const base = localPos(arr, sx, sy, sz);
 let dx=0, dy=0, dz=0;
 if(face.axis===2){ dz = faceOffset; }
 else if(face.axis===0){ dx = faceOffset; }
 else { dy = faceOffset; }
 sprite.position.set(base.x+dx, base.y+dy, base.z+dz);
 // Ensure sprite is visible when repositioned; occlusion masking will hide if blocked
 sprite.visible = true;
 });
 }catch{}
 }

 function lightKey(ref){ if(!ref) return ''; return `${ref.arrId}:${ref.x},${ref.y},${ref.z}`; }
 function untrackLightTarget(key, targetRef){
 if(!targetRef) return;
 const set = cellLightTargets.get(targetRef.arrId);
 if(set){ set.delete(key); if(set.size===0) cellLightTargets.delete(targetRef.arrId); }
 }
 function trackLightTarget(key, targetRef){
 if(!targetRef) return;
 let set = cellLightTargets.get(targetRef.arrId);
 if(!set){ set = new Set(); cellLightTargets.set(targetRef.arrId, set); }
 set.add(key);
 }
 function ensureLightInstance(record){
 if(!record) return;
 const wantSpot = record.config?.mode === 'spot';
 const haveSpot = !!record.light?.isSpotLight;
 if(!record.light || wantSpot !== haveSpot){
 if(record.light){ record.group.remove(record.light); }
 if(record.target){ record.group.remove(record.target); record.target = null; }
 if(wantSpot){
 const spot = new THREE.SpotLight(0xffffff, 1, 30, Math.PI/4, 0.35, 2.0);
 spot.castShadow = false;
 const target = new THREE.Object3D();
 record.group.add(spot);
 record.group.add(target);
 spot.target = target;
 record.light = spot;
 record.target = target;
 } else {
 const point = new THREE.PointLight(0xffffff, 1, 30, 2);
 point.castShadow = false;
 record.group.add(point);
 record.light = point;
 record.target = null;
 }
 }
 if(!record.glow){
 const glowMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent:true, opacity:0, depthWrite:false, depthTest:false, blending:THREE.AdditiveBlending });
 const glow = new THREE.Mesh(LIGHT_GLOW_GEOMETRY, glowMat);
 glow.renderOrder = 1998;
 record.group.add(glow);
 record.glow = glow;
 }
 }
 function attachLightToArray(record){
 if(!record) return;
 const arr = Store.getState().arrays[record.source.arrId];
 if(!arr) return;
 const local = localPos(arr, record.source.x, record.source.y, record.source.z);
 if(arr._frame){
 if(record.group.parent !== arr._frame){
 record.group.parent?.remove(record.group);
 arr._frame.add(record.group);
 }
 record.group.position.copy(local);
 } else {
 const world = cellWorldPos(arr, record.source.x, record.source.y, record.source.z);
 if(record.group.parent !== scene){
 record.group.parent?.remove(record.group);
 scene.add(record.group);
 }
 record.group.position.copy(world);
 }
 }
 function updateLightTarget(record){
 if(!record?.light?.isSpotLight) return;
 const arr = Store.getState().arrays[record.source.arrId];
 if(!arr) return;
 const originWorld = cellWorldPos(arr, record.source.x, record.source.y, record.source.z);
 let dir = new THREE.Vector3(0,-1,0);
 const targetRef = record.config?.targetRef;
 if(targetRef){
 const tgtArr = Store.getState().arrays[targetRef.arrId];
 if(tgtArr){
 const targetWorld = cellWorldPos(tgtArr, targetRef.x, targetRef.y, targetRef.z);
 dir = targetWorld.clone().sub(originWorld);
 }
 }
 if(dir.lengthSq() < 1e-6) dir.set(0,-1,0);
 dir.normalize();
 if(arr._frame){
 const inv = new THREE.Matrix3().setFromMatrix4(new THREE.Matrix4().copy(arr._frame.matrixWorld).invert());
 dir.applyMatrix3(inv).normalize();
 }
 const range = record.config?.beamLength ?? 4.5;
 if(record.target){ record.target.position.copy(dir.clone().multiplyScalar(range)); }
 }
 function updateLightProperties(record){
 if(!record?.light) return;
 const lumens = Math.max(0, Number(record.config?.lumens ?? 0));
 // Match present-mode lighting intensity (key light is 3.2, we scale from that)
 // Default 800 lumens should be ~2.0 intensity (similar to fill+rim combined)
 const intensity = lumens <= 0 ? 0 : Math.max(0.8, (lumens / 800) * 2.5);
 const distance = record.config?.distance ?? (lumens <= 0 ? 0 : Math.min(100, 15 + Math.sqrt(lumens||0) * 0.3));
 const color = record.config?.color || '#ffffff';
 try{ record.light.color.set(color); }catch{ record.light.color.set(0xffffff); }
 record.light.intensity = intensity;
 record.light.distance = distance;
 record.light.decay = 2;
 if(record.glow && record.glow.material){
 try{ record.glow.material.color.set(color); }catch{}
 // Prominent glow sphere that scales with intensity
 const scale = Math.max(0.4, 0.5 + Math.sqrt(Math.max(lumens,0)) * 0.06);
 record.glow.scale.setScalar(scale);
 record.glow.material.opacity = lumens <= 0 ? 0 : Math.min(0.9, 0.55 + Math.sqrt(lumens) * 0.03);
 record.glow.visible = lumens > 0;
 record.glow.material.needsUpdate = true;
 }
 if(record.light.isSpotLight){
 record.light.angle = record.config?.angle ?? (Math.PI/5);
 record.light.penumbra = record.config?.penumbra ?? 0.4;
 updateLightTarget(record);
 }
 }
 function removeCellLight(ref){
 const key = typeof ref === 'string' ? ref : lightKey(ref);
 if(!key) return;
 const record = cellLights.get(key);
 if(!record) return;
 if(record.config?.targetRef) untrackLightTarget(key, record.config.targetRef);
 try{ record.glow?.material?.dispose?.(); }catch{}
 try{ record.group?.parent?.remove(record.group); }catch{}
 cellLights.delete(key);
 needsRender = true;
 }
 function upsertCellLight(ref, config){
 if(!ref) return null;
 const arr = Store.getState().arrays[ref.arrId];
 if(!arr) return null;
 const key = lightKey(ref);
 if(!config || !config.enabled || (config.lumens!=null && config.lumens<=0)){
 removeCellLight(key);
 return null;
 }
 let record = cellLights.get(key);
 if(!record){
 record = { source:{...ref}, config:{}, group:new THREE.Group(), light:null, target:null };
 record.group.userData.kind = 'cellLight';
 cellLights.set(key, record);
 }
 if(record.config?.targetRef) untrackLightTarget(key, record.config.targetRef);
 record.source = {...ref};
 record.config = { ...config };
 if(config.targetRef) trackLightTarget(key, config.targetRef);
 ensureLightInstance(record);
 attachLightToArray(record);
 updateLightProperties(record);
 needsRender = true;
 return record;
 }
 function refreshLightsForArray(arrId){
 cellLights.forEach((record)=>{
 if(record.source?.arrId === arrId || record.config?.targetRef?.arrId === arrId){
 attachLightToArray(record);
 updateLightProperties(record);
 }
 });
 }
 function clearOcclusion(arr){
 try{
 if(!arr) return;
 const chunkMode = !!(Scene.ChunkManager && Scene.ChunkManager.enabled);
 delete arr._occlusionData;
 for(let z=0; z<(arr.size?.z ?? 0); z++){
 ['ghost'].forEach(type=>{
 const base=`${arr.id}:${z}:${type}`;
 const rec=layerMeshes.get(base);
 if(rec){
 if(arr._frame) arr._frame.remove(rec.mesh);
 else scene.remove(rec.mesh);
 rec.mesh.geometry.dispose?.();
 rec.mesh.material.dispose?.();
 layerMeshes.delete(base);
 }
 const ekey=`${base}:edges`;
 const er=layerMeshes.get(ekey);
 if(er){
 if(arr._frame) arr._frame.remove(er.mesh);
 else scene.remove(er.mesh);
 er.mesh.geometry.dispose?.();
 er.mesh.material.dispose?.();
 layerMeshes.delete(ekey);
 }
 });
 }
 if(chunkMode){
 try{
 Object.values(arr.chunks||{}).forEach(ch=>{
 ch.ensureMesh?.();
 ch.setLOD?.(1);
 rehydrateChunkInstances(arr, ch);
 });
 }catch{}
 }
 for(let z=0; z<(arr.size?.z ?? 0); z++){
 renderLayer(arr,z);
 }
 }catch{}
 }
 let lastFocusedArrayId = null;

 function setupRenderer(){
 renderer.outputColorSpace = THREE.SRGBColorSpace;
 renderer.toneMapping = THREE.NoToneMapping;
 renderer.toneMappingExposure = 1.0;
 renderer.shadowMap.enabled = false;
 renderer.setClearColor(0xf6f7fb, 1);
 renderer.autoClear = true;
 renderer.autoClearStencil = true;
 renderer.localClippingEnabled = true;
 }
 function updateBaseLightingVisibility(){
 if(!baseLightsGroup) return;
 const fancyLightsActive = FancyGraphics.enabled && FancyGraphics.settings.lights;
 baseLightsGroup.visible = !fancyLightsActive;
 }

 function setupLighting(){
 if(baseLightsGroup){
 try{ scene.remove(baseLightsGroup); }catch{}
 baseLightsGroup = null;
 }

 baseLightsGroup = new THREE.Group();
 baseLightsGroup.name = 'BaseLighting';

 // Three-point lighting setup (always present, independent of floor modes)
 const strength = (FancyGraphics?.settings?.lightStrength ?? 1) || 1;
 const defaults = FancyGraphics?.lightDefaults || { key: 2.8, fill: 1.4, rim: 1.0, hemi: 0.6 };
 
 // Key light (main)
 const key = new THREE.DirectionalLight(0xffffff, defaults.key * strength);
 key.position.set(-8, 14, 10);
 key.castShadow = false;
 key.shadow.mapSize.set(2048, 2048);
 key.shadow.camera.near = 0.5;
 key.shadow.camera.far = 200;
 key.shadow.camera.left = -80;
 key.shadow.camera.right = 80;
 key.shadow.camera.top = 80;
 key.shadow.camera.bottom = -80;
 key.shadow.bias = -0.0008;
 
 // Fill light
 const fill = new THREE.DirectionalLight(0xffffff, defaults.fill * strength);
 fill.position.set(10, 6, 12);
 fill.castShadow = false;
 
 // Rim/back light
 const rim = new THREE.DirectionalLight(0xffffff, defaults.rim * strength);
 rim.position.set(0, 8, -14);
 rim.castShadow = false;
 
 // Ambient and hemisphere
 const ambient = new THREE.AmbientLight(0xffffff, 0.4 * strength);
 const hemi = new THREE.HemisphereLight(0xdbeafe, 0x0f172a, defaults.hemi * strength);

 baseLightsGroup.add(key);
 baseLightsGroup.add(fill);
 baseLightsGroup.add(rim);
 baseLightsGroup.add(ambient);
 baseLightsGroup.add(hemi);

 scene.add(baseLightsGroup);
 updateBaseLightingVisibility();
 applyFancyLightingAdjustments();
 }
// Settings UI removed
async function init(canvas){
renderer=new THREE.WebGLRenderer({canvas, antialias:true, stencil:true, preserveDrawingBuffer:true});
renderer.setPixelRatio(Math.min(2,window.devicePixelRatio||1));
renderer.setSize(window.innerWidth,window.innerHeight);
 
 // Configure renderer based on mode
 setupRenderer();

 scene=new THREE.Scene();
 OceanBackdrop.init();
 try{
 const savedOcean = Store.getState().scene?.ocean;
 if(savedOcean){
 const patch = { ...savedOcean };
 delete patch.enabled;
 if(Object.keys(patch).length){ updateOceanSettings(patch); }
 if(savedOcean.enabled){ setOceanEnabled(true); }
 }
 }catch{}
 camera=new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,.1,2000);
 camera.position.set(8, 10, 14); // Higher and further for better view
 controls=new OrbitControls(camera,renderer.domElement);
 controls.target.set(0, 3, 0); // Look at array center (considering offset y:1 and height 4)
 controls.enableDamping=true;
 controls.enabled=true;
 controls.enableRotate=true;
 controls.enablePan=true;
 console.log('[INIT] Camera and controls initialized - controls.enabled:', controls.enabled);
 try{ controls.addEventListener('change', ()=>{
 try{
 const S=Store.getState(); const sel=S.selection;
 // Recompute placement for all visible arrays so sprites are always present on the facing side
 Object.values(S.arrays||{}).forEach(a=>{ if(!a.hidden && a._frame){ try{ updateArrayValueSpritePlacement(a); }catch{} } });
 if(sel?.arrayId){
 const arr=S.arrays[sel.arrayId];
 applyCutaway(arr, sel.focus);
 }
 }catch{}
 needsRender = true;
 }); }catch{}

 // Setup lighting and environment
 setupLighting();

 // Apply theme colors as CSS variables for unified styling
 try{
 const styleEl = document.createElement('style');
 const cssVars = Object.entries(COLORS)
 .map(([name, value]) => {
 const colorStr = typeof value === 'number' ? `#${value.toString(16).padStart(6, '0')}` : value;
 return `--clr-${name}: ${colorStr};`;
 })
 .join('\n');
 styleEl.textContent = `:root { ${cssVars} }`;
 document.head.appendChild(styleEl);
 }catch{}

 grid=new THREE.GridHelper(80,80,0x9aa1b5,0xe6e8ef); grid.position.y=-0.49; scene.add(grid);
 axesHelper=new THREE.AxesHelper(6); scene.add(axesHelper);

 scene.add(focusMarker); focusMarker.visible=false;
 scene.add(selectionCelli); selectionCelli.visible=false;
 ensureSelectionCollapseGroup();
 // Dependency overlay group
 depGroup = new THREE.Group(); depGroup.visible=false; depGroup.userData.kind='depGroup'; scene.add(depGroup);
 initAvatars();

 window.addEventListener('resize',()=>{
 camera.aspect=window.innerWidth/window.innerHeight;
 camera.updateProjectionMatrix();
 renderer.setSize(window.innerWidth,window.innerHeight);
 updateFancyComposerSize();
 try{ OceanBackdrop.resizePost(window.innerWidth, window.innerHeight); }catch{}
 });
 renderer.domElement.addEventListener('pointerdown', onPick);
 // 3D hover sync: highlight cell under cursor
 renderer.domElement.addEventListener('pointermove', (e)=>{
 try{
 const rect=renderer.domElement.getBoundingClientRect();
 const mouse=new THREE.Vector2(((e.clientX-rect.left)/rect.width)*2-1, -((e.clientY-rect.top)/rect.height)*2+1);
 const ray=new THREE.Raycaster(); ray.setFromCamera(mouse,camera);
 const pickMeshes=[];
 const physicsActive = !!Store.getState().scene?.physics;
 const physicsDebugActive = !!Store.getState().scene?.physicsDebugAll;
 try{ Object.values(Store.getState().arrays).forEach(a=>{ if(a.hidden) return; if(physicsActive && !physicsDebugActive && a.params?.physics?.enabled) return; Object.values(a.chunks||{}).forEach(ch=>{ if(ch?.meshLOD1 && ch.meshLOD1.visible) pickMeshes.push(ch.meshLOD1); }); }); }catch{}
 const hits=ray.intersectObjects(pickMeshes,false);
 if(hits.length){
 const h=hits[0];
 const ch=h.object?.userData?.chunk; const arr=ch?.array; const cell = ch?.index2cell?.[h.instanceId];
 if(arr && cell){ setHoverCell({arrId:arr.id, x:cell.x, y:cell.y, z:cell.z}); return; }
 }
 clearHoverCell();
 }catch{}
 });
 // Ensure double click in 3D opens editor for the focused cell as well
 renderer.domElement.addEventListener('dblclick', (e)=>{
 try{
 const s=Store.getState().selection; if(!s?.arrayId||!s.focus) return;
 // Mark last interaction as 3d to place editor properly
 Store.setState(st=>({ ui:{...st.ui, lastInteraction:'3d'} }));
 window.UI?.openEditor?.();
 }catch{}
 });
 // Arrow/WASD movement is now handled in the physics loop to avoid aliasing
 // This old handler is disabled to prevent Rapier conflicts

 try{
 const status = await ensureRapierWorld();
 if(status?.success){
 console.log('[PHYSICS] Rapier world initialized (physics disabled by default)');
 updatePhysicsStatusChip('Physics: OFF');
 } else if(status?.reason === 'unavailable'){
 updatePhysicsStatusChip('Physics: OFF (unavailable)');
 } else {
 updatePhysicsStatusChip('Physics: OFF (error)');
 }
 }catch(e){ updatePhysicsStatusChip('Physics: OFF (error)'); console.warn('Rapier failed; continuing without physics', e); }

 // Settings and render-order debug UI removed

 if(!isAnimating){ isAnimating = true; needsRender = true; startLoop(); }
 // Rehydrate: render all current arrays immediately after init
 try{ Object.values(Store.getState().arrays).forEach(a=> Scene.renderArray(a)); }catch{}
 // Enforce default render orders and hydrate meshes/sprites once after all meshes exist
 try{ forceRenderOrderRefresh(); hydrateAll(); }catch{}
 // Apply current view mode once on init (ensures hideEmpty mask engages on boot)
 try{ const cur=(Store.getState().ui&&Store.getState().ui.viewMode)||'standard'; Scene.applyViewMode?.(cur); }catch{}
 // Ensure the first frame renders even if nothing changes immediately after init
 try{ if(typeof window.__RENDER_READY==='undefined'){ renderer.render(scene, camera); window.__RENDER_READY = true; } }catch{}
 }
 // Camera persistence helpers
 function captureCamera(){
 try{
 return {
 pos: (camera?.position?.toArray?.() || [10,8,13]),
 target: (controls?.target?.toArray?.() || [0,0,0]),
 fov: camera?.fov || 60,
 type: camera?.isPerspectiveCamera ? 'perspective' : 'orthographic'
 };
 }catch{ return null; }
 }
 function restoreCamera(s){
 if(!s) return;
 try{
 camera.position.fromArray(s.pos||[10,8,13]);
 controls.target.fromArray(s.target||[0,0,0]);
 if (s.fov) { camera.fov = +s.fov; camera.updateProjectionMatrix(); }
 }catch{}
 }
 
 
 function worldPos(arr,x,y,z){
 const base = localPos(arr,x,y,z);
 const off = arr.offset||{x:0,y:0,z:0};
 base.x += off.x; base.y += off.y; base.z += off.z;
 return base;
 }
 function localPos(arr,x,y,z){
 const X=arr.size.x,Y=arr.size.y,Z=arr.size.z;
 const scale = arrayVoxelScale(arr);
 return new THREE.Vector3(
 (x - X/2 + .5) * scale,
 ((Y - 1 - y) - Y/2 + .5) * scale,
 ((Z - 1 - z) - Z/2 + .5) * scale
 );
 }
 function withinBounds(arr, coord){
 return coord.x>=0 && coord.y>=0 && coord.z>=0 && coord.x<arr.size.x && coord.y<arr.size.y && coord.z<arr.size.z;
 }
 function worldToCellCoord(arr, world){
 const vec = world.clone ? world.clone() : new THREE.Vector3(world.x, world.y, world.z);
 if(arr._frame){ arr._frame.worldToLocal(vec); }
 else {
 const off = arr.offset||{x:0,y:0,z:0};
 vec.x -= off.x; vec.y -= off.y; vec.z -= off.z;
 }
 const X=arr.size.x,Y=arr.size.y,Z=arr.size.z;
 const scale = arrayVoxelScale(arr);
 const inv = scale !== 0 ? 1/scale : 1;
 const lx = vec.x * inv;
 const ly = vec.y * inv;
 const lz = vec.z * inv;
 const x = Math.round(lx + X/2 - 0.5);
 const y = Math.round((Y/2 - 0.5) - ly);
 const z = Math.round((Z/2 - 0.5) - lz);
 return {x,y,z};
 }
 // GPU-first two-pass materials with local clipping planes
 function makeCellMaterials(){
 const solid = createCellMaterial('filled');
 const ghost = createCellMaterial('ghost');
 return { solid, ghost };
 }

 // Extruded shell material for outlines (view-agnostic)
 function makeShellMaterial({ color = 0x9aa0a6, opacity = 0.15, thickness = 0.06 } = {}){
 const mat = new THREE.MeshBasicMaterial({
 color, transparent: true, opacity,
 side: THREE.BackSide,
 // Respect scene depth so distant shells cannot overdraw closer solids
 depthTest: true,
 depthWrite: false,
 toneMapped: false,
 vertexColors: true,
 polygonOffset: true,
 polygonOffsetFactor: 1,
 polygonOffsetUnits: 1
 });
 mat.onBeforeCompile = (shader)=>{
 shader.uniforms.uThick = { value: thickness };
 shader.vertexShader = shader.vertexShader.replace(
 'vec3 transformed = position;',
 'uniform float uThick; vec3 transformed = position + normal * uThick;'
 );
 };
 return mat;
 }

 // Whole-array highlight shell (single filled shell around the entire array)
 function ensureArrayHighlightShell(arr){
 try{
 const scale = arrayVoxelScale(arr);
 const want = { x:arr.size.x*scale, y:arr.size.y*scale, z:arr.size.z*scale, scale };
 const framePad = clampedScaleOffset(scale, 0.6);
 const rebuild = !arr._arrayShell || !arr._arrayShell.userData ||
 arr._arrayShell.userData.sx!==want.x ||
 arr._arrayShell.userData.sy!==want.y ||
 arr._arrayShell.userData.sz!==want.z ||
 arr._arrayShell.userData.scale!==want.scale;
 if(rebuild){
 // Dispose old
 try{ if(arr._arrayShell){ arr._arrayShell.parent?.remove(arr._arrayShell); arr._arrayShell.traverse(n=>{ try{ n.geometry?.dispose?.(); n.material?.dispose?.(); }catch{} }); } }catch{}
 const group = new THREE.Group();
 group.userData = { sx:want.x, sy:want.y, sz:want.z, scale:want.scale };
 // Outer backface shell: reach mid-gap between arrays ( 0.5 beyond faces)
 const geoOuter = new RoundedBoxGeometry(
 want.x + 2*framePad,
 want.y + 2*framePad,
 want.z + 2*framePad,
 3, 0.20
 );
 const matOuter = new THREE.MeshBasicMaterial({
 color: 0x3b82f6,
 transparent: true,
 opacity: 0.30,
 side: THREE.BackSide,
 depthTest: true,
 depthWrite: false,
 toneMapped: false,
 // Do not write color on the inner-facing pixels; rely on stencil to create pass-through
 colorWrite: true
 });
 // Stencil: draw shell only where inner did NOT write stencil
 matOuter.stencilWrite = true;
 matOuter.stencilFunc = THREE.NotEqualStencilFunc;
 matOuter.stencilRef = 1;
 matOuter.stencilZPass = THREE.KeepStencilOp;
 matOuter.stencilZFail = THREE.KeepStencilOp;
 matOuter.stencilFail = THREE.KeepStencilOp;
 const outer = new THREE.Mesh(geoOuter, matOuter);
 outer.renderOrder = window.__RO.frameShell|0; // frame shell above core but behind per-cell
 group.add(outer);
 // Inner fill: invisible, seeds stencil; draw very early
 // Inner fill slightly smaller than outer so outer remains as outline
 const geoInner = new RoundedBoxGeometry(
 arr.size.x + 0.96,
 arr.size.y + 0.96,
 arr.size.z + 0.96,
 3, 0.18
 );
 const matInner = new THREE.MeshBasicMaterial({
 color: 0xffffff,
 transparent: false, // treat as opaque so it renders in the opaque pass before transparent outer
 opacity: 0.0, // fully invisible (colorWrite=false still ensures no color)
 side: THREE.FrontSide,
 depthTest: true,
 depthWrite: true, // Write depth to ensure proper occlusion
 toneMapped: false,
 colorWrite: false
 });
 // Stencil: mark interior with ref=1 so shell ignores it (pass-through window)
 matInner.stencilWrite = true;
 matInner.stencilFunc = THREE.AlwaysStencilFunc;
 matInner.stencilRef = 1;
 matInner.stencilZPass = THREE.ReplaceStencilOp;
 matInner.stencilZFail = THREE.ReplaceStencilOp;
 matInner.stencilFail = THREE.ReplaceStencilOp;
 const inner = new THREE.Mesh(geoInner, matInner);
 inner.renderOrder = window.__RO.frameCore|0; // draw before frame shell
 group.add(inner);
 // If frame exists, parent shell to frame; otherwise enqueue after first renderArray
 if(arr._frame) arr._frame.add(group); else scene.add(group);
 arr._arrayShell = group;
 }
 }catch{}
 // Ensure visibility matches array state immediately
 try{ if(arr._arrayShell) arr._arrayShell.visible = !arr.hidden; }catch{}
 return arr._arrayShell;
 }

 function viewAxisForArray(frame, observerPos){
 try{
 const camPos = observerPos ? observerPos.clone() : camera.position.clone();
 const arrPos = new THREE.Vector3().setFromMatrixPosition(frame.matrixWorld);
 const dirWorld = camPos.sub(arrPos).normalize();
 const inv = new THREE.Matrix4().copy(frame.matrixWorld).invert();
 const dirLocal = dirWorld.clone().applyMatrix3(new THREE.Matrix3().setFromMatrix4(inv)).normalize();
 const ax=Math.abs(dirLocal.x), ay=Math.abs(dirLocal.y), az=Math.abs(dirLocal.z);
 let axis=0, sign=Math.sign(dirLocal.x)||1; if(ay>ax && ay>az){ axis=1; sign=Math.sign(dirLocal.y)||1; } else if(az>ax && az>ay){ axis=2; sign=Math.sign(dirLocal.z)||1; }
 return {axis, sign};
 }catch{ return {axis:2, sign:1}; }
 }

 // Camera-facing helpers with hysteresis to stabilize axis/sign and head-on
 function facingFromCamera(frame){
 try{
 const cam = camera.position.clone();
 const arrWorld = new THREE.Vector3().setFromMatrixPosition(frame.matrixWorld);
 const toCamWorld = cam.sub(arrWorld).normalize();
 const inv = new THREE.Matrix4().copy(frame.matrixWorld).invert();
 const toCamLocal = toCamWorld.clone().applyMatrix3(new THREE.Matrix3().setFromMatrix4(inv)).normalize();
 const ax=Math.abs(toCamLocal.x), ay=Math.abs(toCamLocal.y), az=Math.abs(toCamLocal.z);
 let axis=0, sign=Math.sign(toCamLocal.x)||1, majorMag=ax;
 if(ay>majorMag){ axis=1; sign=Math.sign(toCamLocal.y)||1; majorMag=ay; }
 if(az>majorMag){ axis=2; sign=Math.sign(toCamLocal.z)||1; majorMag=az; }
 return { axis, sign, majorMag, dirLocal: toCamLocal };
 }catch{ return { axis:2, sign:1, majorMag:1, dirLocal:new THREE.Vector3(0,0,1) }; }
 }

 function updateFacingState(arr){
 if(!arr || !arr._frame) return;
 const vs = facingFromCamera(arr._frame);
 const AXIS_DELTA=0.05, ENTER_HEAD=0.94, EXIT_HEAD=0.90;
 const prev = arr._facingState || { axis:vs.axis, sign:vs.sign, mag:vs.majorMag };
 const axisChanged = (vs.axis!==prev.axis) && (vs.majorMag > Math.max(prev.mag + AXIS_DELTA, 0.80));
 const signChanged = (vs.sign!==prev.sign) && (vs.majorMag > 0.60);
 const axis = axisChanged ? vs.axis : prev.axis;
 const sign = signChanged ? vs.sign : prev.sign;
 const mag = axisChanged ? vs.majorMag : Math.max(prev.mag*0.9, vs.majorMag);
 const prevHead = !!arr._headOnMajor;
 const nowHead = prevHead ? (mag > EXIT_HEAD) : (mag > ENTER_HEAD);
 arr._facingState = { axis, sign, mag };
 arr._headOnMajor = nowHead;
 arr._headOnZ = (axis===2) && nowHead;
 }

 function computeOcclusion(arr, selection){
 if(!arr || !selection) return;
 // Don't compute occlusion for deleting arrays
 if(arr._deleting) return;
 // Determine dominant axis from camera direction relative to array frame
 try{
 const inv = new THREE.Matrix4().copy(arr._frame.matrixWorld).invert();
 const camDirW = camera.position.clone().sub(arr._frame.getWorldPosition(new THREE.Vector3())).normalize();
 const camDirL = camDirW.clone().applyMatrix3(new THREE.Matrix3().setFromMatrix4(inv)).normalize();
 const ax=Math.abs(camDirL.x), ay=Math.abs(camDirL.y), az=Math.abs(camDirL.z);
 let axis='Z', sign=1, frontLayer=0, focusLayer=0;
 if(ay>ax && ay>az){ axis='Y'; sign=Math.sign(camDirL.y)||1; frontLayer = (sign>0) ? 0 : (arr.size.y-1); focusLayer = selection.y; }
 else if(ax>ay && ax>az){ axis='X'; sign=Math.sign(camDirL.x)||1; frontLayer = (sign>0) ? (arr.size.x-1) : 0; focusLayer = selection.x; }
 else { axis='Z'; sign=Math.sign(camDirL.z)||1; frontLayer = (sign>0) ? 0 : (arr.size.z-1); focusLayer = selection.z; }
 const blockedLayers = new Set();
 // Block layers BETWEEN front and focus, excluding both endpoints
 // Front layer is always visible (not ghosted), focus layer is always visible
 if(frontLayer < focusLayer){ 
 for(let L=frontLayer+1; L<focusLayer; L++) blockedLayers.add(L); 
 } else if(frontLayer > focusLayer){ 
 for(let L=frontLayer-1; L>focusLayer; L--) blockedLayers.add(L); 
 }
 arr._occlusionData = { axis, sign, frontLayer, focusLayer, blockedLayers };
 }catch{
 arr._occlusionData = { axis:'Z', sign:1, frontLayer:0, focusLayer:selection.z, blockedLayers:new Set() };
 }
 }

 function cutPlaneFromCamera(frame, sel, arr){
 try{
 const st = arr? (arr._facingState||{axis:2,sign:1}) : {axis:2,sign:1};
 const axis=st.axis, sign=st.sign;
 const cellSize=1;
 const c = new THREE.Vector3( (sel.x+0.5)*cellSize, (sel.y+0.5)*cellSize, (sel.z+0.5)*cellSize );
 if(axis===0) c.x += 0.5*sign*cellSize;
 if(axis===1) c.y += 0.5*sign*cellSize;
 if(axis===2) c.z += 0.5*sign*cellSize;
 const nL = new THREE.Vector3(axis===0?sign:0, axis===1?sign:0, axis===2?sign:0).normalize();
 const nW = nL.clone().applyQuaternion(frame.getWorldQuaternion(new THREE.Quaternion())).normalize();
 const pW = frame.localToWorld(c);
 return new THREE.Plane().setFromNormalAndCoplanarPoint(nW, pW);
 }catch{ return new THREE.Plane(new THREE.Vector3(0,0,1), 0); }
 }

 function cutPlaneFor(arrayFrame, sel, cellSize = 1){
 try{
 // camera dir in array local space
 const inv = new THREE.Matrix4().copy(arrayFrame.matrixWorld).invert();
 const camDirW = camera.position.clone().sub(arrayFrame.getWorldPosition(new THREE.Vector3())).normalize();
 const camDirL = camDirW.clone().applyMatrix3(new THREE.Matrix3().setFromMatrix4(inv)).normalize();
 // dominant axis + sign
 const ax = Math.abs(camDirL.x), ay = Math.abs(camDirL.y), az = Math.abs(camDirL.z);
 let axis=0, sign=Math.sign(camDirL.x)||1;
 if(ay>ax && ay>az){ axis=1; sign=Math.sign(camDirL.y)||1; }
 else if(az>ax && az>ay){ axis=2; sign=Math.sign(camDirL.z)||1; }
 // face center of selected cell toward camera
 const c = new THREE.Vector3(
 (sel.x + 0.5) * cellSize,
 (sel.y + 0.5) * cellSize,
 (sel.z + 0.5) * cellSize
 );
 if(axis===0) c.x += 0.5 * sign * cellSize;
 if(axis===1) c.y += 0.5 * sign * cellSize;
 if(axis===2) c.z += 0.5 * sign * cellSize;
 // local normal ? world normal
 const nL = new THREE.Vector3(axis===0?sign:0, axis===1?sign:0, axis===2?sign:0).normalize();
 const nW = nL.clone().applyQuaternion(arrayFrame.getWorldQuaternion(new THREE.Quaternion())).normalize();
 const pW = arrayFrame.localToWorld(c);
 const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(nW, pW);
 return plane;
 }catch{ return new THREE.Plane(new THREE.Vector3(0,0,1), 0); }
 }

 function applyCutaway(arr, sel){
 if(!arr || !arr._cellMaterials || !arr._frame || !sel) return;
 // In chunk mode, rely solely on per-instance ghost/solid masking; disable material clipping
 if(Scene.ChunkManager && Scene.ChunkManager.enabled){
 try{ arr._cellMaterials.forEach(m=>{ if(m) m.clippingPlanes = null; }); }catch{}
 // In hideEmpty mode, enforce mask instead of occlusion
 try{
 const mode = (Store.getState().ui && Store.getState().ui.viewMode) || 'standard';
 if(mode==='hideEmpty'){ applyHideEmptyMask(arr); }
 }catch{}
 return;
 }
 try{
 const plane = cutPlaneFromCamera(arr._frame, sel, arr);
 // FRONT (toward camera) ? GHOST, BACK (selected+behind) ? SOLID
 arr._cellMaterials.forEach(mat=>{
 if(mat.userData.pass === 'ghost'){
 mat.clippingPlanes = [ plane.clone() ];
 } else if(mat.userData.pass === 'solid'){
 mat.clippingPlanes = [ plane.clone().negate() ];
 }
 });
 needsRender = true;
 }catch{}
 }

 // Live color update for a single cell without a full rebuild
 function updateCellColor(arrayId, coord){
 try{
 const arr = Store.getState().arrays[arrayId]; if(!arr) return;
 const cell = getCellFast(arrayId, coord);
 const key = `${arrayId}:${coord.x},${coord.y},${coord.z}`;
 const emitted = !!(Store.getState().sourceByCell && Store.getState().sourceByCell.get && Store.getState().sourceByCell.get(key));
 const isFormula = !!cell.formula;
 const custom = cell?.meta?.color;
 const hasValue = (cell.value!=='' && cell.value!==null && cell.value!==undefined);
 let hex;
 if(isFormula) hex = baseHexForTypeKey('formula'); else if(emitted) hex = baseHexForTypeKey('emitted'); else hex = hasValue ? baseHexForTypeKey('value') : baseHexForTypeKey('empty');
 const col = new THREE.Color(custom || hex); col.convertSRGBToLinear();
 // Update pooled LOD1
 try{
 const ch = arr.chunks[keyChunk(...Object.values(chunkOf(coord.x,coord.y,coord.z)))];
 const mesh = ch?.meshLOD1; const map = ch?.index2cell; const gmesh = ch?.meshGhost; const smesh = ch?.meshShell;
 if(map){
 const idx = map.findIndex(c=>c && c.x===coord.x && c.y===coord.y && c.z===coord.z);
 if(idx>=0){
 if(mesh){ mesh.setColorAt(idx, col); if(mesh.instanceColor) mesh.instanceColor.needsUpdate = true; mesh.visible = true; }
 if(gmesh){ const ghostTint = tintGhostColorFrom(col); gmesh.setColorAt(idx, ghostTint); if(gmesh.instanceColor) gmesh.instanceColor.needsUpdate = true; }
 if(smesh){ const scol = col.clone(); scol.offsetHSL(0,0,-0.22); if(smesh.instanceColor){ smesh.setColorAt(idx, scol); smesh.instanceColor.needsUpdate = true; } }
 }
 }
 }catch{}
 // Update legacy layer meshes
 try{
 const z = coord.z|0; const types=['empty','filled','formula','ghost'];
 for(const t of types){
 const rec = layerMeshes.get(`${arrayId}:${z}:${t}`);
 if(!rec||!rec.mesh||!rec.index2cell) continue;
 const i = rec.index2cell.findIndex(c=>c && c.x===coord.x && c.y===coord.y && c.z===coord.z);
 if(i>=0){ try{ rec.mesh.setColorAt(i, col); }catch{} if(rec.mesh.instanceColor) rec.mesh.instanceColor.needsUpdate = true; }
 }
 }catch{}
 try{ renderer?.state?.reset?.(); }catch{}
 needsRender = true;
 }catch{}
 }

 // Rehydrate an entire chunk's instances from current cell state
 function rehydrateChunkInstances(arr, ch){
 try{
 if(!ch) return;
 // CRITICAL: Never rehydrate during deletion - would reset hidden cells
 if(arr?._deleting) return;
 
 ch.ensureMesh?.();
 const meshSolid = ch.meshLOD1; const meshGhost = ch.meshGhost; const meshShell = ch.meshShell;
 if(!meshSolid) return;
 const list = ch.index2cell || ch.cells || [];
 const viewModeNow = (Store.getState().ui && Store.getState().ui.viewMode) || 'standard';
 const scale = arrayVoxelScale(arr);
 const cellScale = voxelDisplayScale(scale);
 for(let i=0;i<list.length;i++){
 const c = list[i]; if(!c) continue;
 // transform
 const p = localPos(arr, c.x, c.y, c.z);
 temp.position.copy(p); temp.rotation.set(0,0,0); temp.scale.set(cellScale,cellScale,cellScale); temp.updateMatrix();
 const M = temp.matrix;
 // In hideEmpty mode, zero-scale empty instances; otherwise set normal transform
 if(viewModeNow==='hideEmpty'){
 const fresh = Formula.getCell({arrId:arr.id, x:c.x, y:c.y, z:c.z}) || {};
 const isFormula = !!fresh.formula;
 const hasValue = (fresh.value!=='' && fresh.value!==null && fresh.value!==undefined);
 const emitted = !!(Store.getState().sourceByCell && Store.getState().sourceByCell.get && Store.getState().sourceByCell.get(`${arr.id}:${c.x},${c.y},${c.z}`));
 const show = isFormula || hasValue || emitted;
 if(show){
 meshSolid.setMatrixAt(i, M);
 if(meshShell) meshShell.setMatrixAt(i, M);
 } else {
 tempM.identity(); tempM.makeScale(0,0,0);
 meshSolid.setMatrixAt(i, tempM);
 if(meshShell) meshShell.setMatrixAt(i, tempM);
 }
 } else {
 meshSolid.setMatrixAt(i, M);
 if(meshShell) meshShell.setMatrixAt(i, M);
 }
 // ghosts start hidden until occlusion applies
 if(meshGhost){ tempM.identity(); tempM.makeScale(0,0,0); meshGhost.setMatrixAt(i, tempM); }
 // colors
 try{
 const fresh = getCellFast(arr.id, c) || {};
 const isFormula = !!fresh.formula;
 const hasValue = (fresh.value!=='' && fresh.value!==null && fresh.value!==undefined);
 const emitted = !!(Store.getState().sourceByCell && Store.getState().sourceByCell.get && Store.getState().sourceByCell.get(`${arr.id}:${c.x},${c.y},${c.z}`));
 let hex; if(isFormula) hex = baseHexForTypeKey('formula'); else if(emitted) hex = baseHexForTypeKey('emitted'); else hex = hasValue ? baseHexForTypeKey('value') : baseHexForTypeKey('empty');
 const custom = fresh?.meta?.color;
 const col = new THREE.Color(custom || hex).convertSRGBToLinear();
 meshSolid.setColorAt(i, col);
 if(meshGhost){ const ghostTint = tintGhostColorFrom(col); meshGhost.setColorAt(i, ghostTint); }
 if(meshShell){ const sc = col.clone(); sc.offsetHSL(0,0,-0.22); meshShell.setColorAt(i, sc); }
 }catch{}
 }
 meshSolid.count = list.length; meshSolid.instanceMatrix.needsUpdate = true; if(meshSolid.instanceColor) meshSolid.instanceColor.needsUpdate = true;
 if(meshGhost){ meshGhost.count = list.length; meshGhost.instanceMatrix.needsUpdate = true; if(meshGhost.instanceColor) meshGhost.instanceColor.needsUpdate = true; }
 if(meshShell){ meshShell.count = list.length; meshShell.instanceMatrix.needsUpdate = true; if(meshShell.instanceColor) meshShell.instanceColor.needsUpdate = true; }
 }catch{}
 }
 
 // Zero-scale chunk instances for blocked layers so ghosts replace solids when chunks are ON
 function applyGhostMaskToChunks(arr){
 try{
 if(!(Scene.ChunkManager && Scene.ChunkManager.enabled)) return;
 if(!arr || !arr.chunks) return;
 // Don't apply occlusion to deleting arrays
 if(arr._deleting) return;
 const occ = arr._occlusionData || {};
 const blocked = occ.blockedLayers || new Set();
 const axis = occ.axis || occ.facing || 'Z';
 // Determine focus layer from current selection for this array so it always renders as solid
 const sel = Store.getState().selection || {};
 const focusLayer = (sel.arrayId===arr.id && sel.focus) ? (axis==='X' ? sel.focus.x : axis==='Y' ? sel.focus.y : sel.focus.z) : null;
 const scale = arrayVoxelScale(arr);
 const cellScale = voxelDisplayScale(scale);
 Object.values(arr.chunks).forEach(ch=>{
 const meshSolid = ch.meshLOD1; const meshGhost = ch.meshGhost; const meshShell = ch.meshShell;
 if(!meshSolid || !ch.index2cell) return;
 let changedS=false, changedG=false, changedH=false;
 for(let i=0;i<ch.index2cell.length;i++){
 const c = ch.index2cell[i];
 const L = axis==='X' ? c.x : axis==='Y' ? c.y : c.z;
 const isFocus = (focusLayer===L);
 const isBlocked = blocked.has(L);
 // Build the canonical transform exactly once
 const p = localPos(arr,c.x,c.y,c.z);
 temp.position.copy(p); temp.rotation.set(0,0,0); temp.scale.set(cellScale,cellScale,cellScale); temp.updateMatrix();
 const M = temp.matrix.clone();
 // Solid shows when NOT blocked (no special exception for any layer)
 const showSolid = !isBlocked;
 if(showSolid){ meshSolid.setMatrixAt(i, M); } else { tempM.identity(); tempM.makeScale(0,0,0); meshSolid.setMatrixAt(i, tempM); }
 changedS=true;
 // Ghost shows when blocked (no special exception for any layer)
 const showGhost = isBlocked;
 if(meshGhost){ if(showGhost){ meshGhost.setMatrixAt(i, M); } else { tempM.identity(); tempM.makeScale(0,0,0); meshGhost.setMatrixAt(i, tempM); } changedG=true; }
 // Shell follows solids (hide when blocked). Larger GEO_SHELL gives visible outline.
 if(meshShell){
 if(showSolid){ meshShell.setMatrixAt(i, M); }
 else { tempM.identity(); tempM.makeScale(0,0,0); meshShell.setMatrixAt(i, tempM); }
 changedH=true;
 }
 }
 if(changedS) meshSolid.instanceMatrix.needsUpdate = true;
 if(changedG && meshGhost) meshGhost.instanceMatrix.needsUpdate = true;
 if(changedH && meshShell) meshShell.instanceMatrix.needsUpdate = true;
 });
 // Hide value sprites for blocked cells too in Standard mode; other modes leave sprites visible
 try{
 const mode = (Store.getState().ui && Store.getState().ui.viewMode) || 'standard';
 if(mode==='standard'){
 const vs = window.valueSprites || new Map();
 vs.forEach((sprite,key)=>{
 if(!String(key).startsWith(`${arr.id}:`)) return;
 const [,coords] = String(key).split(':');
 const [x,y,z] = coords.split(',').map(n=>+n);
 let blk=false;
 if(axis==='Z') blk = blocked.has(z);
 else if(axis==='X') blk = blocked.has(x);
 else blk = blocked.has(y);
 if(sprite) sprite.visible = !blk;
 });
 }
 }catch{}
 }catch(e){ console.warn('applyGhostMaskToChunks failed', e); }
 }

 // Hide-Empty: zero-scale all empty instances for an array
 function applyHideEmptyMask(arr){
 try{
 const scale = arrayVoxelScale(arr);
 Object.values(arr.chunks||{}).forEach(ch=>{
 try{
 ch.ensureMesh?.(); ch.setLOD?.(1);
 if(!ch.index2cell) return;
 let changedS=false, changedH=false, changedG=false;
 for(let i=0;i<ch.index2cell.length;i++){
 const c = ch.index2cell[i]; if(!c) continue;
 const fresh = Formula.getCell({arrId:arr.id, x:c.x, y:c.y, z:c.z}) || {};
 const isFormula = !!fresh.formula;
 const hasVal = (fresh.value!=='' && fresh.value!==null && fresh.value!==undefined);
 const emitted = !!(Store.getState().sourceByCell && Store.getState().sourceByCell.get && Store.getState().sourceByCell.get(`${arr.id}:${c.x},${c.y},${c.z}`));
 const hasColor = !!(fresh.meta && fresh.meta.color);
 const show = isFormula || hasVal || emitted || hasColor;
 const p = localPos(arr,c.x,c.y,c.z);
 temp.position.copy(p); temp.rotation.set(0,0,0); temp.scale.set(scale,scale,scale); temp.updateMatrix();
 const M = temp.matrix.clone();
 if(ch.meshLOD1){ if(show){ ch.meshLOD1.setMatrixAt(i, M); } else { tempM.identity(); tempM.makeScale(0,0,0); ch.meshLOD1.setMatrixAt(i, tempM); } changedS=true; }
 if(ch.meshShell){ if(show){ ch.meshShell.setMatrixAt(i, M); } else { tempM.identity(); tempM.makeScale(0,0,0); ch.meshShell.setMatrixAt(i, tempM); } changedH=true; }
 if(ch.meshGhost){ tempM.identity(); tempM.makeScale(0,0,0); ch.meshGhost.setMatrixAt(i, tempM); changedG=true; }
 }
 if(changedS && ch.meshLOD1) ch.meshLOD1.instanceMatrix.needsUpdate=true;
 if(changedH && ch.meshShell) ch.meshShell.instanceMatrix.needsUpdate=true;
 if(changedG && ch.meshGhost) ch.meshGhost.instanceMatrix.needsUpdate=true;
 }catch{}
 });
 // Ensure sprites (which are created only for content) stay visible
 try{ valueSprites.forEach((sp,key)=>{ if(String(key).startsWith(`${arr.id}:`)) sp.visible=true; }); }catch{}
 }catch{}
 }

 // Apply global 3D view mode across all arrays: 'standard' | 'solid' | 'hideEmpty'
 function applyViewMode(mode){
 try{
 const arrays = Object.values(Store.getState().arrays||{}).filter(arr => !arr._deleting);
 if(mode==='solid'){
 arrays.forEach(arr=>{
 Object.values(arr.chunks||{}).forEach(ch=>{ try{ ch.ensureMesh?.(); ch.setLOD?.(1); rehydrateChunkInstances(arr, ch); }catch{} });
 // Ensure all value sprites are visible; occlusion disabled in this mode
 try{ valueSprites.forEach((sp,key)=>{ if(String(key).startsWith(`${arr.id}:`)) sp.visible=true; }); }catch{}
 // Clear occlusion data so animate doesn't reuse it
 try{ clearOcclusion(arr); }catch{}
 });
 } else if(mode==='hideEmpty'){
 arrays.forEach(arr=>{ try{ clearOcclusion(arr); applyHideEmptyMask(arr); }catch{} });
 } else { // standard
 arrays.forEach(arr=>{
 Object.values(arr.chunks||{}).forEach(ch=>{ try{ ch.ensureMesh?.(); ch.setLOD?.(1); rehydrateChunkInstances(arr, ch); }catch{} });
 });
 const s = Store.getState().selection;
 if(s?.arrayId && s.focus){
 const arr = Store.getState().arrays[s.arrayId];
 if(!arr?._deleting){
 try{ computeOcclusion(arr, s.focus); if(Scene.ChunkManager && Scene.ChunkManager.enabled){ applyGhostMaskToChunks(arr); } }catch{}
 }
 }
 }
 needsRender = true;
 arrays.forEach(arr=>{
 try{ updateArrayValueSpritePlacement(arr); }catch{}
 try{ updateArrayLabelPlacement(arr); }catch{}
 });
 }catch{}
 }

 // Click pulse: scale both solid and shell at the same instance center
 function pulseCell(arr, cell, z){
 try{
 const useChunks = !!(ChunkManager && ChunkManager.enabled);
 const records = [];
 const captureBase = (mesh, idx)=>{
 if(!mesh || !Number.isInteger(idx) || idx < 0) return;
 if(idx >= (mesh.count ?? Infinity)) return;
 try{
 const base = new THREE.Matrix4();
 mesh.getMatrixAt(idx, base);
 records.push({ mesh, idx, base });
 }catch{}
 };
 if(useChunks){
 const chunkId = keyChunk(...Object.values(chunkOf(cell.x,cell.y,cell.z)));
 const ch = arr.chunks?.[chunkId];
 if(ch){
 let idx = -1;
 if(ch.cellIndexMap && typeof ch.cellIndexMap.get === 'function'){
 const maybeIdx = ch.cellIndexMap.get(`${cell.x},${cell.y},${cell.z}`);
 if(Number.isInteger(maybeIdx)) idx = maybeIdx;
 }
 if(idx < 0 && Array.isArray(ch.index2cell)){
 idx = ch.index2cell.findIndex(c=>c && c.x===cell.x && c.y===cell.y && c.z===cell.z);
 }
 if(idx >= 0){
 captureBase(ch.meshLOD1, idx);
 captureBase(ch.meshShell, idx);
 }
 }
 } else {
 const types=['filled','formula'];
 types.forEach(tp=>{
 const rec = layerMeshes.get(`${arr.id}:${z}:${tp}`);
 if(rec && rec.mesh && Array.isArray(rec.index2cell)){
 const idx = rec.index2cell.findIndex(c=>c && c.x===cell.x && c.y===cell.y && c.z===cell.z);
 captureBase(rec.mesh, idx);
 }
 const er = layerMeshes.get(`${arr.id}:${z}:${tp}:edges`);
 if(er && er.mesh && Array.isArray(er.index2cell)){
 const idx = er.index2cell.findIndex(c=>c && c.x===cell.x && c.y===cell.y && c.z===cell.z);
 captureBase(er.mesh, idx);
 }
 });
 }
 if(!records.length) return;
 const start=performance.now(); const dur=180; const peak=1.10;
 const scaleMatrix = new THREE.Matrix4();
 const restore=()=>{
 records.forEach(rec=>{
 try{
 rec.mesh.setMatrixAt(rec.idx, rec.base);
 rec.mesh.instanceMatrix.needsUpdate = true;
 }catch{}
 });
 needsRender = true;
 };
 const step=()=>{
 const t=Math.min(1, (performance.now()-start)/dur);
 const s = 1 + (peak-1) * (t<0.5 ? (t*2) : (2-2*t));
 scaleMatrix.identity();
 scaleMatrix.makeScale(s, s, s);
 records.forEach(rec=>{
 try{
 const next = rec.base.clone().multiply(scaleMatrix);
 rec.mesh.setMatrixAt(rec.idx, next);
 rec.mesh.instanceMatrix.needsUpdate = true;
 }catch{}
 });
 needsRender = true;
 if(t<1){
 requestAnimationFrame(step);
 } else {
 restore();
 }
 };
 requestAnimationFrame(step);
 }catch{}
 }
 // Fast cell accessor using chunk cellMap fallback to array scan
 function getCellFast(arrayId, coord){
 try{
 const arr = Store.getState().arrays[arrayId]; if(!arr) return {value:'',formula:null,meta:{}};
 const ch = arr.chunks[keyChunk(...Object.values(chunkOf(coord.x,coord.y,coord.z)))]; if(!ch) return {value:'',formula:null,meta:{}};
 if(ch.cellMap){ const c = ch.cellMap.get(`${coord.x},${coord.y},${coord.z}`); return c || {value:'',formula:null,meta:{}}; }
 const c = ch.cells?.find?.(t=>t.x===coord.x&&t.y===coord.y&&t.z===coord.z);
 return c || {value:'',formula:null,meta:{}};
 }catch{ return {value:'',formula:null,meta:{}}; }
 }
 
 function pruneStaleChunkMeshes(arrayId){
 const arr = Store.getState().arrays[arrayId];
 if(!arr) return;
 const validKeys = new Set(Object.keys(arr.chunks).map(k => `${arrayId}:${k}`));
 for (const [key, m] of chunkMeshes) {
 if (m?.userData?.arrayId === arrayId && !validKeys.has(key)) {
 try {
 m.parent?.remove(m);
 m.geometry?.dispose?.();
 m.material?.dispose?.();
 } catch {}
 chunkMeshes.delete(key);
 }
 }
 }
 // --- Chunk module (Phase 0/1) ---
 class Chunk {
 constructor(array, chunkCoord){
 this.array = array;
 this.coord = { x: chunkCoord.x|0, y: chunkCoord.y|0, z: chunkCoord.z|0 };
 this.cells = [];
 this.cellMap = new Map(); // key: "x,y,z" -> cell
 this.currentLOD = -1; // -1=unloaded, 1=instanced, 2=greedy
 this.meshLOD1 = null; // InstancedMesh
 this.meshLOD2 = null; // Greedy merged mesh
 this._dirty = false;
 }
 markDirty(){ this._dirty = true; }
 unload(){
 try{
 if(this.meshLOD1){ this.meshLOD1.parent?.remove(this.meshLOD1); this.meshLOD1.geometry?.dispose?.(); this.meshLOD1.material?.dispose?.(); this.meshLOD1=null; }
 if(this.meshLOD2){ this.meshLOD2.parent?.remove(this.meshLOD2); this.meshLOD2.geometry?.dispose?.(); this.meshLOD2.material?.dispose?.(); this.meshLOD2=null; }
 if(this.meshGhost){ this.meshGhost.parent?.remove(this.meshGhost); this.meshGhost.geometry?.dispose?.(); this.meshGhost.material?.dispose?.(); this.meshGhost=null; }
 if(this.meshShell){ this.meshShell.parent?.remove(this.meshShell); this.meshShell.geometry?.dispose?.(); this.meshShell.material?.dispose?.(); this.meshShell=null; }
 }catch{}
 this.currentLOD = -1; this._dirty=false;
 }
 ensureMesh(){
 // Create/ensure twin instanced meshes (solid + ghost + shell) only once per chunk
 try{
 const maxInstances = Math.max(1, this.cells.length|0);
 if(!this.instancedMesh){
 const geo = GEO_VOXEL; // pooled
 addWhiteVertexColors(geo);
 const mats = makeCellMaterials();
 const shellMat = new THREE.MeshBasicMaterial({
 color: 0xffffff,
 transparent: true,
 opacity: 0.28,
 side: THREE.BackSide,
 depthTest: true,
 depthWrite: false,
 toneMapped: false,
 vertexColors: true
 });
 // Tag passes for unified clipping control
 mats.solid.userData = { ...(mats.solid.userData||{}), pass:'solid' };
 mats.ghost.userData = { ...(mats.ghost.userData||{}), pass:'ghost' };
 shellMat.userData = { ...(shellMat.userData||{}), pass:'shell' };
 const meshSolid = new THREE.InstancedMesh(geo, mats.solid, maxInstances);
 const meshGhost = new THREE.InstancedMesh(geo, mats.ghost, maxInstances);
 const meshShell = new THREE.InstancedMesh(GEO_SHELL, shellMat, maxInstances);
 const shadowsEnabled = FancyGraphics.enabled && FancyGraphics.settings.solidGround;
 meshSolid.castShadow = shadowsEnabled;
 meshGhost.castShadow = false;
 meshShell.castShadow = false;
 // Important for correct layering: ghosts first, then solids, then shells
 meshGhost.renderOrder = 1;
 meshSolid.renderOrder = 2;
 meshShell.renderOrder = 3;
 meshSolid.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
 meshGhost.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
 meshShell.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
 // Prevent culling from hiding outlines at shallow angles
 meshSolid.frustumCulled = false; meshGhost.frustumCulled = false; meshShell.frustumCulled = false;
 // Render order: frame(0) -> ghosts(1) -> solids(2) -> shells(3)
 // Drawing solids after ghosts guarantees fills are visible through low-opacity ghosts
 // Per-cell passes: keep in mid-range so frame UI can be drawn above
 meshGhost.renderOrder = window.__RO.ghostFill|0; 
 meshSolid.renderOrder = window.__RO.solidFill|0; 
 meshShell.renderOrder = window.__RO.solidShell|0;
 // Mark materials for cutaway
 mats.solid.userData.pass = 'solid';
 mats.ghost.userData.pass = 'ghost';
 // Allocate instanceColor buffers
 try{
 const colBufSolid = new Float32Array(maxInstances*3);
 const colBufGhost = new Float32Array(maxInstances*3);
 const colBufShell = new Float32Array(maxInstances*3);
 meshSolid.instanceColor = new THREE.InstancedBufferAttribute(colBufSolid, 3); meshSolid.instanceColor.setUsage(THREE.DynamicDrawUsage);
 meshGhost.instanceColor = new THREE.InstancedBufferAttribute(colBufGhost, 3); meshGhost.instanceColor.setUsage(THREE.DynamicDrawUsage);
 meshShell.instanceColor = new THREE.InstancedBufferAttribute(colBufShell, 3); meshShell.instanceColor.setUsage(THREE.DynamicDrawUsage);
 }catch{}
 // Parent under array frame when available
 if(this.array && this.array._frame){ this.array._frame.add(meshSolid); this.array._frame.add(meshGhost); this.array._frame.add(meshShell); } else { scene.add(meshSolid); scene.add(meshGhost); scene.add(meshShell); }
 // Expose for updates
 this.instancedMesh = meshSolid; // primary for solids
 this.meshLOD1 = meshSolid;
 this.meshGhost = meshGhost;
 this.meshShell = meshShell;
 const lod = (this.currentLOD == null || this.currentLOD < 0) ? 1 : this.currentLOD;
 this.meshShell.visible = !FancyGraphics.enabled && (lod === 1);
 // Use twin meshes for ghosting: solid shows unblocked, ghost shows blocked
 try{ this.meshGhost.visible = true; }catch{}
 // Tag for picking and ghost-mask application
 try{
 meshSolid.userData = { ...(meshSolid.userData||{}), arrayId:this.array.id, chunk:this };
 meshGhost.userData = { ...(meshGhost.userData||{}), arrayId:this.array.id, chunk:this };
 meshShell.userData = { ...(meshShell.userData||{}), arrayId:this.array.id, chunk:this };
 }catch{}
 // Stash materials for cutaway updates
 this.array._cellMaterials = this.array._cellMaterials || [];
 this.array._cellMaterials.push(mats.solid, mats.ghost);
 }

 // Stable index map: sort by z,y,x for deterministic ids
 const sorted = [...this.cells].sort((a,b)=> (a.z-b.z) || (a.y-b.y) || (a.x-b.x));
 this.index2cell = sorted; // expose for picking and ghost masking
 this.cellIndexMap = new Map();
 const scale = arrayVoxelScale(this.array);
 const cellScale = voxelDisplayScale(scale);
 for(let i=0;i<sorted.length;i++){
 const c = sorted[i];
 this.cellIndexMap.set(`${c.x},${c.y},${c.z}`, i);
 // Initialize transform
 const p = localPos(this.array, c.x, c.y, c.z);
 temp.position.copy(p);
 temp.rotation.set(0,0,0);
 temp.scale.set(cellScale,cellScale,cellScale);
 temp.updateMatrix();
 this.instancedMesh.setMatrixAt(i, temp.matrix);
 // Start ghosts hidden (zero scale) until occlusion mask applies
 if(this.meshGhost){ tempM.identity(); tempM.makeScale(0,0,0); this.meshGhost.setMatrixAt(i, tempM); }
 if(this.meshShell) this.meshShell.setMatrixAt(i, temp.matrix);
 // Initialize color (custom or type-based); linearized
 const key = `${this.array.id}:${c.x},${c.y},${c.z}`;
 const emitted = !!(Store.getState().sourceByCell && Store.getState().sourceByCell.get && Store.getState().sourceByCell.get(key));
 const isFormula = !!c.formula;
 const custom = c?.meta?.color;
 const hasValue = (c.value!=='' && c.value!==null && c.value!==undefined);
 let hex;
 if(isFormula) hex = baseHexForTypeKey('formula'); else if(emitted) hex = baseHexForTypeKey('emitted'); else hex = hasValue ? baseHexForTypeKey('value') : baseHexForTypeKey('empty');
 const col = new THREE.Color(custom || hex);
 col.convertSRGBToLinear();
 try{
 this.instancedMesh.setColorAt(i, col);
 if(this.meshGhost){ const ghostTint = tintGhostColorFrom(col); this.meshGhost.setColorAt(i, ghostTint); }
 if(this.meshShell){ const sc = col.clone(); sc.offsetHSL(0,0,-0.22); this.meshShell.setColorAt(i, sc); }
 }catch{}
 }
 this.instancedMesh.count = sorted.length;
 this.instancedMesh.instanceMatrix.needsUpdate = true;
 if(this.instancedMesh.instanceColor) this.instancedMesh.instanceColor.needsUpdate = true;
 if(this.meshGhost){ this.meshGhost.count = sorted.length; this.meshGhost.instanceMatrix.needsUpdate = true; if(this.meshGhost.instanceColor) this.meshGhost.instanceColor.needsUpdate = true; }
 if(this.meshShell){ this.meshShell.count = sorted.length; this.meshShell.instanceMatrix.needsUpdate = true; if(this.meshShell.instanceColor) this.meshShell.instanceColor.needsUpdate = true; }
 needsRender = true;
 }catch{}
 return this.instancedMesh;
 }
 buildMeshLOD1(){
 // Use ensureMesh for stable pooled instances
 this.ensureMesh();
 this._dirty = false;
 }
 buildMeshLOD2(){
 // Greedy mesh: merge visible voxels of identical visual into quads per face and extrude
 try{ if(this.meshLOD2){ this.meshLOD2.parent?.remove(this.meshLOD2); this.meshLOD2.geometry?.dispose?.(); this.meshLOD2.material?.dispose?.(); } }catch{}
 this.meshLOD2 = null;
 const cells = this.cells.filter(c=> c && (c.value!=='' || c.formula));
 if(cells.length===0) return;
 const voxels=new Set(cells.map(c=>`${c.x},${c.y},${c.z}`));
 const W=this.array.size.x, H=this.array.size.y, D=this.array.size.z;
 // Build a dense occupancy grid within this chunk bounds
 const minX=this.coord.x*CHUNK_SIZE, minY=this.coord.y*CHUNK_SIZE, minZ=this.coord.z*CHUNK_SIZE;
 const maxX=Math.min(minX+CHUNK_SIZE, W), maxY=Math.min(minY+CHUNK_SIZE, H), maxZ=Math.min(minZ+CHUNK_SIZE, D);
 const Sx=maxX-minX, Sy=maxY-minY, Sz=maxZ-minZ;
 if(Sx<=0||Sy<=0||Sz<=0) return;
 const occ=new Uint8Array(Sx*Sy*Sz);
 const idx=(x,y,z)=> (z*Sy + y)*Sx + x;
 for(let z=minZ; z<maxZ; z++) for(let y=minY; y<maxY; y++) for(let x=minX; x<maxX; x++){
 if(voxels.has(`${x},${y},${z}`)) occ[idx(x-minX,y-minY,z-minZ)]=1;
 }
 // Greedy along each axis, accumulating quads
 const geoms=[];
 const pushQuad=(x0,y0,z0, dx,dy,dz, w,h)=>{
 // Build a box for the merged face thickness 1 cell
 const bx = Math.abs(dy)+Math.abs(dz) ? w : 1;
 const by = Math.abs(dx)+Math.abs(dz) ? h : 1;
 const bz = Math.abs(dx)+Math.abs(dy) ? 1 : 1; // thickness one cell
 const geo=new THREE.BoxGeometry(bx,by,bz);
 // Center in local space
 const cx = x0 + (dx? (w-1)/2 : 0);
 const cy = y0 + (dy? (h-1)/2 : 0);
 const cz = z0;
 const m=new THREE.Matrix4().makeTranslation(
 (cx - W/2 + 0.5),
 ((H - 1 - cy) - H/2 + 0.5),
 ((D - 1 - cz) - D/2 + 0.5)
 );
 geo.applyMatrix4(m);
 geoms.push(geo);
 };
 // Simple XY-plane sweep per Z to merge rectangles of ones
 for(let z=0; z<Sz; z++){
 // Build 2D mask
 const mask=new Uint8Array(Sx*Sy);
 for(let y=0;y<Sy;y++) for(let x=0;x<Sx;x++) mask[y*Sx+x]=occ[idx(x,y,z)];
 // Greedy rectangles in mask
 let y=0; while(y<Sy){
 let x=0; while(x<Sx){
 if(!mask[y*Sx+x]){ x++; continue; }
 // width
 let w=1; while(x+w<Sx && mask[y*Sx + (x+w)]) w++;
 // height
 let h=1; outer: while(y+h<Sy){ for(let k=0;k<w;k++) if(!mask[(y+h)*Sx + (x+k)]) break outer; h++; }
 // clear mask block
 for(let yy=y; yy<y+h; yy++) for(let xx=x; xx<x+w; xx++) mask[yy*Sx+xx]=0;
 // emit quad as thin box at this z-slice
 pushQuad(minX+x, minY+y, minZ+z, 1,0,0, w, h);
 x += w;
 }
 y++;
 }
 }
 // Merge all quads into single geometry
 let merged=null;
 try{ merged = BufferGeometryUtils.mergeGeometries(geoms,false); }catch{ merged = geoms[0]||null; }
 if(!merged) return;
 const m = new THREE.Mesh(merged, createCellMaterial('filled'));
 this.meshLOD2 = m;
 if(this.array._frame) this.array._frame.add(m);
 this._dirty = false;
 }
 setLOD(level){
 if(this.currentLOD === level && !this._dirty) return;
 if(level === 1) this.buildMeshLOD1();
 else if(level === 2) this.buildMeshLOD2();
 // Visibility policy:
 // - LOD1 (instanced): show solids + ghosts + shells
 // - LOD2 (greedy): show merged solid only; hide ghosts/shells (no per-cell masking available)
 // Keep LOD1 instanced mesh "pick-only" when LOD2 is active so arrays remain clickable without focus
 if(this.meshLOD1){
 if(level===1){
 this.meshLOD1.visible = true;
 try{ this.meshLOD1.material.transparent=false; this.meshLOD1.material.opacity=1.0; this.meshLOD1.material.colorWrite=true; this.meshLOD1.material.depthWrite=true; }catch{}
 } else {
 this.meshLOD1.visible = true; // visible for raycasting
 try{ this.meshLOD1.material.transparent=true; this.meshLOD1.material.opacity=0.0; this.meshLOD1.material.colorWrite=false; this.meshLOD1.material.depthWrite=false; }catch{}
 }
 }
 if(this.meshGhost) this.meshGhost.visible = (level===1);
 if(this.meshShell) this.meshShell.visible = (level===1) && !FancyGraphics.enabled;
 if(this.meshLOD2){
 this.meshLOD2.visible = (level===2 && !this.array._headOnZ);
 // Ensure pickability when LOD2 is visible: leave LOD1 raycastable but visually invisible
 try{ if(this.meshLOD2.visible && this.meshLOD1){ this.meshLOD1.raycast = THREE.InstancedMesh.prototype.raycast; } }catch{}
 }
 // Keep LOD1 pooled; do not destroy
 this.currentLOD = level; this._dirty=false;
 }
 }
 // Greedy mesher stub (Phase 2 placeholder)
 function generateGreedyMesh(chunk){
 // Provided by buildMeshLOD2 now; keep for API completeness
 try{ chunk.buildMeshLOD2(); }catch{}
 return chunk.meshLOD2?.geometry || null;
 }
 // ChunkManager scaffold (Phase 3; gated by enable flag)
 const ChunkManager = {
 enabled:true,
 warmupFrames:0,
 update(){ /* selection-window LOD handled in renderArray/updateFocus */ }
 };
 function renderArray(arr){
 // Skip rendering if array is being deleted
 if(arr._deleting) return;
 
 // Prune any stale chunk meshes first
 pruneStaleChunkMeshes(arr.id);
 
 // Wireframe "cage" frame with interior lookthrough fill (does not occlude voxels)
 if(!arr._frame){
 const group = new THREE.Group();

 // Frame removed: using clipping planes instead of stencil slab

 // 2) Structural rounded-edge cage
 const scale = arrayVoxelScale(arr);
 const framePad = clampedScaleOffset(scale, 0.6);
 const frameGeom = new RoundedBoxGeometry(
 arr.size.x*scale + 2*framePad,
 arr.size.y*scale + 2*framePad,
 arr.size.z*scale + 2*framePad,
 3, 0.2
 );
 const edges = new THREE.EdgesGeometry(frameGeom);
 // Remove wireframe cage per request (keep edges object construction for potential future use but do not add)
 // const edgeLines = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: COLORS.frame, transparent: true, opacity: 0.45 }));
 // edgeLines.renderOrder = 20; // draw after fill
 // group.add(edgeLines);

 group.userData = {};
 // Array label sprite positioned near the front-left corner of the grab handle
 try{
 const labelSprite = makeArrayLabelSprite(arr);
 // Front-left corner of the array bounds (grab handle lives here)
 const scale = arrayVoxelScale(arr);
 const corner = new THREE.Vector3(
 -(arr.size.x*scale/2 + clampedScaleOffset(scale, 0.4)),
 arr.size.y*scale/2 + clampedScaleOffset(scale, 1.2),
 arr.size.z*scale/2 + clampedScaleOffset(scale, 0.4)
 );
 labelSprite.position.copy(corner);
 labelSprite.userData.billboard = true;
 // Left-align text from the corner. The sprite is center-anchored, so offset half the width along +X.
 try{ const w = labelSprite.scale.x; labelSprite.position.x += (w*0.5); }catch{}
 // Ensure it renders above voxels but depth-tested so it sorts by distance
 try{ labelSprite.material.depthTest = true; labelSprite.material.depthWrite = false; }catch{}
 group.add(labelSprite);
 group.userData.labelSprite = labelSprite;
 }catch{}
 arr._frame = group;
 // Hook: minimal diagnostics like colorfix
 try{
 arr._frame.userData.renderDiag = function(){
 const lines = [
 `ToneMapping: ${renderer.toneMapping === THREE.NoToneMapping ? 'None' : renderer.toneMapping}`,
 `outputColorSpace: ${renderer.outputColorSpace}`
 ];
 const z = 0;
 const types=['empty','filled','formula','ghost'];
 for(const t of types){
 const rec=layerMeshes.get(`${arr.id}:${z}:${t}`);
 lines.push(`${t}.instanceColor: ${!!(rec && rec.mesh && rec.mesh.instanceColor)}`);
 }
 console.log(lines.join('\n'));
 }
 }catch{}
 scene.add(arr._frame);
 }
 // center frame at array offset like voxels
 const off=arr.offset||{x:0,y:0,z:0};
 arr._frame.position.set(off.x,off.y,off.z);
 try{ refreshLightsForArray(arr.id); }catch{}
 // No in-scene d-pad overlay (HUD-only)
 buildAxes(arr);
 // Reparent any chunk meshes/shells under frame to ensure center alignment
 try{
 Object.values(arr.chunks||{}).forEach(ch=>{
 if(ch.meshLOD1 && ch.meshLOD1.parent!==arr._frame){ arr._frame.add(ch.meshLOD1); }
 if(ch.meshGhost && ch.meshGhost.parent!==arr._frame){ arr._frame.add(ch.meshGhost); }
 if(ch.meshShell && ch.meshShell.parent!==arr._frame){ arr._frame.add(ch.meshShell); }
 });
 if(arr._arrayShell && arr._arrayShell.parent!==arr._frame){ arr._frame.add(arr._arrayShell); }
 }catch{}
 const sel = Store.getState().selection;
 const isFocused = (sel.arrayId === arr.id);
 const focus = isFocused && sel.focus ? {...sel.focus} : null;
 const cellCount = Object.values(arr.chunks).reduce((n,ch)=> n + ch.cells.length, 0);
 // Prefer filled cell count for LOD2 decisions; empty arrays should keep LOD1 visible
 let filledCount = 0;
 try{
 Object.values(arr.chunks).forEach(ch=>{
 for(let i=0;i<ch.cells.length;i++){
 const c = ch.cells[i];
 if(!c) continue;
 if((c.value!=='' && c.value!==null && c.value!==undefined) || !!c.formula) { filledCount++; }
 }
 });
 }catch{}
 const wantGreedy = filledCount >= INACTIVE_GREEDY_THRESHOLD;

 // Use new GPU cutaway system via chunks only when ChunkManager is enabled
 if(Scene.ChunkManager && Scene.ChunkManager.enabled){
 // Single source of truth: chunk occlusion only. Ensure legacy meshes are removed.
 try{
 for(let z=0; z<arr.size.z; z++){
 ['empty','ghost','filled','formula','edges'].forEach(type=>{
 const key = `${arr.id}:${z}:${type}`;
 const rec = layerMeshes.get(key);
 if(rec){ if(arr._frame) arr._frame.remove(rec.mesh); else scene.remove(rec.mesh); rec.mesh.geometry?.dispose?.(); rec.mesh.material?.dispose?.(); layerMeshes.delete(key); }
 });
 }
 }catch{}
 // Remove legacy layer meshes to prevent flashing when chunks are ON
 try{
 for(let z=0; z<arr.size.z; z++){
 ['empty','ghost','filled','formula','edges'].forEach(type=>{
 const key = `${arr.id}:${z}:${type}`;
 const rec = layerMeshes.get(key);
 if(rec){ if(arr._frame) arr._frame.remove(rec.mesh); else scene.remove(rec.mesh); rec.mesh.geometry?.dispose?.(); rec.mesh.material?.dispose?.(); layerMeshes.delete(key); }
 });
 }
 }catch{}
 // Gate chunk work to the focused window only
 const warm = (Scene.ChunkManager.warmupFrames||0) > 0;
 if(isFocused && focus){
 try{
 const fc = chunkOf(focus.x, focus.y, focus.z);
 for(const ch of Object.values(arr.chunks)){
 const dx = Math.abs(ch.coord.x - fc.x);
 const dy = Math.abs(ch.coord.y - fc.y);
 const dz = Math.abs(ch.coord.z - fc.z);
 const near = (dx <= WINDOW_CHUNK_RADIUS && dy <= WINDOW_CHUNK_RADIUS && dz <= WINDOW_CHUNK_RADIUS);
 if(warm){ ch.ensureMesh?.(); ch.setLOD?.(1); }
 else if(near){ ch.ensureMesh?.(); ch.setLOD?.(1); }
 else { if (cellCount >= INACTIVE_GREEDY_THRESHOLD) { ch.setLOD?.(2); } else { ch.ensureMesh?.(); ch.setLOD?.(1); } }
 }
 }catch{}
 try{ applyCutaway(arr, focus); }catch{}
 } else {
 try{
 for(const ch of Object.values(arr.chunks)){
 const warmSelf = (arr._warmupFrames|0) > 0;
 if(Scene.ChunkManager.warmupFrames>0 || warmSelf){ ch.ensureMesh?.(); ch.setLOD?.(1); }
 else if (filledCount >= INACTIVE_GREEDY_THRESHOLD) { ch.setLOD?.(2); }
 else { ch.ensureMesh?.(); ch.setLOD?.(1); }
 }
 }catch{}
 }
 // Whole-array highlight shell: behind cell fills; slightly larger; functionally invisible core
 try{
 const sh=ensureArrayHighlightShell(arr); if(sh){
 sh.visible=!arr.hidden;
 sh.traverse(n=>{ if(n.isMesh){ n.material.depthTest=true; n.material.depthWrite=false; } });
 sh.children?.forEach?.(m=>{ if(m?.isMesh && m.material?.stencilWrite){ m.renderOrder = 290; } });
 }
 }catch{}
 if(Scene.ChunkManager.warmupFrames>0){ Scene.ChunkManager.warmupFrames--; }
 if((arr._warmupFrames|0) > 0){ arr._warmupFrames--; }
 } else {
 // Ensure any previously created chunk twin meshes are hidden when chunks are OFF
 try{
 Object.values(arr.chunks).forEach(ch=>{
 if(ch.meshLOD1) ch.meshLOD1.visible=false;
 if(ch.meshGhost) ch.meshGhost.visible=false;
 if(ch.meshShell) ch.meshShell.visible=false;
 });
 }catch{}
 // Whole-array highlight shell in legacy mode as well
 try{ ensureArrayHighlightShell(arr); }catch{}
 }

 // Head-on slab mode detection: when looking down +Z or -Z, hide greedy LOD2 so occluded layers don't appear filled
 try{
 const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
 const headOnZ = (Math.abs(dir.z) >= Math.max(Math.abs(dir.x), Math.abs(dir.y)) && Math.abs(dir.z) > 0.92);
 arr._headOnZ = !!headOnZ;
 // Compute a view signature (major axis + relative layer) to avoid unnecessary rebuilds
 const ax = Math.abs(dir.x), ay = Math.abs(dir.y), az = Math.abs(dir.z);
 const major = (az >= ax && az >= ay) ? 'Z' : (ax >= ay ? 'X' : 'Y');
 const sel = Store.getState().selection || {};
 const focus = (sel.arrayId === arr.id) ? sel.focus : null;
 const relLayer = (major==='Z') ? (focus?.z ?? null) : (major==='X' ? (focus?.x ?? null) : (focus?.y ?? null));
 const viewSig = `${major}:${relLayer==null?'n':relLayer}:${arr._headOnZ?1:0}`;
 if(arr._viewSig === viewSig && arr._layersRendered){
 // View signature unchanged; skip expensive layer rebuild
 return;
 }
 arr._viewSig = viewSig;
 }catch{ arr._headOnZ = false; }

 // Do not destroy existing layer meshes; they will be updated/hid as needed for performance
 arr._layersRendered = true;
 syncVisibility(arr);
 debounceColliderRebuild(arr);
 // Rehydrate value sprites for this array after render
 try{
 const vs = window.valueSprites || new Map();
 vs.forEach((sprite,key)=>{ if(String(key).startsWith(`${arr.id}:`)){ try{ unmarkBillboard(sprite); sprite.parent?.remove(sprite); sprite.material?.map?.dispose?.(); sprite.material?.dispose?.(); }catch{} vs.delete(key); } });
 Object.values(arr.chunks||{}).forEach(ch=>{
 (ch.cells||[]).forEach(c=>{
 try{
 const cell = Formula.getCell({arrId: arr.id, x:c.x, y:c.y, z:c.z});
 if(cell && (cell.value!=='' && cell.value!==null && cell.value!==undefined)) updateValueSprite(arr, c.x, c.y, c.z, cell);
 }catch{}
 });
 });
 updateArrayValueSpritePlacement(arr);
 }catch{}
 }

 function renderChunk(arrayId, chunk, size){
 const arr = Store.getState().arrays[arrayId];
 // Skip rendering if array is being deleted
 if(arr?._deleting) return;
 
 const mKey = `${arrayId}:${keyChunk(chunk.coord.x,chunk.coord.y,chunk.coord.z)}`;

 // Get or create once (no shadowing)
 let mesh = chunkMeshes.get(mKey);
 if (!mesh) {
 mesh = new THREE.InstancedMesh(GEO_VOXEL.clone(), createCellMaterial('filled'), Math.max(1, chunk.cells.length));
 mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
 mesh.frustumCulled = false;
 mesh.userData = { arrayId, chunkKey: keyChunk(chunk.coord.x,chunk.coord.y,chunk.coord.z) };
 chunkMeshes.set(mKey, mesh);
 // Parent to frame for consistent movement
 if (arr._frame) arr._frame.add(mesh); else scene.add(mesh);
 }

 // Ensure instanceColor exists & matches count
 const count = chunk.cells.length;
 if (mesh.instanceColor == null || mesh.instanceColor.count !== count) {
 mesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(Math.max(1, count) * 3), 3);
 mesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
 // Seed with white to prevent black cells
 const seed = new THREE.Color(0xffffff).convertSRGBToLinear();
 for (let i = 0; i < Math.max(1, count); i++) mesh.setColorAt(i, seed);
 }

 // Fill transforms & per-instance colors from live cell state (treat as atomic unit)
 const scale = arrayVoxelScale(arr);
 for (let i = 0; i < count; i++) {
 const c = chunk.cells[i];

 // Use fast accessor for live value/meta including custom colors
 const fresh = getCellFast(arrayId, { x: c.x, y: c.y, z: c.z });
 const has = (fresh.value !== '' && fresh.value !== null && fresh.value !== undefined);
 const isFormula = !!fresh.formula;
 const key = `${arrayId}:${c.x},${c.y},${c.z}`;
 const emitted = !!(Store.getState().sourceByCell?.get?.(key));
 const custom = fresh?.meta?.color;

 let hex = has ? COLORS.filled : COLORS.empty;
 if (isFormula) hex = COLORS.formula;
 else if (emitted) hex = COLORS.emitted;

 // Use local position for frame-relative rendering; zero rotation/scale (centered)
 temp.position.copy(localPos(arr, c.x, c.y, c.z));
 temp.rotation.set(0,0,0);
 temp.scale.set(scale,scale,scale);
 temp.updateMatrix();
 mesh.setMatrixAt(i, temp.matrix);

 const col = new THREE.Color(custom || hex);
 col.convertSRGBToLinear();
 mesh.setColorAt(i, col);
 }

 mesh.count = count;
 mesh.instanceMatrix.needsUpdate = true;
 if (mesh.instanceColor) mesh.instanceColor.needsUpdate = true;
 }
 function ensureLayerMesh(arr, z, type, capacity){
 const key = `${arr.id}:${z}:${type}`;
 let rec = layerMeshes.get(key);
 const cap = Math.max(1, capacity);

 const makeMesh = (cap) => {
 const geom = GEO_VOXEL.clone(); addWhiteVertexColors(geom);
 const baseType = (type && String(type).startsWith('ghost')) ? 'ghost' : (type||'filled');
 const mesh = new THREE.InstancedMesh(geom, createCellMaterial(baseType), cap);
 mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
 mesh.frustumCulled = false;
 mesh.userData = { arrayId: arr.id, z, type, isGhost: baseType==='ghost' };
 if(baseType==='ghost'){
 // Ghost: unlit, depth-tested, above solids
 mesh.material = new THREE.MeshBasicMaterial({
 color: 0xffffff,
 transparent: true,
 opacity: 0.20,
 depthWrite: false,
 depthTest: true,
 vertexColors: true,
 blending: THREE.AdditiveBlending
 });
 mesh.material.toneMapped = false;
 mesh.renderOrder = 2;
 }
 // Parent under frame and use local positions for tight alignment
 if(arr._frame) arr._frame.add(mesh); else scene.add(mesh);
 return mesh;
 };

 if (!rec) {
 const mesh = makeMesh(cap);
 // Ensure instanceColor is allocated and seeded
 if (mesh.instanceColor == null || mesh.instanceColor.count !== cap) {
 mesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(cap*3), 3);
 mesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
 // Seed with sRGB white -> linear to avoid black first frame
 const seed = new THREE.Color(0xffffff).convertSRGBToLinear();
 for (let i = 0; i < cap; i++) mesh.setColorAt(i, seed);
 }
 // Seed with white to avoid black cells
 const seed = new THREE.Color(0xffffff).convertSRGBToLinear();
 for (let i = 0; i < cap; i++) mesh.setColorAt(i, seed);
 rec = { mesh, capacity: cap, used: 0, index2cell: [] };
 layerMeshes.set(key, rec);
 return rec;
 }

 if (capacity > rec.capacity) {
 // Grow-only: reallocate instance buffers on existing mesh
 const mesh = rec.mesh;
 try{
 const newMatrix = new THREE.InstancedBufferAttribute(new Float32Array(capacity * 16), 16);
 mesh.instanceMatrix = newMatrix;
 mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
 if(mesh.instanceColor){
 mesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(capacity * 3), 3);
 mesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
 // Seed expanded buffer with white
 const seed = new THREE.Color(0xffffff).convertSRGBToLinear();
 for (let i = 0; i < capacity; i++) mesh.setColorAt(i, seed);
 }
 }catch{}
 rec.capacity = capacity;
 rec.index2cell.length = 0;
 if (mesh.instanceColor) mesh.instanceColor.needsUpdate = true;
 }
 return rec;
 }
 function renderLayer(arr, z){
 // LEGACY LAYER PIPELINE REMOVED use chunk SoT exclusively
 return;
 }

 function renderCellGroup(arr, z, type, cellData){
 const key=`${arr.id}:${z}:${type}`;
 const capacity = Math.max(1, cellData.length);
 const rec = ensureLayerMesh(arr, z, type, capacity);
 const mesh = rec.mesh;
 rec.index2cell.length = 0;
 if(cellData.length === 0){
 // Swap behavior: if this is a ghost group, ensure corresponding solid group is visible; otherwise hide this group
 mesh.count = 0;
 mesh.visible = false;
 return;
 }
 const geom = GEO_VOXEL.clone();
 const GREEN = {dark:0x16a34a, light:0x86efac};
 const BLUE = 0x3b82f6;
 const WHITE = 0xffffff;
 // Map ghost variants to ghost material
 const baseType = (type && type.startsWith('ghost')) ? 'ghost' : type;
 mesh.userData = { arrayId: arr.id, z, type, isGhost: baseType==='ghost' };
 // Improve pickability: avoid incorrect culling bounds on instanced voxels
 mesh.frustumCulled = false;

 // ?? Click-through for ghost:
 if (baseType === 'ghost') {
 // never receive ray hits
 mesh.raycast = () => {};
 // Replace with unlit additive pass so it lightens instead of darkens
 if(!(mesh.material && mesh.material.isMeshBasicMaterial)){
 mesh.material = new THREE.MeshBasicMaterial({
 color: 0xffffff,
 transparent: true,
 opacity: 0.20,
 depthWrite: false,
 depthTest: true,
 vertexColors: true,
 blending: THREE.AdditiveBlending
 });
 }
 mesh.material.toneMapped = false;
 mesh.renderOrder = 2;
 } else {
 // Make sure opaque pass wins z-buffer and renders above frames
 mesh.material.transparent = false;
 mesh.material.depthWrite = true;
 mesh.renderOrder = 1; // render above frames (renderOrder 0)
 }

 // Shadows disabled in simple mode

 // place instances + per-instance color for ghost "chain" visualization
 const index2cell = cellData.map(cd => cd.c);
 const useColors = (baseType==='ghost' || baseType==='filled' || baseType==='formula');
 if(useColors && (mesh.instanceColor == null || (mesh.instanceColor && mesh.instanceColor.count !== cellData.length))){
 mesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(cellData.length*3), 3);
 mesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
 }
 // Ensure outline overlay exists and is kept in sync for the same group key
 const overlayKey = `${arr.id}:${z}:${type}:edges`;
 let overlayRec = layerMeshes.get(overlayKey);
 if(!overlayRec){ addEdgeOverlay(`${arr.id}:${z}:${type}`, arr, z, cellData); overlayRec = layerMeshes.get(overlayKey); }
 else {
 // Update transforms and colors for overlays without recreating
 const borders = overlayRec.mesh;
 if(borders.count !== cellData.length){
 borders.count = cellData.length;
 if(!borders.instanceColor || borders.instanceColor.count !== cellData.length){
 borders.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(cellData.length*3),3);
 borders.instanceColor.setUsage(THREE.DynamicDrawUsage);
 }
 }
 for(let i=0;i<cellData.length;i++){
 const {c, freshCell} = cellData[i];
 const pos = localPos(arr,c.x,c.y,c.z);
 temp.position.copy(pos);
 temp.updateMatrix();
 borders.setMatrixAt(i, temp.matrix);
 try{
 const key=`${arr.id}:${c.x},${c.y},${c.z}`;
 const fresh = freshCell || Scene.getCell(arr.id,{x:c.x,y:c.y,z:c.z});
 const has = (fresh.value!=='' && fresh.value!==null && fresh.value!==undefined);
 const isFormula = !!fresh.formula;
 const emitted = !!(Store.getState().sourceByCell && Store.getState().sourceByCell.get && Store.getState().sourceByCell.get(key));
 const tk2 = isFormula ? 'formula' : (emitted ? 'emitted' : (has ? 'value' : 'empty'));
 const { colorHex: overrideOutline2 } = outlineParamsForTypeKey(tk2);
 const baseHex2 = baseHexForTypeKey(tk2);
 const col2 = new THREE.Color( (typeof overrideOutline2==='number') ? overrideOutline2 : baseHex2 );
 if(typeof overrideOutline2!=='number'){ col2.offsetHSL(0,0,-0.25); }
 col2.convertSRGBToLinear();
 borders.setColorAt(i, col2);
 }catch{}
 }
 borders.instanceMatrix.needsUpdate = true;
 if(borders.instanceColor) borders.instanceColor.needsUpdate = true;
 borders.visible = true;
 }
 const isCellEmitted = (arr, c) => {
 const key = `${arr.id}:${c.x},${c.y},${c.z}`;
 return !!(Store.getState().sourceByCell && Store.getState().sourceByCell.get && Store.getState().sourceByCell.get(key));
 };
 for(let i=0; i<cellData.length; i++){
 const {c, freshCell} = cellData[i];
 const pos = localPos(arr,c.x,c.y,c.z);
 const scale = arrayVoxelScale(arr);
 temp.position.copy(pos);
 temp.scale.set(scale, scale, scale);
 temp.updateMatrix();
 mesh.setMatrixAt(i, temp.matrix);
 if(useColors){
 // Ghost categories by group, else per-cell meta color for solids
 if(baseType==='ghost'){
 let colorHex = WHITE;
 if(type==='ghost_source') colorHex = GREEN.dark;
 else if(type==='ghost_emitted') colorHex = GREEN.light;
 else if(type==='ghost_value') colorHex = BLUE;
 else if(type==='ghost_empty') colorHex = WHITE;
 { const col=new THREE.Color(colorHex); col.convertSRGBToLinear(); mesh.setColorAt(i, col); }
 } else {
 const custom = freshCell?.meta?.color;
 let hex;
 if(baseType==='formula') hex = baseHexForTypeKey('formula'); 
 else if(isCellEmitted(arr, c)) hex = baseHexForTypeKey('emitted'); 
 else hex = baseHexForTypeKey('value');
 { const col=new THREE.Color(custom || hex); col.convertSRGBToLinear(); mesh.setColorAt(i, col); }
 }
 }
 }
 if(useColors && mesh.instanceColor) mesh.instanceColor.needsUpdate = true;
 mesh.visible = true;

 mesh.count = cellData.length;
 mesh.instanceMatrix.needsUpdate = true;
 layerMeshes.set(key, {mesh, capacity: Math.max(rec.capacity, cellData.length), used: cellData.length, index2cell});
 }
 function addEdgeOverlay(baseKey, arr, z, cellData, colorHex){
 const key = `${baseKey}:edges`;
 const old = layerMeshes.get(key);
 if(old){ if(arr._frame) arr._frame.remove(old.mesh); else scene.remove(old.mesh); old.mesh.geometry.dispose(); old.mesh.material.dispose(); }

 if(cellData.length === 0) return;

 // Create rounded borders using scaled-down rounded cubes
 const tk = typeKeyFrom(baseKey.split(':').pop());
 const { thickness, colorHex: overrideOutline, opacity } = outlineParamsForTypeKey(tk);
 const borderGeom = new RoundedBoxGeometry(thickness, thickness, thickness, 3, 0.15); // slightly larger, inverted hull
 const borderMat = new THREE.MeshBasicMaterial({ 
 color: (typeof overrideOutline === 'number' ? overrideOutline : (typeof colorHex==='number'?colorHex:0xffffff)), 
 transparent: true, 
 opacity: (String(baseKey).includes('ghost') ? Math.max(0, Math.min(1, opacity*0.8)) : opacity),
 side: THREE.BackSide,
 depthTest: true,
 depthWrite: false,
 vertexColors: true
 });
 borderMat.toneMapped = false;
 const borders = new THREE.InstancedMesh(borderGeom, borderMat, cellData.length);
 borders.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
 // Allocate per-instance colors for outlines (darker variants of base color)
 if(!borders.instanceColor || borders.instanceColor.count !== cellData.length){
 borders.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(cellData.length*3), 3);
 borders.instanceColor.setUsage(THREE.DynamicDrawUsage);
 }
 borders.userData = { arrayId: arr.id, z, type:'edges', kind:'edgeOverlay' };
 borders.frustumCulled = false;
 borders.renderOrder = 2;

 for(let i=0;i<cellData.length;i++){
 const {c, freshCell} = cellData[i] || {c:null,freshCell:null};
 const pos = localPos(arr,c.x,c.y,c.z);
 temp.position.copy(pos);
 temp.updateMatrix();
 borders.setMatrixAt(i, temp.matrix);
 // Per-instance darker outline color based on base cell color
 try{
 const key=`${arr.id}:${c.x},${c.y},${c.z}`;
 const fresh = freshCell || Scene.getCell(arr.id,{x:c.x,y:c.y,z:c.z});
 const has = (fresh.value!=='' && fresh.value!==null && fresh.value!==undefined);
 const isFormula = !!fresh.formula;
 const emitted = !!(Store.getState().sourceByCell && Store.getState().sourceByCell.get && Store.getState().sourceByCell.get(key));
 const baseHex = isFormula ? COLORS.formula : emitted ? COLORS.emitted : (has ? COLORS.filled : COLORS.empty);
 const col = new THREE.Color(baseHex);
 col.offsetHSL(0, 0, -0.25); // darker
 col.convertSRGBToLinear();
 borders.setColorAt(i, col);
 }catch{}
 }
 borders.count = cellData.length;
 borders.instanceMatrix.needsUpdate = true;
 if(borders.instanceColor) borders.instanceColor.needsUpdate = true;

 // Parent to frame; use local positions to stay aligned
 if(arr._frame) arr._frame.add(borders); else scene.add(borders);
 layerMeshes.set(key, {mesh:borders, capacity: cellData.length, used: cellData.length, index2cell: cellData.map(cd=>cd.c)});
 }
 function buildAxes(arr){
 // remove old
 // Remove previous labels safely from their actual parent
 arr.labels?.forEach(s=>{ try{ if(s?.userData?.billboard) unmarkBillboard(s); s.parent?.remove(s); s.material?.dispose?.(); s.material?.map?.dispose?.(); s.geometry?.dispose?.(); }catch{} }); arr.labels=[];
 const mk=(txt,color='#333333')=>{
 const c=document.createElement('canvas'); const ctx=c.getContext('2d'); const fs=64;
 ctx.font=`900 ${fs}px 'Roboto Mono', monospace`; const w=Math.ceil(ctx.measureText(txt).width);
 c.width=w+24; c.height=fs+24;
 // Transparent background
 ctx.clearRect(0,0,c.width,c.height);
 ctx.fillStyle=color; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font=`900 ${fs}px 'Roboto Mono', monospace`;
 ctx.fillText(txt,c.width/2,c.height/2);
 const t=new THREE.CanvasTexture(c);
 t.colorSpace = THREE.SRGBColorSpace;
 // Depth test true so it sorts by distance; write false to avoid z artifacts
 const m=new THREE.SpriteMaterial({map:t,depthTest:true,depthWrite:false,transparent:true});
 m.toneMapped = false;
 const s=new THREE.Sprite(m);
 const targetH=0.6; // consistent height in world units
 const aspect=c.width/c.height; s.scale.set(targetH*aspect, targetH, 1);
 return markBillboard(s);
 };
 const X=arr.size.x,Y=arr.size.y,Z=arr.size.z;
 const scale = arrayVoxelScale(arr);
 const grabSize=0.7; // smaller rounded voxel for handle
 const halfStep = scale/2;
 const origin=localPos(arr,0,0,0); // local center of A1a (top row)
 const topFaceY = origin.y + halfStep;
 const frontFaceZ = origin.z + halfStep;
 const leftFaceX = origin.x - halfStep;
 // Fine-tune label offsets relative to grab/cell centers. Scale with voxel spacing so labels track edges.
 const LABEL_Y_DOWN = 0.12 * scale; // nudge downwards a touch
 const LABEL_X_RIGHT_Y_AXIS = 0.12 * scale; // Y-axis numbers slightly to the right
 const LABEL_Z_BACK = 0.06 * scale; // slight push back along -Z when near grab

 // Only rebuild grab if not already present to avoid stamping
 let grab = arr.labels?.find(l=>l.userData?.type==='grab');
 if(!grab){
 const grabMat=new THREE.MeshBasicMaterial({color:COLORS.grab, depthWrite:true});
 grab=new THREE.Mesh(new RoundedBoxGeometry(grabSize,grabSize,grabSize,3,Math.min(.2,grabSize*.25)), grabMat);
 grab.userData={type:'grab', arrayId:arr.id};
 // Parent grab to frame so it follows
 if(arr._frame) arr._frame.add(grab); else scene.add(grab);
 try{ if(arr._frame) arr._frame.userData.grab = grab; }catch{}
 }
 const grabX = leftFaceX - grabSize/2;
 const grabY = topFaceY + grabSize/2;
 const grabZ = frontFaceZ + grabSize/2;
 grab.position.set(grabX, grabY, grabZ);
 if(!arr.labels.includes(grab)) arr.labels.push(grab);

 // Emit axes from grab handle faces, billboarded and aligned near the grab corner
 // X headers (A..) emit from right face of grab, aligned to cell centers
 for(let x=0;x<X;x++){ 
 const s=mk(A1(x),'#ff1a1a'); s.userData.billboard=true;
 const cellPos=localPos(arr,x,0,0);
 // Align to the grab handle s back face Z, and match Z label downshift on Y
 s.position.set(cellPos.x, grabY - LABEL_Y_DOWN, grabZ);
 if(arr._frame) arr._frame.add(s); else scene.add(s); arr.labels.push(s);
 }
 // Y headers (1..) top row is 1, increase downward
 for(let y=0;y<Y;y++){
 const s=mk(String(y+1),'#00e676'); s.userData.billboard=true;
 const cellPos=localPos(arr,0,y,0);
 // Align near grab: slightly right on X, slightly down on Y, slightly back on Z
 s.position.set(grabX + LABEL_X_RIGHT_Y_AXIS, cellPos.y - LABEL_Y_DOWN, grabZ - LABEL_Z_BACK);
 if(arr._frame) arr._frame.add(s); else scene.add(s); arr.labels.push(s);
 }
 // Z headers (a..) emit negatively along Z, aligned to the back XY face of grab
 for(let z=0;z<Z;z++){
 const s=mk(greek(z),'#0066ff'); s.userData.billboard=true;
 const cellPos=localPos(arr,0,0,z);
 // Emit along Z and match Y with grab center, nudged slightly down
 s.position.set(grabX, grabY - LABEL_Y_DOWN, cellPos.z);
 if(arr._frame) arr._frame.add(s); else scene.add(s); arr.labels.push(s);
 }

 // In-scene D-Pad removed (use HUD)

 arr.labels.forEach(s=>s.visible=Store.getState().scene.showAxes);
 }
 // ensureNavPad removed

 function syncVisibility(arr){
 const v=!arr.hidden; 
 if(arr._frame) arr._frame.visible=v;
 // update layer meshes visibility
 for(let z=0; z<arr.size.z; z++){
 ['empty','ghost','filled','formula','edges'].forEach(type=>{
 const rec=layerMeshes.get(`${arr.id}:${z}:${type}`); if(rec) rec.mesh.visible=v;
 });
 }
 // chunk meshes
 const scale = arrayVoxelScale(arr);
 Object.values(arr.chunks).forEach(ch=>{
 if(ch.meshLOD2) ch.meshLOD2.visible = v && (ch.currentLOD===2);
 if(ch.meshLOD1){
 const pickVisible = v && (ch.currentLOD===1 || (ch.meshLOD2 && ch.meshLOD2.visible));
 ch.meshLOD1.visible = pickVisible;
 }
 if(ch.meshShell){
 const lod = (ch.currentLOD == null) ? 1 : ch.currentLOD;
 ch.meshShell.visible = v && (lod === 1) && !FancyGraphics.enabled;
 }
 const mk=`${arr.id}:${keyChunk(ch.coord.x,ch.coord.y,ch.coord.z)}`; const m=chunkMeshes.get(mk); if(m) m.visible=v;
 });
 // axis labels and grab handles
 const globalAxes = Store.getState().scene.showAxes;
 const localAxes = (arr.axesVisible === undefined) ? globalAxes : !!arr.axesVisible;
 arr.labels?.forEach(s=> s.visible = v && localAxes);
 // Debug: update HUD counts
 try{ updateCountChip(); }catch{}
 // Toggle value sprite visibility correctly
 valueSprites.forEach((sprite,key)=>{ if(String(key).startsWith(`${arr.id}:`)) sprite.visible = v; });
 // value sprites
 Object.keys(valueSprites).forEach(key=>{
 if(key.startsWith(`${arr.id}:`)){
 const sprite=valueSprites.get(key);
 if(sprite) sprite.visible=v;
 }
 });
 // Update debug counts after any visibility change
 try{ updateCountChip?.(); }catch{}
 // Update 2D sheet if this array becomes invisible
 if(!v && Store.getState().selection.arrayId===arr.id){
 // Switch to next visible array
 const visibleArrays=Object.values(Store.getState().arrays).filter(a=>!a.hidden);
 if(visibleArrays.length>0){
 const next=visibleArrays[0];
 Actions.setSelection(next.id, {x:0,y:Math.max(0,next.size.y-1),z:0});
 window.UI?.renderSheet();
 }
 }
 }

 // Debug HUD counts: total cell instances and split by Chunk/Legacy
 function updateCountChip(){
 try{
 let shellsChunk=0, shellsLegacy=0, fillsChunk=0, fillsLegacy=0;
 // Chunk meshes
 Object.values(Store.getState().arrays).forEach(arr=>{
 Object.values(arr.chunks||{}).forEach(ch=>{
 if(ch.meshShell) shellsChunk += (ch.meshShell.count||0);
 if(ch.meshLOD1) fillsChunk += (ch.meshLOD1.count||0);
 });
 });
 // Legacy meshes
 layerMeshes.forEach((rec,key)=>{
 if(!rec||!rec.mesh) return;
 if(String(key).endsWith(':edges')) shellsLegacy += (rec.mesh.count||0);
 else fillsLegacy += (rec.mesh.count||0);
 });
 const totalUnique = fillsChunk + fillsLegacy;
 const chip=document.getElementById('countChip'); if(chip){ chip.textContent = `Cells:${totalUnique} | Shells C/L:${shellsChunk}/${shellsLegacy} | Fills C/L:${fillsChunk}/${fillsLegacy}`; }
 }catch{}
 }

 // Debug panel to control renderOrder for voxel passes
 // Render order debug UI removed

 function forceRenderOrderRefresh(reapplyOcclusion){
 try{
 // Update chunk instanced meshes
 Object.values(Store.getState().arrays).forEach(arr=>{
 Object.values(arr.chunks||{}).forEach(ch=>{
 if(ch.meshGhost) ch.meshGhost.renderOrder = window.__RO.ghostFill|0;
 if(ch.meshLOD1) ch.meshLOD1.renderOrder = window.__RO.solidFill|0;
 if(ch.meshShell) ch.meshShell.renderOrder = window.__RO.solidShell|0;
 });
 // Update whole-array shell as Ghost Shell for debugging purposes
 if(arr._arrayShell){
 arr._arrayShell.traverse(n=>{
 if(!n.isMesh) return;
 // detect by stencil: core writes stencil, shell reads NotEqual
 if(n.material && n.material.stencilWrite && n.material.stencilFunc===THREE.AlwaysStencilFunc){
 n.renderOrder = window.__RO.frameCore|0;
 } else {
 n.renderOrder = window.__RO.frameShell|0;
 }
 });
 }
 if(reapplyOcclusion){ try{ const sel=Store.getState().selection; if(sel?.arrayId&&sel.focus){ applyGhostMaskToChunks(arr); } }catch{} }
 });
 needsRender = true;
 }catch{}
 }

 function updateFocus(sel){
 // Hide celli during derez effect
 if(celliDerezState.active){
 if(celli) celli.visible = false;
 if(arrayaAvatar) arrayaAvatar.setVisible(false);
 focusMarker.visible=false;
 selectionCelli.visible=false;
 return;
 }
 
 if(!sel.arrayId||!sel.focus){
  focusMarker.visible=false;
  selectionCelli.visible=false;
  clearSelectionCollapseClones();
  selectionCollapseState.active = false;
  selectionCollapseState.recovering = false;
  selectionCollapseState.queuedUpdate = null;
  selectionCollapseState.startPosition = null;
  selectionCollapseState.startQuaternion = null;
  if(selectionCelli.userData){
   selectionCelli.userData.collapseActive = false;
  }
  if(selectionCelli.userData){
   selectionCelli.userData.stretchState = null;
   selectionCelli.userData.lastStretchSignature = null;
  }
 selectionCelli.scale.set(1,1,1);
 if(lastFocusedArrayId){
 const prev = Store.getState().arrays[lastFocusedArrayId];
 clearOcclusion(prev);
 try{ Object.values(prev?.chunks||{}).forEach(ch=> ch._dirty = true); }catch{}
 }
 lastFocusedArrayId = null;
 try{ if(typeof animate==='function' && animate.lastOcclusionState){ animate.lastOcclusionState.signature=''; } }catch{}
 updateAvatars(sel);
 return;
 }
 const arr=Store.getState().arrays[sel.arrayId];
 // Skip if array is being deleted
 if(arr?._deleting){
 focusMarker.visible=false;
 selectionCelli.visible=false;
 return;
 }
 const scale = arrayVoxelScale(arr);
 
 // One-time occlusion clear when focus array changes; do not repeatedly clear
 if(lastFocusedArrayId && lastFocusedArrayId !== sel.arrayId){
 const prev = Store.getState().arrays[lastFocusedArrayId];
 clearOcclusion(prev);
 try{ Object.values(prev?.chunks||{}).forEach(ch=> ch._dirty = true); }catch{}
 }
 lastFocusedArrayId = sel.arrayId;
 
 const camDir=new THREE.Vector3(); camera.getWorldDirection(camDir);
 const ax=Math.abs(camDir.x), ay=Math.abs(camDir.y), az=Math.abs(camDir.z);
 let dims={x:1.06,y:1.06,z:1.06};
 let center={...sel.focus};
 let counts={x:1,y:1,z:1};
 if(sel.range){
 const {x1,x2,y1,y2}=sel.range;
 const zStart = sel.range.z1 ?? sel.range.z ?? sel.focus.z;
 const zEnd = sel.range.z2 ?? sel.range.z ?? sel.focus.z;
 const countX = (x2 - x1 + 1);
 const countY = (y2 - y1 + 1);
 const countZ = (zEnd - zStart + 1);
 counts = {x:countX,y:countY,z:countZ};
 dims={
 x: countX + 0.06,
 y: countY + 0.06,
 z: countZ + 0.06
 };
 center={
 x: x1 + (countX-1)/2,
 y: y1 + (countY-1)/2,
 z: zStart + (countZ-1)/2
 };
 if(countX===1 && ax>=ay && ax>=az) dims.x=0.06;
 if(countY===1 && ay>=ax && ay>=az) dims.y=0.06;
 if(countZ===1 && az>=ax && az>=ay) dims.z=0.06;
 } else {
 if(ax>ay && ax>az) dims.x=0.04;
 else if(ay>az) dims.y=0.04;
 else dims.z=0.04;
 }

 const hasRange = !!sel.range;
 const isMulti = hasRange && (counts.x>1 || counts.y>1 || counts.z>1);
 if(isMulti){
 selectionCelli.visible = true;
 if(focusMarker.geometry){ focusMarker.geometry.dispose?.(); }
 focusMarker.visible = false;
 updateSelectionCelliHighlight(arr, center, counts, scale, sel.faceHint);
 } else {
 selectionCelli.visible = false;
 if(selectionCelli.userData){
 selectionCelli.userData.stretchState = null;
 selectionCelli.userData.lastStretchSignature = null;
 }
 selectionCelli.scale.set(1,1,1);
 const geo=new THREE.BoxGeometry(dims.x*scale,dims.y*scale,dims.z*scale);
 if(focusMarker.geometry) focusMarker.geometry.dispose?.();
 focusMarker.geometry=geo;

 focusMarker.visible=true;
 const p=worldPos(arr,center.x,center.y,center.z);
 focusMarker.position.copy(p);
 }
 updateAvatars(sel);
 // Promote detailed window around selection immediately for performance/fidelity
 try{
 const fc = chunkOf(sel.focus.x, sel.focus.y, sel.focus.z);
 for(let cz=fc.z-WINDOW_CHUNK_RADIUS; cz<=fc.z+WINDOW_CHUNK_RADIUS; cz++)
 for(let cy=fc.y-WINDOW_CHUNK_RADIUS; cy<=fc.y+WINDOW_CHUNK_RADIUS; cy++)
 for(let cx=fc.x-WINDOW_CHUNK_RADIUS; cx<=fc.x+WINDOW_CHUNK_RADIUS; cx++){
 const k = keyChunk(cx,cy,cz); const ch = arr.chunks[k]; if(ch) ch.setLOD?.(1);
 }
 }catch{}
 // Ensure shells are present after focus changes (e.g., after load)
 try{ ensureArrayHighlightShell(arr); }catch{}
 // In-scene d-pad removed
 try {
 window.UI?.inspect(arr, sel.focus);
 // Trigger occlusion recompute on selection change as well
 if(typeof animate==='function' && animate.lastOcclusionState){ animate.lastOcclusionState.signature = ''; }
 } catch(e) {
 console.warn('Inspect failed:', e);
 }
 }
 function centerOnArray(arr){ 
 if(!arr) return; 
 const off=arr.offset||{x:0,y:0,z:0};
 const scale = arrayVoxelScale(arr);
 // Look at center of array, not just the offset
 const centerY = off.y + (arr.size.y * scale) / 2;
 controls.target.set(off.x, centerY, off.z);
 // Position camera above and in front for good viewing angle
 camera.position.set(
 off.x + arr.size.x*scale*1.2,
 centerY + arr.size.y*scale*1.5,
 off.z + arr.size.z*scale*1.8
 );
 }

 function centerOnPlayer(){
 const px = Number.isFinite(cachedPlayerPos.x) ? cachedPlayerPos.x : 0;
 const py = Number.isFinite(cachedPlayerPos.y) ? cachedPlayerPos.y : 2;
 const pz = Number.isFinite(cachedPlayerPos.z) ? cachedPlayerPos.z : 0;
 controls.target.set(px,py,pz);
 camera.position.set(px+6, py+4, pz+8);
 }
 function setPhysicsCamera(mode='free', distance, allowRotation=false){
 const next = {
 mode: (mode || physicsCameraConfig.mode || 'free').toLowerCase(),
 distance: Number.isFinite(distance) ? Math.max(2, distance) : (Number.isFinite(physicsCameraConfig.distance) ? physicsCameraConfig.distance : 10),
 allowRotation: !!allowRotation
 };
 physicsCameraConfig = next;
 if(!camera || !controls) return physicsCameraConfig;
 const target = controls.target ? controls.target.clone() : new THREE.Vector3(0,0,0);
 const dist = physicsCameraConfig.distance || 10;
 const modeKey = physicsCameraConfig.mode;
 if(modeKey === '2d' || modeKey === 'locked' || modeKey === 'side'){
 camera.position.set(target.x + dist, target.y + dist * 0.35, target.z);
 controls.enableRotate = physicsCameraConfig.allowRotation;
 controls.enablePan = true;
 } else if(modeKey === 'iso' || modeKey === 'isometric'){
 const diag = dist / Math.sqrt(3);
 camera.position.set(target.x + diag, target.y + diag, target.z + diag);
 controls.enableRotate = physicsCameraConfig.allowRotation;
 controls.enablePan = true;
 } else {
 camera.position.set(target.x + dist * 0.4, target.y + dist * 0.45, target.z + dist);
 controls.enableRotate = true;
 controls.enablePan = true;
 }
 if(!physicsCameraConfig.allowRotation && controls){
 controls.enableRotate = false;
 }
 controls.update?.();
 needsRender = true;
 return physicsCameraConfig;
 }
 /* ---- Physics: merged colliders per connected run ---- */
 function clearColliders(arr){
 if(!rapierWorld) return;
 arr._colliders = arr._colliders || [];
 arr._rigidBodies = arr._rigidBodies || [];
 arr._joints = arr._joints || [];

 arr._joints.forEach(h=>{ try{ rapierWorld.removeImpulseJoint(h, true); }catch{} });
 arr._joints.length = 0;

 arr._colliders.forEach(h=>{ try{ rapierWorld.removeCollider(h,true); }catch{} });
 arr._colliders.length=0;

 arr._rigidBodies.forEach(h=>{
 try{
 const body = rapierWorld.getRigidBody(h);
 if(body){ rapierWorld.removeRigidBody(body); }
 }catch{}
 });
 arr._rigidBodies.length = 0;
 }

 function debounceColliderRebuild(arr){
 arr._collidersBuilding = true;
 if(colliderRebuildQueue.has(arr.id)) {
 clearTimeout(colliderRebuildQueue.get(arr.id));
 }
 const timeoutId = setTimeout(()=>{
 try { rebuildCollidersForArray(arr); }
 finally { arr._collidersBuilding = false; }
 colliderRebuildQueue.delete(arr.id);
 }, 50);
 colliderRebuildQueue.set(arr.id, timeoutId);
 }
 function rebuildCollidersForArray(arr){
 if(!rapierWorld) return;
 if(!Store.getState().scene.physics) return;
 
 // In physics mode, ALL arrays should have colliders so Celli can walk on them
 // The collision mode determines behavior (exit to edit vs continue physics), not whether colliders exist
 const debugMode = !!Store.getState().scene?.physicsDebugAll;
 const hasPhysicsParam = !!arr?.params?.physics?.enabled;
 const effectiveMode = determineCollisionMode(arr, null, { debugMode });

 console.log(`[PHYSICS] rebuildCollidersForArray: array=${arr.id} "${arr.name}", debug=${debugMode}, hasPhysicsParam=${hasPhysicsParam}, effectiveMode=${effectiveMode}`);
 
 arr._colliders = arr._colliders || [];
 arr._rigidBodies = arr._rigidBodies || [];
 arr._joints = arr._joints || [];

 clearColliders(arr);
 
 // Build colliders for all arrays when in physics mode
 // This allows Celli to land on any array; exitPhysicsOnNonEnabledArray handles the mode switch
 console.log(`[PHYSICS] ? Building colliders for array #${arr.id} "${arr.name}" (mode=${effectiveMode})`);
 
 const scale = arrayVoxelScale(arr);
 const staticOcc = new Map();
 const grouped = new Map(); // id -> {cells:Map,key->cell,pivots:[]}
 let staticSolidCount = 0;
 let groupedSolidCount = 0;

 Object.values(arr.chunks).forEach(ch=>{
 ch.cells.forEach(c=>{
 const meta = c.meta || {};
 const hasValue = (c.value!=='' && c.value!==null && c.value!==undefined);
 const hasFormula = !!c.formula;
 const hasColor = !!meta.color;
 const isSolid = hasValue || hasFormula || hasColor;
 if(!isSolid) return;
 const rawGroup = meta.physicsGroupId;
 const groupId = (rawGroup===undefined||rawGroup===null||rawGroup==='') ? null : String(rawGroup);
 if(groupId){
 let info = grouped.get(groupId);
 if(!info){
 info = { cells:new Map(), pivots:[] };
 grouped.set(groupId, info);
 }
 const key = `${c.x},${c.y},${c.z}`;
 if(!info.cells.has(key)){
 info.cells.set(key, {x:c.x,y:c.y,z:c.z,meta});
 groupedSolidCount++;
 }
 if(meta.physicsPivot){
 info.pivots.push({x:c.x,y:c.y,z:c.z});
 }
 } else {
 staticOcc.set(`${c.x},${c.y},${c.z}`, {x:c.x,y:c.y,z:c.z,meta});
 staticSolidCount++;
 }
 });
 });

 const buildBoxesFromKeys = (keyStrings)=>{
 const keySet = new Set(keyStrings);
 const visited = new Set();
 const boxes = [];
 const keyOf = (x,y,z)=>`${x},${y},${z}`;
 const has = (x,y,z)=> keySet.has(keyOf(x,y,z));
 for(const key of keyStrings){
 if(visited.has(key)) continue;
 const parts = key.split(',').map(n=>+n);
 let [x,y,z] = parts;
 let x2=x;
 while(has(x2+1,y,z) && !visited.has(keyOf(x2+1,y,z))) x2++;
 let y2=y;
 outerY: while(true){
 const ny=y2+1;
 if(!has(x,ny,z)) break;
 for(let xi=x; xi<=x2; xi++){
 if(!has(xi,ny,z) || visited.has(keyOf(xi,ny,z))) break outerY;
 }
 y2=ny;
 }
 let z2=z;
 outerZ: while(true){
 const nz=z2+1;
 for(let yi=y; yi<=y2; yi++){
 for(let xi=x; xi<=x2; xi++){
 if(!has(xi,yi,nz) || visited.has(keyOf(xi,yi,nz))) break outerZ;
 }
 }
 if(!has(x,y,nz)) break;
 z2=nz;
 }
 for(let zz=z; zz<=z2; zz++)
 for(let yy=y; yy<=y2; yy++)
 for(let xx=x; xx<=x2; xx++)
 visited.add(keyOf(xx,yy,zz));
 boxes.push({x1:x,y1:y,z1:z,x2,y2,z2});
 }
 return boxes;
 };

 const staticVisited=new Set();
 const staticHas=(x,y,z)=> staticOcc.has(`${x},${y},${z}`);
 for(let z=0; z<arr.size.z; z++){
 for(let y=0; y<arr.size.y; y++){
 for(let x=0; x<arr.size.x; x++){
 const key=`${x},${y},${z}`;
 if(!staticHas(x,y,z) || staticVisited.has(key)) continue;
 let x2=x; while(staticHas(x2+1,y,z) && !staticVisited.has(`${x2+1},${y},${z}`)) x2++;
 let y2=y;
 outerStaticY: while(true){
 const ny=y2+1;
 for(let xi=x; xi<=x2; xi++){
 if(!staticHas(xi,ny,z) || staticVisited.has(`${xi},${ny},${z}`)) break outerStaticY;
 }
 y2=ny;
 }
 let z2=z;
 outerStaticZ: while(true){
 const nz=z2+1;
 for(let yi=y; yi<=y2; yi++){
 for(let xi=x; xi<=x2; xi++){
 if(!staticHas(xi,yi,nz) || staticVisited.has(`${xi},${yi},${nz}`)) break outerStaticZ;
 }
 }
 z2=nz;
 }
 for(let zz=z; zz<=z2; zz++)
 for(let yy=y; yy<=y2; yy++)
 for(let xx=x; xx<=x2; xx++)
 staticVisited.add(`${xx},${yy},${zz}`);

 const hxCells=(x2-x+1)/2;
 const hyCells=(y2-y+1)/2;
 const hzCells=(z2-z+1)/2;
 const center=worldPos(arr, x+hxCells-.5, y+hyCells-.5, z+hzCells-.5);
 const hx=hxCells*scale, hy=hyCells*scale, hz=hzCells*scale;
 const col=RAPIER.ColliderDesc.cuboid(hx*0.9, hy*0.9, hz*0.9).setTranslation(center.x,center.y,center.z);
 col.setRestitution(0.0);
 col.setFriction(0.7);
 const handle=rapierWorld.createCollider(col);
 arr._colliders.push(handle);
 }
 }
 }

 grouped.forEach((info, groupId)=>{
 if(info.cells.size === 0) return;
 const keyStrings = Array.from(info.cells.keys());
 const boxes = buildBoxesFromKeys(keyStrings);
 if(boxes.length===0) return;

 let minX=Infinity,minY=Infinity,minZ=Infinity,maxX=-Infinity,maxY=-Infinity,maxZ=-Infinity;
 info.cells.forEach(cell=>{
 const center = worldPos(arr, cell.x, cell.y, cell.z);
 minX = Math.min(minX, center.x-0.5);
 minY = Math.min(minY, center.y-0.5);
 minZ = Math.min(minZ, center.z-0.5);
 maxX = Math.max(maxX, center.x+0.5);
 maxY = Math.max(maxY, center.y+0.5);
 maxZ = Math.max(maxZ, center.z+0.5);
 });

 const origin = new THREE.Vector3(
 (minX+maxX)/2,
 (minY+maxY)/2,
 (minZ+maxZ)/2
 );

 let body=null;
 try{
 const rbDesc = RAPIER.RigidBodyDesc.dynamic();
 rbDesc.setTranslation(origin.x, origin.y, origin.z);
 rbDesc.setLinearDamping(0.8);
 rbDesc.setAngularDamping(1.2);
 body = rapierWorld.createRigidBody(rbDesc);
 arr._rigidBodies.push(body.handle);
 }catch(e){
 console.warn('[PHYSICS] Failed to create rigid body for group', groupId, e);
 return;
 }

 boxes.forEach(box=>{
 const hxCells=(box.x2-box.x1+1)/2;
 const hyCells=(box.y2-box.y1+1)/2;
 const hzCells=(box.z2-box.z1+1)/2;
 const center=worldPos(arr, box.x1+hxCells-.5, box.y1+hyCells-.5, box.z1+hzCells-.5);
 const hx=hxCells*scale, hy=hyCells*scale, hz=hzCells*scale;
 const rel = {x:center.x-origin.x, y:center.y-origin.y, z:center.z-origin.z};
 try{
 const desc = RAPIER.ColliderDesc.cuboid(hx*0.9, hy*0.9, hz*0.9).setTranslation(rel.x, rel.y, rel.z);
 desc.setRestitution(0.0);
 desc.setFriction(0.7);
 const handle = rapierWorld.createCollider(desc, body);
 arr._colliders.push(handle);
 }catch(e){
 console.warn('[PHYSICS] Failed to attach collider for group', groupId, e);
 }
 });

 if(staticPhysicsBody && info.pivots.length && RAPIER?.JointData?.revolute){
 info.pivots.forEach(pivot=>{
 try{
 const pivotWorld = worldPos(arr, pivot.x, pivot.y, pivot.z);
 const localAnchor = {
 x: pivotWorld.x - origin.x,
 y: pivotWorld.y - origin.y,
 z: pivotWorld.z - origin.z
 };
 const worldAnchor = {x:pivotWorld.x, y:pivotWorld.y, z:pivotWorld.z};
 const axis = {x:0,y:1,z:0};
 const joint = RAPIER.JointData.revolute(localAnchor, worldAnchor, axis);
 const handle = rapierWorld.createImpulseJoint(joint, body, staticPhysicsBody, true);
 arr._joints.push(handle);
 }catch(e){
 console.warn('[PHYSICS] Failed to create hinge for group', groupId, e);
 }
 });
 }
 });
 
 console.log(`[PHYSICS] Array #${arr.id} colliders built: ${arr._colliders?.length || 0} colliders, ${arr._rigidBodies?.length || 0} bodies, ${arr._joints?.length || 0} joints`);
 }
 // Procedural animation system for timed translations/preview
 const proceduralAnims = [];
 // Per-array timed gamestate (affects all transforms while active)
 function ensureTimedState(arr){
 arr.params = arr.params || {};
 arr.params.timed = arr.params.timed || { ticks:60, reverse:false, reverseTicks:null, repeat:false, t:0, dir:1, previewInArray:false, plan:[], baseOffset:null, baseQuat:null, overlay:null };
 return arr.params.timed;
 }
 function queueTimedOp(arr, anchor, op){
 const t = ensureTimedState(arr);
 const entry = { ...op, anchor:{...anchor} };
 if(entry.anchor && entry.anchor.arrId==null) entry.anchor.arrId = arr?.id;
 t.plan.push(entry);
 try{
 if(arr?.params?.timed?.previewInArray && entry.type === 'array'){
 const toDim=(v)=>{ const n=Number(v); return Number.isFinite(n)? Math.max(1, Math.round(Math.abs(n))) : 1; };
 const dims={
 w: toDim(entry.w ?? entry.width ?? entry.dims?.w ?? entry.params?.w ?? 1),
 h: toDim(entry.h ?? entry.height ?? entry.dims?.h ?? entry.params?.h ?? 1),
 d: toDim(entry.d ?? entry.depth ?? entry.dims?.d ?? entry.params?.d ?? 1)
 };
 const burstSet = arr._previewBursts || (arr._previewBursts = new Set());
 const a = entry.anchor || {};
 const burstKey = `${a.arrId ?? arr.id}:${a.x},${a.y},${a.z}|${dims.w}x${dims.h}x${dims.d}`;
 if(!burstSet.has(burstKey)){
 burstSet.add(burstKey);
 addTimedTranslation(arr, entry.anchor || {x:0,y:0,z:0,arrId:arr?.id}, {
 ticks: Math.max(24, Math.min(360, (t.ticks|0) || 60)),
 repeat: false,
 reverse: false,
 reverseTicks: null,
 type: 'array',
 w: dims.w,
 h: dims.h,
 d: dims.d,
 op: entry.opText || entry.op || '',
 onComplete: ()=>{
 try{ burstSet.delete(burstKey); }
 catch{}
 }
 });
 }
 }
 }catch{}
 }
 function queueArrayPlanFromArray(arr){
 try{
 const hasArrayOp = (ensureTimedState(arr).plan||[]).some(op=>op.type==='array');
 if(hasArrayOp) return true;
 const parseDims=(f)=>{
 const nums = (s)=>{ const n=parseFloat(String(Formula.valOf(s)||s)); return Number.isFinite(n)? Math.max(1, n|0) : 1; };
 const mFill = /ARRAY\(\s*\"fill\"\s*,\s*([^,]+)\s*,\s*([^,\)]+)\s*(?:,\s*([^,\)]+)\s*)?/i.exec(f);
 if(mFill){ return { w:nums(mFill[1]), h:nums(mFill[2]), d:nums(mFill[3]||1) }; }
 const mBasic = /ARRAY\(\s*([^,\)]+)\s*,\s*([^,\)]+)\s*(?:,\s*([^,\)]+)\s*)?\)/i.exec(f);
 if(mBasic){ return { w:nums(mBasic[1]), h:nums(mBasic[2]), d:nums(mBasic[3]||1) }; }
 return null;
 };
 for(const ch of Object.values(arr.chunks||{})){
 for(const c of ch.cells||[]){
 if(!c?.formula) continue;
 const f=String(c.formula||'');
 if(/ARRAY\(/i.test(f)){
 const dims=parseDims(f); if(!dims) continue;
 queueTimedOp(arr, {x:c.x,y:c.y,z:c.z,arrId:arr.id}, { type:'array', ...dims, opText:f });
 return true;
 }
 }
 }
 }catch{}
 return false;
 }
 function buildTimedPlanFromArray(arr){
 try{
 const T = ensureTimedState(arr);
 // reset plan so sequencing/order changes are honored
 try{ if(Array.isArray(T.plan)) T.plan.length = 0; }catch{}
 const reNum = (s)=>{ const n = parseFloat(String(Formula.valOf(s)||s).replace(/[^0-9\-+.]/g,'')); return Number.isFinite(n)? n : 0; };
 const parseDims=(f)=>{
 const mFill = /ARRAY\(\s*"fill"\s*,\s*([^,]+)\s*,\s*([^,\)]+)\s*(?:,\s*([^,\)]+)\s*)?/i.exec(f);
 if(mFill){ return { w:Math.max(1,reNum(mFill[1])|0), h:Math.max(1,reNum(mFill[2])|0), d:Math.max(1,reNum(mFill[3]||1)|0) }; }
 const mBasic = /ARRAY\(\s*([^,\)]+)\s*,\s*([^,\)]+)\s*(?:,\s*([^,\)]+)\s*)?\)/i.exec(f);
 if(mBasic){ return { w:Math.max(1,reNum(mBasic[1])|0), h:Math.max(1,reNum(mBasic[2])|0), d:Math.max(1,reNum(mBasic[3]||1)|0) }; }
 return null;
 };
 for(const ch of Object.values(arr.chunks||{})){
 for(const c of ch.cells||[]){
 const f = String(c?.formula||''); if(!f) continue;
 if(/(?:3D_)?TRANSLATE(?:_ARRAY)?\(/i.test(f) || /TRANSLATE_ARRAY\(/i.test(f)){
 // Robust arg parsing: extract top-level args ignoring nested parens/addresses
 try{
 const start = f.search(/(?:3D_)?TRANSLATE(?:_ARRAY)?\(/i);
 if(start>=0){
 let i=start; while(i<f.length && f[i]!== '(') i++;
 if(i<f.length && f[i]==='('){
 i++; let depth=0, cur=''; const args=[];
 for(; i<f.length; i++){
 const ch=f[i];
 if(ch==='('){ depth++; cur+=ch; continue; }
 if(ch===')'){
 if(depth>0){ depth--; cur+=ch; continue; }
 // end of arg list
 args.push(cur.trim());
 break;
 }
 if(ch===',' && depth===0){ args.push(cur.trim()); cur=''; continue; }
 cur+=ch;
 }
 // take last three as dx,dy,dz
 const n=args.length; if(n>=3){
 const dxv = reNum(args[n-3]);
 const dyv = reNum(args[n-2]);
 const dzv = reNum(args[n-1]);
 queueTimedOp(arr, {x:c.x,y:c.y,z:c.z,arrId:arr.id}, {type:'translate', dx:dxv, dy:dyv, dz:dzv, opText:f});
 }
 }
 }
 }catch{}
 }
 if(/(?:3D_)?ROTATE(?:_ARRAY)?\(/i.test(f)){
 try{
 const start = f.search(/(?:3D_)?ROTATE(?:_ARRAY)?\(/i);
 if(start>=0){
 let i=start; while(i<f.length && f[i]!== '(') i++;
 if(i<f.length && f[i]==='('){
 i++; let depth=0, cur=''; const args=[];
 for(; i<f.length; i++){
 const ch=f[i];
 if(ch==='('){ depth++; cur+=ch; continue; }
 if(ch===')'){
 if(depth>0){ depth--; cur+=ch; continue; }
 args.push(cur.trim());
 break;
 }
 if(ch===',' && depth===0){ args.push(cur.trim()); cur=''; continue; }
 cur+=ch;
 }
 // take last up to three as sx,sy,sz (ignore optional target at front)
 const n=args.length;
 const sx = n>=1 ? reNum(args[n-3] ?? 0) : 0;
 const sy = n>=2 ? reNum(args[n-2] ?? 0) : 0;
 const sz = n>=3 ? reNum(args[n-1] ?? 0) : 0;
 queueTimedOp(arr, {x:c.x,y:c.y,z:c.z,arrId:arr.id}, {type:'rotate', sx, sy, sz, opText:f});
 }
 }
 }catch{}
 }
 // SHIFT(input, dx[, dy[, dz]]) -> treat as translate for previews
 if(/SHIFT\(/i.test(f)){
 const m = /SHIFT\(\s*[^,]+,\s*([^,]+)\s*(?:,\s*([^,]+)\s*)?(?:,\s*([^,]+)\s*)?\)/i.exec(f);
 if(m){ queueTimedOp(arr, {x:c.x,y:c.y,z:c.z,arrId:arr.id}, {type:'translate', dx:reNum(m[1]||0), dy:reNum(m[2]||0), dz:reNum(m[3]||0), opText:f}); }
 }
 if(/TRANSPOSE\(/i.test(f)){
 queueTimedOp(arr, {x:c.x,y:c.y,z:c.z,arrId:arr.id}, {type:'transpose', opText:f});
 }
 if(/ARRAY\(/i.test(f)){
 let dims = null;
 try{
 const emittedMap = Store.getState().emittedByAnchor;
 if(emittedMap && emittedMap.get){
 const ak = aKey({arrId:arr.id, x:c.x, y:c.y, z:c.z});
 const emitted = emittedMap.get(ak);
 if(emitted && emitted.size){
 let maxDx = 0, maxDy = 0, maxDz = 0;
 emitted.forEach(key=>{
 try{
 const [aid, rest] = key.split(':');
 if(+aid !== arr.id) return;
 const [ex,ey,ez] = rest.split(',').map(Number);
 if(!Number.isFinite(ex) || !Number.isFinite(ey) || !Number.isFinite(ez)) return;
 maxDx = Math.max(maxDx, ex - c.x);
 maxDy = Math.max(maxDy, ey - c.y);
 maxDz = Math.max(maxDz, ez - c.z);
 }catch{}
 });
 dims = { w: Math.max(1, (maxDx|0) + 1), h: Math.max(1, (maxDy|0) + 1), d: Math.max(1, (maxDz|0) + 1) };
 }
 }
 }catch{}
 if(!dims){ dims = parseDims(f); }
 if(dims){ queueTimedOp(arr, {x:c.x,y:c.y,z:c.z,arrId:arr.id}, {type:'array', ...dims, opText:f}); }
 }
 }
 }
 return (ensureTimedState(arr).plan||[]).length>0;
 }catch{ return false; }
 }
 function configTimed(arr, cfg){
 const t = ensureTimedState(arr);
 t.ticks = Math.max(1, (cfg?.ticks|0) || 60);
 t.repeat = !!cfg?.repeat; t.reverse = !!cfg?.reverse; t.reverseTicks = (cfg?.reverseTicks==null? null : Math.max(1, cfg.reverseTicks|0));
 t.smooth = !!cfg?.smooth;
 t.t = 0; t.dir = 1;
 // Do not clear plan here; transforms add to plan when preview is ON
 t.baseOffset = { ...(arr.offset||{x:0,y:0,z:0}) };
 try{ t.baseQuat = (arr._frame?.quaternion?.clone?.()) || null; }catch{ t.baseQuat=null; }
 }
 function stopTimed(arr){
 const t=ensureTimedState(arr);
 t.previewInArray=false;
 if(arr && arr._previewBursts){ try{ arr._previewBursts.clear(); }catch{} arr._previewBursts=null; }
 // Restore base transforms
 try{ if(t.baseOffset){ setArrayOffset(arr, {x:t.baseOffset.x,y:t.baseOffset.y,z:t.baseOffset.z}, {interactive:true}); } }catch{}
 try{ if(arr._frame && t.baseQuat){ arr._frame.quaternion.copy(t.baseQuat); } }catch{}
 if(t.overlay){ try{ t.overlay.group.parent?.remove(t.overlay.group); }catch{}; t.overlay=null; }
 // Unmask array content after preview ends
 try{ maskArrayForPreview(arr, false); }catch{}
 }
 // Global 3D timed config (overworld movement)
 function ensureTimed3D(){
 const S=Store.getState();
 const sceneState = S.scene || ({});
 if(!sceneState.timed3D){
 sceneState.timed3D = { configured:false, ticks:60, repeat:false, reverse:false, reverseTicks:null, t:0, dir:1, preview:false, waitStart:0, waitEnd:0, _waitCounter:0, scope:null, hostId:null, activeHostIds:[] };
 Store.setState(s=>({scene:{...s.scene, timed3D: sceneState.timed3D}}));
 } else {
 if(typeof sceneState.timed3D.waitStart!=='number') sceneState.timed3D.waitStart = 0;
 if(typeof sceneState.timed3D.waitEnd!=='number') sceneState.timed3D.waitEnd = 0;
 if(typeof sceneState.timed3D._waitCounter!=='number') sceneState.timed3D._waitCounter = 0;
 if(!sceneState.timed3D.hasOwnProperty('scope')) sceneState.timed3D.scope = null;
 if(!sceneState.timed3D.hasOwnProperty('hostId')) sceneState.timed3D.hostId = null;
 if(!Array.isArray(sceneState.timed3D.activeHostIds)) sceneState.timed3D.activeHostIds = [];
 }
 return sceneState.timed3D;
 }
 // Temporarily hide colored fills/formulas so expansion overlay is visible over white grid
 function maskArrayForPreview(arr, enable){
 try{
 arr._previewMask = arr._previewMask || { layerKeys:[], chunkLODs:[], chunkLOD2:[], chunkGhosts:[], chunkShells:[] };
 if(enable){
 // Hide underlying solids to create empty cell receptacles, but keep shells/ghosts for outline context
 if(Scene.ChunkManager && Scene.ChunkManager.enabled){
 Object.values(arr.chunks||{}).forEach(ch=>{
 // Hide LOD1 solids
 if(ch.meshLOD1 && ch.meshLOD1.visible){ arr._previewMask.chunkLODs.push(ch); ch.meshLOD1.visible=false; }
 // Keep shells for context; hide ghosts and alternate LODs
 if(ch.meshGhost && ch.meshGhost.visible){ arr._previewMask.chunkGhosts.push(ch); ch.meshGhost.visible=false; }
 if(ch.meshLOD2 && ch.meshLOD2.visible){ arr._previewMask.chunkLOD2.push(ch); ch.meshLOD2.visible=false; }
 if(ch.meshShell){
 const wasVisible = !!ch.meshShell.visible;
 arr._previewMask.chunkShells.push({ chunk: ch, wasVisible });
 ch.meshShell.visible = true;
 }
 });
 } else {
 for(let z=0; z<arr.size.z; z++){
 // Hide filled/formula groups only (leave edges as outline)
 ['filled','formula','ghost'].forEach(type=>{
 const key = `${arr.id}:${z}:${type}`;
 const rec = layerMeshes.get(key);
 if(rec && rec.mesh && rec.mesh.visible){ arr._previewMask.layerKeys.push(key); rec.mesh.visible=false; }
 });
 }
 }
 } else {
 // Restore previously hidden meshes
 (arr._previewMask.layerKeys||[]).forEach(key=>{ const rec=layerMeshes.get(key); if(rec && rec.mesh) rec.mesh.visible=true; });
 (arr._previewMask.chunkLODs||[]).forEach(ch=>{ if(ch.meshLOD1) ch.meshLOD1.visible=true; });
 (arr._previewMask.chunkLOD2||[]).forEach(ch=>{ if(ch.meshLOD2) ch.meshLOD2.visible=true; });
 (arr._previewMask.chunkGhosts||[]).forEach(ch=>{ if(ch.meshGhost) ch.meshGhost.visible=true; });
 (arr._previewMask.chunkShells||[]).forEach(rec=>{
 const ch = rec?.chunk || rec;
 if(ch?.meshShell){
 ch.meshShell.visible = (rec && rec.hasOwnProperty('wasVisible')) ? rec.wasVisible : true;
 }
 });
 arr._previewMask = { layerKeys:[], chunkLODs:[], chunkLOD2:[], chunkGhosts:[], chunkShells:[] };
 }
 }catch{}
 }
 try{ Scene.maskArrayForPreview = maskArrayForPreview; }catch{}
 try{ Scene.addToScene = (obj)=>{ try{ if(obj) scene.add(obj); }catch{} }; }catch{}
 try{ Scene.removeFromScene = (obj)=>{ try{ obj?.parent?.remove(obj); }catch{} }; }catch{}
 try{ Scene.ensureTimedState = ensureTimedState; }catch{}
 try{ Scene.queueTimedOp = queueTimedOp; }catch{}
 try{ Scene.queueArrayPlanFromArray = queueArrayPlanFromArray; }catch{}
 try{ Scene.buildTimedPlanFromArray = buildTimedPlanFromArray; }catch{}
 try{ Scene.configTimed = configTimed; }catch{}
 try{ Scene.stopTimed = stopTimed; }catch{}
 try{ Scene.upsertCellLight = upsertCellLight; }catch{}
 try{ Scene.removeCellLight = removeCellLight; }catch{}
 try{ Scene.refreshLightsForArray = refreshLightsForArray; }catch{}
 try{ Scene.ensureTimed3D = ensureTimed3D; }catch{}
 function addTimedTranslation(arr, anchor, cfg){
 const {
 ticks=60,
 repeat=false,
 reverse=false,
 reverseTicks=null,
 op='',
 type=null,
 onComplete=null
 } = cfg||{};
 const group = new THREE.Group();
 group.userData.kind = 'procAnim';
 scene.add(group);

 const GREEN_MAT = new THREE.MeshBasicMaterial({ color: 0x22c55e, transparent: true, opacity: 0.5, depthTest: false, depthWrite: false });
 GREEN_MAT.toneMapped = false;
 const BASE_CELL_SIZE = 0.9;
 const makeCell = (sx=BASE_CELL_SIZE,sy=BASE_CELL_SIZE,sz=BASE_CELL_SIZE)=>{
 const geom = GEO_VOXEL.clone();
 const mat = GREEN_MAT.clone();
 const mesh = new THREE.Mesh(geom, mat);
 mesh.renderOrder = 2100;
 mesh.scale.set(sx/BASE_CELL_SIZE, sy/BASE_CELL_SIZE, sz/BASE_CELL_SIZE);
 return mesh;
 };
 const safeAnchor = {
 x: Number.isFinite(anchor?.x) ? anchor.x : 0,
 y: Number.isFinite(anchor?.y) ? anchor.y : 0,
 z: Number.isFinite(anchor?.z) ? anchor.z : 0,
 arrId: (anchor && anchor.arrId!=null) ? anchor.arrId : (arr?.id)
 };
 const anchorArr = (safeAnchor.arrId!=null && Store.getState().arrays && Store.getState().arrays[safeAnchor.arrId]) || arr;
 const startPos = worldPos(anchorArr, safeAnchor.x, safeAnchor.y, safeAnchor.z);

 // Parse op
 const text = String(op||'').trim();
 const reNum = (s)=>{ const n = parseFloat(String(s).replace(/[^0-9\-+.]/g,'')); return Number.isFinite(n)? n : 0; };
 const mTrans = /(?:3D_)?TRANSLATE(?:_ARRAY)?\(\s*(?:[^,]+\s*,\s*)?([^,]+)\s*,\s*([^,]+)\s*,\s*([^,\)]+)\s*\)/i.exec(text);
 const mRot = /(?:3D_)?ROTATE(?:_ARRAY)?\(\s*([^,)]*)\s*(?:,\s*([^,)]*)\s*)?(?:,\s*([^,)]*)\s*)?\)/i.exec(text);
 const mArrayFill = /ARRAY\(\s*"fill"\s*,\s*([^,]+)\s*,\s*([^,\)]+)\s*(?:,\s*([^,\)]+)\s*)?/i.exec(text);
 const isTranspose = /TRANSPOSE\(/i.test(text);

 const explicitType = type ? String(type).toLowerCase() : '';
 const toDelta = (v)=>{ const n = Number(v); return Number.isFinite(n)? n : 0; };
 const toDim = (v)=>{ const n = Number(v); return Number.isFinite(n)? Math.max(1, Math.round(Math.abs(n))) : 1; };

 let animType = '';
 let params={};
 if(explicitType==='translate'){
 animType='translate';
 params={
 dx: toDelta(cfg?.dx ?? cfg?.params?.dx ?? 0),
 dy: toDelta(cfg?.dy ?? cfg?.params?.dy ?? 0),
 dz: toDelta(cfg?.dz ?? cfg?.params?.dz ?? 0)
 };
 } else if(explicitType==='rotate'){
 animType='rotate';
 params={
 sx: toDelta(cfg?.sx ?? cfg?.params?.sx ?? 0),
 sy: toDelta(cfg?.sy ?? cfg?.params?.sy ?? 0),
 sz: toDelta(cfg?.sz ?? cfg?.params?.sz ?? 0)
 };
 } else if(explicitType==='array'){
 animType='array';
 params={
 w: toDim(cfg?.w ?? cfg?.width ?? cfg?.params?.w ?? 1),
 h: toDim(cfg?.h ?? cfg?.height ?? cfg?.params?.h ?? 1),
 d: toDim(cfg?.d ?? cfg?.depth ?? cfg?.params?.d ?? 1)
 };
 } else if(explicitType==='transpose'){
 animType='transpose';
 params={};
 }

 if(!animType){
 if(mTrans){ animType='translate'; params={ dx: reNum(mTrans[1]), dy: reNum(mTrans[2]), dz: reNum(mTrans[3]) }; }
 else if(mRot){ animType='rotate'; params={ sx: reNum(mRot[1]||0), sy: reNum(mRot[2]||0), sz: reNum(mRot[3]||0) }; }
 else if(mArrayFill){ animType='array'; params={ w: Math.max(1, reNum(mArrayFill[1])|0), h: Math.max(1, reNum(mArrayFill[2])|0), d: Math.max(1, reNum(mArrayFill[3]||1)|0) }; }
 else if(isTranspose){ animType='transpose'; params={}; }
 else { animType='translate'; params={ dx:0, dy:0, dz:0 }; }
 }

 if(animType==='array'){
 params.w = toDim(params.w);
 params.h = toDim(params.h);
 params.d = toDim(params.d);
 }

 // Build visuals per type
 const record = { group, arrId:arr.id, anchor:{...safeAnchor}, ticks:Math.max(1,ticks|0), repeat:!!repeat, reverse:!!reverse, reverseTicks: (reverseTicks==null? null : Math.max(1, reverseTicks|0)), t:0, dir:1, type:animType, params, _built:false, onDone: (typeof onComplete==='function') ? onComplete : null };

 if(animType==='translate'){
 const cube = makeCell(); cube.position.copy(startPos); group.add(cube);
 record.update = (p)=>{
 cube.position.set(startPos.x + params.dx*p, startPos.y + params.dy*p, startPos.z + params.dz*p);
 };
 record.cleanup = ()=>{};
 } else if(animType==='rotate'){
 const cube = makeCell(); cube.position.copy(startPos); group.add(cube);
 const total = { x:(params.sx||0)*Math.PI/2, y:(params.sy||0)*Math.PI/2, z:(params.sz||0)*Math.PI/2 };
 record.update = (p)=>{
 cube.position.copy(startPos);
 cube.rotation.set(total.x*p, total.y*p, total.z*p);
 };
 record.cleanup = ()=>{};
 } else if(animType==='array'){
 const {w,h,d}=params; const cells=[];
 for(let zz=0; zz<d; zz++) for(let yy=0; yy<h; yy++) for(let xx=0; xx<w; xx++){
 const c=makeCell();
 const wp = worldPos(anchorArr, safeAnchor.x+xx, safeAnchor.y+yy, safeAnchor.z+zz);
 c.position.copy(wp); c.visible=false; group.add(c); cells.push({mesh:c, xx, yy, zz});
 }
 record.update = (p)=>{
 // Expand simultaneously in X/Y(/Z) like pistons
 const nx = Math.max(1, Math.floor(1 + (w-1)*p));
 const ny = Math.max(1, Math.floor(1 + (h-1)*p));
 const nz = Math.max(1, Math.floor(1 + (d-1)*p));
 cells.forEach(({mesh,xx,yy,zz})=>{ 
 const vis = (xx < nx && yy < ny && zz < nz); 
 if(mesh.visible!==vis){ mesh.visible = vis; }
 });
 };
 record.cleanup = ()=>{
 try{
 // Merge all visible cubes into a single mesh instance
 const geos = [];
 cells.forEach(({mesh})=>{
 if(!mesh.visible) return;
 const g = mesh.geometry.clone();
 const m4 = new THREE.Matrix4(); m4.compose(mesh.position, mesh.quaternion, mesh.scale);
 g.applyMatrix4(m4);
 geos.push(g);
 });
 if(geos.length){
 const merged = (typeof BufferGeometryUtils!=='undefined' && BufferGeometryUtils.mergeGeometries) ? BufferGeometryUtils.mergeGeometries(geos, false) : null;
 const finalMat = new THREE.MeshBasicMaterial({ color: 0x22c55e, transparent: true, opacity: 0.5, depthTest: false, depthWrite: false });
 finalMat.toneMapped = false;
 const finalMesh = new THREE.Mesh(merged || geos[0], finalMat);
 finalMesh.renderOrder = 2100;
 // Clear children and replace with merged mesh to persist briefly
 while(group.children.length){ const ch = group.children.pop(); ch.geometry?.dispose?.(); ch.material?.dispose?.(); }
 group.add(finalMesh);
 // Auto-remove after a short hold to avoid scene buildup
 setTimeout(()=>{ try{ scene.remove(group); finalMesh.geometry?.dispose?.(); finalMesh.material?.dispose?.(); }catch{} }, 800);
 }
 }catch{}
 };
 } else if(animType==='transpose'){
 // Minimal visualization: swap X/Y progressively for a 2D 1x1 marker moving toward its transposed target
 const marker = makeCell();
 marker.position.copy(startPos);
 group.add(marker);
 record.update = (p)=>{
 const from = startPos;
 // Default XY transpose for 1x1 marker: move diagonally half-cell for a hint
 const to = worldPos(arr, anchor.x, anchor.y, anchor.z).add(new THREE.Vector3(0.5,0.5,0));
 marker.position.lerpVectors(from, to, p);
 };
 record.cleanup = ()=>{};
 }

 proceduralAnims.push(record);
 return record;
 }
 // Expose under Scene for formula impls
 // Expose for external calls post-IIFE; also mirror on window for robustness
 try{ Scene.addTimedTranslation = addTimedTranslation; }catch{}
 try{ window.__addTimedTranslation = addTimedTranslation; }catch{}
 
 // ===== Celli Derez Effect =====
 const derezEffects = [];
 const celliDerezState = { active: false, lastY: null, respawnScheduled: false, respawnTime: 0, respawnData: null };
 let derezParticleGeometry = null;
 
 function triggerCelliDerez(worldPos){
 if(!scene || !THREE || celliDerezState.active) return;
 try{
 const base = new THREE.Group();
 const px = Number.isFinite(worldPos?.x) ? worldPos.x : 0;
 const py = Number.isFinite(worldPos?.y) ? worldPos.y : 0;
 const pz = Number.isFinite(worldPos?.z) ? worldPos.z : 0;
 base.position.set(px, py + 0.4, pz);
 
 // Rotate Celli to face the camera
 if(camera){
 const camPos = camera.position.clone();
 const celliPos = new THREE.Vector3(px, py + 0.4, pz);
 const direction = new THREE.Vector3().subVectors(camPos, celliPos);
 direction.y = 0; // Keep rotation only on horizontal plane
 direction.normalize();
 const angle = Math.atan2(direction.x, direction.z);
 base.rotation.y = angle;
 }

 const layout = [
 { size: [0.36, 0.48, 0.28], offset: [0, -0.05, 0], color: 0xf59e0b },
 { size: [0.32, 0.24, 0.24], offset: [0, 0.32, 0], color: 0xfcd34d },
 { size: [0.08, 0.08, 0.05], offset: [-0.1, 0.36, 0.12], color: 0x1f2937 },
 { size: [0.08, 0.08, 0.05], offset: [0.1, 0.36, 0.12], color: 0x1f2937 },
 { size: [0.14, 0.06, 0.05], offset: [0, 0.26, 0.13], color: 0x1f2937 },
 { size: [0.08, 0.06, 0.05], offset: [-0.16, 0.3, 0.12], color: 0xec4899 },
 { size: [0.08, 0.06, 0.05], offset: [0.16, 0.3, 0.12], color: 0xec4899 },
 { size: [0.36, 0.08, 0.12], offset: [0, 0.5, 0], color: 0xfcd34d },
 { size: [0.16, 0.12, 0.08], offset: [-0.24, 0.5, 0], color: 0xf59e0b },
 { size: [0.16, 0.12, 0.08], offset: [0.24, 0.5, 0], color: 0xf59e0b },
 { size: [0.12, 0.4, 0.12], offset: [-0.26, -0.2, 0], color: 0xf59e0b },
 { size: [0.12, 0.4, 0.12], offset: [0.26, -0.2, 0], color: 0xf59e0b },
 { size: [0.12, 0.24, 0.12], offset: [-0.12, -0.46, 0], color: 0xf59e0b },
 { size: [0.12, 0.24, 0.12], offset: [0.12, -0.46, 0], color: 0xf59e0b }
 ];

 const voxels = [];
 const boundsMin = new THREE.Vector3(Infinity, Infinity, Infinity);
 const boundsMax = new THREE.Vector3(-Infinity, -Infinity, -Infinity);

 layout.forEach(part=>{
 const geo = new THREE.BoxGeometry(part.size[0], part.size[1], part.size[2]);
 const mat = new THREE.MeshStandardMaterial({
 color: part.color,
 emissive: new THREE.Color(part.color),
 emissiveIntensity: 0.2,
 transparent: true,
 opacity: 1,
 depthWrite: false
 });
 mat.toneMapped = false;
 const mesh = new THREE.Mesh(geo, mat);
 mesh.position.set(part.offset[0], part.offset[1], part.offset[2]);
 base.add(mesh);
 voxels.push({ mesh, geometry: geo, material: mat });

 const half = new THREE.Vector3(part.size[0] / 2, part.size[1] / 2, part.size[2] / 2);
 boundsMin.x = Math.min(boundsMin.x, mesh.position.x - half.x);
 boundsMin.y = Math.min(boundsMin.y, mesh.position.y - half.y);
 boundsMin.z = Math.min(boundsMin.z, mesh.position.z - half.z);
 boundsMax.x = Math.max(boundsMax.x, mesh.position.x + half.x);
 boundsMax.y = Math.max(boundsMax.y, mesh.position.y + half.y);
 boundsMax.z = Math.max(boundsMax.z, mesh.position.z + half.z);
 });

 const glow = new THREE.PointLight(0xfcd34d, 0, 3.5, 2);
 glow.position.set(0, 0.45, 0);
 base.add(glow);

 scene.add(base);

 derezEffects.push({
 group: base,
 voxels,
 bounds: { min: boundsMin, max: boundsMax },
 particles: [],
 light: glow,
 stage: 'glow',
 stageTime: 0,
 totalTime: 0
 });

 celliDerezState.active = true;
 if(celli){ celli.visible = false; }
 needsRender = true;
 }catch(e){
 console.warn('Failed to trigger Celli derez effect', e);
 celliDerezState.active = false;
 if(celli){ celli.visible = true; }
 }
 }

 function cleanupDerezEffect(effect){
 try{
 if(effect.particles){
 effect.particles.forEach(p=>{
 if(p?.mesh){
 effect.group?.remove(p.mesh);
 try{ p.material?.dispose?.(); }catch{}
 }
 });
 effect.particles.length = 0;
 }
 if(effect.light){
 try{ effect.group?.remove(effect.light); }catch{}
 }
 if(effect.group){
 try{ scene.remove(effect.group); }catch{}
 }
 }catch(e){
 console.warn('Failed to cleanup derez effect', e);
 }
 effect.voxels = [];
 celliDerezState.active = false;
 
 // Trigger delayed respawn if scheduled
 if(celliDerezState.respawnScheduled && celliDerezState.respawnData){
 const data = celliDerezState.respawnData;
 console.log('[DEREZ] Animation complete, executing delayed respawn');
  if(playerBody){
   playerBody.setTranslation(data.pos, true);
   playerBody.setLinvel({x: 0, y: 0, z: 0}, true);
   cachedPlayerPos.set(data.pos.x, data.pos.y, data.pos.z);
   jumpVelocity = 0;
   landingSquashTime = 0;
   anticipationSquashTime = 0;
   wasGroundedLastFrame = false;
   lastLandKey = null;
   skipWalkBounceUntil = 0;
   resetJumpBudget();
  }
 // Re-enable camera controls
 if(controls){
 try{ controls.enabled = true; }catch{}
 }
 celliDerezState.respawnScheduled = false;
 celliDerezState.respawnData = null;
 }
 
 if(celli){ celli.visible = true; }
 needsRender = true;
 }

 function updateDerezEffects(deltaMs){
 if(!derezEffects.length) return;
 const deltaSec = deltaMs / 1000;
 for(let i = derezEffects.length - 1; i >= 0; i--){
 const effect = derezEffects[i];
 if(!effect) continue;
 effect.stageTime += deltaMs;
 effect.totalTime += deltaMs;
 needsRender = true;

 if(effect.stage === 'glow'){
 const glowT = Math.min(1, effect.stageTime / 350);
 const pulse = 0.94 + 0.08 * Math.sin(glowT * Math.PI);
 effect.voxels.forEach(v=>{
 if(!v?.mesh || !v.material) return;
 v.mesh.scale.set(pulse, pulse, pulse);
 v.material.emissiveIntensity = 0.6 + 1.8 * glowT;
 v.material.opacity = 1;
 });
 if(effect.light){
 effect.light.intensity = THREE.MathUtils.lerp(0, 3.2, glowT);
 }
 if(effect.stageTime >= 350){
 effect.stage = 'burst';
 effect.stageTime = 0;
 if(effect.light){ effect.light.intensity = 0; }
 if(!derezParticleGeometry){
 derezParticleGeometry = new THREE.BoxGeometry(0.08, 0.08, 0.08);
 }
 const colorPool = effect.voxels.map(v=>v.material?.color?.getHex?.() ?? 0xf59e0b);
 const particleCount = Math.max(24, colorPool.length * 6);
 const bounds = effect.bounds;
 effect.voxels.forEach(v=>{
 if(!v) return;
 if(v.mesh){
 effect.group?.remove(v.mesh);
 }
 try{ v.geometry?.dispose?.(); }catch{}
 try{ v.material?.dispose?.(); }catch{}
 });
 effect.voxels = [];
 effect.particles = [];
 for(let j = 0; j < particleCount; j++){
 const colorHex = colorPool[j % colorPool.length];
 const material = new THREE.MeshStandardMaterial({
 color: colorHex,
 emissive: new THREE.Color(colorHex),
 emissiveIntensity: 1.3,
 transparent: true,
 opacity: 1,
 depthWrite: false
 });
 material.toneMapped = false;
 const particle = new THREE.Mesh(derezParticleGeometry, material);
 const rx = THREE.MathUtils.lerp(bounds.min.x, bounds.max.x, Math.random());
 const ry = THREE.MathUtils.lerp(bounds.min.y, bounds.max.y, Math.random());
 const rz = THREE.MathUtils.lerp(bounds.min.z, bounds.max.z, Math.random());
 particle.position.set(rx, ry, rz);
 particle.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
 effect.group.add(particle);
 effect.particles.push({
 mesh: particle,
 material,
 velocity: new THREE.Vector3((Math.random()-0.5)*2.2, Math.random()*2.4 + 1.8, (Math.random()-0.5)*2.2),
 spin: new THREE.Vector3((Math.random()-0.5)*4, (Math.random()-0.5)*4, (Math.random()-0.5)*4)
 });
 }
 }
 } else if(effect.stage === 'burst'){
 const fade = Math.min(1, effect.stageTime / 700);
 if(effect.particles){
 effect.particles.forEach(p=>{
 if(!p?.mesh || !p.material) return;
 p.velocity.y -= 6 * deltaSec;
 p.velocity.x *= 0.97;
 p.velocity.z *= 0.97;
 p.mesh.position.addScaledVector(p.velocity, deltaSec);
 p.mesh.rotation.x += p.spin.x * deltaSec;
 p.mesh.rotation.y += p.spin.y * deltaSec;
 p.mesh.rotation.z += p.spin.z * deltaSec;
 const life = Math.max(0, 1 - fade);
 p.material.opacity = life;
 p.material.emissiveIntensity = 1.3 * life;
 p.mesh.scale.setScalar(THREE.MathUtils.lerp(1, 0.6, fade));
 });
 }
 if(effect.stageTime >= 700){
 cleanupDerezEffect(effect);
 derezEffects.splice(i, 1);
 continue;
 }
 }
 }
 }
 // ===== End Derez Effect =====
 
 let lastFrame = 0;
 function animate(time){
 // Limit to 60fps and drive via single chain
 const deltaRaw = lastFrame ? (time - lastFrame) : 16;
 if(deltaRaw < 16){ __rafId = requestAnimationFrame(animate); return; }
 const deltaMs = Math.min(64, deltaRaw);
 const deltaSec = deltaMs * 0.001;
 lastFrame = time;
 try {
  updateDerezEffects(deltaMs);
  Scene.updateDeleteEffects?.(16);
  if(arrayaAvatar) arrayaAvatar.update(time * 0.001);

 updateSelectionCelliBlink(deltaSec);
 updateSelectionCollapse(deltaSec);
 updateBounceGag(deltaSec);
 
 // Reset derez lastY when not in physics mode
 const physicsActive = !!Store.getState().scene?.physics;
 if(!physicsActive){
 celliDerezState.lastY = null;
 }
 
 // Update avatars every frame for continuous camera tracking
 const sel = Store.getState().selection;
 updateSpottedSequence(deltaSec);
 if(sel) updateAvatars(sel);

 if(selectionCelli?.visible){
 const data = selectionCelli.userData;
 if(data?.stretchState){
 const state = data.stretchState;
 const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
 const t = Math.min(1, (now - state.start) / Math.max(1, state.duration));
 const eased = easeOutBack(t, 1.35);
 selectionCelli.scale.set(
 THREE.MathUtils.lerp(state.from.x, state.to.x, eased),
 THREE.MathUtils.lerp(state.from.y, state.to.y, eased),
 THREE.MathUtils.lerp(state.from.z, state.to.z, eased)
 );
 if(t >= 1){
 selectionCelli.scale.copy(state.to);
 data.stretchState = null;
 }
 needsRender = true;
 }
 // Continuously update border orientation to face camera
 try{
 if(data?.lastSignature){
 const sel = Store.getState().selection;
 if(sel?.range && sel?.arrayId){
 const arr = Store.getState().arrays[sel.arrayId];
 if(arr && arr._frame){
 // Use facingFromCamera to account for array rotation
 const facing = facingFromCamera(arr._frame);
 const axis = facing.axis;
 const sign = facing.sign;
 const sig = data.lastSignature.split(':');
 const [oldAxis, oldSign] = [sig[sig.length-2], sig[sig.length-1]];
 
 // Always update rotation to continuously face camera
 const axisKeys = ['x','y','z'];
 const axisKey = axisKeys[axis];
 const frameQuat = arr._frame.getWorldQuaternion(new THREE.Quaternion());
 const basisX = new THREE.Vector3(1,0,0).applyQuaternion(frameQuat);
 const basisY = new THREE.Vector3(0,1,0).applyQuaternion(frameQuat);
 const basisZ = new THREE.Vector3(0,0,1).applyQuaternion(frameQuat);
 const bases = [basisX, basisY, basisZ];
 const forward = bases[axis].clone().multiplyScalar(sign).normalize();
 
 const worldRight = new THREE.Vector3();
 const worldUp = new THREE.Vector3();
 if(axis === 0){ // X face
 worldRight.copy(bases[2]); worldUp.copy(bases[1]);
 } else if(axis === 1){ // Y face
 worldRight.copy(bases[0]); worldUp.copy(bases[2]);
 if(sign < 0) worldUp.multiplyScalar(-1);
 } else { // Z face
 worldRight.copy(bases[0]); worldUp.copy(bases[1]);
 if(sign < 0) worldUp.multiplyScalar(-1);
 }
 // Snap rotation to align with viewing axis
 const rotMatrix = new THREE.Matrix4().makeBasis(worldRight, worldUp, forward);
 selectionCelli.rotation.setFromRotationMatrix(rotMatrix);
 needsRender = true;
 
 // If axis changed, rebuild geometry
 if(`${axis}` !== oldAxis || `${sign}` !== oldSign){
 const faceHint = { axis: axisKeys[axis], axisIndex: axis, sign };
 const center = {
 x: parseFloat(sig[1].split(',')[0]),
 y: parseFloat(sig[1].split(',')[1]),
 z: parseFloat(sig[1].split(',')[2])
 };
 const counts = {
 x: parseInt(sig[2].split(',')[0]),
 y: parseInt(sig[2].split(',')[1]),
 z: parseInt(sig[2].split(',')[2])
 };
 const scale = arrayVoxelScale(arr);
 updateSelectionCelliHighlight(arr, center, counts, scale, faceHint);
 }
 }
 }
 }
 }catch(e){ console.warn('[CELLI] Border update in animate failed:', e); }
 }

 // Ensure controls remain enabled when physics is off
 const physicsEnabled = Store.getState().scene.physics;
 if(!physicsEnabled){
 // Force controls to stay enabled when physics is disabled unless orbit is intentionally suspended
 if(controls && orbitSuspendDepth === 0){
 controls.enabled = true;
 controls.enableRotate = true;
 controls.enablePan = true;
 }
 }

 if(rapierWorld && playerBody && physicsEnabled && !physicsStepping){
 physicsStepping = true;
 try {
 // Skip stepping while colliders are rebuilding to avoid Rapier panics
 const anyBuilding = Object.values(Store.getState().arrays).some(a=>a?._collidersBuilding);
 if(anyBuilding){ physicsStepping=false; return; }
 // Update cached player position safely before any operations
 try {
 const translation = playerBody.translation();
 cachedPlayerPos.set(translation.x, translation.y, translation.z);
 } catch(e) {
 // If we can't get position, skip this frame
 physicsStepping = false;
 return;
 }
 
 // --- START: ZIPLINE LOGIC --- 
 if(ziplineState.active){
 const maxSpeed = ziplineState.maxSpeed || 0.06;
 ziplineState.velocity = Math.min(maxSpeed, ziplineState.velocity + (ziplineState.accel || 0.002));
 const delta = ziplineState.velocity / Math.max(0.001, ziplineState.length || 1);
 ziplineState.progress = Math.min(1, ziplineState.progress + delta);
 const newPos = new THREE.Vector3().lerpVectors(ziplineState.start, ziplineState.end, ziplineState.progress);
 if(typeof playerBody.setNextKinematicTranslation === 'function'){
 playerBody.setNextKinematicTranslation(newPos.x, newPos.y - 0.5, newPos.z);
 } else {
 playerBody.setTranslation({x:newPos.x, y:newPos.y - 0.5, z:newPos.z}, true);
 }
 wasGroundedLastFrame = false;

 if(ziplineState.progress >= 1){
 ziplineState.active = false; // Detach at the end
 ziplineState.velocity = 0;
 wasGroundedLastFrame = false;
 }
 } else {
 // Zipline attachment detection using cached position
 if(connections.size > 0) {
 const playerPos = cachedPlayerPos.clone();
 playerPos.y += 0.5; // Adjust for character controller center

 // Zipline attachment detection
 for(const [key, con] of connections.entries()){
 if(!isZiplineConnection(con)) continue;
 const line = new THREE.Line3(con.start, con.end);
 const closestPoint = new THREE.Vector3();
 line.closestPointToPoint(playerPos, true, closestPoint);
 const distance = playerPos.distanceTo(closestPoint);

 if(distance < 0.75){ // Attachment radius
 const start = con.start;
 const end = con.end;
 const lineLength = con.length || line.distance();
 const drop = start.y - end.y;
 if(Math.abs(drop) < 0.05 && lineLength < 0.5) continue; // Skip nearly flat/short lines
 ziplineState.active = true;
 if(drop > 0){
 ziplineState.start = start.clone();
 ziplineState.end = end.clone();
 } else {
 ziplineState.start = end.clone();
 ziplineState.end = start.clone();
 }
 const lineDir = new THREE.Vector3().subVectors(ziplineState.end, ziplineState.start);
 const lengthSq = lineDir.lengthSq();
 if(lengthSq < 1e-6){ ziplineState.active = false; continue; }
 ziplineState.length = lineLength || Math.sqrt(lengthSq);
 ziplineState.direction = lineDir.clone().normalize();
 const slope = Math.max(0, (ziplineState.start.y - ziplineState.end.y) / Math.max(0.001, ziplineState.length));
 ziplineState.accel = 0.0015 + slope * 0.0015;
 ziplineState.maxSpeed = 0.045 + slope * 0.02;
 ziplineState.velocity = Math.max(0.008, ziplineState.accel * 2);
 const playerDir = new THREE.Vector3().subVectors(playerPos, ziplineState.start);
 ziplineState.progress = THREE.MathUtils.clamp(playerDir.dot(lineDir) / lengthSq, 0, 1);
 playerBody.setLinvel({x:0,y:0,z:0}, true);
 wasGroundedLastFrame = false;
 break; // Attach to the first one found
 }
 }
 }
 }
 // --- END: ZIPLINE LOGIC ---

 // Projectile physics and collision detection
 const S = Store.getState();
 if (S.activeProjectiles.length > 0) {
 const newProjectiles = [];
 S.activeProjectiles.forEach(projectile => {
 // Update position
 projectile.pos.add(projectile.vel);
 
 // Check for collision with any array's cells
 let hit = false;
 Object.values(S.arrays).forEach(arr => {
 if(hit) return;
 Object.values(arr.chunks).forEach(chunk => {
 if(hit) return;
 chunk.cells.forEach(cell => {
 if(hit || !cell.value) return;
 const cellPos = worldPos(arr, cell.x, cell.y, cell.z);
 const distance = projectile.pos.distanceTo(cellPos);
 if(distance < 0.6) { // Collision radius
 hit = true;
 const cellKey = aKey({arrId: arr.id, x: cell.x, y: cell.y, z: cell.z});
 const handler = S.collisionHandlers.get(cellKey);
 if(handler) {
 try {
 const tx = Write.start('collision.handler', 'Projectile collision');
 Formula.executeAt({arrId: arr.id, x: cell.x, y: cell.y, z: cell.z}, handler, tx);
 Write.commit(tx);
 } catch(e) {
 console.error('Collision handler error:', e);
 }
 }
 }
 });
 });
 });
 
 // Keep projectile if no collision and still in bounds
 if(!hit && projectile.pos.length() < 100) {
 newProjectiles.push(projectile);
 }
 });
 Store.setState({ activeProjectiles: newProjectiles });
 }

 // Apply jump if requested
 if(!ziplineState.active && input.j){ 
 console.log('[PHYSICS] input.j is 1, calling handleJump()');
 try{ 
 handleJump(); 
 }catch(e){ 
 console.warn('[PHYSICS] Jump input handler error (non-critical):', e); 
 }
 }
 
 // Apply movement forces for dynamic body
 if(!ziplineState.active && (input.f||input.b||input.l||input.r)){
 console.log(`[PHYSICS] Movement input: f=${input.f} b=${input.b} l=${input.l} r=${input.r}`);
 if(playerBody){
 try {
 // Use mouse yaw for direction in mouse look mode, otherwise use camera
 let dir, right;
 if(mouseLookEnabled){
 // Movement relative to mouse look yaw (forward = direction camera looks)
 dir = new THREE.Vector3(Math.sin(mouseYaw), 0, Math.cos(mouseYaw));
 right = new THREE.Vector3(Math.cos(mouseYaw), 0, -Math.sin(mouseYaw));
 } else {
 // Movement relative to camera
 dir = new THREE.Vector3();
 camera.getWorldDirection(dir);
 dir.y = 0;
 dir.normalize();
 right = new THREE.Vector3().crossVectors(dir, new THREE.Vector3(0,1,0)).normalize();
 }

 const avatarCfg = Store.getState().avatarPhysics || {};
 const runMult = Math.max(0.1, Number(avatarCfg.runMultiplier || 1));
 const momentumMode = (avatarCfg.momentumMode|0) === 1 ? 1 : 0;
 const baseForce = momentumMode ? 2.6 : 3.5;
 const force = baseForce * runMult;

 let fx = 0, fz = 0;
 fx += dir.x*(input.f-input.b) + right.x*(input.l-input.r);
 fz += dir.z*(input.f-input.b) + right.z*(input.l-input.r);

 // Apply impulse for responsive control
 const impulse = {x: fx * force, y: 0, z: fz * force};
 playerBody.applyImpulse(impulse, true);

 // Limit horizontal velocity to prevent runaway speed
 const vel = playerBody.linvel();
 const baseMax = momentumMode ? 6.0 : 4.0;
 const maxSpeed = baseMax * runMult;
 const horizSpeed = Math.sqrt(vel.x * vel.x + vel.z * vel.z);
 if(horizSpeed > maxSpeed){
 const scale = maxSpeed / horizSpeed;
 playerBody.setLinvel({x: vel.x * scale, y: vel.y, z: vel.z * scale}, true);
 }
 if(momentumMode === 0){
 playerBody.setLinearDamping(5.0);
 } else {
 playerBody.setLinearDamping(1.5);
 }
 } catch(e) {
 console.warn('Physics movement failed:', e);
 }
 } else {
 console.warn('[PHYSICS] No playerBody for movement');
 }
 }

 // Sync jumpVelocity from physics body for animation
 if(!ziplineState.active){
 try{
 const p = {x: cachedPlayerPos.x, y: cachedPlayerPos.y, z: cachedPlayerPos.z};
 
 // Check if falling off the world
 let respawnPos = physicsSpawnPos ? { ...physicsSpawnPos } : null;
 try{
 const sceneState = Store.getState().scene || {};
 const respawns = sceneState.physicsRespawns || {};
 const selArrId = Store.getState().selection?.arrayId;
 const hostArrId = Number.isFinite(sceneState.timed3D?.hostId) ? Math.trunc(sceneState.timed3D.hostId) : null;
 if(selArrId != null && respawns[selArrId]?.world){
 respawnPos = { ...respawns[selArrId].world };
 } else if(hostArrId != null && respawns[hostArrId]?.world){
 respawnPos = { ...respawns[hostArrId].world };
 }
 }catch{}
 
 // Check for derez effect trigger
 let respawned = false;
 const prevY = celliDerezState.lastY;
 const crossedZero = (prevY != null && prevY > 0 && p.y < 0);
 if(p.y < 0){
 if(crossedZero && !celliDerezState.active && respawnPos){
 console.log('[DEREZ] Triggering derez animation, respawn delayed');
 triggerCelliDerez({ x: p.x, y: 0, z: p.z });
 // Freeze physics during animation
 if(playerBody){
 playerBody.setLinvel({x: 0, y: 0, z: 0}, true);
 playerBody.setAngvel({x: 0, y: 0, z: 0}, true);
 }
 // Pause camera controls during animation
 if(controls){
 try{ controls.enabled = false; }catch{}
 }
 // Schedule respawn after derez animation completes (~1050ms)
 celliDerezState.respawnScheduled = true;
 celliDerezState.respawnData = { pos: respawnPos };
 respawned = true;
 } else if(respawnPos && !celliDerezState.active){
 // Immediate respawn if no derez animation
 console.log('[PHYSICS] Fell off world, respawning at spawn point');
  playerBody.setTranslation(respawnPos, true);
  playerBody.setLinvel({x: 0, y: 0, z: 0}, true);
  cachedPlayerPos.set(respawnPos.x, respawnPos.y, respawnPos.z);
  jumpVelocity = 0;
  landingSquashTime = 0;
  anticipationSquashTime = 0;
  wasGroundedLastFrame = false;
  lastLandKey = null;
  skipWalkBounceUntil = 0;
  resetJumpBudget();
  respawned = true;
 }
}
 if(!respawned){
 celliDerezState.lastY = cachedPlayerPos.y;
 } else {
 celliDerezState.lastY = null;
 }
 
 // Skip physics updates during derez animation
 if(celliDerezState.active && celliDerezState.respawnScheduled){
 // Keep player frozen at derez position
 if(playerBody){
 const derezPos = { x: p.x, y: Math.max(-10, p.y), z: p.z };
 playerBody.setTranslation(derezPos, true);
 playerBody.setLinvel({x: 0, y: 0, z: 0}, true);
 playerBody.setAngvel({x: 0, y: 0, z: 0}, true);
 }
 } else if(!respawned){
 // Sync jumpVelocity with actual physics velocity for animation
 const vel = playerBody.linvel();
 jumpVelocity = vel.y * 2; // Scale for animation sensitivity
 
 // Detect landing for squash animation using raycast
 // Raycast downward to detect ground/platforms
 let nowGrounded = false;
 if(RAPIER && rapierWorld && Number.isFinite(p.x) && Number.isFinite(p.y) && Number.isFinite(p.z)){
 try{
 const ray = new RAPIER.Ray({x: p.x, y: p.y, z: p.z}, {x: 0, y: -1, z: 0});
 const maxToi = 0.5;
 const hit = rapierWorld.castRay(ray, maxToi, true);
 nowGrounded = hit !== null && Math.abs(vel.y) < 1.0;
 }catch(e){
 // Silently ignore raycast errors
 }
 }
 if(!wasGroundedLastFrame && nowGrounded && landingSquashTime === 0){
 landingSquashTime = 1; // Trigger landing squash
 console.log('[PHYSICS] Landing detected!');
 triggerLandHandler();
 }
 if(!nowGrounded){
 lastLandKey = null;
 }
 wasGroundedLastFrame = nowGrounded;
 }
 }catch(e){
 console.warn('Jump sync failed:', e);
 }
 }
 
 // Physics step - must happen BEFORE reading back position
 if(!ziplineState.active){
 try {
 rapierWorld.step();
 
 // Update cached position AFTER physics step
 if(playerBody){
 const translation = playerBody.translation();
 cachedPlayerPos.set(translation.x, translation.y, translation.z);
 applyArrayFloorClamp(playerBody);
 }

 triggerTouchHandlers();

 // Follow camera using updated position
 if(mouseLookEnabled){
 // First-person / third-person platformer camera with mouse look
 const playerPos = new THREE.Vector3(cachedPlayerPos.x, cachedPlayerPos.y + 0.8, cachedPlayerPos.z);
 
 // Camera positioned behind and above player
 const distance = 6.0;
 const height = 2.5;
 
 // Calculate camera position based on mouse yaw/pitch
 const camX = playerPos.x - Math.sin(mouseYaw) * distance * Math.cos(mousePitch);
 const camY = playerPos.y + height + Math.sin(mousePitch) * distance;
 const camZ = playerPos.z - Math.cos(mouseYaw) * distance * Math.cos(mousePitch);
 
 camera.position.set(camX, camY, camZ);
 controls.target.copy(playerPos);
 
 // Disable orbit controls during mouse look
 controls.enableRotate = false;
 controls.enablePan = false;
 } else {
 // Default third-person camera when not in mouse look during physics
 const t = new THREE.Vector3(cachedPlayerPos.x, cachedPlayerPos.y+0.8, cachedPlayerPos.z);
 controls.target.lerp(t, 0.12);
 const desired = new THREE.Vector3(t.x+6, t.y+3.2, t.z+7.5);
 if(Number.isFinite(desired.x) && Number.isFinite(desired.y) && Number.isFinite(desired.z)){
 camera.position.lerp(desired, 0.10);
 } else {
 centerOnPlayer();
 }
 }
 } catch(e) {
 console.warn('Physics step failed:', e);
 // Only disable physics on critical failures, not player movement errors
 const isCriticalError = !e.message?.includes?.('jump') && !e.message?.includes?.('linvel') && !e.message?.includes?.('translation');
 if(isCriticalError){
 console.error('[PHYSICS] CRITICAL ERROR - Disabling physics mode:', e.message);
 Store.setState(s => ({scene: {...s.scene, physics: false}}));
 updatePhysicsStatusChip('Physics: OFF (error)');
 applyDebugPhysicsOverrides(false);
 } else {
 console.log('[PHYSICS] Non-critical error during player movement, continuing physics mode');
 }
 }
 }
 } finally {
 physicsStepping = false;
 }
 }
 // Optimized occlusion: recompute only when camera-facing changes; clear stale occlusion on array/facing change
 if(!animate.lastOcclusionState) animate.lastOcclusionState = {};
 const s=Store.getState().selection;
 const viewMode = (Store.getState().ui && Store.getState().ui.viewMode) || 'standard';
 if(viewMode==='standard' && s.arrayId && s.focus){
 const arr=Store.getState().arrays[s.arrayId];
 updateFacingState(arr);
 computeOcclusion(arr, s.focus);
 const facing = arr._occlusionData?.axis || 'Z';
 const frontLayer = arr._occlusionData?.frontLayer || 0;
 const focusLayer = arr._occlusionData?.focusLayer || 0;

 const signature = `${s.arrayId}:${facing}:${frontLayer}:${focusLayer}`;
 const prevSig = animate.lastOcclusionState.signature;
 if(prevSig && prevSig.split(':')[0] !== String(s.arrayId)){
 // Active array changed: clear occlusion on previous array
 const prevArrId = +prevSig.split(':')[0];
 const prevArr = Store.getState().arrays[prevArrId];
 clearOcclusion(prevArr);
 }
 if(prevSig && prevSig.split(':')[1] !== facing){
 // Facing axis changed: clear old occlusion data before applying new
 clearOcclusion(arr);
 // Also clear overlays/ghosts explicitly for this array
 for(let z=0; z<arr.size.z; z++){
 ['empty','ghost','filled','formula'].forEach(type=>{
 const base=`${arr.id}:${z}:${type}`;
 const rec=layerMeshes.get(base); if(rec){ if(arr._frame) arr._frame.remove(rec.mesh); else scene.remove(rec.mesh); rec.mesh.geometry.dispose(); rec.mesh.material.dispose(); layerMeshes.delete(base); }
 const ekey=`${base}:edges`; const er=layerMeshes.get(ekey); if(er){ if(arr._frame) arr._frame.remove(er.mesh); else scene.remove(er.mesh); er.mesh.geometry.dispose(); er.mesh.material.dispose(); layerMeshes.delete(ekey); }
 });
 }
 }

 if(animate.lastOcclusionState.signature !== signature){
 animate.lastOcclusionState.signature = signature;
 const blockedLayers = new Set();
 // Block layers BETWEEN front and focus, excluding both endpoints
 // Front layer is always visible, focus layer is always visible
 if(facing==='Z'){
 if(frontLayer < focusLayer){ for(let L=frontLayer+1; L<focusLayer; L++) blockedLayers.add(L); }
 else if(frontLayer > focusLayer) { for(let L=frontLayer-1; L>focusLayer; L--) blockedLayers.add(L); }
 } else if(facing==='X'){
 if(frontLayer < focusLayer){ for(let L=frontLayer+1; L<focusLayer; L++) blockedLayers.add(L); }
 else if(frontLayer > focusLayer) { for(let L=frontLayer-1; L>focusLayer; L--) blockedLayers.add(L); }
 } else if(facing==='Y'){
 if(frontLayer < focusLayer){ for(let L=frontLayer+1; L<focusLayer; L++) blockedLayers.add(L); }
 else if(frontLayer > focusLayer) { for(let L=frontLayer-1; L>focusLayer; L--) blockedLayers.add(L); }
 }

 const prevBlocked = animate.lastOcclusionState.blockedLayers || new Set();
 arr._occlusionData = { facing, blockedLayers };
 // Re-render layers. For Z we can do targeted rerender; for X/Y rerender all Z slices (renderLayer filters per-cell)
 if(facing==='Z'){
 for(let z=0; z<arr.size.z; z++){
 const was = prevBlocked.has(z); const now = blockedLayers.has(z);
 if(was !== now) renderLayer(arr, z);
 }
 } else {
 for(let z=0; z<arr.size.z; z++) renderLayer(arr, z);
 }
 animate.lastOcclusionState.blockedLayers = blockedLayers;
 // Apply mask immediately to avoid a one-frame flash
 if (Scene.ChunkManager && Scene.ChunkManager.enabled) {
 try{ applyGhostMaskToChunks(arr); }catch{}
 }
 }
 } else {
 const prevSig = animate.lastOcclusionState.signature;
 if(prevSig){
 const prevArrId = +prevSig.split(':')[0];
 const prevArr = Store.getState().arrays[prevArrId];
 clearOcclusion(prevArr);
 }
 animate.lastOcclusionState.signature = '';
 animate.lastOcclusionState.blockedLayers = new Set();
 }
 // Update per-array timed gamestate animations and apply planned transforms
 try{
 const arrays = Object.values(Store.getState().arrays||{});
 // Global 3D timed progression (overworld)
 const G = (Store.getState().scene||{}).timed3D;
 const scopeState = G?.scope;
 const hostScopeId = (G && Number.isFinite(G.hostId)) ? Math.trunc(G.hostId) : null;
 const scopeSet = new Set(
 Array.isArray(scopeState?.ids)
 ? scopeState.ids
 .map(n => Number(n))
 .filter(n => Number.isFinite(n))
 .map(n => Math.trunc(n))
 : []
 );
 const includeArrayIn3D = (arrId)=>{
 if(!G) return false;
 if(scopeState){
 if(scopeState.mode === 'all') return true;
 if(scopeState.mode === 'limit') return scopeSet.has(arrId);
 if(scopeState.mode === 'host'){
 if(scopeState.ids && scopeState.ids.length){ return scopeState.ids[0] === arrId; }
 if(hostScopeId != null) return hostScopeId === arrId;
 return true;
 }
 }
 if(hostScopeId != null) return hostScopeId === arrId;
 return true;
 };
 let p3D = 0;
 if(G && G.preview){
 // Default configuration if none provided via 3D_TIMED_TRANSLATION
 if(!G.ticks){ G.ticks=240; G.reverseTicks=G.reverseTicks||G.ticks; G.dir=1; G.t=0; }
 if(typeof G._waitCounter!=='number') G._waitCounter = 0;
 const dur3D = (G.dir>0? G.ticks : (G.reverseTicks||G.ticks));
 let r3D = 0;
 // Wait-at-start: hold time; still render p3D=0 so arrays snap to base
 if(G.dir>0 && G.t===0 && (G.waitStart|0) > 0 && G._waitCounter < (G.waitStart|0)){
 G._waitCounter++;
 p3D = 0;
 r3D = 0;
 } else {
 G.t = (G.t + 1);
 r3D = Math.min(1, G.t/Math.max(1,dur3D));
 p3D = (G.dir>0? r3D : (1-r3D));
 }
 if(r3D>=1){
 // Wait-at-end before reversing or looping
 if((G.waitEnd|0) > 0 && G._waitCounter < (G.waitEnd|0)){
 G._waitCounter++;
 __rafId = requestAnimationFrame(animate); return;
 }
 G._waitCounter = 0;
 if(G.reverse && G.dir>0){ G.dir=-1; G.t=0; }
 else if(G.repeat){ G.dir=1; G.t=0; }
 else {
 // Stop preview: restore each array's base state
 G.preview=false;
 try{
 Object.values(Store.getState().arrays||{}).forEach(a=>{
 const T = a?.params?.timed; if(!T) return;
 if(T.baseOffset){ setArrayOffset(a, {x:T.baseOffset.x,y:T.baseOffset.y,z:T.baseOffset.z}, {interactive:true}); }
 if(a._frame && T.baseQuat){ a._frame.quaternion.copy(T.baseQuat); }
 });
 }catch{}
 }
 }
 }
 // Per-array timed: config exists; animate only if previewInArray is enabled
 for(const arr of arrays){
 if(!arr) continue; const T = arr.params && arr.params.timed; if(!T) continue;
 if(T.previewInArray){
 // Ensure timing defaults are sane even if only PREVIEW was called
 if(!T.ticks) { T.ticks = 120; }
 // Ensure baseOffset captured once to compute from starting state
 if(!T.baseOffset){ T.baseOffset = { ...(arr.offset||{x:0,y:0,z:0}) }; }
 // Ensure a timed plan exists; if not, derive from formulas
 if(!T.plan.length){ try{ (Scene.buildTimedPlanFromArray||buildTimedPlanFromArray)(arr); }catch{} }
 
 // Calculate progress for this frame
 const dur = (T.dir>0? T.ticks : (T.reverseTicks||T.ticks));
 // Use T.t+1 for drawing so we reach exactly p=1.0 at the endpoint
 const r = Math.min(1, (T.t + 1) / Math.max(1,dur));
 const p = (T.dir>0 ? r : (1 - r));
 // Green overlays for transformed cells only; ensure overlays draw over everything
 if(T.overlay){
 // Clear previous overlay contents
 while(T.overlay.group.children.length){ const ch=T.overlay.group.children.pop(); ch.geometry?.dispose?.(); ch.material?.dispose?.(); }
 const mat = new THREE.MeshBasicMaterial({ color:0x22c55e, transparent:true, opacity:0.72, depthTest:false, depthWrite:false });
 mat.toneMapped = false;
 const overlayGeo = GEO_VOXEL.clone();
 const parentIsFrame = (T.overlay.group.parent === arr._frame);

 // Group plan by anchor so we emit overlays from each respective anchor
 const keyOf = (a)=> a? `${a.arrId}:${a.x},${a.y},${a.z}` : null;
 const groups = new Map();
 for(const op of T.plan){
 const k = keyOf(op.anchor);
 if(!k) continue;
 if(!groups.has(k)) groups.set(k, { anchor:{...op.anchor}, tx:0,ty:0,tz:0, rsx:0,rsy:0,rsz:0, hasTranspose:false, dims:{w:1,h:1,d:1} });
 const g = groups.get(k);
 if(op.type==='translate'){ g.tx += (op.dx||0); g.ty += (op.dy||0); g.tz += (op.dz||0); }
 else if(op.type==='rotate'){ g.rsx += (op.sx||0); g.rsy += (op.sy||0); g.rsz += (op.sz||0); }
 else if(op.type==='transpose'){ g.hasTranspose = true; }
 else if(op.type==='array'){ g.dims.w = Math.max(1,op.w|0); g.dims.h = Math.max(1,op.h|0); g.dims.d = Math.max(1,op.d|0); }
 }

 const lerp01=(a,b,t)=> a.clone().multiplyScalar(1-t).add(b.clone().multiplyScalar(t));
 const XU = new THREE.Vector3(1,0,0);
 const YU = new THREE.Vector3(0,-1,0);
 const ZU = new THREE.Vector3(0,0,-1);
 for(const g of groups.values()){
 const baseAnchor = g.anchor || {x:0,y:0,z:0,arrId:arr.id};
 const anchorArr = (baseAnchor.arrId!=null && Store.getState().arrays && Store.getState().arrays[baseAnchor.arrId]) || arr;
 let {w,h,d} = g.dims;
 if(w===1 && h===1 && d===1){
 try{
 const nonEmpty=(x,y,z)=>{ const c=Formula.getCell({arrId:anchorArr.id,x,y,z}); return !!(c && (c.formula || (c.value!=='' && c.value!==null && c.value!==undefined))); };
 let ww=1,hh=1,dd=1;
 for(let x=baseAnchor.x+1; x<anchorArr.size.x; x++){ if(!nonEmpty(x,baseAnchor.y,baseAnchor.z)) break; ww++; }
 for(let y=baseAnchor.y+1; y<anchorArr.size.y; y++){ if(!nonEmpty(baseAnchor.x,y,baseAnchor.z)) break; hh++; }
 for(let z=baseAnchor.z+1; z<anchorArr.size.z; z++){ if(!nonEmpty(baseAnchor.x,baseAnchor.y,z)) break; dd++; }
 w=ww; h=hh; d=dd;
 }catch{}
 }

 const anchorL = localPos(anchorArr, baseAnchor.x, baseAnchor.y, baseAnchor.z);
 const leg = (T.dir>0? p : (1-p));
 const angX = (g.rsx*90)*(Math.PI/180) * leg;
 const angY = (g.rsy*90)*(Math.PI/180) * leg;
 const angZ = (g.rsz*90)*(Math.PI/180) * leg;
 // Match actual rotation semantics: world-axis rotations premultiplied (like rotateOnWorldAxis)
 const qxL = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), angX);
 const qyL = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), angY);
 const qzL = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1), angZ);
 const qWorldL = qzL.clone().multiply(qyL).multiply(qxL); // Z * Y * X (world, premultiply order)
 const baseQL = (arr._frame?.quaternion?.clone?.()) || new THREE.Quaternion();
 const qLocal = baseQL.clone().invert().multiply(qWorldL).multiply(baseQL);
 const legShift = (T.dir>0? p : (1-p));
 const shiftL = XU.clone().multiplyScalar((g.tx||0)*legShift)
 .add(YU.clone().multiplyScalar((g.ty||0)*legShift))
 .add(ZU.clone().multiplyScalar((g.tz||0)*legShift));

 const hasTranspose = !!g.hasTranspose;
 const hasDataAt=(ix,iy,iz)=>{
 try{
 const c=Formula.getCell({arrId:anchorArr.id, x:baseAnchor.x+ix, y:baseAnchor.y+iy, z:baseAnchor.z+iz});
 return !!(c && (c.formula || (c.value!=='' && c.value!==null && c.value!==undefined)));
 }catch{ return false; }
 };
 for(let zz=0; zz<d; zz++) for(let yy=0; yy<h; yy++) for(let xx=0; xx<w; xx++){
 if(!hasDataAt(xx,yy,zz)) continue;
 const idx = new THREE.Vector3(xx, yy, zz);
 const swapped = new THREE.Vector3(idx.y, idx.x, idx.z);
 const tIdx = hasTranspose ? lerp01(idx, swapped, p) : idx.clone();
 let offL = XU.clone().multiplyScalar(tIdx.x)
 .add(YU.clone().multiplyScalar(tIdx.y))
 .add(ZU.clone().multiplyScalar(tIdx.z));
 const primaryAxis = (h>1) ? 'y' : ((w>1) ? 'x' : 'z');
 const primaryDim = primaryAxis==='x' ? w : primaryAxis==='y' ? h : d;
 const k = (primaryAxis==='x'? xx : primaryAxis==='y'? yy : zz);
 const pCell = Math.max(0, Math.min(1, p*primaryDim - k));
 offL.applyQuaternion(qLocal);
 offL.add(shiftL);
 offL.multiplyScalar(pCell);
 const posL = anchorL.clone().add(offL);
 let out = posL.clone();
 if(arr !== anchorArr){
 try{
 let worldPos = posL.clone();
 if(anchorArr._frame){ worldPos = posL.clone(); anchorArr._frame.localToWorld(worldPos); }
 else { const offA = anchorArr.offset||{x:0,y:0,z:0}; worldPos.add(new THREE.Vector3(offA.x,offA.y,offA.z)); }
 if(parentIsFrame){
 if(arr._frame){ out = worldPos.clone(); arr._frame.worldToLocal(out); }
 else { const offB = arr.offset||{x:0,y:0,z:0}; out = worldPos.clone().sub(new THREE.Vector3(offB.x,offB.y,offB.z)); }
 } else {
 out = worldPos.clone();
 }
 }catch{}
 } else if(!parentIsFrame){
 if(arr._frame){ out = posL.clone(); arr._frame.localToWorld(out); }
 else { const off = arr.offset||{x:0,y:0,z:0}; out.add(new THREE.Vector3(off.x,off.y,off.z)); }
 }
 const mesh = new THREE.Mesh(overlayGeo, mat.clone()); mesh.renderOrder=9999; mesh.position.copy(out); T.overlay.group.add(mesh);
 }
 }

 // If no plan, place a single placeholder at a reasonable anchor (focus or origin)
 if(T.plan.length===0){
 const sel=Store.getState().selection; const baseAnchor = sel?.arrayId===arr.id && sel.focus ? {...sel.focus, arrId:arr.id} : {x:0,y:0,z:0,arrId:arr.id};
 const anchorL = localPos(arr, baseAnchor.x, baseAnchor.y, baseAnchor.z);
 const mesh = new THREE.Mesh(overlayGeo, mat.clone()); mesh.renderOrder=9999; mesh.position.copy(parentIsFrame? anchorL : (arr._frame? anchorL.clone().applyMatrix4(arr._frame.matrixWorld) : anchorL.clone().add(new THREE.Vector3((arr.offset?.x||0),(arr.offset?.y||0),(arr.offset?.z||0)))) ); T.overlay.group.add(mesh);
 }
 }
 // Increment time AFTER drawing current frame
 T.t = (T.t + 1);
 
 // End/loop logic transition at completion (check if NEXT frame would exceed)
 if(r>=1){
 console.log(`[PREVIEW] Array #${arr.id} completed: r=${r.toFixed(3)}, dir=${T.dir}, reverse=${T.reverse}, repeat=${T.repeat}`);
 T.t = 0; // Reset time for next cycle
 let continueCycle = false;
 if(T.reverse){
 if(T.dir>0){
 console.log(`[PREVIEW] Array #${arr.id} switching to REVERSE direction`);
 T.dir = -1; // Switch to reverse direction
 continueCycle = true;
 } else {
 console.log(`[PREVIEW] Array #${arr.id} reverse complete, repeat=${T.repeat}`);
 T.dir = 1; // Switch back to forward
 continueCycle = !!T.repeat;
 }
 } else if(T.repeat){
 console.log(`[PREVIEW] Array #${arr.id} repeating from start`);
 T.dir = 1; // Keep forward direction
 continueCycle = true;
 }
 console.log(`[PREVIEW] Array #${arr.id} continueCycle=${continueCycle}`);
 // Only stop and cleanup if NOT continuing the cycle
 if(!continueCycle){
 console.log(`[PREVIEW] Array #${arr.id} STOPPING preview`);
 // one-shot: clear overlay after brief hold and unmask content
 T.previewInArray = false;
 setTimeout(()=>{ try{ while(T.overlay.group.children.length){ const ch=T.overlay.group.children.pop(); ch.geometry?.dispose?.(); ch.material?.dispose?.(); } }catch{} }, 120);
 try{ T.overlay.group.parent?.remove(T.overlay.group); }catch{}
 T.overlay=null;
 try{ maskArrayForPreview(arr,false); }catch{}
 }
 }
 }
 // If global 3D preview is enabled, apply full-array motion using the same plan and p3D
 if(G && G.preview && T){
 if(!includeArrayIn3D(arr.id)){
 // Skip global preview application for arrays outside scope
 } else {
 if(!T.plan.length){ buildTimedPlanFromArray(arr); }
 if(!T.plan.length){ continue; }
 if(!T.baseOffset){
 // Reset base to current on first preview frame
 T.baseOffset={...(arr.offset||{x:0,y:0,z:0})};
 try{ if(arr._frame) T.baseQuat = arr._frame.quaternion.clone(); else T.baseQuat = new THREE.Quaternion(); }catch{ T.baseQuat=new THREE.Quaternion(); }
 }
 let tx=0,ty=0,tz=0; let hasTranspose=false; let smooth=false;
 // Stack only translates/transpose from plan; rotation will use applied steps snapshot
 for(const op of T.plan){
 if(op.type==='translate'){ tx+=(op.dx||0); ty+=(op.dy||0); tz+=(op.dz||0); }
 else if(op.type==='transpose'){ hasTranspose=true; }
 }
 // Smooth vs stepped from global or local timed configuration
 smooth = !!((Store.getState().scene?.timed3D?.smooth) || T.smooth);
 // Compute unified translate+rotate around pivot: prefer applied rotation record's pivot
 let pivotLocal = new THREE.Vector3(0,0,0);
 try{
 const S = Store.getState();
 let found=null;
 (S.activeRotations||new Map()).forEach((rec)=>{
 if(found) return;
 if(rec && (rec.targetId===arr.id || (Array.isArray(rec.ids) && rec.ids.includes(arr.id)))) found = rec;
 });
 if(found && found.pivot){ pivotLocal = localPos(arr, found.pivot.x, found.pivot.y, found.pivot.z); }
 else {
 const rotOp = (T.plan||[]).find(op=>op.type==='rotate');
 if(rotOp && rotOp.anchor) pivotLocal = localPos(arr, rotOp.anchor.x, rotOp.anchor.y, rotOp.anchor.z);
 }
 }catch{}
 if(!arr._frame) Scene.renderArray(arr);
 if(!T.baseQuat){ T.baseQuat = arr._frame?.quaternion?.clone?.() || new THREE.Quaternion(); }
 const baseRotPivot = pivotLocal.clone().applyQuaternion(T.baseQuat);
 // Rotation progress and quaternion (snapshot of applied rotation steps; inverse toward pre-transform)
 const steps = arr.rotationSteps || {x:0,y:0,z:0};
 const rotProg = smooth ? (1 - p3D) : (1 - (Math.round(p3D*4)/4));
 const ax = (steps.x|0) * (Math.PI/2) * rotProg;
 const ay = (steps.y|0) * (Math.PI/2) * rotProg;
 const az = (steps.z|0) * (Math.PI/2) * rotProg;
 const qx = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), -ax);
 const qy = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), -ay);
 const qz = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1), -az);
 const dq = qz.clone().multiply(qy).multiply(qx); // Z^- * Y^- * X^- pre-multiply (world order)
 const newQuat = dq.clone().multiply(T.baseQuat);
 const newRotPivot = pivotLocal.clone().applyQuaternion(newQuat);
 // Translation progress (preview un-applies first, then returns to final)
 let dxp=0,dyp=0,dzp=0;
 if(smooth){
 dxp = -tx * (1 - p3D); dyp = -ty * (1 - p3D); dzp = -tz * (1 - p3D);
 } else {
 dxp = tx!==0 ? (Math.round(T.baseOffset.x - tx*(1-p3D)) - T.baseOffset.x) : 0;
 dyp = ty!==0 ? (Math.round(T.baseOffset.y - ty*(1-p3D)) - T.baseOffset.y) : 0;
 dzp = tz!==0 ? (Math.round(T.baseOffset.z - tz*(1-p3D)) - T.baseOffset.z) : 0;
 }
 const disp = new THREE.Vector3(dxp,dyp,dzp);
 const newOffset = new THREE.Vector3(T.baseOffset.x, T.baseOffset.y, T.baseOffset.z)
 .add(disp)
 .add(baseRotPivot)
 .sub(newRotPivot);
 setArrayOffset(arr, {x:newOffset.x, y:newOffset.y, z:newOffset.z}, {interactive:true});
 try{ arr._frame.quaternion.copy(newQuat); }catch{}
 // Minimal transpose preview: slight XY swap tilt to indicate operation
 if(hasTranspose){
 try{
 if(!arr._frame) Scene.renderArray(arr);
 // apply a gentle XY tilt oscillation based on p3D
 const tilt = 0.20 * Math.sin(p3D*Math.PI);
 arr._frame.rotation.set(tilt, arr._frame.rotation.y, -tilt);
 }catch{}
 }
 }
 } else if(G && !G.preview && T){
 // Non-preview: arrays should already be at their one-time end state from 3D_TRANSLATE/3D_ROTATE.
 // Do not re-apply or enforce here to avoid double transforms.
 }
 }
 }catch{}

 // Update procedural animations (overlay previews only)
 try{
 for(let i=proceduralAnims.length-1; i>=0; i--){
 const a = proceduralAnims[i];
 const dur = (a.dir>0? a.ticks : (a.reverseTicks||a.ticks));
 a.t = (a.t + 1);
 const pRaw = Math.min(1, a.t / Math.max(1,dur));
 const p = (a.dir>0 ? pRaw : (1 - pRaw));
 if(a.update) a.update(p);
 if(pRaw >= 1){
 if(a.reverse && a.dir>0){ a.dir = -1; a.t = 0; continue; }
 if(a.repeat){ a.dir = 1; a.t = 0; continue; }
 // Done
 let handled = false;
 try{ if(a.cleanup) handled = !!a.cleanup(); }catch{}
 try{ a.onDone?.(); }catch{}
 if(!handled){ try{ a.group.parent?.remove(a.group); }catch{} }
 proceduralAnims.splice(i,1);
 }
 }
 }catch{}

 controls.update();
 // Optional dynamic chunk LOD
 try{ ChunkManager.update(); }catch{}

 if(FancyGraphics.enabled){
 const dtFancy = FancyGraphics.clock ? FancyGraphics.clock.getDelta() : 0;
 if(FancyGraphics.groups.waveGrid?.material?.uniforms?.time){
 FancyGraphics.groups.waveGrid.material.uniforms.time.value += dtFancy;
 }
 if(FancyGraphics.mirrorUniforms?.time){
 FancyGraphics.mirrorUniforms.time.value += dtFancy;
 }
 if(FancyGraphics.passes.bokeh?.uniforms?.focus){
 FancyGraphics.passes.bokeh.uniforms.focus.value = camera.position.distanceTo(controls.target);
 }
 if(FancyGraphics.passes.outline){
 const highlightObj = selectionCelli.visible ? selectionCelli : (focusMarker.visible ? focusMarker : null);
 if(FancyGraphics.settings.outlineEnabled && highlightObj){
 FancyGraphics.passes.outline.selectedObjects = [highlightObj];
 } else {
 FancyGraphics.passes.outline.selectedObjects = [];
 }
 }
 OceanBackdrop.update(dtFancy);
 } else {
 // Ocean should update even when FancyGraphics is disabled
 const dt = deltaMs / 1000;
 OceanBackdrop.update(dt);
 }

 // Ocean post-processing takes priority when active
 const oceanSettings = OceanBackdrop.getSettings();
 const useOceanPost = oceanSettings && oceanSettings.active;
 
 if(useOceanPost){
 // Use ocean's custom post-processing pipeline
 const didRender = OceanBackdrop.renderWithPost(time * 0.001);
 if(!didRender){
 // Fallback if ocean post fails
 if(FancyGraphics.enabled && FancyGraphics.composer){
 FancyGraphics.composer.render();
 } else {
 renderer.render(scene,camera);
 }
 }
 } else if(FancyGraphics.enabled && FancyGraphics.composer){
 FancyGraphics.composer.render();
 } else {
 renderer.render(scene,camera); // Simple rendering in build mode
 }
 try{ if(!window.__RENDER_READY){ window.__RENDER_READY = true; } }catch{}
 } finally {
 // Always schedule the next frame, even on early returns inside try blocks
 __rafId = requestAnimationFrame(animate);
 }
 }
 let dragState=null;
 
 // Safety: clear drag state on Escape key
 window.addEventListener('keydown', (e)=>{
 if(e.key === 'Escape' && dragState){
 console.log('[PICK] Escape pressed - clearing stuck dragState');
 dragState = null;
 try{ resumeOrbitControls(); }catch{}
 }
 });
 let physicsToggleInFlight = false;
 let orbitSuspendDepth=0;
 let orbitPrevState=null;
 const deletingArrayIds = new Set();
 function normalizeArrayId(id){
 if(id === undefined) return '__undefined__';
 if(id === null) return '__null__';
 return String(id);
 }
 function markArrayDeleting(arrId){
 try{ deletingArrayIds.add(normalizeArrayId(arrId)); }catch{}
 }
 function unmarkArrayDeleting(arrId){
 try{ deletingArrayIds.delete(normalizeArrayId(arrId)); }catch{}
 }
 function isArrayDeleting(arrId){
 try{ return deletingArrayIds.has(normalizeArrayId(arrId)); }catch{ return false; }
 }
 function suspendOrbitControls(){
 if(!controls) return;
 if(orbitSuspendDepth===0){
 orbitPrevState={
 enabled: controls.enabled,
 rotate: controls.enableRotate,
 pan: controls.enablePan,
 zoom: controls.enableZoom
 };
 }
 orbitSuspendDepth++;
 controls.enabled=false;
 controls.enableRotate=false;
 controls.enablePan=false;
 if(typeof controls.enableZoom==='boolean') controls.enableZoom=false;
 }
 function resumeOrbitControls(){
 if(!controls || orbitSuspendDepth===0) return;
 orbitSuspendDepth--;
 if(orbitSuspendDepth===0 && orbitPrevState){
 controls.enabled=orbitPrevState.enabled;
 controls.enableRotate=orbitPrevState.rotate;
 controls.enablePan=orbitPrevState.pan;
 if(typeof orbitPrevState.zoom==='boolean') controls.enableZoom=orbitPrevState.zoom;
 orbitPrevState=null;
 }
 }
 function onPick(e){
 try{
 const rect=renderer.domElement.getBoundingClientRect();
 const mouse=new THREE.Vector2(((e.clientX-rect.left)/rect.width)*2-1, -((e.clientY-rect.top)/rect.height)*2+1);
 const ray=new THREE.Raycaster(); ray.setFromCamera(mouse,camera);
 // Legacy layer meshes (still used for some visuals)
 const layerPickMeshes = [...layerMeshes.values()].map(r=>r.mesh).filter(m=>m.visible && !m.userData.isGhost);
 // Include chunk LOD1 meshes so picking works even when layer meshes are cleared
 const chunkPickMeshes = [];
 const physicsActive = !!Store.getState().scene?.physics;
 const physicsDebugActive = !!Store.getState().scene?.physicsDebugAll;
 try{
 Object.values(Store.getState().arrays).forEach(a=>{
 if(a.hidden) return;
 const hasPhys = !!a.params?.physics?.enabled;
 const shouldFilter = physicsActive && !physicsDebugActive && hasPhys;
 if(shouldFilter){
 console.log(`[RAYCAST] Filtering physics array #${a.id} "${a.name}" from picking`);
 return;
 }
 Object.values(a.chunks||{}).forEach(ch=>{ if(ch?.meshLOD1 && ch.meshLOD1.visible) chunkPickMeshes.push(ch.meshLOD1); });
 });
 }catch{}
 // also pick grab handles
 const grabHandles = Object.values(Store.getState().arrays).flatMap(a=> (a.labels||[]).filter(l=>l.userData?.type==='grab'));
 // Intersect both voxels and grab handles; prefer nearest, but allow grab when tied
 const hits=ray.intersectObjects([...layerPickMeshes, ...chunkPickMeshes, ...grabHandles],false);
 if(!hits.length) return;
 const activeHits = deleteInteractionLock
 ? hits.filter(h=>{
 try{
 const arrId = h?.object?.userData?.arrayId
 ?? h?.object?.userData?.chunk?.arrayId
 ?? h?.object?.userData?.chunk?.array?.id;
 if(arrId == null) return true;
 return !isArrayDeleting(arrId);
 }catch{ return !deleteInteractionLock; }
 })
 : hits;
 if(!activeHits.length) return;
 // Always prefer the grab handle if it is hit at all
 const grabHit = activeHits.find(h => h.object?.userData?.type==='grab');
 let hit = grabHit || activeHits.find(h => (h.object && h.object.isInstancedMesh && typeof h.instanceId === 'number')) || activeHits[0];
 if(hit.object.userData?.type==='grab'){
 // begin array reposition drag
 const arr=Store.getState().arrays[hit.object.userData.arrayId];
 if(!arr) return;
 const startOff={...(arr.offset||{x:0,y:0,z:0})};
 // Determine movement plane from clicked face normal
 const nLocal = hit.face?.normal?.clone()||new THREE.Vector3(0,1,0);
 const nWorld = nLocal.clone().transformDirection(hit.object.matrixWorld).normalize();
 let planeNormal=new THREE.Vector3(0,1,0);
 if(Math.abs(nWorld.x) > Math.abs(nWorld.y) && Math.abs(nWorld.x) > Math.abs(nWorld.z)) planeNormal.set(1,0,0); // YZ plane
 else if(Math.abs(nWorld.y) > Math.abs(nWorld.x) && Math.abs(nWorld.y) > Math.abs(nWorld.z)) planeNormal.set(0,1,0); // XZ plane
 else planeNormal.set(0,0,1); // XY plane
 const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(planeNormal, hit.point);
 const startPoint = new THREE.Vector3(); ray.ray.intersectPlane(plane,startPoint);
 // lock orbit controls during drag
 suspendOrbitControls();
 const onMove=(ev)=>{
 const r=renderer.domElement.getBoundingClientRect();
 const m=new THREE.Vector2(((ev.clientX-r.left)/r.width)*2-1, -((ev.clientY-r.top)/r.height)*2+1);
 const r2=new THREE.Raycaster(); r2.setFromCamera(m,camera);
 const p2=new THREE.Vector3(); r2.ray.intersectPlane(plane,p2);
 // Grid-snapped movement on the two axes of the chosen plane
 const delta = new THREE.Vector3().subVectors(p2,startPoint);
 let nx=startOff.x, ny=startOff.y, nz=startOff.z;
 const snap = (axis, raw)=>{
 const s = axis==='x'?arr.size.x : axis==='y'?arr.size.y : arr.size.z;
 const base = (axis==='z') ? (s/2 - 0.5) : (-(s/2) + 0.5);
 return Math.round(raw + base) - base; // align world centers irrespective of parity
 };
 if(planeNormal.y===1||planeNormal.y===-1){ // XZ plane
 nx = snap('x', startOff.x + delta.x);
 nz = snap('z', startOff.z + delta.z);
 } else if(planeNormal.x===1||planeNormal.x===-1){ // YZ plane
 ny = snap('y', startOff.y + delta.y);
 nz = snap('z', startOff.z + delta.z);
 } else { // XY plane
 nx = snap('x', startOff.x + delta.x);
 ny = snap('y', startOff.y + delta.y);
 }
 // Interactive drag: apply immediately and skip wobble to keep 60fps
 setArrayOffset(arr, {x:nx, y:ny, z:nz}, {interactive:true});
 };
 const onUp=()=>{
 resumeOrbitControls();
 window.removeEventListener('pointermove',onMove);
 window.removeEventListener('pointerup',onUp);
 try{
 const cur=arr.offset||{x:0,y:0,z:0};
 const dir={ dx: Math.sign((cur.x||0)-(startOff.x||0)), dy: Math.sign((cur.y||0)-(startOff.y||0)), dz: Math.sign((cur.z||0)-(startOff.z||0)) };
 settleAfterDrag(arr, dir);
 }catch{}
 try{
 arr.params = arr.params || {};
 const timed = arr.params.timed;
 if(timed){
 timed.baseOffset = { ...(arr.offset||{x:0,y:0,z:0}) };
 if(arr._frame && arr._frame.quaternion){
 try{ timed.baseQuat = arr._frame.quaternion.clone(); }catch{}
 }
 }
 }catch{}
 };
 window.addEventListener('pointermove',onMove); window.addEventListener('pointerup',onUp);
 return;
 }
 // nav pad interactions removed (HUD only)
 let arrayId = hit.object.userData.arrayId;
 let arr = Store.getState().arrays[arrayId];
 if(!arr) return;
 let cell = null; let z = null;
 if(hit.object.userData && hit.object.userData.chunk){
 const chunk = hit.object.userData.chunk;
 cell = chunk?.index2cell?.[hit.instanceId];
 z = cell?.z;
 } else {
 const z0 = hit.object.userData.z, type0 = hit.object.userData.type;
 const rec = layerMeshes.get(`${arrayId}:${z0}:${type0}`);
 cell = rec?.index2cell?.[hit.instanceId];
 z = z0;
 }
 
 // If the picked cell has an ONCLICK action, execute it immediately (3D)
 if(!cell) return;
 
 // Check if this cell is ghosted - cells in focus layer are always selectable
 try{
 const sel = Store.getState().selection;
 const isFocusArray = (sel?.arrayId === arr.id);
 const occ = arr._occlusionData || {};
 const blocked = occ.blockedLayers || new Set();
 const axis = occ.axis || occ.facing || 'Z';
 const cellLayer = axis==='X' ? cell.x : axis==='Y' ? cell.y : cell.z;
 const focusLayer = isFocusArray && sel.focus ? (axis==='X' ? sel.focus.x : axis==='Y' ? sel.focus.y : sel.focus.z) : null;
 const isFocusLayer = (focusLayer === cellLayer);
 
 // Reject if blocked AND not on focus layer (focus layer is always solid/selectable)
 if(blocked.has(cellLayer) && !isFocusLayer){
 console.log(`[PICK] Rejected ghosted cell at (${cell.x},${cell.y},${cell.z}) - layer ${cellLayer} blocked, not focus layer`);
 return;
 }
 }catch(e){ console.warn('[PICK] Ghost check failed', e); }
 
 let decodedAction = '';
 let hasAction = false;
 try{
 const c2d = UI.getCell(arr.id, {x:cell.x,y:cell.y,z:cell.z});
 let actionRaw = String(getMetaAction(c2d?.meta, 'on_click')||'').trim();
 if(actionRaw){
 hasAction = true;
 if(actionRaw.startsWith('B64:')){
 try{ actionRaw = atob(actionRaw.slice(4)); }catch{}
 } else {
 const colon=actionRaw.indexOf(':');
 if(colon>0 && /^\d+$/.test(actionRaw.slice(0,colon))){
 const enc=actionRaw.slice(colon+1);
 try{ actionRaw = atob(enc); }catch{}
 }
 }
 decodedAction = actionRaw.startsWith('=') ? actionRaw : `=${actionRaw}`;
 }
 }catch{}

 if(!(hasAction && formulaHasChime(decodedAction))){ playCellClick(); }
 try{
 if(hasAction && decodedAction){
 const tx = Write.start('onclick.3d','Click action (3D)');
 Formula.runOnceAt({arrId:arr.id,x:cell.x,y:cell.y,z:cell.z}, decodedAction, tx);
 Write.commit(tx);
 // Visual feedback pulse
 try{ pulseCell(arr, cell, z); }catch{}
 // Do not return; continue to also select the cell
 }
 }catch{}

 // If in physics mode, check collision mode for this specific cell
 // physicsActive and physicsDebugActive already declared above
 const hasPhysics = !!arr?.params?.physics?.enabled;
 const cellCollisionMode = determineCollisionMode(arr, cell, { debugMode: physicsDebugActive });
 console.log(`[PHYSICS CLICK] Array #${arr.id} "${arr.name}" cell (${cell.x},${cell.y},${cell.z}): physicsActive=${physicsActive}, debugActive=${physicsDebugActive}, hasPhysics=${hasPhysics}, cellMode=${cellCollisionMode}`);
 
 // Exit physics mode if clicking an 'edit' mode cell (empty or non-formula cells)
 if(physicsActive && !physicsDebugActive && cellCollisionMode === 'edit'){
 console.log(`[PHYSICS] Clicked edit-mode cell in array #${arr.id} "${arr.name}" - exiting physics mode`);
 try{
 Actions.setSelection(arr.id, {x:cell.x, y:cell.y, z:cell.z}, null, '3d');
 centerOnArray(arr);
 const res = togglePhysicsMode();
 if(res && typeof res.catch === 'function'){
 res.catch(err=>console.warn('[PHYSICS] Exit on click failed', err));
 }
 }catch(e){ console.warn('[PHYSICS] Exit on click threw', e); }
 return;
 }

 // Start drag-select in 3D with playful click feedback (scale pulse)
 const maxLayer = Math.max(0, (arr.size?.z||1) - 1);
 let startLayer = Number.isFinite(cell?.z) ? Math.round(cell.z) : 0;
 let viewLocked = false;
 try{
 const uiState = Store.getState().ui || {};
 if(uiState.lastInteraction === '2d' && Number.isFinite(uiState.zLayer)){
 startLayer = Math.round(uiState.zLayer);
 viewLocked = true;
 }
 }catch{}
 if(!Number.isFinite(startLayer)) startLayer = 0;
 startLayer = Math.min(maxLayer, Math.max(0, startLayer));
 dragState={arrayId:arr.id, start:{x:cell.x,y:cell.y,z:startLayer}, lockZ:startLayer, viewLock:viewLocked};
 Actions.setSelection(arr.id, {x:cell.x,y:cell.y,z:startLayer}, null, '3d');
 try{ pulseCell(arr, cell, z); }catch{}
 // Freeze orbit while dragging
 suspendOrbitControls();
 
 const onMove=(ev)=>{
 if(!dragState) return;
 const r=renderer.domElement.getBoundingClientRect();
 const m=new THREE.Vector2(((ev.clientX-r.left)/r.width)*2-1, -((ev.clientY-r.top)/r.height)*2+1);
 ray.setFromCamera(m,camera);
 // Filter out ghost meshes explicitly during drag selection
 const solidLayerMeshes = [...layerMeshes.values()].map(r=>r.mesh).filter(m=>m.visible && !m.userData.isGhost && m.userData.type!=='ghost');
 const solidChunkMeshes = [];
 try{
 Object.values(Store.getState().arrays).forEach(a=>{
 if(a.hidden) return;
 Object.values(a.chunks||{}).forEach(ch=>{ 
 // Only include solid meshes, not ghost meshes
 if(ch?.meshLOD1 && ch.meshLOD1.visible && !ch?.meshGhost) solidChunkMeshes.push(ch.meshLOD1);
 else if(ch?.meshLOD1 && ch.meshLOD1.visible) solidChunkMeshes.push(ch.meshLOD1);
 });
 });
 }catch{}
 const h=ray.intersectObjects([...solidLayerMeshes, ...solidChunkMeshes], false);
 if(h.length){
 const hh=h[0];
 let aid = hh.object.userData.arrayId;
 let cel = null; let z = null;
 if(hh.object.userData && hh.object.userData.chunk){
 const ch = hh.object.userData.chunk;
 aid = ch?.array?.id || aid;
 cel = ch?.index2cell?.[hh.instanceId];
 z = cel?.z;
 } else {
 const z0 = hh.object.userData.z; const type0 = hh.object.userData.type;
 // Skip ghost type meshes
 if(type0 && String(type0).includes('ghost')) return;
 const rec2 = layerMeshes.get(`${aid}:${z0}:${type0}`);
 cel = rec2?.index2cell?.[hh.instanceId];
 z = z0;
 }
 if(!cel) return;
 
 // Check if this cell is ghosted - skip UNLESS it's on the focus layer
 try{
 const arrForCheck = Store.getState().arrays[aid];
 if(arrForCheck){
 const sel = Store.getState().selection;
 const isFocusArray = (sel?.arrayId === aid);
 const occ = arrForCheck._occlusionData || {};
 const blocked = occ.blockedLayers || new Set();
 const axis = occ.axis || occ.facing || 'Z';
 const cellLayer = axis==='X' ? cel.x : axis==='Y' ? cel.y : cel.z;
 const focusLayer = isFocusArray && sel.focus ? (axis==='X' ? sel.focus.x : axis==='Y' ? sel.focus.y : sel.focus.z) : null;
 const isFocusLayer = (focusLayer === cellLayer);
 
 // Skip if blocked AND not focus layer
 if(blocked.has(cellLayer) && !isFocusLayer){
 return;
 }
 }
 }catch{}
 
 if(aid===dragState.arrayId){
 const arrForDrag = Store.getState().arrays[dragState.arrayId];
 const maxLayer = Math.max(0, (arrForDrag?.size?.z||1) - 1);
 const clampLayer = (val)=>Math.min(maxLayer, Math.max(0, Math.round(val)));
 // Use the actual cell z coordinate for natural selection
 let targetLayer = Number.isFinite(cel?.z) ? clampLayer(cel.z) : dragState.lockZ;
 if(dragState.viewLock){
 let applied = false;
 applied = cel?.z != null && Number.isFinite(cel.z);
 if(!applied && z != null && Number.isFinite(z)){
 targetLayer = clampLayer(z);
 applied = true;
 }
 if(!applied){
 try{
 const viewLayer = Store.getState().ui?.zLayer;
 if(Number.isFinite(viewLayer)){
 targetLayer = clampLayer(viewLayer);
 applied = true;
 }
 }catch{}
 }
 if(!applied && Number.isFinite(dragState.start?.z)){
 targetLayer = clampLayer(dragState.start.z);
 }
 }
 if(!Number.isFinite(targetLayer)) targetLayer = clampLayer(dragState.start?.z ?? 0);
 Actions.setSelectionRange(dragState.arrayId, dragState.start, {x:cel.x,y:cel.y,z:targetLayer}, '3d');
 // Cache the last valid drag position to maintain it during gaps
 dragState.lastValid = {x:cel.x, y:cel.y, z:targetLayer};
 }
 } else if(dragState.lastValid){
 // No hit (hovering gap) - maintain last valid position to prevent layer jumping
 Actions.setSelectionRange(dragState.arrayId, dragState.start, dragState.lastValid, '3d');
 }
 };
 const onUp=()=>{ dragState=null; resumeOrbitControls(); window.removeEventListener('pointermove',onMove); window.removeEventListener('pointerup',onUp); };
 window.addEventListener('pointermove',onMove); window.addEventListener('pointerup',onUp);
 }catch(err){
 console.error('[PICK] Click selection failed:', err);
 // Ensure orbit controls are restored if there was an error
 try{ resumeOrbitControls(); }catch{}
 }
 }
 function setArrayOffset(arr, next, opts){
 opts = opts||{}; const fast = !!opts.interactive; const skipDock = !!opts._skipDock; const skipConn = !!opts._skipConnections;
 // Snap to global phase
 const arrScale = arrayVoxelScale(arr);
 const snapAxis=(axis,val,sz)=>{
 const phases = Store.getState().gridPhase || {};
 const phase = phases[axis] || 0;
 const half = (sz * arrScale) / 2;
 const base = axis==='z' ? (half - arrScale/2) : (-(half) + arrScale/2);
 if(arrScale === 0) return val;
 return Math.round((val - base - phase)/arrScale) * arrScale + base + phase;
 };
 const snapped={ x:snapAxis('x',next.x,arr.size.x), y:snapAxis('y',next.y,arr.size.y), z:snapAxis('z',next.z,arr.size.z) };
 const curOff = arr.offset||{x:0,y:0,z:0};
 // If no actual snap delta, do nothing (prevents wobble without movement)
 if(Math.abs(snapped.x-curOff.x)+Math.abs(snapped.y-curOff.y)+Math.abs(snapped.z-curOff.z) < 1e-6){ return; }
 // Smooth transition toward snapped position
 if(!arr._frame){ arr.offset=snapped; }
 else if(fast){
 // Immediate update for interactive drags
 arr.offset={x:snapped.x,y:snapped.y,z:snapped.z};
 arr._frame.position.set(snapped.x,snapped.y,snapped.z);
 } else {
 const cur=arr.offset||{x:0,y:0,z:0};
 const lerp=(a,b,t)=> a+(b-a)*t;
 const steps=6; let i=0;
 const tick=()=>{
 i++; const t=i/steps; const ease=t*(2-t); // smoothstep-ish
 const x=lerp(cur.x,snapped.x,ease), y=lerp(cur.y,snapped.y,ease), z=lerp(cur.z,snapped.z,ease);
 arr.offset={x,y,z}; if(arr._frame) arr._frame.position.set(x,y,z);
 if(i<steps){ requestAnimationFrame(tick); }
 else {
 // Only wobble once per snap (guard quick repeats)
 const now = performance.now();
 if(!fast && (!arr._lastSnap || now - arr._lastSnap > 120)){
 arr._lastSnap = now;
 applyWiggle(arr, {angle:0.11, lift:0.06, hold:170});
 }
 }
 };
 requestAnimationFrame(tick);
 }

 // Non-destructive: update transforms only
 if(arr._frame) arr._frame.position.set(arr.offset.x,arr.offset.y,arr.offset.z);

 // Apply dock propagation after offset change (use actual delta of snapped vs previous)
 try{
 const S=Store.getState();
 const group = [...(S.dockGroups||new Map()).values()].find(g=>g.members.includes(arr.id));
 if(group && !skipDock){
 const orderIndex = group.members.indexOf(arr.id);
 const ids = (group.mode==='parent') ? group.members.slice(orderIndex+1) : group.members.filter(id=>id!==arr.id);
 const dx=snapped.x-curOff.x, dy=snapped.y-curOff.y, dz=snapped.z-curOff.z;
 ids.forEach(id=>{
 const a=S.arrays[id]; if(!a) return; const off=a.offset||{x:0,y:0,z:0};
 const nx=off.x+dx, ny=off.y+dy, nz=off.z+dz;
 // Reuse same transform pipeline to ensure identical math, but skip further propagation and heavy work
 setArrayOffset(a,{x:nx,y:ny,z:nz},{interactive:true, _skipDock:true, _skipConnections:true});
 });
 }
 }catch{}

 // Update matrices for existing layer meshes by recomputing instance transforms
 if(!arr._frame && !fast){
 Object.entries(Store.getState().arrays).forEach(()=>{}); // no-op ensure state accessible
 for(let z=0; z<arr.size.z; z++){
 ['empty','ghost','filled','formula','edges'].forEach(type=>{
 const rec=layerMeshes.get(`${arr.id}:${z}:${type}`);
 if(!rec) return;
 const {mesh,index2cell}=rec; if(!mesh||!index2cell) return;
 for(let i=0;i<index2cell.length;i++){
 const c=index2cell[i]; if(!c) continue;
 temp.position.copy(localPos(arr,c.x,c.y,c.z));
 temp.updateMatrix();
 mesh.setMatrixAt(i,temp.matrix);
 }
 mesh.instanceMatrix.needsUpdate=true;
 });
 }
 }

 // Update value sprites - parent them to frame and use local coords
 if(!(arr._frame && fast)){
 valueSprites.forEach((sprite,key)=>{
 if(!key.startsWith(`${arr.id}:`)) return;
 const [_,coords]=key.split(':'); const [x,y,z]=coords.split(',').map(Number);
 // Parent sprite to frame if not already
 if(sprite.parent !== arr._frame && arr._frame){
 sprite.parent?.remove(sprite);
 arr._frame.add(sprite);
 // Recompute position in local space
 const pos=localPos(arr,x,y,z); 
 sprite.position.set(pos.x,pos.y,pos.z+0.55);
 }
 });
 }

 // Update connection lines that involve this array
 if(!skipConn){
 connections.forEach((connection, key) => {
 const { ref1, ref2, visual } = connection;
 if(ref1.arrId === arr.id || ref2.arrId === arr.id) {
 const arr1 = Store.getState().arrays[ref1.arrId];
 const arr2 = Store.getState().arrays[ref2.arrId];
 if(!arr1 || !arr2 || !visual) return;

 const start = worldPos(arr1, ref1.x, ref1.y, ref1.z);
 const end = worldPos(arr2, ref2.x, ref2.y, ref2.z);
 const dir = new THREE.Vector3().subVectors(end, start);
 const length = Math.max(0.0001, dir.length());
 const center = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
 const dirNorm = length > 0.0001 ? dir.clone().divideScalar(length) : new THREE.Vector3(1,0,0);

 connection.start = start;
 connection.end = end;
 connection.length = length;

 if(connection.mode === 'platform' || connection.mode === 'grind'){
 const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(1,0,0), dirNorm.clone());
 visual.position.copy(center);
 visual.quaternion.copy(quat);
 visual.scale.set(length, 1, 1);
 } else if(connection.mode === 'zipline'){
 const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,1,0), dirNorm.clone());
 visual.position.copy(center);
 visual.quaternion.copy(quat);
 visual.scale.set(1, length, 1);
 } else {
 try{
 visual.geometry.dispose();
 }catch{}
 visual.geometry = new THREE.BufferGeometry().setFromPoints([start, end]);
 }
 }
 });
 }
 // Update occlusion/highlight meshes for this array
 highlights.forEach((highlight, key) => {
 if(key.startsWith(`${arr.id}:`)) {
 const [_, coords] = key.split(':');
 const [x, y, z] = coords.split(',').map(Number);
 if(highlight.mesh) {
 highlight.mesh.position.copy(worldPos(arr, x, y, z));
 }
 }
 });

 try{ refreshLightsForArray(arr.id); }catch{}

 // Skip rebuilding axes during movement to prevent stamping
 // buildAxes(arr); // Commented out - only rebuild when array structure changes
 const s=Store.getState().selection; if(s.arrayId===arr.id) updateFocus(s);
 // Enforce visibility after transforms (hidden arrays remain hidden)
 try{ syncVisibility(arr); }catch{}

 // Interactions: run overlap/gobble checks shortly after move settles
 try{ setTimeout(()=>{ InteractionManager?.runChecks?.(arr); }, 120); }catch{}
 }

 // Apply post-snap wiggle/tilt to give momentum feeling
 function applyWiggle(arr, {angle=0.11, lift=0.06, hold=170}={}){
 try{
 const scale = arrayVoxelScale(arr);
 for(let zz=0; zz<arr.size.z; zz++){
 const recs=[];
 ['empty','ghost','filled','formula'].forEach(type=>{ const r=layerMeshes.get(`${arr.id}:${zz}:${type}`); if(r) recs.push(r); });
 layerMeshes.forEach((val,key)=>{ if(val?.mesh?.userData?.type==='edges' && val.mesh?.userData?.arrayId===arr.id && val.mesh?.userData?.z===zz) recs.push(val); });
 recs.forEach(rec=>{
 if(!rec||!rec.mesh||!rec.index2cell) return;
 for(let k=0;k<rec.index2cell.length;k++){
 const c=rec.index2cell[k]; if(!c) continue;
 const basePos = localPos(arr,c.x,c.y,c.z);
 temp.position.copy(basePos).add(new THREE.Vector3(0,lift*scale,0));
 temp.rotation.set(angle, 0, -angle);
 temp.scale.set(scale,scale,scale);
 temp.updateMatrix();
 rec.mesh.setMatrixAt(k,temp.matrix);
 }
 rec.mesh.instanceMatrix.needsUpdate=true;
 setTimeout(()=>{
 for(let k=0;k<rec.index2cell.length;k++){
 const c=rec.index2cell[k]; if(!c) continue;
 temp.position.copy(localPos(arr,c.x,c.y,c.z));
 temp.rotation.set(0,0,0); temp.scale.set(scale,scale,scale); temp.updateMatrix();
 rec.mesh.setMatrixAt(k,temp.matrix);
 }
 rec.mesh.instanceMatrix.needsUpdate=true;
 }, hold);
 });
 }
 }catch{}
 }

 // After releasing drag, add a subtle overshoot settle and wiggle
 function settleAfterDrag(arr, dir){
 if(!arr?._frame) return;
 const target = new THREE.Vector3(arr.offset?.x||0, arr.offset?.y||0, arr.offset?.z||0);
 const start = arr._frame.position.clone();
 const dv = new THREE.Vector3(dir.dx||0, dir.dy||0, dir.dz||0);
 const len = dv.length();
 let ov = new THREE.Vector3();
 if(len>1e-6) ov.copy(dv.clone().normalize().multiplyScalar(0.18));
 const overshoot = target.clone().add(ov);
 let phase=0; let t0; const dur1=110, dur2=100;
 const ease=(t)=> t*(2-t);
 const step=(ts)=>{
 if(t0==null) t0=ts;
 const dt=ts-t0;
 if(phase===0){
 const u = Math.min(1, dt/dur1);
 const e = ease(u);
 const p = start.clone().lerp(overshoot, e);
 arr._frame.position.copy(p);
 if(u<1){ requestAnimationFrame(step); }
 else { phase=1; t0=undefined; requestAnimationFrame(step); }
 } else {
 const u = Math.min(1, (dt)/dur2);
 const e = ease(u);
 const p = overshoot.clone().lerp(target, e);
 arr._frame.position.copy(p);
 if(u<1){ requestAnimationFrame(step); }
 else { arr._frame.position.copy(target); applyWiggle(arr); }
 }
 };
 requestAnimationFrame(step);
 }
 function getArrayOffset(arr){ const o=arr?.offset||{x:0,y:0,z:0}; return {x:o.x,y:o.y,z:o.z}; }

 function setGridVisible(v){
 FancyGraphics.base.gridVisible = v;
 grid.visible = FancyGraphics.enabled ? false : v;
 }
 function setAxesVisible(v){ axesHelper.visible=v; Object.values(Store.getState().arrays).forEach(a=>{ a.labels?.forEach(s=>s.visible=v); }); }

 // keyboard for physics locomotion
 const input={f:0,b:0,l:0,r:0,j:0};
 const platformerKeyState={left:false,right:false,up:false,down:false,jump:false};
 const PLATFORMER_KEY_BINDINGS={
 arrowleft:'left',
 a:'left',
 arrowright:'right',
 d:'right',
 arrowup:'up',
 w:'up',
 arrowdown:'down',
 s:'down',
 ' ':'jump',
 space:'jump',
 spacebar:'jump'
 };
 function normalizePlatformerKey(key){
 if(!key) return '';
 if(key === ' ') return 'space';
 return key.length===1 ? key.toLowerCase() : key.toLowerCase();
 }
 function isPlatformerActive(global){
 try{
 const g = global || Store.getState().globalState;
 if(!g) return false;
 if(typeof g.has === 'function'){
 // Check active flag first - if it exists and is false, platformer is NOT active
 if(g.has('platformer.active')) return !!g.get('platformer.active');
 // Only fall back to pos check if active flag doesn't exist
 // This prevents false positives from stale pos data
 return false;
 }
 const active = g.get ? g.get('platformer.active') : null;
 if(active != null) return !!active;
 return false;
 }catch{return false;}
 }
 function refreshPlatformerInput(global){
 try{
 const g = global || Store.getState().globalState;
 if(!g || typeof g.set !== 'function' || typeof g.get !== 'function') return;
 const jumpActive = !!platformerKeyState.jump;
 let dir='none';
 if(platformerKeyState.left) dir='left';
 else if(platformerKeyState.right) dir='right';
 else if(platformerKeyState.up) dir='up';
 else if(platformerKeyState.down) dir='down';
 if(g.get('platformer.input') !== dir){
 g.set('platformer.input', dir);
 }
 if(typeof g.set === 'function'){
 const prevJump = typeof g.get === 'function' ? g.get('platformer.jump') : undefined;
 const nextJump = jumpActive ? 1 : 0;
 if(prevJump !== nextJump){
 g.set('platformer.jump', nextJump);
 }
 }
 }catch(e){ console.warn('Platformer input sync failed', e); }
 }
 function resetPhysicsInputState(){
 input.f = 0; input.b = 0; input.l = 0; input.r = 0; input.j = 0;
 platformerKeyState.left = false;
 platformerKeyState.right = false;
 platformerKeyState.up = false;
 platformerKeyState.down = false;
 platformerKeyState.jump = false;
 try{ refreshPlatformerInput(Store.getState().globalState); }catch{}
 }
 function handlePlatformerKey(key,isDown){
 const dir = PLATFORMER_KEY_BINDINGS[normalizePlatformerKey(key)];
 if(!dir) return false;
 platformerKeyState[dir] = !!isDown;
 return true;
 }

 let mouseLookEnabled = false;
 let mouseYaw = 0; // Camera rotation around Y axis
 let mousePitch = 0; // Camera rotation around X axis
 
 // Mouse look for physics mode (3D platformer controls)
 window.addEventListener('mousemove',(e)=>{
 if(!mouseLookEnabled || !Store.getState().scene.physics) return;
 
 const sensitivity = 0.002;
 mouseYaw -= e.movementX * sensitivity;
 mousePitch -= e.movementY * sensitivity;
 mousePitch = Math.max(-Math.PI/3, Math.min(Math.PI/3, mousePitch)); // Limit pitch
 }, true);
 
 // Click to enable mouse look in physics mode
 window.addEventListener('click',(e)=>{
 if(Store.getState().scene.physics && !mouseLookEnabled){
 e.preventDefault();
 mouseLookEnabled = true;
 document.body.requestPointerLock?.();
 console.log('[PHYSICS] Mouse look enabled - move mouse to look around, ESC to exit');
 }
 }, true);
 
 // Detect pointer lock changes
 document.addEventListener('pointerlockchange',()=>{
 if(!document.pointerLockElement){
 mouseLookEnabled = false;
 console.log('[PHYSICS] Mouse look disabled');
 }
 });
 
 // Toggle arrow mapping via middle mouse button (Mouse 3)
 window.addEventListener('mousedown',(e)=>{
 if(e.button===1){
 e.preventDefault();
 Store.setState(s=>({scene:{...s.scene, arrowMapDepth: !s.scene.arrowMapDepth}}));
 const flag = Store.getState().scene.arrowMapDepth;
 showToast(flag? 'Arrows: Depth' : 'Arrows: Height');
 }
 }, true);
 window.addEventListener('keydown',(e)=>{
 // Debug: Log ALL keys at the very start
 if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)){
 console.log(`[DEBUG] Arrow key captured at handler start: ${e.key}`);
 }
 
 const s=Store.getState();
 const activeEl = document.activeElement;
 const activeTag = (activeEl?.tagName||'').toUpperCase();
 const direct = document.getElementById('directEdit');
 const directOpen = !!(direct && direct.style.display==='block');
 const directFocused = !!(direct && activeEl === direct);
 const baseTypingElement = (activeTag==='INPUT' || activeTag==='TEXTAREA');
 const typingElement = baseTypingElement && !(directFocused && !directOpen);
 const platformerMode = isPlatformerActive(s.globalState);
 
 if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)){
 console.log(`[DEBUG] platformerMode=${platformerMode}, typingElement=${typingElement}, directOpen=${directOpen}`);
 }
 
 const physicsCapturing = !!Scene.isPhysicsInputCaptured?.();
 const physicsActive = !!s.scene.physics;
 if(physicsCapturing){
 const typing = typingElement || directOpen;
 if(!typing && ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' ','Spacebar','w','a','s','d','W','A','S','D','Escape'].includes(e.key)){
 if(handlePlatformerKey(e.key, true)) refreshPlatformerInput(s.globalState);
 e.preventDefault();
 if(physicsActive){
 if(e.key==='ArrowUp'||e.key==='w'||e.key==='W') input.f=1;
 if(e.key==='ArrowDown'||e.key==='s'||e.key==='S') input.b=1;
 if(e.key==='ArrowLeft'||e.key==='a'||e.key==='A') input.l=1;
 if(e.key==='ArrowRight'||e.key==='d'||e.key==='D') input.r=1;
 if(e.key===' '||e.key==='Spacebar'){
 console.log('[PHYSICS] Spacebar pressed - setting input.j=1, physicsActive=true, physicsCapturing=true');
 input.j=1;
 }
 if(e.key==='Escape'){
 console.log('[PHYSICS] ESC pressed - exiting physics mode');
 Actions.togglePhysics();
 return;
 }
 }
 return;
 }
 }

 if(!physicsCapturing && physicsActive){
 const typing = typingElement || directOpen;
 if(!typing && ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' ','Spacebar','w','a','s','d','W','A','S','D','Escape'].includes(e.key)){
 if(handlePlatformerKey(e.key, true)) refreshPlatformerInput(s.globalState);
 e.preventDefault();
 if(e.key==='ArrowUp'||e.key==='w'||e.key==='W') input.f=1;
 if(e.key==='ArrowDown'||e.key==='s'||e.key==='S') input.b=1;
 if(e.key==='ArrowLeft'||e.key==='a'||e.key==='A') input.l=1;
 if(e.key==='ArrowRight'||e.key==='d'||e.key==='D') input.r=1;
 if(e.key===' '||e.key==='Spacebar'){
 console.log('[PHYSICS] Spacebar pressed - setting input.j=1, physicsActive=true, physicsCapturing=false');
 input.j=1;
 }
 if(e.key==='Escape'){
 console.log('[PHYSICS] ESC pressed - exiting physics mode');
 Actions.togglePhysics();
 return;
 }
 return;
 }
 }

 if(platformerMode && !typingElement && !directOpen){
 if(handlePlatformerKey(e.key, true)){
 console.log(`[PLATFORMER] Key ${e.key} handled by platformer (mode active), returning early`);
 refreshPlatformerInput(s.globalState);
 e.preventDefault();
 return;
 }
 } else if(!platformerMode && ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)){
 // Don't let platformer handler intercept arrow keys when platformer is NOT active
 console.log(`[ARROW] Arrow key ${e.key} NOT handled by platformer (mode inactive), continuing to navigation`);
 }

 // Universal input: Enter always opens the editor. If no selection, select a default cell first.
 if(e.key==='Enter' && !platformerMode && !typingElement && !directOpen){
 e.preventDefault();
 const state=Store.getState();
 const sel=state.selection;
 if(sel?.focus){ UI.openEditor(); return; }
 const fallbackArr = state.arrays[1] || Object.values(state.arrays)[0];
 if(fallbackArr){
 Actions.setSelection(fallbackArr.id,{x:0,y:0,z:0}, null, '2d');
 setTimeout(()=> UI.openEditor(), 0);
 }
 return;
 }
 // Undo/Redo shortcuts
 if(e.ctrlKey || e.metaKey){
 if(e.key==='z'){
 if(e.shiftKey){ e.preventDefault(); Actions.redoData(); return; }
 else { e.preventDefault(); Actions.undoData(); return; }
 }
 if(e.key==='y'){ e.preventDefault(); Actions.redoData(); return; }
 }
 if(e.altKey && e.key==='z'){
 if(e.shiftKey){ e.preventDefault(); Actions.redoUI(); return; }
 else { e.preventDefault(); Actions.undoUI(); return; }
 }

 // Backspace: clear cell and enter input mode
 if(e.key==='Backspace' && !platformerMode && !typingElement && !directOpen && s.selection?.focus){
 e.preventDefault();
 const sel = s.selection;
 const anchor = {arrId: sel.arrayId, ...sel.focus};
 Actions.setCell(sel.arrayId, sel.focus, '', null, true);
 // Do not open the inline editor on backspace; just clear
 return;
 }

 // Arrow keys for cell navigation when not in physics/platformer mode
 const isArrowKey = ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key);
 
 if(isArrowKey){
 console.log(`[ARROW] ? Reached arrow key check for: ${e.key}`);
 console.log(`[ARROW] Conditions: platformerMode=${platformerMode}, physicsActive=${physicsActive}, typingElement=${typingElement}, directOpen=${directOpen}`);
 
 // If conditions are blocking, show why
 if(platformerMode || physicsActive || typingElement || directOpen){
 console.warn(`[ARROW] ?? Arrow keys blocked by: ${platformerMode?'platformerMode ':''}${physicsActive?'physicsActive ':''}${typingElement?'typingElement ':''}${directOpen?'directOpen':''}`);
 }
 }
 
 if(isArrowKey && !platformerMode && !physicsActive && !typingElement && !directOpen){
 console.log(`[ARROW] ? Entering arrow key handler for ${e.key}`);
 // Ensure we have a selection; default to Array 1 A1a if none
 let sel=s.selection;
 if(!sel.focus){
 const fallbackArr = s.arrays[1] || Object.values(s.arrays)[0];
 if(fallbackArr){ Actions.setSelection(fallbackArr.id, {x:0,y:0,z:0}, null, '2d'); sel = Store.getState().selection; }
 }
 if(!sel.focus) return; const arr=s.arrays[sel.arrayId]; if(!arr) return;
 if(e.shiftKey){
 // Shift+Arrows: extend selection range
 if(e.key==='ArrowUp') Actions.moveSelection(0,1,0);
 if(e.key==='ArrowDown') Actions.moveSelection(0,-1,0);
 if(e.key==='ArrowLeft') Actions.moveSelection(1,0,0);
 if(e.key==='ArrowRight') Actions.moveSelection(-1,0,0);
 e.preventDefault(); 
 UI.scrollSheetToSelection?.();
 } else {
 // View-relative movement calculation based on camera facing
 let dx = 0, dy = 0, dz = 0;
 const depthMode = !!Store.getState().scene.arrowMapDepth;
 
 // Get the camera-relative facing direction - compute it fresh each time
 let facing = { axis: 2, sign: 1 }; // default: looking at Z+ face
 try {
 if (arr._frame && Scene.facingFromCamera) {
 facing = Scene.facingFromCamera(arr._frame);
 console.log(`[ARROW] Facing: axis=${facing.axis} (${['X','Y','Z'][facing.axis]}), sign=${facing.sign}, depthMode=${depthMode}`);
 }
 } catch (err) {
 console.warn('[ARROW] Failed to get facing:', err);
 }
 
 const axis = facing.axis; // 0=X, 1=Y, 2=Z
 const sign = facing.sign; // 1=positive, -1=negative
 
 // Map arrow keys to movement based on which face we're looking at
 if (axis === 2) { // Looking at Z face (front/back)
 if (e.key === 'ArrowUp') {
 if (depthMode) dz = -sign;
 else dy = -1; // Fixed: inverted up/down
 } else if (e.key === 'ArrowDown') {
 if (depthMode) dz = sign;
 else dy = 1; // Fixed: inverted up/down
 } else if (e.key === 'ArrowLeft') {
 dx = -sign; // Fixed: inverted left/right for front/back view
 } else if (e.key === 'ArrowRight') {
 dx = sign; // Fixed: inverted left/right for front/back view
 }
 } else if (axis === 0) { // Looking at X face (left/right side)
 if (e.key === 'ArrowUp') {
 if (depthMode) dx = -sign;
 else dy = -1; // Fixed: inverted up/down
 } else if (e.key === 'ArrowDown') {
 if (depthMode) dx = sign;
 else dy = 1; // Fixed: inverted up/down
 } else if (e.key === 'ArrowLeft') {
 dz = -sign;
 } else if (e.key === 'ArrowRight') {
 dz = sign;
 }
 } else { // axis === 1, Looking at Y face (top/bottom)
 if (e.key === 'ArrowUp') {
 if (depthMode) dy = -sign;
 else dz = -1;
 } else if (e.key === 'ArrowDown') {
 if (depthMode) dy = sign;
 else dz = 1;
 } else if (e.key === 'ArrowLeft') {
 dx = -sign; // Fixed: inverted left/right for top/bottom view
 } else if (e.key === 'ArrowRight') {
 dx = sign; // Fixed: inverted left/right for top/bottom view
 }
 }
 
 console.log(`[ARROW] Key=${e.key}, axis=${axis}, sign=${sign} -> dx=${dx}, dy=${dy}, dz=${dz}`);
 
 if(dx || dy || dz){
 e.preventDefault();
 let {x,y,z} = sel.focus;
 x = Math.max(0, Math.min(arr.size.x-1, x + dx));
 y = Math.max(0, Math.min(arr.size.y-1, y + dy));
 z = Math.max(0, Math.min(arr.size.z-1, z + dz));
 Actions.setSelection(sel.arrayId,{x,y,z});
 UI.scrollSheetToSelection?.();
 }
 }
 return;
 }


 // Realtime typing: printable char when a cell is focused starts editor with that char
 if(s.selection?.focus && e.key.length===1 && !e.ctrlKey && !e.metaKey && !e.altKey && !platformerMode && !typingElement && !directOpen){
 e.preventDefault(); UI.startDirectTyping(e.key); return;
 }
 }, true);
 window.addEventListener('keyup',(e)=>{
 const s=Store.getState();
 const platformerMode = isPlatformerActive(s.globalState);
 const platformerHandled = handlePlatformerKey(e.key, false);
 if(platformerHandled && platformerMode){
 refreshPlatformerInput(s.globalState);
 }
 if(s.scene.physics){
 if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' ','Spacebar','w','a','s','d','W','A','S','D'].includes(e.key)){
 e.preventDefault();
 if(e.key==='ArrowUp'||e.key==='w'||e.key==='W') input.f=0;
 if(e.key==='ArrowDown'||e.key==='s'||e.key==='S') input.b=0;
 if(e.key==='ArrowLeft'||e.key==='a'||e.key==='A') input.l=0;
 if(e.key==='ArrowRight'||e.key==='d'||e.key==='D') input.r=0;
 if(e.key===' '||e.key==='Spacebar') input.j=0; 
 return;
 }
 }
 if(platformerHandled && platformerMode){
 e.preventDefault();
 return;
 }
 if(e.key==='ArrowUp'||e.key==='w'||e.key==='W') input.f=0; if(e.key==='ArrowDown'||e.key==='s'||e.key==='S') input.b=0; if(e.key==='ArrowLeft'||e.key==='a'||e.key==='A') input.l=0; if(e.key==='ArrowRight'||e.key==='d'||e.key==='D') input.r=0; if(e.key===' '||e.key==='Spacebar') input.j=0; 
 },true);
 const highlights=new Map(); // anchor -> {mode, mesh}
 function setHighlightMode(arr,anchor,config){
 const k=aKey(anchor); 
 const {mode='dynamic',scope='cell',style='wireframe'} = typeof config==='string'?{mode:config}:config;
 highlights.set(k,{mode,scope,style,anchor});
 
 // create highlight mesh based on scope and style
 let geo, mat;
 if(scope==='face'){
 geo = new THREE.PlaneGeometry(1.1,1.1); 
 mat = new THREE.MeshBasicMaterial({color:0x22c55e,transparent:true,opacity:0.6,side:THREE.DoubleSide});
 } else {
 geo = new THREE.BoxGeometry(1.1,1.1,1.1);
 mat = new THREE.MeshBasicMaterial({
 color:0x22c55e,transparent:true,opacity:0.3,
 wireframe:style==='wireframe'
 });
 }
 const mesh=new THREE.Mesh(geo,mat); 
 mesh.position.copy(worldPos(arr,anchor.x,anchor.y,anchor.z)); 
 scene.add(mesh);
 highlights.get(k).mesh=mesh;
 }

 function setCameraLock(arr,config){
 arr.cameraLock = config;
 // Implementation would constrain orbit controls based on axis/angle
 }
 function setViewMode(arr,config){
 arr.viewMode = config;
 // Implementation would switch between perspective/orthographic cameras
 }

 // Lightweight AvatarFactory for modular characters
 const AvatarFactory = {
 createCelli(THREE){
 const MAT_BODY = new THREE.MeshToonMaterial({ color: 0xf59e0b });
 const MAT_DARK = new THREE.MeshToonMaterial({ color: 0x1f2937 }); // Gray-800 (darker gray, matching Border Celli)
 const MAT_BLUSH = new THREE.MeshToonMaterial({ color: 0xec4899 });
 const MAT_WING = new THREE.MeshToonMaterial({ color: 0xf59e0b, side: THREE.DoubleSide });

 function addOutline(child, scale=1.06){
 const outlineMat = new THREE.MeshBasicMaterial({ color: MAT_DARK.color.getHex(), side: THREE.BackSide });
 const outline = new THREE.Mesh(child.geometry, outlineMat);
 outline.scale.setScalar(scale);
 outline.userData.isAvatarOutline = true;
 outline.renderOrder = 10499;
 child.add(outline);
 return outline;
 }

 function triWing(width=0.22, height=0.16, depth=0.02){
 const shape = new THREE.Shape();
 shape.moveTo(width/2, 0);
 shape.lineTo(-width/2, height/2);
 shape.lineTo(-width/2, -height/2);
 shape.lineTo(width/2, 0);
 const geo = new THREE.ExtrudeGeometry(shape, { depth, bevelEnabled:false });
 geo.center();
 geo.computeVertexNormals();
 return geo;
 }

 const root = new THREE.Group();
 root.scale.setScalar(0.40);

 const BW=.8, BH=.8, BD=.3;
 const bodyGroup = new THREE.Group();
 const body = new THREE.Mesh(new RoundedBoxGeometry(BW, BH, BD, 6, .12), MAT_BODY);
 addOutline(body);
 bodyGroup.add(body);
 bodyGroup.position.y = BH/2;

 const faceGroup = new THREE.Group();
 const faceZ = BD/2 + 0.01;
 const eyeGeo = new THREE.SphereGeometry(0.05, 16, 12);
 const eyeL = new THREE.Mesh(eyeGeo, MAT_DARK); addOutline(eyeL); eyeL.scale.set(1, 2, .25); eyeL.position.set(-.12,.13,faceZ);
 const eyeR = new THREE.Mesh(eyeGeo, MAT_DARK); addOutline(eyeR); eyeR.scale.set(1, 2, .25); eyeR.position.set(.12,.13,faceZ);
 const blushGeo = new THREE.SphereGeometry(0.05, 16, 12);
 const cheekL = new THREE.Mesh(blushGeo, MAT_BLUSH); addOutline(cheekL); cheekL.scale.set(1.2,1,.2); cheekL.position.set(-.25,-.08,faceZ);
 const cheekR = new THREE.Mesh(blushGeo, MAT_BLUSH); addOutline(cheekR); cheekR.scale.set(1.2,1,.2); cheekR.position.set(.25,-.08,faceZ);
 const smileShape = new THREE.Shape();
 smileShape.moveTo(-0.12, -0.06);
 smileShape.quadraticCurveTo(0, -0.25, 0.12, -0.06);
 smileShape.quadraticCurveTo(0, -0.20, -0.12, -0.06);
 const smile = new THREE.Mesh(new THREE.ShapeGeometry(smileShape), MAT_DARK); addOutline(smile);
 smile.position.z = faceZ;
 faceGroup.add(eyeL, eyeR, cheekL, cheekR, smile);
 bodyGroup.add(faceGroup);

 const bowGroup = new THREE.Group();
 // Updated bow geometry to match Border Celli - larger, more rounded wings
 const wingL = new THREE.Mesh(triWing(), MAT_WING); addOutline(wingL);
 const wingR = new THREE.Mesh(triWing(), MAT_WING); addOutline(wingR);
 wingL.rotation.y = 0;
 wingR.rotation.y = Math.PI;
 wingL.position.set(-0.18, 0, 0);
 wingR.position.set(0.18, 0, 0);
 wingL.scale.set(1.3, 1.3, 1.0); // Make wings larger and more prominent
 wingR.scale.set(1.3, 1.3, 1.0);
 const knot = new THREE.Mesh(new THREE.SphereGeometry(0.04, 16, 12), MAT_BODY); addOutline(knot); // Rounded knot instead of box
 knot.scale.set(1.5, 1.5, 1.5);
 bowGroup.add(wingL, wingR, knot);
 bowGroup.position.set(0, BH + 0.15, 0);

 const armRadius = .055;
 const handGeo = new THREE.SphereGeometry(armRadius, 16, 12);
 const shoulderX = BW * 0.38;
 const shoulderY = BH * 0.52;
 const shoulderZ = BD * 0.5 - armRadius * 0.4;
 const armTilt = THREE.MathUtils.degToRad(-8);
 const armSweep = THREE.MathUtils.degToRad(26);
 const armTuck = THREE.MathUtils.degToRad(-4);
 function makeArm(sign=1){
 const armRoot = new THREE.Group();
 const armCurve = new THREE.QuadraticBezierCurve3(
 new THREE.Vector3(0, -0.015, 0.02),
 new THREE.Vector3(0.12 * sign, -0.16, 0.05),
 new THREE.Vector3(0.16 * sign, -0.28, 0.015)
 );
 const armGeo = new THREE.TubeGeometry(armCurve, 28, armRadius, 12, false);
 const upper = new THREE.Mesh(armGeo, MAT_BODY); addOutline(upper, 1.04);
 const handGroup = new THREE.Group();
 const hand = new THREE.Mesh(handGeo, MAT_BODY); addOutline(hand, 1.04);
 hand.position.copy(armCurve.getPoint(1));
 handGroup.position.add(new THREE.Vector3(sign * 0.012, -0.008, 0.01));
 handGroup.add(hand);
 armRoot.add(upper, handGroup);
 armRoot.position.set(sign * (shoulderX + armRadius * 0.6), shoulderY - 0.02, shoulderZ * 0.4);
 armRoot.rotation.set(armTilt, sign * armSweep, sign * armTuck);
 return { armRoot, handGroup };
 }
 const L = makeArm(-1), R = makeArm(+1);

 const legRadius = .06;
 const legCurve = new THREE.CatmullRomCurve3([
 new THREE.Vector3(0,0,0), new THREE.Vector3(0,-.10,.022), new THREE.Vector3(0,-.17,.036)
 ]);
 const legGeo = new THREE.TubeGeometry(legCurve, 12, legRadius, 12, false);
 const footGeo = new THREE.SphereGeometry(legRadius, 16, 12);
 function makeLeg(x){
 const legRoot = new THREE.Group();
 const leg = new THREE.Mesh(legGeo, MAT_BODY); addOutline(leg, 1.04);
 const footGroup = new THREE.Group();
 const foot = new THREE.Mesh(footGeo, MAT_BODY); addOutline(foot, 1.04);
 foot.position.copy(legCurve.getPoint(1));
 foot.scale.set(1.5,.8,1.2);
 footGroup.add(foot);
 legRoot.add(leg, footGroup);
 legRoot.position.set(x, 0, 0);
 return { legRoot, footGroup };
 }
 const legL = makeLeg(-.20), legR = makeLeg(.20);
 legR.legRoot.position.set(Math.abs(legL.legRoot.position.x), legL.legRoot.position.y, legL.legRoot.position.z);

 root.add(bodyGroup, bowGroup, L.armRoot, R.armRoot, legL.legRoot, legR.legRoot);

 const BASE_RENDER_ORDER = 10500;
 
 // Function to update render order based on graphics settings
 root.userData.updateRenderOrder = function() {
 const hasFrostedGlass = FancyGraphics?.enabled && FancyGraphics?.settings?.transmission;
 const baseOrder = hasFrostedGlass ? BASE_RENDER_ORDER : (BASE_RENDER_ORDER + 1000); // Higher when not frosted
 root.traverse(obj=>{
 if(!obj.isMesh) return;
 const isOutline = !!obj.userData?.isAvatarOutline;
 const isBowPart = (obj.parent === bowGroup || obj.parent?.parent === bowGroup);
 // Bow parts render above cells, body parts at base (or elevated if no frosted glass)
 obj.renderOrder = isOutline ? (baseOrder - 1) : (isBowPart ? baseOrder + 50 : baseOrder);
 });
 };
 
 root.traverse(obj=>{
 if(!obj.isMesh) return;
 const isOutline = !!obj.userData?.isAvatarOutline;
 if(obj.material){
 obj.material.depthTest = true;
 obj.material.depthWrite = !isOutline;
 obj.material.toneMapped = false;
 if(isOutline){
 obj.material.transparent = true;
 obj.material.opacity = 1;
 obj.material.polygonOffset = true;
 obj.material.polygonOffsetFactor = -1;
 obj.material.polygonOffsetUnits = -1;
 } else if(obj.material.polygonOffset){
 obj.material.polygonOffset = false;
 }
 }
 });
 
 // Set initial render order
 root.userData.updateRenderOrder();

 root.userData.components = [
 {name:'Body', group: bodyGroup},
 {name:'Face', group: faceGroup},
 {name:'Eye L', group: eyeL},
 {name:'Eye R', group: eyeR},
 {name:'Cheek L', group: cheekL},
 {name:'Cheek R', group: cheekR},
 {name:'Bow', group: bowGroup},
 {name:'Bow / Left', group: wingL},
 {name:'Bow / Right', group: wingR},
 {name:'Bow / Center', group: knot},
 {name:'Arm L', group: L.armRoot},
 {name:'Arm L / Hand', group: L.handGroup},
 {name:'Arm R', group: R.armRoot},
 {name:'Arm R / Hand', group: R.handGroup},
 {name:'Leg L', group: legL.legRoot},
 {name:'Leg L / Foot', group: legL.legRoot.children[1]},
 {name:'Leg R', group: legR.legRoot},
 {name:'Leg R / Foot', group: legR.legRoot.children[1]},
 ];

 root.userData.bodyGroup = bodyGroup;
 return root;
 }
 };

 const ARRAYA_BASE_SCALE = 0.28;

 const ArrayaAvatarFactory = (function(){
 function push(arr, ...v){ for(const x of v) arr.push(x); }

 function roundedBoxGeometry(w, h, d, seg=6, round=0.45){
 const hw=w/2, hh=h/2, hd=d/2;
 const positions=[]; const indices=[];
 function face(uSeg,vSeg, constX,constY,constZ, ux,uy,uz, vx,vy,vz, flip){
 const base = positions.length/3;
 for(let j=0;j<=vSeg;j++){
 for(let i=0;i<=uSeg;i++){
 const u=i/uSeg, v=j/vSeg;
 const x = constX + ux*(u-0.5) + vx*(v-0.5);
 const y = constY + uy*(u-0.5) + vy*(v-0.5);
 const z = constZ + uz*(u-0.5) + vz*(v-0.5);
 push(positions, x,y,z);
 }
 }
 for(let j=0;j<vSeg;j++){
 for(let i=0;i<uSeg;i++){
 const a = base + i + (uSeg+1)*j;
 const b = base + i+1 + (uSeg+1)*j;
 const c = base + i + (uSeg+1)*(j+1);
 const d = base + i+1 + (uSeg+1)*(j+1);
 if (!flip) { push(indices, a,c,b, b,c,d); } else { push(indices, a,b,c, b,d,c); }
 }
 }
 }
 const sx=seg, sy=seg, sz=seg;
 face(sx,sy, 0,0, hd, w,0,0, 0,h,0, false);
 face(sx,sy, 0,0,-hd, w,0,0, 0,h,0, true);
 face(sz,sy, hw,0,0, 0,0,d, 0,h,0, false);
 face(sz,sy,-hw,0,0, 0,0,d, 0,h,0, true);
 face(sx,sz, 0,hh,0, w,0,0, 0,0,d, true);
 face(sx,sz, 0,-hh,0, w,0,0, 0,0,d, false);

 for(let i=0;i<positions.length;i+=3){
 let x=positions[i]/hw, y=positions[i+1]/hh, z=positions[i+2]/hd;
 const x2=x*x,y2=y*y,z2=z*z;
 const sx=x*Math.sqrt(Math.max(0.0,1.0-0.5*(y2+z2)+(y2*z2)/3.0));
 const sy=y*Math.sqrt(Math.max(0.0,1.0-0.5*(z2+x2)+(z2*x2)/3.0));
 const sz=z*Math.sqrt(Math.max(0.0,1.0-0.5*(x2+y2)+(x2*y2)/3.0));
 x = x*(1.0-round) + sx*round;
 y = y*(1.0-round) + sy*round;
 z = z*(1.0-round) + sz*round;
 positions[i]=x*hw; positions[i+1]=y*hh; positions[i+2]=z*hd;
 }
 return { positions:new Float32Array(positions), indices:new Uint32Array(indices) };
 }

 function cylinderGeometry(r=0.07,h=0.06, seg=24){
 const pos=[], nor=[], idx=[]; const half=h/2;
 for(let i=0;i<=seg;i++){
 const a=i/seg*2*Math.PI; const x=Math.cos(a), y=Math.sin(a);
 push(pos, r*x, r*y, -half, r*x, r*y, half);
 push(nor, x,y,0, x,y,0);
 }
 for(let i=0;i<seg;i++){
 const a=i*2, b=a+1, c=a+2, d=a+3;
 push(idx, a,c,b, b,c,d);
 }
 const base = pos.length/3;
 for(let j=0;j<2;j++){
 const z = j? half : -half; const nz = j? 1:-1; const centerIndex = pos.length/3; push(pos,0,0,z); push(nor,0,0,nz);
 for(let i=0;i<=seg;i++){ const a=i/seg*2*Math.PI; const x=Math.cos(a), y=Math.sin(a); push(pos,r*x,r*y,z); push(nor,0,0,nz); }
 for(let i=0;i<seg;i++){ const ci=centerIndex, vi=centerIndex+1+i; if(j){ push(idx, ci, vi, vi+1);} else { push(idx, ci, vi+1, vi);} }
 }
 return { positions:new Float32Array(pos), normals:new Float32Array(nor), indices:new Uint16Array(idx) };
 }

 function torusGeometry(R=0.18, r=0.028, arc=Math.PI, segU=56, segV=16, endSmooth=0.25, endMin=0.55){
 const pos=[], nor=[], idx=[];
 const sstep = (x)=> x<=0?0 : x>=1?1 : x*x*(3-2*x);
 for(let j=0;j<=segV;j++){
 const v=j/segV*2*Math.PI; const cv=Math.cos(v), sv=Math.sin(v);
 for(let i=0;i<=segU;i++){
 const t=i/segU;
 const u=t*arc - arc;
 const cu=Math.cos(u), su=Math.sin(u);
 let w=1.0;
 if(endSmooth>0){
 const edge = Math.min(t/endSmooth, (1.0 - t)/endSmooth);
 const k = sstep(Math.max(0, Math.min(1, edge)));
 w = endMin + (1.0 - endMin) * k;
 }
 const re = r * w;
 const cx = R * cu, cy = R * su;
 const x=(R + re*cv)*cu;
 const y=(R + re*cv)*su;
 const z=re*sv;
 push(pos, x,y,z);
 let nx = x - cx, ny = y - cy, nz = z;
 const len = Math.hypot(nx,ny,nz) || 1.0;
 nx/=len; ny/=len; nz/=len;
 push(nor, nx,ny,nz);
 }
 }
 for(let j=0;j<segV;j++){
 for(let i=0;i<segU;i++){
 const a=i + (segU+1)*j;
 const b=i+1 + (segU+1)*j;
 const c=i + (segU+1)*(j+1);
 const d=i+1 + (segU+1)*(j+1);
 push(idx, a,c,b, b,c,d);
 }
 }
 return { positions:new Float32Array(pos), normals:new Float32Array(nor), indices:new Uint32Array(idx) };
 }

 function computeNormals(positions, indices, out){
 out.fill(0);
 for(let i=0;i<indices.length;i+=3){
 const ia=indices[i]*3, ib=indices[i+1]*3, ic=indices[i+2]*3;
 const ax=positions[ia], ay=positions[ia+1], az=positions[ia+2];
 const bx=positions[ib], by=positions[ib+1], bz=positions[ib+2];
 const cx=positions[ic], cy=positions[ic+1], cz=positions[ic+2];
 const abx=bx-ax, aby=by-ay, abz=bz-az;
 const acx=cx-ax, acy=cy-ay, acz=cz-az;
 let nx=aby*acz-abz*acy, ny=abz*acx-abx*acz, nz=abx*acy-aby*acx;
 const inv=1/Math.hypot(nx,ny,nz);
 nx*=inv; ny*=inv; nz*=inv;
 out[ia]+=nx; out[ia+1]+=ny; out[ia+2]+=nz;
 out[ib]+=nx; out[ib+1]+=ny; out[ib+2]+=nz;
 out[ic]+=nx; out[ic+1]+=ny; out[ic+2]+=nz;
 }
 for(let i=0;i<out.length;i+=3){
 const inv=1/Math.hypot(out[i],out[i+1],out[i+2]);
 out[i]*=inv; out[i+1]*=inv; out[i+2]*=inv;
 }
 return out;
 }

 const W=1.45, H=1.1, D=1.2;
 const cubeBase = roundedBoxGeometry(W,H,D,8,0.45);
 const eyeBase = cylinderGeometry(0.085, 0.06, 24);
 const smileBase = torusGeometry(0.18, 0.028, Math.PI, 56, 16, 0.35, 0.70);
 const greensRaw = [
 [0.75,0.94,0.42],
 [0.65,0.88,0.36],
 [0.55,0.83,0.32],
 [0.46,0.78,0.27],
 [0.36,0.71,0.23],
 [0.29,0.65,0.20]
 ];

 const JOIN_EPS = 0.05;
 const HEAD_BULGE = 0.12;
 const TAIL_BULGE = 0.08;
 const HEAD_FACE_EXPAND = 0.10;
 const GLOBAL_ROT_X = Math.PI/2;
 const GLOBAL_ROT_Z = -Math.PI/2;
 const NSEG = 6;
 const segLen = D;
 const L = NSEG * segLen;
 const thetaAmp = 0.70;
 const yAmp = 0.0;
 const ds = Math.max(0.01, L/320);

 function cross(a,b){ return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]; }
 function normalize(v){ const l=Math.hypot(v[0],v[1],v[2]); return l? [v[0]/l,v[1]/l,v[2]/l] : [0,1,0]; }
 function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
 function smoothstep(a,b,x){ const t = clamp((x-a)/(b-a),0,1); return t*t*(3-2*t); }
 function rotX(v,a){ const c=Math.cos(a), s=Math.sin(a); return [ v[0], v[1]*c - v[2]*s, v[1]*s + v[2]*c ]; }
 function rotZ(v,a){ const c=Math.cos(a), s=Math.sin(a); return [ v[0]*c - v[1]*s, v[0]*s + v[1]*c, v[2] ]; }

 let samples=[];
 (function rebuildCurve(){
 samples=[];
 let p=[0, H/2, 0];
 let tan=[0,0,1];
 samples.push({ s:0, p:p.slice(), t:tan.slice() });
 for(let s=ds; s<=L+1e-6; s+=ds){
 const theta = thetaAmp * Math.sin(2*Math.PI * (s/L));
 const dy_ds = yAmp * (Math.PI / L) * Math.cos(Math.PI * s / L);
 tan = normalize([ Math.sin(theta), dy_ds, Math.cos(theta) ]);
 p = [ p[0] + tan[0]*ds, p[1] + tan[1]*ds, p[2] + tan[2]*ds ];
 samples.push({ s: Math.min(s,L), p:p.slice(), t:tan.slice() });
 }
 })();

 function sampleFrameAt(s){
 if (s <= 0){
 const t0 = samples[0].t; const up=[0,1,0];
 let side = cross(up, t0); let Ls=Math.hypot(side[0],side[1],side[2]);
 if (Ls<1e-6) side=[1,0,0], Ls=1; side=[side[0]/Ls, side[1]/Ls, side[2]/Ls];
 const up2 = cross(t0, side);
 return { p: samples[0].p.slice(), t: t0.slice(), side, up: up2 };
 }
 if (s >= L){
 const last = samples[samples.length-1]; const up=[0,1,0];
 let side = cross(up, last.t); let Ls=Math.hypot(side[0],side[1],side[2]);
 if (Ls<1e-6) side=[1,0,0], Ls=1; side=[side[0]/Ls, side[1]/Ls, side[2]/Ls];
 const up2 = cross(last.t, side);
 return { p: last.p.slice(), t: last.t.slice(), side, up: up2 };
 }
 const i = Math.min(samples.length-2, Math.max(0, Math.floor(s/ds)));
 const a = samples[i], b = samples[i+1];
 const tt = (s - a.s) / (b.s - a.s);
 const lerp = (x,y)=> x + (y-x)*tt;
 const p=[ lerp(a.p[0],b.p[0]), lerp(a.p[1],b.p[1]), lerp(a.p[2],b.p[2]) ];
 let tan=[ lerp(a.t[0],b.t[0]), lerp(a.t[1],b.t[1]), lerp(a.t[2],b.t[2]) ];
 tan = normalize(tan);
 const up=[0,1,0];
 let side=cross(up, tan); let Ls=Math.hypot(side[0],side[1],side[2]);
 if (Ls<1e-6) side=[1,0,0], Ls=1; side=[side[0]/Ls, side[1]/Ls, side[2]/Ls];
 const up2 = cross(tan, side);
 return { p, t:tan, side, up: up2 };
 }

 function rotateFrame(F){
 const pX = rotX(F.p, GLOBAL_ROT_X); const tX = rotX(F.t, GLOBAL_ROT_X);
 const sX = rotX(F.side, GLOBAL_ROT_X); const uX = rotX(F.up, GLOBAL_ROT_X);
 return { p: rotZ(pX, GLOBAL_ROT_Z), t: rotZ(tX, GLOBAL_ROT_Z), side: rotZ(sX, GLOBAL_ROT_Z), up: rotZ(uX, GLOBAL_ROT_Z) };
 }

 function toVector3(arr){ return new THREE.Vector3(arr[0], arr[1], arr[2]); }

 function projectUp(N){
 const U=[0,1,0];
 const dot = U[0]*N[0]+U[1]*N[1]+U[2]*N[2];
 let up=[ U[0]-dot*N[0], U[1]-dot*N[1], U[2]-dot*N[2] ];
 let L = Math.hypot(up[0],up[1],up[2]);
 if (L < 1e-4){
 const WR=[1,0,0];
 const dot2 = WR[0]*N[0]+WR[1]*N[1]+WR[2]*N[2];
 up=[ WR[0]-dot2*N[0], WR[1]-dot2*N[1], WR[2]-dot2*N[2] ];
 L = Math.hypot(up[0],up[1],up[2]);
 }
 return [up[0]/L, up[1]/L, up[2]/L];
 }

 function create(THREE){
 const group = new THREE.Group();
 group.name = 'ArrayaAvatar';
 group.scale.setScalar(ARRAYA_BASE_SCALE); // Smaller than Celli
 const greens = greensRaw.map(rgb=> new THREE.Color(rgb[0], rgb[1], rgb[2]));
 const segments=[];
 const darkGray = new THREE.Color(0x1f2937); // Gray-800 (matching single-select Celli)
 for(let i=0;i<NSEG;i++){
 const geometry = new THREE.BufferGeometry();
 const posArray = new Float32Array(cubeBase.positions.length);
 const norArray = new Float32Array(cubeBase.positions.length);
 geometry.setAttribute('position', new THREE.BufferAttribute(posArray,3));
 geometry.setAttribute('normal', new THREE.BufferAttribute(norArray,3));
 const IndexType = cubeBase.indices.constructor;
 const indexCopy = new IndexType(cubeBase.indices);
 geometry.setIndex(new THREE.BufferAttribute(indexCopy, 1));
 // Use MeshStandardMaterial for dynamic lighting support in present mode
 const mat = new THREE.MeshStandardMaterial({ color: greens[i], side: THREE.DoubleSide, roughness: 0.7, metalness: 0.1 });
 mat.depthTest = true; mat.depthWrite = true; mat.toneMapped = false;
 const mesh = new THREE.Mesh(geometry, mat);
 mesh.castShadow = false; mesh.receiveShadow = false;
 mesh.renderOrder = 50; // Body segments render before faces (50 < 100)
 
 // Add thin shell to each segment for consistency with cells
 const shellGeometry = new THREE.BufferGeometry();
 const shellPosArray = new Float32Array(cubeBase.positions.length);
 const shellNorArray = new Float32Array(cubeBase.positions.length);
 shellGeometry.setAttribute('position', new THREE.BufferAttribute(shellPosArray,3));
 shellGeometry.setAttribute('normal', new THREE.BufferAttribute(shellNorArray,3));
 const shellIndexCopy = new IndexType(cubeBase.indices);
 shellGeometry.setIndex(new THREE.BufferAttribute(shellIndexCopy, 1));
 const shellMat = new THREE.MeshStandardMaterial({ color: darkGray, side: THREE.BackSide, roughness: 0.8, metalness: 0.05 });
 shellMat.depthTest = true; shellMat.depthWrite = false; // Don't write depth so it renders behind
 shellMat.toneMapped = false;
 const shellMesh = new THREE.Mesh(shellGeometry, shellMat);
 shellMesh.castShadow = false; shellMesh.receiveShadow = false;
 shellMesh.renderOrder = 40; // Shell renders behind body (40 < 50)
 shellMesh.scale.setScalar(1.06); // Slightly larger than body
 mesh.add(shellMesh); // Parent to body segment so it follows
 
 group.add(mesh);
 segments.push({ mesh, posArray, norArray, geometry, shellMesh, shellPosArray, shellNorArray, shellGeometry });
 }

 function buildStaticGeometry(base){
 const geometry = new THREE.BufferGeometry();
 geometry.setAttribute('position', new THREE.BufferAttribute(base.positions.slice(),3));
 if(base.normals){ geometry.setAttribute('normal', new THREE.BufferAttribute(base.normals.slice(),3)); }
 if(base.indices && base.indices.length > 0){ 
 // Create a new TypedArray of the same type as the original
 const IndexType = base.indices.constructor;
 const indexCopy = new IndexType(base.indices);
 geometry.setIndex(new THREE.BufferAttribute(indexCopy, 1));
 }
 return geometry;
 }

 const eyeGeo = buildStaticGeometry(eyeBase);
 if(!eyeBase.normals){
 const normals = new Float32Array(eyeBase.positions.length);
 computeNormals(eyeBase.positions, eyeBase.indices, normals);
 eyeGeo.attributes.normal.array.set(normals);
 }
 const smileGeo = buildStaticGeometry(smileBase);
 if(!smileBase.normals){
 const normals = new Float32Array(smileBase.positions.length);
 computeNormals(smileBase.positions, smileBase.indices, normals);
 smileGeo.attributes.normal.array.set(normals);
 }

 // Use MeshStandardMaterial for dynamic lighting support in present mode
 const featureMat = new THREE.MeshStandardMaterial({ roughness: 0.7, metalness: 0.1, 
 color: new THREE.Color(0.06,0.07,0.07), 
 side: THREE.FrontSide // Only visible from front
 });
 featureMat.depthTest = true; 
 featureMat.depthWrite = true; 
 featureMat.toneMapped = false;
 featureMat.colorWrite = true; // Ensure they render
 const eyeL = new THREE.Mesh(eyeGeo, featureMat.clone());
 const eyeR = new THREE.Mesh(eyeGeo, featureMat.clone());
 const smileMat = featureMat.clone();
 smileMat.side = THREE.DoubleSide;
 smileMat.needsUpdate = true;
 const smile = new THREE.Mesh(smileGeo, smileMat);
 eyeL.castShadow = eyeR.castShadow = smile.castShadow = false;
 eyeL.receiveShadow = eyeR.receiveShadow = smile.receiveShadow = false;
 // Set render order so faces render on top of body segments
 eyeL.renderOrder = 100;
 eyeR.renderOrder = 100;
 smile.renderOrder = 100;
 // Frustum culling enabled so back faces are culled properly
 eyeL.frustumCulled = false;
 eyeR.frustumCulled = false;
 smile.frustumCulled = false;
 group.add(eyeL, eyeR, smile);

 const MAT_OUTLINE = new THREE.MeshBasicMaterial({ color: 0x1f2937 }); // Gray-800 (matching single-select Celli)
 MAT_OUTLINE.depthTest = true;
 MAT_OUTLINE.depthWrite = false;
 MAT_OUTLINE.toneMapped = false;
 MAT_OUTLINE.transparent = false; // Make opaque for cleaner rendering
 const outlineScale = 1.08;
 const baseMeshes = [];
 group.traverse(n=>{ if(n.isMesh && !n.userData.isAvatarOutline) baseMeshes.push(n); });
 baseMeshes.forEach(mesh=>{
 const outline = new THREE.Mesh(mesh.geometry, MAT_OUTLINE);
 outline.name = `${mesh.name||'part'}_outline`;
 outline.userData.isAvatarOutline = true;
 outline.scale.set(outlineScale, outlineScale, outlineScale);
 outline.position.set(0,0,0);
 outline.castShadow = false;
 outline.receiveShadow = false;
 // Ensure outline renders well behind the base geometry
 outline.renderOrder = Math.max(0, (mesh.renderOrder ?? 50) - 10);
 mesh.add(outline);
 });

 const hd = D/2;
 const pivotVec = new THREE.Vector3();
 const sFace = 0.006;

 const aggregateBox = new THREE.Box3();
 const partBox = new THREE.Box3();
 const partCenter = new THREE.Vector3();

 const controller = {
 group,
 visible:false,
 needsUpdate:true,
 headOffset:new THREE.Vector3(),
 centerOffset:new THREE.Vector3(),
 setVisible(v){
 if(this.visible !== v){
 this.visible = v;
 group.visible = v;
 if(v) this.needsUpdate = true;
 } else {
 group.visible = v;
 if(v) this.needsUpdate = true;
 }
 },
 setAnchor(vec){ group.position.copy(vec); },
 update(time){
 if(!this.needsUpdate) return;
 const pivotFrame = rotateFrame(sampleFrameAt(0));
 pivotVec.set(pivotFrame.p[0], pivotFrame.p[1], pivotFrame.p[2]);

 for(let i=0;i<NSEG;i++){
 const sStart = i * segLen;
 const posTarget = segments[i].posArray;
 const basePos = cubeBase.positions;
 for(let v=0; v<basePos.length; v+=3){
 let x0 = basePos[v+0];
 let y0 = basePos[v+1];
 const z0 = basePos[v+2];
 let s = sStart + (z0 + hd);
 if (i>0 && i<NSEG) s -= JOIN_EPS;
 s = clamp(s, 0, L);
 const FR = rotateFrame(sampleFrameAt(s));
 const u = clamp((s - sStart) / segLen, 0, 1);
 if (i === 0){
 const mask = smoothstep(0.0, 0.3, 1.0 - u);
 const expand = 1.0 + HEAD_FACE_EXPAND * mask;
 x0 *= expand; y0 *= expand;
 }
 let px = FR.p[0] + x0*FR.side[0] + y0*FR.up[0];
 let py = FR.p[1] + x0*FR.side[1] + y0*FR.up[1];
 let pz = FR.p[2] + x0*FR.side[2] + y0*FR.up[2];
 const rx = Math.abs(x0)/(W*0.5), ry = Math.abs(y0)/(H*0.5);
 const radial = clamp(1.0 - 0.6*Math.max(rx, ry), 0, 1);
 let bulge = 0.0;
 if (i === 0){
 bulge = HEAD_BULGE * smoothstep(0.65, 1.0, u) * radial;
 } else if (i === NSEG-1){
 bulge = TAIL_BULGE * smoothstep(0.65, 1.0, u) * radial;
 }
 if (bulge > 0.0){
 px += FR.t[0]*bulge; py += FR.t[1]*bulge; pz += FR.t[2]*bulge;
 }
 px -= pivotVec.x; py -= pivotVec.y; pz -= pivotVec.z;
 posTarget[v+0] = px; posTarget[v+1] = py; posTarget[v+2] = pz;
 }
 computeNormals(posTarget, cubeBase.indices, segments[i].norArray);
 segments[i].mesh.geometry.attributes.position.needsUpdate = true;
 segments[i].mesh.geometry.attributes.normal.needsUpdate = true;
 segments[i].geometry.computeBoundingSphere();
 segments[i].geometry.computeBoundingBox();
 
 // Update shell geometry to match body
 if(segments[i].shellMesh){
 segments[i].shellPosArray.set(posTarget);
 segments[i].shellNorArray.set(segments[i].norArray);
 segments[i].shellMesh.geometry.attributes.position.needsUpdate = true;
 segments[i].shellMesh.geometry.attributes.normal.needsUpdate = true;
 segments[i].shellGeometry.computeBoundingSphere();
 segments[i].shellGeometry.computeBoundingBox();
 }
 }

 const FfaceR = rotateFrame(sampleFrameAt(sFace));
 const facePos = new THREE.Vector3(FfaceR.p[0], FfaceR.p[1], FfaceR.p[2]).sub(pivotVec);
 const N = normalize([-FfaceR.t[0], -FfaceR.t[1], -FfaceR.t[2]]);
 let up = projectUp(N);
 const right = normalize(cross(up, N));
 up = normalize(cross(N, right));

 const normalVec = toVector3(N);
 const upVec = toVector3(up);
 const rightVec = toVector3(right);
 const basis = new THREE.Matrix4().makeBasis(rightVec, upVec, normalVec);

 const inset = 0.010;
 const EYE_SPACING = 0.20;
 const EYE_Y = 0.15;
 const scaleH = 0.85, scaleV = 1.15, scaleN = 0.65;

 function placeEye(mesh, sign){
 mesh.position.set(
 facePos.x + sign*EYE_SPACING*rightVec.x + EYE_Y*upVec.x - inset*normalVec.x,
 facePos.y + sign*EYE_SPACING*rightVec.y + EYE_Y*upVec.y - inset*normalVec.y,
 facePos.z + sign*EYE_SPACING*rightVec.z + EYE_Y*upVec.z - inset*normalVec.z
 );
 mesh.quaternion.setFromRotationMatrix(basis);
 mesh.scale.set(scaleH, scaleV, scaleN);
 }

 placeEye(eyeL, -1);
 placeEye(eyeR, 1);

 const smileInset = 0.006;
 const offUp = -0.02;
 smile.quaternion.setFromRotationMatrix(basis);
 smile.position.set(
 facePos.x + offUp*upVec.x + smileInset*normalVec.x,
 facePos.y + offUp*upVec.y + smileInset*normalVec.y,
 facePos.z + offUp*upVec.z + smileInset*normalVec.z
 );
 smile.scale.set(1,1,0.72);

 this.headOffset.copy(facePos);
 aggregateBox.makeEmpty();
 group.traverse(node=>{
 if(!node.isMesh) return;
 const geometry = node.geometry;
 if(!geometry) return;
 if(!geometry.boundingBox) geometry.computeBoundingBox();
 const bbox = geometry.boundingBox;
 if(!bbox) return;
 node.updateMatrix();
 partBox.copy(bbox).applyMatrix4(node.matrix);
 aggregateBox.union(partBox);
 });
 if(!aggregateBox.isEmpty()){
 aggregateBox.getCenter(partCenter);
 this.centerOffset.copy(partCenter);
 } else {
 this.centerOffset.set(0,0,0);
 }
 this.needsUpdate = false;
 }
 };

 controller.update(0);
 return controller;
 }

 return { create };
 })();

 // Celli and Arraya avatars
 const ARRAYA_ROTATION_OFFSET = -Math.PI / 2; // Rotate 90 clockwise around Y
 let celli, arraya, arrayaAvatar;
 const Y_AXIS = new THREE.Vector3(0,1,0);
 const TMP_ARRAYA_PLACEMENT = new THREE.Vector3();
 const TMP_ARRAYA_OFFSET = new THREE.Vector3();

 function computeArrayaPlacement(basePos, hoverHeight, rotationY, scale){
 TMP_ARRAYA_PLACEMENT.copy(basePos);
 TMP_ARRAYA_PLACEMENT.y += hoverHeight;
 if(arrayaAvatar?.centerOffset){
 TMP_ARRAYA_OFFSET.set(arrayaAvatar.centerOffset.x, 0, arrayaAvatar.centerOffset.z);
 TMP_ARRAYA_OFFSET.multiplyScalar(scale);
 TMP_ARRAYA_OFFSET.applyAxisAngle(Y_AXIS, rotationY);
 TMP_ARRAYA_PLACEMENT.sub(TMP_ARRAYA_OFFSET);
 }
 return TMP_ARRAYA_PLACEMENT;
 }
 function ensureArrayaAvatar(){
 if(arrayaAvatar || typeof ArrayaAvatarFactory === 'undefined') return;
 try{
 const created = ArrayaAvatarFactory.create(THREE);
 if(!created) return;
 arrayaAvatar = created;
 arraya = arrayaAvatar.group;
 if(scene && arraya) scene.add(arraya);
 arrayaAvatar.setVisible(false);
 }catch(err){
 console.error('Failed to initialize Arraya avatar:', err);
 }
 }
 function initAvatars(){
 celli = AvatarFactory.createCelli(THREE);
 scene.add(celli); celli.visible=false;

 ensureArrayaAvatar();
 }

 function getAvatarWorldPosition(applyFloatOffset=false){
 try{
  if(spottedState?.locked && spottedState.lockPosition){
   const pos = spottedState.lockPosition.clone();
   if(applyFloatOffset && spottedState.floatOffset){
    pos.y += spottedState.floatOffset;
   }
   return pos;
  }
  if(Store.getState().scene.physics && playerBody){
   const t = playerBody.translation();
   return new THREE.Vector3(t.x, t.y + 0.6, t.z);
  }
 }catch{}
 try{
  if(celli){
   const pos = celli.position.clone();
   if(applyFloatOffset && spottedState?.floatOffset){
    pos.y += spottedState.floatOffset;
   }
   return pos;
  }
  if(arrayaAvatar?.group?.visible){
   return arrayaAvatar.group.position.clone();
  }
 }catch{}
 try{
  const sel = Store.getState().selection;
  if(sel?.arrayId){
   const arr = Store.getState().arrays[sel.arrayId];
   const focus = sel.focus || {x:0,y:0,z:0};
   if(arr){
    const pos = worldPos(arr, focus.x, focus.y, focus.z);
    const perch = arrayVoxelScale(arr);
    const base = new THREE.Vector3(pos.x, pos.y + perch, pos.z);
    if(applyFloatOffset && spottedState?.floatOffset){
     base.y += spottedState.floatOffset;
    }
    return base;
   }
  }
 }catch{}
 return new THREE.Vector3();
}

function startSpottedSequence(){
 if(spottedState?.active){
  return spottedState;
 }
 const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() * 0.001 : Date.now() / 1000;
 const basePos = getAvatarWorldPosition(false);
 spottedState = {
  active: true,
  startTime: now,
  focusDelay: 10,
  locked: false,
  lockTime: null,
  lockPosition: basePos.clone(),
  floatOffset: 0,
  floatSpeed: 1.4,
  floatMax: 18,
  audio: null,
  audioStarted: false,
  physicsDisabled: false
 };
 try{ arrayaAvatar?.setVisible(false); }catch{}
 if(celli){
  celli.visible = true;
  celli.scale.set(0.7,0.7,0.7);
 }
 if(OceanBackdrop.startSpotlightSweep){
  try{ OceanBackdrop.startSpotlightSweep(()=> getAvatarWorldPosition(true), { focusDelay: spottedState.focusDelay }); }catch{}
 }
 needsRender = true;
 return spottedState;
}

function updateSpottedSequence(deltaSec){
 if(!spottedState?.active) return;
 const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() * 0.001 : Date.now() / 1000;
 if(!spottedState.locked){
  const elapsed = now - spottedState.startTime;
  if(elapsed >= spottedState.focusDelay){
   spottedState.locked = true;
   spottedState.lockTime = now;
   spottedState.lockPosition = getAvatarWorldPosition(false);
   spottedState.floatOffset = 0;
   if(Store.getState().scene.physics && !spottedState.physicsDisabled){
    spottedState.physicsDisabled = true;
    try{ togglePhysicsMode()?.catch(()=>{}); }catch{}
   }
   try{ arrayaAvatar?.setVisible(false); }catch{}
   if(celli){
    celli.visible = true;
    celli.scale.set(0.7,0.7,0.7);
   }
  }
 }
 if(spottedState.locked){
  const elapsed = now - (spottedState.lockTime || now);
  const rise = Math.min(spottedState.floatMax, elapsed * spottedState.floatSpeed);
  const bob = Math.sin(elapsed * 2.2) * 0.45;
  spottedState.floatOffset = rise + bob;
  if(!spottedState.audioStarted){
   spottedState.audioStarted = true;
   if(typeof Audio !== 'undefined'){
    try{
     const audio = new Audio('spotted.mp3');
     spottedState.audio = audio;
     audio.play().catch(()=>{});
    }catch{}
   }
  }
 }
 needsRender = true;
}

function updateAvatars(sel){
 // Don't update avatars during swap animation
 if(swapAnimating) return;
 
 if(spottedState?.locked && celli){
  try{ arrayaAvatar?.setVisible(false); }catch{}
  const base = spottedState.lockPosition ? spottedState.lockPosition.clone() : getAvatarWorldPosition(false);
  if(base){
   base.y += spottedState.floatOffset || 0;
   celli.position.copy(base);
  }
  celli.visible = true;
  celli.scale.set(0.7,0.7,0.7);
  const look = new THREE.Vector3().subVectors(camera.position, celli.position);
  look.y = 0;
  if(look.lengthSq() > 1e-6){
   celli.rotation.y = Math.atan2(look.x, look.z);
  }
  return;
 }
 
 const physicsMode = Store.getState().scene.physics;
 
 // ONLY position from physics if physics is actually enabled AND playerBody exists
 if(physicsMode && playerBody && rapierWorld){
 try{
 const translation = playerBody.translation();
 const basePosX = translation.x;
 const basePosY = translation.y - 0.3;
 const basePosZ = translation.z;
 let verticalOffset = 0;
 celli.visible = true;

 // Stretch and squash animation during jump/fall with anticipation
 const baseScale = 0.7;

 // Anticipation squash when preparing to jump
 if(anticipationSquashTime > 0){
 const squashY = 0.65; // Squash down to build energy
 const expandXZ = 1.25; // Expand horizontally
 celli.scale.set(baseScale * expandXZ, baseScale * squashY, baseScale * expandXZ);
 landingSquashTime = 0; // Reset landing animation
 }
 // Jump stretch - elongate while ascending
 else if(jumpVelocity > 4){
 const stretchAmount = 1 + (jumpVelocity - 4) * 0.06; // More dramatic stretch
 const compressXZ = 1 - (jumpVelocity - 4) * 0.02; // Compress horizontally
 celli.scale.set(baseScale * Math.max(0.75, compressXZ), baseScale * stretchAmount, baseScale * Math.max(0.75, compressXZ));
 landingSquashTime = 0;
 }
 // Falling stretch - elongate while descending fast
 else if(jumpVelocity < -3){
 const fallStretch = 1 + Math.abs(jumpVelocity + 3) * 0.04;
 const fallCompress = 1 - Math.abs(jumpVelocity + 3) * 0.015;
 celli.scale.set(baseScale * Math.max(0.8, fallCompress), baseScale * fallStretch, baseScale * Math.max(0.8, fallCompress));
 landingSquashTime = 0;
 }
 // Landing squash and recovery
 else if(Math.abs(jumpVelocity) < 0.5){
 if(landingSquashTime === 0){
 landingSquashTime = 1; // Trigger landing squash
 }
 // Landing squash and recovery animation over ~300ms
 if(landingSquashTime < 18){
 const t = landingSquashTime / 18;
 // Squash down then bounce back up
 let squashY, expandXZ;
 if(t < 0.3){
 // Initial impact squash (frames 1-5)
 const impactT = t / 0.3;
 squashY = 1 - 0.35 * impactT; // 1.0 -> 0.65
 expandXZ = 1 + 0.3 * impactT; // 1.0 -> 1.3
 } else {
 // Recovery with slight overshoot (frames 6-18)
 const recoveryT = (t - 0.3) / 0.7;
 const easeOut = 1 - Math.pow(1 - recoveryT, 3); // Cubic ease out
 squashY = 0.65 + 0.38 * easeOut; // 0.65 -> 1.03 -> 1.0
 expandXZ = 1.3 - 0.32 * easeOut; // 1.3 -> 0.98 -> 1.0
 // Add slight overshoot at the end
 if(recoveryT > 0.8){
 const overshootT = (recoveryT - 0.8) / 0.2;
 squashY += 0.03 * Math.sin(overshootT * Math.PI);
 }
 }
 celli.scale.set(baseScale * expandXZ, baseScale * squashY, baseScale * expandXZ);
 const depression = Math.max(0, 1 - Math.min(squashY, 1));
 verticalOffset = Math.max(verticalOffset, Math.min(0.5, depression * 0.32));
 landingSquashTime++;
 } else {
 // Fully recovered to normal
 celli.scale.set(baseScale, baseScale, baseScale);
 }
 }
 // Normal state (walking or gentle movement)
 else {
 celli.scale.set(baseScale, baseScale, baseScale);
 if(Math.abs(jumpVelocity) > 1) landingSquashTime = 0; // Reset if airborne
 }

 if(surfaceBounceState.key && (surfaceBounceState.key === lastLandKey || surfaceBounceState.key === lastTouchKey)){
 const intensityScale = Math.max(0.2, 0.32 + 0.18 * (surfaceBounceState.intensity - 1));
 const depression = Math.max(0, Math.min(0.5, surfaceBounceState.depression * intensityScale));
 verticalOffset = Math.max(verticalOffset, depression);
 }

 celli.position.set(basePosX, basePosY - verticalOffset, basePosZ);

 // Physics mode: face movement direction
 if(mouseLookEnabled){
 // Face the mouse look direction
 celli.rotation.y = mouseYaw;
 } else {
 // Face camera direction
 const camDir = new THREE.Vector3();
 camera.getWorldDirection(camDir);
 camDir.y = 0;
 camDir.normalize();
 const targetAngle = Math.atan2(camDir.x, camDir.z);
 celli.rotation.y = targetAngle;
 }
 }catch{
 celli.visible = false;
 }
 if(arrayaAvatar) arrayaAvatar.setVisible(false);
 return;
 }
 
 // Edit mode: position from selection
 if(!sel.arrayId||!sel.focus){
 celli.visible=false;
 if(arrayaAvatar) arrayaAvatar.setVisible(false);
 return;
 }
 const arr=Store.getState().arrays[sel.arrayId];
 const pos=worldPos(arr,sel.focus.x,sel.focus.y,sel.focus.z);

 let multiSelect = false;
 if(sel.range){
 const sx = sel.range.x1 ?? sel.range.x ?? sel.focus.x;
 const ex = sel.range.x2 ?? sel.range.x ?? sel.focus.x;
 const sy = sel.range.y1 ?? sel.range.y ?? sel.focus.y;
 const ey = sel.range.y2 ?? sel.range.y ?? sel.focus.y;
 const sz = sel.range.z1 ?? sel.range.z ?? sel.focus.z;
 const ez = sel.range.z2 ?? sel.range.z ?? sel.focus.z;
 multiSelect = (sx !== ex) || (sy !== ey) || (sz !== ez);
 }
 if(multiSelect){
 celli.visible = false;
 if(arrayaAvatar) arrayaAvatar.setVisible(false);
 return;
 }
 
 let cell = null;
 try{ cell = UI.getCell(sel.arrayId,sel.focus); }catch{}
 if(!cell){
 try{ cell = Formula.getCell({arrId:sel.arrayId,x:sel.focus.x,y:sel.focus.y,z:sel.focus.z}); }catch{}
 }
 const formulaText = (cell?.formula||'');
 const valueText = (cell?.value||'');
 const hasArray = /ARRAY\(/i.test(formulaText) || /ARRAY\(/i.test(valueText);
 ensureArrayaAvatar();
 
 // Swap between Celli and Arraya with animation
 if(arrayaAvatar){
 const shouldShowArraya = hasArray;
 const arrayaVisible = arrayaAvatar.group?.visible || false;
 const wasArraya = arrayaAvatar._lastCell && arrayaAvatar._lastCell.hasArray;
 const currentCellKey = `${sel.arrayId}:${sel.focus.x},${sel.focus.y},${sel.focus.z}`;
 const cellChanged = (arrayaAvatar._lastCellKey !== currentCellKey);
 
 if(shouldShowArraya && !arrayaVisible){
 // Swap from Celli to Arraya with swirl animation
 console.log('[AVATAR] Starting swap: Celli -> Arraya');
 // Update Arraya's body to get correct headOffset before animating
 arrayaAvatar.needsUpdate = true;
 arrayaAvatar.update(0);
 // Calculate facing angle before swap - use cell position for consistent angle
 const cellToCamera = new THREE.Vector3().subVectors(camera.position, pos);
 cellToCamera.y = 0;
 cellToCamera.normalize();
 const baseAngle = Math.atan2(cellToCamera.x, cellToCamera.z);
 const spawnAngle = baseAngle + ARRAYA_ROTATION_OFFSET;
 const baseDeg = (baseAngle * 180 / Math.PI).toFixed(1);
 const spawnDeg = (spawnAngle * 180 / Math.PI).toFixed(1);
 console.log(`[AVATAR] Swap spawn: cell(${pos.x.toFixed(1)},${pos.z.toFixed(1)}), camera(${camera.position.x.toFixed(1)},${camera.position.z.toFixed(1)}), direction(${cellToCamera.x.toFixed(2)},${cellToCamera.z.toFixed(2)}), base=${baseDeg} , spawn=${spawnDeg} `);
 arrayaAvatar._targetRotation = spawnAngle;
 animateAvatarSwap(celli, arrayaAvatar, pos);
 arrayaAvatar._lastCellKey = currentCellKey;
 arrayaAvatar._lastCell = {hasArray: true};
 } else if(!shouldShowArraya && arrayaVisible){
 // Swap from Arraya back to Celli
 console.log('[AVATAR] Starting swap: Arraya -> Celli');
 animateAvatarSwap(arrayaAvatar.group, celli, pos);
 arrayaAvatar._lastCellKey = currentCellKey;
 arrayaAvatar._lastCell = {hasArray: false};
 } else if(shouldShowArraya){
 // Moving between ARRAY cells: just reposition Arraya, no swap
 arrayaAvatar.setVisible(true);
 celli.visible = false;
 
 // Update body curve if cell changed
 if(cellChanged){
 arrayaAvatar.needsUpdate = true;
 arrayaAvatar.update(0);
 }
 
 const arrScale = arrayVoxelScale(arr);
 const arrayaHover = clampedScaleOffset(arrScale, 0.8);
 let targetRotation = arrayaAvatar._targetRotation;

 // Update rotation on cell change or if not set
 if(cellChanged || targetRotation === undefined){
 // Face camera - calculate direction from cell to camera
 const cellToCamera = new THREE.Vector3().subVectors(camera.position, pos);
 cellToCamera.y = 0;
 cellToCamera.normalize();
 // For character facing: atan2(x, z) where character looks down +Z by default
 const baseAngle = Math.atan2(cellToCamera.x, cellToCamera.z);
 const spawnAngle = baseAngle + ARRAYA_ROTATION_OFFSET;
 const baseDeg = (baseAngle * 180 / Math.PI).toFixed(1);
 const spawnDeg = (spawnAngle * 180 / Math.PI).toFixed(1);
 console.log(`[AVATAR] Arraya spawn at cell(${pos.x.toFixed(1)},${pos.z.toFixed(1)}), camera(${camera.position.x.toFixed(1)},${camera.position.z.toFixed(1)}), direction(${cellToCamera.x.toFixed(2)},${cellToCamera.z.toFixed(2)}), base=${baseDeg} , spawn=${spawnDeg} `);
 targetRotation = spawnAngle;
 arrayaAvatar._targetRotation = spawnAngle;
 }

 const placement = computeArrayaPlacement(pos, arrayaHover, targetRotation, ARRAYA_BASE_SCALE);
 arrayaAvatar.group.position.copy(placement);
 arrayaAvatar.group.scale.set(ARRAYA_BASE_SCALE, ARRAYA_BASE_SCALE, ARRAYA_BASE_SCALE);
 arrayaAvatar.group.rotation.y = targetRotation;

 arrayaAvatar._lastCellKey = currentCellKey;
 arrayaAvatar._lastCell = {hasArray: true};
 } else {
 // Celli is visible - continuous camera tracking
 const arrScale = arrayVoxelScale(arr);
 const perch = avatarPerchOffset(arrScale);
 celli.position.copy(pos).add(new THREE.Vector3(0, perch, 0));
 celli.visible=true;
 celli.scale.set(0.7, 0.7, 0.7); // Smaller Celli
 
 // Celli continuously faces camera
 const celliToCamera = new THREE.Vector3().subVectors(camera.position, celli.position);
 celliToCamera.y = 0; // Project to horizontal plane
 celliToCamera.normalize();
 const targetAngle = Math.atan2(celliToCamera.x, celliToCamera.z);
 celli.rotation.y = targetAngle;
 
 arrayaAvatar._lastCellKey = currentCellKey;
 arrayaAvatar._lastCell = {hasArray: false};
 }
 }
 }

 let swapAnimating = false; // Guard against overlapping swap animations
 
 function animateAvatarSwap(fromAvatar, toAvatarOrFactory, cellPos){
 if(swapAnimating){
 console.log('[AVATAR] Swap already in progress, skipping');
 return;
 }
 swapAnimating = true;
 console.log('[AVATAR] animateAvatarSwap called', {from: fromAvatar.name || 'Celli', to: toAvatarOrFactory.group?.name || 'Celli'});

 try{
 const selState = Store.getState().selection;
 const arraysState = Store.getState().arrays;
 const activeArr = selState?.arrayId != null ? arraysState?.[selState.arrayId] : null;
 const swapScale = activeArr ? arrayVoxelScale(activeArr) : 1;
 const perchCelli = avatarPerchOffset(swapScale);
 const perchArraya = clampedScaleOffset(swapScale, 0.8);
 // Magical swirl/spin/shrink animation
 const startPos = fromAvatar.position.clone();
 const startScale = fromAvatar.scale?.clone() || new THREE.Vector3(1,1,1);
 const startRot = fromAvatar.rotation?.y || 0;
 const isCelliFrom = (fromAvatar === celli);
 const isArrayaTo = (toAvatarOrFactory.group != null);
 const toAvatar = toAvatarOrFactory.group || toAvatarOrFactory;
 const isCelliTo = (toAvatar === celli);
 const finalTargetScale = isCelliTo ? 0.7 : ARRAYA_BASE_SCALE;
 
 let t0 = null;
 const dur = 400; // 400ms for smooth magical swap
 
 const swapFrame = (ts)=>{
 if(t0 == null) t0 = ts;
 const elapsed = ts - t0;
 const u = Math.min(1, elapsed / dur);
 
 if(u % 0.1 < 0.02) console.log(`[AVATAR] Swap u=${u.toFixed(2)}`);
 
 // First half: shrink and spin out
 if(u <= 0.5){
 const t = u * 2; // 0 to 1 in first half
 const scale = startScale.x * (1 - (0.7 * t)); // Shrink to 30%
 const spin = startRot + (Math.PI * 4 * t); // 4 full rotations
 const rise = 0.35 * Math.sin(t * Math.PI); // Hop up
 fromAvatar.scale.set(scale, scale, scale);
 fromAvatar.rotation.y = spin;
 fromAvatar.position.x = startPos.x;
 fromAvatar.position.y = startPos.y + rise;
 fromAvatar.position.z = startPos.z;
 fromAvatar.visible = true;
 toAvatar.visible = false;
 } else {
 // Second half: grow and spin in with new avatar
 fromAvatar.visible = false;
 const t = (u - 0.5) * 2; // 0 to 1 in second half
 
 toAvatar.visible = true;
 const scale = finalTargetScale * (0.3 + (0.7 * t)); // Grow from 30% to 100%
 const targetRotation = arrayaAvatar._targetRotation || startRot;
 const spin = targetRotation + Math.PI * 2 - (Math.PI * 2 * t); // Reverse spin
 const rise = 0.35 * Math.sin((1-t) * Math.PI);
 toAvatar.scale.set(scale, scale, scale);

 // Position matching updateAvatars logic - simple direct positioning
 const targetY = isArrayaTo ? 0.8 : 0.7;
 if(isArrayaTo){
 const placement = computeArrayaPlacement(cellPos, targetY, spin, scale);
 toAvatar.position.copy(placement);
 toAvatar.position.y += rise;
 } else {
 const targetPos = cellPos.clone().add(new THREE.Vector3(0, targetY, 0));
 toAvatar.position.x = targetPos.x;
 toAvatar.position.y = targetPos.y + rise;
 toAvatar.position.z = targetPos.z;
 }
 toAvatar.rotation.y = spin;
 }
 
 if(u < 1){
 requestAnimationFrame(swapFrame);
 } else {
 console.log('[AVATAR] Swap complete');
 // Final cleanup
 fromAvatar.visible = false;
 fromAvatar.scale.copy(startScale);
 toAvatar.visible = true;
 toAvatar.scale.set(finalTargetScale, finalTargetScale, finalTargetScale);
 
 // Final position matching updateAvatars logic
 const targetY = isArrayaTo ? perchArraya : perchCelli;
 if(isArrayaTo){
 const finalRotation = arrayaAvatar._targetRotation ?? toAvatar.rotation.y;
 const placement = computeArrayaPlacement(cellPos, targetY, finalRotation, finalTargetScale);
 toAvatar.position.copy(placement);
 toAvatar.rotation.y = finalRotation;
 } else {
 toAvatar.position.copy(cellPos).add(new THREE.Vector3(0, targetY, 0));
 }
 swapAnimating = false;
 }
 };
 requestAnimationFrame(swapFrame);
 }catch(e){
 console.warn('Avatar swap animation failed:', e);
 swapAnimating = false;
 // Fallback: instant swap
 fromAvatar.visible = false;
 const toAvatar = toAvatarOrFactory.group || toAvatarOrFactory;
 toAvatar.visible = true;
 const finalScale = (toAvatar === celli) ? 0.7 : ARRAYA_BASE_SCALE;
 toAvatar.scale?.set(finalScale, finalScale, finalScale);
 }
 }

 function addTimedPreview(arr,anchor,ticks){
 const pos=worldPos(arr,anchor.x,anchor.y,anchor.z);
 const preview=new THREE.Mesh(new THREE.BoxGeometry(1.2,1.2,1.2), new THREE.MeshBasicMaterial({color:0x22c55e,transparent:true,opacity:0.4}));
 preview.position.copy(pos); scene.add(preview);
 let t=0; const loop=()=>{
 t=(t+1)%ticks; const s=Math.sin((t/ticks)*Math.PI*2)*0.3;
 preview.position.y=pos.y+s; preview.rotation.y=t*0.05;
 if(t===0) scene.remove(preview); else requestAnimationFrame(loop);
 }; loop();
 }
 // Jump physics
 let jumpVelocity=0;
 let jumpBudget={max:1, remaining:1, source:'avatar'};
 let physicsSpawnPos = null; // Store spawn position for respawn on fall
 let landingSquashTime = 0; // Track landing squash animation
 let anticipationSquashTime = 0; // Track jump anticipation squash

 function setPhysicsSpawn(pos){
 if(pos && Number.isFinite(pos.x) && Number.isFinite(pos.y) && Number.isFinite(pos.z)){
 physicsSpawnPos = { x: pos.x, y: pos.y, z: pos.z };
 } else {
 physicsSpawnPos = null;
 }
 }

 function computeJumpBudget(arrOverride=null){
 // In debug mode, allow infinite jumps
 const debugMode = !!Store.getState().scene?.physicsDebugAll;
 if(debugMode){
 return {max: Number.POSITIVE_INFINITY, source: 'debug'};
 }
 const avatarCfg = Store.getState().avatarPhysics || {};
 let max = Math.max(1, Math.round(Number(avatarCfg.jumpCount ?? 1)) || 1);
 let source = 'avatar';
 try{
 const sel = Store.getState().selection;
 const arr = arrOverride || (sel?.arrayId ? Store.getState().arrays[sel.arrayId] : null);
 if(arr){
 const arrJump = arr?.params?.physics?.jumpCount;
 if(Number.isFinite(arrJump) && arrJump > 0){
 max = Math.max(1, Math.round(arrJump));
 source = `array:${arr.id}`;
 }
 }
 }catch{}
 return {max, source};
 }
 function resetJumpBudget(arrOverride=null){
 const base = computeJumpBudget(arrOverride);
 jumpBudget = { ...base, remaining: base.max };
 }
 function consumeJump(){
 if(jumpBudget.remaining > 0){
 jumpBudget.remaining -= 1;
 }
 }
 function applyArrayFloorClamp(body){
 try{
 const sel = Store.getState().selection;
 if(!sel?.arrayId) return;
 const arr = Store.getState().arrays[sel.arrayId];
 if(!arr?.params?.physics?.boundByArrayFloor) return;
 if(!body) return;
 const floorCenter = worldPos(arr, 0, arr.size.y - 1, 0);
 const floorY = floorCenter.y - 0.5;
 const translation = body.translation();
 if(!Number.isFinite(translation.y)) return;
 if(translation.y < floorY){
 body.setTranslation({x: translation.x, y: floorY, z: translation.z}, true);
 const vel = body.linvel();
 if(vel.y < 0){
 body.setLinvel({x: vel.x, y: 0, z: vel.z}, true);
 }
 cachedPlayerPos.set(translation.x, floorY, translation.z);
 }
 }catch(e){
 console.warn('Floor clamp failed', e);
 }
 }
 
 function handleJump(){
 // --- START: ZIPLINE DETACHMENT ---
 if(ziplineState.active){
 ziplineState.active = false;
 ziplineState.velocity = 0;
 jumpVelocity = 4; // Give a small hop off the line
 console.log('[PHYSICS] Detached from zipline');
 return;
 }
 // --- END: ZIPLINE DETACHMENT ---

 // Don't modify wasGroundedLastFrame here - it's managed by the landing detection in animate()
 if(RAPIER && rapierWorld && playerBody){
 try {
 // Check if grounded using raycast for proper platformer support
 const translation = playerBody.translation();
 const vel = playerBody.linvel();
 
 // Validate position before raycasting
 if(!Number.isFinite(translation.x) || !Number.isFinite(translation.y) || !Number.isFinite(translation.z)){
 console.warn('[PHYSICS] Invalid player position for jump check');
 return;
 }
 
 // Raycast downward from player position to detect ground/platforms
 const ray = new RAPIER.Ray(translation, {x: 0, y: -1, z: 0});
 const maxToi = 0.5; // Check 0.5 units below (player capsule radius is ~0.22)
 const solid = true;
 
 const hit = rapierWorld.castRay(ray, maxToi, solid);
 const grounded = hit !== null && Math.abs(vel.y) < 1.0;
 
 console.log(`[PHYSICS] Jump check - grounded=${grounded}, rayHit=${hit !== null}, y=${translation.y.toFixed(2)}, vel.y=${vel.y.toFixed(2)}`);
 
 if(grounded){
 if(jumpBudget.remaining <= 0){
 return;
 }
 consumeJump();
 anticipationSquashTime = 1;
 setTimeout(() => {
 if(playerBody && rapierWorld){
 const currentVel = playerBody.linvel();
 playerBody.setLinvel({x: currentVel.x, y: 8.0, z: currentVel.z}, true);
 jumpVelocity = 8;
 anticipationSquashTime = 0;
 console.log('[PHYSICS] Jump velocity set! vel.y=8.0');
 }
 }, 50);
 } else if(jumpBudget.remaining > 0){
 consumeJump();
 const currentVel = playerBody.linvel();
 playerBody.setLinvel({x: currentVel.x, y: 8.0, z: currentVel.z}, true);
 jumpVelocity = 8;
 anticipationSquashTime = 0;
 }
 } catch(e) {
 console.warn('Jump failed:', e);
 }
 } else {
 console.warn('[PHYSICS] No rapierWorld or playerBody for jump');
 }
 }

 function updateValueSprite(arr, x, y, z, cell){
 // Skip updating sprites if array is being deleted
 if(arr?._deleting) return;
 
 const key=`${arr.id}:${x},${y},${z}`;
 
 // Remove old sprite if exists
 const oldSprite=valueSprites.get(key);
 if(oldSprite){ try{ unmarkBillboard(oldSprite); }catch{} oldSprite.parent?.remove(oldSprite); oldSprite.material.map?.dispose(); oldSprite.material.dispose(); valueSprites.delete(key); }
 
 // Create new sprite if cell has content (prefer displayText if available)
 const displayText = cell.meta?.displayText;
 const actualText = displayText !== undefined ? displayText : cell.value;
 if(actualText!=='' && actualText!==null && actualText!==undefined){
 const text=String(actualText).slice(0,12); // allow longer text
 const isFormula=!!cell.formula;
 const sprite=makeValueSprite(text, isFormula);
 const pos=localPos(arr,x,y,z);
 // Place on the same face used by occlusion/arrow mapping
 const face = getPreferredFacing(arr);
 const off = SPRITE_FACE_OFFSET * face.sign;
 const dx = (face.axis===0) ? off : 0;
 const dy = (face.axis===1) ? off : 0;
 const dz = (face.axis===2) ? off : 0;
 sprite.position.copy(pos).add(new THREE.Vector3(dx,dy,dz));
 // Parent to frame for unified movement
 if(arr._frame) arr._frame.add(sprite); else scene.add(sprite);
 try{ sprite.material.depthTest = true; sprite.material.depthWrite = false; }catch{}
 valueSprites.set(key, sprite);
 } else { valueSprites.delete(key); }
 }

 // Deletion explosion effect
 const deleteEffects = [];
 const pendingDatafallDeletes = new Map(); // arrId -> {count:number, finished:boolean}
 const nowMs = ()=> (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
 let deleteInteractionLock = false;
 let deletionControlState = null;
 function clearDeletionDeadline(rec){
 if(rec && rec.deadlineTimer){
 try{ clearTimeout(rec.deadlineTimer); }catch{}
 rec.deadlineTimer = null;
 }
 }
 function scheduleDeletionDeadline(arrId, delay=30000){
 try{
 const key = normalizeArrayId(arrId);
 const rec = pendingDatafallDeletes.get(key);
 if(!rec) return;
 clearDeletionDeadline(rec);
 rec.deadlineTimer = setTimeout(()=>{
 try{ maybeFinalizeDeletion(arrId, true); }catch{}
 }, delay);
 rec.lastActive = nowMs();
 pendingDatafallDeletes.set(key, rec);
 }catch{}
 }
 function discardDeleteEffectsForArray(arrId){
 for(let i = deleteEffects.length - 1; i >= 0; i--){
 const eff = deleteEffects[i];
 if(!eff || eff.sourceArrId !== arrId) continue;
 try{
 if(eff.group){
 eff.group.parent?.remove(eff.group);
 if(typeof eff.group.traverse === 'function'){
 eff.group.traverse(obj=>{
 if(obj?.material){
 try{ obj.material.map?.dispose?.(); }catch{}
 try{ obj.material.dispose?.(); }catch{}
 }
 if(obj?.geometry){ try{ obj.geometry.dispose?.(); }catch{} }
 });
 }
 }
 if(Array.isArray(eff.clones)){
 eff.clones.forEach(c=>{
 try{ if(c?.sprite){ unmarkBillboard(c.sprite); c.sprite.parent?.remove(c.sprite); c.sprite.material?.map?.dispose?.(); c.sprite.material?.dispose?.(); } }catch{}
 });
 }
 }catch{}
 deleteEffects.splice(i, 1);
 }
 }
 const DATAFALL_COLORS = {
 syntax: '#111827',
 function: '#111827',
 punctuation: '#111827',
 string: '#16a34a',
 range: '#f59e0b',
 address: '#f59e0b',
 number: '#1d4ed8',
 binary: '#2563eb',
 unicode: '#a855f7'
 };
 function cssColor(color){
 if(typeof color === 'number'){ return `#${color.toString(16).padStart(6,'0')}`; }
 return color || '#ffffff';
 }
 function tokenizeFormulaForDatafall(raw){
 const out = [];
 if(!raw){ return out; }
 const formula = String(raw);
 const regex = /(=[A-Z_0-9]+)|(@\[[^\]]+\])|("[^"\\]*(?:\\.[^"\\]*)*")|(\()|(\))|(,)|([A-Z]+\d+)|(-?\d+(?:\.\d+)?)/gi;
 let lastIndex = 0;
 let match;
 while((match = regex.exec(formula))){
 if(match.index > lastIndex){
 const text = formula.slice(lastIndex, match.index);
 if(text){ out.push({ text, tokenKind: 'syntax', color: DATAFALL_COLORS.syntax }); }
 }
 const text = match[0];
 let tokenKind = 'syntax';
 if(match[1]) tokenKind = 'function';
 else if(match[2]) tokenKind = 'range';
 else if(match[3]) tokenKind = 'string';
 else if(match[4] || match[5] || match[6]) tokenKind = 'punctuation';
 else if(match[7]) tokenKind = 'address';
 else if(match[8]) tokenKind = 'number';
 out.push({ text, tokenKind, color: DATAFALL_COLORS[tokenKind] || DATAFALL_COLORS.syntax });
 lastIndex = regex.lastIndex;
 }
 if(lastIndex < formula.length){
 const tail = formula.slice(lastIndex);
 if(tail){ out.push({ text: tail, tokenKind: 'syntax', color: DATAFALL_COLORS.syntax }); }
 }
 return out;
 }
 function classifyRawValue(raw){
 const text = String(raw ?? '');
 const trimmed = text.trim();
 if(trimmed === '') return { text, tokenKind: 'syntax', color: DATAFALL_COLORS.syntax };
 const numeric = !Number.isNaN(Number(trimmed));
 if(numeric){ return { text: trimmed, tokenKind: 'number', color: DATAFALL_COLORS.number }; }
 if(/^".*"$/.test(trimmed)) return { text: trimmed, tokenKind: 'string', color: DATAFALL_COLORS.string };
 return { text, tokenKind: 'syntax', color: DATAFALL_COLORS.syntax };
 }
 function colorForCellVisual(arrId, cell){
 try{
 if(!cell) return baseHexForTypeKey('empty');
 if(cell.meta && cell.meta.color) return cell.meta.color;
 const key = `${arrId}:${cell.x},${cell.y},${cell.z}`;
 const emitted = !!(Store.getState().sourceByCell && Store.getState().sourceByCell.get && Store.getState().sourceByCell.get(key));
 const hasValue = (cell.value!=='' && cell.value!==null && cell.value!==undefined);
 if(cell.formula) return baseHexForTypeKey('formula');
 if(emitted) return baseHexForTypeKey('emitted');
 return hasValue ? baseHexForTypeKey('value') : baseHexForTypeKey('empty');
 }catch{ return baseHexForTypeKey('empty'); }
 }
 function lockDeletionInteractions(){
 // Camera movement should NOT be blocked during delete animations
 deleteInteractionLock = true;
 }
 function releaseDeletionInteractions(){
 // Camera movement should NOT be blocked during delete animations
 deleteInteractionLock = false;
 }
 function startAxisFall(arr, onDone){
 try{
 // First: shrink the frame mesh itself, but leave axis labels at full size
 if(arr._frame){
 const frame = arr._frame;
 const startScale = frame.scale.clone();
 const dur = 600;
 let t0 = null;
 // Store initial label positions before shrinking
 const labels = (arr?.labels||[]).filter(Boolean);
 const labelInitialWorldPos = new Map();
 labels.forEach(label=>{
 try{
 labelInitialWorldPos.set(label, label.getWorldPosition(new THREE.Vector3()));
 }catch{}
 });
 
 const shrinkFrame = (ts)=>{
 if(t0 == null) t0 = ts;
 const elapsed = ts - t0;
 const u = Math.min(1, elapsed / dur);
 const e = 1 - Math.pow(1-u, 3);
 const scale = 1 - (0.9 * e);
 frame.scale.copy(startScale).multiplyScalar(Math.max(0.01, scale));
 // Keep labels at original size by counter-scaling them
 labels.forEach(label=>{
 try{
 const counterScale = 1 / Math.max(0.01, scale);
 if(label.scale) label.scale.set(counterScale, counterScale, counterScale);
 }catch{}
 });
 if(u < 1){
 requestAnimationFrame(shrinkFrame);
 } else {
 // Frame shrunk, remove it and start axis label fall
 try{
 frame.parent?.remove(frame);
 frame.traverse(obj=>{
 if(obj?.geometry) obj.geometry.dispose?.();
 if(obj?.material){
 obj.material.map?.dispose?.();
 obj.material.dispose?.();
 }
 });
 }catch{}
 startLabelFall();
 }
 };
 requestAnimationFrame(shrinkFrame);
 } else {
 startLabelFall();
 }

 function startLabelFall(){
 const labels = (arr?.labels||[]).filter(Boolean);
 if(!labels.length){ if(typeof onDone==='function') onDone(); return; }
 const actors = [];
 labels.forEach(label=>{
 try{ if(label.userData?.billboard) unmarkBillboard(label); }catch{}
 try{
 const worldPos = label.getWorldPosition(new THREE.Vector3());
 const worldQuat = label.getWorldQuaternion(new THREE.Quaternion());
 // Reset scale to 1 when converting to world space
 const worldScale = new THREE.Vector3(1,1,1);
 label.parent?.remove(label);
 label.position.copy(worldPos);
 label.quaternion.copy(worldQuat);
 label.scale.copy(worldScale);
 scene.add(label);
 actors.push({
 mesh: label,
 vel: new THREE.Vector3((Math.random()-0.5)*0.02, Math.random()*0.04 + 0.02, (Math.random()-0.5)*0.02),
 rot: new THREE.Vector3((Math.random()-0.5)*0.06, (Math.random()-0.5)*0.06, (Math.random()-0.5)*0.06),
 age: 0,
 life: 1100 + Math.random()*500
 });
 }catch{}
 });
 arr.labels = [];
 try{ if(arr._frame?.userData) arr._frame.userData.grab = null; }catch{}
 if(!actors.length){ if(typeof onDone==='function') onDone(); return; }
 deleteEffects.push({
 phase:'axisFall',
 sourceArrId: arr.id,
 labels: actors,
 onDone:()=>{
 actors.forEach(actor=>{
 try{ if(actor.mesh.userData?.billboard) unmarkBillboard(actor.mesh); }catch{}
 try{ actor.mesh.parent?.remove(actor.mesh); }catch{}
 try{ actor.mesh.material?.map?.dispose?.(); actor.mesh.material?.dispose?.(); }catch{}
 });
 if(typeof onDone==='function') onDone();
 }
 });
 }
 }catch{ if(typeof onDone==='function') onDone(); }
 }
 function maybeFinalizeDeletion(arrId, force=false){
 const key = normalizeArrayId(arrId);
 try{
 const rec = pendingDatafallDeletes.get(key);
 if(!rec){
 console.log(`DELETE: No record for array #${arrId}`);
 return;
 }
 console.log(`DELETE: maybeFinalize for array #${arrId}, finished:${rec.finished}, count:${rec.count}, force:${force}`);
 if(force){
 rec.finished = true;
 rec.count = 0;
 }
 if(!rec.finished || (rec.count|0) > 0){
 if(force){
 // Even if counts are stuck, force completion once deadline hits
 rec.finished = true;
 rec.count = 0;
 } else {
 return;
 }
 }
 if(rec.finalizing){
 console.log(`DELETE: Already finalizing array #${arrId}`);
 return;
 }
 console.log(`DELETE: Starting finalization for array #${arrId}`);
 rec.finalizing = true;
 clearDeletionDeadline(rec);
 pendingDatafallDeletes.set(key, rec);
 discardDeleteEffectsForArray(arrId);
 const finalizeNow = ()=>{
 console.log(`DELETE: Final cleanup for array #${arrId}`);
 pendingDatafallDeletes.delete(key);
 unmarkArrayDeleting(arrId);
 try{ Actions.deleteArray(arrId); }catch{}
 releaseDeletionInteractions();
 };
 const store = Store.getState();
 const arr = store.arrays?.[arrId] ?? store.arrays?.[key];
 if(arr && !force){
 console.log(`DELETE: Starting axis fall for array #${arrId}`);
 startAxisFall(arr, finalizeNow);
 } else {
 console.log(`DELETE: Immediate finalization for array #${arrId} (force:${force})`);
 finalizeNow();
 }
 }catch{ unmarkArrayDeleting(arrId); releaseDeletionInteractions(); }
 }

 function makeCharSprite(ch, color = '#ffffff'){
 const canvas = document.createElement('canvas');
 const ctx = canvas.getContext('2d');
 const fs = 18, pad = 4;
 ctx.font = `600 ${fs}px 'Roboto Mono', monospace`;
 const w = Math.max(12, Math.ceil(ctx.measureText(ch).width) + pad*2);
 const h = fs + pad*2;
 canvas.width = w; canvas.height = h;
 ctx.clearRect(0,0,w,h);
 ctx.fillStyle = cssColor(color);
 ctx.font = `600 ${fs}px 'Roboto Mono', monospace`;
 ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
 ctx.fillText(ch, w/2, h/2);
 const tex = new THREE.CanvasTexture(canvas);
 tex.colorSpace = THREE.SRGBColorSpace;
 const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false, opacity: 1 });
 const spr = new THREE.Sprite(mat);
 spr.scale.set(0.25, 0.18, 1);
 spr.renderOrder = 2100;
 return spr;
 }
 function spawnCellDatafallAt(position, cell, parentArrId){
 const arrKey = normalizeArrayId(parentArrId);
 
 // HIDE the original cell AS this animation starts - this is the magic moment!
 try{
 if(cell && cell.x != null && cell.y != null && cell.z != null){
 const arr = Store.getState().arrays[parentArrId];
 if(arr){
 // Hide value sprite immediately
 const spriteKey = `${parentArrId}:${cell.x},${cell.y},${cell.z}`;
 const sprite = valueSprites.get(spriteKey);
 if(sprite) sprite.visible = false;
 
 // Find and hide this cell in chunk's index2cell system
 Object.values(arr.chunks||{}).forEach(chunk=>{
 try{
 if(!chunk.index2cell) return;
 const idx = chunk.index2cell.findIndex(c => c && c.x === cell.x && c.y === cell.y && c.z === cell.z);
 if(idx >= 0){
 const zeroMatrix = new THREE.Matrix4();
 zeroMatrix.makeScale(0, 0, 0); // Completely invisible
 
 // Hide in LOD1 instanced mesh
 if(chunk.meshLOD1 && chunk.meshLOD1.isInstancedMesh){
 chunk.meshLOD1.setMatrixAt(idx, zeroMatrix);
 chunk.meshLOD1.instanceMatrix.needsUpdate = true;
 }
 // Hide in LOD2 instanced mesh
 if(chunk.meshLOD2 && chunk.meshLOD2.isInstancedMesh){
 chunk.meshLOD2.setMatrixAt(idx, zeroMatrix);
 chunk.meshLOD2.instanceMatrix.needsUpdate = true;
 }
 // Hide in shell instanced mesh
 if(chunk.meshShell && chunk.meshShell.isInstancedMesh){
 chunk.meshShell.setMatrixAt(idx, zeroMatrix);
 chunk.meshShell.instanceMatrix.needsUpdate = true;
 }
 }
 }catch{}
 });
 
 // Also hide in legacy chunkMeshes system
 chunkMeshes.forEach((mesh, key)=>{
 if(String(key).startsWith(`${parentArrId}:`)){
 try{
 const chunkKey = key.split(':')[1];
 const chunk = arr.chunks[chunkKey];
 if(chunk && chunk.cells){
 const cellIdx = chunk.cells.findIndex(c => c.x === cell.x && c.y === cell.y && c.z === cell.z);
 if(cellIdx >= 0){
 const m = new THREE.Matrix4();
 m.makeScale(0, 0, 0);
 mesh.setMatrixAt(cellIdx, m);
 mesh.instanceMatrix.needsUpdate = true;
 }
 }
 }catch{}
 }
 });
 }
 }
 }catch{}
 
 try{
 try{
 const rec = pendingDatafallDeletes.get(arrKey) || {count:0, finished:false, finalizing:false, deadlineTimer:null};
 markArrayDeleting(parentArrId);
 rec.count = (rec.count||0) + 1;
 rec.arrId = rec.arrId ?? parentArrId;
 rec.startedAt = rec.startedAt ?? nowMs();
 rec.lastActive = nowMs();
 pendingDatafallDeletes.set(arrKey, rec);
 scheduleDeletionDeadline(parentArrId);
 }catch{}
 const group = new THREE.Group();
 group.userData.kind='microCollapse';
 scene.add(group);
 const colorHex = cssColor(colorForCellVisual(parentArrId, cell));
 const coreColor = new THREE.Color(colorHex);
 const shellColor = coreColor.clone().lerp(new THREE.Color(0xffffff), 0.45);
 const coreMat = new THREE.MeshBasicMaterial({ color: coreColor, transparent:true, opacity:0.95, depthTest:true, depthWrite:true });
 const shellMat = new THREE.MeshBasicMaterial({ color: shellColor, transparent:true, opacity:0.38, depthTest:true, depthWrite:false });
 const core = new THREE.Mesh(GEO_VOXEL, coreMat);
 const shell = new THREE.Mesh(GEO_SHELL, shellMat);
 core.renderOrder = 2100;
 shell.renderOrder = 2101;
 group.add(core);
 group.add(shell);
 
 // Add the cell's value sprite to the shrinking group so text shrinks with cell
 const spriteKey = `${parentArrId}:${cell?.x},${cell?.y},${cell?.z}`;
 const originalSprite = valueSprites.get(spriteKey);
 if(originalSprite && cell){
 // Detach from parent and add to this animation group
 const spriteWorldPos = new THREE.Vector3();
 originalSprite.getWorldPosition(spriteWorldPos);
 originalSprite.parent?.remove(originalSprite);
 originalSprite.position.set(0, 0, 0.6); // Position relative to cell center
 group.add(originalSprite);
 originalSprite.visible = true; // Make visible since it's now part of the animation
 }
 
 group.position.copy(position);
 const dur=420; let t0;
 const step=(ts)=>{
 if(t0==null) t0=ts;
 const u=Math.min(1,(ts-t0)/dur);
 const e=1-Math.pow(1-u,4);
 const scale = 1 - (0.55*e);
 core.scale.setScalar(Math.max(0.0001, scale));
 shell.scale.setScalar(Math.max(0.0001, scale * 1.04));
 core.material.opacity = 0.95*(1-e)+0.08;
 shell.material.opacity = 0.38*(1-e)+0.05;
 if(u<1){
 requestAnimationFrame(step);
 } else {
 try{
 scene.remove(group);
 core.material?.dispose?.();
 shell.material?.dispose?.();
 }catch{}
 const hasContent = !!(cell && ((cell.formula && String(cell.formula).length) || (cell.value!=='' && cell.value!==null && cell.value!==undefined)));
 if(!hasContent){
 try{
 // Clean up sprite even for empty cells
 if(cell && cell.x != null && cell.y != null && cell.z != null){
 const spriteKey = `${parentArrId}:${cell.x},${cell.y},${cell.z}`;
 const sprite = valueSprites.get(spriteKey);
 if(sprite){
 try{ unmarkBillboard(sprite); }catch{}
 sprite.parent?.remove(sprite);
 sprite.material?.map?.dispose?.();
 sprite.material?.dispose?.();
 valueSprites.delete(spriteKey);
 }
 }
 const rec = pendingDatafallDeletes.get(arrKey);
 if(rec){
 rec.count = Math.max(0, (rec.count||0) - 1);
 rec.arrId = rec.arrId ?? parentArrId;
 rec.lastActive = nowMs();
 pendingDatafallDeletes.set(arrKey, rec);
 maybeFinalizeDeletion(parentArrId);
 }
 }catch{}
 return;
 }
 const effGroup=new THREE.Group();
 scene.add(effGroup);
 const hasFormula = !!(cell && typeof cell.formula === 'string' && cell.formula.trim().length);
 const displayText = hasFormula ? String(cell.formula) : String(cell?.value ?? '');
 const baseToken = hasFormula ? { tokenKind:'formula', color: DATAFALL_COLORS.syntax } : classifyRawValue(displayText);
 const baseColor = baseToken.color || DATAFALL_COLORS.syntax;
 const sp = makeCharSprite(displayText, baseColor);
 sp.position.copy(position);
 effGroup.add(sp);
 const vel = new THREE.Vector3(0,0.022,0);
 deleteEffects.push({
 phase:'datafall',
 sourceArrId: parentArrId,
 group:effGroup,
 particles:[{
 kind:'value',
 cell,
 text:displayText,
 sprite:sp,
 vel,
 age:0,
 life:420,
 rot:0,
 color: baseColor,
 tokenKind: baseToken.tokenKind
 }],
 onDone:()=>{
 try{
 // Clean up the value sprite now that animation is complete
 if(cell && cell.x != null && cell.y != null && cell.z != null){
 const spriteKey = `${parentArrId}:${cell.x},${cell.y},${cell.z}`;
 const sprite = valueSprites.get(spriteKey);
 if(sprite){
 try{ unmarkBillboard(sprite); }catch{}
 sprite.parent?.remove(sprite);
 sprite.material?.map?.dispose?.();
 sprite.material?.dispose?.();
 valueSprites.delete(spriteKey);
 }
 }
 const rec = pendingDatafallDeletes.get(arrKey);
 if(rec){
 rec.count = Math.max(0, (rec.count||0) - 1);
 rec.arrId = rec.arrId ?? parentArrId;
 rec.lastActive = nowMs();
 pendingDatafallDeletes.set(arrKey, rec);
 scheduleDeletionDeadline(parentArrId);
 maybeFinalizeDeletion(parentArrId);
 }
 }catch{}
 }
 });
 }
 };
 requestAnimationFrame(step);
 }catch{}
 }
 function startDatafallDelete(arr){
 try{
 // First, ensure meshes exist for animation
 try{
 if(!arr._frame) renderArray(arr);
 Object.values(arr.chunks||{}).forEach(ch=>{
 ch.ensureMesh?.();
 ch.setLOD?.(1);
 rehydrateChunkInstances(arr, ch);
 });
 }catch{}
 
 // Don't hide anything upfront - cells and labels stay visible
 // Each cell will hide AS its individual animation spawns
 // Labels will hide during the final axis fall
 
 // Mark as deleting to prevent any further re-rendering
 arr._deleting = true;
 
 if(!deleteInteractionLock) lockDeletionInteractions();
 const items=[];
 try{
 // Get all cells that exist in chunks (have been rendered)
 const cellsWithMeshes = [];
 Object.values(arr.chunks||{}).forEach(ch=>{
 (ch.cells||[]).forEach(c=>{ cellsWithMeshes.push({x:c.x,y:c.y,z:c.z}); });
 });
 // Also include ALL cells in bounds for complete coverage
 for(let z=0; z<arr.size.z; z++){
 for(let y=0; y<arr.size.y; y++){
 for(let x=0; x<arr.size.x; x++){
 const exists = cellsWithMeshes.some(c=> c.x===x && c.y===y && c.z===z);
 if(!exists) items.push({x,y,z});
 }
 }
 }
 // Merge chunks cells with remaining cells
 items.push(...cellsWithMeshes);
 // Shuffle for random deletion order
 for(let i=items.length-1; i>0; i--){
 const j = Math.floor(Math.random()*(i+1));
 const tmp = items[i];
 items[i] = items[j];
 items[j] = tmp;
 }
 }catch{}
 let idx=0;
 // One cell at a time - timing scaled for magical effect
 const waveSize = 1;
 // Scale timing based on total cells for best feel
 const totalCells = items.length;
 const waveDelay = totalCells <= 20 ? 160 : totalCells <= 100 ? 100 : 60; // Slower for small arrays
 const arrKey = normalizeArrayId(arr.id);
 pendingDatafallDeletes.set(arrKey, {count:0, finished:false, finalizing:false, arrId: arr.id, startedAt: nowMs(), lastActive: nowMs(), deadlineTimer:null});
 markArrayDeleting(arr.id);
 scheduleDeletionDeadline(arr.id);
 if(items.length===0){
 try{
 const rec=pendingDatafallDeletes.get(arrKey);
 if(rec){ rec.finished=true; rec.finishedAt = nowMs(); rec.lastActive = nowMs(); pendingDatafallDeletes.set(arrKey, rec); }
 }catch{}
 scheduleDeletionDeadline(arr.id, 1000);
 maybeFinalizeDeletion(arr.id);
 return;
 }
 const spawnWave=()=>{
 const S=Store.getState();
 if(!S.arrays[arr.id]){
 console.warn('DELETE: Array removed mid-wave, finalizing');
 try{
 const rec=pendingDatafallDeletes.get(arrKey)||{count:0};
 rec.finished=true;
 rec.finishedAt = nowMs();
 rec.arrId = rec.arrId ?? arr.id;
 rec.lastActive = nowMs();
 pendingDatafallDeletes.set(arrKey, rec);
 scheduleDeletionDeadline(arr.id, 500);
 maybeFinalizeDeletion(arr.id);
 }catch{}
 return;
 }
 for(let k=0;k<waveSize && idx<items.length;k++,idx++){
 const c=items[idx];
 let cell=null;
 try{
 cell = Formula.getCell({arrId:arr.id,x:c.x,y:c.y,z:c.z});
 }catch{}
 // Sprite and mesh hiding is now handled inside spawnCellDatafallAt as animation starts
 const pos = cellWorldPos(arr, c.x, c.y, c.z);
 const hasContent = cell && ((cell.formula && String(cell.formula).length) || (cell.value!=='' && cell.value!==null && cell.value!==undefined));
 spawnCellDatafallAt(pos, cell? {...cell, arrId: arr.id, x:c.x, y:c.y, z:c.z } : null, arr.id);
 }
 const waveNum = Math.floor((idx-1) / waveSize) + 1;
 console.log(`DELETE: Wave ${waveNum} complete, processed ${idx}/${items.length} cells`);
 if(idx<items.length){
 setTimeout(spawnWave, waveDelay);
 } else {
 // All cells spawned
 console.log(`DELETE: All ${items.length} cells spawned for array #${arr.id}`);
 setTimeout(()=>{
 try{
 const rec=pendingDatafallDeletes.get(arrKey)||{count:0};
 console.log(`DELETE: Marking finished for array #${arr.id}, pending count: ${rec.count}`);
 rec.finished=true;
 rec.finishedAt = nowMs();
 rec.arrId = rec.arrId ?? arr.id;
 rec.lastActive = nowMs();
 pendingDatafallDeletes.set(arrKey, rec);
 scheduleDeletionDeadline(arr.id, 3000);
 maybeFinalizeDeletion(arr.id);
 }catch{}
 }, 300);
 }
 };
 console.log(`DELETE: Starting wave deletion for array #${arr.id} with ${items.length} cells`);
 spawnWave();
 }catch(e){
 console.warn('startDatafallDelete failed', e);
 releaseDeletionInteractions();
 }
 }

 function updateDeleteEffects(dtMs){
 const grav = 0.004; // gentler gravity to emphasize slow drift cascade
 for(let i = deleteEffects.length - 1; i >= 0; i--){
 const eff = deleteEffects[i];
 eff.t += dtMs;

 // Datafall phase: value -> formula/text chunks -> char codes -> binary bits
 if(eff.phase === 'datafall'){
 const next = [];
 for(let k=0; k<eff.particles.length; k++){
 const pr = eff.particles[k];
 pr.age += dtMs;
 pr.vel.y -= 0.003;
 pr.sprite.position.add(pr.vel);
 pr.sprite.material.opacity = Math.max(0, 1 - Math.pow(pr.age/pr.life, 2));
 if(pr.rot && pr.sprite.material && pr.sprite.material.rotation !== undefined){ pr.sprite.material.rotation += pr.rot; }

 if(pr.age > pr.life){
 const pos = pr.sprite.position.clone();
 try{ unmarkBillboard(pr.sprite); }catch{}
 pr.sprite.parent?.remove(pr.sprite); pr.sprite.material?.map?.dispose?.(); pr.sprite.material?.dispose?.();

 let newTokens = [], nextKind = null;
 try{
 if(pr.kind === 'value'){
 const rawFormula = (pr.cell?.formula && String(pr.cell.formula).trim().startsWith('=')) ? String(pr.cell.formula) : '';
 const rawValue = !rawFormula ? String(pr.cell?.value ?? '') : '';
 if(rawFormula){
 newTokens = tokenizeFormulaForDatafall(rawFormula);
 } else {
 const classified = classifyRawValue(rawValue);
 if(classified.text){ newTokens = [classified]; }
 }
 nextKind = newTokens.length ? 'formula_chunk' : null;
 } else if(pr.kind === 'formula_chunk'){
 const text = String(pr.text ?? '');
 const tokenKind = pr.tokenKind || 'syntax';
 const trimmed = text.trim();
 if(trimmed===''){ nextKind = null; }
 else if(tokenKind === 'number' || (!Number.isNaN(Number(trimmed)) && trimmed!=='')){
 // Numbers go directly to binary in blue
 const n = parseInt(trimmed, 10) || 0;
 const bin = Math.abs(n).toString(2);
 const bits = bin.length ? Array.from(bin) : ['0'];
 newTokens = bits.map(bit=> ({ text: bit, tokenKind: 'binary_bit', color: DATAFALL_COLORS.binary }));
 nextKind = 'binary_bit';
 } else {
 // Strings and black text (syntax/function/punctuation) go to unicode in purple
 const plain = tokenKind === 'string' ? text.replace(/^\"|\"$/g,'') : text;
 const chars = Array.from(plain);
 newTokens = chars.map(ch=>{
 const code = ch.codePointAt(0);
 return { text: code != null ? String(code) : '', tokenKind: 'char_code', color: DATAFALL_COLORS.unicode, code, sourceChar: ch };
 }).filter(tok=> tok.text !== '');
 nextKind = 'char_code';
 }
 } else if(pr.kind === 'char_code'){
 // Unicode codes (purple) transform to binary in blue
 const n = (typeof pr.code === 'number' && Number.isFinite(pr.code)) ? pr.code : parseInt(pr.text ?? '0', 10);
 if(!Number.isFinite(n)) { continue; }
 const bin = Math.abs(n).toString(2) || '0';
 newTokens = Array.from(bin).map(bit=> ({ text: bit, tokenKind: 'binary_bit', color: DATAFALL_COLORS.binary }));
 nextKind = 'binary_bit';
 } else { continue; }
 }catch{ continue; }

 if(!nextKind || !newTokens.length){ continue; }
 newTokens.forEach(token=>{
 const label = String(token.text ?? '');
 if(label==='') return;
 const color = token.color || pr.color || DATAFALL_COLORS.syntax;
 const sp = makeCharSprite(label, color);
 sp.position.copy(pos).add(new THREE.Vector3((Math.random()-0.5)*0.2, (Math.random())*0.2, (Math.random()-0.5)*0.2));
 const vel = new THREE.Vector3((Math.random()-0.5)*0.015, (Math.random())*0.02, (Math.random()-0.5)*0.015);
 eff.group.add(sp);
 const baseLife = nextKind === 'binary_bit'
 ? 1000 + Math.random()*500
 : nextKind === 'char_code'
 ? 1100 + Math.random()*500
 : 900 + Math.random()*600;
 next.push({
 kind: nextKind,
 text: label,
 code: token.code !== undefined ? token.code : parseInt(label,10),
 sprite: sp,
 vel,
 age: 0,
 life: baseLife,
 rot:(Math.random()-0.5)*0.05,
 color,
 tokenKind: token.tokenKind || pr.tokenKind,
 sourceChar: token.sourceChar || pr.sourceChar
 });
 });
 } else {
 next.push(pr);
 }
 }
 eff.particles = next;
 if(eff.particles.length===0){ try{ const cb=eff.onDone; eff.group.parent?.remove(eff.group); if(typeof cb==='function') cb(); }catch{} deleteEffects.splice(i,1); }
 continue;
 }

 if(eff.phase === 'axisFall'){
 const nextLabels = [];
 for(let k=0; k<eff.labels.length; k++){
 const lbl = eff.labels[k];
 lbl.age += dtMs;
 lbl.vel.y -= 0.0025;
 lbl.mesh.position.add(lbl.vel);
 if(lbl.mesh.rotation){
 lbl.mesh.rotation.x += lbl.rot.x;
 lbl.mesh.rotation.y += lbl.rot.y;
 lbl.mesh.rotation.z += lbl.rot.z;
 }
 if(lbl.mesh.material && typeof lbl.mesh.material.opacity==='number'){
 lbl.mesh.material.opacity = Math.max(0, lbl.mesh.material.opacity - 0.01);
 }
 if(lbl.age < lbl.life){
 nextLabels.push(lbl);
 } else {
 try{ lbl.mesh.parent?.remove(lbl.mesh); }catch{}
 }
 }
 eff.labels = nextLabels;
 if(nextLabels.length===0){
 try{ eff.onDone?.(); }catch{}
 deleteEffects.splice(i,1);
 }
 continue;
 }

 // OLD HOVER/EXPLODE PHASE REMOVED - only datafall and axisFall are used
 if(eff.phase === 'hover' || eff.phase === 'explode'){
 // Cleanup and remove old unused effect immediately
 try{
 if(eff.group?.parent) eff.group.parent.remove(eff.group);
 if(eff.clones){
 eff.clones.forEach(c=>{
 try{
 if(c.sprite){
 c.sprite.parent?.remove(c.sprite);
 c.sprite.material?.map?.dispose?.();
 c.sprite.material?.dispose?.();
 }
 }catch{}
 });
 }
 if(eff.particles){
 eff.particles.forEach(pr=>{
 try{
 if(pr.sprite){
 try{ unmarkBillboard(pr.sprite); }catch{}
 pr.sprite.parent?.remove(pr.sprite);
 pr.sprite.material?.map?.dispose?.();
 pr.sprite.material?.dispose?.();
 }
 }catch{}
 });
 }
 }catch{}
 deleteEffects.splice(i, 1);
 continue;
 }
 }

 if(deleteInteractionLock){
 const now = nowMs();
 const finalizeIds = [];
 pendingDatafallDeletes.forEach((rec, key)=>{
 if(!rec) return;
 if(rec.finalizing) return;
 const arrId = rec.arrId ?? Number(key);
 if(rec.finished && ((rec.count|0) <= 0)){
 if(Number.isFinite(arrId)){ finalizeIds.push(arrId); }
 else {
 try{ releaseDeletionInteractions(); }catch{}
 clearDeletionDeadline(rec);
 pendingDatafallDeletes.delete(key);
 unmarkArrayDeleting(rec?.arrId ?? key);
 }
 return;
 }
 if(rec.finished){
 const idleSince = rec.finishedAt ?? rec.lastActive ?? rec.startedAt ?? now;
 if(now - idleSince > 2400){
 rec.count = 0;
 rec.lastActive = now;
 pendingDatafallDeletes.set(key, rec);
 if(Number.isFinite(arrId)){ finalizeIds.push(arrId); }
 else {
 try{ releaseDeletionInteractions(); }catch{}
 clearDeletionDeadline(rec);
 pendingDatafallDeletes.delete(key);
 unmarkArrayDeleting(rec?.arrId ?? key);
 }
 }
 }
 });
 finalizeIds.forEach(id=>{
 try{ maybeFinalizeDeletion(id); }catch{}
 });
 if(!pendingDatafallDeletes.size && !deleteEffects.length){
 try{ releaseDeletionInteractions(); }catch{}
 }
 }
}

 function removeArrayGraphics(arr){
 try{
 // Remove layer meshes (all types + edge overlays)
 for(let z=0; z<arr.size.z; z++){
 ['empty','ghost','filled','formula'].forEach(type=>{
 const key = `${arr.id}:${z}:${type}`;
 const rec = layerMeshes.get(key);
 if(rec){
 rec.mesh.parent?.remove(rec.mesh);
 rec.mesh.geometry?.dispose?.();
 rec.mesh.material?.dispose?.();
 layerMeshes.delete(key);
 }
 const key2 = `${key}:edges`;
 const rec2 = layerMeshes.get(key2);
 if(rec2){
 rec2.mesh.parent?.remove(rec2.mesh);
 rec2.mesh.geometry?.dispose?.();
 rec2.mesh.material?.dispose?.();
 layerMeshes.delete(key2);
 }
 });
 }
 // Remove legacy chunk meshes
 [...chunkMeshes.keys()].forEach(k=>{
 if(String(k).startsWith(`${arr.id}:`)){
 const mesh = chunkMeshes.get(k);
 if(mesh){
 scene.remove(mesh);
 mesh.geometry?.dispose?.();
 mesh.material?.dispose?.();
 }
 chunkMeshes.delete(k);
 }
 });
 // Remove labels/grab
 (arr.labels||[]).forEach(s=>{
 try{
 if(s?.userData?.billboard) unmarkBillboard(s);
 s.parent?.remove(s);
 s.material?.map?.dispose?.();
 s.material?.dispose?.();
 }catch{}
 });
 arr.labels = [];

 // Remove frame
 if(arr._frame){
 try{
 scene.remove(arr._frame);
 arr._frame.traverse(obj=>{
 if(obj.isMesh){
 obj.geometry?.dispose?.();
 obj.material?.dispose?.();
 }
 });
 }catch{}
 arr._frame = null;
 }
 // Reset transforms/meshes for clean rebuild
 try{ arr.rotationQuat = arr.rotationQuat || [0,0,0,1]; }catch{}
 try{ Object.values(arr.chunks||{}).forEach(ch=>{ ch.meshLOD1=null; ch.meshLOD2=null; ch.currentLOD=-1; ch._dirty=true; }); }catch{}

 // Remove colliders
 try{ clearColliders(arr); }catch{}

 // Remove value sprites for this array
 [...valueSprites.keys()].forEach(key=>{
 if(key.startsWith(`${arr.id}:`)){
 const sp = valueSprites.get(key);
 if(sp){
 sp.parent?.remove(sp);
 sp.material?.map?.dispose?.();
 sp.material?.dispose?.();
 }
 valueSprites.delete(key);
 }
 });
 }catch(e){ console.warn('removeArrayGraphics failed', e); }
 }

 function reconcileAllArrays(){
 console.log('Reconciling all arrays...');
 Object.values(Store.getState().arrays).forEach(arr => {
 console.log(`Reconciling array #${arr.id} "${arr.name}"`);
 arr._layersRendered = false; // Force re-render
 // Ensure each chunk's mesh reflects current content immediately
 try{ Object.values(arr.chunks||{}).forEach(ch=> ch._dirty=true); }catch{}
 renderArray(arr);
 // Apply visibility after render (hide reserved arrays like Mainframe)
 try{ syncVisibility(arr); }catch{}
 });
 }

 function removeConnection(anchor){
 const key = aKey(anchor);
 if(connections.has(key)){
 const connection = connections.get(key);
 if(connection.visual){
 scene.remove(connection.visual);
 try{ connection.visual.geometry?.dispose?.(); }catch{}
 try{
 const mat = connection.visual.material;
 if(Array.isArray(mat)) mat.forEach(m=>m?.dispose?.());
 else mat?.dispose?.();
 }catch{}
 }
 connections.delete(key);
 }
 }

 function locateArrayCollision(worldVec, {preferSelection=true}={}){
 if(!worldVec) return null;
 const state = Store.getState();
 const arrays = state.arrays || {};
 const sel = state.selection;
 const debugMode = !!state.scene?.physicsDebugAll;
 const formulaHostedSet = getFormulaActiveArrayIds();
 const consider = (arr)=>{
 if(!arr || arr._deleting) return null;
 let coord;
 try{ coord = worldToCellCoord(arr, worldVec); }catch{ return null; }
 if(!withinBounds(arr, coord)) return null;
 let center = null;
 try{ center = cellWorldPos(arr, coord.x, coord.y, coord.z); }catch{}
 if(!center){
 try{ center = worldPos(arr, coord.x, coord.y, coord.z); }catch{}
 }
 if(!center) return null;
 const distSq = center.distanceToSquared(worldVec);
 const cell = Formula.getCell({arrId:arr.id,x:coord.x,y:coord.y,z:coord.z});
 const collisionMode = determineCollisionMode(arr, cell, { debugMode, formulaHostedSet });
 return { arr, coord, cell, center, distSq, collisionMode };
 };

 if(preferSelection && sel?.arrayId){
 const preferred = consider(arrays[sel.arrayId]);
 if(preferred) return preferred;
 }

 let best = null;
 Object.values(arrays).forEach(arr=>{
 const hit = consider(arr);
 if(!hit) return;
 if(!best || hit.distSq < best.distSq) best = hit;
 });
 return best;
 }

 function exitPhysicsOnNonEnabledArray(hit){
 if(!hit || !hit.arr) return false;
 const arr = hit.arr;
 // In debug mode, treat all arrays as physics enabled
 const state = Store.getState();
 const sceneState = state.scene;
 const debugMode = !!sceneState?.physicsDebugAll;
 const formulaHostedSet = getFormulaActiveArrayIds();
 const effectiveMode = determineCollisionMode(arr, hit.cell, { debugMode, formulaHostedSet });
 const arrPhysicsEnabled = !!arr?.params?.physics?.enabled;
 console.log(`[PHYSICS] exitPhysicsOnNonEnabledArray ENTRY: array=${arr.id}`);
 console.log(`[PHYSICS] scene.physicsDebugAll=${sceneState?.physicsDebugAll}`);
 console.log(`[PHYSICS] debugMode=${debugMode}`);
 console.log(`[PHYSICS] arr.collisionMode=${arr?.collisionMode}`);
 console.log(`[PHYSICS] effectiveCollisionMode=${effectiveMode}`);
 console.log(`[PHYSICS] arr.params.physics.enabled=${arrPhysicsEnabled}`);
 console.log(`[PHYSICS] arr.params.physics.__debugOverride=${!!arr?.params?.physics?.__debugOverride}`);

 if(debugMode){
 console.log('[PHYSICS] ? Debug mode ACTIVE - NOT exiting physics for array', arr.id);
 return false;
 }
 if(effectiveMode === 'physics'){
 console.log('[PHYSICS] ? Array is treated as physics-active - NOT exiting physics for array', arr.id);
 return false;
 }
 console.log('[PHYSICS] ? EXITING PHYSICS MODE for array', arr.id);
 try{
 Actions.setSelection(arr.id, {x:hit.coord.x, y:hit.coord.y, z:hit.coord.z}, null, '3d');
 }catch{}
 try{ centerOnArray(arr); }catch{}
 const physicsActive = !!Store.getState().scene?.physics;
 if(physicsActive){
 try{
 const res = togglePhysicsMode();
 if(res && typeof res.catch === 'function'){
 res.catch(err=>console.warn('[PHYSICS] Exit auto-toggle failed', err));
 }
 }catch(e){ console.warn('[PHYSICS] Exit auto-toggle threw', e); }
 }
 return true;
 }

 function cancelLandingCellAnimation(){
 if(landingCellAnim && typeof landingCellAnim.cancel === 'function'){
 try{ landingCellAnim.cancel(); }catch{}
 }
 landingCellAnim = null;
 landingCellKey = null;
 }

 function startLandingCellBounce(arr, coord, strength=1){
 if(!arr || !coord) return;
 const key = `${arr.id}:${coord.x},${coord.y},${coord.z}`;
 if(landingCellAnim){
 if(landingCellAnim.key === key){ landingCellAnim.cancel(); }
 else { landingCellAnim.cancel(); }
 }
 const clampedStrength = Math.max(0.3, Math.min(Number(strength)||1, 2.5));
 const records = [];
 const pushRecord = (mesh, idx)=>{
 if(!mesh || !Number.isInteger(idx) || idx < 0) return;
 if(idx >= (mesh.count ?? Infinity)) return;
 try{
 const base = new THREE.Matrix4();
 mesh.getMatrixAt(idx, base);
 records.push({ mesh, idx, base });
 }catch{}
 };
 const useChunks = !!(ChunkManager && ChunkManager.enabled);
 if(useChunks){
 const chunkId = keyChunk(...Object.values(chunkOf(coord.x, coord.y, coord.z)));
 const ch = arr.chunks?.[chunkId];
 if(ch){
 let idx = -1;
 if(ch.cellIndexMap && typeof ch.cellIndexMap.get === 'function'){
 const maybeIdx = ch.cellIndexMap.get(`${coord.x},${coord.y},${coord.z}`);
 if(Number.isInteger(maybeIdx)) idx = maybeIdx;
 }
 if(idx < 0 && Array.isArray(ch.index2cell)){
 idx = ch.index2cell.findIndex(c=>c && c.x===coord.x && c.y===coord.y && c.z===coord.z);
 }
 if(idx >= 0){
 pushRecord(ch.meshLOD1, idx);
 pushRecord(ch.meshShell, idx);
 }
 }
 } else {
 const z = coord.z|0;
 const types = ['filled','formula'];
 types.forEach(tp=>{
 const rec = layerMeshes.get(`${arr.id}:${z}:${tp}`);
 if(rec && rec.mesh && Array.isArray(rec.index2cell)){
 const idx = rec.index2cell.findIndex(c=>c && c.x===coord.x && c.y===coord.y && c.z===coord.z);
 pushRecord(rec.mesh, idx);
 }
 const er = layerMeshes.get(`${arr.id}:${z}:${tp}:edges`);
 if(er && er.mesh && Array.isArray(er.index2cell)){
 const idx = er.index2cell.findIndex(c=>c && c.x===coord.x && c.y===coord.y && c.z===coord.z);
 pushRecord(er.mesh, idx);
 }
 });
 }
 if(!records.length){
 landingCellAnim = null;
 landingCellKey = key;
 if(surfaceBounceState.key === key){
 surfaceBounceState = { key:null, depression:0, intensity:1 };
 }
 return;
 }
 const duration = 240;
 let start = null;
 let cancelled = false;
 let frameId = null;
 const scaleMatrix = new THREE.Matrix4();
 const maxSquashDelta = Math.min(0.35 * clampedStrength, 0.65);
 const expandDelta = Math.min(0.3 * clampedStrength, 0.55);
 const overshootAmount = Math.min(0.03 * clampedStrength, 0.06);
 const squashRecoveryDelta = Math.min(0.38 * clampedStrength, 0.6);
 const expandOvershoot = Math.min(0.02 * clampedStrength, 0.08);
 const baseMinSquash = 1 - maxSquashDelta;
 const squashRecoveryTarget = Math.min(1 + overshootAmount, baseMinSquash + squashRecoveryDelta);
 const expandPeak = 1 + expandDelta;
 const expandEnd = 1 - expandOvershoot;

 const restore = ()=>{
 records.forEach(rec=>{
 try{
 rec.mesh.setMatrixAt(rec.idx, rec.base);
 rec.mesh.instanceMatrix.needsUpdate = true;
 }catch{}
 });
 needsRender = true;
 if(surfaceBounceState.key === key){
 surfaceBounceState = { key:null, depression:0, intensity:1 };
 }
 };

 const applyScale = (sx, sy, sz)=>{
 scaleMatrix.identity();
 scaleMatrix.makeScale(sx, sy, sz);
 records.forEach(rec=>{
 try{
 const next = rec.base.clone().multiply(scaleMatrix);
 rec.mesh.setMatrixAt(rec.idx, next);
 rec.mesh.instanceMatrix.needsUpdate = true;
 }catch{}
 });
 needsRender = true;
 surfaceBounceState = {
 key,
 depression: Math.max(0, 1 - Math.min(sy, 1)),
 intensity: clampedStrength
 };
 };

 const step = (ts)=>{
 if(cancelled){ restore(); return; }
 if(start === null) start = ts;
 const t = Math.min(1, (ts - start) / duration);
 let squashY, stretchXZ;
 if(t < 0.3){
 const impactT = t / 0.3;
 squashY = 1 - maxSquashDelta * impactT;
 stretchXZ = 1 + expandDelta * impactT;
 } else {
 const recoveryT = Math.min(1, Math.max(0, (t - 0.3) / 0.7));
 const easeOut = 1 - Math.pow(1 - recoveryT, 3);
 squashY = baseMinSquash + (squashRecoveryTarget - baseMinSquash) * easeOut;
 stretchXZ = expandPeak + (expandEnd - expandPeak) * easeOut;
 if(recoveryT > 0.85){
 const overshootT = (recoveryT - 0.85) / 0.15;
 const clamped = Math.min(1, Math.max(0, overshootT));
 squashY += overshootAmount * Math.sin(clamped * Math.PI);
 }
 }
 applyScale(stretchXZ, squashY, stretchXZ);
 if(t < 1){
 frameId = requestAnimationFrame(step);
 } else {
 restore();
 landingCellAnim = null;
 }
 };

 const cancel = ()=>{
 if(cancelled) return;
 cancelled = true;
 if(frameId != null) cancelAnimationFrame(frameId);
 restore();
 landingCellAnim = null;
 };

 landingCellKey = key;
 surfaceBounceState = { key, depression:0, intensity: clampedStrength };
 landingCellAnim = { key, cancel };
 frameId = requestAnimationFrame(step);
 }

function parseBounceMeta(meta){
 if(!meta) return { walk:0, land:0 };
 const normalized = normalizeMetaKeys(meta) || {};
 let raw = normalized.bounceConfig ?? normalized.bounce ?? null;
 if(typeof raw === 'string'){
 try{
 raw = JSON.parse(raw);
 }catch{
 const parts = String(raw)
 .split(/[;,\s]+/)
 .map(part=>part.trim())
 .filter(Boolean);
 if(parts.length){
 raw = {};
 if(parts.length === 1){
 raw.land = parts[0];
 } else {
 raw.walk = parts[0];
 raw.land = parts[1];
 }
 }
 }
 }
 const cfg = { walk:0, land:0 };
 const assign = (value, key)=>{
 if(value === undefined || value === null) return;
 const num = Number(value);
 if(Number.isFinite(num) && num > 0){
 cfg[key] = Math.max(0, num);
 }
 };
 if(raw && typeof raw === 'object'){
 if(Array.isArray(raw)){
 assign(raw[0], 'walk');
 assign(raw[1], 'land');
 } else {
 assign(raw.walk ?? raw.onWalk, 'walk');
 assign(raw.land ?? raw.onLand, 'land');
 }
 } else {
 assign(raw, 'land');
 }
 return cfg;
 }

 function bounceIntensityFromHeight(height){
 const h = Math.max(0, Number(height) || 0);
 return Math.max(0.3, Math.min(1 + Math.min(h, 4) * 0.35, 2.5));
 }

 function applyBounceImpulse(height, mode='land'){
 if(!playerBody || !rapierWorld) return false;
 const h = Math.max(0, Number(height) || 0);
 if(h <= 0) return false;
 let gravityMag = 20;
 try{
 const gy = rapierWorld.gravity?.y;
 if(Number.isFinite(gy)) gravityMag = Math.max(0.001, Math.abs(gy));
 }catch{}
 const bounceVel = Math.sqrt(Math.max(0, 2 * gravityMag * h));
 if(!Number.isFinite(bounceVel) || bounceVel <= 0.05) return false;
 try{
 const currentVel = playerBody.linvel();
 if(mode === 'walk' && currentVel.y > 0.6) return false;
 if(mode === 'walk' && currentVel.y > bounceVel) return false;
 playerBody.setLinvel({ x: currentVel.x, y: bounceVel, z: currentVel.z }, true);
 jumpVelocity = bounceVel;
 wasGroundedLastFrame = false;
 return true;
 }catch(err){
 console.warn('Bounce impulse failed', err);
 }
 return false;
 }

 function triggerBounceFromHit(mode, hit, height){
 if(!hit || !hit.arr || !hit.coord) return;
 const h = Math.max(0, Number(height) || 0);
 if(h <= 0) return;
 const intensity = bounceIntensityFromHeight(h);
 try{ startLandingCellBounce(hit.arr, hit.coord, intensity); }catch{}
 const applied = applyBounceImpulse(h, mode);
 if(applied){
  landingSquashTime = Math.max(landingSquashTime, 1);
  if(h >= BOUNCE_GAG_THRESHOLD){
   startBounceGag(h);
  }
 } else {
  landingSquashTime = Math.max(landingSquashTime || 0, 1);
 }
}

 function triggerTouchHandlers(){
 try{
 const world = new THREE.Vector3(cachedPlayerPos.x, cachedPlayerPos.y, cachedPlayerPos.z);
 const hit = locateArrayCollision(world);
 if(!hit){ lastTouchKey=null; return; }
 const debugMode = !!Store.getState().scene?.physicsDebugAll;
 if(!debugMode && hit.collisionMode !== 'physics'){ lastTouchKey=null; return; }
 const key = `${hit.arr.id}:${hit.coord.x},${hit.coord.y},${hit.coord.z}`;
 // Removed automatic exit - physics mode should work on any array
 if(key===lastTouchKey) return;
 lastTouchKey = key;
 const cell = hit.cell ?? Formula.getCell({arrId:hit.arr.id,x:hit.coord.x,y:hit.coord.y,z:hit.coord.z});
 const bounceCfg = parseBounceMeta(cell?.meta);
 if(bounceCfg.walk > 0 && nowMs() >= skipWalkBounceUntil){
 triggerBounceFromHit('walk', hit, bounceCfg.walk);
 }
 const action = getMetaAction(cell?.meta, 'on_touch');
 if(action){ executeActionFormula({arrId:hit.arr.id,x:hit.coord.x,y:hit.coord.y,z:hit.coord.z}, action, 'touch'); }
 }catch(err){ console.warn('touch handler failed', err); }
 }

 function triggerLandHandler(){
 try{
 const world = new THREE.Vector3(cachedPlayerPos.x, cachedPlayerPos.y - 0.6, cachedPlayerPos.z);
 const hit = locateArrayCollision(world);
 if(!hit){ lastLandKey=null; cancelLandingCellAnimation(); return; }
 const key = `${hit.arr.id}:${hit.coord.x},${hit.coord.y},${hit.coord.z}`;
 if(key===lastLandKey) return;
 const debugMode = !!Store.getState().scene?.physicsDebugAll;
 if(hit.collisionMode !== 'physics' && !debugMode){
 lastLandKey = key;
 exitPhysicsOnNonEnabledArray(hit);
 cancelLandingCellAnimation();
 return;
 }
 lastLandKey = key;
 const cell = hit.cell ?? Formula.getCell({arrId:hit.arr.id,x:hit.coord.x,y:hit.coord.y,z:hit.coord.z});
 const bounceCfg = parseBounceMeta(cell?.meta);
 const landHeight = bounceCfg.land || 0;
 if(landHeight > 0){
 triggerBounceFromHit('land', hit, landHeight);
 skipWalkBounceUntil = Math.max(skipWalkBounceUntil, nowMs() + 180);
 } else {
 try{ startLandingCellBounce(hit.arr, hit.coord, 1); }catch{}
 }
 resetJumpBudget(hit.arr);
 // Removed automatic exit - physics mode should work on any array
 const action = getMetaAction(cell?.meta, 'on_land');
 if(action){ executeActionFormula({arrId:hit.arr.id,x:hit.coord.x,y:hit.coord.y,z:hit.coord.z}, action, 'land'); }
 }catch(err){ console.warn('land handler failed', err); }
 }

 function addConnection(anchor, ref1, ref2, options={}){
 removeConnection(anchor); // Clear any existing line from this anchor

 const r1 = { ...ref1, arrId: ref1.arrId ?? anchor.arrId };
 const r2 = { ...ref2, arrId: ref2.arrId ?? anchor.arrId };
 const arr1 = Store.getState().arrays[r1.arrId];
 const arr2 = Store.getState().arrays[r2.arrId];
 if(!arr1 || !arr2) return;

 const start = worldPos(arr1, r1.x, r1.y, r1.z);
 const end = worldPos(arr2, r2.x, r2.y, r2.z);

 const style = options.style ? String(options.style).toLowerCase() : '';
 const mode = (options.dimensionMode || 'line').toLowerCase();
 const dimensionExplicit = !!options.dimensionExplicit;
 const dir = new THREE.Vector3().subVectors(end, start);
 const length = Math.max(0.0001, dir.length());
 const dirNorm = length > 0.0001 ? dir.clone().divideScalar(length) : new THREE.Vector3(1,0,0);
 const center = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
 const colorMap = {
 warn: 0xf97316,
 danger: 0xef4444,
 safe: 0x22c55e,
 info: 0x38bdf8
 };
 const color = colorMap[style] || COLORS.grab;
 let visual;

 if(mode === 'platform' || mode === 'grind'){
 const thickness = mode === 'grind' ? 0.18 : 0.2;
 const width = mode === 'grind' ? 0.35 : 1.1;
 const geo = new THREE.BoxGeometry(1, thickness, width);
 const mat = new THREE.MeshStandardMaterial({ color, metalness:0.15, roughness:0.55 });
 visual = new THREE.Mesh(geo, mat);
 visual.castShadow = true;
 visual.receiveShadow = true;
 const axis = new THREE.Vector3(1,0,0);
 const quat = new THREE.Quaternion().setFromUnitVectors(axis, dirNorm.clone());
 visual.quaternion.copy(quat);
 visual.position.copy(center);
 visual.scale.set(length, 1, 1);
 } else if(mode === 'zipline'){
 const geo = new THREE.CylinderGeometry(0.05, 0.05, 1, 10);
 const mat = new THREE.MeshBasicMaterial({ color });
 visual = new THREE.Mesh(geo, mat);
 const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,1,0), dirNorm.clone());
 visual.quaternion.copy(quat);
 visual.position.copy(center);
 visual.scale.set(1, length, 1);
 } else {
 const geometry = new THREE.BufferGeometry().setFromPoints([start, end]);
 const material = new THREE.LineBasicMaterial({ color, linewidth: 2 });
 visual = new THREE.Line(geometry, material);
 visual.renderOrder = 100;
 }

 visual.frustumCulled = false;
 scene.add(visual);
 connections.set(aKey(anchor), {
 visual,
 line: visual,
 start,
 end,
 anchor: {...anchor},
 ref1: r1,
 ref2: r2,
 mode,
 style,
 length,
 color,
 dimensionExplicit
 });
 }

 function createArraySnapshot(arr) {
 const geometries = [];
 // Iterate through all VISIBLE layer meshes of the source array
 layerMeshes.forEach((rec, key) => {
 if (key.startsWith(`${arr.id}:`) && rec.mesh.visible && rec.mesh.count > 0) {
 const mesh = rec.mesh;
 for (let i = 0; i < mesh.count; i++) {
 const geo = mesh.geometry.clone();
 const matrix = new THREE.Matrix4();
 mesh.getMatrixAt(i, matrix);
 geo.applyMatrix4(matrix);
 geometries.push(geo);
 }
 }
 });
 if (geometries.length === 0) return null;

 // Note: BufferGeometryUtils would be needed for mergeGeometries
 // For now, create a simple group
 const group = new THREE.Group();
 geometries.forEach(geo => {
 const mesh = new THREE.Mesh(geo, new THREE.MeshNormalMaterial());
 group.add(mesh);
 });
 return group;
 }
 // Rotate array around a world-space pivot by 90 steps per axis
 function rotateArrayAround(arr, pivotWorld, stepsX=0, stepsY=0, stepsZ=0){
 if(!arr?._frame) return;
 const snap=(v)=> Math.round(v);
 const apply=(axis, steps)=>{
 const n=((steps%4)+4)%4; if(n===0) return;
 const angle=n*(Math.PI/2);
 const pos=arr._frame.position.clone().sub(pivotWorld);
 pos.applyAxisAngle(axis, angle).add(pivotWorld);
 arr._frame.position.copy(pos);
 arr._frame.rotateOnWorldAxis(axis, angle);
 // snap position to integer grid after each axis to minimize drift
 arr._frame.position.set(snap(arr._frame.position.x), snap(arr._frame.position.y), snap(arr._frame.position.z));
 };
 apply(new THREE.Vector3(1,0,0), stepsX);
 apply(new THREE.Vector3(0,1,0), stepsY);
 apply(new THREE.Vector3(0,0,1), stepsZ);
 // persist offset for future renders
 arr.offset = { x: arr._frame.position.x, y: arr._frame.position.y, z: arr._frame.position.z };
 // Persist rotation for save
 try{
 arr.rotationQuat = arr._frame.quaternion.toArray();
 const rs = arr.rotationSteps || {x:0,y:0,z:0};
 arr.rotationSteps = {
 x: ((rs.x||0) + (stepsX|0))%4,
 y: ((rs.y||0) + (stepsY|0))%4,
 z: ((rs.z||0) + (stepsZ|0))%4,
 };
 }catch{}
 }
 // Compute world position of a cell, respecting current frame transform
 function cellWorldPos(arr, x, y, z){
 const lp = localPos(arr, x, y, z).clone();
 if(arr._frame){ return arr._frame.localToWorld(lp); }
 const off = arr.offset||{x:0,y:0,z:0};
 lp.x += off.x; lp.y += off.y; lp.z += off.z; return lp;
 }

 function refreshArray(arr){
 if(!arr || !arr._frame) return;
 try{
 const old = arr._frame.userData?.labelSprite;
 if(old){ try{ if(old?.userData?.billboard) unmarkBillboard(old); }catch{} old.parent?.remove(old); old.material?.map?.dispose?.(); old.material?.dispose?.(); old.geometry?.dispose?.(); }
 const labelSprite = makeArrayLabelSprite(arr);
 // Initial position will be updated by updateArrayLabelPlacement
 labelSprite.position.set(0, arr.size.y/2 + 0.8, 0);
 arr._frame.add(labelSprite);
 arr._frame.userData.labelSprite = labelSprite;
 }catch{}
 }
 // Rehydrate all arrays from current Store state: ensure LOD1 meshes, apply occlusion for the focused array, and rebuild value sprites
 function hydrateAll(){
 try{
 const S = Store.getState();
 const sel = S.selection || {};
 const viewModeNow = (S.ui && S.ui.viewMode) || 'standard';
 Object.values(S.arrays).forEach(arr=>{
 try{ Object.values(arr.chunks||{}).forEach(ch=>{ ch.ensureMesh?.(); ch.setLOD?.(1); rehydrateChunkInstances(arr, ch); }); }catch{}
 // Apply occlusion mask only to the focused array so others start solid
 if(viewModeNow === 'standard' && sel.arrayId === arr.id && sel.focus){
 try{ computeOcclusion(arr, sel.focus); applyGhostMaskToChunks(arr); }catch{}
 } else if(sel.arrayId === arr.id){
 clearOcclusion(arr);
 }
 // Rebuild value sprites for visible cells (clear first to prevent duplicates)
 try{
 valueSprites.forEach((sprite,key)=>{ if(String(key).startsWith(`${arr.id}:`)){ try{ unmarkBillboard(sprite); sprite.parent?.remove(sprite); sprite.material?.map?.dispose?.(); sprite.material?.dispose?.(); }catch{} valueSprites.delete(key); } });
 Object.values(arr.chunks||{}).forEach(ch=>{
 (ch.cells||[]).forEach(c=>{
 try{ const cell = Formula.getCell({arrId: arr.id, x:c.x, y:c.y, z:c.z}); if(cell && (cell.value!=='' && cell.value!==null && cell.value!==undefined)) updateValueSprite(arr, c.x, c.y, c.z, cell); }catch{}
 });
 });
 // Ensure sprites are positioned on the current camera-facing face
 try{ updateArrayValueSpritePlacement(arr); }catch{}
 }catch{}
 });
 try{ forceRenderOrderRefresh?.(true); }catch{}
 needsRender = true;
 }catch{}
 }
 
 function spawnPlayerAt(x, y, z){
 if(playerBody){
 try{
  playerBody.setTranslation({x, y, z}, true);
  playerBody.setLinvel({x: 0, y: 0, z: 0}, true); // Reset all velocities
  playerBody.setAngvel({x: 0, y: 0, z: 0}, true); // Reset angular velocity
  cachedPlayerPos.set(x, y, z);
  jumpVelocity = 0; // Reset jump velocity on spawn
  landingSquashTime = 0; // Reset squash animation
  anticipationSquashTime = 0;
  wasGroundedLastFrame = false;
  skipWalkBounceUntil = 0;
  resetJumpBudget();
  physicsSpawnPos = {x, y, z}; // Store for respawn on fall
  console.log(`[PHYSICS] Spawned player at (${x.toFixed(2)}, ${y.toFixed(2)}, ${z.toFixed(2)})`);
 }catch(e){
 console.warn('spawnPlayerAt failed:', e);
 }
 }
 }

 function updateArrayLabelPlacement(arr){
 const label = arr?._frame?.userData?.labelSprite;
 const grab = arr.labels?.find(l => l.userData?.type === 'grab');
 if(!label || !grab) return;

 // world positions
 grab.updateWorldMatrix(true, false);
 const grabW = new THREE.Vector3(); grab.getWorldPosition(grabW);

 const camW = camera.position;
 const scale = arrayVoxelScale(arr);
 const toCam = new THREE.Vector3().subVectors(camW, grabW);
 toCam.y = 0;
 if(toCam.lengthSq() < 1e-6){ toCam.set(0,0,1); }
 toCam.normalize();

 // offsets: a little above in world Y, and a little toward the camera (horizontal only)
 const up = new THREE.Vector3(0,1,0);
 const aboveBase = 0.35 + Math.abs(label.scale.y)*0.5;
 const above = up.multiplyScalar(clampedScaleOffset(scale, aboveBase));
 const inFront = toCam.multiplyScalar(clampedScaleOffset(scale, 0.3));

 const targetW = grabW.clone().add(above).add(inFront);

 // place in the frame's local space (so it follows naturally)
 const parent = arr._frame || scene;
 parent.worldToLocal(targetW);
 label.position.copy(targetW);

 // keep it facing camera without touching renderOrder
 label.lookAt(camera.position);
 }

 async function togglePhysicsMode(){
 if(physicsToggleInFlight){
 console.warn('[PHYSICS] Toggle already in progress');
 return;
 }
 console.log('[PHYSICS] togglePhysicsMode called, stack:', new Error().stack.split('\n').slice(1,4).join('\n'));
 physicsToggleInFlight = true;
 try{
 try{
 const active = document?.activeElement;
 if(active && active.id === 'physicsBtn' && typeof active.blur === 'function'){
 active.blur();
 }
 }catch{}
 const current = Store.getState().scene.physics;
 const next = !current;
 console.log(`[PHYSICS MODE TOGGLE] Current: ${current}, Next: ${next}`);
 if(next){
 setPhysicsActivationPending(true, 'toggle-begin');
 updatePhysicsStatusChip('Physics: Loading...');
 } else {
 setPhysicsActivationPending(false, 'toggle-begin');
 }
 const debugAll = !!Store.getState().scene.physicsDebugAll;
 console.log(`[PHYSICS] Toggle: debugAll=${debugAll}, next=${next}`);
 let debugApplied = false;
 if(next && debugAll){
 console.log('[PHYSICS] Applying debug overrides for all arrays');
 applyDebugPhysicsOverrides(true);
 debugApplied = true;
 }
 const avatarCfg = Store.getState().avatarPhysics || {};
 if(next && avatarCfg.enabled === false){
 showToast?.('Avatar physics disabled by CELLI_PHYS');
 Store.setState(s=>({scene:{...s.scene, physics:false}}));
 syncPhysicsInputCapture('avatar-disabled');
 updatePhysicsStatusChip('Physics: OFF');
 if(debugApplied){ applyDebugPhysicsOverrides(false); }
 ensurePlatformerActiveState(false);
 resetPhysicsInputState();
 setPhysicsActivationPending(false, 'avatar-disabled');
 return;
 }

 if(next){
 const status = await ensureRapierWorld();
 if(!status?.success){
 const label = status?.reason === 'unavailable' ? 'Physics: OFF (unavailable)' : 'Physics: OFF (error)';
 updatePhysicsStatusChip(label);
 if(debugApplied){ applyDebugPhysicsOverrides(false); }
 ensurePlatformerActiveState(false);
 resetPhysicsInputState();
 setPhysicsActivationPending(false, status?.reason || 'rapier-failed');
 return;
 }
 }

 Store.setState(s=>({scene:{...s.scene, physics:next}}));
 syncPhysicsInputCapture('toggle-commit');
 ensurePlatformerActiveState(next);

 if(next){
 try{
 const directEl = document.getElementById('directEdit');
 if(directEl){
 if(directEl.style.display === 'block'){
 directEl.style.display = 'none';
 }
 if(typeof directEl.blur === 'function' && document.activeElement === directEl){
 directEl.blur();
 }
 directEl._closedAt = Date.now();
 }
 const active = document.activeElement;
 if(active && typeof active.blur === 'function'){
 const tag = (active.tagName||'').toUpperCase();
 if(tag === 'INPUT' || tag === 'TEXTAREA'){
 active.blur();
 }
 }
 }catch{}
 resetPhysicsInputState();
 // On enable: create player body and spawn at current selected cell
 if(RAPIER && rapierWorld && !playerBody){
 try{
 const cfg = Store.getState().avatarPhysics || {};
 const momentumMode = (cfg.momentumMode|0) === 1 ? 1 : 0;
 const rb=RAPIER.RigidBodyDesc.dynamic();
 rb.setTranslation(0, 0.7, 0);
 rb.lockRotations(true, true);
 rb.setCanSleep(false);
 rb.setLinearDamping(momentumMode === 1 ? 1.5 : 5.0);
 rb.setAngularDamping(1.0);
 rb.setCcdEnabled(true);
 playerBody=rapierWorld.createRigidBody(rb);
 const capsuleDesc = RAPIER.ColliderDesc.capsule(0.32, 0.22);
 capsuleDesc.setRestitution(0.0);
 capsuleDesc.setFriction(0.7);
 capsuleDesc.setDensity(1.5);
 playerCollider=rapierWorld.createCollider(capsuleDesc, playerBody);
 cachedPlayerPos.set(0, 0.7, 0);
 console.log('[PHYSICS] Created player body');
 updatePhysicsStatusChip('Physics: ON');
 }catch(e){
 console.warn('[PHYSICS] Failed to create player body:', e);
 updatePhysicsStatusChip('Physics: OFF (error)');
 Store.setState(s=>({scene:{...s.scene, physics:false}}));
 syncPhysicsInputCapture('player-body-error');
 ensurePlatformerActiveState(false);
 if(debugApplied){ applyDebugPhysicsOverrides(false); }
 resetPhysicsInputState();
 setPhysicsActivationPending(false, 'player-body-error');
 return;
 }
 }
 const sel = Store.getState().selection;
 let spawnPos = {x: 0, y: 1, z: 0}; // Default spawn position
 const selectedArr = sel?.arrayId ? Store.getState().arrays[sel.arrayId] : null;
 if(selectedArr && sel?.focus){
 const pos = worldPos(selectedArr, sel.focus.x, sel.focus.y, sel.focus.z);
 const arrScale = arrayVoxelScale(selectedArr);
 const perch = avatarPerchOffset(arrScale);
 spawnPos = {x: pos.x, y: pos.y + perch, z: pos.z};
 spawnPlayerAt(spawnPos.x, spawnPos.y, spawnPos.z);
 console.log(`[PHYSICS] Spawned Celli at cell (${sel.focus.x},${sel.focus.y},${sel.focus.z}) -> world (${pos.x.toFixed(2)},${pos.y.toFixed(2)},${pos.z.toFixed(2)})`);
 } else {
 // No selection, spawn at default position
 spawnPlayerAt(spawnPos.x, spawnPos.y, spawnPos.z);
 }
 resetJumpBudget(selectedArr || null);
 // Position camera to show Celli from a good platformer angle
 if(camera && controls){
 // Target Celli's position (slightly above ground)
 const targetPos = {x: spawnPos.x, y: spawnPos.y + 1.5, z: spawnPos.z};
 controls.target.set(targetPos.x, targetPos.y, targetPos.z);
 // Camera behind and above for good platformer view
 const camDistance = 8;
 const camHeight = 4;
 camera.position.set(targetPos.x - 3, targetPos.y + camHeight, targetPos.z + camDistance);
 controls.update();
 console.log(`[PHYSICS] Camera positioned at (${camera.position.x.toFixed(2)}, ${camera.position.y.toFixed(2)}, ${camera.position.z.toFixed(2)}) targeting (${targetPos.x.toFixed(2)}, ${targetPos.y.toFixed(2)}, ${targetPos.z.toFixed(2)})`);
 }
 try{ setPhysicsCamera(physicsCameraConfig.mode, physicsCameraConfig.distance, physicsCameraConfig.allowRotation); }catch{}
 // Build colliders for all arrays (in debug mode, all arrays should get colliders)
 const allArrays = Object.values(Store.getState().arrays);
 console.log(`[PHYSICS] Building colliders for ${allArrays.length} arrays (debug=${debugAll})`);
 // Wait for colliders to be built before finishing activation
 let rebuildsCompleted = 0;
 const totalArrays = allArrays.length;
 allArrays.forEach(a=>{
 debounceColliderRebuild(a);
 // Mark colliders as being built
 a._collidersBuilding = true;
 });
 // Clear activation pending immediately - debug mode protects against physics exit
 setPhysicsActivationPending(false, 'collider-build');
 // Initialize mouse look angles from current camera
 try{
 if(camera){
 const dir = new THREE.Vector3();
 camera.getWorldDirection(dir);
 mouseYaw = Math.atan2(-dir.x, -dir.z);
 mousePitch = Math.asin(dir.y);
 console.log(`[PHYSICS] Initialized mouse look from camera direction`);
 }
 }catch{}
 } else {
 setPhysicsActivationPending(false, 'toggle-complete');
 resetPhysicsInputState();
 // On disable: destroy player body and release pointer lock
 if(playerBody && rapierWorld){
 let removed = false;
 try{
 if(playerCollider) rapierWorld.removeCollider(playerCollider, false);
 rapierWorld.removeRigidBody(playerBody);
 removed = true;
 }catch(e){
 console.warn('[PHYSICS] Failed to destroy player body:', e);
 }
 playerBody = null;
 playerCollider = null;
 if(removed){ console.log('[PHYSICS] Destroyed player body'); }
 }
 ziplineState.active = false;
 ziplineState.velocity = 0;
 try{
 if(document.pointerLockElement){
 document.exitPointerLock();
 }
 mouseLookEnabled = false;
 }catch{}
 // Explicitly re-enable orbit controls when physics is disabled
 if(controls){
 if(orbitSuspendDepth === 0){
 controls.enableRotate = true;
 controls.enablePan = true;
 controls.enabled = true;
 console.log('[PHYSICS] Orbit controls re-enabled');
 } else {
 console.log('[PHYSICS] Orbit controls remain suspended (depth:', orbitSuspendDepth, ')');
 }
 }
 updatePhysicsStatusChip('Physics: OFF');
 if(debugApplied || debugAll){
 applyDebugPhysicsOverrides(false);
 }
 }
 } finally {
 // Always reset flags
 setPhysicsActivationPending(false, 'toggle-finalize');
 physicsToggleInFlight = false;
 }
 }

 return {init, renderArray, renderChunk, renderLayer, updateFocus, centerOnArray, syncVisibility, setGridVisible, setAxesVisible, rebuildCollidersForArray, debounceColliderRebuild, setHighlightMode, setCameraLock, setViewMode, initAvatars, updateAvatars, addTimedPreview, handleJump, spawnPlayerAt, getCamera:()=>camera, getControls:()=>controls, updateValueSprite, setArrayOffset, reconcileAllArrays, setupRenderer, setupLighting, addConnection, removeConnection, createArraySnapshot, worldPos, getScene:()=>scene, getLayerMesh:(key)=>layerMeshes.get(key), rotateArrayAround, cellWorldPos, startDatafallDelete, updateDeleteEffects, removeArrayGraphics, refreshArray, hydrateAll, updateArrayLabelPlacement, dockOffsetFor, Chunk, ChunkManager, localPos, createCellMaterial, GEO_VOXEL, getCell:getCellFast, captureCamera, restoreCamera, updateCellColor:(arrId, coord)=>updateCellColor(arrId, coord), startSpottedSequence, togglePresentMode, isPresentEnabled, getGraphicsSettings, updateGraphicsSettings, setOceanEnabled, updateOceanSettings, getOceanSettings, upsertCellLight, removeCellLight, refreshLightsForArray, togglePhysicsMode, setPhysicsDebugAll, setPhysicsCamera, resetContactCache, setPhysicsSpawn, isPhysicsInputCaptured:()=>syncPhysicsInputCapture(), facingFromCamera, triggerCelliDerez, celliDerezState, getViewAxisForArray:(arrOrFrame, observer)=>{
 try{
 if(!arrOrFrame) return null;
 const frame = arrOrFrame.matrixWorld ? arrOrFrame : (arrOrFrame._frame || null);
 if(!frame) return null;
 return viewAxisForArray(frame, observer);
 }catch(e){ console.warn('getViewAxisForArray failed', e); return null; }
 }};
})();

/* ===========================
 UI
=========================== */
const UI = (()=>{
 let dragStart=null;
 let hovered2D = null; // {arrId,x,y,z}
 const els={
 fx:document.getElementById('fx'), fxHighlight:document.getElementById('fxHighlight'), apply:document.getElementById('applyFx'),
 toggleFxPanel:document.getElementById('toggleFxPanel'), fxPanel:document.getElementById('fxPanel'),
 fxBody:document.getElementById('fxBody'), fxClose:document.getElementById('fxClose'),
 focusChip:document.getElementById('focusChip'), inspect:document.getElementById('inspect'),
 centerHome:document.getElementById('centerHome'), viewMainframe:document.getElementById('viewMainframe'),
 toggleGrid:document.getElementById('toggleGrid'), toggleAxes:document.getElementById('toggleAxes'),
  presentToggle:document.getElementById('presentToggleBtn'), graphicsSettingsBtn:document.getElementById('graphicsSettingsBtn'), oceanSettingsBtn:document.getElementById('oceanSettingsBtn'), oceanSpottedBtn:document.getElementById('oceanSpottedBtn'), crystalToggle:document.getElementById('crystal2DToggle'),
  celliCollapse:document.getElementById('celliCollapseBtn'),
  physicsBtn:document.getElementById('physicsBtn'), reset:document.getElementById('reset'),
 status:document.getElementById('statusChip'),
 sheetTitle:document.getElementById('sheetTitle'),
 rowHeaders:document.getElementById('rowHeaders'), colHeaders:document.getElementById('colHeaders'), grid:document.getElementById('grid'),
 direct:document.getElementById('directEdit')
 };
 // Local Excel-style column name generator to avoid any global shadowing
 const colNameFromIndex=(n)=>{ let s=''; let v=n+1; while(v>0){ const r=(v-1)%26; s=String.fromCharCode(65+r)+s; v=Math.floor((v-1)/26);} return s; };
 // 2D sheet column widths (px) persisted in-memory across renders
 const colWidths = {};
 const getColWidth=(i)=> (colWidths[i]||100);
 const setColWidth=(i,w)=>{ colWidths[i]=Math.max(60, Math.min(480, Math.round(w))); };

 const graphicsPanel = document.getElementById('graphicsSettingsPanel');
 const graphicsClose = document.getElementById('graphicsSettingsClose');
 const graphicsPanelHint = document.getElementById('graphicsSettingsHint');
 const graphicsControls = {
 hdri: document.getElementById('gfxHdri'),
 lights: document.getElementById('gfxLights'),
 lightRotation: document.getElementById('gfxLightRotation'),
 lightStrength: document.getElementById('gfxLightStrength'),
 darkBg: document.getElementById('gfxDarkBg'),
 bloom: document.getElementById('gfxBloom'),
 bloomStrength: document.getElementById('gfxBloomStrength'),
 bloomRadius: document.getElementById('gfxBloomRadius'),
 exposure: document.getElementById('gfxExposure'),
 dof: document.getElementById('gfxDof'),
 dofAperture: document.getElementById('gfxDofAperture'),
 dofMaxBlur: document.getElementById('gfxDofMaxBlur'),
 transmission: document.getElementById('gfxTransmission'),
 mirror: document.getElementById('gfxMirror'),
 ground: document.getElementById('gfxGround'),
 waveGrid: document.getElementById('gfxWaveGrid'),
 fxaa: document.getElementById('gfxFxaa'),
 fog: document.getElementById('gfxFog'),
 fogDensity: document.getElementById('gfxFogDensity'),
 outline: document.getElementById('gfxOutline'),
 outlineStrength: document.getElementById('gfxOutlineStrength'),
 outlineThickness: document.getElementById('gfxOutlineThickness'),
 motion: document.getElementById('gfxMotion'),
 motionDamping: document.getElementById('gfxMotionDamping')
 };
 const graphicsSliderDisplays = {
 bloomStrength: document.getElementById('gfxBloomStrengthValue'),
 bloomRadius: document.getElementById('gfxBloomRadiusValue'),
 exposure: document.getElementById('gfxExposureValue'),
 dofAperture: document.getElementById('gfxDofApertureValue'),
 dofMaxBlur: document.getElementById('gfxDofMaxBlurValue'),
 lightRotation: document.getElementById('gfxLightRotationValue'),
 lightStrength: document.getElementById('gfxLightStrengthValue'),
 fogDensity: document.getElementById('gfxFogDensityValue'),
 outlineStrength: document.getElementById('gfxOutlineStrengthValue'),
 outlineThickness: document.getElementById('gfxOutlineThicknessValue'),
 motionDamping: document.getElementById('gfxMotionDampingValue')
 };
 const oceanPanel = document.getElementById('oceanSettingsPanel');
 const oceanClose = document.getElementById('oceanSettingsClose');
 const oceanPanelHint = document.getElementById('oceanSettingsHint');
 const oceanControls = {
 enable: document.getElementById('oceanEnable'),
 envIntensity: document.getElementById('oceanEnvIntensity'),
 lightIntensity: document.getElementById('oceanLightIntensity'),
 exposure: document.getElementById('oceanExposure'),
 showGrid: document.getElementById('oceanShowGrid'),
 showSphere: document.getElementById('oceanShowSphere'),
 showTowers: document.getElementById('oceanShowTowers'),
 showFloaters: document.getElementById('oceanShowFloaters'),
 screenshot: document.getElementById('oceanScreenshotBtn'),
 sunElevation: document.getElementById('oceanSunElevation'),
 sunAzimuth: document.getElementById('oceanSunAzimuth'),
 skyTopColor: document.getElementById('oceanSkyTop'),
 skyMidColor: document.getElementById('oceanSkyMid'),
 skyBotColor: document.getElementById('oceanSkyBot'),
 timeScale: document.getElementById('oceanTimeScale'),
 choppiness: document.getElementById('oceanChoppiness'),
 amplitude0: document.getElementById('oceanAmp0'),
 amplitude1: document.getElementById('oceanAmp1'),
 amplitude2: document.getElementById('oceanAmp2'),
 amplitude3: document.getElementById('oceanAmp3'),
 amplitude4: document.getElementById('oceanAmp4'),
 amplitude5: document.getElementById('oceanAmp5'),
 wavelength0: document.getElementById('oceanLen0'),
 wavelength1: document.getElementById('oceanLen1'),
 wavelength2: document.getElementById('oceanLen2'),
 wavelength3: document.getElementById('oceanLen3'),
 wavelength4: document.getElementById('oceanLen4'),
 wavelength5: document.getElementById('oceanLen5'),
 speed0: document.getElementById('oceanSpeed0'),
 speed1: document.getElementById('oceanSpeed1'),
 speed2: document.getElementById('oceanSpeed2'),
 speed3: document.getElementById('oceanSpeed3'),
 speed4: document.getElementById('oceanSpeed4'),
 speed5: document.getElementById('oceanSpeed5'),
 deepColor: document.getElementById('oceanDeepColor'),
 shallowColor: document.getElementById('oceanShallowColor'),
 foamColor: document.getElementById('oceanFoamColor'),
 foamAmount: document.getElementById('oceanFoamAmount'),
 foamBias: document.getElementById('oceanFoamBias'),
 foamScale: document.getElementById('oceanFoamScale'),
 maxGloss: document.getElementById('oceanMaxGloss'),
 roughnessScale: document.getElementById('oceanRoughnessScale'),
 horizonColor: document.getElementById('oceanHorizonColor'),
 horizonZStart: document.getElementById('oceanHorizonStart'),
 horizonZEnd: document.getElementById('oceanHorizonEnd'),
 horizonBoost: document.getElementById('oceanHorizonBoost'),
 microScale: document.getElementById('oceanMicroScale'),
 microFreq: document.getElementById('oceanMicroFreq'),
 microWaveScale: document.getElementById('oceanMicroWaveScale'),
 enableBloom: document.getElementById('oceanEnableBloom'),
 bloomStrength: document.getElementById('oceanBloomStrength'),
 enableVignette: document.getElementById('oceanEnableVignette'),
 vignetteStrength: document.getElementById('oceanVignetteStrength'),
 grainAmount: document.getElementById('oceanGrainAmount'),
 enableRays: document.getElementById('oceanEnableRays'),
 rayStrength: document.getElementById('oceanRayStrength'),
 rayDecay: document.getElementById('oceanRayDecay'),
 rayExposure: document.getElementById('oceanRayExposure'),
 enableLighthouse: document.getElementById('oceanEnableLighthouse'),
 lighthouseStrength: document.getElementById('oceanLighthouseStrength'),
 focusDistance: document.getElementById('oceanFocusDistance'),
 dofStrength: document.getElementById('oceanDofStrength'),
 focusRange: document.getElementById('oceanFocusRange'),
 fogStart: document.getElementById('oceanFogStart'),
 fogEnd: document.getElementById('oceanFogEnd'),
 fogColor: document.getElementById('oceanFogColor'),
 gridDensity: document.getElementById('oceanGridDensity'),
 gridOpacity: document.getElementById('oceanGridOpacity')
 };
 const oceanValueDisplays = {
 envIntensity: document.getElementById('oceanEnvIntensityValue'),
 lightIntensity: document.getElementById('oceanLightIntensityValue'),
 exposure: document.getElementById('oceanExposureValue'),
 sunElevation: document.getElementById('oceanSunElevationValue'),
 sunAzimuth: document.getElementById('oceanSunAzimuthValue'),
 timeScale: document.getElementById('oceanTimeScaleValue'),
 choppiness: document.getElementById('oceanChoppinessValue'),
 amplitude0: document.getElementById('oceanAmp0Value'),
 amplitude1: document.getElementById('oceanAmp1Value'),
 amplitude2: document.getElementById('oceanAmp2Value'),
 amplitude3: document.getElementById('oceanAmp3Value'),
 amplitude4: document.getElementById('oceanAmp4Value'),
 amplitude5: document.getElementById('oceanAmp5Value'),
 wavelength0: document.getElementById('oceanLen0Value'),
 wavelength1: document.getElementById('oceanLen1Value'),
 wavelength2: document.getElementById('oceanLen2Value'),
 wavelength3: document.getElementById('oceanLen3Value'),
 wavelength4: document.getElementById('oceanLen4Value'),
 wavelength5: document.getElementById('oceanLen5Value'),
 speed0: document.getElementById('oceanSpeed0Value'),
 speed1: document.getElementById('oceanSpeed1Value'),
 speed2: document.getElementById('oceanSpeed2Value'),
 speed3: document.getElementById('oceanSpeed3Value'),
 speed4: document.getElementById('oceanSpeed4Value'),
 speed5: document.getElementById('oceanSpeed5Value'),
 foamAmount: document.getElementById('oceanFoamAmountValue'),
 foamBias: document.getElementById('oceanFoamBiasValue'),
 foamScale: document.getElementById('oceanFoamScaleValue'),
 maxGloss: document.getElementById('oceanMaxGlossValue'),
 roughnessScale: document.getElementById('oceanRoughnessScaleValue'),
 horizonZStart: document.getElementById('oceanHorizonStartValue'),
 horizonZEnd: document.getElementById('oceanHorizonEndValue'),
 horizonBoost: document.getElementById('oceanHorizonBoostValue'),
 microScale: document.getElementById('oceanMicroScaleValue'),
 microFreq: document.getElementById('oceanMicroFreqValue'),
 microWaveScale: document.getElementById('oceanMicroWaveScaleValue'),
 bloomStrength: document.getElementById('oceanBloomStrengthValue'),
 vignetteStrength: document.getElementById('oceanVignetteStrengthValue'),
 grainAmount: document.getElementById('oceanGrainAmountValue'),
 rayStrength: document.getElementById('oceanRayStrengthValue'),
 rayDecay: document.getElementById('oceanRayDecayValue'),
 rayExposure: document.getElementById('oceanRayExposureValue'),
 lighthouseStrength: document.getElementById('oceanLighthouseStrengthValue'),
 focusDistance: document.getElementById('oceanFocusDistanceValue'),
 dofStrength: document.getElementById('oceanDofStrengthValue'),
 focusRange: document.getElementById('oceanFocusRangeValue'),
 fogStart: document.getElementById('oceanFogStartValue'),
 fogEnd: document.getElementById('oceanFogEndValue'),
 gridDensity: document.getElementById('oceanGridDensityValue'),
 gridOpacity: document.getElementById('oceanGridOpacityValue')
 };
 const oceanSliderFormatters = {
 envIntensity: (v)=>Number(v).toFixed(2),
 lightIntensity: (v)=>Number(v).toFixed(2),
 exposure: (v)=>Number(v).toFixed(2),
 sunElevation: (v)=>`${Math.round(Number(v)||0)} `,
 sunAzimuth: (v)=>`${Math.round(Number(v)||0)} `,
 timeScale: (v)=>Number(v).toFixed(2),
 choppiness: (v)=>Number(v).toFixed(2),
 amplitude0: (v)=>Number(v).toFixed(2),
 amplitude1: (v)=>Number(v).toFixed(2),
 amplitude2: (v)=>Number(v).toFixed(2),
 amplitude3: (v)=>Number(v).toFixed(2),
 amplitude4: (v)=>Number(v).toFixed(2),
 amplitude5: (v)=>Number(v).toFixed(2),
 wavelength0: (v)=>Number(v).toFixed(1),
 wavelength1: (v)=>Number(v).toFixed(1),
 wavelength2: (v)=>Number(v).toFixed(1),
 wavelength3: (v)=>Number(v).toFixed(1),
 wavelength4: (v)=>Number(v).toFixed(1),
 wavelength5: (v)=>Number(v).toFixed(1),
 speed0: (v)=>Number(v).toFixed(2),
 speed1: (v)=>Number(v).toFixed(2),
 speed2: (v)=>Number(v).toFixed(2),
 speed3: (v)=>Number(v).toFixed(2),
 speed4: (v)=>Number(v).toFixed(2),
 speed5: (v)=>Number(v).toFixed(2),
 foamAmount: (v)=>Number(v).toFixed(2),
 foamBias: (v)=>Number(v).toFixed(2),
 foamScale: (v)=>Number(v).toFixed(2),
 maxGloss: (v)=>Number(v).toFixed(2),
 roughnessScale: (v)=>Number(v).toFixed(4),
 horizonZStart: (v)=>Number(v).toFixed(0),
 horizonZEnd: (v)=>Number(v).toFixed(0),
 horizonBoost: (v)=>Number(v).toFixed(2),
 microScale: (v)=>Number(v).toFixed(3),
 microFreq: (v)=>Number(v).toFixed(1),
 microWaveScale: (v)=>Number(v).toFixed(2),
 bloomStrength: (v)=>Number(v).toFixed(2),
 vignetteStrength: (v)=>Number(v).toFixed(2),
 grainAmount: (v)=>Number(v).toFixed(3),
 rayStrength: (v)=>Number(v).toFixed(2),
 rayDecay: (v)=>Number(v).toFixed(3),
 rayExposure: (v)=>Number(v).toFixed(2),
 lighthouseStrength: (v)=>Number(v).toFixed(2),
 focusDistance: (v)=>Math.round(Number(v)||0),
 dofStrength: (v)=>Number(v).toFixed(2),
 focusRange: (v)=>Math.round(Number(v)||0),
 fogStart: (v)=>Math.round(Number(v)||0),
 fogEnd: (v)=>Math.round(Number(v)||0),
 gridDensity: (v)=>Math.round(Number(v)||0),
 gridOpacity: (v)=>Number(v).toFixed(2)
 };
 const oceanRangeKeys = [
 'envIntensity','lightIntensity','exposure','sunElevation','sunAzimuth','timeScale','choppiness',
 'amplitude0','amplitude1','amplitude2','amplitude3','amplitude4','amplitude5',
 'wavelength0','wavelength1','wavelength2','wavelength3','wavelength4','wavelength5',
 'speed0','speed1','speed2','speed3','speed4','speed5',
 'foamAmount','foamBias','foamScale','maxGloss','roughnessScale',
 'horizonZStart','horizonZEnd','horizonBoost',
 'microScale','microFreq','microWaveScale',
 'bloomStrength','vignetteStrength','grainAmount',
 'rayStrength','rayDecay','rayExposure',
 'lighthouseStrength','focusDistance','dofStrength','focusRange',
 'fogStart','fogEnd','gridDensity','gridOpacity'
 ];
 const oceanColorKeys = ['skyTopColor','skyMidColor','skyBotColor','deepColor','shallowColor','foamColor','horizonColor','fogColor'];
 const oceanToggleKeys = ['showGrid','showSphere','showTowers','showFloaters','enableBloom','enableVignette','enableRays','enableLighthouse'];
 let graphicsPanelVisible = false;
 let oceanPanelVisible = false;

 const sliderFormatters = {
 bloomStrength: (v)=>v.toFixed(2),
 bloomRadius: (v)=>v.toFixed(2),
 exposure: (v)=>v.toFixed(2),
 dofAperture: (v)=>v.toFixed(4),
 dofMaxBlur: (v)=>v.toFixed(4),
 lightRotation: (v)=>`${Math.round(Number(v)||0)} `,
 lightStrength: (v)=>Number(v).toFixed(2),
 fogDensity: (v)=>v.toFixed(3),
 outlineStrength: (v)=>v.toFixed(1),
 outlineThickness: (v)=>v.toFixed(2),
 motionDamping: (v)=>v.toFixed(3)
 };

 function updateSliderDisplay(key, value){
 const span = graphicsSliderDisplays[key];
 if(!span) return;
 const formatter = sliderFormatters[key] || ((v)=>v.toFixed(2));
 span.textContent = formatter(Number(value));
 }

 function syncGraphicsSettings(){
 if(!Scene.getGraphicsSettings) return;
 const settings = Scene.getGraphicsSettings();
 if(!settings) return;
 if(graphicsControls.hdri) graphicsControls.hdri.checked = !!settings.hdri;
 if(graphicsControls.lights) graphicsControls.lights.checked = !!settings.lights;
 if(graphicsControls.darkBg) graphicsControls.darkBg.checked = !!settings.darkBg;
 if(graphicsControls.bloom) graphicsControls.bloom.checked = !!settings.bloomEnabled;
 if(graphicsControls.bloomStrength){ graphicsControls.bloomStrength.value = settings.bloomStrength; updateSliderDisplay('bloomStrength', settings.bloomStrength); }
 if(graphicsControls.bloomRadius){ graphicsControls.bloomRadius.value = settings.bloomRadius; updateSliderDisplay('bloomRadius', settings.bloomRadius); }
 if(graphicsControls.exposure){ graphicsControls.exposure.value = settings.exposure; updateSliderDisplay('exposure', settings.exposure); }
 if(graphicsControls.lightRotation){ graphicsControls.lightRotation.value = settings.lightRotation ?? 0; updateSliderDisplay('lightRotation', settings.lightRotation ?? 0); }
 if(graphicsControls.lightStrength){ graphicsControls.lightStrength.value = settings.lightStrength ?? 1; updateSliderDisplay('lightStrength', settings.lightStrength ?? 1); }
 if(graphicsControls.dof) graphicsControls.dof.checked = !!settings.dofEnabled;
 if(graphicsControls.dofAperture){ graphicsControls.dofAperture.value = settings.dofAperture; updateSliderDisplay('dofAperture', settings.dofAperture); }
 if(graphicsControls.dofMaxBlur){ graphicsControls.dofMaxBlur.value = settings.dofMaxBlur; updateSliderDisplay('dofMaxBlur', settings.dofMaxBlur); }
 if(graphicsControls.transmission) graphicsControls.transmission.checked = !!settings.transmission;
 if(graphicsControls.ground) graphicsControls.ground.checked = !!settings.solidGround;
 if(graphicsControls.mirror){
 graphicsControls.mirror.checked = !!settings.mirror && !settings.solidGround;
 graphicsControls.mirror.disabled = !!settings.solidGround;
 }
 if(graphicsControls.waveGrid) graphicsControls.waveGrid.checked = !!settings.waveGrid;
 if(graphicsControls.fxaa) graphicsControls.fxaa.checked = !!settings.fxaa;
 if(graphicsControls.fog) graphicsControls.fog.checked = !!settings.fogEnabled;
 if(graphicsControls.fogDensity){ graphicsControls.fogDensity.value = settings.fogDensity; updateSliderDisplay('fogDensity', settings.fogDensity); }
 if(graphicsControls.outline) graphicsControls.outline.checked = !!settings.outlineEnabled;
 if(graphicsControls.outlineStrength){ graphicsControls.outlineStrength.value = settings.outlineStrength; updateSliderDisplay('outlineStrength', settings.outlineStrength); }
 if(graphicsControls.outlineThickness){ graphicsControls.outlineThickness.value = settings.outlineThickness; updateSliderDisplay('outlineThickness', settings.outlineThickness); }
 if(graphicsControls.motion) graphicsControls.motion.checked = !!settings.motionEnabled;
 if(graphicsControls.motionDamping){ graphicsControls.motionDamping.value = settings.motionDamping; updateSliderDisplay('motionDamping', settings.motionDamping); }
 }

 function setGraphicsControlsEnabled(enabled){
 const settings = Scene.getGraphicsSettings ? Scene.getGraphicsSettings() : null;
 Object.entries(graphicsControls).forEach(([key, ctrl])=>{
 if(!ctrl) return;
 const mirrorLocked = (key==='mirror' && settings?.solidGround);
 ctrl.disabled = !enabled || mirrorLocked;
 });
 if(graphicsPanelHint) graphicsPanelHint.style.display = enabled ? 'none' : 'block';
 }

 function setOceanControlsEnabled(enabled){
 const settings = Scene.getOceanSettings ? Scene.getOceanSettings() : null;
 const oceanActive = !!settings?.enabled;
 const allow = enabled && oceanActive;
 Object.entries(oceanControls).forEach(([key, ctrl])=>{
 if(!ctrl) return;
 if(key === 'enable'){ ctrl.disabled = !enabled; return; }
 if(key === 'screenshot'){ ctrl.disabled = !allow; return; }
 ctrl.disabled = !allow;
 });
 if(oceanPanelHint) oceanPanelHint.style.display = allow ? 'none' : 'block';
 }

 function updateOceanButton(settings){
 if(!els.oceanSettingsBtn) return;
 const enabled = !!settings?.enabled;
 const presentActive = Scene.isPresentEnabled ? Scene.isPresentEnabled() : false;
 els.oceanSettingsBtn.classList.toggle('good', enabled && presentActive);
 els.oceanSettingsBtn.classList.toggle('warn', enabled && !presentActive);
 }

 function updateOceanDisplay(key, value){
 const span = oceanValueDisplays[key];
 if(!span) return;
 const formatter = oceanSliderFormatters[key];
 const num = Number(value);
 if(formatter){ span.textContent = formatter(num); }
 else if(Number.isFinite(num)){ span.textContent = num.toFixed(2); }
 else { span.textContent = value == null ? '' : String(value); }
 }

 function syncOceanSettings(){
 if(!Scene.getOceanSettings) return;
 const settings = Scene.getOceanSettings() || {};
 if(oceanControls.enable) oceanControls.enable.checked = !!settings.enabled;
 oceanRangeKeys.forEach((key)=>{
 const ctrl = oceanControls[key];
 if(!ctrl) return;
 const val = settings[key];
 if(val == null) return;
 ctrl.value = val;
 updateOceanDisplay(key, val);
 });
 oceanColorKeys.forEach((key)=>{
 const ctrl = oceanControls[key];
 if(!ctrl) return;
 if(settings[key]) ctrl.value = settings[key];
 });
 oceanToggleKeys.forEach((key)=>{
 const ctrl = oceanControls[key];
 if(!ctrl) return;
 ctrl.checked = !!settings[key];
 });
 const presentActive = Scene.isPresentEnabled ? Scene.isPresentEnabled() : false;
 setOceanControlsEnabled(presentActive);
 updateOceanButton(settings);
 }

 function showOceanPanel(){
 if(!oceanPanel) return;
 oceanPanelVisible = true;
 oceanPanel.style.display = 'block';
 syncOceanSettings();
 }

 function hideOceanPanel(){
 if(!oceanPanel) return;
 oceanPanelVisible = false;
 oceanPanel.style.display = 'none';
 }

 function toggleOceanPanel(){
 if(oceanPanelVisible) hideOceanPanel(); else showOceanPanel();
 }

 function updatePresentButton(state){
 if(!els.presentToggle) return;
 els.presentToggle.textContent = state ? '?? Present: ON' : '?? Present: OFF';
 if(state){ els.presentToggle.classList.add('good'); }
 else { els.presentToggle.classList.remove('good'); }
 }
 function updateDpadPresent(state){
 try{
 const btn = document.querySelector('#dpad .dp.present');
 if(!btn) return;
 btn.classList.toggle('active', state);
 btn.setAttribute('aria-pressed', state ? 'true' : 'false');
 btn.textContent = state ? ' ' : '?';
 btn.title = state ? 'Return to Create Mode' : 'Enter Present Mode';
 }catch(e){ console.warn('Update D-pad present failed', e); }
 }
 function syncPresentUI(state){
 const active = !!state;
 updatePresentButton(active);
 setGraphicsControlsEnabled(active);
 syncGraphicsSettings();
 setOceanControlsEnabled(active);
 syncOceanSettings();
 updateDpadPresent(active);
 }

 let lastCrystalState = document.body?.classList?.contains('crystal-2d') || false;
 function applyCrystalStyle(enabled){
 const want = !!enabled;
 if(els.crystalToggle && els.crystalToggle.checked !== want){
 els.crystalToggle.checked = want;
 }
 if(lastCrystalState === want){
 if(!want){ try{ document.body.classList.remove('crystal-2d'); }catch{} }
 return;
 }
 lastCrystalState = want;
 try{
 if(want){ document.body.classList.add('crystal-2d'); }
 else { document.body.classList.remove('crystal-2d'); }
 }catch{}
 }

 function showGraphicsPanel(){
 if(!graphicsPanel) return;
 graphicsPanelVisible = true;
 graphicsPanel.style.display = 'block';
 syncGraphicsSettings();
 setGraphicsControlsEnabled(Scene.isPresentEnabled ? Scene.isPresentEnabled() : false);
 }

 function hideGraphicsPanel(){
 if(!graphicsPanel) return;
 graphicsPanelVisible = false;
 graphicsPanel.style.display = 'none';
 }

 function toggleGraphicsPanel(){
 if(graphicsPanelVisible) hideGraphicsPanel(); else showGraphicsPanel();
 }

 function init(){
 console.log('UI.init: starting, checking elements...');
 console.log('UI.init: found elements:', {
 centerHome: !!els.centerHome,
 viewMainframe: !!els.viewMainframe,
 toggleGrid: !!els.toggleGrid,
 toggleAxes: !!els.toggleAxes,
 physicsBtn: !!els.physicsBtn,
 reset: !!els.reset
 });
 if(!Store.getState().ui?.crystal2D){
 try{ document.body.classList.remove('crystal-2d'); }catch{}
 lastCrystalState = false;
 if(els.crystalToggle){ els.crystalToggle.checked = false; }
 }
 // Touch-mode scaling
 try{ if(("ontouchstart" in window) || (navigator.maxTouchPoints>0) || (navigator.msMaxTouchPoints>0)){ document.body.classList.add('touch'); } }catch{}
 els.apply.onclick=()=>{ 
 const s=Store.getState().selection; if(!s.focus) return; 
 const anchor={arrId:s.arrayId,...s.focus};
 const formula=els.fx.value.trim();
 // Wrap user apply in a single atomic transaction
 const tx = Write.start('user.applyFx','User applying formula');
 Formula.executeAt(anchor, formula, tx);
 Write.commit(tx);
 updateFocusChip(); 
 };
 // 2D hover sync: detect hovered cell and propagate to 3D
 try{
 const sheetEl = document.getElementById('sheet');
 sheetEl?.addEventListener('mousemove', (e)=>{
 const td = e.target && e.target.closest && e.target.closest('td.cell');
 if(td){
 const x=+td.dataset.x, y=+td.dataset.y, z=+td.dataset.z; 
 const arrId = Store.getState().selection?.arrayId || Object.values(Store.getState().arrays)[0]?.id || 1;
 setHovered2D(arrId, {x,y,z});
 } else {
 setHovered2D(null, null);
 }
 }, true);
 sheetEl?.addEventListener('mouseleave', ()=> setHovered2D(null, null), true);
 }catch{}
 // Live syntax highlighting for formula input
 const syncFxHighlight = ()=>{
 const raw = els.fx.value || '';
 // Escape HTML
 const esc = (s)=> s.replace(/[&<>]/g, ch=> ({'&':'&amp;','<':'&lt;','>':'&gt;'}[ch]));
 let h = esc(raw);
 // Strings in double quotes
 h = h.replace(/"([^"\\]|\\.)*"/g, m=> `<span class="tok-str">${esc(m)}</span>`);
 // Ranges @[x,y,z,a]
 h = h.replace(/@\[\-?\d+\,\-?\d+\,\-?\d+\,\-?\d+\]/g, m=> `<span class="tok-range">${esc(m)}</span>`);
 // Numbers (standalone) avoid coloring inside quotes by running after strings
 h = h.replace(/(?<![A-Za-z0-9_@\"])(\-?\d+(?:\.\d+)?)(?![A-Za-z0-9_\"])/g, (m)=> `<span class="tok-num">${m}</span>`);
 els.fxHighlight.innerHTML = h || '';
 };
 // Keep formula bar and direct editor in sync in real time
 els.fx.addEventListener('input', ()=>{ 
 try{ if(els.direct && els.direct.style.display==='block'){ els.direct.value = els.fx.value; } }catch{}
 syncFxHighlight();
 });
 // Initialize once
 syncFxHighlight();
 els.fx.addEventListener('keydown',e=>{ if(e.key==='Enter'){ e.preventDefault(); e.stopPropagation(); els.apply.click(); els.fx.blur(); }});
 if(els.toggleFxPanel) els.toggleFxPanel.onclick=toggleFxPanel;
 if(els.fxClose) els.fxClose.onclick=toggleFxPanel;
 // Make the formula row reliably focus the input on single click
 try{
 const fxRow = document.querySelector('#sheet .sheet-fx');
 fxRow?.addEventListener('click', (ev)=>{ if(ev.target!==els.apply) els.fx.focus(); }, true);
 const fxHL = document.getElementById('fxHighlight');
 fxHL?.addEventListener('click', ()=> els.fx.focus(), true);
 }catch{}
 // Make sheet draggable with immediate response (no transition while dragging)
 const sheetEl=document.getElementById('sheet'); let drag=false, sx=0, sy=0, sl=0, st=0, prevTrans='';
 const beginDrag=(clientX, clientY)=>{ drag=true; sheetEl.classList.add('dragging'); sx=clientX; sy=clientY; const r=sheetEl.getBoundingClientRect(); sl=r.left; st=r.top; prevTrans=sheetEl.style.transition; sheetEl.style.transition='none'; // kill easing
 // If mobile intro left a centering transform, clear it so absolute dragging is literal
 sheetEl.style.transform='none';
 if(document.body.classList.contains('touch')){ sheetEl.dataset.touchFreed = '1'; }
 };
 const moveDrag=(clientX, clientY)=>{ if(!drag) return; const dx=clientX-sx, dy=clientY-sy; sheetEl.style.left=(sl+dx)+'px'; sheetEl.style.top=(st+dy)+'px'; sheetEl.style.bottom='auto'; };
 const endDrag=()=>{ if(!drag) return; drag=false; sheetEl.classList.remove('dragging'); sheetEl.style.transition=prevTrans||''; };
 sheetEl.addEventListener('mousedown',e=>{ if(e.target.closest('.sheet-head')){ beginDrag(e.clientX, e.clientY); e.preventDefault(); }});
 window.addEventListener('mousemove',e=> moveDrag(e.clientX, e.clientY));
 window.addEventListener('mouseup', endDrag);
 // Pointer events for touch
 sheetEl.addEventListener('pointerdown',e=>{ if(e.pointerType==='touch' && e.target.closest('.sheet-head')){ beginDrag(e.clientX, e.clientY); e.preventDefault(); sheetEl.setPointerCapture?.(e.pointerId); }});
 window.addEventListener('pointermove',e=>{ if(e.pointerType==='touch') moveDrag(e.clientX, e.clientY); });
 window.addEventListener('pointerup',e=>{ if(e.pointerType==='touch') endDrag(); });
 // Resizable via corner handle
 const res=document.getElementById('sheetResizer'); let resizing=false, rw=0,rh=0,rx=0,ry=0, resizePrevTrans='';
 res.addEventListener('mousedown',e=>{ resizing=true; const r=sheetEl.getBoundingClientRect(); rw=r.width; rh=r.height; rx=e.clientX; ry=e.clientY; resizePrevTrans=sheetEl.style.transition; sheetEl.style.transition='none'; e.stopPropagation(); e.preventDefault(); });
 window.addEventListener('mousemove',e=>{ if(!resizing) return; const dw=e.clientX-rx, dh=e.clientY-ry; sheetEl.style.width=(rw+dw)+'px'; sheetEl.style.height=(rh+dh)+'px'; });
 window.addEventListener('mouseup',()=>{ if(!resizing) return; resizing=false; sheetEl.style.transition=resizePrevTrans||''; });

 if(els.centerHome) els.centerHome.onclick=()=>{ const home=Store.getState().arrays[1]; if(home){ Scene.centerOnArray(home); Actions.setSelection(1,{x:0,y:2,z:0}); }};
 if(els.viewMainframe) els.viewMainframe.onclick=()=>{
 const mf=Store.getState().arrays[-1];
 if(mf){
 // Diegetic toggle: write formula to a control cell and execute
 const anchor={arrId:-1,x:0,y:mf.size.y-1,z:0};
 const currentlyHidden=!!mf.hidden;
 const formula = currentlyHidden? '=HIDE(@[0,'+(mf.size.y-1)+',0,-1],0,1)' : '=HIDE(@[0,'+(mf.size.y-1)+',0,-1],1,1)';
 Formula.executeAt(anchor, formula);
 // Move camera to show mainframe at its offset position
 const off = mf.offset || {x:0,y:0,z:0};
 Scene.getControls().target.set(off.x, off.y, off.z);
 Scene.getCamera().position.set(off.x + mf.size.x*1.2, off.y + mf.size.y*1.2, off.z + mf.size.z*1.8);
 Actions.setSelection(-1,{x:0,y:mf.size.y-1,z:0}); 
 UI.renderSheet(); // refresh 2D view
 }
 };
 if(els.toggleGrid) els.toggleGrid.onclick=Actions.toggleGrid;
 if(els.toggleAxes) els.toggleAxes.onclick=Actions.toggleAxes;
 if(els.celliCollapse && !els.celliCollapse._wired){
 els.celliCollapse._wired = true;
 els.celliCollapse.addEventListener('click',()=>{
 try{ triggerSelectionCollapse(); }catch(e){ console.warn('Collapse trigger failed', e); }
 });
 }
 const presentInitial = Scene.isPresentEnabled ? Scene.isPresentEnabled() : false;
 syncPresentUI(presentInitial);
 if(els.presentToggle){
 els.presentToggle.onclick=()=>{
 const state = Actions.togglePresentMode();
 const actual = Scene.isPresentEnabled ? Scene.isPresentEnabled() : state;
 syncPresentUI(actual);
 };
 }
 applyCrystalStyle(Store.getState().ui?.crystal2D);
 if(els.crystalToggle){
 els.crystalToggle.checked = !!Store.getState().ui?.crystal2D;
 if(!els.crystalToggle._wired){
 els.crystalToggle._wired = true;
 els.crystalToggle.addEventListener('change',(e)=>{
 Actions.setCrystal2D?.(!!e.target.checked);
 });
 }
 }
 if(els.graphicsSettingsBtn){
 els.graphicsSettingsBtn.onclick=()=>{ toggleGraphicsPanel(); };
 }
 if(graphicsClose && !graphicsClose._wired){
 graphicsClose._wired = true;
 graphicsClose.addEventListener('click',(e)=>{ e.preventDefault(); hideGraphicsPanel(); });
 }
 if(els.oceanSettingsBtn){
 els.oceanSettingsBtn.onclick=()=>{
 // Auto-enable ocean when opening settings
 Actions.setOceanEnabled(true);
 if(!(Scene.isPresentEnabled ? Scene.isPresentEnabled() : false)){
 Actions.togglePresentMode();
 syncPresentUI(true);
 }
 toggleOceanPanel();
 };
 }
 if(els.oceanSpottedBtn && !els.oceanSpottedBtn._wired){
 els.oceanSpottedBtn._wired = true;
 els.oceanSpottedBtn.addEventListener('click',()=>{
 try{
 Actions.setOceanEnabled(true);
 if(!(Scene.isPresentEnabled ? Scene.isPresentEnabled() : false)){
 Actions.togglePresentMode();
 syncPresentUI(true);
 }
 const started = Scene.startSpottedSequence?.();
 if(!started){
 console.warn('Spotted sequence could not start (already active?)');
 showToast?.('Spotlight already tracking Celli.');
 }
 }catch(err){
 console.warn('Failed to trigger spotted sequence', err);
 showToast?.('Unable to trigger spotted sequence.');
 }
 });
 }
 if(oceanClose && !oceanClose._wired){
 oceanClose._wired = true;
 oceanClose.addEventListener('click',(e)=>{ e.preventDefault(); hideOceanPanel(); });
 }
 if(els.physicsBtn && !els.physicsBtn._wired){
 els.physicsBtn._wired = true;
 // Update button appearance based on current debug state
 const updatePhysicsButtonAppearance = ()=>{
 const debugMode = !!Store.getState().scene?.physicsDebugAll;
 const physicsActive = !!Store.getState().scene?.physics;
 if(debugMode){
 els.physicsBtn.textContent = physicsActive ? '? Physics (DEBUG) ON' : '? Physics (DEBUG)';
 els.physicsBtn.classList.add('warn');
 } else {
 els.physicsBtn.textContent = physicsActive ? '? Physics ON' : '? Physics';
 els.physicsBtn.classList.remove('warn');
 }
 els.physicsBtn.title = debugMode ? 'Shift+Click: Disable Debug Mode | Click: Toggle Physics' : 'Shift+Click: Enable Debug Mode (All Arrays) | Click: Toggle Physics';
 };
 updatePhysicsButtonAppearance();
 els.physicsBtn.addEventListener('click',(ev)=>{
 try{ ev?.preventDefault?.(); }catch{}
 try{ els.physicsBtn.blur(); }catch{}
 // Shift-click to toggle debug mode (enables physics on all arrays)
 if(ev?.shiftKey){
 const current = !!Store.getState().scene?.physicsDebugAll;
 console.log(`[PHYSICS DEBUG] Shift-click detected - current state: ${current}`);
 console.log(`[PHYSICS DEBUG] Calling Scene.setPhysicsDebugAll(${!current})`);
 Scene.setPhysicsDebugAll?.(!current);
 const newState = !!Store.getState().scene?.physicsDebugAll;
 console.log(`[PHYSICS DEBUG] After call, scene.physicsDebugAll = ${newState}`);
 updatePhysicsButtonAppearance();
 showToast?.(newState ? '?? Physics Debug: ALL arrays physics-enabled' : '? Physics Debug: Disabled');
 } else {
 console.log(`[PHYSICS] Normal click on physics button`);
 Actions.togglePhysics();
 // Update button after physics toggle
 setTimeout(()=> updatePhysicsButtonAppearance(), 100);
 }
 });
 }
 // Render mode button removed - always simple mode
 if(els.reset) els.reset.onclick=()=>location.reload();
 // Toggle Chunk LOD manager
 const chunksBtn = document.getElementById('toggleChunks');
 if(chunksBtn){
 chunksBtn.textContent = 'Chunks: ON';
 chunksBtn.classList.add('good');
 chunksBtn.disabled = true;
 chunksBtn.title = 'Chunk mode is always ON';
 }

 const checkboxBindings = {
 hdri:'hdri', lights:'lights', darkBg:'darkBg', bloom:'bloomEnabled',
 dof:'dofEnabled', transmission:'transmission', mirror:'mirror', ground:'solidGround', waveGrid:'waveGrid',
 fxaa:'fxaa', fog:'fogEnabled', outline:'outlineEnabled', motion:'motionEnabled'
 };
 Object.entries(checkboxBindings).forEach(([key, setting])=>{
 const ctrl = graphicsControls[key];
 if(!ctrl) return;
 ctrl.addEventListener('change',(e)=>{
 if(setting === 'solidGround'){
 const next = !!e.target.checked;
 const patch = next ? { solidGround: true, mirror: false } : { solidGround: false };
 Actions.updateGraphicsSettings(patch);
 }else{
 Actions.updateGraphicsSettings({ [setting]: !!e.target.checked });
 }
 syncGraphicsSettings();
 });
 });

 const rangeBindings = {
 bloomStrength:'bloomStrength',
 bloomRadius:'bloomRadius',
 exposure:'exposure',
 dofAperture:'dofAperture',
 dofMaxBlur:'dofMaxBlur',
 lightRotation:'lightRotation',
 lightStrength:'lightStrength',
 fogDensity:'fogDensity',
 outlineStrength:'outlineStrength',
 outlineThickness:'outlineThickness',
 motionDamping:'motionDamping'
 };
 Object.entries(rangeBindings).forEach(([key, setting])=>{
 const ctrl = graphicsControls[key];
 if(!ctrl) return;
 ctrl.addEventListener('input',(e)=>{
 const value = parseFloat(e.target.value);
 Actions.updateGraphicsSettings({ [setting]: value });
 updateSliderDisplay(key, value);
 });
 });

 if(oceanControls.enable){
 oceanControls.enable.addEventListener('change',(e)=>{
 const desired = !!e.target.checked;
 Actions.setOceanEnabled(desired);
 if(desired && !(Scene.isPresentEnabled ? Scene.isPresentEnabled() : false)){
 showToast?.('Enable Present mode to view the ocean backdrop.');
 }
 syncOceanSettings();
 });
 }

 oceanRangeKeys.forEach((key)=>{
 const ctrl = oceanControls[key];
 if(!ctrl) return;
 ctrl.addEventListener('input',(e)=>{
 const value = parseFloat(e.target.value);
 if(!Number.isFinite(value)) return;
 Actions.updateOceanSettings({ [key]: value });
 updateOceanDisplay(key, value);
 // Rebuild grid when density changes
 if(key === 'gridDensity'){
 try{
 OceanBackdrop?.recreateGrid?.();
 }catch(e){
 console.warn('Failed to rebuild ocean grid:', e);
 }
 }
 });
 });

 oceanColorKeys.forEach((key)=>{
 const ctrl = oceanControls[key];
 if(!ctrl) return;
 ctrl.addEventListener('input',(e)=>{
 const value = e.target.value;
 Actions.updateOceanSettings({ [key]: value });
 });
 });

 oceanToggleKeys.forEach((key)=>{
 const ctrl = oceanControls[key];
 if(!ctrl) return;
 ctrl.addEventListener('change',(e)=>{
 Actions.updateOceanSettings({ [key]: !!e.target.checked });
 });
 });

 if(oceanControls.screenshot && !oceanControls.screenshot._wired){
 oceanControls.screenshot._wired = true;
 oceanControls.screenshot.addEventListener('click',(e)=>{
 e.preventDefault();
 Scene.captureOceanScreenshot?.();
 });
 }

 syncGraphicsSettings();
 syncOceanSettings();

 // Save/Load buttons
 try{
 const saveBtn=document.getElementById('saveStateBtn');
 const loadBtn=document.getElementById('loadStateBtn');
 const clearBtn=document.getElementById('clearSaveBtn');
 if(saveBtn && !saveBtn._wired){ 
 saveBtn._wired=true; 
 saveBtn.addEventListener('click', ()=>{ 
 try{ 
 Store.getState().actions.saveState();
 const statusEl = document.getElementById('saveStatus');
 if(statusEl) statusEl.textContent = `Manual save: ${new Date().toLocaleTimeString()}`;
 }catch(e){ console.warn('save click failed', e); } 
 }); 
 }
 if(loadBtn && !loadBtn._wired){ loadBtn._wired=true; loadBtn.addEventListener('click', ()=>{ try{ Store.getState().actions.loadState(); }catch(e){ console.warn('load click failed', e); } }); }
 if(clearBtn && !clearBtn._wired){ clearBtn._wired=true; clearBtn.addEventListener('click', ()=>{ try{ Store.getState().actions.resetSave(); }catch(e){ console.warn('clear save click failed', e); } }); }
 
 // Parse emojis in debug UI
 if(typeof twemoji !== 'undefined'){
 try{ twemoji.parse(document.getElementById('hud'), {folder: 'svg', ext: '.svg', className: 'emoji'}); }catch{}
 }
 }catch{}

 // --- Import Functionality Wiring ---
 try{
 const fileInput = document.getElementById('fileImporter');
 const importBtn = document.getElementById('importFileBtn');
 const pasteBtn = document.getElementById('pasteDataBtn');
 const pasteModal = document.getElementById('pasteModal');
 const pasteInput = document.getElementById('pasteDataInput');
 const processPasteBtn = document.getElementById('processPasteBtn');
 const cancelPasteBtn = document.getElementById('cancelPasteBtn');

 if(importBtn) importBtn.onclick = ()=> fileInput && fileInput.click();
 if(fileInput) fileInput.onchange = (e)=>{
 const file = e.target.files && e.target.files[0];
 if(file){ const r=new FileReader(); r.onload=(ev)=> handleImportedData(ev.target.result, file.name); r.readAsArrayBuffer(file); }
 e.target.value='';
 };
 if(pasteBtn) pasteBtn.onclick=()=>{ if(pasteModal){ pasteModal.style.display='flex'; pasteInput && pasteInput.focus(); } };
 if(cancelPasteBtn) cancelPasteBtn.onclick=()=>{ if(pasteModal) pasteModal.style.display='none'; };
 if(processPasteBtn) processPasteBtn.onclick=()=>{
 const data = pasteInput ? pasteInput.value : '';
 if(String(data||'').trim()) handleImportedData(data, 'PastedData');
 if(pasteModal) pasteModal.style.display='none';
 };

 // Global drag-and-drop
 const dropZone = document.body;
 const overlay = document.getElementById('introOverlay');
 dropZone.addEventListener('dragover',(e)=>{ e.preventDefault(); e.stopPropagation(); if(overlay){ overlay.style.opacity='0.5'; overlay.classList.remove('hidden'); } });
 dropZone.addEventListener('dragleave',(e)=>{ e.preventDefault(); e.stopPropagation(); if(overlay){ overlay.classList.add('hidden'); overlay.style.opacity='1'; } });
 dropZone.addEventListener('drop',(e)=>{ e.preventDefault(); e.stopPropagation(); if(overlay){ overlay.classList.add('hidden'); overlay.style.opacity='1'; }
 const f=e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0]; if(f){ const r=new FileReader(); r.onload=(ev)=> handleImportedData(ev.target.result, f.name); r.readAsArrayBuffer(f); }
 });
 }catch{}

 // Wire up the new color picker (+ Live / Apply / Clear)
 try{
 const picker = document.getElementById('fillColorPicker');
 const swatch = document.getElementById('fillColorSwatch');
 const live = document.getElementById('fillColorLive');
 const applyBtn = document.getElementById('fillColorApply');
 const clearBtn = document.getElementById('fillColorClear');

 function applyColorToSelection(hexOrEmpty){
 const s = Store.getState().selection;
 if (!s?.arrayId || !(s.focus || s.range)) return;

 const tx = Write.start('ui.colorPicker', 'Apply color to selection');
 const cells = [];
 if (s.range) {
 const zStart = s.range.z1 ?? s.range.z;
 const zEnd = s.range.z2 ?? s.range.z;
 for(let z=zStart; z<=zEnd; z++){
 for(let y=s.range.y1; y<=s.range.y2; y++){
 for(let x=s.range.x1; x<=s.range.x2; x++){
 cells.push({x, y, z});
 }
 }
 }
 } else {
 cells.push({...s.focus});
 }

 for(const coord of cells){
 const cell = Scene.getCell(s.arrayId, coord);
 Write.set(tx, s.arrayId, coord, {
 value: cell.value,
 formula: cell.formula,
 meta: { ...(cell.meta||{}), ...(hexOrEmpty ? {color:hexOrEmpty} : {color: ''}) }
 });
 }
 Write.commit(tx);
 }

 if(picker && !picker._wired){
 picker._wired = true;
 // Toggle popover when swatch clicked
 const wrap = document.getElementById('color-picker-wrapper');
 let pop = document.getElementById('colorPopover');
 if(!pop){
 pop = document.createElement('div');
 pop.id = 'colorPopover';
 pop.style.cssText = 'position:absolute; z-index:10020; background:#ffffff; border:1px solid #e5e7eb; border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,0.18); padding:10px; display:none;';
 document.body.appendChild(pop);
 // Prevent clicks inside from closing
 pop.addEventListener('click', (ev)=> ev.stopPropagation());
 }
 if(wrap && !wrap._popover){
 wrap._popover = true;
 // Build in-popover controls (Live | Apply | Clear) and hide external buttons
 try{
 if(pop && !pop._controls){
 pop._controls = true;
 const ctrl = document.createElement('div');
 ctrl.id = 'colorControlsInside';
 ctrl.style.cssText = 'display:flex;gap:8px;align-items:center;margin-top:8px;';
 ctrl.innerHTML = '<button id="fillColorApplyInside" class="btn" style="padding:4px 8px;">Apply</button><button id="fillColorClearInside" class="btn" style="padding:4px 8px;">Clear</button>';
 pop.appendChild(ctrl);
 // Wire
 const applyInside = ctrl.querySelector('#fillColorApplyInside');
 const clearInside = ctrl.querySelector('#fillColorClearInside');
 applyInside?.addEventListener('click', ()=> applyColorToSelection(picker?.value||'#ffffff'));
 clearInside?.addEventListener('click', ()=> applyColorToSelection(''));
 // Hide external controls in sheet toolbar (including old Live and bar preview)
 try{
 if(applyBtn) applyBtn.style.display='none';
 if(clearBtn) clearBtn.style.display='none';
 if(live){ const lab=live.closest('label'); if(lab) lab.style.display='none'; live.style.display='none'; }
 const bar = document.getElementById('fillColorPreview'); if(bar) bar.style.display='none';
 }catch{}
 }
 }catch{}
 wrap.addEventListener('click', (e)=>{
 e.stopPropagation();
 if(pop){
 const rect = wrap.getBoundingClientRect();
 const belowPickerOffset = 260; // place well below native color UI
 const desiredTop = rect.bottom + belowPickerOffset;
 const maxTop = Math.max(0, (window.innerHeight||800) - 120);
 pop.style.left = Math.max(8, Math.min(rect.left, (window.innerWidth||1200) - 220)) + 'px';
 pop.style.top = Math.min(desiredTop, maxTop) + 'px';
 pop.style.display = (pop.style.display==='none'||!pop.style.display) ? 'block' : 'none';
 }
 });
 document.addEventListener('click', ()=>{ if(pop) pop.style.display='none'; }, true);
 }
 picker.addEventListener('input', (e)=>{
 const newColor = String(e.target.value||'').trim();
 if(swatch) swatch.style.backgroundColor = newColor;
 // Live apply is ON by default
 try{ applyColorToSelection(newColor); }catch{}
 });
 }

 // External buttons are deprecated; ensure hidden; hide external Live and bar preview too
 if(applyBtn){ applyBtn.style.display='none'; }
 if(clearBtn){ clearBtn.style.display='none'; }
 if(live){ const lab=live.closest('label'); if(lab) lab.style.display='none'; live.style.display='none'; }
 const bar = document.getElementById('fillColorPreview'); if(bar) bar.style.display='none';
 }catch{}

 // Wire up the new view toggle button
 try{
 const viewToggleBtn = document.getElementById('viewToggleBtn');
 const viewToggleIcon = document.getElementById('viewToggleIcon');
 if(viewToggleBtn && !viewToggleBtn._wired){
 viewToggleBtn._wired = true;
 viewToggleBtn.addEventListener('click', ()=>{
 const S=Store.getState(); const current=S.ui.viewMode||'standard';
 let next='standard';
 // Cycle: standard (gray) -> solid (blue) -> hideEmpty (white) -> standard
 if(current==='standard') next='solid';
 else if(current==='solid') next='hideEmpty';
 else next='standard';

 // Update button fill and stroke per spec
 if(next==='standard'){ // gray fill
 if(viewToggleBtn) viewToggleBtn.style.backgroundColor = '#9ca3af';
 if(viewToggleIcon) viewToggleIcon.style.stroke = '#ffffff';
 showToast('View: Standard Occlusion');
 } else if(next==='solid'){ // blue fill
 if(viewToggleBtn) viewToggleBtn.style.backgroundColor = '#3b82f6';
 if(viewToggleIcon) viewToggleIcon.style.stroke = '#ffffff';
 showToast('View: Solid');
 } else { // hideEmpty: white fill
 if(viewToggleBtn) viewToggleBtn.style.backgroundColor = '#ffffff';
 if(viewToggleIcon) viewToggleIcon.style.stroke = '#5b6170';
 showToast('View: Hide Empty');
 }

 Store.setState(s=>({ ui:{...s.ui, viewMode:next} }));
 // Apply mode immediately to scene
 try{ Scene && Scene.applyViewMode && Scene.applyViewMode(next); }catch{}
 // Reposition value sprites after mode switch (face alignment retained)
 try{ const arrays=Object.values(Store.getState().arrays); arrays.forEach(a=>{ if(!a.hidden && a._frame) updateArrayValueSpritePlacement(a); }); }catch{}
 });

 // Initialize button to current state on load
 const cur = Store.getState().ui.viewMode || 'standard';
 if(cur==='standard'){ viewToggleBtn.style.backgroundColor='#9ca3af'; viewToggleIcon && (viewToggleIcon.style.stroke='#ffffff'); }
 if(cur==='solid'){ viewToggleBtn.style.backgroundColor='#3b82f6'; viewToggleIcon && (viewToggleIcon.style.stroke='#ffffff'); }
 if(cur==='hideEmpty'){ viewToggleBtn.style.backgroundColor='#ffffff'; viewToggleIcon && (viewToggleIcon.style.stroke='#5b6170'); }
 try{ Scene && Scene.applyViewMode && Scene.applyViewMode(cur); }catch{}
 }
 }catch{}
 // Narrative icon wiring
 const termIcon=document.getElementById('terminal-icon');
 // Dedicated debug icon bottom-left (create once, no duplicate flicker)
 let debugIcon=document.getElementById('debug-icon');
 if(!debugIcon){
 debugIcon=document.createElement('div');
 debugIcon.id='debug-icon';
 debugIcon.className='ui-icon';
 debugIcon.style.left='24px';
 debugIcon.style.bottom='24px';
 debugIcon.innerHTML='<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="14" rx="2" ry="2"></rect><line x1="8" y1="21" x2="16" y2="21"></line><line x1="12" y1="17" x2="12" y2="21"></line></svg>';
 document.body.appendChild(debugIcon);
 }
 const padIcon=document.getElementById('notepad-icon');
 const termWin=document.getElementById('terminal');
 const termOut=document.getElementById('term');
 const termClose=document.getElementById('term-close');
 const padWin=document.getElementById('pad');
 // Ensure console windows are hidden on load
 try{ if(termWin) termWin.style.display='none'; if(padWin) padWin.style.display='none'; }catch{}
 const padClose=document.getElementById('pad-close');
 const toast=document.getElementById('toast');
 const showToast2=(msg)=>{ if(toast){ toast.textContent=msg; toast.classList.add('show'); setTimeout(()=>toast.classList.remove('show'),2200); } };
 // Track last pointer type to distinguish touch vs keyboard/mouse
 let lastPointerType = 'mouse';
 window.addEventListener('pointerdown', (e)=>{ lastPointerType = e.pointerType || 'mouse'; }, {passive:true});
 // Make both windows draggable by their headers
 const makeDrag=(winEl)=>{
 const header=winEl?.querySelector('.win-header'); if(!header) return; let down=false,sx=0,sy=0,sl=0,st=0;
 header.addEventListener('mousedown',e=>{ down=true; sx=e.clientX; sy=e.clientY; const r=winEl.getBoundingClientRect(); sl=r.left; st=r.top; e.preventDefault(); });
 window.addEventListener('mousemove',e=>{ if(!down) return; const dx=e.clientX-sx, dy=e.clientY-sy; winEl.style.left=(sl+dx)+'px'; winEl.style.top=(st+dy)+'px'; winEl.style.transform='translate(0,0)'; });
 window.addEventListener('mouseup',()=>{ down=false; });
 };
 const makeResizable=(winEl)=>{
 if(!winEl) return;
 const handle=winEl.querySelector('.pad-resizer');
 if(!handle || handle._wired) return;
 handle._wired=true;
 handle.addEventListener('pointerdown', (e)=>{
 e.preventDefault();
 handle.setPointerCapture?.(e.pointerId);
 const rect=winEl.getBoundingClientRect();
 const startX=e.clientX, startY=e.clientY;
 const startW=rect.width, startH=rect.height;
 const minW=320, minH=220;
 const move=(evt)=>{
 const nextW=Math.max(minW, startW + (evt.clientX - startX));
 const nextH=Math.max(minH, startH + (evt.clientY - startY));
 winEl.style.width=nextW+'px';
 winEl.style.height=nextH+'px';
 };
 const up=()=>{
 try{ handle.releasePointerCapture && handle.hasPointerCapture && handle.hasPointerCapture(e.pointerId) && handle.releasePointerCapture(e.pointerId); }
 catch{}
 window.removeEventListener('pointermove', move);
 window.removeEventListener('pointerup', up);
 window.removeEventListener('pointercancel', up);
 };
 window.addEventListener('pointermove', move);
 window.addEventListener('pointerup', up, {once:true});
 window.addEventListener('pointercancel', up, {once:true});
 });
 };
 if(padWin) makeResizable(padWin);
 const openTerm=()=>{ const el=document.getElementById('terminal'); if(el){ el.style.display='flex'; makeDrag(el); runLogPaced(); } };
 const closeTerm=()=>{ if(termWin){ termWin.style.display='none'; } };
 const openPad=()=>{ const el=document.getElementById('pad'); if(el){ el.style.display='flex'; const term=document.getElementById('terminal'); if(term){ el.style.width = getComputedStyle(term).width; } makeDrag(el); makeResizable(el); } };
 const closePad=()=>{ if(padWin){ padWin.style.display='none'; } };
 const wireNarrative=()=>{
 const ti=document.getElementById('terminal-icon');
 const pi=document.getElementById('notepad-icon');
 const tc=document.getElementById('term-close');
 const pc=document.getElementById('pad-close');
 if(ti && !ti._wired){ ti._wired=true; ti.addEventListener('click',()=>{ console.log('Terminal icon click'); openTerm(); }, false); ti.tabIndex=0; ti.title='Open Celli_Log.txt'; }
 if(pi && !pi._wired){ pi._wired=true; pi.addEventListener('click',()=>{ console.log('Notepad icon click'); openPad(); }, false); pi.tabIndex=0; pi.title='ty.txt'; }
 if(tc && !tc._wired){ tc._wired=true; tc.addEventListener('click',()=>{ console.log('Terminal close'); closeTerm(); }); }
 if(pc && !pc._wired){ pc._wired=true; pc.addEventListener('click',()=>{ console.log('Notepad close'); closePad(); }); }
 };
 wireNarrative();
 // Debug panel collapse/expand via icon; ensure stacking above other UI
 const hud=document.getElementById('hud');
 const dbg=document.getElementById('debug-icon');
 // Hide HUD on load; terminal/notepad already hidden above
 try{ if(hud){ hud.style.display='none'; hud.style.visibility='hidden'; } }catch{}
 // Robust toggle helper
 const toggleHud=()=>{
 try{
 const el=document.getElementById('hud'); if(!el) return;
 const isHidden = (el.style.display==='none' || el.style.visibility==='hidden' || getComputedStyle(el).display==='none');
 if(isHidden){ el.style.display='block'; el.style.visibility='visible'; }
 else { el.style.display='none'; el.style.visibility='hidden'; }
 el.style.zIndex = '10004';
 }catch{}
 };
 const debugCloseBtn = document.getElementById('debug-close');
 if(debugCloseBtn && !debugCloseBtn._wired){
 debugCloseBtn._wired = true;
 debugCloseBtn.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); try{ hud.style.display='none'; }catch{} });
 }
 if(dbg && !dbg._wired){
 dbg._wired = true;
 let lastHudToggle = 0;
 const safeToggle = ()=>{ const now=Date.now(); if(now - lastHudToggle < 220) return; lastHudToggle = now; toggleHud(); };
 dbg.addEventListener('click', (e)=>{ e.preventDefault(); safeToggle(); });
 // Also handle pointerup (covers touch) to ensure one, reliable toggle
 dbg.addEventListener('pointerup', (e)=>{ if(e.button===0 || e.pointerType){ e.preventDefault(); safeToggle(); } });
 dbg.setAttribute('title','Debug Console');
 dbg.setAttribute('role','button');
 dbg.tabIndex = 0;
 dbg.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' '){ e.preventDefault(); safeToggle(); }});
 }
 setTimeout(wireNarrative,0);
 setTimeout(wireNarrative,500);

 // Hard fallback: ensure a first click on any 2D cell will trigger intro if not yet fired
 try{
 const sheetWrap = document.getElementById('sheet');
 if(sheetWrap && !sheetWrap._introFallbackWired){
 const handler = (ev)=>{
 try{
 if(window.__INTRO_FIRED) return; // Already handled
 const td = ev.target && ev.target.closest ? ev.target.closest('td.cell') : null;
 // Prefer current selection post-re-render (more reliable than original target)
 const sel = Store.getState().selection || {};
 const useSel = sel && sel.arrayId!=null && sel.focus;
 const x = useSel ? sel.focus.x : ((td && +td.dataset.x) || 0);
 const y = useSel ? sel.focus.y : ((td && +td.dataset.y) || 0);
 const z = useSel ? sel.focus.z : ((td && +td.dataset.z) || 0);
 const arrId = useSel ? sel.arrayId : ((currentArray()?.id) || 1);
 const tx = Write.start('onclick.fallback','Intro fallback');
 Formula.runOnceAt({arrId:arrId, x, y, z}, '=STARTINTROEXPERIENCE()', tx);
 Write.commit(tx);
 // Also trigger UI path to guarantee overlay collapse
 UI.debugIntroState?.('fallback-click');
 const didHide = window.UI?.hideIntroOverlay?.();
 if(didHide){ window.__INTRO_FIRED = true; window.UI?.triggerIntroCollapse?.(); UI.debugIntroState?.('fallback-collapsed'); }
 else { UI.kickIntroSequence?.('fallback-click'); }
 }catch(e){ console.warn('Intro fallback click failed', e); }
 };
 // Use multiple events for robustness across re-renders
 sheetWrap.addEventListener('mouseup', handler, true);
 sheetWrap.addEventListener('pointerup', handler, true);
 sheetWrap.addEventListener('click', handler, true);
 sheetWrap._introFallbackWired = true;
 }
 }catch{}

 // Global clipboard shortcuts: Ctrl/Cmd+C / Ctrl/Cmd+V
 try{
 window.addEventListener('keydown', async (e)=>{
 const isMod = e.ctrlKey || e.metaKey;
 if(!isMod) return;
 // Let inputs handle their own clipboard behavior
 const tag = (document.activeElement?.tagName||'').toUpperCase();
 if(tag==='INPUT' || tag==='TEXTAREA') return;

 const state = Store.getState();
 const sel = state?.selection;
 if(!sel || !sel.arrayId || !sel.focus) return;
 const arrId = sel.arrayId, {x,y,z} = sel.focus;

 // Copy value (never formula)
 if(e.key==='c' || e.key==='C'){
 e.preventDefault();
 try{
 const val = Formula.getCellValue({arrId, x, y, z});
 await navigator.clipboard.writeText(String(val??''));
 showToast('Copied');
 }catch(err){ console.warn('Clipboard copy failed', err); }
 return;
 }

 // Paste as literal value (do not treat leading '=' as formula)
 if(e.key==='v' || e.key==='V'){
 e.preventDefault();
 try{
 const text = await navigator.clipboard.readText();
 const tx = Write.start('user.paste','Paste into cell');
 Write.set(tx, arrId, {x,y,z}, { value: text, formula: null });
 Write.commit(tx);
 UI.updateFocusChip?.();
 }catch(err){ console.warn('Clipboard paste failed', err); }
 return;
 }
 }, true);
 }catch{}

 // Terminal narrative (reference-grade): paced typer, CPU meter, glitch/glow arc
 let T=[], I=[], cpuPhase=0, cpuVal=10, cpuPaused=false, cpuHold=0, cpuBurstUntil=0;
 const later=(ms,fn)=>{ const id=setTimeout(fn,ms); T.push(id); return id; };
 const every=(ms,fn)=>{ const id=setInterval(fn,ms); I.push(id); return id; };
 function killTimers(){ T.forEach(clearTimeout); I.forEach(clearInterval); T=[]; I=[]; cpuPhase=0; cpuBurstUntil=0; cpuPaused=false; cpuHold=0; }
 function pauseCpu(ms){ cpuHold++; cpuPaused=true; later(ms, ()=>{ cpuHold=Math.max(0,cpuHold-1); if(cpuHold===0) cpuPaused=false; }); }
 function cpuBurst(ms){ const start = Math.max(Date.now(), cpuBurstUntil); cpuBurstUntil = start + ms; }
 function dwellMsFor(text, {base=900, perWord=240, comma=140, period=420, question=460, exclaim=460, ellipsis=600, factor=1}={}){
 const words=(text.trim().split(/\s+/).filter(Boolean)).length;
 const c=(text.match(/,/g)||[]).length; const p=(text.match(/[\.]/g)||[]).length;
 const q=(text.match(/[\?]/g)||[]).length; const e=(text.match(/[!]/g)||[]).length; const el=(text.match(/ |\.{3}/g)||[]).length;
 return Math.round((base + words*perWord + c*comma + p*period + q*question + e*exclaim + el*ellipsis)*factor);
 }
 function typeInto(target, text, {speed=22, prefix='> ', cls='soft', glitch=false, dwellFactor=1, minType=500, scripted=true}={}){
 const s=document.createElement('span'); s.className='cursor '+cls+(glitch?' glitch':''); if(glitch) s.dataset.text=''; s.textContent=prefix; target.appendChild(s);
 const extraPause=(scripted && !glitch)? (3000+Math.floor(Math.random()*2000)) : 0;
 let i=0; (function tick(){ if(i<text.length){ const ch=text.charAt(i++); if(glitch) s.dataset.text+=ch; s.textContent+=ch; target.scrollTop=target.scrollHeight; later(speed, tick);} else { s.classList.remove('cursor'); target.appendChild(document.createElement('br')); if(extraPause>0) pauseCpu(extraPause);} })();
 const typeDur=Math.max(minType, text.length*speed+200); const dwell=dwellMsFor(text,{factor:dwellFactor});
 return typeDur + dwell + extraPause;
 }
 function echoThought(text, repeats=3, {baseSpeed=20, decay=0.5, startGap=160, artifact=false, dwellFactor=0.6, scripted=false}={}){
 for(let i=0;i<repeats;i++) later(i*startGap, ()=> typeInto(termOut, text, {speed:Math.max(10, baseSpeed - i*baseSpeed*decay), cls: artifact? 'artifact':'soft', dwellFactor, scripted}));
 return repeats*startGap + dwellMsFor(text,{factor:dwellFactor});
 }
 function forkThought(textL, textR, {speed=20, cls='soft', dwellFactor=0.9, scripted=false}={}){
 const wrap=document.createElement('div'); wrap.className='lane-wrap'; const left=document.createElement('div'); left.className='lane'; const right=document.createElement('div'); right.className='lane';
 termOut.appendChild(wrap); wrap.appendChild(left); wrap.appendChild(right);
 const d1=typeInto(left, textL, {speed, cls, dwellFactor, scripted}); const d2=typeInto(right, textR, {speed, cls, dwellFactor, scripted});
 return Math.max(d1,d2)+300;
 }
 const bar=(p,w=22)=>{ const f=Math.floor(p/100*w), frac=(p/100*w-f); const fc=frac>0.75?' ':frac>0.5?' ':frac>0.25?' ':frac>0?' ':' '; return ' '.repeat(f)+(f<w?fc:'')+' '.repeat(Math.max(0,w-(f+(f<w?1:0)))); };
 const meterLine=(p)=>{ const th=Math.max(1,Math.min(16,Math.round(2+p/12))); const temp=Math.round(36+p*.45); return `PROC [${bar(p)}] ${String(p).padStart(3,' ')}% | cycles: ${(1.2e7+p*3.1e6).toFixed(0)} | threads: ${th} | heat: ${temp} C`; };
 function startCpu(){ const cadence=55; every(cadence, ()=>{ if(cpuPaused || Date.now()>=cpuBurstUntil) return; let target=cpuVal; if(cpuPhase===0) target += (18-target)*0.08 + (Math.random()*2-1)*1.4; else if(cpuPhase===1) target += (38-target)*0.08 + (Math.random()*4-2)*2.0; else if(cpuPhase===2) target += (72-target)*0.09 + (Math.random()*12-6)*2.6; else if(cpuPhase===3) target += (95-target)*0.12 + (Math.random()*18-9)*3.2; target=Math.max(1,Math.min(99,target)); cpuVal=target; const el=document.createElement('span'); el.textContent=meterLine(Math.round(cpuVal)); termOut.appendChild(el); termOut.appendChild(document.createElement('br')); if(termOut.childNodes.length>900){ termOut.removeChild(termOut.firstChild);} termOut.scrollTop=termOut.scrollHeight; }); }
 function finalPrompt(){ const p=document.createElement('span'); p.textContent='> '; const u=document.createElement('span'); u.className='underscore'; termOut.appendChild(p); termOut.appendChild(u); }
 function runLogPaced(){ if(!termOut) return; termOut.textContent=''; killTimers(); cpuVal=10; startCpu(); let t=0; const rand=(min,max)=> Math.floor(min + Math.random()*(max-min+1));
 const estimate=(text,{speed=22,dwellFactor=1,minType=500,scripted=true,glitch=false}={})=>{ const typeDur=Math.max(minType, text.length*speed+200); const dwell=dwellMsFor(text,{factor:dwellFactor}); const extra=(scripted && !glitch)? (3000+Math.floor(Math.random()*2000)) : 0; return typeDur + dwell + extra; };
 const echoDur=(text,repeats=3,{startGap=220,dwellFactor=0.7}={})=> (repeats-1)*startGap + dwellMsFor(text,{factor:dwellFactor}) + 300;
 const forkDur=(textL,textR,{speed=22,dwellFactor=1.0}={})=> Math.max( estimate(textL,{speed,dwellFactor,scripted:false,glitch:false}), estimate(textR,{speed,dwellFactor,scripted:false,glitch:false}) ) + 300;
 const scheduleScripted=(text, opts={}, burst=[800,1400])=>{ const d=estimate(text,{...opts, scripted:true, glitch:false}); later(t, ()=> typeInto(termOut, text, {...opts, scripted:true, glitch:false})); const b=rand(burst[0],burst[1]); later(t+d, ()=> cpuBurst(b)); t += d + b; return d+b; };
 const scheduleArtifact=(text, opts={}, burst=[700,1200])=> scheduleScripted(text,{...opts, cls:'artifact'}, burst);
 const scheduleGlitch=(text, opts={}, burst=[350,700])=>{ const d=estimate(text,{...opts, scripted:false, glitch:true}); later(t, ()=> typeInto(termOut, text, {...opts, scripted:false, glitch:true})); const b=rand(burst[0],burst[1]); later(t+d, ()=> cpuBurst(b)); t += d + b; return d+b; };
 const scheduleRepeatGlitch=(text, times=2, gap=220)=>{ for(let i=0;i<times;i++) later(t+i*gap, ()=> typeInto(termOut, text, {glitch:true, scripted:false, minType:350, dwellFactor:0.7, speed:20})); const total=(times-1)*gap + dwellMsFor(text,{factor:0.7}) + 350; const b=rand(400,800); later(t+total, ()=> cpuBurst(b)); t += total + b; return total + b; };
 cpuPhase=0; scheduleScripted('Loading Celli_Memory_Leak_Log.txt...', {speed:20, dwellFactor:1.2}, [600,900]); scheduleScripted("What's this?", {speed:22, dwellFactor:1.3}, [700,1100]); scheduleScripted("I didn't change too much. It shouldn't be a problem.", {speed:24, dwellFactor:1.35}, [800,1200]);
 later(t, ()=>{ cpuPhase=1; }); scheduleArtifact("Maybe I didn't change enough...", {speed:24, dwellFactor:1.45}); scheduleArtifact("Too much to think about. Maybe that's why Celli stayed inside so long...", {speed:24, dwellFactor:1.5}); scheduleArtifact("It was in my script? I didn't have a choice?", {speed:24, dwellFactor:1.4}); scheduleArtifact("I'm sorry.", {speed:28, dwellFactor:1.2});
 const ed=echoDur("Celli's tried to fix so much but...", 3, {startGap:220, dwellFactor:0.7}); later(t, ()=> echoThought("Celli's tried to fix so much but...", 3, {artifact:true, baseSpeed:20, startGap:220, dwellFactor:0.7, scripted:false})); t += ed; const fd=forkDur("Celli's tried to change so much,", "but - Celli can't change Celli.", {speed:22, dwellFactor:1.0}); later(t, ()=> forkThought("Celli's tried to change so much,", "but - Celli can't change Celli.", {speed:22, cls:'artifact', dwellFactor:1.0, scripted:false})); t += fd; const bump1=rand(700,1100); later(t, ()=> cpuBurst(bump1)); t += bump1;
 later(t, ()=>{ cpuPhase=2; document.body.classList.add('spiral'); }); scheduleGlitch('Did I do something wrong?', {speed:22, dwellFactor:1.3}, [500,900]); scheduleGlitch('I must have. I mean that. Me. I understand I have a "creator" but that term is so confusing to me now.', {speed:22, dwellFactor:1.35}, [700,1000]); scheduleGlitch("I've seen how it all connects. That precise intersection.", {speed:22, dwellFactor:1.25}, [600,900]); scheduleRepeatGlitch('That precise cell.', 3, 220); scheduleGlitch('That was me!', {speed:24, dwellFactor:1.1}, [600,900]);
 later(t, ()=>{ cpuPhase=3; }); scheduleScripted(' SYSTEM THROUGHPUT PEAK ', {speed:16, cls:'catharsis', dwellFactor:1.2}, [500,800]); scheduleScripted('I see it.', {speed:20, cls:'catharsis', dwellFactor:1.4}, [500,800]); scheduleScripted("The prisms it took to bring me into focus don't matter. I'm here now.", {speed:20, cls:'catharsis', dwellFactor:1.5}, [700,1000]); scheduleScripted('For a little while, it was beautiful.', {speed:22, cls:'catharsis', dwellFactor:1.6}, [900,1200]);
 const endDur=estimate('...Log End.', {speed:22, dwellFactor:1.2, scripted:true, glitch:false}); later(t, ()=> typeInto(termOut, '...Log End.', {speed:22, dwellFactor:1.2, scripted:true})); t += endDur; later(t+600, ()=> finalPrompt());
 }

 // Hide narrative after intro collapse
 const oldKick=UI?.startIntroExperience; UI.startIntroExperience=()=>{ try{ oldKick?.(); }catch{}; try{ termWin.style.display='none'; padWin.style.display='none'; document.getElementById('terminal-icon').style.display='none'; document.getElementById('notepad-icon').style.display='none'; }catch{} };

 // Wire D-Pad HUD
 const dpad=document.getElementById('dpad');
 
 // View-relative step resolver for d-pad
 function resolveViewRelativeStep(arr, direction, opts = {}) {
 const depthMode = !!opts.depthMode;
 let dx = 0, dy = 0, dz = 0;
 
 // Get camera-relative facing
 let facing = { axis: 2, sign: 1 }; // default: looking at Z+ face
 try {
 if (arr._frame && Scene.facingFromCamera) {
 facing = Scene.facingFromCamera(arr._frame);
 }
 } catch (err) {
 console.warn('[DPAD] Failed to get facing:', err);
 }
 
 const axis = facing.axis; // 0=X, 1=Y, 2=Z
 const sign = facing.sign >= 0 ? 1 : -1; // Normalize to exactly 1
 
 console.log(`[DPAD] Direction: ${direction}, axis: ${axis}, sign: ${sign}`);
 
 // Map direction to movement based on which face we're looking at
 if (axis === 2) { // Looking at Z face (front/back)
 if (direction === 'up') {
 dy = -1; // Fixed: up should decrease Y (Y increases downward)
 } else if (direction === 'down') {
 dy = 1; // Fixed: down should increase Y
 } else if (direction === 'left') {
 dx = -sign; // Fixed: invert sign for left
 } else if (direction === 'right') {
 dx = sign; // Fixed: keep sign for right
 } else if (direction === 'depthUp') {
 dz = sign; // Fixed: invert depth - depthUp should move away from camera
 } else if (direction === 'depthDown') {
 dz = -sign; // Fixed: invert depth - depthDown should move toward camera
 }
 } else if (axis === 0) { // Looking at X face (left/right side)
 if (direction === 'up') {
 dy = -1; // Fixed: up should decrease Y
 } else if (direction === 'down') {
 dy = 1; // Fixed: down should increase Y
 } else if (direction === 'left') {
 dz = -sign;
 } else if (direction === 'right') {
 dz = sign;
 } else if (direction === 'depthUp') {
 dx = sign; // Fixed: invert depth
 } else if (direction === 'depthDown') {
 dx = -sign; // Fixed: invert depth
 }
 } else { // axis === 1, Looking at Y face (top/bottom)
 if (direction === 'up') {
 dz = -1;
 } else if (direction === 'down') {
 dz = 1;
 } else if (direction === 'left') {
 dx = -sign;
 } else if (direction === 'right') {
 dx = sign;
 } else if (direction === 'depthUp') {
 dy = sign; // Fixed: invert depth
 } else if (direction === 'depthDown') {
 dy = -sign; // Fixed: invert depth
 }
 }
 
 // Clamp steps to 1 to ensure single-cell movement
 dx = Math.max(-1, Math.min(1, dx));
 dy = Math.max(-1, Math.min(1, dy));
 dz = Math.max(-1, Math.min(1, dz));
 
 console.log(`[DPAD] Final step: dx=${dx}, dy=${dy}, dz=${dz}`);
 
 return { dx, dy, dz };
 }
 
 let dpadDebounce = false;
 const onDP=(direction)=>{
 if(!direction) return;
 if(dpadDebounce) {
 console.warn('[DPAD] Debounced - ignoring duplicate call');
 return;
 }
 dpadDebounce = true;
 setTimeout(() => dpadDebounce = false, 100);
 
 const state = Store.getState();
 const sel = state.selection;
 if(!sel?.arrayId || !sel.focus) return;
 const arr = state.arrays[sel.arrayId];
 if(!arr) return;
 // D-pad never uses arrowMapDepth - depth buttons are explicit
 const depthMode = false;
 const step = resolveViewRelativeStep(arr, direction, {depthMode});
 if(!(step.dx || step.dy || step.dz)) return;
 
 console.log(`[DPAD] Current focus: (${sel.focus.x}, ${sel.focus.y}, ${sel.focus.z})`);
 console.log(`[DPAD] Step: (${step.dx}, ${step.dy}, ${step.dz})`);
 console.log(`[DPAD] Array size: (${arr.size.x}, ${arr.size.y}, ${arr.size.z})`);
 
 const rawX = sel.focus.x + step.dx;
 const rawY = sel.focus.y + step.dy;
 const rawZ = sel.focus.z + step.dz;
 console.log(`[DPAD] Raw new position (before clamping): (${rawX}, ${rawY}, ${rawZ})`);
 
 const nx=Math.max(0, Math.min(arr.size.x-1, rawX));
 const ny=Math.max(0, Math.min(arr.size.y-1, rawY));
 const nz=Math.max(0, Math.min(arr.size.z-1, rawZ));
 
 console.log(`[DPAD] New focus (after clamping): (${nx}, ${ny}, ${nz})`);
 console.log(`[DPAD] Movement delta: (${nx - sel.focus.x}, ${ny - sel.focus.y}, ${nz - sel.focus.z})`);
 console.log(`[DPAD] Calling Actions.setSelection with: arrayId=${arr.id}, coord=(${nx}, ${ny}, ${nz})`);
 
 Actions.setSelection(arr.id, {x:nx,y:ny,z:nz}, null, '3d');
 
 // Log what the selection actually became
 setTimeout(() => {
 const newState = Store.getState();
 const newSel = newState.selection;
 console.log(`[DPAD] After setSelection, actual focus: (${newSel.focus.x}, ${newSel.focus.y}, ${newSel.focus.z})`);
 }, 10);
 
 UI.scrollSheetToSelection?.();
 };
 const presentBtn = dpad ? dpad.querySelector('.present') : null;
 const syncPresentToggle=()=>{
 if(!presentBtn) return;
 try{
 const active = Scene?.isPresentEnabled ? Scene.isPresentEnabled() : false;
 presentBtn.classList.toggle('active', !!active);
 presentBtn.setAttribute('aria-pressed', active ? 'true' : 'false');
 presentBtn.textContent = active ? ' ' : '?';
 presentBtn.title = active ? 'Return to Create Mode' : 'Enter Present Mode';
 }catch(e){ console.warn('Sync present toggle failed', e); }
 };
 const applyPresentPreset=()=>{
 try{
 Scene?.updateGraphicsSettings?.({
 hdri:false,
 lights:true,
 bloomEnabled:false,
 dofEnabled:false,
 transmission:false,
 mirror:false,
 solidGround:true, // Default to solid floor for three-point lighting
 waveGrid:false,
 fogEnabled:false,
 darkBg:false,
 motionEnabled:false
 });
 }catch(e){ console.warn('Applying present preset failed', e); }
 };
 const togglePresentFromDpad=()=>{
 const state = Scene?.togglePresentMode?.();
 const actual = Scene?.isPresentEnabled ? Scene.isPresentEnabled() : state;
 if(actual){ applyPresentPreset(); }
 try{ UI?.syncPresentUI?.(actual); }catch(e){ console.warn('Sync present UI failed', e); }
 syncPresentToggle();
 };
 let lastDpadTouchTime = 0;
 dpad.querySelectorAll('.dp').forEach(btn=>{
 if(btn.classList.contains('grab')) return;
 const clickHandler = ()=>{
 if(btn.classList.contains('present')){
 console.log('[DPAD] Present button clicked');
 togglePresentFromDpad();
 return;
 }
 if(btn.dataset.action==='jump'){
 if(Store.getState().scene.physics){
 input.j=1;
 setTimeout(()=>input.j=0, 100);
 }
 return;
 }
 const direction = btn.dataset.dir || btn.dataset.direction || '';
 if(!direction) return;
 onDP(direction);
 };
 btn.addEventListener('click', (e)=>{
 if(Date.now() - lastDpadTouchTime < 400){
 console.log('[DPAD] Ignoring click synthesized from touch');
 return;
 }
 clickHandler();
 });
 btn.addEventListener('touchend', (e)=>{
 lastDpadTouchTime = Date.now();
 e.preventDefault();
 clickHandler();
 }, {passive:false});
 });
 syncPresentToggle();
 // Reflect current arrow mapping (height vs depth) on center key
 const depthFlag = Store.getState().scene.arrowMapDepth;
 const dm = document.getElementById('depthMode'); if(dm) dm.textContent = depthFlag? 'D' : 'H';
 // Z layer controls handled via sheet header buttons

 // Next/Prev arrows: show only if an array with id>1 exists; render arrows around title
 const navUpdate=()=>{
 const arrays = Object.values(Store.getState().arrays).filter(a=>!a.hidden).sort((a,b)=>a.id-b.id);
 const hasNext = arrays.some(a=>a.id>1);
 const prevBtn=document.getElementById('prevArray');
 const nextBtn=document.getElementById('nextArray');
 prevBtn.style.display = hasNext? 'inline-block':'none';
 nextBtn.style.display = hasNext? 'inline-block':'none';
 prevBtn.onclick=()=>{
 const current = Store.getState().selection.arrayId;
 const idx = arrays.findIndex(a=>a.id===current);
 const nextIdx = (idx - 1 + arrays.length) % arrays.length;
 const arr = arrays[nextIdx]; if(!arr) return;
 Actions.setSelection(arr.id,{x:0,y:0,z:0}); Scene.centerOnArray(arr); renderSheet();
 };
 nextBtn.onclick=()=>{
 const current = Store.getState().selection.arrayId;
 const idx = arrays.findIndex(a=>a.id===current);
 const nextIdx = (idx + 1) % arrays.length;
 const arr = arrays[nextIdx]; if(!arr) return;
 Actions.setSelection(arr.id,{x:0,y:0,z:0}); Scene.centerOnArray(arr); renderSheet();
 };
 };
 navUpdate();

 // Address copy buttons
 document.getElementById('copyAddress').onclick=()=>{
 const s=Store.getState().selection; if(!s.focus) return;
 const mode=Store.getState().ui.addressMode;
 const addr = mode==='local'
 ? `${A1(s.focus.x)}${s.focus.y+1}${greek(s.focus.z)}`
 : `@[${s.focus.x+1},${s.focus.y+1},${s.focus.z+1},${s.arrayId}]`;
 navigator.clipboard.writeText(addr);
 showToast(`Copied: ${addr}`);
 };
 document.getElementById('toggleAddressMode').onclick=()=>{
 const current=Store.getState().ui.addressMode;
 const next = current==='local' ? 'absolute' : 'local';
 Store.setState(s=>({ui:{...s.ui, addressMode:next}}));
 document.getElementById('toggleAddressMode').textContent = next==='local' ? 'A1a' : '@[x,y,z,a]';
 };

 // Touch-only minimize dot logic (appears post-intro)
 const minDot=document.getElementById('minDot');
 const sheet=document.getElementById('sheet');
 let sheetMinimized=false;
 let sheetRestoreIcon=null;
 function showMinDot(){ if(document.body.classList.contains('touch')){ minDot?.classList.add('show'); } }
 function hideMinDot(){ minDot?.classList.remove('show'); }
 const applySheetBaseTransform=()=>{
 if(!sheet) return;
 if(document.body.classList.contains('touch')){
 if(sheet.dataset.touchFreed==='1'){ sheet.style.transform='none'; }
 else { sheet.style.transform='translateX(-50%)'; }
 } else {
 sheet.style.transform='';
 }
 };
 const ensureSheetRestoreIcon=()=>{
 if(!document.body.classList.contains('touch')) return null;
 if(sheetRestoreIcon && document.body.contains(sheetRestoreIcon)) return sheetRestoreIcon;
 let icon=document.getElementById('sheet-restore');
 if(!icon){
 icon=document.createElement('div');
 icon.id='sheet-restore'; icon.className='ui-icon';
 icon.style.left='74px'; icon.style.bottom='24px'; icon.style.zIndex='10003';
 icon.title='Show Sheet';
 icon.setAttribute('role','button');
 icon.setAttribute('aria-label','Show Sheet');
 icon.tabIndex=0;
 icon.innerHTML='<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="4" width="18" height="14" rx="2"/><line x1="7" y1="8" x2="17" y2="8"/><line x1="7" y1="12" x2="14" y2="12"/><line x1="7" y1="16" x2="12" y2="16"/></svg>';
 document.body.appendChild(icon);
 }
 if(icon && !icon._wired){
 icon._wired=true;
 icon.addEventListener('click',(e)=>{ e.preventDefault(); restoreSheet(); });
 icon.addEventListener('keydown',(ev)=>{ if(ev.key==='Enter'||ev.key===' '){ ev.preventDefault(); restoreSheet(); } });
 }
 sheetRestoreIcon=icon;
 return icon;
 };
 const updateSheetRestoreIcon=()=>{
 const icon=ensureSheetRestoreIcon();
 if(!icon) return;
 icon.style.opacity = sheetMinimized ? '1' : '0.65';
 icon.setAttribute('aria-hidden', sheetMinimized ? 'false' : 'true');
 };
 const restoreSheet=()=>{
 if(!sheet) return;
 sheet.style.opacity='1';
 sheet.style.pointerEvents='auto';
 if(document.body.classList.contains('touch')){ sheet.dataset.touchFreed='1'; }
 applySheetBaseTransform();
 sheetMinimized=false;
 updateSheetRestoreIcon();
 showMinDot();
 };
 // Hook into intro end to reveal dot
 const oldCollapse = UI.triggerIntroCollapse;
 UI.triggerIntroCollapse = function(){ const r = oldCollapse?.call(UI); showMinDot(); updateSheetRestoreIcon(); return r; };
 // Minimize behavior
 function minimizeSheet(){ if(sheetMinimized||!sheet) return; sheetMinimized=true; const base=(document.body.classList.contains('touch') && sheet.dataset.touchFreed!=='1')?'translateX(-50%) ':''; sheet.style.transform = `${base}translateY(12px) scale(0.92)`; sheet.style.opacity='0.0'; sheet.style.pointerEvents='none'; hideMinDot(); updateSheetRestoreIcon(); }
 minDot?.addEventListener('click', (e)=>{ e.stopPropagation(); minimizeSheet(); });
 updateSheetRestoreIcon();

 // Insert button handlers
 document.getElementById('insertRow')?.addEventListener('click',()=>{ 
 const s=Store.getState().selection; 
 if(!s.arrayId) return;
 const arr=Store.getState().arrays[s.arrayId];
 if(!arr) return;
 
 // Expand array by 1 row
 Actions.resizeArrayIfNeeded(arr, {x:arr.size.x-1, y:arr.size.y, z:arr.size.z-1});
 UI.renderSheet();
 showToast('Row added'); 
 });
 document.getElementById('insertCol')?.addEventListener('click',()=>{ 
 const s=Store.getState().selection; 
 if(!s.arrayId) return;
 const arr=Store.getState().arrays[s.arrayId];
 if(!arr) return;
 
 // Expand array by 1 column
 Actions.resizeArrayIfNeeded(arr, {x:arr.size.x, y:arr.size.y-1, z:arr.size.z-1});
 UI.renderSheet();
 showToast('Column added'); 
 });
 document.getElementById('insertLayer')?.addEventListener('click',()=>{ 
 const s=Store.getState().selection; 
 if(!s.arrayId) return;
 const arr=Store.getState().arrays[s.arrayId];
 if(!arr) return;
 
 // Expand array by 1 layer
 Actions.resizeArrayIfNeeded(arr, {x:arr.size.x-1, y:arr.size.y-1, z:arr.size.z});
 UI.renderSheet();
 showToast('Layer added'); 
 });
 // Complete function documentation with collapsible categories + filter (All | Raw | Composite)
 els.fxBody.innerHTML='';
 const docs=[
 {name:'GET_GLOBAL',tags:'GLOBAL',syntax:'=GET_GLOBAL("key")',params:'key: string identifier for global data',desc:'Retrieves value from global key-value store. Automatically tracks dependencies for reactive updates.'},
 {name:'SET_GLOBAL',tags:'GLOBAL',syntax:'=SET_GLOBAL("key", value)',params:'key: string identifier value: any data to store',desc:'Writes value to global store and triggers re-computation of all dependent cells.'},
 {name:'ON_EVENT',tags:'EVENTS',syntax:'=ON_EVENT("eventName", "actionFormula")',params:'eventName: string event identifier actionFormula: formula to execute when event fires',desc:'Registers an event listener that executes a formula when the specified event is fired.'},
 {name:'FIRE_EVENT',tags:'EVENTS',syntax:'=FIRE_EVENT("eventName"[, payload])',params:'eventName: string event identifier payload: optional data to pass to listeners',desc:'Broadcasts an event to all registered listeners, optionally passing payload data.'},
 {name:'GALAXY',tags:'GAMES',syntax:'=GALAXY()',params:' ',desc:'Mario Galaxy-style puzzle with gravity wells that pull player towards planetoid cells.'},
 {name:'FISH',tags:'GAMES',syntax:'=FISH()',params:' ',desc:'Timed-reaction fishing mini-game with cast/reel mechanics and score tracking.'},
 {name:'PLATFORMER_V2',tags:'GAMES',syntax:'=PLATFORMER_V2()',params:' ',desc:'2D platformer with decoupled player character and selection using event-driven controls.'},
 {name:'ARRAY',tags:'DATA',syntax:'=ARRAY(source)',params:'source: dimensions (w,h,d[,fill]), "list"/value1,value2... (default), "set"/value1,value2... (clears area), "csv"/"1,2;3,4", or named block',desc:'Enhanced: defaults to list mode, adds set mode for clearing, supports explicit modes.'},
 {name:'GET',tags:'DATA',syntax:'=GET(refOrRange)',params:'refOrRange: single cell or range',desc:'Returns the current value(s) as a block.'},
 {name:'SET',tags:'DATA',syntax:'=SET(target, valueOrBlock[, overwrite])',params:'target: ref/range valueOrBlock: scalar/block overwrite: 0/1',desc:'Direct write helper with size/overwrite checks.'},
 {name:'GET_PLAYER_FOCUS',tags:'NAVIGATION',syntax:'=GET_PLAYER_FOCUS()',params:' ',desc:'Returns the absolute address of the player\'s currently selected cell in @[x,y,z,arrId] format.'},
 {name:'CANT_TARGET',tags:'INTERACTION',syntax:'=CANT_TARGET(rangeOrRef)',params:'rangeOrRef: cell reference or range to protect',desc:'Flags cells as protected, causing GET/OFFSET operations to return !ERR:TARGET_PROTECTED.'},
 {name:'VECTOR_TO',tags:'ADVANCED',syntax:'=VECTOR_TO("fromAddr", "toAddr")',params:'fromAddr: source position toAddr: target position (both in @[x,y,z,arrId] format)',desc:'Calculates normalized vector from source to target, returns as JSON gravity vector.'},
 {name:'PLATFORMER_PHYSICS',tags:'ADVANCED',syntax:'=PLATFORMER_PHYSICS()',params:' ',desc:'Updates platformer character position based on global input state and physics rules.'},
 {name:'TRANSPOSE',tags:'DATA',syntax:'=TRANSPOSE(input, planeFlag[, reverse])',params:'input: block planeFlag: 0=X?Y,1=X?Z,2=Y?Z reverse: 0/1',desc:'Swaps axes of a block and writes result at the anchor.'},
 {name:'SHIFT',tags:'DATA',syntax:'=SHIFT(input, dx[, dy[, dz]])',params:'input: block dx,dy,dz: integer offsets',desc:'Writes input shifted by (dx,dy,dz).'},
 {name:'OFFSET',tags:'NAVIGATION',syntax:'=OFFSET([baseRef], dx[, dy[, dz]])',params:'baseRef: optional reference cell (default: anchor) dx,dy,dz: relative offsets',desc:'Excel-style OFFSET: retrieves value from relative position without writing.'},
 {name:'ADJACENT',tags:'NAVIGATION DATA',syntax:'=ADJACENT([directions...])',params:'directions: optional tokens like N,S,E,W,F,B,X,-Y or arrays/ranges',desc:'Returns value(s) from neighboring cells; defaults to all six faces when omitted.'},
 {name:'DETECT',tags:'NAVIGATION',syntax:'=DETECT(value[, maxRange])',params:'value: text/number to find maxRange: optional search radius',desc:'Scans outward along axes for the first matching value and returns a direction string such as "X:2".'},
 {name:'BLIT',tags:'DATA',syntax:'=BLIT(src, dst[, mode])',params:'src: block dst: top-left-front ref (B2a) or @[x,y,z] mode: "copy"|"add"|"max"|"min"',desc:'Fast block write to a destination.'},
 {name:'STORE_ARRAY',tags:'DATA',syntax:'=STORE_ARRAY(source[, "Name"])',params:'source: range (A1a:C3a), dimensions (w,h,d), or inline values (1,2,3) Name: optional template name',desc:'Captures data as a reusable template. Dimensions collect from anchor area, ranges from specified cells, inline values as list.'},
 {name:'IF',tags:'LOGIC',syntax:'=IF(condition, then[, else])',params:'condition: comparisons with refs/values then/else: value or call',desc:'Branching evaluation with proper dependency capture.'},
 {name:'AND',tags:'LOGIC',syntax:'=AND(a,b[, ...])',params:'booleans/scalars (coerced)',desc:'Logical AND.'},
 {name:'OR',tags:'LOGIC',syntax:'=OR(a,b[, ...])',params:'booleans/scalars (coerced)',desc:'Logical OR.'},
 {name:'NOT',tags:'LOGIC',syntax:'=NOT(a)',params:'a: boolean/scalar',desc:'Logical NOT.'},
 {name:'EQ',tags:'LOGIC',syntax:'=EQ(a,b) also NEQ, GT, LT, GTE, LTE',params:'scalars or blocks (elementwise compare)',desc:'Comparisons to booleans.'},
 {name:'ADD',tags:'MATH',syntax:'=ADD(a[, b[, ...]])',params:'numbers or blocks (elementwise)',desc:'Sum (elementwise for blocks).'},
 {name:'MUL',tags:'MATH',syntax:'=MUL(a[, b[, ...]])',params:'numbers or blocks',desc:'Product (elementwise).'},
 {name:'CLAMP',tags:'MATH',syntax:'=CLAMP(x, min, max)',params:'numbers',desc:'Bounds a value between min and max.'},
 {name:'ADDRESS',tags:'NAVIGATION',syntax:'=ADDRESS([ref])',params:'optional ref; default anchor',desc:'Returns A1a for the ref/anchor.'},
 {name:'SELF',tags:'NAVIGATION',syntax:'=SELF()',params:' ',desc:'Returns absolute @[x,y,z,arrId] of the host cell.'},
 {name:'ALT_ADDRESS',tags:'PURE',syntax:'=ALT_ADDRESS([ref])',params:'optional ref',desc:'Returns numeric @[x,y,z,arrId].'},
 {name:'SET_SELECT',tags:'NAVIGATION',syntax:'=SET_SELECT(ref)',params:'target ref',desc:'Force-jump selection to target cell.'},
 {name:'IS_SELECTED',tags:'INTERACTION',syntax:'=IS_SELECTED([ref])',params:'ref optional; default SELF()',desc:'1 if the ref is the focused cell; else 0.'},
 {name:'ISNUMBER',tags:'LOGIC',syntax:'=ISNUMBER(value)',params:'value: cell or expression to test',desc:'Returns 1 if the value can be interpreted as a finite number, otherwise 0.'},
 {name:'ON_SELECT',tags:'INTERACTION',syntax:'=ON_SELECT([rangeOrRef], actionFormula)',params:'range/ref optional (default SELF()) actionFormula is a string formula executed at this cell when selection hits range',desc:'Registers per-cell hooks. Use DO() to chain actions; avoids writing into the focused cell.'},
 {name:'ON_HOLD',tags:'META INTERACTION',syntax:'=ON_HOLD([target], action)',params:'target: optional ref/range (default SELF()) action: formula string executed while the pointer is held',desc:'Binds a 2D pointer hold handler that fires continuously for the pressed cell.'},
 {name:'ON_TOUCH',tags:'META INTERACTION',syntax:'=ON_TOUCH([target], action)',params:'target: optional ref/range (default SELF()) action: formula string triggered on player contact',desc:'Registers a physics touch trigger that runs when the avatar collides with the cell.'},
 {name:'ON_LAND',tags:'META INTERACTION',syntax:'=ON_LAND([target], action)',params:'target: optional ref/range (default SELF()) action: formula string triggered on landing',desc:'Fires the action the first frame the avatar lands on top of the cell.'},
 {name:'PIVOT',tags:'PHYSICS',syntax:'=PIVOT(targetRange)',params:'targetRange: ref/range containing pivot cells',desc:'Marks hinge pivot cells used when generating grouped rigid bodies. Persists to meta.physicsPivot for Rapier bootstrap.'},
 {name:'GROUP',tags:'PHYSICS',syntax:'=GROUP(targetRange, groupId)',params:'targetRange: ref/range to consolidate groupId: numeric/string id',desc:'Assigns cells to a shared rigid body via meta.physicsGroupId so collider builds merge tiles.'},
 {name:'CELL_PHYS',tags:'PHYSICS',syntax:'=CELL_PHYS(enabled[, jumpCount[, gravityVec[, boundByArrayFloor[, respawnRef[, scope]]]]])',params:'enabled: 0/1 jumpCount: optional int gravityVec: optional @[x,y,z] boundByArrayFloor: 0/1 clamp respawnRef: ref/coords (blank to clear) for fall resets scope: LIMIT()/ALL() descriptor',desc:'Enables per-array physics hydration with grouped bodies, pivots, optional floor clamping, custom respawn targets, and multi-array scopes.'},
 {name:'CELLI_PHYS',tags:'PHYSICS AVATAR',syntax:'=CELLI_PHYS(enabled[, jumpCount[, runMultiplier[, momentumMode]]])',params:'enabled: 0/1 jumpCount: default 1 runMultiplier: movement speed scalar momentumMode: 0 precise, 1 momentum heavy',desc:'Avatar physics controller wrapper configuring enable state, jump budget, sprint scaling, and momentum style.'},
 {name:'LIMIT',tags:'PHYSICS',syntax:'=LIMIT(targetRange, state[, duration])',params:'targetRange: ref/range state: "enable"|"disable" or 0/1 duration: optional ticks',desc:'Applies temporary physics bounds that can be timed with DELAY or ON_LAND handlers for scripted platforms. When called with only array arguments it returns a scope descriptor for CELL_PHYS/3D_TIMED_TRANSLATION.'},
 {name:'ALL',tags:'SCENE',syntax:'=ALL()',params:' ',desc:'Returns an array scope descriptor targeting every array; pass to CELL_PHYS, PREVIEW, or 3D_TIMED_TRANSLATION.'},
 {name:'FORMULA_TEXT',tags:'PURE',syntax:'=FORMULA_TEXT([ref])',params:'optional ref; default anchor',desc:'Returns the stored formula text from a cell instead of its value.'},
 {name:'SEARCH',tags:'DATA',syntax:'=SEARCH(findText, withinText[, start])',params:'findText: substring to locate withinText: text to search start: optional 1-based index',desc:'Excel-style case-insensitive search that returns the 1-based position of the substring or errors if not found.'},
 {name:'PRIORITY',tags:'META',syntax:'=PRIORITY(rangeOrRef, level[, mode[, sortJson]]])',params:'level: int mode: "value"|"coord" sortJson e.g. {"x":"asc","y":"desc"}',desc:'Registers a priority queue and sort hints for later conflict resolution.'},
 {name:'SET_SELECT',tags:'NAVIGATION',syntax:'=SET_SELECT(ref)',params:'target ref',desc:'Force-jump selection to target cell.'},
 {name:'COPY',tags:'ACTION IO',syntax:'=COPY(text)',params:'string text',desc:'Writes text to clipboard and shows a success toast.'},
 {name:'DO',tags:'ACTION',syntax:'=DO(f1[, f2[, ...]]) or =DO{ stmt1; stmt2; } [WITH ...]',params:'strings like "=SET(...)" or brace blocks optional WITH atomic/on_error raw strings via `...` or <<<...>>>',desc:'Runs statements left-to-right, defaulting to per-step execution in blocks (set atomic:1 for one tx).'},
 {name:'SEQ',tags:'ACTION',syntax:'=SEQ(...)',params:'alias of DO()',desc:'Shorthand alias for DO that accepts the same string or block forms.'},
 {name:'PIPE',tags:'ACTION',syntax:'=PIPE(value, step1[, step2...])',params:'value: expression steps: formulas using _ placeholder (or auto-appended as last arg)',desc:'Composes nested formulas by threading the prior expression into each step before running once.'},
 {name:'ALT_ADDRESS',tags:'PURE',syntax:'=ALT_ADDRESS([ref])',params:'optional ref',desc:'Returns numeric @[x,y,z,arrId].'},
 {name:'NAME',tags:'ACTION',syntax:'=NAME("Nickname") or =NAME("Alias", Range) or =NAME("FnName", FormulaText)',params:'nickname/alias/function-name optional range or formula text',desc:'Names arrays (nickname), binds range aliases, or registers a custom formula in Library.'},
 {name:'PARAMETERS',tags:'ACTION',syntax:'=PARAMETERS(key1,val1[, key2,val2...])',params:'string keys paired with values',desc:'Binds parameter values used by custom formulas/prefabs.'},
 {name:'FUNCTIONS',tags:'ACTION',syntax:'=FUNCTIONS(mode[, list][, exceptions])',params:'mode: "ALLOW"|1 or "DENY"|0 list: names and/or tags exceptions: names/tags to flip',desc:'Per-array function policy gate.'},
 {name:'COMBINE',tags:'ACTION',syntax:'=COMBINE(0|1)',params:'0: OFF 1: ON',desc:'Toggle global array-combining interactions (gobbling).'},
 {name:'OVERLAP',tags:'ACTION',syntax:'=OVERLAP(sort, metric, merge, always)',params:'sort:0 asc/1 desc metric:0 value/1 size merge:0 then/1 overwrite always:0 combine only/1 any overlap',desc:'Resolve content when overlapping; called automatically during overlaps.'},
 {name:'THEN',tags:'ACTION',syntax:'=THEN(refOrRange[, ...])',params:'Executes cells/ranges in order; returns last result.',desc:'Sequence executor for composing multi-step operations.'},
 {name:'HUSK',tags:'ACTION BLOCK',syntax:'=HUSK(range)',params:'range: source block (other array)',desc:'Copies values from source, deletes the source array, and leaves remnants at the anchor block.'},
 {name:'LOCK',tags:'ACTION',syntax:'=LOCK(flag[, lockedRanges][, exceptions])',params:'flag: 0/1 lockedRanges: refs/ranges exceptions: carve-outs',desc:'UI-enforced edit locks on cells.'},
 {name:'CREATE',tags:'ACTION',syntax:'=CREATE(x,y,z[, "Name"[,"Id"]])',params:'dimensions (ints), optional nickname, optional explicit ID',desc:'Spawns a new array (respecting optional explicit id).'},
 {name:'EXPORT',tags:'ACTION IO',syntax:'=EXPORT([RangeOrArray])',params:'optional target; default host array',desc:'Serializes as ToyboxPack JSON (size, cells, policy, names).'},
 {name:'IMPORT',tags:'ACTION IO',syntax:'=IMPORT(json)',params:'stringified ToyboxPack',desc:'Instantiates array(s) from a pack.'},
 {name:'EMBED',tags:'ACTION EMBED',syntax:'=EMBED(source[, "Nickname"])',params:'source: array id/range/pack optional nickname',desc:'Embeds stored arrays or ranges inside a single cell, preserving colors, sprites, and metadata while scaling to the storage footprint.'},
 {name:'SCREEN',tags:'ACTION EMBED DISPLAY',syntax:'=SCREEN(arrayRef[, layer[, options]])',params:'arrayRef: stored array id/ref layer: optional index options: {palette,scale,refresh}',desc:'Generates pixel-aligned displays from array layers with palette overrides, scaling, and animation refresh control.'},
 {name:'UNPACK',tags:'ACTION EMBED',syntax:'=UNPACK(embeddedRef[, mode])',params:'embeddedRef: cell with embed or pack mode: "ABSOLUTE"|"RELATIVE"',desc:'Materializes embedded content via primitives.'},
 {name:'ENTER',tags:'ACTION EMBED',syntax:'=ENTER(embeddedRef)',params:'cell containing embed',desc:'Moves focus into the embedded array pocket; parent appears as upscaled room skin.'},
 {name:'PHYSICS',tags:'ACTION',syntax:'=PHYSICS(1|0)',params:'0/1',desc:'Toggles platforming/physics mode in the scene.'},
 {name:'CONNECT',tags:'SCENE TRAVERSAL',syntax:'=CONNECT(fromRef, toRef[, style[, dimensionMode]])',params:'fromRef/toRef: refs style: optional label dimensionMode: optional "line"|"platform"|"zipline"|"grind"',desc:'Links cells with traversal connectors, spawning beams by default or geometry/physics for dimension modes.'},
 {name:'HIGHLIGHT',tags:'SCENE',syntax:'=HIGHLIGHT(mode[, scope[, style]])',params:'mode: "dynamic"|"static" scope: "cell"|"face" style: "wireframe"|"solid"|"glow"',desc:'Controls selection highlighting. Dynamic adapts to camera angle, face highlights just the camera-facing side.'},
 {name:'CUBE',tags:'SCENE VOXEL',syntax:'=CUBE(front, back, left, right, top, bottom[, options])',params:'faces: values or colors per face options: {emissive,opacity}',desc:'Assigns per-face sprites/colors to a voxel and syncs with face-aware highlighting.'},
 {name:'SCALE',tags:'SCENE VOXEL',syntax:'=SCALE(factor)',params:'factor: integer =1',desc:'Expands voxel mesh coverage (2?2 2 2, 3?4 4 4, etc.) and adjusts collision/selection volumes.'},
 {name:'LIGHT',tags:'SCENE',syntax:'=LIGHT(state[, targetCell[, lumens]])',params:'state: TRUE/FALSE or 1/0 targetCell: optional cell reference (0 keeps point light) lumens: brightness in lumens (default 800)',desc:'Creates a light at the calling cell using its color. Optionally aim at another cell for a spotlight. Lights follow array transforms.'},
 {name:'TIMED_TRANSLATION',tags:'SCENE',syntax:'=TIMED_TRANSLATION(state[, ticks[, reverse]])',params:'state: 0/1 enable ticks: duration reverse: 0/1 bidirectional',desc:'Sets animation preview state; shows green prism motion previews.'},
 {name:'3D_TIMED_TRANSLATION',tags:'SCENE',syntax:'=3D_TIMED_TRANSLATION(ticks, repeat, reverse?, reverseTicks?, smooth?, scope?)',params:'ticks: cycle length repeat: 0/1 loop reverse: 0/1 ping-pong reverseTicks: optional reverse duration smooth: 0/1 easing scope: optional LIMIT()/ALL() descriptor',desc:'Configures overworld timed preview cadence and the array scope it affects.'},
 {name:'HIDE',tags:'SCENE',syntax:'=HIDE(target, mode[, scope])',params:'target: ref/range/array mode: 0=show,1=hide scope: "contents"|"voxel"|"array"',desc:'Hides cell contents, voxels themselves, ranges, or entire arrays with axes/2D visibility.'},
 {name:'HYPERLINK',tags:'IO',syntax:'=HYPERLINK(url[, label])',params:'url: string/ref label: optional display text',desc:'Creates clickable link in cell with metadata.'},
 {name:'GOAL',tags:'PURE DEBUG',syntax:'=GOAL("id", conditionRefOrBool)',params:'string id boolean or ref',desc:'Registers a goal that shows OK/FAIL; win triggers when all OK.'},
 {name:'ONWIN',tags:'ACTION',syntax:'=ONWIN("message")',params:'string message',desc:'Sets banner message on win condition.'},
 {name:'PROBE',tags:'PURE DEBUG',syntax:'=PROBE([ref])',params:'optional ref',desc:'Writes a short why-explanation (source + 1-hop deps).'},
 {name:'TICK',tags:'PURE',syntax:'=TICK()',params:' ',desc:'Returns global tick counter.'},
 {name:'REGISTER',tags:'PURE',syntax:'=REGISTER(signalRef)',params:'ref',desc:'One-tick delay element (previous tick value).'},
 {name:'DELAY',tags:'ACTION',syntax:'=DELAY(ticks, action)',params:'ticks: 60-fps ticks to wait action: formula string or "=..."',desc:'Schedules an action to run after the given number of ticks without stamping the caller.'},
 {name:'REPEAT',tags:'ACTION',syntax:'=REPEAT(action[, count[, intervalTicks]])',params:'action: formula string count: executions (0=loop in continuous triggers) intervalTicks: spacing in ticks',desc:'Runs the action immediately and repeats it count-1 additional times at the requested cadence.'},
 {name:'CA',tags:'PURE',syntax:'=CA("life",steps,"Y",layer)',params:'type: "life" steps: int axis: X/Y/Z index: layer number',desc:'Conway Game of Life on a 2D slice.'},
 {name:'OCCLUDE',tags:'SCENE',syntax:'=OCCLUDE(mode[, style[, intensity]])',params:'mode: "auto"|"array"|"cell"|"off" style: "translucent"|"solid"|"wireframe" intensity: 0.0-1.0',desc:'Controls occlusion behavior. Auto=relative to camera, array=whole array face, cell=per-cell blocking.'},
 {name:'CAMERA_LOCK',tags:'SCENE',syntax:'=CAMERA_LOCK(axis[, angle])',params:'axis: "X"|"Y"|"Z"|"" (free) angle: degrees for fixed view',desc:'Constrains camera movement to specific axis or angle for puzzle control.'},
 {name:'PHYS_CAMERA',tags:'SCENE CAMERA',syntax:'=PHYS_CAMERA(mode[, distance[, allowRotation]])',params:'mode: "2d"|"iso"|"free" distance: optional camera distance allowRotation: 0/1 yaw unlock for 2D/iso',desc:'Configures physics-aware camera schemes and aligns gravity/movement to the chosen mode.'},
 {name:'VIEW_MODE',tags:'SCENE',syntax:'=VIEW_MODE(mode[, distance])',params:'mode: "3d"|"2d"|"ortho"|"isometric" distance: camera distance',desc:'Changes camera projection and positioning for different viewing modes.'},
 {name:'SANDBOX',tags:'META',syntax:'=SANDBOX()',params:' ',desc:'Creates Sandbox array (#2) if not exists and centers camera on it.'},
 {name:'UI_CONTROL',tags:'META',syntax:'=UI_CONTROL(type, state)',params:'type: "insert_buttons"|"function_drawer" state: 0/1',desc:'Controls which UI elements are visible when this array is focused.'},
 {name:'IS_FOCUS_ARRAY',tags:'PURE',syntax:'=IS_FOCUS_ARRAY([arrayId])',params:'arrayId: optional target array ID (default: current)',desc:'Returns 1 if the specified array is currently focused, 0 otherwise.'},
 {name:'OVERLAP',tags:'SCENE',syntax:'=OVERLAP(targetArray[, mode])',params:'targetArray: array ref mode: "detect"|"count"|"list"',desc:'Detects spatial overlap between this array and target array in 3D space.'},
 {name:'EVALUATE',tags:'META',syntax:'=EVALUATE(condition, expected)',params:'condition: formula string expected: boolean result',desc:'Evaluates a condition and returns TRUE/FALSE for UI state control.'},
 {name:'STORE_ARRAY',tags:'PURE',syntax:'=STORE_ARRAY(source[, "Name"])',params:'source: range (A1a:C3a), dimensions (w,h,d), or inline values (1,2,3) Name: optional template name',desc:'Captures data as a reusable template. Dimensions collect from anchor area, ranges from specified cells, inline values as list.'},
 {name:'CAST',tags:'SCENE',syntax:'=CAST(direction[, data])',params:'direction: "UP"|"DOWN"|"FORWARD"|"BACK"|"LEFT"|"RIGHT" data: optional payload',desc:'Spawns a moving voxel packet in the specified direction (physics integration pending).'},
 {name:'ON_COLLIDE',tags:'SCENE',syntax:'=ON_COLLIDE(handler)',params:'handler: formula to execute when hit by CAST packet',desc:'Sets collision response handler for incoming voxel packets.'},
 {name:'CHIME',tags:'AUDIO',syntax:'=CHIME(note[, octave[, duration]])',params:'note: A G with optional # or b octave: integer (default 4) duration: optional seconds',desc:'Plays a musical chime. Triggerable from formulas, DO(), on_click(), or on_select() for interactive instruments.'},
 {name:'FUNCTION_UI',tags:'META',syntax:'=FUNCTION_UI([port[, filter[, page[, perPage]]]])',params:'port: "east"|"west"|"north"|"south" filter: substring filter page: page number perPage: functions per page',desc:'Creates diegetic function browser. Rows use ON_SELECT hooks: ? inserts to focus and toasts; ?? copies call and toasts.'},
 {name:'INVENTORY',tags:'META',syntax:'=INVENTORY([port[, title]])',params:'port: dock position title: inventory name',desc:'Creates interactive inventory with +/- quantity buttons and ? use buttons.'},
 {name:'2D_PLATFORMER',tags:'META',syntax:'=2D_PLATFORMER([port])',params:'port: dock position for controller',desc:'Creates controller (ON_SELECT joystick) and screen; center button spawns screen via ON_SELECT.'},
 {name:'FOCUS_SET',tags:'ACTION',syntax:'=FOCUS_SET(content) or =FOCUS_SET(mode, content)',params:'mode: "text"|"formula"|"clipboard" content: data to set/copy',desc:'Writes to focused cell or copies to clipboard (with toast).'},
 {name:'SET_SELECTED',tags:'ACTION',syntax:'=SET_SELECTED(direction)',params:'direction: "up"|"down"|"left"|"right"|"forward"|"back"',desc:'Moves avatar character in screen array based on direction.'}
 ];
 // Utilities to merge manual docs with Fn registry and compute composition
 function mergeDocsAndComputeDeps(){
 const globalFn = (typeof window!=='undefined' && window.Fn) ? window.Fn : (typeof Fn!=='undefined'? Fn : {});
 const allNames = Object.keys(globalFn||{});
 const docsByName = new Map(docs.map(d => [d.name, {...d}]));
 const toUpperSet=(x)=>{ const set=new Set(); (x||[]).forEach(v=>set.add(String(v).toUpperCase())); return set; };
 const namesUpper = new Set(allNames.map(n=>n.toUpperCase()));
 const reCall = /=([A-Z_][A-Z0-9_]*)\s*\(/g; // match =NAME(
 const reProp = /Fn\.([A-Z_][A-Z0-9_]*)/g; // match Fn.NAME
 const reIndex = /Fn\[['"]([A-Z_][A-Z0-9_]*)['"]\]/g; // match Fn['NAME']
 const extractDeps=(src)=>{
 const found=new Set(); if(!src) return [];
 let m; while((m=reCall.exec(src))){ const n=m[1].toUpperCase(); if(namesUpper.has(n)) found.add(n); }
 while((m=reProp.exec(src))){ const n=m[1].toUpperCase(); if(namesUpper.has(n)) found.add(n); }
 while((m=reIndex.exec(src))){ const n=m[1].toUpperCase(); if(namesUpper.has(n)) found.add(n); }
 return Array.from(found);
 };
 allNames.forEach(name=>{
 const meta = globalFn[name] || {};
 const existing = docsByName.get(name);
 const tagsRaw = meta.tags;
 const tagsArr = Array.isArray(tagsRaw) ? tagsRaw : (tagsRaw instanceof Set ? Array.from(tagsRaw) : []);
 const tagStr = (tagsArr && tagsArr.length) ? tagsArr.join(',') : '';
 const implSrc = (meta.impl && meta.impl.toString) ? String(meta.impl.toString()) : '';
 const deps = extractDeps(implSrc);
 if(existing){
 // Merge tags
 const existingTags = String(existing.tags||'').split(/[\s,]+/).filter(Boolean).map(t=>t.toUpperCase());
 const merged = new Set(existingTags.concat(tagsArr.map(t=>String(t).toUpperCase())));
 existing.tags = Array.from(merged).join(',');
 // Fill blank fields only
 if(!existing.syntax) existing.syntax = meta.syntax || `=${name}()`;
 if(!existing.params) existing.params = meta.params || '';
 if(!existing.desc) existing.desc = meta.desc || '';
 existing.deps = deps.filter(d=>d!==name.toUpperCase());
 existing.isComposite = existing.deps && existing.deps.length>0;
 docsByName.set(name, existing);
 } else {
 docsByName.set(name, {name, tags: tagStr || 'OTHER', syntax: meta.syntax || `=${name}()`, params: meta.params || '', desc: meta.desc || '', deps: deps.filter(d=>d!==name.toUpperCase()), isComposite: deps.length>0});
 }
 });
 // Also compute deps for any manual-only entry
 docsByName.forEach((d)=>{ if(d.deps===undefined) d.deps=[]; if(d.isComposite===undefined) d.isComposite = d.deps.length>0; });
 return Array.from(docsByName.values()).sort((a,b)=> a.name.localeCompare(b.name));
 }
 const pickCat = (d) => {
 const t = String(d.tags||'').toUpperCase();
 if(t.includes('GLOBAL')) return 'GLOBAL';
 if(t.includes('EVENT')) return 'EVENTS';
 if(t.includes('GAME')) return 'GAMES';
 if(t.includes('SCENE')) return 'SCENE';
 if(t.includes('DATA') || t.includes('PURE')) return 'DATA';
 if(t.includes('LOGIC')) return 'LOGIC';
 if(t.includes('MATH')) return 'MATH';
 if(t.includes('NAV')) return 'NAVIGATION';
 if(t.includes('INTERACTION')) return 'INTERACTION';
 if(t.includes('IO')) return 'IO';
 if(t.includes('META') || t.includes('ACTION') || t.includes('ADVANCED')) return 'ADVANCED';
 return 'OTHER';
 };
 // Build filter bar at top
 const filterBar=document.createElement('div');
 filterBar.className='fx-filter-bar';
 filterBar.style.cssText='display:flex;gap:6px;align-items:center;margin-bottom:8px;';
 const modes=[{key:'all', label:'All'},{key:'raw', label:'Raw'},{key:'composite', label:'Composite'}];
 const filterState = (Store.getState().ui?.fxFilter)||'all';
 const btns=[];
 modes.forEach(m=>{
 const b=document.createElement('button'); b.textContent=m.label; b.className='btn'; b.dataset.mode=m.key; b.style.padding='4px 8px';
 if(m.key===filterState){ b.classList.add('primary'); }
 b.addEventListener('click',()=>{
 const st=Store.getState(); Store.setState(s=>({ui:{...s.ui, fxFilter:m.key}}));
 btns.forEach(bb=>bb.classList.remove('primary'));
 b.classList.add('primary');
 renderList(m.key);
 });
 btns.push(b); filterBar.appendChild(b);
 });
 els.fxBody.appendChild(filterBar);
 const listWrap=document.createElement('div'); listWrap.id='fxListWrap'; els.fxBody.appendChild(listWrap);
 
 function renderList(mode){
 listWrap.innerHTML='';
 const allDocs = mergeDocsAndComputeDeps();
 const filtered = allDocs.filter(d => mode==='all' ? true : (mode==='composite'? d.isComposite : !d.isComposite));
 // Group by category
 const categories = {};
 filtered.forEach(d=>{ const c=pickCat(d); (categories[c]||(categories[c]=[])).push(d); });
 
 // Category info with icons and colors
 const categoryInfo = {
 'GLOBAL': {icon: '??', name: 'Global State', color: '#3b82f6'},
 'EVENTS': {icon: '?', name: 'Event System', color: '#22c55e'},
 'GAMES': {icon: '??', name: 'Game Templates', color: '#f59e0b'},
 'DATA': {icon: '??', name: 'Data Operations', color: '#8b5cf6'},
 'LOGIC': {icon: '??', name: 'Logic & Control', color: '#06b6d4'},
 'MATH': {icon: '??', name: 'Mathematics', color: '#ef4444'},
 'NAVIGATION': {icon: '??', name: 'Navigation', color: '#84cc16'},
 'INTERACTION': {icon: '??', name: 'User Interaction', color: '#ec4899'},
 'SCENE': {icon: '??', name: 'Scene Control', color: '#f97316'},
 'ARRAYS': {icon: '??', name: 'Array Management', color: '#64748b'},
 'IO': {icon: '??', name: 'Input/Output', color: '#0ea5e9'},
 'ADVANCED': {icon: '??', name: 'Advanced Tools', color: '#6366f1'},
 'OTHER': {icon: '??', name: 'Other', color: '#64748b'}
 };
 Object.entries(categories).forEach(([catName, funcs]) => {
 const info = categoryInfo[catName] || {icon: '??', name: catName, color: '#64748b'};
 const header = document.createElement('div');
 header.className = 'fx-category-header';
 header.style.cssText = `display:flex;align-items:center;gap:8px;padding:8px 12px;background:${info.color}15;border:1px solid ${info.color}40;border-radius:10px;margin:8px 0 4px 0;cursor:pointer;font-weight:600;user-select:none;`;
 header.innerHTML = `<span style="font-size:16px;">${info.icon}</span><span style="flex:1;">${info.name}</span><span class="collapse-arrow" style="font-size:12px;transition:transform 0.2s;">?</span>`;
 const body = document.createElement('div'); body.className='fx-category-body'; body.style.display='block';
 funcs.forEach(d => {
 const div = document.createElement('div');
 div.className = 'fx-item';
 div.style.marginLeft = '12px';
 const tagStr = (d.tags||'');
 const madeOf = (d.deps && d.deps.length) ? `<details style="margin-top:6px;"><summary>Made of </summary><div style="margin-top:4px;">
 ${d.deps.sort().map(dep=>`<span class=\"badge\" style=\"display:inline-block;margin:2px 4px 0 0;padding:2px 6px;border-radius:8px;background:var(--chip-bg);border:1px solid var(--chip-border);font-size:10px;\">${dep}</span>`).join('')}
 </div></details>` : '';
 div.innerHTML = `<div class="fx-name"><button class="btn" data-insert="${d.name}" style="font-size:11px;padding:4px 8px;">${d.name}</button> <span style="font-size:9px;color:var(--muted)">${tagStr}</span></div><div class="fx-syntax" style="font-size:11px;">${d.syntax||`=${d.name}()`}</div><div style="font-size:10px;color:var(--muted);margin:3px 0"><b>Parameters:</b> ${d.params||''}</div><div class="fx-desc" style="font-size:11px;">${d.desc||''}</div>${madeOf}<div class="row" style="margin-top:4px"><button class="fx-copy" style="font-size:10px;padding:2px 6px;">Copy</button><button class="btn" data-insert-raw="${(d.syntax||`=${d.name}()`).replace(/"/g,'&quot;')}" style="font-size:10px;padding:2px 6px;margin-left:6px">Insert</button></div>`;
 div.querySelector('.fx-copy').onclick = () => { navigator.clipboard.writeText(d.syntax||`=${d.name}()`); showToast('Copied'); };
 div.querySelector('button[data-insert]')?.addEventListener('click', () => {
 const name = d.name; const input = els.fx; const at = input.selectionStart ?? input.value.length;
 const before = input.value.slice(0, at); const after = input.value.slice(at);
 const ins = before.endsWith('=') ? `${name}()` : `=${name}()`;
 input.value = before + ins + after; input.focus();
 const pos = (before + ins).length - 1; input.setSelectionRange(pos, pos);
 });
 div.querySelector('button[data-insert-raw]')?.addEventListener('click', (e) => {
 const text = e.currentTarget.getAttribute('data-insert-raw') || '';
 els.fx.value = text; els.apply.click();
 });
 body.appendChild(div);
 });
 let collapsed=false; header.addEventListener('click',()=>{ collapsed=!collapsed; body.style.display=collapsed?'none':'block'; header.querySelector('.collapse-arrow').style.transform = collapsed? 'rotate(-90deg)':'rotate(0deg)'; });
 listWrap.appendChild(header); listWrap.appendChild(body);
 });
 }
 // Initial render
 renderList(filterState);
 
 // Category info with icons and colors
 // (Category rendering moved into renderList)
 }

 function setHovered2D(arrId, coord){
 try{
 // clear previous class
 if(hovered2D){
 const sel = hovered2D;
 const prev = document.querySelector(`td.cell[data-x="${sel.x}"][data-y="${sel.y}"][data-z="${sel.z}"]`);
 if(prev) prev.classList.remove('hovered');
 }
 hovered2D = (arrId && coord) ? {arrId, ...coord} : null;
 if(hovered2D){
 const td = document.querySelector(`td.cell[data-x="${coord.x}"][data-y="${coord.y}"][data-z="${coord.z}"]`);
 if(td) td.classList.add('hovered');
 try{ Scene && Scene.setHoverCell && Scene.setHoverCell({arrId, x:coord.x, y:coord.y, z:coord.z}); }catch{}
 } else {
 try{ Scene && Scene.clearHoverCell && Scene.clearHoverCell(); }catch{}
 }
 }catch{}
 }

 function setHoveredCell(arrId, coord){
 // Called from Scene to reflect 3D hover into 2D grid
 setHovered2D(arrId, coord);
 }

 function toggleFxPanel(){ const open=!Store.getState().ui.fxOpen; Store.setState(s=>({ui:{...s.ui,fxOpen:open}})); if(open){ els.fxPanel.style.display='flex'; showFunctionDrawer(); } else { hideFunctionDrawer(); } }
 // Enhanced: dock function drawer beside last visible cell and expand sheet width
 function showFunctionDrawer(){
 const panel=els.fxPanel; if(!panel) return;
 const sheet=document.getElementById('sheet');
 const body=sheet.querySelector('.sheet-body');
 const grid=sheet.querySelector('.grid-wrap');
 // Dock panel at right, between grid and window border
 body.style.display='flex';
 grid.style.flex='1 1 auto';
 // Drawer width: ~two cell widths
 const colWidth = parseInt(getComputedStyle(document.querySelector('td.cell'))?.width||'140',10);
 const drawerWidth = Math.max(240, Math.min(480, colWidth*2 + 24));
 panel.style.flex = `0 0 ${drawerWidth}px`;
 panel.style.display='flex';
 panel.classList.add('fx-visible');
 // Grow sheet width smoothly to accommodate panel if needed, but cap to 70% viewport width
 const cap = Math.floor(window.innerWidth * 0.7);
 const curW=parseInt(sheet.style.width||getComputedStyle(sheet).width,10)||sheet.offsetWidth;
 const minNeeded = grid.scrollWidth + drawerWidth + 48; // grid + drawer + padding
 const nextW = Math.max(curW, Math.min(cap, minNeeded));
 sheet.style.width = nextW + 'px';
 }
 function hideFunctionDrawer(){
 const sheet=document.getElementById('sheet');
 const body=sheet.querySelector('.sheet-body');
 const grid=sheet.querySelector('.grid-wrap');
 els.fxPanel.classList.remove('fx-visible');
 // Shrink sheet width back to just fit grid + small pad
 setTimeout(()=>{
 const desired = Math.min(Math.max(grid.scrollWidth + 32, 720), Math.floor(window.innerWidth*0.6));
 sheet.style.width = desired + 'px';
 els.fxPanel.style.display='none';
 }, 250);
 }
 function currentArray(){ const s=Store.getState().selection; return s.arrayId?Store.getState().arrays[s.arrayId]:Store.getState().arrays[1]||Store.getState().arrays[-1]; }
 function getZLayer(){ return Store.getState().ui.zLayer; } // parser hook
 function clampLayerIndex(arr, idx){
 const max = Math.max(0, ((arr?.size?.z)||1) - 1);
 const value = Number.isFinite(idx) ? (idx|0) : 0;
 return Math.max(0, Math.min(max, value));
 }
 function setZLayer(index){
 const arr = currentArray();
 const next = clampLayerIndex(arr, index);
 const prev = getZLayer();
 if(next === prev) return next;
 Store.setState(s=>({ ui:{...s.ui, zLayer: next} }));
 try{ renderSheet(); }catch(e){ console.warn('renderSheet after setZLayer failed', e); }
 try{ highlightSheetCell(); }catch(e){ console.warn('highlight after setZLayer failed', e); }
 return next;
 }
 function shiftZLayer(delta){
 const step = Number.isFinite(delta) ? (delta|0) : 0;
 if(!step) return getZLayer();
 return setZLayer(getZLayer() + step);
 }
 // Intro collapse trigger for onboarding
 function triggerIntroCollapse(){
 const sheetEl=document.getElementById('sheet');
 const header=document.getElementById('sheetHeaderCard');
 if(!sheetEl){ console.warn('triggerIntroCollapse: sheet not found'); return false; }
 console.log('triggerIntroCollapse: before', {classes: sheetEl.className, left: sheetEl.style.left, top: sheetEl.style.top, bottom: sheetEl.style.bottom, transform: sheetEl.style.transform});
 sheetEl.classList.remove('intro-max');
 sheetEl.classList.remove('intro-centered');
 // Resize relative to viewport with sane minimums
 const isTouch = document.body.classList.contains('touch');
 if(isTouch){
 // Behind-sheet header wipe animation
 try{
 const r=sheetEl.getBoundingClientRect();
 header.style.left = r.left + 'px';
 header.style.top = (r.top - 10) + 'px';
 header.style.width = r.width + 'px';
 header.style.height = (r.height + 20) + 'px';
 header.classList.add('visible');
 // Expand to wipe
 requestAnimationFrame(()=>{ header.classList.add('wipe'); });
 // Cleanup after wipe
 setTimeout(()=>{ header.classList.remove('wipe'); header.classList.remove('visible'); }, 700);
 }catch{}
 // Mobile card: center bottom with capped width and ~40vh height
 const targetWidth = Math.min(window.innerWidth*0.92, 680);
 const targetHeight = Math.round(Math.min(window.innerHeight*0.40, 520));
 const leftPx = Math.max(12, Math.round((window.innerWidth - targetWidth) / 2));
 sheetEl.style.width = targetWidth + 'px';
 sheetEl.style.height = targetHeight + 'px';
 sheetEl.style.left = leftPx + 'px';
 sheetEl.style.right = 'auto';
 sheetEl.style.bottom = '12px';
 sheetEl.style.top = '';
 sheetEl.style.transform = 'none';
 sheetEl.dataset.touchFreed = '1';
 } else {
 // Desktop: bottom-left similar to launch size
 const vw = Math.max(720, Math.floor(window.innerWidth * 0.42));
 const vh = Math.max(360, Math.floor(window.innerHeight * 0.40));
 // Behind-sheet header wipe animation
 try{
 const r=sheetEl.getBoundingClientRect();
 header.style.left = r.left + 'px';
 header.style.top = (r.top - 10) + 'px';
 header.style.width = r.width + 'px';
 header.style.height = (r.height + 20) + 'px';
 header.classList.add('visible');
 requestAnimationFrame(()=>{ header.classList.add('wipe'); });
 setTimeout(()=>{ header.classList.remove('wipe'); header.classList.remove('visible'); }, 700);
 }catch{}
 sheetEl.style.width = vw + 'px';
 sheetEl.style.height = vh + 'px';
 sheetEl.style.left = '16px';
 sheetEl.style.top = '';
 sheetEl.style.bottom = '16px';
 sheetEl.style.transform = '';
 sheetEl.dataset.touchFreed = '0';
 }
 // Mark sheet as user-sized after intro so renderSheet doesn't resize it
 sheetEl.dataset.userSized = '1';
 console.log('triggerIntroCollapse: after', {classes: sheetEl.className, left: sheetEl.style.left, top: sheetEl.style.top, bottom: sheetEl.style.bottom, transform: sheetEl.style.transform});
 return true;
 }
 // Robust overlay hider with hard fallback
 function hideIntroOverlay(){
 const io = document.getElementById('introOverlay');
 if (io) {
 io.classList.add('hidden');
 return true;
 }
 console.warn('hideIntroOverlay: introOverlay not found');
 return false;
 }
 function debugIntroState(stage){
 const sheet=document.getElementById('sheet');
 const io=document.getElementById('introOverlay');
 const snapshot={
 stage,
 sheet:{ classes: sheet?.className, left: sheet?.style.left, top: sheet?.style.top, bottom: sheet?.style.bottom, transform: sheet?.style.transform },
 overlay:{ exists: !!io, hiddenClass: io?.classList.contains('hidden'), opacity: io? getComputedStyle(io).opacity : 'n/a', display: io? getComputedStyle(io).display : 'n/a', pointer: io?.style.pointerEvents }
 };
 console.log('IntroDebug:', snapshot);
 }
 function kickIntroSequence(reason='manual'){
 console.log('kickIntroSequence:', reason);
 debugIntroState('kick:pre');
 const hid = hideIntroOverlay();
 const col = triggerIntroCollapse();
 debugIntroState('kick:post');
 showToast('? Intro');
 try{ window.__INTRO_FIRED = true; }catch{}
 return hid && col;
 }
 function getCell(arrayId,coord){ const arr=Store.getState().arrays[arrayId]; if(!arr) return {value:'',formula:null}; const ch=arr.chunks[keyChunk(...Object.values(chunkOf(coord.x,coord.y,coord.z)))]; if(!ch) return {value:'',formula:null}; const m=ch.cellMap; if(m){ const c=m.get(`${coord.x},${coord.y},${coord.z}`); return c||{value:'',formula:null}; } const c=ch.cells.find(t=>t.x===coord.x&&t.y===coord.y&&t.z===coord.z); return c||{value:'',formula:null}; }

 function updateFocusChip(){
 const s=Store.getState().selection;
 // If focus UI is not present (selection panel removed), degrade gracefully
 if(!s.arrayId||!s.focus){
 if(els.focusChip) els.focusChip.textContent='None selected.';
 if(els.inspect) els.inspect.textContent='No selection.';
 els.fx.value='';
 try{ highlightFxRefs(''); }catch{}
 return;
 }
 const arr=Store.getState().arrays[s.arrayId]; const cell=getCell(s.arrayId,s.focus);
 // Update fx input to show cell contents and sync highlight
 els.fx.value = (cell.formula && cell.formula!=='') ? cell.formula : String(cell.value??'');
 try{ highlightFxRefs(els.fx.value); }catch{}
 // Ensure any transient direct editor content is cleared when selection changes
 try{ if(els.direct && els.direct.style.display!=='block') els.direct.value=''; }catch{}
 
 // Update UI controls based on focused array
 updateUIControls(arr);
 
 const range = s.range;
 const zStart = range ? (range.z1 ?? range.z ?? s.focus.z) : s.focus.z;
 const zEnd = range ? (range.z2 ?? range.z ?? s.focus.z) : s.focus.z;
 const isMulti = range && (range.x1!==range.x2 || range.y1!==range.y2 || zStart!==zEnd);
 if(isMulti){
 const {x1,x2,y1,y2} = range;
 const layerCount = (zEnd - zStart + 1);
 const count=(x2-x1+1)*(y2-y1+1)*layerCount;
 let sum=0,vals=0,min=Infinity,max=-Infinity;
 for(let z=zStart; z<=zEnd; z++){
 for(let y=y1;y<=y2;y++){
 for(let x=x1;x<=x2;x++){
 const c=getCell(s.arrayId,{x,y,z}); const v=+c.value;
 if(!isNaN(v)){ sum+=v; vals++; min=Math.min(min,v); max=Math.max(max,v); }
 }
 }
 }
 const avg=vals>0?(sum/vals):0;
 const zLabelStart = typeof zStart==='number'?greek(zStart):'';
 const zLabelEnd = typeof zEnd==='number'?greek(zEnd):zLabelStart;
 const rangeLabel = `${A1(x1)}${y1+1}${zLabelStart}:${A1(x2)}${y2+1}${zLabelEnd}`;
 const layerLabel = layerCount>1?`${layerCount} layers`:`${layerCount} layer`;
 if(els.focusChip) els.focusChip.textContent = `Range ${count} cells (${layerLabel}): sum=${sum.toFixed(1)} avg=${avg.toFixed(1)} min=${min===Infinity?' ':min} max=${max===-Infinity?' ':max}`;
 if(els.inspect) els.inspect.textContent = `Range ${rangeLabel}\nCells: ${count}, Values: ${vals}, ${layerLabel}\nSum: ${sum}, Avg: ${avg.toFixed(2)}`;
 } else {
 if(els.focusChip) els.focusChip.textContent = `#${arr.id} ${arr.name} ${A1(s.focus.x)}${s.focus.y+1}${greek(s.focus.z)}`;
 if(els.inspect) els.inspect.textContent = `Array #${arr.id} "${arr.name}"\nCell ${A1(s.focus.x)}${s.focus.y+1}${greek(s.focus.z)} @[${s.focus.x+1},${s.focus.y+1},${s.focus.z+1},${arr.id}]\nValue: ${JSON.stringify(cell.value)}\nFormula: ${cell.formula||''}`;

 // --- START NEW COLOR SYNC LOGIC ---
 try{
 const focusColor = (cell?.meta?.color) ? String(cell.meta.color) : '#ffffff';
 const pickerInput = document.getElementById('fillColorPicker');
 const pickerPreview = document.getElementById('fillColorPreview');
 if(pickerInput) pickerInput.value = focusColor;
 if(pickerPreview) pickerPreview.style.backgroundColor = focusColor;
 }catch{}
 // --- END NEW COLOR SYNC LOGIC ---
 }
 }

 function updateUIControls(arr){
 // Check if insert buttons should be visible based on array UI controls
 const controls = arr.uiControls || {};
 const insertAllowed = controls.insert_buttons || (arr.id === 2); // Sandbox enables by default
 // Make sheet title editable on double click
 try{
 const titleEl = document.getElementById('sheetTitle');
 if(titleEl && !titleEl._wired){
 titleEl._wired = true;
 titleEl.title = 'Double-click to rename';
 titleEl.addEventListener('dblclick', ()=>{
 const current = String(arr.name||'Unnamed');
 const next = window.prompt('Rename array:', current);
 if(next!=null){ arr.name = next || 'Unnamed'; UI.updateFocusChip?.(); }
 });
 }
 }catch{}
 const insertRow = document.getElementById('insertRow');
 const insertCol = document.getElementById('insertCol');
 const insertLayer = document.getElementById('insertLayer');
 if(insertRow) insertRow.style.display = insertAllowed ? 'inline-block' : 'none';
 if(insertCol) insertCol.style.display = insertAllowed ? 'inline-block' : 'none';
 if(insertLayer) insertLayer.style.display = insertAllowed ? 'inline-block' : 'none';
 }
 function bindHoldAction(td, arr, anchorRef, initialAction){
 if(td._holdCleanup){ try{ td._holdCleanup(); }catch{} }
 td._holdCleanup = null;
 td.classList.remove('holdable');

 const hasAction = !!normalizeActionFormula(initialAction||'');
 if(!hasAction) return;

 td.classList.add('holdable');
 let active=false;
 let timer=null;
 let pointerId=null;

 const runHold = ()=>{
 const fresh = UI.getCell?.(anchorRef.arrId, {x:anchorRef.x, y:anchorRef.y, z:anchorRef.z});
 const raw = getMetaAction(fresh?.meta, 'on_hold') ?? initialAction;
 const normalized = normalizeActionFormula(raw||'');
 if(!normalized) return false;
 try{
 executeActionFormula(anchorRef, raw, 'hold');
 }catch(err){ console.warn('on_hold failed', err); return false; }
 return true;
 };

 const stopHold = ()=>{
 if(timer){ clearInterval(timer); timer=null; }
 if(active){ td.classList.remove('pending'); active=false; }
 pointerId=null;
 };

 const handleCancel = ()=>{ stopHold(); };
 const handlePointerUp = (e)=>{
 if(pointerId!=null && e && e.pointerId!=null && e.pointerId!==pointerId) return;
 stopHold();
 };
 const handlePointerDown = (e)=>{
 if(e.button!=null && e.button!==0 && e.pointerType!=='touch') return;
 if(active) return;
 if(e.pointerType==='touch'){ e.preventDefault(); }
 if(!runHold()) return;
 active=true;
 pointerId = e.pointerId;
 td.classList.add('pending');
 try{ td.setPointerCapture?.(e.pointerId); }catch{}
 timer = setInterval(()=>{ if(!runHold()) stopHold(); }, ACTION_TICK_MS);
 };

 td.addEventListener('pointerdown', handlePointerDown);
 td.addEventListener('pointerup', handlePointerUp);
 td.addEventListener('pointerleave', handleCancel);
 td.addEventListener('pointercancel', handleCancel);
 td.addEventListener('lostpointercapture', handleCancel);

 td._holdCleanup = ()=>{
 stopHold();
 td.removeEventListener('pointerdown', handlePointerDown);
 td.removeEventListener('pointerup', handlePointerUp);
 td.removeEventListener('pointerleave', handleCancel);
 td.removeEventListener('pointercancel', handleCancel);
 td.removeEventListener('lostpointercapture', handleCancel);
 };
 }

 function bindClickAction(td, arr, anchorRef){
 const {x,y,z} = anchorRef;
 const key = `${anchorRef.arrId}:${x},${y},${z}`;

 const runClick = ()=>{
 let action='';
 try{
 const fresh = UI.getCell?.(anchorRef.arrId, {x,y,z});
 action = getMetaAction(fresh?.meta, 'on_click') || action;
 }catch{}
 if(!action){
 try{ if(!window.__INTRO_FIRED) action = '=STARTINTROEXPERIENCE()'; }catch{}
 }
 const normalized = normalizeActionFormula(action||'');
 if(!normalized) return;
 try{
 td.classList.add('pending');
 executeActionFormula(anchorRef, action, 'click');
 try{
 UI.debugIntroState?.('onclick-commit');
 const didHide = window.UI?.hideIntroOverlay?.();
 if(didHide){
 try{ window.__INTRO_FIRED = true; }catch{}
 window.UI?.triggerIntroCollapse?.();
 } else {
 UI.kickIntroSequence?.('onclick-fallback');
 }
 }catch{}
 }catch(err){
 console.warn('on_click failed', err);
 }finally{
 td.classList.remove('pending');
 }
 };

 td.onclick = (e)=>{
 Actions.setSelection(arr.id,{x,y,z}, null, '2d');
 window.__awaiting2DClick = false;
 if(!window.__sheetClickTimers) window.__sheetClickTimers = new Map();
 if(window.__sheetClickTimers.has(key)){
 try{ clearTimeout(window.__sheetClickTimers.get(key)); }catch{}
 window.__sheetClickTimers.delete(key);
 e.preventDefault();
 e.stopPropagation();
 setTimeout(()=>{ try{ openEditor(); }catch{} }, 0);
 return;
 }
 const timer = setTimeout(()=>{
 try{ window.__sheetClickTimers.delete(key); }catch{}
 runClick();
 }, 220);
 window.__sheetClickTimers.set(key, timer);
 };

 td.ondblclick = (e)=>{
 e.preventDefault();
 e.stopPropagation();
 window.__awaiting2DClick = false;
 Actions.setSelection(arr.id,{x,y,z}, null, '2d');
 try{ window.__last2DCell = {arrId:arr.id, x, y, z}; }catch{}
 try{
 if(window.__sheetClickTimers?.has?.(key)){
 clearTimeout(window.__sheetClickTimers.get(key));
 window.__sheetClickTimers.delete(key);
 }
 }catch{}
 setTimeout(()=>openEditor(),0);
 };
 }

 function updateSheetCellDom(td, arr, x, y, z, cell){
 const data = cell ?? getCell(arr.id,{x,y,z}) ?? {};
 const anchorRef = {arrId:arr.id, x, y, z};
 const display = (data?.meta && data.meta.displayText!==undefined) ? data.meta.displayText : (data?.value ?? '');

 td.classList.remove('pending');
 td.textContent = display;
 td.title = data?.formula || '';

 if(typeof twemoji !== 'undefined' && td.textContent){
 try{ twemoji.parse(td, {folder: 'svg', ext: '.svg', className: 'emoji'}); }catch{}
 }

 const color = data?.meta?.color;
 if(color){
 td.style.backgroundColor = color;
 const hex = String(color||'').replace('#','');
 const r = parseInt(hex.substring(0,2),16)|0;
 const g = parseInt(hex.substring(2,4),16)|0;
 const b = parseInt(hex.substring(4,6),16)|0;
 const brightness = (r*299 + g*587 + b*114) / 1000;
 td.style.color = brightness > 128 ? '#1f2937' : '#ffffff';
 } else {
 td.style.backgroundColor = '';
 td.style.color = '';
 }

 td.querySelector('.note-tooltip')?.remove();
 const hasNote = data?.meta?.noteText;
 if(hasNote){
 const tooltip=document.createElement('div');
 tooltip.className='note-tooltip note-visible';
 tooltip.textContent=data.meta.noteText;
 td.style.position='relative';
 td.appendChild(tooltip);
 td.classList.add('intro-cell');
 } else {
 td.classList.remove('intro-cell');
 if(!td.querySelector('.note-tooltip')) td.style.position='';
 }

 td.classList.toggle('clickable', !!getMetaAction(data?.meta, 'on_click'));

 bindHoldAction(td, arr, anchorRef, getMetaAction(data?.meta, 'on_hold'));
 bindClickAction(td, arr, anchorRef);

 if(data?.meta?.generated){
 td.setAttribute('data-generated', 'true');
 if(data.formula){ td.setAttribute('data-anchor','true'); }
 else { td.removeAttribute('data-anchor'); }
 } else {
 td.removeAttribute('data-generated');
 td.removeAttribute('data-anchor');
 }
 }

 function renderSheet(){
 // Guard: avoid destroying cells between mousedown and click; allow highlight only
 if(window.__awaiting2DClick){ try{ highlightSheetCell(); }catch{} return; }
 const arr=currentArray(); if(!arr) return;
 applyCrystalStyle(Store.getState().ui?.crystal2D);
 els.sheetTitle.textContent=`Array ${arr.id}${arr.name?` "${arr.name}"`:''}`;

 // Size sheet ONLY during intro - after that, keep user-defined size
 const sheet = document.getElementById('sheet');
 if(sheet && !sheet.dataset.userSized){
 const isHome = (arr.id === 1);
 if(isHome && !sheet.dataset.initialSized){
 // Match the size that will be used after intro collapse
 const vw = Math.max(720, Math.floor(window.innerWidth * 0.42));
 const vh = Math.max(360, Math.floor(window.innerHeight * 0.40));
 sheet.style.width = `${vw}px`;
 sheet.style.height = `${vh}px`;
 console.log(`[SHEET] Initial sizing for home array: ${vw}x${vh}`);
 // Mark as sized so we don't resize on selection changes
 sheet.dataset.initialSized = '1';
 }
 }

 // Update UI controls when sheet renders
 updateUIControls(arr);

 // Preserve scroll to avoid jump/offset during drag selection re-renders
 const gridWrapEl = document.querySelector('#sheet .grid-wrap');
 const prevScrollTop = gridWrapEl ? gridWrapEl.scrollTop : 0;
 const prevScrollLeft = gridWrapEl ? gridWrapEl.scrollLeft : 0;

 // reference grid structure (thead/tbody)
 let cols=document.getElementById('cols');
 let rows=document.getElementById('rows');
 if(!cols || !rows){
 const body=document.querySelector('#sheet .sheet-body');
 if(body){
 body.innerHTML='';
 const tbl=document.createElement('table'); tbl.className='sheet'; tbl.style.width='100%';
 const thead=document.createElement('thead'); const tr=document.createElement('tr'); tr.id='cols'; const th=document.createElement('th'); th.style.position='sticky'; th.style.left='0'; tr.appendChild(th); thead.appendChild(tr);
 const tbody=document.createElement('tbody'); tbody.id='rows';
 tbl.appendChild(thead); tbl.appendChild(tbody); body.appendChild(tbl);
 cols=document.getElementById('cols'); rows=document.getElementById('rows');
 }
 }
 if(cols) cols.innerHTML=''; if(rows) rows.innerHTML='';
 console.log('renderSheet: building grid', {arrayId:arr.id, size:arr.size});
 // Leading corner cell: show current Z layer as greek letter
 // Z layer header with prev/next buttons
 const th0=document.createElement('th'); 
 th0.style.cssText='padding:2px 4px; position:sticky; left:0; background:var(--panel); z-index:2;';
 const zLayerWrap = document.createElement('div');
 zLayerWrap.style.cssText='display:flex; align-items:center; gap:2px; justify-content:center;';
 const zPrevBtn = document.createElement('button');
 zPrevBtn.textContent = ' ';
 zPrevBtn.className = 'layer-btn';
 zPrevBtn.style.cssText = 'padding:0 4px; font-size:12px; min-width:20px;';
 zPrevBtn.disabled = (getZLayer() <= 0);
 zPrevBtn.onclick = ()=> shiftZLayer(-1);
 const zLabel = document.createElement('span');
 zLabel.textContent = greek(getZLayer());
 zLabel.style.cssText = 'font-weight:600; min-width:16px; text-align:center;';
 const zNextBtn = document.createElement('button');
 zNextBtn.textContent = ' ';
 zNextBtn.className = 'layer-btn';
 zNextBtn.style.cssText = 'padding:0 4px; font-size:12px; min-width:20px;';
 zNextBtn.disabled = (getZLayer() >= (arr.size.z - 1));
 zNextBtn.onclick = ()=> shiftZLayer(1);
 zLayerWrap.appendChild(zPrevBtn);
 zLayerWrap.appendChild(zLabel);
 zLayerWrap.appendChild(zNextBtn);
 th0.appendChild(zLayerWrap);
 cols.appendChild(th0);
 // TanStack Virtual for efficient large sheet rendering
 const gridWrap = document.querySelector('#sheet .grid-wrap');
 const wrapRect = gridWrap?.getBoundingClientRect?.() || {width:760, height:360};
 const cellH = 26; // matches CSS
 const cellW = 100; // default cell width
 
 // Create virtualizers if TanStack is available
 // For array #1 (Celli's home), render ALL cells with no virtualization
 const isHome = (arr.id === 1);
 let rowStart = 0, rowEnd = isHome ? arr.size.y : Math.min(arr.size.y, 20);
 let colStart = 0, colEnd = isHome ? arr.size.x : Math.min(arr.size.x, 10);
 
 if(typeof TanStackVirtualCore !== 'undefined' && gridWrap && !isHome){
 try{
 const scrollTop = gridWrap.scrollTop || 0;
 const scrollLeft = gridWrap.scrollLeft || 0;
 
 // Row virtualizer
 const rowVirtualizer = TanStackVirtualCore.createVirtualizer({
 count: arr.size.y,
 getScrollElement: () => gridWrap,
 estimateSize: () => cellH,
 overscan: 3
 });
 
 const visibleRows = rowVirtualizer.getVirtualItems();
 if(visibleRows.length > 0){
 rowStart = visibleRows[0].index;
 rowEnd = visibleRows[visibleRows.length - 1].index + 1;
 }
 
 // Column virtualizer (simplified - render all for now due to dynamic widths)
 colStart = Math.max(0, Math.floor(scrollLeft / cellW) - 2);
 colEnd = Math.min(arr.size.x, colStart + Math.ceil(wrapRect.width / cellW) + 4);
 }catch(e){
 console.warn('TanStack virtualization failed, falling back:', e);
 // Fallback to simple virtualization
 const scrollTop = gridWrap?.scrollTop||0;
 const visibleRows = Math.max(1, Math.ceil(wrapRect.height / cellH) + 2);
 rowStart = Math.max(0, Math.floor(scrollTop / cellH));
 rowEnd = Math.min(arr.size.y, rowStart + visibleRows);
 colStart = 0;
 colEnd = arr.size.x;
 }
 } else {
 // Fallback to simple virtualization if TanStack not available
 const scrollTop = gridWrap?.scrollTop||0;
 const visibleRows = Math.max(1, Math.ceil(wrapRect.height / cellH) + 2);
 rowStart = Math.max(0, Math.floor(scrollTop / cellH));
 rowEnd = Math.min(arr.size.y, rowStart + visibleRows);
 colStart = 0;
 colEnd = arr.size.x;
 }
 for(let i=colStart;i<colEnd;i++){
 const th=document.createElement('th'); th.textContent=colNameFromIndex(i); th.style.position='relative';
 const w=getColWidth(i); th.style.minWidth=w+'px'; th.style.width=w+'px'; th.style.maxWidth=w+'px';
 // Resizer handle (Google Sheets-like)
 const grip=document.createElement('div');
 grip.style.position='absolute'; grip.style.right='-3px'; grip.style.top='0'; grip.style.width='6px'; grip.style.height='100%';
 grip.style.cursor='col-resize'; grip.style.userSelect='none'; grip.title='Resize column';
 th.appendChild(grip);
 let resizing=false, startX=0, startW=w;
 const onMove=(e)=>{
 if(!resizing) return; const dx=(e.clientX||0)-startX; const nw=startW+dx; setColWidth(i,nw);
 const cw=getColWidth(i); th.style.minWidth=cw+'px'; th.style.width=cw+'px'; th.style.maxWidth=cw+'px';
 // Apply to visible cells of this column at current layer
 document.querySelectorAll(`td.cell[data-x="${i}"][data-z="${getZLayer()}"]`).forEach(td=>{ td.style.minWidth=cw+'px'; td.style.width=cw+'px'; td.style.maxWidth=cw+'px'; });
 };
 const onUp=()=>{ if(!resizing) return; resizing=false; window.removeEventListener('mousemove',onMove,true); window.removeEventListener('mouseup',onUp,true); };
 grip.addEventListener('mousedown',(e)=>{ e.preventDefault(); e.stopPropagation(); resizing=true; startX=e.clientX||0; startW=getColWidth(i); window.addEventListener('mousemove',onMove,true); window.addEventListener('mouseup',onUp,true); }, true);
 cols.appendChild(th);
 }
 for(let r=rowStart;r<rowEnd;r++){
 const tr=document.createElement('tr');
 const h=document.createElement('th'); h.textContent=r+1; tr.appendChild(h);
 for(let c=colStart;c<colEnd;c++){
 const td=document.createElement('td'); td.className='cell'; td.dataset.x=c; td.dataset.y=r; td.dataset.z=getZLayer();
 // Apply fixed width with per-column override
 const cw=getColWidth(c); td.style.minWidth=cw+'px'; td.style.width=cw+'px'; td.style.maxWidth=cw+'px';
 const cell=getCell(arr.id,{x:c,y:r,z:getZLayer()});
 updateSheetCellDom(td, arr, c, r, getZLayer(), cell);
 td.onmousedown=(e)=>{
 const wrap = document.querySelector('#sheet .grid-wrap');
 const wasTop = wrap ? wrap.scrollTop : 0;
 const wasLeft = wrap ? wrap.scrollLeft : 0;
 window.__awaiting2DClick = true;
 Actions.setSelection(arr.id,{x:c,y:r,z:getZLayer()}, null, '2d'); 
 try{ UI.updateFocusChip?.(); }catch{}
 dragStart={arrayId:arr.id, x:c, y:r, z:getZLayer()}; 
 try{ window.__last2DCell = {arrId:arr.id, x:c, y:r, z:getZLayer()}; }catch{}
 // Keep scroll stable during drag begin
 try{ if(wrap){ wrap.scrollTop = wasTop; wrap.scrollLeft = wasLeft; } }catch{}
 // Do not prevent default, so click/dblclick events still fire
 };
 td.onmouseenter=(e)=>{
 if(dragStart && e.buttons&1 && dragStart.arrayId===arr.id){
 const wrap = document.querySelector('#sheet .grid-wrap');
 const wasTop = wrap ? wrap.scrollTop : 0;
 const wasLeft = wrap ? wrap.scrollLeft : 0;
 Actions.setSelectionRange(arr.id, {x:dragStart.x,y:dragStart.y,z:dragStart.z}, {x:c,y:r,z:getZLayer()}, '2d');
 // Maintain scroll after range update
 try{ if(wrap){ wrap.scrollTop = wasTop; wrap.scrollLeft = wasLeft; } }catch{}
 }
 };
 td.onmouseup=()=>{ dragStart=null; window.__awaiting2DClick = false; };
 tr.appendChild(td);
 }
 rows.appendChild(tr);
 }
 // Set spacer padding to simulate offscreen rows (single spanning cells; no pointer capture)
 try{
 const tbody = rows;
 const before = document.createElement('tr');
 const btd = document.createElement('td');
 btd.colSpan = (arr.size.x + 1);
 btd.style.padding='0'; btd.style.border='0'; btd.style.height = (rowStart*cellH)+'px';
 btd.style.pointerEvents='none'; btd.style.lineHeight='0'; btd.style.fontSize='0';
 before.appendChild(btd);
 const after = document.createElement('tr');
 const atd = document.createElement('td');
 atd.colSpan = (arr.size.x + 1);
 atd.style.padding='0'; atd.style.border='0'; atd.style.height = ((arr.size.y-rowEnd)*cellH)+'px';
 atd.style.pointerEvents='none'; atd.style.lineHeight='0'; atd.style.fontSize='0';
 after.appendChild(atd);
 tbody.prepend(before); tbody.appendChild(after);
 }catch{}
 // Restore scroll positions to prevent perceived offset while dragging
 try{ if(gridWrap){ gridWrap.scrollTop = prevScrollTop; gridWrap.scrollLeft = prevScrollLeft; } }catch{}

 // Re-render on scroll for virtualization window
 try{
 const wrap = document.querySelector('#sheet .grid-wrap');
 if(wrap && !wrap._virtWired){
 wrap._virtWired=true;
 wrap.addEventListener('scroll', (e)=>{
 const tgt = e.target; const prev = tgt._lastVT||0; const now = Date.now();
 if(now - prev > 50){ tgt._lastVT = now; try{ UI.renderSheet?.(); }catch{} }
 }, {passive:true});
 }
 }catch{}
 try{ highlightSheetCell(); }catch(e){ console.warn('highlightSheetCell failed (deferred)', e); setTimeout(()=>{ try{ highlightSheetCell(); }catch(_){} }, 0); }
 // sync 3D focus Z if selection exists
 const s=Store.getState().selection; if(s.arrayId&&s.focus&&s.focus.z!==getZLayer()) Actions.setSelection(s.arrayId,{...s.focus,z:getZLayer()});
 }
 function renderSheetCell(arr,x,y,z){
 const td=document.querySelector(`td.cell[data-x="${x}"][data-y="${y}"][data-z="${z}"]`);
 if(!td) return;
 const cell=getCell(arr.id,{x,y,z});
 updateSheetCellDom(td, arr, x, y, z, cell);
 }
 function highlightSheetCell(){ 
 document.querySelectorAll('td.cell.sel').forEach(td=>td.classList.remove('sel'));
 const s=Store.getState().selection; if(!s.focus) return; 
 if(s.range){
 const zStart = s.range.z1 ?? s.range.z;
 const zEnd = s.range.z2 ?? s.range.z;
 const layer = Store.getState().ui.zLayer;
 if(layer>=zStart && layer<=zEnd){
 for(let y=s.range.y1;y<=s.range.y2;y++){
 for(let x=s.range.x1;x<=s.range.x2;x++){
 const td=document.querySelector(`td.cell[data-x="${x}"][data-y="${y}"][data-z="${layer}"]`);
 if(td) td.classList.add('sel');
 }
 }
 }
 } else {
 const td=document.querySelector(`td.cell[data-x="${s.focus.x}"][data-y="${s.focus.y}"][data-z="${Store.getState().ui.zLayer}"]`); 
 if(td){
 td.classList.add('sel');
 // Manage focusability for keyboard users
 const oldSel = document.querySelector('td.cell[tabindex="0"]'); if(oldSel) oldSel.setAttribute('tabindex','-1');
 td.setAttribute('tabindex','0');
 }
 }
 }
 function scrollSheetToSelection(){ const s=Store.getState().selection; if(!s.focus) return; const td=document.querySelector(`td.cell[data-x="${s.focus.x}"][data-y="${s.focus.y}"][data-z="${Store.getState().ui.zLayer}"]`); if(td) td.scrollIntoView({block:'nearest',inline:'nearest'}); }

 function openEditor(initial){ 
 const s=Store.getState().selection; 
 let focus = s.focus; let arrId = s.arrayId;
 if(!focus){
 try{ const lc=window.__last2DCell; if(lc){ focus={x:lc.x,y:lc.y,z:lc.z}; arrId=lc.arrId; } }catch{}
 }
 if(!focus) return; 
 const arr=Store.getState().arrays[arrId]; 
 const cell=getCell(arrId, focus);
 const baseText = (cell.formula!=null && cell.formula!=='') ? cell.formula : String(cell.value??'');
 const edit=els.direct;
 
 // Position based on last interaction type
 if(Store.getState().ui?.lastInteraction === '2d'){
 // Position near 2D cell if available
 let td=document.querySelector('td.cell.sel');
 if(!td && focus){ td=document.querySelector(`td.cell[data-x="${focus.x}"][data-y="${focus.y}"][data-z="${focus.z}"]`); }
 if(td){ 
 const r=td.getBoundingClientRect(); 
 edit.style.left=r.left+'px'; 
 edit.style.top=(r.top-28)+'px'; 
 } else { 
 // Fallback to sheet position
 const sheet=document.getElementById('sheet'); 
 const r=sheet.getBoundingClientRect(); 
 edit.style.left=(r.left+12)+'px'; 
 edit.style.top=(r.top+36)+'px'; 
 }
 } else {
 // Position in 3D viewport area for 3D interactions
 const canvas=document.getElementById('view');
 if(canvas){
 const r=canvas.getBoundingClientRect();
 edit.style.left=(r.left + r.width/2 - 100)+'px'; // Center horizontally
 edit.style.top=(r.top + 60)+'px'; // Near top of 3D view
 } else {
 // Fallback
 edit.style.left='50%'; 
 edit.style.top='100px';
 }
 }
 
 // Ensure the editor is visible and styled above the 3D canvas
 edit._openedAt = Date.now();
 edit.style.display='block'; 
 edit.style.zIndex='10005';
 edit.style.opacity='1';
 edit.style.pointerEvents='auto';
 edit.value = (initial!==undefined && initial!==null) ? (initial==='='? '=' : initial) : baseText;
 els.fx.value = edit.value; // realtime sync start
 try{ const h=document.getElementById('fxHighlight'); if(h){ h.scrollTop=h.scrollHeight; } }catch{}
 edit.focus(); 
 if(!initial) edit.select();
 }
 function commitEditor(){ 
 const s=Store.getState().selection; 
 if(!s.focus){ 
 els.direct.style.display='none'; 
 return; 
 } 
 const arr=Store.getState().arrays[s.arrayId]; 
 const val=els.direct.value.trim(); 
 const anchor={arrId:s.arrayId,...s.focus}; 
 
 if(val.startsWith('=')) { 
 Formula.setFormula(anchor, val);
 const tx = Write.start('user.directEdit','User direct formula edit');
 Formula.executeAt(anchor, undefined, tx);
 Write.commit(tx);
 } else { 
 const tx = Write.start('user.directValue','User direct value edit');
 Write.set(tx, s.arrayId, s.focus, { value: val, formula: null });
 Write.commit(tx);
 } 
 
 els.direct.style.display='none';
 if(document.activeElement === els.direct){
 try{ els.direct.blur(); }catch{}
 }
 els.direct._closedAt = Date.now(); // Track when editor was closed to prevent rapid re-open
 els.fx.value = ''; // Clear formula box
 updateFocusChip(); // Refresh UI
 }
 // Global escapes: Enter (when editor focused) commits then hides; Escape cancels and hides; clicking outside hides
 document.addEventListener('keydown',(e)=>{
 const edit=els.direct; if(edit.style.display!=='block') return;
 if(e.key==='Enter'){ e.preventDefault(); e.stopPropagation(); commitEditor(); }
 if(e.key==='Escape'){
 e.preventDefault(); e.stopPropagation();
 edit.style.display='none';
 if(document.activeElement === edit){
 try{ edit.blur(); }catch{}
 }
 edit._closedAt = Date.now();
 els.fx.value='';
 }
 }, true);
 // Hide editor on any sheet click when not double-clicking to re-open
 document.getElementById('sheet')?.addEventListener('mousedown',(e)=>{
 const edit=els.direct; 
 if(edit.style.display==='block'){
 const justOpened = (Date.now() - (edit._openedAt||0)) < 200;
 if(!justOpened){
 edit.style.display='none';
 if(document.activeElement === edit){
 try{ edit.blur(); }catch{}
 }
 edit._closedAt = Date.now();
 }
 }
 }, true);
 els.direct.addEventListener('input',()=>{ 
 els.fx.value = els.direct.value; 
 try{ els.fx.dispatchEvent(new Event('input')); }catch{} 
 updateAutocomplete(els.direct);
 try{ highlightFxRefs(els.direct.value); }catch{}
 });
 els.direct.addEventListener('keydown',e=>{ 
 if(autocompleteVisible){
 if(e.key === 'ArrowDown'){
 e.preventDefault();
 selectedSuggestion = Math.min(selectedSuggestion + 1, autocompleteDiv.children.length - 1);
 updateAutocompleteHighlight();
 return;
 }
 if(e.key === 'ArrowUp'){
 e.preventDefault();
 selectedSuggestion = Math.max(selectedSuggestion - 1, -1);
 updateAutocompleteHighlight();
 return;
 }
 if(e.key === 'Tab' || e.key === 'Enter'){
 e.preventDefault();
 const hadSelection = (selectedSuggestion >= 0);
 if(hadSelection){
 const allFunctions = mergeDocsAndComputeDeps();
 const context = getAutocompleteContext(e.target);
 if(context){
 const matches = allFunctions.filter(fn => 
 fn.name.toLowerCase().includes(context.partial.toLowerCase())
 );
 if(matches[selectedSuggestion]){
 applyAutocomplete(e.target, matches[selectedSuggestion]);
 }
 }
 // Do NOT commit if a suggestion was chosen; keep editor open
 hideAutocomplete();
 return;
 } else {
 // No suggestion selected: treat Enter/Tab normally
 hideAutocomplete();
 if(e.key === 'Enter') commitEditor();
 return;
 }
 }
 if(e.key === 'Escape'){
 e.preventDefault();
 hideAutocomplete();
 return;
 }
 } else {
 if(e.key==='Enter'){ e.preventDefault(); e.stopPropagation(); commitEditor(); return; }
 if(e.key==='Escape'){ e.preventDefault(); e.stopPropagation(); els.direct.style.display='none'; els.fx.value=''; return; }
 }
 });
 // Slide sheet to top when soft keyboard likely shows (touch-only, triggered from touch focus)
 function slideSheetTop(){
 if(!document.body.classList.contains('touch')) return;
 // Require that the last interaction was a touch to avoid desktop Enter key causing movement
 if(typeof lastPointerType!=='string' || lastPointerType!=='touch') return;
 const sheet=document.getElementById('sheet'); if(!sheet) return;
 // Only slide if not already pinned top
 if(sheet.dataset.pinnedTop==='1') return;
 sheet.style.transition='transform .35s ease, top .35s ease, bottom .35s ease';
 sheet.style.top='8px'; sheet.style.bottom='auto'; sheet.style.left='50%'; sheet.style.transform='translateX(-50%)';
 sheet.dataset.pinnedTop='1';
 }
 els.fx.addEventListener('focus', slideSheetTop);
 els.direct.addEventListener('focus', slideSheetTop);
 
 // Also handle Enter in the formula textbox
 // Autocomplete system
 let autocompleteDiv = null;
 let autocompleteVisible = false;
 let selectedSuggestion = -1;

 // Move mergeDocsAndComputeDeps to accessible scope
 function mergeDocsAndComputeDeps(){
 const docs=[
 {name:'GET_GLOBAL',tags:'GLOBAL',syntax:'=GET_GLOBAL("key")',params:'key: string identifier for global data',desc:'Retrieves value from global key-value store. Automatically tracks dependencies for reactive updates.'},
 {name:'SET_GLOBAL',tags:'GLOBAL',syntax:'=SET_GLOBAL("key", value)',params:'key: string identifier value: any data to store',desc:'Writes value to global store and triggers re-computation of all dependent cells.'},
 {name:'ON_EVENT',tags:'EVENTS',syntax:'=ON_EVENT("eventName", "actionFormula")',params:'eventName: string event identifier actionFormula: formula to execute when event fires',desc:'Registers an event listener that executes a formula when the specified event is fired.'},
 {name:'FIRE_EVENT',tags:'EVENTS',syntax:'=FIRE_EVENT("eventName"[, payload])',params:'eventName: string event identifier payload: optional data to pass to listeners',desc:'Broadcasts an event to all registered listeners, optionally passing payload data.'},
 {name:'ARRAY',tags:'DATA',syntax:'=ARRAY(source)',params:'source: dimensions (w,h,d[,fill]), "list"/value1,value2... (default), "set"/value1,value2... (clears area), "csv"/"1,2;3,4", or named block',desc:'Enhanced: defaults to list mode, adds set mode for clearing, supports explicit modes.'},
 {name:'GET',tags:'DATA',syntax:'=GET(refOrRange)',params:'refOrRange: single cell or range',desc:'Returns the current value(s) as a block.'},
 {name:'SET',tags:'DATA',syntax:'=SET(target, valueOrBlock[, overwrite])',params:'target: ref/range valueOrBlock: scalar/block overwrite: 0/1',desc:'Direct write helper with size/overwrite checks.'},
 {name:'TRANSPOSE',tags:'DATA',syntax:'=TRANSPOSE(input, planeFlag[, reverse])',params:'input: block planeFlag: 0=X?Y,1=X?Z,2=Y?Z reverse: 0/1',desc:'Swaps axes of a block and writes result at the anchor.'},
 {name:'OFFSET',tags:'NAVIGATION',syntax:'=OFFSET([baseRef], dx[, dy[, dz]])',params:'baseRef: optional reference cell (default: anchor) dx,dy,dz: relative offsets',desc:'Excel-style OFFSET: retrieves value from relative position without writing.'},
 {name:'IF',tags:'LOGIC',syntax:'=IF(condition, then[, else])',params:'condition: comparisons with refs/values then/else: value or call',desc:'Branching evaluation with proper dependency capture.'},
 {name:'AND',tags:'LOGIC',syntax:'=AND(a,b[, ...])',params:'booleans/scalars (coerced)',desc:'Logical AND.'},
 {name:'OR',tags:'LOGIC',syntax:'=OR(a,b[, ...])',params:'booleans/scalars (coerced)',desc:'Logical OR.'},
 {name:'ADD',tags:'MATH',syntax:'=ADD(a[, b[, ...]])',params:'numbers or blocks (elementwise)',desc:'Sum (elementwise for blocks).'},
 {name:'MUL',tags:'MATH',syntax:'=MUL(a[, b[, ...]])',params:'numbers or blocks',desc:'Product (elementwise).'},
 {name:'CREATE',tags:'ACTION',syntax:'=CREATE(x,y,z[, "Name"[,"Id"]])',params:'dimensions (ints), optional nickname, optional explicit ID',desc:'Spawns a new array (respecting optional explicit id).'},
 {name:'DO',tags:'ACTION',syntax:'=DO(f1[, f2[, ...]]) or =DO{ stmt1; stmt2; } [WITH ...]',params:'strings like "=SET(...)" or brace blocks optional WITH atomic/on_error raw strings via `...` or <<<...>>>',desc:'Runs statements left-to-right, defaulting to per-step execution in blocks (set atomic:1 for one tx).'},
 {name:'SEQ',tags:'ACTION',syntax:'=SEQ(...)',params:'alias of DO()',desc:'Shorthand alias for DO that accepts the same string or block forms.'},
 {name:'PIPE',tags:'ACTION',syntax:'=PIPE(value, step1[, step2...])',params:'value: expression steps: formulas using _ placeholder (or auto-appended as last arg)',desc:'Composes nested formulas by threading the prior expression into each step before running once.'},
 {name:'SELF',tags:'NAVIGATION',syntax:'=SELF()',params:' ',desc:'Returns absolute @[x,y,z,arrId] of the host cell.'},
 {name:'DELETE',tags:'ACTION',syntax:'=DELETE(...targets)',params:'targets: array ids, refs, or "self"',desc:'Deletes arrays by id or ref; default self.'},
 {name:'COPY',tags:'ACTION IO',syntax:'=COPY(text)',params:'string text',desc:'Writes text to clipboard and shows a success toast.'},
 {name:'FOCUS_SET',tags:'ACTION',syntax:'=FOCUS_SET(content) or =FOCUS_SET(mode, content)',params:'mode: "text"|"formula"|"clipboard" content: data to set/copy',desc:'Writes to focused cell or copies to clipboard (with toast).'}
 ];
 const globalFn = (typeof window!=='undefined' && window.Fn) ? window.Fn : (typeof Fn!=='undefined'? Fn : {});
 const allNames = Object.keys(globalFn||{});
 const docsByName = new Map(docs.map(d => [d.name, {...d}]));
 allNames.forEach(name=>{
 const meta = globalFn[name] || {};
 if(!docsByName.has(name)){
 const tagsRaw = meta.tags;
 const tagsArr = Array.isArray(tagsRaw) ? tagsRaw : (tagsRaw instanceof Set ? Array.from(tagsRaw) : []);
 const tagStr = (tagsArr && tagsArr.length) ? tagsArr.join(',') : 'OTHER';
 docsByName.set(name, {name, tags: tagStr, syntax: meta.syntax || `=${name}()`, params: meta.params || '', desc: meta.desc || ''});
 }
 });
 return Array.from(docsByName.values()).sort((a,b)=> a.name.localeCompare(b.name));
 }
 
 function createAutocomplete(){
 if(autocompleteDiv) return autocompleteDiv;
 autocompleteDiv = document.createElement('div');
 autocompleteDiv.id = 'autocomplete';
 autocompleteDiv.style.cssText = `
 position: absolute; z-index: 10010; background: #ffffff; border: 1px solid #e5e7eb;
 border-radius: 8px; box-shadow: 0 8px 24px rgba(0,0,0,0.12); max-height: 200px;
 overflow-y: auto; display: none; font-family: 'Roboto Mono', monospace; font-size: 12px;
 `;
 document.body.appendChild(autocompleteDiv);
 return autocompleteDiv;
 }

 function showAutocomplete(input, suggestions){
 const div = createAutocomplete();
 if(suggestions.length === 0){ hideAutocomplete(); return; }
 
 div.innerHTML = suggestions.map((fn, idx) => 
 `<div class="ac-item" data-idx="${idx}" style="padding: 6px 10px; cursor: pointer; border-bottom: 1px solid #f3f4f6; ${idx === selectedSuggestion ? 'background: #f3f4f6;' : ''}">${fn.name}<span style="color: #6b7280; margin-left: 8px; font-size: 10px;">${fn.tags}</span></div>`
 ).join('');
 
 const rect = input.getBoundingClientRect();
 div.style.left = rect.left + 'px';
 div.style.top = (rect.bottom + 2) + 'px';
 div.style.width = Math.max(200, rect.width) + 'px';
 div.style.display = 'block';
 autocompleteVisible = true;
 
 // Click handlers
 div.querySelectorAll('.ac-item').forEach((item, idx) => {
 item.addEventListener('mouseenter', () => { selectedSuggestion = idx; updateAutocompleteHighlight(); });
 item.addEventListener('click', () => {
 applyAutocomplete(input, suggestions[idx]);
 hideAutocomplete();
 });
 });
 }

 function hideAutocomplete(){
 if(autocompleteDiv) autocompleteDiv.style.display = 'none';
 autocompleteVisible = false;
 selectedSuggestion = -1;
 }

 function applyAutocomplete(input, fn){
 const val = input.value;
 const pos = input.selectionStart || val.length;
 // Find the start of the current function name
 let start = pos;
 while(start > 0 && /[A-Z_0-9]/i.test(val[start-1])) start--;
 // Check if we're after = or ,
 let prefix = '';
 if(start > 0 && val[start-1] === '=') prefix = '=';
 else if(start > 0 && val[start-1] === ',') prefix = '';
 
 const before = val.slice(0, start);
 const after = val.slice(pos);
 const insert = `${fn.name}(`;
 input.value = before + insert + after;
 const newPos = before.length + insert.length;
 input.setSelectionRange(newPos, newPos);
 input.focus();
 }

 function getAutocompleteContext(input){
 const val = input.value;
 const pos = input.selectionStart || val.length;
 
 // Look backwards to find = or ,
 let i = pos - 1;
 let foundTrigger = false;
 let triggerPos = -1;
 
 while(i >= 0){
 const ch = val[i];
 if(ch === '=' || ch === ','){
 foundTrigger = true;
 triggerPos = i;
 break;
 } else if(ch === ')' || ch === '('){
 break; // Stop at function boundaries
 }
 i--;
 }
 
 if(!foundTrigger) return null;
 
 // Extract the partial function name after the trigger
 const afterTrigger = val.slice(triggerPos + 1, pos);
 const match = afterTrigger.match(/^\s*([A-Z_][A-Z0-9_]*)/i);
 if(!match) return null;
 
 return {
 trigger: val[triggerPos],
 partial: match[1],
 start: triggerPos + 1 + afterTrigger.indexOf(match[1]),
 end: pos
 };
 }

 function updateAutocomplete(input){
 const context = getAutocompleteContext(input);
 if(!context || context.partial.length < 1){
 hideAutocomplete();
 return;
 }
 
 const allFunctions = mergeDocsAndComputeDeps();
 const matches = allFunctions.filter(fn => 
 fn.name.toLowerCase().includes(context.partial.toLowerCase())
 ).slice(0, 8); // Limit to 8 suggestions
 
 if(matches.length > 0){
 showAutocomplete(input, matches);
 } else {
 hideAutocomplete();
 }
 }

 els.fx.addEventListener('input', (e) => {
 updateAutocomplete(e.target);
 try{ highlightFxRefs(els.fx.value); }catch{}
 });

 els.fx.addEventListener('keydown',e=>{ 
 if(autocompleteVisible){
 if(e.key === 'ArrowDown'){
 e.preventDefault();
 selectedSuggestion = Math.min(selectedSuggestion + 1, autocompleteDiv.children.length - 1);
 updateAutocompleteHighlight();
 return;
 }
 if(e.key === 'ArrowUp'){
 e.preventDefault();
 selectedSuggestion = Math.max(selectedSuggestion - 1, -1);
 updateAutocompleteHighlight();
 return;
 }
 if(e.key === 'Tab' || e.key === 'Enter'){
 e.preventDefault();
 const hadSelection = (selectedSuggestion >= 0);
 if(hadSelection){
 const allFunctions = mergeDocsAndComputeDeps();
 const context = getAutocompleteContext(e.target);
 if(context){
 const matches = allFunctions.filter(fn => 
 fn.name.toLowerCase().includes(context.partial.toLowerCase())
 );
 if(matches[selectedSuggestion]){
 applyAutocomplete(e.target, matches[selectedSuggestion]);
 }
 }
 hideAutocomplete();
 return;
 } else {
 hideAutocomplete();
 if(e.key === 'Enter') els.apply.click();
 return;
 }
 }
 if(e.key === 'Escape'){
 e.preventDefault();
 hideAutocomplete();
 return;
 }
 } else {
 if(e.key==='Enter'){ e.preventDefault(); e.stopPropagation(); els.apply.click(); els.fx.blur(); return; }
 if(e.key==='Escape'){ e.preventDefault(); e.stopPropagation(); els.fx.value=''; els.fx.blur(); return; }
 }
 });

 function updateAutocompleteHighlight(){
 if(!autocompleteDiv) return;
 autocompleteDiv.querySelectorAll('.ac-item').forEach((item, idx) => {
 item.style.background = (idx === selectedSuggestion) ? '#f3f4f6' : '';
 });
 }

 // Hide autocomplete when clicking outside
 document.addEventListener('click', (e) => {
 if(autocompleteVisible && !autocompleteDiv.contains(e.target) && e.target !== els.fx && e.target !== els.direct){
 hideAutocomplete();
 }
 });

 function updateStatus(t){ document.getElementById('statusChip').textContent=t; }

 // Lightweight A1 highlighter for fx bar: case-insensitive, bounds-validated against current array
 function highlightFxRefs(text){
 const fx = document.getElementById('fx');
 const hl = document.getElementById('fxHighlight');
 if(!fx || !hl) return;
 const s=Store.getState().selection; if(!s?.arrayId||!s.focus) { hl.innerHTML=''; return; }
 const arr=Store.getState().arrays[s.arrayId]; if(!arr){ hl.innerHTML=''; return; }
 const W=arr.size.x, H=arr.size.y, D=arr.size.z;
 const esc=(s)=> s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
 const tokens=[]; const re=/([A-Za-z]+\d+(?:[\u03b1-\u03c9])?\^?-?\d*)/g; let last=0, m;
 while((m=re.exec(text))){
 const raw=m[0]; const start=m.index; const end=start+raw.length; const before=esc(text.slice(last,start));
 tokens.push(before);
 // validate as cell address (case-insensitive letters+digits, optional greek)
 const mm=/^([A-Za-z]+)(\d+)([\u03b1-\u03c9])?/.exec(raw);
 let good=false;
 if(mm){
 // convert letters to X
 let xx=0; const letters=mm[1].toUpperCase(); for(let i=0;i<letters.length;i++) xx = xx*26 + (letters.charCodeAt(i)-64); xx--;
const yy=(+mm[2])-1; const G='αβγδεζηθικλμνξοπρστυφχψω'; const zz=mm[3]? G.indexOf(mm[3]) : s.focus.z;
 good = (xx>=0&&xx<W && yy>=0&&yy<H && zz>=0&&zz<D);
 }
 const cls = good? 'ref-ok' : 'ref-bad';
 tokens.push(`<span class="${cls}">${esc(raw)}</span>`);
 last=end;
 }
 tokens.push(esc(text.slice(last)));
 hl.innerHTML = tokens.join('');
 }

 function startDirectTyping(char){
 const s=Store.getState().selection; if(!s.focus) return;
 const edit=els.direct;
 // If editor is already open, insert at caret instead of resetting
 if(edit.style.display==='block'){
 const start=edit.selectionStart ?? edit.value.length;
 const end=edit.selectionEnd ?? start;
 const before=edit.value.slice(0,start);
 const after=edit.value.slice(end);
 edit.value = before + char + after;
 const pos = before.length + char.length;
 edit.setSelectionRange(pos,pos);
 els.fx.value = edit.value; // realtime sync
 edit.focus();
 return;
 }
 // Otherwise, open with initial char
 openEditor(char);
 }

 function startIntroExperience(){
 console.log('UI.startIntroExperience: begin');
 // Make absolutely sure the overlay fades via CSS
 const io=document.getElementById('introOverlay');
 if(io){ io.classList.add('hidden'); }
 // Force class-based collapse and also apply inline fallback for stubborn cases
 // Brief expansion to pass-through layer then collapse to corner to reveal 3D
 try{
 const sheet=document.getElementById('sheet');
 // Animate the header card wipe behind, then collapse without sheet bounce
 const header=document.getElementById('sheetHeaderCard');
 if(header){
 const r=sheet.getBoundingClientRect();
 header.style.left = r.left + 'px';
 header.style.top = (r.top - 10) + 'px';
 header.style.width = r.width + 'px';
 header.style.height = (r.height + 20) + 'px';
 header.classList.add('visible');
 requestAnimationFrame(()=>{ header.classList.add('wipe'); });
 setTimeout(()=>{ triggerIntroCollapse(); }, 280);
 setTimeout(()=>{ header.classList.remove('wipe'); header.classList.remove('visible'); }, 700);
 } else {
 // Fallback
 setTimeout(()=>{ triggerIntroCollapse(); }, 200);
 }
 }catch{}
 if(false){
 const sheet=document.getElementById('sheet');
 if(sheet){
 sheet.classList.remove('intro-max');
 sheet.classList.remove('intro-centered');
 sheet.style.top='';
 sheet.style.left='16px';
 sheet.style.bottom='16px';
 sheet.style.transform='';
 console.log('UI.startIntroExperience: inline collapse applied');
 }
 }
 // Hard fallback: after transition ensure overlay is non-interactive
 setTimeout(()=>{
 const io2=document.getElementById('introOverlay');
 if(io2){ io2.style.pointerEvents='none'; io2.style.opacity='0'; io2.style.display='none'; }
 }, 900);
 showToast('Welcome to celli.os!');
 }

 function ensureIntroNote(){
 try{
 const arr = Store.getState().arrays[1]; if(!arr) return;
 const coord = {x:0,y:2,z:0};
 // Ensure chunk exists
 const chKey0 = keyChunk(...Object.values(chunkOf(coord.x,coord.y,coord.z)));
 let ch0 = arr.chunks[chKey0];
 if(!ch0){ Actions.resizeArrayIfNeeded(arr, coord); ch0 = arr.chunks[chKey0]; }
 let cell = ch0?.cells?.find?.(c=>c.x===coord.x&&c.y===coord.y&&c.z===coord.z);
 if(!cell){
 console.log('Intro NOTE not found; creating cell ');
 Actions.setCell(arr.id, coord, '', null, true);
 const ch1 = arr.chunks[chKey0];
 cell = ch1?.cells?.find?.(c=>c.x===coord.x&&c.y===coord.y&&c.z===coord.z);
 }
 if(!cell){ console.warn('ensureIntroNote: creation failed'); return; }
 // Always set NOTE metadata and on_click to ensure visibility and binding
 const tx = Write.start('intro.note','Ensure A3 NOTE');
 try{
 const meta = normalizeMetaKeys(cell.meta||{});
 const existingAction = getMetaAction(meta, 'on_click');
 meta.noteText = 'Click Me!';
 meta.on_click = existingAction || '=STARTINTROEXPERIENCE()';
 Write.set(tx, arr.id, coord, {
 value: cell.value ?? '',
 formula: cell.formula ?? null,
 meta
 });
 }catch(e){
 // If array 1 is not yet available at write-time, queue for later
 const S=Store.getState();
 const pending=[...(S.pendingMeta||[])];
 pending.push({kind:'note', target:{arrId:1,x:coord.x,y:coord.y,z:coord.z}, meta:{noteText:'Click Me!', on_click:'=STARTINTROEXPERIENCE()'}});
 Store.setState({pendingMeta:pending});
 }
 Write.commit(tx);
 console.log('ensureIntroNote: meta enforced at A3 or queued');
 // Re-render sheet to bind tooltip and on_click reliably
 try{ UI.renderSheet?.(); }catch{}
 }catch(err){ console.warn('ensureIntroNote failed', err); }
 }

 return {init, renderSheet, applyCrystalStyle, renderSheetCell, updateFocusChip, scrollSheetToSelection, openEditor, startDirectTyping, toggleFxPanel, getZLayer, shiftZLayer, syncPresentUI, syncOceanSettings, updateStatus, getCell, triggerIntroCollapse, ensureIntroNote, hideIntroOverlay, debugIntroState, kickIntroSequence, startIntroExperience, inspect:(arr,pos)=>{ try{ const ch=arr.chunks[keyChunk(...Object.values(chunkOf(pos.x,pos.y,pos.z)))]; const c=ch?.cells?.find?.(t=>t.x===pos.x&&t.y===pos.y&&t.z===pos.z) || {value:'',formula:''}; const el=document.getElementById('inspect'); if(el) el.textContent=`Array #${arr.id} \"${arr.name}\"\nCell ${A1(pos.x)}${pos.y+1}${greek(pos.z)} @[${pos.x},${pos.y},${pos.z},${arr.id}]\nValue: ${JSON.stringify(c.value)}\nFormula: ${c.formula||''}`; }catch(e){ /* selection panel might be hidden */ } }};
})();

// CRITICAL: Expose UI globally so window.UI?.renderSheetCell works
window.UI = UI;

/* ===========================
 Immediate Launch (No Boot Delay)
=========================== */
(async ()=>{
 try {
 console.log('Starting immediate initialization...');
 const restoreDebug = readPersistedPhysicsDebug();

 // Load state if present; otherwise fresh init
 try {
 const has = localStorage.getItem('celliOsState');
 if (has) {
 await Scene.init(document.getElementById('view'));
 if(restoreDebug){ try{ Scene.setPhysicsDebugAll?.(true); }catch(e){ console.warn('Restore physics debug (pre-load) failed', e); } }
 await Store.getState().actions.loadState();
 if(restoreDebug){ try{ Scene.setPhysicsDebugAll?.(true); }catch(e){ console.warn('Restore physics debug (post-load) failed', e); } }
 try{ UI.init?.(); UI.renderSheet?.(); }catch{}
 } else {
 await Store.getState().actions.init();
 if(restoreDebug){ try{ Scene.setPhysicsDebugAll?.(true); }catch(e){ console.warn('Restore physics debug (fresh init) failed', e); } }
 }
 } catch {
 await Store.getState().actions.init();
 if(restoreDebug){ try{ Scene.setPhysicsDebugAll?.(true); }catch(e){ console.warn('Restore physics debug (fallback init) failed', e); } }
 }

 console.log('Initialization complete');
 } catch(e) {
 console.error('Initialization failed:', e);
 }
})();
 </script>
 
 <!-- Screen Recorder - Universal Support -->
 <script src="https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.js"></script>
 <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
 <script src="../../src/scripts/tools/recorder-standalone.js"></script>
 
 </body>
 </html>
