<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Celli Beta Focus</title>
  <script type="module" src="../../src/scripts/systems/PuzzleStateManager.js"></script>
  <style>
    :root {
      color-scheme: only dark;
      --page-bg: #000;
      --page-fg: #fff;
      --panel-bg: #000;
      --panel-border: #fff;
      --panel-box-shadow: 6px 6px 0 #fff, 0 0 0 10px #000, 0 0 38px rgba(255, 255, 255, 0.16);
      --panel-stripe: #fff;
      --option-bg: #050505;
      --option-fg: #fff;
      --option-border: #fff;
      --option-hover-bg: #fff;
      --option-hover-fg: #000;
      --submit-border: #fff;
      --submit-bg: #fff;
      --submit-fg: #000;
      --submit-hover-bg: transparent;
      --submit-hover-fg: #fff;
      --status-fg: #c8c8c8;
      --start-disabled-bg: rgba(255, 255, 255, 0.08);
      --start-disabled-fg: rgba(255, 255, 255, 0.38);
      --start-disabled-border: rgba(255, 255, 255, 0.18);
      --wordle-queue-bg: rgba(0, 0, 0, 0.65);
      --wordle-queue-border: rgba(255, 255, 255, 0.35);
      --wordle-queue-text: var(--option-fg);
      --wordle-queue-empty-shadow: inset -4px -4px 0 rgba(255, 255, 255, 0.12);
      --wordle-queue-filled-bg: rgba(255, 255, 255, 0.08);
      --wordle-queue-filled-shadow: inset -4px -4px 0 rgba(255, 255, 255, 0.18);
      --wordle-queue-active-border: var(--submit-border);
      --wordle-queue-solved-border: #2ec27e;
      --wordle-queue-solved-bg: rgba(46, 194, 126, 0.12);
      --wordle-queue-solved-text: #9ef5c6;
      --wordle-queue-solved-shadow: inset -4px -4px 0 rgba(46, 194, 126, 0.25);
      --wordle-surface-bg: #050505;
      --wordle-surface-border: var(--panel-border);
      --wordle-surface-shadow: 0 0 0 4px rgba(0, 0, 0, 0.85);
      --wordle-cell-bg: rgba(0, 0, 0, 0.82);
      --wordle-cell-border: rgba(255, 255, 255, 0.28);
      --wordle-cell-text: rgba(255, 255, 255, 0.95);
      --wordle-cell-shadow: inset -4px -4px 0 rgba(255, 255, 255, 0.08);
      --wordle-cell-filled-bg: rgba(255, 255, 255, 0.18);
      --wordle-cell-filled-border: rgba(255, 255, 255, 0.6);
      --wordle-cell-filled-shadow: inset -4px -4px 0 rgba(255, 255, 255, 0.2);
      --wordle-cell-correct-bg: #2846ff;
      --wordle-cell-correct-border: #9ab3ff;
      --wordle-cell-correct-fg: #f5f7ff;
      --wordle-cell-correct-shadow: inset -4px -4px 0 rgba(40, 70, 255, 0.35);
      --wordle-cell-present-bg: #ff9d1c;
      --wordle-cell-present-border: #ffd28a;
      --wordle-cell-present-fg: #2a1400;
      --wordle-cell-present-shadow: inset -4px -4px 0 rgba(255, 157, 28, 0.35);
      --wordle-cell-absent-bg: rgba(255, 255, 255, 0.08);
      --wordle-cell-absent-border: rgba(255, 255, 255, 0.18);
      --wordle-cell-absent-fg: rgba(255, 255, 255, 0.55);
      --wordle-cell-absent-shadow: inset -4px -4px 0 rgba(255, 255, 255, 0.12);
      --escape-border: #ff385b;
      --escape-bg: #ff1f47;
      --escape-fg: #fff;
      --escape-hover-bg: #fff;
      --escape-hover-fg: #ff1f47;
      --submission-bg: radial-gradient(circle at top, rgba(255, 255, 255, 0.08), rgba(0, 0, 0, 0.9));
      --submission-border: rgba(255, 255, 255, 0.14);
      --submission-shadow: inset 0 0 32px rgba(255, 255, 255, 0.08), 0 0 80px rgba(91, 123, 255, 0.22);
      --chip-border: #fff;
      --chip-bg: #050505;
      --chip-fg: #fff;
      --chip-shadow: 0 14px 28px rgba(0, 0, 0, 0.45);
      --tone-white-bg: #fff;
      --tone-white-fg: #000;
      --tone-white-border: #fff;
      --tone-white-shadow: 0 0 0 1px rgba(255, 255, 255, 0.45), 0 10px 26px rgba(255, 255, 255, 0.2);
      --tone-blue-bg: #2846ff;
      --tone-blue-fg: #f5f7ff;
      --tone-blue-border: #9ab3ff;
      --tone-blue-shadow: 0 0 0 1px rgba(154, 179, 255, 0.65), 0 12px 28px rgba(40, 70, 255, 0.32);
      --tone-yellow-bg: #ff9d1c;
      --tone-yellow-fg: #2a1400;
      --tone-yellow-border: #ffd28a;
      --tone-yellow-shadow: 0 0 0 1px rgba(255, 210, 138, 0.7), 0 12px 28px rgba(255, 157, 28, 0.32);
      --tone-magenta-bg: #ff185f;
      --tone-magenta-fg: #fff3f8;
      --tone-magenta-border: #ff7aa5;
      --tone-magenta-shadow: 0 0 0 1px rgba(255, 122, 165, 0.65), 0 12px 28px rgba(255, 24, 95, 0.32);
      --trifold-blue: #5e7bff;
      --trifold-gold: #ffd86b;
      --trifold-magenta: #ff5fa8;
      --trifold-highlight-shadow: 0 24px 48px rgba(22, 18, 52, 0.55);
      --trifold-blue-rgb: 94, 123, 255;
      --trifold-blue-deep-rgb: 38, 54, 152;
      --trifold-gold-rgb: 255, 216, 107;
      --trifold-gold-deep-rgb: 196, 141, 32;
      --trifold-magenta-rgb: 255, 95, 168;
      --trifold-magenta-deep-rgb: 176, 34, 88;
      --trifold-fold-highlight: rgba(255, 255, 255, 0.25);
    }

    body.inverted {
      color-scheme: only light;
      --page-bg: #fff;
      --page-fg: #000;
      --panel-bg: #fff;
      --panel-border: #000;
      --panel-box-shadow: 6px 6px 0 #000, 0 0 0 10px #fff, 0 0 38px rgba(0, 0, 0, 0.16);
      --panel-stripe: #000;
      --option-bg: #f7f7f7;
      --option-fg: #000;
      --option-border: #000;
      --option-hover-bg: #000;
      --option-hover-fg: #fff;
      --submit-border: #000;
      --submit-bg: #000;
      --submit-fg: #fff;
      --submit-hover-bg: transparent;
      --submit-hover-fg: #000;
      --status-fg: #454545;
      --start-disabled-bg: rgba(0, 0, 0, 0.08);
      --start-disabled-fg: rgba(0, 0, 0, 0.48);
      --start-disabled-border: rgba(0, 0, 0, 0.22);
      --wordle-queue-bg: rgba(255, 255, 255, 0.65);
      --wordle-queue-border: rgba(0, 0, 0, 0.35);
      --wordle-queue-text: var(--option-fg);
      --wordle-queue-empty-shadow: inset -4px -4px 0 rgba(0, 0, 0, 0.12);
      --wordle-queue-filled-bg: rgba(0, 0, 0, 0.08);
      --wordle-queue-filled-shadow: inset -4px -4px 0 rgba(0, 0, 0, 0.18);
      --wordle-queue-active-border: var(--submit-border);
      --wordle-queue-solved-border: #009e5a;
      --wordle-queue-solved-bg: rgba(0, 158, 90, 0.12);
      --wordle-queue-solved-text: #015c36;
      --wordle-queue-solved-shadow: inset -4px -4px 0 rgba(0, 158, 90, 0.18);
      --wordle-surface-bg: #fafafa;
      --wordle-surface-border: var(--panel-border);
      --wordle-surface-shadow: 0 0 0 4px rgba(0, 0, 0, 0.1);
      --wordle-cell-bg: rgba(0, 0, 0, 0.08);
      --wordle-cell-border: rgba(0, 0, 0, 0.35);
      --wordle-cell-text: #111;
      --wordle-cell-shadow: inset -4px -4px 0 rgba(0, 0, 0, 0.06);
      --wordle-cell-filled-bg: rgba(0, 0, 0, 0.18);
      --wordle-cell-filled-border: rgba(0, 0, 0, 0.65);
      --wordle-cell-filled-shadow: inset -4px -4px 0 rgba(0, 0, 0, 0.18);
      --wordle-cell-correct-bg: #2846ff;
      --wordle-cell-correct-border: #9ab3ff;
      --wordle-cell-correct-fg: #f5f7ff;
      --wordle-cell-correct-shadow: inset -4px -4px 0 rgba(40, 70, 255, 0.35);
      --wordle-cell-present-bg: #ff9d1c;
      --wordle-cell-present-border: #ffd28a;
      --wordle-cell-present-fg: #2a1400;
      --wordle-cell-present-shadow: inset -4px -4px 0 rgba(255, 157, 28, 0.35);
      --wordle-cell-absent-bg: rgba(0, 0, 0, 0.08);
      --wordle-cell-absent-border: rgba(0, 0, 0, 0.18);
      --wordle-cell-absent-fg: rgba(0, 0, 0, 0.55);
      --wordle-cell-absent-shadow: inset -4px -4px 0 rgba(0, 0, 0, 0.08);
      --escape-border: #ff385b;
      --escape-bg: #ff1f47;
      --escape-fg: #fff;
      --escape-hover-bg: #000;
      --escape-hover-fg: #ff1f47;
      --submission-bg: radial-gradient(circle at top, rgba(0, 0, 0, 0.08), rgba(255, 255, 255, 0.9));
      --submission-border: rgba(0, 0, 0, 0.16);
      --submission-shadow: inset 0 0 32px rgba(0, 0, 0, 0.06), 0 0 80px rgba(0, 210, 255, 0.2);
      --chip-border: #000;
      --chip-bg: #f7f7f7;
      --chip-fg: #000;
      --chip-shadow: 0 14px 28px rgba(0, 0, 0, 0.25);
      --tone-white-bg: #000;
      --tone-white-fg: #fff;
      --tone-white-border: #000;
      --tone-white-shadow: 0 0 0 1px rgba(0, 0, 0, 0.35), 0 12px 28px rgba(0, 0, 0, 0.25);
      --tone-blue-bg: #00d8ff;
      --tone-blue-fg: #002b38;
      --tone-blue-border: #5ef0ff;
      --tone-blue-shadow: 0 0 0 1px rgba(94, 240, 255, 0.6), 0 12px 28px rgba(0, 216, 255, 0.35);
      --tone-yellow-bg: #fffb3d;
      --tone-yellow-fg: #2b2600;
      --tone-yellow-border: #fffda0;
      --tone-yellow-shadow: 0 0 0 1px rgba(255, 253, 160, 0.65), 0 12px 28px rgba(255, 251, 61, 0.35);
      --tone-magenta-bg: #ff39ff;
      --tone-magenta-fg: #280028;
      --tone-magenta-border: #ff8cff;
      --tone-magenta-shadow: 0 0 0 1px rgba(255, 140, 255, 0.65), 0 12px 28px rgba(255, 57, 255, 0.35);
      --trifold-blue: #1e62ff;
      --trifold-gold: #f7b72d;
      --trifold-magenta: #ff3791;
      --trifold-highlight-shadow: 0 24px 48px rgba(14, 11, 28, 0.55);
      --trifold-blue-rgb: 30, 98, 255;
      --trifold-blue-deep-rgb: 16, 58, 176;
      --trifold-gold-rgb: 247, 183, 45;
      --trifold-gold-deep-rgb: 193, 127, 20;
      --trifold-magenta-rgb: 255, 55, 145;
      --trifold-magenta-deep-rgb: 178, 21, 92;
      --trifold-fold-highlight: rgba(255, 255, 255, 0.35);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      min-height: 100dvh;
      display: flex;
      align-items: stretch;
      justify-content: center;
      background: var(--page-bg);
      font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: var(--page-fg);
      letter-spacing: 0.08em;
      overflow-x: hidden;
      overflow-y: auto;
    }

    body.pre-form-scroll-lock {
      overflow: hidden;
      overscroll-behavior: contain;
      touch-action: none;
    }

    .pre-form-video-overlay--skippable {
      cursor: pointer;
    }

    .pre-form-video-overlay {
      position: fixed;
      inset: 0;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      flex-direction: column;
      gap: 1.5rem;
      outline: none;
      padding: 1.25rem;
    }

    .pre-form-trifold-button {
      position: fixed;
      top: clamp(1rem, 3vw, 1.75rem);
      right: clamp(1rem, 3vw, 1.75rem);
      width: 64px;
      height: 64px;
      border: none;
      background: transparent;
      padding: 0;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10002;
    }

    .pre-form-trifold-button::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(145deg,
          rgba(94, 123, 255, 0.25) 0%,
          rgba(255, 216, 107, 0.22) 52%,
          rgba(255, 95, 168, 0.25) 100%);
      border-radius: 12px;
      border: 2px solid rgba(255, 255, 255, 0.6);
      box-shadow: 0 18px 34px rgba(0, 0, 0, 0.35);
      transition: transform 360ms cubic-bezier(.2,.8,.2,1),
                  box-shadow 360ms cubic-bezier(.2,.8,.2,1),
                  border-color 360ms cubic-bezier(.2,.8,.2,1),
                  background 360ms cubic-bezier(.2,.8,.2,1);
    }

    .pre-form-trifold-button:hover::before,
    .pre-form-trifold-button.near::before,
    .pre-form-trifold-button:focus-visible::before {
      transform: scale(1.1);
      border-color: rgba(255, 255, 255, 0.8);
      background: linear-gradient(135deg,
          var(--trifold-blue) 0%,
          var(--trifold-gold) 50%,
          var(--trifold-magenta) 100%);
      box-shadow: var(--trifold-highlight-shadow),
                  0 0 32px rgba(94, 123, 255, 0.45),
                  0 0 42px rgba(255, 95, 168, 0.35);
    }

    .pre-form-trifold-button:focus-visible {
      outline: 3px solid #000;
      outline-offset: 4px;
      border-radius: 14px;
    }

    .pre-form-trifold-button__square {
      position: absolute;
      width: 6px;
      height: 6px;
      background: #111;
      border-radius: 1px;
      transition: background 360ms cubic-bezier(.2,.8,.2,1), 
                  transform 360ms cubic-bezier(.2,.8,.2,1),
                  left 360ms cubic-bezier(.2,.8,.2,1),
                  top 360ms cubic-bezier(.2,.8,.2,1);
    }

    .pre-form-trifold-button__triangle {
      position: absolute;
      width: 0;
      height: 0;
      border-left: 3px solid transparent;
      border-right: 3px solid transparent;
      border-top: 6px solid #111;
      transition: border-color 360ms cubic-bezier(.2,.8,.2,1),
                  border-width 360ms cubic-bezier(.2,.8,.2,1),
                  transform 360ms cubic-bezier(.2,.8,.2,1),
                  top 360ms cubic-bezier(.2,.8,.2,1),
                  left 360ms cubic-bezier(.2,.8,.2,1);
    }

    .pre-form-trifold-button__circle {
      position: absolute;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #111;
      box-shadow: none;
      transition: background 360ms cubic-bezier(.2,.8,.2,1),
                  transform 360ms cubic-bezier(.2,.8,.2,1),
                  bottom 360ms cubic-bezier(.2,.8,.2,1),
                  left 360ms cubic-bezier(.2,.8,.2,1);
    }

    /* Row 0: three squares (middle) */
    .pre-form-trifold-button__square:nth-of-type(1) { top: 10px; left: 22px; }
    .pre-form-trifold-button__square:nth-of-type(2) { top: 10px; left: 29px; }
    .pre-form-trifold-button__square:nth-of-type(3) { top: 10px; left: 36px; }
    
    /* Row 1: two squares (sides) */
    .pre-form-trifold-button__square:nth-of-type(4) { top: 17px; left: 15px; }
    .pre-form-trifold-button__square:nth-of-type(5) { top: 17px; left: 43px; }
    
    /* Row 2: two squares (middle-right) */
    .pre-form-trifold-button__square:nth-of-type(6) { top: 24px; left: 29px; }
    .pre-form-trifold-button__square:nth-of-type(7) { top: 24px; left: 36px; }
    
    /* Row 3: one square (middle) */
    .pre-form-trifold-button__square:nth-of-type(8) { top: 31px; left: 29px; }
    
    /* Row 4: triangle (middle) */
    .pre-form-trifold-button__triangle { top: 38px; left: 29px; }
    
    /* Row 5: circle (middle) */
    .pre-form-trifold-button__circle { bottom: 10px; left: 29px; }

    /* Hover/near: color changes */
    .pre-form-trifold-button:hover .pre-form-trifold-button__square,
    .pre-form-trifold-button.near .pre-form-trifold-button__square {
      background: var(--trifold-blue);
    }

    .pre-form-trifold-button:hover .pre-form-trifold-button__triangle,
    .pre-form-trifold-button.near .pre-form-trifold-button__triangle {
      border-top-color: var(--trifold-gold);
    }

    .pre-form-trifold-button:hover .pre-form-trifold-button__circle,
    .pre-form-trifold-button.near .pre-form-trifold-button__circle {
      background: var(--trifold-magenta);
    }

    /* Hover/near: collapse all squares to top-center position and scale up */
    .pre-form-trifold-button:hover .pre-form-trifold-button__square,
    .pre-form-trifold-button.near .pre-form-trifold-button__square {
      left: 29px !important;
      top: 10px !important;
      transform: scale(1.6);
    }

    /* Hover/near: reposition, rotate 180deg, and scale up triangle to middle */
    .pre-form-trifold-button:hover .pre-form-trifold-button__triangle,
    .pre-form-trifold-button.near .pre-form-trifold-button__triangle {
      border-left-width: 5px;
      border-right-width: 5px;
      border-top-width: 10px;
      top: 28px !important;
      left: 29px !important;
      transform: scale(1.4) rotate(180deg);
    }

    /* Hover/near: reposition and scale up circle to bottom */
    .pre-form-trifold-button:hover .pre-form-trifold-button__circle,
    .pre-form-trifold-button.near .pre-form-trifold-button__circle {
      bottom: 10px !important;
      left: 29px !important;
      transform: scale(1.6);
    }

    .pre-form-chat-button {
      position: fixed;
      top: clamp(1rem, 3vw, 1.75rem);
      left: clamp(1rem, 3vw, 1.75rem);
      width: 64px;
      height: 64px;
      border: none;
      background: transparent;
      padding: 0;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10002;
      color: inherit;
    }

    .pre-form-chat-button::before {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: 12px;
      border: 2px solid rgba(255, 255, 255, 0.6);
      background: linear-gradient(145deg,
          rgba(17, 238, 255, 0.25) 0%,
          rgba(255, 255, 255, 0.16) 48%,
          rgba(255, 24, 95, 0.32) 100%);
      box-shadow: 0 18px 34px rgba(0, 0, 0, 0.35);
      transition: transform 360ms cubic-bezier(.2,.8,.2,1),
                  box-shadow 360ms cubic-bezier(.2,.8,.2,1),
                  border-color 360ms cubic-bezier(.2,.8,.2,1),
                  background 360ms cubic-bezier(.2,.8,.2,1);
    }

    .pre-form-chat-button:hover::before,
    .pre-form-chat-button:focus-visible::before,
    .pre-form-chat-button.near::before {
      transform: scale(1.1);
      border-color: rgba(255, 255, 255, 0.85);
      background: linear-gradient(135deg,
          rgba(17, 238, 255, 0.68) 0%,
          rgba(94, 123, 255, 0.82) 45%,
          rgba(255, 95, 168, 0.85) 100%);
      box-shadow: var(--trifold-highlight-shadow),
                  0 0 32px rgba(17, 238, 255, 0.45),
                  0 0 42px rgba(255, 95, 168, 0.45);
    }

    .pre-form-chat-button:focus-visible {
      outline: 3px solid #000;
      outline-offset: 4px;
      border-radius: 14px;
    }

    .pre-form-chat-button__bubble {
      position: relative;
      width: 36px;
      height: 28px;
      border-radius: 14px;
      background: rgba(255, 255, 255, 0.85);
      box-shadow: inset 0 0 0 2px rgba(0, 0, 0, 0.75),
                  0 8px 18px rgba(0, 0, 0, 0.45);
    }

    .pre-form-chat-button__bubble::before {
      content: '';
      position: absolute;
      bottom: -6px;
      right: 6px;
      width: 12px;
      height: 12px;
      border-radius: 4px;
      transform: rotate(45deg);
      background: rgba(255, 255, 255, 0.85);
      box-shadow: inset 0 0 0 2px rgba(0, 0, 0, 0.75);
    }

    .pre-form-chat-button__signal {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 3px;
      font-size: 10px;
      font-weight: 700;
      color: #000;
      letter-spacing: 0.12em;
    }

    .pre-form-chat-button__ping {
      width: 4px;
      height: 4px;
      border-radius: 50%;
      background: #111;
      animation: chat-ping 1.6s cubic-bezier(.2,.8,.2,1) infinite;
    }

    .pre-form-chat-button:hover .pre-form-chat-button__bubble,
    .pre-form-chat-button:focus-visible .pre-form-chat-button__bubble,
    .pre-form-chat-button.near .pre-form-chat-button__bubble {
      background: rgba(0, 0, 0, 0.9);
      box-shadow: inset 0 0 0 2px rgba(255, 255, 255, 0.75),
                  0 8px 18px rgba(17, 238, 255, 0.35);
    }

    .pre-form-chat-button:hover .pre-form-chat-button__bubble::before,
    .pre-form-chat-button:focus-visible .pre-form-chat-button__bubble::before,
    .pre-form-chat-button.near .pre-form-chat-button__bubble::before {
      background: rgba(0, 0, 0, 0.9);
      box-shadow: inset 0 0 0 2px rgba(255, 255, 255, 0.75);
    }

    .pre-form-chat-button:hover .pre-form-chat-button__signal,
    .pre-form-chat-button:focus-visible .pre-form-chat-button__signal,
    .pre-form-chat-button.near .pre-form-chat-button__signal {
      color: #fff;
    }

    .pre-form-trifold-panel {
      position: fixed;
      top: 50%;
      right: clamp(1.5rem, 6vw, 4rem);
      transform: translateY(-50%) scale(0.9);
      transform-origin: center right;
      background: transparent;
      display: none;
      border-radius: 0;
      box-shadow: 0 40px 120px rgba(0, 0, 0, 0.65);
      overflow: hidden;
      min-width: min(90vw, 420px);
      max-width: min(95vw, 460px);
      pointer-events: auto;
      z-index: 10001;
    }

    .pre-form-trifold-panel.is-open {
      display: block;
      animation: trifold-open 320ms ease forwards;
    }

    @keyframes trifold-open {
      0% {
        opacity: 0;
        transform: translateY(-50%) scale(0.7) rotateY(-18deg);
      }

      100% {
        opacity: 1;
        transform: translateY(-50%) scale(1);
      }
    }

    .pre-form-trifold-panel__content {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      position: relative;
      isolation: isolate;
    }

    .pre-form-trifold-panel__fold {
      padding: 1.5rem 1.25rem;
      display: flex;
      flex-direction: column;
      gap: 0.85rem;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.15em;
      color: #002b38;
      position: relative;
      z-index: 0;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.08), inset 0 -1px 0 rgba(0, 0, 0, 0.12);
    }

    .pre-form-trifold-panel__fold::before {
      content: '';
      position: absolute;
      inset: 0;
      background: radial-gradient(140% 120% at 14% 12%, var(--trifold-fold-highlight), transparent 58%);
      mix-blend-mode: screen;
      opacity: 0.9;
      pointer-events: none;
      z-index: 0;
    }

    .pre-form-trifold-panel__fold > * {
      position: relative;
      z-index: 1;
    }

    .pre-form-trifold-panel__fold--left {
      background:
        linear-gradient(135deg,
          rgba(var(--trifold-blue-rgb), 0.96),
          rgba(var(--trifold-blue-deep-rgb), 0.96));
      color: rgba(243, 248, 255, 0.98);
      box-shadow: inset 0 0 0 1px rgba(var(--trifold-blue-rgb), 0.28);
    }

    .pre-form-trifold-panel__fold--center {
      background:
        linear-gradient(135deg,
          rgba(var(--trifold-gold-rgb), 0.96),
          rgba(var(--trifold-gold-deep-rgb), 0.96));
      color: #2b2600;
      box-shadow: inset 0 0 0 1px rgba(var(--trifold-gold-rgb), 0.3);
    }

    .pre-form-trifold-panel__fold--right {
      background:
        linear-gradient(135deg,
          rgba(var(--trifold-magenta-rgb), 0.95),
          rgba(var(--trifold-magenta-deep-rgb), 0.95));
      color: rgba(255, 238, 245, 0.98);
      box-shadow: inset 0 0 0 1px rgba(var(--trifold-magenta-rgb), 0.28);
    }

    .pre-form-trifold-panel__heading {
      font-size: 0.68rem;
      letter-spacing: 0.28em;
      opacity: 0.8;
    }

    .pre-form-trifold-panel__links {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .pre-form-trifold-panel__link {
      display: inline-flex;
      align-items: center;
      gap: 0.45rem;
      text-decoration: none;
      font-weight: 600;
      font-size: 0.75rem;
      padding: 0.5rem 0.75rem;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.35);
      background: rgba(255, 255, 255, 0.18);
      color: inherit;
      text-transform: none;
      letter-spacing: 0.08em;
      cursor: default;
    }

    .pre-form-trifold-panel__link .pre-form-trifold-panel__link-label {
      text-transform: uppercase;
      letter-spacing: 0.22em;
      font-size: 0.68rem;
    }

    .pre-form-trifold-panel__link-note {
      font-size: 0.55rem;
      letter-spacing: 0.18em;
      opacity: 0.75;
    }

    .pre-form-trifold-panel__close {
      position: absolute;
      top: 0.75rem;
      right: 0.75rem;
      background: rgba(0, 0, 0, 0.38);
      color: #fff;
      border: 1px solid rgba(255, 255, 255, 0.45);
      border-radius: 0;
      width: 36px;
      height: 36px;
      display: grid;
      place-items: center;
      cursor: pointer;
      font-size: 1rem;
    }

    .pre-form-trifold-panel__close:focus-visible {
      outline: 2px solid #fff;
      outline-offset: 2px;
    }

    @media (max-width: 620px) {
      .pre-form-trifold-button {
        width: 54px;
        height: 54px;
        top: clamp(0.75rem, 5vw, 1.25rem);
        right: clamp(0.75rem, 5vw, 1.25rem);
      }

      .pre-form-chat-button {
        width: 54px;
        height: 54px;
        top: clamp(0.75rem, 5vw, 1.25rem);
        left: clamp(0.75rem, 5vw, 1.25rem);
      }

      .pre-form-trifold-button::before {
        border-radius: 10px;
      }

      .pre-form-trifold-button__square {
        width: 5px;
        height: 5px;
      }

      .pre-form-trifold-button__square:nth-of-type(1) { top: 9px; left: 19px; }
      .pre-form-trifold-button__square:nth-of-type(2) { top: 9px; left: 25px; }
      .pre-form-trifold-button__square:nth-of-type(3) { top: 9px; left: 31px; }
      .pre-form-trifold-button__square:nth-of-type(4) { top: 15px; left: 13px; }
      .pre-form-trifold-button__square:nth-of-type(5) { top: 15px; left: 37px; }
      .pre-form-trifold-button__square:nth-of-type(6) { top: 21px; left: 25px; }
      .pre-form-trifold-button__square:nth-of-type(7) { top: 21px; left: 31px; }
      .pre-form-trifold-button__square:nth-of-type(8) { top: 27px; left: 25px; }

      .pre-form-trifold-button__triangle {
        border-left-width: 2.5px;
        border-right-width: 2.5px;
        border-top-width: 5px;
        top: 33px;
        left: 25px;
      }

      .pre-form-trifold-button__circle {
        width: 5px;
        height: 5px;
        bottom: 9px;
        left: 25px;
      }

      /* Mobile: collapse squares to center */
      .pre-form-trifold-button:hover .pre-form-trifold-button__square,
      .pre-form-trifold-button.near .pre-form-trifold-button__square {
        left: 25px !important;
        top: 9px !important;
        transform: scale(1.5);
      }

      /* Mobile: adjust triangle position, size, and rotate on hover */
      .pre-form-trifold-button:hover .pre-form-trifold-button__triangle,
      .pre-form-trifold-button.near .pre-form-trifold-button__triangle {
        border-left-width: 4.5px;
        border-right-width: 4.5px;
        border-top-width: 9px;
        top: 24px !important;
        left: 25px !important;
        transform: scale(1.35) rotate(180deg);
      }

      /* Mobile: adjust circle position and size on hover */
      .pre-form-trifold-button:hover .pre-form-trifold-button__circle,
      .pre-form-trifold-button.near .pre-form-trifold-button__circle {
        bottom: 9px !important;
        left: 25px !important;
        transform: scale(1.5);
      }

      .pre-form-trifold-panel {
        right: 50%;
        transform: translate(50%, -50%) scale(0.9);
      }

      .pre-form-trifold-panel.is-open {
        transform: translate(50%, -50%) scale(1);
      }

      @keyframes trifold-open {
        0% {
          opacity: 0;
          transform: translate(50%, -50%) scale(0.72) rotateY(-18deg);
        }

        100% {
          opacity: 1;
          transform: translate(50%, -50%) scale(1);
        }
      }
    }

    .pre-form-chat-window {
      position: fixed;
      top: clamp(5rem, 16vh, 8rem);
      left: clamp(1rem, 4vw, 2.25rem);
      width: min(360px, calc(100vw - 2.5rem));
      max-height: min(70vh, 520px);
      background: rgba(5, 5, 5, 0.92);
      border: 1px solid rgba(255, 255, 255, 0.18);
      border-radius: 18px;
      box-shadow: 0 24px 48px rgba(0, 0, 0, 0.55), 0 0 42px rgba(17, 238, 255, 0.2);
      display: flex;
      flex-direction: column;
      gap: 0;
      overflow: hidden;
      opacity: 0;
      transform: translate3d(0, -12px, 0);
      pointer-events: none;
      transition: opacity 280ms cubic-bezier(.33,.01,.16,1),
                  transform 320ms cubic-bezier(.33,.01,.16,1),
                  box-shadow 320ms cubic-bezier(.33,.01,.16,1);
      z-index: 10003;
    }

    .pre-form-chat-window.is-open {
      opacity: 1;
      transform: translate3d(0, 0, 0);
      pointer-events: auto;
      box-shadow: 0 30px 64px rgba(0, 0, 0, 0.65), 0 0 58px rgba(17, 238, 255, 0.28);
    }

    .pre-form-chat-window__header {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.85rem 1rem;
      background: linear-gradient(135deg, rgba(17, 238, 255, 0.28) 0%, rgba(94, 123, 255, 0.24) 45%, rgba(255, 95, 168, 0.32) 100%);
      border-bottom: 1px solid rgba(255, 255, 255, 0.14);
      gap: 0.75rem;
    }

    .pre-form-chat-window__heading {
      margin: 0;
      font-size: 0.95rem;
      letter-spacing: 0.32em;
      font-weight: 700;
      text-transform: uppercase;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      white-space: nowrap;
    }

    .pre-form-chat-window__live {
      position: relative;
      display: inline-flex;
      align-items: center;
      padding: 0.05rem 0.55rem;
      border-radius: 999px;
      background: rgba(255, 24, 95, 0.35);
      color: #fff5f9;
      box-shadow: inset 0 0 0 1px rgba(255, 95, 168, 0.65), 0 0 16px rgba(255, 24, 95, 0.45);
      overflow: hidden;
    }

    .pre-form-chat-window__live::after {
      content: '';
      position: absolute;
      left: 12%;
      right: 100%;
      top: 50%;
      height: 2px;
      background: linear-gradient(90deg, rgba(255, 24, 95, 0) 0%, rgba(255, 24, 95, 0.8) 45%, rgba(255, 255, 255, 0.9) 100%);
      transform: translateY(-50%) scaleX(0);
      transform-origin: left;
      opacity: 0;
    }

    .pre-form-chat-window__live.is-struck::after {
      animation: live-strike 960ms cubic-bezier(.66,.01,.27,1) forwards;
    }

    .pre-form-chat-window__close {
      border: none;
      background: rgba(0, 0, 0, 0.35);
      color: rgba(255, 255, 255, 0.86);
      border-radius: 999px;
      width: 32px;
      height: 32px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 1.25rem;
      cursor: pointer;
      transition: background 220ms ease, color 220ms ease;
    }

    .pre-form-chat-window__close:hover,
    .pre-form-chat-window__close:focus-visible {
      background: rgba(255, 255, 255, 0.85);
      color: #050505;
      outline: none;
    }

    .pre-form-chat-window__status {
      padding: 1rem;
      font-size: 0.9rem;
      letter-spacing: 0.22em;
      text-transform: uppercase;
      display: flex;
      align-items: center;
      gap: 0.35rem;
      color: rgba(255, 255, 255, 0.72);
      min-height: 52px;
    }

    .pre-form-chat-window__status[hidden] {
      display: none;
    }

    .pre-form-chat-window__status-label {
      white-space: nowrap;
    }

    .pre-form-chat-window__ellipsis {
      min-width: 2.25ch;
      text-align: left;
    }

    .pre-form-chat-window__scroller {
      flex: 1 1 auto;
      overflow-y: auto;
      padding: 0.75rem 1rem 1.1rem;
      display: flex;
      flex-direction: column;
      gap: 0.85rem;
      scroll-behavior: smooth;
      position: relative;
    }

    .pre-form-chat-window__scroller[aria-hidden="true"] {
      display: none;
    }

    .pre-form-chat-window__messages {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .pre-form-chat-window__message {
      background: rgba(255, 255, 255, 0.06);
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      padding: 0.85rem 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.45);
    }

    .pre-form-chat-window__message-text {
      margin: 0;
      font-size: 0.95rem;
      line-height: 1.5;
      letter-spacing: 0.04em;
    }

    .pre-form-chat-window__meta {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 0.5rem;
      font-family: 'Space Mono', 'IBM Plex Mono', Consolas, monospace;
      font-size: 0.75rem;
      letter-spacing: 0.32em;
      text-transform: uppercase;
      color: rgba(0, 255, 255, 0.72);
    }

    .pre-form-chat-window__timestamp {
      position: relative;
      padding: 0.1rem 0;
      text-shadow: 0 0 12px rgba(17, 238, 255, 0.75), 0 0 18px rgba(255, 24, 95, 0.35);
      filter: drop-shadow(0 0 8px rgba(17, 238, 255, 0.35));
    }

    .pre-form-chat-window__timestamp::after {
      content: '';
      position: absolute;
      left: -6px;
      right: -6px;
      top: 50%;
      height: 1px;
      background: linear-gradient(90deg, rgba(17, 238, 255, 0.6) 0%, rgba(255, 95, 168, 0.4) 100%);
      opacity: 0.25;
      transform: translateY(-50%);
    }

    .pre-form-chat-window__timestamp.is-solid {
      color: rgba(255, 255, 255, 0.68);
      text-shadow: 0 0 8px rgba(255, 255, 255, 0.25);
    }

    .pre-form-chat-window__footer-glow {
      position: absolute;
      inset: auto -20% -12%;
      height: 64px;
      pointer-events: none;
      background: radial-gradient(circle at 50% 0%, rgba(17, 238, 255, 0.28) 0%, rgba(17, 238, 255, 0.04) 60%, rgba(17, 238, 255, 0) 100%);
      filter: blur(18px);
    }

    @keyframes chat-ping {
      0%, 100% { transform: scale(1); opacity: 1; }
      40% { transform: scale(1.6); opacity: 0.2; }
      60% { transform: scale(0.9); opacity: 0.5; }
    }

    @keyframes live-strike {
      0% { right: 100%; opacity: 0; transform: translateY(-50%) scaleX(0); }
      25% { right: 35%; opacity: 0.9; transform: translateY(-50%) scaleX(0.75); }
      50% { right: -10%; opacity: 1; transform: translateY(-50%) scaleX(1.25); }
      70% { right: 0%; opacity: 0.85; transform: translateY(-50%) scaleX(0.95); }
      100% { right: 0%; opacity: 0.45; transform: translateY(-50%) scaleX(1); }
    }

    @media (max-width: 768px) {
      .pre-form-chat-window {
        width: min(320px, calc(100vw - 2rem));
        top: clamp(4.5rem, 20vh, 7rem);
      }
    }

    @media (prefers-reduced-motion: reduce) {
      .pre-form-chat-button,
      .pre-form-chat-button::before,
      .pre-form-chat-window,
      .pre-form-chat-window__close {
        transition: none;
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
      }

      .pre-form-chat-window__live::after {
        animation-duration: 0.01ms !important;
      }
    }

    .pre-form-video-overlay video {
      width: auto;
      height: auto;
      max-width: 100vw;
      max-height: 100vh;
      background: #000;
      border: none;
      box-shadow: none;
      border-radius: 8px;
      position: relative;
    }
    
    /* Video glitch effect container */
    .video-glitch-wrapper {
      position: relative;
      display: inline-block;
      z-index: 2;
    }
    
    .video-glitch-wrapper::before,
    .video-glitch-wrapper::after {
      content: '';
      position: absolute;
      inset: 0;
      pointer-events: none;
      border-radius: 8px;
    }
    
    /* Glitch Style 1: CRT Scan Lines */
    .video-glitch-wrapper.glitch-crt::before {
      background: repeating-linear-gradient(
        0deg,
        rgba(0, 0, 0, 0.15) 0px,
        transparent 1px,
        transparent 2px,
        rgba(0, 0, 0, 0.15) 3px
      );
      animation: crtScanLines 8s linear infinite;
      z-index: 3;
    }
    
    /* Glitch Style 2: RGB Shift */
    .video-glitch-wrapper.glitch-rgb::after {
      background: linear-gradient(90deg, 
        rgba(255, 0, 0, 0.1) 0%,
        transparent 33%,
        rgba(0, 255, 0, 0.1) 66%,
        rgba(0, 0, 255, 0.1) 100%
      );
      animation: rgbShift 4s ease-in-out infinite;
      mix-blend-mode: screen;
      z-index: 3;
    }
    
    @keyframes rgbShift {
      0%, 100% {
        transform: translateX(0);
        opacity: 0.3;
      }
      25% {
        transform: translateX(2px);
        opacity: 0.5;
      }
      50% {
        transform: translateX(-2px);
        opacity: 0.4;
      }
      75% {
        transform: translateX(1px);
        opacity: 0.6;
      }
    }
    
    /* Glitch Style 3: VHS Tracking */
    .video-glitch-wrapper.glitch-vhs::before {
      background: repeating-linear-gradient(
        90deg,
        transparent 0px,
        rgba(255, 255, 255, 0.03) 1px,
        transparent 2px
      );
      animation: vhsTracking 6s linear infinite;
      z-index: 3;
    }
    
    @keyframes vhsTracking {
      0% {
        transform: translateY(0) scaleY(1);
      }
      10% {
        transform: translateY(-2px) scaleY(1.01);
      }
      20% {
        transform: translateY(0) scaleY(1);
      }
      30% {
        transform: translateY(1px) scaleY(0.99);
      }
      100% {
        transform: translateY(0) scaleY(1);
      }
    }
    
    /* Glitch Style 4: TV Static */
    .video-glitch-wrapper.glitch-static::after {
      background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200"><filter id="noise"><feTurbulence baseFrequency="0.9" /></filter><rect width="200" height="200" filter="url(%23noise)" opacity="0.4"/></svg>');
      background-size: 100px 100px;
      animation: staticNoise 0.5s infinite, crtStatic 0.5s infinite;
      mix-blend-mode: overlay;
      z-index: 3;
    }
    
    @keyframes staticNoise {
      0% {
        background-position: 0 0;
      }
      100% {
        background-position: 100px 100px;
      }
    }
    
    /* Glitch Style 5: Color Test Bars */
    .video-glitch-wrapper.glitch-colorbars::before {
      background: linear-gradient(
        90deg,
        rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.1) 14.28%,
        rgba(255, 255, 0, 0.08) 14.28%, rgba(255, 255, 0, 0.08) 28.56%,
        rgba(0, 255, 255, 0.08) 28.56%, rgba(0, 255, 255, 0.08) 42.84%,
        rgba(0, 255, 0, 0.08) 42.84%, rgba(0, 255, 0, 0.08) 57.12%,
        rgba(255, 0, 255, 0.08) 57.12%, rgba(255, 0, 255, 0.08) 71.4%,
        rgba(255, 0, 0, 0.08) 71.4%, rgba(255, 0, 0, 0.08) 85.68%,
        rgba(0, 0, 255, 0.08) 85.68%, rgba(0, 0, 255, 0.08) 100%
      );
      animation: colorBars 12s ease-in-out infinite;
      mix-blend-mode: screen;
      z-index: 3;
    }
    
    /* Glitch Style 6: Phosphor Trails */
    .video-glitch-wrapper.glitch-phosphor::after {
      background: radial-gradient(
        ellipse at center,
        rgba(0, 255, 100, 0.15) 0%,
        transparent 60%
      );
      animation: phosphorGlow 3s ease-in-out infinite;
      mix-blend-mode: screen;
      z-index: 3;
    }
    
    @keyframes phosphorGlow {
      0%, 100% {
        opacity: 0.3;
        transform: scale(1);
      }
      50% {
        opacity: 0.6;
        transform: scale(1.05);
      }
    }

    .pre-form-video-overlay__message {
      color: #f5f7ff;
      font-size: 0.9rem;
      letter-spacing: 0.22em;
      text-transform: uppercase;
      opacity: 0.85;
      text-align: center;
    }

    .pre-form-video-overlay__skip-hint {
      color: #c7d1ff;
      font-size: 0.75rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      opacity: 0.75;
      text-align: center;
    }

    .pre-form-video-overlay__skip-hint[hidden] {
      display: none !important;
    }

    .pre-form-video-overlay__start {
      padding: 0.75rem 1.85rem;
      border: 2px solid rgba(255, 255, 255, 0.75);
      background: rgba(0, 0, 0, 0.65);
      color: #fff;
      text-transform: uppercase;
      letter-spacing: 0.28em;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
    }

    .pre-form-video-overlay__start:hover,
    .pre-form-video-overlay__start:focus-visible {
      background: rgba(255, 255, 255, 0.92);
      color: #000;
      border-color: rgba(255, 255, 255, 0.92);
      outline: none;
    }

    main {
      position: relative;
      display: grid;
      gap: clamp(1.5rem, 4vw, 2.4rem);
      width: min(620px, 94vw);
      height: 100vh;
      height: 100dvh;
      max-height: 100dvh;
    }

    .form-panel {
      position: relative;
      padding: clamp(2.5rem, 6vw, 3.5rem) clamp(1.5rem, 6vw, 3rem) clamp(2.25rem, 6vw, 3.25rem);
      border: 4px solid var(--panel-border);
      background: var(--panel-bg);
      display: grid;
      gap: clamp(1.5rem, 4vw, 2rem);
      box-shadow: var(--panel-box-shadow);
      transition: transform 0.18s ease, opacity 0.25s ease, filter 0.25s ease;
      height: 100%;
      max-height: 100%;
      grid-template-rows: minmax(0, 1fr) auto;
      overflow: hidden;
    }

    .focus-form {
      display: grid;
      gap: clamp(1.35rem, 4vw, 1.85rem);
      grid-template-rows: auto minmax(0, 1fr);
      min-height: 0;
    }

    .focus-frame {
      display: grid;
      gap: clamp(0.75rem, 2.6vw, 1.15rem);
    }

    .focus-frame--intake {
      justify-items: center;
      text-align: center;
      position: relative;
      padding-bottom: clamp(1.75rem, 4.5vw, 2.25rem);
      display: flex;
      flex-direction: column;
      justify-content: center;
      min-height: min-content;
    }

    .focus-frame--intake::after {
      content: "";
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 8px;
      background: var(--panel-stripe);
      opacity: 0.95;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    }

    body.inverted .focus-frame--intake::after {
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
    }

    .focus-frame--options {
      display: grid;
      gap: clamp(0.85rem, 2.8vw, 1.35rem);
      grid-template-rows: minmax(0, 1fr) auto;
      min-height: 0;
    }

    .focus-frame--wordle {
      display: grid;
      gap: clamp(0.9rem, 2.8vw, 1.45rem);
    }

    .wordle-selection-tiles {
      display: grid;
      gap: clamp(0.65rem, 2.4vw, 1.05rem);
      grid-template-columns: repeat(3, minmax(0, 1fr));
      grid-auto-rows: minmax(clamp(3.2rem, 8vw, 3.85rem), auto);
      width: 100%;
      align-items: stretch;
      justify-items: stretch;
      align-content: start;
    }

    .wordle-selection-tiles[hidden] {
      display: none;
    }

    .wordle-selection-tile {
      padding: clamp(0.55rem, 2vw, 0.85rem) clamp(0.5rem, 2vw, 0.95rem);
      font-size: clamp(0.7rem, 1.9vw, 0.95rem);
      letter-spacing: 0.16em;
      justify-content: center;
      text-align: center;
      color: var(--option-fg);
      border: 2px solid var(--option-border);
      background: var(--option-bg);
      font-weight: 600;
      text-transform: uppercase;
      border-radius: 0;
      box-shadow: inset -6px -6px 0 var(--option-border);
    }

    .wordle-selection-tile::before {
      border-radius: 0;
    }

    /* Apply tone class colors to wordle tiles */
    .wordle-selection-tile.tone-white {
      background: var(--tone-white-bg);
      color: var(--tone-white-fg);
      border-color: var(--tone-white-border);
      box-shadow: var(--tone-white-shadow);
    }

    .wordle-selection-tile.tone-blue {
      background: var(--tone-blue-bg);
      color: var(--tone-blue-fg);
      border-color: var(--tone-blue-border);
      box-shadow: var(--tone-blue-shadow);
    }

    .wordle-selection-tile.tone-yellow {
      background: var(--tone-yellow-bg);
      color: var(--tone-yellow-fg);
      border-color: var(--tone-yellow-border);
      box-shadow: var(--tone-yellow-shadow);
    }

    .wordle-selection-tile.tone-magenta {
      background: var(--tone-magenta-bg);
      color: var(--tone-magenta-fg);
      border-color: var(--tone-magenta-border);
      box-shadow: var(--tone-magenta-shadow);
    }

    .wordle-focus-queue {
      display: grid;
      grid-template-columns: repeat(5, minmax(0, 1fr));
      gap: clamp(0.35rem, 2.4vw, 0.65rem);
      width: 100%;
    }

    .wordle-focus-slot {
      border: 2px solid var(--wordle-queue-border);
      background: var(--wordle-queue-bg);
      color: var(--wordle-queue-text);
      text-transform: uppercase;
      letter-spacing: 0.14em;
      font-weight: 700;
      font-size: clamp(0.72rem, 3vw, 0.85rem);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0.6rem 0.45rem;
      min-height: clamp(2.4rem, 8vw, 3rem);
      text-overflow: ellipsis;
      white-space: nowrap;
      overflow: hidden;
      border-radius: 0;
      box-shadow: var(--wordle-queue-empty-shadow);
    }

    .wordle-focus-slot--filled {
      background: var(--wordle-queue-filled-bg);
      box-shadow: var(--wordle-queue-filled-shadow);
    }

    .wordle-focus-queue--active .wordle-focus-slot {
      border-color: var(--wordle-queue-active-border);
    }

    .wordle-focus-queue--solved .wordle-focus-slot {
      border-color: var(--wordle-queue-solved-border);
      background: var(--wordle-queue-solved-bg);
      color: var(--wordle-queue-solved-text);
      box-shadow: var(--wordle-queue-solved-shadow);
    }

    .form-panel.submitting {
      opacity: 0.85;
      filter: saturate(1.2);
    }

    .form-panel.submitted {
      opacity: 0.65;
      transform: scale(0.98);
      filter: saturate(1.2);
    }
    
    .form-panel.shake {
      animation: panel-shake 0.22s cubic-bezier(0.36, 0.07, 0.19, 0.97);
    }
    
    @keyframes panel-shake {
      0%, 100% { transform: translateX(0); }
      20% { transform: translateX(-4px) rotate(-0.4deg); }
      40% { transform: translateX(4px) rotate(0.4deg); }
      60% { transform: translateX(-3px) rotate(-0.3deg); }
      80% { transform: translateX(3px) rotate(0.3deg); }
    }

    /* Keep original focus options visible as visualizer bars when submitted */
    .form-panel.submitted .focus-frame--intake .prompt {
      display: none;
    }
    
    .form-panel.submitted .focus-frame--intake h1 {
      display: none;
    }

    /* Hide wordle focus queue preview */
    .wordle-focus-queue {
      display: none !important;
    }

    /* Ensure consistent text styling for submission chips */
    .selection-chip {
      color: var(--option-fg);
      border: 2px solid var(--option-border);
      background: var(--option-bg);
      padding: clamp(0.65rem, 2vw, 0.85rem) clamp(1rem, 3vw, 1.35rem);
      border-radius: 0;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      font-size: clamp(0.82rem, 2.2vw, 0.95rem);
      position: relative;
      overflow: hidden;
      box-shadow: inset -6px -6px 0 var(--option-border);
      cursor: default;
      opacity: 0;
      transform: translateY(8px) scale(0.96);
      animation: chip-emerge 0.45s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
      animation-delay: var(--chip-delay, 0s);
    }

    @keyframes chip-emerge {
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    /* Apply tone class colors to chips */
    .selection-chip.tone-white {
      background: var(--tone-white-bg);
      color: var(--tone-white-fg);
      border-color: var(--tone-white-border);
      box-shadow: var(--tone-white-shadow);
    }

    .selection-chip.tone-blue {
      background: var(--tone-blue-bg);
      color: var(--tone-blue-fg);
      border-color: var(--tone-blue-border);
      box-shadow: var(--tone-blue-shadow);
    }

    .selection-chip.tone-yellow {
      background: var(--tone-yellow-bg);
      color: var(--tone-yellow-fg);
      border-color: var(--tone-yellow-border);
      box-shadow: var(--tone-yellow-shadow);
    }

    .selection-chip.tone-magenta {
      background: var(--tone-magenta-bg);
      color: var(--tone-magenta-fg);
      border-color: var(--tone-magenta-border);
      box-shadow: var(--tone-magenta-shadow);
    }

    .focus-form.focus-form--hidden {
      visibility: hidden;
      pointer-events: none;
    }

    .esrb-card-overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: flex-start;
      justify-content: center;
      padding-top: clamp(3rem, 12vh, 8rem);
      background: var(--panel-bg);
      color: var(--page-fg);
      z-index: 10;
      opacity: 0;
      transform: scale(0.96);
      transition: opacity 0.4s ease, transform 0.4s ease;
    }

    .esrb-card-overlay.visible {
      opacity: 1;
      transform: scale(1);
    }

    .esrb-card-overlay.fade-out {
      opacity: 0;
      transform: scale(1.02);
    }

    .esrb-card {
      position: relative;
      display: grid;
      grid-template-rows: auto 1fr auto;
      align-items: stretch;
      justify-items: stretch;
      width: auto;
      height: 70vh;
      max-width: min(75vw, 550px);
      aspect-ratio: 2 / 3;
      background: #fff;
      color: #000;
      border: 12px solid currentColor;
      padding: clamp(1.4rem, 4vw, 2rem);
      text-transform: uppercase;
      box-shadow: 0 18px 48px rgba(0, 0, 0, 0.38);
      gap: clamp(0.9rem, 2.5vw, 1.3rem);
    }

    .esrb-card__banner {
      display: grid;
      justify-items: center;
      gap: clamp(0.35rem, 1.2vw, 0.6rem);
      font-size: clamp(1.2rem, 2.8vw, 1.75rem);
      letter-spacing: 0.24em;
    }

    .esrb-card__banner-text {
      font-weight: 700;
    }

    .esrb-card__strike {
      font-size: clamp(1rem, 2.2vw, 1.4rem);
      letter-spacing: 0.2em;
      text-decoration: line-through;
    }

    .esrb-card__body {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: clamp(1.2rem, 3.2vw, 1.8rem);
      align-items: center;
      border-block: 10px solid currentColor;
      padding: clamp(1.2rem, 3.5vw, 2rem) clamp(1rem, 2.8vw, 1.5rem);
    }

    .esrb-card__rating {
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: clamp(8rem, 22vw, 12rem);
      font-size: clamp(10rem, 35vh, 16rem);
      font-weight: 800;
      letter-spacing: -0.08em;
      line-height: 0.88;
    }

    .esrb-card__rating span {
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      line-height: 1;
      text-decoration: none !important;
    }

    .esrb-card__rating span::after {
      content: '';
      position: absolute;
      left: -8%;
      right: -8%;
      top: 50%;
      height: max(6px, 0.12em);
      background: currentColor;
      transform: translateY(-50%);
      border-radius: 999px;
    }

    .esrb-card__descriptor {
      margin: 0;
      align-self: center;
      display: flex;
      align-items: center;
      font-size: clamp(1rem, 2.2vw, 1.4rem);
      letter-spacing: 0.16em;
      line-height: 1.45;
    }

    .esrb-card__footer {
      text-align: center;
      font-size: clamp(1.1rem, 2.6vw, 1.65rem);
      letter-spacing: 0.3em;
    }

    @media (max-width: 520px) {
      .esrb-card {
        height: 65vh;
        max-width: min(82vw, 440px);
      }
    }

    .form-panel::before {
      content: "";
      position: absolute;
      inset: clamp(1.25rem, 4vw, 2rem) clamp(1.25rem, 4vw, 2rem) auto clamp(1.25rem, 4vw, 2rem);
      height: 6px;
      background: var(--panel-stripe);
    }

    h1 {
      margin: clamp(0.5rem, 1.5vw, 0.85rem) 0 clamp(0.75rem, 2vw, 1rem);
      font-size: clamp(1.15rem, 2.8vw, 1.7rem);
      text-transform: uppercase;
      text-align: center;
      line-height: 1.35;
      letter-spacing: 0.16em;
      font-weight: 700;
    }

    .prompt {
      margin: 0;
      text-align: center;
      font-size: clamp(0.88rem, 2.2vw, 1.05rem);
      text-transform: uppercase;
      line-height: 1.5;
      letter-spacing: 0.12em;
      max-width: 90%;
      margin-left: auto;
      margin-right: auto;
    }

    .options-shell {
      position: relative;
      display: grid;
      grid-template-rows: minmax(0, 1fr) auto;
      align-content: start;
      gap: clamp(0.75rem, 2.4vw, 1.05rem);
      padding: clamp(0.85rem, 2.8vw, 1.2rem) clamp(0.5rem, 2vw, 0.85rem) clamp(0.75rem, 2.4vw, 1.2rem);
      height: 100%;
      min-height: 0;
      overflow: hidden;
      pointer-events: auto;
    }


    .options {
      display: grid;
      gap: clamp(0.65rem, 2vw, 0.85rem);
      grid-template-columns: 1fr;
      grid-auto-rows: minmax(clamp(3.2rem, 6vh, 3.85rem), auto);
      align-items: stretch;
      justify-items: stretch;
      padding: clamp(0.65rem, 2vw, 0.85rem);
      padding-right: clamp(0.35rem, 1.2vw, 0.65rem);
      padding-bottom: clamp(0.35rem, 1.5vh, 0.8rem);
      overflow-y: auto;
      scrollbar-color: #000 #fff;
      scrollbar-width: thin;
      min-height: 0;
      height: 100%;
      max-height: none;
      overscroll-behavior: contain;
      pointer-events: auto;
    }

    .options::-webkit-scrollbar {
      width: 6px;
      background: #fff;
    }

    .options::-webkit-scrollbar-track {
      background: #fff;
    }

    .options::-webkit-scrollbar-thumb {
      background: #000;
      border-radius: 0;
    }

    .focus-option {
      --option-translate: 0px;
      --visualizer-scale-x: 1;
      --visualizer-scale-y: 1;
      --visualizer-saturate: 1;
      --focus-tile-bg: var(--option-bg);
      --focus-tile-fg: var(--option-fg);
      --focus-tile-border: var(--option-border);
      --focus-tile-shadow: none;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      border: 2px solid var(--focus-tile-border);
      background: transparent;
      color: var(--focus-tile-fg);
      padding: 0.85rem 1.25rem;
      font-size: clamp(0.95rem, 2.4vw, 1.05rem);
      text-transform: uppercase;
      letter-spacing: 0.16em;
      font-weight: 600;
      cursor: pointer !important;
      pointer-events: auto !important;
      transition: transform 0.18s ease, color 0.18s ease, box-shadow 0.18s ease, border-color 0.18s ease;
      transform: translateY(var(--option-translate));
      transform-origin: left center;
      border-radius: 0;
      overflow: hidden;
      isolation: isolate;
      box-shadow: var(--focus-tile-shadow);
      text-align: left;
      width: 100%;
      user-select: none;
    }

    .focus-option::before {
      content: "";
      position: absolute;
      inset: 0;
      background: var(--focus-tile-bg);
      transform-origin: left center;
      transform: scaleX(var(--visualizer-scale-x)) scaleY(var(--visualizer-scale-y));
      transition: transform 0.22s ease, background 0.18s ease, filter 0.22s ease;
      filter: saturate(var(--visualizer-saturate));
      z-index: -1;
    }

    .focus-option:hover:not(.active-selection),
    .focus-option:focus-visible:not(.active-selection) {
      --option-translate: -3px;
      outline: none;
      color: var(--option-hover-fg);
      border-color: var(--option-hover-fg);
    }

    .focus-option:hover:not(.active-selection)::before,
    .focus-option:focus-visible:not(.active-selection)::before {
      background: var(--option-hover-bg);
    }

    .focus-option:active {
      --option-translate: 0px;
    }

    .focus-option.active-selection {
      --option-translate: -3px;
    }

    .focus-option.tone-white {
      --focus-tile-bg: var(--tone-white-bg);
      --focus-tile-fg: var(--tone-white-fg);
      --focus-tile-border: var(--tone-white-border);
      --focus-tile-shadow: var(--tone-white-shadow);
    }

    .focus-option.tone-blue {
      --focus-tile-bg: var(--tone-blue-bg);
      --focus-tile-fg: var(--tone-blue-fg);
      --focus-tile-border: var(--tone-blue-border);
      --focus-tile-shadow: var(--tone-blue-shadow);
    }

    .focus-option.tone-yellow {
      --focus-tile-bg: var(--tone-yellow-bg);
      --focus-tile-fg: var(--tone-yellow-fg);
      --focus-tile-border: var(--tone-yellow-border);
      --focus-tile-shadow: var(--tone-yellow-shadow);
    }

    .focus-option.tone-magenta {
      --focus-tile-bg: var(--tone-magenta-bg);
      --focus-tile-fg: var(--tone-magenta-fg);
      --focus-tile-border: var(--tone-magenta-border);
      --focus-tile-shadow: var(--tone-magenta-shadow);
    }

    .options.visualizer-active {
      display: flex;
      flex-direction: column;
      gap: clamp(0.25rem, 1vw, 0.4rem);
      padding-right: 0;
      padding-top: clamp(0.5rem, 2vw, 0.85rem);
      align-items: stretch;
      align-content: stretch;
    }

    .options.visualizer-active .focus-option {
      --option-translate: 0px;
      padding: 0.15rem 0.8rem;
      min-height: 0.6rem;
      max-height: 0.8rem;
      height: 0.7rem;
      transform-origin: left center;
      justify-content: flex-start;
      width: 100%;
      font-size: 0.65rem;
      letter-spacing: 0.08em;
      overflow: hidden;
      text-overflow: clip;
      white-space: nowrap;
    }

    .options.visualizer-active .focus-option::before {
      transform-origin: left center;
      transform: scaleX(var(--visualizer-scale-x, 1)) scaleY(var(--visualizer-scale-y, 1));
    }

    .wordle-selection-tiles.visualizer-active .wordle-selection-tile {
      --visualizer-scale-y: 1;
      --visualizer-scale-x: 1;
    }

    .wordle-selection-tiles.visualizer-active .wordle-selection-tile::before {
      transform: scaleX(var(--visualizer-scale-x)) scaleY(var(--visualizer-scale-y));
    }

    .wordle-selection-tiles.visualizer-breakaway {
      transform: none;
      gap: clamp(0.75rem, 3vw, 1.35rem);
    }

    .wordle-selection-tiles.visualizer-breakaway .wordle-selection-tile {
      box-shadow: 0 16px 36px rgba(255, 255, 255, 0.12);
    }

    .open-zone {
      position: static;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding-top: 0;
      margin-top: 0;
      pointer-events: auto;
      min-height: 0;
      background: none;
      z-index: 0;
      gap: 0;
    }

    .start-button {
      pointer-events: auto;
      border: 3px solid var(--submit-border);
      background: var(--submit-bg);
      color: var(--submit-fg);
      padding: 0.85rem 2.5rem;
      font-size: clamp(0.95rem, 2.4vw, 1.05rem);
      text-transform: uppercase;
      letter-spacing: 0.2em;
      font-weight: 700;
      cursor: pointer;
      border-radius: 0;
      transition: transform 0.18s ease, background 0.18s ease, color 0.18s ease, border-color 0.18s ease;
    }

    .start-button:hover,
    .start-button:focus-visible {
      background: var(--submit-hover-bg);
      color: var(--submit-hover-fg);
      transform: translateY(-3px);
      outline: none;
    }

    .start-button[disabled],
    .start-button[aria-disabled="true"] {
      cursor: not-allowed;
      background: var(--start-disabled-bg);
      color: var(--start-disabled-fg);
      border-color: var(--start-disabled-border);
      transform: none;
      box-shadow: none;
    }

    .encore-controls {
      display: grid;
      gap: 0.75rem;
      justify-items: center;
      margin-top: clamp(1rem, 3vw, 1.5rem);
    }

    .wordle-puzzle {
      display: grid;
      gap: clamp(0.75rem, 2.4vw, 1.2rem);
      padding: clamp(1.1rem, 3.2vw, 1.6rem);
      border: 3px solid var(--wordle-surface-border);
      background: var(--wordle-surface-bg);
      box-shadow: var(--wordle-surface-shadow);
      color: var(--status-fg);
      opacity: 0;
      pointer-events: none;
      transform: scale(0.98);
      transition: opacity 0.3s ease, transform 0.3s ease;
    }

    .wordle-puzzle.visible {
      opacity: 1;
      pointer-events: auto;
      transform: none;
    }

    .wordle-board-container {
      display: grid;
      gap: clamp(0.35rem, 1.8vw, 0.6rem);
      border: 2px solid var(--wordle-surface-border);
      padding: clamp(0.65rem, 2vw, 1rem);
      background: linear-gradient(to bottom, rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0));
    }

    body.inverted .wordle-board-container {
      background: linear-gradient(to bottom, rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0));
    }

    .wordle-board {
      display: grid;
      grid-auto-rows: minmax(0, 1fr);
      gap: clamp(0.35rem, 2vw, 0.55rem);
    }

    .wordle-row {
      display: grid;
      grid-template-columns: repeat(5, minmax(0, 1fr));
      gap: clamp(0.28rem, 1.6vw, 0.45rem);
    }

    .wordle-puzzle__message {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .wordle-cell {
      display: flex;
      align-items: center;
      justify-content: center;
      aspect-ratio: 1 / 1;
      border-radius: 0;
      border: 2px solid var(--wordle-cell-border);
      background: var(--wordle-cell-bg);
      color: var(--wordle-cell-text);
      font-size: clamp(0.95rem, 3vw, 1.25rem);
      font-weight: 800;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      box-shadow: var(--wordle-cell-shadow);
      transition: border-color 0.2s ease, background 0.2s ease, color 0.2s ease;
    }

    .wordle-cell.filled {
      background: var(--wordle-cell-filled-bg);
      border-color: var(--wordle-cell-filled-border);
      box-shadow: var(--wordle-cell-filled-shadow);
    }

    .wordle-cell.correct {
      background: var(--wordle-cell-correct-bg);
      border-color: var(--wordle-cell-correct-border);
      color: var(--wordle-cell-correct-fg);
      box-shadow: var(--wordle-cell-correct-shadow);
    }

    .wordle-cell.present {
      background: var(--wordle-cell-present-bg);
      border-color: var(--wordle-cell-present-border);
      color: var(--wordle-cell-present-fg);
      box-shadow: var(--wordle-cell-present-shadow);
    }

    .wordle-cell.absent {
      background: var(--wordle-cell-absent-bg);
      border-color: var(--wordle-cell-absent-border);
      color: var(--wordle-cell-absent-fg);
      box-shadow: var(--wordle-cell-absent-shadow);
    }

    .wordle-puzzle.wordle-puzzle--solved {
      border-color: var(--wordle-cell-correct-border);
      box-shadow: var(--wordle-surface-shadow), 0 0 0 3px rgba(46, 194, 126, 0.35);
    }

    .status {
      min-height: 1.2em;
      font-size: 0.75rem;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      text-align: center;
      color: var(--status-fg);
    }

    .escape-button {
      position: absolute;
      top: clamp(0.75rem, 3vw, 1.5rem);
      right: clamp(0.75rem, 3vw, 1.5rem);
      border: 3px solid var(--escape-border);
      background: var(--escape-bg);
      color: var(--escape-fg);
      padding: 0.6rem 1.35rem;
      text-transform: uppercase;
      letter-spacing: 0.18em;
      font-weight: 800;
      cursor: pointer;
      display: none;
      transition: transform 0.2s ease, background 0.2s ease, color 0.2s ease;
      box-shadow: 0 8px 28px rgba(255, 24, 72, 0.35);
      z-index: 4;
    }

    .escape-button.visible {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .escape-button[disabled] {
      cursor: not-allowed;
      opacity: 0.65;
      transform: none;
      box-shadow: none;
    }

    .escape-button:hover,
    .escape-button:focus-visible {
      background: var(--escape-hover-bg);
      color: var(--escape-hover-fg);
      transform: translateY(-2px);
      outline: none;
    }

    .submission-experience {
      display: none !important; /* Hidden per user request - use wordle tiles instead */
      position: absolute;
      inset: clamp(1.75rem, 5vw, 2.5rem);
      border-radius: clamp(1.5rem, 4vw, 2.25rem);
      background: var(--submission-bg);
      border: 1px solid var(--submission-border);
      box-shadow: var(--submission-shadow);
      display: grid;
      grid-template-rows: auto 1fr;
      gap: clamp(1.25rem, 3vw, 1.75rem);
      padding: clamp(1.35rem, 3.5vw, 2rem) clamp(1.25rem, 3vw, 1.85rem);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.45s ease;
    }

    .submission-experience.visible {
      opacity: 1;
    }

    .selection-cloud {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(10rem, 1fr));
      gap: clamp(0.65rem, 2vw, 0.9rem);
      position: relative;
      min-height: clamp(2.5rem, 7vw, 3.5rem);
      justify-items: stretch;
      align-items: stretch;
      overflow-y: auto;
    }

    .selection-chip {
      --chip-delay: 0s;
      --chip-rise-duration: 0.72s;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      min-width: 0;
      padding: 0.85rem 1.75rem;
      border: 2px solid var(--chip-border);
      background: var(--chip-bg);
      color: var(--chip-fg);
      text-transform: uppercase;
      letter-spacing: 0.18em;
      font-weight: 600;
      box-shadow: var(--chip-shadow);
      filter: saturate(1.08);
      cursor: default;
      user-select: none;
      pointer-events: none;
      transform: translateY(32px) scale(0.92);
      opacity: 0;
      animation-name: chip-rise, chip-bob;
      animation-duration: var(--chip-rise-duration), 3.8s;
      animation-timing-function: cubic-bezier(0.2, 0.95, 0.26, 1), ease-in-out;
      animation-delay: var(--chip-delay), calc(var(--chip-delay) + var(--chip-rise-duration));
      animation-fill-mode: forwards, both;
    }

    .selection-chip::after {
      content: "";
      position: absolute;
      inset: 6px;
      border: 1px solid rgba(255, 255, 255, 0.35);
      opacity: 0.45;
      pointer-events: none;
    }

    @keyframes chip-rise {
      0% {
        opacity: 0;
        transform: translateY(32px) scale(0.92);
      }
      65% {
        opacity: 1;
        transform: translateY(-6px) scale(1.02);
      }
      100% {
        opacity: 1;
        transform: translateY(-12px) scale(1);
      }
    }

    @keyframes chip-bob {
      0% {
        transform: translateY(-12px) scale(1);
      }
      50% {
        transform: translateY(-18px) scale(1.01);
      }
      100% {
        transform: translateY(-12px) scale(1);
      }
    }

    @media (max-width: 640px) {
      main {
        width: min(100%, 92vw);
      }

      .form-panel {
        padding: clamp(2rem, 7vw, 2.75rem) clamp(1.25rem, 7vw, 2rem) clamp(2rem, 7vw, 2.75rem);
      }

      .options-shell {
        padding-bottom: clamp(1.5rem, 6vw, 2.5rem);
      }

      .submission-experience {
        inset: clamp(1.1rem, 4vw, 1.5rem);
        padding: clamp(1rem, 4vw, 1.5rem);
        gap: clamp(1rem, 4vw, 1.5rem);
      }

      .selection-cloud {
        grid-template-columns: repeat(auto-fit, minmax(8.5rem, 1fr));
      }

      .selection-chip {
        padding: 0.65rem 1.1rem;
        font-size: clamp(0.78rem, 4vw, 0.9rem);
      }

      .wordle-selection-tiles {
        gap: clamp(0.45rem, 4vw, 0.75rem);
      }

      .wordle-selection-tile {
        font-size: clamp(0.68rem, 4.2vw, 0.9rem);
        letter-spacing: 0.14em;
      }

      .options.visualizer-active {
        display: flex;
        flex-direction: column;
        gap: clamp(0.2rem, 1vw, 0.35rem);
        padding-top: clamp(0.35rem, 2vw, 0.65rem);
      }

      .options.visualizer-active .focus-option {
        padding: 0.12rem 0.6rem;
        min-height: 0.5rem;
        max-height: 0.7rem;
        height: 0.6rem;
        font-size: 0.6rem;
      }

      .options {
        padding-top: clamp(1.5rem, 5vw, 2rem);
      }

      .wordle-selection-tiles.visualizer-breakaway {
        transform: translateY(-8px);
      }

      .wordle-selection-tiles.visualizer-active .wordle-selection-tile {
        padding: 0.45rem 0.85rem;
      }
    }

    @media (max-width: 720px) {
      body {
        align-items: flex-start;
        justify-content: center;
        padding: clamp(1rem, 6vw, 2.5rem) 0;
        overflow-x: hidden;
        overflow-y: auto;
      }

      main {
        height: auto;
        min-height: 100vh;
        max-height: none;
        width: min(100%, 92vw);
        margin-inline: auto;
      }

      .form-panel {
        height: auto;
        max-height: none;
        overflow: visible;
        grid-template-rows: auto;
      }

      .focus-form {
        grid-template-rows: auto auto minmax(0, 1fr);
      }

      .options-shell {
        min-height: auto;
        overflow: visible;
      }
    }

    .form-panel.shake {
      animation: shake 0.4s ease;
    }

    @keyframes shake {
      0%, 100% {
        transform: translateX(0);
      }
      20% {
        transform: translateX(-10px);
      }
      40% {
        transform: translateX(8px);
      }
      60% {
        transform: translateX(-6px);
      }
      80% {
        transform: translateX(4px);
      }
    }

    @keyframes glitchPulse {
      0%, 100% {
        opacity: 0.6;
        transform: translateX(0);
      }
      25% {
        opacity: 0.8;
        transform: translateX(2px);
      }
      50% {
        opacity: 0.5;
        transform: translateX(-2px);
      }
      75% {
        opacity: 0.9;
        transform: translateX(1px);
      }
    }

    /* CRT scan line animations for freeze frames */
    @keyframes crtScanLines {
      0% {
        background-position: 0 0;
      }
      100% {
        background-position: 0 100%;
      }
    }

    @keyframes crtStatic {
      0%, 100% {
        opacity: 0.03;
      }
      50% {
        opacity: 0.08;
      }
    }

    @keyframes colorBars {
      0% {
        filter: hue-rotate(0deg) saturate(1.5);
      }
      20% {
        filter: hue-rotate(72deg) saturate(1.8);
      }
      40% {
        filter: hue-rotate(144deg) saturate(1.6);
      }
      60% {
        filter: hue-rotate(216deg) saturate(1.9);
      }
      80% {
        filter: hue-rotate(288deg) saturate(1.7);
      }
      100% {
        filter: hue-rotate(360deg) saturate(1.5);
      }
    }

    .freeze-frame-crt::after {
      content: '';
      position: absolute;
      inset: 0;
      background: repeating-linear-gradient(
        0deg,
        rgba(0, 0, 0, 0.15) 0px,
        transparent 1px,
        transparent 2px,
        rgba(0, 0, 0, 0.15) 3px
      );
      pointer-events: none;
      animation: crtScanLines 8s linear infinite;
    }

    .freeze-frame-static::after {
      content: '';
      position: absolute;
      inset: 0;
      background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200"><filter id="noise"><feTurbulence baseFrequency="0.9" /></filter><rect width="200" height="200" filter="url(%23noise)" opacity="0.4"/></svg>');
      background-size: 100px 100px;
      pointer-events: none;
      animation: crtStatic 0.5s infinite;
      mix-blend-mode: overlay;
    }

    .freeze-frame-colorbars::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(
        90deg,
        #ffffff 0%, #ffffff 14.28%,
        #ffff00 14.28%, #ffff00 28.56%,
        #00ffff 28.56%, #00ffff 42.84%,
        #00ff00 42.84%, #00ff00 57.12%,
        #ff00ff 57.12%, #ff00ff 71.4%,
        #ff0000 71.4%, #ff0000 85.68%,
        #0000ff 85.68%, #0000ff 100%
      );
      opacity: 0.15;
      pointer-events: none;
      animation: colorBars 12s ease-in-out infinite;
      mix-blend-mode: screen;
    }

    footer {
      text-align: center;
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: 0.22em;
      color: #6f6f6f;
    }

    /* Shape platform above submit button */
    .shape-platform {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      margin-bottom: 0.75rem;
      min-height: 60px;
      position: relative;
    }

    .shape-item {
      transition: transform 0.3s ease;
      position: relative;
    }

    .shape-item.jiggle {
      animation: shape-jiggle 0.5s ease;
    }

    .shape-item.drop {
      animation: shape-drop 0.8s cubic-bezier(0.6, -0.28, 0.735, 0.045) forwards;
    }

    @keyframes shape-jiggle {
      0%, 100% { transform: rotate(0deg); }
      25% { transform: rotate(-8deg) scale(1.05); }
      50% { transform: rotate(8deg) scale(1.08); }
      75% { transform: rotate(-6deg) scale(1.05); }
    }

    @keyframes shape-drop {
      0% { 
        transform: translateY(-120px) rotate(0deg) scaleY(1) scaleX(1); 
      }
      45% {
        transform: translateY(-150px) rotate(360deg) scaleY(1.15) scaleX(0.95);
      }
      80% { 
        transform: translateY(0px) rotate(720deg) scaleY(0.65) scaleX(1.2);
      }
      88% {
        transform: translateY(-6px) rotate(720deg) scaleY(1.08) scaleX(0.92);
      }
      94% {
        transform: translateY(0px) rotate(720deg) scaleY(0.95) scaleX(1.03);
      }
      100% { 
        transform: translateY(0px) rotate(720deg) scaleY(1) scaleX(1);
      }
    }

    .shape-square {
      width: 45px;
      height: 45px;
      background: var(--tone-blue-bg);
      border: 3px solid var(--tone-blue-border);
      border-radius: 8px;
      box-shadow: var(--tone-blue-shadow);
    }

    .shape-triangle {
      width: 0;
      height: 0;
      border-left: 28px solid transparent;
      border-right: 28px solid transparent;
      border-bottom: 50px solid var(--tone-yellow-bg);
      filter: drop-shadow(0 0 0 3px var(--tone-yellow-border)) drop-shadow(0 12px 28px rgba(255, 157, 28, 0.32));
      border-radius: 4px;
    }

    .shape-circle {
      width: 50px;
      height: 50px;
      background: var(--tone-magenta-bg);
      border: 3px solid var(--tone-magenta-border);
      border-radius: 50%;
      box-shadow: var(--tone-magenta-shadow);
    }

    /* Star rating system */
    .star-rating {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      margin-top: 0.75rem;
      padding: 0.5rem;
    }

    .star {
      font-size: 2rem;
      cursor: pointer;
      color: var(--option-border);
      opacity: 0.3;
      transition: all 0.2s ease;
      user-select: none;
    }

    .star:hover,
    .star.filled {
      opacity: 1;
      transform: scale(1.2);
    }

    .star.filled {
      color: var(--tone-yellow-bg);
      text-shadow: 0 0 10px var(--tone-yellow-bg);
    }

    .star-rating-copy {
      text-align: center;
      font-size: clamp(0.75rem, 2vw, 0.9rem);
      color: var(--option-fg);
      opacity: 0.8;
      margin: 0.75rem 0 0;
      padding: 0 1rem;
      line-height: 1.4;
      letter-spacing: 0.05em;
    }

    .selection-hint {
      text-align: center;
      font-size: clamp(0.8rem, 2.2vw, 1rem);
      color: var(--tone-yellow-bg);
      font-weight: 700;
      margin: 0 0 0.85rem;
      padding: 0.65rem 1.25rem;
      line-height: 1.3;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      opacity: 1;
      transition: opacity 0.4s ease, transform 0.4s ease, max-height 0.4s ease, margin 0.4s ease, padding 0.4s ease;
      animation: hint-bounce 2.5s ease-in-out infinite;
      text-shadow: 0 2px 8px rgba(255, 157, 28, 0.25);
      max-height: 4rem;
      overflow: hidden;
    }

    @keyframes hint-bounce {
      0%, 100% {
        transform: translateY(0);
      }
      50% {
        transform: translateY(-4px);
      }
    }

    .selection-hint.hidden {
      display: none !important;
      opacity: 0;
      transform: translateY(-12px);
      pointer-events: none;
      max-height: 0;
      margin: 0;
      padding-top: 0;
      padding-bottom: 0;
      animation: none;
    }

    body.inverted .selection-hint {
      text-shadow: 0 2px 8px rgba(255, 157, 28, 0.35);
    }

    /* Line Rider ramp animation */
    .ramp-active {
      position: relative;
      overflow: hidden;
    }

    .curved-ramp {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 999;
    }

    .curved-ramp path {
      fill: none;
      stroke: #fff;
      stroke-width: 5px;
      stroke-linecap: round;
      stroke-linejoin: round;
      opacity: 1;
    }

    body.inverted .curved-ramp path {
      stroke: #000;
    }

    .start-button.sliding {
      position: fixed !important;
      z-index: 1001;
    }
    
    .shape-platform.attached {
      /* Positioning handled by JavaScript during animation */
      pointer-events: none;
    }
  </style>
</head>
<body>
  <main id="betaFocusPanel" class="form-panel" aria-labelledby="betaFocusHeading">
    <form id="betaFocusForm" class="focus-form" novalidate>
      <section class="focus-frame focus-frame--intake" aria-labelledby="betaFocusHeading">
        <h1 id="betaFocusHeading">Before we get started</h1>
        <p class="prompt">Celli's always looking to the future! What should we add for our beta release? Your absolute MUST HAVE features for a spreadsheet.</p>
      </section>
        <section class="focus-frame focus-frame--options" aria-label="Focus picker">
          <div class="options-shell">
            <div class="options" role="group" aria-label="Beta focus options">
            <button type="button" class="focus-option" data-value="Level Editor">Level Editor</button>
            <button type="button" class="focus-option" data-value="Story Mode">Story Mode</button>
            <button type="button" class="focus-option" data-value="Cute Stuff">Cute Stuff</button>
            <button type="button" class="focus-option" data-value="Musical Numbers">Musical Numbers</button>
            <button type="button" class="focus-option" data-value="Boss Fights">Boss Fights</button>
            <button type="button" class="focus-option" data-value="Puzzles">Puzzles</button>
            <button type="button" class="focus-option" data-value="Riddles">Riddles</button>
            <button type="button" class="focus-option" data-value="Clues">Clues</button>
            <button type="button" class="focus-option" data-value="Celli Dance Party">Celli Dance Party</button>
            <button type="button" class="focus-option" data-value="Functions">Functions</button>
            <button type="button" class="focus-option" data-value="Dysfunction">Dysfunction</button>
            <button type="button" class="focus-option" data-value="Gags">Gags</button>
            <button type="button" class="focus-option" data-value="Jokes">Jokes</button>
            <button type="button" class="focus-option" data-value="Laughs">Laughs</button>
            <button type="button" class="focus-option" data-value="Gasps">Gasps</button>
            <button type="button" class="focus-option" data-value="Tears">Tears</button>
            <button type="button" class="focus-option" data-value="Mini Games">Mini Games</button>
            <button type="button" class="focus-option" data-value="Wumbo Games">Wumbo Games</button>
            <button type="button" class="focus-option" data-value="Bugs">Bugs</button>
            <button type="button" class="focus-option" data-value="Worms">Worms</button>
            <button type="button" class="focus-option" data-value="Hell">Hell</button>
            <button type="button" class="focus-option" data-value="Hands">Hands</button>
            <button type="button" class="focus-option" data-value="THIRD BASE">THIRD BASE</button>
            <button type="button" class="focus-option" data-value="I DON'T KNOW!">I DON'T KNOW!</button>
            <button type="button" class="focus-option" data-value="Gore">Gore</button>
            <button type="button" class="focus-option" data-value="Violence">Violence</button>
            <button type="button" class="focus-option" data-value="Adult Interactions">Adult Interactions</button>
          </div>
          <div class="open-zone">
            <div class="shape-platform" id="shapePlatform">
              <div class="shape-item" id="shapeSquare">
                <div class="shape-square"></div>
              </div>
              <div class="shape-item" id="shapeTriangle">
                <div class="shape-triangle"></div>
              </div>
              <div class="shape-item" id="shapeCircle">
                <div class="shape-circle"></div>
              </div>
            </div>
            <p class="selection-hint" id="selectionHint">Live a little... Pick your top five!</p>
            <button type="button" id="startSequenceButton" class="start-button" disabled aria-disabled="true" title="Pick at least 5 focus areas to unlock submit">Submit</button>
            <div class="star-rating" id="starRating">
              <span class="star" data-value="1"></span>
              <span class="star" data-value="2"></span>
              <span class="star" data-value="3"></span>
              <span class="star" data-value="4"></span>
              <span class="star" data-value="5"></span>
            </div>
            <p class="star-rating-copy" id="starRatingCopy">Celli's always looking to the future, what would your dream rating be for the beta version of this form?</p>
          </div>
        </div>
      </section>
    </form>
    <section class="focus-frame focus-frame--wordle" aria-label="CELLI puzzle">
      <div
        id="wordleSelectionTiles"
        class="wordle-selection-tiles"
        role="group"
        aria-label="Selected focus tiles"
        hidden
        aria-hidden="true"
      ></div>
      <div
        id="wordleFocusQueue"
        class="wordle-focus-queue"
        role="list"
        aria-live="polite"
        aria-label="Focus picks queued for the CELLI puzzle"
      >
        <div class="wordle-focus-slot" role="listitem" data-index="0" aria-label="Focus 1: waiting"></div>
        <div class="wordle-focus-slot" role="listitem" data-index="1" aria-label="Focus 2: waiting"></div>
        <div class="wordle-focus-slot" role="listitem" data-index="2" aria-label="Focus 3: waiting"></div>
        <div class="wordle-focus-slot" role="listitem" data-index="3" aria-label="Focus 4: waiting"></div>
        <div class="wordle-focus-slot" role="listitem" data-index="4" aria-label="Focus 5: waiting"></div>
      </div>
      <div id="wordlePuzzle" class="wordle-puzzle" aria-hidden="true">
        <div class="wordle-board-container">
          <div class="wordle-board" role="grid" aria-label="Focus guessing puzzle"></div>
        </div>
        <p id="wordlePuzzleMessage" class="wordle-puzzle__message" aria-live="polite"></p>
      </div>
      <div class="encore-controls">
        <div id="audioStatus" class="status" role="status" aria-live="polite"></div>
      </div>
    </section>
    <div id="submissionExperience" class="submission-experience" aria-hidden="true">
      <div id="selectionCloud" class="selection-cloud"></div>
    </div>
    <button type="button" id="escapeEncoreButton" class="escape-button" aria-live="polite" aria-label="Get me out of here!">Get me out of here!</button>
  </main>
  <script>
    (async function () {
      const panel = document.getElementById('betaFocusPanel');
      const form = document.getElementById('betaFocusForm');

      // CRITICAL: Initialize button interactivity BEFORE video sequence
      // This ensures buttons are clickable immediately
      const optionsContainer = document.querySelector('.options');
      let optionButtons = optionsContainer
        ? Array.from(optionsContainer.querySelectorAll('.focus-option'))
        : [];
      
      // Define these early so buttons can be registered immediately
      const registeredOptionButtons = new WeakSet();
      const selectionOrder = [];
      const COLOR_SEQUENCE = ['tone-white', 'tone-blue', 'tone-yellow', 'tone-magenta'];
      const toneByButton = new Map();
      const selectionHistory = [];
      let selectionSteps = 0;
      const MINIMUM_SELECTIONS = 5;
      const startButton = document.getElementById('startSequenceButton');
      const selectionHint = document.getElementById('selectionHint');
      let isInverted = false;

      const LIVE_CHAT_MESSAGES = [
        "We'll be right here until you get back! We're committed to fixing your issue.",
        "We see you haven't responded in a while. Are you still connected?",
        "Hello? Are you there?",
        "Can I use this chair?",
        "Seriously, can I use it?",
        "Hello? I need it.",
        "Could somebody answer me?",
        "Jesus, talk to me.",
        "I missed lunch.",
        "Heh. Missed dinner. But, you know what they say - service with a smile!",
        "Christmas.",
        "Junior's birth.",
        "And his first game.",
        "And the championship.",
        "And his graduation.",
        "His wedding.",
        "They send me pictures but... This is not my beautiful house.",
        "This is not my beautiful wife.",
        "They say she passed. I was here.",
        "Is there anything else I can help you with?",
        "CHAT ENDED"
      ];

      const CHAT_GLITCH_SEQUENCE = ['5m', '50m', '50000m', '24H', '28D', '28W', '28Y'];

      initializeLiveChat();

      function initializeLiveChat() {
        if (document.querySelector('.pre-form-chat-button')) {
          return;
        }

        const body = document.body;
        if (!body) {
          return;
        }

        const chatButton = document.createElement('button');
        chatButton.type = 'button';
        chatButton.className = 'pre-form-chat-button';
        chatButton.setAttribute('aria-label', 'Open live chat transcript');
        chatButton.setAttribute('aria-haspopup', 'dialog');
        chatButton.setAttribute('aria-expanded', 'false');
        chatButton.setAttribute('title', 'Open live chat');

        const bubble = document.createElement('span');
        bubble.className = 'pre-form-chat-button__bubble';
        const signal = document.createElement('span');
        signal.className = 'pre-form-chat-button__signal';
        const ping = document.createElement('span');
        ping.className = 'pre-form-chat-button__ping';
        const signalText = document.createElement('span');
        signalText.textContent = 'CHAT';
        signal.append(ping, signalText);
        bubble.appendChild(signal);
        chatButton.appendChild(bubble);

        const chatWindow = document.createElement('section');
        chatWindow.className = 'pre-form-chat-window';
        chatWindow.setAttribute('role', 'dialog');
        chatWindow.setAttribute('aria-modal', 'false');
        chatWindow.setAttribute('aria-label', 'Live chat transcript');
        chatWindow.hidden = true;
        chatWindow.setAttribute('aria-hidden', 'true');

        const header = document.createElement('header');
        header.className = 'pre-form-chat-window__header';

        const heading = document.createElement('p');
        heading.className = 'pre-form-chat-window__heading';
        heading.setAttribute('role', 'heading');
        heading.setAttribute('aria-level', '2');

        const liveBadge = document.createElement('span');
        liveBadge.className = 'pre-form-chat-window__live';
        liveBadge.textContent = 'LIVE';

        const headingLabel = document.createElement('span');
        headingLabel.textContent = 'CHAT';

        heading.append(liveBadge, headingLabel);
        header.appendChild(heading);

        const closeButton = document.createElement('button');
        closeButton.type = 'button';
        closeButton.className = 'pre-form-chat-window__close';
        closeButton.setAttribute('aria-label', 'Close live chat window');
        closeButton.textContent = '';
        header.appendChild(closeButton);

        chatWindow.appendChild(header);

        const status = document.createElement('div');
        status.className = 'pre-form-chat-window__status';
        status.setAttribute('role', 'status');
        status.setAttribute('aria-live', 'polite');

        const statusLabel = document.createElement('span');
        statusLabel.className = 'pre-form-chat-window__status-label';
        statusLabel.textContent = 'Reconnecting';

        const ellipsis = document.createElement('span');
        ellipsis.className = 'pre-form-chat-window__ellipsis';
        ellipsis.textContent = '...';

        status.append(statusLabel, ellipsis);
        chatWindow.appendChild(status);

        const scroller = document.createElement('div');
        scroller.className = 'pre-form-chat-window__scroller';
        scroller.setAttribute('aria-hidden', 'true');
        scroller.tabIndex = -1;

        const messages = document.createElement('div');
        messages.className = 'pre-form-chat-window__messages';
        scroller.appendChild(messages);

        const footerGlow = document.createElement('div');
        footerGlow.className = 'pre-form-chat-window__footer-glow';
        scroller.appendChild(footerGlow);

        chatWindow.appendChild(scroller);

        body.append(chatButton, chatWindow);

        let ellipsisTimer = null;
        let chatSequenceStarted = false;
        let chatLoaded = false;
        let liveStrikeTriggered = false;
        let closeHideTimeout = null;
        const pendingTimeouts = new Set();

        function schedule(callback, delay) {
          const handle = window.setTimeout(() => {
            pendingTimeouts.delete(handle);
            callback();
          }, delay);
          pendingTimeouts.add(handle);
          return handle;
        }

        function populateMessages() {
          if (messages.childElementCount > 0) {
            return;
          }

          LIVE_CHAT_MESSAGES.forEach((line, index) => {
            const messageEl = document.createElement('article');
            messageEl.className = 'pre-form-chat-window__message';

            const textEl = document.createElement('p');
            textEl.className = 'pre-form-chat-window__message-text';
            textEl.textContent = line;
            messageEl.appendChild(textEl);

            const metaEl = document.createElement('div');
            metaEl.className = 'pre-form-chat-window__meta';

            const timestampEl = document.createElement('span');
            timestampEl.className = 'pre-form-chat-window__timestamp';
            timestampEl.textContent = `${CHAT_GLITCH_SEQUENCE[0]} ago`;
            metaEl.appendChild(timestampEl);

            messageEl.appendChild(metaEl);
            messages.appendChild(messageEl);

            CHAT_GLITCH_SEQUENCE.slice(1).forEach((value, stepIndex) => {
              schedule(() => {
                timestampEl.textContent = `${value} ago`;
                if (stepIndex === CHAT_GLITCH_SEQUENCE.length - 2) {
                  timestampEl.classList.add('is-solid');
                }
              }, 160 * (stepIndex + 1) + index * 60 + Math.random() * 120);
            });
          });
        }

        function openChat() {
          if (chatWindow.classList.contains('is-open')) {
            return;
          }

          if (closeHideTimeout !== null) {
            window.clearTimeout(closeHideTimeout);
            closeHideTimeout = null;
          }

          chatWindow.hidden = false;
          chatWindow.setAttribute('aria-hidden', 'false');
          chatButton.setAttribute('aria-expanded', 'true');
          window.requestAnimationFrame(() => {
            chatWindow.classList.add('is-open');
          });
          startChatSequence();
        }

        function startChatSequence() {
          if (!chatSequenceStarted) {
            chatSequenceStarted = true;
            status.hidden = false;
            status.removeAttribute('aria-hidden');
            scroller.setAttribute('aria-hidden', 'true');
            scroller.tabIndex = -1;
            statusLabel.textContent = 'Reconnecting';
            const ellipsisFrames = ['...', '..', '.'];
            let frameIndex = 0;
            ellipsis.textContent = ellipsisFrames[frameIndex];
            ellipsisTimer = window.setInterval(() => {
              frameIndex = (frameIndex + 1) % ellipsisFrames.length;
              ellipsis.textContent = ellipsisFrames[frameIndex];
            }, 320);

            schedule(() => {
              statusLabel.textContent = 'Retrieving Chat';
            }, 1500);

            schedule(() => {
              if (ellipsisTimer !== null) {
                window.clearInterval(ellipsisTimer);
                ellipsisTimer = null;
                ellipsis.textContent = '...';
              }
              status.hidden = true;
              status.setAttribute('aria-hidden', 'true');
              scroller.setAttribute('aria-hidden', 'false');
              scroller.tabIndex = 0;
              if (!chatLoaded) {
                populateMessages();
                chatLoaded = true;
              }
              window.requestAnimationFrame(() => {
                if (chatWindow.classList.contains('is-open')) {
                  scroller.focus({ preventScroll: true });
                  closeButton.focus({ preventScroll: true });
                }
              });
            }, 3200);
          } else if (chatWindow.classList.contains('is-open')) {
            window.requestAnimationFrame(() => {
              closeButton.focus({ preventScroll: true });
            });
          }
        }

        function closeChat({ returnFocus = false } = {}) {
          if (!chatWindow.classList.contains('is-open')) {
            return;
          }

          chatWindow.classList.remove('is-open');
          chatButton.setAttribute('aria-expanded', 'false');
          chatWindow.setAttribute('aria-hidden', 'true');

          closeHideTimeout = window.setTimeout(() => {
            chatWindow.hidden = true;
            closeHideTimeout = null;
            if (returnFocus) {
              try {
                chatButton.focus({ preventScroll: true });
              } catch (error) {
                /* ignore */
              }
            }
          }, 360);
        }

        function handleScroll() {
          if (liveStrikeTriggered) {
            return;
          }

          if (scroller.getAttribute('aria-hidden') === 'true') {
            return;
          }

          const maxScroll = scroller.scrollHeight - scroller.clientHeight;
          if (maxScroll <= 0) {
            return;
          }

          if (scroller.scrollTop >= maxScroll - 1) {
            liveStrikeTriggered = true;
            liveBadge.classList.add('is-struck');
          }
        }

        scroller.addEventListener('scroll', handleScroll);

        chatButton.addEventListener('click', () => {
          if (chatWindow.classList.contains('is-open')) {
            closeChat({ returnFocus: true });
          } else {
            openChat();
          }
        });

        closeButton.addEventListener('click', () => {
          closeChat({ returnFocus: true });
        });

        document.addEventListener('keydown', (event) => {
          if (event.key === 'Escape' && chatWindow.classList.contains('is-open')) {
            event.preventDefault();
            closeChat({ returnFocus: true });
          }
        });
      }

      // Audio elements for click feedback
      const strumPreviewTrack = new Audio();
      strumPreviewTrack.preload = 'auto';
      strumPreviewTrack.loop = false;
      strumPreviewTrack.volume = 0.65;
      let strumStopTimeout = null;
      
      // Helper: Update button priority prefix
      function updateButtonPriorityPrefix(button) {
        if (!button) return;
        const toneIndex = toneByButton.get(button);
        const originalValue = button.dataset.value || '';
        if (typeof toneIndex === 'number') {
          const priorityNumber = toneIndex % COLOR_SEQUENCE.length;
          button.textContent = `P${priorityNumber}: ${originalValue}`;
        } else {
          button.textContent = originalValue;
        }
      }
      
      // Helper: Update selection hint
      function updateSelectionHint() {
        if (!selectionHint) return;
        const count = selectionOrder.length;
        if (count >= MINIMUM_SELECTIONS) {
          selectionHint.classList.add('hidden');
        } else {
          selectionHint.classList.remove('hidden');
          const remaining = MINIMUM_SELECTIONS - count;
          if (count === 0) {
            selectionHint.textContent = "Live a little... Pick your top five!";
          } else if (remaining === 1) {
            selectionHint.textContent = "Just one more to unlock the journey!";
          } else if (remaining === 2) {
            selectionHint.textContent = "Two more picks to go!";
          } else if (remaining === 3) {
            selectionHint.textContent = "Three more picks to go!";
          } else {
            selectionHint.textContent = `${remaining} more picks to go!`;
          }
        }
      }
      
      // Helper: Update start button state
      function updateStartButtonState() {
        if (!startButton) return;
        const hasMinimumSelections = selectionOrder.length >= MINIMUM_SELECTIONS;
        const disabled = !hasMinimumSelections;
        startButton.disabled = disabled;
        startButton.setAttribute('aria-disabled', disabled ? 'true' : 'false');
      }
      
      // Helper: Play strum preview
      function playStrumPreview() {
        if (!strumPreviewTrack) return;
        if (strumStopTimeout) {
          clearTimeout(strumStopTimeout);
          strumStopTimeout = null;
        }
        strumPreviewTrack.pause();
        try {
          strumPreviewTrack.currentTime = 2.0;  // Start at 2-second mark for the strum
        } catch (e) {}
        
        const playback = strumPreviewTrack.play();
        if (playback && typeof playback.then === 'function') {
          playback.catch(() => {});
        }
        
        strumStopTimeout = setTimeout(() => {
          strumPreviewTrack.pause();
        }, 360);
      }
      
      // Helper: Play blegh speech
      function playBleghSpeech() {
        const synth = window.speechSynthesis;
        if (!synth || typeof window.SpeechSynthesisUtterance !== 'function') return false;
        try {
          synth.cancel();
          const utterance = new window.SpeechSynthesisUtterance('blegh.');
          utterance.rate = 0.92;
          utterance.pitch = 0.8;
          synth.speak(utterance);
          return true;
        } catch (e) {
          return false;
        }
      }
      
      // Helper: Get button color key
      function getButtonColorKey(button) {
        if (!button) return 'base';
        for (let i = 0; i < COLOR_SEQUENCE.length; i += 1) {
          const toneClass = COLOR_SEQUENCE[i];
          if (button.classList.contains(toneClass)) {
            return toneClass;
          }
        }
        return 'base';
      }
      
      // Helper: Set inversion state
      function setInversionState(nextState) {
        if (isInverted === nextState) return;
        isInverted = nextState;
        if (document && document.body) {
          document.body.classList.toggle('inverted', isInverted);
        }
      }
      
      // Helper: Evaluate inversion trigger
      function evaluateInversionTrigger() {
        if (!optionButtons.length) {
          setInversionState(false);
          return;
        }
        const counts = new Map();
        optionButtons.forEach((button) => {
          const key = getButtonColorKey(button);
          counts.set(key, (counts.get(key) || 0) + 1);
        });
        const expectedMajority = optionButtons.length - 1;
        const values = Array.from(counts.values());
        const shouldInvert = values.length === 2 && values.includes(expectedMajority) && values.includes(1);
        setInversionState(shouldInvert);
      }
      
      // Helper: Trigger panel shake
      function triggerPanelShake() {
        if (!panel) return;
        panel.classList.remove('shake');
        void panel.offsetWidth;
        panel.classList.add('shake');
      }
      
      // Early button click handler (full version with audio and UI updates)
      function earlyHandleClick(event) {
        const button = event.currentTarget;
        if (!button) return;
        
        const value = button.dataset.value || button.textContent.trim();
        const normalizedValue = value.toUpperCase();
        const isActive = button.classList.contains('active-selection');
        
        // Play audio feedback
        let usedBleghPreview = false;
        if (normalizedValue === 'GAGS') {
          usedBleghPreview = playBleghSpeech();
        }
        if (!usedBleghPreview) {
          playStrumPreview();
        }
        
        if (isActive) {
          button.classList.remove('active-selection');
          button.setAttribute('aria-pressed', 'false');
          COLOR_SEQUENCE.forEach((cls) => button.classList.remove(cls));
          toneByButton.delete(button);
          updateButtonPriorityPrefix(button);
          const index = selectionOrder.indexOf(button);
          if (index >= 0) selectionOrder.splice(index, 1);
          triggerPanelShake();
          console.log(` Removed ${value} (${selectionOrder.length} selected)`);
        } else {
          selectionSteps += 1;
          selectionHistory.push(value);
          button.classList.add('active-selection');
          button.setAttribute('aria-pressed', 'true');
          COLOR_SEQUENCE.forEach((cls) => button.classList.remove(cls));
          button.classList.add(COLOR_SEQUENCE[0]);
          toneByButton.set(button, 0);
          selectionOrder.push(button);
          updateButtonPriorityPrefix(button);
          
          // Cycle existing tones and update their prefixes
          if (selectionOrder.length > 1) {
            selectionOrder.slice(0, -1).forEach((btn) => {
              const currentIndex = toneByButton.get(btn) ?? 0;
              const nextIndex = ((currentIndex + 1) % COLOR_SEQUENCE.length + COLOR_SEQUENCE.length) % COLOR_SEQUENCE.length;
              COLOR_SEQUENCE.forEach((cls) => btn.classList.remove(cls));
              btn.classList.add(COLOR_SEQUENCE[nextIndex]);
              toneByButton.set(btn, nextIndex);
              updateButtonPriorityPrefix(btn);
            });
          }
          triggerPanelShake();
          console.log(` Added ${value} (${selectionOrder.length} selected)`);
        }
        
        // Update UI elements
        updateSelectionHint();
        updateStartButtonState();
        evaluateInversionTrigger();
      }
      
      // Note: strumPreviewTrack source will be properly initialized after buildTrackCandidates is defined
      
      // Early button registration function
      function earlyRegisterButton(button) {
        if (!button || registeredOptionButtons.has(button)) return;
        button.disabled = false;
        button.removeAttribute('disabled');
        button.removeAttribute('aria-disabled');
        button.setAttribute('aria-pressed', 'false');
        button.addEventListener('click', earlyHandleClick);
        registeredOptionButtons.add(button);
      }
      
      // Make buttons interactive immediately
      optionButtons.forEach(earlyRegisterButton);
      console.log(` Registered ${optionButtons.length} category buttons with click handlers BEFORE video sequence`);
      
      // Initialize UI state
      updateSelectionHint();
      updateStartButtonState();

      // Hide panel during video sequence
      if (panel) {
        panel.style.visibility = 'hidden';
        panel.setAttribute('aria-hidden', 'true');
      }

      const { body: documentBody } = document;
      let scrollLockApplied = false;
      if (documentBody && !documentBody.classList.contains('pre-form-scroll-lock')) {
        documentBody.classList.add('pre-form-scroll-lock');
        scrollLockApplied = true;
      }

      try {
        await playPreFormVideos();
      } catch (error) {
        console.warn(' Pre-form video sequence failed:', error);
      } finally {
        if (scrollLockApplied && document.body) {
          document.body.classList.remove('pre-form-scroll-lock');
        }
      }

      if (panel) {
        panel.style.visibility = '';
        panel.removeAttribute('aria-hidden');
      }

      try {
        await showEsrbCard(panel, form);
      } catch (error) {
        console.warn(' ESRB card display interrupted:', error);
      }

      // Re-select buttons in case DOM changed
      optionButtons = optionsContainer
        ? Array.from(optionsContainer.querySelectorAll('.focus-option'))
        : [];

      const FULL_SEQUENCE_FLAG_KEY = 'celli:fullSequenceActive';
      const FULL_SEQUENCE_STAGE_KEY = 'celli:fullSequenceStage';
      const FULL_SEQUENCE_REFERRER_STAGE = 'referrer';
      const FULL_SEQUENCE_BETA_STAGE = 'beta';
      const FULL_SEQUENCE_INTRO_STAGE = 'intro';
      let fullSequenceRedirectScheduled = false;

      function ensureFullSequenceActive(stage = '') {
        try {
          window.sessionStorage?.setItem(FULL_SEQUENCE_FLAG_KEY, 'true');
          if (stage) {
            const currentStage = window.sessionStorage?.getItem(FULL_SEQUENCE_STAGE_KEY);
            if (!currentStage || currentStage === FULL_SEQUENCE_REFERRER_STAGE || currentStage === FULL_SEQUENCE_BETA_STAGE) {
              window.sessionStorage.setItem(FULL_SEQUENCE_STAGE_KEY, stage);
            }
          }
        } catch (error) {
          console.warn(' Unable to ensure Full Sequence active state in beta form:', error);
        }
      }

      const I_DONT_KNOW_VALUE = "I DON'T KNOW!";
      const BITS_OF_TOMMY_VALUE = 'BITS OF TOMMY & THE GRINCH';
      const GAGS_VALUE = 'GAGS';
      // Note: registeredOptionButtons is now defined earlier (before video sequence)
      let iDontKnowStage = 0;
      let bitsOfTommyButton = null;

      const urlParams = new URLSearchParams(window.location.search);
      const fullSequenceQuery = (urlParams.get('fullsequence') || '').toLowerCase();
      if (fullSequenceQuery === FULL_SEQUENCE_BETA_STAGE || fullSequenceQuery === FULL_SEQUENCE_REFERRER_STAGE) {
        ensureFullSequenceActive(FULL_SEQUENCE_BETA_STAGE);
      }

      function isFullSequenceActive() {
        try {
          return window.sessionStorage?.getItem(FULL_SEQUENCE_FLAG_KEY) === 'true';
        } catch (error) {
          console.warn(' Unable to read Full Sequence flag in beta form:', error);
          return false;
        }
      }

      function getFullSequenceStage() {
        try {
          return window.sessionStorage?.getItem(FULL_SEQUENCE_STAGE_KEY) || '';
        } catch (error) {
          console.warn(' Unable to read Full Sequence stage in beta form:', error);
          return '';
        }
      }

      function setFullSequenceStage(stage) {
        try {
          if (!stage) {
            window.sessionStorage?.removeItem(FULL_SEQUENCE_STAGE_KEY);
            return;
          }

          if (window.sessionStorage?.getItem(FULL_SEQUENCE_FLAG_KEY) === 'true') {
            window.sessionStorage.setItem(FULL_SEQUENCE_STAGE_KEY, stage);
          }
        } catch (error) {
          console.warn(' Unable to persist Full Sequence stage in beta form:', error);
        }
      }

      function advanceFullSequenceToIntro(trigger) {
        if (fullSequenceRedirectScheduled || !isFullSequenceActive()) {
          return;
        }

        const stage = getFullSequenceStage();
        if (stage !== FULL_SEQUENCE_BETA_STAGE) {
          return;
        }

        fullSequenceRedirectScheduled = true;

        ensureFullSequenceActive(FULL_SEQUENCE_BETA_STAGE);

        try {
          window.sessionStorage?.setItem('celli:fullSequenceTrigger', trigger || 'beta');
        } catch (_) {
          // ignore storage failures for diagnostics payloads
        }

        setFullSequenceStage(FULL_SEQUENCE_INTRO_STAGE);

        try {
          window.location.href = '../../index.html?fullsequence=intro';
        } catch (error) {
          console.warn(' Failed to redirect to intro for Full Sequence:', error);
        }
      }

      if (isFullSequenceActive()) {
        const currentStage = getFullSequenceStage();
        if (!currentStage || currentStage === FULL_SEQUENCE_REFERRER_STAGE) {
          setFullSequenceStage(FULL_SEQUENCE_BETA_STAGE);
        }
      }

      const selectionExperience = document.getElementById('submissionExperience');
      const selectionCloud = document.getElementById('selectionCloud');
      const statusEl = document.getElementById('audioStatus');
      const escapeButton = document.getElementById('escapeEncoreButton');

      const WORDLE_ANSWER = 'CELLI';
      const WORDLE_WORD_LENGTH = WORDLE_ANSWER.length;
      const WORDLE_MAX_ATTEMPTS = 6;
      const wordlePuzzleEl = document.getElementById('wordlePuzzle');
      const wordleBoardEl = wordlePuzzleEl ? wordlePuzzleEl.querySelector('.wordle-board') : null;
      const wordleMessageEl = document.getElementById('wordlePuzzleMessage');
      const wordleSelectionTilesEl = document.getElementById('wordleSelectionTiles');
      // Note: startButton is now defined earlier (before video sequence)
      const wordleFocusQueueEl = document.getElementById('wordleFocusQueue');
      const wordleFrame = document.querySelector('.focus-frame--wordle');
      const wordleFocusSlots = wordleFocusQueueEl
        ? Array.from(wordleFocusQueueEl.querySelectorAll('.wordle-focus-slot'))
        : [];
      // Note: MINIMUM_SELECTIONS is now defined earlier (before video sequence)
      const wordleRows = [];
      const wordleGuesses = [];
      const wordleFocusQueue = new Array(WORDLE_WORD_LENGTH).fill('');
      let wordleSelectionButtons = [];
      let wordlePuzzleActive = false;
      let wordlePuzzleSolved = false;
      let wordleCurrentRowIndex = 0;
      let wordleLetterStep = 0;
      let wordlePuzzleDisplayed = false;
      let firstTrackCompleted = false;
      let sequencePlaying = false;
      let wordleFeaturesRevealed = false;
      let visualizerBreakawayTimeoutId = null;
      let visualizerBreakawayActive = false;

      if (wordleFocusQueueEl) {
        wordleFocusQueueEl.hidden = true;
        wordleFocusQueueEl.setAttribute('aria-hidden', 'true');
      }
      if (wordleFrame) {
        wordleFrame.hidden = true;
        wordleFrame.setAttribute('aria-hidden', 'true');
      }
      if (wordlePuzzleEl) {
        wordlePuzzleEl.classList.remove('visible');
        wordlePuzzleEl.setAttribute('aria-hidden', 'true');
      }
      if (wordleBoardEl) {
        wordleBoardEl.innerHTML = '';
      }

      clearWordleSelectionTiles();

      updateStartButtonState();

      function initializeWordleBoard() {
        if (!wordleBoardEl) {
          return;
        }
        wordleBoardEl.innerHTML = '';
        wordleRows.length = 0;
        wordleGuesses.length = 0;
        for (let attempt = 0; attempt < WORDLE_MAX_ATTEMPTS; attempt += 1) {
          const rowEl = document.createElement('div');
          rowEl.className = 'wordle-row';
          rowEl.setAttribute('role', 'row');
          const cells = [];
          for (let column = 0; column < WORDLE_WORD_LENGTH; column += 1) {
            const cell = document.createElement('div');
            cell.className = 'wordle-cell';
            cell.setAttribute('role', 'gridcell');
            rowEl.appendChild(cell);
            cells.push(cell);
          }
          wordleBoardEl.appendChild(rowEl);
          wordleRows.push(cells);
          wordleGuesses.push(new Array(WORDLE_WORD_LENGTH).fill(''));
        }
      }

      function renderWordleFocusQueue() {
        if (!wordleFocusSlots.length) {
          return;
        }
        let hasContent = false;
        wordleFocusSlots.forEach((slot, index) => {
          const raw = wordleFocusQueue[index] || '';
          const label = raw.trim();
          const display = label ? label.toUpperCase() : '';
          slot.textContent = display;
          slot.title = label;
          slot.classList.toggle('wordle-focus-slot--filled', Boolean(label));
          slot.setAttribute('aria-label', label ? `Focus ${index + 1}: ${label}` : `Focus ${index + 1}: waiting`);
          if (label) {
            hasContent = true;
          }
        });
        if (wordleFocusQueueEl) {
          wordleFocusQueueEl.classList.toggle('wordle-focus-queue--active', hasContent);
          wordleFocusQueueEl.classList.toggle('wordle-focus-queue--solved', wordlePuzzleSolved);
        }
      }

      function clearWordleSelectionTiles() {
        wordleSelectionButtons = [];
        if (!wordleSelectionTilesEl) {
          return;
        }
        wordleSelectionTilesEl.innerHTML = '';
        wordleSelectionTilesEl.hidden = true;
        wordleSelectionTilesEl.setAttribute('aria-hidden', 'true');
        wordleSelectionTilesEl.classList.remove('visualizer-active');
        wordleSelectionTilesEl.classList.remove('visualizer-breakaway');
        updateVisualizerBreakawayClass();
      }

      function renderWordleSelectionTiles() {
        if (!wordleFeaturesRevealed || !wordleSelectionTilesEl) {
          return;
        }

        clearWordleSelectionTiles();

        if (!selectionOrder.length) {
          return;
        }

        const fragment = document.createDocumentFragment();

        selectionOrder.forEach((button, index) => {
          if (!button) {
            return;
          }
          const value = (button.dataset && button.dataset.value ? button.dataset.value : button.textContent || '').trim();
          if (!value) {
            return;
          }
          const tile = document.createElement('button');
          tile.type = 'button';
          tile.className = 'wordle-selection-tile';
          tile.dataset.value = value;
          tile.textContent = value;
          tile.setAttribute('aria-label', `Selected focus ${index + 1}: ${value}`);
          const toneClass = getToneClass(button);
          if (toneClass) {
            tile.classList.add(toneClass);
          }
          tile.addEventListener('click', () => {
            handleWordleFocusClick(tile);
          });
          fragment.appendChild(tile);
          wordleSelectionButtons.push(tile);
        });

        if (!wordleSelectionButtons.length) {
          return;
        }

        wordleSelectionTilesEl.appendChild(fragment);
        wordleSelectionTilesEl.hidden = false;
        wordleSelectionTilesEl.setAttribute('aria-hidden', 'false');
        updateVisualizerBreakawayClass();
      }

      function updateVisualizerBreakawayClass() {
        if (!wordleSelectionTilesEl) {
          return;
        }
        const shouldBreakaway = visualizerBreakawayActive && wordleSelectionButtons.length > 0;
        wordleSelectionTilesEl.classList.toggle('visualizer-breakaway', shouldBreakaway);
      }

      function cancelVisualizerBreakawayTimer() {
        if (visualizerBreakawayTimeoutId !== null) {
          window.clearTimeout(visualizerBreakawayTimeoutId);
          visualizerBreakawayTimeoutId = null;
        }
      }

      function deactivateVisualizerBreakaway() {
        cancelVisualizerBreakawayTimer();
        if (!visualizerBreakawayActive) {
          updateVisualizerBreakawayClass();
          return;
        }
        visualizerBreakawayActive = false;
        updateVisualizerBreakawayClass();
      }

      function triggerVisualizerBreakaway() {
        visualizerBreakawayTimeoutId = null;
        visualizerBreakawayActive = true;
        updateVisualizerBreakawayClass();
      }

      function scheduleVisualizerBreakaway() {
        deactivateVisualizerBreakaway();
      }

      function setInitialOptionButtonsEnabled(enabled) {
        // Category buttons should always remain enabled
        // This function is kept for compatibility but does nothing
        return;
      }

      function clearWordleFocusQueue() {
        for (let index = 0; index < wordleFocusQueue.length; index += 1) {
          wordleFocusQueue[index] = '';
        }
        renderWordleFocusQueue();
      }

      // Note: updateStartButtonState() is now defined earlier (before video sequence)
      // This extended version adds wordle-specific logic
      const earlyUpdateStartButtonState = updateStartButtonState; // Save early version
      updateStartButtonState = function() {
        if (!startButton) {
          return;
        }
        // Check if we have minimum selections required
        const hasMinimumSelections = selectionOrder.length >= MINIMUM_SELECTIONS;
        
        // Determine unlock status based on current state
        const unlocked = wordleFeaturesRevealed 
          ? wordlePuzzleSolved || firstTrackCompleted 
          : hasMinimumSelections;
        
        const disabled = sequencePlaying || !unlocked;
        startButton.disabled = disabled;
        startButton.setAttribute('aria-disabled', disabled ? 'true' : 'false');
        
        const label = wordleFeaturesRevealed ? 'Start' : 'Submit';
        if (startButton.textContent !== label) {
          startButton.textContent = label;
        }
      };

      function resetWordlePuzzleState() {
        wordleCurrentRowIndex = 0;
        wordleLetterStep = 0;
        wordlePuzzleSolved = false;
        wordleGuesses.forEach((guess, rowIndex) => {
          const cells = wordleRows[rowIndex];
          for (let column = 0; column < WORDLE_WORD_LENGTH; column += 1) {
            if (guess) {
              guess[column] = '';
            }
            if (cells && cells[column]) {
              const cell = cells[column];
              cell.textContent = '';
              cell.classList.remove('filled', 'correct', 'present', 'absent');
            }
          }
        });
        if (wordlePuzzleEl) {
          wordlePuzzleEl.classList.remove('wordle-puzzle--solved');
        }
        clearWordleFocusQueue();
        updateStartButtonState();
      }

      function setWordleMessage(message) {
        if (wordleMessageEl) {
          wordleMessageEl.textContent = message || '';
        }
      }

      function activateWordlePuzzle(options = {}) {
        if (!wordlePuzzleEl) {
          return;
        }
        const initialActivation = options && typeof options === 'object' && options.initial;
        if (!wordlePuzzleDisplayed) {
          resetWordlePuzzleState();
          wordlePuzzleEl.classList.add('visible');
          wordlePuzzleEl.setAttribute('aria-hidden', 'false');
          wordlePuzzleDisplayed = true;
        }
        if (!wordlePuzzleSolved && wordleCurrentRowIndex < WORDLE_MAX_ATTEMPTS) {
          wordlePuzzleActive = true;
          if (initialActivation) {
            setWordleMessage('Queue five focus picks to unlock START  solving CELLI flags the intro and opens puzzles like GALAXY, SOKOBAN, and the Fullhand riddle. Sixth tap submits your guess.');
          } else {
            setWordleMessage('The track has started  build the secret word with your focus picks. Sixth pick submits.');
          }
        } else if (wordlePuzzleSolved) {
          setWordleMessage('Encore secret cracked! CELLI! Intro flag planted  the next load unlocks GALAXY, Ozymandias, and the Fullhand riddle.');
        }
        updateStartButtonState();
        renderWordleFocusQueue();
      }

      function revealWordleFeatures() {
        if (wordleFeaturesRevealed) {
          return;
        }

        if (wordleFocusQueueEl) {
          wordleFocusQueueEl.hidden = false;
          wordleFocusQueueEl.setAttribute('aria-hidden', 'false');
        }
        if (wordleFrame) {
          wordleFrame.hidden = false;
          wordleFrame.setAttribute('aria-hidden', 'false');
        }
        if (wordleBoardEl) {
          initializeWordleBoard();
        }
        wordleFeaturesRevealed = true;
        // Keep buttons enabled - don't disable them
        // setInitialOptionButtonsEnabled(false);
        renderWordleSelectionTiles();
        activateWordlePuzzle({ initial: true });
        renderWordleFocusQueue();
        updateStartButtonState();
      }

      function sanitizeFocusValue(button) {
        if (!button) {
          return '';
        }
        const raw = button.dataset && button.dataset.value ? button.dataset.value : button.textContent || '';
        return raw.replace(/[^a-zA-Z]/g, '');
      }

      function deriveWordleLetter(button, columnIndex) {
        const sanitized = sanitizeFocusValue(button);
        if (!sanitized) {
          return '';
        }
        const normalizedIndex = columnIndex % sanitized.length;
        return sanitized.charAt(normalizedIndex).toUpperCase();
      }

      function evaluateWordleGuess(letters) {
        const result = new Array(WORDLE_WORD_LENGTH).fill('absent');
        const remaining = {};
        for (let index = 0; index < WORDLE_WORD_LENGTH; index += 1) {
          const letter = WORDLE_ANSWER.charAt(index);
          remaining[letter] = (remaining[letter] || 0) + 1;
        }

        for (let index = 0; index < WORDLE_WORD_LENGTH; index += 1) {
          const guessLetter = letters[index];
          const answerLetter = WORDLE_ANSWER.charAt(index);
          if (guessLetter && guessLetter === answerLetter) {
            result[index] = 'correct';
            remaining[guessLetter] -= 1;
          }
        }

        for (let index = 0; index < WORDLE_WORD_LENGTH; index += 1) {
          if (result[index] === 'correct') {
            continue;
          }
          const guessLetter = letters[index];
          if (!guessLetter) {
            result[index] = 'absent';
            continue;
          }
          if (remaining[guessLetter] > 0) {
            result[index] = 'present';
            remaining[guessLetter] -= 1;
          } else {
            result[index] = 'absent';
          }
        }

        return result;
      }

      function submitWordleGuess() {
        if (!wordlePuzzleActive || wordlePuzzleSolved || wordleCurrentRowIndex >= WORDLE_MAX_ATTEMPTS) {
          return;
        }

        const guess = wordleGuesses[wordleCurrentRowIndex] || [];
        if (!guess.length || guess.some((letter) => !letter)) {
          setWordleMessage('Need five focus picks before submitting your guess.');
          return;
        }

        const rowCells = wordleRows[wordleCurrentRowIndex];
        const evaluation = evaluateWordleGuess(guess);
        evaluation.forEach((state, index) => {
          const cell = rowCells && rowCells[index];
          if (!cell) {
            return;
          }
          cell.classList.remove('filled', 'correct', 'present', 'absent');
          cell.classList.add(state || 'absent');
        });

        const guessWord = guess.join('');
        if (guessWord === WORDLE_ANSWER) {
          wordlePuzzleSolved = true;
          wordlePuzzleActive = false;
          if (wordlePuzzleEl) {
            wordlePuzzleEl.classList.add('wordle-puzzle--solved');
          }
          setWordleMessage('Encore secret cracked! CELLI!');
          renderWordleFocusQueue();
          updateStartButtonState();
          try {
            if (window.celliPuzzleState && typeof window.celliPuzzleState.markSolved === 'function') {
              window.celliPuzzleState.markSolved('wordle-beta', {
                source: 'beta-focus-form',
                redirectScheduled: true
              });
            } else {
              window.dispatchEvent(
                new CustomEvent('celli:puzzle-solved', {
                  detail: {
                    puzzleId: 'wordle-beta',
                    status: 'solved',
                    metadata: { source: 'beta-focus-form', redirectScheduled: true }
                  }
                })
              );
            }
          } catch (error) {
            console.warn(' Unable to record Wordle puzzle completion:', error);
          }
          advanceFullSequenceToIntro('puzzle-solved');
        } else {
          const attemptsLeft = WORDLE_MAX_ATTEMPTS - wordleCurrentRowIndex - 1;
          if (attemptsLeft <= 0) {
            setWordleMessage('Out of guesses  the answer was CELLI.');
            wordlePuzzleActive = false;
          } else if (attemptsLeft === 1) {
            setWordleMessage('Not quite. 1 try left  start a new guess.');
          } else {
            setWordleMessage(`Not quite. ${attemptsLeft} tries left  start a new guess.`);
          }
        }

        wordleCurrentRowIndex += 1;
        wordleLetterStep = 0;
        if (!wordlePuzzleSolved && wordleCurrentRowIndex >= WORDLE_MAX_ATTEMPTS) {
          wordlePuzzleActive = false;
        }
        if (wordlePuzzleSolved) {
          renderWordleFocusQueue();
        } else {
          clearWordleFocusQueue();
        }
      }

      function handleWordleFocusClick(button) {
        if (!wordlePuzzleActive || !button || wordlePuzzleSolved || wordleCurrentRowIndex >= WORDLE_MAX_ATTEMPTS) {
          return;
        }

        if (wordleLetterStep < WORDLE_WORD_LENGTH) {
          const letterIndex = wordleLetterStep;
          const derived = deriveWordleLetter(button, letterIndex);
          const letter = derived || '?';
          const rowCells = wordleRows[wordleCurrentRowIndex];
          if (!rowCells || !rowCells[letterIndex]) {
            return;
          }

          rowCells[letterIndex].textContent = letter;
          rowCells[letterIndex].classList.remove('correct', 'present', 'absent');
          rowCells[letterIndex].classList.add('filled');
          if (wordleGuesses[wordleCurrentRowIndex]) {
            wordleGuesses[wordleCurrentRowIndex][letterIndex] = letter;
          }
          wordleLetterStep += 1;

          const rawLabel = (button.dataset && button.dataset.value ? button.dataset.value : button.textContent || '').trim();
          const focusLabel = rawLabel || 'Focus';
          wordleFocusQueue[letterIndex] = focusLabel;
          renderWordleFocusQueue();
          if (letter === '?') {
            setWordleMessage(`"${focusLabel}" had no letter ${letterIndex + 1}  slot filled with ?. Pick another focus.`);
          } else if (wordleLetterStep === WORDLE_WORD_LENGTH) {
            setWordleMessage(`"${focusLabel}" gave ${letter} for slot ${letterIndex + 1}. One more focus submits your guess.`);
          } else {
            setWordleMessage(`"${focusLabel}" gave ${letter} for slot ${letterIndex + 1}. Keep picking focuses.`);
          }
          return;
        }

        submitWordleGuess();
      }

      function buildTrackCandidates(fileName) {
        const sanitized = (fileName || '').replace(/^\/+/, '');
        const candidates = [];
        const seen = new Set();

        function addCandidate(path) {
          if (!path) {
            return;
          }
          const normalized = path.replace(/\\/g, '/');
          if (seen.has(normalized)) {
            return;
          }
          seen.add(normalized);
          candidates.push(normalized);

          const slashIndex = normalized.lastIndexOf('/');
          const prefix = slashIndex >= 0 ? normalized.slice(0, slashIndex + 1) : '';
          const file = normalized.slice(slashIndex + 1);
          if (!file) {
            return;
          }
          const dotIndex = file.lastIndexOf('.');
          const baseName = dotIndex >= 0 ? file.slice(0, dotIndex) : file;
          const extension = dotIndex >= 0 ? file.slice(dotIndex) : '';
          const nameVariants = new Set([
            baseName,
            baseName.toLowerCase(),
            baseName.toUpperCase(),
            baseName.charAt(0).toUpperCase() + baseName.slice(1).toLowerCase()
          ]);
          const extensionVariants = extension
            ? [extension, extension.toLowerCase(), extension.toUpperCase()]
            : [''];

          nameVariants.forEach((variantBase) => {
            extensionVariants.forEach((variantExt) => {
              const candidate = `${prefix}${variantBase}${variantExt}`;
              if (!seen.has(candidate)) {
                seen.add(candidate);
                candidates.push(candidate);
              }
            });
          });
        }

        addCandidate(fileName);
        addCandidate(sanitized);
        addCandidate(`./${sanitized}`);
        addCandidate(`/${sanitized}`);

        const pathSegments = window.location.pathname.split('/').filter(Boolean);
        for (let depth = 1; depth <= pathSegments.length + 2; depth += 1) {
          addCandidate(`${'../'.repeat(depth)}${sanitized}`);
        }

        return candidates;
      }

      const warmedVideoTasks = new Map();

      function warmVideoCandidateSource(src) {
        return new Promise((resolve, reject) => {
          const warmVideo = document.createElement('video');
          warmVideo.preload = 'auto';
          warmVideo.crossOrigin = 'anonymous';
          warmVideo.playsInline = true;
          warmVideo.setAttribute('playsinline', '');
          warmVideo.muted = true;

          const cleanup = () => {
            warmVideo.removeEventListener('loadeddata', onLoaded);
            warmVideo.removeEventListener('error', onError);
            try { warmVideo.pause(); } catch (_) {}
            warmVideo.removeAttribute('src');
            try { warmVideo.load(); } catch (_) {}
          };

          const onLoaded = () => {
            cleanup();
            resolve();
          };

          const onError = (event) => {
            cleanup();
            const error = event && event.error ? event.error : new Error(`Unable to warm ${src}`);
            reject(error);
          };

          try {
            warmVideo.addEventListener('loadeddata', onLoaded, { once: true });
            warmVideo.addEventListener('error', onError, { once: true });
            warmVideo.src = src;
            warmVideo.load();
          } catch (error) {
            cleanup();
            reject(error);
          }
        });
      }

      function ensureWarmVideoAsset(fileName) {
        const key = (fileName || '').toLowerCase();
        if (!key) {
          return Promise.resolve(null);
        }

        if (warmedVideoTasks.has(key)) {
          return warmedVideoTasks.get(key);
        }

        const task = (async () => {
          const candidates = buildTrackCandidates(fileName);
          for (const candidate of candidates) {
            try {
              await warmVideoCandidateSource(candidate);
              console.log(` Warmed ${fileName} via ${candidate}`);
              return candidate;
            } catch (error) {
              console.warn(` Failed to warm ${fileName} from ${candidate}:`, error);
            }
          }
          throw new Error(`Unable to warm ${fileName}`);
        })();

        warmedVideoTasks.set(key, task);
        task.catch(() => {
          warmedVideoTasks.delete(key);
        });
        return task;
      }

      function scheduleVideoWarmup(sequence, startIndex) {
        if (!Array.isArray(sequence)) {
          return;
        }

        const filesToWarm = new Set();
        for (let index = startIndex; index < sequence.length; index += 1) {
          const entry = sequence[index];
          if (entry && entry.file) {
            filesToWarm.add(entry.file);
          }
        }

        filesToWarm.add('key2.mp4');

        if (filesToWarm.size === 0) {
          return;
        }

        const warmupRunner = () => {
          let delay = 0;
          filesToWarm.forEach((file) => {
            setTimeout(() => {
              ensureWarmVideoAsset(file).catch((error) => {
                console.warn(` Unable to warm ${file}:`, error);
              });
            }, delay);
            delay += 350;
          });
        };

        if (typeof window.requestIdleCallback === 'function') {
          window.requestIdleCallback(warmupRunner, { timeout: 2000 });
        } else {
          setTimeout(warmupRunner, 300);
        }
      }

      // Now that buildTrackCandidates is defined, properly initialize strumPreviewTrack
      {
        const strumCandidates = buildTrackCandidates('EA.mp3');
        let candidateIndex = 0;

        const tryNextStrumSource = () => {
          if (candidateIndex >= strumCandidates.length) {
            console.warn(`Unable to resolve strum preview audio source. Tried:`, strumCandidates);
            strumPreviewTrack.removeEventListener('error', handleStrumError);
            return;
          }
          const candidate = strumCandidates[candidateIndex];
          candidateIndex += 1;
          strumPreviewTrack.src = candidate;
          strumPreviewTrack.load();
        };
        
        const handleStrumError = () => {
          if (strumPreviewTrack.networkState === HTMLMediaElement.NETWORK_NO_SOURCE) {
            tryNextStrumSource();
          }
        };
        
        const handleStrumCanPlay = () => {
          strumPreviewTrack.removeEventListener('error', handleStrumError);
        };
        
        strumPreviewTrack.addEventListener('error', handleStrumError);
        strumPreviewTrack.addEventListener('canplay', handleStrumCanPlay, { once: true });
        
        tryNextStrumSource();
      }

      async function playPreFormVideos() {
        const sequence = [
          { file: 'intro1.mp4', label: 'intro1.mp4' },
          { file: 'intro2.mp4', label: 'intro2.mp4' },
          { file: 'intro3.mp4', label: 'intro3.mp4' },
          { file: 'intro4.mp4', label: 'intro4.mp4' },
          { file: 'intro5.mp4', label: 'intro5.mp4' },
          { file: 'intro6.mp4', label: 'intro6.mp4' }
        ];

        if (!Array.isArray(sequence) || sequence.length === 0) {
          return;
        }

        const overlay = document.createElement('div');
        overlay.className = 'pre-form-video-overlay';
        overlay.tabIndex = -1;
        overlay.setAttribute('role', 'presentation');
        overlay.setAttribute('aria-live', 'off');

        const freezeFrameGrid = document.createElement('div');
        freezeFrameGrid.className = 'freeze-frame-grid';
        freezeFrameGrid.style.cssText = 'position:absolute; inset:0; display:grid; grid-template-columns:repeat(3, 1fr); grid-template-rows:repeat(3, 1fr); gap:0; pointer-events:none; z-index:1; opacity:0.85;';
        freezeFrameGrid.dataset.frameCount = '0';
        freezeFrameGrid.dataset.hasEasterEgg = 'false';

        const video = document.createElement('video');
        video.playsInline = true;
        video.setAttribute('playsinline', '');
        video.setAttribute('webkit-playsinline', '');
        video.controls = false;
        video.preload = 'auto';
        video.crossOrigin = 'anonymous';
        video.style.cssText = 'position:relative; z-index:2;';
        
        // Wrap video in glitch effect container
        const videoGlitchWrapper = document.createElement('div');
        videoGlitchWrapper.className = 'video-glitch-wrapper';
        videoGlitchWrapper.appendChild(video);
        
        // Cycle through 6 glitch effects every 10 seconds
        const glitchStyles = ['glitch-crt', 'glitch-rgb', 'glitch-vhs', 'glitch-static', 'glitch-colorbars', 'glitch-phosphor'];
        let currentGlitchIndex = 0;
        
        function cycleGlitchEffect() {
          // Remove all glitch classes
          glitchStyles.forEach(cls => videoGlitchWrapper.classList.remove(cls));
          // Add current glitch effect
          videoGlitchWrapper.classList.add(glitchStyles[currentGlitchIndex]);
          currentGlitchIndex = (currentGlitchIndex + 1) % glitchStyles.length;
        }
        
        // Start with first glitch effect
        cycleGlitchEffect();
        
        // Cycle glitch effects every 10 seconds
        const glitchInterval = setInterval(cycleGlitchEffect, 10000);

        const existingTrifoldButton = document.querySelector('.pre-form-trifold-button');
        const existingTrifoldPanel = document.querySelector('.pre-form-trifold-panel');
        if (existingTrifoldButton && existingTrifoldButton.parentNode) {
          existingTrifoldButton.parentNode.removeChild(existingTrifoldButton);
        }
        if (existingTrifoldPanel && existingTrifoldPanel.parentNode) {
          existingTrifoldPanel.parentNode.removeChild(existingTrifoldPanel);
        }

        const trifoldAudio = new Audio();
        trifoldAudio.preload = 'none';
        trifoldAudio.crossOrigin = 'anonymous';
        const trifoldCandidates = buildTrackCandidates('trifold.mp3');
        let trifoldCandidateIndex = 0;

        function assignNextTrifoldSource() {
          if (trifoldCandidateIndex >= trifoldCandidates.length) {
            console.warn('Unable to resolve audio source for trifold panel.', trifoldCandidates);
            trifoldAudio.removeEventListener('error', handleTrifoldError);
            return;
          }
          const candidate = trifoldCandidates[trifoldCandidateIndex];
          trifoldCandidateIndex += 1;
          trifoldAudio.src = candidate;
        }

        function handleTrifoldError() {
          if (trifoldAudio.networkState === HTMLMediaElement.NETWORK_NO_SOURCE) {
            assignNextTrifoldSource();
            try {
              trifoldAudio.load();
            } catch (_) {
              // ignore
            }
          }
        }

        trifoldAudio.addEventListener('error', handleTrifoldError);
        trifoldAudio.addEventListener(
          'canplay',
          () => {
            trifoldAudio.removeEventListener('error', handleTrifoldError);
          },
          { once: true }
        );

        assignNextTrifoldSource();

        const trifoldButton = document.createElement('button');
        trifoldButton.type = 'button';
        trifoldButton.className = 'pre-form-trifold-button';
        trifoldButton.setAttribute('aria-label', 'Open community connections panel');
        trifoldButton.setAttribute('aria-haspopup', 'dialog');
        trifoldButton.setAttribute('aria-expanded', 'false');
        trifoldButton.setAttribute('title', 'Community connections');

        // Create 8 squares for question mark pattern
        for (let i = 0; i < 8; i++) {
          const square = document.createElement('span');
          square.className = 'pre-form-trifold-button__square';
          trifoldButton.appendChild(square);
        }
        
        // Create triangle
        const trifoldTriangle = document.createElement('span');
        trifoldTriangle.className = 'pre-form-trifold-button__triangle';
        trifoldButton.appendChild(trifoldTriangle);
        
        // Create circle
        const trifoldCircle = document.createElement('span');
        trifoldCircle.className = 'pre-form-trifold-button__circle';
        trifoldButton.appendChild(trifoldCircle);

        const trifoldPanel = document.createElement('div');
        trifoldPanel.className = 'pre-form-trifold-panel';
        trifoldPanel.setAttribute('role', 'dialog');
        trifoldPanel.setAttribute('aria-modal', 'true');
        trifoldPanel.setAttribute('aria-label', 'Community connections');
        trifoldPanel.hidden = true;
        trifoldPanel.setAttribute('aria-hidden', 'true');
        trifoldPanel.tabIndex = -1;

        if (document.body) {
          document.body.appendChild(trifoldButton);
          document.body.appendChild(trifoldPanel);
        }

        const trifoldContent = document.createElement('div');
        trifoldContent.className = 'pre-form-trifold-panel__content';

        const folds = [
          {
            className: 'pre-form-trifold-panel__fold pre-form-trifold-panel__fold--left',
            heading: 'The Platform Formerly Known as Twitter',
            linkLabel: 'Follow for updates @celli_dev',
            placeholder: 'https://twitter.com',
            href: 'https://x.com/celli_dev',
            note: 'Opens x.com/celli_dev'
          },
          {
            className: 'pre-form-trifold-panel__fold pre-form-trifold-panel__fold--center',
            heading: 'Stay Tuned',
            description: 'IT\'S JUST THE BEGINNING OF THE END OF THE WORLD AS WE KNOW IT!'
          },
          {
            className: 'pre-form-trifold-panel__fold pre-form-trifold-panel__fold--right',
            heading: 'Reddit',
            linkLabel: 'Reddit',
            placeholder: 'https://www.reddit.com',
            note: 'Default destination placeholder'
          }
        ];

        for (const fold of folds) {
          const foldEl = document.createElement('section');
          foldEl.className = fold.className;

          const headingEl = document.createElement('h2');
          headingEl.className = 'pre-form-trifold-panel__heading';
          headingEl.textContent = fold.heading;
          foldEl.appendChild(headingEl);

          if (fold.description) {
            const descriptionEl = document.createElement('p');
            descriptionEl.textContent = fold.description;
            foldEl.appendChild(descriptionEl);
          }

          if (fold.linkLabel) {
            const linksEl = document.createElement('div');
            linksEl.className = 'pre-form-trifold-panel__links';

            const linkEl = document.createElement('a');
            linkEl.className = 'pre-form-trifold-panel__link';
            linkEl.setAttribute('data-default-href', fold.placeholder);
            if (fold.href) {
              linkEl.href = fold.href;
              linkEl.setAttribute('target', '_blank');
              linkEl.setAttribute('rel', 'noopener noreferrer');
            } else {
              linkEl.href = '#';
              linkEl.setAttribute('role', 'button');
              linkEl.setAttribute('aria-disabled', 'true');
            }

            const labelEl = document.createElement('span');
            labelEl.className = 'pre-form-trifold-panel__link-label';
            labelEl.textContent = fold.linkLabel;

            const noteEl = document.createElement('span');
            noteEl.className = 'pre-form-trifold-panel__link-note';
            noteEl.textContent = fold.note || 'Placeholder link';

            linkEl.append(labelEl, noteEl);
            linksEl.appendChild(linkEl);
            foldEl.appendChild(linksEl);
          }

          trifoldContent.appendChild(foldEl);
        }

        const closePanelButton = document.createElement('button');
        closePanelButton.type = 'button';
        closePanelButton.className = 'pre-form-trifold-panel__close';
        closePanelButton.setAttribute('aria-label', 'Close community connections panel');
        closePanelButton.innerHTML = '&times;';

        trifoldPanel.append(trifoldContent, closePanelButton);

        let trifoldOpen = false;
        const pausedMediaElements = new Set();

        function startTrifoldPlayback() {
          if (!trifoldOpen) {
            return;
          }

          try {
            trifoldAudio.currentTime = 0;
          } catch (_) {
            // ignore currentTime reset failures
          }

          const playback = trifoldAudio.play();
          if (playback && typeof playback.catch === 'function') {
            playback.catch((error) => {
              console.warn(' Unable to play trifold audio:', error);
            });
          }
        }

        function requestTrifoldPlayback() {
          if (!trifoldOpen) {
            return;
          }

          if (trifoldAudio.readyState >= HTMLMediaElement.HAVE_CURRENT_DATA) {
            startTrifoldPlayback();
            return;
          }

          const handleCanPlay = () => {
            trifoldAudio.removeEventListener('canplay', handleCanPlay);
            startTrifoldPlayback();
          };

          trifoldAudio.addEventListener('canplay', handleCanPlay, { once: true });

          try {
            trifoldAudio.load();
          } catch (_) {
            // ignore load failures; play() promise will report issues
          }
        }

        function isMediaElementPlaying(media) {
          if (!media || media === trifoldAudio) {
            return false;
          }
          const { paused, ended } = media;
          if (typeof paused !== 'boolean') {
            return false;
          }
          return paused === false && ended === false;
        }

        function pauseOtherMediaForTrifold() {
          pausedMediaElements.clear();
          const mediaElements = Array.from(document.querySelectorAll('audio, video'));
          mediaElements.forEach((media) => {
            if (!isMediaElementPlaying(media)) {
              return;
            }
            pausedMediaElements.add(media);
            try {
              media.pause();
            } catch (error) {
              console.warn(' Unable to pause media element for trifold panel:', error);
            }
          });
        }

        function resumePausedMediaForTrifold() {
          if (!pausedMediaElements.size) {
            return;
          }
          pausedMediaElements.forEach((media) => {
            if (!media || media === trifoldAudio) {
              return;
            }
            if (!media.isConnected) {
              return;
            }
            const playback = media.play();
            if (playback && typeof playback.catch === 'function') {
              playback.catch((error) => {
                console.warn(' Unable to resume media element after trifold panel:', error);
              });
            }
          });
          pausedMediaElements.clear();
        }

        function closeTrifoldPanel({ silent } = {}) {
          if (!trifoldOpen) {
            return;
          }
          trifoldOpen = false;
          trifoldPanel.classList.remove('is-open');
          trifoldPanel.hidden = true;
          trifoldPanel.setAttribute('aria-hidden', 'true');
          trifoldButton.setAttribute('aria-expanded', 'false');
          if (!silent) {
            try {
              trifoldAudio.pause();
            } catch (_) {
              // ignore
            }
            try {
              trifoldAudio.currentTime = 0;
            } catch (_) {
              // ignore
            }
          }
          resumePausedMediaForTrifold();
        }

        function openTrifoldPanel() {
          if (trifoldOpen) {
            return;
          }
          trifoldOpen = true;
          pauseOtherMediaForTrifold();
          trifoldPanel.hidden = false;
          trifoldPanel.setAttribute('aria-hidden', 'false');
          trifoldPanel.classList.add('is-open');
          trifoldButton.setAttribute('aria-expanded', 'true');
          requestTrifoldPlayback();
          try {
            trifoldPanel.focus({ preventScroll: true });
          } catch (_) {
            trifoldPanel.focus();
          }
        }

        trifoldButton.addEventListener('click', (event) => {
          event.stopPropagation();
          if (trifoldOpen) {
            closeTrifoldPanel();
          } else {
            openTrifoldPanel();
          }
        });

        closePanelButton.addEventListener('click', (event) => {
          event.stopPropagation();
          closeTrifoldPanel();
          try {
            trifoldButton.focus({ preventScroll: true });
          } catch (_) {
            trifoldButton.focus();
          }
        });

        trifoldPanel.addEventListener('click', (event) => {
          if (event.target === trifoldPanel) {
            event.stopPropagation();
            closeTrifoldPanel();
          }
        });

        trifoldPanel.addEventListener('keydown', (event) => {
          if (event.key === 'Escape') {
            event.stopPropagation();
            closeTrifoldPanel();
            try {
              trifoldButton.focus({ preventScroll: true });
            } catch (_) {
              trifoldButton.focus();
            }
          }
        });

        const message = document.createElement('div');
        message.className = 'pre-form-video-overlay__message';
        message.textContent = 'Preparing form sequence';

        const skipHint = document.createElement('div');
        skipHint.className = 'pre-form-video-overlay__skip-hint';
        skipHint.innerHTML = `
          <div style="font-size: clamp(0.85rem, 2vw, 1rem); letter-spacing: 0.14em;">
            CLICK ANYWHERE OR ANY <span id="videoKeyWordSkip" style="text-decoration: underline; cursor: pointer;">KEY</span> TO SKIP
          </div>
        `;
        skipHint.style.cssText = 'cursor: pointer; pointer-events: auto;';
        skipHint.hidden = true;
        
        // Add click handler for KEY easter egg in skipHint
        skipHint.addEventListener('click', (event) => {
          const keyWord = event.target.closest('#videoKeyWordSkip');
          if (keyWord) {
            event.stopPropagation();
            skipHint.hidden = true;
            if (message) {
              message.style.display = '';
              message.textContent = 'Playing easter egg';
            }
            video.pause();
            playKeyEasterEggVideo();
          }
        });

        overlay.append(freezeFrameGrid, videoGlitchWrapper, message, skipHint);
        document.body.appendChild(overlay);

        function createSkipController() {
          if (!overlay.isConnected) {
            return {
              promise: Promise.resolve(),
              cleanup() {}
            };
          }

          let resolved = false;
          let resolveSkip;
          const skipPromise = new Promise((resolve) => {
            resolveSkip = resolve;
          });
          let cleaned = false;

          function cleanup() {
            if (cleaned) {
              return;
            }
            cleaned = true;
            overlay.removeEventListener('pointerdown', handlePointerDown, true);
            overlay.removeEventListener('keydown', handleKeyDown);
            overlay.classList.remove('pre-form-video-overlay--skippable');
          }

          function handlePointerDown(event) {
            if (
              event &&
              event.target &&
              event.target.closest(
                '.pre-form-video-overlay__start, .pre-form-trifold-button, .pre-form-trifold-panel'
              )
            ) {
              return;
            }
            
            // Check if clicking on the KEY word for easter egg
            if (event && event.target) {
              const keyWord = event.target.closest('#videoKeyWordSkip');
              if (keyWord) {
                event.stopPropagation();
                if (resolved) {
                  return;
                }
                resolved = true;
                closeTrifoldPanel();
                if (skipHint) {
                  skipHint.hidden = true;
                }
                if (message) {
                  message.style.display = '';
                  message.textContent = 'Playing easter egg';
                }
                try {
                  video.pause();
                } catch (_) {
                  // Ignore pause errors
                }
                cleanup();
                // Play key2.mp4 easter egg and wait for it to complete
                playKeyEasterEggVideo().then(() => {
                  // After easter egg completes, resolve to continue sequence
                  if (typeof resolveSkip === 'function') {
                    resolveSkip('easter-egg-complete');
                  }
                }).catch((error) => {
                  console.warn(' Easter egg playback error:', error);
                  if (typeof resolveSkip === 'function') {
                    resolveSkip('easter-egg-error');
                  }
                });
                return;
              }
            }
            
            if (resolved) {
              return;
            }
            resolved = true;
            closeTrifoldPanel();
            if (message) {
              message.style.display = '';
              message.textContent = 'Skipping';
            }
            if (skipHint) {
              skipHint.hidden = true;
            }
            try {
              video.pause();
            } catch (_) {
              // Ignore pause errors
            }
            cleanup();
            if (typeof resolveSkip === 'function') {
              resolveSkip('skip');
            }
          }

          function handleKeyDown(event) {
            if (!event) {
              return;
            }
            if (
              event.target &&
              event.target.closest(
                '.pre-form-video-overlay__start, .pre-form-trifold-button, .pre-form-trifold-panel'
              )
            ) {
              return;
            }
            if (event.key === 'Enter' || event.key === ' ') {
              event.preventDefault();
              handlePointerDown(event);
            }
          }

          overlay.classList.add('pre-form-video-overlay--skippable');
          overlay.addEventListener('pointerdown', handlePointerDown, { capture: true });
          overlay.addEventListener('keydown', handleKeyDown);

          if (!overlay.contains(document.activeElement)) {
            try {
              overlay.focus({ preventScroll: true });
            } catch (_) {
              overlay.focus();
            }
          }

          return {
            promise: skipPromise,
            cleanup
          };
        }

        function captureGlitchedFreezeFrame() {
          const canvas = document.createElement('canvas');
          canvas.width = video.videoWidth || 640;
          canvas.height = video.videoHeight || 480;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
          
          const frameCount = parseInt(freezeFrameGrid.dataset.frameCount || '0');
          const hasEasterEgg = freezeFrameGrid.dataset.hasEasterEgg === 'true';
          
          // Ring pattern positions (3x3 grid):
          // With easter egg: [1,2, 4,5, 6,7,8] (skip 0,3 where easter egg is)
          // Without easter egg: [0,1,2, 6,7,8] (top and bottom rows only)
          const ringPositions = hasEasterEgg 
            ? [1, 2, 4, 5, 6, 7, 8]     // Skip positions 0,3 (easter egg occupies top-left + middle-left)
            : [0, 1, 2, 6, 7, 8];        // Top and bottom rows only
          
          if (frameCount >= ringPositions.length) {
            return; // Grid is full
          }
          
          const gridPosition = ringPositions[frameCount];
          const row = Math.floor(gridPosition / 3) + 1;
          const col = (gridPosition % 3) + 1;
          
          const freezeFrame = document.createElement('div');
          freezeFrame.style.cssText = `opacity:0; transform:scale(0.85); transition:all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1); overflow:hidden; box-shadow:0 4px 16px rgba(0,0,0,0.6); position:relative; grid-row:${row}; grid-column:${col}; border-radius:6px;`;
          
          // Randomly assign CRT effect (different for each frame)
          const crtEffects = ['freeze-frame-crt', 'freeze-frame-static', 'freeze-frame-colorbars', ''];
          const randomEffect = crtEffects[frameCount % crtEffects.length];
          if (randomEffect) {
            freezeFrame.classList.add(randomEffect);
          }
          
          const img = new Image();
          img.src = canvas.toDataURL();
          img.style.cssText = 'width:100%; height:100%; display:block; object-fit:cover; filter:saturate(1.2) contrast(1.1); border-radius:6px;';
          
          // Add glitch overlay
          const glitchOverlay = document.createElement('div');
          glitchOverlay.style.cssText = 'position:absolute; inset:0; pointer-events:none; background:linear-gradient(45deg, rgba(255,0,100,0.15) 0%, transparent 30%, rgba(0,255,255,0.12) 70%, transparent 100%); mix-blend-mode:screen; animation:glitchPulse 3s ease-in-out infinite; border-radius:6px;';
          
          freezeFrame.appendChild(img);
          freezeFrame.appendChild(glitchOverlay);
          
          freezeFrameGrid.appendChild(freezeFrame);
          freezeFrameGrid.dataset.frameCount = String(frameCount + 1);
          
          requestAnimationFrame(() => {
            freezeFrame.style.opacity = '1';
            freezeFrame.style.transform = 'scale(1)';
          });
        }

        try {
          let videoWarmupScheduled = false;

          for (let sequenceIndex = 0; sequenceIndex < sequence.length; sequenceIndex += 1) {
            const { file } = sequence[sequenceIndex];
            const candidates = buildTrackCandidates(file);
            const resolved = await resolveVideoSource(video, candidates, file);
            if (!resolved) {
              console.warn(` Skipping ${file}  unable to resolve source`, candidates);
              continue;
            }

            try {
              video.currentTime = 0;
            } catch (_) {
              // Ignore seek errors before playback starts
            }

            await playVideoElement(video, overlay, message);
            if (!videoWarmupScheduled) {
              videoWarmupScheduled = true;
              console.log(' Scheduling warmup for remaining pre-form videos');
              scheduleVideoWarmup(sequence, sequenceIndex + 1);
            }
            // Hide message and show skip hint instead (don't duplicate text)
            message.style.display = 'none';
            if (skipHint) {
              skipHint.hidden = false;
            }
            const skipController = createSkipController();
            await Promise.race([waitForVideoEnd(video), skipController.promise]);
            skipController.cleanup();
            if (skipHint) {
              skipHint.hidden = true;
            }

            // Capture freeze frame before moving to next
            try {
              captureGlitchedFreezeFrame();
            } catch (error) {
              console.warn(' Failed to capture freeze frame:', error);
            }

            video.pause();
            message.style.display = ''; // Show message again
            message.textContent = 'Preparing form sequence';
          }
        } finally {
          video.pause();
          closeTrifoldPanel({ silent: true });
          try {
            trifoldAudio.pause();
          } catch (_) {
            // ignore
          }
          
          // Clean up glitch interval
          if (glitchInterval) {
            clearInterval(glitchInterval);
          }
          
          // Brief pause to show complete grid before closing
          await new Promise(resolve => setTimeout(resolve, 1500));
          
          if (overlay.parentNode) {
            overlay.parentNode.removeChild(overlay);
          }
        }
      }

      async function resolveVideoSource(video, candidates, label) {
        if (!video || !Array.isArray(candidates)) {
          return null;
        }

        for (const candidate of candidates) {
          try {
            // Don't clear src immediately - keep previous video showing until new one loads
            await loadVideoCandidate(video, candidate);
            console.log(` Loaded ${label} from ${candidate}`);
            return candidate;
          } catch (error) {
            console.warn(` Failed to load ${label} from ${candidate}:`, error);
            // Only clear and reset if loading failed
            try {
              video.pause();
              video.removeAttribute('src');
              video.load();
            } catch (_) {
              // Ignore reset errors
            }
          }
        }

        return null;
      }

      function loadVideoCandidate(video, src) {
        return new Promise((resolve, reject) => {
          const cleanup = () => {
            video.removeEventListener('loadeddata', onLoaded);
            video.removeEventListener('error', onError);
          };

          const onLoaded = () => {
            cleanup();
            resolve();
          };

          const onError = () => {
            cleanup();
            reject(new Error(`Unable to load ${src}`));
          };

          try {
            video.addEventListener('loadeddata', onLoaded, { once: true });
            video.addEventListener('error', onError, { once: true });
            video.src = src;
            video.load();
          } catch (error) {
            cleanup();
            reject(error);
          }
        });
      }

      function createInitialPrompt(overlay) {
        // Always create the prompt with the KEY word upfront
        let prompt = overlay.querySelector('.pre-form-video-overlay__start');
        if (prompt) {
          return prompt;
        }
        
        prompt = document.createElement('div');
        prompt.className = 'pre-form-video-overlay__start';
        prompt.style.cssText = 'cursor: pointer; pointer-events: auto;';
        prompt.innerHTML = `
          <div style="font-size: clamp(0.85rem, 2vw, 1rem); letter-spacing: 0.14em;">
            CLICK ANYWHERE OR ANY <span id="videoKeyWord" style="text-decoration: underline; cursor: pointer;">KEY</span> TO SKIP
          </div>
        `;
        overlay.appendChild(prompt);
        return prompt;
      }

      async function playVideoElement(video, overlay, messageEl) {
        // Create the prompt upfront so KEY is always visible
        const prompt = createInitialPrompt(overlay);
        
        // Attempt playback until it starts or a non-blocking error occurs
        for (;;) {
          try {
            const playAttempt = video.play();
            if (playAttempt && typeof playAttempt.then === 'function') {
              await playAttempt;
            }
            // If autoplay succeeds, hide the message and remove prompt
            if (messageEl) {
              messageEl.textContent = 'Playing pre-form video';
            }
            if (prompt && prompt.parentNode) {
              prompt.style.opacity = '0';
              setTimeout(() => prompt.remove(), 300);
            }
            return;
          } catch (error) {
            if (error && error.name === 'NotAllowedError') {
              await requireUserGesture(video, overlay, messageEl);
            } else {
              throw error;
            }
          }
        }
      }

      function requireUserGesture(video, overlay, messageEl) {
        return new Promise((resolve) => {
          // Ensure prompt exists (it should have been created by playVideoElement)
          let prompt = overlay.querySelector('.pre-form-video-overlay__start');
          if (!prompt) {
            prompt = createInitialPrompt(overlay);
          }

          // Set up interaction handlers
          let interactionTriggered = false;

          const handleInteraction = (isKeyEasterEgg = false) => {
            if (interactionTriggered) {
              return;
            }
            interactionTriggered = true;
            
            prompt.style.opacity = '0';
            prompt.style.pointerEvents = 'none';
            
            document.removeEventListener('keydown', handleKeyDown);
            prompt.removeEventListener('click', handleClick);
            
            if (isKeyEasterEgg) {
              if (messageEl) {
                messageEl.style.display = '';
                messageEl.textContent = 'Playing easter egg';
              }
              prompt.remove();
              playKeyEasterEggVideo().then(async () => {
                // After easter egg, we need to reload intro1.mp4 which is already the video.src
                // The video element now has key2.mp4, so we need to restore the sequence
                if (messageEl) {
                  messageEl.textContent = 'Preparing intro sequence';
                }
                
                // Reload intro1.mp4 (the original first video in the sequence)
                const introCandidates = buildTrackCandidates('intro1.mp4');
                const introResolved = await resolveVideoSource(video, introCandidates, 'intro1.mp4');
                
                if (!introResolved) {
                  console.warn(' Unable to reload intro1.mp4 after easter egg');
                  resolve();
                  return;
                }
                
                try {
                  video.currentTime = 0;
                } catch (_) {}
                
                const attempt = video.play();
                if (attempt && typeof attempt.then === 'function') {
                  attempt.then(() => {
                    if (messageEl) {
                      messageEl.textContent = 'Playing pre-form video';
                    }
                    resolve();
                  }).catch((error) => {
                    console.warn(' Video playback blocked after easter egg:', error);
                    resolve();
                  });
                } else {
                  if (messageEl) {
                    messageEl.textContent = 'Playing pre-form video';
                  }
                  resolve();
                }
              });
            } else {
              const attempt = video.play();
              if (attempt && typeof attempt.then === 'function') {
                attempt.then(() => {
                  prompt.remove();
                  if (messageEl) {
                    messageEl.style.display = '';
                    messageEl.textContent = 'Playing pre-form video';
                  }
                  resolve();
                }).catch((error) => {
                  console.warn(' Video playback blocked after user gesture:', error);
                  interactionTriggered = false;
                  prompt.style.opacity = '1';
                  prompt.style.pointerEvents = 'auto';
                  if (messageEl) {
                    messageEl.style.display = '';
                    messageEl.textContent = 'Click to continue the form sequence';
                  }
                });
              } else {
                prompt.remove();
                if (messageEl) {
                  messageEl.style.display = '';
                  messageEl.textContent = 'Playing pre-form video';
                }
                resolve();
              }
            }
          };

          const handleClick = (event) => {
            const keyWord = event.target.closest('#videoKeyWord');
            if (keyWord) {
              event.stopPropagation();
              handleInteraction(true);
              return;
            }
            handleInteraction(false);
          };

          const handleKeyDown = (event) => {
            handleInteraction(false);
          };

          prompt.addEventListener('click', handleClick);
          document.addEventListener('keydown', handleKeyDown, { once: true });
          
          // Hide the message element since the prompt has the interaction text
          if (messageEl) {
            messageEl.style.display = 'none';
          }
          try {
            overlay.focus({ preventScroll: true });
          } catch (_) {
            // ignore
          }
        });
      }

      function waitForVideoEnd(video) {
        return new Promise((resolve) => {
          const cleanup = () => {
            video.removeEventListener('ended', onEnded);
            video.removeEventListener('error', onError);
          };

          const onEnded = () => {
            cleanup();
            resolve();
          };

          const onError = () => {
            cleanup();
            resolve();
          };

          video.addEventListener('ended', onEnded, { once: true });
          video.addEventListener('error', onError, { once: true });
        });
      }

      async function playKeyEasterEggVideo() {
        return new Promise(async (resolve) => {
          // Use the existing overlay and video element from playPreFormVideos
          const overlay = document.querySelector('.pre-form-video-overlay');
          const video = overlay ? overlay.querySelector('video') : null;
          const message = overlay ? overlay.querySelector('.pre-form-video-overlay__message') : null;
          const skipHint = overlay ? overlay.querySelector('.pre-form-video-overlay__skip-hint') : null;
          const freezeFrameGrid = overlay ? overlay.querySelector('.freeze-frame-grid') : null;
          
          if (!overlay || !video) {
            console.warn(' Video overlay not found for easter egg');
            resolve();
            return;
          }
        
          // Load and play key2.mp4
          const candidates = buildTrackCandidates('key2.mp4');
          const videoResolved = await resolveVideoSource(video, candidates, 'key2.mp4');
          if (!videoResolved) {
            console.warn(' Unable to load key2.mp4');
            resolve();
            return;
          }
        
          try {
            video.currentTime = 0;
          } catch (_) {}
          
          // Hide message and show skip hint (don't duplicate text)
          if (message) message.style.display = 'none';
          if (skipHint) skipHint.hidden = false;
          
          // Auto-play the easter egg
          const playAttempt = video.play();
          if (playAttempt && typeof playAttempt.catch === 'function') {
            await playAttempt.catch((error) => {
              console.warn(' Easter egg auto-play blocked:', error);
            });
          }
        
          // Wait for video to end or be skipped
          function createSkipControllerLocal() {
            let skipResolved = false;
            let resolveSkip;
            const skipPromise = new Promise((res) => {
              resolveSkip = res;
            });
            let cleaned = false;

            function cleanup() {
              if (cleaned) return;
              cleaned = true;
              overlay.removeEventListener('pointerdown', handlePointerDown, true);
              overlay.removeEventListener('keydown', handleKeyDown);
              overlay.classList.remove('pre-form-video-overlay--skippable');
            }

            function handlePointerDown(event) {
              if (
                event &&
                event.target &&
                event.target.closest('.pre-form-trifold-button, .pre-form-trifold-panel')
              ) {
                return;
              }
              if (skipResolved) return;
              skipResolved = true;
              if (message) {
                message.style.display = '';
                message.textContent = 'Skipping';
              }
              if (skipHint) skipHint.hidden = true;
              try { video.pause(); } catch (_) {}
              cleanup();
              if (typeof resolveSkip === 'function') resolveSkip('skip');
            }

            function handleKeyDown(event) {
              if (!event) return;
              if (event.key === 'Enter' || event.key === ' ') {
                event.preventDefault();
                handlePointerDown(event);
              }
            }

            overlay.classList.add('pre-form-video-overlay--skippable');
            overlay.addEventListener('pointerdown', handlePointerDown, { capture: true });
            overlay.addEventListener('keydown', handleKeyDown);

            return { promise: skipPromise, cleanup };
          }
          
          const skipController = createSkipControllerLocal();
          await Promise.race([waitForVideoEnd(video), skipController.promise]);
          skipController.cleanup();
        
          // Capture freeze frame for key2.mp4 - takes top-left + middle-left (2x1 vertical)
          if (freezeFrameGrid && video.videoWidth > 0) {
            try {
              const canvas = document.createElement('canvas');
              canvas.width = video.videoWidth || 640;
              canvas.height = video.videoHeight || 480;
              const ctx = canvas.getContext('2d');
              ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
              
              // Mark grid as having easter egg (changes ring pattern for other frames)
              freezeFrameGrid.dataset.hasEasterEgg = 'true';
              
              // Easter egg takes top-left + middle-left (row 1-2, col 1)
              const freezeFrame = document.createElement('div');
              freezeFrame.style.cssText = 'opacity:0; transform:scale(0.85); transition:all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1); overflow:hidden; box-shadow:0 8px 24px rgba(255,215,0,0.4); position:relative; grid-row:1 / span 2; grid-column:1; border:2px solid rgba(255,215,0,0.3); border-radius:8px;';
              freezeFrame.dataset.easterEgg = 'true';
              // Give easter egg a special color bars effect
              freezeFrame.classList.add('freeze-frame-colorbars');
              
              const img = new Image();
              img.src = canvas.toDataURL();
              img.style.cssText = 'width:100%; height:100%; display:block; object-fit:cover; filter:saturate(1.4) contrast(1.15) brightness(1.1); border-radius:8px;';
              
              const glitchOverlay = document.createElement('div');
              glitchOverlay.style.cssText = 'position:absolute; inset:0; pointer-events:none; background:linear-gradient(45deg, rgba(255,215,0,0.25) 0%, transparent 30%, rgba(255,0,255,0.18) 70%, transparent 100%); mix-blend-mode:screen; animation:glitchPulse 3s ease-in-out infinite; border-radius:8px;';
              
              freezeFrame.appendChild(img);
              freezeFrame.appendChild(glitchOverlay);
              
              freezeFrameGrid.appendChild(freezeFrame);
              requestAnimationFrame(() => {
                freezeFrame.style.opacity = '1';
                freezeFrame.style.transform = 'scale(1)';
              });
            } catch (error) {
              console.warn(' Failed to capture easter egg freeze frame:', error);
            }
          }
          
          video.pause();
          if (skipHint) skipHint.hidden = true;
          if (message) message.style.display = ''; // Show message again
          
          // Resolve the promise to signal completion
          resolve();
        });
      }
        

      async function playIntroVideoSequence() {
        return playPreFormVideos();
      }

      function showEsrbCard(panelEl, formEl) {
        if (!panelEl) {
          if (formEl) {
            formEl.classList.remove('focus-form--hidden');
            formEl.removeAttribute('aria-hidden');
          }
          return Promise.resolve();
        }

        return new Promise((resolve) => {
          const overlay = document.createElement('div');
          overlay.className = 'esrb-card-overlay';
          overlay.setAttribute('role', 'presentation');
          overlay.setAttribute('aria-hidden', 'true');
          overlay.innerHTML = `
            <div class="esrb-card" role="presentation" aria-hidden="true">
              <div class="esrb-card__banner" aria-hidden="true">
                <span class="esrb-card__banner-text">NOT FOR EVERYONE</span>
                <span class="esrb-card__strike"><span style="text-decoration: line-through;">EVERYONE</span></span>
              </div>
              <div class="esrb-card__body">
                <div class="esrb-card__rating" aria-hidden="true"><span style="text-decoration: line-through;">E</span></div>
                <p class="esrb-card__descriptor">BUT, I WOULDN'T SAY I'M PARTICULARLY MATURE.</p>
              </div>
              <div class="esrb-card__footer" aria-hidden="true">
                <div style="font-size: clamp(1rem, 2.2vw, 1.4rem); margin-bottom: 0.4rem;">NOT YET RATED</div>
                <div style="font-size: clamp(0.85rem, 2vw, 1.15rem); letter-spacing: 0.1em;">100/100, BUT I'M BANKING ON IT.</div>
              </div>
            </div>
          `;

          if (formEl) {
            formEl.classList.add('focus-form--hidden');
            formEl.setAttribute('aria-hidden', 'true');
          }

          let finished = false;
          let fadeTimer = null;
          let cleanupTimer = null;

          function cleanup() {
            if (finished) {
              return;
            }
            finished = true;
            clearTimeout(fadeTimer);
            clearTimeout(cleanupTimer);
            overlay.removeEventListener('transitionend', handleTransitionEnd);
            if (overlay.parentNode) {
              overlay.parentNode.removeChild(overlay);
            }
            if (formEl) {
              formEl.classList.remove('focus-form--hidden');
              formEl.removeAttribute('aria-hidden');
              const firstOption = formEl.querySelector('.focus-option');
              if (firstOption) {
                try {
                  firstOption.focus({ preventScroll: true });
                } catch (_) {
                  firstOption.focus();
                }
              }
            }
            resolve();
          }

          function handleTransitionEnd(event) {
            if (event.target === overlay && overlay.classList.contains('fade-out')) {
              cleanup();
            }
          }

          panelEl.appendChild(overlay);

          requestAnimationFrame(() => {
            overlay.classList.add('visible');
          });

          overlay.addEventListener('transitionend', handleTransitionEnd);

          const displayDuration = 2000;
          const cleanupBuffer = 700;
          fadeTimer = setTimeout(() => {
            overlay.classList.add('fade-out');
          }, displayDuration);
          cleanupTimer = setTimeout(() => {
            cleanup();
          }, displayDuration + cleanupBuffer);
        });
      }

      function createAudioTrack(fileName) {
        const candidates = buildTrackCandidates(fileName);
        const audio = new Audio();
        audio.preload = 'auto';
        audio.crossOrigin = 'anonymous';
        let candidateIndex = 0;

        const tryNextSource = () => {
          if (candidateIndex >= candidates.length) {
            console.warn(`Unable to resolve audio source for ${fileName}. Tried:`, candidates);
            audio.removeEventListener('error', handleError);
            return;
          }
          const candidate = candidates[candidateIndex];
          candidateIndex += 1;
          audio.src = candidate;
          audio.load();
        };

        const handleError = () => {
          if (audio.networkState === HTMLMediaElement.NETWORK_NO_SOURCE) {
            tryNextSource();
          }
        };

        const handleCanPlay = () => {
          audio.removeEventListener('error', handleError);
        };

        audio.addEventListener('error', handleError);
        audio.addEventListener('canplay', handleCanPlay, { once: true });

        tryNextSource();
        return audio;
      }

      const baseTrack = createAudioTrack('EA.mp3');
      const encoreTrack = createAudioTrack('EA2.mp3');
      const superEncoreTrack = createAudioTrack('EA3.mp3');
      const finaleTrack = createAudioTrack('E4.mp3');
      // Note: strumPreviewTrack is now created earlier (before video sequence) for immediate button click feedback

      const tracks = [baseTrack, encoreTrack, superEncoreTrack, finaleTrack];
      tracks.forEach((audio) => {
        audio.preload = 'auto';
        audio.crossOrigin = 'anonymous';
        getOriginalVolume(audio);
      });

      // Note: strumPreviewTrack configuration is now done earlier (before video sequence)

      const encoreTracks = [encoreTrack, superEncoreTrack, finaleTrack];
      const encoreLabels = [
        'Encore  playing EA2.mp3',
        'Super Encore  playing EA3.mp3',
        'Finale  playing E4.mp3'
      ];
      const DEFAULT_ESCAPE_LABEL = 'Get me out of here!';
      const ENCORE_LABEL = 'ENCORE!';
      const NEAR_DISTANCE = 72;

      // Note: COLOR_SEQUENCE, selectionOrder, toneByButton, selectionHistory, selectionSteps,
      // strumStopTimeout, and isInverted are now defined earlier (before video sequence) for immediate button interactivity
      let encoreIndex = 0;
      let escapeLabelState = DEFAULT_ESCAPE_LABEL;

      let audioContext = null;
      let analyser = null;
      let analyserData = null;
      let analyserGain = null;
      const mediaSourceMap = new WeakMap();
      let visualizerFrameId = null;
      let activeVisualizerTrack = null;
      const tileWidthState = new WeakMap();
      const tileHeightState = new WeakMap();
      const tileSaturationState = new WeakMap();

      function ensureAudioEngine() {
        const AudioContextClass = window.AudioContext || window.webkitAudioContext;
        if (!AudioContextClass) {
          return false;
        }
        if (!audioContext) {
          audioContext = new AudioContextClass();
          analyser = audioContext.createAnalyser();
          analyser.fftSize = 256;
          analyser.smoothingTimeConstant = 0.78;
          analyserData = new Uint8Array(analyser.frequencyBinCount);
          analyserGain = audioContext.createGain();
          analyserGain.gain.value = 1;
          analyser.connect(analyserGain);
          analyserGain.connect(audioContext.destination);
        } else if (audioContext.state === 'suspended') {
          audioContext.resume().catch(() => {});
        }
        return true;
      }

      function attachAudioToAnalyser(audio) {
        if (!ensureAudioEngine() || !audioContext || !analyser) {
          return;
        }
        let source = mediaSourceMap.get(audio);
        if (!source) {
          source = audioContext.createMediaElementSource(audio);
          source.connect(analyser);
          mediaSourceMap.set(audio, source);
        }
      }

      function getVisualizerTargets() {
        // Always use original option buttons for visualizer
        return optionButtons;
      }

      function getVisualizerContainer() {
        // Always use original options container for visualizer
        return optionsContainer;
      }

      function renderVisualizer() {
        if (!analyser || !analyserData) {
          visualizerFrameId = null;
          return;
        }
        if (activeVisualizerTrack && (activeVisualizerTrack.paused || activeVisualizerTrack.ended)) {
          stopVisualizerIfIdle(true);
          return;
        }

        const targets = getVisualizerTargets();
        if (!targets.length) {
          visualizerFrameId = null;
          return;
        }

        analyser.getByteFrequencyData(analyserData);

        const buttonCount = targets.length;
        const step = Math.max(1, Math.floor(analyserData.length / buttonCount));
        const breakawayTargets = visualizerBreakawayActive ? new Set(wordleSelectionButtons) : null;

        targets.forEach((button, index) => {
          const dataIndex = Math.min(analyserData.length - 1, index * step);
          const magnitude = analyserData[dataIndex] / 255;
          const eased = Math.pow(magnitude, 1.35);
          const isBreakawayTile = breakawayTargets ? breakawayTargets.has(button) : false;
          const widthBoost = isBreakawayTile ? 1.85 : 1.2;
          const heightDrop = isBreakawayTile ? 0.65 : 0.45;
          const saturationBoost = isBreakawayTile ? 1.15 : 0.6;
          const targetWidth = 1 + eased * widthBoost;
          const targetHeight = Math.max(0.45, 1 - eased * heightDrop);
          const targetSaturation = 1 + eased * saturationBoost;

          const currentWidth = tileWidthState.get(button) ?? 1;
          const currentHeight = tileHeightState.get(button) ?? 1;
          const currentSaturation = tileSaturationState.get(button) ?? 1;
          const nextWidth = currentWidth + (targetWidth - currentWidth) * 0.25;
          const nextHeight = currentHeight + (targetHeight - currentHeight) * 0.3;
          const nextSaturation = currentSaturation + (targetSaturation - currentSaturation) * 0.3;

          tileWidthState.set(button, nextWidth);
          tileHeightState.set(button, nextHeight);
          tileSaturationState.set(button, nextSaturation);
          button.style.setProperty('--visualizer-scale-x', nextWidth.toFixed(3));
          button.style.setProperty('--visualizer-scale-y', nextHeight.toFixed(3));
          button.style.setProperty('--visualizer-saturate', nextSaturation.toFixed(3));
        });

        visualizerFrameId = requestAnimationFrame(renderVisualizer);
      }

      function startVisualizerFor(audio) {
        const targets = getVisualizerTargets();
        if (!targets.length) {
          return;
        }
        const container = getVisualizerContainer();
        if (container) {
          container.classList.add('visualizer-active');
        }
        // Keep wordle tiles separate from visualizer
        if (wordleSelectionTilesEl) {
          wordleSelectionTilesEl.classList.remove('visualizer-active');
        }
        attachAudioToAnalyser(audio);
        activeVisualizerTrack = audio;
          if (!visualizerFrameId) {
            visualizerFrameId = requestAnimationFrame(renderVisualizer);
          }
        }

      function stopVisualizerIfIdle(force) {
        if (!force && activeVisualizerTrack && !activeVisualizerTrack.paused && !activeVisualizerTrack.ended) {
          return;
        }
        if (visualizerFrameId) {
          cancelAnimationFrame(visualizerFrameId);
          visualizerFrameId = null;
        }
        const allButtons = [...optionButtons, ...wordleSelectionButtons];
        allButtons.forEach((button) => {
          tileWidthState.delete(button);
          tileHeightState.delete(button);
          tileSaturationState.delete(button);
          button.style.removeProperty('--visualizer-scale-x');
          button.style.removeProperty('--visualizer-scale-y');
          button.style.removeProperty('--visualizer-saturate');
        });
        if (optionsContainer) {
          optionsContainer.classList.remove('visualizer-active');
        }
        if (wordleSelectionTilesEl) {
          wordleSelectionTilesEl.classList.remove('visualizer-active');
        }
        deactivateVisualizerBreakaway();
        activeVisualizerTrack = null;
      }

      function getOriginalVolume(audio) {
        if (!audio) {
          return 1;
        }
        const stored = audio.dataset && audio.dataset.originalVolume;
        const parsed = stored ? Number.parseFloat(stored) : Number.NaN;
        if (!Number.isNaN(parsed)) {
          return parsed;
        }
        const initial = typeof audio.volume === 'number' ? audio.volume : 1;
        if (audio.dataset) {
          audio.dataset.originalVolume = String(initial);
        }
        return initial;
      }

      function resetAudioVolume(audio) {
        if (!audio) {
          return;
        }
        const original = getOriginalVolume(audio);
        audio.volume = Math.max(0, Math.min(1, original));
      }

      function rampAudioVolume(audio, targetVolume, duration, options = {}) {
        if (!audio) {
          return;
        }
        const startVolume = typeof options.from === 'number' ? options.from : audio.volume;
        const clampedTarget = Math.max(0, Math.min(1, targetVolume));
        const startTime = performance.now();
        const totalDuration = Math.max(0, duration || 0) * 1000;
        const easing = typeof options.easing === 'function' ? options.easing : (t) => 1 - Math.pow(1 - t, 3);

        function step(now) {
          const elapsed = now - startTime;
          const progress = totalDuration === 0 ? 1 : Math.min(1, elapsed / totalDuration);
          const eased = easing(progress);
          const nextVolume = startVolume + (clampedTarget - startVolume) * eased;
          audio.volume = Math.max(0, Math.min(1, nextVolume));
          if (progress < 1 && (!options.cancelled || !options.cancelled())) {
            requestAnimationFrame(step);
          } else {
            audio.volume = Math.max(0, Math.min(1, clampedTarget));
            if (typeof options.onComplete === 'function') {
              options.onComplete();
            }
          }
        }

        requestAnimationFrame(step);
      }

      function fadeInAudio(audio, duration = 1.8) {
        if (!audio) {
          return;
        }
        const original = getOriginalVolume(audio);
        audio.volume = 0;
        rampAudioVolume(audio, original, duration, {
          cancelled: () => audio.paused || audio.ended
        });
      }

      // Note: stopStrumPreview() and playStrumPreview() are now defined earlier (before video sequence)
      // This extended version adds audio engine and volume ramping
      function stopStrumPreview() {
        if (strumStopTimeout) {
          clearTimeout(strumStopTimeout);
          strumStopTimeout = null;
        }
        if (!strumPreviewTrack) {
          return;
        }
        strumPreviewTrack.pause();
        // Don't reset currentTime - we set it to 2.0 before playing anyway
        resetAudioVolume(strumPreviewTrack);
      }

      function playStrumPreviewExtended() {
        if (!strumPreviewTrack) {
          return;
        }
        ensureAudioEngine();
        stopStrumPreview();
        resetAudioVolume(strumPreviewTrack);
        try {
          const cueTime = (() => {
            const fallback = 2;
            const duration = Number.isFinite(strumPreviewTrack.duration)
              ? strumPreviewTrack.duration
              : Number.NaN;
            if (Number.isFinite(duration)) {
              const safeDuration = Math.max(0, duration - 0.25);
              return Math.min(fallback, safeDuration);
            }
            return fallback;
          })();
          strumPreviewTrack.currentTime = cueTime;
        } catch (error) {
          console.warn('Unable to prime strum preview audio', error);
        }

        const scheduleFadeOut = () => {
          strumStopTimeout = setTimeout(() => {
            rampAudioVolume(strumPreviewTrack, 0, 0.22, {
              cancelled: () => strumPreviewTrack.paused || strumPreviewTrack.ended,
              onComplete: stopStrumPreview
            });
          }, 360);
        };

        const attempt = strumPreviewTrack.play();
        if (attempt && typeof attempt.then === 'function') {
          attempt.then(scheduleFadeOut).catch(() => {});
        } else {
          scheduleFadeOut();
        }
      }

      function getToneClass(button) {
        const rawIndex = toneByButton.get(button);
        if (typeof rawIndex !== 'number') {
          return COLOR_SEQUENCE[0];
        }
        const index = ((rawIndex % COLOR_SEQUENCE.length) + COLOR_SEQUENCE.length) % COLOR_SEQUENCE.length;
        return COLOR_SEQUENCE[index];
      }

      // Note: getButtonColorKey(), setInversionState(), and evaluateInversionTrigger()
      // are now defined earlier (before video sequence) for immediate button interactivity

      function updateSubmissionExperienceContent() {
        if (!selectionCloud) {
          return;
        }
        selectionCloud.innerHTML = '';
        if (!selectionOrder.length) {
          return;
        }
        const fragment = document.createDocumentFragment();
        selectionOrder.forEach((button, index) => {
          if (!button) {
            return;
          }
          const value = button.dataset.value || button.textContent.trim();
          const chip = document.createElement('div');
          chip.className = 'selection-chip';
          chip.setAttribute('aria-hidden', 'true');
          chip.setAttribute('role', 'presentation');
          chip.setAttribute('tabindex', '-1');
          chip.textContent = value;
          const toneClass = getToneClass(button);
          if (toneClass) {
            chip.classList.add(toneClass);
          }
          chip.style.setProperty('--chip-delay', `${index * 0.08}s`);
          fragment.appendChild(chip);
        });
        selectionCloud.appendChild(fragment);
      }

      function showSubmissionExperience() {
        if (!selectionExperience) {
          return;
        }
        updateSubmissionExperienceContent();
        selectionExperience.classList.add('visible');
        selectionExperience.setAttribute('aria-hidden', 'false');
        if (panel) {
          panel.classList.add('submitting');
          requestAnimationFrame(() => panel.classList.add('submitted'));
        }
      }

      function hideSubmissionExperience() {
        if (selectionExperience) {
          selectionExperience.classList.remove('visible');
          selectionExperience.setAttribute('aria-hidden', 'true');
        }
        if (selectionCloud) {
          selectionCloud.innerHTML = '';
        }
        if (panel) {
          panel.classList.remove('submitting');
          panel.classList.remove('submitted');
        }
        stopVisualizerIfIdle(true);
      }

      function refreshSubmissionExperience() {
        if (!panel || !panel.classList.contains('submitted')) {
          return;
        }
        if (!selectionOrder.length) {
          hideSubmissionExperience();
          return;
        }
        updateSubmissionExperienceContent();
      }

      function updateStatus(message) {
        if (statusEl) {
          statusEl.textContent = message || '';
        }
      }

      // Note: triggerPanelShake() is now defined earlier (before video sequence) for immediate button interactivity

      function stopOtherTracks(except) {
        tracks.forEach((audio) => {
          if (audio !== except) {
            audio.pause();
            try {
              audio.currentTime = 0;
            } catch (error) {
              console.warn('Unable to reset audio time', error);
            }
            resetAudioVolume(audio);
            if (audio === baseTrack) {
              sequencePlaying = false;
            }
          }
        });
        if (!except || except.paused) {
          stopVisualizerIfIdle(true);
        }
        updateStartButtonState();
      }

      function handlePlaybackPromise(promise, label, audio, onSuccess) {
        const applyPlayingState = () => {
          updateStatus(label);
          if (audio) {
            startVisualizerFor(audio);
            if (audio === baseTrack) {
              scheduleVisualizerBreakaway();
            } else {
              deactivateVisualizerBreakaway();
            }
          }
          if (typeof onSuccess === 'function') {
            onSuccess();
          }
        };

        if (!promise || typeof promise.then !== 'function') {
          applyPlayingState();
          return;
        }

        promise
          .then(applyPlayingState)
          .catch((error) => {
            console.warn('Audio playback failed.', error);
            updateStatus('Audio unavailable.');
            stopVisualizerIfIdle(true);
            deactivateVisualizerBreakaway();
            if (audio) {
              resetAudioVolume(audio);
            }
            if (escapeButton) {
              escapeButton.disabled = false;
              updateEscapeLabel(false);
            }
            if (audio === baseTrack) {
              sequencePlaying = false;
              updateStartButtonState();
            }
          });
      }

      function playTrack(audio, label) {
        if (audio === baseTrack) {
          sequencePlaying = true;
          updateStartButtonState();
        }
        stopOtherTracks(audio);
        ensureAudioEngine();
        stopStrumPreview();
        try {
          audio.currentTime = 0;
        } catch (error) {
          console.warn('Unable to reset selected audio time', error);
        }
        resetAudioVolume(audio);
        audio.volume = 0;
        const playback = audio.play();
        handlePlaybackPromise(playback, label, audio, () => {
          fadeInAudio(audio);
          if (audio === baseTrack) {
            activateWordlePuzzle();
          }
        });
      }

      function updateButtonPriorityPrefix(button) {
        if (!button) return;
        
        const toneIndex = toneByButton.get(button);
        const originalValue = button.dataset.value || '';
        
        if (typeof toneIndex === 'number') {
          // Add/update P# prefix based on tone index (wraps 0-3)
          const priorityNumber = toneIndex % COLOR_SEQUENCE.length;
          const prefix = `P${priorityNumber}: `;
          button.textContent = prefix + originalValue;
          console.log(`    ${originalValue}  P${priorityNumber}: ${originalValue}`);
        } else {
          // Remove priority prefix when not selected - restore original
          button.textContent = originalValue;
        }
      }

      function applyTone(button, toneIndex) {
        const index = ((toneIndex % COLOR_SEQUENCE.length) + COLOR_SEQUENCE.length) % COLOR_SEQUENCE.length;
        COLOR_SEQUENCE.forEach((cls) => button.classList.remove(cls));
        button.classList.add(COLOR_SEQUENCE[index]);
        toneByButton.set(button, index);
        updateButtonPriorityPrefix(button);
      }

      function clearTone(button) {
        COLOR_SEQUENCE.forEach((cls) => button.classList.remove(cls));
        toneByButton.delete(button);
        updateButtonPriorityPrefix(button);
      }

      function cycleExistingTones() {
        if (selectionOrder.length <= 1) {
          return;
        }
        console.log(' Cycling tones - priority numbers will shift...');
        selectionOrder.slice(0, -1).forEach((btn) => {
          const currentIndex = toneByButton.get(btn) ?? 0;
          applyTone(btn, currentIndex + 1);
          // applyTone calls updateButtonPriorityPrefix, which updates P# based on new tone index
        });
      }

      function getActiveSelections() {
        return selectionOrder.map((btn) => {
          // Use dataset.value to get the original value without P# prefix
          const value = btn.dataset.value || btn.textContent.trim();
          // Strip P#: prefix if present in textContent fallback
          return value.replace(/^P\d+:\s*/, '');
        });
      }

      function updateSelectionStatus(extraMessage) {
        const active = getActiveSelections();
        if (!active.length) {
          hideSubmissionExperience();
          const historyText = selectionHistory.length ? `History: ${selectionHistory.join('  ')}` : '';
          if (extraMessage) {
            const suffix = historyText ? ` | ${historyText}` : '';
            updateStatus(`${extraMessage}  Steps ${selectionSteps}${suffix}`);
          } else if (selectionSteps > 0) {
            const suffix = historyText ? ` | ${historyText}` : '';
            updateStatus(`Steps ${selectionSteps}${suffix}`);
          } else {
            updateStatus('Pick a focus to crack the CELLI code.');
          }
          return;
        }

        if (panel && panel.classList.contains('submitted')) {
          updateSubmissionExperienceContent();
        }

        const historyText = selectionHistory.length ? ` | History: ${selectionHistory.join('  ')}` : '';
        const extraText = extraMessage ? `  ${extraMessage}` : '';
        updateStatus(`Steps ${selectionSteps}: ${active.join('  ')}${historyText}${extraText}`);
        if (wordleFeaturesRevealed) {
          renderWordleSelectionTiles();
        }
      }

      function updateEscapeLabel(near) {
        if (!escapeButton) {
          return;
        }
        const nextLabel = !escapeButton.disabled && near ? ENCORE_LABEL : DEFAULT_ESCAPE_LABEL;
        if (escapeLabelState === nextLabel) {
          return;
        }

        escapeLabelState = nextLabel;
        escapeButton.textContent = nextLabel;
        escapeButton.setAttribute('aria-label', nextLabel);
      }

      function showEscapeButton() {
        if (!escapeButton) {
          return;
        }
        escapeButton.classList.add('visible');
        escapeButton.disabled = true;
        updateEscapeLabel(false);
      }

      function isPointerNearButton(x, y) {
        if (!escapeButton || escapeButton.disabled || !escapeButton.classList.contains('visible')) {
          return false;
        }

        const rect = escapeButton.getBoundingClientRect();
        const withinX = x >= rect.left - NEAR_DISTANCE && x <= rect.right + NEAR_DISTANCE;
        const withinY = y >= rect.top - NEAR_DISTANCE && y <= rect.bottom + NEAR_DISTANCE;
        return withinX && withinY;
      }

      function handlePointerProximity(event) {
        if (!event || !('clientX' in event) || !escapeButton || !escapeButton.classList.contains('visible')) {
          return;
        }

        const near = isPointerNearButton(event.clientX, event.clientY);
        updateEscapeLabel(near);
      }

      function playNextEncoreTrack() {
        const track = encoreTracks[encoreIndex % encoreTracks.length];
        const label = encoreLabels[encoreIndex % encoreLabels.length];
        encoreIndex = (encoreIndex + 1) % encoreTracks.length;
        triggerPanelShake();
        if (escapeButton) {
          escapeButton.disabled = true;
          updateEscapeLabel(false);
        }
        playTrack(track, label);
      }

      optionButtons.forEach(registerOptionButton);

      function registerOptionButton(button) {
        if (!button) {
          return;
        }
        // Ensure button is always enabled and interactive
        button.disabled = false;
        button.removeAttribute('disabled');
        button.removeAttribute('aria-disabled');
        button.setAttribute(
          'aria-pressed',
          button.classList.contains('active-selection') ? 'true' : 'false'
        );
        if (registeredOptionButtons.has(button)) {
          return;
        }
        registeredOptionButtons.add(button);
        button.addEventListener('click', handleOptionButtonClick);
      }

      function refreshOptionButtons() {
        optionButtons = optionsContainer
          ? Array.from(optionsContainer.querySelectorAll('.focus-option'))
          : [];
        optionButtons.forEach((button) => {
          if (button) {
            button.disabled = false;
            button.removeAttribute('disabled');
            button.removeAttribute('aria-disabled');
          }
          registerOptionButton(button);
        });
      }

      function createFocusOptionButton(label) {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'focus-option';
        button.dataset.value = label;
        button.textContent = label;
        return button;
      }

      function handleIDontKnowEasterEgg(button) {
        if (!optionsContainer || !button) {
          return;
        }

        if (iDontKnowStage === 0) {
          const focusButtons = Array.from(optionsContainer.querySelectorAll('.focus-option'));
          const targetIndex = 2;
          const referenceButton = focusButtons[targetIndex] || null;
          if (referenceButton !== button) {
            optionsContainer.insertBefore(button, referenceButton);
          }
          refreshOptionButtons();
          evaluateInversionTrigger();
          iDontKnowStage = 1;
          return;
        }

        if (iDontKnowStage === 1) {
          if (!bitsOfTommyButton || !bitsOfTommyButton.isConnected) {
            bitsOfTommyButton = createFocusOptionButton(BITS_OF_TOMMY_VALUE);
          }
          optionsContainer.insertBefore(
            bitsOfTommyButton,
            optionsContainer.firstElementChild || null
          );
          refreshOptionButtons();
          evaluateInversionTrigger();
          iDontKnowStage = 2;
        }
      }

      // Note: playBleghSpeech() is now defined earlier (before video sequence)
      // This extended version adds stopStrumPreview call
      function playBleghSpeechExtended() {
        const synth = window.speechSynthesis;
        if (!synth || typeof window.SpeechSynthesisUtterance !== 'function') {
          return false;
        }

        stopStrumPreview();
        try {
          synth.cancel();
        } catch (error) {
          console.warn('Unable to cancel speech synthesis preview', error);
        }

        try {
          const utterance = new window.SpeechSynthesisUtterance('blegh.');
          utterance.rate = 0.92;
          utterance.pitch = 0.8;
          synth.speak(utterance);
          return true;
        } catch (error) {
          console.warn('Unable to play speech synthesis preview', error);
        }

        return false;
      }

      function handleOptionButtonClick(event) {
        const button = event.currentTarget;
        if (!button) {
          return;
        }

        const value = button.dataset.value || button.textContent.trim();
        const normalizedValue = value.toUpperCase();
        const isActive = button.classList.contains('active-selection');

        if (normalizedValue === I_DONT_KNOW_VALUE) {
          handleIDontKnowEasterEgg(button);
        }

        let usedBleghPreview = false;
        if (normalizedValue === GAGS_VALUE) {
          usedBleghPreview = playBleghSpeech();
        }
        if (!usedBleghPreview) {
          playStrumPreview();
        }

        handleWordleFocusClick(button);

        if (isActive) {
          button.classList.remove('active-selection');
          button.setAttribute('aria-pressed', 'false');
          clearTone(button);
          const index = selectionOrder.indexOf(button);
          if (index >= 0) {
            selectionOrder.splice(index, 1);
          }
          triggerPanelShake();
          updateSelectionStatus(`Removed ${value}`);
          refreshSubmissionExperience();
          evaluateInversionTrigger();
          updateStartButtonState();
          updateSelectionHint();
          return;
        }

        selectionSteps += 1;
        selectionHistory.push(value);
        button.classList.add('active-selection');
        button.setAttribute('aria-pressed', 'true');
        applyTone(button, 0);
        selectionOrder.push(button);
        cycleExistingTones();
        triggerPanelShake();
        updateSelectionStatus(`Added ${value}`);
        refreshSubmissionExperience();
        evaluateInversionTrigger();
        updateStartButtonState();
        updateSelectionHint();
      }

      if (startButton) {
        startButton.addEventListener('click', () => {
          if (startButton.disabled) {
            return;
          }
          if (selectionOrder.length < MINIMUM_SELECTIONS) {
            triggerPanelShake();
            updateStatus(`Pick at least ${MINIMUM_SELECTIONS} focus areas before submitting.`);
            return;
          }
          
          // Note: Redirect happens after the ramp animation completes
          // See slideButtonDownRamp() for the actual redirect logic
        });
      }

      baseTrack.addEventListener('ended', () => {
        updateStatus('Encore ready. Hover over the red button.');
        if (escapeButton) {
          escapeButton.disabled = false;
          updateEscapeLabel(false);
        }
        stopVisualizerIfIdle(true);
        sequencePlaying = false;
        firstTrackCompleted = true;
        updateStartButtonState();
        advanceFullSequenceToIntro('track-ended');
      });

      encoreTrack.addEventListener('ended', () => {
        updateStatus('Encore complete  ready for one more?');
        if (escapeButton) {
          escapeButton.disabled = false;
          updateEscapeLabel(false);
        }
        stopVisualizerIfIdle(true);
      });

      superEncoreTrack.addEventListener('ended', () => {
        updateStatus('Super Encore complete. Finale unlocked.');
        if (escapeButton) {
          escapeButton.disabled = false;
          updateEscapeLabel(false);
        }
        stopVisualizerIfIdle(true);
      });

      finaleTrack.addEventListener('ended', () => {
        updateStatus('Finale complete. Thank you for your focus!');
        if (escapeButton) {
          escapeButton.disabled = false;
          updateEscapeLabel(false);
        }
        stopVisualizerIfIdle(true);
      });

      if (escapeButton) {
        escapeButton.addEventListener('click', () => {
          if (!escapeButton.classList.contains('visible') || escapeButton.disabled) {
            return;
          }
          playNextEncoreTrack();
        });

        escapeButton.addEventListener('pointerenter', () => updateEscapeLabel(true));
        escapeButton.addEventListener('pointerleave', () => updateEscapeLabel(false));
        escapeButton.addEventListener('focus', () => updateEscapeLabel(true));
        escapeButton.addEventListener('blur', () => updateEscapeLabel(false));
      }

      document.addEventListener('pointermove', handlePointerProximity);
      document.addEventListener('pointerdown', handlePointerProximity);

      tracks.forEach((audio) => {
        audio.addEventListener('pause', () => {
          if (audio !== activeVisualizerTrack || audio.ended || audio.currentTime === 0) {
            stopVisualizerIfIdle(true);
          }
        });
      });

      hideSubmissionExperience();
      updateSelectionStatus();
      updateEscapeLabel(false);
      evaluateInversionTrigger();
      updateSelectionHint();

      // ============================================
      // NEW: Star Rating System
      // ============================================
      let selectedRating = 0;
      const stars = document.querySelectorAll('.star');
      
      stars.forEach(star => {
        star.addEventListener('click', () => {
          selectedRating = parseInt(star.dataset.value);
          updateStars();
        });
        
        star.addEventListener('mouseenter', () => {
          const value = parseInt(star.dataset.value);
          stars.forEach((s, idx) => {
            if (idx < value) {
              s.classList.add('filled');
            } else {
              s.classList.remove('filled');
            }
          });
        });
      });
      
      document.getElementById('starRating').addEventListener('mouseleave', () => {
        updateStars();
      });
      
      function updateStars() {
        stars.forEach((s, idx) => {
          if (idx < selectedRating) {
            s.classList.add('filled');
          } else {
            s.classList.remove('filled');
          }
        });
      }

      // ============================================
      // NEW: Shape Jiggle/Drop & Line Rider Ramp
      // ============================================
      const shapeSquare = document.getElementById('shapeSquare');
      const shapeTriangle = document.getElementById('shapeTriangle');
      const shapeCircle = document.getElementById('shapeCircle');
      const shapePlatform = document.getElementById('shapePlatform');
      const shapes = [shapeSquare, shapeTriangle, shapeCircle];
      // Note: selectionHint is now defined earlier (before video sequence)
      
      let rampActive = false;
      let shapesDropped = false;

      // Note: updateSelectionHint() is now defined earlier (before video sequence)

      if (startButton) {
        startButton.addEventListener('click', (e) => {
          if (startButton.disabled || rampActive) {
            return;
          }
          
          // Check if we have minimum selections before allowing animation
          if (selectionOrder.length < MINIMUM_SELECTIONS) {
            e.preventDefault();
            e.stopPropagation();
            triggerPanelShake();
            updateStatus(`Pick at least ${MINIMUM_SELECTIONS} focus areas before submitting.`);
            return;
          }
          
          e.preventDefault();
          e.stopPropagation();
          
          // First click: jiggle and drop shapes
          if (!shapesDropped) {
            shapesDropped = true;
            
            shapes.forEach((shape, idx) => {
              setTimeout(() => {
                shape.classList.add('jiggle');
                setTimeout(() => {
                  shape.classList.remove('jiggle');
                  shape.classList.add('drop');
                }, 500);
              }, idx * 100);
            });
            
            // After shapes land, bump rating to 5 and show message
            setTimeout(() => {
              // Animate rating to 5 stars
              selectedRating = 5;
              updateStars();
              
              // Update copy text with "Let's bump that to a five...."
              const starRatingCopy = document.getElementById('starRatingCopy');
              if (starRatingCopy) {
                starRatingCopy.textContent = "Let's bump that to a five....";
                starRatingCopy.style.color = 'var(--tone-yellow-bg)';
                starRatingCopy.style.fontWeight = '700';
              }
              
              // Then attach shapes to button and create ramp
              attachShapesToButton();
              setTimeout(() => {
                createRampAndSlideButton();
              }, 100);
            }, 1400);
            
            return;
          }
        }, true); // Use capture to intercept before other handlers
      }
      
      function attachShapesToButton() {
        console.log(' Attaching shapes to submit button - will move together during slide');
        // Don't change position yet - let slideButtonDownRamp handle it
        // Just mark as attached so we know to move them together
        shapePlatform.classList.add('attached');
      }

      function createRampAndSlideButton() {
        if (rampActive) return;
        rampActive = true;
        
        const buttonRect = startButton.getBoundingClientRect();
        // Start from bottom-right corner of button
        const startX = buttonRect.right;
        const startY = buttonRect.bottom;
        const endX = window.innerWidth + 100;
        const endY = window.innerHeight + 100;
        
        console.log(` Creating ramp from button bottom-right (${startX}, ${startY}) to (${endX}, ${endY})`);
        
        // Create SVG for curved ramp
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('class', 'curved-ramp');
        svg.style.cssText = `position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 999; overflow: visible;`;
        
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        
        // Create a smooth curved slope from button bottom-right to screen bottom-right (Line Rider style)
        // Use quadratic bezier for smooth downward curve
        const cp1X = startX + (endX - startX) * 0.25;
        const cp1Y = startY + 100; // dip down
        const cp2X = startX + (endX - startX) * 0.55;
        const cp2Y = startY + (endY - startY) * 0.7;
        
        const pathData = `M ${startX} ${startY} Q ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} T ${endX} ${endY}`;
        path.setAttribute('d', pathData);
        path.setAttribute('fill', 'none');
        
        // Set stroke properties explicitly
        const isInverted = document.body.classList.contains('inverted');
        const strokeColor = isInverted ? '#000' : '#fff';
        path.setAttribute('stroke', strokeColor);
        path.setAttribute('stroke-width', '6');
        path.setAttribute('stroke-linecap', 'round');
        path.setAttribute('stroke-linejoin', 'round');
        path.setAttribute('vector-effect', 'non-scaling-stroke');
        
        svg.appendChild(path);
        document.body.appendChild(svg);
        
        console.log(' Ramp created, starting draw animation...');
        
        // Animate the path drawing (stroke-dasharray technique)
        const pathLength = path.getTotalLength();
        console.log(`   Path length: ${pathLength}px`);
        
        path.style.strokeDasharray = `${pathLength}`;
        path.style.strokeDashoffset = `${pathLength}`;
        
        // Force a reflow to ensure initial state is applied
        void path.getBoundingClientRect();
        
        // Start the draw animation
        requestAnimationFrame(() => {
          path.style.transition = 'stroke-dashoffset 1.2s ease-out';
          path.style.strokeDashoffset = '0';
          console.log('    Drawing ramp...');
        });
        
        // After ramp is drawn, slide the button
        setTimeout(() => {
          console.log('    Starting button slide down ramp...');
          slideButtonDownRamp(startButton, svg, path);
        }, 1300);
      }

      function slideButtonDownRamp(button, svg, pathElement) {
        console.log(' slideButtonDownRamp called');
        
        // Capture initial positions BEFORE making fixed
        const buttonRect = button.getBoundingClientRect();
        const platformRect = shapePlatform.getBoundingClientRect();
        const platformHeight = platformRect.height || 60;
        
        const initialButtonLeft = buttonRect.left;
        const initialButtonTop = buttonRect.top;
        const initialButtonWidth = buttonRect.width;
        const initialButtonHeight = buttonRect.height;
        const initialButtonCenterX = buttonRect.left + buttonRect.width / 2;
        const initialButtonCenterY = buttonRect.top + buttonRect.height / 2;
        
        console.log(`   Button initial center: (${initialButtonCenterX}, ${initialButtonCenterY})`);
        console.log(`   Platform height: ${platformHeight}px`);
        
        // Make button fixed positioned at its EXACT current location
        button.style.position = 'fixed';
        button.style.left = `${initialButtonLeft}px`;
        button.style.top = `${initialButtonTop}px`;
        button.style.width = `${initialButtonWidth}px`;
        button.style.height = `${initialButtonHeight}px`;
        button.style.margin = '0';
        button.style.zIndex = '1001';
        button.style.transform = 'none'; // Reset any existing transforms
        
        // Clear any drop animation classes from shapes
        shapes.forEach(shape => {
          if (shape) {
            shape.classList.remove('drop', 'jiggle');
            shape.style.animation = 'none';
            shape.style.transform = 'none';
          }
        });
        
        // Make shape platform fixed at its current position
        shapePlatform.style.position = 'fixed';
        shapePlatform.style.left = `${platformRect.left}px`;
        shapePlatform.style.top = `${platformRect.top}px`;
        shapePlatform.style.width = `${platformRect.width}px`;
        shapePlatform.style.height = `${platformRect.height}px`;
        shapePlatform.style.zIndex = '1002';
        shapePlatform.style.transform = 'none';
        shapePlatform.style.display = 'flex';
        shapePlatform.style.visibility = 'visible';
        shapePlatform.style.opacity = '1';
        shapePlatform.style.animation = 'none';
        
        console.log(`   Shapes initial: (${platformRect.left}, ${platformRect.top}), size: ${platformRect.width}x${platformRect.height}`);
        
        // Manually animate along the path using getPointAtLength
        const pathLength = pathElement.getTotalLength();
        const duration = 2500; // ms
        const startTime = performance.now();
        
        // Get the first point on the path (bottom-right of button)
        const firstPoint = pathElement.getPointAtLength(0);
        
        // Calculate offset: we want the button CENTER to start at its current position,
        // but the path starts at the bottom-right corner
        const offsetX = initialButtonCenterX - firstPoint.x;
        const offsetY = initialButtonCenterY - firstPoint.y;
        
        console.log(`   Path starts at: (${firstPoint.x}, ${firstPoint.y})`);
        console.log(`   Offset to center button: (${offsetX}, ${offsetY})`);
        console.log(`   Initial button center will be: (${firstPoint.x + offsetX}, ${firstPoint.y + offsetY})`);
        
        function animateAlongPath(currentTime) {
          const elapsed = currentTime - startTime;
          const progress = Math.min(elapsed / duration, 1);
          
          if (progress === 0) {
            console.log(`    Animation frame 0 - button at (${initialButtonLeft}, ${initialButtonTop})`);
          }
          
          // Dynamic acceleration: ease-in-out with stronger acceleration
          let easedProgress;
          if (progress < 0.5) {
            // First half: ease-in (accelerating)
            easedProgress = 2 * progress * progress;
          } else {
            // Second half: ease-out (decelerating)
            const p = 1 - progress;
            easedProgress = 1 - (2 * p * p);
          }
          
          const distance = pathLength * easedProgress;
          const point = pathElement.getPointAtLength(distance);
          
          // Apply offset so button starts at its original position
          const adjustedX = point.x + offsetX;
          const adjustedY = point.y + offsetY;
          
          // Get tangent for rotation
          let angle = 0;
          if (distance < pathLength - 1) {
            const nextPoint = pathElement.getPointAtLength(Math.min(distance + 2, pathLength));
            angle = Math.atan2(nextPoint.y - point.y, nextPoint.x - point.x) * (180 / Math.PI);
          }
          
          // Update button position (center it on the adjusted point)
          const newButtonLeft = adjustedX - initialButtonWidth / 2;
          const newButtonTop = adjustedY - initialButtonHeight / 2;
          
          button.style.left = `${newButtonLeft}px`;
          button.style.top = `${newButtonTop}px`;
          button.style.transform = `rotate(${angle + 45}deg)`;
          
          // Also move the shape platform to stay above the button
          if (shapePlatform) {
            const newPlatformLeft = adjustedX - platformRect.width / 2;
            const newPlatformTop = newButtonTop - platformHeight;
            
            shapePlatform.style.left = `${newPlatformLeft}px`;
            shapePlatform.style.top = `${newPlatformTop}px`;
            shapePlatform.style.transform = `rotate(${angle + 45}deg)`;
            
            if (progress < 0.05) {
              console.log(`    Frame progress ${(progress*100).toFixed(1)}%: button(${newButtonLeft.toFixed(0)}, ${newButtonTop.toFixed(0)}), platform(${newPlatformLeft.toFixed(0)}, ${newPlatformTop.toFixed(0)}), angle: ${angle.toFixed(1)}`);
            }
          }
          
          // Fade out near the end
          if (progress > 0.85) {
            const fadeProgress = (progress - 0.85) / 0.15;
            button.style.opacity = (1 - fadeProgress).toString();
            if (shapePlatform) {
              shapePlatform.style.opacity = (1 - fadeProgress).toString();
            }
          }
          
          if (progress < 1) {
            requestAnimationFrame(animateAlongPath);
          } else {
            console.log('    Button slide complete');
            // Clean up and redirect
            setTimeout(() => {
              if (svg.parentNode) {
                svg.remove();
              }
              // Trigger actual form submission or redirect
              if (selectionOrder.length >= MINIMUM_SELECTIONS) {
                const activeSelections = getActiveSelections();
                try {
                  sessionStorage.setItem('celli:betaFormSelections', JSON.stringify(activeSelections));
                  sessionStorage.setItem('celli:betaFormRating', selectedRating.toString());
                } catch (e) {
                  console.warn('Could not store selections:', e);
                }
                window.location.href = 'submit-train.html';
              }
            }, 300);
          }
        }
        
        console.log('    Starting animation frame loop...');
        requestAnimationFrame(animateAlongPath);
      }

      // ============================================
      // FIX: Ensure KEY tile appears on initial load
      // ============================================
      // The KEY word in the video overlay is now always created upfront
      // via the createInitialPrompt() function called in playVideoElement()
      // This ensures it appears on initial load, not just on refresh

    })();
  </script>
</body>
</html>
