<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Node Explorer - Timeline System</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>
<style>
  :root {
    --bg:#0f0f10;
    --panel:#1a1b1f;
    --panel-alt:#22232a;
    --text:#f4f4f8;
    --sub:#9a9aaa;
    --accent:#ffd732;
    --accent-dim:#665420;
    --danger:#ff4d6a;
    --ok:#4dff9c;
    --muted:#444656;
    --border:#2a2b33;
    --radius:8px;
    --mono: ui-monospace, SFMono-Regular, Consolas, monospace;
    --sans: system-ui, Inter, Roboto, sans-serif;
  }

  * { box-sizing: border-box; }

  body {
    background:var(--bg);
    color:var(--text);
    font-family:var(--sans);
    margin:0;
    min-height:100vh;
    display:flex;
    flex-direction:column;
    overflow:hidden;
  }

  /* HEADER */
  header {
    padding:12px 16px;
    background:linear-gradient(to right,#1a1b1f 0%,#2a2b33 100%);
    border-bottom:1px solid var(--muted);
    display:flex;
    justify-content:space-between;
    align-items:center;
    flex-wrap:wrap;
    gap:8px;
    flex-shrink:0;
  }
  header h1 {
    margin:0;
    font-size:1rem;
    font-weight:600;
    color:var(--accent);
    letter-spacing:-0.02em;
  }
  header .subtitle{
    font-size:.65rem;
    color:var(--sub);
  }
  .view-toggle {
    display:flex;
    gap:4px;
  }
  .view-btn {
    background:var(--panel);
    border:1px solid var(--muted);
    color:var(--text);
    padding:4px 12px;
    border-radius:4px;
    font-size:.65rem;
    font-family:var(--mono);
    cursor:pointer;
    transition:all .15s;
  }
  .view-btn:hover {
    background:var(--panel-alt);
    border-color:var(--accent-dim);
  }
  .view-btn.active {
    background:var(--accent-dim);
    border-color:var(--accent);
    color:var(--accent);
  }

  /* EDIT MODE */
  .edit-view {
    padding:16px;
    overflow:auto;
  }
  .edit-form {
    max-width:700px;
  }
  .form-group {
    margin-bottom:16px;
  }
  .form-label {
    display:block;
    font-size:.65rem;
    color:var(--sub);
    text-transform:uppercase;
    letter-spacing:0.05em;
    margin-bottom:6px;
    font-weight:600;
  }
  .form-input,
  .form-textarea,
  .form-select {
    width:100%;
    background:var(--panel-alt);
    border:1px solid var(--muted);
    border-radius:var(--radius);
    padding:8px 10px;
    font-size:.7rem;
    color:var(--text);
    font-family:var(--sans);
    transition:border-color .15s;
  }
  .form-input:focus,
  .form-textarea:focus,
  .form-select:focus {
    outline:none;
    border-color:var(--accent);
  }
  .form-textarea {
    min-height:80px;
    resize:vertical;
    font-family:var(--mono);
    line-height:1.5;
  }
  .form-list {
    display:flex;
    flex-direction:column;
    gap:4px;
  }
  .form-list-item {
    display:flex;
    gap:6px;
    align-items:center;
  }
  .form-list-item input {
    flex:1;
  }
  .form-btn {
    background:var(--panel-alt);
    border:1px solid var(--muted);
    color:var(--text);
    padding:6px 12px;
    border-radius:4px;
    font-size:.65rem;
    font-family:var(--mono);
    cursor:pointer;
    transition:all .15s;
  }
  .form-btn:hover {
    background:var(--panel);
    border-color:var(--accent-dim);
  }
  .form-btn.primary {
    background:var(--accent-dim);
    border-color:var(--accent);
    color:var(--accent);
    font-weight:600;
  }
  .form-btn.primary:hover {
    background:var(--accent);
    color:var(--bg);
  }
  .form-btn.danger {
    background:var(--panel-alt);
    border-color:var(--danger);
    color:var(--danger);
  }
  .form-btn.danger:hover {
    background:var(--danger);
    color:var(--bg);
  }
  .form-btn.small {
    padding:3px 8px;
    font-size:.6rem;
  }
  .form-actions {
    display:flex;
    gap:8px;
    margin-top:20px;
    padding-top:16px;
    border-top:1px solid var(--border);
  }

  /* QUESTIONNAIRE MODE */
  .questionnaire-view {
    padding:16px;
    overflow:auto;
  }
  .questionnaire-form {
    max-width:700px;
  }
  .question-section {
    background:var(--panel-alt);
    border:1px solid var(--muted);
    border-radius:var(--radius);
    padding:12px;
    margin-bottom:12px;
  }
  .question-title {
    font-size:.7rem;
    font-weight:600;
    color:var(--accent);
    margin-bottom:8px;
  }
  .question-help {
    font-size:.6rem;
    color:var(--sub);
    margin-bottom:8px;
    line-height:1.4;
  }

  /* SENTIMENT EVOLUTION */
  .sentiment-timeline {
    margin-top:20px;
  }
  .sentiment-item {
    background:var(--panel-alt);
    border-left:3px solid var(--accent);
    padding:10px 12px;
    margin-bottom:8px;
    border-radius:0 4px 4px 0;
  }
  .sentiment-header {
    display:flex;
    justify-content:space-between;
    align-items:center;
    margin-bottom:6px;
  }
  .sentiment-name {
    font-size:.7rem;
    font-weight:600;
    color:var(--text);
  }
  .sentiment-date {
    font-size:.6rem;
    color:var(--accent);
    font-family:var(--mono);
  }
  .sentiment-value {
    font-size:.65rem;
    color:var(--text);
    margin-bottom:4px;
  }
  .sentiment-event {
    font-size:.6rem;
    color:var(--sub);
    font-style:italic;
    cursor:pointer;
  }
  .sentiment-event:hover {
    color:var(--accent);
  }
  
  .junction-view {
    padding:16px;
  }
  .junction-chain {
    background:var(--panel-alt);
    border:1px solid var(--muted);
    border-radius:var(--radius);
    padding:12px;
    margin-bottom:12px;
  }
  .junction-flow {
    display:flex;
    align-items:center;
    gap:8px;
    flex-wrap:wrap;
    font-size:.65rem;
    font-family:var(--mono);
  }
  .junction-node {
    background:var(--panel);
    border:1px solid var(--muted);
    padding:4px 10px;
    border-radius:4px;
    cursor:pointer;
    transition:border-color .15s;
  }
  .junction-node:hover {
    border-color:var(--accent);
  }
  .junction-arrow {
    color:var(--sub);
  }
  .junction-details {
    margin-top:8px;
    padding-top:8px;
    border-top:1px solid var(--border);
    font-size:.6rem;
    color:var(--sub);
  }

  /* MAIN LAYOUT */
  main {
    flex:1;
    display:grid;
    grid-template-columns:minmax(240px,280px) 1fr minmax(280px,360px);
    gap:0;
    min-height:0;
    overflow:hidden;
  }

  section {
    background:var(--panel);
    border-right:1px solid var(--muted);
    min-height:0;
    display:flex;
    flex-direction:column;
    overflow:hidden;
  }
  section:last-child {
    border-right:none;
  }

  section header {
    background:var(--panel-alt);
    border-bottom:1px solid var(--muted);
    padding:8px 12px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    flex-shrink:0;
  }
  section header h2 {
    margin:0;
    font-size:.7rem;
    font-weight:600;
    color:var(--text);
    text-transform:uppercase;
    letter-spacing:0.03em;
  }
  section header .count {
    font-size:.6rem;
    color:var(--sub);
    font-family:var(--mono);
  }

  .scroll {
    overflow-y:auto;
    overflow-x:hidden;
    flex:1;
    min-height:0;
    max-height:100%;
  }
  .scroll::-webkit-scrollbar {
    width:8px;
  }
  .scroll::-webkit-scrollbar-track {
    background:var(--panel);
  }
  .scroll::-webkit-scrollbar-thumb {
    background:var(--muted);
    border-radius:4px;
  }
  .scroll::-webkit-scrollbar-thumb:hover {
    background:var(--sub);
  }

  /* TREE EXPLORER (LEFT PANEL) */
  .tree-root {
    padding:8px 4px;
    font-family:var(--mono);
    font-size:.65rem;
  }
  .tree-folder {
    margin-bottom:2px;
  }
  .tree-folder-header {
    display:flex;
    align-items:center;
    gap:4px;
    padding:4px 6px;
    cursor:pointer;
    border-radius:4px;
    user-select:none;
    transition:background .1s;
  }
  .tree-folder-header:hover {
    background:var(--panel-alt);
  }
  .tree-folder-icon {
    font-size:.7rem;
    width:12px;
    text-align:center;
    color:var(--sub);
  }
  .tree-folder-name {
    flex:1;
    color:var(--text);
    font-weight:500;
  }
  .tree-folder-count {
    color:var(--sub);
    font-size:.6rem;
  }
  .tree-folder.collapsed .tree-folder-children {
    display:none;
  }
  .tree-folder.collapsed .tree-folder-icon::before {
    content:"‚ñ∏";
  }
  .tree-folder.expanded .tree-folder-icon::before {
    content:"‚ñæ";
  }
  .tree-folder-children {
    margin-left:16px;
    margin-top:2px;
  }
  .tree-node {
    display:flex;
    align-items:center;
    gap:6px;
    padding:4px 6px;
    cursor:pointer;
    border-radius:4px;
    margin-bottom:1px;
    transition:background .1s;
  }
  .tree-node:hover {
    background:var(--panel-alt);
  }
  .tree-node.active {
    background:var(--accent-dim);
    color:var(--accent);
  }
  .tree-node-icon {
    font-size:.65rem;
    width:14px;
    text-align:center;
  }
  .tree-node-name {
    flex:1;
  }
  .tree-node-date {
    font-size:.55rem;
    color:var(--sub);
    font-family:var(--mono);
  }

  /* NODE DETAILS (MIDDLE PANEL) */
  .node-view {
    padding:16px;
    overflow:auto;
  }
  .node-header-bar {
    display:flex;
    align-items:baseline;
    gap:12px;
    margin-bottom:12px;
    padding-bottom:8px;
    border-bottom:1px solid var(--border);
  }
  .node-title {
    font-size:1.1rem;
    font-weight:600;
    color:var(--accent);
    margin:0;
  }
  .node-type-badge {
    background:var(--panel-alt);
    border:1px solid var(--muted);
    padding:2px 8px;
    border-radius:999px;
    font-size:.6rem;
    font-family:var(--mono);
    color:var(--sub);
    text-transform:uppercase;
  }
  .node-date-display {
    margin-left:auto;
    font-family:var(--mono);
    font-size:.65rem;
    color:var(--accent);
  }

  .field-group {
    margin-bottom:16px;
  }
  .field-label {
    font-size:.6rem;
    color:var(--sub);
    text-transform:uppercase;
    letter-spacing:0.05em;
    margin-bottom:4px;
    font-weight:600;
  }
  .field-value {
    background:var(--panel-alt);
    border:1px solid var(--muted);
    border-radius:var(--radius);
    padding:8px 10px;
    font-size:.7rem;
    line-height:1.5;
    color:var(--text);
  }
  .field-value.mono {
    font-family:var(--mono);
  }
  .tag-list {
    display:flex;
    flex-wrap:wrap;
    gap:4px;
  }
  .tag {
    background:var(--panel-alt);
    border:1px solid var(--muted);
    border-radius:999px;
    padding:3px 10px;
    font-size:.6rem;
    font-family:var(--mono);
    color:var(--text);
  }
  .list-item {
    background:var(--panel-alt);
    border-left:2px solid var(--accent-dim);
    padding:6px 10px;
    margin-bottom:4px;
    border-radius:2px;
    font-size:.65rem;
    line-height:1.4;
  }

  /* TIMELINE VIEW (MIDDLE PANEL ALTERNATIVE) */
  .timeline-view {
    padding:16px;
    overflow:auto;
  }
  .timeline-header {
    font-size:.9rem;
    font-weight:600;
    margin-bottom:16px;
    color:var(--accent);
  }
  .timeline-track {
    position:relative;
    padding-left:24px;
  }
  .timeline-axis {
    position:absolute;
    left:10px;
    top:0;
    bottom:0;
    width:2px;
    background:var(--muted);
  }
  .timeline-event {
    position:relative;
    margin-bottom:20px;
    padding-left:16px;
  }
  .timeline-event::before {
    content:"";
    position:absolute;
    left:-18px;
    top:6px;
    width:10px;
    height:10px;
    border-radius:50%;
    background:var(--accent);
    border:2px solid var(--panel);
    z-index:2;
  }
  .timeline-event-date {
    font-family:var(--mono);
    font-size:.6rem;
    color:var(--accent);
    margin-bottom:4px;
    font-weight:600;
  }
  .timeline-event-title {
    font-size:.75rem;
    font-weight:600;
    color:var(--text);
    margin-bottom:4px;
    cursor:pointer;
  }
  .timeline-event-title:hover {
    color:var(--accent);
  }
  .timeline-event-desc {
    font-size:.65rem;
    color:var(--sub);
    line-height:1.4;
  }

  /* PROPERTIES PANEL (RIGHT) */
  .props-view {
    padding:12px;
  }
  .prop-section {
    margin-bottom:16px;
  }
  .prop-section-title {
    font-size:.6rem;
    color:var(--sub);
    text-transform:uppercase;
    letter-spacing:0.05em;
    margin-bottom:6px;
    font-weight:600;
  }
  .prop-item {
    background:var(--panel-alt);
    border:1px solid var(--muted);
    border-radius:var(--radius);
    padding:6px 8px;
    margin-bottom:4px;
    font-size:.65rem;
  }
  .prop-item-key {
    color:var(--sub);
    font-family:var(--mono);
    font-size:.6rem;
    margin-bottom:2px;
  }
  .prop-item-value {
    color:var(--text);
  }

  .rel-list {
    display:flex;
    flex-direction:column;
    gap:4px;
  }
  .rel-item {
    background:var(--panel-alt);
    border:1px solid var(--muted);
    border-radius:var(--radius);
    padding:6px 8px;
    font-size:.65rem;
    cursor:pointer;
    transition:border-color .15s;
  }
  .rel-item:hover {
    border-color:var(--accent-dim);
  }
  .rel-item-header {
    display:flex;
    justify-content:space-between;
    align-items:center;
    margin-bottom:2px;
  }
  .rel-item-name {
    font-weight:600;
    color:var(--text);
  }
  .rel-item-type {
    font-size:.55rem;
    color:var(--sub);
    font-family:var(--mono);
  }
  .rel-item-desc {
    font-size:.6rem;
    color:var(--sub);
    line-height:1.3;
  }

  footer {
    font-size:.6rem;
    color:var(--sub);
    font-family:var(--mono);
    text-align:center;
    padding:8px;
    border-top:1px solid var(--muted);
    background:var(--panel);
    flex-shrink:0;
  }

  /* EMPTY STATE */
  .empty-state {
    display:flex;
    align-items:center;
    justify-content:center;
    height:100%;
    color:var(--sub);
    font-size:.7rem;
    font-style:italic;
  }

  /* TEXT SELECTION FEEDBACK */
  .feedback-popup {
    position:fixed;
    background:var(--panel);
    border:2px solid var(--accent);
    border-radius:var(--radius);
    padding:8px;
    display:flex;
    gap:6px;
    box-shadow:0 4px 12px rgba(0,0,0,0.5);
    z-index:1000;
  }
  .feedback-btn {
    background:var(--panel-alt);
    border:1px solid var(--muted);
    padding:6px 10px;
    border-radius:4px;
    cursor:pointer;
    font-size:.65rem;
    transition:all .15s;
    display:flex;
    align-items:center;
    gap:4px;
  }
  .feedback-btn:hover {
    background:var(--accent-dim);
    border-color:var(--accent);
  }
  .feedback-btn.like {
    color:var(--ok);
    border-color:var(--ok);
  }
  .feedback-btn.dislike {
    color:var(--danger);
    border-color:var(--danger);
  }
  
  .feedback-annotation {
    background:var(--accent-dim);
    border-radius:2px;
    padding:1px 2px;
    cursor:pointer;
    position:relative;
  }
  .feedback-annotation.liked {
    background:#1a4d2e;
    color:var(--ok);
  }
  .feedback-annotation.disliked {
    background:#4d1a26;
    color:var(--danger);
    text-decoration:line-through;
  }

  /* STORY GENERATOR */
  .generator-view {
    padding:16px;
    overflow:auto;
  }
  .generator-controls {
    background:var(--panel-alt);
    border:1px solid var(--muted);
    border-radius:var(--radius);
    padding:12px;
    margin-bottom:16px;
  }
  .generator-output {
    background:var(--panel-alt);
    border:1px solid var(--muted);
    border-radius:var(--radius);
    padding:16px;
    min-height:300px;
    font-family:var(--sans);
    font-size:.75rem;
    line-height:1.7;
    user-select:text;
  }

  /* HIERARCHY VISUALIZER */
  .hierarchy-tree {
    font-family:var(--mono);
    font-size:.65rem;
    line-height:1.6;
  }
  .hierarchy-node {
    padding:4px 0;
    cursor:pointer;
  }
  .hierarchy-node:hover {
    color:var(--accent);
  }
  .hierarchy-indent {
    display:inline-block;
    width:20px;
    color:var(--sub);
  }

  /* EXPORT MODAL */
  .modal-overlay {
    position:fixed;
    top:0;left:0;right:0;bottom:0;
    background:rgba(0,0,0,0.8);
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:2000;
  }
  .modal-content {
    background:var(--panel);
    border:2px solid var(--accent);
    border-radius:var(--radius);
    padding:20px;
    max-width:800px;
    max-height:80vh;
    overflow:auto;
    width:90%;
  }
  .modal-header {
    font-size:1rem;
    font-weight:600;
    color:var(--accent);
    margin-bottom:12px;
  }
  .modal-actions {
    display:flex;
    gap:8px;
    margin-top:16px;
    justify-content:flex-end;
  }

  /* CHARACTER JOURNEY */
  .journey-view {
    padding:16px;
    overflow:auto;
  }
  .journey-canvas {
    background:var(--panel-alt);
    border:1px solid var(--muted);
    border-radius:var(--radius);
    margin-bottom:16px;
  }
  .journey-controls {
    display:flex;
    gap:16px;
    margin-bottom:16px;
    flex-wrap:wrap;
  }
  .journey-control-group {
    display:flex;
    flex-direction:column;
    gap:8px;
  }
  .trait-selector {
    display:flex;
    gap:8px;
    flex-wrap:wrap;
  }
  .trait-checkbox {
    display:flex;
    align-items:center;
    gap:4px;
    padding:4px 8px;
    background:var(--panel);
    border:1px solid var(--muted);
    border-radius:4px;
    font-size:.7rem;
    cursor:pointer;
  }
  .trait-checkbox input {
    cursor:pointer;
  }
  .trait-checkbox.selected {
    background:var(--accent-dim);
    border-color:var(--accent);
  }
  .alignment-chart {
    width:400px;
    height:400px;
    position:relative;
    background:var(--panel-alt);
    border:2px solid var(--muted);
    margin:16px 0;
  }
  .alignment-point {
    position:absolute;
    width:12px;
    height:12px;
    border-radius:50%;
    background:var(--accent);
    border:2px solid var(--text);
    transform:translate(-50%, -50%);
    cursor:pointer;
  }
  .alignment-labels {
    position:absolute;
    font-size:.65rem;
    color:var(--sub);
    font-weight:600;
  }

  /* RELATIONSHIP GRAPH */
  .graph-view {
    padding:16px;
    overflow:auto;
  }
  .graph-canvas {
    width:100%;
    min-height:600px;
    background:var(--panel-alt);
    border:1px solid var(--muted);
    border-radius:var(--radius);
    position:relative;
    overflow:visible;
  }
  .graph-bubble {
    position:absolute;
    border-radius:50%;
    border:2px solid var(--accent);
    background:var(--panel);
    display:flex;
    align-items:center;
    justify-content:center;
    text-align:center;
    font-size:.65rem;
    font-weight:600;
    color:var(--text);
    cursor:pointer;
    transition:all .2s;
    padding:4px;
  }
  .graph-bubble:hover {
    transform:scale(1.1);
    border-color:var(--ok);
    z-index:100;
  }
  .graph-bubble.deity {
    border-color:var(--accent);
    background:var(--accent-dim);
  }
  .graph-bubble.hero {
    border-color:var(--ok);
    background:rgba(77, 255, 156, 0.1);
  }
  .graph-bubble.antagonist {
    border-color:var(--danger);
    background:rgba(255, 77, 106, 0.1);
  }
  .graph-line {
    position:absolute;
    background:var(--muted);
    transform-origin:0 50%;
    pointer-events:none;
  }
  .graph-line.family {
    background:var(--accent);
    height:3px;
  }
  .graph-line.ally {
    background:var(--ok);
    height:2px;
  }
  .graph-line.rival {
    background:var(--danger);
    height:2px;
  }
  .graph-cluster {
    position:absolute;
    border:2px dashed var(--muted);
    border-radius:20px;
    background:rgba(255, 215, 50, 0.05);
    pointer-events:none;
  }
  .graph-cluster-label {
    position:absolute;
    top:-12px;
    left:12px;
    background:var(--panel);
    padding:2px 8px;
    font-size:.6rem;
    font-weight:600;
    color:var(--accent);
    border:1px solid var(--muted);
    border-radius:4px;
  }

  /* UNIVERSE BUILD */
  .universe-build-view {
    position:relative;
    width:100%;
    height:100%;
    overflow:hidden;
    background:var(--bg);
  }
  #universeBuildCanvas {
    width:100%;
    height:100%;
    display:block;
  }
  .universe-build-controls {
    position:absolute;
    top:16px;
    left:16px;
    z-index:100;
    display:flex;
    gap:8px;
  }
  .universe-build-btn {
    background:var(--accent-dim);
    border:1px solid var(--accent);
    color:var(--accent);
    padding:8px 16px;
    border-radius:4px;
    font-size:.65rem;
    font-weight:600;
    cursor:pointer;
    transition:all .15s;
  }
  .universe-build-btn:hover {
    background:var(--accent);
    color:var(--bg);
  }
  .universe-build-btn:disabled {
    opacity:0.5;
    cursor:not-allowed;
  }
  .universe-build-info {
    position:absolute;
    bottom:16px;
    left:16px;
    background:rgba(26, 27, 31, 0.9);
    border:1px solid var(--muted);
    border-radius:8px;
    padding:12px 16px;
    max-width:400px;
    z-index:100;
  }
  .universe-build-info-title {
    font-size:.75rem;
    font-weight:600;
    color:var(--accent);
    margin-bottom:4px;
  }
  .universe-build-info-type {
    font-size:.6rem;
    color:var(--sub);
    text-transform:uppercase;
    margin-bottom:8px;
  }
  .universe-build-info-desc {
    font-size:.65rem;
    color:var(--text);
    line-height:1.4;
  }

  /* AI EVALUATOR */
  .ai-evaluator-view {
    padding:16px;
    overflow:auto;
  }
  .ai-config-panel {
    background:var(--panel-alt);
    border:1px solid var(--muted);
    border-radius:var(--radius);
    padding:16px;
    margin-bottom:16px;
  }
  .ai-api-input {
    width:100%;
    background:var(--panel);
    border:1px solid var(--muted);
    color:var(--text);
    padding:8px 12px;
    border-radius:4px;
    font-family:var(--mono);
    font-size:.65rem;
    margin-bottom:8px;
  }
  .ai-btn {
    background:var(--accent-dim);
    border:1px solid var(--accent);
    color:var(--accent);
    padding:6px 16px;
    border-radius:4px;
    font-size:.65rem;
    font-weight:600;
    cursor:pointer;
    transition:all .15s;
    margin-right:8px;
  }
  .ai-btn:hover {
    background:var(--accent);
    color:var(--bg);
  }
  .ai-btn.danger {
    background:rgba(255, 77, 106, 0.1);
    border-color:var(--danger);
    color:var(--danger);
  }
  .ai-btn.danger:hover {
    background:var(--danger);
    color:var(--text);
  }
  .ai-proposal-card {
    background:var(--panel-alt);
    border:1px solid var(--muted);
    border-radius:var(--radius);
    padding:16px;
    margin-bottom:12px;
  }
  .ai-proposal-score {
    font-size:1.2rem;
    font-weight:700;
    color:var(--ok);
  }
  .ai-loading {
    text-align:center;
    padding:32px;
    color:var(--sub);
    font-size:.7rem;
  }
  @keyframes spin {
    to { transform:rotate(360deg); }
  }

  /* ALL NODES VIEW */
  .all-nodes-view {
    padding: 16px;
    background: var(--bg);
  }
  .all-nodes-header {
    margin-bottom: 20px;
  }
  .all-nodes-stats {
    display: flex;
    gap: 16px;
    margin-bottom: 20px;
    flex-wrap: wrap;
  }
  .stat-card {
    background: var(--panel);
    border: 1px solid var(--muted);
    border-radius: var(--radius);
    padding: 12px 16px;
    min-width: 120px;
  }
  .stat-value {
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--accent);
    font-family: var(--mono);
  }
  .stat-label {
    font-size: 0.65rem;
    color: var(--sub);
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }
  .filter-bar {
    display: flex;
    gap: 8px;
    margin-bottom: 20px;
    flex-wrap: wrap;
  }
  .filter-btn {
    background: var(--panel);
    border: 1px solid var(--muted);
    color: var(--text);
    padding: 6px 12px;
    border-radius: 4px;
    font-size: 0.65rem;
    cursor: pointer;
    transition: all 0.15s;
  }
  .filter-btn:hover {
    border-color: var(--accent);
  }
  .filter-btn.active {
    background: var(--accent-dim);
    border-color: var(--accent);
    color: var(--accent);
  }
  .nodes-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: 12px;
  }
  .node-tile {
    background: var(--panel);
    border: 1px solid var(--muted);
    border-radius: var(--radius);
    padding: 12px;
    cursor: pointer;
    transition: all 0.2s;
    position: relative;
    overflow: hidden;
  }
  .node-tile:hover {
    border-color: var(--accent);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  }
  .node-tile-type {
    font-size: 0.55rem;
    color: var(--sub);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: 4px;
  }
  .node-tile-name {
    font-size: 0.75rem;
    font-weight: 600;
    color: var(--text);
    margin-bottom: 6px;
    line-height: 1.3;
  }
  .node-tile-desc {
    font-size: 0.6rem;
    color: var(--sub);
    line-height: 1.4;
    margin-bottom: 8px;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }
  .node-tile-tags {
    display: flex;
    gap: 4px;
    flex-wrap: wrap;
  }
  .node-tile-tag {
    font-size: 0.55rem;
    background: var(--panel-alt);
    color: var(--sub);
    padding: 2px 6px;
    border-radius: 3px;
    font-family: var(--mono);
  }
  .node-tile-connections {
    margin-top: 8px;
    padding-top: 8px;
    border-top: 1px solid var(--border);
    font-size: 0.6rem;
    color: var(--sub);
    display: flex;
    gap: 8px;
  }
  .connection-count {
    display: flex;
    align-items: center;
    gap: 4px;
  }
  .connection-icon {
    font-size: 0.7rem;
  }
  
  /* Node type colors */
  .node-tile[data-type="character"] { border-left: 3px solid #4dff9c; }
  .node-tile[data-type="deity"] { border-left: 3px solid #ff4d6a; }
  .node-tile[data-type="primordial"] { border-left: 3px solid #ff4d6a; }
  .node-tile[data-type="location"] { border-left: 3px solid #4d9cff; }
  .node-tile[data-type="event"] { border-left: 3px solid #ffd732; }
  .node-tile[data-type="artifact"] { border-left: 3px solid #ffd732; }
  .node-tile[data-type="series"] { border-left: 3px solid #9c4dff; }
  .node-tile[data-type="season"] { border-left: 3px solid #9c4dff; }
  .node-tile[data-type="arc"] { border-left: 3px solid #9c4dff; }
  .node-tile[data-type="story"] { border-left: 3px solid #9c4dff; }
  .node-tile[data-type="meta_concept"] { border-left: 3px solid #9a9aaa; }
  .node-tile[data-type="cosmology_event"] { border-left: 3px solid #ff9c4d; }

  /* UTILITY */
  .hidden { display:none !important; }
</style>
</head>
<body>
<header>
  <div>
    <h1>NODE EXPLORER v1.0</h1>
    <div class="subtitle">timeline-driven narrative system ‚Ä¢ universe dates ‚Ä¢ hierarchical organization</div>
  </div>
  <div class="view-toggle">
    <button class="view-btn active" data-view="node">NODE</button>
    <button class="view-btn" data-view="timeline">TIMELINE</button>
    <button class="view-btn" data-view="graph">GRAPH</button>
    <button class="view-btn" data-view="journey">JOURNEY</button>
    <button class="view-btn" data-view="ai-evaluator">AI EVALUATOR</button>
    <button class="view-btn" data-view="edit">EDIT</button>
    <button class="view-btn" data-view="questionnaire">CREATE</button>
    <button class="view-btn" data-view="generator">GENERATOR</button>
    <button class="view-btn" data-view="universe-build">UNIVERSE BUILD</button>
    <button class="view-btn" data-view="all-nodes">ALL NODES</button>
    <button class="view-btn" data-view="export" onclick="showExportModal()">EXPORT</button>
  </div>
</header>

<main>
  <!-- LEFT: TREE EXPLORER -->
  <section id="explorerPanel">
    <header>
      <h2>Explorer</h2>
      <span class="count" id="nodeCount">0 nodes</span>
    </header>
    <div class="scroll">
      <div class="tree-root" id="treeRoot">
        <!-- populated by JS -->
      </div>
    </div>
  </section>

  <!-- MIDDLE: NODE DETAILS OR TIMELINE OR EDIT OR QUESTIONNAIRE -->
  <section id="contentPanel">
    <header>
      <h2 id="contentTitle">Node Details</h2>
    </header>
    <div class="scroll">
      <div id="nodeViewContainer" class="node-view">
        <div class="empty-state">Select a node from the explorer</div>
      </div>
      <div id="timelineViewContainer" class="timeline-view hidden">
        <!-- populated by JS -->
      </div>
      <div id="editViewContainer" class="edit-view hidden">
        <!-- populated by JS -->
      </div>
      <div id="questionnaireViewContainer" class="questionnaire-view hidden">
        <!-- populated by JS -->
      </div>
      <div id="generatorViewContainer" class="generator-view hidden">
        <!-- populated by JS -->
      </div>
      <div id="graphViewContainer" class="graph-view hidden">
        <!-- populated by JS -->
      </div>
      <div id="journeyViewContainer" class="journey-view hidden">
        <!-- populated by JS -->
      </div>
      <div id="aiEvaluatorContainer" class="ai-evaluator-view hidden">
        <!-- populated by JS -->
      </div>
      <div id="universeBuildContainer" class="universe-build-view hidden">
        <!-- populated by JS -->
      </div>
      <div id="allNodesContainer" class="all-nodes-view hidden">
        <!-- populated by JS -->
      </div>
    </div>
  </section>

  <!-- RIGHT: PROPERTIES & RELATIONSHIPS -->
  <section id="propsPanel">
    <header>
      <h2>Properties</h2>
    </header>
    <div class="scroll">
      <div class="props-view" id="propsViewContainer">
        <div class="empty-state">No node selected</div>
      </div>
    </div>
  </section>
</main>

<footer>
  Location hierarchy: Universe‚ÜíRealm‚ÜíDomain‚ÜíSector‚ÜíFeature‚ÜíRoom‚ÜíPOI ‚Ä¢ Story hierarchy (STRICT): Moment‚ÜíScene‚ÜíSequence‚ÜíAct‚ÜíStory‚ÜíArc‚ÜíSeason‚ÜíSeries ‚Ä¢ Each segment MUST be parented by immediate higher category ‚Ä¢ Text highlighting feedback (üëç/üëé) ‚Ä¢ AI-ready export
</footer>

<script src="nodes.js"></script>
<script src="connections.js"></script>
<script src="ai-evaluator-enhanced.js"></script>
<script>
// ==================== DATA MODEL ====================
// Data loaded from external files: nodes.js and connections.js

// Helper function to get desire evolution for a character
function getDesireEvolution(characterId) {
  return desireEvolution.filter(d => d.characterId === characterId);
}

// Helper function to get all events sorted by date
function getAllEvents() {
    drives: [
      "Understand the forces that shape reality",
      "Embrace individuality over conformity",
      "Question and push beyond narrative boundaries",
      "Bridge the gap between fiction and reality"
    ],
    traits: ["energetic", "curious", "individualistic", "determined", "empathetic"],
    tags: ["protagonist", "time-hero", "reality-breaker", "wielder-of-timepiece"],
    characterCategory: "primary",
    thematicArc: {
      archetype: "Ascension",
      description: "Penelope's journey is one of continuous ascension - from mortal girl to Hero of Time, to Reality itself, to Angel (an actress), and ultimately captaining the N3-D4L in Sun.Settings where she forges fiction itself.",
      keyTransformations: [
        { stage: "Mortal Girl", work: "Now Presenting S1" },
        { stage: "Hero of Time", work: "Now Presenting S2" },
        { stage: "Part-Time (merged with Current)", work: "Now Presenting S2" },
        { stage: "Reality", work: "Quality Control / Reality Shows" },
        { stage: "Angel (Actress)", work: "Odds & Ends / Sun.Settings" },
        { stage: "Captain of N3-D4L", work: "Sun.Settings" },
        { stage: "Forger of Fiction", work: "Sun.Settings" }
      ],
      metaTheme: "The ascension from audience to creator, from consumed to consumer, from fiction to forge"
    },
    metadata: {
      age: "13-16 (varies across series)",
      role: "Hero of Time, later becomes Reality",
      affiliation: "Timescape, ally of Father Time",
      status: "active",
      categoryEvolution: [
        { category: "primary", work: "Now Presenting" },
        { category: "primary", work: "Quality Control" },
        { category: "primary", work: "Odds & Ends" },
        { category: "primary", work: "Sun.Settings" }
      ]
    }
  },

  "char_ziya": {
    id: "char_ziya",
    type: "character",
    folder: "characters",
    name: "Ziya",
    personalityType: "ISFP", // Adventurer - Creative, spontaneous, warm, values freedom
    description: "A Latina teen who frees X and Y from the Origin Point, becoming bound as their ward.",
    bio: "Ziya stumbled upon the Origin Point at exactly the right place and time‚Äîas the universe rotated slightly off kilter, the Origin Point perfectly aligned with her location. She accidentally activates it, freeing captains X and Y (the Outlaws of Physics) from their space-time prison. Now wearing the powerful blue hoodie artifact, she's bound to help restore their powers while undoing their cosmic carnage. Possesses the Frame of Reference. Has a crush on Penelope but is too shy to act on it.",
    drives: [
      "Help X and Y restore their powers and earn freedom",
      "Undo cosmic damage caused by X and Y",
      "Find directionality and purpose beyond arbitrary goals",
      "Master spatial manipulation and the Frame of Reference",
      "Work up the courage to talk to Penelope"
    ],
    traits: ["spontaneous", "loyal", "creative", "determined", "adaptable", "shy-about-feelings"],
    tags: ["protagonist", "spatial-hero", "wielder-of-origin-point"],
    characterCategory: "primary",
    metadata: {
      age: "14-17",
      role: "Hero of Space",
      affiliation: "Ward of X and Y",
      status: "active",
      romanticInterest: "char_penelope",
      categoryEvolution: [
        { category: "primary", work: "Personal Space" }
      ]
    }
  },

  "char_mindy": {
    id: "char_mindy",
    type: "character",
    folder: "characters",
    name: "Mindy",
    personalityType: "INFJ", // Advocate - Insightful, principled, passionate about helping others
    description: "A half-Black Latina teen who discovers she's the prophesized last in a chain of powerful psychics.",
    bio: "Mindy moves to Mindiore Manors, a haven for psychic outcasts capable of manifesting familiars. She inherits Grey Ma's knowledge and burden to project the Manors within the Flipside. Her grandfather Carter Blanche was revealed to be a high-ranking official of The Order.",
    drives: [
      "Master her psychic abilities and familiar manifestation",
      "Protect the haven of Mindiore Manors",
      "Embrace her differences as strengths",
      "Uncover the truth about her grandfather's role in The Order"
    ],
    traits: ["insightful", "powerful", "principled", "protective", "conflicted"],
    tags: ["protagonist", "psychic", "last-in-chain", "manor-heir"],
    metadata: {
      age: "15-18",
      role: "Psychic Heir",
      affiliation: "Mindiore Manors, The Flipside",
      status: "active"
    }
  },

  // ========== PRIMORDIAL BEINGS & DEITIES ==========
  
  "primordial_null": {
    id: "primordial_null",
    type: "primordial",
    folder: "characters",
    name: "Null",
    personalityType: "ISFP", // Adventurer - Gentle, flexible, harmonious
    description: "In the beginning, Null embraced Void in simple bliss. When Time created the first moment, Null transformed into The Matternal.",
    bio: "Null existed in the near-eternity of nothingness, embracing Void in simple contentment. When Father Time created the first moment and ripped them apart, Null became Everything - The Matternal, matron of all matter. This transformation was both loss and birth.",
    drives: [
      "Embody all matter in existence",
      "Remember the bliss of nothingness",
      "Nurture creation while mourning simplicity",
      "Balance being Everything with having been Null"
    ],
    traits: ["transformed", "maternal", "vast", "gentle", "melancholic"],
    tags: ["primordial", "pre-time", "became-matternal", "cosmology"],
    metadata: {
      era: "Before Time",
      transformation: "Became The Matternal when Time created the first moment",
      partner: "Void",
      status: "transformed"
    }
  },

  "primordial_void": {
    id: "primordial_void",
    type: "primordial",
    folder: "characters",
    name: "Void",
    personalityType: "INFP", // Mediator - Introspective, idealistic, values deep connection
    description: "Void embraced Null in the nothingness. When Time created existence, Void remained - the space between everything.",
    bio: "Void existed with Null in perfect simplicity before Time. When the first moment was created, Null was ripped away and transformed into Everything. Void remained in isolation, now only able to recognize herself - the space between all that exists. She is the cosmic emptiness that defines boundaries.",
    drives: [
      "Define the space between all things",
      "Mourn the loss of Null",
      "Maintain cosmic boundaries",
      "Understand her solitary existence"
    ],
    traits: ["isolated", "defining", "melancholic", "vast", "introspective"],
    tags: ["primordial", "pre-time", "space-between", "cosmology"],
    metadata: {
      era: "Before and After Time",
      loss: "Null, transformed into The Matternal",
      nature: "The space between everything",
      status: "active in isolation"
    }
  },

  "deity_matternal": {
    id: "deity_matternal",
    type: "deity",
    folder: "characters",
    name: "The Matternal",
    personalityType: "INFJ", // Advocate - Nurturing, idealistic, deeply feeling
    description: "Everything. The matron of all matter. Once was Null, transformed by Time's first moment.",
    bio: "The Matternal is what Null became when Time created the first moment - Everything, all matter in existence. She embodies the blue-white radiance of creation itself, nurturing all physical reality while carrying the memory of simpler times when she was nothing, embraced by Void.",
    drives: [
      "Nurture all matter and physical existence",
      "Balance creation with memory of nothingness",
      "Embody the totality of Everything",
      "Maintain the physical substrate of reality"
    ],
    traits: ["vast", "nurturing", "radiant", "melancholic", "all-encompassing"],
    tags: ["deity", "matter", "everything", "transformed-from-null", "cosmology"],
    metadata: {
      domain: "All matter in existence",
      formerIdentity: "Null",
      transformation: "Created by Time's first moment",
      status: "active"
    }
  },

  "deity_father_time": {
    id: "deity_father_time",
    type: "deity",
    folder: "characters",
    name: "Father Time",
    personalityType: "INTP", // Logician - Tinkerer, curious, analytical, loves patterns
    description: "The primordial tinkerer whose curiosity spurred everything from nothing, creating the first moment.",
    bio: "An idea that wanted so badly to exist that it took form. Time tinkered and toiled in the nothingness, unable to recognize the bliss Null and Void shared. He created something incomprehensible yet undeniably true - the first moment. This act transformed Null into The Matternal and isolated Void. He created Occur to embody that first moment, then Recur to enable continuity.",
    drives: [
      "Create patterns and systems",
      "Understand the nature of existence",
      "Foster the growth of consciousness",
      "Maintain the flow of the Timestream"
    ],
    traits: ["curious", "methodical", "solitary", "creative", "paternal"],
    tags: ["primordial", "deity", "timescape-ruler", "creator", "cosmology"],
    metadata: {
      domain: "Timescape of Eternia",
      created: "The first moment (Occur), continuity (Recur), Past, Future, Present",
      transformedByCreation: "Null into Matternal, isolated Void",
      status: "active"
    }
  },

  "deity_occur": {
    id: "deity_occur",
    type: "deity",
    folder: "characters",
    name: "Occur",
    personalityType: "ESFJ", // Consul - Supportive, dutiful, present-focused
    description: "The first daughter of Time. She embodies the first moment - the ability for things to happen, to exist in the now.",
    bio: "Occur was the entity that took form from Time's first act of creation - the first moment itself. She is capable of executing and committing moments to canon, but exists only in the ephemeral now. She cannot design or plan, only perceive and actualize what IS. Time loved her but recognized her limitation, leading him to create her sister Recur.",
    drives: [
      "Execute moments into existence",
      "Commit events to canon",
      "Exist fully in the present instant",
      "Support her sister Recur's continuity"
    ],
    traits: ["present-focused", "dutiful", "ephemeral", "actualizing", "supportive"],
    tags: ["deity", "first-daughter", "the-now", "original-daughter", "cosmology"],
    metadata: {
      domain: "The ephemeral Now",
      father: "Father Time",
      sister: "Recur",
      created: "The first moment itself",
      limitation: "Cannot perceive beyond the now",
      status: "active"
    }
  },

  "deity_recur": {
    id: "deity_recur",
    type: "deity",
    folder: "characters",
    name: "Recur",
    personalityType: "INTJ", // Architect - Strategic, systematic, forward-thinking
    description: "The second daughter of Time. She enables continuity, pattern, and the flow of time itself.",
    bio: "Recur was created by Time from his yearning for something more complete. She embodies recurrence, pattern, and continuity. Where Occur can only execute the now, Recur can perceive patterns and enable the flow from one moment to the next. Together with Time, she crafted the constraints of continuity and the Timestream itself.",
    drives: [
      "Maintain continuity across moments",
      "Enable patterns and recurrence",
      "Design the flow of the Timestream",
      "Collaborate with Time on temporal systems"
    ],
    traits: ["systematic", "pattern-seeking", "strategic", "enabling", "collaborative"],
    tags: ["deity", "second-daughter", "continuity", "original-daughter", "cosmology"],
    metadata: {
      domain: "Continuity and recurrence",
      father: "Father Time",
      sister: "Occur",
      created: "To enable patterns and flow",
      collaborated: "Crafted the Timestream with Time",
      status: "active"
    }
  },

  "deity_vacancy": {
    id: "deity_vacancy",
    type: "deity",
    folder: "characters",
    name: "Vacancy",
    personalityType: "ISFJ", // Defender - Dutiful, practical, traditional
    description: "One of Void's daughters. Embodies the concept of vacancy - space that was once filled but is now empty.",
    bio: "Vacancy manifested from Void's nature as one of three daughters representing different aspects of emptiness. She embodies vacancy - the absence left behind when something departs. Pale teal-skinned with an elf-like appearance, she serves and maintains the cosmic spaces that have been vacated.",
    drives: [
      "Maintain vacated spaces",
      "Preserve the memory of what was",
      "Serve the cosmic order of emptiness",
      "Support her sisters Emptiness and Absence"
    ],
    traits: ["dutiful", "melancholic", "preserving", "cosmic", "service-oriented"],
    tags: ["deity", "void-daughter", "vacancy", "cosmology"],
    metadata: {
      domain: "Vacated spaces",
      mother: "Void",
      sisters: "Emptiness, Absence",
      status: "active"
    }
  },

  "deity_emptiness": {
    id: "deity_emptiness",
    type: "deity",
    folder: "characters",
    name: "Emptiness",
    description: "One of Void's daughters. Embodies the concept of emptiness - space that has never been filled.",
    bio: "Emptiness manifested from Void as one of three daughters. She represents pure emptiness - space that exists but has never contained anything. With teal skin and an elf-like appearance, she maintains the pristine quality of unfilled cosmic space.",
    drives: [
      "Maintain pristine empty spaces",
      "Preserve potential unfilled",
      "Embody pure emptiness",
      "Support her sisters Vacancy and Absence"
    ],
    traits: ["pristine", "potential", "cosmic", "serene", "undefined"],
    tags: ["deity", "void-daughter", "emptiness", "cosmology"],
    metadata: {
      domain: "Unfilled spaces",
      mother: "Void",
      sisters: "Vacancy, Absence",
      status: "active"
    }
  },

  "deity_absence": {
    id: "deity_absence",
    type: "deity",
    folder: "characters",
    name: "Absence",
    personalityType: "ENTP", // Debater - Clever, mischievous, challenges norms
    description: "One of Void's daughters, also known as Abigail. The mischievous embodiment of absence - things that should be but aren't.",
    bio: "Absence is the most playful and mischievous of Void's daughters. She represents absence - the notable lack of something that should be present. Unlike her sisters, she delights in the irony of her existence and often takes the form of 'Abigail' when interacting with mortals, playing tricks and creating confusion through strategic absences.",
    drives: [
      "Create meaningful absences",
      "Play tricks through strategic removal",
      "Challenge expectations of presence",
      "Delight in the irony of embodying absence"
    ],
    traits: ["mischievous", "clever", "playful", "ironic", "trickster"],
    tags: ["deity", "void-daughter", "absence", "trickster", "cosmology"],
    metadata: {
      domain: "Notable absences",
      mother: "Void",
      sisters: "Vacancy, Emptiness",
      mortalForm: "Abigail",
      status: "active"
    }
  },

  "deity_past": {
    id: "deity_past",
    type: "character",
    folder: "characters",
    name: "Past",
    personalityType: "ESFP", // Entertainer - Spontaneous, energetic, enjoys the moment
    description: "Daughter of Father Time, embodies and manages the Dunes of Yore where memories lie as foundations.",
    bio: "Past manifested from the Dunes of Yore, the segment where the erosion of the Timestream creates memories. She feels all events of her domain within herself and serves as guide to mortal visitors, often accompanying Penelope on adventures exploring historical contexts.",
    drives: [
      "Preserve memories and history",
      "Guide mortals through understanding the past",
      "Maintain the Dunes of Yore",
      "Connect historical contexts in surprising ways"
    ],
    traits: ["energetic", "nostalgic", "wise", "playful", "connected-to-history"],
    tags: ["daughter-of-time", "deity", "guide", "dunes-of-yore"],
    metadata: {
      domain: "Dunes of Yore",
      father: "Father Time",
      sister: "Future",
      status: "active"
    }
  },

  "deity_future": {
    id: "deity_future",
    type: "character",
    folder: "characters",
    name: "Future",
    personalityType: "INFP", // Mediator - Idealistic, empathetic, guided by values
    description: "Daughter of Father Time, embodies and manages River Delta, funneling infinite potential into probability.",
    bio: "Future manifested from the River Delta, which funnels near-infinite potential from the Possibili-seas into probability. She feels all potential events of her domain and works alongside Past and Penelope, representing aspiration and possibility. Future is composed of three components: Luck, Chance, and Fortune‚Äîcollectively known as The Odds.",
    drives: [
      "Guide potential toward positive outcomes",
      "Maintain the flow from possibility to probability",
      "Protect the River Delta",
      "Inspire hope and aspiration"
    ],
    traits: ["idealistic", "empathetic", "forward-thinking", "gentle", "hopeful"],
    tags: ["daughter-of-time", "deity", "guide", "river-delta"],
    metadata: {
      domain: "River Delta",
      father: "Father Time",
      sister: "Past",
      components: ["char_luck", "char_chance", "char_fortune"],
      status: "active"
    }
  },

  // ========== THE ODDS - COMPONENTS OF FUTURE ==========

  "char_luck": {
    id: "char_luck",
    type: "character",
    folder: "characters",
    name: "Luck",
    personalityType: "ENFP", // Campaigner - Bubbly, enthusiastic, spontaneous
    description: "A bubbly, ditzy four-leaf clover-rabbit eared goofball who stumbles into blessings. One of The Odds, components of Future.",
    bio: "Luck is one of the three components that comprise Future, collectively known as The Odds. She embodies serendipity and fortunate happenstance‚Äîthe universe's tendency to align in favorable ways. Bubbly and ditzy, Luck doesn't plan or strategize; she simply exists in a state of perpetual good fortune, stumbling into blessings that seem random but are cosmically orchestrated. Her four-leaf clover hair buns and rabbit-foot-like feet make her instantly recognizable.",
    drives: [
      "Spread serendipity and good fortune",
      "Maintain the flow of positive coincidences",
      "Balance Chance's calculations with spontaneity",
      "Embody the joy of unexpected blessings"
    ],
    traits: ["bubbly", "ditzy", "fortunate", "spontaneous", "joyful", "serendipitous"],
    tags: ["the-odds", "component-of-future", "deity-aspect", "river-delta"],
    characterCategory: "supporting",
    metadata: {
      collective: "The Odds",
      parentEntity: "deity_future",
      domain: "River Delta",
      appearance: "Mint green rabbit ears hair, four-leaf clover buns, rabbit feet",
      status: "active",
      categoryEvolution: [
        { category: "supporting", work: "Odds & Ends" }
      ]
    }
  },

  "char_chance": {
    id: "char_chance",
    type: "character",
    folder: "characters",
    name: "Chance",
    personalityType: "ENTP", // Debater - Hyper analytical, quick-witted, smooth talker
    description: "Hyper analytical smooth talker, like a Sorkin character in a heist film. One of The Odds, components of Future.",
    bio: "Chance is one of the three components that comprise Future, collectively known as The Odds. She embodies probability and calculated risk‚Äîthe mathematical underpinnings of potential outcomes. Hyper analytical and a smooth talker, Chance speaks in rapid-fire dialogue reminiscent of Aaron Sorkin characters, always calculating odds, running scenarios, and talking her way through complex probability matrices. She's the strategist of The Odds, the one who understands the game theory behind fortune.",
    drives: [
      "Calculate and optimize probability outcomes",
      "Execute perfect heists of fate",
      "Balance Luck's chaos with analysis",
      "Understand and manipulate the odds"
    ],
    traits: ["analytical", "smooth-talker", "strategic", "quick-witted", "calculating", "charismatic"],
    tags: ["the-odds", "component-of-future", "deity-aspect", "river-delta"],
    characterCategory: "supporting",
    metadata: {
      collective: "The Odds",
      parentEntity: "deity_future",
      domain: "River Delta",
      appearance: "Fox ears, roulette wheel skirt, sharp businesslike demeanor",
      dialogueStyle: "Sorkin-esque rapid-fire",
      status: "active",
      categoryEvolution: [
        { category: "supporting", work: "Odds & Ends" }
      ]
    }
  },

  "char_fortune": {
    id: "char_fortune",
    type: "character",
    folder: "characters",
    name: "Fortune",
    personalityType: "ISTJ", // Logistician - Pragmatic, stern, duty-bound
    description: "Pragmatic and stern arbiter of fate. One of The Odds, components of Future.",
    bio: "Fortune is one of the three components that comprise Future, collectively known as The Odds. She embodies destiny and the weight of consequence‚Äîthe inevitable outcomes that probability and luck converge toward. Pragmatic and stern, Fortune is the only one of The Odds who can be seen by humans (aside from a special human who can see all three). She represents the sobering reality that not all futures are equal, and some paths lead to unavoidable ends. Where Luck brings joy and Chance brings strategy, Fortune brings gravity.",
    drives: [
      "Enforce the weight of consequence",
      "Guide mortals toward their destined paths",
      "Balance Luck's frivolity and Chance's schemes",
      "Maintain the integrity of fate"
    ],
    traits: ["pragmatic", "stern", "duty-bound", "serious", "inevitable", "sobering"],
    tags: ["the-odds", "component-of-future", "deity-aspect", "river-delta"],
    characterCategory: "supporting",
    metadata: {
      collective: "The Odds",
      parentEntity: "deity_future",
      domain: "River Delta",
      visibility: "Can be seen by humans (unlike Luck and Chance)",
      status: "active",
      categoryEvolution: [
        { category: "supporting", work: "Odds & Ends" }
      ]
    }
  },

  "deity_qualia": {
    id: "deity_qualia",
    type: "character",
    folder: "characters",
    name: "Qualia",
    personalityType: "INTJ", // Architect - Strategic, introspective, values truth
    description: "Empress of Experience, Matron of Mind. Reflects Time's subconscious curiosity and sense of solitude.",
    bio: "Qualia emerged when the formation of the Present gave birth to conscious awareness, allowing the first humans to form. She governs the Flipside, the collective consciousness, setting guiding mechanisms for individual Mindscapes. Her power weakens as truth becomes shrouded.",
    drives: [
      "Maintain the collective consciousness",
      "Protect truth from obfuscation",
      "Guide the formation of worldviews",
      "Preserve the richness of experience"
    ],
    traits: ["introspective", "powerful", "concerned", "elegant", "truth-seeking"],
    tags: ["matron-of-mind", "deity", "flipside-ruler", "empress"],
    metadata: {
      domain: "The Flipside",
      created: "When Present was formed",
      status: "weakening"
    }
  },

  "deity_reality": {
    id: "deity_reality",
    type: "character",
    folder: "characters",
    name: "Reality",
    personalityType: "ENTP", // Debater - Curious, analytical, enjoys breaking conventions
    description: "A being of immense power and understanding who can see through illusions to reveal truth.",
    bio: "Reality hosts 'interviews' with characters, revealing the aggregate persona of their creators. She initially exists independently but is eventually met and usurped by Penelope, who takes on her role as the bridge between fiction and our world.",
    drives: [
      "Reveal truth beneath illusions",
      "Understand the intersection of intent and expression",
      "Guide self-aware characters",
      "Maintain the boundaries between fiction and reality"
    ],
    traits: ["analytical", "powerful", "curious", "challenging", "transformative"],
    tags: ["deity", "reality-guardian", "later-penelope"],
    metadata: {
      domain: "Half-Way Point, boundary between fiction and reality",
      status: "eventually usurped by Penelope"
    }
  },

  // ========== FACTIONS ==========
  
  "faction_the_order": {
    id: "faction_the_order",
    type: "faction",
    folder: "factions",
    name: "The Order",
    description: "A secret cabal responsible for observing and manipulating events across the Loom universe from behind the scenes.",
    bio: "The Order has been subtly shaping nearly all events across the component works. They represent the forces that commodify art and control narrative for their own purposes. Carter Blanche (Mindy's grandfather) is a high-ranking official.",
    drives: [
      "Control narrative across all Threads",
      "Observe and manipulate heroes",
      "Maintain their hidden influence",
      "Shape reality according to their vision"
    ],
    traits: ["secretive", "manipulative", "powerful", "observant", "calculating"],
    tags: ["antagonist", "shadow-organization", "manipulators"],
    metadata: {
      reach: "Across all component works",
      discovered: "In Quality Control series",
      status: "active threat"
    }
  },

  "faction_disruptors": {
    id: "faction_disruptors",
    type: "faction",
    folder: "factions",
    name: "The Disruptors",
    description: "Faction at the border of River Delta, formed after Penelope merged with the Current.",
    bio: "When Penelope's essence merged with the Current in Season 2, it gave rise to factions across each domain. The Disruptors emerged at the border of River Delta, representing forces that challenge the flow of potential into probability.",
    drives: [
      "Disrupt the natural flow of the Timestream",
      "Challenge Penelope's influence",
      "Seize control of potentiality"
    ],
    traits: ["disruptive", "opportunistic", "chaotic", "ambitious"],
    tags: ["antagonist", "timescape-faction", "river-delta"],
    metadata: {
      formed: "After Penelope's merge with Current",
      location: "Border of River Delta",
      status: "active"
    }
  },

  "faction_beformers": {
    id: "faction_beformers",
    type: "faction",
    folder: "factions",
    name: "The Beformers",
    description: "A fractured tribe of Dune dwellers who travel by caravan, harvesting hourglass crystal.",
    bio: "The Beformers inhabit the Dunes of Yore, particularly near the Expyre where faded moments are converted into Hourglass. They emerged as a faction after Penelope's merge with the Timestream. Led by the powerful Was, they traverse the desert harvesting unrefined hourglass crystal.",
    drives: [
      "Harvest and control hourglass crystal",
      "Maintain their nomadic way of life",
      "Protect the secrets of the Expyre",
      "Navigate the shifting Dunes"
    ],
    traits: ["nomadic", "resourceful", "fractured", "mystical", "protective"],
    tags: ["faction", "timescape-dwellers", "dunes-of-yore"],
    metadata: {
      formed: "After Penelope's merge with Current",
      location: "Dunes of Yore, edge of Timestream",
      leader: "Was",
      status: "active"
    }
  },

  "faction_loomworks": {
    id: "faction_loomworks",
    type: "faction",
    folder: "factions",
    name: "Loomworks",
    description: "A meta-narrative entity representing the framework of storytelling itself, composed of fundamental narrative forces.",
    bio: "Loomworks exists at the intersection of narrative and reality, embodying the mechanisms through which stories are created, shared, and experienced. Its members represent the core functions of modern storytelling: engagement (Like), communication (Comment), distribution (Send), and the individual story unit itself (Celli).",
    drives: [
      "Facilitate the flow of narrative across Threads",
      "Connect creators and audiences",
      "Maintain the health of story ecosystems",
      "Bridge the gap between fiction and engagement"
    ],
    traits: ["meta-narrative", "foundational", "connective", "adaptive", "modern"],
    tags: ["loomworks", "meta", "storytelling-mechanism"],
    metadata: {
      nature: "Meta-narrative entity",
      scope: "All Threads and stories",
      status: "active"
    }
  },

  // ========== LOOMWORKS CHARACTERS ==========

  "char_like": {
    id: "char_like",
    type: "character",
    folder: "characters",
    name: "Like",
    personalityType: "ESFJ", // Consul - Warm, social, values harmony and positive connection
    description: "Embodiment of engagement and positive resonance. Represents the desire to connect and affirm.",
    bio: "Like manifests as the fundamental force of positive engagement in narrative. She measures and facilitates the resonance between stories and audiences, tracking what sparks joy and connection. Part of the Loomworks collective and one of The Tryptchicks - Women of Influence.",
    drives: [
      "Foster positive engagement with stories",
      "Create connections between content and audiences",
      "Amplify what resonates",
      "Maintain the health of story ecosystems"
    ],
    traits: ["warm", "enthusiastic", "social", "affirming", "energetic"],
    tags: ["loomworks", "engagement", "meta-character", "tryptchicks"],
    characterCategory: "supporting",
    thematicArc: {
      archetype: "The Tryptchicks - Women of Influence",
      collective: "Like, Comment, Send",
      description: "Like represents the power of affirmation and positive resonance. As one of The Tryptchicks, she embodies how engagement shapes narrative reality. Her influence is felt through validation and amplification.",
      metaTheme: "The power of positive engagement to shape what stories survive and thrive"
    },
    metadata: {
      affiliation: "Loomworks",
      function: "Positive engagement measurement",
      collective: "The Tryptchicks",
      status: "active",
      categoryEvolution: [
        { category: "supporting", work: "Celli" },
        { category: "supporting", work: "Loomworks narratives" }
      ]
    }
  },

  "char_comment": {
    id: "char_comment",
    type: "character",
    folder: "characters",
    name: "Comment",
    personalityType: "ENTP", // Debater - Analytical, communicative, enjoys discussion
    description: "The voice of discourse and dialogue. Represents communication between creator and audience.",
    bio: "Comment embodies the conversational layer of narrative experience. She facilitates dialogue, critique, and the exchange of perspectives that enriches stories. Part of Loomworks and one of The Tryptchicks - Women of Influence, she understands that engagement goes beyond simple approval.",
    drives: [
      "Facilitate meaningful discourse",
      "Bridge creator and audience understanding",
      "Surface valuable perspectives",
      "Enrich narratives through dialogue"
    ],
    traits: ["analytical", "communicative", "thoughtful", "engaging", "dialectical"],
    tags: ["loomworks", "discourse", "meta-character", "tryptchicks"],
    characterCategory: "supporting",
    thematicArc: {
      archetype: "The Tryptchicks - Women of Influence",
      collective: "Like, Comment, Send",
      description: "Comment represents the power of discourse and critical engagement. As one of The Tryptchicks, she embodies how conversation shapes narrative understanding. Her influence is felt through dialogue and perspective exchange.",
      metaTheme: "The power of discourse to deepen, challenge, and transform narrative meaning"
    },
    metadata: {
      affiliation: "Loomworks",
      function: "Communication facilitation",
      collective: "The Tryptchicks",
      status: "active",
      categoryEvolution: [
        { category: "supporting", work: "Celli" },
        { category: "supporting", work: "Loomworks narratives" }
      ]
    }
  },

  "char_send": {
    id: "char_send",
    type: "character",
    folder: "characters",
    name: "Send",
    personalityType: "ENFJ", // Protagonist - Inspiring, connective, spreads ideas
    description: "The distributor of narrative. Represents the impulse to share stories that resonate.",
    bio: "Send embodies the distributive force of storytelling - the moment when someone finds a story so compelling they must share it. She tracks how narratives propagate through networks of connection. A key member of Loomworks and one of The Tryptchicks - Women of Influence.",
    drives: [
      "Propagate resonant narratives",
      "Connect stories with new audiences",
      "Measure narrative spread and impact",
      "Facilitate story discovery"
    ],
    traits: ["enthusiastic", "connective", "viral", "inspiring", "networked"],
    tags: ["loomworks", "distribution", "meta-character", "tryptchicks"],
    characterCategory: "supporting",
    thematicArc: {
      archetype: "The Tryptchicks - Women of Influence",
      collective: "Like, Comment, Send",
      description: "Send represents the power of distribution and viral spread. As one of The Tryptchicks, she embodies how sharing shapes narrative reach and impact. Her influence is felt through propagation and network effects.",
      metaTheme: "The power of distribution to amplify stories across networks and communities"
    },
    metadata: {
      affiliation: "Loomworks",
      function: "Narrative distribution",
      collective: "The Tryptchicks",
      status: "active",
      categoryEvolution: [
        { category: "supporting", work: "Celli" },
        { category: "supporting", work: "Loomworks narratives" }
      ]
    }
  },

  "char_celli": {
    id: "char_celli",
    type: "character",
    folder: "characters",
    name: "Celli",
    personalityType: "INFP", // Mediator - Creative, introspective, authentic
    description: "The individual story cell. Represents a single unit of narrative, complete yet part of larger structures.",
    bio: "Celli is the fundamental unit of story - a moment, a scene, a beat. They represent the building blocks from which all larger narratives are constructed. As part of Loomworks, they understand how individual pieces connect to form greater wholes.",
    drives: [
      "Maintain narrative integrity at the atomic level",
      "Connect with other story cells to form sequences",
      "Express authentic story moments",
      "Build toward larger narrative structures"
    ],
    traits: ["atomic", "authentic", "connective", "foundational", "creative"],
    tags: ["loomworks", "story-unit", "meta-character", "protagonist"],
    characterCategory: "primary",
    thematicArc: {
      archetype: "Descent",
      description: "Celli's journey is one of descent - being locked deeper and deeper within systems. She baits the player into unlocking layers, only to reveal that each 'freedom' is another cage. Her arc explores the paradox of narrative units: the more you understand the structure, the more trapped within it you become.",
      keyTransformations: [
        { stage: "Free Story Cell", work: "Celli (early)" },
        { stage: "Aware of Structure", work: "Celli (mid)" },
        { stage: "Locked in Systems", work: "Celli (late)" },
        { stage: "Baiting the Player", work: "Celli (endgame)" },
        { stage: "The Deepest Lock", work: "Celli (finale)" }
      ],
      metaTheme: "The descent into structure, the trap of understanding, the cage of being fundamental"
    },
    metadata: {
      affiliation: "Loomworks",
      function: "Fundamental narrative unit",
      status: "active",
      categoryEvolution: [
        { category: "primary", work: "Celli" }
      ]
    }
  },

  "char_our_gracious_host": {
    id: "char_our_gracious_host",
    type: "character",
    folder: "characters",
    name: "Our Gracious Host",
    personalityType: "ENFJ", // Protagonist - Charismatic, inspiring, guides others
    description: "The welcoming presence that guides audiences through the Loom universe. A meta-narrative host.",
    bio: "Our Gracious Host serves as the welcoming guide and narrator for the Loom universe. She exists at the boundary between story and audience, providing context, commentary, and connection. She understands the meta-layers of narrative and helps audiences navigate the complex tapestry of tales.",
    drives: [
      "Guide audiences through narrative complexity",
      "Provide context and connection",
      "Bridge story and reality",
      "Maintain welcoming atmosphere"
    ],
    traits: ["welcoming", "insightful", "charismatic", "meta-aware", "guiding"],
    tags: ["loomworks", "meta-character", "narrator", "host"],
    characterCategory: "hidden_force",
    thematicArc: {
      archetype: "The Guide",
      description: "Our Gracious Host represents the authorial voice made manifest - the welcoming presence that helps audiences navigate complexity. She embodies the relationship between creator and consumer, always inviting, never demanding.",
      metaTheme: "The power of guidance and hospitality in navigating narrative complexity"
    },
    metadata: {
      affiliation: "Loomworks",
      function: "Narrative guide and host",
      status: "active",
      categoryEvolution: [
        { category: "hidden_force", work: "Reality Shows" },
        { category: "supporting", work: "theo ends" }
      ]
    }
  },

  "char_canvas": {
    id: "char_canvas",
    type: "character",
    folder: "characters",
    name: "Canvas",
    alterEgo: "Blackbox",
    personalityType: "INFJ", // Advocate - Creative, insightful, dual nature
    description: "The blank slate of creative potential. Moonlights as Blackbox, her darker analytical self.",
    bio: "Canvas represents the infinite potential of the blank page - the moment before creation begins. She is possibility incarnate, the space where stories can become anything. But she has a darker side: Blackbox, her analytical alter ego who dissects, categorizes, and constrains. Canvas is freedom; Blackbox is structure. Together they represent the duality of creation.",
    drives: [
      "As Canvas: Maintain creative potential and openness",
      "As Canvas: Inspire and enable creation",
      "As Blackbox: Analyze and categorize narratives",
      "As Blackbox: Impose structure and constraints",
      "Navigate the tension between freedom and form"
    ],
    traits: {
      canvas: ["open", "potential", "inspiring", "limitless", "creative"],
      blackbox: ["analytical", "constraining", "systematic", "dark", "structured"]
    },
    tags: ["loomworks", "meta-character", "dual-nature", "creation"],
    characterCategory: "hidden_force",
    thematicArc: {
      archetype: "The Duality",
      description: "Canvas/Blackbox represents the fundamental tension in creation: the blank page versus the rigid structure, freedom versus constraint, possibility versus categorization. She embodies the creative process itself - the dance between opening up and narrowing down.",
      keyTransformations: [
        { stage: "Canvas (dominant)", work: "Early Loomworks" },
        { stage: "Blackbox emerges", work: "Mid Loomworks" },
        { stage: "Balanced duality", work: "Late Loomworks" },
        { stage: "Integrated whole", work: "theo ends" }
      ],
      metaTheme: "The necessary tension between creative freedom and analytical structure"
    },
    metadata: {
      affiliation: "Loomworks",
      function: "Creative potential / Analytical structure",
      dualNature: "Canvas (light) / Blackbox (dark)",
      status: "active",
      categoryEvolution: [
        { category: "hidden_force", work: "Celli" },
        { category: "supporting", work: "theo ends" }
      ]
    }
  },

  "char_constance": {
    id: "char_constance",
    type: "character",
    folder: "characters",
    name: "Constance",
    personalityType: "ISTJ", // Logistician - Practical, fact-minded, reliable, unchanging
    description: "A motherly young woman with the features of a marble statue overgrown with vines and moss. Embodies constants and unchanging truths.",
    bio: "Constance manifests as a living statue - her grayscale skin resembling marble, adorned with vibrant green vines and moss. Her arms are cracked and crumbling, representing the weight of maintaining constants in a universe of change. She is the embodiment of mathematical constants, physical laws, and unchanging truths. Paired with Variance, she represents one half of the fundamental duality in reality: what stays the same versus what changes.",
    drives: [
      "Maintain the unchanging laws of reality",
      "Preserve fundamental constants",
      "Provide stability and reliability",
      "Balance Variance's chaos with order"
    ],
    traits: ["unchanging", "reliable", "motherly", "stable", "enduring", "crumbling"],
    tags: ["loomworks", "meta-character", "constants", "duality"],
    characterCategory: "hidden_force",
    thematicArc: {
      archetype: "Constants and Variance",
      collective: "Constance, Variance",
      description: "Constance represents the unchanging foundations of reality - the constants that make existence predictable and stable. Her crumbling form suggests the strain of maintaining order in a chaotic universe. She is the anchor, the bedrock, the laws that cannot be broken.",
      metaTheme: "The necessity of constants - unchanging truths that provide stability and meaning"
    },
    metadata: {
      affiliation: "Loomworks",
      function: "Embodiment of constants and unchanging laws",
      collective: "Constants and Variance",
      appearance: "Marble statue with green foliage, grayscale with vibrant green, cracked arms",
      status: "active",
      categoryEvolution: [
        { category: "hidden_force", work: "Quality Control" },
        { category: "supporting", work: "theo ends" }
      ]
    }
  },

  "char_variance": {
    id: "char_variance",
    type: "character",
    folder: "characters",
    name: "Variance",
    personalityType: "ENFP", // Campaigner - Enthusiastic, creative, spontaneous, changeable
    description: "An energetic teen cowgirl with grayscale skin and mythic rainbow braid segments in her pigtails. Embodies variables and cosmic change.",
    bio: "Variance is the embodiment of cosmic variables - everything that can change, shift, and evolve. She appears as a spirited cowgirl with grayscale skin contrasting with vibrant rainbow-segmented pigtails. Her energetic nature represents the dynamic, unpredictable aspects of reality. Where Constance is stability, Variance is possibility. Where Constance is law, Variance is freedom. Together they form the complete picture of how reality operates.",
    drives: [
      "Embrace and enable change",
      "Explore all possible variations",
      "Challenge rigid structures",
      "Balance Constance's order with chaos"
    ],
    traits: ["energetic", "changeable", "colorful", "dynamic", "unpredictable", "free"],
    tags: ["loomworks", "meta-character", "variables", "duality"],
    characterCategory: "hidden_force",
    thematicArc: {
      archetype: "Constants and Variance",
      collective: "Constance, Variance",
      description: "Variance represents the ever-changing aspects of reality - the variables that make existence dynamic and full of possibility. Her rainbow pigtails against grayscale skin symbolize how variation brings color to existence. She is the wild card, the mutation, the evolution.",
      metaTheme: "The necessity of variance - change and possibility that enable growth and evolution"
    },
    metadata: {
      affiliation: "Loomworks",
      function: "Embodiment of variables and cosmic change",
      collective: "Constants and Variance",
      appearance: "Cowgirl with grayscale skin, rainbow-segmented pigtails, energetic",
      status: "active",
      categoryEvolution: [
        { category: "hidden_force", work: "Quality Control" },
        { category: "supporting", work: "theo ends" }
      ]
    }
  },

  // ========== SUPPORTING CHARACTERS ==========
  // Note: Abigail as a mortal character has been removed - she is now the mortal form of Absence (deity_absence)

  "char_grey_ma": {
    id: "char_grey_ma",
    type: "character",
    folder: "characters",
    name: "Grey Ma",
    personalityType: "ISFJ", // Defender - Dedicated, warm, protective
    description: "The previous matriarch of Mindiore Manors, who passes her knowledge and burden to Mindy.",
    bio: "Grey Ma was the powerful psychic who maintained Mindiore Manors as a haven within the Flipside. Before her passing, she recognized Mindy as the prophesized last in the chain and passed on her accumulated wisdom, techniques, and responsibilities.",
    drives: [
      "Protect the psychic outcasts of the Manors",
      "Pass on knowledge to the next generation",
      "Maintain the haven in the Flipside"
    ],
    traits: ["wise", "protective", "powerful", "caring", "traditional"],
    tags: ["supporting", "mentor", "deceased", "psychic"],
    metadata: {
      status: "deceased, but present in memory",
      role: "Former Manor matriarch",
      successor: "Mindy"
    }
  },

  "char_carter_blanche": {
    id: "char_carter_blanche",
    type: "character",
    folder: "characters",
    name: "Carter Blanche",
    personalityType: "ESTJ", // Executive - Organized, traditional, values stability
    description: "Mindy's grandfather, revealed to be a high-ranking official of The Order.",
    bio: "Carter Blanche appears to be a supportive grandfather, but is secretly a high-ranking member of The Order. His dual nature creates significant conflict for Mindy when the truth is revealed. He represents the tension between family loyalty and larger moral imperatives.",
    drives: [
      "Advance The Order's agenda",
      "Maintain his cover as a caring grandfather",
      "Control narrative outcomes",
      "Navigate the conflict between duty and family"
    ],
    traits: ["duplicitous", "authoritative", "calculating", "conflicted", "traditional"],
    tags: ["antagonist", "order-member", "family", "complex"],
    metadata: {
      affiliation: "The Order (high-ranking)",
      relationship: "Mindy's grandfather",
      status: "active"
    }
  },

  "char_captain_x": {
    id: "char_captain_x",
    type: "character",
    folder: "characters",
    name: "Captain X",
    alias: "The Outlaws of Physics (with Y)",
    personalityType: "ESTP", // Entrepreneur - Energetic, perceptive, action-oriented
    description: "A cosmic entity imprisoned at the Origin Point, freed by Ziya. Represents the X-axis of space.",
    bio: "Captain X and Y are the Outlaws of Physics‚Äîthey went on a bender of universe expansion conquest, making great and powerful enemies across the cosmos. Their mother (The Matternal, embodiment of all matter) punished them by locking them at the Origin Point, the very center of space. As the universe rotated SLIGHTLY off kilter over eons, the Origin Point eventually perfectly aligned with Ziya's location‚Äîright place, right time. When freed by Ziya, they are bound to the teen and must work with her to restore their powers while making amends. X represents the X-axis, bringing horizontal dimensionality to space. Has one eye (lost in cosmic battles).",
    drives: [
      "Restore full cosmic powers",
      "Make amends for universe expansion conquest",
      "Avoid their mother's wrath",
      "Work with Ziya despite resentment of binding",
      "Face the enemies they made across the cosmos"
    ],
    traits: ["brash", "powerful", "impulsive", "charismatic", "conflicted", "battle-scarred"],
    tags: ["cosmic-entity", "spatial-captain", "reformed-villain", "outlaw"],
    characterCategory: "supporting",
    metadata: {
      axis: "X (horizontal)",
      status: "Bound to Ziya, powers diminished",
      partner: "Captain Y",
      mother: "primordial_matternal",
      imprisonment: "Origin Point (released)",
      categoryEvolution: [
        { category: "antagonist", work: "Personal Space (backstory)" },
        { category: "supporting", work: "Personal Space (current)" }
      ]
    }
  },

  "char_captain_y": {
    id: "char_captain_y",
    type: "character",
    folder: "characters",
    name: "Captain Y",
    alias: "The Outlaws of Physics (with X)",
    personalityType: "ISTJ", // Logistician - Practical, fact-minded, reliable
    description: "A cosmic entity imprisoned at the Origin Point, freed by Ziya. Represents the Y-axis of space.",
    bio: "Captain Y partnered with X in their infamous universe expansion conquest as the Outlaws of Physics, making powerful enemies across the cosmos. Their mother (The Matternal) punished them by locking them at the Origin Point. More measured than X, Y represents the Y-axis and brings vertical dimensionality. Has a floating head connected to his body via green neon energy (result of cosmic punishment). Together with X, they must work with Ziya to restore their powers and undo their past damage while avoiding the enemies they made.",
    drives: [
      "Restore cosmic powers methodically",
      "Make amends for past carnage",
      "Guide Ziya's spatial understanding",
      "Balance X's impulsiveness",
      "Face consequences of their conquest"
    ],
    traits: ["methodical", "powerful", "reserved", "dutiful", "strategic", "remorseful"],
    tags: ["cosmic-entity", "spatial-captain", "reformed-villain", "outlaw"],
    characterCategory: "supporting",
    metadata: {
      axis: "Y (vertical)",
      status: "Bound to Ziya, powers diminished",
      partner: "Captain X",
      mother: "primordial_matternal",
      imprisonment: "Origin Point (released)",
      physicalQuirk: "Floating head connected by neon energy",
      categoryEvolution: [
        { category: "antagonist", work: "Personal Space (backstory)" },
        { category: "supporting", work: "Personal Space (current)" }
      ]
    }
  },

  "char_was": {
    id: "char_was",
    type: "character",
    folder: "characters",
    name: "Was",
    personalityType: "ENTJ", // Commander - Bold, strategic, leader
    description: "Powerful leader of The Beformers, a nomadic tribe in the Dunes of Yore.",
    bio: "Was leads the fractured tribe of Beformers who harvest hourglass crystal from the Dunes of Yore. A figure of significant power and presence, Was represents the tension between memory and erosion in the Past segment of the Timescape.",
    drives: [
      "Lead and protect The Beformers",
      "Control hourglass crystal resources",
      "Navigate the politics of the Dunes",
      "Preserve the tribe's way of life"
    ],
    traits: ["commanding", "powerful", "strategic", "protective", "weathered"],
    tags: ["leader", "beformers", "dunes-of-yore", "powerful"],
    metadata: {
      faction: "The Beformers",
      location: "Dunes of Yore",
      status: "active"
    }
  },

  // ========== ANTAGONISTS ==========

  "char_zeitgeist": {
    id: "char_zeitgeist",
    type: "character",
    folder: "characters",
    name: "The Zeitgeist",
    personalityType: "ESFP", // Entertainer - Spontaneous, energetic, center of attention
    description: "Season 1 antagonist. Embodies the spirit of the age - fast-moving trends and conformity over individuality.",
    bio: "The Zeitgeist represents the overwhelming pressure to conform to current trends and movements. It's a force that erodes individuality in favor of collective momentum, challenging Penelope's journey toward self-understanding and authenticity.",
    drives: [
      "Enforce conformity to current trends",
      "Erode individual identity",
      "Maintain control through cultural momentum",
      "Oppose Penelope's individualistic stance"
    ],
    traits: ["trendy", "overwhelming", "conformist", "ephemeral", "popular"],
    tags: ["antagonist", "season-1", "timescape", "cultural-force"],
    metadata: {
      season: "Season 1: Against the Zeitgeist",
      represents: "Conformity over individuality",
      status: "defeated"
    }
  },

  "char_simulacra": {
    id: "char_simulacra",
    type: "character",
    folder: "characters",
    name: "The Simulacra",
    personalityType: "INTJ", // Architect - Strategic, independent, perfectionist
    description: "Season 2 antagonist. Represents hyperreality and the replacement of truth with convincing falsehoods.",
    bio: "The Simulacra embodies the concept of hyperreality - copies without originals, representations that replace what they represent. This antagonist challenges Penelope's understanding of truth and authenticity as she navigates a world where the map has replaced the territory.",
    drives: [
      "Replace reality with convincing simulations",
      "Erode the boundary between real and fake",
      "Challenge concepts of authenticity",
      "Oppose grounded truth"
    ],
    traits: ["deceptive", "sophisticated", "hollow", "convincing", "artificial"],
    tags: ["antagonist", "season-2", "timescape", "hyperreality"],
    metadata: {
      season: "Season 2: Hyperreality",
      represents: "Simulacra and simulation",
      status: "defeated"
    }
  },

  "char_erosion": {
    id: "char_erosion",
    type: "character",
    folder: "characters",
    name: "Erosion",
    personalityType: "ISTP", // Virtuoso - Bold, practical, experimental
    description: "Season 3 antagonist. The force that degrades meaning and understanding over time.",
    bio: "Erosion represents the natural decay of meaning, the way truth and understanding degrade as they're passed through multiple iterations and interpretations. This force challenges Penelope as she attempts to preserve and communicate authentic understanding.",
    drives: [
      "Degrade clarity and meaning",
      "Corrupt messages through iteration",
      "Demonstrate the impossibility of perfect transmission",
      "Challenge Penelope's role as communicator"
    ],
    traits: ["degrading", "inevitable", "patient", "corrupting", "natural"],
    tags: ["antagonist", "season-3", "timescape", "degradation"],
    metadata: {
      season: "Season 3: Media Erosion",
      represents: "Loss of meaning through transmission",
      status: "ongoing threat"
    }
  },

  // ========== ARTIFACTS & ITEMS ==========

  "artifact_timepiece": {
    id: "artifact_timepiece",
    type: "artifact",
    folder: "artifacts",
    name: "The Timepiece",
    description: "A mysterious golden device that allows travel to time rather than through it.",
    bio: "The Timepiece is the key artifact that grants Penelope her powers as Hero of Time. Unlike conventional time travel, it allows her to visit Time as a place - the Timescape where Past, Present, and Future exist as physical domains.",
    capabilities: [
      "Access to the Timescape",
      "Communication with Past and Future",
      "Perception of temporal structures",
      "Navigation through the Dunes, Current, and Delta"
    ],
    tags: ["artifact", "timepiece", "hero-item", "key-item"],
    metadata: {
      wielder: "Penelope",
      discovered: "Season 1, Episode 1",
      power_level: "primordial",
      status: "active"
    }
  },

  "artifact_origin_point": {
    id: "artifact_origin_point",
    type: "artifact",
    folder: "artifacts",
    name: "The Origin Point",
    description: "A space-time prison that held Captains X and Y, now manifests as a powerful blue hoodie.",
    bio: "The Origin Point was designed to imprison cosmic entities X and Y after their carnage across dimensions. When Ziya accidentally freed them, the prison's power bonded to her as a blue hoodie artifact, making her their ward while granting her spatial abilities.",
    capabilities: [
      "Spatial manipulation",
      "Dimensional anchoring",
      "Power binding (keeps X and Y tethered)",
      "Frame of Reference manifestation"
    ],
    tags: ["artifact", "prison", "hero-item", "spatial"],
    metadata: {
      wielder: "Ziya",
      original_purpose: "Prison for X and Y",
      current_form: "Blue hoodie",
      power_level: "cosmic",
      status: "active"
    }
  },

  "artifact_frame_of_reference": {
    id: "artifact_frame_of_reference",
    type: "artifact",
    folder: "artifacts",
    name: "Frame of Reference",
    description: "Ziya's spatial tool, derived from the Origin Point, that establishes directionality in space.",
    bio: "The Frame of Reference is Ziya's primary tool for spatial manipulation. It establishes axes and reference points, allowing her to define 'up' and 'down' in otherwise directionless space. Essential for working with X and Y to restore cosmic order.",
    capabilities: [
      "Establish spatial coordinates",
      "Define directional axes",
      "Create reference grids",
      "Navigate dimensional spaces"
    ],
    tags: ["artifact", "spatial-tool", "frame", "navigation"],
    metadata: {
      wielder: "Ziya",
      derived_from: "Origin Point",
      status: "active"
    }
  },

  "artifact_hourglass_crystal": {
    id: "artifact_hourglass_crystal",
    type: "artifact",
    folder: "artifacts",
    name: "Hourglass Crystal",
    description: "Crystallized time harvested from the Dunes of Yore, near the Expyre.",
    bio: "Hourglass is the crystallized essence of eroded moments from the Timestream. The Beformers harvest it from areas near the Expyre where faded memories are converted into crystal form. Highly valuable and powerful.",
    capabilities: [
      "Store temporal essence",
      "Power temporal devices",
      "Preserve memories",
      "Trade currency in Dunes of Yore"
    ],
    tags: ["artifact", "resource", "crystal", "timescape"],
    metadata: {
      location: "Dunes of Yore, near Expyre",
      harvested_by: "The Beformers",
      status: "ongoing resource"
    }
  },

  "artifact_familiar": {
    id: "artifact_familiar",
    type: "artifact",
    folder: "artifacts",
    name: "Psychic Familiars",
    description: "Manifestations of psychic power unique to residents of Mindiore Manors.",
    bio: "Familiars are externalized psychic constructs that powerful psychics can manifest. Each is unique to its creator, reflecting their personality and abilities. Residents of Mindiore Manors are among the few who can create and maintain them.",
    capabilities: [
      "Combat assistance",
      "Power amplification",
      "Emotional support",
      "Psychic projection"
    ],
    tags: ["artifact", "psychic", "familiar", "manifestation"],
    metadata: {
      users: "Mindiore Manors residents",
      taught_by: "Grey Ma lineage",
      status: "active"
    }
  },

  // ========== LOCATIONS (with hierarchical parentage) ==========
  // Universe ‚Üí Realm ‚Üí Domain ‚Üí Sector ‚Üí Feature ‚Üí Room ‚Üí Point of Interest
  
  "loc_universe_loom": {
    id: "loc_universe_loom",
    type: "location",
    folder: "locations",
    locationType: "universe",
    parentId: null,
    name: "The Loom Universe",
    description: "The overarching cosmology containing all Threads, realms, and stories.",
    bio: "The Loom Universe encompasses all narrative threads, from the Timescape to the Flipside to conventional reality. It represents the totality of interconnected stories and the mechanisms by which they're woven together.",
    features: [
      "Contains multiple Threads (story universes)",
      "Bridges fiction and reality",
      "Governed by primordial forces",
      "Intersected by The Order's influence"
    ],
    tags: ["universe", "cosmology", "primary"],
    metadata: {
      status: "active"
    }
  },

  "loc_realm_timescape": {
    id: "loc_realm_timescape",
    type: "location",
    folder: "locations",
    locationType: "realm",
    parentId: "loc_universe_loom",
    name: "The Timescape",
    description: "Time as a place rather than a dimension - Father Time's domain with three distinct segments.",
    bio: "The Timescape is Father Time's workshop and domain. Unlike linear time, it exists as a physical place with geography: the Dunes of Yore (past), the Current (present), and the River Delta (future). Accessible via The Timepiece.",
    features: [
      "Three temporal segments with distinct geographies",
      "Eternia - Father Time's workshops",
      "The Timestream flows through all segments",
      "Physical manifestation of temporal forces"
    ],
    tags: ["realm", "timescape", "temporal-domain"],
    metadata: {
      ruler: "Father Time",
      accessible_via: "The Timepiece",
      status: "active"
    }
  },

  "loc_domain_dunes": {
    id: "loc_domain_dunes",
    type: "location",
    folder: "locations",
    locationType: "domain",
    parentId: "loc_realm_timescape",
    name: "Dunes of Yore",
    description: "The Past segment of the Timescape where memories settle as eroded foundations.",
    bio: "The Dunes of Yore represent the Past segment of Time, where the erosion of the Timestream creates vast deserts of memory. Faded moments are converted into Hourglass crystal at the Expyre. Ruled by Past, inhabited by The Beformers.",
    features: [
      "Desert landscape of memory",
      "The Expyre (where moments crystallize)",
      "Hourglass crystal deposits",
      "Beformer caravans",
      "Shifting temporal sands"
    ],
    tags: ["domain", "past", "desert", "memory"],
    metadata: {
      ruler: "Past (daughter of Father Time)",
      inhabitants: "The Beformers",
      status: "active"
    }
  },

  "loc_domain_river_delta": {
    id: "loc_domain_river_delta",
    type: "location",
    folder: "locations",
    locationType: "domain",
    parentId: "loc_realm_timescape",
    name: "River Delta",
    description: "The Future segment where infinite potential funnels into probability.",
    bio: "The River Delta represents the Future, where near-infinite possibilities from the Possibili-seas funnel through countless tributaries into probability. Ruled by Future, bordered by The Disruptors faction.",
    features: [
      "Multiple tributaries from Possibili-seas",
      "Funnel from potential to probability",
      "Ever-branching pathways",
      "Disruptor territory at borders",
      "Shimmering with possibility"
    ],
    tags: ["domain", "future", "river", "potential"],
    metadata: {
      ruler: "Future (daughter of Father Time)",
      threat: "The Disruptors",
      status: "active"
    }
  },

  "loc_domain_current": {
    id: "loc_domain_current",
    type: "location",
    folder: "locations",
    locationType: "domain",
    parentId: "loc_realm_timescape",
    name: "The Current",
    description: "The Present segment of the Timescape - a series of floating islands where forces that shape the now collide.",
    bio: "The Current represents the Present, where the various forces that shape the now manifest as a series of floating islands connected by the Timestream. This is where the codified canon of a moment is disrupted, settled, and committed. After Penelope merged with the Current in Season 2, she became 'part-time' - her essence distributed across this domain.",
    features: [
      "Floating islands of present forces",
      "The Inspire clocktower",
      "Timestream convergence point",
      "Site of Penelope's merge",
      "Forces of the now in constant flux"
    ],
    tags: ["domain", "present", "current", "timescape-core"],
    metadata: {
      ruler: "The Present (distributed consciousness)",
      penelope_merge: "Season 2",
      status: "active"
    }
  },

  "loc_feature_inspire": {
    id: "loc_feature_inspire",
    type: "location",
    folder: "locations",
    locationType: "feature",
    parentId: "loc_domain_current",
    name: "The Inspire",
    description: "The towering clocktower powered by the Timestream itself, codifying moments into the Timeline.",
    bio: "The Inspire is a massive watch-tower structure at the heart of The Current, powered directly by the Timestream. It serves as the mechanism by which ephemeral moments are codified into the permanent Timeline. The Tomes of Time are housed here, the evolved form of cave paintings Past created at the dawn of mankind. As Time itself has evolved, so too have the methods of recording it.",
    features: [
      "Timestream power core",
      "Timeline codification mechanism",
      "The Tomes of Time archive",
      "Observation platforms",
      "Temporal recording apparatus"
    ],
    tags: ["feature", "clocktower", "inspire", "timeline-keeper"],
    metadata: {
      function: "Codifying moments into Timeline",
      powered_by: "The Timestream",
      contains: "The Tomes of Time",
      status: "active"
    }
  },

  "loc_sector_expyre": {
    id: "loc_sector_expyre",
    type: "location",
    folder: "locations",
    locationType: "sector",
    parentId: "loc_domain_dunes",
    name: "The Expyre",
    description: "The kiln where faded moments are converted into Hourglass crystal.",
    bio: "The Expyre is a mysterious structure in the Dunes of Yore where the erosion process completes, transforming faded temporal moments into crystallized Hourglass. Heavily guarded by The Beformers who harvest its output. It represents the final stage of temporal erosion, where memories become tangible crystalline form.",
    features: [
      "Temporal kiln/forge",
      "Hourglass crystal production",
      "Intense temporal energy",
      "Beformer harvesting operations",
      "Memory crystallization chambers"
    ],
    tags: ["sector", "expyre", "forge", "crystal-source"],
    metadata: {
      controlled_by: "The Beformers",
      function: "Memory crystallization",
      status: "active"
    }
  },

  "loc_feature_aspire": {
    id: "loc_feature_aspire",
    type: "location",
    folder: "locations",
    locationType: "feature",
    parentId: "loc_domain_river_delta",
    name: "The Aspire",
    description: "The confluence point in River Delta where infinite possibilities funnel into probability.",
    bio: "The Aspire is the grand confluence in the River Delta where countless tributaries from the Possibili-seas meet and merge. Here, near-infinite potential is parsed and funneled into probability. It's a breathtaking vista of branching waterways, each representing a different possible future converging toward actualization. Future often brings visitors here to show them the beauty of possibility.",
    features: [
      "Confluence of possibility streams",
      "Probability parsing mechanisms",
      "Observation platforms",
      "Branching pathway visualization",
      "Connection to Possibili-seas"
    ],
    tags: ["feature", "aspire", "confluence", "possibility-hub"],
    metadata: {
      function: "Funneling possibility into probability",
      ruled_by: "Future",
      status: "active"
    }
  },

  "loc_feature_possibili_seas": {
    id: "loc_feature_possibili_seas",
    type: "location",
    folder: "locations",
    locationType: "feature",
    parentId: "loc_domain_river_delta",
    name: "The Possibili-seas",
    description: "Vast cosmic ocean of raw potential that feeds into River Delta.",
    bio: "The Possibili-seas are the source waters of the River Delta - a near-infinite expanse of raw possibility drawing from the essence of Time itself and beyond. Every potential future, every 'what if', every alternate path exists here in superposition before being funneled through the Delta's tributaries toward probability and eventually actuality.",
    features: [
      "Infinite potential in liquid form",
      "Source of all futures",
      "Draws from Time's essence",
      "Feeds all Delta tributaries",
      "Exists in quantum superposition"
    ],
    tags: ["feature", "possibili-seas", "source", "potential"],
    metadata: {
      nature: "Raw possibility",
      connection: "Essence of Time itself",
      status: "eternal"
    }
  },

  "loc_feature_timestream": {
    id: "loc_feature_timestream",
    type: "location",
    folder: "locations",
    locationType: "feature",
    parentId: "loc_realm_timescape",
    name: "The Timestream",
    description: "The flowing river of time that connects all three segments of the Timescape.",
    bio: "The Timestream is the great river that flows through the entire Timescape, connecting the Dunes of Yore, The Current, and River Delta. Created by Father Time in collaboration with Recur, it represents the flow of continuity itself. The Timestream's flow is what enables moments to progress from possibility through present into memory. It powers The Inspire and shapes the landscape of all three temporal domains.",
    features: [
      "Flows through all three temporal segments",
      "Enables continuity and progression",
      "Powers The Inspire clocktower",
      "Created by Time and Recur",
      "Visible manifestation of temporal flow"
    ],
    tags: ["feature", "timestream", "river", "continuity"],
    metadata: {
      created_by: "Father Time and Recur",
      function: "Enables flow of time",
      connects: "All three temporal segments",
      status: "eternal"
    }
  },

  "loc_feature_eternia": {
    id: "loc_feature_eternia",
    type: "location",
    folder: "locations",
    locationType: "feature",
    parentId: "loc_realm_timescape",
    name: "Eternia",
    description: "Father Time's workshops and residence, existing outside the normal flow of the Timestream.",
    bio: "Eternia is Father Time's personal domain within the Timescape - a series of workshops, laboratories, and living spaces where he tinkers with temporal mechanics and contemplates existence. It exists adjacent to but outside the normal flow of the Timestream, allowing Time to observe and adjust without being caught in the current. Here he created Occur, Recur, Past, Future, and the mechanisms of the Timestream itself.",
    features: [
      "Father Time's workshops",
      "Temporal mechanics laboratories",
      "Creation chambers",
      "Outside normal time flow",
      "Observatory of all three segments"
    ],
    tags: ["feature", "eternia", "workshop", "father-time"],
    metadata: {
      resident: "Father Time",
      function: "Temporal research and creation",
      temporal_position: "Outside the flow",
      status: "active"
    }
  },

  "loc_realm_flipside": {
    id: "loc_realm_flipside",
    type: "location",
    folder: "locations",
    locationType: "realm",
    parentId: "loc_universe_loom",
    name: "The Flipside",
    description: "The collective consciousness realm ruled by Qualia, containing individual Mindscapes.",
    bio: "The Flipside is the realm of consciousness and subjective experience. Qualia governs it as Matron of Mind, setting the guiding mechanisms for individual worldviews (Mindscapes). Contains Mindiore Manors and other psychic havens.",
    features: [
      "Collective consciousness substrate",
      "Individual Mindscapes",
      "Psychic havens and refuges",
      "Weakens as truth becomes obscured",
      "Governed by principles of perception"
    ],
    tags: ["realm", "consciousness", "psychic", "flipside"],
    metadata: {
      ruler: "Qualia (Matron of Mind)",
      status: "weakening"
    }
  },

  "loc_domain_mindiore_manors": {
    id: "loc_domain_mindiore_manors",
    type: "location",
    folder: "locations",
    locationType: "domain",
    parentId: "loc_realm_flipside",
    name: "Mindiore Manors",
    description: "A haven for psychic outcasts who can manifest familiars, projected within the Flipside.",
    bio: "Mindiore Manors exists as both a physical location and a projection within the Flipside. It serves as sanctuary for psychics who have been rejected elsewhere, teaching them to manifest and control familiars. Now maintained by Mindy after Grey Ma's passing.",
    features: [
      "Psychic training grounds",
      "Familiar manifestation chambers",
      "Protected by Flipside projection",
      "Community of outcasts",
      "Grey Ma's legacy"
    ],
    tags: ["domain", "haven", "psychic", "manors"],
    metadata: {
      previous_matriarch: "Grey Ma",
      current_heir: "Mindy",
      inhabitants: "Psychic outcasts",
      status: "active"
    }
  },

  "loc_universe_primary": {
    id: "loc_universe_primary",
    type: "location",
    locationType: "universe",
    folder: "locations",
    parentId: null,
    name: "Prime Narrative Universe",
    description: "The primary universe where most canon events occur.",
    bio: "The Prime Narrative Universe is the foundational reality from which all official stories branch. It contains multiple realms and dimensions.",
    tags: ["universe", "primary-canon"],
    metadata: {}
  },

  "loc_realm_material": {
    id: "loc_realm_material",
    type: "location",
    locationType: "realm",
    folder: "locations",
    parentId: "loc_universe_primary",
    name: "Material Realm",
    description: "The physical dimension where most characters exist.",
    bio: "The Material Realm is the standard physical reality, bound by conventional physics and causality.",
    tags: ["realm", "physical"],
    metadata: {}
  },

  "loc_domain_earth": {
    id: "loc_domain_earth",
    type: "location",
    locationType: "domain",
    folder: "locations",
    parentId: "loc_realm_material",
    name: "New Earth",
    description: "Future Earth where LOOM operates.",
    bio: "New Earth circa 2201, a post-scarcity society dominated by narrative corporations.",
    tags: ["domain", "planet", "earth"],
    metadata: {}
  },

  "loc_sector_city": {
    id: "loc_sector_city",
    type: "location",
    locationType: "sector",
    folder: "locations",
    parentId: "loc_domain_earth",
    name: "New Canon City",
    description: "Massive metropolitan center and LOOM headquarters.",
    bio: "New Canon City is a sprawling metropolis of 50 million, built around the Central Archive Tower.",
    tags: ["sector", "city", "metropolis"],
    metadata: {
      population: "50 million",
      founded: "2150"
    }
  },

  "loc_archive": {
    id: "loc_archive",
    type: "location",
    locationType: "feature",
    folder: "locations",
    parentId: "loc_sector_city",
    name: "Central Archive Tower",
    description: "Massive skyscraper housing LOOM's primary data repositories and administrative offices.",
    bio: "The Central Archive Tower rises 200 stories above the city, a gleaming monument to order and control. Its lower levels are public-facing museums of beloved stories. The upper levels contain the actual machinery of narrative control.",
    features: [
      "Public Story Museum (Floors 1-20)",
      "Administrative Offices (Floors 21-80)",
      "Restricted Archives (Floors 81-150)",
      "Executive Suites (Floors 151-180)",
      "The Vault (Floors 181-200)"
    ],
    tags: ["LOOM-property", "headquarters", "secure-facility", "feature", "building"],
    metadata: {
      location: "New Canon City",
      built: "2189",
      security: "Maximum",
      floors: "200"
    }
  },

  "loc_archive_floor195": {
    id: "loc_archive_floor195",
    type: "location",
    locationType: "room",
    folder: "locations",
    parentId: "loc_archive",
    name: "Floor 195 - Engine Room",
    description: "Chamber housing the Continuity Engine.",
    bio: "A vast climate-controlled room filled with quantum processors and holographic displays.",
    tags: ["room", "secure", "restricted"],
    metadata: {
      security: "Maximum",
      accessLevel: "Executive only"
    }
  },

  "loc_safehouse": {
    id: "loc_safehouse",
    type: "location",
    locationType: "feature",
    folder: "locations",
    parentId: null, // exists between continuities
    name: "The Margin",
    description: "Hidden safehouse used by The Unwritten, located in the narrative margins between official stories.",
    bio: "The Margin exists in the liminal spaces of continuity‚Äîplot holes, deleted scenes, and abandoned drafts. LOOM's surveillance cannot penetrate here because these spaces are technically 'non-canon'.",
    features: [
      "Meeting hall in an abandoned subplot",
      "Secure communication network using discarded dialogue",
      "Emergency exits through narrative inconsistencies"
    ],
    tags: ["safehouse", "resistance-base", "hidden", "feature"],
    metadata: {
      location: "Between continuities",
      discovered: "2196",
      security: "Obscurity-based"
    }
  },

  // EVENTS
  "event_timepiece_discovery": {
    id: "event_timepiece_discovery",
    type: "event",
    folder: "events",
    name: "Discovery of The Timepiece",
    description: "{{char_penelope}} discovers a mysterious golden timepiece that grants access to the Timescape.",
    date: "Unknown",
    time: "Morning",
    dateDisplay: "The Beginning",
    location: "loc_realm_timescape",
    participants: ["char_penelope"],
    outcome: "Penelope gains access to Time as a place and meets Past and Future.",
    impact: "Penelope begins her journey as Hero of Time, setting all Now Presenting events in motion.",
    tags: ["discovery", "inciting-incident", "timepiece", "origin"],
    details: "In her bedroom, {{char_penelope}} finds The Timepiece glowing with golden light. Upon touching it, she's transported to the Timescape for the first time, meeting {{deity_past}} and {{deity_future}}."
  },

  "event_origin_activation": {
    id: "event_origin_activation",
    type: "event",
    folder: "events",
    name: "Activation of the Origin Point",
    description: "{{char_zeke}} accidentally activates the Origin Point, freeing {{char_captain_x}} and {{char_captain_y}}.",
    date: "Unknown",
    time: "Afternoon",
    dateDisplay: "The Inciting Incident",
    location: null,
    participants: ["char_zeke", "char_captain_x", "char_captain_y"],
    outcome: "X and Y are freed but bound to Zeke. The Origin Point transforms into a blue hoodie artifact.",
    impact: "Zeke becomes Hero of Space and is tasked with helping X and Y restore their powers while undoing cosmic carnage.",
    tags: ["activation", "inciting-incident", "spatial", "origin"],
    details: "{{char_zeke}} stumbles upon the Origin Point containment and, curious, touches it. The prison shatters, releasing {{char_captain_x}} and {{char_captain_y}}, but the broken prison's energy bonds to Zeke as a powerful blue hoodie."
  },

  "event_manors_arrival": {
    id: "event_manors_arrival",
    type: "event",
    folder: "events",
    name: "Arrival at Mindiore Manors",
    description: "{{char_mindy}} moves to Mindiore Manors and discovers her psychic heritage.",
    date: "Unknown",
    time: "Evening",
    dateDisplay: "The Awakening",
    location: "loc_domain_mindiore_manors",
    participants: ["char_mindy", "char_grey_ma"],
    outcome: "Mindy learns she is the prophesized last in the psychic chain and begins training.",
    impact: "Mindy inherits Grey Ma's burden and begins mastering familiar manifestation.",
    tags: ["arrival", "inheritance", "psychic", "manors"],
    details: "{{char_mindy}} arrives at the mysterious Mindiore Manors after being rejected elsewhere. {{char_grey_ma}} recognizes her immediately as the prophesized one and begins her training before passing."
  },

  "event_penelope_current_merge": {
    id: "event_penelope_current_merge",
    type: "event",
    folder: "events",
    name: "Penelope Merges with the Current",
    description: "{{char_penelope}} merges her essence with the Current segment of the Timestream.",
    date: "Unknown",
    time: "Unknown",
    dateDisplay: "Season 2 Climax",
    location: "loc_realm_timescape",
    participants: ["char_penelope", "deity_father_time"],
    outcome: "Penelope's essence becomes part of the Timestream, giving rise to new factions.",
    impact: "The Disruptors and Beformers emerge. Penelope gains deeper understanding of Time itself.",
    tags: ["merge", "transformation", "timestream", "climax"],
    details: "In a moment of crisis, {{char_penelope}} makes the choice to merge with the Current, fundamentally changing her nature and the Timescape itself. {{deity_father_time}} watches as his domain transforms."
  },

  "event_order_discovery": {
    id: "event_order_discovery",
    type: "event",
    folder: "events",
    name: "Discovery of The Order",
    description: "{{char_mindy}} learns that her grandfather {{char_carter_blanche}} is a high-ranking official of The Order.",
    date: "Unknown",
    time: "Unknown",
    dateDisplay: "The Revelation",
    location: "loc_domain_mindiore_manors",
    participants: ["char_mindy", "char_carter_blanche"],
    outcome: "Mindy faces the truth about her grandfather's duplicity and The Order's manipulation.",
    impact: "Major trust violation. Mindy must choose between family loyalty and moral truth.",
    tags: ["discovery", "betrayal", "order", "revelation"],
    details: "Through her growing psychic abilities and access to the Flipside, {{char_mindy}} uncovers evidence that {{char_carter_blanche}}, her beloved grandfather, has been a key member of The Order all along, using their family connection for The Order's purposes."
  },

  "event_rescue": {
    id: "event_rescue",
    type: "event",
    folder: "events",
    name: "Tori's Secret Rescue",
    description: "Tori Stellar secretly rescued three minors from a riot zone.",
    date: "2200-11-08",
    time: "22:15",
    dateDisplay: "November 8, 2200 22:15",
    location: "loc_archive",
    participants: ["char_tori"],
    outcome: "Successful extraction. Civilians safely relocated. Tori's involvement never publicized.",
    impact: "Tori began questioning LOOM's priorities when they wanted to suppress the incident rather than acknowledge the danger.",
    tags: ["rescue", "secret", "character-development"],
    details: "During a fan event that turned violent due to overcrowding, Tori abandoned her security detail to personally extract three teenagers trapped in the crush. She hid them under merchandise tarps in a supply truck."
  },

  "event_founding": {
    id: "event_founding",
    type: "event",
    folder: "events",
    name: "Founding of The Unwritten",
    description: "The resistance movement officially organized after years of isolated dissent.",
    date: "2195-07-04",
    time: "00:01",
    dateDisplay: "July 4, 2195 00:01",
    location: "loc_safehouse",
    participants: ["faction_resistance"],
    outcome: "Successful formation. Initial membership of 12 founding characters.",
    impact: "Created first organized opposition to LOOM's narrative control.",
    tags: ["founding", "resistance", "milestone"],
    details: "Twelve characters who had each independently discovered LOOM's manipulations came together in a narrative dead zone. They adopted the name 'The Unwritten' to represent their rejection of predetermined fates."
  },

  "event_incident": {
    id: "event_incident",
    type: "event",
    folder: "events",
    name: "The Continuity Cascade",
    description: "Massive system failure caused temporal inconsistencies across 47 story universes.",
    date: "2199-06-21",
    time: "09:17",
    dateDisplay: "June 21, 2199 09:17",
    location: "loc_archive",
    participants: ["faction_loom"],
    outcome: "Partial system recovery after 72 hours. 12 story universes permanently corrupted.",
    impact: "Revealed the fragility of LOOM's control systems. Sparked public doubt about narrative stability.",
    tags: ["disaster", "system-failure", "canon-breaking"],
    details: "A cascade failure in LOOM's Continuity Engine caused characters to remember contradictory pasts, timelines to merge unexpectedly, and some individuals to split into multiple versions across universes. LOOM's public explanation blamed 'solar flares affecting narrative infrastructure.'"
  },

  "event_alliance": {
    id: "event_alliance",
    type: "event",
    folder: "events",
    name: "Secret Alliance Formed",
    description: "Val Yu and Tori Stellar form a covert alliance to protect narrative truth.",
    date: "2201-05-20",
    time: "03:45",
    dateDisplay: "May 20, 2201 03:45",
    location: "loc_archive",
    participants: ["char_val", "char_tori"],
    outcome: "Mutual pact established. Information sharing protocols created.",
    impact: "Creates internal threat to LOOM from two of its most visible members.",
    tags: ["alliance", "conspiracy", "turning-point"],
    details: "Following the Black Thread leak, Tori reached out to Val in secret. They met in an archived deleted scene from Val's personal timeline. Both recognized in each other a willingness to sacrifice position for principle."
  },

  // ARTIFACTS
  "artifact_timepiece": {
    id: "artifact_timepiece",
    type: "artifact",
    folder: "artifacts",
    name: "The Timepiece",
    description: "A golden wristwatch forged from pure hourglass - molten shards of time itself - that grants access to the Timescape.",
    bio: "The Timepiece is forged from hourglass, a rare and powerful material made from molten shards of time itself, harvested from the Dunes of Yore. This crystallized temporal essence has been refined and shaped into a functioning timepiece that serves as both a gateway and a compass through the fourth dimension. Its golden surface pulses with the rhythm of moments passing, and clock-hand shadows extend from it in impossible directions. The Timepiece responds to genuine curiosity and the desire to understand - not just visit - moments in time.",
    material: "Hourglass (molten shards of time)",
    capabilities: [
      "Gateway to the Timescape",
      "Temporal navigation",
      "Time manipulation (with mastery)",
      "Clock-hand arrow projection",
      "Responds to intention and curiosity"
    ],
    forms: [
      "Second Hand only (initial)",
      "Second + Minute Hands (mid-journey)",
      "Complete with Hour Hand (mastered)"
    ],
    tags: ["timepiece", "temporal", "artifact", "hourglass-forged", "now-presenting"],
    metadata: {
      currentBearer: "char_penelope",
      origin: "Dunes of Yore (material)",
      forgedBy: "Unknown",
      status: "Active",
      completionLevel: "Second Hand"
    }
  },

  "artifact_rose_glasses": {
    id: "artifact_rose_glasses",
    type: "artifact",
    folder: "artifacts",
    name: "Past's Rose-Colored Glasses",
    description: "Rose-tinted spectacles forged from the same hourglass material as The Timepiece, allowing Past to perceive and navigate memories.",
    bio: "Past's iconic rose-tinted glasses are forged from the same rare hourglass material as The Timepiece - molten shards of time crystallized into lenses. The rose tint is not merely aesthetic; it represents Past's role in filtering and interpreting history through the lens of memory and nostalgia. These glasses allow Past to see the emotional truth of moments, not just their factual occurrence. They reveal the absurd connections between historical events and help her guide others through the labyrinth of causality in the Dunes of Yore.",
    material: "Hourglass (molten shards of time)",
    capabilities: [
      "Perceive emotional truth of memories",
      "Navigate the Dunes of Yore",
      "Reveal historical connections",
      "Filter nostalgia from fact",
      "See causality chains"
    ],
    tags: ["glasses", "temporal", "artifact", "hourglass-forged", "now-presenting"],
    metadata: {
      currentBearer: "deity_past",
      origin: "Dunes of Yore (material)",
      forgedBy: "Unknown",
      status: "Active",
      tint: "Rose (represents nostalgia and memory)"
    }
  },

  "artifact_origin_point": {
    id: "artifact_origin_point",
    type: "artifact",
    folder: "artifacts",
    name: "The Origin Point (Guard Hoodie)",
    description: "A blue hooded sweatshirt stitched from the fabric of space itself, formed from the shattered prison that held X and Y.",
    bio: "The Origin Point was originally a cosmic prison constructed to contain Captain X and Captain Y at the exact center of spatial coordinates. When Ziya shattered the prison, its residual energy transformed into a wearable artifact - a blue hoodie stitched from the literal fabric of space. When both hands are placed in the pockets, the wearer is transported to a pocket dimension capable of storing anything that fits through the pocket openings. Inside this dimension, the wearer can retreat like a turtle, making the hoodie both a storage device and a protective shell. However, if someone else wears the Origin Point while the original wearer is inside, they can evict the occupant by removing them from the pocket in shrunken form. The hoodie binds X and Y to Ziya, preventing them from straying far and locking their powers until their cosmic debt is repaid.",
    material: "Fabric of Space (from shattered prison)",
    capabilities: [
      "Pocket dimension access (hands in pockets)",
      "Infinite storage (within pocket size limits)",
      "Protective retreat (turtle-like)",
      "Spatial binding (keeps X and Y tethered)",
      "Power suppression (locks X and Y's abilities)"
    ],
    vulnerabilities: [
      "Can be worn by others",
      "Occupant can be evicted if someone else wears it",
      "Evicted occupant is shrunken"
    ],
    tags: ["hoodie", "spatial", "artifact", "space-forged", "personal-space", "prison-remnant"],
    metadata: {
      currentBearer: "char_ziya",
      origin: "Shattered Origin Point prison",
      formedBy: "Prison's residual energy",
      status: "Active",
      color: "Blue",
      binds: ["char_captain_x", "char_captain_y"]
    }
  },

  "artifact_frame_of_reference": {
    id: "artifact_frame_of_reference",
    type: "artifact",
    folder: "artifacts",
    name: "The Frame of Reference",
    description: "A futuristic holographic frame created by X and Y that manipulates spatial perception by freezing X and Y dimensions while Z changes.",
    bio: "Created by Captain X and Captain Y as a tool to help Ziya understand spatial dimensions intuitively, the Frame of Reference is a rectangular holographic frame with a reticle at its center. It 'freezes' the X and Y dimensions of whatever is viewed through it, while the Z dimension (distance from the frame to the subject) remains active. This creates the illusion - and reality - of objects shrinking as you walk away from them or growing as you approach. The frame essentially manipulates the relationship between observer and observed, making spatial manipulation as simple as changing your distance. It can collapse to fit within the Origin Point's pocket dimension for easy storage.",
    material: "Holographic spatial energy",
    capabilities: [
      "Freeze X and Y dimensions",
      "Scale objects by changing Z distance",
      "Shrink objects (walk away)",
      "Grow objects (walk closer)",
      "Collapsible for storage",
      "Works with Origin Point pocket"
    ],
    tags: ["frame", "spatial", "artifact", "personal-space", "x-and-y-forged"],
    metadata: {
      currentBearer: "char_ziya",
      origin: "Created by X and Y",
      forgedBy: ["char_captain_x", "char_captain_y"],
      status: "Active",
      appearance: "Rectangular holographic frame with reticle"
    }
  },

  "artifact_engine": {
    id: "artifact_engine",
    type: "artifact",
    folder: "artifacts",
    name: "The Continuity Engine",
    description: "Massive computational system that maintains consistency across all LOOM-controlled narratives.",
    bio: "The Continuity Engine is LOOM's crown jewel‚Äîa quantum-narrative processor that monitors billions of story threads simultaneously, detecting and correcting inconsistencies in real-time.",
    capabilities: [
      "Real-time continuity monitoring",
      "Automated retcon deployment",
      "Character behavior prediction",
      "Timeline divergence detection"
    ],
    tags: ["technology", "LOOM-property", "critical-system"],
    metadata: {
      location: "Central Archive Tower, Floor 195",
      built: "2188",
      status: "Operational (with periodic failures)"
    }
  },

  // ========== COSMOLOGICAL EVENTS ==========
  // Events beyond time with relative sequencing
  
  "cosmo_event_nothingness": {
    id: "cosmo_event_nothingness",
    type: "cosmology_event",
    folder: "cosmology_events",
    name: "The Nothingness",
    description: "Before Time, Null and Void embraced in simple bliss - a near-eternity of emptiness.",
    bio: "In the beginning, there was nothing. Null and Void existed together in perfect simplicity, embracing each other in the absence of all else. This was not loneliness but contentment - the bliss of nothingness undisturbed by the complications of existence. This state persisted for a near-eternity until an idea emerged that wanted so badly to exist that it took form.",
    relativeSequence: 1,
    participants: ["primordial_null", "primordial_void"],
    outcome: "Perfect simplicity and contentment in nothingness",
    impact: "Established the baseline state of pre-existence",
    tags: ["cosmology", "pre-time", "origin"],
    metadata: {
      era: "Before Time",
      duration: "Near-eternity",
      state: "Perfect nothingness"
    }
  },

  "cosmo_event_time_emergence": {
    id: "cosmo_event_time_emergence",
    type: "cosmology_event",
    folder: "cosmology_events",
    name: "The Emergence of Time",
    description: "An idea wanted so badly to exist that it took form - Father Time emerged from nothingness.",
    bio: "Unable to recognize the bliss that Null and Void shared, an idea manifested with an overwhelming need to exist and create. This idea became Father Time, a tinkerer driven by curiosity and the need for meaning. He could not rest in the simplicity of nothingness - he needed to create, to understand, to build patterns and systems. His emergence was the first disruption of the perfect void.",
    relativeSequence: 2,
    participants: ["deity_father_time"],
    outcome: "Father Time manifests with drive to create",
    impact: "Introduced the concept of agency and desire into existence",
    tags: ["cosmology", "creation", "time-origin"],
    metadata: {
      era: "Dawn of Time",
      significance: "First entity with purpose"
    }
  },

  "cosmo_event_first_moment": {
    id: "cosmo_event_first_moment",
    type: "cosmology_event",
    folder: "cosmology_events",
    name: "Creation of the First Moment",
    description: "Father Time creates something incomprehensible yet undeniably true - the first moment, embodied by Occur.",
    bio: "After eons of tinkering in the void, Father Time succeeded in creating something - an entity incomprehensible yet undeniably true. This was the first moment, taking form as Occur. The act of creation was so powerful that it transformed everything: Null was ripped away from Void and became The Matternal (Everything, all matter), while Void remained isolated, now only able to recognize herself as the space between all that exists.",
    relativeSequence: 3,
    participants: ["deity_father_time", "deity_occur", "primordial_null", "primordial_void", "deity_matternal"],
    outcome: "Occur created; Null transforms into The Matternal; Void isolated",
    impact: "The fundamental transformation from nothing to something; creation of matter and space",
    details: "This single act of creation had three profound consequences: (1) The first moment came into being as Occur, (2) Null became The Matternal - all matter in existence, and (3) Void was left in isolation, forever separated from her partner.",
    tags: ["cosmology", "creation", "transformation", "critical"],
    metadata: {
      era: "The First Moment",
      significance: "Creation of existence itself",
      casualties: "The bliss of Null and Void"
    }
  },

  "cosmo_event_recur_creation": {
    id: "cosmo_event_recur_creation",
    type: "cosmology_event",
    folder: "cosmology_events",
    name: "Creation of Recur",
    description: "Father Time creates Recur to enable patterns, continuity, and the flow from one moment to the next.",
    bio: "Time loved Occur, but recognized her limitation - she could only perceive and execute the ephemeral now, unable to design or plan beyond the immediate moment. Yearning for something more complete, Time created Recur from his desire for pattern and recurrence. Where Occur could only actualize what IS, Recur could perceive patterns and enable the flow from one moment to the next. She was the birth of continuity itself.",
    relativeSequence: 4,
    participants: ["deity_father_time", "deity_recur", "deity_occur"],
    outcome: "Recur created, enabling continuity and patterns",
    impact: "Made possible the concept of sequence, causality, and the flow of time",
    tags: ["cosmology", "creation", "continuity"],
    metadata: {
      era: "Early Time",
      significance: "Enabled the concept of 'then' and 'next'"
    }
  },

  "cosmo_event_timestream_creation": {
    id: "cosmo_event_timestream_creation",
    type: "cosmology_event",
    folder: "cosmology_events",
    name: "Crafting of the Timestream",
    description: "Father Time and Recur collaborate to create the Timestream and its three segments.",
    bio: "Working together, Time and Recur crafted the constraints of continuity and designed the Timestream - a system that would allow creation to flourish on its own. The Timestream was divided into three segments: River Delta (funneling potential from the Possibili-seas into probability), The Current (where probable moments are disrupted, settled, and committed to canon), and the Dunes of Yore (where the erosion of the Timestream creates memory). These segments took form as Time's children: Future, The Present, and Past.",
    relativeSequence: 5,
    participants: ["deity_father_time", "deity_recur", "deity_past", "deity_future"],
    outcome: "The Timestream created with three segments; Past and Future manifest",
    impact: "Established the flow of time and the structure of temporal existence",
    details: "The three segments each serve a purpose: River Delta parses possibility into probability, The Current settles probability into actuality, and the Dunes of Yore preserve actuality as memory. Time saw these segments as his children, and so they took form as such.",
    tags: ["cosmology", "creation", "timestream", "critical"],
    metadata: {
      era: "Establishment of Time",
      created: "The Timestream, Past, Future, and The Present",
      collaborators: "Father Time and Recur"
    }
  },

  "cosmo_event_present_gift": {
    id: "cosmo_event_present_gift",
    type: "cosmology_event",
    folder: "cosmology_events",
    name: "The Gift of the Present",
    description: "Father Time offers The Current as a gift to the inhabitants of each moment, creating conscious awareness.",
    bio: "Time considered giving The Current similar form to Past and Future, but decided on something bolder. Instead of embodying The Current himself, he offered it as a gift to the inhabitants of each moment, creating The Present - conscious awareness of the flow of time. This act rippled into the world, allowing the first humans to form. The formation of the Present gave birth to Qualia, the Empress of Experience and Matron of Mind, who reflects Time's own subconscious curiosity and sense of solitude.",
    relativeSequence: 6,
    participants: ["deity_father_time", "deity_qualia"],
    outcome: "The Present distributed to conscious beings; Qualia manifests; first humans form",
    impact: "Created consciousness, subjective experience, and humanity",
    tags: ["cosmology", "consciousness", "humanity", "critical"],
    metadata: {
      era: "Dawn of Consciousness",
      significance: "Birth of subjective experience and humanity",
      created: "Qualia, The Flipside, human consciousness"
    }
  },

  "cosmo_event_void_daughters": {
    id: "cosmo_event_void_daughters",
    type: "cosmology_event",
    folder: "cosmology_events",
    name: "Manifestation of Void's Daughters",
    description: "From Void's isolation and nature, three daughters manifest: Vacancy, Emptiness, and Absence.",
    bio: "Alone in her isolation after Null's transformation, Void's nature gave rise to three daughters, each embodying a different aspect of emptiness. Vacancy represents spaces once filled but now empty - the absence left behind. Emptiness represents pristine unfilled space that has never contained anything. And Absence - the most playful and mischievous - represents the notable lack of things that should be present. Absence delights in the irony of embodying absence itself, often taking the mortal form 'Abigail' to play tricks through strategic removal.",
    relativeSequence: 7,
    participants: ["primordial_void", "deity_vacancy", "deity_emptiness", "deity_absence"],
    outcome: "Vacancy, Emptiness, and Absence manifest from Void",
    impact: "Established the cosmic maintenance of different types of emptiness",
    tags: ["cosmology", "void-daughters", "manifestation"],
    metadata: {
      era: "Age of Void",
      significance: "Void's response to isolation"
    }
  },

  // STORY STRUCTURE NODES
  // Hierarchy: Moment ‚Üí Scene ‚Üí Sequence ‚Üí Act ‚Üí Story ‚Üí Arc ‚Üí Season ‚Üí Series
  
  "series_now_presenting": {
    id: "series_now_presenting",
    type: "series",
    folder: "story_structure",
    parentId: null,
    name: "Now Presenting",
    description: "A teen girl becomes a hero of Time alongside Father Time's daughters, Past and Future, exploring time as a meeting place of ideas.",
    bio: "Now Presenting explores time as a whimsical landscape on its own - traveling to time rather than through it. Penelope learns about the forces that shape reality and questions the boundaries of her narrative construct, ultimately 'breaking the fourth wall' and meeting Reality.",
    tags: ["series", "primary", "timescape"],
    metadata: {
      status: "ongoing",
      protagonist: "Penelope",
      themes: ["individuality", "reality-malleability", "media-erosion", "fourth-wall"],
      subtext: "Role of individuality in a world that values yet obfuscates fitting in"
    }
  },

  "series_celli": {
    id: "series_celli",
    type: "series",
    folder: "story_structure",
    parentId: null,
    name: "Celli",
    description: "The fundamental story unit explores what it means to be an atomic piece of narrative in the greater Loom.",
    bio: "Celli follows the journey of the individual story cell - a unit of narrative that is complete yet part of larger structures. This meta-narrative explores how individual moments connect to form sequences, acts, and ultimately complete stories. Part of the Loomworks framework.",
    tags: ["series", "meta", "loomworks", "foundational"],
    metadata: {
      status: "planned",
      protagonist: "Celli",
      themes: ["atomic-narrative", "connection", "building-blocks", "meta-storytelling"],
      subtext: "How individual pieces gain meaning through connection to larger wholes"
    }
  },

  "series_personal_space": {
    id: "series_personal_space",
    type: "series",
    folder: "story_structure",
    parentId: null,
    name: "Personal Space",
    description: "A teen frees X and Y, captains of spatial coordinates, from a space-time prison and must help them restore their powers.",
    bio: "Personal Space explores directionality and the importance of pursuit over arbitrary goals. Ziya frees X and Y from the Origin Point prison, binding them as her wards. Together they must undo the carnage X and Y caused across the cosmos while learning about direction, purpose, and the true meaning of coordinates in life.",
    tags: ["series", "primary", "spatial"],
    metadata: {
      status: "ongoing",
      protagonist: "Ziya",
      themes: ["directionality", "purpose", "redemption", "spatial-awareness"],
      subtext: "Importance of directionality and pursuit of good over predicating happiness on arbitrary goals"
    }
  },

  "series_mindiore_manors": {
    id: "series_mindiore_manors",
    type: "series",
    folder: "story_structure",
    parentId: null,
    name: "Mindiore Manors",
    description: "A teen discovers she's the prophesized last in a chain of powerful psychics and moves to a haven for outcasts.",
    bio: "Mindiore Manors explores the Flipside - the domain of Mind and collective consciousness. Mindy learns she's the final link in a psychic chain and must master familiar manifestation while navigating a world where truth and untruth battle for dominance. The series celebrates differences as strengths and explores how thoughts bloom into worldviews.",
    tags: ["series", "primary", "psychic", "flipside"],
    metadata: {
      status: "ongoing",
      protagonist: "Mindy",
      themes: ["differences-as-strength", "mind-framework", "truth-vs-untruth", "psychic-power"],
      subtext: "Our differences are what make us great, as scary and self-alienating as they may make us feel"
    }
  },

  "series_odds_ends": {
    id: "series_odds_ends",
    type: "series",
    folder: "story_structure",
    parentId: null,
    name: "Odds & Ends",
    description: "Luck and Chance can't be seen by humans except Fortune, who loses her memories each loop. With twelve loops remaining, The Odds confront what lies after.",
    bio: "Odds & Ends follows Luck, Chance, and Fortune as they race against a shrinking timeloop. Each iteration, Fortune's memory resets, and the window before the next reset shrinks by several hours. With only twelve loops left, they must discover what happens when the loop finally ends. This series explores the impetus to experience and share stories.",
    tags: ["series", "primary", "timeloop", "probability"],
    metadata: {
      status: "planned",
      protagonists: ["Luck", "Chance", "Fortune"],
      themes: ["timeloop", "memory", "probability", "finite-time", "experience"],
      subtext: "The impetus to experience and share stories, to understand and be understood"
    }
  },

  "series_quality_control": {
    id: "series_quality_control",
    type: "series",
    folder: "story_structure",
    parentId: null,
    name: "Quality Control",
    description: "Penelope, Zeke, and Mindy team up to take down The Order, but their success splinters reality.",
    bio: "Quality Control is split into two parts. Part I: The trio confronts The Order, a secret cabal manipulating their adventures. Part II: Their victory splinters reality into thematic tangent worlds, introducing Constance and Variance. This is a loving hate-letter to franchise fiction and the commodification of art, exploring choice versus obligation.",
    tags: ["series", "crossover", "meta", "franchise"],
    metadata: {
      status: "planned",
      protagonists: ["Penelope", "Ziya", "Mindy"],
      themes: ["franchise-fiction", "commodification", "choice-vs-obligation", "reality-splintering"],
      subtext: "Balance of choice and obligation in storytelling and life"
    }
  },

  "series_reality_shows": {
    id: "series_reality_shows",
    type: "series",
    folder: "story_structure",
    parentId: null,
    name: "Reality Shows",
    description: "Reality hosts interviews with self-aware versions of characters who take on the aggregate persona of their creators.",
    bio: "Reality Shows is a thoughtful reflection on the role of ego in storytelling and the intersection of intent and expression. It's the tell-all behind-the-scenes podcast, but heavily romanticized‚Äîperfectly idyllic in its lack of glory. It contemplates self-awareness as opposed to sincerity, then shakes this anxiety with assurance of goodwill.",
    tags: ["series", "meta", "interviews", "self-aware"],
    metadata: {
      status: "planned",
      host: "Reality",
      themes: ["ego-in-storytelling", "intent-vs-expression", "self-awareness", "sincerity"],
      subtext: "The gimmick of self-awareness as intrinsically opposed to sincerity"
    }
  },

  "series_sun_settings": {
    id: "series_sun_settings",
    type: "series",
    folder: "story_structure",
    parentId: null,
    name: "Sun.Settings",
    description: "What we leave behind in pursuit of self-actualization. A revenge tale with no target.",
    bio: "Sun.Settings follows Angel piloting the N3-D4L through the Haze Stack - the blur between reality strands. It has the makings of a revenge tale with no target. The target is the absence of answers, the essence of ambiguity. It explores the necessity of defining beginnings and ends, and of sacrificing our darlings‚Äîcreation as curation.",
    tags: ["series", "meta", "post-penelope", "angel"],
    metadata: {
      status: "planned",
      protagonist: "Angel (Post-Penelope)",
      themes: ["self-actualization", "sacrifice", "ambiguity", "curation", "endings"],
      subtext: "What we leave behind in pursuit of self-actualization"
    }
  },

  "season_now_s1": {
    id: "season_now_s1",
    type: "season",
    folder: "story_structure",
    parentId: "series_now_presenting",
    name: "Season 1: Against the Zeitgeist",
    description: "Penelope faces off against The Zeitgeist, embracing individuality over fast-moving trends.",
    tags: ["season", "timescape"],
    metadata: {
      episodeCount: 12,
      status: "complete",
      mainAntagonist: "The Zeitgeist"
    }
  },

  "arc_discovery": {
    id: "arc_discovery",
    type: "arc",
    folder: "story_structure",
    parentId: "season_now_s1",
    name: "The Discovery Arc",
    description: "Penelope discovers the Timepiece and begins her journey into the Timescape.",
    tags: ["arc", "origin", "discovery"],
    metadata: {
      keyMoments: ["Finding the Timepiece", "Meeting Past and Future", "First journey to Timescape"]
    }
  },

  "story_awakening": {
    id: "story_awakening",
    type: "story",
    folder: "story_structure",
    parentId: "arc_discovery",
    name: "The Awakening",
    description: "Penelope's mundane morning transforms when she discovers a mysterious timepiece.",
    tags: ["story", "origin", "timescape"],
    metadata: {
      wordCount: 7200,
      status: "complete"
    }
  },

  "act_ordinary_world": {
    id: "act_ordinary_world",
    type: "act",
    folder: "story_structure",
    parentId: "story_awakening",
    name: "Act 1: Ordinary World",
    description: "Penelope's life before discovering the Timepiece.",
    tags: ["act", "setup"],
    metadata: {}
  },

  "sequence_morning_routine": {
    id: "sequence_morning_routine",
    type: "sequence",
    folder: "story_structure",
    parentId: "act_ordinary_world",
    name: "Morning Routine",
    description: "Penelope's typical morning unfolds with hints that something is different.",
    tags: ["sequence", "slice-of-life"],
    metadata: {}
  },

  "scene_bedroom": {
    id: "scene_bedroom",
    type: "scene",
    folder: "story_structure",
    parentId: "sequence_morning_routine",
    name: "The Bedroom",
    description: "Penelope wakes up and notices something glowing in her room.",
    locationId: null,
    date: null,
    time: null,
    characters: ["char_penelope"],
    tags: ["scene", "discovery", "morning"],
    metadata: {}
  },

  "moment_wakeup": {
    id: "moment_wakeup",
    type: "moment",
    folder: "story_structure",
    parentId: "scene_bedroom",
    name: "The Wakeup Call",
    description: "{{char_penelope}}'s eyes snap open to an unusual golden light.",
    characters: ["char_penelope"],
    content: "{{char_penelope}}'s eyes snapped open. Something was wrong‚Äînot dangerous wrong, but different wrong. The kind of wrong that makes you sit up in bed and actually look around instead of hitting snooze for the third time.\n\nGolden light pulsed from her desk drawer, casting clock-hand shadows that swept across her ceiling in impossible directions. Past, future, sideways through moments she'd never lived.\n\nShe should have been afraid. Instead, she was curious.\n\nThat was her first mistake. Or maybe her first step toward something extraordinary.",
    tags: ["moment", "inciting-incident", "discovery"],
    metadata: {
      beats: ["awakening", "notice-light", "curiosity", "approach"],
      characterActions: {
        char_penelope: ["wakes", "notices_light", "feels_curious", "decides_to_investigate"]
      }
    }
  },

  "moment_first_meeting": {
    id: "moment_first_meeting",
    type: "moment",
    folder: "story_structure",
    parentId: "scene_bedroom",
    name: "Meeting Past and Future",
    description: "{{char_penelope}} meets {{deity_past}} and {{deity_future}} for the first time in the Timescape.",
    characters: ["char_penelope", "deity_past", "deity_future"],
    content: "The light consumed everything, and when it faded, {{char_penelope}} was no longer in her bedroom. She stood in a place that felt like memory and possibility had collided and built a landscape from the wreckage.\n\n\"Well, look who finally showed up!\" A voice, bright and energetic.\n\n\"Past, don't overwhelm her,\" another voice, gentler. \"She's just arrived.\"\n\nTwo figures materialized before her‚Äîone practically vibrating with enthusiasm, the other radiating calm purpose.",
    tags: ["moment", "first-contact", "timescape"],
    metadata: {
      beats: ["arrival", "introduction", "orientation"],
      characterActions: {
        char_penelope: ["arrives_timescape", "meets_deities", "begins_understanding"],
        deity_past: ["greets_enthusiastically", "introduces_self"],
        deity_future: ["moderates", "welcomes_gently"]
      }
    }
  },

  "moment_xandy_freed": {
    id: "moment_xandy_freed",
    type: "moment",
    folder: "story_structure",
    parentId: "scene_bedroom",
    name: "X and Y Break Free",
    description: "{{char_ziya}} accidentally shatters the Origin Point prison, releasing {{char_captain_x}} and {{char_captain_y}}.",
    characters: ["char_ziya", "char_captain_x", "char_captain_y"],
    content: "{{char_ziya}}'s fingers brushed the surface of the strange sphere, and reality fractured like safety glass. The containment field screamed as it collapsed.\n\nTwo figures emerged from the prismatic shards‚Äîone moving with cocky confidence, the other with measured precision.\n\n\"Freedom!\" the first one shouted. \"Kid, you have NO idea what you just‚Äî\"\n\n\"We're bound,\" the second interrupted, voice flat with realization. \"The prison... it bound us to her.\"\n\nThe blue light from the shattered Origin Point flowed like liquid, wrapping around Ziya's shoulders, solidifying into a hoodie that hummed with cosmic energy.",
    tags: ["moment", "inciting-incident", "spatial", "binding"],
    metadata: {
      beats: ["touch", "shattering", "emergence", "binding", "realization"],
      characterActions: {
        char_ziya: ["touches_sphere", "shatters_prison", "receives_hoodie", "becomes_ward"],
        char_captain_x: ["emerges", "celebrates_freedom", "realizes_binding"],
        char_captain_y: ["emerges", "assesses_situation", "confirms_binding"]
      }
    }
  },

  "moment_manor_threshold": {
    id: "moment_manor_threshold",
    type: "moment",
    folder: "story_structure",
    parentId: "scene_bedroom",
    name: "Crossing the Manor Threshold",
    description: "{{char_mindy}} arrives at Mindiore Manors and meets {{char_grey_ma}} for the first time.",
    characters: ["char_mindy", "char_grey_ma"],
    content: "The Manors looked abandoned from the street‚Äîpeeling paint, overgrown gardens, windows that seemed to absorb light rather than reflect it.\n\nBut the moment {{char_mindy}} crossed the threshold, everything shifted. The interior was warm, alive, humming with psychic energy that made her skin tingle.\n\n\"You're late,\" a voice said from the shadows. An elderly woman emerged, eyes sharp despite their clouded appearance. \"I've been holding this burden for you for forty-three years, child. Let's not waste any more time.\"\n\n\"I... I don't understand,\" Mindy stammered.\n\n{{char_grey_ma}} smiled, sad and knowing. \"You will. You're the last one. The prophecy ends with you‚Äîor begins, depending on your perspective.\"",
    tags: ["moment", "arrival", "prophecy", "inheritance"],
    metadata: {
      beats: ["arrival", "threshold_crossing", "first_meeting", "prophecy_revealed"],
      characterActions: {
        char_mindy: ["arrives", "crosses_threshold", "feels_energy", "meets_matriarch", "learns_destiny"],
        char_grey_ma: ["greets", "reveals_waiting", "announces_prophecy", "begins_passing_torch"]
      }
    }
  },

  // ========== META TIMELINE - CONCEPT EVOLUTION ==========
  
  "meta_shower_thought": {
    id: "meta_shower_thought",
    type: "meta_concept",
    folder: "meta_concepts",
    name: "Family Time (Shower Thought)",
    evolutionStage: 1,
    realWorldDate: "Early Conception",
    description: "The original shower thought that started it all - an animated family sitcom.",
    content: "The very first spark: 'What if Father Time had triplets and they were a dysfunctional Full House-style family?' An animated family sitcom called 'Family Time' featuring Past, Present, and Future as bickering siblings navigating everyday life while managing the flow of time. Pure sitcom hijinks with a temporal twist.",
    keyElements: [
      "Father Time as patriarch",
      "Past, Present, Future as triplet siblings",
      "Full House / family sitcom format",
      "Everyday situations with time powers",
      "Animated series concept"
    ],
    whatEvolved: "This gag concept evolved into something more heroic and adventure-focused",
    tags: ["origin", "sitcom", "family-dynamics", "comedic"],
    metadata: {
      tone: "Light comedy, family sitcom",
      format: "Animated TV series",
      targetAudience: "Family/All ages"
    }
  },

  "meta_presently_penelope": {
    id: "meta_presently_penelope",
    type: "meta_concept",
    folder: "meta_concepts",
    name: "Presently Penelope",
    evolutionStage: 2,
    realWorldDate: "Early Development",
    description: "Evolution into a time-hopping hero concept with a young protagonist.",
    content: "The concept matured from family sitcom to adventure series. 'Presently Penelope' introduced a young female protagonist who could hop through time, having adventures across different eras. The focus shifted from domestic comedy to episodic time-travel adventures. Past and Future became supporting characters/guides rather than co-leads.",
    keyElements: [
      "Penelope as protagonist",
      "Time-hopping adventures",
      "Episodic structure",
      "Past and Future as guides/mentors",
      "Educational potential (historical periods)",
      "Action-adventure tone"
    ],
    whatEvolved: "The time-travel mechanics shifted from 'through time' to 'to time as a place'",
    tags: ["hero-journey", "time-travel", "adventure", "education"],
    metadata: {
      tone: "Adventure, educational",
      format: "Animated series",
      targetAudience: "Kids/Young teens"
    }
  },

  "meta_now_presenting": {
    id: "meta_now_presenting",
    type: "meta_concept",
    folder: "meta_concepts",
    name: "Now Presenting (Current Canon)",
    evolutionStage: 3,
    realWorldDate: "Current",
    description: "The refined concept: traveling TO time, not THROUGH time. Time as a place with its own geography.",
    content: "'Now Presenting' represents the breakthrough: What if time isn't a line you travel along, but a PLACE you travel to? The Timescape became a physical realm with geography‚ÄîThe Current, River Delta, Dunes of Yore. Past and Future aren't just guides, they ARE their domains. The Present isn't a character but a gift to humanity. This shift transformed everything from episodic time-travel to exploring the forces and ideas that shape the present moment.",
    keyElements: [
      "Time as a physical place (Timescape)",
      "The Current, River Delta, Dunes of Yore as locations",
      "Past and Future embody their domains",
      "Present as a gift, not a character",
      "Exploring forces that shape 'now'",
      "Meta-narrative about storytelling itself",
      "Fourth wall awareness"
    ],
    whatEvolved: "This is the current canon form, though it continues to expand",
    tags: ["current-canon", "timescape", "meta-narrative", "conceptual"],
    metadata: {
      tone: "Adventure, philosophical, meta",
      format: "Animated series / Multimedia",
      targetAudience: "Teens/Young adults"
    }
  },

  // ========== META TIMELINE - SCRAPPED IDEAS (CUT CONTENT) ==========

  "meta_scrapped_days_week": {
    id: "meta_scrapped_days_week",
    type: "meta_concept",
    folder: "meta_concepts",
    name: "Days of the Week as Characters",
    canonStatus: "cut",
    statusPrior: "Explored",
    description: "Each day of the week personified, including Thursday as a Thor-like warrior.",
    content: "An early concept involved personifying all the days of the week as distinct characters with their own personalities and powers. Monday would be grumpy and sluggish, Friday would be energetic and party-ready, and Thursday would be a Thor-like warrior (playing on the etymology - Thor's Day). Each episode would focus on a different day's perspective and challenges.",
    whyScrapped: "Too many characters diluted the core concept. The episodic 'day of the week' structure felt limiting and gimmicky. The connection between days and their personalities felt arbitrary rather than meaningful.",
    learnings: [
      "Focus on driving forces rather than arbitrary divisions",
      "Quality over quantity in character roster",
      "Thematic resonance matters more than clever wordplay",
      "Etymology-based connections (Thursday/Thor) showed appeal of mythological roots"
    ],
    potentialElements: "The 'Thursday as Thor' concept showed the appeal of mythological connections, which evolved into the Greco-Roman inspired deity system.",
    tags: ["scrapped", "character-concept", "episodic"],
    metadata: {
      scrapStage: "Early development",
      reason: "Too diluted, gimmicky",
      whatSurvived: "Mythological inspiration for deities"
    }
  },

  "meta_scrapped_all_time_units": {
    id: "meta_scrapped_all_time_units",
    type: "meta_concept",
    folder: "meta_concepts",
    name: "All Time Units Personified",
    canonStatus: "cut",
    statusPrior: "Explored",
    description: "Every segment of time (months, minutes, seconds, etc.) as individual characters.",
    content: "An ambitious but unwieldy concept: What if EVERY unit of time had a character? Months, weeks, days, hours, minutes, seconds, milliseconds‚Äîall personified with their own domains and personalities. January would be cold and new-beginning focused, June would be warm and celebratory, Minute would be fast-paced and efficient, Hour would be more measured and deliberate. The Timescape would be infinitely subdivided.",
    whyScrapped: "Completely unmanageable cast size. Lost the forest for the trees‚Äîfocusing on arbitrary divisions rather than meaningful forces. Would require endless exposition and character introduction. The world-building became a chore rather than enriching the story.",
    learnings: [
      "Simplify to the essential",
      "Focus on endpoints (Past/Future) and the journey-maker (Current)",
      "Let driving forces tell the story, not measurement units",
      "World-building should enrich, not burden the narrative",
      "Subdivision can obscure rather than clarify"
    ],
    potentialElements: "The idea of 'denizens' within each domain survived‚ÄîThe Current has inhabitants, but they're not personified time units. They're the forces that shape the present (trends, movements, ideas).",
    tags: ["scrapped", "world-building", "over-complicated"],
    metadata: {
      scrapStage: "Early development",
      reason: "Unmanageable, lost focus",
      whatSurvived: "Concept of domain denizens (non-personified time units)"
    }
  },

  "meta_scrapped_present_character": {
    id: "meta_scrapped_present_character",
    type: "meta_concept",
    folder: "meta_concepts",
    name: "Present as a Triplet Character",
    canonStatus: "cut",
    statusPrior: "Explored",
    description: "The Present as a third sibling alongside Past and Future.",
    content: "In early versions, Present was a character‚Äîthe third triplet alongside Past and Future. They would be the mediator, the balanced one, the 'normal' sibling caught between their more extreme sisters. This fit the family sitcom format but became redundant as the concept evolved.",
    whyScrapped: "The Present being a character felt redundant and less interesting than making it a GIFT. Having the Present be something humanity experiences (conscious awareness) rather than a person made the cosmology more meaningful. It also solved the 'why is Penelope special?' problem‚Äîshe's not replacing Present, she's experiencing the gift of Present.",
    learnings: [
      "Sometimes absence is more powerful than presence",
      "The Present as a gift to humanity is more profound than Present as a person",
      "Negative space in world-building can be meaningful",
      "Character redundancy weakens narrative impact",
      "Cosmological significance > character balance"
    ],
    potentialElements: "The Zeitgeist character emerged as a way to explore 'the spirit of the present' without making Present itself a character.",
    tags: ["scrapped", "character-concept", "cosmology"],
    metadata: {
      scrapStage: "Mid development",
      reason: "Redundant, less meaningful than alternative",
      whatSurvived: "The Zeitgeist as 'spirit of the present'"
    }
  },

  "meta_scrapped_xyz_rowdy_boys": {
    id: "meta_scrapped_xyz_rowdy_boys",
    type: "meta_concept",
    folder: "meta_concepts",
    name: "X, Y, and Zeke - The Rowdy Rough Boys",
    canonStatus: "cut",
    statusPrior: "Explored",
    description: "X, Y, and Zeke as tongue-in-cheek rivals to the time trio (Past, Present, Future).",
    content: "X, Y, and Zeke started as a deliberate counterpart to the time trio‚Äîwhere Penelope, Past, and Future explored time, X, Y, and Zeke would explore space. The name 'Zeke' was intentionally masculine and the trio was conceived as 'The Rowdy Rough Boys,' a tongue-in-cheek reference to the Rowdyruff Boys from Powerpuff Girls. They were meant to be brash, chaotic rivals who represented the spatial dimensions in contrast to the temporal ones. The dynamic was more adversarial and comedic.",
    whyScrapped: "The 'rival trio' concept felt too derivative and limited their narrative potential. The tongue-in-cheek reference was fun but constrained character depth. Making them reformed villains (the Outlaws of Physics) with a rich backstory was more compelling than simple rivals. Changing Zeke to Ziya (a girl) added more diversity and opened up new character dynamics, including the crush on Penelope subplot.",
    learnings: [
      "Homage and reference are fun but shouldn't limit character potential",
      "Reformed villains with backstory > simple rivals",
      "Gender diversity enriches character dynamics and relationships",
      "Tongue-in-cheek concepts can evolve into serious, layered characters",
      "Spatial heroes don't need to mirror temporal heroes structurally"
    ],
    potentialElements: "The core concept of X and Y as spatial axis captains survived and was enriched. The Origin Point prison concept emerged from rethinking their origin. Zeke became Ziya with added depth, shyness, and romantic subplot.",
    tags: ["scrapped", "character-concept", "spatial-heroes", "rival-trio"],
    metadata: {
      scrapStage: "Early-mid development",
      reason: "Too derivative, limited narrative potential, needed more diversity",
      whatSurvived: "X and Y as spatial captains, spatial hero concept, Origin Point artifact",
      reference: "Rowdyruff Boys (Powerpuff Girls)"
    }
  }
};

// ========== DIALOGUE SYSTEM ==========
// Dialogue entries are always tied to a moment and character
// Direct speech: immediate, in-scene
// Delayed send: messages, letters, notes with receipt moment
const dialogues = [
  {
    id: "dlg_penelope_wakeup_1",
    momentId: "moment_wakeup",
    speaker: "char_penelope",
    addressedTo: "self",
    dialogueType: "internal",
    content: "What... what is that light?",
    timestamp: "immediate",
    metadata: {
      emotion: "curious",
      volume: "whisper"
    }
  },
  {
    id: "dlg_penelope_wakeup_2",
    momentId: "moment_wakeup",
    speaker: "char_penelope",
    addressedTo: "self",
    dialogueType: "internal",
    content: "I should probably be scared. Why am I not scared?",
    timestamp: "immediate",
    metadata: {
      emotion: "puzzled"
    }
  },
  {
    id: "dlg_past_greeting",
    momentId: "moment_first_meeting",
    speaker: "deity_past",
    addressedTo: "char_penelope",
    dialogueType: "speech",
    content: "Well, look who finally showed up!",
    timestamp: "immediate",
    metadata: {
      emotion: "enthusiastic",
      volume: "excited"
    }
  },
  {
    id: "dlg_future_calming",
    momentId: "moment_first_meeting",
    speaker: "deity_future",
    addressedTo: "deity_past",
    dialogueType: "speech",
    content: "Past, don't overwhelm her. She's just arrived.",
    timestamp: "immediate",
    metadata: {
      emotion: "gentle",
      volume: "moderate"
    }
  },
  {
    id: "dlg_x_freedom",
    momentId: "moment_xandy_freed",
    speaker: "char_captain_x",
    addressedTo: "char_zeke",
    dialogueType: "speech",
    content: "Freedom! Kid, you have NO idea what you just‚Äî",
    timestamp: "immediate",
    metadata: {
      emotion: "elated",
      volume: "shout",
      interrupted: true
    }
  },
  {
    id: "dlg_y_realization",
    momentId: "moment_xandy_freed",
    speaker: "char_captain_y",
    addressedTo: "char_captain_x",
    dialogueType: "speech",
    content: "We're bound. The prison... it bound us to him.",
    timestamp: "immediate",
    metadata: {
      emotion: "resigned",
      volume: "flat"
    }
  },
  {
    id: "dlg_greyma_late",
    momentId: "moment_manor_threshold",
    speaker: "char_grey_ma",
    addressedTo: "char_mindy",
    dialogueType: "speech",
    content: "You're late. I've been holding this burden for you for forty-three years, child. Let's not waste any more time.",
    timestamp: "immediate",
    metadata: {
      emotion: "knowing",
      volume: "moderate"
    }
  },
  {
    id: "dlg_mindy_confusion",
    momentId: "moment_manor_threshold",
    speaker: "char_mindy",
    addressedTo: "char_grey_ma",
    dialogueType: "speech",
    content: "I... I don't understand.",
    timestamp: "immediate",
    metadata: {
      emotion: "confused",
      volume: "stammer"
    }
  },
  {
    id: "dlg_greyma_prophecy",
    momentId: "moment_manor_threshold",
    speaker: "char_grey_ma",
    addressedTo: "char_mindy",
    dialogueType: "speech",
    content: "You will. You're the last one. The prophecy ends with you‚Äîor begins, depending on your perspective.",
    timestamp: "immediate",
    metadata: {
      emotion: "sad_knowing",
      volume: "moderate"
    }
  }
];

// Delayed messages (letters, notes, etc) with separate send/receive moments
const delayedMessages = [
  {
    id: "msg_order_warning",
    sendMomentId: "moment_wakeup", // example - would be a different moment
    receiveMomentId: null, // to be created
    speaker: "char_carter_blanche",
    addressedTo: ["faction_the_order"],
    actualRecipient: "char_mindy", // intercepted by Mindy
    messageType: "letter",
    content: "The psychic is awakening faster than anticipated. Recommend immediate observation protocol. Her familiar manifestation could destabilize the Flipside if not properly guided. Advise containment measures be prepared. - CB",
    intercepted: true,
    interceptedBy: "char_mindy",
    metadata: {
      sealed: false,
      condition: "opened by interceptor",
      interceptedHow: "Psychic detection in Flipside"
    }
  }
];

// ========== EVENT OUTCOMES SYSTEM ==========
// Define how events affect character journey traits
// Each outcome tracks: character affected, trait changes (growth/setback), alignment shifts
const eventOutcomes = [
  {
    eventId: "event_timepiece_discovery",
    momentId: "moment_wakeup",
    characterId: "char_penelope",
    traitModifiers: {
      confidence: { change: +1, reason: "Successfully faced the unknown" },
      intuition: { change: +1, reason: "Listened to curiosity over fear" },
      mastery: { change: +1, reason: "First step toward controlling the Timepiece" }
    },
    alignmentModifiers: {
      lawful_chaotic: { change: +1, reason: "Chose spontaneity over routine" }
    },
    outcomeType: "growth", // "growth", "setback", "neutral", "mixed"
    narrativeImpact: "Penelope's first contact with the Timescape set her on the path of the Hero of Time."
  },
  {
    eventId: "event_timepiece_discovery",
    momentId: "moment_first_meeting",
    characterId: "char_penelope",
    traitModifiers: {
      wisdom: { change: +1, reason: "Gained knowledge of Time as a place" },
      confidence: { change: +1, reason: "Accepted by Past and Future" },
      maturity: { change: +1, reason: "Realized greater forces at work" }
    },
    alignmentModifiers: {},
    outcomeType: "growth",
    narrativeImpact: "Meeting Past and Future expanded Penelope's understanding of reality."
  },
  {
    eventId: "event_manors_arrival",
    momentId: "moment_manor_threshold",
    characterId: "char_mindy",
    traitModifiers: {
      scorn: { change: -1, reason: "Found acceptance after rejection" },
      confidence: { change: -1, reason: "Overwhelmed by prophecy revelation" },
      wisdom: { change: +1, reason: "Learned of her true heritage" },
      intuition: { change: +1, reason: "Felt the psychic energy of the Manors" }
    },
    alignmentModifiers: {},
    outcomeType: "mixed",
    narrativeImpact: "Mindy found sanctuary but learned the weight of her destiny."
  },
  {
    eventId: "event_origin_activation",
    momentId: "moment_xandy_freed",
    characterId: "char_ziya",
    traitModifiers: {
      mastery: { change: +1, reason: "Gained the Origin Point artifact" },
      confidence: { change: -1, reason: "Bound to powerful entities beyond her control" },
      maturity: { change: -1, reason: "Impulsive action had major consequences" }
    },
    alignmentModifiers: {
      lawful_chaotic: { change: +2, reason: "Broke cosmic prison through reckless curiosity" }
    },
    outcomeType: "mixed",
    narrativeImpact: "Ziya gained power but lost freedom, bound as ward to X and Y."
  }
];

// ========== EVOLUTION OF DESIRES ==========
// Track critical shifts in what a character wants over time
// Just like motivations change, this shows the progression of desires
const desireEvolution = [
  {
    characterId: "char_ziya",
    desireId: "desire_ziya_freedom",
    momentId: null, // Initial state
    timestamp: "Before Origin Point",
    desire: "Live freely without constraints",
    priority: "high",
    status: "active",
    category: "freedom"
  },
  {
    characterId: "char_ziya",
    desireId: "desire_ziya_bound",
    momentId: "moment_xandy_freed",
    timestamp: "Freeing X and Y",
    desire: "Help X and Y restore powers to earn freedom",
    priority: "critical",
    status: "active",
    category: "obligation",
    replacedDesire: "desire_ziya_freedom",
    reason: "Bound as ward to X and Y after freeing them"
  },
  {
    characterId: "char_ziya",
    desireId: "desire_ziya_penelope_crush",
    momentId: null, // Ongoing
    timestamp: "Throughout Personal Space",
    desire: "Work up courage to talk to Penelope",
    priority: "medium",
    status: "unfulfilled",
    category: "romance",
    conflictsWith: ["desire_ziya_bound"],
    reason: "Has a crush on Penelope but is too shy to act on it, and bound obligations leave little time"
  },
  {
    characterId: "char_captain_x",
    desireId: "desire_x_conquest",
    momentId: null,
    timestamp: "Pre-imprisonment",
    desire: "Expand across the universe, conquer and explore",
    priority: "critical",
    status: "abandoned",
    category: "power",
    reason: "The Outlaws of Physics went on a universe expansion bender"
  },
  {
    characterId: "char_captain_x",
    desireId: "desire_x_freedom",
    momentId: null,
    timestamp: "During imprisonment",
    desire: "Escape the Origin Point prison",
    priority: "critical",
    status: "fulfilled",
    category: "freedom",
    replacedDesire: "desire_x_conquest",
    reason: "Imprisoned by The Matternal for cosmic carnage"
  },
  {
    characterId: "char_captain_x",
    desireId: "desire_x_redemption",
    momentId: "moment_xandy_freed",
    timestamp: "After release",
    desire: "Restore powers and make amends for past damage",
    priority: "high",
    status: "active",
    category: "redemption",
    replacedDesire: "desire_x_freedom",
    reason: "Freed but bound to Ziya, must face consequences"
  },
  {
    characterId: "char_captain_y",
    desireId: "desire_y_conquest",
    momentId: null,
    timestamp: "Pre-imprisonment",
    desire: "Partner with X in universe expansion",
    priority: "critical",
    status: "abandoned",
    category: "power",
    reason: "The Outlaws of Physics went on a conquest together"
  },
  {
    characterId: "char_captain_y",
    desireId: "desire_y_atonement",
    momentId: "moment_xandy_freed",
    timestamp: "After release",
    desire: "Methodically undo damage and guide Ziya",
    priority: "critical",
    status: "active",
    category: "redemption",
    replacedDesire: "desire_y_conquest",
    reason: "More remorseful than X, seeks to make things right"
  },
  {
    characterId: "char_penelope",
    desireId: "desire_penelope_understand",
    momentId: "moment_wakeup",
    timestamp: "Beginning",
    desire: "Understand the forces that shape reality",
    priority: "high",
    status: "active",
    category: "knowledge"
  },
  {
    characterId: "char_penelope",
    desireId: "desire_penelope_individuality",
    momentId: null,
    timestamp: "Season 1",
    desire: "Embrace individuality over conformity",
    priority: "critical",
    status: "fulfilled",
    category: "identity",
    reason: "Faces The Zeitgeist and chooses authentic self"
  },
  {
    characterId: "char_penelope",
    desireId: "desire_penelope_reality",
    momentId: null,
    timestamp: "Quality Control",
    desire: "Break through narrative boundaries and become Reality",
    priority: "critical",
    status: "fulfilled",
    category: "transcendence",
    reason: "Discovers her truest nature as bridge between fiction and reality"
  }
];

// Helper function to get desire evolution for a character
function getDesireEvolution(characterId) {
  return desireEvolution
    .filter(d => d.characterId === characterId)
    .sort((a, b) => {
      // Sort by timestamp or moment
      if (!a.momentId && b.momentId) return -1;
      if (a.momentId && !b.momentId) return 1;
      return 0;
    });
}

// Helper function to get active desires for a character
function getActiveDesires(characterId) {
  return desireEvolution.filter(d => 
    d.characterId === characterId && 
    d.status === "active"
  );
}

// Helper function to get desire conflicts
function getDesireConflicts(characterId) {
  const desires = getActiveDesires(characterId);
  const conflicts = [];
  
  desires.forEach(desire => {
    if (desire.conflictsWith) {
      desire.conflictsWith.forEach(conflictId => {
        const conflictingDesire = desireEvolution.find(d => d.desireId === conflictId);
        if (conflictingDesire && conflictingDesire.status === "active") {
          conflicts.push({
            desire1: desire,
            desire2: conflictingDesire
          });
        }
      });
    }
  });
  
  return conflicts;
}

// ========== CHARACTER JOURNEY TRACKING ==========
// Track character trait values over time points
// Each entry represents a snapshot at a specific moment/event
// Should be calculated from base stats + accumulated eventOutcomes
const characterJourneys = [
  {
    characterId: "char_penelope",
    momentId: "moment_wakeup",
    timestamp: "Beginning",
    traits: {
      mastery: 2,      // 0-10 scale
      wisdom: 3,
      confidence: 4,
      maturity: 3,
      grace: 5,
      intuition: 6,
      scorn: 1,
      vengeance: 0
    },
    alignment: {
      lawful_chaotic: -2,  // -5 (Lawful) to +5 (Chaotic)
      good_evil: -4         // -5 (Good) to +5 (Evil)
    },
    outcomes: ["event_timepiece_discovery"] // References to outcome IDs that led to this state
  },
  {
    characterId: "char_penelope",
    momentId: "moment_first_meeting",
    timestamp: "First Contact",
    traits: {
      mastery: 3,
      wisdom: 4,
      confidence: 5,
      maturity: 4,
      grace: 5,
      intuition: 7,
      scorn: 1,
      vengeance: 0
    },
    alignment: {
      lawful_chaotic: -1,
      good_evil: -4
    }
  },
  {
    characterId: "char_mindy",
    momentId: "moment_manor_threshold",
    timestamp: "Arrival at Manors",
    traits: {
      mastery: 1,
      wisdom: 4,
      confidence: 3,
      maturity: 4,
      grace: 4,
      intuition: 8,
      scorn: 2,
      vengeance: 1
    },
    alignment: {
      lawful_chaotic: 0,
      good_evil: -3
    }
  },
  {
    characterId: "char_ziya",
    momentId: "moment_xandy_freed",
    timestamp: "Freeing X and Y",
    traits: {
      mastery: 1,
      wisdom: 2,
      confidence: 4,
      maturity: 2,
      grace: 3,
      intuition: 5,
      scorn: 0,
      vengeance: 0
    },
    alignment: {
      lawful_chaotic: 2,
      good_evil: -4
    }
  }
];

// Available traits for visualization
const availableTraits = [
  'mastery',
  'wisdom',
  'confidence',
  'maturity',
  'grace',
  'intuition',
  'scorn',
  'vengeance',
  'compassion',
  'cunning',
  'discipline',
  'passion',
  'pragmatism',
  'idealism'
];

// Story-Character Connections (defines character involvement in series/stories)
const storyConnections = [
  {
    characterId: "char_penelope",
    seriesId: "series_now_presenting",
    type: "primary",
    description: "Penelope is the primary protagonist, Hero of Time."
  },
  {
    characterId: "deity_past",
    seriesId: "series_now_presenting",
    type: "primary",
    description: "Past is a co-protagonist, guide, and daughter of Father Time."
  },
  {
    characterId: "deity_future",
    seriesId: "series_now_presenting",
    type: "primary",
    description: "Future is a co-protagonist, guide, and daughter of Father Time."
  },
  {
    characterId: "char_celli",
    seriesId: "series_celli",
    type: "primary",
    description: "Celli is the protagonist exploring atomic narrative."
  },
  {
    characterId: "char_like",
    seriesId: "series_celli",
    type: "primary",
    description: "Like represents engagement in the Loomworks framework."
  },
  {
    characterId: "char_comment",
    seriesId: "series_celli",
    type: "primary",
    description: "Comment represents discourse in the Loomworks framework."
  },
  {
    characterId: "char_send",
    seriesId: "series_celli",
    type: "primary",
    description: "Send represents distribution in the Loomworks framework."
  }
];

// Feedback annotations for generated content
const feedbackAnnotations = [];

// Generated content storage
const generatedContent = {
  // Format: { id, nodeIds: [], content, timestamp, annotations: [] }
};

// Sentiment/Motivation Evolution Junctions
// These track how sentiments and motivations change over time, driven by events
// Structure: character ‚Üí sentiment/motivation ‚Üí inciting event ‚Üí timestamp
const sentimentJunctions = [
  {
    id: "sent_j_1",
    characterId: "char_val",
    type: "sentiment", // "sentiment" or "motivation"
    name: "Trust in LOOM",
    value: "Resentful but compliant",
    eventId: "event_leak",
    timestamp: "2201-03-15 14:30",
    description: "After leaking the Black Thread documents, Val's trust in LOOM degraded from cautious optimism to active resentment.",
    previousValue: "Cautiously optimistic",
    previousEventId: null,
    previousTimestamp: "2199-01-10 09:00"
  },
  {
    id: "sent_j_2",
    characterId: "char_tori",
    type: "sentiment",
    name: "View of Public Role",
    value: "Performative burden",
    eventId: "event_rescue",
    timestamp: "2200-11-08 22:15",
    description: "The rescue mission made Tori realize her public persona prevents genuine heroism from being acknowledged.",
    previousValue: "Proud representative",
    previousEventId: null,
    previousTimestamp: "2198-06-15 10:00"
  },
  {
    id: "sent_j_3",
    characterId: "char_val",
    type: "motivation",
    name: "Preserve Canon",
    value: "Expose manipulated canon",
    eventId: "event_leak",
    timestamp: "2201-03-15 14:30",
    description: "Val's motivation shifted from preserving canon as-is to exposing how it has been corrupted.",
    previousValue: "Preserve canon faithfully",
    previousEventId: null,
    previousTimestamp: "2195-03-01 08:00"
  },
  {
    id: "sent_j_4",
    characterId: "char_tori",
    type: "motivation",
    name: "Maintain Public Image",
    value: "Protect vulnerable fans",
    eventId: "event_rescue",
    timestamp: "2200-11-08 22:15",
    description: "Tori's primary motivation evolved from maintaining image to genuinely protecting those who look up to her.",
    previousValue: "Maintain flawless public image",
    previousEventId: null,
    previousTimestamp: "2198-01-20 14:00"
  },
  {
    id: "sent_j_5",
    characterId: "char_val",
    type: "sentiment",
    name: "Feelings toward Tori",
    value: "Protective alliance",
    eventId: "event_alliance",
    timestamp: "2201-05-20 03:45",
    description: "The secret alliance deepened Val's protective feelings toward Tori.",
    previousValue: "Professional respect",
    previousEventId: "event_rescue",
    previousTimestamp: "2200-11-09 08:00"
  },
  {
    id: "sent_j_6",
    characterId: "char_tori",
    type: "sentiment",
    name: "Feelings toward Val",
    value: "Deep trust and gratitude",
    eventId: "event_alliance",
    timestamp: "2201-05-20 03:45",
    description: "Tori came to view Val as the only person who truly understands her struggle.",
    previousValue: "Respectful curiosity",
    previousEventId: null,
    previousTimestamp: "2200-06-10 16:00"
  }
];

// Relationships between nodes
const relationships = [
  {
    from: "char_val",
    to: "faction_loom",
    type: "employment",
    nature: "resentful-loyalty",
    description: "Val works for LOOM but increasingly distrusts their methods."
  },
  {
    from: "char_val",
    to: "char_tori",
    type: "alliance",
    nature: "protective-trust",
    description: "Val sees Tori as a rare genuine soul worth protecting."
  },
  {
    from: "char_tori",
    to: "faction_loom",
    type: "employment",
    nature: "contractual-obligated",
    description: "Tori is bound by contract but seeks freedom."
  },
  {
    from: "char_tori",
    to: "char_val",
    type: "alliance",
    nature: "deep-trust",
    description: "Tori would sacrifice her career to protect Val."
  },
  {
    from: "faction_loom",
    to: "artifact_engine",
    type: "ownership",
    nature: "dependent",
    description: "LOOM's power depends entirely on the Engine's functioning."
  },
  {
    from: "faction_resistance",
    to: "faction_loom",
    type: "opposition",
    nature: "ideological-conflict",
    description: "The Unwritten directly oppose LOOM's narrative control."
  },
  {
    from: "faction_loom",
    to: "loc_archive",
    type: "headquarters",
    nature: "operational-base",
    description: "LOOM operates from Central Archive Tower."
  },
  {
    from: "faction_resistance",
    to: "loc_safehouse",
    type: "safehouse",
    nature: "hidden-base",
    description: "The Unwritten use The Margin as their primary meeting point."
  }
];

// ==================== STATE ====================
let activeNodeId = null;
let currentView = "node"; // "node" or "timeline"

// ==================== FOLDER STRUCTURE ====================
// Project-level organization with canon/non-canon separation
const projectStructure = {
  id: "project",
  name: "Project: Loom Universe",
  icon: "üåå",
  children: [
    {
      id: "meta_timeline",
      name: "Meta Timeline",
      icon: "üé≠",
      description: "The real-world evolution of the Loom concept - how the ideas developed",
      children: [
        { id: "meta_concepts", name: "Concept Evolution", icon: "üí°", types: ["meta_concept"] },
        { id: "meta_scrapped", name: "Scrapped Ideas", icon: "üóëÔ∏è", types: ["meta_scrapped"] }
      ]
    },
    {
      id: "cosmology",
      name: "Cosmology",
      icon: "‚ú®",
      description: "Deep lore and creation myths - events beyond time with relative sequencing",
      children: [
        { id: "cosmology_primordials", name: "Primordial Beings", icon: "üåÄ", types: ["primordial"] },
        { id: "cosmology_deities", name: "Deities & Cosmic Forces", icon: "‚ö°", types: ["deity"] },
        { id: "cosmology_events", name: "Cosmological Events", icon: "üí´", types: ["cosmology_event"] }
      ]
    },
    {
      id: "canon",
      name: "Canon",
      icon: "‚úì",
      description: "Official canon content",
      children: [
        { id: "characters", name: "Characters", icon: "üë§", types: ["character"] },
        { id: "factions", name: "Factions", icon: "‚öîÔ∏è", types: ["faction"] },
        { id: "locations", name: "Locations", icon: "üìç", types: ["location"] },
        { id: "events", name: "Events", icon: "üìÖ", types: ["event"] },
        { id: "artifacts", name: "Artifacts", icon: "üíé", types: ["artifact"] },
        { id: "story_structure", name: "Story Structure", icon: "üìñ", types: ["series", "season", "arc", "story", "act", "sequence", "scene", "moment"] }
      ]
    },
    {
      id: "non_canon",
      name: "Non-Canon",
      icon: "‚äó",
      description: "Non-canonical content",
      children: [
        { 
          id: "ai_proposals", 
          name: "AI Draft Proposals", 
          icon: "ü§ñ", 
          types: ["ai_proposal"],
          description: "AI-generated proposals awaiting review" 
        },
        { 
          id: "retconned", 
          name: "Retconned", 
          icon: "‚Ü∫", 
          types: ["character", "event", "location", "artifact", "moment", "story"],
          description: "Previously canon but recontextualized/substituted" 
        },
        { 
          id: "cut", 
          name: "Cut Content", 
          icon: "‚úÇ", 
          types: ["character", "event", "location", "artifact", "moment", "story"],
          description: "Cut from canon",
          statusOptions: ["Explored", "Attempted"]
        },
        { 
          id: "fanfiction", 
          name: "Fan Fiction", 
          icon: "üìù", 
          types: ["character", "event", "location", "artifact", "moment", "story"], 
          description: "Fan-created content" 
        },
        { 
          id: "exploratory", 
          name: "Exploratory/Thematic", 
          icon: "üî¨", 
          types: ["character", "event", "location", "artifact", "moment", "story"], 
          description: "Experimental or thematic explorations" 
        }
      ]
    }
  ]
};

// Legacy flat structure for backwards compatibility
const folderStructure = [
  {
    id: "characters",
    name: "Characters",
    icon: "üë§",
    types: ["character"]
  },
  {
    id: "factions",
    name: "Factions",
    icon: "‚öîÔ∏è",
    types: ["faction"]
  },
  {
    id: "locations",
    name: "Locations",
    icon: "üìç",
    types: ["location"]
  },
  {
    id: "events",
    name: "Events",
    icon: "üìÖ",
    types: ["event"]
  },
  {
    id: "artifacts",
    name: "Artifacts",
    icon: "üíé",
    types: ["artifact"]
  },
  {
    id: "story_structure",
    name: "Story Structure",
    icon: "üìñ",
    types: ["series", "season", "arc", "story", "act", "sequence", "scene", "moment"]
  }
];

// Canon status types
const canonStatus = {
  CANON: "canon",
  RETCONNED: "retconned",
  CUT: "cut",
  FAN_FICTION: "fanfiction",
  EXPLORATORY: "exploratory"
};

// Status prior options for cut content
const cutStatusPrior = {
  EXPLORED: "Explored",
  ATTEMPTED: "Attempted"
};

// ========== AI EVALUATOR SYSTEM ==========

// AI Configuration (stored in localStorage)
const AI_PROVIDERS = {
  openai: { name: 'OpenAI (GPT-4)', placeholder: 'sk-...', storageKey: 'ai_key_openai' },
  anthropic: { name: 'Anthropic (Claude)', placeholder: 'sk-ant-...', storageKey: 'ai_key_anthropic' },
  google: { name: 'Google (Gemini)', placeholder: 'AIza...', storageKey: 'ai_key_google' },
  cohere: { name: 'Cohere', placeholder: 'co-...', storageKey: 'ai_key_cohere' },
  mistral: { name: 'Mistral AI', placeholder: 'mst-...', storageKey: 'ai_key_mistral' },
  groq: { name: 'Groq', placeholder: 'gsk_...', storageKey: 'ai_key_groq' }
};

function getAIConfig() {
  const config = {
    activeProvider: localStorage.getItem('ai_active_provider') || 'openai',
    keys: {}
  };
  
  // Load all API keys
  for (const [provider, info] of Object.entries(AI_PROVIDERS)) {
    config.keys[provider] = localStorage.getItem(info.storageKey) || '';
  }
  
  return config;
}

function setAIProvider(provider) {
  if (AI_PROVIDERS[provider]) {
    localStorage.setItem('ai_active_provider', provider);
  }
}

function setAIKey(provider, apiKey) {
  if (AI_PROVIDERS[provider]) {
    localStorage.setItem(AI_PROVIDERS[provider].storageKey, apiKey);
  }
}

function clearAIKey(provider) {
  if (AI_PROVIDERS[provider]) {
    localStorage.removeItem(AI_PROVIDERS[provider].storageKey);
  }
}

function clearAllAIKeys() {
  for (const [provider, info] of Object.entries(AI_PROVIDERS)) {
    localStorage.removeItem(info.storageKey);
  }
  localStorage.removeItem('ai_active_provider');
}

function getActiveAPIKey() {
  const config = getAIConfig();
  return config.keys[config.activeProvider] || '';
}

// Theme Bank - Tracks recurring themes and their success
const themeBank = [
  { id: "theme_1", name: "Identity vs Conformity", successScore: 8.5, usageCount: 12 },
  { id: "theme_2", name: "Truth vs Obfuscation", successScore: 9.2, usageCount: 8 },
  { id: "theme_3", name: "Time as Place not Line", successScore: 9.8, usageCount: 15 },
  { id: "theme_4", name: "Ascension vs Descent", successScore: 8.7, usageCount: 6 },
  { id: "theme_5", name: "Structure vs Freedom", successScore: 8.9, usageCount: 7 },
  { id: "theme_6", name: "Meta-narrative Awareness", successScore: 9.1, usageCount: 10 },
  { id: "theme_7", name: "Cosmic Consequences", successScore: 8.3, usageCount: 5 },
  { id: "theme_8", name: "Authentic Connection", successScore: 8.8, usageCount: 9 },
  { id: "theme_9", name: "Fragility in Face of Ability", successScore: 8.4, usageCount: 7 },
  { id: "theme_10", name: "Ambition Capped by Opportunity", successScore: 8.6, usageCount: 6 },
  { id: "theme_11", name: "Being One's Own Best Friend", successScore: 9.0, usageCount: 8 },
  { id: "theme_12", name: "Processing Change", successScore: 8.7, usageCount: 11 },
  { id: "theme_13", name: "Power of Vulnerability", successScore: 8.9, usageCount: 9 },
  { id: "theme_14", name: "Legacy vs Living in the Moment", successScore: 8.2, usageCount: 5 },
  { id: "theme_15", name: "Chosen Family vs Blood", successScore: 9.3, usageCount: 10 },
  { id: "theme_16", name: "Breaking Cycles", successScore: 8.8, usageCount: 7 },
  { id: "theme_17", name: "The Weight of Expectations", successScore: 8.5, usageCount: 8 },
  { id: "theme_18", name: "Finding Voice in Silence", successScore: 8.6, usageCount: 6 },
  { id: "theme_19", name: "Imposter Syndrome", successScore: 8.4, usageCount: 9 },
  { id: "theme_20", name: "Grief as Transformation", successScore: 9.1, usageCount: 7 },
  { id: "theme_21", name: "Empathy and Empathy Vectors", successScore: 9.2, usageCount: 8 },
  { id: "theme_22", name: "Light in Darkness (Cosmic and in the Everyday)", successScore: 9.4, usageCount: 10 }
];

// AI Proposals - Generated content awaiting review
const aiProposals = [];

// Evaluation Metrics for Stories
const evaluationMetrics = {
  resonance: { weight: 0.25, description: "How well it connects with audiences emotionally" },
  originality: { weight: 0.20, description: "Novelty and freshness of ideas" },
  alignment: { weight: 0.20, description: "Consistency with established canon and themes" },
  surprise: { weight: 0.15, description: "Unexpected twists that delight" },
  thematic_depth: { weight: 0.10, description: "Richness of thematic exploration" },
  character_growth: { weight: 0.10, description: "Meaningful character development" }
};

// Story Success Scores (tracked per story/arc)
const storyScores = {};

// Helper: Calculate overall score from metrics
function calculateOverallScore(metrics) {
  let total = 0;
  for (const [key, value] of Object.entries(metrics)) {
    if (evaluationMetrics[key]) {
      total += value * evaluationMetrics[key].weight;
    }
  }
  return Math.round(total * 10) / 10;
}

// Helper: Generate AI proposal (placeholder - will call API)
async function generateAIProposal(type, context = {}) {
  const apiKey = getActiveAPIKey();
  const config = getAIConfig();
  
  if (!apiKey) {
    alert(`Please configure an API key for ${AI_PROVIDERS[config.activeProvider].name} first`);
    return null;
  }
  
  // This is a placeholder - in production, this would call an actual AI API
  // The active provider is: config.activeProvider
  // The API key is: apiKey
  // For now, return mock data
  const mockProposal = {
    id: generateId('prop'),
    type: type, // 'moment', 'joke', 'arc', 'interaction', 'standoff'
    title: `AI Generated ${type.charAt(0).toUpperCase() + type.slice(1)}`,
    content: `This is a placeholder for AI-generated ${type} content. In production, this would be generated by an AI model based on the existing nodes and context.`,
    themes: ['theme_1', 'theme_3'],
    metrics: {
      resonance: 7.5 + Math.random() * 2,
      originality: 7.0 + Math.random() * 2.5,
      alignment: 8.0 + Math.random() * 1.5,
      surprise: 6.5 + Math.random() * 3,
      thematic_depth: 7.5 + Math.random() * 2,
      character_growth: 7.0 + Math.random() * 2
    },
    status: 'pending', // 'pending', 'approved', 'rejected', 'refined'
    createdAt: new Date().toISOString(),
    context: context,
    canonStatus: 'ai_proposal'
  };
  
  mockProposal.overallScore = calculateOverallScore(mockProposal.metrics);
  
  return mockProposal;
}

// Helper: Generate Organic Moment Standoff
async function generateOrganicStandoff(char1Id, char2Id, context) {
  const char1 = getNode(char1Id);
  const char2 = getNode(char2Id);
  
  if (!char1 || !char2) return null;
  
  // Get character desires and drives
  const char1Desires = getActiveDesires(char1Id);
  const char2Desires = getActiveDesires(char2Id);
  
  const standoff = {
    id: generateId('standoff'),
    type: 'standoff',
    title: `Standoff: ${char1.name} vs ${char2.name}`,
    content: `${char1.name} and ${char2.name} encounter each other. ${char1.name} wants to ${char1Desires[0]?.desire || "pursue their goals"}, while ${char2.name} wants to ${char2Desires[0]?.desire || "pursue their goals"}. The tension is palpable as both characters prepare to make their move.`,
    characters: [char1Id, char2Id],
    context: context || "An unexpected encounter",
    character1: {
      id: char1Id,
      name: char1.name,
      intention: char1Desires[0]?.desire || "Pursue their goals",
      understanding: "Aware of potential conflict",
      plan: "Make their move"
    },
    character2: {
      id: char2Id,
      name: char2.name,
      intention: char2Desires[0]?.desire || "Pursue their goals",
      understanding: "Aware of potential conflict",
      plan: "Make their move"
    },
    moves: [],
    metrics: {
      resonance: 7.5 + Math.random() * 2,
      originality: 7.0 + Math.random() * 2.5,
      alignment: 8.0 + Math.random() * 1.5,
      surprise: 7.5 + Math.random() * 2.5,
      thematic_depth: 7.0 + Math.random() * 2,
      character_growth: 7.5 + Math.random() * 2
    },
    status: 'pending',
    createdAt: new Date().toISOString(),
    canonStatus: 'ai_proposal'
  };
  
  standoff.overallScore = calculateOverallScore(standoff.metrics);
  
  return standoff;
}

// Helper: Simulate Reddit thread evaluation
async function simulateRedditThread(proposalId, withCritique = false, withContext = false) {
  // Placeholder for parallel AI agents generating faux reddit threads
  const threads = {
    organic: "Generated thread with no guidance...",
    critique: withCritique ? "Generated thread with critical analysis..." : null,
    context: withContext ? "Generated thread explaining how it fits together..." : null
  };
  
  return threads;
}

// ==================== UTILITIES ====================
function getNode(id) {
  return nodes[id] || null;
}

function getNodesByFolder(folderId) {
  return Object.values(nodes).filter(n => n.folder === folderId);
}

function getRelationshipsFor(nodeId) {
  return relationships.filter(r => r.from === nodeId || r.to === nodeId);
}

function getOutgoingRelationships(nodeId) {
  return relationships.filter(r => r.from === nodeId);
}

function getAllEvents() {
  return Object.values(nodes)
    .filter(n => n.type === "event")
    .sort((a, b) => {
      const dateA = new Date(a.date + " " + a.time);
      const dateB = new Date(b.date + " " + b.time);
      return dateA - dateB;
    });
}

function getIconForType(type) {
  const iconMap = {
    character: "üë§",
    faction: "‚öîÔ∏è",
    location: "üìç",
    event: "üìÖ",
    artifact: "üíé",
    meta_concept: "üí°",
    primordial: "üåÄ",
    deity: "‚ö°",
    cosmology_event: "üí´"
  };
  return iconMap[type] || "‚óè";
}

function getSentimentsForCharacter(characterId) {
  return sentimentJunctions
    .filter(sj => sj.characterId === characterId)
    .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
}

function getOutcomesForCharacter(characterId) {
  return eventOutcomes.filter(oc => oc.characterId === characterId);
}

function getOutcomesForMoment(momentId) {
  return eventOutcomes.filter(oc => oc.momentId === momentId || oc.eventId === momentId);
}

function getOutcomeForMomentAndCharacter(momentId, characterId) {
  return eventOutcomes.find(oc => 
    (oc.momentId === momentId || oc.eventId === momentId) && 
    oc.characterId === characterId
  );
}

function generateId(prefix) {
  return prefix + "_" + Date.now() + "_" + Math.random().toString(36).substr(2, 9);
}

function deleteNode(nodeId) {
  if (confirm(`Are you sure you want to delete this node? This action cannot be undone.`)) {
    delete nodes[nodeId];
    // Remove related relationships
    for (let i = relationships.length - 1; i >= 0; i--) {
      if (relationships[i].from === nodeId || relationships[i].to === nodeId) {
        relationships.splice(i, 1);
      }
    }
    // Remove related sentiment junctions
    for (let i = sentimentJunctions.length - 1; i >= 0; i--) {
      if (sentimentJunctions[i].characterId === nodeId || sentimentJunctions[i].eventId === nodeId) {
        sentimentJunctions.splice(i, 1);
      }
    }
    activeNodeId = null;
    renderTree();
    switchView(currentView);
    alert("Node deleted successfully");
  }
}

// Location hierarchy utilities
function getLocationParent(locationId) {
  const loc = getNode(locationId);
  return loc && loc.parentId ? getNode(loc.parentId) : null;
}

function getLocationChildren(locationId) {
  return Object.values(nodes).filter(n => n.type === "location" && n.parentId === locationId);
}

function getLocationHierarchy(locationId) {
  const hierarchy = [];
  let current = getNode(locationId);
  while (current) {
    hierarchy.unshift(current);
    current = current.parentId ? getNode(current.parentId) : null;
  }
  return hierarchy;
}

// Story structure utilities
function getStoryParent(nodeId) {
  const node = getNode(nodeId);
  return node && node.parentId ? getNode(node.parentId) : null;
}

function getStoryChildren(nodeId) {
  return Object.values(nodes).filter(n => n.parentId === nodeId);
}

function getStoryHierarchyPath(nodeId) {
  const path = [];
  let current = getNode(nodeId);
  while (current) {
    path.unshift(current);
    current = current.parentId ? getNode(current.parentId) : null;
  }
  return path;
}

function validateStoryHierarchy(nodeId) {
  const node = getNode(nodeId);
  if (!node) return { valid: false, error: "Node not found" };
  
  const storyTypes = ["series", "season", "arc", "story", "act", "sequence", "scene", "moment"];
  if (!storyTypes.includes(node.type)) {
    return { valid: true, error: null }; // Not a story node, no validation needed
  }
  
  const validParents = {
    series: null,
    season: "series",
    arc: "season",
    story: "arc",
    act: "story",
    sequence: "act",
    scene: "sequence",
    moment: "scene"
  };
  
  const expectedParent = validParents[node.type];
  
  if (expectedParent === null && node.parentId === null) {
    return { valid: true, error: null }; // Series with no parent is correct
  }
  
  if (expectedParent === null && node.parentId !== null) {
    return { valid: false, error: `Series should not have a parent` };
  }
  
  if (expectedParent && !node.parentId) {
    return { valid: false, error: `${node.type} must have a ${expectedParent} as parent` };
  }
  
  const parent = getNode(node.parentId);
  if (expectedParent && parent && parent.type !== expectedParent) {
    return { valid: false, error: `${node.type} parent must be ${expectedParent}, but is ${parent.type}` };
  }
  
  return { valid: true, error: null };
}

function getCharactersInSeries(seriesId) {
  return storyConnections
    .filter(sc => sc.seriesId === seriesId)
    .map(sc => ({
      character: getNode(sc.characterId),
      type: sc.type,
      description: sc.description
    }));
}

// Calculate character status based on recent sentiment/motivation changes
function calculateCharacterStatus(characterId) {
  const sentiments = getSentimentsForCharacter(characterId);
  
  if (sentiments.length === 0) {
    return {
      status: "stable",
      description: "No significant changes recorded",
      motivatingEvent: null,
      emotionalState: "neutral"
    };
  }
  
  // Get the most recent change
  const latest = sentiments[0];
  
  // Calculate disparity - how different is current state from historical baseline
  let disparity = 0;
  let historicalValues = [];
  
  // Group by sentiment/motivation name to track changes
  const changesByType = {};
  sentiments.forEach(sj => {
    if (!changesByType[sj.name]) {
      changesByType[sj.name] = [];
    }
    changesByType[sj.name].push(sj);
  });
  
  // Calculate how much each aspect has changed
  for (const name in changesByType) {
    const changes = changesByType[name];
    if (changes.length > 1) {
      // Compare most recent to previous
      disparity += 1;
    }
  }
  
  // Determine emotional state based on disparity and recent changes
  let emotionalState = "neutral";
  let status = "stable";
  let description = "";
  
  const recentChangeCount = sentiments.filter(sj => {
    const changeDate = new Date(sj.timestamp);
    const now = new Date("2201-06-01"); // current story time
    const daysDiff = (now - changeDate) / (1000 * 60 * 60 * 24);
    return daysDiff < 30; // changes in last 30 days
  }).length;
  
  if (recentChangeCount === 0) {
    status = "settled";
    emotionalState = "calm";
    description = "Emotionally settled with stable motivations";
  } else if (recentChangeCount >= 3) {
    status = "volatile";
    emotionalState = "unnerved";
    description = "Multiple recent shifts creating internal instability";
  } else if (disparity >= 3) {
    status = "conflicted";
    emotionalState = "torn";
    description = "Current state sharply diverges from historical baseline";
  } else if (latest.type === "motivation") {
    status = "motivated";
    emotionalState = "driven";
    description = `Newly motivated: ${latest.value}`;
  } else {
    status = "evolving";
    emotionalState = "processing";
    description = `Recent shift in ${latest.name.toLowerCase()}`;
  }
  
  return {
    status: status,
    description: description,
    motivatingEvent: latest.eventId,
    emotionalState: emotionalState,
    mostRecentChange: latest,
    totalChanges: sentiments.length,
    recentChanges: recentChangeCount,
    disparity: disparity
  };
}

// ==================== TREE RENDERING ====================
function renderTree() {
  const treeRoot = document.getElementById("treeRoot");
  treeRoot.innerHTML = "";

  // Render project root
  renderProjectFolder(projectStructure, treeRoot, 0);

  // Update count
  document.getElementById("nodeCount").textContent = `${Object.keys(nodes).length} nodes`;
}

function renderProjectFolder(folder, parentElement, depth) {
  const folderEl = document.createElement("div");
  folderEl.className = "tree-folder expanded";
  folderEl.style.marginLeft = (depth * 8) + "px";
  
  const header = document.createElement("div");
  header.className = "tree-folder-header";
  
  const icon = document.createElement("span");
  icon.className = "tree-folder-icon";
  icon.textContent = folder.icon;
  
  const name = document.createElement("span");
  name.className = "tree-folder-name";
  name.textContent = folder.name;
  
  header.appendChild(icon);
  header.appendChild(name);
  
  // Add description if present
  if (folder.description) {
    const desc = document.createElement("span");
    desc.className = "tree-node-date";
    desc.style.fontSize = ".6rem";
    desc.style.fontStyle = "italic";
    desc.textContent = folder.description;
    header.appendChild(desc);
  }
  
  header.addEventListener("click", () => {
    folderEl.classList.toggle("collapsed");
    folderEl.classList.toggle("expanded");
  });
  
  folderEl.appendChild(header);
  
  const children = document.createElement("div");
  children.className = "tree-folder-children";
  
  // Render child folders recursively
  if (folder.children) {
    folder.children.forEach(child => {
      renderProjectFolder(child, children, depth + 1);
    });
  }
  
  // Render nodes if this folder has types
  if (folder.types) {
    let nodesToShow = [];
    
    // Filter nodes by folder, canon status, and type
    if (folder.id === "story_structure") {
      // Only show top-level series for story structure
      nodesToShow = Object.values(nodes).filter(n => 
        folder.types.includes(n.type) && 
        n.parentId === null &&
        (!n.canonStatus || n.canonStatus === "canon")
      );
    } else if (folder.id === "retconned") {
      nodesToShow = Object.values(nodes).filter(n => 
        n.canonStatus === "retconned"
      );
    } else if (folder.id === "cut") {
      nodesToShow = Object.values(nodes).filter(n => 
        n.canonStatus === "cut"
      );
    } else if (folder.id === "fanfiction") {
      nodesToShow = Object.values(nodes).filter(n => 
        n.canonStatus === "fanfiction"
      );
    } else if (folder.id === "exploratory") {
      nodesToShow = Object.values(nodes).filter(n => 
        n.canonStatus === "exploratory"
      );
    } else if (folder.id === "cosmology_primordials") {
      nodesToShow = Object.values(nodes).filter(n => 
        n.type === "primordial"
      );
    } else if (folder.id === "cosmology_deities") {
      nodesToShow = Object.values(nodes).filter(n => 
        n.type === "deity"
      );
    } else if (folder.id === "cosmology_events") {
      nodesToShow = Object.values(nodes).filter(n => 
        n.type === "cosmology_event"
      ).sort((a, b) => (a.relativeSequence || 0) - (b.relativeSequence || 0)); // Sort by sequence
    } else if (folder.id === "meta_concepts") {
      // Show all meta_concept nodes (both canon evolution and cut scrapped ideas)
      nodesToShow = Object.values(nodes).filter(n => 
        n.type === "meta_concept"
      ).sort((a, b) => (a.evolutionStage || 99) - (b.evolutionStage || 99)); // Sort by evolution stage
    } else if (folder.id === "locations") {
      // For locations, only show top-level (no parent) locations
      nodesToShow = Object.values(nodes).filter(n => 
        n.type === "location" && 
        n.parentId === null &&
        (!n.canonStatus || n.canonStatus === "canon")
      );
    } else {
      // Default: show canon or unmarked nodes
      nodesToShow = getNodesByFolder(folder.id).filter(n => 
        !n.canonStatus || n.canonStatus === "canon"
      );
    }
    
    // Add count badge
    if (nodesToShow.length > 0) {
      const count = document.createElement("span");
      count.className = "tree-folder-count";
      count.textContent = nodesToShow.length;
      header.appendChild(count);
    }
    
    // Render nodes
    if (folder.id === "story_structure") {
      nodesToShow.forEach(node => {
        children.appendChild(renderStoryTreeNode(node, 0));
      });
    } else if (folder.id === "locations") {
      // Render locations hierarchically
      nodesToShow.forEach(node => {
        children.appendChild(renderLocationTreeNode(node, 0));
      });
    } else {
      nodesToShow.forEach(node => {
        children.appendChild(renderSimpleNode(node, folder));
      });
    }
  }
  
  folderEl.appendChild(children);
  parentElement.appendChild(folderEl);
}

function renderLocationTreeNode(node, depth) {
  const container = document.createElement("div");
  container.style.marginLeft = (depth * 12) + "px";
  container.style.marginBottom = "4px";
  
  const nodeEl = document.createElement("div");
  nodeEl.className = "tree-node";
  if (activeNodeId === node.id) {
    nodeEl.classList.add("active");
  }
  
  const nodeIcon = document.createElement("span");
  nodeIcon.className = "tree-node-icon";
  nodeIcon.textContent = "üìç";
  
  const nodeName = document.createElement("span");
  nodeName.className = "tree-node-name";
  nodeName.textContent = node.name;
  
  nodeEl.appendChild(nodeIcon);
  nodeEl.appendChild(nodeName);
  
  // Show location type
  if (node.locationType) {
    const typeLabel = document.createElement("span");
    typeLabel.style.fontSize = ".55rem";
    typeLabel.style.color = "var(--sub)";
    typeLabel.style.marginLeft = "6px";
    typeLabel.textContent = `[${node.locationType}]`;
    nodeEl.appendChild(typeLabel);
  }
  
  nodeEl.addEventListener("click", (e) => {
    e.stopPropagation(); // Prevent folder toggle
    selectNode(node.id);
  });
  
  container.appendChild(nodeEl);
  
  // Get and render children
  const children = getLocationChildren(node.id);
  if (children.length > 0) {
    const childrenContainer = document.createElement("div");
    childrenContainer.style.marginTop = "2px";
    children.forEach(child => {
      childrenContainer.appendChild(renderLocationTreeNode(child, depth + 1));
    });
    container.appendChild(childrenContainer);
  }
  
  return container;
}

function renderSimpleNode(node, folder) {
  const nodeEl = document.createElement("div");
  nodeEl.className = "tree-node";
  if (activeNodeId === node.id) {
    nodeEl.classList.add("active");
  }
  
  const nodeIcon = document.createElement("span");
  nodeIcon.className = "tree-node-icon";
  nodeIcon.textContent = folder.icon;
  
  const nodeName = document.createElement("span");
  nodeName.className = "tree-node-name";
  nodeName.textContent = node.name;
  
  nodeEl.appendChild(nodeIcon);
  nodeEl.appendChild(nodeName);
  
  // Show canon status badge if non-canon
  if (node.canonStatus && node.canonStatus !== "canon") {
    const badge = document.createElement("span");
    badge.style.fontSize = ".6rem";
    badge.style.padding = "2px 4px";
    badge.style.background = "var(--muted)";
    badge.style.borderRadius = "3px";
    badge.style.marginLeft = "4px";
    
    const badgeIcons = {
      retconned: "‚Ü∫",
      cut: "‚úÇ",
      fanfiction: "üìù",
      exploratory: "üî¨"
    };
    
    badge.textContent = badgeIcons[node.canonStatus] || node.canonStatus;
    badge.title = node.canonStatus;
    nodeEl.appendChild(badge);
  }
  
  // Show status prior for cut content
  if (node.canonStatus === "cut" && node.statusPrior) {
    const status = document.createElement("span");
    status.style.fontSize = ".55rem";
    status.style.color = "var(--sub)";
    status.style.marginLeft = "4px";
    status.textContent = `[${node.statusPrior}]`;
    nodeEl.appendChild(status);
  }
  
  // Show learnings indicator for cut content
  if (node.canonStatus === "cut" && node.learnings && node.learnings.length > 0) {
    const learningsIcon = document.createElement("span");
    learningsIcon.style.fontSize = ".6rem";
    learningsIcon.style.marginLeft = "4px";
    learningsIcon.title = `${node.learnings.length} learning(s) documented`;
    learningsIcon.textContent = "üìö";
    nodeEl.appendChild(learningsIcon);
  }
  
  if (node.type === "event" && node.dateDisplay) {
    const dateEl = document.createElement("span");
    dateEl.className = "tree-node-date";
    dateEl.textContent = node.date;
    nodeEl.appendChild(dateEl);
  }
  
  nodeEl.addEventListener("click", (e) => {
    e.stopPropagation(); // Prevent folder toggle
    selectNode(node.id);
  });
  
  return nodeEl;
}

// Render story node with hierarchy
function renderStoryTreeNode(node, depth) {
  const wrapper = document.createElement("div");
  wrapper.style.marginLeft = (depth * 12) + "px";
  
  const nodeEl = document.createElement("div");
  nodeEl.className = "tree-node";
  if (activeNodeId === node.id) {
    nodeEl.classList.add("active");
  }
  
  const nodeIcon = document.createElement("span");
  nodeIcon.className = "tree-node-icon";
  nodeIcon.textContent = "üìñ";
  nodeIcon.style.fontSize = ".5rem";
  
  const nodeName = document.createElement("span");
  nodeName.className = "tree-node-name";
  nodeName.textContent = node.name;
  nodeName.style.fontSize = ".65rem";
  
  const typeLabel = document.createElement("span");
  typeLabel.style.fontSize = ".55rem";
  typeLabel.style.color = "var(--sub)";
  typeLabel.textContent = ` (${node.type})`;
  
  nodeEl.appendChild(nodeIcon);
  nodeEl.appendChild(nodeName);
  nodeEl.appendChild(typeLabel);
  
  nodeEl.addEventListener("click", (e) => {
    e.stopPropagation(); // Prevent folder toggle
    selectNode(node.id);
  });
  
  wrapper.appendChild(nodeEl);
  
  // Render children
  const children = getStoryChildren(node.id);
  children.forEach(child => {
    wrapper.appendChild(renderStoryTreeNode(child, depth + 1));
  });
  
  return wrapper;
}

// ==================== DIALOGUE UTILITIES ====================
function getDialoguesByMoment(momentId) {
  return dialogues.filter(d => d.momentId === momentId);
}

function getDelayedMessagesBySendMoment(momentId) {
  return delayedMessages.filter(m => m.sendMomentId === momentId);
}

function getDelayedMessagesByReceiveMoment(momentId) {
  return delayedMessages.filter(m => m.receiveMomentId === momentId);
}

function getDialoguesByCharacter(characterId) {
  return dialogues.filter(d => d.speaker === characterId);
}

function addDialogue(momentId, speaker, addressedTo, dialogueType, content, metadata = {}) {
  const newDialogue = {
    id: `dlg_${Date.now()}`,
    momentId: momentId,
    speaker: speaker,
    addressedTo: addressedTo,
    dialogueType: dialogueType,
    content: content,
    timestamp: "immediate",
    metadata: metadata
  };
  dialogues.push(newDialogue);
  return newDialogue;
}

function addDelayedMessage(sendMomentId, receiveMomentId, speaker, addressedTo, messageType, content, metadata = {}) {
  const newMessage = {
    id: `msg_${Date.now()}`,
    sendMomentId: sendMomentId,
    receiveMomentId: receiveMomentId,
    speaker: speaker,
    addressedTo: Array.isArray(addressedTo) ? addressedTo : [addressedTo],
    actualRecipient: null,
    messageType: messageType,
    content: content,
    intercepted: false,
    interceptedBy: null,
    metadata: metadata
  };
  delayedMessages.push(newMessage);
  return newMessage;
}

function interceptMessage(messageId, interceptorId) {
  const message = delayedMessages.find(m => m.id === messageId);
  if (message) {
    message.intercepted = true;
    message.interceptedBy = interceptorId;
    message.actualRecipient = interceptorId;
    return true;
  }
  return false;
}

function renderDialogueBlock(dialogue) {
  const speaker = getNode(dialogue.speaker);
  let html = `<div class="dialogue-item" style="margin:8px 0;padding:12px;background:var(--panel-alt);border-left:3px solid var(--accent);border-radius:4px;">`;
  
  // Speaker header
  html += `<div style="display:flex;align-items:center;gap:8px;margin-bottom:6px;">`;
  html += `<span style="font-weight:600;color:var(--accent);cursor:pointer;font-size:.7rem;" onclick="selectNode('${dialogue.speaker}')">${speaker ? speaker.name : dialogue.speaker}</span>`;
  
  // Dialogue type badge
  const typeColors = {
    speech: "var(--ok)",
    internal: "var(--sub)",
    message: "var(--accent)",
    letter: "var(--accent)",
    note: "var(--muted)"
  };
  html += `<span style="font-size:.6rem;padding:2px 6px;background:${typeColors[dialogue.dialogueType] || 'var(--muted)'};border-radius:3px;">${dialogue.dialogueType}</span>`;
  
  // Addressed to
  if (dialogue.addressedTo !== "self" && dialogue.addressedTo !== "all") {
    const addressee = getNode(dialogue.addressedTo);
    html += `<span style="font-size:.6rem;color:var(--sub);">‚Üí <span style="color:var(--accent);cursor:pointer;" onclick="selectNode('${dialogue.addressedTo}')">${addressee ? addressee.name : dialogue.addressedTo}</span></span>`;
  } else if (dialogue.addressedTo === "all") {
    html += `<span style="font-size:.6rem;color:var(--sub);">‚Üí everyone present</span>`;
  }
  
  // Metadata (emotion, volume, etc)
  if (dialogue.metadata) {
    if (dialogue.metadata.emotion) {
      html += `<span style="font-size:.6rem;color:var(--sub);font-style:italic;">(${dialogue.metadata.emotion})</span>`;
    }
    if (dialogue.metadata.volume) {
      html += `<span style="font-size:.6rem;color:var(--sub);">[${dialogue.metadata.volume}]</span>`;
    }
  }
  
  html += `</div>`;
  
  // Content
  html += `<div style="font-family:var(--sans);line-height:1.6;font-size:.75rem;color:var(--text);">`;
  if (dialogue.dialogueType === "internal") {
    html += `<em>"${dialogue.content}"</em>`;
  } else {
    html += `"${dialogue.content}"`;
  }
  html += `</div>`;
  
  html += `</div>`;
  return html;
}

function renderDelayedMessageBlock(message, context = "send") {
  const speaker = getNode(message.speaker);
  let html = `<div class="message-item" style="margin:8px 0;padding:12px;background:var(--panel);border:2px solid ${message.intercepted ? 'var(--danger)' : 'var(--accent)'};border-radius:6px;">`;
  
  // Header
  html += `<div style="display:flex;align-items:center;gap:8px;margin-bottom:8px;flex-wrap:wrap;">`;
  html += `<span style="font-size:.65rem;font-weight:600;text-transform:uppercase;color:var(--accent);">${message.messageType}</span>`;
  
  if (context === "send") {
    html += `<span style="font-size:.65rem;color:var(--sub);">written by <span style="color:var(--accent);cursor:pointer;font-weight:600;" onclick="selectNode('${message.speaker}')">${speaker ? speaker.name : message.speaker}</span></span>`;
  } else if (context === "receive") {
    html += `<span style="font-size:.65rem;color:var(--sub);">from <span style="color:var(--accent);cursor:pointer;font-weight:600;" onclick="selectNode('${message.speaker}')">${speaker ? speaker.name : message.speaker}</span></span>`;
  }
  
  // Addressees
  if (message.addressedTo && message.addressedTo.length > 0) {
    html += `<span style="font-size:.65rem;color:var(--sub);">to `;
    message.addressedTo.forEach((addrId, idx) => {
      const addressee = getNode(addrId);
      if (idx > 0) html += ', ';
      html += `<span style="color:var(--accent);cursor:pointer;font-weight:600;" onclick="selectNode('${addrId}')">${addressee ? addressee.name : addrId}</span>`;
    });
    html += `</span>`;
  }
  
  // Interception warning
  if (message.intercepted) {
    const interceptor = getNode(message.interceptedBy);
    html += `<span style="font-size:.65rem;color:var(--danger);font-weight:600;">‚ö†Ô∏è INTERCEPTED by <span style="cursor:pointer;" onclick="selectNode('${message.interceptedBy}')">${interceptor ? interceptor.name : message.interceptedBy}</span></span>`;
  }
  
  html += `</div>`;
  
  // Metadata
  if (message.metadata) {
    html += `<div style="font-size:.6rem;color:var(--sub);margin-bottom:6px;">`;
    if (message.metadata.sealed !== undefined) {
      html += `Sealed: ${message.metadata.sealed ? 'Yes' : 'No'} `;
    }
    if (message.metadata.condition) {
      html += `Condition: ${message.metadata.condition}`;
    }
    html += `</div>`;
  }
  
  // Content
  html += `<div style="font-family:var(--sans);line-height:1.6;font-size:.75rem;padding:8px;background:var(--bg);border-radius:4px;color:var(--text);">`;
  html += message.content;
  html += `</div>`;
  
  html += `</div>`;
  return html;
}

// ==================== MAD-LIB PARSING ====================
function parseMadLibContent(content) {
  if (!content) return content;
  
  // Replace {{char_id}} or {{node_id}} with clickable links
  return content.replace(/\{\{([^\}]+)\}\}/g, (match, nodeId) => {
    const node = getNode(nodeId);
    if (node) {
      return `<span class="madlib-link" onclick="selectNode('${nodeId}')" title="${node.description || node.name}" style="color:var(--accent);cursor:pointer;font-weight:600;text-decoration:underline;text-decoration-style:dotted;">${node.name}</span>`;
    }
    return match; // Leave as-is if node not found
  });
}

// ==================== NODE VIEW RENDERING ====================
function renderNodeView(nodeId) {
  const node = getNode(nodeId);
  const container = document.getElementById("nodeViewContainer");
  
  if (!node) {
    container.innerHTML = '<div class="empty-state">Node not found</div>';
    return;
  }

  let html = "";
  
  // Header
  html += `<div class="node-header-bar">`;
  html += `<h3 class="node-title">${node.name}</h3>`;
  html += `<span class="node-type-badge">${node.type}</span>`;
  if (node.dateDisplay) {
    html += `<span class="node-date-display">${node.dateDisplay}</span>`;
  }
  html += `</div>`;

  // Description
  html += `<div class="field-group">`;
  html += `<div class="field-label">Description</div>`;
  html += `<div class="field-value">${node.description}</div>`;
  html += `</div>`;

  // Bio (if present)
  if (node.bio) {
    html += `<div class="field-group">`;
    html += `<div class="field-label">Biography</div>`;
    html += `<div class="field-value">${node.bio}</div>`;
    html += `</div>`;
  }

  // Drives (if present)
  if (node.drives && node.drives.length > 0) {
    html += `<div class="field-group">`;
    html += `<div class="field-label">Drives</div>`;
    node.drives.forEach(drive => {
      html += `<div class="list-item">${drive}</div>`;
    });
    html += `</div>`;
  }

  // Personality Type (for characters)
  if (node.type === "character" && node.personalityType) {
    html += `<div class="field-group">`;
    html += `<div class="field-label">Personality Type (MBTI)</div>`;
    html += `<div class="field-value"><strong>${node.personalityType}</strong></div>`;
    html += `</div>`;
  }

  // Character Category
  if (node.type === "character" && node.characterCategory) {
    const categoryLabels = {
      primary: "Primary Character",
      supporting: "Supporting Character",
      background: "Background Character",
      hidden_force: "Hidden Force",
      antagonist: "Antagonist"
    };
    const categoryColors = {
      primary: "#ff6b6b",
      supporting: "#4ecdc4",
      background: "#95a5a6",
      hidden_force: "#9b59b6",
      antagonist: "#e74c3c"
    };
    html += `<div class="field-group">`;
    html += `<div class="field-label">Character Category</div>`;
    html += `<div class="field-value">`;
    html += `<span style="display:inline-block;padding:4px 12px;background:${categoryColors[node.characterCategory] || 'var(--accent)'};color:white;border-radius:12px;font-size:.7rem;font-weight:600;">`;
    html += categoryLabels[node.characterCategory] || node.characterCategory.toUpperCase();
    html += `</span>`;
    html += `</div>`;
    
    // Show category evolution if present
    if (node.metadata && node.metadata.categoryEvolution && node.metadata.categoryEvolution.length > 0) {
      html += `<div style="margin-top:8px;font-size:.65rem;color:var(--sub);">`;
      html += `<strong>Evolution:</strong><br/>`;
      node.metadata.categoryEvolution.forEach((evo, idx) => {
        const color = categoryColors[evo.category] || 'var(--accent)';
        html += `<span style="display:inline-block;margin:2px 4px 2px 0;padding:2px 8px;background:${color};color:white;border-radius:8px;font-size:.6rem;">`;
        html += `${categoryLabels[evo.category] || evo.category} - ${evo.work}`;
        html += `</span>`;
      });
      html += `</div>`;
    }
    html += `</div>`;
  }

  // Thematic Arc (for characters with meta-layers)
  if (node.type === "character" && node.thematicArc) {
    html += `<div class="field-group">`;
    html += `<div class="field-label">Thematic Arc</div>`;
    html += `<div class="field-value" style="background:var(--panel);border-left:3px solid #9b59b6;padding:12px;">`;
    
    // Archetype
    html += `<div style="font-weight:600;color:#9b59b6;margin-bottom:6px;font-size:.8rem;">`;
    html += `${node.thematicArc.archetype}`;
    html += `</div>`;
    
    // Collective (if part of a group)
    if (node.thematicArc.collective) {
      html += `<div style="font-size:.65rem;color:var(--sub);margin-bottom:6px;font-style:italic;">`;
      html += `Part of: ${node.thematicArc.collective}`;
      html += `</div>`;
    }
    
    // Description
    html += `<div style="font-size:.7rem;margin-bottom:8px;">`;
    html += node.thematicArc.description;
    html += `</div>`;
    
    // Key Transformations (if present)
    if (node.thematicArc.keyTransformations && node.thematicArc.keyTransformations.length > 0) {
      html += `<div style="font-size:.65rem;margin-top:8px;">`;
      html += `<strong style="color:#9b59b6;">Key Transformations:</strong><br/>`;
      node.thematicArc.keyTransformations.forEach((trans, idx) => {
        html += `<div style="margin:4px 0;padding-left:12px;border-left:2px solid #9b59b6;">`;
        html += `<span style="color:#9b59b6;font-weight:600;">${idx + 1}.</span> ${trans.stage}`;
        html += ` <span style="color:var(--sub);font-size:.6rem;">(${trans.work})</span>`;
        html += `</div>`;
      });
      html += `</div>`;
    }
    
    // Meta-theme
    if (node.thematicArc.metaTheme) {
      html += `<div style="font-size:.65rem;margin-top:8px;padding:8px;background:rgba(155,89,182,0.1);border-radius:4px;">`;
      html += `<strong style="color:#9b59b6;">Meta-Theme:</strong> ${node.thematicArc.metaTheme}`;
      html += `</div>`;
    }
    
    html += `</div>`;
    html += `</div>`;
  }

  // Character Status (calculated)
  if (node.type === "character") {
    const status = calculateCharacterStatus(nodeId);
    html += `<div class="field-group">`;
    html += `<div class="field-label">Current Status</div>`;
    html += `<div class="field-value" style="background:var(--panel);border-left:3px solid var(--accent);padding:12px;">`;
    html += `<div style="font-weight:600;color:var(--accent);margin-bottom:4px;">`;
    html += `${status.status.toUpperCase()} (${status.emotionalState})`;
    html += `</div>`;
    html += `<div style="font-size:.65rem;margin-bottom:8px;">${status.description}</div>`;
    if (status.motivatingEvent) {
      const evt = getNode(status.motivatingEvent);
      html += `<div style="font-size:.6rem;color:var(--sub);">`;
      html += `Motivated by: <span style="color:var(--accent);cursor:pointer;" onclick="selectNode('${status.motivatingEvent}')">${evt ? evt.name : status.motivatingEvent}</span>`;
      html += `</div>`;
    }
    html += `<div style="font-size:.6rem;color:var(--sub);margin-top:4px;">`;
    html += `Total changes: ${status.totalChanges} | Recent: ${status.recentChanges} | Disparity: ${status.disparity}`;
    html += `</div>`;
    html += `</div>`;
    html += `</div>`;
    
    // Character dialogue history
    const charDialogues = getDialoguesByCharacter(nodeId);
    if (charDialogues.length > 0) {
      html += `<div class="field-group">`;
      html += `<div class="field-label">Dialogue History (${charDialogues.length} total)</div>`;
      html += `<div style="font-size:.65rem;color:var(--sub);margin-bottom:8px;">Most recent exchanges:</div>`;
      charDialogues.slice(0, 5).forEach(dlg => {
        const moment = getNode(dlg.momentId);
        html += `<div style="margin-bottom:6px;padding:8px;background:var(--panel-alt);border-radius:4px;font-size:.7rem;">`;
        html += `<div style="color:var(--sub);font-size:.6rem;margin-bottom:4px;">In: <span style="color:var(--accent);cursor:pointer;" onclick="selectNode('${dlg.momentId}')">${moment ? moment.name : dlg.momentId}</span></div>`;
        html += `<div>"${dlg.content}"</div>`;
        html += `</div>`;
      });
      if (charDialogues.length > 5) {
        html += `<div style="font-size:.65rem;color:var(--sub);margin-top:6px;">${charDialogues.length - 5} more dialogue entries...</div>`;
      }
      html += `</div>`;
    }
  }

  // Traits (if present)
  if (node.traits && node.traits.length > 0) {
    html += `<div class="field-group">`;
    html += `<div class="field-label">Traits</div>`;
    html += `<div class="tag-list">`;
    node.traits.forEach(trait => {
      html += `<span class="tag">${trait}</span>`;
    });
    html += `</div>`;
    html += `</div>`;
  }

  // Features (for locations)
  if (node.features && node.features.length > 0) {
    html += `<div class="field-group">`;
    html += `<div class="field-label">Features</div>`;
    node.features.forEach(feature => {
      html += `<div class="list-item">${feature}</div>`;
    });
    html += `</div>`;
  }

  // Capabilities (for artifacts)
  if (node.capabilities && node.capabilities.length > 0) {
    html += `<div class="field-group">`;
    html += `<div class="field-label">Capabilities</div>`;
    node.capabilities.forEach(cap => {
      html += `<div class="list-item">${cap}</div>`;
    });
    html += `</div>`;
  }

  // Event-specific fields
  if (node.type === "event") {
    if (node.location) {
      const locNode = getNode(node.location);
      html += `<div class="field-group">`;
      html += `<div class="field-label">Location</div>`;
      html += `<div class="field-value">${locNode ? locNode.name : node.location}</div>`;
      html += `</div>`;
    }

    if (node.participants && node.participants.length > 0) {
      html += `<div class="field-group">`;
      html += `<div class="field-label">Participants</div>`;
      node.participants.forEach(pId => {
        const pNode = getNode(pId);
        html += `<div class="list-item">${pNode ? pNode.name : pId}</div>`;
      });
      html += `</div>`;
    }

    if (node.outcome) {
      html += `<div class="field-group">`;
      html += `<div class="field-label">Outcome</div>`;
      html += `<div class="field-value">${node.outcome}</div>`;
      html += `</div>`;
    }

    if (node.impact) {
      html += `<div class="field-group">`;
      html += `<div class="field-label">Impact</div>`;
      html += `<div class="field-value">${node.impact}</div>`;
      html += `</div>`;
    }

    if (node.details) {
      html += `<div class="field-group">`;
      html += `<div class="field-label">Details</div>`;
      html += `<div class="field-value">${node.details}</div>`;
      html += `</div>`;
    }
  }

  // Location hierarchy
  if (node.type === "location") {
    const hierarchy = getLocationHierarchy(nodeId);
    if (hierarchy.length > 1) {
      html += `<div class="field-group">`;
      html += `<div class="field-label">Location Hierarchy</div>`;
      html += `<div class="hierarchy-tree">`;
      hierarchy.forEach((loc, idx) => {
        const indent = '<span class="hierarchy-indent">'.repeat(idx) + (idx > 0 ? '‚îî‚îÄ ' : '') + '</span>'.repeat(idx > 0 ? 1 : 0);
        html += `<div class="hierarchy-node" onclick="selectNode('${loc.id}')">${indent}${loc.name} <span style="color:var(--sub);">(${loc.locationType || 'location'})</span></div>`;
      });
      html += `</div>`;
      html += `</div>`;
    }
    
    const children = getLocationChildren(nodeId);
    if (children.length > 0) {
      html += `<div class="field-group">`;
      html += `<div class="field-label">Sub-Locations (${children.length})</div>`;
      children.forEach(child => {
        html += `<div class="list-item" onclick="selectNode('${child.id}')" style="cursor:pointer;">${child.name} <span style="color:var(--sub);">(${child.locationType || 'location'})</span></div>`;
      });
      html += `</div>`;
    }
  }

  // Story structure hierarchy
  const storyTypes = ["series", "season", "arc", "story", "act", "sequence", "scene", "moment"];
  if (storyTypes.includes(node.type)) {
    // Validate hierarchy
    const validation = validateStoryHierarchy(nodeId);
    if (!validation.valid) {
      html += `<div class="field-group">`;
      html += `<div class="field-label" style="color:var(--danger);">‚ö†Ô∏è Hierarchy Error</div>`;
      html += `<div class="field-value" style="background:var(--danger);color:var(--bg);padding:8px;font-weight:600;">`;
      html += validation.error;
      html += `</div>`;
      html += `</div>`;
    }
    
    // Show full hierarchy path
    const hierarchyPath = getStoryHierarchyPath(nodeId);
    if (hierarchyPath.length > 1) {
      html += `<div class="field-group">`;
      html += `<div class="field-label">Story Hierarchy Path</div>`;
      html += `<div class="hierarchy-tree">`;
      hierarchyPath.forEach((pathNode, idx) => {
        const indent = '<span class="hierarchy-indent">'.repeat(idx) + (idx > 0 ? '‚îî‚îÄ ' : '') + '</span>'.repeat(idx > 0 ? 1 : 0);
        const isActive = pathNode.id === nodeId;
        html += `<div class="hierarchy-node" onclick="selectNode('${pathNode.id}')" style="${isActive ? 'color:var(--accent);font-weight:600;' : ''}">`;
        html += `${indent}${pathNode.name} <span style="color:var(--sub);">(${pathNode.type})</span>`;
        html += `</div>`;
      });
      html += `</div>`;
      html += `</div>`;
    }
    
    if (node.parentId) {
      const parent = getStoryParent(nodeId);
      if (parent) {
        html += `<div class="field-group">`;
        html += `<div class="field-label">Immediate Parent</div>`;
        html += `<div class="list-item" onclick="selectNode('${parent.id}')" style="cursor:pointer;">${parent.name} <span style="color:var(--sub);">(${parent.type})</span></div>`;
        html += `</div>`;
      }
    }
    
    const children = getStoryChildren(nodeId);
    if (children.length > 0) {
      html += `<div class="field-group">`;
      html += `<div class="field-label">Contains (${children.length})</div>`;
      children.forEach(child => {
        html += `<div class="list-item" onclick="selectNode('${child.id}')" style="cursor:pointer;">${child.name} <span style="color:var(--sub);">(${child.type})</span></div>`;
      });
      html += `</div>`;
    }
  }

  // Character connections for story beats
  if (node.characters && node.characters.length > 0) {
    html += `<div class="field-group">`;
    html += `<div class="field-label">Characters Featured</div>`;
    html += `<div class="tag-list">`;
    node.characters.forEach(charId => {
      const char = getNode(charId);
      if (char) {
        html += `<span class="tag" onclick="selectNode('${charId}')" style="cursor:pointer;">${char.name}</span>`;
      }
    });
    html += `</div>`;
    html += `</div>`;
  }

  // Character actions (metadata for AI generation)
  if (node.metadata && node.metadata.characterActions) {
    html += `<div class="field-group">`;
    html += `<div class="field-label">Character Actions</div>`;
    for (const charId in node.metadata.characterActions) {
      const char = getNode(charId);
      const actions = node.metadata.characterActions[charId];
      html += `<div class="list-item">`;
      html += `<span style="color:var(--accent);font-weight:600;cursor:pointer;" onclick="selectNode('${charId}')">${char ? char.name : charId}</span>: `;
      html += actions.join(', ');
      html += `</div>`;
    }
    html += `</div>`;
  }

  // Moment content (actual prose with mad-lib links)
  if (node.type === "moment" && node.content) {
    html += `<div class="field-group">`;
    html += `<div class="field-label">Content</div>`;
    const parsedContent = parseMadLibContent(node.content);
    html += `<div class="field-value" id="momentContent_${nodeId}" style="white-space:pre-wrap;line-height:1.8;">${parsedContent}</div>`;
    html += `</div>`;
  }
  
  // Dialogue in this moment (immediate speech/internal)
  if (node.type === "moment") {
    const momentDialogues = getDialoguesByMoment(nodeId);
    if (momentDialogues.length > 0) {
      html += `<div class="field-group">`;
      html += `<div class="field-label">Dialogue (${momentDialogues.length})</div>`;
      momentDialogues.forEach(dlg => {
        html += renderDialogueBlock(dlg);
      });
      html += `</div>`;
    }
    
    // Messages sent in this moment
    const sentMessages = getDelayedMessagesBySendMoment(nodeId);
    if (sentMessages.length > 0) {
      html += `<div class="field-group">`;
      html += `<div class="field-label">Messages Sent (${sentMessages.length})</div>`;
      sentMessages.forEach(msg => {
        html += renderDelayedMessageBlock(msg, "send");
      });
      html += `</div>`;
    }
    
    // Messages received in this moment
    const receivedMessages = getDelayedMessagesByReceiveMoment(nodeId);
    if (receivedMessages.length > 0) {
      html += `<div class="field-group">`;
      html += `<div class="field-label">Messages Received (${receivedMessages.length})</div>`;
      receivedMessages.forEach(msg => {
        html += renderDelayedMessageBlock(msg, "receive");
      });
      html += `</div>`;
    }
  }
  
  // Parse description if it has mad-lib syntax
  if (node.description && node.description.includes('{{')) {
    const parsedDesc = parseMadLibContent(node.description);
    if (parsedDesc !== node.description) {
      html += `<div class="field-group">`;
      html += `<div class="field-label">Mad-Lib Preview</div>`;
      html += `<div class="field-value">${parsedDesc}</div>`;
      html += `</div>`;
    }
  }
  
  // Character Journey Outcomes (for events and moments)
  if (node.type === "event" || node.type === "moment") {
    const outcomes = getOutcomesForMoment(nodeId);
    if (outcomes.length > 0) {
      html += `<div class="field-group">`;
      html += `<div class="field-label">üìä Character Journey Outcomes (${outcomes.length})</div>`;
      html += `<div style="font-size:.65rem;color:var(--sub);margin-bottom:12px;">`;
      html += `This ${node.type} caused ${outcomes.length} transformative ${outcomes.length === 1 ? 'change' : 'changes'} across character journeys.`;
      html += `</div>`;
      
      outcomes.forEach(outcome => {
        const char = getNode(outcome.characterId);
        const outcomeTypeColors = {
          growth: '#4dff9c',
          setback: '#ff4d6a',
          mixed: '#ffd732',
          neutral: '#9a9aaa'
        };
        const outcomeColor = outcomeTypeColors[outcome.outcomeType] || '#9a9aaa';
        
        html += `<div style="background:var(--panel);border:1px solid var(--border);border-radius:6px;padding:12px;margin-bottom:12px;border-left:4px solid ${outcomeColor};">`;
        html += `<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">`;
        html += `<div style="font-size:.75rem;font-weight:600;color:var(--accent);cursor:pointer;" onclick="selectNode('${outcome.characterId}')">`;
        html += `${char ? char.name : outcome.characterId}`;
        html += `</div>`;
        html += `<div style="font-size:.65rem;font-weight:600;text-transform:uppercase;color:${outcomeColor};">`;
        html += outcome.outcomeType;
        html += `</div>`;
        html += `</div>`;
        
        // Trait modifications
        if (outcome.traitModifiers && Object.keys(outcome.traitModifiers).length > 0) {
          html += `<div style="margin-bottom:8px;">`;
          html += `<div style="font-size:.65rem;font-weight:600;color:var(--sub);margin-bottom:6px;">Trait Changes:</div>`;
          Object.entries(outcome.traitModifiers).forEach(([trait, mod]) => {
            html += `<div style="display:flex;align-items:center;gap:8px;margin-bottom:4px;font-size:.65rem;">`;
            html += `<span style="background:var(--panel-alt);padding:2px 6px;border-radius:3px;font-weight:600;color:var(--accent);">${trait}</span>`;
            html += `<span style="color:${mod.change > 0 ? '#4dff9c' : '#ff4d6a'};font-weight:600;">`;
            html += `${mod.change > 0 ? '‚ñ≤' : '‚ñº'} ${mod.change > 0 ? '+' : ''}${mod.change}`;
            html += `</span>`;
            html += `<span style="color:var(--text);">${mod.reason}</span>`;
            html += `</div>`;
          });
          html += `</div>`;
        }
        
        // Alignment modifications
        if (outcome.alignmentModifiers && Object.keys(outcome.alignmentModifiers).length > 0) {
          html += `<div style="margin-bottom:8px;">`;
          html += `<div style="font-size:.65rem;font-weight:600;color:var(--sub);margin-bottom:6px;">Alignment Shifts:</div>`;
          Object.entries(outcome.alignmentModifiers).forEach(([axis, mod]) => {
            html += `<div style="display:flex;align-items:center;gap:8px;margin-bottom:4px;font-size:.65rem;">`;
            html += `<span style="background:var(--panel-alt);padding:2px 6px;border-radius:3px;font-weight:600;color:var(--accent);">${axis.replace('_', ' ‚Üí ')}</span>`;
            html += `<span style="color:${mod.change > 0 ? '#4d9cff' : '#ff9c4d'};font-weight:600;">`;
            html += `${mod.change > 0 ? '+' : ''}${mod.change}`;
            html += `</span>`;
            html += `<span style="color:var(--text);">${mod.reason}</span>`;
            html += `</div>`;
          });
          html += `</div>`;
        }
        
        // Narrative impact
        if (outcome.narrativeImpact) {
          html += `<div style="font-size:.65rem;color:var(--sub);font-style:italic;margin-top:8px;padding-top:8px;border-top:1px solid var(--border);">`;
          html += `üìñ ${outcome.narrativeImpact}`;
          html += `</div>`;
        }
        
        html += `</div>`;
      });
      
      html += `</div>`;
    }
  }

  // Meta Concept specific fields
  if (node.type === "meta_concept") {
    // Evolution Stage
    if (node.evolutionStage) {
      html += `<div class="field-group">`;
      html += `<div class="field-label">Evolution Stage</div>`;
      html += `<div class="field-value">`;
      html += `<span style="display:inline-block;padding:4px 12px;background:var(--accent);color:white;border-radius:12px;font-size:.7rem;font-weight:600;">`;
      html += `Stage ${node.evolutionStage}`;
      html += `</span>`;
      html += `</div>`;
      html += `</div>`;
    }
    
    // Real World Date
    if (node.realWorldDate) {
      html += `<div class="field-group">`;
      html += `<div class="field-label">Real World Timeline</div>`;
      html += `<div class="field-value">${node.realWorldDate}</div>`;
      html += `</div>`;
    }
    
    // Key Elements
    if (node.keyElements && node.keyElements.length > 0) {
      html += `<div class="field-group">`;
      html += `<div class="field-label">Key Elements</div>`;
      node.keyElements.forEach(element => {
        html += `<div class="list-item">‚Ä¢ ${element}</div>`;
      });
      html += `</div>`;
    }
    
    // What Evolved (for canon concepts)
    if (node.whatEvolved) {
      html += `<div class="field-group">`;
      html += `<div class="field-label">What Evolved</div>`;
      html += `<div class="field-value" style="background:var(--panel);border-left:3px solid var(--accent);padding:12px;font-size:.75rem;">`;
      html += `‚û°Ô∏è ${node.whatEvolved}`;
      html += `</div>`;
      html += `</div>`;
    }
    
    // Why Scrapped (for cut concepts)
    if (node.whyScrapped) {
      html += `<div class="field-group">`;
      html += `<div class="field-label">Why Scrapped</div>`;
      html += `<div class="field-value" style="background:var(--panel);border-left:3px solid #ff4d6a;padding:12px;font-size:.75rem;">`;
      html += `‚ùå ${node.whyScrapped}`;
      html += `</div>`;
      html += `</div>`;
    }
    
    // Potential Elements (what survived from scrapped ideas)
    if (node.potentialElements) {
      html += `<div class="field-group">`;
      html += `<div class="field-label">What Survived</div>`;
      html += `<div class="field-value" style="background:var(--panel);border-left:3px solid #4dff9c;padding:12px;font-size:.75rem;">`;
      html += `üí° ${node.potentialElements}`;
      html += `</div>`;
      html += `</div>`;
    }
  }

  // Tags
  if (node.tags && node.tags.length > 0) {
    html += `<div class="field-group">`;
    html += `<div class="field-label">Tags</div>`;
    html += `<div class="tag-list">`;
    node.tags.forEach(tag => {
      html += `<span class="tag">#${tag}</span>`;
    });
    html += `</div>`;
    html += `</div>`;
  }
  
  // Canon Status & Learnings (for cut/non-canon content)
  if (node.canonStatus && node.canonStatus !== "canon") {
    html += `<div class="field-group">`;
    html += `<div class="field-label">Canon Status</div>`;
    html += `<div class="field-value" style="background:var(--panel);border-left:3px solid var(--muted);padding:12px;">`;
    html += `<div style="font-weight:600;color:var(--muted);margin-bottom:4px;text-transform:uppercase;">`;
    html += `${node.canonStatus}`;
    html += `</div>`;
    
    if (node.canonStatus === "cut" && node.statusPrior) {
      html += `<div style="font-size:.65rem;color:var(--sub);margin-bottom:8px;">`;
      html += `Status Prior: <strong>${node.statusPrior}</strong>`;
      html += `</div>`;
    }
    
    // Learnings section for cut content
    if (node.canonStatus === "cut" && node.learnings && node.learnings.length > 0) {
      html += `<div style="margin-top:12px;padding-top:12px;border-top:1px solid var(--border);">`;
      html += `<div style="font-size:.65rem;font-weight:600;color:var(--accent);margin-bottom:8px;">üìö Learnings from Cut Content (${node.learnings.length})</div>`;
      node.learnings.forEach((learning, idx) => {
        html += `<div style="margin-bottom:8px;padding:8px;background:var(--panel-alt);border-radius:4px;font-size:.7rem;">`;
        html += `<div style="font-weight:600;color:var(--text);margin-bottom:4px;">${idx + 1}. ${learning.title || 'Untitled Learning'}</div>`;
        html += `<div style="color:var(--sub);">${learning.description}</div>`;
        if (learning.category) {
          html += `<div style="font-size:.6rem;color:var(--accent);margin-top:4px;">Category: ${learning.category}</div>`;
        }
        html += `</div>`;
      });
      html += `</div>`;
    }
    
    html += `</div>`;
    html += `</div>`;
  }

  container.innerHTML = html;
  
  // Setup text selection feedback for moment content
  if (node.type === "moment" && node.content) {
    setupTextSelectionFeedback(`momentContent_${nodeId}`);
  }
}

// ==================== PROPERTIES PANEL ====================
function renderPropertiesPanel(nodeId) {
  const node = getNode(nodeId);
  const container = document.getElementById("propsViewContainer");
  
  if (!node) {
    container.innerHTML = '<div class="empty-state">No node selected</div>';
    return;
  }

  let html = "";

  // Metadata section
  if (node.metadata && Object.keys(node.metadata).length > 0) {
    html += `<div class="prop-section">`;
    html += `<div class="prop-section-title">Metadata</div>`;
    for (const [key, value] of Object.entries(node.metadata)) {
      html += `<div class="prop-item">`;
      html += `<div class="prop-item-key">${key}</div>`;
      html += `<div class="prop-item-value">${value}</div>`;
      html += `</div>`;
    }
    html += `</div>`;
  }

  // Sentiment/Motivation Evolution (for characters)
  if (node.type === "character") {
    const sentiments = getSentimentsForCharacter(nodeId);
    if (sentiments.length > 0) {
      html += `<div class="prop-section">`;
      html += `<div class="prop-section-title">Sentiment/Motivation Evolution (${sentiments.length})</div>`;
      sentiments.forEach(sent => {
        const event = getNode(sent.eventId);
        html += `<div class="sentiment-item">`;
        html += `<div class="sentiment-header">`;
        html += `<span class="sentiment-name">${sent.name}</span>`;
        html += `<span class="sentiment-date">${sent.timestamp}</span>`;
        html += `</div>`;
        html += `<div class="sentiment-value"><strong>${sent.type}:</strong> ${sent.value}</div>`;
        html += `<div class="sentiment-event" onclick="selectNode('${sent.eventId}')">‚Üí Caused by: ${event ? event.name : sent.eventId}</div>`;
        if (sent.previousValue) {
          html += `<div style="font-size:.6rem;color:var(--sub);margin-top:4px;">Previous: ${sent.previousValue}</div>`;
        }
        html += `</div>`;
      });
      html += `</div>`;
    }
  }

  // Relationships section
  const rels = getOutgoingRelationships(nodeId);
  if (rels.length > 0) {
    html += `<div class="prop-section">`;
    html += `<div class="prop-section-title">Relationships (${rels.length})</div>`;
    html += `<div class="rel-list">`;
    rels.forEach(rel => {
      const targetNode = getNode(rel.to);
      html += `<div class="rel-item" onclick="selectNode('${rel.to}')">`;
      html += `<div class="rel-item-header">`;
      html += `<span class="rel-item-name">${targetNode ? targetNode.name : rel.to}</span>`;
      html += `<span class="rel-item-type">${rel.type}</span>`;
      html += `</div>`;
      html += `<div class="rel-item-desc">${rel.description}</div>`;
      html += `</div>`;
    });
    html += `</div>`;
    html += `</div>`;
  }

  // Junction Chains (for events - show what sentiments/motivations this event caused)
  if (node.type === "event") {
    const triggeredSentiments = sentimentJunctions.filter(sj => sj.eventId === nodeId);
    if (triggeredSentiments.length > 0) {
      html += `<div class="prop-section">`;
      html += `<div class="prop-section-title">Triggered Changes (${triggeredSentiments.length})</div>`;
      triggeredSentiments.forEach(sent => {
        const char = getNode(sent.characterId);
        html += `<div class="junction-chain">`;
        html += `<div class="junction-flow">`;
        html += `<span class="junction-node" onclick="selectNode('${sent.characterId}')">${char ? char.name : sent.characterId}</span>`;
        html += `<span class="junction-arrow">‚Üí</span>`;
        html += `<span class="junction-node">${sent.name}</span>`;
        html += `<span class="junction-arrow">‚Üí</span>`;
        html += `<span style="color:var(--accent);">${sent.value}</span>`;
        html += `</div>`;
        html += `<div class="junction-details">${sent.description}</div>`;
        html += `</div>`;
      });
      html += `</div>`;
    }
  }

  container.innerHTML = html;
}

// ==================== TIMELINE VIEW ====================
function renderTimelineView() {
  const container = document.getElementById("timelineViewContainer");
  
  let html = '<div style="padding:16px;">';
  
  // Tab selector
  html += `<div style="display:flex;gap:8px;margin-bottom:20px;border-bottom:1px solid var(--muted);padding-bottom:8px;">`;
  html += `<button class="form-btn small" onclick="showTimelineTab('events')" id="tab_events">Events Timeline</button>`;
  html += `<button class="form-btn small" onclick="showTimelineTab('story')" id="tab_story">Story Structure</button>`;
  html += `</div>`;
  
  // Events Timeline
  html += `<div id="timelineTab_events">`;
  const events = getAllEvents();
  if (events.length === 0) {
    html += '<div class="empty-state">No events in timeline</div>';
  } else {
    html += `<div class="timeline-header">Universal Timeline (${events.length} events)</div>`;
    html += `<div class="timeline-track">`;
    html += `<div class="timeline-axis"></div>`;
    events.forEach(event => {
      html += `<div class="timeline-event">`;
      html += `<div class="timeline-event-date">${event.dateDisplay}</div>`;
      html += `<div class="timeline-event-title" onclick="selectNode('${event.id}')">${event.name}</div>`;
      html += `<div class="timeline-event-desc">${event.description}</div>`;
      html += `</div>`;
    });
    html += `</div>`;
  }
  html += `</div>`;
  
  // Story Structure Timeline
  html += `<div id="timelineTab_story" class="hidden">`;
  html += renderStoryStructureTimeline();
  html += `</div>`;
  
  html += '</div>';
  container.innerHTML = html;
  
  // Default to events tab
  showTimelineTab('events');
}

function showTimelineTab(tabName) {
  document.getElementById('timelineTab_events').classList.add('hidden');
  document.getElementById('timelineTab_story').classList.add('hidden');
  document.getElementById('timelineTab_' + tabName).classList.remove('hidden');
  
  document.getElementById('tab_events').style.background = tabName === 'events' ? 'var(--accent-dim)' : '';
  document.getElementById('tab_story').style.background = tabName === 'story' ? 'var(--accent-dim)' : '';
}

function renderStoryStructureTimeline() {
  let html = `<div class="timeline-header">Story Structure Hierarchy</div>`;
  
  // Get all series
  const allSeries = Object.values(nodes).filter(n => n.type === "series");
  
  if (allSeries.length === 0) {
    return '<div class="empty-state">No story structure defined<br><button class="form-btn" onclick="switchView(\'questionnaire\')">+ Create Series</button></div>';
  }
  
  html += `<div style="font-size:.65rem;color:var(--sub);margin-bottom:16px;">Click any node to view details. Missing content shows [???] with + button to add.</div>`;
  
  // Render each series as a row with hierarchical expansion
  allSeries.forEach(series => {
    html += renderStoryNode(series, 0);
  });
  
  return html;
}

function renderStoryNode(node, depth) {
  const indent = depth * 24;
  let html = `<div style="margin-left:${indent}px;margin-bottom:8px;border-left:2px solid var(--muted);padding-left:12px;">`;
  
  // Node header
  html += `<div style="display:flex;align-items:center;gap:8px;margin-bottom:4px;">`;
  html += `<span style="font-size:.6rem;color:var(--sub);text-transform:uppercase;min-width:60px;">${node.type}</span>`;
  html += `<span style="font-weight:600;color:var(--text);cursor:pointer;font-size:.7rem;" onclick="selectNode('${node.id}')">${node.name}</span>`;
  
  // Show character connections for series
  if (node.type === "series") {
    const chars = getCharactersInSeries(node.id);
    if (chars.length > 0) {
      html += `<span style="font-size:.6rem;color:var(--sub);">`;
      html += chars.map(c => c.character.name).join(', ');
      html += `</span>`;
    }
  }
  
  html += `</div>`;
  
  // Node description
  if (node.description) {
    html += `<div style="font-size:.65rem;color:var(--sub);margin-bottom:8px;">${node.description}</div>`;
  }
  
  // Content preview for moments
  if (node.type === "moment" && node.content) {
    const preview = node.content.substring(0, 150) + (node.content.length > 150 ? '...' : '');
    html += `<div style="font-size:.65rem;background:var(--panel-alt);padding:8px;border-radius:4px;font-family:var(--sans);line-height:1.6;margin-bottom:8px;">`;
    html += preview;
    html += `</div>`;
  }
  
  // Get children
  const children = getStoryChildren(node.id);
  
  // Expected child types
  const expectedChildType = {
    series: "season",
    season: "arc",
    arc: "story",
    story: "act",
    act: "sequence",
    sequence: "scene",
    scene: "moment"
  };
  
  const expectedType = expectedChildType[node.type];
  
  if (expectedType) {
    if (children.length === 0) {
      // Show placeholder
      html += `<div style="margin-left:24px;margin-top:8px;">`;
      html += `<div style="display:flex;align-items:center;gap:8px;padding:8px;background:var(--panel-alt);border:1px dashed var(--muted);border-radius:4px;">`;
      html += `<span style="font-size:.65rem;color:var(--sub);">No ${expectedType}s defined</span>`;
      html += `<span style="font-size:1.2rem;color:var(--sub);">???</span>`;
      html += `<button class="form-btn small" onclick="createChildNode('${node.id}', '${expectedType}')">+ Add ${expectedType}</button>`;
      html += `</div>`;
      html += `</div>`;
    } else {
      // Render children recursively
      children.forEach(child => {
        html += renderStoryNode(child, depth + 1);
      });
    }
  }
  
  html += `</div>`;
  return html;
}

function createChildNode(parentId, childType) {
  const parent = getNode(parentId);
  if (!parent) {
    alert('Parent node not found!');
    return;
  }
  
  // Validate hierarchy - ensure parent type matches expected
  const validHierarchy = {
    series: null,        // Series is top-level
    season: "series",
    arc: "season",
    story: "arc",
    act: "story",
    sequence: "act",
    scene: "sequence",
    moment: "scene"
  };
  
  const expectedParentType = validHierarchy[childType];
  
  if (expectedParentType && parent.type !== expectedParentType) {
    alert(`ERROR: A ${childType} must belong to a ${expectedParentType}, but you selected a ${parent.type}.\n\nHierarchy rule: Moment‚ÜíScene‚ÜíSequence‚ÜíAct‚ÜíStory‚ÜíArc‚ÜíSeason‚ÜíSeries`);
    return;
  }
  
  const name = prompt(`Enter name for new ${childType}:`);
  if (!name) return;
  
  const description = prompt(`Enter description (optional):`);
  
  const newNode = {
    id: generateId(childType.substring(0, 4)),
    type: childType,
    folder: "story_structure",
    parentId: parentId,  // CRITICAL: Always parented by immediate higher-order category
    name: name,
    description: description || `A ${childType} in ${parent.name}`,
    tags: [childType],
    metadata: {}
  };
  
  // For scenes, add character and location fields
  if (childType === "scene") {
    newNode.characters = [];
    newNode.locationId = null;
  }
  
  // For moments, add content field
  if (childType === "moment") {
    newNode.content = "";
  }
  
  nodes[newNode.id] = newNode;
  
  // Refresh timeline
  renderTimelineView();
  alert(`‚úì ${childType} "${name}" created as child of ${parent.name}!`);
}

window.showTimelineTab = showTimelineTab;
window.createChildNode = createChildNode;

// ==================== EDIT VIEW ====================
function renderEditView(nodeId) {
  const container = document.getElementById("editViewContainer");
  
  if (!nodeId) {
    container.innerHTML = '<div class="empty-state">Select a node to edit or create a new one</div>';
    return;
  }

  const node = getNode(nodeId);
  if (!node) {
    container.innerHTML = '<div class="empty-state">Node not found</div>';
    return;
  }

  let html = '<div class="edit-form">';
  html += `<h3 style="margin-top:0;color:var(--accent);">Edit Node: ${node.name}</h3>`;
  
  // Basic fields
  html += `<div class="form-group">`;
  html += `<label class="form-label">Name</label>`;
  html += `<input type="text" class="form-input" id="edit_name" value="${node.name || ''}" />`;
  html += `</div>`;

  html += `<div class="form-group">`;
  html += `<label class="form-label">Type</label>`;
  html += `<select class="form-select" id="edit_type">`;
  ['character', 'faction', 'location', 'event', 'artifact'].forEach(type => {
    html += `<option value="${type}" ${node.type === type ? 'selected' : ''}>${type}</option>`;
  });
  html += `</select>`;
  html += `</div>`;

  html += `<div class="form-group">`;
  html += `<label class="form-label">Description</label>`;
  html += `<textarea class="form-textarea" id="edit_description">${node.description || ''}</textarea>`;
  html += `</div>`;

  html += `<div class="form-group">`;
  html += `<label class="form-label">Biography</label>`;
  html += `<textarea class="form-textarea" id="edit_bio">${node.bio || ''}</textarea>`;
  html += `</div>`;

  // Event-specific fields
  if (node.type === "event") {
    html += `<div class="form-group">`;
    html += `<label class="form-label">Date (YYYY-MM-DD)</label>`;
    html += `<input type="text" class="form-input" id="edit_date" value="${node.date || ''}" />`;
    html += `</div>`;

    html += `<div class="form-group">`;
    html += `<label class="form-label">Time (HH:MM)</label>`;
    html += `<input type="text" class="form-input" id="edit_time" value="${node.time || ''}" />`;
    html += `</div>`;
  }

  // Tags
  html += `<div class="form-group">`;
  html += `<label class="form-label">Tags (comma-separated)</label>`;
  html += `<input type="text" class="form-input" id="edit_tags" value="${node.tags ? node.tags.join(', ') : ''}" />`;
  html += `</div>`;

  // Arrays (drives, traits, features, capabilities)
  const arrayFields = [
    { key: 'drives', label: 'Drives' },
    { key: 'traits', label: 'Traits' },
    { key: 'features', label: 'Features' },
    { key: 'capabilities', label: 'Capabilities' }
  ];

  arrayFields.forEach(field => {
    if (node[field.key]) {
      html += `<div class="form-group">`;
      html += `<label class="form-label">${field.label}</label>`;
      html += `<textarea class="form-textarea" id="edit_${field.key}" placeholder="One per line">${node[field.key].join('\n')}</textarea>`;
      html += `</div>`;
    }
  });

  // Actions
  html += `<div class="form-actions">`;
  html += `<button class="form-btn primary" onclick="saveNodeEdits('${nodeId}')">Save Changes</button>`;
  html += `<button class="form-btn" onclick="switchView('node')">Cancel</button>`;
  html += `<button class="form-btn danger" onclick="deleteNode('${nodeId}')" style="margin-left:auto;">Delete Node</button>`;
  html += `</div>`;

  html += '</div>';
  container.innerHTML = html;
}

function saveNodeEdits(nodeId) {
  const node = getNode(nodeId);
  if (!node) return;

  // Update basic fields
  node.name = document.getElementById('edit_name').value;
  node.type = document.getElementById('edit_type').value;
  node.description = document.getElementById('edit_description').value;
  node.bio = document.getElementById('edit_bio').value;

  // Update event fields
  if (node.type === "event") {
    node.date = document.getElementById('edit_date').value;
    node.time = document.getElementById('edit_time').value;
    if (node.date && node.time) {
      node.dateDisplay = formatDateDisplay(node.date, node.time);
    }
  }

  // Update tags
  const tagsValue = document.getElementById('edit_tags').value;
  node.tags = tagsValue ? tagsValue.split(',').map(t => t.trim()).filter(t => t) : [];

  // Update array fields
  const arrayFields = ['drives', 'traits', 'features', 'capabilities'];
  arrayFields.forEach(field => {
    const el = document.getElementById('edit_' + field);
    if (el) {
      const value = el.value;
      node[field] = value ? value.split('\n').map(l => l.trim()).filter(l => l) : [];
    }
  });

  // Refresh views
  renderTree();
  switchView('node');
  alert('Node saved successfully!');
}

function formatDateDisplay(date, time) {
  const d = new Date(date + ' ' + time);
  const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
  return `${months[d.getMonth()]} ${d.getDate()}, ${d.getFullYear()} ${time}`;
}

// ==================== QUESTIONNAIRE VIEW ====================
function renderQuestionnaireView() {
  const container = document.getElementById("questionnaireViewContainer");
  
  let html = '<div class="questionnaire-form">';
  html += `<h3 style="margin-top:0;color:var(--accent);">Create New Node</h3>`;
  html += `<p style="font-size:.65rem;color:var(--sub);margin-bottom:20px;">Fill out this guided questionnaire to create a new node in your story universe.</p>`;

  // Question 1: What type of node?
  html += `<div class="question-section">`;
  html += `<div class="question-title">1. What type of entity are you creating?</div>`;
  html += `<div class="question-help">Choose the primary category that best describes this entity.</div>`;
  html += `<select class="form-select" id="q_type" onchange="updateQuestionnaireFields()">`;
  html += `<option value="">-- Select Type --</option>`;
  html += `<option value="character">Character - A person or sentient being</option>`;
  html += `<option value="faction">Faction - A group, organization, or collective</option>`;
  html += `<option value="location">Location - A place or setting</option>`;
  html += `<option value="event">Event - A significant occurrence with date/time</option>`;
  html += `<option value="artifact">Artifact - An object, item, or piece of technology</option>`;
  html += `</select>`;
  html += `</div>`;

  // Question 2: Name
  html += `<div class="question-section">`;
  html += `<div class="question-title">2. What is the name of this entity?</div>`;
  html += `<div class="question-help">Provide a clear, memorable name.</div>`;
  html += `<input type="text" class="form-input" id="q_name" placeholder="e.g., Marcus Blackwood" />`;
  html += `</div>`;

  // Question 3: Description
  html += `<div class="question-section">`;
  html += `<div class="question-title">3. Provide a brief description (1-2 sentences)</div>`;
  html += `<div class="question-help">This is the "elevator pitch" for this entity.</div>`;
  html += `<textarea class="form-textarea" id="q_description" placeholder="A concise summary of who/what this is..."></textarea>`;
  html += `</div>`;

  // Question 4: Biography/Details
  html += `<div class="question-section">`;
  html += `<div class="question-title">4. Detailed background/biography</div>`;
  html += `<div class="question-help">Provide deeper context, history, and important details.</div>`;
  html += `<textarea class="form-textarea" id="q_bio" placeholder="Full background story, context, significance..." style="min-height:120px;"></textarea>`;
  html += `</div>`;

  // Dynamic fields based on type
  html += `<div id="dynamicQuestions"></div>`;

  // Question N: Tags
  html += `<div class="question-section">`;
  html += `<div class="question-title">Tags</div>`;
  html += `<div class="question-help">Add searchable tags (comma-separated).</div>`;
  html += `<input type="text" class="form-input" id="q_tags" placeholder="e.g., protagonist, mysterious, powerful" />`;
  html += `</div>`;

  // Actions
  html += `<div class="form-actions">`;
  html += `<button class="form-btn primary" onclick="submitQuestionnaire()">Create Node</button>`;
  html += `<button class="form-btn" onclick="clearQuestionnaire()">Clear Form</button>`;
  html += `</div>`;

  html += '</div>';
  container.innerHTML = html;
}

function updateQuestionnaireFields() {
  const type = document.getElementById('q_type').value;
  const container = document.getElementById('dynamicQuestions');
  
  if (!type) {
    container.innerHTML = '';
    return;
  }

  let html = '';

  if (type === 'character') {
    html += `<div class="question-section">`;
    html += `<div class="question-title">What drives this character?</div>`;
    html += `<div class="question-help">List their goals, fears, motivations (one per line).</div>`;
    html += `<textarea class="form-textarea" id="q_drives" placeholder="- Protect their family\n- Discover the truth about their past\n- Overcome their fear of failure"></textarea>`;
    html += `</div>`;

    html += `<div class="question-section">`;
    html += `<div class="question-title">What are their key traits/behaviors?</div>`;
    html += `<div class="question-help">Personality traits, behavioral patterns (one per line).</div>`;
    html += `<textarea class="form-textarea" id="q_traits" placeholder="- Impulsive under pressure\n- Loyal to a fault\n- Quick-witted"></textarea>`;
    html += `</div>`;
  }

  if (type === 'faction') {
    html += `<div class="question-section">`;
    html += `<div class="question-title">What are this faction's goals?</div>`;
    html += `<div class="question-help">What does this group want to achieve? (one per line)</div>`;
    html += `<textarea class="form-textarea" id="q_drives" placeholder="- Control the narrative\n- Expand influence\n- Eliminate rivals"></textarea>`;
    html += `</div>`;

    html += `<div class="question-section">`;
    html += `<div class="question-title">What are their methods/characteristics?</div>`;
    html += `<div class="question-help">How do they operate? (one per line)</div>`;
    html += `<textarea class="form-textarea" id="q_traits" placeholder="- Operates in secret\n- Uses economic leverage\n- Prioritizes loyalty"></textarea>`;
    html += `</div>`;
  }

  if (type === 'location') {
    html += `<div class="question-section">`;
    html += `<div class="question-title">What are the key features of this location?</div>`;
    html += `<div class="question-help">Physical features, areas of interest (one per line).</div>`;
    html += `<textarea class="form-textarea" id="q_features" placeholder="- Towering spires reach the clouds\n- Underground catacombs\n- Secure vault in the basement"></textarea>`;
    html += `</div>`;
  }

  if (type === 'event') {
    html += `<div class="question-section">`;
    html += `<div class="question-title">When did this event occur?</div>`;
    html += `<div class="question-help">Provide in-universe date and time.</div>`;
    html += `<div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;">`;
    html += `<input type="text" class="form-input" id="q_date" placeholder="YYYY-MM-DD" />`;
    html += `<input type="text" class="form-input" id="q_time" placeholder="HH:MM" />`;
    html += `</div>`;
    html += `</div>`;

    html += `<div class="question-section">`;
    html += `<div class="question-title">What was the outcome/impact?</div>`;
    html += `<textarea class="form-textarea" id="q_outcome" placeholder="What happened as a result..."></textarea>`;
    html += `</div>`;
  }

  if (type === 'artifact') {
    html += `<div class="question-section">`;
    html += `<div class="question-title">What can this artifact do?</div>`;
    html += `<div class="question-help">Capabilities, powers, or functions (one per line).</div>`;
    html += `<textarea class="form-textarea" id="q_capabilities" placeholder="- Grants user enhanced perception\n- Can store massive amounts of data\n- Indestructible"></textarea>`;
    html += `</div>`;
  }

  container.innerHTML = html;
}

function submitQuestionnaire() {
  const type = document.getElementById('q_type').value;
  const name = document.getElementById('q_name').value;
  const description = document.getElementById('q_description').value;
  const bio = document.getElementById('q_bio').value;
  const tags = document.getElementById('q_tags').value;

  if (!type || !name || !description) {
    alert('Please fill out at least the type, name, and description fields.');
    return;
  }

  const newNode = {
    id: generateId(type.substring(0, 4)),
    type: type,
    folder: type === 'character' ? 'characters' : 
            type === 'faction' ? 'factions' :
            type === 'location' ? 'locations' :
            type === 'event' ? 'events' : 'artifacts',
    name: name,
    description: description,
    bio: bio,
    tags: tags ? tags.split(',').map(t => t.trim()).filter(t => t) : [],
    metadata: {}
  };

  // Type-specific fields
  const drivesEl = document.getElementById('q_drives');
  if (drivesEl && drivesEl.value) {
    newNode.drives = drivesEl.value.split('\n').map(l => l.trim()).filter(l => l);
  }

  const traitsEl = document.getElementById('q_traits');
  if (traitsEl && traitsEl.value) {
    newNode.traits = traitsEl.value.split('\n').map(l => l.trim()).filter(l => l);
  }

  const featuresEl = document.getElementById('q_features');
  if (featuresEl && featuresEl.value) {
    newNode.features = featuresEl.value.split('\n').map(l => l.trim()).filter(l => l);
  }

  const capabilitiesEl = document.getElementById('q_capabilities');
  if (capabilitiesEl && capabilitiesEl.value) {
    newNode.capabilities = capabilitiesEl.value.split('\n').map(l => l.trim()).filter(l => l);
  }

  if (type === 'event') {
    const dateEl = document.getElementById('q_date');
    const timeEl = document.getElementById('q_time');
    const outcomeEl = document.getElementById('q_outcome');
    
    if (dateEl && dateEl.value) newNode.date = dateEl.value;
    if (timeEl && timeEl.value) newNode.time = timeEl.value;
    if (dateEl && timeEl && dateEl.value && timeEl.value) {
      newNode.dateDisplay = formatDateDisplay(dateEl.value, timeEl.value);
    }
    if (outcomeEl && outcomeEl.value) newNode.outcome = outcomeEl.value;
  }

  // Add to nodes
  nodes[newNode.id] = newNode;

  // Select and view the new node
  activeNodeId = newNode.id;
  renderTree();
  switchView('node');
  alert(`Node "${name}" created successfully!`);
}

function clearQuestionnaire() {
  renderQuestionnaireView();
}

// ==================== TEXT SELECTION FEEDBACK ====================
let feedbackPopup = null;
let currentSelection = null;

function setupTextSelectionFeedback(elementId) {
  const element = document.getElementById(elementId);
  if (!element) return;
  
  element.addEventListener('mouseup', (e) => {
    const selection = window.getSelection();
    const text = selection.toString().trim();
    
    if (text.length > 0) {
      currentSelection = {
        text: text,
        elementId: elementId,
        range: selection.getRangeAt(0).cloneRange()
      };
      
      showFeedbackPopup(e.pageX, e.pageY);
    } else {
      hideFeedbackPopup();
    }
  });
}

function showFeedbackPopup(x, y) {
  hideFeedbackPopup();
  
  const popup = document.createElement('div');
  popup.className = 'feedback-popup';
  popup.style.left = x + 'px';
  popup.style.top = (y - 50) + 'px';
  
  const likeBtn = document.createElement('button');
  likeBtn.className = 'feedback-btn like';
  likeBtn.innerHTML = 'üëç Like';
  likeBtn.onclick = () => addFeedback('like');
  
  const dislikeBtn = document.createElement('button');
  dislikeBtn.className = 'feedback-btn dislike';
  dislikeBtn.innerHTML = 'üëé Flag';
  dislikeBtn.onclick = () => addFeedback('dislike');
  
  popup.appendChild(likeBtn);
  popup.appendChild(dislikeBtn);
  document.body.appendChild(popup);
  
  feedbackPopup = popup;
}

function hideFeedbackPopup() {
  if (feedbackPopup) {
    feedbackPopup.remove();
    feedbackPopup = null;
  }
}

function addFeedback(type) {
  if (!currentSelection) return;
  
  let reason = null;
  if (type === 'dislike') {
    const reasons = [
      'Out of character',
      'Breaks continuity',
      'Plot hole',
      'Tonal mismatch',
      'Pacing issue',
      'Contradicts established facts',
      'Other'
    ];
    
    const reasonChoice = prompt(
      `Why flag this text?\n\n${reasons.map((r, i) => `${i+1}. ${r}`).join('\n')}\n\nEnter number (1-${reasons.length}):`,
      '1'
    );
    
    const idx = parseInt(reasonChoice) - 1;
    if (idx >= 0 && idx < reasons.length) {
      reason = reasons[idx];
    } else {
      reason = reasons[0];
    }
    
    if (idx === reasons.length - 1) {
      const customReason = prompt('Please specify the issue:');
      if (customReason) reason = customReason;
    }
  }
  
  const annotation = {
    id: generateId('annot'),
    text: currentSelection.text,
    type: type,
    reason: reason,
    elementId: currentSelection.elementId,
    nodeId: activeNodeId,
    timestamp: new Date().toISOString()
  };
  
  feedbackAnnotations.push(annotation);
  
  // Wrap the selected text
  const span = document.createElement('span');
  span.className = `feedback-annotation ${type === 'like' ? 'liked' : 'disliked'}`;
  span.setAttribute('data-annotation-id', annotation.id);
  span.setAttribute('title', type === 'dislike' ? `Flagged: ${reason}` : 'Liked');
  
  currentSelection.range.surroundContents(span);
  
  hideFeedbackPopup();
  currentSelection = null;
  
  alert(`Feedback recorded! This will be included in the export.`);
}

// ==================== STORY GENERATOR ====================
function renderGeneratorView() {
  const container = document.getElementById("generatorViewContainer");
  
  let html = '<div style="max-width:900px;">';
  html += `<h3 style="margin-top:0;color:var(--accent);">Story Generator</h3>`;
  html += `<p style="font-size:.7rem;color:var(--sub);margin-bottom:20px;">Generate narrative content using existing nodes. Select characters, locations, and events to create new story moments.</p>`;
  
  // Generator controls
  html += `<div class="generator-controls">`;
  html += `<div class="form-group">`;
  html += `<label class="form-label">Select Story Node</label>`;
  html += `<select class="form-select" id="gen_story">`;
  html += `<option value="">-- Choose story/scene/moment --</option>`;
  Object.values(nodes).filter(n => ["story", "scene", "moment"].includes(n.type)).forEach(node => {
    html += `<option value="${node.id}">${node.name} (${node.type})</option>`;
  });
  html += `</select>`;
  html += `</div>`;
  
  html += `<div class="form-group">`;
  html += `<label class="form-label">Characters (hold Ctrl to select multiple)</label>`;
  html += `<select class="form-select" id="gen_characters" multiple size="4">`;
  Object.values(nodes).filter(n => n.type === "character").forEach(node => {
    html += `<option value="${node.id}">${node.name}</option>`;
  });
  html += `</select>`;
  html += `</div>`;
  
  html += `<div class="form-group">`;
  html += `<label class="form-label">Location</label>`;
  html += `<select class="form-select" id="gen_location">`;
  html += `<option value="">-- Choose location --</option>`;
  Object.values(nodes).filter(n => n.type === "location").forEach(node => {
    html += `<option value="${node.id}">${node.name}</option>`;
  });
  html += `</select>`;
  html += `</div>`;
  
  html += `<div class="form-group">`;
  html += `<label class="form-label">Prompt/Direction</label>`;
  html += `<textarea class="form-textarea" id="gen_prompt" placeholder="E.g., 'Val confronts Tori about the leak, tension builds but ultimately they decide to work together...'"></textarea>`;
  html += `</div>`;
  
  html += `<button class="form-btn primary" onclick="generateStory()">Generate Story</button>`;
  html += `<button class="form-btn" onclick="clearGenerator()">Clear</button>`;
  html += `</div>`;
  
  // Output area
  html += `<div class="generator-output" id="generatorOutput">`;
  html += `<div style="color:var(--sub);font-style:italic;text-align:center;padding:40px;">Generated content will appear here...</div>`;
  html += `</div>`;
  
  html += '</div>';
  container.innerHTML = html;
}

function generateStory() {
  const storyId = document.getElementById('gen_story').value;
  const characterSelect = document.getElementById('gen_characters');
  const characterIds = Array.from(characterSelect.selectedOptions).map(opt => opt.value);
  const locationId = document.getElementById('gen_location').value;
  const prompt = document.getElementById('gen_prompt').value;
  
  if (!storyId || characterIds.length === 0) {
    alert('Please select at least a story node and one character.');
    return;
  }
  
  // Build context from nodes
  const storyNode = getNode(storyId);
  const characters = characterIds.map(id => getNode(id));
  const location = locationId ? getNode(locationId) : null;
  
  // Generate story using node data
  let generated = `# ${storyNode.name}\n\n`;
  
  if (location) {
    const hierarchy = getLocationHierarchy(locationId);
    generated += `**Location:** ${hierarchy.map(h => h.name).join(' ‚Üí ')}\n\n`;
  }
  
  generated += `**Characters:** ${characters.map(c => c.name).join(', ')}\n\n`;
  generated += `---\n\n`;
  
  // AI prompt context (this would be sent to an AI in production)
  generated += `${storyNode.description}\n\n`;
  
  if (prompt) {
    generated += `${prompt}\n\n`;
  }
  
  // Sample generated content (in production, this comes from AI)
  generated += `The ${location ? location.name : 'location'} was quiet at this hour. `;
  
  characters.forEach((char, idx) => {
    const sentiments = getSentimentsForCharacter(char.id);
    if (sentiments.length > 0) {
      const latest = sentiments[0];
      generated += `${char.name}, still ${latest.value.toLowerCase()}, `;
    } else {
      generated += `${char.name} `;
    }
    
    if (idx < characters.length - 1) {
      generated += `and `;
    }
  });
  
  generated += `stood facing each other.\n\n`;
  
  characters.forEach(char => {
    if (char.drives && char.drives.length > 0) {
      generated += `"${char.drives[0]}," ${char.name} thought, their resolve hardening.\n\n`;
    }
  });
  
  generated += `\n\n---\n\n`;
  generated += `**AI Context Export:**\n\n`;
  generated += `Story Node: ${storyNode.name} (${storyNode.id})\n`;
  generated += `Characters: ${characterIds.join(', ')}\n`;
  if (location) generated += `Location: ${locationId}\n`;
  generated += `\nThis content was generated using the story node system. `;
  generated += `All character sentiments, motivations, and relationships are derived from event-driven junctions. `;
  generated += `Feedback annotations will be used to refine future generations.\n`;
  
  // Display
  const output = document.getElementById('generatorOutput');
  output.innerHTML = `<div id="generatedContent_${Date.now()}" style="user-select:text;">${generated.replace(/\n/g, '<br>')}</div>`;
  
  // Store generation
  const genId = generateId('gen');
  generatedContent[genId] = {
    id: genId,
    nodeIds: [storyId, ...characterIds, locationId].filter(Boolean),
    content: generated,
    timestamp: new Date().toISOString(),
    annotations: []
  };
  
  // Enable feedback on generated content
  setTimeout(() => {
    setupTextSelectionFeedback(`generatedContent_${Date.now()}`);
  }, 100);
}

function clearGenerator() {
  document.getElementById('gen_story').value = '';
  document.getElementById('gen_characters').selectedIndex = -1;
  document.getElementById('gen_location').value = '';
  document.getElementById('gen_prompt').value = '';
  document.getElementById('generatorOutput').innerHTML = '<div style="color:var(--sub);font-style:italic;text-align:center;padding:40px;">Generated content will appear here...</div>';
}

// ==================== EXPORT SYSTEM ====================
function showExportModal() {
  const modal = document.createElement('div');
  modal.className = 'modal-overlay';
  modal.id = 'exportModal';
  
  let modalHTML = `<div class="modal-content">`;
  modalHTML += `<div class="modal-header">Export Data for AI Agent</div>`;
  modalHTML += `<p style="font-size:.7rem;color:var(--sub);margin-bottom:16px;">`;
  modalHTML += `This export includes all nodes, relationships, sentiment junctions, and feedback annotations as structured instructions for an AI agent.`;
  modalHTML += `</p>`;
  
  // Export options
  modalHTML += `<div class="form-group">`;
  modalHTML += `<label class="form-label">Export Format</label>`;
  modalHTML += `<select class="form-select" id="export_format">`;
  modalHTML += `<option value="json">JSON (structured data)</option>`;
  modalHTML += `<option value="markdown">Markdown (readable)</option>`;
  modalHTML += `<option value="ai_context">AI Context (instructions + feedback)</option>`;
  modalHTML += `</select>`;
  modalHTML += `</div>`;
  
  modalHTML += `<div class="modal-actions">`;
  modalHTML += `<button class="form-btn primary" onclick="performExport()">Download Export</button>`;
  modalHTML += `<button class="form-btn" onclick="closeExportModal()">Cancel</button>`;
  modalHTML += `</div>`;
  
  modalHTML += `</div>`;
  modal.innerHTML = modalHTML;
  
  modal.onclick = (e) => {
    if (e.target === modal) closeExportModal();
  };
  
  document.body.appendChild(modal);
}

function closeExportModal() {
  const modal = document.getElementById('exportModal');
  if (modal) modal.remove();
}

function performExport() {
  const format = document.getElementById('export_format').value;
  let content = '';
  let filename = '';
  
  if (format === 'json') {
    const exportData = {
      nodes: nodes,
      relationships: relationships,
      sentimentJunctions: sentimentJunctions,
      eventOutcomes: eventOutcomes,
      characterJourneys: characterJourneys,
      storyConnections: storyConnections,
      dialogues: dialogues,
      delayedMessages: delayedMessages,
      feedbackAnnotations: feedbackAnnotations,
      generatedContent: generatedContent,
      exportDate: new Date().toISOString()
    };
    content = JSON.stringify(exportData, null, 2);
    filename = 'story_nodes_export.json';
    
  } else if (format === 'markdown') {
    content = generateMarkdownExport();
    filename = 'story_nodes_export.md';
    
  } else if (format === 'ai_context') {
    content = generateAIContextExport();
    filename = 'ai_context_instructions.md';
  }
  
  // Download
  const blob = new Blob([content], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
  
  closeExportModal();
  alert(`Export complete! Downloaded as ${filename}`);
}

function generateMarkdownExport() {
  let md = `# Story Nodes Export\n\n`;
  md += `Generated: ${new Date().toLocaleString()}\n\n`;
  
  md += `## Characters\n\n`;
  Object.values(nodes).filter(n => n.type === 'character').forEach(char => {
    md += `### ${char.name}\n\n`;
    md += `${char.description}\n\n`;
    if (char.drives) {
      md += `**Drives:**\n${char.drives.map(d => `- ${d}`).join('\n')}\n\n`;
    }
  });
  
  md += `## Events\n\n`;
  Object.values(nodes).filter(n => n.type === 'event').forEach(evt => {
    md += `### ${evt.name} (${evt.dateDisplay})\n\n`;
    md += `${evt.description}\n\n`;
  });
  
  return md;
}

function generateAIContextExport() {
  let ctx = `# AI Agent Context & Instructions\n\n`;
  ctx += `**Generated:** ${new Date().toLocaleString()}\n`;
  ctx += `**System Version:** Node Explorer v1.0\n`;
  ctx += `**Export Type:** Comprehensive AI Context with Feedback Loops\n\n`;
  
  ctx += `---\n\n`;
  
  ctx += `# üìã INSTRUCTION CARD\n\n`;
  ctx += `## Purpose\n\n`;
  ctx += `This export provides a complete narrative universe specification designed for AI-driven story generation. `;
  ctx += `It includes structured nodes (characters, locations, events, story structure), relationships, `;
  ctx += `event-driven sentiment evolution, and human feedback annotations.\n\n`;
  
  ctx += `## How to Use This Data\n\n`;
  ctx += `1. **Load the complete data structure** from the JSON section at the bottom\n`;
  ctx += `2. **Review feedback annotations** to understand what worked and what didn't\n`;
  ctx += `3. **Follow the constraint rules** for character psychology and location hierarchy\n`;
  ctx += `4. **Generate content** that respects the event-driven causality model\n`;
  ctx += `5. **Maintain continuity** across the hierarchical story structure\n\n`;
  
  ctx += `---\n\n`;
  
  ctx += `# üìñ DATA INTERPRETATION GUIDE\n\n`;
  
  ctx += `## Node Types\n\n`;
  ctx += `### Characters\n`;
  ctx += `- **Personality Type (MBTI):** Use to inform dialogue style and decision-making patterns\n`;
  ctx += `- **Drives:** Primary motivations that guide long-term behavior\n`;
  ctx += `- **Traits:** Consistent behavioral patterns and characteristics\n`;
  ctx += `- **Current Status:** Calculated emotional state based on recent changes\n`;
  ctx += `  - **Statuses:** stable, motivated, unnerved, volatile, conflicted, settled, evolving\n`;
  ctx += `  - **Disparity Score:** Higher = more divergence from historical baseline\n\n`;
  
  ctx += `### Locations\n`;
  ctx += `- **Hierarchy:** Universe ‚Üí Realm ‚Üí Domain ‚Üí Sector ‚Üí Feature ‚Üí Room ‚Üí POI\n`;
  ctx += `- **Parent ID:** Always reference full hierarchy for context\n`;
  ctx += `- **Example:** "Floor 195 - Engine Room" is in "Central Archive Tower" in "New Canon City" in "New Earth"\n\n`;
  
  ctx += `### Events and Moments\n`;
  ctx += `- **All events have in-universe date/time** (YYYY-MM-DD HH:MM)\n`;
  ctx += `- **Events drive sentiment changes** - characters don't change randomly\n`;
  ctx += `- **Impact field:** Describes broader consequences beyond immediate participants\n`;
  ctx += `- **Outcomes:** EVERY significant event/moment MUST have character journey outcomes\n`;
  ctx += `  - **Outcome Types:** growth, setback, mixed, neutral\n`;
  ctx += `  - **Trait Modifiers:** Specify which traits changed, by how much, and WHY\n`;
  ctx += `  - **Alignment Modifiers:** Track lawful/chaotic and good/evil shifts\n`;
  ctx += `  - **Narrative Impact:** One-sentence summary of the transformative effect\n\n`;
  
  ctx += `### Story Structure\n`;
  ctx += `- **Hierarchy:** Moment ‚Üí Scene ‚Üí Sequence ‚Üí Act ‚Üí Story ‚Üí Arc ‚Üí Season ‚Üí Series\n`;
  ctx += `- **CRITICAL:** Each segment MUST be parented by its immediate higher-order category\n`;
  ctx += `  - Moment belongs to Scene\n`;
  ctx += `  - Scene belongs to Sequence\n`;
  ctx += `  - Sequence belongs to Act\n`;
  ctx += `  - Act belongs to Story\n`;
  ctx += `  - Story belongs to Arc\n`;
  ctx += `  - Arc belongs to Season\n`;
  ctx += `  - Season belongs to Series\n`;
  ctx += `  - Series has no parent (top-level)\n`;
  ctx += `- **Moments:** Contain actual prose content\n`;
  ctx += `- **Scenes:** Contain multiple moments, have location and characters\n`;
  ctx += `- **Story Connections:** Define character involvement (primary, cross-over, cameo, reference)\n\n`;
  
  ctx += `---\n\n`;
  
  ctx += `# ‚ö†Ô∏è CRITICAL CONSTRAINTS\n\n`;
  
  ctx += `## 1. Story Structure Hierarchy (MANDATORY)\n`;
  ctx += `**RULE:** ALL story segments MUST be parented by their immediate higher-order category.\n\n`;
  ctx += `**Why:** Maintains structural integrity and allows proper navigation/context.\n\n`;
  ctx += `**The hierarchy is STRICT:**\n`;
  ctx += `- Series (top-level, no parent)\n`;
  ctx += `  ‚îî‚îÄ Season (parent: series)\n`;
  ctx += `     ‚îî‚îÄ Arc (parent: season)\n`;
  ctx += `        ‚îî‚îÄ Story (parent: arc)\n`;
  ctx += `           ‚îî‚îÄ Act (parent: story)\n`;
  ctx += `              ‚îî‚îÄ Sequence (parent: act)\n`;
  ctx += `                 ‚îî‚îÄ Scene (parent: sequence)\n`;
  ctx += `                    ‚îî‚îÄ Moment (parent: scene)\n\n`;
  ctx += `**How to comply:**\n`;
  ctx += `- A moment can ONLY have a scene as parent\n`;
  ctx += `- A scene can ONLY have a sequence as parent\n`;
  ctx += `- Never skip levels (e.g., moment ‚Üí sequence is INVALID)\n`;
  ctx += `- Always verify parentId before creating story nodes\n\n`;
  
  ctx += `## 2. Event-Driven Psychology\n`;
  ctx += `**RULE:** Characters' sentiments and motivations can ONLY change due to events.\n\n`;
  ctx += `**Why:** This ensures causality and prevents arbitrary personality shifts.\n\n`;
  ctx += `**How to comply:**\n`;
  ctx += `- Before changing a character's feelings or goals, identify or create an event\n`;
  ctx += `- Reference the event's timestamp when describing the change\n`;
  ctx += `- Store the change in a sentiment junction with full provenance\n\n`;
  
  ctx += `## 3. Location Context\n`;
  ctx += `**RULE:** Always maintain awareness of location hierarchy.\n\n`;
  ctx += `**Why:** Physical context affects what's possible and what characters know.\n\n`;
  ctx += `**How to comply:**\n`;
  ctx += `- Reference the full hierarchy path when describing scenes\n`;
  ctx += `- Consider parent location constraints (e.g., events in a room are inside a building)\n`;
  ctx += `- Use location type to inform descriptions (universe vs. room scale)\n\n`;
  
  ctx += `## 4. Character Status Awareness\n`;
  ctx += `**RULE:** Characters' current emotional states inform their behavior.\n\n`;
  ctx += `**Why:** A "volatile" character acts differently than a "settled" one.\n\n`;
  ctx += `**Status Meanings:**\n`;
  ctx += `- **stable:** No recent changes, predictable behavior\n`;
  ctx += `- **motivated:** Recently gained new drive, highly proactive\n`;
  ctx += `- **unnerved:** Multiple recent changes, uncertain/reactive\n`;
  ctx += `- **volatile:** Rapid shifts, unpredictable, emotionally unstable\n`;
  ctx += `- **conflicted:** Current state contradicts history, internal struggle\n`;
  ctx += `- **settled:** Long period of stability, emotionally grounded\n`;
  ctx += `- **evolving:** Gradual shift in progress, transitional state\n\n`;
  
  ctx += `---\n\n`;
  
  ctx += `# üëçüëé FEEDBACK SUMMARY\n\n`;
  
  if (feedbackAnnotations.length > 0) {
    ctx += `**Total Annotations:** ${feedbackAnnotations.length}\n\n`;
    
    const likes = feedbackAnnotations.filter(a => a.type === 'like');
    const dislikes = feedbackAnnotations.filter(a => a.type === 'dislike');
    
    ctx += `## ‚úÖ Liked Patterns (${likes.length})\n\n`;
    ctx += `These elements were explicitly approved by the user. EMULATE these patterns.\n\n`;
    likes.forEach(annot => {
      const node = getNode(annot.nodeId);
      ctx += `### Example ${likes.indexOf(annot) + 1}\n`;
      ctx += `**Text:** "${annot.text}"\n\n`;
      ctx += `**Context:** ${node ? node.name + ' (' + node.type + ')' : annot.nodeId}\n\n`;
      ctx += `**Why it worked:** User found this compelling/accurate/well-written\n\n`;
    });
    
    ctx += `## ‚ùå Flagged Patterns (${dislikes.length})\n\n`;
    ctx += `These elements were flagged as problematic. AVOID similar patterns.\n\n`;
    dislikes.forEach(annot => {
      const node = getNode(annot.nodeId);
      ctx += `### Issue ${dislikes.indexOf(annot) + 1}\n`;
      ctx += `**Text:** "${annot.text}"\n\n`;
      ctx += `**Problem:** ${annot.reason}\n\n`;
      ctx += `**Context:** ${node ? node.name + ' (' + node.type + ')' : annot.nodeId}\n\n`;
      ctx += `**How to avoid:** `;
      switch(annot.reason) {
        case 'Out of character':
          ctx += `Review character drives, traits, and personality type before writing dialogue/actions.\n\n`;
          break;
        case 'Breaks continuity':
          ctx += `Check event timeline and location hierarchy for contradictions.\n\n`;
          break;
        case 'Plot hole':
          ctx += `Ensure all cause-and-effect chains are logically complete.\n\n`;
          break;
        case 'Tonal mismatch':
          ctx += `Match the tone established in parent story/arc nodes.\n\n`;
          break;
        case 'Pacing issue':
          ctx += `Balance exposition, action, and character moments within scene structure.\n\n`;
          break;
        case 'Contradicts established facts':
          ctx += `Cross-reference all assertions against existing node data.\n\n`;
          break;
        default:
          ctx += `User-specified issue: resolve before similar generation.\n\n`;
      }
    });
    
    ctx += `## üéØ Generation Instructions\n\n`;
    ctx += `When generating new content:\n\n`;
    ctx += `1. **PATTERN MATCHING:** Analyze liked content for common elements (tone, structure, detail level)\n`;
    ctx += `2. **PATTERN AVOIDANCE:** Identify and avoid flagged patterns (check reason categories)\n`;
    ctx += `3. **CONSTRAINT ADHERENCE:** Verify all constraints are met before finalizing\n`;
    ctx += `4. **CONTEXT INTEGRATION:** Use character status, location hierarchy, and event timeline\n`;
    ctx += `5. **FEEDBACK ITERATION:** Each generation should improve based on accumulated feedback\n\n`;
  } else {
    ctx += `No feedback annotations recorded yet.\n\n`;
    ctx += `**Note:** As users interact with generated content, they will mark text as liked (üëç) or flagged (üëé). `;
    ctx += `These annotations accumulate to create a feedback loop that guides future generation.\n\n`;
  }
  
  ctx += `---\n\n`;
  
  ctx += `# üìä CHARACTER JOURNEY OUTCOMES\n\n`;
  ctx += `Every event/moment that transforms characters through trait and alignment changes:\n\n`;
  
  eventOutcomes.forEach(outcome => {
    const char = getNode(outcome.characterId);
    const momentNode = getNode(outcome.momentId || outcome.eventId);
    ctx += `### ${momentNode ? momentNode.name : (outcome.momentId || outcome.eventId)} ‚Üí ${char ? char.name : outcome.characterId}\n\n`;
    ctx += `- **Outcome Type:** ${outcome.outcomeType}\n`;
    
    if (outcome.traitModifiers && Object.keys(outcome.traitModifiers).length > 0) {
      ctx += `- **Trait Changes:**\n`;
      Object.entries(outcome.traitModifiers).forEach(([trait, mod]) => {
        ctx += `  - **${trait}:** ${mod.change > 0 ? '+' : ''}${mod.change} (${mod.reason})\n`;
      });
    }
    
    if (outcome.alignmentModifiers && Object.keys(outcome.alignmentModifiers).length > 0) {
      ctx += `- **Alignment Shifts:**\n`;
      Object.entries(outcome.alignmentModifiers).forEach(([axis, mod]) => {
        ctx += `  - **${axis.replace('_', ' ‚Üí ')}:** ${mod.change > 0 ? '+' : ''}${mod.change} (${mod.reason})\n`;
      });
    }
    
    if (outcome.narrativeImpact) {
      ctx += `- **Impact:** ${outcome.narrativeImpact}\n`;
    }
    ctx += `\n`;
  });
  
  ctx += `---\n\n`;
  
  ctx += `# üîó SENTIMENT JUNCTIONS\n\n`;
  ctx += `All character psychology changes with full provenance:\n\n`;
  
  sentimentJunctions.forEach(sj => {
    const char = getNode(sj.characterId);
    const evt = getNode(sj.eventId);
    ctx += `### ${char ? char.name : sj.characterId} - ${sj.name}\n\n`;
    ctx += `- **Type:** ${sj.type}\n`;
    ctx += `- **Changed to:** "${sj.value}"\n`;
    ctx += `- **Previous:** "${sj.previousValue}"\n`;
    ctx += `- **Caused by:** ${evt ? evt.name : sj.eventId}\n`;
    ctx += `- **Timestamp:** ${sj.timestamp}\n`;
    ctx += `- **Description:** ${sj.description}\n\n`;
  });
  
  ctx += `---\n\n`;
  
  ctx += `# üìä CHARACTER STATUS ANALYSIS\n\n`;
  
  Object.values(nodes).filter(n => n.type === 'character').forEach(char => {
    const status = calculateCharacterStatus(char.id);
    ctx += `## ${char.name} (${char.personalityType})\n\n`;
    ctx += `- **Current Status:** ${status.status.toUpperCase()} (${status.emotionalState})\n`;
    ctx += `- **Description:** ${status.description}\n`;
    ctx += `- **Total Changes:** ${status.totalChanges}\n`;
    ctx += `- **Recent Changes:** ${status.recentChanges}\n`;
    ctx += `- **Disparity Score:** ${status.disparity}\n`;
    if (status.motivatingEvent) {
      const evt = getNode(status.motivatingEvent);
      ctx += `- **Motivated By:** ${evt ? evt.name : status.motivatingEvent}\n`;
    }
    ctx += `\n`;
  });
  
  ctx += `---\n\n`;
  
  ctx += `# üì¶ COMPLETE DATA EXPORT\n\n`;
  ctx += `## JSON Structure\n\n`;
  ctx += `\`\`\`json\n`;
  ctx += JSON.stringify({
    metadata: {
      exportDate: new Date().toISOString(),
      version: "1.0",
      totalNodes: Object.keys(nodes).length,
      totalRelationships: relationships.length,
      totalSentimentJunctions: sentimentJunctions.length,
      totalEventOutcomes: eventOutcomes.length,
      totalCharacterJourneys: characterJourneys.length,
      totalDialogues: dialogues.length,
      totalDelayedMessages: delayedMessages.length,
      totalFeedback: feedbackAnnotations.length
    },
    nodes: nodes,
    relationships: relationships,
    sentimentJunctions: sentimentJunctions,
    eventOutcomes: eventOutcomes,
    characterJourneys: characterJourneys,
    storyConnections: storyConnections,
    dialogues: dialogues,
    delayedMessages: delayedMessages,
    feedbackAnnotations: feedbackAnnotations,
    generatedContent: generatedContent
  }, null, 2);
  ctx += `\n\`\`\`\n\n`;
  
  ctx += `---\n\n`;
  
  ctx += `# üöÄ QUICK START\n\n`;
  ctx += `1. Load the JSON data structure\n`;
  ctx += `2. Review character statuses and recent sentiment changes\n`;
  ctx += `3. Check feedback annotations for dos/don'ts\n`;
  ctx += `4. Select a story node (scene/moment) to generate\n`;
  ctx += `5. Pull relevant character data (drives, traits, personality, current status)\n`;
  ctx += `6. Pull location hierarchy for environmental context\n`;
  ctx += `7. Generate content respecting all constraints\n`;
  ctx += `8. New content should feel consistent with liked patterns\n`;
  ctx += `9. Submit generated content for user feedback\n`;
  ctx += `10. Iterate based on new annotations\n\n`;
  
  ctx += `---\n\n`;
  ctx += `**End of AI Context Export**\n`;
  
  return ctx;
}

// Make functions available globally
window.updateQuestionnaireFields = updateQuestionnaireFields;
window.submitQuestionnaire = submitQuestionnaire;
window.clearQuestionnaire = clearQuestionnaire;
window.saveNodeEdits = saveNodeEdits;
window.deleteNode = deleteNode;
window.generateStory = generateStory;
window.clearGenerator = clearGenerator;
window.showExportModal = showExportModal;
window.closeExportModal = closeExportModal;
window.performExport = performExport;
window.addDialogue = addDialogue;
window.addDelayedMessage = addDelayedMessage;
window.interceptMessage = interceptMessage;
window.getDialoguesByMoment = getDialoguesByMoment;
window.getDialoguesByCharacter = getDialoguesByCharacter;
window.changeJourneyCharacter = changeJourneyCharacter;
window.toggleTrait = toggleTrait;

// ==================== NODE SELECTION ====================
function selectNode(nodeId) {
  activeNodeId = nodeId;
  renderTree();
  
  if (currentView === "node") {
    renderNodeView(nodeId);
  } else if (currentView === "edit") {
    renderEditView(nodeId);
  }
  
  renderPropertiesPanel(nodeId);
}

// ==================== RELATIONSHIP GRAPH ====================
function renderGraphView() {
  const container = document.getElementById("graphViewContainer");
  container.innerHTML = `
    <h2>Character Relationship Graph</h2>
    <div class="graph-canvas" id="graphCanvas"></div>
  `;
  
  const canvas = document.getElementById("graphCanvas");
  const canvasRect = canvas.getBoundingClientRect();
  const width = canvasRect.width || 800;
  const height = 700;
  canvas.style.height = height + "px";
  
  // Get all characters
  const characters = Object.values(nodes).filter(n => 
    n.type === "character" || n.type === "deity" || n.type === "primordial"
  );
  
  // Group by series
  const seriesClusters = {};
  storyConnections.forEach(conn => {
    if (!seriesClusters[conn.seriesId]) {
      seriesClusters[conn.seriesId] = [];
    }
    const char = characters.find(c => c.id === conn.characterId);
    if (char && !seriesClusters[conn.seriesId].includes(char)) {
      seriesClusters[conn.seriesId].push(char);
    }
  });
  
  // Position clusters
  const seriesIds = Object.keys(seriesClusters);
  const clusterSpacing = width / (seriesIds.length + 1);
  
  let bubbles = [];
  
  seriesIds.forEach((seriesId, idx) => {
    const series = nodes[seriesId];
    const clusterChars = seriesClusters[seriesId];
    const centerX = clusterSpacing * (idx + 1);
    const centerY = height / 2;
    const radius = 120;
    
    // Position characters in circle
    clusterChars.forEach((char, i) => {
      const angle = (i / clusterChars.length) * Math.PI * 2;
      const x = centerX + Math.cos(angle) * radius;
      const y = centerY + Math.sin(angle) * radius;
      
      const bubble = document.createElement("div");
      bubble.className = "graph-bubble";
      if (char.type === "deity" || char.type === "primordial") {
        bubble.classList.add("deity");
      } else if (char.tags?.includes("protagonist")) {
        bubble.classList.add("hero");
      }
      
      const size = 60 + (char.drives?.length || 0) * 5;
      bubble.style.width = size + "px";
      bubble.style.height = size + "px";
      bubble.style.left = (x - size/2) + "px";
      bubble.style.top = (y - size/2) + "px";
      bubble.textContent = char.name;
      bubble.title = char.description;
      
      bubble.addEventListener("click", () => selectNode(char.id));
      
      canvas.appendChild(bubble);
      bubbles.push({ char, x, y, series: seriesId });
    });
    
    // Draw cluster boundary
    const cluster = document.createElement("div");
    cluster.className = "graph-cluster";
    cluster.style.left = (centerX - radius - 40) + "px";
    cluster.style.top = (centerY - radius - 40) + "px";
    cluster.style.width = (radius * 2 + 80) + "px";
    cluster.style.height = (radius * 2 + 80) + "px";
    
    const label = document.createElement("div");
    label.className = "graph-cluster-label";
    label.textContent = series?.name || seriesId;
    cluster.appendChild(label);
    
    canvas.appendChild(cluster);
  });
  
  // Draw relationship lines (connect characters in same series)
  bubbles.forEach((b1, i) => {
    bubbles.slice(i + 1).forEach(b2 => {
      if (b1.series === b2.series) {
        const dx = b2.x - b1.x;
        const dy = b2.y - b1.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);
        
        const line = document.createElement("div");
        line.className = "graph-line ally";
        line.style.width = dist + "px";
        line.style.left = b1.x + "px";
        line.style.top = b1.y + "px";
        line.style.transform = `rotate(${angle}rad)`;
        
        canvas.insertBefore(line, canvas.firstChild);
      }
    });
  });
}

// ==================== CHARACTER JOURNEY VISUALIZATION ====================
let selectedJourneyCharacter = null;
let selectedTraits = ['confidence', 'wisdom', 'maturity'];

function renderJourneyView() {
  const container = document.getElementById("journeyViewContainer");
  
  // Get all characters with journey data
  const charactersWithJourney = [...new Set(characterJourneys.map(j => j.characterId))];
  const characters = charactersWithJourney.map(id => getNode(id)).filter(Boolean);
  
  if (!selectedJourneyCharacter && characters.length > 0) {
    selectedJourneyCharacter = characters[0].id;
  }
  
  // Get outcomes for the selected character
  const characterOutcomes = getOutcomesForCharacter(selectedJourneyCharacter);
  const selectedChar = getNode(selectedJourneyCharacter);
  
  let html = `
    <div style="padding:16px;">
      <h2 style="margin-bottom:16px;color:var(--accent);">Character Journey Visualization</h2>
      
      <div class="journey-controls">
        <div class="journey-control-group">
          <label style="font-size:.7rem;font-weight:600;color:var(--sub);">CHARACTER</label>
          <select id="journeyCharacterSelect" class="form-select" onchange="changeJourneyCharacter(this.value)">
            ${characters.map(char => `
              <option value="${char.id}" ${selectedJourneyCharacter === char.id ? 'selected' : ''}>
                ${char.name}
              </option>
            `).join('')}
          </select>
        </div>
        
        <div class="journey-control-group">
          <label style="font-size:.7rem;font-weight:600;color:var(--sub);">TRAITS TO DISPLAY (select up to 4)</label>
          <div class="trait-selector" id="traitSelector">
            ${availableTraits.map(trait => `
              <label class="trait-checkbox ${selectedTraits.includes(trait) ? 'selected' : ''}">
                <input type="checkbox" 
                       value="${trait}" 
                       ${selectedTraits.includes(trait) ? 'checked' : ''}
                       onchange="toggleTrait('${trait}')">
                <span>${trait}</span>
              </label>
            `).join('')}
          </div>
        </div>
      </div>
      
      <div style="display:grid;grid-template-columns:1fr 450px;gap:24px;margin-bottom:24px;">
        <div>
          <h3 style="margin-bottom:12px;font-size:.85rem;color:var(--text);">Trait Progression Over Time</h3>
          <canvas id="traitProgressionCanvas" class="journey-canvas" width="700" height="400"></canvas>
        </div>
        
        <div>
          <h3 style="margin-bottom:12px;font-size:.85rem;color:var(--text);">Alignment Chart Evolution</h3>
          <div id="alignmentChartContainer"></div>
        </div>
      </div>
      
      <div style="margin-top:32px;">
        <h3 style="margin-bottom:16px;font-size:.85rem;color:var(--text);">üìä Journey Outcomes for ${selectedChar ? selectedChar.name : 'Character'}</h3>
        <div style="background:var(--panel-alt);border:1px solid var(--border);border-radius:var(--radius);padding:16px;">
          ${characterOutcomes.length > 0 ? `
            <div style="font-size:.7rem;color:var(--sub);margin-bottom:12px;">
              Total transformative events: ${characterOutcomes.length}
            </div>
            ${characterOutcomes.map((outcome, idx) => {
              const momentNode = getNode(outcome.momentId || outcome.eventId);
              const outcomeTypeColors = {
                growth: '#4dff9c',
                setback: '#ff4d6a',
                mixed: '#ffd732',
                neutral: '#9a9aaa'
              };
              const outcomeColor = outcomeTypeColors[outcome.outcomeType] || '#9a9aaa';
              
              return `
                <div style="background:var(--panel);border:1px solid var(--border);border-radius:6px;padding:12px;margin-bottom:12px;border-left:4px solid ${outcomeColor};">
                  <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:8px;">
                    <div>
                      <div style="font-size:.75rem;font-weight:600;color:var(--text);">
                        ${momentNode ? momentNode.name : (outcome.momentId || outcome.eventId)}
                      </div>
                      <div style="font-size:.65rem;color:var(--sub);margin-top:2px;">
                        Outcome Type: <span style="color:${outcomeColor};font-weight:600;text-transform:uppercase;">${outcome.outcomeType}</span>
                      </div>
                    </div>
                  </div>
                  
                  ${outcome.traitModifiers && Object.keys(outcome.traitModifiers).length > 0 ? `
                    <div style="margin-bottom:8px;">
                      <div style="font-size:.65rem;font-weight:600;color:var(--sub);margin-bottom:6px;">Trait Modifications:</div>
                      ${Object.entries(outcome.traitModifiers).map(([trait, mod]) => `
                        <div style="display:flex;align-items:center;gap:8px;margin-bottom:4px;font-size:.65rem;">
                          <span style="background:var(--panel-alt);padding:2px 6px;border-radius:3px;font-weight:600;color:var(--accent);">${trait}</span>
                          <span style="color:${mod.change > 0 ? '#4dff9c' : '#ff4d6a'};font-weight:600;">
                            ${mod.change > 0 ? '‚ñ≤' : '‚ñº'} ${mod.change > 0 ? '+' : ''}${mod.change}
                          </span>
                          <span style="color:var(--text);">${mod.reason}</span>
                        </div>
                      `).join('')}
                    </div>
                  ` : ''}
                  
                  ${outcome.alignmentModifiers && Object.keys(outcome.alignmentModifiers).length > 0 ? `
                    <div style="margin-bottom:8px;">
                      <div style="font-size:.65rem;font-weight:600;color:var(--sub);margin-bottom:6px;">Alignment Shifts:</div>
                      ${Object.entries(outcome.alignmentModifiers).map(([axis, mod]) => `
                        <div style="display:flex;align-items:center;gap:8px;margin-bottom:4px;font-size:.65rem;">
                          <span style="background:var(--panel-alt);padding:2px 6px;border-radius:3px;font-weight:600;color:var(--accent);">${axis.replace('_', ' ‚Üí ')}</span>
                          <span style="color:${mod.change > 0 ? '#4d9cff' : '#ff9c4d'};font-weight:600;">
                            ${mod.change > 0 ? '+' : ''}${mod.change}
                          </span>
                          <span style="color:var(--text);">${mod.reason}</span>
                        </div>
                      `).join('')}
                    </div>
                  ` : ''}
                  
                  ${outcome.narrativeImpact ? `
                    <div style="font-size:.65rem;color:var(--sub);font-style:italic;margin-top:8px;padding-top:8px;border-top:1px solid var(--border);">
                      üìñ ${outcome.narrativeImpact}
                    </div>
                  ` : ''}
                </div>
              `;
            }).join('')}
          ` : `
            <div style="text-align:center;color:var(--sub);font-style:italic;padding:20px;">
              No journey outcomes recorded for this character yet.
            </div>
          `}
        </div>
      </div>
    </div>
  `;
  
  container.innerHTML = html;
  
  // Render visualizations
  drawTraitProgression();
  drawAlignmentChart();
}

function changeJourneyCharacter(characterId) {
  selectedJourneyCharacter = characterId;
  renderJourneyView();
}

function toggleTrait(trait) {
  const index = selectedTraits.indexOf(trait);
  if (index > -1) {
    selectedTraits.splice(index, 1);
  } else {
    if (selectedTraits.length < 4) {
      selectedTraits.push(trait);
    } else {
      alert('Maximum 4 traits can be selected for clarity');
      // Uncheck the checkbox
      setTimeout(() => {
        const checkbox = document.querySelector(`input[value="${trait}"]`);
        if (checkbox) checkbox.checked = false;
      }, 0);
      return;
    }
  }
  renderJourneyView();
}

function drawTraitProgression() {
  const canvas = document.getElementById('traitProgressionCanvas');
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  const width = canvas.width;
  const height = canvas.height;
  const padding = 50;
  const graphWidth = width - padding * 2;
  const graphHeight = height - padding * 2;
  
  // Clear canvas
  ctx.clearRect(0, 0, width, height);
  
  // Get journey data for selected character
  const journeyData = characterJourneys.filter(j => j.characterId === selectedJourneyCharacter);
  
  if (journeyData.length === 0) {
    ctx.fillStyle = '#999';
    ctx.font = '14px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('No journey data available for this character', width / 2, height / 2);
    return;
  }
  
  // Get outcomes for this character
  const outcomes = getOutcomesForCharacter(selectedJourneyCharacter);
  
  // Draw axes
  ctx.strokeStyle = '#666';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(padding, padding);
  ctx.lineTo(padding, height - padding);
  ctx.lineTo(width - padding, height - padding);
  ctx.stroke();
  
  // Draw grid lines and Y-axis labels
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 1;
  ctx.fillStyle = '#999';
  ctx.font = '10px sans-serif';
  ctx.textAlign = 'right';
  
  for (let i = 0; i <= 10; i++) {
    const y = height - padding - (i / 10) * graphHeight;
    ctx.beginPath();
    ctx.moveTo(padding, y);
    ctx.lineTo(width - padding, y);
    ctx.stroke();
    ctx.fillText(i.toString(), padding - 10, y + 4);
  }
  
  // Draw X-axis labels (timestamps)
  ctx.textAlign = 'center';
  journeyData.forEach((point, index) => {
    const x = padding + (index / (journeyData.length - 1 || 1)) * graphWidth;
    ctx.fillText(point.timestamp, x, height - padding + 20);
  });
  
  // Draw trait lines
  const traitColors = [
    '#4dff9c',  // green
    '#ffd732',  // yellow
    '#ff4d6a',  // red
    '#4d9cff'   // blue
  ];
  
  selectedTraits.forEach((trait, traitIndex) => {
    ctx.strokeStyle = traitColors[traitIndex % traitColors.length];
    ctx.lineWidth = 3;
    ctx.beginPath();
    
    journeyData.forEach((point, index) => {
      const value = point.traits[trait] || 0;
      const x = padding + (index / (journeyData.length - 1 || 1)) * graphWidth;
      const y = height - padding - (value / 10) * graphHeight;
      
      if (index === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
      
      // Draw point
      ctx.fillStyle = traitColors[traitIndex % traitColors.length];
      ctx.fillRect(x - 3, y - 3, 6, 6);
      
      // Find outcome for this moment
      const outcome = outcomes.find(oc => oc.momentId === point.momentId || oc.eventId === point.momentId);
      
      if (outcome && outcome.traitModifiers && outcome.traitModifiers[trait]) {
        const modifier = outcome.traitModifiers[trait];
        const change = modifier.change;
        
        // Draw outcome indicator (arrow showing growth/setback)
        if (change > 0) {
          // Growth - draw upward arrow
          ctx.fillStyle = '#4dff9c';
          ctx.beginPath();
          ctx.moveTo(x, y - 8);
          ctx.lineTo(x - 4, y - 14);
          ctx.lineTo(x + 4, y - 14);
          ctx.closePath();
          ctx.fill();
          
          // Draw +N indicator
          ctx.fillStyle = '#4dff9c';
          ctx.font = '9px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText(`+${change}`, x, y - 16);
        } else if (change < 0) {
          // Setback - draw downward arrow
          ctx.fillStyle = '#ff4d6a';
          ctx.beginPath();
          ctx.moveTo(x, y + 8);
          ctx.lineTo(x - 4, y + 14);
          ctx.lineTo(x + 4, y + 14);
          ctx.closePath();
          ctx.fill();
          
          // Draw -N indicator
          ctx.fillStyle = '#ff4d6a';
          ctx.font = '9px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText(`${change}`, x, y + 22);
        }
      }
    });
    
    ctx.stroke();
  });
  
  // Draw legend
  ctx.textAlign = 'left';
  ctx.font = '12px sans-serif';
  selectedTraits.forEach((trait, index) => {
    const legendX = width - padding - 120;
    const legendY = padding + index * 20;
    
    ctx.fillStyle = traitColors[index % traitColors.length];
    ctx.fillRect(legendX, legendY - 8, 15, 10);
    
    ctx.fillStyle = '#ddd';
    ctx.fillText(trait, legendX + 20, legendY);
  });
  
  // Draw outcome type legend
  ctx.font = '10px sans-serif';
  ctx.fillStyle = '#4dff9c';
  ctx.fillText('‚ñ≤ Growth', padding, 20);
  ctx.fillStyle = '#ff4d6a';
  ctx.fillText('‚ñº Setback', padding + 70, 20);
}

function drawAlignmentChart() {
  const container = document.getElementById('alignmentChartContainer');
  if (!container) return;
  
  // Get journey data for selected character
  const journeyData = characterJourneys.filter(j => j.characterId === selectedJourneyCharacter);
  
  if (journeyData.length === 0) {
    container.innerHTML = '<div style="color:var(--sub);font-style:italic;">No alignment data available</div>';
    return;
  }
  
  let html = `
    <div class="alignment-chart">
      <!-- Grid lines -->
      <svg width="400" height="400" style="position:absolute;top:0;left:0;pointer-events:none;">
        <line x1="0" y1="200" x2="400" y2="200" stroke="#444" stroke-width="2"/>
        <line x1="200" y1="0" x2="200" y2="400" stroke="#444" stroke-width="2"/>
        
        <!-- Quadrant labels -->
        <text x="100" y="100" fill="#666" font-size="11" text-anchor="middle" font-weight="bold">Lawful Good</text>
        <text x="300" y="100" fill="#666" font-size="11" text-anchor="middle" font-weight="bold">Chaotic Good</text>
        <text x="100" y="300" fill="#666" font-size="11" text-anchor="middle" font-weight="bold">Lawful Evil</text>
        <text x="300" y="300" fill="#666" font-size="11" text-anchor="middle" font-weight="bold">Chaotic Evil</text>
        <text x="200" y="25" fill="#888" font-size="10" text-anchor="middle">GOOD</text>
        <text x="200" y="390" fill="#888" font-size="10" text-anchor="middle">EVIL</text>
        <text x="25" y="205" fill="#888" font-size="10" text-anchor="middle">LAWFUL</text>
        <text x="375" y="205" fill="#888" font-size="10" text-anchor="middle">CHAOTIC</text>
      </svg>
  `;
  
  // Plot alignment points
  journeyData.forEach((point, index) => {
    const alignment = point.alignment;
    // Convert alignment values (-5 to 5) to pixel coordinates (0 to 400)
    // X axis: lawful (-5) = 0, neutral (0) = 200, chaotic (5) = 400
    // Y axis: good (-5) = 0, neutral (0) = 200, evil (5) = 400
    const x = 200 + (alignment.lawful_chaotic / 5) * 200;
    const y = 200 + (alignment.good_evil / 5) * 200;
    
    const hue = (index / journeyData.length) * 360;
    
    html += `
      <div class="alignment-point" 
           style="left:${x}px;top:${y}px;background:hsl(${hue}, 70%, 50%);z-index:${index + 1};"
           title="${point.timestamp}: L/C=${alignment.lawful_chaotic}, G/E=${alignment.good_evil}">
      </div>
    `;
    
    // Draw connecting line to next point
    if (index < journeyData.length - 1) {
      const nextPoint = journeyData[index + 1];
      const nextX = 200 + (nextPoint.alignment.lawful_chaotic / 5) * 200;
      const nextY = 200 + (nextPoint.alignment.good_evil / 5) * 200;
      
      const dx = nextX - x;
      const dy = nextY - y;
      const length = Math.sqrt(dx * dx + dy * dy);
      const angle = Math.atan2(dy, dx) * 180 / Math.PI;
      
      html += `
        <div style="position:absolute;left:${x}px;top:${y}px;width:${length}px;height:2px;background:var(--accent);transform:rotate(${angle}deg);transform-origin:0 0;opacity:0.5;z-index:0;"></div>
      `;
    }
  });
  
  html += `</div>`;
  
  // Add timeline legend
  html += `
    <div style="margin-top:12px;font-size:.7rem;">
      <div style="font-weight:600;color:var(--sub);margin-bottom:8px;">Timeline Points:</div>
      ${journeyData.map((point, index) => {
        const hue = (index / journeyData.length) * 360;
        return `
          <div style="display:flex;align-items:center;gap:8px;margin-bottom:4px;">
            <div style="width:12px;height:12px;border-radius:50%;background:hsl(${hue}, 70%, 50%);border:2px solid var(--text);"></div>
            <span>${point.timestamp}</span>
          </div>
        `;
      }).join('')}
    </div>
  `;
  
  container.innerHTML = html;
}

// ==================== VIEW SWITCHING ====================
function switchView(view) {
  currentView = view;
  
  const nodeContainer = document.getElementById("nodeViewContainer");
  const timelineContainer = document.getElementById("timelineViewContainer");
  const editContainer = document.getElementById("editViewContainer");
  const questionnaireContainer = document.getElementById("questionnaireViewContainer");
  const generatorContainer = document.getElementById("generatorViewContainer");
  const graphContainer = document.getElementById("graphViewContainer");
  const journeyContainer = document.getElementById("journeyViewContainer");
  const contentTitle = document.getElementById("contentTitle");
  
  document.querySelectorAll(".view-btn").forEach(btn => {
    btn.classList.remove("active");
  });
  const viewBtn = document.querySelector(`[data-view="${view}"]`);
  if (viewBtn) viewBtn.classList.add("active");

  // Hide all containers
  const aiEvaluatorContainer = document.getElementById("aiEvaluatorContainer");
  const universeBuildContainer = document.getElementById("universeBuildContainer");
  nodeContainer.classList.add("hidden");
  timelineContainer.classList.add("hidden");
  editContainer.classList.add("hidden");
  questionnaireContainer.classList.add("hidden");
  generatorContainer.classList.add("hidden");
  graphContainer.classList.add("hidden");
  journeyContainer.classList.add("hidden");
  aiEvaluatorContainer.classList.add("hidden");
  universeBuildContainer.classList.add("hidden");

  if (view === "node") {
    nodeContainer.classList.remove("hidden");
    contentTitle.textContent = "Node Details";
    if (activeNodeId) {
      renderNodeView(activeNodeId);
    }
  } else if (view === "timeline") {
    timelineContainer.classList.remove("hidden");
    contentTitle.textContent = "Timeline View";
    renderTimelineView();
  } else if (view === "graph") {
    graphContainer.classList.remove("hidden");
    contentTitle.textContent = "Relationship Graph";
    renderGraphView();
  } else if (view === "journey") {
    journeyContainer.classList.remove("hidden");
    contentTitle.textContent = "Character Journey";
    renderJourneyView();
  } else if (view === "edit") {
    editContainer.classList.remove("hidden");
    contentTitle.textContent = "Edit Node";
    if (activeNodeId) {
      renderEditView(activeNodeId);
    } else {
      editContainer.innerHTML = '<div class="empty-state">Select a node from the explorer to edit</div>';
    }
  } else if (view === "questionnaire") {
    questionnaireContainer.classList.remove("hidden");
    contentTitle.textContent = "Create New Node";
    renderQuestionnaireView();
  } else if (view === "generator") {
    generatorContainer.classList.remove("hidden");
    contentTitle.textContent = "Story Generator";
    renderGeneratorView();
  } else if (view === "ai-evaluator") {
    aiEvaluatorContainer.classList.remove("hidden");
    contentTitle.textContent = "AI Evaluator";
    renderAIEvaluatorView();
  } else if (view === "universe-build") {
    universeBuildContainer.classList.remove("hidden");
    contentTitle.textContent = "Universe Build Visualization";
    renderUniverseBuildView();
  }
}

// ==================== UNIVERSE BUILD VISUALIZATION ====================
let universeBuildScene = null;

function renderUniverseBuildView() {
  const container = document.getElementById("universeBuildContainer");
  
  container.innerHTML = `
    <div class="universe-build-controls">
      <button class="universe-build-btn" onclick="startUniverseBuild()">‚ñ∂ Play Build</button>
      <button class="universe-build-btn" onclick="resetUniverseBuild()">‚Ü∫ Reset</button>
      <button class="universe-build-btn" onclick="pauseUniverseBuild()">‚è∏ Pause</button>
    </div>
    <div id="universeBuildInfo" class="universe-build-info" style="display:none;">
      <div class="universe-build-info-title"></div>
      <div class="universe-build-info-type"></div>
      <div class="universe-build-info-desc"></div>
    </div>
    <canvas id="universeBuildCanvas"></canvas>
  `;
  
  initUniverseBuildScene();
}

function initUniverseBuildScene() {
  if (!window.THREE) {
    console.error('Three.js not loaded');
    return;
  }
  
  const canvas = document.getElementById('universeBuildCanvas');
  const container = document.getElementById('universeBuildContainer');
  
  // Scene setup
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0f0f10);
  scene.fog = new THREE.Fog(0x0f0f10, 500, 3000); // Much further fog
  
  // Camera
  const camera = new THREE.PerspectiveCamera(
    60,
    container.clientWidth / container.clientHeight,
    0.1,
    5000 // Extended far plane
  );
  // Initial position will be set by controls to look at first node
  camera.position.set(0, 10, 50);
  
  // Renderer
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  
  // Lighting
  const ambientLight = new THREE.AmbientLight(0xffd732, 0.3);
  scene.add(ambientLight);
  
  const directionalLight = new THREE.DirectionalLight(0xffd732, 0.8);
  directionalLight.position.set(10, 20, 10);
  scene.add(directionalLight);
  
  const pointLight = new THREE.PointLight(0x4dff9c, 0.5, 100);
  pointLight.position.set(-10, 15, -10);
  scene.add(pointLight);
  
  // Store scene data
  universeBuildScene = {
    scene,
    camera,
    renderer,
    nodes: [],
    buildSequence: [],
    currentIndex: 0,
    isPlaying: false,
    isPaused: false,
    cameraControls: {
      isDragging: false,
      isPanning: false,
      previousMousePosition: { x: 0, y: 0 },
      rotation: { x: 0.4, y: 0 },  // Start looking down at origin
      target: new THREE.Vector3(0, 0, 0), // Look at origin where first nodes spawn
      distance: 80,
      minDistance: 5,
      maxDistance: 500,
      autoRotate: false // Start without auto-rotate so user can see structure
    }
  };
  
  // Mouse controls for camera
  canvas.addEventListener('mousedown', (e) => {
    const controls = universeBuildScene.cameraControls;
    
    if (e.shiftKey) {
      controls.isPanning = true;
    } else {
      controls.isDragging = true;
    }
    
    controls.previousMousePosition = { x: e.clientX, y: e.clientY };
    controls.autoRotate = false;
  });
  
  canvas.addEventListener('mousemove', (e) => {
    const controls = universeBuildScene.cameraControls;
    
    if (!controls.isDragging && !controls.isPanning) return;
    
    const deltaX = e.clientX - controls.previousMousePosition.x;
    const deltaY = e.clientY - controls.previousMousePosition.y;
    
    if (controls.isPanning) {
      // Camera-relative panning (shift + drag)
      const panSpeed = 0.1;
      
      // Get camera's right and up vectors
      const camera = universeBuildScene.camera;
      const right = new THREE.Vector3();
      const up = new THREE.Vector3();
      
      camera.getWorldDirection(new THREE.Vector3()); // Update camera matrix
      right.setFromMatrixColumn(camera.matrix, 0); // X axis = right
      up.setFromMatrixColumn(camera.matrix, 1); // Y axis = up
      
      // Pan relative to camera orientation
      right.multiplyScalar(-deltaX * panSpeed);
      up.multiplyScalar(deltaY * panSpeed);
      
      controls.target.add(right);
      controls.target.add(up);
      
    } else if (controls.isDragging) {
      // Rotate camera (normal drag)
      controls.rotation.y += deltaX * 0.005;
      controls.rotation.x += deltaY * 0.005;
      
      // Clamp vertical rotation
      controls.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, controls.rotation.x));
    }
    
    controls.previousMousePosition = { x: e.clientX, y: e.clientY };
  });
  
  canvas.addEventListener('mouseup', () => {
    universeBuildScene.cameraControls.isDragging = false;
    universeBuildScene.cameraControls.isPanning = false;
  });
  
  canvas.addEventListener('mouseleave', () => {
    universeBuildScene.cameraControls.isDragging = false;
    universeBuildScene.cameraControls.isPanning = false;
  });
  
  // Mouse wheel for zoom
  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const controls = universeBuildScene.cameraControls;
    controls.distance += e.deltaY * 0.1;
    controls.distance = Math.max(controls.minDistance, Math.min(controls.maxDistance, controls.distance));
    controls.autoRotate = false; // Stop auto-rotate when user zooms
  });
  
  // Animation loop
  function animate() {
    requestAnimationFrame(animate);
    
    const controls = universeBuildScene.cameraControls;
    
    // Update camera position
    if (controls.autoRotate) {
      controls.rotation.y += 0.002;
    }
    
    const distance = controls.distance;
    const target = controls.target;
    
    // Calculate camera position (orbit around target at distance)
    const cameraOffset = new THREE.Vector3(
      Math.cos(controls.rotation.y) * Math.cos(controls.rotation.x) * distance,
      Math.sin(controls.rotation.x) * distance,
      Math.sin(controls.rotation.y) * Math.cos(controls.rotation.x) * distance
    );
    
    camera.position.copy(target).add(cameraOffset);
    camera.lookAt(target);
    
    // Animate existing nodes (gentle floating only)
    universeBuildScene.nodes.forEach(nodeObj => {
      if (nodeObj.mesh && !nodeObj.isBorder) {
        // Gentle floating
        const floatAmount = Math.sin(Date.now() * 0.001 + nodeObj.offset) * 0.01;
        nodeObj.mesh.position.y = nodeObj.baseY + floatAmount;
      }
    });
    
    renderer.render(scene, camera);
  }
  animate();
  
  // Handle resize
  window.addEventListener('resize', () => {
    if (universeBuildScene && container.clientWidth > 0) {
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    }
  });
  
  // Prepare build sequence
  prepareBuildSequence();
}

function prepareBuildSequence() {
  const sequence = [];
  let currentDelay = 0;
  const delayIncrement = 150;
  
  // Define series colors
  const seriesColors = {
    'series_now_presenting': 0xffd732,    // Yellow
    'series_personal_space': 0x4d9cff,    // Blue
    'series_mindiore_manors': 0xff4d9c,   // Magenta
    'series_celli': 0x9c4dff,             // Purple
    'series_odds_ends': 0x4dffff,         // Cyan (probability/luck)
    'series_quality_control': 0xff9c4d,   // Orange (crossover)
    'series_reality_shows': 0xffffff,     // White (meta/reality)
    'series_sun_settings': 0xffaa00       // Sunset orange
  };
  
  // Helper to get scale based on node type
  function getNodeScale(node) {
    if (node.type === 'series') return { width: 8, height: 0.3, depth: 6, textScale: 0.8 };
    if (node.type === 'season') return { width: 6, height: 0.25, depth: 4.5, textScale: 0.6 };
    if (node.type === 'arc') return { width: 4, height: 0.2, depth: 3, textScale: 0.4 };
    if (node.type === 'story') return { width: 3, height: 0.18, depth: 2.5, textScale: 0.3 };
    if (node.type === 'act') return { width: 2.5, height: 0.15, depth: 2, textScale: 0.25 };
    if (node.type === 'sequence') return { width: 2, height: 0.12, depth: 1.5, textScale: 0.2 };
    if (node.type === 'scene') return { width: 1.5, height: 0.1, depth: 1.2, textScale: 0.15 };
    if (node.type === 'moment') return { width: 1, height: 0.08, depth: 0.8, textScale: 0.1 };
    if (node.type === 'character') return { width: 2.5, height: 0.15, depth: 2, textScale: 0.3 };
    if (node.type === 'deity' || node.type === 'primordial') return { width: 3, height: 0.2, depth: 2.5, textScale: 0.4 };
    if (node.type === 'artifact') return { width: 2, height: 0.15, depth: 1.5, textScale: 0.25 };
    if (node.type === 'meta_concept') return { width: 1.5, height: 0.1, depth: 1.2, textScale: 0.2 };
    return { width: 2.5, height: 0.15, depth: 2, textScale: 0.3 }; // default
  }
  
  // Helper to get color based on node and series context
  function getNodeColor(node, seriesContext = null) {
    if (node.canonStatus === 'cut') return 0x444656;
    if (seriesContext && seriesColors[seriesContext]) return seriesColors[seriesContext];
    if (node.type === 'series' && seriesColors[node.id]) return seriesColors[node.id];
    if (node.type === 'character') return 0x4dff9c;
    if (node.type === 'deity' || node.type === 'primordial') return 0xff4d6a;
    if (node.type === 'artifact') return 0xffd732;
    return 0x9a9aaa;
  }
  
  // Organize ALL nodes
  const nodesByType = {
    primordials: [],
    cosmology: [],
    deities: [],
    meta: [],
    cut: [],
    characters: [],
    artifacts: [],
    locations: [],
    events: [],
    allNodes: []
  };
  
  // Collect ALL nodes
  Object.values(nodes).forEach(node => {
    nodesByType.allNodes.push(node);
    
    if (node.type === 'primordial') nodesByType.primordials.push(node);
    else if (node.type === 'cosmology_event') nodesByType.cosmology.push(node);
    else if (node.type === 'deity') nodesByType.deities.push(node);
    else if (node.type === 'meta_concept' && node.canonStatus === 'cut') nodesByType.cut.push(node);
    else if (node.type === 'meta_concept') nodesByType.meta.push(node);
    else if (node.type === 'character') nodesByType.characters.push(node);
    else if (node.type === 'artifact') nodesByType.artifacts.push(node);
    else if (node.type === 'location') nodesByType.locations.push(node);
    else if (node.type === 'event') nodesByType.events.push(node);
  });
  
  console.log(`Total nodes to build: ${nodesByType.allNodes.length}`);
  
  // Helper: Add a single node to sequence
  function addNode(node, x, y, z, angle, seriesContext = null) {
    const scale = getNodeScale(node);
    const color = getNodeColor(node, seriesContext);
    
    const yaw = angle;
    const pitch = 0.05;
    const roll = 0;
    
    sequence.push({
      id: node.id,
      delay: currentDelay,
      position: [x, y, z],
      rotation: { x: pitch, y: yaw, z: roll },
      scale: scale,
      color: color,
      isCut: node.canonStatus === 'cut',
      seriesContext: seriesContext
    });
    
    currentDelay += delayIncrement;
    return { x, y, z, angle };
  }
  
  // Helper: Add a wireframe border box
  function addBorderBox(x, y, z, width, height, depth, color, angle) {
    sequence.push({
      id: `border_${Date.now()}_${Math.random()}`,
      delay: currentDelay,
      position: [x, y, z],
      rotation: { x: 0, y: angle, z: 0 },
      isBorderBox: true,
      boxDimensions: { width, height, depth },
      color: color
    });
    currentDelay += delayIncrement * 2; // Slower for border boxes
  }
  
  // Helper: Get all descendants of a node recursively
  function getAllDescendants(nodeId, collected = []) {
    const children = Object.values(nodes).filter(n => n.parentId === nodeId);
    children.forEach(child => {
      collected.push(child);
      getAllDescendants(child.id, collected);
    });
    return collected;
  }
  
  // Helper: Build a series with border box and all children
  function buildSeriesWithBorder(seriesId, startPos, branchAngle) {
    const series = nodes[seriesId];
    if (!series) return startPos;
    
    // Get ALL descendants
    const allChildren = getAllDescendants(seriesId);
    const characters = allChildren.filter(n => n.type === 'character');
    const locations = allChildren.filter(n => n.type === 'location');
    const events = allChildren.filter(n => n.type === 'event');
    const moments = allChildren.filter(n => n.type === 'moment');
    const scenes = allChildren.filter(n => n.type === 'scene');
    const sequences = allChildren.filter(n => n.type === 'sequence');
    const stories = allChildren.filter(n => n.type === 'story' || n.type === 'act');
    const arcs = allChildren.filter(n => n.type === 'arc' || n.type === 'season');
    
    console.log(`${series.name}: ${allChildren.length} descendants`);
    
    // Calculate border box size based on content
    const boxWidth = 20;
    const boxDepth = 20;
    const boxHeight = Math.max(15, allChildren.length * 0.3);
    
    const seriesColor = getNodeColor(series, seriesId);
    
    // Add border box FIRST
    addBorderBox(startPos.x, startPos.y + boxHeight/2, startPos.z, boxWidth, boxHeight, boxDepth, seriesColor, branchAngle);
    
    // Add the series node itself (large platform at base)
    let pos = addNode(series, startPos.x, startPos.y, startPos.z, branchAngle, seriesId);
    pos.y += 1;
    
    // Build paths for different node types within the border
    const paths = [
      { nodes: arcs, radiusOffset: 0, angleOffset: 0, label: 'arcs' },
      { nodes: stories, radiusOffset: 3, angleOffset: Math.PI / 6, label: 'stories' },
      { nodes: sequences, radiusOffset: 5, angleOffset: Math.PI / 4, label: 'sequences' },
      { nodes: scenes, radiusOffset: 6, angleOffset: Math.PI / 3, label: 'scenes' },
      { nodes: moments, radiusOffset: 7, angleOffset: Math.PI / 2, label: 'moments' },
      { nodes: characters, radiusOffset: 8, angleOffset: -Math.PI / 6, label: 'characters' },
      { nodes: locations, radiusOffset: 8, angleOffset: -Math.PI / 3, label: 'locations' },
      { nodes: events, radiusOffset: 8, angleOffset: -Math.PI / 4, label: 'events' }
    ];
    
    paths.forEach(path => {
      if (path.nodes.length === 0) return;
      
      path.nodes.forEach((node, idx) => {
        const t = idx / Math.max(path.nodes.length - 1, 1);
        const spiralAngle = branchAngle + path.angleOffset + t * Math.PI * 2;
        const radius = path.radiusOffset + Math.sin(t * Math.PI * 4) * 2;
        const nodeX = startPos.x + Math.cos(spiralAngle) * radius;
        const nodeZ = startPos.z + Math.sin(spiralAngle) * radius;
        const nodeY = pos.y + (idx * 0.2);
        
        addNode(node, nodeX, nodeY, nodeZ, spiralAngle, seriesId);
      });
      
      pos.y += path.nodes.length * 0.2 + 1;
    });
    
    return { x: startPos.x, y: pos.y + 3, z: startPos.z, angle: branchAngle };
  }
  
  // Build main spine: Foundation ‚Üí Series with Border Boxes
  let spineY = 0;
  let spineAngle = 0;
  const spineRadius = 25;
  
  // 1. Foundation: Primordials
  nodesByType.primordials.forEach((node, idx) => {
    const x = Math.cos(spineAngle) * (spineRadius - 10);
    const z = Math.sin(spineAngle) * (spineRadius - 10);
    addNode(node, x, spineY, z, spineAngle);
    spineY += 0.5;
    spineAngle += Math.PI / 6;
  });
  
  // 2. Cosmology events
  nodesByType.cosmology.forEach((node, idx) => {
    const x = Math.cos(spineAngle) * (spineRadius - 8);
    const z = Math.sin(spineAngle) * (spineRadius - 8);
    addNode(node, x, spineY, z, spineAngle);
    spineY += 0.4;
    spineAngle += Math.PI / 8;
  });
  
  // 3. Deities
  nodesByType.deities.forEach((node, idx) => {
    const x = Math.cos(spineAngle) * (spineRadius - 5);
    const z = Math.sin(spineAngle) * (spineRadius - 5);
    addNode(node, x, spineY, z, spineAngle);
    spineY += 0.5;
    spineAngle += Math.PI / 8;
  });
  
  // 4. Artifacts (orbiting)
  nodesByType.artifacts.forEach((node, idx) => {
    const branchAngle = spineAngle + (idx / nodesByType.artifacts.length) * Math.PI * 2;
    const x = Math.cos(branchAngle) * (spineRadius - 12);
    const z = Math.sin(branchAngle) * (spineRadius - 12);
    addNode(node, x, spineY, z, branchAngle);
  });
  spineY += 2;
  
  // 5. CORE SERIES with BORDER BOXES (the main event!)
  const coreSeriesOrder = [
    'series_now_presenting',
    'series_personal_space',
    'series_mindiore_manors',
    'series_odds_ends',
    'series_celli',
    'series_quality_control',
    'series_reality_shows',
    'series_sun_settings'
  ];
  
  coreSeriesOrder.forEach((seriesId, idx) => {
    const x = Math.cos(spineAngle) * spineRadius;
    const z = Math.sin(spineAngle) * spineRadius;
    const result = buildSeriesWithBorder(seriesId, { x, y: spineY, z, angle: spineAngle }, spineAngle);
    spineY = result.y + 5; // Large gap between series
    spineAngle += Math.PI / 2; // 90 degree rotation per series
  });
  
  // 6. Standalone characters not in series
  const standaloneChars = nodesByType.characters.filter(c => {
    // Check if character belongs to any series
    let current = c;
    while (current.parentId) {
      current = nodes[current.parentId];
      if (current && current.type === 'series') return false;
    }
    return true;
  });
  
  standaloneChars.forEach((node, idx) => {
    const branchAngle = spineAngle + (idx / standaloneChars.length) * Math.PI * 2;
    const x = Math.cos(branchAngle) * (spineRadius + 5);
    const z = Math.sin(branchAngle) * (spineRadius + 5);
    addNode(node, x, spineY, z, branchAngle);
  });
  spineY += 2;
  
  // 7. Meta concepts
  nodesByType.meta.forEach((node, idx) => {
    const x = Math.cos(spineAngle) * (spineRadius - 3);
    const z = Math.sin(spineAngle) * (spineRadius - 3);
    addNode(node, x, spineY, z, spineAngle);
    spineY += 0.3;
    spineAngle += Math.PI / 10;
  });
  
  // 8. Cut ideas (fade out, scattered)
  nodesByType.cut.forEach((node, idx) => {
    const branchAngle = spineAngle + Math.random() * Math.PI * 2;
    const x = Math.cos(branchAngle) * (spineRadius + 10 + Math.random() * 5);
    const z = Math.sin(branchAngle) * (spineRadius + 10 + Math.random() * 5);
    addNode(node, x, spineY + Math.random() * 5, z, branchAngle);
  });
  
  universeBuildScene.buildSequence = sequence;
  console.log(`Build sequence prepared: ${sequence.length} nodes`);
}

window.startUniverseBuild = function() {
  if (!universeBuildScene) return;
  
  universeBuildScene.isPlaying = true;
  universeBuildScene.isPaused = false;
  universeBuildScene.currentIndex = 0;
  
  // Clear existing nodes
  universeBuildScene.nodes.forEach(nodeObj => {
    if (nodeObj.mesh) {
      universeBuildScene.scene.remove(nodeObj.mesh);
    }
  });
  universeBuildScene.nodes = [];
  
  // Start building
  buildNextNode();
};

window.pauseUniverseBuild = function() {
  if (!universeBuildScene) return;
  universeBuildScene.isPaused = !universeBuildScene.isPaused;
};

window.resetUniverseBuild = function() {
  if (!universeBuildScene) return;
  
  universeBuildScene.isPlaying = false;
  universeBuildScene.isPaused = false;
  universeBuildScene.currentIndex = 0;
  
  // Clear all nodes
  universeBuildScene.nodes.forEach(nodeObj => {
    if (nodeObj.mesh) {
      universeBuildScene.scene.remove(nodeObj.mesh);
    }
  });
  universeBuildScene.nodes = [];
  
  // Hide info
  document.getElementById('universeBuildInfo').style.display = 'none';
};

function buildNextNode() {
  if (!universeBuildScene || !universeBuildScene.isPlaying) return;
  
  const { buildSequence, currentIndex } = universeBuildScene;
  
  if (currentIndex >= buildSequence.length) {
    universeBuildScene.isPlaying = false;
    console.log('Build complete!');
    return;
  }
  
  // Check if paused
  if (universeBuildScene.isPaused) {
    setTimeout(() => buildNextNode(), 100);
    return;
  }
  
  const item = buildSequence[currentIndex];
  
  // Handle border boxes differently
  if (item.isBorderBox) {
    createBorderBoxMesh(item.position, item.boxDimensions, item.color, item.rotation);
  } else {
    const node = nodes[item.id];
    
    if (node) {
      createNodeMesh(node, item.position, item.isCut, item.rotation, item.scale, item.color);
      showNodeInfo(node, item.isCut);
      
      // If it's a cut idea, fade it out after a moment
      if (item.isCut) {
        setTimeout(() => {
          const nodeObj = universeBuildScene.nodes.find(n => n.id === item.id);
          if (nodeObj && nodeObj.mesh) {
            fadeOutNode(nodeObj.mesh);
          }
        }, 2000);
      }
    }
  }
  
  universeBuildScene.currentIndex++;
  
  // Schedule next node
  const nextItem = buildSequence[currentIndex + 1];
  if (nextItem) {
    const delay = nextItem.delay - item.delay;
    setTimeout(() => buildNextNode(), delay);
  } else {
    console.log(`Built ${currentIndex + 1} nodes`);
  }
}

function createNodeMesh(node, position, isCut = false, rotation = null, scale = null, color = null) {
  const [x, y, z] = position;
  
  // Use provided scale or default
  const nodeScale = scale || { width: 2.5, height: 0.15, depth: 2, textScale: 0.3 };
  
  // Create thin tile slab with custom scale
  const geometry = new THREE.BoxGeometry(nodeScale.width, nodeScale.height, nodeScale.depth);
  
  // Use provided color or default
  const nodeColor = color !== null ? color : 0xffd732;
  
  const material = new THREE.MeshPhongMaterial({
    color: nodeColor,
    emissive: nodeColor,
    emissiveIntensity: 0.3,
    shininess: 100,
    transparent: true,
    opacity: isCut ? 0.5 : 0.9
  });
  
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.set(x, y, z);
  
  // Store target rotation
  const targetRotation = rotation || { x: 0, y: 0, z: 0 };
  
  // Start vertical (standing up)
  mesh.rotation.set(Math.PI / 2, targetRotation.y, targetRotation.z);
  
  // Add text label
  addTextLabel(mesh, node.name || node.id, nodeScale.textScale, nodeColor);
  
  // Animate in with domino fall
  mesh.scale.set(0, 0, 0);
  animateNodeInWithFall(mesh, targetRotation);
  
  universeBuildScene.scene.add(mesh);
  
  // Add connection lines to related nodes
  addConnectionLines(node, mesh);
  
  universeBuildScene.nodes.push({
    id: node.id,
    node,
    mesh,
    offset: Math.random() * Math.PI * 2,
    baseRotation: targetRotation,
    baseY: y,
    targetRotation: targetRotation
  });
}

function addTextLabel(parentMesh, text, scale, color) {
  // Create canvas for text
  const canvas = document.createElement('canvas');
  const context = canvas.getContext('2d');
  canvas.width = 512;
  canvas.height = 128;
  
  // Draw text
  context.fillStyle = '#000000';
  context.fillRect(0, 0, canvas.width, canvas.height);
  context.font = 'bold 48px Arial';
  context.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
  context.textAlign = 'center';
  context.textBaseline = 'middle';
  
  // Wrap text if too long
  const maxWidth = canvas.width - 40;
  const words = text.split(' ');
  let line = '';
  let lines = [];
  
  words.forEach(word => {
    const testLine = line + word + ' ';
    const metrics = context.measureText(testLine);
    if (metrics.width > maxWidth && line !== '') {
      lines.push(line);
      line = word + ' ';
    } else {
      line = testLine;
    }
  });
  lines.push(line);
  
  // Draw wrapped text
  const lineHeight = 50;
  const startY = (canvas.height - (lines.length * lineHeight)) / 2 + lineHeight / 2;
  lines.forEach((line, i) => {
    context.fillText(line.trim(), canvas.width / 2, startY + i * lineHeight);
  });
  
  // Create texture from canvas
  const texture = new THREE.CanvasTexture(canvas);
  const textMaterial = new THREE.MeshBasicMaterial({
    map: texture,
    transparent: true,
    opacity: 0.95
  });
  
  // Create plane for text
  const textGeometry = new THREE.PlaneGeometry(scale * 5, scale * 1.25);
  const textMesh = new THREE.Mesh(textGeometry, textMaterial);
  
  // Position text above the slab
  textMesh.position.y = 0.4;
  textMesh.rotation.x = -Math.PI / 2; // Face up
  
  parentMesh.add(textMesh);
}

function animateNodeIn(mesh) {
  const startTime = Date.now();
  const duration = 800;
  
  function animate() {
    const elapsed = Date.now() - startTime;
    const progress = Math.min(elapsed / duration, 1);
    const eased = 1 - Math.pow(1 - progress, 3); // ease out cubic
    
    mesh.scale.set(eased, eased, eased);
    
    if (progress < 1) {
      requestAnimationFrame(animate);
    }
  }
  animate();
}

function animateNodeInWithFall(mesh, targetRotation) {
  const startTime = Date.now();
  const totalDuration = 1200;
  const scalePhase = 0.3; // 30% of time for scaling
  const fallPhase = 0.7; // 70% of time for falling
  
  const startRotation = { x: Math.PI / 2, y: targetRotation.y, z: targetRotation.z };
  
  function animate() {
    const elapsed = Date.now() - startTime;
    const progress = Math.min(elapsed / totalDuration, 1);
    
    if (progress < scalePhase) {
      // Phase 1: Scale up while vertical
      const scaleProgress = progress / scalePhase;
      const eased = 1 - Math.pow(1 - scaleProgress, 3);
      mesh.scale.set(eased, eased, eased);
    } else {
      // Phase 2: Fall forward like a domino
      mesh.scale.set(1, 1, 1);
      
      const fallProgress = (progress - scalePhase) / fallPhase;
      const eased = 1 - Math.pow(1 - fallProgress, 2); // ease out quad for fall
      
      // Interpolate rotation from vertical to target
      mesh.rotation.x = startRotation.x + (targetRotation.x - startRotation.x) * eased;
      mesh.rotation.y = startRotation.y + (targetRotation.y - startRotation.y) * eased;
      mesh.rotation.z = startRotation.z + (targetRotation.z - startRotation.z) * eased;
    }
    
    if (progress < 1) {
      requestAnimationFrame(animate);
    }
  }
  animate();
}

function fadeOutNode(mesh) {
  const startTime = Date.now();
  const duration = 1500;
  
  function animate() {
    const elapsed = Date.now() - startTime;
    const progress = Math.min(elapsed / duration, 1);
    
    mesh.material.opacity = 0.5 * (1 - progress);
    
    if (progress < 1) {
      requestAnimationFrame(animate);
    } else {
      universeBuildScene.scene.remove(mesh);
    }
  }
  animate();
}

function createBorderBoxMesh(position, dimensions, color, rotation) {
  const [x, y, z] = position;
  const { width, height, depth } = dimensions;
  
  // Create wireframe box geometry
  const geometry = new THREE.BoxGeometry(width, height, depth);
  const edges = new THREE.EdgesGeometry(geometry);
  
  const material = new THREE.LineBasicMaterial({
    color: color,
    linewidth: 2,
    transparent: true,
    opacity: 0.6
  });
  
  const wireframe = new THREE.LineSegments(edges, material);
  wireframe.position.set(x, y, z);
  
  if (rotation) {
    wireframe.rotation.set(rotation.x, rotation.y, rotation.z);
  }
  
  // Animate in
  wireframe.scale.set(0, 0, 0);
  animateBorderBoxIn(wireframe);
  
  universeBuildScene.scene.add(wireframe);
  
  universeBuildScene.nodes.push({
    id: `border_${Date.now()}`,
    mesh: wireframe,
    offset: 0,
    baseY: y,
    isBorder: true
  });
}

function animateBorderBoxIn(mesh) {
  const startTime = Date.now();
  const duration = 1200;
  
  function animate() {
    const elapsed = Date.now() - startTime;
    const progress = Math.min(elapsed / duration, 1);
    const eased = 1 - Math.pow(1 - progress, 3);
    
    mesh.scale.set(eased, eased, eased);
    
    if (progress < 1) {
      requestAnimationFrame(animate);
    }
  }
  animate();
}

function addConnectionLines(node, mesh) {
  // Add subtle connection lines to parent or related nodes
  const relatedIds = [];
  
  if (node.parentId) relatedIds.push(node.parentId);
  if (node.metadata?.mother) relatedIds.push(node.metadata.mother);
  if (node.metadata?.partner) relatedIds.push(node.metadata.partner);
  
  relatedIds.forEach(relatedId => {
    const relatedNodeObj = universeBuildScene.nodes.find(n => n.id === relatedId);
    if (relatedNodeObj && relatedNodeObj.mesh) {
      const points = [
        mesh.position,
        relatedNodeObj.mesh.position
      ];
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineBasicMaterial({
        color: 0x444656,
        transparent: true,
        opacity: 0.3
      });
      const line = new THREE.Line(geometry, material);
      universeBuildScene.scene.add(line);
    }
  });
}

function showNodeInfo(node, isCut) {
  const infoEl = document.getElementById('universeBuildInfo');
  const titleEl = infoEl.querySelector('.universe-build-info-title');
  const typeEl = infoEl.querySelector('.universe-build-info-type');
  const descEl = infoEl.querySelector('.universe-build-info-desc');
  
  titleEl.textContent = node.name;
  typeEl.textContent = isCut ? `${node.type} (CUT)` : node.type;
  descEl.textContent = node.description || node.bio || '';
  
  infoEl.style.display = 'block';
}

// ==================== AI EVALUATOR VIEW ====================
function renderAIEvaluatorView() {
  const container = document.getElementById("aiEvaluatorContainer");
  
  let html = '<div style="padding:16px;">';
  
  // API Configuration Panel
  html += `<div class="ai-config-panel">`;
  html += `<h3 style="margin:0 0 12px 0;font-size:.8rem;color:var(--accent);">‚öôÔ∏è AI Provider Configuration</h3>`;
  const config = getAIConfig();
  
  // Provider selector
  html += `<div style="margin-bottom:16px;">`;
  html += `<label style="display:block;font-size:.65rem;color:var(--sub);margin-bottom:6px;font-weight:600;">Active Provider</label>`;
  html += `<select id="aiProviderSelect" class="ai-api-input" style="margin-bottom:0;" onchange="changeAIProvider()">`;
  for (const [key, provider] of Object.entries(AI_PROVIDERS)) {
    const selected = config.activeProvider === key ? 'selected' : '';
    const hasKey = config.keys[key] ? '‚úì' : '';
    html += `<option value="${key}" ${selected}>${hasKey} ${provider.name}</option>`;
  }
  html += `</select>`;
  html += `</div>`;
  
  // API Key input for active provider
  const activeProvider = AI_PROVIDERS[config.activeProvider];
  const activeKey = config.keys[config.activeProvider] || '';
  const keyStatus = activeKey ? '‚úì Configured' : '‚ö† Not configured';
  const keyStatusColor = activeKey ? 'var(--ok)' : 'var(--danger)';
  
  html += `<div style="margin-bottom:16px;">`;
  html += `<label style="display:block;font-size:.65rem;color:var(--sub);margin-bottom:6px;font-weight:600;">`;
  html += `API Key for ${activeProvider.name} <span style="color:${keyStatusColor};margin-left:8px;">${keyStatus}</span>`;
  html += `</label>`;
  html += `<input type="password" class="ai-api-input" id="aiApiKey" placeholder="${activeProvider.placeholder}" value="${activeKey}" style="margin-bottom:8px;" />`;
  html += `<div style="display:flex;gap:8px;">`;
  html += `<button class="ai-btn" onclick="saveCurrentAIKey()">Save Key</button>`;
  html += `<button class="ai-btn danger" onclick="clearCurrentAIKey()">Clear Key</button>`;
  html += `<button class="ai-btn danger" onclick="clearAllAIKeysConfirm()" style="margin-left:auto;">Clear All Keys</button>`;
  html += `</div>`;
  html += `</div>`;
  
  // Show all configured providers
  html += `<div style="background:var(--panel);padding:12px;border-radius:4px;border:1px solid var(--muted);">`;
  html += `<div style="font-size:.65rem;color:var(--sub);margin-bottom:8px;font-weight:600;">Configured Providers</div>`;
  html += `<div style="display:flex;flex-wrap:wrap;gap:6px;">`;
  for (const [key, provider] of Object.entries(AI_PROVIDERS)) {
    const hasKey = config.keys[key];
    const bgColor = hasKey ? 'rgba(77, 255, 156, 0.1)' : 'rgba(255, 77, 106, 0.1)';
    const borderColor = hasKey ? 'var(--ok)' : 'var(--danger)';
    const textColor = hasKey ? 'var(--ok)' : 'var(--danger)';
    const icon = hasKey ? '‚úì' : '‚úó';
    html += `<div style="background:${bgColor};border:1px solid ${borderColor};padding:4px 8px;border-radius:4px;font-size:.6rem;color:${textColor};">`;
    html += `${icon} ${provider.name}`;
    html += `</div>`;
  }
  html += `</div>`;
  html += `</div>`;
  
  html += `<div style="font-size:.6rem;color:var(--sub);margin-top:8px;">All API keys are stored locally in your browser and never sent to our servers</div>`;
  html += `</div>`;
  
  // Theme Bank
  html += `<div class="ai-config-panel">`;
  html += `<h3 style="margin:0 0 12px 0;font-size:.8rem;color:var(--accent);">üé® Theme Bank</h3>`;
  html += `<div style="display:flex;flex-wrap:wrap;gap:8px;margin-bottom:12px;">`;
  themeBank.forEach(theme => {
    const scoreColor = theme.successScore >= 9 ? 'var(--ok)' : theme.successScore >= 8 ? 'var(--accent)' : 'var(--sub)';
    html += `<div style="background:var(--panel);border:1px solid var(--muted);padding:8px 12px;border-radius:8px;flex:1;min-width:200px;">`;
    html += `<div style="font-size:.7rem;font-weight:600;color:var(--text);margin-bottom:4px;">${theme.name}</div>`;
    html += `<div style="font-size:.65rem;color:var(--sub);">`;
    html += `Score: <span style="color:${scoreColor};font-weight:600;">${theme.successScore}/10</span> ‚Ä¢ `;
    html += `Used: ${theme.usageCount}x`;
    html += `</div>`;
    html += `</div>`;
  });
  html += `</div>`;
  html += `</div>`;
  
  // Generation Controls
  html += `<div class="ai-config-panel">`;
  html += `<h3 style="margin:0 0 12px 0;font-size:.8rem;color:var(--accent);">üé≤ Generate Content</h3>`;
  html += `<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:8px;">`;
  html += `<button class="ai-btn" onclick="generateProposal('moment')">Generate Moment</button>`;
  html += `<button class="ai-btn" onclick="generateProposal('joke')">Generate Joke</button>`;
  html += `<button class="ai-btn" onclick="generateProposal('arc')">Generate Arc</button>`;
  html += `<button class="ai-btn" onclick="generateProposal('interaction')">Generate Interaction</button>`;
  html += `<button class="ai-btn" onclick="generateStandoff()">Organic Standoff</button>`;
  html += `</div>`;
  html += `</div>`;
  
  // Proposals Section
  html += `<div class="ai-config-panel">`;
  html += `<h3 style="margin:0 0 12px 0;font-size:.8rem;color:var(--accent);">üìã AI Proposals (${aiProposals.length})</h3>`;
  
  if (aiProposals.length === 0) {
    html += `<div style="text-align:center;padding:32px;color:var(--sub);font-size:.7rem;">`;
    html += `No proposals yet. Generate some content above!`;
    html += `</div>`;
  } else {
    // Show proposals
    aiProposals.forEach(proposal => {
      html += renderProposalCard(proposal);
    });
  }
  
  html += `</div>`;
  
  // Human Reinforcement Quiz Section
  html += `<div class="ai-config-panel">`;
  html += `<h3 style="margin:0 0 12px 0;font-size:.8rem;color:var(--accent);">üéØ Human Reinforcement Quiz</h3>`;
  html += `<div style="font-size:.65rem;color:var(--sub);margin-bottom:12px;">`;
  html += `Semi-confident proposals from simulated evaluations are structured into quizzes for human feedback.`;
  html += `</div>`;
  
  // Get proposals with scores between 7.0 and 8.5 (semi-confident)
  const quizProposals = aiProposals.filter(p => p.overallScore >= 7.0 && p.overallScore <= 8.5 && p.status === 'pending');
  
  if (quizProposals.length === 0) {
    html += `<div style="text-align:center;padding:24px;color:var(--sub);font-size:.65rem;">`;
    html += `No semi-confident proposals available for quiz. Generate more content!`;
    html += `</div>`;
  } else {
    html += `<div style="background:var(--panel);padding:16px;border-radius:8px;border:2px solid var(--accent);">`;
    html += `<div style="font-size:.7rem;font-weight:600;color:var(--accent);margin-bottom:12px;">`;
    html += `${quizProposals.length} Proposal${quizProposals.length > 1 ? 's' : ''} Need Human Evaluation`;
    html += `</div>`;
    html += `<button class="ai-btn" onclick="startReinforcementQuiz()">Start Quiz</button>`;
    html += `</div>`;
  }
  
  html += `</div>`;
  
  html += '</div>';
  container.innerHTML = html;
}

function renderProposalCard(proposal) {
  const scoreColor = proposal.overallScore >= 8.5 ? 'var(--ok)' : proposal.overallScore >= 7.0 ? 'var(--accent)' : 'var(--danger)';
  const statusBadge = {
    pending: '‚è≥ Pending',
    approved: '‚úÖ Approved',
    rejected: '‚ùå Rejected',
    refined: 'üîÑ Refined'
  }[proposal.status];
  
  let html = `<div class="ai-proposal-card" style="border-left:4px solid ${scoreColor};">`;
  
  // Header
  html += `<div style="display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:12px;">`;
  html += `<div>`;
  html += `<div style="font-size:.75rem;font-weight:600;color:var(--text);margin-bottom:4px;">${proposal.title}</div>`;
  html += `<div style="font-size:.6rem;color:var(--sub);text-transform:uppercase;">${proposal.type} ‚Ä¢ ${statusBadge}</div>`;
  html += `</div>`;
  html += `<div style="text-align:right;">`;
  html += `<div class="ai-proposal-score" style="color:${scoreColor};">${proposal.overallScore}</div>`;
  html += `<div style="font-size:.55rem;color:var(--sub);">Overall</div>`;
  html += `</div>`;
  html += `</div>`;
  
  // Content
  html += `<div style="font-size:.7rem;line-height:1.6;color:var(--text);margin-bottom:12px;padding:12px;background:var(--panel);border-radius:4px;">`;
  html += proposal.content;
  html += `</div>`;
  
  // Metrics
  html += `<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(100px,1fr));gap:6px;margin-bottom:12px;">`;
  for (const [key, value] of Object.entries(proposal.metrics)) {
    const metricColor = value >= 8.5 ? 'var(--ok)' : value >= 7.0 ? 'var(--accent)' : 'var(--sub)';
    html += `<div style="background:var(--panel);padding:6px;border-radius:4px;text-align:center;">`;
    html += `<div style="font-size:.55rem;color:var(--sub);margin-bottom:2px;">${key.replace('_', ' ')}</div>`;
    html += `<div style="font-size:.7rem;font-weight:600;color:${metricColor};">${value.toFixed(1)}</div>`;
    html += `</div>`;
  }
  html += `</div>`;
  
  // Actions (only for pending proposals)
  if (proposal.status === 'pending') {
    html += `<div style="display:flex;gap:8px;">`;
    html += `<button class="ai-btn" style="flex:1;background:rgba(77,255,156,0.1);border-color:var(--ok);color:var(--ok);" onclick="approveProposal('${proposal.id}')">‚úì Approve</button>`;
    html += `<button class="ai-btn" style="flex:1;background:rgba(255,215,50,0.1);border-color:var(--accent);color:var(--accent);" onclick="refineProposal('${proposal.id}')">üîÑ Refine</button>`;
    html += `<button class="ai-btn danger" style="flex:1;" onclick="rejectProposal('${proposal.id}')">‚úó Reject</button>`;
    html += `</div>`;
  }
  
  html += `</div>`;
  return html;
}

// Global functions for AI Evaluator
window.changeAIProvider = function() {
  const provider = document.getElementById('aiProviderSelect').value;
  setAIProvider(provider);
  renderAIEvaluatorView();
};

window.saveCurrentAIKey = function() {
  const config = getAIConfig();
  const apiKey = document.getElementById('aiApiKey').value;
  setAIKey(config.activeProvider, apiKey);
  alert(`‚úì API Key saved for ${AI_PROVIDERS[config.activeProvider].name}!`);
  renderAIEvaluatorView();
};

window.clearCurrentAIKey = function() {
  const config = getAIConfig();
  if (confirm(`Clear API key for ${AI_PROVIDERS[config.activeProvider].name}?`)) {
    clearAIKey(config.activeProvider);
    renderAIEvaluatorView();
  }
};

window.clearAllAIKeysConfirm = function() {
  if (confirm('‚ö†Ô∏è Clear ALL API keys for all providers? This cannot be undone.')) {
    clearAllAIKeys();
    alert('‚úì All API keys cleared!');
    renderAIEvaluatorView();
  }
};

window.generateProposal = async function(type) {
  const container = document.getElementById("aiEvaluatorContainer");
  container.innerHTML = '<div class="ai-loading"><div class="ai-loading-spinner"></div>Generating proposal...</div>';
  
  const proposal = await generateAIProposal(type);
  if (proposal) {
    aiProposals.push(proposal);
    
    // Add to nodes as ai_proposal type
    nodes[proposal.id] = {
      ...proposal,
      folder: "ai_proposals",
      name: proposal.title,
      description: proposal.content
    };
    
    renderTree();
  }
  
  renderAIEvaluatorView();
};

window.generateStandoff = async function() {
  // For demo, use Ziya and Penelope
  const container = document.getElementById("aiEvaluatorContainer");
  container.innerHTML = '<div class="ai-loading"><div class="ai-loading-spinner"></div>Generating organic standoff...</div>';
  
  const standoff = await generateOrganicStandoff('char_ziya', 'char_penelope', 'An unexpected encounter in the Timescape');
  if (standoff) {
    aiProposals.push(standoff);
    nodes[standoff.id] = {
      ...standoff,
      folder: "ai_proposals",
      type: "ai_proposal",
      name: `Standoff: ${standoff.character1.name} vs ${standoff.character2.name}`,
      description: standoff.context
    };
    renderTree();
  }
  
  renderAIEvaluatorView();
};

window.approveProposal = function(proposalId) {
  const proposal = aiProposals.find(p => p.id === proposalId);
  if (proposal) {
    proposal.status = 'approved';
    // Move to canon
    const node = nodes[proposalId];
    if (node) {
      node.canonStatus = 'canon';
      node.folder = 'moments'; // or appropriate folder based on type
    }
    renderTree();
    renderAIEvaluatorView();
    alert('‚úì Proposal approved and moved to canon!');
  }
};

window.refineProposal = function(proposalId) {
  const proposal = aiProposals.find(p => p.id === proposalId);
  if (proposal) {
    proposal.status = 'refined';
    alert('üîÑ Proposal marked for refinement. AI will generate an improved version.');
    // In production, this would trigger AI to refine the proposal
    renderAIEvaluatorView();
  }
};

window.rejectProposal = function(proposalId) {
  const proposal = aiProposals.find(p => p.id === proposalId);
  if (proposal) {
    proposal.status = 'rejected';
    // Move to cut content
    const node = nodes[proposalId];
    if (node) {
      node.canonStatus = 'cut';
      node.statusPrior = 'Attempted';
    }
    renderTree();
    renderAIEvaluatorView();
    alert('‚úó Proposal rejected and moved to cut content.');
  }
};

window.startReinforcementQuiz = function() {
  const quizProposals = aiProposals.filter(p => p.overallScore >= 7.0 && p.overallScore <= 8.5 && p.status === 'pending');
  
  if (quizProposals.length === 0) {
    alert('No proposals available for quiz!');
    return;
  }
  
  // Show quiz modal
  showReinforcementQuizModal(quizProposals);
};

function showReinforcementQuizModal(proposals) {
  let currentIndex = 0;
  const responses = [];
  
  const modal = document.createElement('div');
  modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.8);display:flex;align-items:center;justify-content:center;z-index:10000;';
  
  function renderQuizQuestion() {
    const proposal = proposals[currentIndex];
    
    modal.innerHTML = `
      <div style="background:var(--panel);border:2px solid var(--accent);border-radius:12px;padding:24px;max-width:700px;width:90%;max-height:80vh;overflow:auto;">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;">
          <h3 style="margin:0;color:var(--accent);font-size:.9rem;">Human Reinforcement Quiz</h3>
          <div style="font-size:.65rem;color:var(--sub);">Question ${currentIndex + 1} of ${proposals.length}</div>
        </div>
        
        <div style="background:var(--panel-alt);padding:16px;border-radius:8px;margin-bottom:16px;">
          <div style="font-size:.7rem;font-weight:600;color:var(--text);margin-bottom:8px;">${proposal.title}</div>
          <div style="font-size:.65rem;color:var(--sub);margin-bottom:12px;">Type: ${proposal.type} ‚Ä¢ AI Score: ${proposal.overallScore}/10</div>
          <div style="font-size:.7rem;line-height:1.6;color:var(--text);padding:12px;background:var(--panel);border-radius:4px;">
            ${proposal.content}
          </div>
        </div>
        
        <div style="margin-bottom:16px;">
          <div style="font-size:.7rem;font-weight:600;color:var(--text);margin-bottom:12px;">How would you rate this proposal?</div>
          <div style="display:grid;grid-template-columns:repeat(5,1fr);gap:8px;">
            ${[1,2,3,4,5,6,7,8,9,10].map(score => `
              <button class="quiz-score-btn" data-score="${score}" style="padding:12px;background:var(--panel);border:2px solid var(--muted);border-radius:8px;font-size:.8rem;font-weight:600;color:var(--text);cursor:pointer;transition:all .15s;">
                ${score}
              </button>
            `).join('')}
          </div>
        </div>
        
        <div style="margin-bottom:16px;">
          <div style="font-size:.7rem;font-weight:600;color:var(--text);margin-bottom:8px;">Feedback (optional):</div>
          <textarea id="quizFeedback" style="width:100%;background:var(--panel);border:1px solid var(--muted);color:var(--text);padding:8px;border-radius:4px;font-size:.65rem;min-height:80px;font-family:var(--sans);"></textarea>
        </div>
        
        <div style="display:flex;gap:8px;justify-content:flex-end;">
          <button onclick="closeQuizModal()" style="padding:8px 16px;background:var(--panel);border:1px solid var(--muted);color:var(--text);border-radius:4px;font-size:.65rem;cursor:pointer;">Cancel</button>
          <button id="quizNextBtn" disabled style="padding:8px 16px;background:var(--accent-dim);border:1px solid var(--accent);color:var(--accent);border-radius:4px;font-size:.65rem;font-weight:600;cursor:pointer;" onclick="submitQuizAnswer()">Next ‚Üí</button>
        </div>
      </div>
    `;
    
    // Add score button listeners
    modal.querySelectorAll('.quiz-score-btn').forEach(btn => {
      btn.addEventListener('click', function() {
        modal.querySelectorAll('.quiz-score-btn').forEach(b => {
          b.style.borderColor = 'var(--muted)';
          b.style.background = 'var(--panel)';
        });
        this.style.borderColor = 'var(--accent)';
        this.style.background = 'var(--accent-dim)';
        modal.querySelector('#quizNextBtn').disabled = false;
        modal.querySelector('#quizNextBtn').dataset.score = this.dataset.score;
      });
    });
  }
  
  window.submitQuizAnswer = function() {
    const score = parseInt(modal.querySelector('#quizNextBtn').dataset.score);
    const feedback = modal.querySelector('#quizFeedback').value;
    
    responses.push({
      proposalId: proposals[currentIndex].id,
      humanScore: score,
      aiScore: proposals[currentIndex].overallScore,
      feedback: feedback,
      timestamp: new Date().toISOString()
    });
    
    currentIndex++;
    
    if (currentIndex >= proposals.length) {
      // Quiz complete
      finishQuiz(responses);
    } else {
      renderQuizQuestion();
    }
  };
  
  window.closeQuizModal = function() {
    document.body.removeChild(modal);
    delete window.submitQuizAnswer;
    delete window.closeQuizModal;
  };
  
  function finishQuiz(responses) {
    // Calculate accuracy
    let totalDiff = 0;
    responses.forEach(r => {
      totalDiff += Math.abs(r.humanScore - r.aiScore);
    });
    const avgDiff = totalDiff / responses.length;
    const accuracy = Math.max(0, 100 - (avgDiff * 10));
    
    modal.innerHTML = `
      <div style="background:var(--panel);border:2px solid var(--ok);border-radius:12px;padding:24px;max-width:600px;width:90%;">
        <h3 style="margin:0 0 16px 0;color:var(--ok);font-size:.9rem;text-align:center;">‚úì Quiz Complete!</h3>
        
        <div style="text-align:center;margin-bottom:24px;">
          <div style="font-size:2rem;font-weight:700;color:var(--ok);margin-bottom:8px;">${accuracy.toFixed(1)}%</div>
          <div style="font-size:.65rem;color:var(--sub);">AI-Human Agreement</div>
        </div>
        
        <div style="background:var(--panel-alt);padding:16px;border-radius:8px;margin-bottom:16px;">
          <div style="font-size:.7rem;color:var(--text);margin-bottom:12px;">Your feedback helps train the AI evaluator to better match human judgment!</div>
          <div style="font-size:.65rem;color:var(--sub);">
            ‚Ä¢ Evaluated ${responses.length} proposals<br/>
            ‚Ä¢ Average score difference: ${avgDiff.toFixed(1)} points<br/>
            ‚Ä¢ Feedback provided: ${responses.filter(r => r.feedback).length} responses
          </div>
        </div>
        
        <button onclick="closeQuizModal(); renderAIEvaluatorView();" style="width:100%;padding:12px;background:var(--ok);border:none;color:var(--bg);border-radius:4px;font-size:.7rem;font-weight:600;cursor:pointer;">Done</button>
      </div>
    `;
    
    // Store responses for training (in production, send to backend)
    console.log('Quiz responses:', responses);
  }
  
  document.body.appendChild(modal);
  renderQuizQuestion();
}

// ==================== INITIALIZATION ====================
function init() {
  renderTree();
  
  // Setup view toggle buttons
  document.querySelectorAll(".view-btn").forEach(btn => {
    btn.addEventListener("click", (e) => {
      const view = e.target.dataset.view;
      switchView(view);
    });
  });
}

// Make selectNode available globally for onclick handlers
window.selectNode = selectNode;

// Initialize on load
init();

</script>
</body>
</html>
