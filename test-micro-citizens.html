<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Micro Citizens Test</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #1a1a1a;
      color: #e0e0e0;
      overflow: hidden;
    }
    
    #container {
      display: grid;
      grid-template-columns: 300px 1fr;
      height: 100vh;
    }
    
    #sidebar {
      background: #2a2a2a;
      padding: 20px;
      overflow-y: auto;
      border-right: 2px solid #444;
    }
    
    #canvas-container {
      position: relative;
    }
    
    h1 {
      color: #667eea;
      margin-bottom: 20px;
      font-size: 1.5em;
    }
    
    .stat-box {
      background: #333;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 15px;
    }
    
    .stat-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      font-size: 0.9em;
    }
    
    .stat-label {
      color: #aaa;
    }
    
    .stat-value {
      color: #fff;
      font-weight: bold;
    }
    
    button {
      width: 100%;
      padding: 12px;
      margin-bottom: 10px;
      border: none;
      border-radius: 6px;
      font-size: 1em;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    button.primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }
    
    button.secondary {
      background: #444;
      color: #e0e0e0;
    }
    
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    
    #log {
      background: #1a1a1a;
      padding: 10px;
      border-radius: 6px;
      max-height: 300px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 0.8em;
      margin-top: 15px;
    }
    
    #log div {
      padding: 2px 0;
      border-bottom: 1px solid #333;
    }
    
    .gen-stats {
      margin: 10px 0;
      padding: 10px;
      background: #2a2a2a;
      border-left: 3px solid #667eea;
      border-radius: 4px;
    }
    
    input[type="range"] {
      width: 100%;
      margin: 10px 0;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="sidebar">
      <h1>üèôÔ∏è Micro Citizens Test</h1>
      
      <div class="stat-box">
        <div class="stat-row">
          <span class="stat-label">Population:</span>
          <span class="stat-value" id="population">0</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Generations:</span>
          <span class="stat-value" id="generations">0</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Structures:</span>
          <span class="stat-value" id="structures">0</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">FPS:</span>
          <span class="stat-value" id="fps">60</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Real Time:</span>
          <span class="stat-value" id="realTime">0s</span>
        </div>
      </div>
      
      <button class="primary" id="startBtn">‚ñ∂Ô∏è Start Simulation</button>
      <button class="secondary" id="pauseBtn">‚è∏Ô∏è Pause</button>
      <button class="secondary" id="spawnBtn">üë§ Spawn 5 Citizens</button>
      <button class="secondary" id="resetBtn">üîÑ Reset</button>
      
      <div style="margin-top: 15px;">
        <label>Time Scale: <span id="timeScaleValue">1.0</span>x</label>
        <input type="range" id="timeScale" min="0.1" max="10" step="0.1" value="1">
      </div>
      
      <div id="generationStats"></div>
      
      <div id="log">
        <div>üöÄ System initialized. Press Start!</div>
      </div>
    </div>
    
    <div id="canvas-container"></div>
  </div>
  
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>
  
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { MicroCityCore } from './js/micro-city/MicroCityCore.js';
    import { MicroCityEvents } from './js/micro-city/EventBus.js';
    import { ScaleConstants } from './js/micro-city/ScaleConstants.js';
    
    // ===== Three.js Setup =====
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a1a);
    scene.fog = new THREE.Fog(0x1a1a1a, 5, 15);
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.001, 1000);
    camera.position.set(2, 2, 2);
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    container.appendChild(renderer.domElement);
    
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
    
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(5, 10, 5);
    dirLight.castShadow = true;
    dirLight.shadow.camera.left = -10;
    dirLight.shadow.camera.right = 10;
    dirLight.shadow.camera.top = 10;
    dirLight.shadow.camera.bottom = -10;
    scene.add(dirLight);
    
    // Ground
    const groundGeometry = new THREE.PlaneGeometry(20, 20);
    const groundMaterial = new THREE.MeshStandardMaterial({ 
      color: 0x2a2a2a,
      roughness: 0.9
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);
    
    // Grid
    const gridHelper = new THREE.GridHelper(20, 40, 0x444444, 0x333333);
    scene.add(gridHelper);
    
    // ===== Micro City System =====
    const microCity = new MicroCityCore({
      initialCitizens: 5,
      startScale: 0.01,
      autoResourceSpawn: true,
      resourceSpawnRate: 0.2
    });
    
    // ===== Rendering =====
    const citizenMeshes = new Map();
    const structureMeshes = new Map();
    const resourceMeshes = new Map();
    
    function createCitizenMesh(citizenId) {
      const citizen = microCity.getCitizen(citizenId);
      if (!citizen) return;
      
      const size = citizen.size * 50;
      const geometry = new THREE.SphereGeometry(size, 8, 6);
      const material = new THREE.MeshStandardMaterial({
        color: getGenerationColor(citizen.generation),
        roughness: 0.7,
        metalness: 0.1
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      
      mesh.position.set(citizen.position.x, citizen.position.y + size, citizen.position.z);
      scene.add(mesh);
      citizenMeshes.set(citizenId, mesh);
    }
    
    function removeCitizenMesh(citizenId) {
      const mesh = citizenMeshes.get(citizenId);
      if (mesh) {
        scene.remove(mesh);
        mesh.geometry.dispose();
        mesh.material.dispose();
        citizenMeshes.delete(citizenId);
      }
    }
    
    function createStructureMesh(structure) {
      const size = structure.scale * 0.3;
      const height = size * 0.6;
      
      const geometry = new THREE.BoxGeometry(size, height, size);
      const material = new THREE.MeshStandardMaterial({
        color: getStructureColor(structure.tier),
        roughness: 0.8
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      
      mesh.position.set(structure.position.x, height / 2, structure.position.z);
      scene.add(mesh);
      structureMeshes.set(structure.id, mesh);
    }
    
    function createResourceMesh(resource) {
      const size = 0.02;
      const geometry = new THREE.SphereGeometry(size, 6, 6);
      const material = new THREE.MeshStandardMaterial({
        color: getResourceColor(resource.type),
        emissive: getResourceColor(resource.type),
        emissiveIntensity: 0.2
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(resource.position.x, size, resource.position.z);
      scene.add(mesh);
      resourceMeshes.set(resource.id, mesh);
    }
    
    function getGenerationColor(generation) {
      const colors = [0xff6b6b, 0x4ecdc4, 0xffe66d, 0x95e1d3, 0xf38181, 0x6c5ce7, 0x00b894, 0xfd79a8];
      return colors[Math.min(generation, colors.length - 1)];
    }
    
    function getStructureColor(tier) {
      const colors = [0x8b7355, 0xd2b48c, 0xa0826d, 0x808080, 0xc0c0c0, 0xffd700, 0xff6b6b];
      return colors[Math.min(tier, colors.length - 1)];
    }
    
    function getResourceColor(type) {
      const colors = {
        wood: 0x8b4513,
        stone: 0x808080,
        fiber: 0xdaa520,
        food: 0x32cd32,
        metal: 0xc0c0c0,
        clay: 0xb8860b
      };
      return colors[type] || 0xffffff;
    }
    
    // ===== Event Listeners =====
    microCity.on(MicroCityEvents.CITIZEN_SPAWNED, (data) => {
      createCitizenMesh(data.citizenId);
      addLog(`üë§ Citizen spawned (Gen ${data.generation})`);
    });
    
    microCity.on(MicroCityEvents.CITIZEN_DIED, (data) => {
      removeCitizenMesh(data.citizenId);
      addLog(`üíÄ Citizen died (Gen ${data.generation}, Age: ${data.age.toFixed(1)})`);
    });
    
    microCity.on(MicroCityEvents.GENERATION_ADVANCED, (data) => {
      addLog(`üåç Generation ${data.generation} emerged! (Scale: ${data.scale.toFixed(4)})`);
    });
    
    microCity.on(MicroCityEvents.CONSTRUCTION_COMPLETED, (data) => {
      createStructureMesh(data.structure);
      addLog(`üèóÔ∏è ${data.type} completed (Gen ${data.generation})`);
    });
    
    microCity.on(MicroCityEvents.CITIZEN_REPRODUCED, (data) => {
      addLog(`üë∂ New citizen born! (Gen ${data.generation})`);
    });
    
    // ===== UI =====
    const logDiv = document.getElementById('log');
    function addLog(message) {
      const div = document.createElement('div');
      div.textContent = message;
      logDiv.appendChild(div);
      logDiv.scrollTop = logDiv.scrollHeight;
      
      // Keep only last 50 messages
      while (logDiv.children.length > 50) {
        logDiv.removeChild(logDiv.firstChild);
      }
    }
    
    function updateStats() {
      const stats = microCity.getStats();
      
      document.getElementById('population').textContent = stats.citizens.totalPopulation;
      document.getElementById('generations').textContent = stats.generations.length;
      document.getElementById('structures').textContent = stats.structures.totalCompleted;
      document.getElementById('fps').textContent = stats.fps;
      document.getElementById('realTime').textContent = microCity.timeSystem.globalRealTime.toFixed(1) + 's';
      
      // Generation stats
      const genStatsDiv = document.getElementById('generationStats');
      genStatsDiv.innerHTML = '<h3 style="margin-top: 15px; color: #667eea;">Generations</h3>';
      
      for (const gen of stats.generations) {
        const div = document.createElement('div');
        div.className = 'gen-stats';
        div.innerHTML = `
          <strong>Gen ${gen.number}</strong> (${gen.population} pop)<br>
          Scale: ${gen.scale.toFixed(4)}<br>
          Cultural Level: ${gen.culturalLevel}
        `;
        genStatsDiv.appendChild(div);
      }
    }
    
    // Buttons
    document.getElementById('startBtn').addEventListener('click', () => {
      microCity.start();
      addLog('‚ñ∂Ô∏è Simulation started');
    });
    
    document.getElementById('pauseBtn').addEventListener('click', () => {
      if (microCity.running) {
        microCity.pause();
        addLog('‚è∏Ô∏è Simulation paused');
      } else {
        microCity.resume();
        addLog('‚ñ∂Ô∏è Simulation resumed');
      }
    });
    
    document.getElementById('spawnBtn').addEventListener('click', () => {
      for (let i = 0; i < 5; i++) {
        microCity.spawnCitizen({
          generation: 0,
          position: {
            x: (Math.random() - 0.5) * 1,
            y: 0,
            z: (Math.random() - 0.5) * 1
          }
        });
      }
      addLog('‚ûï Spawned 5 new citizens');
    });
    
    document.getElementById('resetBtn').addEventListener('click', () => {
      microCity.reset();
      
      // Clear all meshes
      for (const mesh of citizenMeshes.values()) {
        scene.remove(mesh);
        mesh.geometry.dispose();
        mesh.material.dispose();
      }
      citizenMeshes.clear();
      
      for (const mesh of structureMeshes.values()) {
        scene.remove(mesh);
        mesh.geometry.dispose();
        mesh.material.dispose();
      }
      structureMeshes.clear();
      
      for (const mesh of resourceMeshes.values()) {
        scene.remove(mesh);
        mesh.geometry.dispose();
        mesh.material.dispose();
      }
      resourceMeshes.clear();
      
      addLog('üîÑ System reset');
    });
    
    document.getElementById('timeScale').addEventListener('input', (e) => {
      const scale = parseFloat(e.target.value);
      microCity.timeSystem.setTimeScale(scale);
      document.getElementById('timeScaleValue').textContent = scale.toFixed(1);
    });
    
    // ===== Animation Loop =====
    const clock = new THREE.Clock();
    
    function animate() {
      requestAnimationFrame(animate);
      
      const deltaTime = clock.getDelta();
      
      // Update micro city
      if (microCity.running) {
        microCity.update(deltaTime);
        
        // Update citizen positions
        for (const [citizenId, mesh] of citizenMeshes.entries()) {
          const citizen = microCity.getCitizen(citizenId);
          if (citizen) {
            const size = citizen.size * 50;
            mesh.position.set(citizen.position.x, citizen.position.y + size, citizen.position.z);
          }
        }
        
        // Sync resources (create new ones)
        const resources = microCity.getResources();
        for (const resource of resources) {
          if (!resourceMeshes.has(resource.id)) {
            createResourceMesh(resource);
          }
        }
        
        // Remove old resources
        for (const [id, mesh] of resourceMeshes.entries()) {
          if (!resources.find(r => r.id === id)) {
            scene.remove(mesh);
            mesh.geometry.dispose();
            mesh.material.dispose();
            resourceMeshes.delete(id);
          }
        }
      }
      
      controls.update();
      renderer.render(scene, camera);
    }
    
    // Update stats every second
    setInterval(updateStats, 1000);
    
    // Handle resize
    window.addEventListener('resize', () => {
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    });
    
    // Start
    animate();
    addLog('‚úì System ready. Press Start to begin!');
  </script>
</body>
</html>



