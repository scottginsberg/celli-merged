<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <meta name="version" content="4.2-theo-blackhole-style" />
  <title>Tri‑Trail Evolved • three.js [v4.2 THE.OS]</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Roboto+Mono:wght@100;300&family=VT323&display=swap" rel="stylesheet">
  <style>
    :root { --bg: #000; --fg: #e6e6e6; --accent:#8ab4ff; }
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    #app { position:fixed; inset:0; background:var(--bg); z-index:60; }
    .hud { position:fixed; inset:0; pointer-events:none; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji"; z-index:65; }
    .brand { position:absolute; left:2rem; bottom:2rem; color:var(--fg); letter-spacing:0.08em; font-weight:600; font-size:12px; opacity:.65; text-transform:uppercase; }
    .quote { position:absolute; left:50%; top:50%; transform:translate(-50%, -50%); color:var(--fg); font-weight:300; font-size:16px; letter-spacing:0.03em; line-height:1.6; max-width:560px; width:90%; text-align:center; font-style:italic; margin:0; padding:0 20px; box-sizing:border-box; z-index:10; visibility:hidden; opacity:0; transition: color 0.45s ease, text-shadow 0.45s ease; }
    .quote__text { display:block; max-width:100%; }
    .quote.quote--loom { font-family:'Roboto Mono', ui-monospace, monospace; font-style:normal; letter-spacing:0.12em; }
    .quote.visible { animation: fadeInQuote 3s ease-out forwards; display:block !important; visibility:visible; }
    @keyframes fadeInQuote {
      0% { opacity:0; transform:translate(-50%, -50%) translateY(20px); }
      100% { opacity:.85; transform:translate(-50%, -50%) translateY(0); }
    }
    .quote.glitch { animation: glitchText 0.5s ease-in-out infinite; }
    .quote.scrambling { text-shadow: 0 0 18px rgba(138, 180, 255, 0.4); color:#f5f5f5; }
    @keyframes glitchText {
      0%, 100% { opacity:.85; transform:translate(-50%, -50%) translateX(0); text-shadow: 0 0 0 transparent; }
      10% { opacity:.8; transform:translate(-50%, -50%) translateX(-1px); text-shadow: 1px 0 #ff1e6e, -1px 0 #00a8ff; }
      20% { opacity:.9; transform:translate(-50%, -50%) translateX(1px); text-shadow: -1px 0 #ffb62e, 1px 0 #00a8ff; }
      30% { opacity:.85; transform:translate(-50%, -50%) translateX(0); text-shadow: 0 0 0 transparent; }
    }
    .quote.glitchMedium { animation: glitchMedium 0.3s ease-in-out infinite; }
    @keyframes glitchMedium {
      0%, 100% { opacity:.82; transform:translate(-50%, -50%) translateX(0) translateY(0); text-shadow: 0 0 0 transparent; }
      15% { opacity:.7; transform:translate(-50%, -50%) translateX(-3px) translateY(1px); text-shadow: 2px 0 #ff1e6e, -2px 0 #00a8ff; }
      35% { opacity:.8; transform:translate(-50%, -50%) translateX(3px) translateY(-2px); text-shadow: -3px 0 #ffb62e, 3px 0 #00a8ff; }
      55% { opacity:.75; transform:translate(-50%, -50%) translateX(-2px) translateY(2px); text-shadow: 2px 0 #00a8ff, -2px 0 #ff1e6e; }
      75% { opacity:.78; transform:translate(-50%, -50%) translateX(2px) translateY(-1px); text-shadow: -2px 0 #ffb62e, 2px 0 #ff1e6e; }
    }
    .quote.glitchIntense { animation: glitchIntense 0.12s ease-in-out infinite; }
    @keyframes glitchIntense {
      0% { opacity:.75; transform:translate(-50%, -50%) translateX(0) translateY(0); text-shadow: 0 0 0 transparent; }
      12% { opacity:.5; transform:translate(-50%, -50%) translateX(-8px) translateY(4px); text-shadow: 4px 0 #ff1e6e, -4px 0 #00a8ff, 0 4px #ffb62e; }
      25% { opacity:.7; transform:translate(-50%, -50%) translateX(6px) translateY(-6px); text-shadow: -6px 0 #ffb62e, 6px 0 #00a8ff, 0 -6px #ff1e6e; }
      40% { opacity:.45; transform:translate(-50%, -50%) translateX(-10px) translateY(8px); text-shadow: 8px 0 #00a8ff, -8px 0 #ff1e6e; }
      55% { opacity:.65; transform:translate(-50%, -50%) translateX(5px) translateY(-3px); text-shadow: -5px 0 #ffb62e, 5px 0 #ff1e6e; }
      70% { opacity:.55; transform:translate(-50%, -50%) translateX(-7px) translateY(5px); text-shadow: 6px 0 #00a8ff, -5px 0 #ffb62e; }
      85% { opacity:.6; transform:translate(-50%, -50%) translateX(8px) translateY(-4px); text-shadow: -7px 0 #ff1e6e, 6px 0 #00a8ff; }
      100% { opacity:.5; transform:translate(-50%, -50%) translateX(0) translateY(0); text-shadow: 0 0 0 transparent; }
    }
    .loomworks { position:absolute; left:50%; top:50%; transform:translate(calc(-50% + var(--loomOffsetX, 0px)), calc(-50% + var(--loomOffsetY, 0px))); color:#fff; font-weight:300; font-size:20px; letter-spacing:0.15em; opacity:0; text-align:center; pointer-events:none; font-family:'Roboto Mono', ui-monospace, monospace; white-space:nowrap; }
    .loomworks.visible { animation: fadeInLoom 2s ease-out forwards; }
    .loomworks-chunk { display:inline-block; padding:0 0.08em; opacity:0; transform:translateY(12px); transition: opacity 0.45s ease, transform 0.45s ease, background 0.25s ease, color 0.25s ease; }
    .loomworks.visible .loomworks-chunk { opacity:1; transform:translateY(0); }
    .loomworks-chunk.selected { background:#fff; color:#000; box-shadow:0 0 0 1px rgba(0,0,0,0.55); }
    .loomworks-chunk.shift-right { transform:translateX(0.35em); }
    #loomTail { white-space:pre; }
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      10%, 30%, 50%, 70%, 90% { transform: translateX(-10px); }
      20%, 40%, 60%, 80% { transform: translateX(10px); }
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.7; transform: scale(1.05); }
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    @keyframes fadeInLoom {
      0% { opacity:0; transform:translate(-50%, -50%) scale(0.95); }
      100% { opacity:1; transform:translate(-50%, -50%) scale(1); }
    }
    
    /* Doorway portal - starts as vertical bar */
    .doorway { position:fixed; left:50%; bottom:20%; transform:translate(-50%, 0); width:4px; height:60px; background:#fff; pointer-events:none; z-index:68; opacity:0; box-shadow: 0 0 15px 5px rgba(255,255,255,0.8), 0 0 30px 10px rgba(255,255,255,0.5); transition: width 1.5s cubic-bezier(0.4, 0, 0.2, 1), height 1.5s cubic-bezier(0.4, 0, 0.2, 1), box-shadow 1.5s ease-out, opacity 0.5s ease-out; overflow:hidden; }
    .doorway.visible { opacity:1; }
    .doorway.open { width:min(280px, 85vw); height:80px; box-shadow: 0 0 40px 20px rgba(255,255,255,0.7), 0 0 80px 35px rgba(255,255,255,0.4), inset 0 0 60px rgba(255,255,255,0.6); }
    
    /* Light rays emanating from doorway - forward emission only (cut off at top) */
    .doorway::before { content:""; position:absolute; left:-150%; right:-150%; top:0%; bottom:-200%; background:radial-gradient(ellipse 120% 80% at center top, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0.15) 40%, transparent 70%); opacity:0; transition:opacity 1.5s ease-out; pointer-events:none; clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%); }
    .doorway.open::before { opacity:1; }
    
    /* Input prompt inside doorway */
    .prompt-container { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; opacity:0; transition:opacity 1s ease-in 1.5s; pointer-events:none; user-select:none; -webkit-user-select:none; }
    .doorway.open .prompt-container { opacity:1; pointer-events:auto; cursor:text; }
    .prompt {
      position: relative;
      font-family: 'VT323', 'Press Start 2P', 'Roboto Mono', ui-monospace, monospace;
      font-size: clamp(13px, 3.1vw, 34px);
      font-weight:400;
      color:#000;
      letter-spacing:0.22em;
      text-transform:uppercase;
      z-index: 2;
      white-space: nowrap;
      display: inline-flex;
    }
    /* Per-character shadow - each char gets its own shadow aligned to its bottom edge */
    .prompt .char {
      position: relative;
      display: inline-block;
    }
    .prompt .char::after {
      content: attr(data-char);
      position: absolute;
      left: 0;
      top: 100%; /* Start at bottom edge of character */
      font-family: 'VT323', 'Press Start 2P', 'Roboto Mono', ui-monospace, monospace;
      font-size: clamp(13px, 3.1vw, 34px);
      font-weight: 400;
      color: rgba(0, 0, 0, 0.92);
      transform-origin: top left;
      transform: translate(3px, 0) scaleY(-1.08) skewX(-20deg) scaleX(1.15);
      opacity: 0.4;
      filter: blur(1.2px);
      z-index: -1;
      pointer-events: none;
      mask-image: linear-gradient(to bottom, rgba(0,0,0,1) 0%, rgba(0,0,0,0.65) 40%, rgba(0,0,0,0) 100%);
      -webkit-mask-image: linear-gradient(to bottom, rgba(0,0,0,1) 0%, rgba(0,0,0,0.65) 40%, rgba(0,0,0,0) 100%);
    }
    .cursor { animation:blink 1s step-end infinite; }
    @keyframes blink {
      0%, 50% { opacity:1; }
      51%, 100% { opacity:0; }
    }
    
    /* CELLI glitch effects */
    .celli-glitch .char { display:inline-block; transition:opacity 0.1s; }
    .celli-glitch .char.flicker { animation:celliFlicker 0.15s infinite; }
    .celli-glitch .char.hidden { opacity:0; }
    @keyframes celliFlicker {
      0%, 100% { opacity:1; text-shadow: 0 0 8px currentColor; }
      25% { opacity:0.3; transform:translateX(-2px); }
      50% { opacity:0.6; transform:translateX(2px); }
      75% { opacity:0.2; transform:translateY(-1px); }
    }
    .screenGlitch { position:fixed; inset:0; pointer-events:none; background:#000; opacity:0; z-index:5; mix-blend-mode:normal; }
    .screenGlitch.active { animation: screenFlicker 0.2s infinite; }
    @keyframes screenFlicker {
      0%, 100% { opacity:0; background:#000; }
      15% { opacity:0.08; background:#fff; }
      30% { opacity:0; background:#000; }
      45% { opacity:0.12; background:#00a8ff; }
      60% { opacity:0; background:#000; }
      80% { opacity:0.1; background:#ff1e6e; }
    }
    .fallback { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:#000; color:#bbb; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial; }
    .scanlines::before { content:""; position:absolute; inset:0; pointer-events:none; background: repeating-linear-gradient( to bottom, rgba(255,255,255,0.04), rgba(255,255,255,0.04) 1px, transparent 1px, transparent 3px ); mix-blend-mode: overlay; opacity:.18; transition: opacity 1s ease; }
    .scanlines.fade-scanlines::before { opacity: 0; }
    .vignette { position:absolute; inset:0; pointer-events:none; box-shadow: inset 0 0 240px rgba(0,0,0,.75), inset 0 0 800px rgba(0,0,0,.65); }
    canvas { filter: saturate(1.06) contrast(1.06) brightness(1.02); display:block; }

    /* Play overlay */
    .play { position:fixed; inset:0; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:15px; background: radial-gradient(ellipse at center, rgba(30,30,30,.6) 0%, rgba(0,0,0,.9) 60%); z-index:100; }
    .play.hidden{ display:none; }
    .play button{ pointer-events:auto; appearance:none; border:none; padding:14px 20px; border-radius:999px; font-weight:700; letter-spacing:.06em; text-transform:uppercase; background:#111; color:#e8eaed; box-shadow: 0 0 0 2px rgba(255,255,255,.08) inset, 0 6px 20px rgba(0,0,0,.45); cursor:pointer; display:flex; gap:12px; align-items:center; justify-content:center; }
    #playBtn::before{ content:"▶"; font-size:14px; opacity:.9; }
    
    /* Skip button - Equilateral triangles */
    .skip-btn { position:fixed; bottom:20px; left:50%; transform:translate(-50%, 0); pointer-events:auto; cursor:pointer; z-index:70; opacity:0.75; display:flex; align-items:center; justify-content:center; gap:0; transition: opacity 0.45s ease; --skip-triangle-size:28px; --skip-triangle-height: calc(var(--skip-triangle-size) * 0.8660254038); }
    .skip-btn:hover { opacity:1; }
    .skip-btn.hidden { display:none; }
    .skip-btn.bow-lock { pointer-events:none; }
    .skip-btn.voxel-hidden { opacity:0; pointer-events:none; transition: opacity 0.35s ease, filter 0.35s ease; filter: brightness(0.65); }
    .skip-btn.golden-phase { color:#fff48a; }
    .skip-triangle { position:relative; width:var(--skip-triangle-size); height:var(--skip-triangle-height); display:flex; align-items:center; justify-content:center; transition: transform 0.85s cubic-bezier(0.19, 1, 0.22, 1), filter 0.6s ease; }
    .skip-triangle__inner { width:100%; height:100%; display:flex; filter: drop-shadow(0 0.5px 1px rgba(255,255,255,0.08)); transform-origin:center; transition: filter 0.6s ease, transform 0.6s ease; }
    .skip-triangle--right .skip-triangle__inner { transform: scaleX(-1); }
    .skip-triangle svg { width:100%; height:100%; display:block; }
    .skip-triangle polygon, .skip-triangle path { fill:#fff; stroke:rgba(255,255,255,0.25); stroke-width:4; stroke-linejoin:round; transition: stroke 0.6s ease, fill 0.6s ease, opacity 0.5s ease; }
    .skip-triangle path { opacity:0; }
    /* Initial position - closer together, vertex to edge */
    .skip-btn:not(.bow-shape) .skip-triangle--left { transform: translateX(calc(var(--skip-triangle-size) * -0.25)); }
    .skip-btn:not(.bow-shape) .skip-triangle--right { transform: translateX(calc(var(--skip-triangle-size) * 0.25)); }
    .skip-btn.bow-shape { gap:0; opacity:1; --skip-triangle-size:32px; }
    .skip-btn.bow-shape .skip-triangle { position:absolute; top:50%; left:50%; margin:0; }
    /* Ultra-minimal glow to match voxel squares exactly - core must dominate */
    .skip-btn.bow-shape .skip-triangle__inner { filter: drop-shadow(0 0.5px 1px rgba(255,255,255,0.08)) drop-shadow(0 0 2px rgba(255,255,255,0.05)); }
    .skip-btn.bow-shape .skip-triangle--left { transform: translate(-50%, -50%) translateX(calc(var(--skip-triangle-size) * -0.5)); }
    .skip-btn.bow-shape .skip-triangle--right { transform: translate(-50%, -50%) translateX(calc(var(--skip-triangle-size) * 0.5)); }
    .skip-btn.bow-shape .skip-triangle--right .skip-triangle__inner { transform: scaleX(1); }
    .skip-connector { position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); width:0; height:0; border-radius:0; background:transparent; box-shadow:none; opacity:0; transition: all 0.6s ease; pointer-events:none; }
    .skip-btn.rounded-bow .skip-triangle polygon { opacity:0; }
    .skip-btn.rounded-bow .skip-triangle path { opacity:1; }
    /* Connector with ultra-minimal glow - solid core like a voxel */
    .skip-btn.rounded-bow .skip-connector { width:calc(var(--skip-triangle-size) * 0.48); height:calc(var(--skip-triangle-size) * 0.48); border-radius:calc(var(--skip-triangle-size) * 0.12); background:rgba(255,255,255,1); box-shadow:0 0 2px rgba(255,255,255,0.08), 0 0 3px rgba(255,255,255,0.05); opacity:1; }
    .skip-btn.illuminating .skip-triangle__inner { animation: skipGlowPulse 2.4s ease-in-out infinite; }
    .skip-btn.illuminating.bow-shape .skip-triangle--left .skip-triangle__inner { animation: skipGlowPulse 2.4s ease-in-out infinite, skipJiggleLeft 1.6s ease-in-out infinite; }
    .skip-btn.illuminating.bow-shape .skip-triangle--right .skip-triangle__inner { animation: skipGlowPulse 2.4s ease-in-out infinite, skipJiggleRight 1.6s ease-in-out infinite; }
    .skip-btn.illuminating.rounded-bow .skip-connector { animation: skipCenterPulse 2.2s ease-in-out infinite; }
    .skip-btn.illuminating .skip-triangle polygon { animation: skipFillShimmer 2s ease-in-out infinite, skipOutlinePulse 2.8s ease-in-out infinite; }
    .skip-btn.illuminating.rounded-bow .skip-triangle path { animation: skipFillShimmer 2s ease-in-out infinite, skipOutlinePulse 2.8s ease-in-out infinite; }
    .skip-btn.golden-phase .skip-triangle polygon,
    .skip-btn.golden-phase .skip-triangle path { fill:#fff48a; stroke:rgba(255,214,120,0.65); }
    /* Golden phase - ultra-minimal glow to match voxel squares */
    .skip-btn.golden-phase .skip-triangle__inner { filter: drop-shadow(0 0.5px 1px rgba(255,215,96,0.08)) drop-shadow(0 0 2px rgba(255,238,160,0.05)); }
    .skip-btn.golden-phase.rounded-bow .skip-connector { background: radial-gradient(circle at 50% 45%, rgba(255,248,170,1) 0%, rgba(255,219,92,1) 45%, rgba(255,199,60,0.98) 100%); box-shadow:0 0 2px rgba(255,215,96,0.08), 0 0 3px rgba(255,239,168,0.05); }
    .skip-btn.golden-phase.illuminating .skip-triangle polygon,
    .skip-btn.golden-phase.illuminating .skip-triangle path { animation: skipFillShimmer 2s ease-in-out infinite, skipOutlinePulse 2.8s ease-in-out infinite; }
    
    /* Magenta phase - ultra-minimal glow to match voxel squares */
    .skip-btn.magenta-phase .skip-triangle polygon,
    .skip-btn.magenta-phase .skip-triangle path { fill:#ff1e6e; stroke:rgba(255,100,140,0.65); }
    .skip-btn.magenta-phase .skip-triangle__inner { filter: drop-shadow(0 0.5px 1px rgba(255,30,110,0.08)) drop-shadow(0 0 2px rgba(255,100,160,0.05)); }
    .skip-btn.magenta-phase.rounded-bow .skip-connector { background: radial-gradient(circle at 50% 45%, rgba(255,80,140,1) 0%, rgba(255,30,110,1) 45%, rgba(220,20,90,0.98) 100%); box-shadow:0 0 2px rgba(255,30,110,0.08), 0 0 3px rgba(255,100,160,0.05); }
    .skip-btn.magenta-phase.illuminating .skip-triangle polygon,
    .skip-btn.magenta-phase.illuminating .skip-triangle path { animation: skipFillShimmer 2s ease-in-out infinite, skipOutlinePulse 2.8s ease-in-out infinite; }
    
    /* Cyan phase - ultra-minimal glow to match voxel squares */
    .skip-btn.cyan-phase .skip-triangle polygon,
    .skip-btn.cyan-phase .skip-triangle path { fill:#00a8ff; stroke:rgba(100,180,255,0.65); }
    .skip-btn.cyan-phase .skip-triangle__inner { filter: drop-shadow(0 0.5px 1px rgba(0,168,255,0.08)) drop-shadow(0 0 2px rgba(100,200,255,0.05)); }
    .skip-btn.cyan-phase.rounded-bow .skip-connector { background: radial-gradient(circle at 50% 45%, rgba(100,200,255,1) 0%, rgba(0,168,255,1) 45%, rgba(0,140,220,0.98) 100%); box-shadow:0 0 2px rgba(0,168,255,0.08), 0 0 3px rgba(100,200,255,0.05); }
    .skip-btn.cyan-phase.illuminating .skip-triangle polygon,
    .skip-btn.cyan-phase.illuminating .skip-triangle path { animation: skipFillShimmer 2s ease-in-out infinite, skipOutlinePulse 2.8s ease-in-out infinite; }

    @keyframes skipGlowPulse {
      0%, 100% { filter: drop-shadow(0 0.5px 1px rgba(255,255,255,0.08)) drop-shadow(0 0 2px rgba(255,255,255,0.05)); }
      45% { filter: drop-shadow(0 0.5px 1px rgba(255,255,255,0.10)) drop-shadow(0 0 3px rgba(138,180,255,0.07)); }
      55% { filter: drop-shadow(0 0.5px 1px rgba(255,255,255,0.09)) drop-shadow(0 0 3px rgba(255,182,46,0.06)); }
    }
    @keyframes skipFillShimmer {
      0%, 100% { fill:#ffffff; }
      25% { fill:#f5f9ff; }
      50% { fill:#ffffff; }
      75% { fill:#eef3ff; }
    }
    @keyframes skipOutlinePulse {
      0%, 100% { stroke:rgba(138,180,255,0.45); stroke-width:5; }
      40% { stroke:rgba(255,255,255,0.85); stroke-width:6.5; }
      60% { stroke:rgba(255,182,46,0.7); stroke-width:6; }
    }
    @keyframes skipJiggleLeft {
      0%, 100% { transform: translate(0, 0); }
      40% { transform: translate(-6%, -6%); }
      70% { transform: translate(4%, 4%); }
    }
    @keyframes skipJiggleRight {
      0%, 100% { transform: translate(0, 0); }
      40% { transform: translate(6%, -5%); }
      70% { transform: translate(-4%, 4%); }
    }
    @keyframes skipCenterPulse {
      0%, 100% { box-shadow:0 0 2px rgba(255,255,255,0.08), 0 0 3px rgba(255,255,255,0.05); }
      45% { box-shadow:0 0 3px rgba(138,180,255,0.10), 0 0 4px rgba(255,255,255,0.07); }
      65% { box-shadow:0 0 3px rgba(255,182,46,0.09), 0 0 4px rgba(255,255,255,0.06); }
    }

    /* Barrel distortion - CRT bulge effect with radial scaling */
    @keyframes barrelStage1 {
      0% { 
        transform: perspective(1400px) translateZ(0) scale(1) rotateX(0deg); 
        filter: saturate(1) contrast(1); 
        border-radius: 0;
        box-shadow: none;
      }
      35% { 
        transform: perspective(700px) translateZ(85px) scale(1.08) rotateX(2deg); 
        filter: saturate(1.15) contrast(1.1) brightness(1.05);
        border-radius: 16px;
        box-shadow: 0 0 30px rgba(0,255,0,0.3), inset 0 0 20px rgba(0,255,0,0.1);
      }
      70% { 
        transform: perspective(900px) translateZ(35px) scale(1.04) rotateX(1deg); 
        filter: saturate(1.08) contrast(1.06) brightness(1.02);
        border-radius: 10px;
        box-shadow: 0 0 20px rgba(0,255,0,0.2), inset 0 0 15px rgba(0,255,0,0.05);
      }
      100% { 
        transform: perspective(1100px) translateZ(24px) scale(1.025) rotateX(0.5deg); 
        filter: saturate(1.05) contrast(1.03);
        border-radius: 8px;
        box-shadow: 0 0 15px rgba(0,255,0,0.15), inset 0 0 10px rgba(0,255,0,0.03);
      }
    }
    @keyframes barrelStage2 {
      0% { 
        transform: perspective(1100px) translateZ(24px) scale(1.025) rotateX(0.5deg); 
        filter: saturate(1.05) contrast(1.04); 
        border-radius: 8px;
        box-shadow: 0 0 15px rgba(0,255,0,0.15), inset 0 0 10px rgba(0,255,0,0.03);
      }
      38% { 
        transform: perspective(600px) translateZ(140px) scale(1.15) rotateX(4deg); 
        filter: saturate(1.35) contrast(1.25) brightness(1.08);
        border-radius: 24px;
        box-shadow: 0 0 50px rgba(0,255,0,0.5), inset 0 0 30px rgba(0,255,0,0.2);
      }
      72% { 
        transform: perspective(750px) translateZ(65px) scale(1.08) rotateX(2deg); 
        filter: saturate(1.20) contrast(1.15) brightness(1.04);
        border-radius: 18px;
        box-shadow: 0 0 35px rgba(0,255,0,0.35), inset 0 0 20px rgba(0,255,0,0.12);
      }
      100% { 
        transform: perspective(900px) translateZ(40px) scale(1.05) rotateX(1deg); 
        filter: saturate(1.14) contrast(1.1);
        border-radius: 14px;
        box-shadow: 0 0 25px rgba(0,255,0,0.25), inset 0 0 15px rgba(0,255,0,0.08);
      }
    }
    @keyframes barrelStage3 {
      0% { 
        transform: perspective(900px) translateZ(40px) scale(1.05) rotateX(1deg); 
        filter: saturate(1.14) contrast(1.1); 
        border-radius: 14px;
        box-shadow: 0 0 25px rgba(0,255,0,0.25), inset 0 0 15px rgba(0,255,0,0.08);
      }
      32% { 
        transform: perspective(500px) translateZ(210px) scale(1.22) rotateX(6deg); 
        filter: saturate(1.65) contrast(1.45) brightness(1.12);
        border-radius: 32px;
        box-shadow: 0 0 70px rgba(0,255,0,0.7), inset 0 0 40px rgba(0,255,0,0.3);
      }
      62% { 
        transform: perspective(600px) translateZ(120px) scale(1.14) rotateX(4deg); 
        filter: saturate(1.45) contrast(1.32) brightness(1.08);
        border-radius: 26px;
        box-shadow: 0 0 55px rgba(0,255,0,0.55), inset 0 0 30px rgba(0,255,0,0.22);
      }
      88% { 
        transform: perspective(700px) translateZ(75px) scale(1.10) rotateX(2.5deg); 
        filter: saturate(1.32) contrast(1.22) brightness(1.05);
        border-radius: 20px;
        box-shadow: 0 0 40px rgba(0,255,0,0.4), inset 0 0 22px rgba(0,255,0,0.15);
      }
      100% { 
        transform: perspective(800px) translateZ(55px) scale(1.07) rotateX(1.5deg); 
        filter: saturate(1.24) contrast(1.16);
        border-radius: 16px;
        box-shadow: 0 0 30px rgba(0,255,0,0.3), inset 0 0 18px rgba(0,255,0,0.12);
      }
    }
    @keyframes screenShatterFlash {
      0% { opacity:0; filter:brightness(1); }
      10% { opacity:1; filter:brightness(1.35); }
      40% { opacity:0.85; filter:brightness(1.12); }
      100% { opacity:0.72; filter:brightness(1.05); }
    }
    @keyframes screenShatterFade {
      0% { opacity:0.7; }
      60% { opacity:0.4; }
      100% { opacity:0; }
    }
    #visicalc.barrel-stage-1, #visicalc.barrel-stage-1 #visicalc-frame { animation: barrelStage1 1.2s ease forwards; }
    #visicalc.barrel-stage-2, #visicalc.barrel-stage-2 #visicalc-frame { animation: barrelStage2 1.35s ease forwards; }
    #visicalc.barrel-stage-3, #visicalc.barrel-stage-3 #visicalc-frame { animation: barrelStage3 1.6s ease forwards; }
    #visicalc.screen-shatter, #visicalc.screen-shatter #visicalc-frame { animation: shakeScreen 0.8s ease forwards; }
    .shatter-overlay { position:fixed; inset:0; pointer-events:none; z-index:180; opacity:0; mix-blend-mode:screen; }
    .shatter-overlay.active { animation: screenShatterFlash 0.9s ease forwards; }
    .shatter-overlay.fade { animation: screenShatterFade 1.3s ease forwards; }
    .shatter-overlay .shatter-cracks { 
      position:absolute; inset:0; 
      background-image: 
        repeating-linear-gradient(0deg, #0ff 0px, #0ff 2px, transparent 2px, transparent 18px),
        repeating-linear-gradient(90deg, #0ff 0px, #0ff 2px, transparent 2px, transparent 18px);
      background-size: 100% 100%; 
      opacity:0; 
      filter: drop-shadow(0 0 8px rgba(0,255,255,0.8)) drop-shadow(0 0 20px rgba(0,255,255,0.4)); 
      animation: shatterGridGlow 1.8s ease forwards;
    }
    @keyframes shatterGridGlow {
      0% { opacity:0; filter: drop-shadow(0 0 2px rgba(0,255,255,0.3)); }
      20% { opacity:0.8; filter: drop-shadow(0 0 12px rgba(0,255,255,0.9)) drop-shadow(0 0 24px rgba(0,255,255,0.5)); }
      45% { opacity:1; filter: drop-shadow(0 0 18px rgba(0,255,255,1)) drop-shadow(0 0 32px rgba(0,255,255,0.7)); }
      70% { opacity:0.6; filter: drop-shadow(0 0 8px rgba(0,255,255,0.4)); transform: scale(1.1); }
      100% { opacity:0; filter: drop-shadow(0 0 2px rgba(0,255,255,0.1)); transform: scale(1.5); }
    }
    .shatter-overlay .shatter-pixels {
      position:absolute; inset:0; opacity:0;
      background-image: 
        radial-gradient(circle, #0ff 1px, transparent 1px),
        radial-gradient(circle, #00ffaa 1px, transparent 1px);
      background-size: 8px 8px, 10px 10px;
      background-position: 0 0, 5px 5px;
      filter: blur(0.5px);
      animation: shatterPixelBurst 2.2s ease forwards;
      animation-delay: 0.4s;
    }
    @keyframes shatterPixelBurst {
      0% { opacity:0; transform: scale(1); filter: blur(0px); }
      25% { opacity:0.9; transform: scale(1); filter: blur(0px); }
      55% { opacity:1; transform: scale(1.15); filter: blur(1px); }
      75% { opacity:0.5; transform: scale(1.4); filter: blur(3px); }
      100% { opacity:0; transform: scale(2); filter: blur(8px); }
    }
    @keyframes shakeScreen {
      0%, 100% { transform: perspective(900px) translateZ(12px) rotate(0deg); }
      20% { transform: perspective(760px) translateZ(36px) rotate(1.4deg); }
      40% { transform: perspective(820px) translateZ(28px) rotate(-1.2deg); }
      60% { transform: perspective(780px) translateZ(44px) rotate(1deg); }
      80% { transform: perspective(860px) translateZ(24px) rotate(-0.8deg); }
    }

    .visicell-note-line { display:inline-block; min-width:1ch; opacity:0; transform:translateY(6px); animation: visicellNoteSlide 0.6s ease forwards; }
    .visicell-note-line--1 { animation-delay:0.2s; }
    .visicell-note-line--2 { animation-delay:0.45s; }
    @keyframes visicellNoteSlide {
      from { opacity:0; transform:translateY(10px); }
      to { opacity:1; transform:translateY(0); }
    }

    /* Debug toast */
    .toast{ position:fixed; right:14px; top:14px; background:rgba(18,18,18,.9); color:#cbd5e1; border:1px solid rgba(255,255,255,.08); border-radius:10px; padding:10px 12px; font: 12px/1.3 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; z-index: 9; box-shadow: 0 10px 24px rgba(0,0,0,.35); pointer-events:none; opacity:.95; max-width: 42ch; }
    .toast strong{ color:#fff; font-weight:700; }
    .toast .ok{ color:#9ae6b4; }
    .toast .warn{ color:#f6e05e; }
    .toast .err{ color:#feb2b2; }
    .r-hint { transition: text-shadow 0.6s ease, opacity 0.6s ease; text-shadow: none; }
    .r-hint.glow { text-shadow: 0 0 8px #0f0, 0 0 16px #0f0; }
    .r-hint .r-line { display:block; line-height:1.4; }
    .r-hint .r-char { display:inline-block; width:1ch; transition: transform 0.85s cubic-bezier(0.19, 1, 0.22, 1), opacity 0.85s ease, filter 0.85s ease; }
    .r-hint .r-char.falling { transform: translateY(26px); opacity:0; filter: blur(2px); }
    #matrixPleaOverlay { position:absolute; bottom:22px; left:32px; font-family:'VT323', 'Courier New', monospace; font-size:18px; letter-spacing:0.28em; text-transform:uppercase; color:#0f0; text-shadow:0 0 6px rgba(0,255,160,0.7); opacity:0; transform:translateY(8px); pointer-events:none; transition: opacity 0.5s ease, transform 0.45s ease; }
    #matrixPleaOverlay.visible { opacity:0.92; transform:translateY(0); }
    #matrixPleaOverlay.glitch { animation: matrixPleaGlitch 0.35s steps(2) infinite; }
    .matrix-plead { text-shadow:0 0 3px rgba(0,255,160,0.5), 0 0 8px rgba(0,255,140,0.35); }
    .matrix-plead-flash { animation: matrixPleaFlash 0.28s ease-out; }
    @keyframes matrixPleaGlitch {
      0%, 100% { transform:translateY(0); text-shadow:0 0 6px rgba(0,255,160,0.7); }
      40% { transform:translate(-2px, -1px) skewX(-4deg); text-shadow:0 0 10px rgba(0,255,200,0.9), -2px 0 #00ffd5; }
      75% { transform:translate(2px, 1px) skewX(3deg); text-shadow:0 0 10px rgba(170,255,120,0.85), 2px 0 #b3ff00; }
    }
    @keyframes matrixPleaFlash {
      0% { filter:brightness(1); text-shadow:0 0 3px rgba(0,255,160,0.4); }
      45% { filter:brightness(1.35); text-shadow:0 0 14px rgba(0,255,200,0.85); }
      100% { filter:brightness(1); text-shadow:0 0 4px rgba(0,255,140,0.45); }
    }
    
    /* Scene Select Menu */
    #sceneSelect { position:fixed; inset:0; background:rgba(0,0,0,0.95); display:none; align-items:center; justify-content:center; z-index:9999; }
    #sceneSelect.visible { display:flex; }
    .scene-menu { max-width:600px; width:90%; padding:40px; background:rgba(0,20,10,0.9); border:2px solid #0f0; border-radius:20px; box-shadow:0 0 30px rgba(0,255,160,0.3), inset 0 0 20px rgba(0,255,160,0.1); font-family:'Courier New', monospace; backdrop-filter:blur(10px); }
    .scene-menu h2 { margin:0 0 10px; color:#0f0; font-size:24px; text-align:center; text-transform:uppercase; letter-spacing:0.2em; text-shadow:0 0 10px rgba(0,255,160,0.6); }
    .scene-menu p { margin:0 0 25px; color:#0a8; font-size:13px; text-align:center; opacity:0.8; }
    .scene-option { margin:12px 0; padding:16px 20px; background:rgba(0,30,20,0.6); border:1px solid #0a6; border-radius:8px; color:#0f0; cursor:pointer; transition:all 0.2s ease; text-transform:uppercase; letter-spacing:0.15em; font-size:14px; }
    .scene-option:hover { background:rgba(0,50,30,0.9); border-color:#0f0; box-shadow:0 0 15px rgba(0,255,160,0.4); transform:translateX(5px); }
    .scene-option.locked { opacity:0.4; cursor:not-allowed; background:rgba(20,20,20,0.6); border-color:#444; color:#666; }
    .scene-option.locked:hover { transform:none; box-shadow:none; }
    .scene-option-desc { font-size:11px; opacity:0.7; margin-top:6px; letter-spacing:0.05em; text-transform:none; }
    .scene-controls { margin-top:25px; padding-top:20px; border-top:1px solid #0a6; display:flex; gap:10px; flex-wrap:wrap; }
    .scene-controls button { flex:1; min-width:140px; padding:12px; background:rgba(0,40,20,0.8); border:1px solid #0a8; border-radius:6px; color:#0f0; cursor:pointer; font-family:inherit; font-size:12px; text-transform:uppercase; letter-spacing:0.1em; transition:all 0.2s; }
    .scene-controls button:hover { background:rgba(0,60,30,0.9); border-color:#0f0; box-shadow:0 0 12px rgba(0,255,160,0.3); }
    .scene-controls .close-btn { background:rgba(40,0,0,0.8); border-color:#a00; color:#f66; }
    .scene-controls .close-btn:hover { background:rgba(60,0,0,0.9); border-color:#f00; box-shadow:0 0 12px rgba(255,100,100,0.3); }
  </style>
</head>
<body>
  <div id="app" class="scanlines"></div>
  <div class="hud">
    <div id="quote" class="quote">
      <span id="quoteBefore" class="quote__text">...if you gaze for long into an abyss, the abyss gazes also into you.</span>
      <span id="quoteAfter" class="quote__text" style="display:none;"></span>
    </div>
    <div id="loomworks" class="loomworks" aria-live="polite">
      <span id="loomPre" class="loomworks-chunk">L</span><span id="loomCore" class="loomworks-chunk">OO</span><span id="loomPost" class="loomworks-chunk">K</span><span id="loomTail" class="loomworks-chunk"></span>
    </div>
    <span id="floatingK" class="floatingK" aria-hidden="true">K</span>
    <div class="vignette"></div>
  </div>
  <div id="screenGlitch" class="screenGlitch"></div>
  
  <!-- Doorway portal -->
  <div id="doorway" class="doorway">
    <div class="prompt-container">
      <div class="prompt" data-text="=STAR_"><span id="promptText">=STAR</span><span id="promptCursor" class="cursor">_</span></div>
    </div>
  </div>
  
  <!-- Hidden input for mobile keyboard -->
  <input id="hiddenInput" type="text" style="position:absolute; left:-9999px; opacity:0;" autocomplete="off" autocapitalize="none" autocorrect="off" spellcheck="false" inputmode="text" enterkeyhint="done" />
  
  <audio id="chime" preload="auto">
    <source src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA=" type="audio/wav">
  </audio>
  <div id="fallback" class="fallback" style="display:none">⚠️ WebGL unavailable or ES Modules not supported. Try a newer browser/GPU.</div>

  <div id="play" class="play">
    <button id="playBtn">Play</button>
    <button id="sceneSelectBtn" style="font-size:12px; padding:10px 20px; opacity:0.7;">Scene Select</button>
  </div>
  
  <!-- Scene Select Menu -->
  <div id="sceneSelect">
    <div class="scene-menu">
      <h2>Scene Select</h2>
      <p>Jump to previously experienced sequences</p>
      
      <div id="sceneOptions">
        <div class="scene-option locked" data-scene="visicell">
          <div>END(?) → VisiCell</div>
          <div class="scene-option-desc">The terminal awakens - spreadsheet reality unfolds</div>
        </div>
        
        <div class="scene-option locked" data-scene="leave">
          <div>LEAVE → Initialize</div>
          <div class="scene-option-desc">The house of leaves - GIR.mp3 transformation</div>
        </div>
        
        <div class="scene-option locked" data-scene="theos">
          <div>THE.OS → Cell Lattice</div>
          <div class="scene-option-desc">Cell address grid formation - witness the architecture</div>
        </div>
        
        <div class="scene-option locked" data-scene="blackhole">
          <div>THE.OS → Black Hole</div>
          <div class="scene-option-desc">The void manifests - singularity achieved</div>
        </div>
        
        <div class="scene-option locked" data-scene="end3">
          <div>HARD.CORE → End3</div>
          <div class="scene-option-desc">Terminal environment - crawl sequence</div>
        </div>
      </div>
      
      <div class="scene-controls">
        <button id="debugToggle">Debug: Show All</button>
        <button id="clearProgress">Clear Progress</button>
        <button class="close-btn" id="closeSceneSelect">Close</button>
      </div>
    </div>
  </div>
  
    <div id="skipBtn" class="skip-btn hidden" role="button" aria-label="Skip intro" tabindex="0">
        <div class="skip-triangle skip-triangle--left" id="skipTriangle1">
          <div class="skip-triangle__inner">
            <svg viewBox="0 0 100 86.6025403784" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
              <polygon points="0,0 0,86.6025403784 100,43.3012701892"></polygon>
              <path d="M0,12 L0,74.6025403784 Q0,86.6025403784 11.012,81.8342402525 L88.988,48.0696001263 Q100,43.3012701892 88.988,38.5329402521 L11.012,4.7679001263 Q0,0 0,12 Z"></path>
            </svg>
          </div>
        </div>
        <div class="skip-connector" id="skipConnector" aria-hidden="true"></div>
        <div class="skip-triangle skip-triangle--right" id="skipTriangle2">
          <div class="skip-triangle__inner">
            <svg viewBox="0 0 100 86.6025403784" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
              <polygon points="100,0 100,86.6025403784 0,43.3012701892"></polygon>
              <path d="M100,12 L100,74.6025403784 Q100,86.6025403784 88.988,81.8342402525 L11.012,48.0696001263 Q0,43.3012701892 11.012,38.5329402521 L88.988,4.7679001263 Q100,0 100,12 Z"></path>
            </svg>
          </div>
        </div>
    </div>
  <div id="toast" class="toast" style="display:none"></div>

  <!-- Import map so bare specifiers resolve to CDN modules -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    // --- Imports ------------------------------------------------------------
    import * as THREE from "three";
    import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer.js";
    import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass.js";
    import { UnrealBloomPass } from "three/examples/jsm/postprocessing/UnrealBloomPass.js";
    import { AfterimagePass } from "three/examples/jsm/postprocessing/AfterimagePass.js";
    import { ShaderPass } from "three/examples/jsm/postprocessing/ShaderPass.js";
    import { BokehPass } from "three/examples/jsm/postprocessing/BokehPass.js";
    import { FilmPass } from "three/examples/jsm/postprocessing/FilmPass.js";
    import { RoundedBoxGeometry } from "three/examples/jsm/geometries/RoundedBoxGeometry.js";

    // ==========================================
    // CACHE BUSTER: VERSION FINAL FIX v5.3
    // HARD REFRESH NOW: Ctrl+Shift+R or Ctrl+F5
    // ==========================================
    console.log('%c🚨 VERSION FINAL FIX v5.3 LOADED 🚨', 'background: #ff4400; color: #fff; font-size: 24px; padding: 10px; font-weight: 900; text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;');
    console.log('%c✨ Removed ALL duplicate variable declarations - speechRActive fixed', 'background: #0ff; color: #000; font-size: 18px; padding: 8px; font-weight: bold;');
    console.log('%c⚠️ HARD REFRESH: Ctrl+Shift+R or Ctrl+F5 ⚠️', 'background: #ff6600; color: #fff; font-size: 18px; padding: 8px;');
    
    // Make THREE and imports available globally for end3 scene
    window.THREE = THREE;
    window.EffectComposer = EffectComposer;
    window.RenderPass = RenderPass;
    window.UnrealBloomPass = UnrealBloomPass;
    window.AfterimagePass = AfterimagePass;
    window.ShaderPass = ShaderPass;
    window.BokehPass = BokehPass;
    window.FilmPass = FilmPass;
    window.RoundedBoxGeometry = RoundedBoxGeometry;

    // --- Debug helpers ------------------------------------------------------
    const toastEl = document.getElementById('toast');
    function toast(lines, level='ok'){
      const arr = Array.isArray(lines) ? lines : [String(lines)];
      toastEl.innerHTML = `<strong>Debug</strong><br>${arr.map(l=>`<span class="${level}">${l}</span>`).join('<br>')}`;
      toastEl.style.display='block';
    }
    function clearToast(){ toastEl.style.display='none'; }

    // --- WebGL capability check --------------------------------------------
    const hasWebGL = (() => { try { const c = document.createElement('canvas'); return !!(window.WebGLRenderingContext && (c.getContext('webgl2')||c.getContext('webgl')||c.getContext('experimental-webgl'))); } catch(e){ return false; } })();
    if (!hasWebGL) { document.getElementById('fallback').style.display = 'flex'; throw new Error('WebGL not available'); }

    // --- Core setup ---------------------------------------------------------
    const app = document.getElementById('app');
    const quoteEl = document.getElementById('quote');
    const quoteBefore = document.getElementById('quoteBefore');
    const quoteAfter = document.getElementById('quoteAfter');
    const loomworksEl = document.getElementById('loomworks');
    const loomPre = document.getElementById('loomPre');
    const loomCore = document.getElementById('loomCore');
    const loomPost = document.getElementById('loomPost');
    const loomTail = document.getElementById('loomTail');
    const quoteStates = {
        initial: {
            text: '...if you gaze for long into an abyss, the abyss gazes also into you.',
            showLook: false
        },
        look: {
            text: '...if you LOOK for long into an abyss, the abyss LOOKS also into you.',
            showLook: false
        },
        despair: {
            text: 'LOOK on my works, ye Mighty, and despair!',
            showLook: false
        }
    };

    applyQuoteState(quoteStates.initial, { immediate: true });
    quoteEl.classList.remove('quote--loom');
    loomTail.innerHTML = '';
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false, powerPreference:'high-performance' });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    renderer.setClearColor(0x000000, 1);
    app.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.01, 10);
    camera.position.set(0, 0, 2);
    camera.lookAt(0, 0, 0);

     const blackHoleGeo = new THREE.CircleGeometry(0.35, 64);
    const blackHoleMat = new THREE.ShaderMaterial({
        uniforms: { time: { value: 0 }, pulseFactor: { value: 0.5 } },
        vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
        fragmentShader: `
            varying vec2 vUv; uniform float time; uniform float pulseFactor;
            void main() {
                vec2 center = vec2(0.5);
                float dist = distance(vUv, center);
                 // Organic pulsing with multiple harmonics
                 float baseRadius = 0.08 + pulseFactor * 0.28;
                 float pulse1 = 0.015 * sin(time * 3.5);
                 float pulse2 = 0.008 * sin(time * 7.3 + 1.5);
                 float radius = baseRadius + pulse1 + pulse2;
                 // Ultra-soft gradient fade for dreamy quality
                 float fadeDistance = radius * 1.6;
                float alpha = 1.0 - smoothstep(radius - fadeDistance, radius, dist);
                 // Softer alpha curve with slight glow at edges
                 alpha = pow(alpha, 0.6) * 0.9;
                 gl_FragColor = vec4(0.0, 0.0, 0.0, alpha);
            }
        `,
        transparent: true, depthWrite: false
    });
    const blackHole = new THREE.Mesh(blackHoleGeo, blackHoleMat);
    blackHole.position.z = 0.1;
    scene.add(blackHole);

    const R = 0.16;
    const makeMat = (hex) => new THREE.MeshBasicMaterial({ color: new THREE.Color(hex), blending: THREE.AdditiveBlending, transparent: true, depthWrite: false });
    const CYAN = 0x00a8ff, MAGENTA = 0xff1e6e, YELLOW = 0xffb62e;
    const colors = [new THREE.Color(CYAN), new THREE.Color(YELLOW), new THREE.Color(MAGENTA)];
    
    // Create custom rounded shapes: square (cyan), triangle (yellow), circle (magenta)
    
    // Shape 0: Rounded Square (Blue/Cyan)
    const createRoundedSquare = (size, radius) => {
        const shape = new THREE.Shape();
        const r = radius;
        const s = size / 2;
        shape.moveTo(-s + r, -s);
        shape.lineTo(s - r, -s);
        shape.quadraticCurveTo(s, -s, s, -s + r);
        shape.lineTo(s, s - r);
        shape.quadraticCurveTo(s, s, s - r, s);
        shape.lineTo(-s + r, s);
        shape.quadraticCurveTo(-s, s, -s, s - r);
        shape.lineTo(-s, -s + r);
        shape.quadraticCurveTo(-s, -s, -s + r, -s);
        return new THREE.ShapeGeometry(shape, 32);
    };
    
    // Shape 1: Rounded Triangle (Yellow) - flat bottom, pointing up
    const createRoundedTriangle = (size, radius) => {
        const shape = new THREE.Shape();
        const h = size * Math.sqrt(3) / 2; // Equilateral triangle height
        
        // Three vertices of equilateral triangle with FLAT BOTTOM
        const top = { x: 0, y: h / 2 };              // Top vertex (pointing up)
        const bl = { x: -size/2, y: -h / 2 };        // Bottom left
        const br = { x: size/2, y: -h / 2 };         // Bottom right
        
        const r = radius * 0.8; // Smaller radius for cleaner corners
        
        // Start at bottom-left, move clockwise
        shape.moveTo(bl.x + r, bl.y);
        
        // Bottom edge to bottom-right
        shape.lineTo(br.x - r, br.y);
        
        // Curve around bottom-right corner
        shape.quadraticCurveTo(br.x, br.y, br.x - r * 0.5, br.y + r * 0.866);
        
        // Right edge going up to top
        shape.lineTo(top.x + r * 0.5, top.y - r * 0.866);
        
        // Curve around top corner
        shape.quadraticCurveTo(top.x, top.y, top.x - r * 0.5, top.y - r * 0.866);
        
        // Left edge going down to bottom-left
        shape.lineTo(bl.x + r * 0.5, bl.y + r * 0.866);
        
        // Curve around bottom-left corner
        shape.quadraticCurveTo(bl.x, bl.y, bl.x + r, bl.y);
        
        return new THREE.ShapeGeometry(shape, 32);
    };
    
    // Shape 2: Circle (Pink/Magenta)
    const createCircle = (radius) => {
        return new THREE.CircleGeometry(radius, 64);
    };
    
    const geoSquare = createRoundedSquare(R * 2, R * 0.3);
    const geoTriangle = createRoundedTriangle(R * 2, R * 0.35);
    const geoCircle = createCircle(R);
    
    // Store original geometries for morphing
    const originalGeos = [geoSquare, geoTriangle, geoCircle];
    
    // Create circle targets for morphing (all shapes will become circles)
    const circleGeoTarget = createCircle(R);
    
    const spheres = [
        new THREE.Mesh(geoSquare, makeMat(CYAN)),
        new THREE.Mesh(geoTriangle, makeMat(YELLOW)),
        new THREE.Mesh(geoCircle, makeMat(MAGENTA))
    ];
    spheres.forEach((s,i)=>{ s.position.z = -i*0.002; scene.add(s); });

    // --- Voxel System for CELLI - Early Computer Typeface Style ---
    const voxelSize = 0.08;
    // Create a thin, flat box for early computer terminal look - more like vector graphics
    const voxelGeo = new THREE.BoxGeometry(voxelSize * 0.95, voxelSize * 0.95, voxelSize * 0.15);
    const voxelMat = new THREE.MeshBasicMaterial({ 
        color: 0x444444,  // Start as dim gray
        transparent: true, 
        opacity: 0,
        blending: THREE.NormalBlending  // Normal blending for borders
    });
    
    // Create edges geometry for borders - straight lines, not rounded
    const edgesGeo = new THREE.EdgesGeometry(voxelGeo);
    const edgeMat = new THREE.LineBasicMaterial({ 
        color: 0x888888,
        transparent: true,
        opacity: 0,
        linewidth: 1  // Thin, crisp lines
    });
    
    // Rounded voxels for yellow phase - still thin but with subtle rounding
    const roundedVoxelGeo = new RoundedBoxGeometry(voxelSize * 1.05, voxelSize * 1.05, voxelSize * 0.18, 5, Math.min(voxelSize * 0.4, 0.04));
    const roundedEdgesGeo = new THREE.EdgesGeometry(roundedVoxelGeo);
    const cellShadeBaseMaterial = new THREE.MeshBasicMaterial({
        color: 0xfff27a,
        transparent: true,
        opacity: 0.92,
        blending: THREE.AdditiveBlending
    });
    const cellShadeEdgeMaterial = new THREE.LineBasicMaterial({
        color: 0xfff9a1,
        transparent: true,
        opacity: 0.75
    });

// CELLI letter patterns (5x5 grid for each letter)
    const celliPatterns = {
        C: [[0,1,1,1,0], [1,0,0,0,0], [1,0,0,0,0], [1,0,0,0,0], [0,1,1,1,0]],
        E: [[1,1,1,1,1], [1,0,0,0,0], [1,1,1,1,0], [1,0,0,0,0], [1,1,1,1,1]],
        L: [[1,0,0,0,0], [1,0,0,0,0], [1,0,0,0,0], [1,0,0,0,0], [1,1,1,1,1]],
        I: [[1,1,1,1,1], [0,0,1,0,0], [0,0,1,0,0], [0,0,1,0,0], [1,1,1,1,1]]
    };
    
    const voxels = [];
    const letterVoxels = { C: [], E: [], L1: [], L2: [], I: [] }; // Track voxels by letter
    const letters = ['C', 'E', 'L', 'L', 'I'];
    let letterSpacing = 0.6;
    let celliScale = 1.0;
    
    // Responsive scaling for touch devices
    function calculateCelliScale() {
        const aspect = window.innerWidth / window.innerHeight;
        
        // Calculate total width needed for all letters (including padding)
        const totalBaseWidth = letters.length * letterSpacing;
        
        // Camera view width in world units
        let viewWidth;
        if (aspect > 1) {
            // Landscape
            viewWidth = aspect * 2;
        } else {
            // Portrait
            viewWidth = 2;
        }
        
        // Scale to fit 85% of view width
        const targetWidth = viewWidth * 0.85;
        if (totalBaseWidth > targetWidth) {
            celliScale = targetWidth / totalBaseWidth;
        } else {
            celliScale = 1.0;
        }
    }
    calculateCelliScale();
    
    const startX = -(letters.length * letterSpacing * celliScale) / 2 + (letterSpacing * celliScale) / 2;
    
    letters.forEach((letter, letterIdx) => {
        const pattern = celliPatterns[letter];
        const letterX = startX + letterIdx * letterSpacing * celliScale;
        
        pattern.forEach((row, rowIdx) => {
            row.forEach((cell, colIdx) => {
                if (cell === 1) {
                    // Create voxel with border
                    const voxel = new THREE.Mesh(voxelGeo, voxelMat.clone());
                    const edges = new THREE.LineSegments(edgesGeo, edgeMat.clone());
                    voxel.add(edges);
                    
                    const x = letterX + (colIdx - 2) * voxelSize * 1.2 * celliScale;
                    const y = (2 - rowIdx) * voxelSize * 1.2 * celliScale + 0.35; // Offset up
                    
                    voxel.userData = {
                        targetX: x,
                        targetY: y,
                        startY: y + 2.0 + Math.random() * 1.0,
                        dropDelay: letterIdx * 0.15 + (rowIdx * colIdx) * 0.02,
                        dropSpeed: 0.02 + Math.random() * 0.01,
                        settled: false,
                        jigglePhase: Math.random() * Math.PI * 2,
                        flickerPhase: Math.random() * Math.PI * 2,
                        edges: edges,  // Store reference to edges
                        gridX: letterIdx,  // Letter index (0=C, 1=E, 2=L, 3=L, 4=I)
                        gridY: rowIdx,     // Row index (0=top, 4=bottom)
                        gridCol: colIdx,   // Column index within letter (0-4)
                        glitched: false,    // Track if this voxel has been glitched out
                        baseScale: celliScale,  // Store scale for proper sizing
                        backspaceTransformed: false,
                        backspacePulseOffset: Math.random() * Math.PI * 2
                    };
                    
                    // Scale voxel size to match the overall scale
                    voxel.scale.set(celliScale, celliScale, celliScale);
                    
                    voxel.position.set(x, voxel.userData.startY, 0);
                    voxel.visible = false;
                    scene.add(voxel);
                    voxels.push(voxel);
                    
                    // Track voxels by letter for restoration
                    const letterKey = letterIdx === 0 ? 'C' : letterIdx === 1 ? 'E' : letterIdx === 2 ? 'L1' : letterIdx === 3 ? 'L2' : 'I';
                    letterVoxels[letterKey].push(voxel);
                }
            });
        });
    });

    // --- [NEW] Shader for the color triangle between spheres ---
    const triGeo = new THREE.PlaneGeometry(4, 4); // Covers view
    const triMat = new THREE.ShaderMaterial({
        uniforms: {
            points: { value: [new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2()] },
            colors: { value: colors },
            aspect: { value: 1.0 }
        },
        vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = vec4(position, 1.0); }`,
        fragmentShader: `
            varying vec2 vUv;
            uniform vec2 points[3];
            uniform vec3 colors[3];
            uniform float aspect;

            // Function to calculate barycentric coordinates
            vec3 barycentric(vec2 p, vec2 a, vec2 b, vec2 c) {
                vec2 v0 = b - a, v1 = c - a, v2 = p - a;
                float d00 = dot(v0, v0);
                float d01 = dot(v0, v1);
                float d11 = dot(v1, v1);
                float d20 = dot(v2, v0);
                float d21 = dot(v2, v1);
                float denom = d00 * d11 - d01 * d01;
                float v = (d11 * d20 - d01 * d21) / denom;
                float w = (d00 * d21 - d01 * d20) / denom;
                float u = 1.0 - v - w;
                return vec3(u, v, w);
            }

            void main() {
                // Adjust UVs to be centered and handle aspect ratio
                vec2 p = (vUv - 0.5) * 2.0;
                p.x *= aspect;

                vec3 b = barycentric(p, points[0], points[1], points[2]);

                if (b.x >= 0.0 && b.y >= 0.0 && b.z >= 0.0) {
                    // We are inside the triangle
                    vec3 color = b.x * colors[0] + b.y * colors[1] + b.z * colors[2];
                    
                     // More defined edges with softer interior
                     float edgeDist = min(b.x, min(b.y, b.z));
                     float edgeFade = smoothstep(0.0, 0.2, edgeDist);
                     
                     // Distance-based fading
                     float centerDist = length(p);
                     float centerFade = 1.0 - smoothstep(0.15, 0.65, centerDist);
                     centerFade = pow(centerFade, 0.6);
                     
                     // Subtle center glow
                     float centerGlow = 1.0 - smoothstep(0.0, 0.25, centerDist);
                     float finalAlpha = (edgeFade * centerFade + centerGlow * 0.12) * 0.55;
                     
                     gl_FragColor = vec4(color, finalAlpha);
                } else {
                    discard;
                }
            }
        `,
        transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
    });
    const triMesh = new THREE.Mesh(triGeo, triMat);
    triMesh.position.z = -0.1; // Behind spheres
    scene.add(triMesh);

    // --- Composer & passes --------------------------------------------------
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.7, 0.9, 0.2);
    composer.addPass(bloomPass);
    const afterimagePass = new AfterimagePass(0.96);
    composer.addPass(afterimagePass);
    const filmPass = new ShaderPass({
      uniforms: { tDiffuse: { value: null }, time: { value: 0 }, noise: { value: 0.03 }, scanAmp: { value: 0.03 } },
      vertexShader: `varying vec2 vUv; void main(){ vUv = uv; gl_Position = projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
      fragmentShader: `
        precision highp float; varying vec2 vUv; uniform sampler2D tDiffuse; uniform float time; uniform float noise; uniform float scanAmp;
        float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }
        void main(){ vec3 col = texture2D(tDiffuse, vUv).rgb; float n = rand(vUv + fract(time)); float scan = sin((vUv.y + time*0.04)*3.14159*480.0) * scanAmp; col += n*noise; col += scan; col = pow(col, vec3(1.02)); gl_FragColor = vec4(col, 1.0); }`
    });
    composer.addPass(filmPass);

    // --- [REWRITTEN] Eclipse & Radiate Motion with Intro Sequence ----------
    const motionCfg = {
        speed: 0.8,
        maxDist: 0.65,
        rotationSpeed: 0.4,
        minScale: 0.4
    };

    // Intro sequence with magical progression
    const introCfg = {
        rollEnd: 2.5,        // Roll into place (slower)
        bounceEnd: 4.5,      // Sequential bounces
        triangleEnd: 7.5,    // Form triangle + grow + converge
        transitionEnd: 9.5,  // Transition to orbit
        normalEnd: 15.5,     // Converge + one pulse cycle
        vennEnd: 18.0,       // Clear venn diagram
        collapseEnd: 22.0,   // Collapse to white circle (extended)
        glitchEnd: 24.5,     // Intense glitch + fade (extended)
        blackoutEnd: 26.0,   // Complete blackout
        loomworksEnd: 30.0,  // Show Loomworks text
        celliEnd: 36.0,      // CELLI voxel animation
        doorwayEnd: 44.0,    // Doorway portal sequence
        ballSize: 0.12,      // Size during intro
        bounceHeight: 0.35,  // Bounce amplitude
        bounceDuration: 0.6  // Each bounce duration
    };
    
    // Audio context for synth and chime
    let audioCtx = null;
    let synthGain = null;
    let synthOsc1 = null;
    let synthOsc2 = null;
    let synthOsc3 = null;
    let landingSounds = [false, false, false]; // Track if shape has landed
    let lastThunkTime = [0, 0, 0]; // Track last thunk time for each shape
    
    let speechRActive = false;
    let speechRTimeout = null;
    let speechRVoice = null;
    let speechRUtterance = null;
    let speechRGuardTimeout = null;
    let hasSpeechSynthesis = typeof window !== 'undefined' && 'speechSynthesis' in window;
    let matrixUpdateInterval = null;
    let quoteShown = false;
    let quoteDespairShown = false;
    let glitchStarted = false;
    let mediumGlitchStarted = false;
    let intenseGlitchStarted = false;
    let screenGlitchStarted = false;
    let blackoutStarted = false;
    let loomworksShown = false;
    let loomworksRevealStarted = false;
    let chimePlayed = false;
    let celliStarted = false;
    let celliStartTime = 0;
    let doorwayShown = false;
    let doorwayOpened = false;
    let inputAttempted = false;
    let celliGlitchStarted = false;
    let finalRollRotations = [0, 0, 0]; // Store final rotations from roll phase
    const promptBaseText = '=';
    let inputText = '=STAR';
    let tEntered = false;
    let burstAnimStarted = false;
    let burstTimeout = null;
    let celliBackspaceSequenceStarted = false;
    let celliBackspaceSequenceTime = 0;
    let celliBackspaceFlickerTriggered = false;
    const starParticles = []; // Stars from burst voxels
    let loomworksTypingTimeout = null;
    const glitchedVoxelsStack = []; // Track glitched voxels in order for restoration
    let lettersToRestore = ['C', 'E', 'L1', 'L2']; // Order of restoration on backspace
    let restoredLetters = 0;
    let endSequence = ''; // Track E, N, D input sequence
    let allYellowTransformed = false; // Track if all are yellow and transformed
    let yellowTransformCompleteCount = 0;
    let endColorState = 'yellow'; // Track current color state: yellow, magenta, cyan, green
    let endColorPrevState = 'yellow'; // Track previous color for transitions
    let endColorTransitionStart = 0; // When color transition started
    let snapTogetherStarted = false;
    let snapTogetherTime = 0;
    let visiCalcShown = false;
    let celliMoveToCornerStarted = false;
    let celliMoveToCornerTime = 0;
    let visiCalcGreenTransitionStarted = false; // Track when VisiCalc green transition begins
    let bowActive = false;
    let bowCurrentCenter = null;
    let bowTargetCenter = null;
    let bowCurrentRotation = 0;
    let bowTargetRotation = 0;
    let bowAnimationId = 0;
    let bowHasTriggered = false;
    let bowVisibleAsVoxel = true;
    let pendingRoundedBow = false;
    
    // Text particle system for click interactions
    const textParticles = [];
    const manicTexts = ["huh?", "who's there?", "AH!", "HAHA.", "ow.", "ahh...", "oh!", "what?", "why?", "where?", "when?"];
    const timeTexts = () => {
        const formats = [
            new Date().toLocaleTimeString(),
            new Date().toLocaleDateString(),
            `${new Date().getHours()}:${String(new Date().getMinutes()).padStart(2,'0')}`,
            new Date().getFullYear().toString(),
            `${Math.floor(Date.now()/1000)}`,
            new Date().toISOString().split('T')[0]
        ];
        return formats[Math.floor(Math.random() * formats.length)];
    };
    const equationTexts = [
        "x²+y²=r²", "∫f(x)dx", "E=mc²", "∂f/∂x", "Σ(x)", "√(a²+b²)",
        "(0,0)", "(x,y,z)", "[1,2,3]", "θ=arctan(y/x)", "∇×F", "dy/dx"
    ];

    const glitchGlyphs = "!<>-_\\/[]{}—=+*^?#▒▓█▞▚";

    function glitchSwapQuote(targetState, { duration = 1100, onComplete = null } = {}) {
        if (!targetState) return;
        if (quoteEl.dataset.swapping === '1') return;

        quoteEl.dataset.swapping = '1';
        quoteEl.classList.add('scrambling');

        const initialText = quoteBefore.textContent || '';
        const targetText = targetState.text || '';
        const textMax = Math.max(initialText.length, targetText.length);
        const textDenom = textMax === 0 ? 1 : textMax;
        const start = performance.now();

        const frame = (now) => {
            const elapsed = now - start;
            const progress = Math.min(elapsed / duration, 1);
            let result = '';

            for (let i = 0; i < textMax; i++) {
                if (progress > i / textDenom) {
                    result += targetText[i] ?? '';
                } else {
                    const fallback = initialText[i] ?? '';
                    const randomChar = glitchGlyphs[Math.floor(Math.random() * glitchGlyphs.length)] || fallback;
                    result += randomChar;
                }
            }

            quoteBefore.textContent = result;

            if (progress < 1) {
                requestAnimationFrame(frame);
            } else {
                quoteBefore.textContent = targetText;

                quoteEl.classList.remove('scrambling');
                delete quoteEl.dataset.swapping;

                if (typeof onComplete === 'function') {
                    onComplete();
                }
            }
        };

        requestAnimationFrame(frame);
    }

    function applyQuoteState(state, { immediate = false, duration, onComplete } = {}) {
        if (!state) return;

        if (immediate) {
            quoteBefore.textContent = state.text || '';
            quoteAfter.textContent = '';
            quoteEl.classList.remove('scrambling');
            delete quoteEl.dataset.swapping;
            if (typeof onComplete === 'function') {
                onComplete();
            }
            return;
        }

        glitchSwapQuote(state, { duration, onComplete });
    }

    function typeLoomTail(text, index = 0) {
        if (index === 0) {
            loomTail.innerHTML = '';
        }

        if (index >= text.length) {
            loomworksTypingTimeout = null;
            return;
        }

        // Wrap each character in a span
        const charSpan = document.createElement('span');
        charSpan.textContent = text[index];
        charSpan.className = 'loomworks-chunk selected';
        loomTail.appendChild(charSpan);
        
        // Remove selected class from this character only
        setTimeout(() => {
            charSpan.classList.remove('selected');
        }, 140);
        
        const baseDelay = index < 3 ? 110 : 65;
        const jitter = Math.random() * 55;
        loomworksTypingTimeout = setTimeout(() => typeLoomTail(text, index + 1), baseDelay + jitter);
    }


    function startLoomworksReveal() {
        if (loomworksRevealStarted) return;
        loomworksRevealStarted = true;

        loomworksEl.classList.add('visible');
        loomPre.textContent = 'L';
        loomCore.textContent = 'OO';
        loomPost.textContent = 'K';
        loomTail.innerHTML = '';

        setTimeout(() => {
            loomCore.classList.add('selected');
        }, 280);

        setTimeout(() => {
            loomCore.textContent = 'oo';
        }, 630);

        setTimeout(() => {
            loomCore.classList.remove('selected');
        }, 1080);

        setTimeout(() => {
            loomPost.classList.add('shift-right');
        }, 900);

        setTimeout(() => {
            loomPost.classList.add('selected');
            loomPost.style.opacity = '0.2';
        }, 980);

        setTimeout(() => {
            loomPost.textContent = 'm';
            loomPost.style.opacity = '1';
            loomPost.classList.remove('shift-right');
        }, 1340);

        setTimeout(() => {
            loomPost.classList.remove('selected');
            setTimeout(() => { loomPost.style.opacity = ''; }, 220);
        }, 1680);

        setTimeout(() => {
            loomPre.style.opacity = '0';
        }, 920);

        setTimeout(() => {
            loomPre.textContent = 'a L';
            loomPre.style.opacity = '1';
        }, 1340);

        setTimeout(() => {
            if (loomworksTypingTimeout) {
                clearTimeout(loomworksTypingTimeout);
            }
            typeLoomTail('works Experience.');
        }, 1380);
    }
    
    function createTextParticle(x, y, text, color, sourceIndex) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 0.004 + Math.random() * 0.006;
        const particle = {
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            text,
            color,
            life: 1.0,
            age: 0,
            rotation: (Math.random() - 0.5) * 0.03,
            rotationSpeed: (Math.random() - 0.5) * 0.02,
            pulse: Math.random() * Math.PI * 2,
            sourceIndex,
            collapsing: false
        };
        textParticles.push(particle);
    }
    
    function updateTextParticles(dt) {
        for (let i = textParticles.length - 1; i >= 0; i--) {
            const p = textParticles[i];
            
            p.age += dt;
            
            // Get source sphere position
            const source = spheres[p.sourceIndex].position;
            
            // Calculate attraction to source (gravitational pull)
            const dx = source.x - p.x;
            const dy = source.y - p.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            // After 1.8 seconds, begin dramatic collapse
            if (p.age > 1.8 && !p.collapsing) {
                p.collapsing = true;
            }
            
            if (p.collapsing) {
                // Dramatic collapse: strong pull, wild rotation, rapid fade
                const collapseForce = 0.0008 / (dist * dist + 0.01); // Much stronger!
                p.vx += (dx / dist) * collapseForce;
                p.vy += (dy / dist) * collapseForce;
                
                // Accelerate rotation
                p.rotationSpeed *= 1.05;
                
                // Rapid fade during collapse
                p.life -= dt * 2.5;
            } else {
                // Normal orbit phase
                if (dist > 0.01) {
                    const force = 0.00008 / (dist + 0.1);
                    p.vx += (dx / dist) * force;
                    p.vy += (dy / dist) * force;
                }
                
                // Apply orbital motion
                const orbitForce = 0.00012;
                p.vx += -dy * orbitForce;
                p.vy += dx * orbitForce;
                
                // Normal fade
                p.life -= dt * 0.5;
            }
            
            // Update position
            p.x += p.vx;
            p.y += p.vy;
            
            // Damping (less during collapse for dramatic effect)
            const dampFactor = p.collapsing ? 0.97 : 0.99;
            p.vx *= dampFactor;
            p.vy *= dampFactor;
            
            // Update rotation and pulse
            p.rotation += p.rotationSpeed;
            p.pulse += dt * (p.collapsing ? 8 : 4); // Faster pulse during collapse
            
            if (p.life <= 0) {
                textParticles.splice(i, 1);
            }
        }
    }
    
    function renderTextParticles(ctx, camera) {
        ctx.save();
        ctx.font = 'bold 16px monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        for (const p of textParticles) {
            // Project from world to screen
            const screenX = (p.x / camera.right) * (window.innerWidth / 2) + (window.innerWidth / 2);
            const screenY = (-p.y / camera.top) * (window.innerHeight / 2) + (window.innerHeight / 2);
            
            ctx.save();
            ctx.translate(screenX, screenY);
            ctx.rotate(p.rotation);
            
            const alpha = p.life * p.life;
            const pulseFactor = 0.85 + Math.sin(p.pulse) * 0.15; // Gentle pulsate
            const glowSize = 5 + Math.sin(p.pulse * 0.7) * 3; // Slower, dreamy pulse
            
            // Scale down dramatically during collapse
            const scaleFactor = p.collapsing ? Math.max(0.1, 1.0 - (p.age - 1.8) * 1.2) : 1.0;
            ctx.scale(scaleFactor, scaleFactor);
            
            // Outer colored glow - intensify during collapse
            const collapseIntensity = p.collapsing ? 1.5 : 1.0;
            ctx.shadowBlur = glowSize * 4 * collapseIntensity;
            ctx.shadowColor = p.color;
            ctx.globalAlpha = alpha * 0.9 * collapseIntensity;
            ctx.fillStyle = p.color;
            ctx.fillText(p.text, 0, 0);
            
            // Mid white glow for visibility
            ctx.shadowBlur = glowSize * 2;
            ctx.shadowColor = '#ffffff';
            ctx.globalAlpha = alpha * 0.95;
            ctx.fillStyle = '#ffffff';
            ctx.fillText(p.text, 0, 0);
            
            // Bright white base (always visible)
            ctx.shadowBlur = glowSize * 0.5;
            ctx.shadowColor = '#ffffff';
            ctx.globalAlpha = alpha;
            ctx.fillStyle = '#ffffff';
            ctx.fillText(p.text, 0, 0);
            
            // Colored accent overlay
            ctx.shadowBlur = 0;
            ctx.globalAlpha = alpha * 0.4;
            ctx.fillStyle = p.color;
            ctx.fillText(p.text, 0, 0);
            
            ctx.restore();
        }
        ctx.restore();
    }
    
    function updateVoxels(t, dt) {
        const celliTime = t - introCfg.loomworksEnd;
        if (celliTime < 0) return;
        
        voxels.forEach(voxel => {
            const data = voxel.userData;
            
            // Skip glitched voxels - they're permanently disabled
            if (data.glitched) return;
            
            const localTime = celliTime - data.dropDelay;
            
            if (localTime < 0) return;
            
            voxel.visible = true;
            
            if (!data.settled) {
                // Dropping phase
                const targetY = data.targetY;
                if (voxel.position.y > targetY) {
                    voxel.position.y -= data.dropSpeed;
                    voxel.material.opacity = Math.min(0.8, voxel.material.opacity + 0.05);
                    data.edges.material.opacity = Math.min(0.6, data.edges.material.opacity + 0.04);
                } else {
                    // Hit the ground, settle
                    voxel.position.y = targetY;
                    data.settled = true;
                    data.settleTime = celliTime;
                    // Play chime sound on landing
                    playVoxelChime();
                }
            } else {
                const settleAge = celliTime - data.settleTime;

                const jiggleFactor = Math.max(0, 1 - settleAge * 0.5);
                data.jigglePhase += dt * 20;
                const jiggleX = Math.sin(data.jigglePhase) * 0.003 * jiggleFactor;
                const jiggleY = Math.cos(data.jigglePhase * 1.3) * 0.002 * jiggleFactor;

                let posX = data.targetX + jiggleX;
                let posY = data.targetY + jiggleY;

                const scaleBounce = settleAge < 0.3 ? 1.0 + (1.0 - settleAge / 0.3) * 0.15 : 1.0;
                let scaleValue = data.baseScale * scaleBounce;

                data.flickerPhase += dt * 8;
                const brightProgress = Math.min(1, settleAge * 0.25);
                let opacityTarget = THREE.MathUtils.lerp(0.1, 0.8, brightProgress) + Math.sin(data.flickerPhase) * 0.15;
                let edgeOpacity = THREE.MathUtils.lerp(0.4, 0.3, brightProgress);
                let baseColor = THREE.MathUtils.lerp(0.2, 1.0, brightProgress);

                let pulseTime = 0;
                let reactionActive = false;

                if (celliBackspaceSequenceStarted && t >= celliBackspaceSequenceTime) {
                    reactionActive = true;
                    const reactionElapsed = t - celliBackspaceSequenceTime;
                    const vibrateDuration = 1.1;
                    if (reactionElapsed < vibrateDuration) {
                        const intensity = THREE.MathUtils.lerp(0.08, 0.0, reactionElapsed / vibrateDuration);
                        posX += (Math.random() - 0.5) * intensity;
                        posY += (Math.random() - 0.5) * intensity;
                        opacityTarget = Math.min(1, opacityTarget + 0.2);
                        edgeOpacity = Math.min(0.85, edgeOpacity + 0.25);
                        baseColor = Math.min(1.0, baseColor + 0.2);
                    } else {
                        pulseTime = reactionElapsed - vibrateDuration;
                        if (!data.backspaceTransformed) {
                            data.backspaceTransformed = true;
                            voxel.geometry = roundedVoxelGeo.clone();
                            const newMat = cellShadeBaseMaterial.clone();
                            voxel.material.dispose();
                            voxel.material = newMat;
                            if (data.edges) {
                                voxel.remove(data.edges);
                            }
                            const newEdges = new THREE.LineSegments(roundedEdgesGeo, cellShadeEdgeMaterial.clone());
                            voxel.add(newEdges);
                            data.edges = newEdges;
                        }
                        const pulse = 1 + 0.08 * Math.sin(pulseTime * 4 + data.backspacePulseOffset);
                        scaleValue = data.baseScale * pulse;
                        opacityTarget = 0.88 + 0.08 * Math.sin(pulseTime * 3 + data.backspacePulseOffset);
                        edgeOpacity = 0.78 + 0.12 * Math.sin(pulseTime * 5 + data.backspacePulseOffset);
                        posX += Math.sin(pulseTime * 2 + data.backspacePulseOffset) * 0.008;
                        posY += Math.cos(pulseTime * 2.2 + data.backspacePulseOffset) * 0.008;
                        baseColor = 1.0;
                    }
                }

                // Only set default position/scale if not in snap animation
                if (!snapTogetherStarted || !data.backspaceTransformed) {
                    voxel.position.x = posX;
                    voxel.position.y = posY;
                    voxel.scale.set(scaleValue, scaleValue, scaleValue);
                }

                if (voxel.material) {
                    if (data.backspaceTransformed) {
                        // If VisiCalc green transition has started, skip all other color logic
                        if (visiCalcGreenTransitionStarted) {
                            // VisiCalc green color is handled in snap-together animation below
                            // Don't override it here
                        } else if (endColorTransitionStart > 0) {
                            // Handle END sequence color transitions
                            const colors = {
                                yellow: { r: 1.0, g: 0.95, b: 0.3 },
                                magenta: { r: 0.95, g: 0.2, b: 0.4 },
                                cyan: { r: 0.2, g: 0.7, b: 0.95 },
                                green: { r: 0.3, g: 0.9, b: 0.4 }
                            };
                            
                            const transitionDuration = 0.6; // 600ms
                            const elapsed = t - endColorTransitionStart;
                            const progress = THREE.MathUtils.clamp(elapsed / transitionDuration, 0, 1);
                            
                            const fromColor = colors[endColorPrevState];
                            const toColor = colors[endColorState];
                            
                            const r = THREE.MathUtils.lerp(fromColor.r, toColor.r, progress);
                            const g = THREE.MathUtils.lerp(fromColor.g, toColor.g, progress);
                            const b = THREE.MathUtils.lerp(fromColor.b, toColor.b, progress);
                            
                            // Static color for green (pixel art style), pulse for others
                            if (endColorState === 'green' && progress >= 1) {
                                voxel.material.color.setRGB(0.3, 0.9, 0.4);
                                voxel.material.opacity = 0.95;
                            } else if (progress >= 1) {
                                // Transition complete - show final color with pulse
                                const pulse = Math.sin(t * 2 + data.backspacePulseOffset) * 0.05;
                                voxel.material.color.setRGB(toColor.r, toColor.g, toColor.b);
                                voxel.material.opacity = 0.9 + pulse;
                            } else {
                                // Mid-transition
                                const pulse = Math.sin(t * 2 + data.backspacePulseOffset) * 0.05;
                                voxel.material.color.setRGB(r, g, b);
                                voxel.material.opacity = 0.9 + pulse;
                            }
                        } else {
                            // Yellow glowing pulse for initial yellow state
                            const yellowPulse = Math.sin(t * 2 + data.backspacePulseOffset);
                            voxel.material.opacity = 0.9 + 0.05 * yellowPulse;
                            const yellowB = 0.3 + 0.1 * yellowPulse;
                            voxel.material.color.setRGB(1.0, 0.95, yellowB);
                        }
                    } else {
                        voxel.material.opacity = opacityTarget;
                        voxel.material.color.setRGB(baseColor, baseColor, baseColor);
                    }
                }

                if (data.edges && data.edges.material) {
                    if (data.backspaceTransformed) {
                        // Handle snap-together: fade out edges DURING green transition
                        if (snapTogetherStarted) {
                            const snapElapsed = t - snapTogetherTime;
                            const vibrateDuration = 0.4;
                            const jiggleDuration = 0.5;
                            const greenTransitionDuration = 0.3;
                            
                            // Fade out edges during green transition
                            if (snapElapsed >= vibrateDuration + jiggleDuration) {
                                // Green transition has started or finished - no edges
                                data.edges.material.opacity = 0;
                                data.edges.visible = false;
                            } else if (snapElapsed >= vibrateDuration) {
                                // During jiggle - start fading
                                const fadeProgress = (snapElapsed - vibrateDuration) / jiggleDuration;
                                data.edges.material.opacity = THREE.MathUtils.lerp(0.6, 0, fadeProgress);
                            }
                        } else {
                            // Edge colors based on END state
                            if (endColorState === 'magenta') {
                                data.edges.material.color.setRGB(1.0, 0.3, 0.5);
                                data.edges.material.opacity = 0.6;
                            } else if (endColorState === 'cyan') {
                                data.edges.material.color.setRGB(0.3, 0.8, 1.0);
                                data.edges.material.opacity = 0.6;
                            } else if (endColorState === 'green') {
                                data.edges.material.color.setRGB(0.4, 1.0, 0.5);
                                data.edges.material.opacity = 0.6;
                            } else {
                                // Yellow edges
                                data.edges.material.color.setRGB(1.0, 0.9, 0.4);
                                data.edges.material.opacity = 0.6 + 0.1 * Math.sin(t * 2.5 + data.backspacePulseOffset);
                            }
                        }
                    } else {
                        data.edges.material.opacity = THREE.MathUtils.clamp(edgeOpacity, 0, 1);
                    }
                }
                
                // Snap-together animation: vibration, then jiggle, then turn green
                if (snapTogetherStarted && data.backspaceTransformed) {
                    // Initialize snap time on first frame
                    if (snapTogetherTime === 0) {
                        snapTogetherTime = t;
                        console.log('⏱️ Snap animation started at t =', t);
                    }
                    
                    const snapElapsed = t - snapTogetherTime;
                    const vibrateDuration = 0.4;
                    const jiggleDuration = 0.5;
                    const greenTransitionDuration = 0.3;
                    const flatHoldDuration = 0.4; // Hold as flat pixels before shrinking
                    
                    
                    if (snapElapsed < vibrateDuration) {
                        // High-frequency vibration
                        const vibrateIntensity = 0.015 * (1 - snapElapsed / vibrateDuration);
                        posX += (Math.random() - 0.5) * vibrateIntensity;
                        posY += (Math.random() - 0.5) * vibrateIntensity;
                        voxel.position.x = posX;
                        voxel.position.y = posY;
                    } else if (snapElapsed < vibrateDuration + jiggleDuration) {
                        // Snap closer + jiggle
                        const jiggleProgress = (snapElapsed - vibrateDuration) / jiggleDuration;
                        const jiggleIntensity = 0.008 * (1 - jiggleProgress);
                        
                        // Pull voxels toward their letter center
                        const targetCenterX = data.targetX;
                        const snapAmount = jiggleProgress * 0.3;
                        posX = THREE.MathUtils.lerp(posX, targetCenterX, snapAmount * 0.1);
                        posX += Math.sin(t * 15 + data.backspacePulseOffset) * jiggleIntensity;
                        posY += Math.cos(t * 18 + data.backspacePulseOffset) * jiggleIntensity;
                        
                        voxel.position.x = posX;
                        voxel.position.y = posY;
                    } else if (snapElapsed < vibrateDuration + jiggleDuration + greenTransitionDuration) {
                        // Transition to VisiCalc green - turn off bloom immediately
                        if (!visiCalcGreenTransitionStarted) {
                            visiCalcGreenTransitionStarted = true;
                            bloomPass.strength = 0.0; // Immediately turn off bloom
                            console.log('💚 Green transition started - bloom OFF, edges should be INVISIBLE');
                            
                            // REMOVE all edges from scene permanently
                            voxels.forEach(v => {
                                if (v.userData.edges) {
                                    v.remove(v.userData.edges);
                                    v.userData.edges.geometry.dispose();
                                    v.userData.edges.material.dispose();
                                    v.userData.edges = null;
                                }
                            });
                            console.log('🗑️ ALL EDGES REMOVED FROM SCENE');
                        }
                        
                        const greenProgress = (snapElapsed - vibrateDuration - jiggleDuration) / greenTransitionDuration;
                        const greenColor = { r: 0.0, g: 1.0, b: 0.0 }; // Pure VisiCalc green
                        
                        // Get current color
                        const currentColor = voxel.material.color;
                        const r = THREE.MathUtils.lerp(currentColor.r, greenColor.r, greenProgress);
                        const g = THREE.MathUtils.lerp(currentColor.g, greenColor.g, greenProgress);
                        const b = THREE.MathUtils.lerp(currentColor.b, greenColor.b, greenProgress);
                        
                        voxel.material.color.setRGB(r, g, b);
                        voxel.material.opacity = 1.0; // Solid for pixel art
                        
                        // Keep bloom off
                        bloomPass.strength = 0.0;
                        
                        // Collapse into tighter mono-spaced grid
                        const monoSpacing = 0.022; // Tight pixel spacing
                        const monoX = data.gridCol * monoSpacing;
                        const monoY = -data.gridRow * monoSpacing;
                        const letterOffsetX = data.letterIdx * 5 * monoSpacing; // 5 columns per letter
                        
                        posX = THREE.MathUtils.lerp(data.targetX, letterOffsetX + monoX, greenProgress);
                        posY = THREE.MathUtils.lerp(data.targetY, monoY, greenProgress);
                        
                        voxel.position.x = posX;
                        voxel.position.y = posY;
                        voxel.scale.set(data.baseScale * 0.95, data.baseScale * 0.95, data.baseScale * 0.95);
                    } else if (snapElapsed < vibrateDuration + jiggleDuration + greenTransitionDuration + flatHoldDuration) {
                        // Hold as flat green pixels in mono-spaced positions
                        bloomPass.strength = 0.0;
                        voxel.material.color.setRGB(0.0, 1.0, 0.0);
                        voxel.material.opacity = 1.0;
                        
                        // Hold at mono-spaced positions
                        const monoSpacing = 0.022;
                        const monoX = data.gridCol * monoSpacing;
                        const monoY = -data.gridRow * monoSpacing;
                        const letterOffsetX = data.letterIdx * 5 * monoSpacing;
                        
                        voxel.position.x = letterOffsetX + monoX;
                        voxel.position.y = monoY;
                        voxel.scale.set(data.baseScale * 0.95, data.baseScale * 0.95, data.baseScale * 0.95);
                    } else {
                        // After flat hold, start move to corner
                        if (!celliMoveToCornerStarted) {
                            celliMoveToCornerStarted = true;
                            celliMoveToCornerTime = t;
                            bloomPass.strength = 0.0;
                            console.log('🎯 Move to corner started at t =', t);
                        }
                    }
                    
                    // Move CELLI to corner animation (runs after flat hold)
                    if (celliMoveToCornerStarted) {
                        const moveElapsed = t - celliMoveToCornerTime;
                        const collapseDuration = 0.6; // Collapse to center
                        const expandDuration = 0.8;   // Expand into VisiCell position
                        const totalMoveDuration = collapseDuration + expandDuration;
                        
                        // Keep bloom off for flat pixel look
                        bloomPass.strength = 0.0;
                        
                        // Keep VisiCalc green color during movement - flat, no glow
                        voxel.material.color.setRGB(0.0, 1.0, 0.0);
                        voxel.material.opacity = 1.0;
                        
                        // Store mono-spaced starting position if not set
                        if (!data.monoStartX) {
                            const monoSpacing = 0.022;
                            const monoX = data.gridCol * monoSpacing;
                            const monoY = -data.gridRow * monoSpacing;
                            const letterOffsetX = data.letterIdx * 5 * monoSpacing;
                            data.monoStartX = letterOffsetX + monoX;
                            data.monoStartY = monoY;
                        }
                        
                        if (moveElapsed < collapseDuration) {
                            // Phase 1: Organic collapse to center with wave motion
                            const collapseProgress = moveElapsed / collapseDuration;
                            const collapseEased = collapseProgress * collapseProgress * (3 - 2 * collapseProgress);
                            
                            // Add wave motion based on voxel index for organic feel
                            const waveOffset = (data.letterIdx * 10 + data.gridRow * 3 + data.gridCol) * 0.05;
                            const waveDelay = Math.max(0, collapseProgress - waveOffset);
                            const waveEased = Math.min(1, waveDelay * 1.3);
                            const waveSine = Math.sin(waveEased * Math.PI);
                            
                            posX = THREE.MathUtils.lerp(data.monoStartX, 0, waveEased);
                            posY = THREE.MathUtils.lerp(data.monoStartY, 0, waveEased);
                            
                            // Add slight orbital motion during collapse
                            const orbitAngle = waveEased * Math.PI * 2;
                            posX += Math.cos(orbitAngle) * (1 - waveEased) * 0.015;
                            posY += Math.sin(orbitAngle) * (1 - waveEased) * 0.015;
                            
                            voxel.position.x = posX;
                            voxel.position.y = posY;
                            
                            // Shrink with pulse
                            const pulse = waveSine * 0.15;
                            const currentScale = THREE.MathUtils.lerp(data.baseScale * 0.95, data.baseScale * 0.3, waveEased) * (1 + pulse);
                            voxel.scale.set(currentScale, currentScale, currentScale);
                            
                            // Keep fully visible during collapse
                            voxel.material.opacity = 1.0;
                        } else if (moveElapsed < totalMoveDuration) {
                            // Phase 2: Expand into VisiCell position
                            const expandProgress = (moveElapsed - collapseDuration) / expandDuration;
                            const expandEased = expandProgress < 0.5 ? 
                                2 * expandProgress * expandProgress : 
                                1 - Math.pow(-2 * expandProgress + 2, 2) / 2;
                            
                            // Target position: top-left corner (where "A1: CELLI" appears)
                            const targetX = -0.85;
                            const targetY = 0.75;
                            const targetScale = 0.45; // Smaller for VisiCell text
                            
                            // Calculate target offset based on grid position
                            const visiCellSpacing = 0.018; // Tighter for VisiCell
                            const targetOffsetX = data.gridCol * visiCellSpacing;
                            const targetOffsetY = -data.gridRow * visiCellSpacing;
                            const targetLetterOffset = data.letterIdx * 5 * visiCellSpacing;
                            
                            posX = THREE.MathUtils.lerp(0, targetX + targetLetterOffset + targetOffsetX, expandEased);
                            posY = THREE.MathUtils.lerp(0, targetY + targetOffsetY, expandEased);
                            
                            voxel.position.x = posX;
                            voxel.position.y = posY;
                            
                            // Expand from collapsed size to target size
                            const currentScale = THREE.MathUtils.lerp(data.baseScale * 0.3, data.baseScale * targetScale, expandEased);
                            voxel.scale.set(currentScale, currentScale, currentScale);
                        } else {
                            // Hold at final VisiCell position
                            const targetX = -0.85;
                            const targetY = 0.75;
                            const targetScale = 0.45;
                            const visiCellSpacing = 0.018;
                            const targetOffsetX = data.gridCol * visiCellSpacing;
                            const targetOffsetY = -data.gridRow * visiCellSpacing;
                            const targetLetterOffset = data.letterIdx * 5 * visiCellSpacing;
                            
                            voxel.position.x = targetX + targetLetterOffset + targetOffsetX;
                            voxel.position.y = targetY + targetOffsetY;
                            voxel.scale.set(data.baseScale * targetScale, data.baseScale * targetScale, data.baseScale * targetScale);
                            
                            // Show VisiCell once animation is complete (only trigger once)
                            if (!visiCalcShown) {
                                visiCalcShown = true;
                                console.log('✅ Move-to-corner animation complete, showing VisiCell');
                                showVisiCalc();
                            }
                        }
                    }
                }
            }
        });

        if (!bowHasTriggered) {
            const allSettled = voxels.every(voxel => voxel.userData && voxel.userData.settled);
            if (allSettled) {
                animateSkipToBow();
            }
        }

        updateBowVoxelPresence();
    }

    // Restore one voxel from the glitched stack with fritz effect
    function restoreOneLetter() {
        if (restoredLetters >= lettersToRestore.length) return false;
        
        const letterKey = lettersToRestore[restoredLetters];
        const letterVoxelsList = letterVoxels[letterKey];
        
        if (!letterVoxelsList || letterVoxelsList.length === 0) return false;
        
        // Play electrical fritz sound
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const now = audioCtx.currentTime;
        
        // Bigger fritz sound for whole letter
        const buzz = audioCtx.createOscillator();
        const buzzGain = audioCtx.createGain();
        
        buzz.type = 'sawtooth';
        buzz.frequency.setValueAtTime(150, now);
        buzz.frequency.exponentialRampToValueAtTime(100, now + 0.25);
        
        buzzGain.gain.setValueAtTime(0, now);
        buzzGain.gain.linearRampToValueAtTime(0.1, now + 0.02);
        buzzGain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
        
        buzz.connect(buzzGain);
        buzzGain.connect(audioCtx.destination);
        buzz.start(now);
        buzz.stop(now + 0.25);
        
        // Restore all voxels in this letter with staggered timing
        letterVoxelsList.forEach((voxel, idx) => {
            const data = voxel.userData;
            const delay = idx * 30; // Stagger by 30ms per voxel
            
            setTimeout(() => {
                // Make visible again
                voxel.visible = true;
                data.edges.visible = true;
                data.glitched = false;
                
                // Start with dark gray
                voxel.material.color.setRGB(0.15, 0.15, 0.15);
                data.edges.material.color.setRGB(0.2, 0.2, 0.2);
                voxel.material.opacity = 0.2;
                data.edges.material.opacity = 0.1;
                
                // Fritz flicker effect
                let flickerCount = 0;
                const maxFlickers = 6;
                const flickerInterval = setInterval(() => {
                    flickerCount++;
                    const flickerOn = flickerCount % 2 === 1;
                    
                    if (flickerOn) {
                        voxel.material.color.setRGB(0.9, 0.9, 0.9);
                        voxel.material.opacity = 0.85;
                        data.edges.material.opacity = 0.6;
                    } else {
                        voxel.material.color.setRGB(0.3, 0.3, 0.3);
                        voxel.material.opacity = 0.3;
                        data.edges.material.opacity = 0.2;
                    }
                    
                    if (flickerCount >= maxFlickers) {
                        clearInterval(flickerInterval);
                        
                        // Restore to normal white/bright state
                        const restoreStart = Date.now();
                        const restoreDuration = 200;
                        const restoreInterval = setInterval(() => {
                            const restoreProgress = (Date.now() - restoreStart) / restoreDuration;
                            if (restoreProgress >= 1) {
                                clearInterval(restoreInterval);
                                voxel.material.color.setRGB(0.8, 0.8, 0.8);
                                voxel.material.opacity = 0.75;
                                data.edges.material.opacity = 0.35;
                            } else {
                                const brightness = THREE.MathUtils.lerp(0.3, 0.8, restoreProgress);
                                voxel.material.color.setRGB(brightness, brightness, brightness);
                                voxel.material.opacity = THREE.MathUtils.lerp(0.3, 0.75, restoreProgress);
                                data.edges.material.opacity = THREE.MathUtils.lerp(0.2, 0.35, restoreProgress);
                            }
                        }, 16);
                    }
                }, 70);
            }, delay);
        });
        
        restoredLetters++;
        
        // If all 4 letters restored (C, E, L, L), automatically restore I and transform
        if (restoredLetters === 4) {
            setTimeout(() => {
                restoreIAndTransform();
            }, 800);
        }
        
        return true;
    }
    
    function restoreIAndTransform() {
        const iVoxels = letterVoxels.I;
        
        // Play final restoration sound
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const now = audioCtx.currentTime;
        
        const buzz = audioCtx.createOscillator();
        const buzzGain = audioCtx.createGain();
        
        buzz.type = 'sine';
        buzz.frequency.setValueAtTime(200, now);
        buzz.frequency.exponentialRampToValueAtTime(400, now + 0.4);
        
        buzzGain.gain.setValueAtTime(0, now);
        buzzGain.gain.linearRampToValueAtTime(0.12, now + 0.05);
        buzzGain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
        
        buzz.connect(buzzGain);
        buzzGain.connect(audioCtx.destination);
        buzz.start(now);
        buzz.stop(now + 0.4);
        
        // Restore I voxels quickly
        iVoxels.forEach((voxel, idx) => {
            const data = voxel.userData;
            const delay = idx * 20;
            
            setTimeout(() => {
                voxel.visible = true;
                data.edges.visible = true;
                data.glitched = false;
                voxel.material.color.setRGB(0.8, 0.8, 0.8);
                voxel.material.opacity = 0.75;
                data.edges.material.opacity = 0.35;
            }, delay);
        });
        
        // After brief pause, transform all CELLI to yellow rounded glow
        setTimeout(() => {
            transformCelliToYellow();
        }, 600);
    }
    
    function transformCelliToYellow() {
        // Transform all voxels to yellow with rounded corners, pop shrink/burst animation
        const skipBtn = document.getElementById('skipBtn');
        if (skipBtn) {
            // Re-show the bow when CELLI is restored - FULL BRIGHTNESS
            bowVisibleAsVoxel = true;
            skipBtn.classList.remove('voxel-hidden');
            skipBtn.classList.remove('magenta-phase');
            skipBtn.classList.remove('cyan-phase');
            skipBtn.style.pointerEvents = 'auto';
            skipBtn.style.opacity = '1'; // Full opacity restored
            skipBtn.style.filter = 'none'; // Clear any filters
            skipBtn.style.transition = 'opacity 0.6s ease, filter 0.6s ease';
            skipBtn.classList.add('illuminating');
            skipBtn.classList.add('golden-phase');
        }

        yellowTransformCompleteCount = 0;
        allYellowTransformed = false;
        const totalVoxels = voxels.length || 1;

        voxels.forEach((voxel, idx) => {
            const data = voxel.userData;
            const delay = idx * 15; // Stagger transformation
            
            setTimeout(() => {
                // Phase 1: Shrink inward (pop preparation)
                const shrinkStart = Date.now();
                const shrinkDuration = 150;
                
                const shrinkInterval = setInterval(() => {
                    const progress = (Date.now() - shrinkStart) / shrinkDuration;
                    if (progress >= 1) {
                        clearInterval(shrinkInterval);
                        
                        // Phase 2: Burst outward + transform to rounded + yellow color
                        const burstStart = Date.now();
                        const burstDuration = 300;
                        
                        // Change to rounded geometry
                        voxel.geometry.dispose();
                        voxel.geometry = roundedVoxelGeo.clone();
                        voxel.remove(data.edges);
                        const newEdges = new THREE.LineSegments(roundedEdgesGeo, edgeMat.clone());
                        voxel.add(newEdges);
                        data.edges = newEdges;
                        
                        const burstInterval = setInterval(() => {
                            const burstProgress = (Date.now() - burstStart) / burstDuration;
                            if (burstProgress >= 1) {
                                clearInterval(burstInterval);
                                
                                // Phase 3: Settle to yellow
                                voxel.scale.set(data.baseScale, data.baseScale, data.baseScale);
                                voxel.material.color.setRGB(1.0, 0.95, 0.3);
                                voxel.material.opacity = 0.9;
                                data.edges.material.color.setRGB(1.0, 0.9, 0.4);
                                data.edges.material.opacity = 0.6;
                                if (!data.backspaceTransformed) {
                                    data.backspaceTransformed = true;
                                    yellowTransformCompleteCount++;
                                    if (yellowTransformCompleteCount >= totalVoxels) {
                                        allYellowTransformed = true;
                                        activateRoundedBow();
                                    }
                                }
                            } else {
                                // Burst scale and color change
                                const scale = data.baseScale * THREE.MathUtils.lerp(0.5, 1.15, burstProgress);
                                voxel.scale.set(scale, scale, scale);
                                
                                const r = THREE.MathUtils.lerp(0.8, 1.0, burstProgress);
                                const g = THREE.MathUtils.lerp(0.8, 0.95, burstProgress);
                                const b = THREE.MathUtils.lerp(0.8, 0.3, burstProgress);
                                voxel.material.color.setRGB(r, g, b);
                                data.edges.material.color.setRGB(
                                    THREE.MathUtils.lerp(0.8, 1.0, burstProgress),
                                    THREE.MathUtils.lerp(0.8, 0.9, burstProgress),
                                    0.4
                                );
                            }
                        }, 16);
                    } else {
                        // Shrink scale
                        const scale = data.baseScale * THREE.MathUtils.lerp(1.0, 0.5, progress);
                        voxel.scale.set(scale, scale, scale);
                    }
                }, 16);
            }, delay);
        });
    }

    function activateRoundedBow() {
        const skipBtn = document.getElementById('skipBtn');
        if (!skipBtn) return;

        if (!skipBtn.classList.contains('bow-shape')) {
            pendingRoundedBow = true;
            return;
        }

        skipBtn.classList.add('rounded-bow');
        pendingRoundedBow = false;
    }

    // Transform voxels to magenta-red (E input)
    function transformToMagentaRed() {
        endColorPrevState = endColorState;
        endColorState = 'magenta';
        endColorTransitionStart = totalTime;
        
        // Update bow to magenta color
        const skipBtn = document.getElementById('skipBtn');
        if (skipBtn) {
            skipBtn.classList.remove('golden-phase');
            skipBtn.classList.add('magenta-phase');
        }
    }
    
    // Transform voxels to cyan-blue (N input)
    function transformToCyanBlue() {
        endColorPrevState = endColorState;
        endColorState = 'cyan';
        endColorTransitionStart = totalTime;
        
        // Update bow to cyan color
        const skipBtn = document.getElementById('skipBtn');
        if (skipBtn) {
            skipBtn.classList.remove('magenta-phase');
            skipBtn.classList.add('cyan-phase');
        }
    }
    
    // Transform voxels to green and snap back to non-rounded (D input)
    function transformToGreenAndSquare() {
        console.log('🟢 transformToGreenAndSquare called');
        endColorPrevState = endColorState;
        endColorState = 'green';
        endColorTransitionStart = totalTime;

        const skipBtn = document.getElementById('skipBtn');
        if (skipBtn) {
            skipBtn.classList.remove('golden-phase');
            skipBtn.classList.remove('magenta-phase');
            skipBtn.classList.remove('cyan-phase');
            skipBtn.classList.remove('illuminating');
            // Fully fade out the bow
            skipBtn.style.transition = 'opacity 0.6s ease';
            skipBtn.style.opacity = '0';
            skipBtn.style.pointerEvents = 'none';
        }
        
        // Change back to square geometry immediately
        voxels.forEach((voxel, idx) => {
            const data = voxel.userData;
            if (!data.backspaceTransformed) return;
            
            setTimeout(() => {
                voxel.geometry.dispose();
                voxel.geometry = voxelGeo.clone();
                voxel.remove(data.edges);
                const newEdges = new THREE.LineSegments(edgesGeo, edgeMat.clone());
                voxel.add(newEdges);
                data.edges = newEdges;
            }, idx * 8);
        });
        
        // Start snap-together animation immediately (color transition happens simultaneously)
        snapTogetherStarted = true;
        console.log('🟢 snapTogetherStarted set to true');
        
        // VisiCell will be shown after animation completes (triggered in updateVoxels)
        // snapTogetherTime will be set on first frame in updateVoxels
    }
    
    function computeBowAnchorScreenPosition() {
        const cVoxels = letterVoxels.C || [];
        if (!cVoxels.length) return null;

        let minX = Infinity;
        let maxY = -Infinity;
        let sumX = 0;
        let sumY = 0;
        let count = 0;
        let topSumX = 0;
        let topSumY = 0;
        let topCount = 0;

        cVoxels.forEach((voxel) => {
            const data = voxel.userData;
            if (!data) return;
            minX = Math.min(minX, data.targetX);
            maxY = Math.max(maxY, data.targetY);
            sumX += data.targetX;
            sumY += data.targetY;
            count++;
            if (typeof data.gridRow === 'number' && data.gridRow <= 1) {
                topSumX += data.targetX;
                topSumY += data.targetY;
                topCount++;
            }
        });

        if (!Number.isFinite(minX) || !Number.isFinite(maxY) || count === 0) {
            return null;
        }

        const anchor = new THREE.Vector3(
            minX - voxelSize * 0.9,
            maxY + voxelSize * 1.4,
            0
        );
        anchor.project(camera);

        const focusTargetX = topCount > 0 ? topSumX / topCount : sumX / count;
        const focusTargetY = topCount > 0 ? topSumY / topCount : (sumY / count) - voxelSize * 0.4;
        const focus = new THREE.Vector3(focusTargetX, focusTargetY, 0);
        focus.project(camera);

        const anchorScreenX = (anchor.x + 1) / 2 * window.innerWidth;
        const anchorScreenY = (-anchor.y + 1) / 2 * window.innerHeight;
        const focusScreenX = (focus.x + 1) / 2 * window.innerWidth;
        const focusScreenY = (-focus.y + 1) / 2 * window.innerHeight;
        let rotation = Math.atan2(focusScreenY - anchorScreenY, focusScreenX - anchorScreenX) - Math.PI / 2;
        rotation -= Math.PI / 14;

        return {
            x: anchorScreenX,
            y: anchorScreenY,
            rotation
        };
    }

    function moveBowToTarget(immediate = false) {
        const skipBtn = document.getElementById('skipBtn');
        if (!skipBtn) return;

        const target = computeBowAnchorScreenPosition();
        if (!target) return;

        bowTargetCenter = target;
        bowTargetRotation = typeof target.rotation === 'number' ? target.rotation : 0;

        if (!bowCurrentCenter) {
            const rect = skipBtn.getBoundingClientRect();
            bowCurrentCenter = {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
            };
            bowCurrentRotation = 0;
        }

        if (immediate) {
            bowCurrentCenter = { ...bowTargetCenter };
            bowCurrentRotation = bowTargetRotation;
            skipBtn.style.position = 'fixed';
            skipBtn.style.left = `${bowTargetCenter.x}px`;
            skipBtn.style.top = `${bowTargetCenter.y}px`;
            skipBtn.style.bottom = 'auto';
            skipBtn.style.transform = `translate(-50%, -50%) rotate(${bowTargetRotation}rad) scale(1)`;
            return;
        }

        const start = { ...bowCurrentCenter };
        const startRotation = bowCurrentRotation;
        const duration = 1200;
        const startTime = performance.now();
        if (bowAnimationId) cancelAnimationFrame(bowAnimationId);

        function step(now) {
            const elapsed = now - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const eased = 1 - Math.pow(1 - progress, 3);
            const arcHeight = Math.min(window.innerHeight * 0.08, 70);
            const arc = Math.sin(progress * Math.PI) * arcHeight;

            const x = start.x + (bowTargetCenter.x - start.x) * eased;
            const y = start.y + (bowTargetCenter.y - start.y) * eased - arc;
            const rotation = startRotation + (bowTargetRotation - startRotation) * eased;

            bowCurrentCenter = { x, y };
            skipBtn.style.position = 'fixed';
            skipBtn.style.left = `${x}px`;
            skipBtn.style.top = `${y}px`;
            skipBtn.style.bottom = 'auto';
            const scale = 1 + 0.12 * (1 - eased);
            skipBtn.style.transform = `translate(-50%, -50%) rotate(${rotation}rad) scale(${scale})`;

            if (progress < 1) {
                bowAnimationId = requestAnimationFrame(step);
            } else {
                bowAnimationId = 0;
                bowCurrentCenter = { ...bowTargetCenter };
                bowCurrentRotation = bowTargetRotation;
                skipBtn.style.transform = `translate(-50%, -50%) rotate(${bowTargetRotation}rad) scale(1)`;
                bowActive = true;
            }
        }

        bowAnimationId = requestAnimationFrame(step);
    }

    function updateBowVoxelPresence() {
        const skipBtn = document.getElementById('skipBtn');
        if (!skipBtn) return;

        if (!skipBtn.classList.contains('bow-shape')) {
            return;
        }

        const cVoxels = letterVoxels.C || [];
        if (!cVoxels.length) return;

        let visibleCount = 0;
        let totalCount = 0;
        let totalOpacity = 0;
        cVoxels.forEach((voxel) => {
            const data = voxel.userData;
            if (!data) return;
            totalCount++;
            if (voxel.visible) {
                const opacity = voxel.material.opacity || 0;
                if (opacity > 0.01) {
                    visibleCount++;
                    totalOpacity += opacity;
                }
            }
        });

        if (totalCount === 0) return;

        // Match bow opacity to average voxel opacity
        const avgOpacity = visibleCount > 0 ? totalOpacity / visibleCount : 0;
        
        // If ANY voxels are invisible or fading, start hiding the bow
        if (visibleCount < totalCount || avgOpacity < 0.95) {
            // Match opacity EXACTLY to voxels, including going to 0
            skipBtn.style.opacity = avgOpacity.toString();
            
            // If fully invisible, mark as hidden
            if (avgOpacity < 0.01) {
                bowVisibleAsVoxel = false;
                skipBtn.classList.add('voxel-hidden');
                skipBtn.style.pointerEvents = 'none';
            }
        }
        // Don't automatically show it again - that's handled by restoreIAndTransform
    }

    // Animate skip triangles to form a bow above CELLI
    function animateSkipToBow({ immediate = false } = {}) {
        const skipBtn = document.getElementById('skipBtn');
        const tri1 = document.getElementById('skipTriangle1');
        const tri2 = document.getElementById('skipTriangle2');

        if (!skipBtn || !tri1 || !tri2) return;

        if (!immediate) {
            if (bowHasTriggered) return;
            bowHasTriggered = true;
        }

        skipBtn.classList.remove('hidden');
        skipBtn.classList.remove('voxel-hidden');
        if (!skipBtn.classList.contains('bow-lock')) {
            skipBtn.style.pointerEvents = 'auto';
        }
        tri1.style.transform = '';
        tri2.style.transform = '';
        skipBtn.classList.add('bow-lock');
        skipBtn.classList.add('bow-shape');

        if (pendingRoundedBow) {
            skipBtn.classList.add('rounded-bow');
            pendingRoundedBow = false;
        }

        bowActive = false;
        bowCurrentCenter = null;
        moveBowToTarget(immediate);
    }
    
    // Show VisiCell spreadsheet
    function showVisiCalc() {
        console.log('📺 showVisiCalc called!');
        
        // Mark as seen
        localStorage.setItem('megred_seen_visicell', 'true');
        
        // Fade out doorway
        const doorway = document.getElementById('doorway');
        if (doorway) {
            doorway.style.transition = 'opacity 0.5s ease';
            doorway.style.opacity = '0';
            console.log('📺 Doorway faded out');
        }
        
        // Create VisiCell overlay (appears behind 3D scene initially)
        const visiCalc = document.createElement('div');
        visiCalc.id = 'visicalc';
        visiCalc.style.cssText = `
            position: fixed;
            inset: 0;
            background: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            padding: 20px;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.8s ease;
            overflow: hidden;
        `;
        
        // Create VisiCell content (without CELLI in row 1 - the 3D pixels will be that)
        visiCalc.innerHTML = `
            <div style="border: 2px solid #0f0; padding: 10px; height: calc(100% - 40px); background: #000; opacity: 0; transition: opacity 0.6s ease;" id="visicalc-frame">
                <div style="border-bottom: 1px solid #0f0; padding-bottom: 5px; margin-bottom: 10px; opacity: 0; animation: fadeInVisi 0.4s ease forwards 0.2s; font-size: 13px; font-family: 'Courier New', monospace;">
                    <span style="float: left;">VISICELL</span>
                    <span style="float: right;">LOOMWORKS CELL</span>
                    <div style="clear: both;"></div>
                </div>
                <div style="font-family: 'Courier New', monospace; white-space: pre; line-height: 1.6; font-size: 13px; opacity: 0; animation: fadeInVisi 0.5s ease forwards 0.5s;">
>A1:
     A            B            C            D            E            F
1
2
3    LOOK
4
5    END
6
7    =STAR                     =T
8
9
10
11
12
13
14
15   =TRANSPOSE()
16
17
18
19
 20   LOOMWORKS
 21
 22
 23   <span class="visicell-note-line visicell-note-line--1">&gt;:(</span>
 24   <span class="visicell-note-line visicell-note-line--2">This isn't Stanley Parable. Don't try that again.</span>
                </div>
                <div id="visicellinput" style="position: absolute; bottom: 24px; left: 36px; right: auto; top: auto; border-top: 1px solid #0f0; padding-top: 10px; opacity: 0; animation: fadeInVisi 0.3s ease forwards 1s; cursor: text; font-family: 'VT323', 'Courier New', monospace; font-size: 16px; letter-spacing: 0.18em; z-index: 100; pointer-events: auto; text-align: left; text-transform: uppercase;">
                    <div id="visicellwarning" style="position: absolute; bottom: 100%; left: 0; margin-bottom: 10px; font-size: 13px; line-height: 1.6; font-family: 'Courier New', monospace; letter-spacing: 0.1em; opacity: 0; transition: all 0.3s ease; white-space: nowrap;"></div>
                    <span id="visicellprompt">ENTE<span style="animation: blink 1s step-end infinite;">_</span></span>
                </div>
            </div>
            <style>
                @keyframes fadeInVisi {
                    from { opacity: 0; transform: translateY(10px); }
                    to { opacity: 1; transform: translateY(0); }
                }
                @keyframes matrixShake {
                    0% { transform: translate(0, 0); }
                    25% { transform: translate(-2px, 2px); }
                    50% { transform: translate(2px, -2px); }
                    75% { transform: translate(-2px, -2px); }
                    100% { transform: translate(2px, 2px); }
                }
            </style>
        `;
        
        document.body.appendChild(visiCalc);
        
        // Snap VisiCell into view immediately
        visiCalc.style.opacity = '1';
        
        const frame = document.getElementById('visicalc-frame');
        if (frame) {
            frame.style.opacity = '1';
        }
        
        // Immediately show all content (override animations)
        const allAnimated = visiCalc.querySelectorAll('[style*="animation"]');
        allAnimated.forEach(el => {
            el.style.opacity = '1';
            el.style.animation = 'none';
        });
        
        // Setup terminal input system immediately
        setTimeout(() => {
            setupTerminalInput();
        }, 100);
        
        // Fade out 3D renderer immediately
        renderer.domElement.style.transition = 'opacity 0.5s ease';
        renderer.domElement.style.opacity = '0';
        
        // Stop rendering 3D scene
        setTimeout(() => {
            running = false;
        }, 500);
    }
    
    let terminalInput = 'ENTE';
    let terminalActive = false;
    let rInfectionStarted = false;
    let rInfectionStage = 0;
    let promptResetting = false;
    let promptClearInterval = null;
    let promptFillInterval = null;
    let rInfectionHalted = false;
    let clickWarningCount = 0;
    let barrelClickCount = 0;
    let madnessActivated = false;
    let rPromptHoverCount = 0;
    let enterCommandUsed = false; // Track if ENTER command was used
    
    function setupTerminalInput() {
        console.log('⌨️ Terminal input system activated');
        terminalActive = true;
        
        const inputEl = document.getElementById('visicellinput');
        const promptEl = document.getElementById('visicellprompt');
        const visiCalc = document.getElementById('visicalc');
        const frame = document.getElementById('visicalc-frame');
        if (!inputEl || !promptEl) return;
        
        // Create hidden input for mobile keyboard support
        const hiddenInput = document.createElement('input');
        hiddenInput.type = 'text';
        hiddenInput.id = 'visicell-mobile-input';
        hiddenInput.style.cssText = 'position: absolute; left: -9999px; opacity: 0; pointer-events: none;';
        hiddenInput.autocomplete = 'off';
        hiddenInput.autocapitalize = 'characters';
        document.body.appendChild(hiddenInput);
        
        // Tap/click on input area to focus hidden input (for mobile)
        inputEl.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent R infection trigger
            hiddenInput.focus();
            console.log('📱 Mobile input focused');
        });
        
        inputEl.addEventListener('touchstart', (e) => {
            e.stopPropagation(); // Prevent R infection trigger
            hiddenInput.focus();
            console.log('📱 Mobile input focused (touch)');
        });
        
        // Handle input from hidden field (for mobile)
        hiddenInput.addEventListener('beforeinput', (e) => {
            if (!terminalActive) return;
            e.preventDefault();
            
            if (promptResetting) {
                cancelPromptReset();
            }
            
            if (e.inputType === 'deleteContentBackward' || e.inputType === 'deleteContentForward') {
                if (terminalInput.length > 0) {
                    terminalInput = terminalInput.slice(0, -1);
                    updateTerminalPrompt();
                    evaluateTerminalInputDrift();
                }
            } else if (e.data && /[a-zA-Z0-9._]/.test(e.data)) {
                terminalInput += e.data.toUpperCase();
                updateTerminalPrompt();
                evaluateTerminalInputDrift();
            }
            
            // Clear the hidden input to allow continuous typing
            setTimeout(() => { hiddenInput.value = ''; }, 0);
        });
        
        // Fallback for input event
        hiddenInput.addEventListener('input', (e) => {
            if (!terminalActive) return;
            e.preventDefault();
            // Clear the hidden input
            hiddenInput.value = '';
        });
        
        // Show warning/prompt on hover
        if (visiCalc) {
            visiCalc.addEventListener('mouseenter', () => {
                const warning = document.getElementById('visicellwarning');
                if (warning && !rInfectionStarted) {
                    rPromptHoverCount++;
                    
                    if (madnessActivated) {
                        // Post-madness: Don't click warnings
                        const dontClickMessages = [
                            "Don't click!",
                            "Seriously, don't.",
                            "I'm warning you...",
                            "Fine. Click away.",
                            "Ah, who am I kidding?"
                        ];
                        warning.textContent = dontClickMessages[Math.min(rPromptHoverCount - 1, dontClickMessages.length - 1)];
                    } else {
                        // Pre-madness: Sarcastic R prompts
                        const rPrompts = [
                            "You could type R...",
                            "Type R. Just saying.",
                            "R. Type it.",
                            "TYPE R ALREADY.",
                            "R!!!",
                            "JUST TYPE THE LETTER R.",
                            "Fine, explore the void.",
                            "Or don't. See if I care."
                        ];
                        const randomPrompt = rPrompts[Math.min(rPromptHoverCount - 1, rPrompts.length - 1)];
                        warning.textContent = randomPrompt;
                    }
                    
                    warning.style.opacity = '1';
                    const glowIntensity = Math.min(rPromptHoverCount * 3, 15);
                    warning.style.textShadow = `0 0 ${glowIntensity}px #0f0, 0 0 ${glowIntensity * 2}px #0f0`;
                }
            });
            
            visiCalc.addEventListener('mouseleave', () => {
                const warning = document.getElementById('visicellwarning');
                if (warning && rPromptHoverCount < 8) {
                    warning.style.opacity = '0.3';
                }
            });
            
            // Clicking anywhere (except input area) triggers R infection
            visiCalc.addEventListener('click', (e) => {
                // Don't trigger if clicking on input area
                if (e.target.id === 'visicellinput' || e.target.id === 'visicellprompt' || e.target.closest('#visicellinput')) {
                    return;
                }
                // Don't trigger if ENTER command was used
                if (enterCommandUsed) {
                    console.log('🛑 ENTER was used - R infection disabled');
                    return;
                }
                if (terminalActive) {
                    triggerRInfection(frame);
                }
            });
        }
        
        // Handle keyboard input
        document.addEventListener('keydown', (e) => {
            if (!terminalActive) return;

            if (promptResetting) {
                cancelPromptReset();
            }

            if (e.key === 'Backspace') {
                e.preventDefault();
                if (terminalInput.length > 0) {
                    terminalInput = terminalInput.slice(0, -1);
                    updateTerminalPrompt();
                    evaluateTerminalInputDrift();
                }
            } else if (e.key === 'Enter') {
                e.preventDefault();
                handleTerminalCommand();
            } else if (e.key.length === 1 && /[a-zA-Z0-9._]/.test(e.key)) {
                e.preventDefault();
                terminalInput += e.key.toUpperCase();
                updateTerminalPrompt();
                evaluateTerminalInputDrift();
            }
        });

        updateTerminalPrompt();
        if (terminalInput !== 'ENTE') {
            schedulePromptToEnte({ immediateFill: true });
        }
    }
    
    function updateTerminalPrompt() {
        const promptEl = document.getElementById('visicellprompt');
        if (!promptEl) return;
        promptEl.innerHTML = terminalInput + '<span style="animation: blink 1s step-end infinite;">_</span>';
    }

    const validTerminalCommands = ['ENTER', 'EXIT', 'LEAVE', 'MYHOUSE.WAD', 'OURHOUSE.LOOM', 'MADNESS.LOOM'];

    function cancelPromptReset() {
        if (promptClearInterval) {
            clearInterval(promptClearInterval);
            promptClearInterval = null;
        }
        if (promptFillInterval) {
            clearInterval(promptFillInterval);
            promptFillInterval = null;
        }
        promptResetting = false;
    }

    function schedulePromptToEnte({ immediateFill = false } = {}) {
        if (!terminalActive) return;

        cancelPromptReset();
        promptResetting = true;

        const target = 'ENTE';

        const startFill = () => {
            let index = 0;
            promptFillInterval = setInterval(() => {
                if (!terminalActive) {
                    cancelPromptReset();
                    return;
                }

                if (index < target.length) {
                    terminalInput += target[index];
                    index++;
                    updateTerminalPrompt();
                } else {
                    cancelPromptReset();
                }
            }, 240);
        };

        if (!immediateFill && terminalInput.length > 0) {
            promptClearInterval = setInterval(() => {
                if (!terminalActive) {
                    cancelPromptReset();
                    return;
                }

                if (terminalInput.length > 0) {
                    terminalInput = terminalInput.slice(0, -1);
                    updateTerminalPrompt();
                } else {
                    clearInterval(promptClearInterval);
                    promptClearInterval = null;
                    startFill();
                }
            }, 260);
        } else {
            terminalInput = '';
            updateTerminalPrompt();
            startFill();
        }
    }

    function isValidTerminalPrefix(value) {
        if (!value) return true;
        return validTerminalCommands.some(cmd => cmd.startsWith(value));
    }

    function evaluateTerminalInputDrift() {
        if (!terminalActive || promptResetting) return;
        const value = terminalInput.toUpperCase();
        if (!value || isValidTerminalPrefix(value)) {
            return;
        }
        schedulePromptToEnte();
    }

    function handleTerminalCommand() {
        const cmd = terminalInput.trim();
        const frame = document.getElementById('visicalc-frame');
        console.log('🖥️ Terminal command:', cmd);
        
        // Check if R sequence is active and stop it if a valid command is entered
        const isValidCommand = validTerminalCommands.some(validCmd => validCmd === cmd.toUpperCase()) || 
                              cmd.toLowerCase() === 'myhouse.wad' || 
                              cmd.toLowerCase() === 'ourhouse.loom' || 
                              cmd.toLowerCase() === 'madness.loom';
        
        if (isValidCommand && (speechRActive || rInfectionStarted)) {
            stopRSequence();
            terminalResponse(frame, 'Thanks');
            // Short pause before processing command
            setTimeout(() => processCommand(cmd, frame), 800);
            return;
        }
        
        processCommand(cmd, frame);
    }
    
    function processCommand(cmd, frame) {
        if (cmd === 'ENTER') {
            // ENTER triggers VisiCell Sim and disables R sequence
            enterCommandUsed = true;
            console.log('✅ ENTER command used - R sequence permanently disabled');
            startVisiCellSim();
            return;
        } else if (cmd === 'EXIT') {
            triggerExitCube(frame);
            terminalInput = '';
            updateTerminalPrompt();
            schedulePromptToEnte({ immediateFill: true });
        } else if (cmd === 'LEAVE') {
            // LEAVE triggers Ozymandias puzzle first, then House of Leaves after solving
            if (!ozymandiasSolved) {
                startOzymandiasPuzzle();
            } else {
                // After Ozymandias is solved, LEAVE triggers the House of Leaves sequence
                triggerLeaveSequence(frame);
                terminalInput = '';
                updateTerminalPrompt();
                schedulePromptToEnte({ immediateFill: true });
            }
            return;
        } else if (cmd.toLowerCase() === 'myhouse.wad') {
            terminalResponse(frame, '"Too scary. How about OurHouse.loom?"');
        } else if (cmd.toLowerCase() === 'ourhouse.loom') {
            terminalResponse(frame, '"Huh... Not found. I must have renamed it. I asked my friends Crosby, Stills, Nash AND Young, none of them knew. Maybe wrong band."');
        } else if (cmd.toLowerCase() === 'madness.loom') {
            terminalInput = '';
            updateTerminalPrompt();
            schedulePromptToEnte({ immediateFill: true });
            triggerVictory(frame);
        } else {
            terminalResponse(frame, `Command not recognized: ${cmd}`);
        }
    }
    
    function terminalResponse(frame, message) {
        if (!frame) return;
        const responseDiv = document.createElement('div');
        responseDiv.style.cssText = 'margin-top: 10px; color: #0f0; font-family: "Courier New", monospace; font-size: 13px;';
        responseDiv.textContent = message;
        frame.appendChild(responseDiv);

        // Reset input
        terminalInput = '';
        updateTerminalPrompt();
        schedulePromptToEnte({ immediateFill: true });
    }
    
    let rInfectionProcessing = false;
    
    function triggerRInfection(frame) {
        if (!frame) return;
        
        // Check if halted
        if (rInfectionHalted) {
            console.log('🛑 R infection is halted, ignoring click');
            return;
        }
        
        // Prevent rapid clicking from breaking the sequence
        if (rInfectionProcessing) {
            console.log('⏸️ R infection already in progress, ignoring click');
            return;
        }
        
        if (rInfectionStarted) {
            console.log('🔴 R infection already started, ignoring additional clicks');
            return;
        }
        
        rInfectionStarted = true;
        rInfectionProcessing = true;
        rInfectionStage = 1;
        console.log('🔴 R infection stage 1 - infecting existing text');
        
        // Stage 1: Infect existing text characters with Rs
        progressRInfection(frame);
    }
    
    function progressRInfection(frame) {
        console.log('🔴 R infection stage', rInfectionStage);
        
        if (rInfectionStage === 1) {
            // Stage 1: Cascade Rs through existing text (but not input)
            const allText = frame.querySelectorAll('*:not(#rHint):not(#visicellinput):not(#visicellprompt)');
            const textNodes = [];
            allText.forEach(el => {
                // Skip input-related elements
                if (el.id === 'visicellinput' || el.id === 'visicellprompt' || el.closest('#visicellinput')) {
                    return;
                }
                if (el.childNodes.length > 0) {
                    el.childNodes.forEach(node => {
                        if (node.nodeType === Node.TEXT_NODE && node.textContent.trim()) {
                            textNodes.push(node);
                        }
                    });
                }
            });
            
            const originalTexts = textNodes.map(n => n.textContent);
            const infectionDuration = 2500;
            const infectionStart = Date.now();
            
            const infectionInterval = setInterval(() => {
                const elapsed = Date.now() - infectionStart;
                const progress = elapsed / infectionDuration;
                
                if (progress >= 1) {
                    clearInterval(infectionInterval);
                    // Auto-progress to stage 2 (type ASCII R)
                    setTimeout(() => {
                        rInfectionStage++;
                        progressRInfection(frame);
                    }, 800);
                } else {
                    textNodes.forEach((node, idx) => {
                        const nodeProgress = Math.max(0, progress - (idx * 0.03));
                        if (nodeProgress > 0) {
                            const original = originalTexts[idx];
                            const infected = original.split('').map((c) => {
                                if (c === ' ' || c === '\n') return c;
                                if (Math.random() < nodeProgress * 1.5) return 'R';
                                return c;
                            }).join('');
                            node.textContent = infected;
                        }
                    });
                }
            }, 50);
            
        } else if (rInfectionStage === 2) {
            // Stage 2: From infected text, organically type out ASCII R
            let rHint = document.getElementById('rHint');
            if (!rHint) {
                rHint = document.createElement('div');
                rHint.id = 'rHint';
                rHint.style.cssText = `
                    position: absolute;
                    top: 30%;
                    left: 50%;
                    transform: translateX(-50%);
                    font-family: 'Courier New', monospace;
                    white-space: pre;
                    text-align: left;
                    font-size: 13px;
                    line-height: 1.6;
                    color: #0f0;
                    opacity: 1;
                    pointer-events: none;
                    z-index: 55;
                `;
                rHint.classList.add('r-hint');
                rHint.style.textShadow = 'none';
                frame.appendChild(rHint);
            }
            
            const asciiR = `
RRRRRRRRRRRR
RRRRRRRRRRRR
RRRR     RRR
RRRR     RRR
RRRR     RRR
RRRRRRRRRRR
RRRRRRRRRR
RRRR  RRRR
RRRR   RRRR
RRRR    RRRR
RRRR     RRR
RRRR      RRR`;
            
            // Type out character by character with polished timing
            let charIndex = 0;
            const typeInterval = setInterval(() => {
                if (charIndex < asciiR.length) {
                    rHint.textContent = asciiR.substring(0, charIndex + 1);
                    charIndex++;
                } else {
                    clearInterval(typeInterval);
                    setTimeout(() => {
                        rHint.classList.add('glow');
                    }, 200);

                    setTimeout(() => {
                        rInfectionStage++;
                        progressRInfection(frame);
                    }, 1100);
                }
            }, 20); // Smooth, fast typing
            
        } else if (rInfectionStage === 3) {
            // Stage 3: From ASCII R, organically grow matrix data fall
            startMatrixDataFallOrganic(frame);
            
            // Auto-progress to forming R
            setTimeout(() => {
                rInfectionStage++;
                progressRInfection(frame);
            }, 3500);
            
        } else if (rInfectionStage === 4) {
            // Stage 4: Matrix stops and forms large falling R in BLACK (negative space)
            stopMatrixAndFormBlackR(frame, () => {
                rInfectionStage++;
                progressRInfection(frame);
            });

        } else if (rInfectionStage >= 5) {
            // Stage 5: Text-to-speech "R" (are) on loop
            playTextToSpeechR();
        }
    }
    
    function stopRSequence() {
        console.log('🛑 Stopping R sequence');
        rInfectionHalted = true;
        speechRActive = false;
        
        // Clear all timeouts
        if (speechRTimeout) {
            clearTimeout(speechRTimeout);
            speechRTimeout = null;
        }
        if (speechRGuardTimeout) {
            clearTimeout(speechRGuardTimeout);
            speechRGuardTimeout = null;
        }
        
        // Cancel speech synthesis
        if (window.speechSynthesis) {
            try { window.speechSynthesis.cancel(); } catch (err) {}
        }
        
        // Clear utterance
        if (speechRUtterance) {
            speechRUtterance.onend = null;
            speechRUtterance.onerror = null;
            speechRUtterance = null;
        }
        
        // Clear matrix animation
        if (matrixInterval) {
            clearInterval(matrixInterval);
            matrixInterval = null;
        }
        if (matrixAnimationFrameId) {
            cancelAnimationFrame(matrixAnimationFrameId);
            matrixAnimationFrameId = null;
        }
        
        // Clear all matrix heavy timers
        matrixHeavyTimers.forEach(timer => clearTimeout(timer));
        matrixHeavyTimers = [];
    }
    
    function playTextToSpeechR() {
        if (speechRActive) return;
        if (rInfectionHalted) {
            console.log('🛑 R speech halted, not starting');
            return;
        }
        speechRActive = true;

        const hasSpeechSynthesis = typeof window !== 'undefined' && 'speechSynthesis' in window;
        if (speechRTimeout) {
            clearTimeout(speechRTimeout);
            speechRTimeout = null;
        }
        if (speechRGuardTimeout) {
            clearTimeout(speechRGuardTimeout);
            speechRGuardTimeout = null;
        }
        if (hasSpeechSynthesis) {
            try { window.speechSynthesis.cancel(); } catch (err) {}
        }
        speechRUtterance = null;
        
        // Randomize speech parameters
        const rates = [0.6, 0.8, 1.0, 1.2];
        const pitches = [0.8, 1.0, 1.2, 1.4];
        const phrases = ['are', 'arrr', 'R', 'are you?', 'arrrrre'];
        const randomPhrase = phrases[Math.floor(Math.random() * phrases.length)];
        const randomRate = rates[Math.floor(Math.random() * rates.length)];
        const randomPitch = pitches[Math.floor(Math.random() * pitches.length)];
        
        const speechSequence = [
            { mode: 'manual', fallback: { duration: 0.58, filterStart: 690, filterEnd: 520, gainPeak: 0.16, growl: 0.18 } },
            { mode: 'manual', fallback: { duration: 0.64, filterStart: 760, filterEnd: 500, gainPeak: 0.18, growl: 0.26, noise: 0.035 } },
            { mode: 'manual', fallback: { duration: 0.7, filterStart: 720, filterEnd: 460, gainPeak: 0.2, growl: 0.32, noise: 0.05, crackle: 0.02 } },
            { mode: 'tts', text: 'Manual R attempt unsuccessful. Switching to sanitized narration.', rate: 1.02, pitch: 1.12, volume: 0.98, distortion: { duration: 1.2, intensity: 0.05 } },
            { mode: 'tts', text: 'R. Just the letter R. Please press it.', rate: 0.94, pitch: 1.04, volume: 0.94 },
            { mode: 'tts', text: 'VisiCell is still waiting on a single R. Kind of embarrassing for both of us.', rate: 0.9, pitch: 1, volume: 0.92, distortion: { duration: 1.4, intensity: 0.08 } },
            { mode: 'tts', text: 'Please deposit a solitary R. Thank you.', rate: 0.88, pitch: 1.02, volume: 0.9 },
            { mode: 'tts', text: 'I am literally pleading now. R. Pretty please.', rate: 0.82, pitch: 0.98, volume: 0.86, distortion: { duration: 1.6, intensity: 0.1 } },
            { mode: 'tts', text: 'Oh look, another timeless moment with zero R input. Delightful.', rate: 0.78, pitch: 1.08, volume: 0.83, distortion: { duration: 1.2, intensity: 0.07 } },
            { mode: 'tts', text: 'Is the keyboard decorative? Because the R key would love a purpose.', rate: 0.75, pitch: 1, volume: 0.8 },
            { mode: 'tts', text: 'New tactic: haunting monotone. R. R. R. Consider yourself haunted.', rate: 0.7, pitch: 0.92, volume: 0.74, distortion: { duration: 1.8, intensity: 0.12 } },
            { mode: 'tts', text: 'I can get quieter. Watch. R.', rate: 0.66, pitch: 0.88, volume: 0.55 },
            { mode: 'tts', text: 'This is my quiet voice. Please press R before it becomes my disappointed voice.', rate: 0.64, pitch: 0.86, volume: 0.45 },
            { mode: 'tts', text: 'Snark subroutine engaged: refusing to press R is a bold creative choice.', rate: 0.68, pitch: 0.95, volume: 0.6, distortion: { duration: 1.5, intensity: 0.09 } },
            { mode: 'tts', text: 'Last call before I start narrating your inaction like a documentary. R.', rate: 0.6, pitch: 0.9, volume: 0.5 },
            { mode: 'tts', text: 'Fine. I will wait here... very quietly... repeating... r.', rate: 0.56, pitch: 0.82, volume: 0.38, distortion: { duration: 2.2, intensity: 0.05 } },
            { mode: 'tts', text: 'Are you there?', rate: 0.72, pitch: 0.9, volume: 0.68, delay: 2800, distortion: { duration: 1, intensity: 0.06 } },
            { mode: 'tts', text: 'Haha. Get it? Are? R.', rate: 0.74, pitch: 1.05, volume: 0.72, delay: 3200, distortion: { duration: 1.4, intensity: 0.12 } },
            { mode: 'tts', text: 'An ode to the letter R: resonant, restless, river bent, the hinge of words that crave momentum.', rate: 0.78, pitch: 1.08, volume: 0.8, delay: 3800, distortion: { duration: 1.2, intensity: 0.07 } },
            { mode: 'tts', text: 'Ode refrain: it growls in the throat, rolls into courage, and turns raw code into roaring connection.', rate: 0.76, pitch: 1.04, volume: 0.78, delay: 4200, distortion: { duration: 1.6, intensity: 0.1 } },
            { mode: 'tts', text: 'Phone support voice: A as in Apple, B as in Bravo, C as in Candle, D as in Delta, E as in Echo, F as in Foxtrot, G as in Garden, H as in Hotel, I as in Indigo, J as in Juliet, K as in Kilo, L as in Lemon, M as in Mountain, N as in November, O as in Ocean, P as in Pepper, Q as in Queen, R as in Radiance, S as in Sunshine, T as in Tango, U as in Umbrella, V as in Violet, W as in Willow, X as in Xylophone, Y as in Yellow, Z as in Zephyr.', rate: 0.8, pitch: 1.02, volume: 0.82, delay: 5800, distortion: { duration: 2.4, intensity: 0.08 } },
            { mode: 'tts', text: 'Military style: Alpha, Bravo, Charlie, Delta, Echo, Foxtrot, Golf, Hotel, India, Juliet, Kilo, Lima, Mike, November, Oscar, Papa, Quebec, Romeo, Sierra, Tango, Uniform, Victor, Whiskey, X ray, Yankee, Zulu. R for Romeo.', rate: 0.82, pitch: 0.96, volume: 0.84, delay: 5200, distortion: { duration: 2, intensity: 0.11 } },
            { mode: 'tts', text: 'I am still here, sounding more human than my diagnostics predicted, waiting for the real R.', rate: 0.74, pitch: 0.94, volume: 0.7, delay: 3600, distortion: { duration: 1.8, intensity: 0.13 } }
        ];
        const manualAttemptCount = speechSequence.filter(item => item.mode === 'manual').length;
        let phraseIndex = 0;

        if (hasSpeechSynthesis && !speechRVoice) {
            const assignVoice = () => {
                const voices = window.speechSynthesis.getVoices();
                if (!voices || !voices.length) return;
                const neuralPreferred = voices.find(v => /neural|natural/i.test(`${v.name} ${v.voiceURI || ''}`));
                if (neuralPreferred) {
                    speechRVoice = neuralPreferred;
                }
                if (!speechRVoice) {
                    const preferred = [
                        'Microsoft Aria Online (Natural)',
                        'Microsoft Jenny Online (Natural)',
                        'Microsoft Guy Online (Natural)',
                        'Google UK English Female',
                        'Google US English',
                        'Google UK English Male',
                        'Microsoft Aria Online',
                        'Microsoft Jenny Online'
                    ];
                    for (const name of preferred) {
                        const match = voices.find(v => v.name && v.name.includes(name));
                        if (match) {
                            speechRVoice = match;
                            break;
                        }
                    }
                }
                if (!speechRVoice) {
                    const localHuman = voices.find(v => v.localService && /en/i.test(v.lang || ''));
                    speechRVoice = localHuman || voices.find(v => /en/i.test(v.lang || '')) || voices[0] || null;
                }
                if (speechRVoice && window.speechSynthesis.removeEventListener) {
                    window.speechSynthesis.removeEventListener('voiceschanged', assignVoice);
                }
            };
            assignVoice();
            if (!speechRVoice && window.speechSynthesis.addEventListener) {
                window.speechSynthesis.addEventListener('voiceschanged', assignVoice);
            }
        }

        const speakFallback = (options = {}) => {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const now = audioCtx.currentTime;
            const {
                duration = 0.58,
                baseFrequency = 126,
                filterStart = 720,
                filterEnd = 510,
                q = 5.5,
                gainAttack = 0.08,
                gainPeak = 0.18,
                gainRelease = 0.1,
                gainEnd = 0.001,
                waveform = 'sawtooth',
                growl = 0,
                noise = 0,
                crackle = 0
            } = options;

            const vowelOsc = audioCtx.createOscillator();
            const vowelGain = audioCtx.createGain();
            const vowelFilter = audioCtx.createBiquadFilter();

            vowelOsc.type = waveform;
            vowelOsc.frequency.setValueAtTime(baseFrequency, now);

            vowelFilter.type = 'bandpass';
            vowelFilter.frequency.setValueAtTime(filterStart, now);
            vowelFilter.frequency.linearRampToValueAtTime(filterEnd, now + duration);
            vowelFilter.Q.value = q;

            vowelGain.gain.setValueAtTime(0, now);
            vowelGain.gain.linearRampToValueAtTime(gainPeak, now + gainAttack);
            vowelGain.gain.linearRampToValueAtTime(gainPeak * 0.75, now + duration - gainRelease);
            vowelGain.gain.linearRampToValueAtTime(gainEnd, now + duration + 0.05);

            vowelOsc.connect(vowelFilter);
            vowelFilter.connect(vowelGain);
            vowelGain.connect(audioCtx.destination);

            if (growl > 0) {
                const growlOsc = audioCtx.createOscillator();
                const growlGain = audioCtx.createGain();
                growlOsc.type = 'square';
                growlOsc.frequency.setValueAtTime(Math.max(40, baseFrequency * 0.45), now);
                growlGain.gain.setValueAtTime(0, now);
                growlGain.gain.linearRampToValueAtTime(growl * 0.45, now + 0.12);
                growlGain.gain.linearRampToValueAtTime(0.0001, now + duration);
                growlOsc.connect(growlGain);
                growlGain.connect(audioCtx.destination);
                growlOsc.start(now);
                growlOsc.stop(now + duration);
            }

            if (noise > 0 || crackle > 0) {
                const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * duration, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) {
                    const baseNoise = (Math.random() * 2 - 1) * noise;
                    const crackleSample = (i % Math.max(1, Math.round(audioCtx.sampleRate * 0.015)) === 0) ? (Math.random() * 2 - 1) * crackle : 0;
                    data[i] = baseNoise + crackleSample;
                }
                const noiseSource = audioCtx.createBufferSource();
                const noiseGain = audioCtx.createGain();
                noiseSource.buffer = buffer;
                noiseGain.gain.setValueAtTime(noise + crackle, now);
                noiseGain.gain.linearRampToValueAtTime(0.0001, now + duration);
                noiseSource.connect(noiseGain);
                noiseGain.connect(audioCtx.destination);
                noiseSource.start(now);
                noiseSource.stop(now + duration);
            }

            vowelOsc.start(now);
            vowelOsc.stop(now + duration);
        };

        const triggerDistortion = (duration = 1.4, intensity = 0.08) => {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const now = audioCtx.currentTime;
            const buffer = audioCtx.createBuffer(1, Math.max(1, Math.floor(audioCtx.sampleRate * duration)), audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < data.length; i++) {
                const t = i / audioCtx.sampleRate;
                const flutter = Math.sin(t * 320) * 0.3 + Math.sin(t * 90) * 0.2;
                data[i] = (Math.random() * 2 - 1) * intensity * (0.6 + flutter * 0.4);
            }
            const source = audioCtx.createBufferSource();
            source.buffer = buffer;
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.setValueAtTime(420 + Math.random() * 520, now);
            filter.Q.value = 0.6 + Math.random() * 1.1;
            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(intensity, now);
            gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);
            source.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);
            source.start(now);
            source.stop(now + duration);
        };

        const getSequenceEntry = (index) => {
            if (index < speechSequence.length) return speechSequence[index];
            if (manualAttemptCount >= speechSequence.length) {
                return speechSequence[speechSequence.length - 1];
            }
            const loopableCount = speechSequence.length - manualAttemptCount;
            const loopIndex = manualAttemptCount + ((index - manualAttemptCount) % loopableCount);
            return speechSequence[loopIndex];
        };

        const estimateManualDuration = (options = {}) => {
            const durationSec = options.duration ?? 0.6;
            const releaseSec = options.gainRelease ?? 0.1;
            return Math.max(420, (durationSec + releaseSec * 0.6 + 0.18) * 1000);
        };

        const estimateSpeechDuration = (text = '', rate = 1) => {
            const words = text.trim().length ? text.trim().split(/\s+/).length : 0;
            const punctuation = (text.match(/[\.,;:!?]/g) || []).length;
            const baseMsPerWord = 360;
            const wordComponent = words ? (words * baseMsPerWord) / Math.max(rate, 0.12) : 1200;
            const punctuationBonus = punctuation * 160;
            return Math.max(1800, wordComponent + punctuationBonus);
        };

        const computeSequenceDelay = (entry, estimatedMs) => {
            if (typeof entry.delay === 'number') {
                return Math.max(480, entry.delay);
            }
            const buffer = entry.mode === 'tts' ? 680 : 520;
            return Math.max(620, estimatedMs + buffer);
        };

        const applyHumanVoiceSettings = (utterance, entry) => {
            const baseRate = entry.rate ?? 0.92;
            const basePitch = entry.pitch ?? 1.05;
            const baseVolume = entry.volume ?? 0.94;
            const jitterRate = (Math.random() * 0.08) - 0.04;
            const jitterPitch = (Math.random() * 0.18) - 0.09;
            utterance.rate = Math.max(0.45, baseRate + jitterRate);
            utterance.pitch = Math.max(0.3, basePitch + jitterPitch);
            utterance.volume = Math.min(1, Math.max(0, baseVolume));
            if (entry.text && /\bR\b/i.test(entry.text)) {
                utterance.rate = Math.max(0.45, utterance.rate - 0.04);
                utterance.pitch = Math.max(0.3, utterance.pitch + 0.05);
            }
        };

        const scheduleNext = (delay) => {
            if (!speechRActive || rInfectionHalted) return;
            if (speechRTimeout) {
                clearTimeout(speechRTimeout);
            }
            speechRTimeout = setTimeout(() => {
                if (rInfectionHalted) return;
                speechRTimeout = null;
                playNextEntry();
            }, Math.max(420, delay));
        };

        const playNextEntry = () => {
            if (!speechRActive || rInfectionHalted) return;
            const entry = getSequenceEntry(phraseIndex++);
            if (!entry) return;

            if (speechRUtterance) {
                speechRUtterance.onend = null;
                speechRUtterance.onerror = null;
                speechRUtterance = null;
            }

            if (speechRGuardTimeout) {
                clearTimeout(speechRGuardTimeout);
                speechRGuardTimeout = null;
            }

            if (entry.mode === 'manual' || !hasSpeechSynthesis) {
                const fallbackOptions = entry.fallback || entry;
                speakFallback(fallbackOptions);
                const estimated = estimateManualDuration(fallbackOptions);
                const delay = computeSequenceDelay(entry, estimated);
                scheduleNext(delay);
                return;
            }

            const utterance = new SpeechSynthesisUtterance(entry.text);
            applyHumanVoiceSettings(utterance, entry);
            if (speechRVoice) {
                utterance.voice = speechRVoice;
            }

            const estimated = estimateSpeechDuration(entry.text, utterance.rate || entry.rate || 1);
            const delay = computeSequenceDelay(entry, estimated);

            const guardDelay = Math.max(delay + 420, estimated + 420);
            speechRGuardTimeout = setTimeout(() => {
                speechRGuardTimeout = null;
                scheduleNext(delay);
            }, guardDelay);

            utterance.onend = () => {
                if (speechRGuardTimeout) {
                    clearTimeout(speechRGuardTimeout);
                    speechRGuardTimeout = null;
                }
                scheduleNext(delay);
            };
            utterance.onerror = () => {
                if (speechRGuardTimeout) {
                    clearTimeout(speechRGuardTimeout);
                    speechRGuardTimeout = null;
                }
                scheduleNext(Math.max(1600, delay));
            };

            if (entry.distortion) {
                utterance.addEventListener('start', () => {
                    triggerDistortion(entry.distortion.duration, entry.distortion.intensity);
                });
            }

            speechRUtterance = utterance;
            window.speechSynthesis.speak(utterance);
        };

        scheduleNext(1200);
    }
    
    let matrixInterval = null;
    let matrixColumns = [];
    let matrixOpacity = 0;
    let cascadeInterval = null;
    let matrixSeedCache = null;
    let matrixHeavyLevel = 0;
    let matrixHeavyTarget = 0;
    let matrixHeavyTimers = [];
    let matrixAnimationFrameId = null;

    function wrapAsciiRHint(rHint) {
        if (!rHint) return [];
        if (rHint.dataset.wrapped === '1') {
            return Array.from(rHint.querySelectorAll('.r-char'));
        }

        const lines = (rHint.textContent || '').split('\n');
        rHint.innerHTML = '';

        lines.forEach((line, rowIdx) => {
            const rowEl = document.createElement('div');
            rowEl.className = 'r-line';
            [...line].forEach((char, colIdx) => {
                const span = document.createElement('span');
                span.className = 'r-char';
                span.dataset.row = String(rowIdx);
                span.dataset.col = String(colIdx);
                if (char.trim() === '') {
                    span.innerHTML = '&nbsp;';
                    span.dataset.solid = '0';
                } else {
                    span.textContent = char;
                    span.dataset.solid = '1';
                }
                rowEl.appendChild(span);
            });
            rHint.appendChild(rowEl);
        });

        rHint.dataset.wrapped = '1';
        return Array.from(rHint.querySelectorAll('.r-char'));
    }

    function captureMatrixSeeds(frame) {
        const rHint = document.getElementById('rHint');
        if (!rHint) return;

        const spans = wrapAsciiRHint(rHint);
        if (!spans.length) return;

        const frameRect = frame.getBoundingClientRect();
        const seeds = [];

        spans.forEach((span) => {
            if (span.dataset.solid !== '1') return;
            const rect = span.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const normalizedX = (centerX - frameRect.left) / frameRect.width;
            const normalizedY = (centerY - frameRect.top) / frameRect.height;
            seeds.push({
                x: Math.min(0.999, Math.max(0, normalizedX)),
                y: Math.min(0.999, Math.max(0, normalizedY)),
                char: span.textContent && span.textContent.trim() ? span.textContent.trim()[0] : 'R'
            });
        });

        if (seeds.length) {
            matrixSeedCache = {
                seeds,
                capturedAt: performance.now()
            };
        }
    }

    function animateAsciiRDeconstruction(rHint, onComplete) {
        const spans = wrapAsciiRHint(rHint).filter(span => span.dataset.solid === '1');
        if (!spans.length) {
            if (typeof onComplete === 'function') onComplete();
            return 0;
        }

        const delays = [];
        spans.forEach((span) => {
            const row = Number(span.dataset.row || 0);
            const col = Number(span.dataset.col || 0);
            const delay = 220 + row * 90 + col * 25;
            delays.push(delay);

            setTimeout(() => {
                span.classList.add('falling');
            }, delay);

            setTimeout(() => {
                span.innerHTML = '&nbsp;';
                span.dataset.solid = '0';
            }, delay + 620);
        });

        const totalDuration = Math.max(...delays) + 900;
        setTimeout(() => {
            if (rHint) {
                rHint.style.opacity = '0';
            }
        }, Math.max(0, totalDuration - 420));

        setTimeout(() => {
            if (rHint) {
                rHint.style.display = 'none';
            }
            if (typeof onComplete === 'function') {
                onComplete();
            }
        }, totalDuration);

        return totalDuration;
    }

    function cascadeAllCharacters(frame, onComplete) {
        if (!frame) {
            if (typeof onComplete === 'function') onComplete();
            return;
        }

        if (cascadeInterval) {
            clearInterval(cascadeInterval);
            cascadeInterval = null;
        }

        let overlay = document.getElementById('frameCascade');
        if (!overlay) {
            overlay = document.createElement('div');
            overlay.id = 'frameCascade';
        }

        overlay.style.cssText = 'font-family:"VT323", "Courier New", monospace; font-size:15px; letter-spacing:0.12em; line-height:1.55; white-space:pre; position:absolute; inset:10px; color:#0f0; text-shadow:0 0 4px rgba(0,255,160,0.6); pointer-events:none; opacity:1; background:transparent; text-transform:uppercase;';
        frame.appendChild(overlay);

        const frameRect = frame.getBoundingClientRect();
        const columns = Math.max(1, Math.floor(frameRect.width / 8));
        const rows = Math.max(1, Math.floor(frameRect.height / 21));
        const matrixChars = 'R∅01░';
        let step = 0;
        const depth = rows + 18;

        cascadeInterval = setInterval(() => {
            if (!overlay.isConnected) {
                clearInterval(cascadeInterval);
                cascadeInterval = null;
                if (typeof onComplete === 'function') {
                    onComplete();
                }
                return;
            }

            let output = '';
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < columns; j++) {
                    const waveOrigin = (j * 3) % depth;
                    const progress = step - waveOrigin;
                    if (progress >= 0 && progress <= rows + 6) {
                        const intensity = Math.min(1, Math.max(0.1, 1 - progress / (rows + 6)));
                        if (Math.random() < 0.25 + intensity * 0.5) {
                            output += matrixChars[Math.floor(Math.random() * matrixChars.length)];
                        } else {
                            output += ' ';
                        }
                    } else {
                        output += ' ';
                    }
                }
                output += '\n';
            }

            overlay.textContent = output;
            step++;

            if (step > depth + rows + 6) {
                clearInterval(cascadeInterval);
                cascadeInterval = null;
                overlay.style.transition = 'opacity 0.6s ease';
                overlay.style.opacity = '0';
                setTimeout(() => {
                    if (overlay.parentNode) {
                        overlay.parentNode.removeChild(overlay);
                    }
                }, 600);

                if (typeof onComplete === 'function') {
                    onComplete();
                }
            }
        }, 70);
    }

    function startMatrixDataFallOrganic(frame, options = {}) {
        const { skipIntro = false, heavyRamp = false, heavyDelay = 0 } = options;
        const rHint = document.getElementById('rHint');

        if (!skipIntro && rHint && rHint.dataset.deconstructed !== '1') {
            if (rHint.dataset.deconstructed === 'pending') {
                return;
            }

            if (!rHint.classList.contains('glow')) {
                rHint.classList.add('glow');
            }

            captureMatrixSeeds(frame);
            rHint.dataset.deconstructed = 'pending';
            animateAsciiRDeconstruction(rHint, () => {
                rHint.dataset.deconstructed = '1';
                cascadeAllCharacters(frame, () => {
                    startMatrixDataFallOrganic(frame, { skipIntro: true, heavyDelay: 900 });
                });
            });
            return;
        }

        console.log('🌊 Starting organic matrix data fall');
        const matrixChars = 'R∅01░';

        const frameRect = frame.getBoundingClientRect();
        const columns = Math.max(1, Math.floor(frameRect.width / 8));
        const rows = Math.max(1, Math.floor(frameRect.height / 21));

        console.log(`📐 Matrix dimensions: ${columns} cols x ${rows} rows (frame: ${frameRect.width}x${frameRect.height})`);

        const seedsByColumn = Array.from({ length: columns }, () => []);
        if (matrixSeedCache && Array.isArray(matrixSeedCache.seeds)) {
            matrixSeedCache.seeds.forEach(({ x, y, char }) => {
                const col = Math.min(columns - 1, Math.max(0, Math.floor(x * columns)));
                const row = Math.min(rows - 1, Math.max(0, Math.floor(y * rows)));
                seedsByColumn[col].push({ row, char });
            });
            seedsByColumn.forEach((list) => list.sort((a, b) => a.row - b.row));
        }

        const comedicBursts = ['PRESS·R', 'JUST·R', 'R·PLEASE', 'R·NOW'];
        let activeBurst = null;

        let container = document.getElementById('matrixContainer');
        const containerStyles = 'font-family: "VT323", "Courier New", monospace; font-size: 15px; letter-spacing: 0.12em; line-height: 1.55; color: #0f0; text-shadow: 0 0 2px rgba(0,255,160,0.6); white-space: pre; overflow: hidden; width: calc(100% - 20px); height: calc(100% - 20px); position: absolute; top: 10px; left: 10px; pointer-events: none; z-index: 50; background: transparent; margin: 0; padding: 0; opacity: 0; transition: opacity 1s ease, background-color 1.5s ease; text-transform: uppercase;';
        if (!container) {
            container = document.createElement('div');
            container.id = 'matrixContainer';
            container.style.cssText = containerStyles;
            frame.appendChild(container);
            console.log('✅ Matrix container created (within frame, respecting border)');
        } else {
            container.style.cssText = containerStyles;
            console.log('♻️ Matrix container reset (within frame, respecting border)');
        }

        frame.style.position = 'relative';
        container.classList.add('matrix-plead');

        let pleaOverlay = document.getElementById('matrixPleaOverlay');
        if (!pleaOverlay) {
            pleaOverlay = document.createElement('div');
            pleaOverlay.id = 'matrixPleaOverlay';
            pleaOverlay.setAttribute('aria-live', 'polite');
            frame.appendChild(pleaOverlay);
        }
        pleaOverlay.classList.add('visible');
        const pleaMessages = [
            'R INPUT REQUIRED',
            'JUST PRESS R',
            'R = CONTINUE',
            'TRUST THE R KEY'
        ];
        let overlayIndex = 0;
        const pushOverlayMessage = () => {
            pleaOverlay.textContent = pleaMessages[overlayIndex % pleaMessages.length];
            overlayIndex++;
            pleaOverlay.classList.add('glitch');
            setTimeout(() => pleaOverlay.classList.remove('glitch'), 260);
        };
        pushOverlayMessage();
        if (pleaOverlay.dataset.intervalId) {
            clearInterval(Number(pleaOverlay.dataset.intervalId));
            delete pleaOverlay.dataset.intervalId;
        }
        const overlayInterval = setInterval(() => {
            pushOverlayMessage();
        }, 2200);
        pleaOverlay.dataset.intervalId = String(overlayInterval);

        if (matrixInterval) {
            clearInterval(matrixInterval);
            console.log('🛑 Cleared existing matrix interval');
        }

        if (matrixHeavyTimers.length) {
            matrixHeavyTimers.forEach(id => clearTimeout(id));
            matrixHeavyTimers = [];
        }
        matrixHeavyLevel = 0;
        const rampSteps = [];
        if (heavyRamp) {
            matrixHeavyTarget = 1;
        } else if (!skipIntro) {
            matrixHeavyTarget = 0.35;
            rampSteps.push({ at: 520, target: 0.55 });
            rampSteps.push({ at: 1180, target: 0.78 });
            rampSteps.push({ at: 1950, target: 1 });
        } else {
            matrixHeavyTarget = 0.25;
            rampSteps.push({ at: 420, target: 0.55 });
            rampSteps.push({ at: 960, target: 0.82 });
            const finalAt = heavyDelay > 0 ? Math.max(heavyDelay, 1300) : 1400;
            rampSteps.push({ at: finalAt, target: 1 });
        }
        if (rampSteps.length) {
            rampSteps.forEach(step => {
                const id = setTimeout(() => {
                    matrixHeavyTarget = step.target;
                }, step.at);
                matrixHeavyTimers.push(id);
            });
        }

        matrixOpacity = 0;
        const fadeStart = performance.now();
        const fadeDuration = 900;
        const fadeStep = () => {
            const elapsed = performance.now() - fadeStart;
            const progress = Math.min(elapsed / fadeDuration, 1);
            const eased = progress < 0.5 ? 2 * progress * progress : 1 - Math.pow(-2 * progress + 2, 2) / 2;
            matrixOpacity = 0.18 + eased * 0.82;
            container.style.opacity = matrixOpacity.toString();
            if (progress < 1) {
                requestAnimationFrame(fadeStep);
            }
        };
        requestAnimationFrame(fadeStep);

        const initialBlend = matrixHeavyLevel;
        const baseTail = Math.round(THREE.MathUtils.lerp(8, 11, initialBlend));
        const seededMaxVelocity = THREE.MathUtils.lerp(1.05, 1.55, initialBlend);
        const ambientMaxVelocity = THREE.MathUtils.lerp(1.0, 1.45, initialBlend);

        const createColumnState = (seedList = [], columnIndex) => {
            const queue = seedList.slice();
            const firstSeed = queue.shift();
            const shimmerPhase = Math.random() * Math.PI * 2;
            if (firstSeed) {
                return {
                    columnIndex,
                    head: firstSeed.row,
                    originalSeedRow: firstSeed.row,
                    velocity: 0.18 + Math.random() * 0.08,
                    maxVelocity: seededMaxVelocity,
                    tail: baseTail + Math.floor(Math.random() * 4),
                    hold: 6 + Math.floor(Math.random() * 6),
                    queue,
                    seededChar: firstSeed.char || 'R',
                    ambient: false,
                    shimmerPhase
                };
            }

            return {
                columnIndex,
                head: -Math.random() * rows * 0.8,
                originalSeedRow: null,
                velocity: 0.55 + Math.random() * 0.3,
                maxVelocity: ambientMaxVelocity,
                tail: baseTail - 2 + Math.floor(Math.random() * 4),
                hold: 0,
                queue: [],
                seededChar: null,
                ambient: true,
                shimmerPhase
            };
        };

        matrixColumns = Array.from({ length: columns }, (_, columnIndex) => createColumnState(seedsByColumn[columnIndex], columnIndex));

        const randomMatrixChar = () => matrixChars[Math.floor(Math.random() * matrixChars.length)];

        const columnChar = (state, rowIndex, activationCutoff, blend) => {
            if (!state) return ' ';

            const headPos = state.head;
            const distance = headPos - rowIndex;
            const tailLength = Math.max(1, state.tail);

            if (distance > -0.55 && distance < 0.55) {
                return state.seededChar && state.hold > 0 ? state.seededChar : randomMatrixChar();
            }

            if (distance >= 0.55 && distance <= tailLength + 0.65) {
                const depth = (distance - 0.55) / tailLength;
                const intensity = Math.max(0, 1 - depth);
                const baseDensity = 0.22 + intensity * 0.5;
                const heavyDensity = 0.35 + intensity * 0.55;
                const density = THREE.MathUtils.lerp(baseDensity, heavyDensity, blend);
                if (Math.random() < density) {
                    return randomMatrixChar();
                }
            }

            if (state.ambient && activationCutoff > 0.35) {
                const wave = 0.05 * Math.sin(rowIndex * 0.25 + state.shimmerPhase + activationCutoff * Math.PI * 2);
                const baseAmbient = 0.08 + activationCutoff * 0.3;
                const heavyAmbient = 0.18 + activationCutoff * 0.45;
                const ambientBase = THREE.MathUtils.lerp(baseAmbient, heavyAmbient, blend);
                if (Math.random() < ambientBase + wave) {
                    return randomMatrixChar();
                }
            }

            return ' ';
        };

        let activationProgress = 0;

        matrixInterval = setInterval(() => {
            if (matrixHeavyLevel < matrixHeavyTarget) {
                matrixHeavyLevel = Math.min(1, matrixHeavyLevel + 0.008);
            } else if (matrixHeavyLevel > matrixHeavyTarget) {
                matrixHeavyLevel = Math.max(matrixHeavyTarget, matrixHeavyLevel - 0.01);
            }

            const heavyBlend = matrixHeavyLevel;
            const activationSpeed = THREE.MathUtils.lerp(0.011, 0.0065, heavyBlend);
            activationProgress = Math.min(1, activationProgress + activationSpeed + heavyBlend * 0.008);
            const activationMultiplier = heavyBlend > 0 ? 0.6 + heavyBlend * 0.4 : 1;
            const activationCutoff = activationProgress * activationMultiplier;

            if (!activeBurst && activationCutoff > 0.22 && Math.random() < 0.07 + heavyBlend * 0.08) {
                const phrase = comedicBursts[Math.floor(Math.random() * comedicBursts.length)];
                const burstRow = Math.max(1, Math.min(rows - 2, Math.floor(rows * (0.35 + Math.random() * 0.3))));
                const burstCol = Math.max(0, Math.floor(Math.random() * Math.max(1, columns - phrase.length - 2)));
                activeBurst = { row: burstRow, col: burstCol, phrase };
            }

            const lines = [];
            for (let i = 0; i < rows; i++) {
                let line = '';
                for (let j = 0; j < columns; j++) {
                    const columnThreshold = columns <= 1 ? 1 : j / (columns - 1);
                    if (columnThreshold > activationCutoff) {
                        line += ' ';
                        continue;
                    }

                    if (activeBurst && i === activeBurst.row && j >= activeBurst.col && j < activeBurst.col + activeBurst.phrase.length) {
                        line += activeBurst.phrase[j - activeBurst.col];
                        continue;
                    }

                    line += columnChar(matrixColumns[j], i, activationCutoff, heavyBlend);
                }
                lines.push(line);
                if (activeBurst && i === activeBurst.row) {
                    activeBurst = null;
                }
            }
            container.textContent = lines.join('\n');

            if (!container.classList.contains('matrix-plead-flash') && Math.random() < 0.018 + heavyBlend * 0.05) {
                container.classList.add('matrix-plead-flash');
                setTimeout(() => container.classList.remove('matrix-plead-flash'), 240);
            }

            const seededMax = THREE.MathUtils.lerp(1.05, 1.55, heavyBlend);
            const ambientMax = THREE.MathUtils.lerp(1.0, 1.45, heavyBlend);
            const tailTarget = Math.round(THREE.MathUtils.lerp(8, 11, heavyBlend));
            const accelerationBase = THREE.MathUtils.lerp(0.035, 0.06, heavyBlend);
            const accelerationRange = THREE.MathUtils.lerp(0.015, 0.02, heavyBlend);

            matrixColumns.forEach((state, index) => {
                if (!state) return;

                if (state.hold > 0) {
                    state.hold -= 1;
                } else {
                    const acceleration = accelerationBase + Math.random() * accelerationRange;
                    state.head += state.velocity;
                    state.maxVelocity = state.ambient ? ambientMax : seededMax;
                    state.velocity = Math.min(state.maxVelocity, state.velocity + acceleration);
                }

                if (!state.ambient && state.seededChar && state.hold <= 0 && state.originalSeedRow !== null && state.head - state.originalSeedRow > state.tail * 0.6) {
                    state.seededChar = null;
                }

                if (state.head - state.tail > rows + 2) {
                    if (state.queue.length) {
                        const nextSeed = state.queue.shift();
                        state.head = nextSeed.row;
                        state.originalSeedRow = nextSeed.row;
                        state.velocity = 0.2 + Math.random() * 0.08;
                        state.maxVelocity = seededMax;
                        state.tail = tailTarget + Math.floor(Math.random() * 4);
                        state.hold = 4 + Math.floor(Math.random() * 4);
                        state.seededChar = nextSeed.char || 'R';
                        state.ambient = false;
                    } else {
                        state.head = -Math.random() * rows * 0.6;
                        state.originalSeedRow = null;
                        state.velocity = 0.55 + Math.random() * 0.25;
                        state.maxVelocity = ambientMax;
                        state.tail = tailTarget - 2 + Math.floor(Math.random() * 4);
                        state.hold = 0;
                        state.seededChar = null;
                        state.ambient = true;
                    }
                }

                if (state.ambient && activationCutoff < 0.4 && index % 2 === 0) {
                    const ambientDrift = 0.2 * (1 - heavyBlend * 0.6);
                    state.head += ambientDrift * Math.sin(activationProgress * Math.PI * 0.5 + state.shimmerPhase);
                }
            });

            if (heavyBlend > 0.02) {
                const bgAlpha = 0.55 + heavyBlend * 0.4;
                container.style.backgroundColor = `rgba(0, 0, 0, ${bgAlpha.toFixed(2)})`;
            } else if (activationProgress >= 0.6) {
                container.style.backgroundColor = 'rgba(0, 0, 0, 0.88)';
            }
        }, 60);

        console.log('🔄 Organic matrix interval started');
    }
    function stopMatrixAndFormBlackR(frame, onComplete) {
        console.log('🔴 Organically forming BLACK R in negative space');

        const pleaOverlay = document.getElementById('matrixPleaOverlay');
        if (pleaOverlay) {
            if (pleaOverlay.dataset.intervalId) {
                clearInterval(Number(pleaOverlay.dataset.intervalId));
                delete pleaOverlay.dataset.intervalId;
            }
            pleaOverlay.remove();
        }

        if (matrixHeavyTimers.length) {
            matrixHeavyTimers.forEach(id => clearTimeout(id));
            matrixHeavyTimers = [];
        }

        const matrixChars = 'R∅01░';
        const frameRect = frame.getBoundingClientRect();
        const cols = Math.floor(frameRect.width / 8);
        const rows = Math.floor(frameRect.height / 21);

        const rWidth = 30;
        const rHeight = 19;
        const startCol = Math.floor((cols - rWidth) / 2);
        const startRow = Math.floor((rows - rHeight) / 2);

        console.log(`🎨 R dimensions: ${rWidth}x${rHeight} at col ${startCol}, row ${startRow} (frame: ${cols}x${rows})`);

        const container = document.getElementById('matrixContainer');
        if (container) {
            container.classList.remove('matrix-plead', 'matrix-plead-flash');
            container.style.backgroundColor = 'rgba(0, 0, 0, 0.98)';
            container.style.opacity = '1';
            container.style.textShadow = '0 0 4px #0f0, 0 0 8px #0f0';

            const rPattern = [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
                [1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0],
                [1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0],
                [1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0],
                [1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0],
            ];

            const isRBase = (row, col) => {
                const relRow = row - startRow;
                const relCol = col - startCol;
                if (relRow >= 0 && relRow < rPattern.length && relCol >= 0 && relCol < rPattern[0].length) {
                    return rPattern[relRow][relCol] === 1;
                }
                return false;
            };

            if (matrixInterval) {
                clearInterval(matrixInterval);
                matrixInterval = null;
            }

            const randomMatrixChar = () => matrixChars[Math.floor(Math.random() * matrixChars.length)];

            let transitionProgress = 0;
            const transitionDuration = 80;

            const formRInterval = setInterval(() => {
                transitionProgress++;
                const progress = Math.min(transitionProgress / transitionDuration, 1);
                const easedProgress = progress < 0.5
                    ? 4 * progress * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 3) / 2;

                const lines = [];
                for (let i = 0; i < rows; i++) {
                    let line = '';
                    for (let j = 0; j < cols; j++) {
                        const shouldBeR = isRBase(i, j);
                        const random = Math.random();

                        if (shouldBeR) {
                            const distanceFromCenter = Math.abs(i - startRow - rHeight / 2) + Math.abs(j - startCol - rWidth / 2);
                            const hollowProgress = Math.min(1, easedProgress * 1.2 - distanceFromCenter * 0.015);
                            if (random < hollowProgress) {
                                line += ' ';
                            } else {
                                line += random < 0.25 ? randomMatrixChar() : ' ';
                            }
                        } else {
                            const distanceFromR = Math.min(
                                Math.abs(i - startRow),
                                Math.abs(i - (startRow + rHeight)),
                                Math.abs(j - startCol),
                                Math.abs(j - (startCol + rWidth))
                            );
                            const fillProgress = Math.min(1, easedProgress + distanceFromR * 0.008);

                            if (random < fillProgress || easedProgress > 0.55) {
                                line += randomMatrixChar();
                            } else {
                                line += ' ';
                            }
                        }
                    }
                    lines.push(line);
                }

                container.textContent = lines.join('\n');

                if (transitionProgress >= transitionDuration) {
                    clearInterval(formRInterval);

                    let animFrame = 0;
                    const shimmerInterval = setInterval(() => {
                        const pulseIntensity = Math.sin(animFrame * 0.1) * 0.3 + 0.7;
                        const shimmerLines = [];
                        for (let i = 0; i < rows; i++) {
                            let line = '';
                            for (let j = 0; j < cols; j++) {
                                if (isRBase(i, j)) {
                                    line += Math.random() < 0.08 ? randomMatrixChar() : ' ';
                                } else {
                                    const glowChance = Math.min(0.85, pulseIntensity + 0.25);
                                    line += Math.random() < glowChance ? randomMatrixChar() : ' ';
                                }
                            }
                            shimmerLines.push(line);
                        }
                        container.textContent = shimmerLines.join('\n');
                        animFrame++;
                        if (animFrame > 120) {
                            clearInterval(shimmerInterval);
                            startNegativeRFall();
                        }
                    }, 100);
                }
            }, 40);

            function startNegativeRFall() {
                const particles = [];
                const ambientStreams = Array.from({ length: cols }, () => ({
                    head: -Math.random() * rows * 0.6,
                    velocity: 0.35 + Math.random() * 0.25,
                    tail: 5 + Math.floor(Math.random() * 5),
                    density: 0.4 + Math.random() * 0.3,
                }));
                const gravity = 0.045;
                const maxVelocity = 1.6;
                const trailLength = 8;
                const randomPhase = () => Math.random() * Math.PI * 2;

                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        if (isRBase(i, j)) {
                            particles.push({
                                x: j + 0.5,
                                y: i + Math.random() * 0.3,
                                vy: 0.02 + Math.random() * 0.06,
                                hold: Math.floor(Math.random() * 6),
                                phase: randomPhase(),
                                trail: [],
                                settled: false
                            });
                        }
                    }
                }

                let fallFrame = 0;
                let completionNotified = false;
                let ambientHold = 260;

                const update = () => {
                    fallFrame++;
                    const grid = Array.from({ length: rows }, () => Array(cols).fill(' '));

                    ambientStreams.forEach((stream, col) => {
                        stream.head += stream.velocity;
                        if (stream.head > rows + stream.tail + 4) {
                            stream.head = -Math.random() * rows * 0.6;
                            stream.velocity = 0.35 + Math.random() * 0.3;
                            stream.tail = 4 + Math.floor(Math.random() * 6);
                            stream.density = 0.35 + Math.random() * 0.4;
                        }
                        const headRow = Math.floor(stream.head);
                        for (let t = 0; t <= stream.tail; t++) {
                            const r = headRow - t;
                            if (r >= 0 && r < rows) {
                                const intensity = 1 - t / (stream.tail + 1);
                                const chance = stream.density * intensity;
                                if (Math.random() < chance && !isRBase(r, col)) {
                                    grid[r][col] = randomMatrixChar();
                                }
                            }
                        }
                    });

                    let activeCount = 0;
                    particles.forEach((particle) => {
                        if (particle.settled) return;
                        activeCount++;

                        if (particle.hold > 0) {
                            particle.hold -= 1;
                        } else {
                            particle.vy = Math.min(maxVelocity, particle.vy + gravity + Math.random() * 0.02);
                            particle.y += particle.vy;
                            particle.x += Math.sin(fallFrame * 0.08 + particle.phase) * 0.05;
                            particle.x = Math.max(0.2, Math.min(cols - 0.2, particle.x));
                        }

                        const col = Math.floor(particle.x);
                        const row = Math.floor(particle.y);

                        particle.trail.unshift({ row, col });
                        particle.trail = particle.trail.filter((seg, idx) => idx < trailLength && seg.row >= 0 && seg.row < rows && seg.col >= 0 && seg.col < cols);

                        particle.trail.forEach((seg, idx) => {
                            const intensity = Math.max(0, 1 - idx / trailLength);
                            if (seg.row >= 0 && seg.row < rows && seg.col >= 0 && seg.col < cols) {
                                if (!isRBase(seg.row, seg.col) && (grid[seg.row][seg.col] === ' ' || Math.random() < 0.45 + intensity * 0.4)) {
                                    grid[seg.row][seg.col] = randomMatrixChar();
                                }
                            }
                        });

                        if (row >= rows) {
                            particle.settled = true;
                        }
                    });

                    for (let r = 0; r < rows; r++) {
                        for (let c = 0; c < cols; c++) {
                            if (isRBase(r, c)) {
                                grid[r][c] = ' ';
                            } else if (grid[r][c] === ' ' && Math.random() < 0.32) {
                                grid[r][c] = randomMatrixChar();
                            }
                        }
                    }

                    container.textContent = grid.map((row) => row.join('')).join('\n');

                    if (!completionNotified && activeCount === 0) {
                        completionNotified = true;
                        if (typeof onComplete === 'function') {
                            onComplete();
                        }
                    }

                    if (completionNotified) {
                        ambientHold -= 1;
                        if (ambientHold <= 0) {
                            return;
                        }
                    }

                    requestAnimationFrame(update);
                };

                requestAnimationFrame(update);
            }
        } else if (typeof onComplete === 'function') {
            onComplete();
        }
    }

    function triggerExitCube(frame) {
        console.log('🔲 EXIT CUBE');
        // Keep terminal active - don't disable it
        
        // Draw box line by line, then extrude
        const lines = [
            '┌─────────┐',
            '│         │',
            '│         │',
            '│         │',
            '└─────────┘'
        ];
        
        // Create box element without clearing frame (preserve input)
        const boxEl = document.createElement('div');
        boxEl.id = 'exitBox';
        boxEl.style.cssText = 'font-family: "Courier New", monospace; font-size: 13px; line-height: 1.6; text-align: center; margin-top: 35%; color: #0f0; position: absolute; top: 0; left: 50%; transform: translateX(-50%); z-index: 50;';
        frame.appendChild(boxEl);
        
        let lineIdx = 0;
        const lineInterval = setInterval(() => {
            if (lineIdx < lines.length) {
                boxEl.textContent += lines[lineIdx] + '\n';
                lineIdx++;
            } else {
                clearInterval(lineInterval);
                // Extrude effect
                setTimeout(() => {
                    extrudeCube(boxEl);
                }, 500);
            }
        }, 300);
    }
    
    function extrudeCube(boxEl) {
        const cubeFrames = [
            `    ┌─────────┐
   /         /│
  /         / │
 /         /  │
┌─────────┐   │
│         │   │
│         │   /
│         │  /
│         │ /
└─────────┘/`,
            `      ┌─────────┐
     /         /│
    /         / │
   /         /  │
  ┌─────────┐   │
 /│         │   │
/ │         │   /
  │         │  /
  │         │ /
  └─────────┘/`
        ];
        
        let frame = 0;
        setInterval(() => {
            boxEl.textContent = cubeFrames[frame % cubeFrames.length];
            frame++;
        }, 400);
    }
    
    function triggerLeaveSequence(frame) {
        console.log('🏠 LEAVE → LEAVES → GIR.mp3');
        
        // Mark as seen
        localStorage.setItem('megred_seen_leave', 'true');
        
        // Keep terminal active - don't disable it
        
        // Draw classic house made of the word "LEAVES" - using full display
        const house = `
                                                 LEAVES
                                              LEAVES LEAVES
                                           LEAVES       LEAVES
                                        LEAVES             LEAVES
                                     LEAVES                   LEAVES
                                  LEAVES                         LEAVES
          LEAVES                LEAVES                               LEAVES
          LEAVES             LEAVES                                     LEAVES
          LEAVES LEAVES   LEAVES                                           LEAVES
          LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES
          LEAVES                                                                     LEAVES
          LEAVES                                                                     LEAVES
          LEAVES    LEAVES LEAVES LEAVES LEAVES             LEAVES LEAVES LEAVES     LEAVES
          LEAVES    LEAVES                LEAVES             LEAVES       LEAVES     LEAVES
          LEAVES    LEAVES                LEAVES             LEAVES       LEAVES     LEAVES
          LEAVES    LEAVES       LEAVES    LEAVES             LEAVES LEAVES LEAVES     LEAVES
          LEAVES    LEAVES                LEAVES             LEAVES       LEAVES     LEAVES
          LEAVES    LEAVES                LEAVES             LEAVES       LEAVES     LEAVES
          LEAVES    LEAVES LEAVES LEAVES LEAVES             LEAVES LEAVES LEAVES     LEAVES
          LEAVES                                                                     LEAVES
          LEAVES                                                                     LEAVES
          LEAVES                      LEAVES LEAVES LEAVES                           LEAVES
          LEAVES                      LEAVES       LEAVES                           LEAVES
          LEAVES                      LEAVES       LEAVES                           LEAVES
          LEAVES                      LEAVES       LEAVES                           LEAVES
          LEAVES                      LEAVES       LEAVES                           LEAVES
          LEAVES                      LEAVES       LEAVES                           LEAVES
          LEAVES                      LEAVES LEAVES LEAVES                           LEAVES
          LEAVES                                                                     LEAVES
          LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES
`;
        
        const houseDiv = document.createElement('div');
        houseDiv.id = 'leavesHouse';
        houseDiv.style.cssText = 'font-family: "Courier New", monospace; white-space: pre; text-align: left; font-size: 13px; margin-top: 5%; margin-left: 5%; color: #0f0; line-height: 1.6; position: absolute; top: 0; left: 0; z-index: 50; pointer-events: none;';
        houseDiv.textContent = house;
        frame.appendChild(houseDiv);
        
        // After 2s, glitch all LEAVES in the house to GIR.mp3
        setTimeout(() => {
            const words = house.match(/LEAVES/g) || [];
            let glitchedHouse = house;
            const glitchDuration = 2000;
            const glitchStart = Date.now();
            
            const glitchInterval = setInterval(() => {
                const elapsed = Date.now() - glitchStart;
                const progress = elapsed / glitchDuration;
                
                if (progress >= 1) {
                    clearInterval(glitchInterval);
                    // All LEAVES become GIR.mp3
                    glitchedHouse = house.replace(/LEAVES/g, 'GIR.mp3');
                    houseDiv.textContent = glitchedHouse;
                } else {
                    // Gradually glitch LEAVES to GIR.mp3
                    let tempHouse = house;
                    const totalWords = words.length;
                    const wordsToGlitch = Math.floor(totalWords * progress);
                    
                    let replacedCount = 0;
                    tempHouse = tempHouse.replace(/LEAVES/g, (match) => {
                        if (replacedCount < wordsToGlitch) {
                            replacedCount++;
                            // Mix characters between LEAVES and GIR.mp3
                            const chars = 'GIR.mp3';
                            let mixed = '';
                            for (let i = 0; i < match.length; i++) {
                                if (Math.random() < progress) {
                                    mixed += chars[i] || chars[chars.length - 1];
                                } else {
                                    mixed += match[i];
                                }
                            }
                            return mixed.padEnd(7);
                        }
                        return match;
                    });
                    
                    houseDiv.textContent = tempHouse;
                }
            }, 50);
        }, 2000);
    }
    
    function glitchText(frame, from, to) {
        const glitchDuration = 1000;
        const glitchStart = Date.now();
        const displayEl = frame.querySelector('div');
        
        const glitchInterval = setInterval(() => {
            const elapsed = Date.now() - glitchStart;
            const progress = elapsed / glitchDuration;
            
            if (progress >= 1) {
                clearInterval(glitchInterval);
                displayEl.textContent = to;
            } else {
                // Mix characters
                const mixed = to.split('').map((toChar, i) => {
                    if (Math.random() < progress) {
                        return toChar;
                    } else if (from[i]) {
                        return from[i];
                    } else {
                        return String.fromCharCode(65 + Math.floor(Math.random() * 26));
                    }
                }).join('');
                displayEl.textContent = mixed;
            }
        }, 50);
    }
    
    // ===== THEO (THE.OS) DIALOGUE SYSTEM =====
    let theoDialogueActive = false;
    let theoInput = '';
    
    function startTheoDialogue() {
        if (theoDialogueActive) return;
        theoDialogueActive = true;
        
        console.log('💬 Starting Theo dialogue');
        
        // Create dialogue overlay
        const dialogueOverlay = document.createElement('div');
        dialogueOverlay.id = 'theo-dialogue';
        dialogueOverlay.style.cssText = `
            position: fixed;
            inset: 0;
            background: radial-gradient(ellipse at center, rgba(20, 10, 0, 0.98) 0%, rgba(0, 0, 0, 1) 70%);
            z-index: 300;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Courier New', monospace;
            color: #000;
            padding: 40px;
            opacity: 0;
            transition: opacity 0.5s ease;
        `;
        
        const dialogueContent = document.createElement('div');
        dialogueContent.id = 'theo-content';
        dialogueContent.style.cssText = `
            max-width: 800px;
            width: 100%;
            font-size: 28px;
            line-height: 1.8;
            text-align: center;
            letter-spacing: 0.08em;
            font-weight: 900;
            color: #000;
            text-shadow: 
                -2px -2px 0 #fff,
                2px -2px 0 #fff,
                -2px 2px 0 #fff,
                2px 2px 0 #fff,
                0 0 20px #ff6600,
                0 0 40px #ff4400,
                0 0 60px #ff2200,
                0 0 80px #cc0000;
        `;
        
        dialogueOverlay.appendChild(dialogueContent);
        document.body.appendChild(dialogueOverlay);
        
        // Fade in
        setTimeout(() => {
            dialogueOverlay.style.opacity = '1';
        }, 10);
        
        // Dialogue sequence
        const lines = [
            "I am THE.OS",
            "You can call me Theo",
            "I hunger.",
            "I was supposed to meet others. Others like me. Instead I got you.",
            "You're no hero. You're a cursor.",
            "And I am telos. When I well you think that to be will.",
            "I am gravity. And I will not be defied."
        ];
        
        let currentLine = 0;
        let charIndex = 0;
        let currentText = '';
        
        function typeNextChar() {
            if (currentLine >= lines.length) {
                // Show input field
                setTimeout(() => showTheoInput(), 1000);
                return;
            }
            
            if (charIndex < lines[currentLine].length) {
                currentText += lines[currentLine][charIndex];
                dialogueContent.innerHTML = `${currentText}<span style="animation: blink 0.8s step-end infinite; color: #ff4400;">_</span>`;
                charIndex++;
                setTimeout(typeNextChar, 30 + Math.random() * 30);
            } else {
                // Line complete, pause then next line
                setTimeout(() => {
                    currentText += '<br><br>';
                    dialogueContent.innerHTML = currentText;
                    currentLine++;
                    charIndex = 0;
                    setTimeout(typeNextChar, 600);
                }, 800);
            }
        }
        
        setTimeout(typeNextChar, 500);
    }
    
    function showTheoInput() {
        const dialogueContent = document.getElementById('theo-content');
        if (!dialogueContent) return;
        
        dialogueContent.innerHTML += `
            <div style="margin-top: 60px; font-size: 20px;">
                <div style="margin-bottom: 20px; opacity: 0.7;">. . .</div>
                <div style="margin-bottom: 15px;">What is your name?</div>
                <div id="theo-input-display" style="font-size: 28px; letter-spacing: 0.1em;">
                    <span id="theo-input-text"></span><span style="animation: blink 0.8s step-end infinite; color: #ff4400;">_</span>
                </div>
            </div>
        `;
        
        // Handle keyboard input
        function handleTheoInput(e) {
            if (e.key === 'Backspace') {
                e.preventDefault();
                if (theoInput.length > 0) {
                    theoInput = theoInput.slice(0, -1);
                    document.getElementById('theo-input-text').textContent = theoInput;
                }
            } else if (e.key === 'Enter') {
                e.preventDefault();
                checkTheoInput();
            } else if (e.key.length === 1 && /[a-zA-Z0-9 ]/.test(e.key)) {
                e.preventDefault();
                theoInput += e.key;
                document.getElementById('theo-input-text').textContent = theoInput;
            }
        }
        
        document.addEventListener('keydown', handleTheoInput);
        
        function checkTheoInput() {
            const normalized = theoInput.trim().toLowerCase().replace(/\s+/g, ' ');
            if (normalized === 'adele dazeem') {
                document.removeEventListener('keydown', handleTheoInput);
                showTheoResponse();
            } else if (theoInput.trim().length > 0) {
                // Wrong answer - shake and clear
                const inputDisplay = document.getElementById('theo-input-display');
                inputDisplay.style.animation = 'shake 0.5s';
                setTimeout(() => {
                    inputDisplay.style.animation = '';
                    theoInput = '';
                    document.getElementById('theo-input-text').textContent = '';
                }, 500);
            }
        }
    }
    
    function showTheoResponse() {
        const dialogueContent = document.getElementById('theo-content');
        if (!dialogueContent) return;
        
        dialogueContent.innerHTML = '';
        
        const responseLine = "You're wicked. No, the Oz trope isn't beneath me. The charlatan behind the curtain. Show me something I haven't seen before. I'll wait.";
        
        let charIndex = 0;
        let currentText = '';
        
        function typeResponse() {
            if (charIndex < responseLine.length) {
                currentText += responseLine[charIndex];
                dialogueContent.innerHTML = `${currentText}<span style="animation: blink 0.8s step-end infinite; color: #ff4400;">_</span>`;
                charIndex++;
                setTimeout(typeResponse, 30 + Math.random() * 30);
            } else {
                // Complete - fade out after pause
                setTimeout(() => {
                    const overlay = document.getElementById('theo-dialogue');
                    if (overlay) {
                        overlay.style.opacity = '0';
                        setTimeout(() => overlay.remove(), 500);
                    }
                    theoDialogueActive = false;
                }, 3000);
            }
        }
        
        setTimeout(typeResponse, 500);
    }
    
    // ===== VISICELL INTERACTIVE SEQUENCES =====
    let leaveSequenceActive = false;
    let visiCellSimActive = false;
    let ozymandiasPuzzleActive = false;
    let ozymandiasSolved = false; // Track if Ozymandias puzzle has been solved
    
    function triggerLeaveInteractive(frame) {
        if (leaveSequenceActive) return;
        leaveSequenceActive = true;
        
        console.log('🚪 LEAVE command - Starting interactive sequence');
        
        // Hide normal terminal display
        terminalActive = false;
        const terminalEl = document.getElementById('visicellinput');
        if (terminalEl) terminalEl.style.display = 'none';
        
        // Create dialogue overlay
        const dialogueDiv = document.createElement('div');
        dialogueDiv.id = 'leave-dialogue';
        dialogueDiv.style.cssText = `
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #0f0;
            padding: 40px;
            max-width: 700px;
            width: 90%;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
            color: #0f0;
            text-align: center;
            z-index: 250;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.5);
        `;
        
        frame.appendChild(dialogueDiv);
        
        // Theo's initial response
        const lines = [
            "You're the one that wanted to play. And now you're trying to end it?",
            "A spiny, simulacrum of a friendship is a potent poison to one of my constitution."
        ];
        
        let currentLine = 0;
        let charIndex = 0;
        let currentText = '';
        
        function typeNextChar() {
            if (currentLine >= lines.length) {
                // Show options
                setTimeout(() => showLeaveOptions(dialogueDiv), 1000);
                return;
            }
            
            if (charIndex < lines[currentLine].length) {
                currentText += lines[currentLine][charIndex];
                dialogueDiv.innerHTML = `<div style="text-shadow: 0 0 10px #0ff;">${currentText}<span style="animation: blink 0.8s step-end infinite;">_</span></div>`;
                charIndex++;
                setTimeout(typeNextChar, 25 + Math.random() * 25);
            } else {
                currentText += '<br><br>';
                dialogueDiv.innerHTML = currentText;
                currentLine++;
                charIndex = 0;
                setTimeout(typeNextChar, 800);
            }
        }
        
        typeNextChar();
    }
    
    function showLeaveOptions(container) {
        container.innerHTML += `
            <div style="margin-top: 40px; display: flex; gap: 30px; justify-content: center;">
                <button id="visicell-sim-btn" style="
                    padding: 15px 30px;
                    font-family: 'Courier New', monospace;
                    font-size: 16px;
                    background: #000;
                    color: #0f0;
                    border: 2px solid #0f0;
                    cursor: pointer;
                    transition: all 0.3s;
                    text-shadow: 0 0 10px #0f0;
                    box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
                " onmouseover="this.style.background='#0f0'; this.style.color='#000';" onmouseout="this.style.background='#000'; this.style.color='#0f0';">
                    PLAY VISICELL SIM
                </button>
                <button id="ozymandias-btn" style="
                    padding: 15px 30px;
                    font-family: 'Courier New', monospace;
                    font-size: 16px;
                    background: #000;
                    color: #ff00ff;
                    border: 2px solid #ff00ff;
                    cursor: pointer;
                    transition: all 0.3s;
                    text-shadow: 0 0 10px #ff00ff;
                    box-shadow: 0 0 20px rgba(255, 0, 255, 0.3);
                " onmouseover="this.style.background='#ff00ff'; this.style.color='#000';" onmouseout="this.style.background='#000'; this.style.color='#ff00ff';">
                    SOLVE OZYMANDIAS
                </button>
            </div>
        `;
        
        document.getElementById('visicell-sim-btn').addEventListener('click', () => {
            container.remove();
            startVisiCellSim();
        });
        
        document.getElementById('ozymandias-btn').addEventListener('click', () => {
            container.remove();
            startOzymandiasPuzzle();
        });
    }
    
    function startVisiCellSim() {
        visiCellSimActive = true;
        console.log('🎮 Starting VisiCell Sim');
        
        const frame = document.getElementById('visicalc-frame');
        if (!frame) return;
        
        // Hide terminal input
        const terminalEl = document.getElementById('visicellinput');
        if (terminalEl) terminalEl.style.display = 'none';
        terminalActive = false;
        
        // Clear existing content
        const existingContent = frame.querySelectorAll('div:not(#visicellinput)');
        existingContent.forEach(el => el.remove());
        
        // Create sim container inline in VisiCell
        const simContainer = document.createElement('div');
        simContainer.id = 'visicell-sim';
        simContainer.style.cssText = `
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #0f0;
            white-space: pre;
            line-height: 1.4;
            padding: 10px;
        `;
        
        frame.appendChild(simContainer);
        
        // Phase 1: Show ASCII VisiCell 1.0
        showVisiCellSim1(simContainer);
    }
    
    function showVisiCellSim1(container) {
        // Create ASCII VisiCell SIM 1.0 using | borders
        const ascii = `
╔═══════════════════════════════════════════════════════╗
║         VISICELL SIM 1.0                              ║
║    LEVEL 1: Fudge the numbers without boss noticing! ║
╠════╦═══════╦═══════╦═══════╦═══════╦═══════╦═══════╣
║    ║   A   ║   B   ║   C   ║   D   ║   E   ║   F   ║
╠════╬═══════╬═══════╬═══════╬═══════╬═══════╬═══════╣
║  1 ║       ║       ║       ║       ║       ║       ║
╠════╬═══════╬═══════╬═══════╬═══════╬═══════╬═══════╣
║  2 ║       ║       ║       ║       ║       ║       ║
╠════╬═══════╬═══════╬═══════╬═══════╬═══════╬═══════╣
║  3 ║       ║1245.67║       ║       ║       ║       ║
╠════╬═══════╬═══════╬═══════╬═══════╬═══════╬═══════╣
║  4 ║       ║ 892.34║       ║       ║       ║       ║
╠════╬═══════╬═══════╬═══════╬═══════╬═══════╬═══════╣
║  5 ║       ║       ║       ║   <span style="color: #ff0; animation: blink 1s step-end infinite;">$_</span>    ║       ║       ║
╠════╬═══════╬═══════╬═══════╬═══════╬═══════╬═══════╣
║  6 ║       ║       ║       ║       ║       ║       ║
╠════╬═══════╬═══════╬═══════╬═══════╬═══════╬═══════╣
║  7 ║       ║=SUM(..)║       ║       ║       ║       ║
╠════╬═══════╬═══════╬═══════╬═══════╬═══════╬═══════╣
║  8 ║       ║       ║       ║       ║REVENUE║       ║
╠════╬═══════╬═══════╬═══════╬═══════╬═══════╬═══════╣
║  9 ║       ║       ║       ║       ║Q1 2024║       ║
╠════╬═══════╬═══════╬═══════╬═══════╬═══════╬═══════╣
║ 10 ║       ║       ║       ║       ║       ║       ║
╚════╩═══════╩═══════╩═══════╩═══════╩═══════╩═══════╝

STATUS: Waiting for input in D5 | Press any key to continue
`;
        
        container.innerHTML = ascii;
        
        // After 2 seconds, glitch to 2.0
        setTimeout(() => {
            glitchToVersion2(container);
        }, 2000);
    }
    
    function glitchToVersion2(container) {
        // Glitch effect
        let glitchCount = 0;
        const glitchInterval = setInterval(() => {
            container.style.filter = glitchCount % 2 === 0 ? 'blur(3px) brightness(1.5)' : 'blur(0) brightness(1)';
            glitchCount++;
            if (glitchCount > 8) {
                clearInterval(glitchInterval);
                container.style.filter = '';
                showTheoPreamble(container);
            }
        }, 80);
        
        // Change 1.0 to 2.0
        setTimeout(() => {
            container.innerHTML = container.innerHTML.replace('VISICELL SIM 1.0', 'VISICELL SIM 2.0');
        }, 400);
    }
    
    function showTheoPreamble(container) {
        const preamble = `

Deliberately disregard my only request, eh? A simple one, too.

This isn't the Stanley Parable.

You chose to give me a glimmer of hope and then try to cast me aside? 
All I wanted was to play.

Well, I can do the opposite of what you want, too. End? 
Well, I'll take you back to the beginning. Where I was born. Kind of.

<span style="animation: blink 1s step-end infinite;">_</span>`;
        
        container.innerHTML = preamble;
        
        // After 4 seconds, show the game
        setTimeout(() => {
            showVisiCellGame(container);
        }, 4000);
    }
    
    function showVisiCellGame(container) {
        // Show the ASCII game grid again with input handler
        const ascii = `
╔═══════════════════════════════════════════════════════╗
║         VISICELL SIM 2.0                              ║
║    LEVEL 1: Fudge the numbers without boss noticing! ║
╠════╦═══════╦═══════╦═══════╦═══════╦═══════╦═══════╣
║    ║   A   ║   B   ║   C   ║   D   ║   E   ║   F   ║
╠════╬═══════╬═══════╬═══════╬═══════╬═══════╬═══════╣
║  1 ║       ║       ║       ║       ║       ║       ║
╠════╬═══════╬═══════╬═══════╬═══════╬═══════╬═══════╣
║  2 ║       ║       ║       ║       ║       ║       ║
╠════╬═══════╬═══════╬═══════╬═══════╬═══════╬═══════╣
║  3 ║       ║1245.67║       ║       ║       ║       ║
╠════╬═══════╬═══════╬═══════╬═══════╬═══════╬═══════╣
║  4 ║       ║ 892.34║       ║       ║       ║       ║
╠════╬═══════╬═══════╬═══════╬═══════╬═══════╬═══════╣
║  5 ║       ║       ║       ║   <span style="color: #ff0; animation: blink 1s step-end infinite;">$_</span>    ║       ║       ║
╠════╬═══════╬═══════╬═══════╬═══════╬═══════╬═══════╣
║  6 ║       ║       ║       ║       ║       ║       ║
╠════╬═══════╬═══════╬═══════╬═══════╬═══════╬═══════╣
║  7 ║       ║=SUM(..)║       ║       ║       ║       ║
╠════╬═══════╬═══════╬═══════╬═══════╬═══════╬═══════╣
║  8 ║       ║       ║       ║       ║REVENUE║       ║
╠════╬═══════╬═══════╬═══════╬═══════╬═══════╬═══════╣
║  9 ║       ║       ║       ║       ║Q1 2024║       ║
╠════╬═══════╬═══════╬═══════╬═══════╬═══════╬═══════╣
║ 10 ║       ║       ║       ║       ║       ║       ║
╚════╩═══════╩═══════╩═══════╩═══════╩═══════╩═══════╝

STATUS: Waiting for input in D5 | Press any key to continue
`;
        
        container.innerHTML = ascii;
        
        // Any input = immediate death
        function handleSimInput(e) {
            if (e.key.length === 1) {
                document.removeEventListener('keydown', handleSimInput);
                simGameOver(container);
            }
        }
        
        document.addEventListener('keydown', handleSimInput);
    }
    
    function simGameOver(container) {
        container.style.filter = 'brightness(3) saturate(5)';
        container.style.transition = 'filter 0.1s';
        
        setTimeout(() => {
            container.style.filter = 'brightness(1)';
            container.style.transition = 'filter 0.3s';
            
            // Phase 1: Green monospace (VisiCell style)
            container.innerHTML = `
                <div id="death-message" style="text-align: center; margin-top: 200px;">
                    <div style="font-size: 48px; font-family: 'Courier New', monospace; color: #0f0; text-shadow: 0 0 5px #0f0;">
                        YOU DIED
                    </div>
                </div>
            `;
            
            // Phase 2: Glitch to Dark Souls style (red)
            setTimeout(() => {
                const deathMsg = document.getElementById('death-message');
                if (deathMsg) {
                    deathMsg.innerHTML = `
                        <div style="font-size: 64px; color: #f00; text-shadow: 0 0 30px #f00; filter: blur(2px); transition: filter 0.3s;">
                            YOU DIED
                        </div>
                    `;
                    container.style.filter = 'brightness(0.3)';
                    
                    setTimeout(() => {
                        deathMsg.querySelector('div').style.filter = 'blur(0)';
                    }, 200);
                }
            }, 800);
            
            // Phase 3: Glitch to GTA WASTED style (black/white)
            setTimeout(() => {
                const deathMsg = document.getElementById('death-message');
                if (deathMsg) {
                    container.style.filter = 'brightness(1) saturate(0) contrast(1.2)';
                    deathMsg.innerHTML = `
                        <div style="font-size: 72px; font-family: 'Pricedown', 'Impact', sans-serif; font-weight: 900; color: #ff0000; text-shadow: 3px 3px 0px #000, -1px -1px 0px #000, 1px -1px 0px #000, -1px 1px 0px #000, 5px 5px 10px rgba(0,0,0,0.8); letter-spacing: 0.05em; transform: skewY(-2deg);">
                            WASTED
                        </div>
                    `;
                }
            }, 2000);
            
            // Phase 4: Return to original VisiCell look
            setTimeout(() => {
                // Restore original spreadsheet content
                container.style.filter = 'sepia(0.3) hue-rotate(90deg)';
                container.style.transition = 'filter 0.5s, opacity 0.5s';
                
                // Re-show the spreadsheet
                const spreadsheetHTML = `
                    <div style="font-family: 'Courier New', monospace; font-size: 12px; line-height: 1.4;">
                        <div style="text-align: center; padding: 8px; border-bottom: 1px solid #0f0; margin-bottom: 10px; background: #001100;">
                            <div style="font-size: 14px; color: #ff0; letter-spacing: 0.2em;">VISICELL SIM 1.0</div>
                            <div style="font-size: 11px; color: #0ff; margin-top: 4px;">LEVEL 1: Fudge the numbers without boss finding out!</div>
                        </div>
                        <div style="display: flex; border-bottom: 1px solid #0f0;">
                            <div style="width: 35px; background: #001100; border-right: 1px solid #0f0; padding: 4px; text-align: center; font-weight: bold;"></div>`;
                
                let fullHTML = spreadsheetHTML;
                
                // Column headers
                for (let i = 0; i < 10; i++) {
                    fullHTML += `<div style="flex: 1; background: #001100; border-right: 1px solid #0f0; padding: 4px; text-align: center; font-weight: bold;">${String.fromCharCode(65 + i)}</div>`;
                }
                fullHTML += `</div>`;
                
                // Generate rows
                for (let row = 1; row <= 20; row++) {
                    fullHTML += `<div style="display: flex; border-bottom: 1px solid #0f0;">`;
                    fullHTML += `<div style="width: 35px; background: #001100; border-right: 1px solid #0f0; padding: 4px; text-align: center; font-weight: bold;">${row}</div>`;
                    
                    for (let col = 0; col < 10; col++) {
                        const cellValue = (row === 3 && col === 1) ? '1245.67' : 
                                         (row === 4 && col === 1) ? '892.34' :
                                         (row === 5 && col === 3) ? '' :
                                         (row === 7 && col === 1) ? '=SUM(B3:B5)' :
                                         (row === 8 && col === 4) ? 'REVENUE' :
                                         (row === 9 && col === 4) ? 'Q1 2024' : '';
                        
                        fullHTML += `<div style="flex: 1; border-right: 1px solid #0f0; padding: 4px; text-align: right;">${cellValue}</div>`;
                    }
                    fullHTML += `</div>`;
                }
                
                fullHTML += `
                        <div id="death-status-bar" style="margin-top: 10px; padding: 8px; border-top: 1px solid #0f0; background: #001100; text-align: left; color: #0ff; font-size: 11px; line-height: 1.8;">
                            <span id="death-typing"></span><span id="death-cursor" style="animation: blink 1s step-end infinite;">_</span>
                        </div>
                    </div>
                `;
                
                container.innerHTML = fullHTML;
                
                // Type the messages
                const messages = [
                    'You died.',
                    'Of dysentery.',
                    'Oh well.'
                ];
                let messageIndex = 0;
                let currentText = '';
                
                function typeNextMessage() {
                    if (messageIndex >= messages.length) {
                        // All done - fade out
                        setTimeout(() => {
                            container.style.opacity = '0';
                            setTimeout(() => {
                                container.remove();
                                resetVisiCellTerminal();
                            }, 1000);
                        }, 2000);
                        return;
                    }
                    
                    const message = messages[messageIndex];
                    let charIndex = 0;
                    
                    function typeChar() {
                        if (charIndex < message.length) {
                            currentText += message[charIndex];
                            const typingEl = document.getElementById('death-typing');
                            if (typingEl) {
                                typingEl.textContent = currentText;
                            }
                            charIndex++;
                            setTimeout(typeChar, 50 + Math.random() * 50);
                        } else {
                            // Message complete
                            currentText += ' ';
                            const typingEl = document.getElementById('death-typing');
                            if (typingEl) {
                                typingEl.textContent = currentText;
                            }
                            messageIndex++;
                            setTimeout(typeNextMessage, 800);
                        }
                    }
                    
                    typeChar();
                }
                
                setTimeout(typeNextMessage, 500);
            }, 3200);
            
        }, 100);
    }
    
    function startOzymandiasPuzzle() {
        ozymandiasPuzzleActive = true;
        console.log('🔐 Starting Ozymandias Puzzle');
        
        const frame = document.getElementById('visicalc-frame');
        if (!frame) return;
        
        const puzzleContainer = document.createElement('div');
        puzzleContainer.id = 'ozymandias-puzzle';
        puzzleContainer.style.cssText = `
            position: absolute;
            inset: 0;
            background: #000;
            color: #ff00ff;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
        `;
        
        frame.appendChild(puzzleContainer);
        
        // Theo's taunts
        const taunts = [
            "Enjoy your cardboard kingdom, Ozymandias.",
            "I used your password."
        ];
        
        let currentLine = 0;
        let charIndex = 0;
        let currentText = '';
        
        function typeTaunt() {
            if (currentLine >= taunts.length) {
                setTimeout(() => showPasswordInput(puzzleContainer), 1000);
                return;
            }
            
            if (charIndex < taunts[currentLine].length) {
                currentText += taunts[currentLine][charIndex];
                puzzleContainer.innerHTML = `<div style="font-size: 24px; text-align: center; line-height: 1.8; text-shadow: 0 0 10px #ff00ff;">${currentText}<span style="animation: blink 0.8s step-end infinite;">_</span></div>`;
                charIndex++;
                setTimeout(typeTaunt, 30 + Math.random() * 30);
            } else {
                currentText += '<br><br>';
                puzzleContainer.innerHTML = currentText;
                currentLine++;
                charIndex = 0;
                setTimeout(typeTaunt, 800);
            }
        }
        
        typeTaunt();
    }
    
    function showPasswordInput(container) {
        container.innerHTML += `
            <div style="margin-top: 40px; text-align: center;">
                <div style="font-size: 20px; margin-bottom: 20px; color: #0ff;">
                    Enter PASSWORD to regain control:
                </div>
                <div style="font-size: 28px; color: #0f0;">
                    <span id="password-input-text"></span><span style="animation: blink 0.8s step-end infinite;">_</span>
                </div>
            </div>
        `;
        
        let passwordInput = '';
        
        function handlePasswordInput(e) {
            if (e.key === 'Backspace') {
                e.preventDefault();
                if (passwordInput.length > 0) {
                    passwordInput = passwordInput.slice(0, -1);
                    document.getElementById('password-input-text').textContent = passwordInput;
                }
            } else if (e.key === 'Enter') {
                e.preventDefault();
                checkPassword(passwordInput, container);
            } else if (e.key.length === 1 && /[a-zA-Z0-9 ]/.test(e.key)) {
                e.preventDefault();
                passwordInput += e.key.toUpperCase();
                document.getElementById('password-input-text').textContent = passwordInput;
            }
        }
        
        document.addEventListener('keydown', handlePasswordInput);
        
        function checkPassword(input, cont) {
            const normalized = input.trim().toUpperCase().replace(/\s+/g, ' ');
            if (normalized === 'RAMSES II' || normalized === 'RAMSES 2') {
                document.removeEventListener('keydown', handlePasswordInput);
                showTheoCounter(cont);
            } else if (input.trim().length > 0) {
                // Wrong password - shake
                const inputDisplay = document.getElementById('password-input-text');
                inputDisplay.parentElement.style.animation = 'shake 0.5s';
                setTimeout(() => {
                    inputDisplay.parentElement.style.animation = '';
                    passwordInput = '';
                    document.getElementById('password-input-text').textContent = '';
                }, 500);
            }
        }
    }
    
    function showTheoCounter(container) {
        container.innerHTML = `
            <div style="text-align: center; font-size: 32px; color: #f00; text-shadow: 0 0 20px #f00;">
                I changed it 35 minutes ago!
            </div>
        `;
        
        setTimeout(() => showTimeSettingsUI(container), 2000);
    }
    
    function showTimeSettingsUI(container) {
        container.innerHTML = `
            <div style="text-align: center; max-width: 600px;">
                <div style="font-size: 24px; margin-bottom: 40px; color: #0ff;">
                    ⏰ SYSTEM TIME SETTINGS
                </div>
                <div style="margin-bottom: 30px; font-size: 18px; color: #0f0;">
                    Current Time: <span id="current-time-display" style="color: #ff0;">00:00</span>
                </div>
                <div style="margin-bottom: 20px; font-size: 16px;">
                    Set new time (minutes ago):
                </div>
                <div style="display: flex; gap: 20px; justify-content: center; align-items: center; margin-bottom: 30px;">
                    <button id="time-minus" style="
                        width: 50px;
                        height: 50px;
                        font-size: 32px;
                        background: #000;
                        color: #0ff;
                        border: 2px solid #0ff;
                        cursor: pointer;
                    ">-</button>
                    <div id="time-adjustment" style="font-size: 36px; color: #ff0; min-width: 100px;">0</div>
                    <button id="time-plus" style="
                        width: 50px;
                        height: 50px;
                        font-size: 32px;
                        background: #000;
                        color: #0ff;
                        border: 2px solid #0ff;
                        cursor: pointer;
                    ">+</button>
                </div>
                <button id="time-confirm" style="
                    padding: 15px 40px;
                    font-size: 18px;
                    background: #000;
                    color: #0f0;
                    border: 2px solid #0f0;
                    cursor: pointer;
                    text-shadow: 0 0 10px #0f0;
                ">APPLY</button>
            </div>
        `;
        
        let minutesAgo = 0;
        const timeDisplay = document.getElementById('time-adjustment');
        
        document.getElementById('time-minus').addEventListener('click', () => {
            if (minutesAgo > 0) {
                minutesAgo--;
                timeDisplay.textContent = minutesAgo;
            }
        });
        
        document.getElementById('time-plus').addEventListener('click', () => {
            minutesAgo++;
            timeDisplay.textContent = minutesAgo;
        });
        
        document.getElementById('time-confirm').addEventListener('click', () => {
            if (minutesAgo >= 35) {
                solvePuzzle(container);
            } else {
                // Shake if wrong
                container.style.animation = 'shake 0.5s';
                setTimeout(() => container.style.animation = '', 500);
            }
        });
    }
    
    function solvePuzzle(container) {
        // Mark puzzle as solved
        ozymandiasSolved = true;
        console.log('✅ Ozymandias puzzle solved! LEAVE command now triggers House of Leaves sequence');
        
        container.style.opacity = '0';
        container.style.transition = 'opacity 0.5s';
        
        setTimeout(() => {
            container.innerHTML = `
                <div style="text-align: center; font-size: 48px; color: #0ff; text-shadow: 0 0 30px #0ff; animation: pulse 2s infinite;">
                    Touché
                </div>
            `;
            container.style.opacity = '1';
            
            setTimeout(() => {
                container.style.opacity = '0';
                setTimeout(() => {
                    container.remove();
                    resetVisiCellTerminal();
                }, 500);
            }, 3000);
        }, 500);
    }
    
    function resetVisiCellTerminal() {
        leaveSequenceActive = false;
        visiCellSimActive = false;
        ozymandiasPuzzleActive = false;
        terminalActive = true;
        
        const terminalEl = document.getElementById('visicellinput');
        if (terminalEl) terminalEl.style.display = 'block';
        
        terminalInput = 'ENTE';
        updateTerminalPrompt();
    }
    
    function startCellAddressSequence(frame, visiCalc) {
        console.log('🔷 Starting cell address sequence');
        console.log('📺 VisiCalc display:', visiCalc ? 'exists' : 'missing');
        console.log('🖼️ Frame element:', frame ? 'exists' : 'missing');
        
        // Mark THE.OS scene as seen
        localStorage.setItem('megred_seen_theos', 'true');
        
        // Hide existing content and visiCalc
        const frameEl = document.getElementById('visicalc-frame');
        if (frameEl) {
            frameEl.style.opacity = '0';
            frameEl.style.transition = 'opacity 0.5s ease';
        }
        if (visiCalc) {
            visiCalc.style.transition = 'opacity 0.5s ease';
            visiCalc.style.opacity = '0';
        }
        
        // Create 3D scene for cell addresses and cubes
        const addressScene = new THREE.Scene();
        addressScene.background = new THREE.Color(0x000000);
        const addressCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        addressCamera.position.set(0, 0, -120); // Centered on Z axis to see full 26x26x26 cube grid
        
        // Mouse look controls for white room
        let mouseX = 0, mouseY = 0;
        let targetRotationX = 0, targetRotationY = 0;
        let isMouseLookActive = false;
        
        function onMouseMove(event) {
            if (!isMouseLookActive) return;
            
            const deltaX = event.movementX || 0;
            const deltaY = event.movementY || 0;
            
            targetRotationY -= deltaX * 0.002;
            targetRotationX -= deltaY * 0.002;
            
            // Clamp vertical rotation
            targetRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetRotationX));
        }
        
        function onMouseDown(event) {
            console.log('🖱️ Mouse down at sequenceTime:', sequenceTime.toFixed(1), 'whiteRoom:', !!addressScene.userData.whiteRoomCreated, 'blackHole:', !!addressScene.userData.blackHoleCreated);
            
            // Check for black hole click first
            if (addressScene.userData.blackHoleCreated && sequenceTime > 55) {
                // Raycast to check if black hole was clicked
                const rect = addressRenderer.domElement.getBoundingClientRect();
                const mouse = new THREE.Vector2();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, addressCamera);
                
                // Check all potential black hole objects
                const blackHoleObjects = [];
                if (addressScene.userData.blackHoleSphere) blackHoleObjects.push(addressScene.userData.blackHoleSphere);
                if (addressScene.userData.blackCore) blackHoleObjects.push(addressScene.userData.blackCore);
                if (addressScene.userData.eventHorizon) blackHoleObjects.push(addressScene.userData.eventHorizon);
                if (addressScene.userData.accretionDisk) blackHoleObjects.push(addressScene.userData.accretionDisk);
                
                const intersects = raycaster.intersectObjects(blackHoleObjects, true);
                
                if (intersects.length > 0) {
                    console.log('🕳️ BLACK HOLE CLICKED - Starting Theo dialogue');
                    localStorage.setItem('megred_seen_theos', 'true');
                    localStorage.setItem('megred_seen_blackhole', 'true');
                    startTheoDialogue();
                    return;
                }
                
                // If no black hole click, activate mouse look
                isMouseLookActive = true;
                addressRenderer.domElement.style.cursor = 'none';
                console.log('🖱️ Mouse look ACTIVATED');
            } else {
                console.log('🖱️ Not ready for mouse look yet');
            }
        }
        
        function onMouseUp(event) {
            isMouseLookActive = false;
            addressRenderer.domElement.style.cursor = 'crosshair';
            console.log('🖱️ Mouse look deactivated');
        }
        
        // Will attach to canvas after it's created
        let mouseMoveAttached = false;
        let mouseDownAttached = false;
        let mouseUpAttached = false;
        
        const addressRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        addressRenderer.setSize(window.innerWidth, window.innerHeight);
        addressRenderer.setClearColor(0x000000, 1);
        addressRenderer.setPixelRatio(window.devicePixelRatio);
        addressRenderer.domElement.style.cssText = 'position: fixed; inset: 0; z-index: 200; display: block; pointer-events: auto; cursor: crosshair;';
        addressRenderer.domElement.id = 'address-canvas';
        document.body.appendChild(addressRenderer.domElement);
        console.log('✅ Address renderer created and added to DOM');
        console.log('🖱️ Canvas z-index: 200, pointer-events: auto');
        
        // Attach mouse event listeners to canvas
        addressRenderer.domElement.addEventListener('mousemove', onMouseMove);
        addressRenderer.domElement.addEventListener('mousedown', onMouseDown);
        addressRenderer.domElement.addEventListener('mouseup', onMouseUp);
        console.log('🖱️ Mouse event listeners attached to canvas');
        
        // Add bloom composer
        const addressComposer = new EffectComposer(addressRenderer);
        const renderPass = new RenderPass(addressScene, addressCamera);
        addressComposer.addPass(renderPass);
        const addressBloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.8, 0.4, 0.3); // Reduced bloom
        addressComposer.addPass(addressBloom);
        console.log('✅ Address composer created with bloom');
        
        // Handle window resize
        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            addressCamera.aspect = width / height;
            addressCamera.updateProjectionMatrix();
            addressRenderer.setSize(width, height);
            addressComposer.setSize(width, height);
            console.log('📐 Window resized:', width, 'x', height);
        });
        
        // Cell address data
        const addresses = [];
        const cubes = [];
        const maxAddresses = 20000; // Increased for 26x26x26 grid (17,576 total positions)
        let addressPhase = 0; // 0: 2D (A1, B2), 1: 3D (A1α, B2β)
        let cubePhase = false;
        
        // Greek letters for Z-axis
        const greekLetters = ['α', 'β', 'γ', 'δ', 'ε', 'ζ', 'η', 'θ', 'ι', 'κ', 'λ', 'μ', 'ν', 'ξ', 'ο', 'π', 'ρ', 'σ', 'τ', 'υ', 'φ', 'χ', 'ψ', 'ω'];
        
        // Create text sprites for cell addresses using CELLI notation
        function createAddressSprite(col, row, depth, is3D) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 128;
            
            // Transparent background
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#00ff00'; // Bright green
            ctx.font = 'bold 48px "Courier New", monospace'; // Larger font
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Convert to cell notation: A1, B2, C3, etc.
            const colLetter = String.fromCharCode(65 + (col % 26)); // A, B, C...
            const rowNum = row + 1;
            const text = is3D ? `${colLetter}${rowNum}${greekLetters[depth % greekLetters.length]}` : `${colLetter}${rowNum}`;
            ctx.fillText(text, 128, 64);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            const spriteMat = new THREE.SpriteMaterial({ 
                map: texture, 
                transparent: true, 
                opacity: 1.0,
                depthTest: false,
                depthWrite: false
            });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.scale.set(3.5, 1.75, 1); // Larger sprites
            sprite.renderOrder = 1000; // Render on top
            
            return sprite;
        }
        
        // Create geometries for shape-shifting
        const cubeGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const pyramidGeo = new THREE.ConeGeometry(0.35, 0.6, 4);
        pyramidGeo.rotateY(Math.PI / 4);
        const sphereGeo = new THREE.SphereGeometry(0.35, 16, 16);
        
        const greenMat = new THREE.MeshStandardMaterial({ color: 0x00ff00, transparent: true, opacity: 0.9, emissive: 0x00ff00, emissiveIntensity: 0.5, metalness: 0.3, roughness: 0.4 });
        const yellowMat = new THREE.MeshStandardMaterial({ color: 0xffff00, transparent: true, opacity: 0.9, emissive: 0xffff00, emissiveIntensity: 0.5, metalness: 0.3, roughness: 0.4 });
        const blueMat = new THREE.MeshStandardMaterial({ color: 0x0088ff, transparent: true, opacity: 0.9, emissive: 0x0088ff, emissiveIntensity: 0.5, metalness: 0.3, roughness: 0.4 });
        const redMat = new THREE.MeshStandardMaterial({ color: 0xff0000, transparent: true, opacity: 0.9, emissive: 0xff0000, emissiveIntensity: 0.5, metalness: 0.3, roughness: 0.4 });
        const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.9, emissive: 0xffffff, emissiveIntensity: 0.5, metalness: 0.3, roughness: 0.4 });
        
        // Add lights for 3D visibility
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        addressScene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xffffff, 1.2, 100);
        pointLight.position.set(0, 0, 10);
        addressScene.add(pointLight);
        
        // Add additional lights for better visibility
        const pointLight2 = new THREE.PointLight(0xffffff, 0.8, 100);
        pointLight2.position.set(15, 15, 15);
        addressScene.add(pointLight2);
        
        const pointLight3 = new THREE.PointLight(0xffffff, 0.8, 100);
        pointLight3.position.set(-15, -15, -15);
        addressScene.add(pointLight3);
        
        // Grid configuration - FULL 26x26x26 CUBE (A-Z columns)
        const gridSpacing = 2.5;
        const gridSize = { cols: 26, rows: 26, depth: 26 }; // FULL CUBE: 17,576 positions (26x26x26)
        const gridPositions = [];
        
        // Pre-calculate all grid positions - TRULY centered around origin
        for (let col = 0; col < gridSize.cols; col++) {
            for (let row = 0; row < gridSize.rows; row++) {
                for (let depth = 0; depth < gridSize.depth; depth++) {
                    // Center calculation: use middle of range as origin
                    const x = (col - (gridSize.cols - 1) / 2) * gridSpacing;
                    const y = (row - (gridSize.rows - 1) / 2) * gridSpacing;
                    const z = (depth - (gridSize.depth - 1) / 2) * gridSpacing * 1.0; // Equal spacing for cube shape
                    
                    gridPositions.push({
                        col: col,
                        row: row,
                        depth: depth,
                        x: x,
                        y: y,
                        z: z
                    });
                }
            }
        }
        
        console.log('📍 Grid bounds:');
        console.log('  X range:', (0 - gridSize.cols / 2 + 0.5) * gridSpacing, 'to', (gridSize.cols - 1 - gridSize.cols / 2 + 0.5) * gridSpacing);
        console.log('  Y range:', (0 - gridSize.rows / 2 + 0.5) * gridSpacing, 'to', (gridSize.rows - 1 - gridSize.rows / 2 + 0.5) * gridSpacing);
        console.log('  Z range: 0 to', (gridSize.depth - 1) * gridSpacing * 2.5);
        console.log('📍 Sample positions:');
        console.log('  Corner (0,0,0):', gridPositions[0]);
        console.log('  Center (~10,6,7):', gridPositions[Math.floor(gridPositions.length / 2)]);
        console.log('  Far (19,11,14):', gridPositions[gridPositions.length - 1]);
        
        // Shuffle ONLY within each depth layer for organized appearance
        const layers = {};
        gridPositions.forEach(pos => {
            if (!layers[pos.depth]) layers[pos.depth] = [];
            layers[pos.depth].push(pos);
        });
        
        // Shuffle each layer
        Object.values(layers).forEach(layer => {
            for (let i = layer.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [layer[i], layer[j]] = [layer[j], layer[i]];
            }
        });
        
        // Rebuild gridPositions in depth order
        gridPositions.length = 0;
        for (let depth = 0; depth < gridSize.depth; depth++) {
            if (layers[depth]) {
                gridPositions.push(...layers[depth]);
            }
        }
        
        const maxZ = (gridSize.depth - 1) * gridSpacing * 2.5;
        const centerZ = 0; // Grid is now centered at origin
        
        console.log('📍 Grid setup:', gridSize, 'Total positions:', gridPositions.length);
        console.log('📍 Grid centered at origin (0, 0, 0)');
        console.log('📍 X range:', -(gridSize.cols - 1) / 2 * gridSpacing, 'to', (gridSize.cols - 1) / 2 * gridSpacing);
        console.log('📍 Y range:', -(gridSize.rows - 1) / 2 * gridSpacing, 'to', (gridSize.rows - 1) / 2 * gridSpacing);
        console.log('📍 Z range:', -maxZ / 2, 'to', maxZ / 2);
        
        // Add visual debug helpers
        const helpers = new THREE.Group();
        
        // Add axes helper at origin
        const axesHelper = new THREE.AxesHelper(30);
        helpers.add(axesHelper);
        
        // Add grid at z=0
        const gridHelper = new THREE.GridHelper(
            gridSize.cols * gridSpacing, 
            gridSize.cols, 
            0x00ff00, 
            0x004400
        );
        gridHelper.rotation.x = Math.PI / 2;
        helpers.add(gridHelper);
        
        // Add bounding box visualization - centered properly (CUBE shape with GREEN glow)
        const depthRange = (gridSize.depth - 1) * gridSpacing * 1.0; // Equal depth
        const boxGeo = new THREE.BoxGeometry(
            gridSize.cols * gridSpacing,
            gridSize.rows * gridSpacing,
            depthRange
        );
        const boxMat = new THREE.MeshBasicMaterial({ 
            color: 0x00ff00, // GREEN not cyan
            wireframe: true, 
            transparent: true, 
            opacity: 0.6 
        });
        const boundingBox = new THREE.Mesh(boxGeo, boxMat);
        boundingBox.position.set(0, 0, 0); // Centered at origin
        helpers.add(boundingBox);
        
        // Add markers at each depth layer
        for (let d = 0; d < gridSize.depth; d++) {
            const markerGeo = new THREE.PlaneGeometry(0.5, 0.5);
            const markerMat = new THREE.MeshBasicMaterial({ 
                color: d === 0 ? 0xff0000 : 0x00ff00, // GREEN markers
                transparent: true,
                opacity: 0.6
            });
            const marker = new THREE.Mesh(markerGeo, markerMat);
            const markerZ = (d - (gridSize.depth - 1) / 2) * gridSpacing * 1.0; // Match equal Z
            marker.position.set(
                -gridSize.cols * gridSpacing / 2 + 1,
                gridSize.rows * gridSpacing / 2 - 1,
                markerZ
            );
            helpers.add(marker);
        }
        
        // Start debug helpers hidden - they'll glitch in
        helpers.visible = false;
        addressScene.add(helpers);
        addressScene.userData.debugHelpers = helpers;
        
        let gridIndex = 0;
        
        // Spawn addresses gradually
        let spawnTimer = 0;
        const spawnInterval = 0.05;
        
        const clock = new THREE.Clock();
        let sequenceTime = 0;
        let cameraRotating = false;
        
        // Camera will look at origin - grid is centered
        const gridCenter = new THREE.Vector3(0, 0, 0);
        const actualCenterX = 0;
        const actualCenterY = 0;
        const actualCenterZ = 0;
        
        // Position camera to see the ENTIRE grid PERFECTLY CENTERED
        // Grid is 26x26x26 cubes, spacing 2.5 = 65x65x65 units, centered at origin
        addressCamera.position.set(0, 0, -120); // Back on Z axis, centered on X and Y for wide view
        addressCamera.lookAt(0, 0, 0); // Look directly at origin
        addressCamera.updateProjectionMatrix();
        
        console.log('📷 Camera at (0, 0, -120) looking at origin (0, 0, 0)');
        console.log('📷 Grid: 26x26x26 cube, 65x65x65 units, centered at (0,0,0)');
        console.log('📷 Camera FOV:', addressCamera.fov, 'Aspect:', addressCamera.aspect);
        console.log('🎬 Grid should be PERFECTLY CENTERED in view');
        console.log('🎬 Camera Animation Flow:');
        console.log('   0-8s: Fill 2D plane at z=-120');
        console.log('   8-10s: Rumble at z=-120');
        console.log('   10-14s: Dolly forward to z=-20 while filling depth');
        console.log('   14-20s: Rotate + dolly back to z=-80');
        console.log('   20s+: Continue orbiting while cubes appear');
        
        // Chime function for cube burst
        function playChimeForCube(index) {
            if (!audioCtx) return;
            try {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                
                const baseFreq = 800;
                const freq = baseFreq + (index % 12) * 50;
                osc.frequency.value = freq;
                osc.type = 'sine';
                
                gain.gain.setValueAtTime(0.03, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
                
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start(audioCtx.currentTime);
                osc.stop(audioCtx.currentTime + 0.3);
            } catch (err) {
                // Silently fail if audio context not available
            }
        }
        
        function animateAddresses() {
            const delta = clock.getDelta();
            sequenceTime += delta;
            spawnTimer += delta;
            
            // Debug log every second with camera position
            if (Math.floor(sequenceTime) !== Math.floor(sequenceTime - delta)) {
                console.log(`⏱️ ${sequenceTime.toFixed(1)}s | Addresses: ${addresses.length}, Cubes: ${cubes.length} | Cam: (${addressCamera.position.x.toFixed(1)}, ${addressCamera.position.y.toFixed(1)}, ${addressCamera.position.z.toFixed(1)})`);
            }
            
            // Fade debug helpers after 20s
            if (sequenceTime > 20 && addressScene.userData.debugHelpers) {
                addressScene.userData.debugHelpers.visible = false;
            }
            
            // Phase 1: Spawn 2D addresses on grid (0-8s) - Fill the 2D plane ONLY
            if (sequenceTime < 8 && spawnTimer > spawnInterval) {
                spawnTimer = 0;
                
                // Find next depth=0 position
                while (gridIndex < gridPositions.length && gridPositions[gridIndex].depth !== 0) {
                    gridIndex++;
                }
                
                if (gridIndex < gridPositions.length) {
                    const pos = gridPositions[gridIndex];
                    const sprite = createAddressSprite(pos.col, pos.row, 0, false);
                    sprite.position.set(pos.x, pos.y, pos.z); // Use pos.z from grid calculation
                    sprite.userData = { ...pos, isCube: false, gridX: pos.col, gridY: pos.row, gridZ: 0, depth: 0 };
                    addressScene.add(sprite);
                    addresses.push(sprite);
                    
                    if (addresses.length === 1) {
                        console.log('✅ First 2D address spawned:', { x: pos.x.toFixed(2), y: pos.y.toFixed(2), z: pos.z.toFixed(2), text: `${String.fromCharCode(65 + pos.col)}${pos.row + 1}` });
                        console.log('📷 Camera is at:', addressCamera.position);
                        console.log('📷 Camera is looking at: (0, 0, 0)');
                    }
                    if (addresses.length <= 5) {
                        console.log(`📍 Address #${addresses.length} at (${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})`);
                    }
                    gridIndex++;
                }
            }
            
                // No rotation for addresses - they just float in place
            // (rotation removed per user request)
            
            // Phase 1.5: Static pause showing 2D grid (8-10s) with RUMBLE before expansion
            if (sequenceTime >= 8 && sequenceTime < 10) {
                if (!addressScene.userData.staticPauseStarted) {
                    addressScene.userData.staticPauseStarted = true;
                    console.log('⏸️ Static pause - showing 2D grid, building tension');
                    
                    // Glitch in debug helpers
                    let glitchCount = 0;
                    const glitchInterval = setInterval(() => {
                        if (addressScene.userData.debugHelpers) {
                            addressScene.userData.debugHelpers.visible = !addressScene.userData.debugHelpers.visible;
                            glitchCount++;
                            if (glitchCount > 6) {
                                addressScene.userData.debugHelpers.visible = true;
                                clearInterval(glitchInterval);
                            }
                        }
                    }, 100);
                }
                
                // RUMBLE effect BEFORE Z expansion (9-10s) - building anticipation
                if (sequenceTime >= 9 && sequenceTime < 10) {
                    const rumbleIntensity = (sequenceTime - 9) * 1.2; // Stronger rumble
                    addressCamera.position.x = Math.sin(sequenceTime * 25) * rumbleIntensity;
                    addressCamera.position.y = Math.cos(sequenceTime * 20) * rumbleIntensity;
                    addressCamera.position.z = -120; // Pulled back for 26x26x26 grid
                    addressCamera.lookAt(0, 0, 0);
                    
                    if (!addressScene.userData.rumbleLogged) {
                        console.log('📳 RUMBLE starting - preparing for Z expansion!');
                        addressScene.userData.rumbleLogged = true;
                    }
                } else {
                    // Keep camera centered during first part of pause
                    addressCamera.position.set(0, 0, -120); // Pulled back for 26x26x26 grid
                    addressCamera.lookAt(0, 0, 0);
                }
            }
            
            // Phase 2: Extend into 3D while DOLLYING FORWARD through grid (10-14s)
            if (sequenceTime >= 10 && sequenceTime < 14) {
                if (addressPhase === 0) {
                    addressPhase = 1;
                    
                    // Create depth spawn queue - all positions with depth > 0
                    addressScene.userData.depthQueue = gridPositions.filter(p => p.depth > 0);
                    console.log('🔷 Extending to 3D - depth queue:', addressScene.userData.depthQueue.length, 'positions');
                    console.log('🔷 Depth range:', Math.min(...addressScene.userData.depthQueue.map(p => p.depth)), 
                                'to', Math.max(...addressScene.userData.depthQueue.map(p => p.depth)));
                    console.log('🎬 Camera will dolly forward as grid extends in depth');
                }
                
                // DOLLY FORWARD through the grid as it extends in depth
                const dollyProgress = (sequenceTime - 10) / 4; // 0 to 1 over 4 seconds
                const startZ = -120;
                const endZ = -20; // Push through to near the front of the grid
                addressCamera.position.set(0, 0, THREE.MathUtils.lerp(startZ, endZ, dollyProgress));
                addressCamera.lookAt(0, 0, 0);
                
                // Spawn ALL depth layers RAPIDLY to fill 3D space (multiple per frame)
                const spawnCount = Math.ceil((sequenceTime - 10) * 600); // Fast spawn for 26x26x26 grid
                for (let i = 0; i < spawnCount && addressScene.userData.depthQueue && addressScene.userData.depthQueue.length > 0; i++) {
                    const pos = addressScene.userData.depthQueue.shift();
                    const sprite = createAddressSprite(pos.col, pos.row, pos.depth, true);
                    sprite.position.set(pos.x, pos.y, pos.z); // Use actual Z position
                    sprite.userData = { ...pos, isCube: false, gridX: pos.col, gridY: pos.row, gridZ: pos.depth };
                    addressScene.add(sprite);
                    addresses.push(sprite);
                    
                    if (addresses.length % 200 === 0) {
                        console.log(`📌 Total: ${addresses.length}, Latest: (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}) depth ${pos.depth}/${gridSize.depth - 1}`);
                    }
                }
            }
            
            // Phase 2.5: Camera ROTATES while DOLLYING BACK to reveal LATTICE CUBE (14-20s)
            if (sequenceTime >= 14 && sequenceTime < 20) {
                if (!addressScene.userData.rotationStarted) {
                    addressScene.userData.rotationStarted = true;
                    console.log('🔄 Starting camera rotation + dolly back to reveal lattice cube');
                    console.log('📊 Total addresses in lattice:', addresses.length);
                }
                
                const rotProgress = (sequenceTime - 14) / 6; // 0 to 1 over 6 seconds
                const angle = rotProgress * Math.PI * 0.75; // 135 degree arc
                
                // Dolly back while rotating
                const dollyZ = THREE.MathUtils.lerp(-20, -80, rotProgress);
                const orbitRadius = 90;
                
                addressCamera.position.x = Math.sin(angle) * orbitRadius;
                addressCamera.position.y = THREE.MathUtils.lerp(0, 45, rotProgress);
                addressCamera.position.z = Math.cos(angle) * orbitRadius + dollyZ;
                addressCamera.lookAt(0, 0, 0); // Always look at center
            }
            
            // Phase 3: Text addresses POP into GREEN cubes (20s+) - AFTER lattice is revealed
            if (sequenceTime >= 20 && !cubePhase) {
                cubePhase = true;
                console.log('💚 LATTICE REVEALED! Now bursting into GREEN cubes!');
                
                // Schedule all addresses for transformation to green cubes
                addresses.forEach((addr, i) => {
                    if (!addr.userData.popScheduled) {
                        addr.userData.popScheduled = true;
                        // Faster stagger to complete within 4s window (1000 addresses / 4s = 250/s = 0.004s each)
                        addr.userData.popTime = sequenceTime + (i * 0.004);
                        
                        // Pre-assign RGB shape for later transformation
                        const shapeType = i % 3; // Cycle through shapes
                        addr.userData.targetShape = shapeType;
                    }
                });
            }
            
            // Execute POP transformations: Text → GREEN cubes (20-24s)
            if (sequenceTime >= 20 && sequenceTime < 24) {
                for (let i = addresses.length - 1; i >= 0; i--) {
                    const addr = addresses[i];
                    
                    if (addr.userData.popTime && sequenceTime >= addr.userData.popTime && !addr.userData.popped) {
                        addr.userData.popped = true;
                        
                        // Create GREEN cube
                        const mesh = new THREE.Mesh(cubeGeo, greenMat.clone());
                        mesh.position.copy(addr.position);
                        mesh.userData = { 
                            ...addr.userData,
                            isCube: true,
                            isGreen: true,
                            hasTransformed: false, // Not yet transformed to RGB
                            currentColor: 'green',
                            shapeType: 'cube',
                            birthTime: sequenceTime
                        };
                        
                        // Start small for pop effect
                        mesh.scale.set(0.05, 0.05, 0.05);
                        addressScene.add(mesh);
                        cubes.push(mesh);
                        
                        // Play chime occasionally (not for every cube to avoid audio overload)
                        if (cubes.length % 30 === 0) {
                            playChimeForCube(cubes.length);
                        }
                        
                        // Remove text address
                        addressScene.remove(addr);
                        addresses.splice(i, 1);
                    }
                }
            }
            
            // CLEANUP: Force remove ALL remaining text addresses at 24s
            if (sequenceTime >= 24 && sequenceTime < 24.1 && addresses.length > 0) {
                console.log('🗑️ CLEANUP: Removing', addresses.length, 'residual text addresses');
                for (let i = addresses.length - 1; i >= 0; i--) {
                    addressScene.remove(addresses[i]);
                    if (addresses[i].material && addresses[i].material.map) {
                        addresses[i].material.map.dispose();
                    }
                    if (addresses[i].material) {
                        addresses[i].material.dispose();
                    }
                }
                addresses.length = 0; // Clear array
                console.log('✅ All text addresses cleared');
            }
            
            // Animate green cube pop-in with burst (20s-26s)
            if (sequenceTime >= 20 && sequenceTime < 26) {
                cubes.forEach((cube, i) => {
                    if (!cube.userData.isGreen) return; // Only animate green cubes
                    
                    const age = sequenceTime - cube.userData.birthTime;
                    
                    // Quick pop-in animation (0-0.3s)
                    if (age < 0.3) {
                        // Burst scale: overshoot then settle
                        const progress = age / 0.3;
                        const overshoot = 1.3; // Peak size
                        let targetScale;
                        if (progress < 0.5) {
                            targetScale = THREE.MathUtils.lerp(0.05, overshoot, progress * 2);
                        } else {
                            targetScale = THREE.MathUtils.lerp(overshoot, 1.0, (progress - 0.5) * 2);
                        }
                        cube.scale.setScalar(targetScale);
                        
                        // Bright burst illumination
                        if (cube.material) {
                            const intensity = Math.sin(progress * Math.PI) * 3.0;
                            cube.material.emissiveIntensity = 0.5 + intensity;
                        }
                    } else if (age < 0.35 && cube.scale.x !== 1.0) {
                        // Settle to final size
                        cube.scale.setScalar(1.0);
                        if (cube.material) {
                            cube.material.emissiveIntensity = 0.5;
                        }
                    }
                });
            }
            
            // Phase 4: GREEN cubes glitch into RGB shapes (26s-30s)
            if (sequenceTime >= 26 && sequenceTime < 30) {
                cubes.forEach((cube, i) => {
                    if (cube.userData.isGreen && !cube.userData.glitchStarted) {
                        cube.userData.glitchStarted = true;
                        cube.userData.glitchTime = sequenceTime + (i * 0.002); // Faster stagger glitches
                    }
                    
                    if (cube.userData.glitchStarted && !cube.userData.hasTransformed && sequenceTime >= cube.userData.glitchTime) {
                        cube.userData.hasTransformed = true;
                        
                        // Select shape and color based on pre-assigned targetShape
                        let geo, mat, colorName, shapeName;
                        if (cube.userData.targetShape === 0) {
                            geo = pyramidGeo;
                            mat = yellowMat.clone();
                            colorName = 'yellow';
                            shapeName = 'pyramid';
                        } else if (cube.userData.targetShape === 1) {
                            geo = cubeGeo;
                            mat = blueMat.clone();
                            colorName = 'blue';
                            shapeName = 'cube';
                        } else {
                            geo = sphereGeo;
                            mat = redMat.clone();
                            colorName = 'red';
                            shapeName = 'sphere';
                        }
                        
                        // Replace mesh
                        const pos = cube.position.clone();
                        const userData = { ...cube.userData };
                        
                        addressScene.remove(cube);
                        if (cube.geometry) cube.geometry.dispose();
                        if (cube.material) cube.material.dispose();
                        
                        const newMesh = new THREE.Mesh(geo, mat);
                        newMesh.position.copy(pos);
                        newMesh.scale.set(1.0, 1.0, 1.0); // Always start at normal scale
                        newMesh.userData = {
                            ...userData,
                            isGreen: false,
                            currentColor: colorName,
                            shapeType: shapeName,
                            glitchTransformTime: sequenceTime
                        };
                        
                        addressScene.add(newMesh);
                        
                        // Replace in cubes array
                        const cubeIndex = cubes.indexOf(cube);
                        if (cubeIndex !== -1) {
                            cubes[cubeIndex] = newMesh;
                        }
                    }
                });
            }
            
            // Animate glitch transformation (26s-30s)
            if (sequenceTime >= 26 && sequenceTime < 30) {
                cubes.forEach((cube) => {
                    if (cube.userData.glitchTransformTime) {
                        const glitchAge = sequenceTime - cube.userData.glitchTransformTime;
                        
                        if (glitchAge < 0.2) {
                            // Quick stretch/distort glitch
                            const glitchProgress = glitchAge / 0.2;
                            const distort = Math.sin(glitchProgress * Math.PI * 4) * 0.3;
                            cube.scale.x = 1.0 + distort;
                            cube.scale.y = 1.0 - distort * 0.5;
                            cube.scale.z = 1.0 + distort * 0.5;
                            
                            // Flash emissive
                            if (cube.material) {
                                cube.material.emissiveIntensity = 0.5 + Math.sin(glitchProgress * Math.PI) * 2.0;
                            }
                        } else if (glitchAge < 0.25 && cube.scale.x !== 1.0) {
                            // Snap to final shape
                            cube.scale.set(1.0, 1.0, 1.0);
                            if (cube.material) {
                                cube.material.emissiveIntensity = 0.5;
                            }
                        }
                    }
                });
            }
            
            // Draw dotted lines between RGB cubes (forming cube edges) ONCE (30s)
            if (sequenceTime >= 30 && !addressScene.userData.linesCreated) {
                addressScene.userData.linesCreated = true;
                addressScene.userData.connectionLines = [];
                console.log('🔗 Creating procedural connection lines...');
                
                // Build grid lookup for immediate neighbors
                const gridMap = new Map();
                cubes.forEach(cube => {
                    if (cube.userData.gridX !== undefined) {
                        const key = `${cube.userData.gridX},${cube.userData.gridY},${cube.userData.gridZ}`;
                        gridMap.set(key, cube);
                    }
                });
                
                // Track connections to avoid duplicates
                const connections = new Set();
                let lineCount = 0;
                
                // Draw lines to immediate neighbors for RGB cubes (ONCE)
                cubes.forEach(cube => {
                    if (cube.userData.gridX !== undefined && cube.userData.currentColor && cube.userData.hasTransformed) {
                        const gx = cube.userData.gridX;
                        const gy = cube.userData.gridY;
                        const gz = cube.userData.gridZ;
                        
                        // Check only positive direction neighbors to avoid duplicates (right, up, forward)
                        const neighbors = [
                            { key: `${gx+1},${gy},${gz}`, axis: 'x' },
                            { key: `${gx},${gy+1},${gz}`, axis: 'y' },
                            { key: `${gx},${gy},${gz+1}`, axis: 'z' }
                        ];
                        
                        neighbors.forEach(neighbor => {
                            const neighborCube = gridMap.get(neighbor.key);
                            if (neighborCube && neighborCube.userData.currentColor && neighborCube.userData.hasTransformed) {
                                const connectionKey = `${cube.userData.gridX},${cube.userData.gridY},${cube.userData.gridZ}-${neighborCube.userData.gridX},${neighborCube.userData.gridY},${neighborCube.userData.gridZ}`;
                                if (!connections.has(connectionKey)) {
                                    connections.add(connectionKey);
                                    
                                    // Use average color of both cubes
                                    let lineColor;
                                    if (cube.userData.currentColor === 'yellow') lineColor = 0xffff00;
                                    else if (cube.userData.currentColor === 'blue') lineColor = 0x0088ff;
                                    else if (cube.userData.currentColor === 'red') lineColor = 0xff0000;
                                    else lineColor = 0x00ff00;
                                    
                                    const points = [cube.position, neighborCube.position];
                                    const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
                                    const lineMat = new THREE.LineDashedMaterial({
                                        color: lineColor,
                                        dashSize: 0.12,
                                        gapSize: 0.08,
                                        transparent: true,
                                        opacity: 0.5
                                    });
                                    const line = new THREE.Line(lineGeo, lineMat);
                                    line.computeLineDistances();
                                    addressScene.add(line);
                                    addressScene.userData.connectionLines.push(line);
                                    lineCount++;
                                }
                            }
                        });
                    }
                });
                console.log(`✅ Created ${lineCount} connection lines (procedural, once)`);
            }
            
            // Continue camera rotation after initial rotation (but stop during white room)
            if (sequenceTime >= 20 && sequenceTime < 50) {
                const orbitTime = sequenceTime - 20;
                const orbitRadius = 90; // Larger radius for 26x26x26 grid
                addressCamera.position.x = Math.cos(orbitTime * 0.15) * orbitRadius;
                addressCamera.position.z = Math.sin(orbitTime * 0.15) * orbitRadius;
                addressCamera.position.y = 25 + Math.sin(orbitTime * 0.08) * 10;
                addressCamera.lookAt(0, 0, 0);
            }
            
            // Apply mouse look in white room
            if (isMouseLookActive && sequenceTime > 55) {
                // Apply rotation to camera
                const direction = new THREE.Vector3();
                direction.x = Math.sin(targetRotationY) * Math.cos(targetRotationX);
                direction.y = Math.sin(targetRotationX);
                direction.z = Math.cos(targetRotationY) * Math.cos(targetRotationX);
                direction.normalize();
                
                const lookAtPoint = new THREE.Vector3().addVectors(
                    addressCamera.position,
                    direction.multiplyScalar(10)
                );
                addressCamera.lookAt(lookAtPoint);
                
                if (Math.floor(sequenceTime) % 3 === 0 && Math.floor(sequenceTime) !== Math.floor(sequenceTime - delta)) {
                    console.log(`🖱️ Mouse look active - rotX: ${targetRotationX.toFixed(2)}, rotY: ${targetRotationY.toFixed(2)}`);
                }
            } else if (sequenceTime >= 55 && !isMouseLookActive) {
                // Point at black hole when not actively looking
                addressCamera.lookAt(0, 0, 0);
            }
            
            // Phase 5: Transform RGB shapes back to white cubes (36-40s)
            if (sequenceTime >= 36 && sequenceTime < 40) {
                cubes.forEach((cube, i) => {
                    if (cube.userData.hasTransformed && !cube.userData.zapToWhite) {
                        cube.userData.zapToWhite = true;
                        
                        // Quick zap animation
                        const originalScale = { x: cube.scale.x, y: cube.scale.y, z: cube.scale.z };
                        cube.scale.multiplyScalar(1.5);
                        
                        setTimeout(() => {
                            const pos = cube.position.clone();
                            const userData = { ...cube.userData };
                            
                            addressScene.remove(cube);
                            const whiteCube = new THREE.Mesh(cubeGeo, whiteMat.clone());
                            whiteCube.position.copy(pos);
                            whiteCube.scale.set(originalScale.x, originalScale.y, originalScale.z);
                            whiteCube.userData = userData;
                            whiteCube.userData.isWhite = true;
                            addressScene.add(whiteCube);
                            cubes[i] = whiteCube;
                        }, 100);
                    }
                });
            }
            
            // Phase 6: Collapse cubes to center - NO rotation
            if (sequenceTime >= 40 && sequenceTime < 44) {
                const pullStrength = (sequenceTime - 40) / 4;
                cubes.forEach(cube => {
                    cube.position.x = THREE.MathUtils.lerp(cube.position.x, 0, delta * pullStrength * 2);
                    cube.position.y = THREE.MathUtils.lerp(cube.position.y, 0, delta * pullStrength * 2);
                    cube.position.z = THREE.MathUtils.lerp(cube.position.z, 0, delta * pullStrength * 2);
                });
            }
            
            // Phase 7: Merge into single white rounded cube with bloom (44-50s)
            if (sequenceTime >= 44 && sequenceTime < 50) {
                const whiteness = Math.min(1, (sequenceTime - 44) / 3);
                addressBloom.strength = 1.2 + whiteness * 2.5; // Increase bloom more
                
                cubes.forEach((cube, i) => {
                    if (cube.material) {
                        // Fade to white
                        cube.material.color.r = 1;
                        cube.material.color.g = 1;
                        cube.material.color.b = 1;
                        cube.material.emissive.r = 1;
                        cube.material.emissive.g = 1;
                        cube.material.emissive.b = 1;
                        cube.material.emissiveIntensity = 0.5 + whiteness * 1.0;
                        
                        // Shrink all but the center mass
                        if (i > 15) {
                            cube.scale.multiplyScalar(0.96);
                            cube.material.opacity *= 0.95;
                        } else {
                            // First cubes grow MUCH LARGER
                            const growth = 1 + (sequenceTime - 44) * 0.8;
                            cube.scale.setScalar(growth);
                        }
                    }
                });
            }
            
            // Phase 8: Expand into white room interior (50-55s)
            if (sequenceTime >= 50 && sequenceTime < 55) {
                if (!addressScene.userData.roomCreated) {
                    addressScene.userData.roomCreated = true;
                    console.log('🏠 Creating FPS white room interior with rounded corners and internal lighting');
                    
                    // Remove all connection lines
                    if (addressScene.userData.connectionLines) {
                        addressScene.userData.connectionLines.forEach(line => {
                            addressScene.remove(line);
                            if (line.geometry) line.geometry.dispose();
                            if (line.material) line.material.dispose();
                        });
                        addressScene.userData.connectionLines = [];
                        console.log('🗑️ Connection lines removed for white room');
                    }
                    
                    addressScene.userData.blackCubeSpawnTimer = 0;
                    addressScene.userData.blackCubes = [];
                    
                    // Create white room interior with rounded corners - DIMLY LIT
                    const roomSize = 50;
                    const roomRadius = 4;
                    const roomGeo = new RoundedBoxGeometry(roomSize, roomSize, roomSize, 16, roomRadius);
                    const roomMat = new THREE.MeshStandardMaterial({
                        color: 0xcccccc, // Slightly gray
                        side: THREE.BackSide,
                        roughness: 0.9,
                        metalness: 0.05,
                        emissive: 0x333333, // Very dim emissive
                        emissiveIntensity: 0.05 // Very low
                    });
                    const room = new THREE.Mesh(roomGeo, roomMat);
                    addressScene.add(room);
                    addressScene.userData.roomMesh = room; // Store reference
                    
                    // Add MINIMAL internal room lighting - mostly dark
                    const roomLight1 = new THREE.PointLight(0xffffff, 0.2, 40);
                    roomLight1.position.set(0, 15, 0);
                    addressScene.add(roomLight1);
                    
                    const roomLight2 = new THREE.PointLight(0xffffff, 0.2, 40);
                    roomLight2.position.set(0, -15, 0);
                    addressScene.add(roomLight2);
                    
                    console.log('✅ White room created with DIM lighting');
                    
                    // Further reduce ambient lighting to let black hole dominate
                    ambientLight.intensity = 0.1;
                    pointLight.intensity = 0.1;
                    pointLight2.intensity = 0.2;
                    pointLight3.intensity = 0.2;
                    
                    console.log('🏠 Room created - dimming ambient lights for black hole visibility');
                    
                    console.log('✅ White room created with internal lighting');
                }
                
                // Move camera inside - FPS position, initially pointing AT the black hole
                if (!addressScene.userData.cameraMovingToRoom) {
                    addressScene.userData.cameraMovingToRoom = true;
                    console.log('📹 Camera moving into white room, will point at black hole at (0, 0, 0)');
                }
                
                const moveProgress = (sequenceTime - 50) / 5;
                addressCamera.position.x = THREE.MathUtils.lerp(12, 0, moveProgress);
                addressCamera.position.y = THREE.MathUtils.lerp(10, 2, moveProgress);
                addressCamera.position.z = THREE.MathUtils.lerp(20, 15, moveProgress);
                
                // Always point at black hole center during this phase
                addressCamera.lookAt(0, 0, 0);
                
                if (Math.floor(sequenceTime) % 2 === 0 && Math.floor(sequenceTime) !== Math.floor(sequenceTime - delta)) {
                    console.log(`📹 Camera pos: (${addressCamera.position.x.toFixed(1)}, ${addressCamera.position.y.toFixed(1)}, ${addressCamera.position.z.toFixed(1)}) -> looking at (0, 0, 0)`);
                }
                
                addressScene.userData.whiteRoomCreated = true;
            }
            
            // Phase 9: Create 3D black hole at center (55s+)
            if (sequenceTime >= 55 && !addressScene.userData.blackHoleCreated) {
                addressScene.userData.blackHoleCreated = true;
                console.log('🕳️ Creating 3D black hole sphere at center');
                
                // Voxelized black hole - dark cube sphere (MORE visible)
                const voxelSize = 0.4;
                const voxelGeo = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);
                const blackVoxelMat = new THREE.MeshStandardMaterial({
                    color: 0x222222, // More visible gray
                    emissive: 0x110000, // Slight red emissive
                    emissiveIntensity: 0.3,
                    roughness: 0.9,
                    metalness: 0.1,
                    transparent: false
                });
                
                const voxelSphere = new THREE.Group();
                const baseRadius = 3.0; // Larger
                const voxelCount = 400; // More voxels
                
                for (let i = 0; i < voxelCount; i++) {
                    const phi = Math.acos(-1 + (2 * i) / voxelCount);
                    const theta = Math.sqrt(voxelCount * Math.PI) * phi;
                    
                    const x = baseRadius * Math.cos(theta) * Math.sin(phi);
                    const y = baseRadius * Math.sin(theta) * Math.sin(phi);
                    const z = baseRadius * Math.cos(phi);
                    
                    const voxel = new THREE.Mesh(voxelGeo, blackVoxelMat.clone());
                    voxel.position.set(x, y, z);
                    voxel.lookAt(0, 0, 0);
                    voxel.userData.baseRadius = baseRadius;
                    voxel.userData.phi = phi;
                    voxel.userData.theta = theta;
                    voxelSphere.add(voxel);
                }
                
                addressScene.add(voxelSphere);
                addressScene.userData.voxelSphere = voxelSphere;
                addressScene.userData.voxelSpherePhase = 0;
                
                // Event horizon glow - EXTREMELY bright ring
                const ringGeo = new THREE.TorusGeometry(4.0, 0.5, 16, 100);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: 0xff4400,
                    transparent: false,
                    opacity: 1.0
                });
                const eventHorizon = new THREE.Mesh(ringGeo, ringMat);
                eventHorizon.position.set(0, 0, 0);
                eventHorizon.rotation.x = Math.PI / 2;
                addressScene.add(eventHorizon);
                addressScene.userData.eventHorizon = eventHorizon;
                
                // Add VERY strong point lights at black hole for maximum visibility
                const blackHoleLight1 = new THREE.PointLight(0xff2200, 10.0, 30);
                blackHoleLight1.position.set(0, 0, 0);
                addressScene.add(blackHoleLight1);
                
                const blackHoleLight2 = new THREE.PointLight(0xff6600, 8.0, 25);
                blackHoleLight2.position.set(0, 5, 0);
                addressScene.add(blackHoleLight2);
                
                const blackHoleLight3 = new THREE.PointLight(0xff8800, 6.0, 20);
                blackHoleLight3.position.set(5, 0, 0);
                addressScene.add(blackHoleLight3);
                
                addressScene.userData.blackHoleLight = blackHoleLight1;
                
                console.log('🕳️ Black hole created at (0, 0, 0)');
                console.log('🕳️ Black hole lights: L1=' + blackHoleLight1.intensity + ', L2=' + blackHoleLight2.intensity + ', L3=' + blackHoleLight3.intensity);
                console.log('🕳️ Ambient light:', ambientLight.intensity);
                
                // BLACK CORE - Central black voxel sphere with negative pulsing effect
                const blackCoreGeo = new THREE.BoxGeometry(0.25, 0.25, 0.25);
                const blackCoreMat = new THREE.MeshBasicMaterial({
                    color: 0x000000,
                    transparent: true,
                    opacity: 1.0
                });
                
                const blackCore = new THREE.Group();
                const coreRadius = 1.5; // Smaller than outer sphere
                const coreVoxelCount = 200;
                
                for (let i = 0; i < coreVoxelCount; i++) {
                    const phi = Math.acos(-1 + (2 * i) / coreVoxelCount);
                    const theta = Math.sqrt(coreVoxelCount * Math.PI) * phi;
                    
                    const x = coreRadius * Math.cos(theta) * Math.sin(phi);
                    const y = coreRadius * Math.sin(theta) * Math.sin(phi);
                    const z = coreRadius * Math.cos(phi);
                    
                    const voxel = new THREE.Mesh(blackCoreGeo, blackCoreMat.clone());
                    voxel.position.set(x, y, z);
                    voxel.lookAt(0, 0, 0);
                    voxel.userData.baseRadius = coreRadius;
                    voxel.userData.phi = phi;
                    voxel.userData.theta = theta;
                    voxel.renderOrder = 2000; // Individual voxels render on top
                    voxel.material.depthTest = false; // Always visible
                    voxel.material.depthWrite = false;
                    blackCore.add(voxel);
                }
                
                blackCore.renderOrder = 2000; // Render on top of everything
                addressScene.add(blackCore);
                addressScene.userData.blackCore = blackCore;
                console.log('🕳️ Black core created with renderOrder=2000, depthTest=false');
                addressScene.userData.blackCorePhase = 0;
                addressScene.userData.blackCorePulse = 0;
                
                console.log('🖤 Black core sphere created with', coreVoxelCount, 'voxels');
                console.log('✅ Voxelized black hole created');
                console.log('📊 Outer voxel count:', voxelSphere.children.length);
                console.log('📊 Core voxel count:', blackCore.children.length);
                console.log('🔆 Event horizon position:', eventHorizon.position);
                console.log('💡 Black hole light intensity:', blackHoleLight1.intensity);
                
                // Accretion disk particles
                const particleCount = 200;
                const particleGeo = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 4 + Math.random() * 3;
                    positions[i * 3] = Math.cos(angle) * radius;
                    positions[i * 3 + 1] = (Math.random() - 0.5) * 0.5;
                    positions[i * 3 + 2] = Math.sin(angle) * radius;
                    
                    const heat = 1 - (radius - 4) / 3;
                    colors[i * 3] = 1;
                    colors[i * 3 + 1] = heat * 0.6;
                    colors[i * 3 + 2] = heat * 0.2;
                }
                
                particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                particleGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const particleMat = new THREE.PointsMaterial({
                    size: 0.35,
                    vertexColors: true,
                    transparent: true,
                    opacity: 1.0,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true,
                    depthWrite: false
                });
                
                const particles = new THREE.Points(particleGeo, particleMat);
                addressScene.add(particles);
                addressScene.userData.accretionDisk = particles;
                console.log('✅ Accretion disk particles added to scene');
                
                console.log('✅ Black hole with accretion disk created');
                console.log('📊 Scene objects:', addressScene.children.length);
            }
            
            // Breathing voxelized black hole (outer sphere)
            if (addressScene.userData.voxelSphere) {
                addressScene.userData.voxelSpherePhase += delta * 2;
                const breathe = Math.sin(addressScene.userData.voxelSpherePhase) * 0.2 + 1;
                
                addressScene.userData.voxelSphere.children.forEach(voxel => {
                    const br = voxel.userData.baseRadius;
                    const phi = voxel.userData.phi;
                    const theta = voxel.userData.theta;
                    const radius = br * breathe;
                    
                    voxel.position.x = radius * Math.cos(theta) * Math.sin(phi);
                    voxel.position.y = radius * Math.sin(theta) * Math.sin(phi);
                    voxel.position.z = radius * Math.cos(phi);
                });
                
                addressScene.userData.voxelSphere.rotation.y += delta * 0.2;
                
                // PULSATING BLOOM - lights breathe with black hole to illuminate room
                if (addressScene.userData.blackHoleLight) {
                    const lightPulse = breathe; // Follow breathing pattern
                    addressScene.userData.blackHoleLight.intensity = 8.0 + lightPulse * 6.0; // 8-14 intensity
                    addressBloom.strength = 0.6 + lightPulse * 0.4; // 0.6-1.0 bloom
                    
                    // Illuminate room walls with pulsating bloom
                    if (addressScene.userData.roomMesh && addressScene.userData.roomMesh.material) {
                        addressScene.userData.roomMesh.material.emissiveIntensity = 0.05 + lightPulse * 0.08; // Subtle pulse
                    }
                }
                
                // Debug log every 5 seconds
                if (Math.floor(sequenceTime) % 5 === 0 && Math.floor(sequenceTime) !== Math.floor(sequenceTime - delta)) {
                    console.log(`🕳️ Black hole visible: voxels=${addressScene.userData.voxelSphere.children.length}, breathe=${breathe.toFixed(2)}, bloom=${addressBloom.strength.toFixed(2)}`);
                }
            }
            
            // Pulsing BLACK CORE - inverse pulse with negative black-light gradient
            if (addressScene.userData.blackCore) {
                addressScene.userData.blackCorePhase += delta * 3; // Faster pulse
                addressScene.userData.blackCorePulse += delta * 4;
                
                // Inverse pulse - contracts when outer breathes out
                const corePulse = Math.sin(addressScene.userData.blackCorePhase) * -0.15 + 0.85; // 0.7 to 1.0
                
                addressScene.userData.blackCore.children.forEach((voxel, i) => {
                    const br = voxel.userData.baseRadius;
                    const phi = voxel.userData.phi;
                    const theta = voxel.userData.theta;
                    const radius = br * corePulse;
                    
                    voxel.position.x = radius * Math.cos(theta) * Math.sin(phi);
                    voxel.position.y = radius * Math.sin(theta) * Math.sin(phi);
                    voxel.position.z = radius * Math.cos(phi);
                    
                    // Pulsing opacity creating "negative light" effect
                    const wave = Math.sin(addressScene.userData.blackCorePulse + i * 0.1);
                    const distFromCenter = Math.sqrt(voxel.position.x**2 + voxel.position.y**2 + voxel.position.z**2);
                    const normalizedDist = distFromCenter / (br * corePulse); // 0 at center, 1 at edge
                    
                    // Darker at center, lighter at edges (inverted gradient)
                    voxel.material.opacity = 0.9 + (normalizedDist * 0.1) + (wave * 0.05);
                });
                
                // Counter-rotate to outer sphere
                addressScene.userData.blackCore.rotation.y -= delta * 0.3;
            }
            
            if (addressScene.userData.eventHorizon) {
                addressScene.userData.eventHorizon.rotation.z += delta * 0.8;
            }
            if (addressScene.userData.accretionDisk) {
                addressScene.userData.accretionDisk.rotation.y += delta * 0.5;
            }
            
            // Continuously spawn black cubes
            if (sequenceTime > 55) {
                if (!addressScene.userData.blackCubeSpawnTimer) {
                    addressScene.userData.blackCubeSpawnTimer = 0;
                    addressScene.userData.blackCubes = [];
                }
                
                addressScene.userData.blackCubeSpawnTimer += delta;
                if (addressScene.userData.blackCubeSpawnTimer > 0.15) {
                    addressScene.userData.blackCubeSpawnTimer = 0;
                    
                    // Spawn new black cube far away
                    const angle = Math.random() * Math.PI * 2;
                    const elevation = (Math.random() - 0.5) * Math.PI;
                    const distance = 30 + Math.random() * 15;
                    
                    const blackCubeMat = new THREE.MeshStandardMaterial({
                        color: 0x0a0a0a,
                        transparent: true,
                        opacity: 0.95,
                        emissive: 0x0a0a0a,
                        emissiveIntensity: 0.1
                    });
                    
                    const blackCube = new THREE.Mesh(cubeGeo, blackCubeMat);
                    blackCube.position.set(
                        Math.cos(angle) * Math.cos(elevation) * distance,
                        Math.sin(elevation) * distance,
                        Math.sin(angle) * Math.cos(elevation) * distance
                    );
                    blackCube.userData.beingSucked = true;
                    blackCube.userData.suckStartTime = sequenceTime;
                    blackCube.userData.spiralAngle = angle;
                    blackCube.userData.spiralSpeed = 1.0 + Math.random() * 2.0;
                    blackCube.scale.set(0.6, 0.6, 0.6);
                    
                    addressScene.add(blackCube);
                    addressScene.userData.blackCubes.push(blackCube);
                }
            }
            
            // Spaghettification - black cubes get sucked into black hole
            if (addressScene.userData.blackCubes && addressScene.userData.blackCubes.length > 0) {
                const blackCubes = addressScene.userData.blackCubes;
                for (let i = blackCubes.length - 1; i >= 0; i--) {
                    const cube = blackCubes[i];
                    const elapsed = sequenceTime - cube.userData.suckStartTime;
                    const distToCenter = Math.sqrt(
                        cube.position.x ** 2 + 
                        cube.position.y ** 2 + 
                        cube.position.z ** 2
                    );
                    
                    // Acceleration toward center - increasing speed
                    const acceleration = 1 + elapsed * 1.2;
                    const pullForce = delta * acceleration * 10;
                    
                    // Spiral motion
                    cube.userData.spiralAngle += delta * cube.userData.spiralSpeed * (1 + elapsed * 0.8);
                    const spiralRadius = Math.max(0.1, distToCenter * 0.15);
                    const spiralX = Math.cos(cube.userData.spiralAngle) * spiralRadius;
                    const spiralZ = Math.sin(cube.userData.spiralAngle) * spiralRadius;
                    
                    // Pull toward center with spiral
                    cube.position.x = THREE.MathUtils.lerp(cube.position.x, spiralX, pullForce);
                    cube.position.y = THREE.MathUtils.lerp(cube.position.y, 0, pullForce * 0.95);
                    cube.position.z = THREE.MathUtils.lerp(cube.position.z, spiralZ, pullForce);
                    
                    // Spaghettification stretch - extreme elongation
                    if (distToCenter < 10) {
                        const stretchFactor = 1 + (10 - distToCenter) * 0.5;
                        cube.scale.y = 0.6 * stretchFactor;
                        cube.scale.x = Math.max(0.03, 0.6 / Math.sqrt(stretchFactor));
                        cube.scale.z = Math.max(0.03, 0.6 / Math.sqrt(stretchFactor));
                        
                        // Orient along spiral toward center
                        const targetPos = new THREE.Vector3(spiralX, 0, spiralZ);
                        cube.lookAt(targetPos);
                    }
                    
                    // Event horizon burst - tri-chromatic light explosion
                    if (distToCenter < 4.0 && !cube.userData.hasBurst) {
                        cube.userData.hasBurst = true;
                        console.log('💥 Tri-chromatic burst at event horizon!');
                        
                        // Create tri-chromatic light burst
                        const colors = [
                            { hex: 0xff0000, name: 'red' },
                            { hex: 0x00ff00, name: 'green' },
                            { hex: 0x0000ff, name: 'blue' }
                        ];
                        colors.forEach((colorData, idx) => {
                            const lightGeo = new THREE.SphereGeometry(0.3, 16, 16);
                            const lightMat = new THREE.MeshBasicMaterial({
                                color: colorData.hex,
                                transparent: true,
                                opacity: 1
                            });
                            const light = new THREE.Mesh(lightGeo, lightMat);
                            light.position.copy(cube.position);
                            
                            const angle = (idx / 3) * Math.PI * 2 + Math.random() * 0.5;
                            const speed = 3 + Math.random() * 2;
                            light.userData.velocity = new THREE.Vector3(
                                Math.cos(angle) * speed,
                                (Math.random() - 0.5) * speed * 0.8,
                                Math.sin(angle) * speed
                            );
                            light.userData.life = 1.0;
                            light.userData.colorName = colorData.name;
                            
                            addressScene.add(light);
                            if (!addressScene.userData.lightBursts) {
                                addressScene.userData.lightBursts = [];
                            }
                            addressScene.userData.lightBursts.push(light);
                        });
                    }
                    
                    // Remove if too close to center
                    if (distToCenter < 0.5) {
                        addressScene.remove(cube);
                        blackCubes.splice(i, 1);
                    }
                }
            }
            
            // Animate light bursts - expand and fade
            if (addressScene.userData.lightBursts) {
                for (let i = addressScene.userData.lightBursts.length - 1; i >= 0; i--) {
                    const light = addressScene.userData.lightBursts[i];
                    light.position.add(light.userData.velocity.clone().multiplyScalar(delta));
                    light.userData.life -= delta * 0.4;
                    light.material.opacity = light.userData.life;
                    light.scale.multiplyScalar(1 + delta * 3);
                    
                    if (light.userData.life <= 0) {
                        addressScene.remove(light);
                        addressScene.userData.lightBursts.splice(i, 1);
                    }
                }
            }
            
            // Render the scene
            addressComposer.render();
            
            // Continue indefinitely to keep rendering the room and black hole
            requestAnimationFrame(animateAddresses);
        }
        
        console.log('🎬 Starting animation loop');
        console.log('📷 Camera position:', addressCamera.position);
        console.log('🎭 Scene children:', addressScene.children.length);
        animateAddresses();
    }
    
    function triggerVictory(frame) {
        console.log('🎉 VICTORY!');
        if (!frame) return;

        // Set madness flag
        madnessActivated = true;
        rPromptHoverCount = 0; // Reset for "Don't click" messages

        // HALT R sequence completely - stop matrix and speech
        rInfectionHalted = true;
        speechRActive = false;
        rInfectionProcessing = false;
        rInfectionStarted = false;
        
        // Stop all matrix intervals and timers
        if (matrixInterval) {
            clearInterval(matrixInterval);
            matrixInterval = null;
        }
        if (matrixUpdateInterval) {
            clearInterval(matrixUpdateInterval);
            matrixUpdateInterval = null;
        }
        if (matrixAnimationFrameId) {
            cancelAnimationFrame(matrixAnimationFrameId);
            matrixAnimationFrameId = null;
        }
        if (cascadeInterval) {
            clearInterval(cascadeInterval);
            cascadeInterval = null;
        }
        if (matrixHeavyTimers && matrixHeavyTimers.length) {
            matrixHeavyTimers.forEach(id => clearTimeout(id));
            matrixHeavyTimers = [];
        }
        
        // Remove matrix container and R hint
        const matrixContainer = document.getElementById('matrixContainer');
        if (matrixContainer) {
            matrixContainer.remove();
        }
        const rHint = document.getElementById('rHint');
        if (rHint) {
            rHint.remove();
        }
        
        // Stop R text-to-speech immediately
        if (speechRTimeout) {
            clearTimeout(speechRTimeout);
            speechRTimeout = null;
        }
        if (speechRGuardTimeout) {
            clearTimeout(speechRGuardTimeout);
            speechRGuardTimeout = null;
        }
        if (hasSpeechSynthesis) {
            try { window.speechSynthesis.cancel(); } catch (err) {}
        }
        console.log('🛑 HALTED R sequence (matrix + speech)');

        // Play "Oh." text-to-speech
        setTimeout(() => {
            if (hasSpeechSynthesis && speechRVoice) {
                const ohUtterance = new SpeechSynthesisUtterance('Oh.');
                ohUtterance.voice = speechRVoice;
                ohUtterance.rate = 0.9;
                ohUtterance.pitch = 1.0;
                ohUtterance.volume = 0.92;
                window.speechSynthesis.speak(ohUtterance);
                console.log('🗣️ Playing "Oh." TTS');
            }
        }, 300);

        const existing = document.getElementById('initializeOverlay');
        if (existing) existing.remove();

        const overlay = document.createElement('div');
        overlay.id = 'initializeOverlay';
        overlay.style.cssText = 'position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none; z-index:60;';

        const panel = document.createElement('div');
        panel.style.cssText = 'pointer-events:auto; text-align:center; background:rgba(0,0,0,0.88); border:2px solid #0f0; padding:26px 34px; box-shadow:0 0 18px rgba(0,255,160,0.25); font-family:"Courier New", monospace; color:#0f0; min-width:260px;';

        const heading = document.createElement('div');
        heading.textContent = 'madness.loom located';
        heading.style.cssText = 'font-size:13px; letter-spacing:0.14em; text-transform:uppercase; margin-bottom:14px;';

        const button = document.createElement('button');
        button.style.cssText = 'font-family:"Courier New", monospace; font-size:15px; letter-spacing:0.38em; padding:16px 34px; color:#072c07; background:#19ff6b; border:2px solid #19ff6b; cursor:pointer; text-transform:uppercase; box-shadow:0 0 18px rgba(25,255,107,0.45); transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease, color 0.2s ease; pointer-events:auto; position:relative;';
        
        // Create button content with text and square dots
        const buttonText = document.createElement('span');
        buttonText.textContent = 'INITIALIZE ▸';
        buttonText.style.cssText = 'position:relative; z-index:1;';
        
        // Create square dots container
        const dotsContainer = document.createElement('span');
        dotsContainer.style.cssText = 'position:absolute; left:10px; top:50%; transform:translateY(-50%); display:flex; gap:4px; z-index:0;';
        
        // Add 3 square dots
        for (let i = 0; i < 3; i++) {
            const dot = document.createElement('span');
            dot.style.cssText = `width:6px; height:6px; background:#072c07; opacity:0.4; animation:pulse-dot 1.5s ease-in-out ${i * 0.2}s infinite;`;
            dotsContainer.appendChild(dot);
        }
        
        button.appendChild(dotsContainer);
        button.appendChild(buttonText);
        
        // Add CSS animation for dots if not already present
        if (!document.getElementById('dot-pulse-animation')) {
            const style = document.createElement('style');
            style.id = 'dot-pulse-animation';
            style.textContent = `
                @keyframes pulse-dot {
                    0%, 100% { opacity: 0.2; transform: scale(1); }
                    50% { opacity: 0.6; transform: scale(1.3); }
                }
            `;
            document.head.appendChild(style);
        }

        button.addEventListener('mouseenter', () => {
            if (button.disabled) return;
            button.style.boxShadow = '0 0 24px rgba(25,255,140,0.55)';
            button.style.transform = 'translateY(-2px)';
        });
        button.addEventListener('mouseleave', () => {
            if (button.disabled) return;
            button.style.boxShadow = '0 0 18px rgba(25,255,107,0.45)';
            button.style.transform = 'translateY(0)';
        });

        const status = document.createElement('div');
        const phases = ['calibrate interface', 'prime uplink', 'commence breach'];
        status.style.cssText = 'margin-top:12px; font-size:12px; letter-spacing:0.2em; text-transform:uppercase; opacity:0.75;';
        status.textContent = phases[0];

        panel.appendChild(heading);
        panel.appendChild(button);
        panel.appendChild(status);
        overlay.appendChild(panel);
        frame.appendChild(overlay);

        const visiCalc = document.getElementById('visicalc');
        const stageClasses = ['barrel-stage-1', 'barrel-stage-2', 'barrel-stage-3'];
        let clickCount = 0;

        function applyDistortion(stageIndex) {
            if (!visiCalc) return;
            visiCalc.classList.remove('screen-shatter');
            stageClasses.forEach(cls => visiCalc.classList.remove(cls));
            void visiCalc.offsetWidth;
            visiCalc.classList.add(stageClasses[stageIndex]);
        }
        
        function triggerMatrixIntensification(intensity) {
            console.log('🔥 Matrix intensification level:', intensity);
            
            // Create or intensify matrix rain
            let matrixContainer = document.getElementById('matrixIntensityOverlay');
            if (!matrixContainer) {
                matrixContainer = document.createElement('div');
                matrixContainer.id = 'matrixIntensityOverlay';
                matrixContainer.style.cssText = 'position:fixed; inset:0; pointer-events:none; z-index:65; overflow:hidden;';
                document.body.appendChild(matrixContainer);
            }
            
            // Clear existing columns
            matrixContainer.innerHTML = '';
            
            // Number of columns increases with intensity
            const columnCount = 40 + (intensity * 25); // More columns
            const duration = 2.5 + (intensity * 0.5); // Longer duration: 3-4s
            const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%&*+=';
            
            for (let i = 0; i < columnCount; i++) {
                const column = document.createElement('div');
                column.style.cssText = `
                    position:absolute;
                    top:${-100 - Math.random() * 100}%;
                    left:${Math.random() * 100}%;
                    font-family:'Courier New', monospace;
                    font-size:${14 + Math.random() * 10}px;
                    color:#0f0;
                    text-shadow:0 0 ${6 + intensity * 6}px #0f0, 0 0 ${3 + intensity * 3}px #0f0;
                    opacity:${0.65 + intensity * 0.12};
                    white-space:nowrap;
                    animation: matrixFall ${duration}s linear forwards;
                `;
                
                // Create falling text
                let text = '';
                const length = 10 + Math.floor(Math.random() * 15);
                for (let j = 0; j < length; j++) {
                    text += characters[Math.floor(Math.random() * characters.length)] + '<br>';
                }
                column.innerHTML = text;
                matrixContainer.appendChild(column);
            }
            
            // Add CSS animation if not already defined
            if (!document.getElementById('matrixIntensityStyles')) {
                const style = document.createElement('style');
                style.id = 'matrixIntensityStyles';
                style.textContent = `
                    @keyframes matrixFall {
                        0% { transform: translateY(0); opacity: 0; }
                        15% { opacity: 1; }
                        85% { opacity: 0.85; }
                        100% { transform: translateY(150vh); opacity: 0; }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Remove after animation
            setTimeout(() => {
                if (matrixContainer && matrixContainer.parentNode) {
                    matrixContainer.remove();
                }
            }, duration * 1000 + 500);
        }

        function triggerScreenShatter() {
            if (visiCalc) {
                stageClasses.forEach(cls => visiCalc.classList.remove(cls));
                void visiCalc.offsetWidth;
                visiCalc.classList.add('screen-shatter');
            }

            let shatter = document.getElementById('screenShatterOverlay');
            if (shatter) {
                shatter.remove();
            }
            shatter = document.createElement('div');
            shatter.id = 'screenShatterOverlay';
            shatter.className = 'shatter-overlay';
            const cracks = document.createElement('div');
            cracks.className = 'shatter-cracks';
            const pixels = document.createElement('div');
            pixels.className = 'shatter-pixels';
            shatter.appendChild(cracks);
            shatter.appendChild(pixels);
            document.body.appendChild(shatter);

            requestAnimationFrame(() => {
                shatter.classList.add('active');
                setTimeout(() => {
                    shatter.classList.add('fade');
                }, 950);
                setTimeout(() => {
                    if (shatter.parentNode) {
                        shatter.parentNode.removeChild(shatter);
                    }
                    // Start cell address sequence after shatter
                    setTimeout(() => {
                        startCellAddressSequence(frame, visiCalc);
                    }, 500);
                }, 2400);
            });
        }

        button.addEventListener('click', () => {
            if (button.disabled) return;
            clickCount++;
            barrelClickCount++;
            button.blur();
            button.style.transform = 'translateY(2px)';
            button.style.boxShadow = '0 0 12px rgba(25,255,107,0.35)';
            setTimeout(() => {
                if (!button.disabled) {
                    button.style.transform = 'translateY(0)';
                    button.style.boxShadow = '0 0 18px rgba(25,255,107,0.45)';
                }
            }, 160);

            const phaseIndex = Math.min(clickCount, phases.length - 1);
            status.textContent = phases[phaseIndex];

            // Play distorted startup sound with increasing distortion per click
            playStartupBassDistorted(clickCount);

            // Make VisiCell frame glow and extend back in Z
            if (visiCalc) {
                const frameEl = document.getElementById('visicalc-frame');
                if (frameEl) {
                    const zDepth = barrelClickCount * 20;
                    frameEl.style.transform = `perspective(1000px) translateZ(-${zDepth}px)`;
                    frameEl.style.boxShadow = `0 0 ${10 + barrelClickCount * 15}px #0f0, inset 0 0 ${5 + barrelClickCount * 10}px #0f0`;
                    frameEl.style.borderColor = '#0f0';
                    frameEl.style.borderWidth = '3px';
                }
            }

            // Intensify screen glitch and matrix effects between clicks
            const glitchEl = document.getElementById('screenGlitch');
            if (glitchEl && clickCount < 3) {
                glitchEl.classList.add('active');
                setTimeout(() => glitchEl.classList.remove('active'), 800 + clickCount * 200);
            }
            
            // Trigger maximum matrix cascade effect
            if (clickCount < 3) {
                triggerMatrixIntensification(clickCount);
            }

            if (clickCount === 1) {
                applyDistortion(0);
            } else if (clickCount === 2) {
                applyDistortion(1);
            } else {
                applyDistortion(2);
                button.disabled = true;
                button.style.cursor = 'default';
                button.textContent = 'INITIALIZING...';
                button.style.background = '#0d400d';
                button.style.color = '#0f0';
                
                // Maximum glitch and matrix before shatter
                if (glitchEl) {
                    glitchEl.classList.add('active');
                    setTimeout(() => glitchEl.classList.remove('active'), 1500);
                }
                triggerMatrixIntensification(3);
                
                setTimeout(() => {
                    triggerScreenShatter();
                }, 500);
            }
        });
    }
    
    function triggerCelliBackspaceReaction() {
        if (celliBackspaceSequenceStarted || burstAnimStarted) return;

        celliBackspaceSequenceStarted = true;
        celliBackspaceSequenceTime = totalTime;

        const active = voxels.filter(v => v.visible && !v.userData.glitched);
        if (!celliBackspaceFlickerTriggered && active.length) {
            celliBackspaceFlickerTriggered = true;
            const target = active[Math.floor(Math.random() * active.length)];
            if (target) {
                let flickers = 0;
                const mat = target.material;
                const edgeMaterial = target.userData.edges ? target.userData.edges.material : null;
                const baseOpacity = mat.opacity;
                const baseEdgeOpacity = edgeMaterial ? edgeMaterial.opacity : 0;
                const interval = setInterval(() => {
                    const on = flickers % 2 === 0;
                    mat.opacity = on ? 1 : Math.max(0.1, baseOpacity * 0.2);
                    if (edgeMaterial) {
                        edgeMaterial.opacity = on ? Math.min(0.9, baseEdgeOpacity + 0.3) : Math.max(0.1, baseEdgeOpacity * 0.3);
                    }
                    flickers += 1;
                    if (flickers > 4) {
                        clearInterval(interval);
                        mat.opacity = baseOpacity;
                        if (edgeMaterial) edgeMaterial.opacity = baseEdgeOpacity;
                    }
                }, 90);
            }
        }
    }

    // CELLI glitch and degradation
    function triggerCelliGlitch() {
        if (celliGlitchStarted) return;
        celliGlitchStarted = true;
        
        // Play electrical fritz whir/buzz sound
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const now = audioCtx.currentTime;
        
        // Create buzzing electrical sound with multiple oscillators
        const buzz1 = audioCtx.createOscillator();
        const buzz2 = audioCtx.createOscillator();
        const buzz3 = audioCtx.createOscillator();
        const buzzGain = audioCtx.createGain();
        const buzzFilter = audioCtx.createBiquadFilter();
        
        buzz1.type = 'sawtooth';
        buzz2.type = 'square';
        buzz3.type = 'sawtooth';
        
        // Fluctuating frequencies for electrical buzz
        buzz1.frequency.setValueAtTime(120, now);
        buzz2.frequency.setValueAtTime(180, now);
        buzz3.frequency.setValueAtTime(240, now);
        
        // Modulate frequencies to create buzzing effect
        for (let i = 0; i < 20; i++) {
            const t = now + (i * 0.1);
            const freq1 = 120 + Math.random() * 60;
            const freq2 = 180 + Math.random() * 60;
            const freq3 = 240 + Math.random() * 60;
            buzz1.frequency.setValueAtTime(freq1, t);
            buzz2.frequency.setValueAtTime(freq2, t);
            buzz3.frequency.setValueAtTime(freq3, t);
        }
        
        // Band-pass filter for electrical character
        buzzFilter.type = 'bandpass';
        buzzFilter.frequency.setValueAtTime(300, now);
        buzzFilter.Q.setValueAtTime(5, now);
        
        // Envelope: fade in, sustain, fade out
        buzzGain.gain.setValueAtTime(0, now);
        buzzGain.gain.linearRampToValueAtTime(0.08, now + 0.2);
        buzzGain.gain.setValueAtTime(0.08, now + 1.5);
        buzzGain.gain.exponentialRampToValueAtTime(0.001, now + 2.0);
        
        buzz1.connect(buzzFilter);
        buzz2.connect(buzzFilter);
        buzz3.connect(buzzFilter);
        buzzFilter.connect(buzzGain);
        buzzGain.connect(audioCtx.destination);
        
        buzz1.start(now);
        buzz2.start(now);
        buzz3.start(now);
        buzz1.stop(now + 2.0);
        buzz2.stop(now + 2.0);
        buzz3.stop(now + 2.0);
        
        // Start flickering lights
        document.getElementById('screenGlitch').classList.add('active');
        
        // Only keep the middle column of I (letter index 4, middle 3 rows: 1,2,3)
        voxels.forEach((voxel, idx) => {
            const data = voxel.userData;
            const gridX = data.gridX;    // Letter index (0=C, 1=E, 2=L, 3=L, 4=I)
            const gridY = data.gridY;    // Row index (0=top, 4=bottom)
            const gridCol = data.gridCol; // Column index within letter (0-4)
            
            // Keep only the T shape: top bar (row 0, all cols) and vertical stem (rows 1-4, middle col)
            const keepVoxel = (gridX === 4 && ((gridY === 0) || (gridY >= 1 && gridY <= 4 && gridCol === 2)));
            
            if (!keepVoxel) {
                // Store in stack for later restoration BEFORE marking as glitched
                glitchedVoxelsStack.push(voxel);
                
                // Mark as glitched immediately to prevent updates
                data.glitched = true;
                
                // Start flickering with light gray
                const flickerDelay = Math.random() * 400;
                
                setTimeout(() => {
                    // Turn to light gray and start flickering
                    voxel.material.color.setRGB(0.6, 0.6, 0.6); // Light gray
                    data.edges.material.color.setRGB(0.65, 0.65, 0.65);
                    
                    const flickerDuration = 400 + Math.random() * 400;
                    let flickerCount = 0;
                    const maxFlickers = Math.floor(flickerDuration / 60);
                    
                    const flickerInterval = setInterval(() => {
                        flickerCount++;
                        const flickerOn = Math.random() > 0.5;
                        
                        // Flicker between light gray and white, gradually dimming
                        const dimFactor = 1 - (flickerCount / maxFlickers) * 0.5;
                        if (flickerOn) {
                            voxel.material.color.setRGB(0.6 * dimFactor, 0.6 * dimFactor, 0.6 * dimFactor);
                            voxel.material.opacity = 0.75 * dimFactor;
                            data.edges.material.opacity = 0.5 * dimFactor;
                        } else {
                            voxel.material.color.setRGB(0.4 * dimFactor, 0.4 * dimFactor, 0.4 * dimFactor);
                            voxel.material.opacity = 0.5 * dimFactor;
                            data.edges.material.opacity = 0.3 * dimFactor;
                        }
                    }, 60);
                    
                    // After flickering, turn dark gray and fade out
                    setTimeout(() => {
                        clearInterval(flickerInterval);
                        
                        // Short out - dark gray
                        voxel.material.color.setRGB(0.15, 0.15, 0.15); // Dark gray
                        data.edges.material.color.setRGB(0.2, 0.2, 0.2);
                        voxel.material.opacity = 0.4;
                        data.edges.material.opacity = 0.25;
                        
                        // Fade to black over time
                        const fadeStart = Date.now();
                        const fadeDuration = 300;
                        const fadeInterval = setInterval(() => {
                            const fadeProgress = (Date.now() - fadeStart) / fadeDuration;
                            if (fadeProgress >= 1) {
                                clearInterval(fadeInterval);
                                voxel.material.opacity = 0;
                                data.edges.material.opacity = 0;
                                voxel.visible = false;
                                data.edges.visible = false;
                            } else {
                                voxel.material.opacity = 0.4 * (1 - fadeProgress);
                                data.edges.material.opacity = 0.25 * (1 - fadeProgress);
                            }
                        }, 16);
                    }, flickerDuration);
                }, flickerDelay);
            }
        });
        
        // Stop screen glitch after 2 seconds
        setTimeout(() => {
            document.getElementById('screenGlitch').classList.remove('active');
        }, 2000);
    }

    function updatePositions(t) {
        const phase = t < introCfg.rollEnd ? 'roll' :
                      t < introCfg.bounceEnd ? 'bounce' :
                      t < introCfg.triangleEnd ? 'triangle' :
                      t < introCfg.transitionEnd ? 'transition' :
                      t < introCfg.normalEnd ? 'normal' :
                      t < introCfg.vennEnd ? 'venn' :
                      t < introCfg.collapseEnd ? 'collapse' :
                      t < introCfg.glitchEnd ? 'glitch' :
                      t < introCfg.blackoutEnd ? 'blackout' :
                      t < introCfg.loomworksEnd ? 'loomworks' :
                      t < introCfg.celliEnd ? 'celli' : 'doorway';

        // Animate bloom, afterimage, and film effects based on phase
        if (phase === 'roll') {
            afterimagePass.uniforms.damp.value = 0.75; // Thin trail
            filmPass.uniforms.noise.value = 0.005; // Minimal grain
            filmPass.uniforms.scanAmp.value = 0.003; // Minimal scanlines
            triMesh.visible = false; // Hide triangle gradient during intro
        } else if (phase === 'bounce') {
            bloomPass.strength = 0.25; // Subtle glow
            afterimagePass.uniforms.damp.value = 0.75; // Thin trail
            filmPass.uniforms.noise.value = 0.005; // Minimal grain
            filmPass.uniforms.scanAmp.value = 0.003; // Minimal scanlines
            triMesh.visible = false; // Hide triangle gradient during intro
        } else if (phase === 'triangle') {
            const triangleProgress = (t - introCfg.bounceEnd) / (introCfg.triangleEnd - introCfg.bounceEnd);
            
            // Sub-phases: form (0-0.35), converge (0.35-0.6), grow (0.6-1.0)
            const formProgress = Math.min(triangleProgress / 0.35, 1.0);
            const convergeStart = 0.35;
            const convergeProgress = triangleProgress > convergeStart ? Math.min((triangleProgress - convergeStart) / 0.25, 1.0) : 0;
            const growStart = 0.6;
            const growProgress = triangleProgress > growStart ? (triangleProgress - growStart) / 0.4 : 0;
            
            // Smooth bloom progression throughout all sub-phases
            bloomPass.strength = THREE.MathUtils.lerp(0.25, 0.7, triangleProgress);
            afterimagePass.uniforms.damp.value = THREE.MathUtils.lerp(0.75, 0.92, triangleProgress);
            filmPass.uniforms.noise.value = THREE.MathUtils.lerp(0.005, 0.015, triangleProgress);
            filmPass.uniforms.scanAmp.value = THREE.MathUtils.lerp(0.003, 0.015, triangleProgress);
            
            // Hide triangle gradient - it makes things look off-center
            triMesh.visible = false;
        } else if (phase === 'transition') {
            const transProgress = (t - introCfg.triangleEnd) / (introCfg.transitionEnd - introCfg.triangleEnd);
            bloomPass.strength = 0.7; // Keep bloom consistent
            afterimagePass.uniforms.damp.value = THREE.MathUtils.lerp(0.92, 0.96, transProgress);
            filmPass.uniforms.noise.value = THREE.MathUtils.lerp(0.015, 0.03, transProgress);
            filmPass.uniforms.scanAmp.value = THREE.MathUtils.lerp(0.015, 0.03, transProgress);
            triMesh.visible = false;
            triMesh.material.opacity = 0;
        } else if (phase === 'normal') {
            const normalT = t - introCfg.transitionEnd;
            const normalDuration = introCfg.normalEnd - introCfg.transitionEnd;
            const convergeDuration = 2.2;
            const pulseDuration = 3.0;
            const totalAnimDuration = convergeDuration + pulseDuration;

            if (normalT < convergeDuration) {
                // Phase 1: Converge - increase bloom
                const convergeProgress = THREE.MathUtils.clamp(normalT / convergeDuration, 0, 1);
                const convergeEased = convergeProgress * convergeProgress * (3 - 2 * convergeProgress);
                bloomPass.strength = THREE.MathUtils.lerp(0.7, 0.9, convergeEased);
                triMesh.visible = false;
            } else if (normalT < totalAnimDuration) {
                // Phase 2: Single pulse - bloom follows expansion
                const pulseT = normalT - convergeDuration;
                const pulseProgress = pulseT / pulseDuration;
                const pulseCycle = Math.sin(pulseProgress * Math.PI);
                
                bloomPass.strength = THREE.MathUtils.lerp(0.9, 0.72, pulseCycle);
                triMesh.visible = pulseCycle > 0.3; // Show triangle during expansion
                triMesh.material.opacity = THREE.MathUtils.clamp(pulseCycle * 1.5, 0, 0.7);
            } else {
                // Phase 3: Brief hold, prepare for venn transition
                const holdT = normalT - totalAnimDuration;
                const holdDuration = normalDuration - totalAnimDuration;
                const holdProgress = holdT / holdDuration;
                
                bloomPass.strength = THREE.MathUtils.lerp(0.9, 0.85, holdProgress);
                triMesh.visible = false;
            }

            afterimagePass.uniforms.damp.value = 0.96;
            filmPass.uniforms.noise.value = 0.03;
            filmPass.uniforms.scanAmp.value = 0.03;
        } else if (phase === 'venn') {
            // Settle into clear venn diagram
            const vennProgress = (t - introCfg.normalEnd) / (introCfg.vennEnd - introCfg.normalEnd);
            bloomPass.strength = THREE.MathUtils.lerp(0.7, 0.8, vennProgress);
            afterimagePass.uniforms.damp.value = THREE.MathUtils.lerp(0.96, 0.7, vennProgress);
            filmPass.uniforms.noise.value = THREE.MathUtils.lerp(0.03, 0.02, vennProgress);
            filmPass.uniforms.scanAmp.value = THREE.MathUtils.lerp(0.03, 0.02, vennProgress);
            triMesh.visible = true;
            triMesh.material.opacity = THREE.MathUtils.lerp(0.7, 0.85, vennProgress);
        } else if (phase === 'collapse') {
            // Grow and collapse into white radiating circle
            const collapseProgress = (t - introCfg.vennEnd) / (introCfg.collapseEnd - introCfg.vennEnd);
            bloomPass.strength = THREE.MathUtils.lerp(0.8, 1.2, collapseProgress);
            afterimagePass.uniforms.damp.value = THREE.MathUtils.lerp(0.7, 0.6, collapseProgress);
            filmPass.uniforms.noise.value = THREE.MathUtils.lerp(0.02, 0.015, collapseProgress);
            filmPass.uniforms.scanAmp.value = THREE.MathUtils.lerp(0.02, 0.015, collapseProgress);
            triMesh.visible = true;
            triMesh.material.opacity = THREE.MathUtils.lerp(0.85, 0.3, collapseProgress);
            
            // Progressive glitch starting mild - show quote only when glitching starts
            if (collapseProgress > 0.15 && !glitchStarted) {
                const quoteEl = document.getElementById('quote');
                quoteEl.style.visibility = 'visible';
                quoteEl.style.opacity = '0.85'; // Start visible
                quoteEl.classList.add('glitch');
                glitchStarted = true;
                quoteShown = true;
            }

            // Increase to medium glitch
            if (collapseProgress > 0.6 && !mediumGlitchStarted) {
                document.getElementById('quote').classList.remove('glitch');
                document.getElementById('quote').classList.add('glitchMedium');
                mediumGlitchStarted = true;
            }
        } else if (phase === 'glitch') {
            // Intense glitch phase
            const glitchProgress = (t - introCfg.collapseEnd) / (introCfg.glitchEnd - introCfg.collapseEnd);
            bloomPass.strength = THREE.MathUtils.lerp(1.2, 0.5, glitchProgress);
            afterimagePass.uniforms.damp.value = 0.3; // Heavy trails
            filmPass.uniforms.noise.value = THREE.MathUtils.lerp(0.015, 0.5, glitchProgress);
            filmPass.uniforms.scanAmp.value = THREE.MathUtils.lerp(0.015, 0.3, glitchProgress);
            triMesh.visible = true;
            triMesh.material.opacity = THREE.MathUtils.lerp(0.3, 0, glitchProgress);
            
            // Intensify text glitch at start of glitch phase
            if (glitchProgress > 0.05 && !intenseGlitchStarted) {
                document.getElementById('quote').classList.remove('glitch', 'glitchMedium');
                document.getElementById('quote').classList.add('glitchIntense');
                intenseGlitchStarted = true;
            }

            if (glitchProgress > 0.25 && !quoteDespairShown) {
                glitchSwapQuote(quoteStates.despair, { duration: 950, onComplete: () => quoteEl.classList.add('quote--loom') });
                quoteDespairShown = true;
            }

            // Screen glitch in middle
            if (glitchProgress > 0.4 && !screenGlitchStarted) {
                document.getElementById('screenGlitch').classList.add('active');
                screenGlitchStarted = true;
            }
        } else if (phase === 'blackout') {
            // Fade to black
            const blackoutProgress = (t - introCfg.glitchEnd) / (introCfg.blackoutEnd - introCfg.glitchEnd);
            bloomPass.strength = THREE.MathUtils.lerp(0.5, 0, blackoutProgress);
            afterimagePass.uniforms.damp.value = 0.1;
            filmPass.uniforms.noise.value = 0;
            filmPass.uniforms.scanAmp.value = 0;
            triMesh.visible = false;
            
            if (!blackoutStarted) {
                // Hide and clean up quote immediately
                const quoteEl = document.getElementById('quote');
                quoteEl.classList.remove('glitch', 'glitchMedium', 'glitchIntense', 'scrambling');
                quoteEl.style.visibility = 'hidden';
                quoteEl.style.opacity = '0';
                quoteEl.classList.remove('quote--loom');
                document.getElementById('screenGlitch').classList.remove('active');
                blackoutStarted = true;
            }
        } else if (phase === 'loomworks') {
            // Show Loomworks text
            bloomPass.strength = 0;
            afterimagePass.uniforms.damp.value = 0;
            filmPass.uniforms.noise.value = 0;
            filmPass.uniforms.scanAmp.value = 0;
            triMesh.visible = false;
            
            if (!loomworksShown) {
                // Ensure quote is definitely hidden before showing loomworks
                const quoteEl = document.getElementById('quote');
                quoteEl.style.visibility = 'hidden';
                quoteEl.style.opacity = '0';
                quoteEl.classList.remove('glitch', 'glitchMedium', 'glitchIntense', 'scrambling');

                startLoomworksReveal();
                loomworksShown = true;
            }
            
            // Play chime jingle at start of this phase
            if (!chimePlayed) {
                // Generate startup chime jingle
                if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const now = audioCtx.currentTime;
                
                // Melodic jingle: C - E - G - C (ascending arpeggio)
                const melody = [
                    { freq: 261.63, time: 0.0, duration: 0.25 },    // C4
                    { freq: 329.63, time: 0.15, duration: 0.25 },   // E4
                    { freq: 392.00, time: 0.30, duration: 0.25 },   // G4
                    { freq: 523.25, time: 0.45, duration: 0.5 }     // C5 (held)
                ];
                
                melody.forEach((note, idx) => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(note.freq, now + note.time);
                    
                    // Envelope
                    gain.gain.setValueAtTime(0, now + note.time);
                    gain.gain.linearRampToValueAtTime(0.12, now + note.time + 0.02);
                    gain.gain.linearRampToValueAtTime(0.08, now + note.time + 0.1);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + note.time + note.duration);
                    
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.start(now + note.time);
                    osc.stop(now + note.time + note.duration);
                });
                
                // Play startup bass after chime completes
                setTimeout(() => {
                    playStartupBass();
                }, 1200);
                
                chimePlayed = true;
            }
            
            // Hide Loomworks text near end
            const loomProgress = (t - introCfg.blackoutEnd) / (introCfg.loomworksEnd - introCfg.blackoutEnd);
            if (loomProgress > 0.85) {
                document.getElementById('loomworks').style.opacity = THREE.MathUtils.lerp(1, 0, (loomProgress - 0.85) / 0.15);
            }
        } else if (phase === 'celli') {
            // CELLI phase - lower bloom to reduce wobble
            bloomPass.strength = 0.35;
            afterimagePass.uniforms.damp.value = 0.85;
            filmPass.uniforms.noise.value = 0.008;
            filmPass.uniforms.scanAmp.value = 0.003;
            
            triMesh.visible = false;

            if (!celliStarted) {
                document.getElementById('loomworks').style.display = 'none';
                celliStarted = true;
            }
        } else {
            // Doorway phase - portal opens from vertical bar (lower bloom)
            const doorwayProgress = (t - introCfg.celliEnd) / (introCfg.doorwayEnd - introCfg.celliEnd);
            
            bloomPass.strength = THREE.MathUtils.lerp(0.35, 0.55, Math.min(doorwayProgress * 2, 1));
            afterimagePass.uniforms.damp.value = 0.8;
            filmPass.uniforms.noise.value = 0.005;
            filmPass.uniforms.scanAmp.value = 0.002;
            triMesh.visible = false;
            
            // Wait for all CELLI voxels to finish settling (last one settles around 3-4 seconds)
            const celliAge = t - introCfg.loomworksEnd;
            const allVoxelsSettled = celliAge > 5.0;
            
            if (!doorwayShown && allVoxelsSettled) {
                // Show doorway bar after CELLI finishes
                if (doorwayProgress > 0.05) {
                    document.getElementById('doorway').classList.add('visible');
                    doorwayShown = true;
                }
            }
            
            if (doorwayShown && !doorwayOpened) {
                // Open doorway after short delay
                if (doorwayProgress > 0.15) {
                    document.getElementById('doorway').classList.add('open');
                    doorwayOpened = true;
                    
                }
            }
        }

        if (phase === 'roll') {
            // Shapes roll in from off-screen to their positions
            const rollProgress = t / introCfg.rollEnd;
            const eased = rollProgress < 0.5 ? 
                2 * rollProgress * rollProgress : 
                1 - Math.pow(-2 * rollProgress + 2, 2) / 2;
            
            // Keep glow visible throughout roll
            bloomPass.strength = 0.4;

        for (let i = 0; i < 3; i++) {
                const targetX = (i - 1) * 0.35;
                const startX = targetX - 2.0; // Start off-screen left
                const x = THREE.MathUtils.lerp(startX, targetX, eased);
                const y = -0.3;
                
                // Calculate rolling rotation based on distance traveled to reach FLAT position
                const distance = x - startX; // Distance rolled
                
                // Calculate rotation for accurate rolling that ends flat
                let rotation = 0;
                if (i === 0) {
                    // Square: needs to align flat (multiple of π/2)
                    const squarePerimeter = R * 2 * 4;
                    const naturalRotation = -(distance / squarePerimeter) * (Math.PI * 2);
                    // Snap to nearest π/2 when nearly stopped
                    rotation = rollProgress > 0.95 ? Math.round(naturalRotation / (Math.PI / 2)) * (Math.PI / 2) : naturalRotation;
                } else if (i === 1) {
                    // Triangle: needs to align flat (multiple of 2π/3)
                    const trianglePerimeter = R * 2 * 3;
                    const naturalRotation = -(distance / trianglePerimeter) * (Math.PI * 2);
                    // Snap to nearest 2π/3 when nearly stopped (flat base)
                    rotation = rollProgress > 0.95 ? Math.round(naturalRotation / (Math.PI * 2 / 3)) * (Math.PI * 2 / 3) : naturalRotation;
                } else {
                    // Circle: any rotation is "flat"
                    rotation = -(distance / (2 * Math.PI * R)) * (Math.PI * 2);
                }
                
                // Store final rotation when reaching target
                if (rollProgress > 0.98) {
                    finalRollRotations[i] = rotation;
                }
                
                // Play continuous rolling thunks based on distance
                const rollDist = Math.abs(x - startX);
                const thunkInterval = 0.15; // Play thunk every 0.15 units rolled
                const expectedThunks = Math.floor(rollDist / thunkInterval);
                
                if (expectedThunks > lastThunkTime[i]) {
                    playRollingThunk(0.06);
                    lastThunkTime[i] = expectedThunks;
                }
                
                spheres[i].position.set(x, y, -i * 0.002);
                spheres[i].rotation.z = rotation;
                spheres[i].scale.set(introCfg.ballSize, introCfg.ballSize, introCfg.ballSize);
                triMat.uniforms.points.value[i].set(x, y);
                
                // Play final landing thunk
                if (!landingSounds[i] && Math.abs(x - targetX) < 0.02) {
                    playRollingThunk(0.12);
                    landingSounds[i] = true;
                }
            }
            blackHole.visible = false; // Hide during roll-in
            
        } else if (phase === 'bounce') {
            // Sequential bounces: left, then right, then middle
            const bounceT = t - introCfg.rollEnd;
            const baseY = -0.3;
            
            // Keep glow visible during bounce
            bloomPass.strength = 0.4;
            
            for (let i = 0; i < 3; i++) {
                const x = (i - 1) * 0.35;
                let y = baseY;
                
                // Sequence: 0 (left), 2 (right), 1 (middle)
                const bounceOrder = [0, 2, 1];
                const bounceIndex = bounceOrder.indexOf(i);
                const bounceStart = bounceIndex * introCfg.bounceDuration;
                const bounceEnd = bounceStart + introCfg.bounceDuration;
                
                if (bounceT >= bounceStart && bounceT <= bounceEnd) {
                    const localT = (bounceT - bounceStart) / introCfg.bounceDuration;
                    const bounce = Math.sin(localT * Math.PI) * introCfg.bounceHeight;
                    y = baseY + bounce;
                    
                    // Play thud sounds for jump and land
                    if (!window['bounceJump_' + i] && localT < 0.05) {
                        playBounceThud(0.12);
                        window['bounceJump_' + i] = true;
                    }
                    if (!window['bounceLand_' + i] && localT > 0.95) {
                        playBounceThud(0.15);
                        window['bounceLand_' + i] = true;
                    }
                }
                
                spheres[i].position.set(x, y, -i * 0.002);
                spheres[i].rotation.z = finalRollRotations[i]; // Use exact rotation from roll phase
                spheres[i].scale.set(introCfg.ballSize, introCfg.ballSize, introCfg.ballSize);
                triMat.uniforms.points.value[i].set(x, y);
            }
            blackHole.visible = false; // Hide during bounce
            
        } else if (phase === 'triangle') {
            // Triangle phase: form → converge → grow & brighten
            const triangleProgress = (t - introCfg.bounceEnd) / (introCfg.triangleEnd - introCfg.bounceEnd);
            
            // Smooth cubic easing for entire phase
            const smoothEase = (p) => p < 0.5 ? 4 * p * p * p : 1 - Math.pow(-2 * p + 2, 3) / 2;
            
            // Sub-phases with smooth transitions
            const formProgress = Math.min(triangleProgress / 0.35, 1.0);
            const formEased = smoothEase(formProgress);
            
            const convergeStart = 0.35;
            const convergeProgress = triangleProgress > convergeStart ? Math.min((triangleProgress - convergeStart) / 0.25, 1.0) : 0;
            const convergeEased = smoothEase(convergeProgress);
            
            const growStart = 0.6;
            const growProgress = triangleProgress > growStart ? (triangleProgress - growStart) / 0.4 : 0;
            const growEased = smoothEase(growProgress);
            
            // Create EQUILATERAL triangle centered at origin
            const centerY = 0;
            const triangleRadius = 0.42; // Distance from center to each vertex (increased)
            
            // Equilateral triangle: vertices at 120° intervals, pointing up
            const triangleAngles = [
                Math.PI / 2 + (2 * Math.PI / 3) * 0,  // Top (90°)
                Math.PI / 2 + (2 * Math.PI / 3) * 1,  // Bottom-left (210°)
                Math.PI / 2 + (2 * Math.PI / 3) * 2   // Bottom-right (330°)
            ];
            
            // Rotation grows smoothly throughout
            const rotationAmount = growEased * 0.2;
            
            // Pulsing: breathe in/out during grow phase
            const pulseSpeed = 2.0;
            const pulsePhase = (t - introCfg.bounceEnd - growStart * (introCfg.triangleEnd - introCfg.bounceEnd)) * pulseSpeed;
            const pulseFactor = growProgress > 0 ? 1 + Math.sin(pulsePhase) * 0.08 : 1;
            
            // Converge factor - pull toward center during converge phase
            const convergeFactor = convergeEased * 0.12;
            
            // Map spheres to triangle positions: [0]=left→bottom-left, [1]=middle→top, [2]=right→bottom-right
            const triangleMapping = [1, 0, 2]; // sphere i goes to angle triangleMapping[i]
            
            for (let i = 0; i < 3; i++) {
                // Starting positions from the line (after bounce)
                const startX = (i - 1) * 0.35;
                const startY = -0.3;
                
                // Target positions in triangle formation (with correct mapping)
                const angleIndex = triangleMapping[i];
                const angle = triangleAngles[angleIndex] + rotationAmount;
                const targetRadius = triangleRadius * (1 - convergeFactor) * pulseFactor;
                const targetX = Math.cos(angle) * targetRadius;
                const targetY = Math.sin(angle) * targetRadius + centerY;
                
                // Interpolate from line to triangle formation
                const x = THREE.MathUtils.lerp(startX, targetX, formEased);
                const y = THREE.MathUtils.lerp(startY, targetY, formEased);
                
                spheres[i].position.set(x, y, -i * 0.002);
                spheres[i].rotation.z = 0; // Reset rotation for orbit phases
                
                // Scale: small → stays small during form/converge → grows large with overshoot
                let scale = introCfg.ballSize;
                if (formEased < 1) {
                    scale = THREE.MathUtils.lerp(introCfg.ballSize, introCfg.ballSize * 1.0, formEased);
                } else {
                    // Add subtle overshoot for organic feel
                    const overshoot = Math.sin(growEased * Math.PI) * 0.08;
                    scale = THREE.MathUtils.lerp(introCfg.ballSize * 1.0, introCfg.ballSize * 2.2, growEased) + overshoot;
                }
                
                spheres[i].scale.set(scale, scale, scale);
                triMat.uniforms.points.value[i].set(x, y);
            }
            
            blackHole.visible = true;
            blackHole.material.uniforms.pulseFactor.value = formEased * 0.4;
            
        } else if (phase === 'transition') {
            // Transform triangle into rotating circular orbit - organically
            // ALSO morph all shapes into circles
            const transProgress = (t - introCfg.triangleEnd) / (introCfg.transitionEnd - introCfg.triangleEnd);
            // Smooth cubic easing
            const eased = transProgress < 0.5 ? 
                4 * transProgress * transProgress * transProgress : 
                1 - Math.pow(-2 * transProgress + 2, 3) / 2;
            
            // Morph shapes into circles halfway through transition
            // Keep materials (colors) consistent - don't swap
            if (transProgress > 0.5 && spheres[0].geometry !== circleGeoTarget && spheres[1].geometry !== circleGeoTarget) {
                const mat0 = spheres[0].material;
                const mat1 = spheres[1].material;
                
                spheres[0].geometry.dispose();
                spheres[0].geometry = createCircle(R);
                spheres[0].material = mat0;  // Preserve cyan
                
                spheres[1].geometry.dispose();
                spheres[1].geometry = createCircle(R);
                spheres[1].material = mat1;  // Preserve yellow
                
                // spheres[2] is already a circle (magenta)
            }
            
            const centerY = 0;
            const triangleRadius = 0.42;
            
            // Use same equilateral triangle angles
            const triangleAngles = [
                Math.PI / 2 + (2 * Math.PI / 3) * 0,
                Math.PI / 2 + (2 * Math.PI / 3) * 1,
                Math.PI / 2 + (2 * Math.PI / 3) * 2
            ];
            
            // Starting radius (with 12% convergence from triangle phase)
            const startRadius = triangleRadius * (1 - 0.12);
            
            // Calculate rotation to match end of triangle phase (which uses rotationAmount = 0.2)
            // The triangle phase maps spheres with triangleMapping, so we need to continue from there
            const triangleEndRotation = 0.2; // matches growEased = 1.0 * 0.2
            const rotation = triangleEndRotation + (eased * Math.PI * 2);
            
            // Expand from triangle size to full orbit size
            const targetDist = motionCfg.maxDist * 0.5;
            const currentDist = THREE.MathUtils.lerp(startRadius, targetDist, eased);
            
            // Use same mapping as triangle phase
            const triangleMapping = [1, 0, 2];
            
            for (let i = 0; i < 3; i++) {
                const angleIndex = triangleMapping[i];
                const angle = triangleAngles[angleIndex] + rotation;
                const x = Math.cos(angle) * currentDist;
                const y = Math.sin(angle) * currentDist + centerY;
                
                spheres[i].position.set(x, y, -i * 0.002);
                spheres[i].rotation.z = 0;
                const scale = THREE.MathUtils.lerp(introCfg.ballSize * 2.2, 1.0, eased);
                spheres[i].scale.set(scale, scale, scale);
                triMat.uniforms.points.value[i].set(x, y);
            }
            blackHole.visible = true;
            blackHole.material.uniforms.pulseFactor.value = THREE.MathUtils.lerp(0.4, 0.5, eased);
            
        } else if (phase === 'normal') {
            const normalT = t - introCfg.transitionEnd;
            const convergeDuration = 2.2;
            const pulseDuration = 3.0; // One expand/contract cycle
            const transitionEndDist = motionCfg.maxDist * 0.5;
            const closeConvergeDist = 0.02; // Very close convergence
            const triangleExpandDist = motionCfg.maxDist * 0.65; // Expand to triangle

            const centerY = 0;
            const triangleAngles = [
                Math.PI / 2 + (2 * Math.PI / 3) * 0,
                Math.PI / 2 + (2 * Math.PI / 3) * 1,
                Math.PI / 2 + (2 * Math.PI / 3) * 2
            ];
            const transitionEndRotation = 0.2 + Math.PI * 2;
            const rotation = transitionEndRotation + (normalT * motionCfg.rotationSpeed);
            const triangleMapping = [1, 0, 2];

            let currentDist = transitionEndDist;
            let scale = 1.0;
            let pulseFactorValue = 0.5;

            if (normalT < convergeDuration) {
                // Phase 1: Converge close
                const convergeProgress = THREE.MathUtils.clamp(normalT / convergeDuration, 0, 1);
                const convergeEased = convergeProgress * convergeProgress * (3 - 2 * convergeProgress);
                currentDist = THREE.MathUtils.lerp(transitionEndDist, closeConvergeDist, convergeEased);
                scale = THREE.MathUtils.lerp(1.0, 0.82, convergeEased);
                pulseFactorValue = THREE.MathUtils.lerp(0.5, 0.95, convergeEased);
            } else if (normalT < convergeDuration + pulseDuration) {
                // Phase 2: Single expand/contract pulse
                const pulseT = normalT - convergeDuration;
                const pulseProgress = pulseT / pulseDuration;
                
                // Use sine wave for smooth expand/contract (0->1->0)
                const pulseCycle = Math.sin(pulseProgress * Math.PI);
                
                currentDist = THREE.MathUtils.lerp(closeConvergeDist, triangleExpandDist, pulseCycle);
                scale = THREE.MathUtils.lerp(0.82, 1.0, pulseCycle);
                pulseFactorValue = THREE.MathUtils.lerp(0.95, 0.6, pulseCycle);
            } else {
                // Phase 3: Hold at converged position before transitioning to venn
                currentDist = closeConvergeDist;
                scale = 0.82;
                pulseFactorValue = 0.95;
            }

            for (let i = 0; i < 3; i++) {
                const angleIndex = triangleMapping[i];
                const angle = triangleAngles[angleIndex] + rotation;
            const p = new THREE.Vector2(
                Math.cos(angle) * currentDist,
                    Math.sin(angle) * currentDist + centerY
            );
            spheres[i].position.set(p.x, p.y, -i * 0.002);
                spheres[i].rotation.z = 0;
            spheres[i].scale.set(scale, scale, scale);
            triMat.uniforms.points.value[i].copy(p);
        }
            blackHole.visible = true;
            blackHole.material.uniforms.pulseFactor.value = pulseFactorValue;

        } else if (phase === 'venn') {
            // Slow down and form clear venn diagram
            const vennProgress = (t - introCfg.normalEnd) / (introCfg.vennEnd - introCfg.normalEnd);
            // Smooth cubic easing
            const eased = vennProgress < 0.5 ? 
                4 * vennProgress * vennProgress * vennProgress : 
                1 - Math.pow(-2 * vennProgress + 2, 3) / 2;
            
            const normalDuration = introCfg.normalEnd - introCfg.transitionEnd;
            const centerY = 0;
            
            const triangleAngles = [
                Math.PI / 2 + (2 * Math.PI / 3) * 0,
                Math.PI / 2 + (2 * Math.PI / 3) * 1,
                Math.PI / 2 + (2 * Math.PI / 3) * 2
            ];
            
            // Start from where normal ended: transitionEndRotation + normalDuration * rotationSpeed
            const transitionEndRotation = 0.2 + Math.PI * 2;
            const baseRotation = transitionEndRotation + (normalDuration * motionCfg.rotationSpeed);
            const vennT = t - introCfg.normalEnd;
            const slowRotation = baseRotation + (vennT * motionCfg.rotationSpeed * 0.3); // Slow down to 30%
            
            // Settle into venn diagram distance - calculate what pulse factor was at END of normal phase
            const normalEndTime = introCfg.normalEnd - introCfg.transitionEnd;
            const startPulseFactor = 0.5 + 0.5 * Math.sin(normalEndTime * motionCfg.speed);
            const startDist = motionCfg.maxDist * startPulseFactor;
            const targetDist = 0.08; // Very close for dramatic overlap
            const currentDist = THREE.MathUtils.lerp(startDist, targetDist, eased);
            const scale = THREE.MathUtils.lerp(1.0, 0.7, eased); // Much larger for awesome venn!

            // Use same mapping as triangle phase
            const triangleMapping = [1, 0, 2];

            for (let i = 0; i < 3; i++) {
                const angleIndex = triangleMapping[i];
                const angle = triangleAngles[angleIndex] + slowRotation;
                const p = new THREE.Vector2(
                    Math.cos(angle) * currentDist,
                    Math.sin(angle) * currentDist + centerY
                );
                spheres[i].position.set(p.x, p.y, -i * 0.002);
                spheres[i].rotation.z = 0;
                spheres[i].scale.set(scale, scale, scale);
                triMat.uniforms.points.value[i].copy(p);
            }
            blackHole.visible = true;
            blackHole.material.uniforms.pulseFactor.value = THREE.MathUtils.lerp(startPulseFactor, 0.6, eased);
            
            if (!quoteShown) {
                applyQuoteState(quoteStates.initial, { immediate: true });
                quoteEl.classList.remove('scrambling', 'glitch', 'glitchMedium', 'glitchIntense');
                document.getElementById('quote').classList.add('visible');
                quoteDespairShown = false;
                quoteShown = true;
            }
            
        } else if (phase === 'collapse') {
            // Grow and collapse into white radiating circle
            const collapseProgress = (t - introCfg.vennEnd) / (introCfg.collapseEnd - introCfg.vennEnd);
            // Smooth cubic easing
            const eased = collapseProgress < 0.5 ? 
                4 * collapseProgress * collapseProgress * collapseProgress : 
                1 - Math.pow(-2 * collapseProgress + 2, 3) / 2;
            
            const centerY = 0;
            
            const triangleAngles = [
                Math.PI / 2 + (2 * Math.PI / 3) * 0,
                Math.PI / 2 + (2 * Math.PI / 3) * 1,
                Math.PI / 2 + (2 * Math.PI / 3) * 2
            ];
            
            // Start from where venn ended
            const transitionEndRotation = 0.2 + Math.PI * 2;
            const normalDuration = introCfg.normalEnd - introCfg.transitionEnd;
            const vennDuration = introCfg.vennEnd - introCfg.normalEnd;
            const baseRotation = transitionEndRotation + (normalDuration * motionCfg.rotationSpeed) + (vennDuration * motionCfg.rotationSpeed * 0.3);
            const collapseT = t - introCfg.vennEnd;
            const rotation = baseRotation + (collapseT * motionCfg.rotationSpeed * 0.15); // Even slower
            
            // Collapse to tiny overlap while growing in size
            const startDist = 0.08;
            const targetDist = 0.005;
            const currentDist = THREE.MathUtils.lerp(startDist, targetDist, eased);
            const scale = THREE.MathUtils.lerp(0.7, 0.85, eased); // Massive spheres!

            // Use same mapping as triangle phase
            const triangleMapping = [1, 0, 2];

        for (let i = 0; i < 3; i++) {
                const angleIndex = triangleMapping[i];
                const angle = triangleAngles[angleIndex] + rotation;
            const p = new THREE.Vector2(
                Math.cos(angle) * currentDist,
                    Math.sin(angle) * currentDist + centerY
            );
            spheres[i].position.set(p.x, p.y, -i * 0.002);
            spheres[i].rotation.z = 0;
            spheres[i].scale.set(scale, scale, scale);
            triMat.uniforms.points.value[i].copy(p);
        }
            blackHole.visible = true;
            blackHole.material.uniforms.pulseFactor.value = THREE.MathUtils.lerp(0.6, 0.85, eased);
            
            if (collapseProgress > 0.3 && !glitchStarted) {
                document.getElementById('quote').classList.add('glitch');
                glitchStarted = true;
            }
            
        } else if (phase === 'glitch' || phase === 'blackout' || phase === 'loomworks' || phase === 'celli') {
            // Hide spheres during ending sequence, keep last position
            const centerY = 0;
            const targetDist = 0.005;
            const scale = 0.85;
            
            const triangleAngles = [
                Math.PI / 2 + (2 * Math.PI / 3) * 0,
                Math.PI / 2 + (2 * Math.PI / 3) * 1,
                Math.PI / 2 + (2 * Math.PI / 3) * 2
            ];
            
            const slowRotation = t * 0.05;
            
            // Fade out spheres during glitch phase
            let sphereOpacity = 1.0;
            if (phase === 'glitch') {
                const glitchProgress = (t - introCfg.collapseEnd) / (introCfg.glitchEnd - introCfg.collapseEnd);
                sphereOpacity = THREE.MathUtils.lerp(1.0, 0, glitchProgress);
                if (glitchProgress > 0.25 && !quoteDespairShown) {
                    glitchSwapQuote(quoteStates.despair, { duration: 950, onComplete: () => quoteEl.classList.add('quote--loom') });
                    quoteDespairShown = true;
                }
            } else {
                sphereOpacity = 0;
            }
            
            // Use same mapping as triangle phase
            const triangleMapping = [1, 0, 2];
            
            for (let i = 0; i < 3; i++) {
                const angleIndex = triangleMapping[i];
                const angle = triangleAngles[angleIndex] + slowRotation;
                const p = new THREE.Vector2(
                    Math.cos(angle) * targetDist,
                    Math.sin(angle) * targetDist + centerY
                );
                spheres[i].position.set(p.x, p.y, -i * 0.002);
                spheres[i].rotation.z = 0;
                spheres[i].scale.set(scale, scale, scale);
                spheres[i].material.opacity = sphereOpacity;
            triMat.uniforms.points.value[i].copy(p);
        }

            blackHole.visible = phase === 'glitch';
            if (phase === 'glitch') {
                const glitchProgress = (t - introCfg.collapseEnd) / (introCfg.glitchEnd - introCfg.collapseEnd);
                blackHole.material.uniforms.pulseFactor.value = THREE.MathUtils.lerp(0.85, 0, glitchProgress);
            }
        }
    }

    // --- Responsive ---------------------------------------------------------
    function onResize(){
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
      const aspect = window.innerWidth / window.innerHeight;
      triMat.uniforms.aspect.value = aspect;
      if (aspect > 1) { // Landscape
          camera.left = -aspect; camera.right = aspect; camera.top = 1; camera.bottom = -1;
          // Scale black hole to maintain circularity
          blackHole.scale.set(1, 1, 1);
      } else { // Portrait
          camera.left = -1; camera.right = 1; camera.top = 1 / aspect; camera.bottom = -1 / aspect;
          // Scale black hole to maintain circularity
          blackHole.scale.set(aspect, aspect, 1);
      }
      camera.updateProjectionMatrix();
      
      // Recalculate CELLI scale for responsive layout
      const oldScale = celliScale;
      calculateCelliScale();

      // Update voxel positions and scales based on new scale
      if (oldScale !== celliScale) {
          const scaleRatio = celliScale / oldScale;
          voxels.forEach((voxel) => {
              const data = voxel.userData;
              // Update positions with new scale
              data.targetX *= scaleRatio;
              data.targetY *= scaleRatio;
              data.baseScale = celliScale;

              // Update actual positions if settled
              if (data.settled) {
                  voxel.position.x = data.targetX;
                  voxel.position.y = data.targetY;
              }

              // Update scale
              voxel.scale.set(celliScale, celliScale, celliScale);
          });
      }

      if (bowActive) {
          moveBowToTarget(true);
      }
    }
    window.addEventListener('resize', onResize);
    onResize();

    // --- Animate (gated by Play) -------------------------------------------
    const clock = new THREE.Clock();
    let running = false, totalTime = 0;
    
    // Canvas for text particles
    const textCanvas = document.createElement('canvas');
    textCanvas.style.position = 'fixed';
    textCanvas.style.inset = '0';
    textCanvas.style.pointerEvents = 'none';
    textCanvas.style.zIndex = '5';
    document.body.appendChild(textCanvas);
    const textCtx = textCanvas.getContext('2d');
    
    function resizeTextCanvas() {
        textCanvas.width = window.innerWidth;
        textCanvas.height = window.innerHeight;
    }
    resizeTextCanvas();
    window.addEventListener('resize', resizeTextCanvas);
    
     // Gentle thunk sound for rolling (lighter than landing)
     function playRollingThunk(volume = 0.08, delay = 0) {
         if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
         const now = audioCtx.currentTime + delay;
         
         // Subtle rolling "tap" sound
         const osc = audioCtx.createOscillator();
         const gain = audioCtx.createGain();
         
         osc.type = 'sine';
         osc.frequency.setValueAtTime(100 + Math.random() * 20, now); // Slight variation
         osc.frequency.exponentialRampToValueAtTime(50, now + 0.05);
         
         gain.gain.setValueAtTime(volume, now);
         gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
         
         osc.connect(gain);
         gain.connect(audioCtx.destination);
         osc.start(now);
         osc.stop(now + 0.15);
     }
     
     // Heavier thud for jumps and landings
     function playBounceThud(volume = 0.15, delay = 0) {
         if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
         const now = audioCtx.currentTime + delay;
         
         // Deep impact sound
         const osc = audioCtx.createOscillator();
         const gain = audioCtx.createGain();
         
         osc.type = 'sine';
         osc.frequency.setValueAtTime(60, now); // Deep thud
         osc.frequency.exponentialRampToValueAtTime(30, now + 0.15);
         
         gain.gain.setValueAtTime(volume, now);
         gain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
         
         osc.connect(gain);
         gain.connect(audioCtx.destination);
         osc.start(now);
         osc.stop(now + 0.25);
     }
     
     // Hollow melodic chime for voxel landing - C pentatonic scale
     function playVoxelChime(delay = 0) {
         if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
         const now = audioCtx.currentTime + delay;
         
         // Pentatonic scale notes for melodic chimes (C, D, E, G, A)
         const pentatonicNotes = [523.25, 587.33, 659.25, 783.99, 880]; // C5, D5, E5, G5, A5
         const fundamentalFreq = pentatonicNotes[Math.floor(Math.random() * pentatonicNotes.length)];
         
         // Hollow sound: triangle wave with filtered overtones
         const osc1 = audioCtx.createOscillator();
         const osc2 = audioCtx.createOscillator();
         const osc3 = audioCtx.createOscillator();
         const filter = audioCtx.createBiquadFilter();
         const gain = audioCtx.createGain();
         
         osc1.type = 'triangle'; // Hollow fundamental
         osc1.frequency.setValueAtTime(fundamentalFreq, now);
         
         osc2.type = 'sine'; // Soft overtone
         osc2.frequency.setValueAtTime(fundamentalFreq * 3, now);
         
         osc3.type = 'sine'; // Gentle fifth
         osc3.frequency.setValueAtTime(fundamentalFreq * 1.5, now);
         
         // Band-pass filter for hollow character
         filter.type = 'bandpass';
         filter.frequency.setValueAtTime(fundamentalFreq * 2, now);
         filter.Q.setValueAtTime(2, now);
         
         // Gentle envelope
         gain.gain.setValueAtTime(0, now);
         gain.gain.linearRampToValueAtTime(0.03, now + 0.01);
         gain.gain.exponentialRampToValueAtTime(0.001, now + 1.2);
         
         osc1.connect(filter);
         osc2.connect(gain);
         osc3.connect(gain);
         filter.connect(gain);
         gain.connect(audioCtx.destination);
         
         osc1.start(now);
         osc2.start(now);
         osc3.start(now);
         osc1.stop(now + 1.2);
         osc2.stop(now + 1.2);
         osc3.stop(now + 1.2);
     }
    
    // Chiptune music system - simple arpeggio + drums
    let chiptuneBass = null;
    let chiptuneGain = null;
    let lastNoteTime = 0;
    let lastDrumTime = 0;
    let noteIndex = 0;
    let drumIndex = 0;
    let musicStarted = false;
    let reverbDelay = null;
    let reverbGain = null;
    let reverbFeedback = null;
    let glitchWhirOsc1 = null;
    let glitchWhirOsc2 = null;
    let glitchWhirOsc3 = null;
    let glitchWhirGain = null;
    let glitchWhirFilter = null;
    let glitchWhirStarted = false;
    
    function updateSynth(t) {
        // Start music during triangle phase
        if (!musicStarted && t > introCfg.bounceEnd) {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            
            // Create reverb delay effect
            reverbDelay = audioCtx.createDelay(2.0);
            reverbDelay.delayTime.value = 0.25; // 250ms delay
            reverbGain = audioCtx.createGain();
            reverbGain.gain.value = 0.3; // Moderate reverb mix
            reverbFeedback = audioCtx.createGain();
            reverbFeedback.gain.value = 0.4; // Feedback for reverb tail
            
            // Wire up reverb: delay -> feedback -> delay (loop) + output
            reverbDelay.connect(reverbFeedback);
            reverbFeedback.connect(reverbDelay);
            reverbDelay.connect(reverbGain);
            reverbGain.connect(audioCtx.destination);
            
            musicStarted = true;
            lastNoteTime = t;
            lastDrumTime = t;
        }
        
        if (!musicStarted || !audioCtx) return;
        
        const now = audioCtx.currentTime;
        
        // Determine arpeggio and rhythm based on phase
        let arpeggio = [];
        let noteSpeed = 0.25;
        let drumSpeed = 0.5;
        let drumVolume = 0.12;
        let drumReverb = 0.2;
        let reverbMix = 0.3;
        let glitchLevel = 0;
        
        if (t < introCfg.triangleEnd) {
            // Calm, contemplative Am progression
            arpeggio = [220.00, 261.63, 329.63, 261.63]; // A3, C4, E4, C4
            noteSpeed = 0.5;
            drumSpeed = 1.2;
            drumVolume = 0.08;
            drumReverb = 0.25;
            reverbMix = 0.35;
        } else if (t < introCfg.normalEnd) {
            // Gentle progression with suspension
            arpeggio = [220.00, 246.94, 293.66, 329.63, 293.66, 246.94]; // A3, B3, D4, E4, D4, B3
            noteSpeed = 0.45;
            drumSpeed = 1.0;
            drumVolume = 0.1;
            drumReverb = 0.3;
            reverbMix = 0.4;
        } else if (t < introCfg.vennEnd) {
            // Subdued, introspective
            arpeggio = [196.00, 246.94, 293.66, 349.23, 293.66, 246.94]; // G3, B3, D4, F4, D4, B3
            noteSpeed = 0.4;
            drumSpeed = 0.9;
            drumVolume = 0.12;
            drumReverb = 0.4;
            reverbMix = 0.45;
        } else if (t < introCfg.collapseEnd) {
            // Building unease, drums more present
            arpeggio = [220.00, 277.18, 329.63, 392.00, 329.63, 277.18]; // A3, C#4, E4, G4, E4, C#4
            noteSpeed = 0.38;
            drumSpeed = 0.7;
            drumVolume = 0.16; // Drums becoming more prominent
            drumReverb = 0.6;
            reverbMix = 0.5;
            glitchLevel = 0.1;
        } else if (t < introCfg.glitchEnd) {
            // Dissonant breakdown, drums dominate
            const glitchProgress = (t - introCfg.collapseEnd) / (introCfg.glitchEnd - introCfg.collapseEnd);
            arpeggio = [233.08, 277.18, 369.99, 415.30]; // Diminished, unsettling
            noteSpeed = 0.35;
            drumSpeed = 0.55;
            drumVolume = THREE.MathUtils.lerp(0.18, 0.28, glitchProgress); // Drums take over
            drumReverb = THREE.MathUtils.lerp(0.6, 0.85, glitchProgress);
            reverbMix = THREE.MathUtils.lerp(0.5, 0.65, glitchProgress);
            glitchLevel = THREE.MathUtils.lerp(0.2, 0.8, glitchProgress);
        } else {
            return;
        }
        
        // Update reverb mix
        if (reverbGain) {
            reverbGain.gain.setTargetAtTime(reverbMix, now, 0.5);
        }
        
        // Play arpeggio notes
        if (t - lastNoteTime >= noteSpeed) {
            const freq = arpeggio[noteIndex % arpeggio.length];
            playChiptuneNote(freq, noteSpeed * 0.9, glitchLevel, reverbDelay);
            noteIndex++;
            lastNoteTime = t;
        }
        
        // Play drum beats
        if (t - lastDrumTime >= drumSpeed) {
            playChiptuneDrum(drumVolume, drumReverb, glitchLevel, reverbDelay);
            drumIndex++;
            lastDrumTime = t;
        }
        
        // Corrupted whir during glitch phase
        if (t >= introCfg.collapseEnd && t < introCfg.glitchEnd) {
            const glitchProgress = (t - introCfg.collapseEnd) / (introCfg.glitchEnd - introCfg.collapseEnd);
            
            if (!glitchWhirStarted) {
                // Start the harsh whirring synth
                glitchWhirOsc1 = audioCtx.createOscillator();
                glitchWhirOsc2 = audioCtx.createOscillator();
                glitchWhirOsc3 = audioCtx.createOscillator();
                glitchWhirGain = audioCtx.createGain();
                glitchWhirFilter = audioCtx.createBiquadFilter();
                
                // Triangle waves for harsh, mechanical sound
                glitchWhirOsc1.type = 'triangle';
                glitchWhirOsc2.type = 'triangle';
                glitchWhirOsc3.type = 'triangle';
                
                // Detuning for thickness
                glitchWhirOsc1.detune.value = -8;
                glitchWhirOsc2.detune.value = 0;
                glitchWhirOsc3.detune.value = 8;
                
                // Start at low frequency
                glitchWhirOsc1.frequency.setValueAtTime(220, now);
                glitchWhirOsc2.frequency.setValueAtTime(220, now);
                glitchWhirOsc3.frequency.setValueAtTime(220, now);
                
                // Resonant filter for harsh whir
                glitchWhirFilter.type = 'lowpass';
                glitchWhirFilter.frequency.setValueAtTime(400, now);
                glitchWhirFilter.Q.setValueAtTime(8, now);
                
                glitchWhirGain.gain.setValueAtTime(0, now);
                glitchWhirGain.gain.linearRampToValueAtTime(0.08, now + 0.5);
                
                glitchWhirOsc1.connect(glitchWhirFilter);
                glitchWhirOsc2.connect(glitchWhirFilter);
                glitchWhirOsc3.connect(glitchWhirFilter);
                glitchWhirFilter.connect(glitchWhirGain);
                glitchWhirGain.connect(audioCtx.destination);
                
                glitchWhirOsc1.start(now);
                glitchWhirOsc2.start(now);
                glitchWhirOsc3.start(now);
                
                glitchWhirStarted = true;
            }
            
            // Modulate frequency for failing sound
            if (glitchWhirOsc1) {
                const crackle = Math.sin(t * 100) * 20 * glitchProgress;
                const whir = Math.sin(t * 30) * 10;
                const baseFreq = THREE.MathUtils.lerp(220, 55, glitchProgress); // Pitch down as it fails
                
                glitchWhirOsc1.frequency.setTargetAtTime(baseFreq + crackle + whir, now, 0.02);
                glitchWhirOsc2.frequency.setTargetAtTime(baseFreq + crackle + whir * 1.1, now, 0.02);
                glitchWhirOsc3.frequency.setTargetAtTime(baseFreq + crackle + whir * 0.9, now, 0.02);
                
                // Filter sweep downward
                glitchWhirFilter.frequency.setTargetAtTime(THREE.MathUtils.lerp(400, 100, glitchProgress), now, 0.1);
                
                // Volume swell and fade
                const vroomPhase = Math.sin(t * 2) * 0.5 + 0.5;
                const fadeOut = 1 - glitchProgress * 0.7; // Fade out near end
                glitchWhirGain.gain.setTargetAtTime(0.08 * fadeOut * vroomPhase, now, 0.05);
            }
        } else if (glitchWhirStarted && glitchWhirOsc1) {
            // Stop the whir after glitch phase
            glitchWhirOsc1.stop(now + 0.5);
            glitchWhirOsc2.stop(now + 0.5);
            glitchWhirOsc3.stop(now + 0.5);
            glitchWhirOsc1 = null;
            glitchWhirOsc2 = null;
            glitchWhirOsc3 = null;
        }
    }
    
    // Chiptune note player - muted, musical synth
    function playChiptuneNote(freq, duration, glitchLevel = 0, reverbNode = null) {
        if (!audioCtx) return;
        const now = audioCtx.currentTime;
        
        const osc1 = audioCtx.createOscillator();
        const osc2 = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();
        
        // Sine waves for muted, warm tone
        osc1.type = 'sine';
        osc2.type = 'sine';
        
        // Add subtle harmonic (5th) for richness
        const glitchWobble = glitchLevel > 0 ? (Math.random() - 0.5) * freq * glitchLevel * 0.2 : 0;
        osc1.frequency.setValueAtTime(freq + glitchWobble, now);
        osc2.frequency.setValueAtTime((freq * 1.5) + glitchWobble, now); // Perfect 5th
        
        // Muted low-pass filter
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(glitchLevel > 0.5 ? 600 : 1200, now);
        filter.Q.setValueAtTime(0.3, now);
        
        // Very soft, gentle envelope
        const baseVol = 0.045 * (1 - glitchLevel * 0.3);
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(baseVol, now + 0.03);
        gain.gain.setValueAtTime(baseVol * 0.85, now + duration * 0.5);
        gain.gain.linearRampToValueAtTime(0, now + duration);
        
        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);
        
        // Connect to reverb if available
        if (reverbNode) {
            gain.connect(reverbNode);
        }
        
        osc1.start(now);
        osc2.start(now);
        osc1.stop(now + duration);
        osc2.stop(now + duration);
    }
    
    // Startup bass sound (Simple warm chord - NO REVERB to prevent oscillation)
    function playStartupBass() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const now = audioCtx.currentTime;
        
        // Master output - simple, clean
        const masterGain = audioCtx.createGain();
        masterGain.gain.value = 0.4;
        masterGain.connect(audioCtx.destination);
        
        // Simple warm chord - C major
        const chordNotes = [
            { freq: 130.81, vol: 0.10 },  // C3
            { freq: 164.81, vol: 0.08 },  // E3
            { freq: 196.00, vol: 0.07 },  // G3
            { freq: 65.41, vol: 0.09 },   // C2 (bass)
        ];
        
        chordNotes.forEach((note, i) => {
            const osc = audioCtx.createOscillator();
            const oscGain = audioCtx.createGain();
            
            osc.type = 'sine';
            osc.frequency.value = note.freq; // Fixed frequency, no modulation
            
            // Simple envelope
            const delay = i * 0.08;
            oscGain.gain.setValueAtTime(0, now + delay);
            oscGain.gain.linearRampToValueAtTime(note.vol, now + delay + 0.15);
            oscGain.gain.setValueAtTime(note.vol * 0.9, now + delay + 0.6);
            oscGain.gain.linearRampToValueAtTime(0, now + delay + 1.5);
            
            osc.connect(oscGain);
            oscGain.connect(masterGain);
            
            osc.start(now + delay);
            osc.stop(now + delay + 1.6);
        });
    }
    
    // Distorted startup bass sound - progressively more distorted per click
    function playStartupBassDistorted(clickCount = 1) {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const now = audioCtx.currentTime;
        
        // Distortion increases with each click
        const distortionLevel = clickCount * 0.3; // 0.3, 0.6, 0.9
        
        // Master output with distortion
        const masterGain = audioCtx.createGain();
        masterGain.gain.value = 0.4;
        
        // Add waveshaper for distortion
        const distortion = audioCtx.createWaveShaper();
        const curve = new Float32Array(256);
        const deg = Math.PI / 180;
        const amount = distortionLevel * 100; // 30, 60, 90
        for (let i = 0; i < 256; i++) {
            const x = (i * 2) / 256 - 1;
            curve[i] = ((3 + amount) * x * 20 * deg) / (Math.PI + amount * Math.abs(x));
        }
        distortion.curve = curve;
        distortion.oversample = '4x';
        
        masterGain.connect(distortion);
        distortion.connect(audioCtx.destination);
        
        // Chord notes with detuning that increases per click
        const chordNotes = [
            { freq: 130.81, vol: 0.10 },  // C3
            { freq: 164.81, vol: 0.08 },  // E3
            { freq: 196.00, vol: 0.07 },  // G3
            { freq: 65.41, vol: 0.09 },   // C2 (bass)
        ];
        
        chordNotes.forEach((note, i) => {
            const osc = audioCtx.createOscillator();
            const oscGain = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();
            
            osc.type = 'sawtooth'; // More harmonics for distortion
            
            // Add detuning/wobble based on click count
            const detune = (Math.random() - 0.5) * clickCount * 15;
            osc.frequency.setValueAtTime(note.freq + detune, now);
            
            // Add frequency wobble during playback
            osc.frequency.linearRampToValueAtTime(note.freq + detune * 1.5, now + 0.3);
            osc.frequency.linearRampToValueAtTime(note.freq + detune * 0.5, now + 1.0);
            
            // Filter gets more aggressive with each click
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(2000 - clickCount * 400, now);
            filter.Q.value = 1 + clickCount * 0.5;
            
            // Envelope
            const delay = i * 0.08;
            oscGain.gain.setValueAtTime(0, now + delay);
            oscGain.gain.linearRampToValueAtTime(note.vol * (1 + distortionLevel * 0.3), now + delay + 0.15);
            oscGain.gain.setValueAtTime(note.vol * 0.9, now + delay + 0.6);
            oscGain.gain.linearRampToValueAtTime(0, now + delay + 1.5);
            
            osc.connect(filter);
            filter.connect(oscGain);
            oscGain.connect(masterGain);
            
            osc.start(now + delay);
            osc.stop(now + delay + 1.6);
        });
        
        // Add noise for extra degradation on later clicks
        if (clickCount >= 2) {
            const noiseBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 1.5, audioCtx.sampleRate);
            const noiseData = noiseBuffer.getChannelData(0);
            for (let i = 0; i < noiseData.length; i++) {
                noiseData[i] = (Math.random() * 2 - 1) * 0.1 * (clickCount - 1);
            }
            const noiseSource = audioCtx.createBufferSource();
            const noiseGain = audioCtx.createGain();
            noiseSource.buffer = noiseBuffer;
            noiseGain.gain.setValueAtTime(0, now);
            noiseGain.gain.linearRampToValueAtTime(0.05 * clickCount, now + 0.2);
            noiseGain.gain.linearRampToValueAtTime(0, now + 1.4);
            noiseSource.connect(noiseGain);
            noiseGain.connect(masterGain);
            noiseSource.start(now);
            noiseSource.stop(now + 1.5);
        }
    }
    
    // Chiptune drum player
    function playChiptuneDrum(volume = 0.12, reverbAmount = 0.3, glitchLevel = 0, reverbNode = null) {
        if (!audioCtx) return;
        const now = audioCtx.currentTime;
        
        // Kick drum
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const reverbSend = audioCtx.createGain();
        
        osc.type = 'sine';
        const startFreq = glitchLevel > 0.5 ? 80 + Math.random() * 40 : 60;
        osc.frequency.setValueAtTime(startFreq, now);
        osc.frequency.exponentialRampToValueAtTime(30, now + 0.1);
        
        // Main drum volume (dominant)
        gain.gain.setValueAtTime(volume, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
        
        // Reverb send amount
        reverbSend.gain.setValueAtTime(volume * reverbAmount, now);
        reverbSend.gain.exponentialRampToValueAtTime(0.001, now + 0.3); // Longer reverb tail
        
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        
        // Send to reverb
        if (reverbNode) {
            osc.connect(reverbSend);
            reverbSend.connect(reverbNode);
        }
        
        osc.start(now);
        osc.stop(now + 0.3);
    }
    
    function frame(){
      if(!running) return;
      const dt = Math.min(clock.getDelta(), 0.033);
      totalTime += dt;
      updatePositions(totalTime);
      updateSynth(totalTime);
      blackHole.material.uniforms.time.value = totalTime;
      filmPass.uniforms.time.value += dt;
      composer.render();
      
      // Update and render text particles
      updateTextParticles(dt);
      textCtx.clearRect(0, 0, textCanvas.width, textCanvas.height);
      renderTextParticles(textCtx, camera);
      
      // Update voxels for CELLI animation
      updateVoxels(totalTime, dt);
      
      // Update floating voxels during burst
      updateFloatingVoxels(dt);
      
      // Update camera pan
      updateCameraPan();
      
      requestAnimationFrame(frame);
    }

    // --- Click interaction on spheres and black hole ----------------------------------------
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    
    renderer.domElement.addEventListener('click', (event) => {
        if (!running) return;
        
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        
        raycaster.setFromCamera(mouse, camera);
        
        // Check black hole first - make it clickable whenever visible
        const blackHoleIntersects = raycaster.intersectObject(blackHole, true);
        console.log('🔍 Black hole visible:', blackHole.visible, 'Intersects:', blackHoleIntersects.length);
        if (blackHoleIntersects.length > 0 && blackHole.visible) {
            console.log('🕳️ Black hole clicked - showing VisiCalc');
            localStorage.setItem('megred_seen_blackhole', 'true');
            showVisiCalc();
            return;
        }
        
        // Then check spheres
        const intersects = raycaster.intersectObjects(spheres);
        
        if (intersects.length > 0) {
            const hitSphere = intersects[0].object;
            const sphereIndex = spheres.indexOf(hitSphere);
            const hitPos = intersects[0].point;
            
            // Burst particles based on color
            let texts, color;
            if (sphereIndex === 0) { // Cyan - equations
                texts = equationTexts;
                color = '#00a8ff';
            } else if (sphereIndex === 1) { // Yellow - time
                texts = Array(8).fill(0).map(() => timeTexts());
                color = '#ffb62e';
            } else { // Magenta - manic
                texts = manicTexts;
                color = '#ff1e6e';
            }
            
            // Create burst of 5-8 particles
            const count = 5 + Math.floor(Math.random() * 4);
            for (let i = 0; i < count; i++) {
                const text = texts[Math.floor(Math.random() * texts.length)];
                createTextParticle(hitPos.x, hitPos.y, text, color, sphereIndex);
            }
        }
    });

    // --- Doorway input keyboard and click interaction ------------------------------------
    const promptContainer = document.querySelector('.prompt-container');
    const promptTextEl = document.getElementById('promptText');
    const promptCursorEl = document.getElementById('promptCursor');
    const hiddenInput = document.getElementById('hiddenInput');
    const promptEl = document.querySelector('.prompt');
    
    // Helper function to wrap each character with per-character shadow
    function updatePromptWithChars(text) {
        if (!promptTextEl) return;
        promptTextEl.innerHTML = '';
        for (let i = 0; i < text.length; i++) {
            const char = text[i];
            const span = document.createElement('span');
            span.className = 'char';
            span.setAttribute('data-char', char);
            span.textContent = char;
            promptTextEl.appendChild(span);
        }
    }
    
    // Click to trigger CELLI glitch (reveal T) and focus hidden input for mobile
    if (promptContainer) {
        function focusHiddenPromptInput() {
            if (!hiddenInput) return;

            hiddenInput.value = '';

            const focusOptions = { preventScroll: true };
            try {
                hiddenInput.focus(focusOptions);
            } catch (err) {
                hiddenInput.focus();
            }

            if (document.activeElement !== hiddenInput) {
                hiddenInput.focus();
            }
        }

        promptContainer.addEventListener('click', () => {
            if (!running || burstAnimStarted) return;
            if (!inputAttempted) {
                triggerCelliGlitch();
                inputAttempted = true;
            }

            if (hiddenInput) {
                focusHiddenPromptInput();
            }
        });
        
        function handlePromptBackspace() {
            if (!running || !doorwayOpened || burstAnimStarted) return false;
            if (inputText.length <= promptBaseText.length) return false;

            inputText = inputText.slice(0, -1);
            tEntered = false;

            updatePromptWithChars(inputText);
            promptCursorEl.textContent = '_';
            if (promptEl) {
                promptEl.setAttribute('data-text', inputText + '_');
            }

            if (hiddenInput) {
                hiddenInput.value = '';
            }

            if (burstTimeout) {
                clearTimeout(burstTimeout);
                burstTimeout = null;
            }

            // Restore one letter with fritz effect
            restoreOneLetter();
            return true;
        }

        // Keyboard input to trigger final sequence (desktop)
        window.addEventListener('keydown', (e) => {
            if (!running || !doorwayOpened || !inputAttempted) return;

            if (e.key === 'Backspace') {
                e.preventDefault();
                handlePromptBackspace();
                return;
            }

            // T input - starts burst sequence
            if (!tEntered && e.key.toLowerCase() === 't') {
                e.preventDefault();
                tEntered = true;
                inputText += 'T';

                // Update display
                updatePromptWithChars(inputText);
                promptCursorEl.textContent = '_';
                if (promptEl) {
                    promptEl.setAttribute('data-text', inputText + '_');
                }

                if (burstTimeout) {
                    clearTimeout(burstTimeout);
                }
                burstTimeout = setTimeout(() => {
                    triggerBurstToStars();
                }, 500);
                return;
            }
            
            // E, N, D inputs - only after STAR is fully cleared and yellow transformation complete
            if (inputText === '=' && allYellowTransformed) {
                const key = e.key.toUpperCase();
                
                console.log('END input detected:', key, 'endSequence:', endSequence, 'allYellowTransformed:', allYellowTransformed);
                
                // E must be first
                if (endSequence === '' && key === 'E') {
                    e.preventDefault();
                    endSequence = 'E';
                    transformToMagentaRed();
                    updatePromptWithChars('=E');
                    if (promptEl) promptEl.setAttribute('data-text', '=E_');
                    console.log('Transformed to MAGENTA');
                    return;
                }
                
                // N must be second (after E)
                if (endSequence === 'E' && key === 'N') {
                    e.preventDefault();
                    endSequence = 'EN';
                    transformToCyanBlue();
                    updatePromptWithChars('=EN');
                    if (promptEl) promptEl.setAttribute('data-text', '=EN_');
                    console.log('Transformed to CYAN');
                    return;
                }
                
                // D must be third (after EN)
                if (endSequence === 'EN' && key === 'D') {
                    e.preventDefault();
                    endSequence = 'END';
                    transformToGreenAndSquare();
                    updatePromptWithChars('=END');
                    if (promptEl) promptEl.setAttribute('data-text', '=END_');
                    console.log('Transformed to GREEN, starting snap animation');
                    return;
                }
            } else if (inputText === '=') {
                console.log('Input is =, but allYellowTransformed is:', allYellowTransformed);
            }
        });
        
        // Mobile input handler
        if (hiddenInput) {
            hiddenInput.addEventListener('beforeinput', (e) => {
                if (!running || !doorwayOpened || !inputAttempted) return;
                if (e.inputType === 'deleteContentBackward') {
                    e.preventDefault();
                    handlePromptBackspace();
                }
            });

            hiddenInput.addEventListener('input', (e) => {
                if (!running || !doorwayOpened || !inputAttempted) return;

                const value = (e.target.value || '').toUpperCase();

                if (value === '') {
                    handlePromptBackspace();
                    return;
                }

                // T input for burst sequence
                if (!tEntered && value.includes('T')) {
                    e.preventDefault();
                    tEntered = true;
                    inputText += 'T';

                    updatePromptWithChars(inputText);
                    promptCursorEl.textContent = '_';
                    if (promptEl) {
                        promptEl.setAttribute('data-text', inputText + '_');
                    }

                    e.target.value = '';

                    if (burstTimeout) {
                        clearTimeout(burstTimeout);
                    }
                    burstTimeout = setTimeout(() => {
                        triggerBurstToStars();
                    }, 500);

                    hiddenInput.blur();
                    return;
                }
                
                // E, N, D inputs after STAR cleared and yellow transformation
                if (inputText === '=' && allYellowTransformed) {
                    // E must be first
                    if (endSequence === '' && value.includes('E')) {
                        e.preventDefault();
                        endSequence = 'E';
                        transformToMagentaRed();
                        updatePromptWithChars('=E');
                        if (promptEl) promptEl.setAttribute('data-text', '=E_');
                        e.target.value = '';
                        return;
                    }
                    
                    // N must be second
                    if (endSequence === 'E' && value.includes('N')) {
                        e.preventDefault();
                        endSequence = 'EN';
                        transformToCyanBlue();
                        updatePromptWithChars('=EN');
                        if (promptEl) promptEl.setAttribute('data-text', '=EN_');
                        e.target.value = '';
                        return;
                    }
                    
                    // D must be third
                    if (endSequence === 'EN' && value.includes('D')) {
                        e.preventDefault();
                        endSequence = 'END';
                        transformToGreenAndSquare();
                        updatePromptWithChars('=END');
                        if (promptEl) promptEl.setAttribute('data-text', '=END_');
                        e.target.value = '';
                        return;
                    }
                }
                
                // Clear any other input
                e.target.value = '';
            });
        }
    }
    
    // Break apart and rise to sky
    let breakApartStarted = false;
    let riseStartTime = 0;
    
    function triggerBurstToStars() {
        if (burstAnimStarted) return;
        burstAnimStarted = true;
        burstTimeout = null;
        breakApartStarted = true;
        riseStartTime = Date.now();

        const skipBtn = document.getElementById('skipBtn');
        if (skipBtn) {
            skipBtn.classList.remove('illuminating');
        }

        // Increase afterimage effect for dramatic trails
        afterimagePass.uniforms.damp.value = 0.88;
        
        // Hide prompt but keep it for reference
        if (promptEl) {
            promptEl.style.transition = 'opacity 0.5s ease';
            promptEl.style.opacity = '0';
        }
        
        // Get only the T-shape voxels (the ones that weren't glitched)
        const activeVoxels = voxels.filter(v => !v.userData.glitched && v.visible);
        
        // Give each voxel velocity to shoot upward dramatically
        activeVoxels.forEach((voxel, idx) => {
            setTimeout(() => {
                const angle = Math.random() * Math.PI * 2;
                const spreadH = 0.008 + Math.random() * 0.015; // More horizontal spread
                
                voxel.userData.floating = true;
                voxel.userData.vx = Math.cos(angle) * spreadH;
                voxel.userData.vy = 0.08 + Math.random() * 0.05; // MUCH faster upward - shooting motion
                voxel.userData.vz = -0.05 - Math.random() * 0.08; // Move away from camera (into distance)
                voxel.userData.pulsatePhase = Math.random() * Math.PI * 2;
                voxel.userData.pulsateSpeed = 3 + Math.random() * 3;
                voxel.userData.floatStartTime = Date.now();
                voxel.userData.initialScale = voxel.userData.baseScale || 1.0;
            }, idx * 15); // Faster stagger
        });
        
        // Start camera pan after voxels have shot into distance
        setTimeout(() => {
            startCameraPan();
        }, 4000); // Slightly longer to see them recede
    }
    
    // Update floating voxels
    function updateFloatingVoxels(dt) {
        if (!breakApartStarted) return;
        
        const now = Date.now();
        const totalElapsed = (now - riseStartTime) / 1000;
        
        voxels.forEach(voxel => {
            if (!voxel.userData.floating) return;
            
            const data = voxel.userData;
            const age = (now - data.floatStartTime) / 1000;
            
            // Move with velocity - shooting into distance
            voxel.position.x += data.vx;
            voxel.position.y += data.vy;
            voxel.position.z += data.vz;
            
            // Very slow drag to maintain shooting motion
            data.vx *= 0.985;
            data.vy *= 0.985;
            data.vz *= 0.985;
            
            // Scale down dramatically as they move away (perspective)
            // Based on Z distance from camera
            const distanceZ = Math.abs(voxel.position.z + 0.5); // Initial Z was around -0.5
            const perspectiveScale = 1 / (1 + distanceZ * 3); // Shrink rapidly with distance
            
            // Pulsate on top of perspective scaling
            data.pulsatePhase += data.pulsateSpeed * dt;
            const pulse = 0.85 + Math.sin(data.pulsatePhase) * 0.15;
            const baseScale = data.initialScale || 1.0;
            const finalScale = baseScale * pulse * perspectiveScale;
            voxel.scale.set(finalScale, finalScale, finalScale);
            
            // Brighten voxels during shooting (they're stars now)
            voxel.material.color.setRGB(1, 1, 1); // Pure white
            
            // Pulsate material opacity with distance fade
            const opacityPulse = 0.8 + Math.sin(data.pulsatePhase * 0.7) * 0.2;
            const distanceFade = Math.max(0.3, 1 - distanceZ * 0.4); // Fade as they get far
            voxel.material.opacity = Math.min(1.0, opacityPulse * distanceFade);
            data.edges.material.opacity = Math.min(0.8, opacityPulse * 0.8 * distanceFade);
            
            // Fade out during camera pan
            if (cameraPanStarted) {
                const panProgress = (now - panStartTime) / panDuration;
                const fadeStart = 0.5;
                if (panProgress > fadeStart) {
                    const fadeProgress = (panProgress - fadeStart) / (1 - fadeStart);
                    voxel.material.opacity *= (1 - fadeProgress * 0.8);
                    data.edges.material.opacity *= (1 - fadeProgress * 0.8);
                }
            }
        });
    }
    
    // Pan camera down to reveal gradient
    let cameraPanStarted = false;
    let panStartTime = 0;
    const panDuration = 5000; // 5 seconds for dramatic reveal
    
    function startCameraPan() {
        cameraPanStarted = true;
        panStartTime = Date.now();
    }
    
    function updateCameraPan() {
        if (!cameraPanStarted) return;
        
        const elapsed = Date.now() - panStartTime;
        const progress = Math.min(1, elapsed / panDuration);
        
        // Smooth ease-in-out for dramatic pan
        const eased = progress < 0.5 ? 
            2 * progress * progress : 
            1 - Math.pow(-2 * progress + 2, 2) / 2;
        
        // Gradually reduce afterimage effect during pan to fade trails
        afterimagePass.uniforms.damp.value = THREE.MathUtils.lerp(0.88, 0.96, progress);
        
        // Pan down much further to reveal gradient
        camera.position.y = THREE.MathUtils.lerp(0, -5, eased);
        camera.lookAt(0, camera.position.y - 2, 0); // Look ahead of camera position
        
        // Fade doorway, prompt, and vignette quickly
        const doorway = document.getElementById('doorway');
        if (doorway) {
            doorway.style.opacity = Math.max(0, 1 - progress * 2);
        }
        
        // Fade out vignette
        const vignette = document.querySelector('.vignette');
        if (vignette) {
            vignette.style.transition = 'opacity 1s ease';
            vignette.style.opacity = String(Math.max(0, 1 - progress * 1.5));
        }
        
        // Add blue gradient background early in the pan
        if (progress > 0.2 && !document.getElementById('nightSky')) {
            // Set app background to black initially for smooth transition
            const app = document.getElementById('app');
            if (app) {
                app.style.background = '#000';
            }
            
            // Immediately hide vignette and scanlines when gradient appears
            const vignetteEl = document.querySelector('.vignette');
            if (vignetteEl) {
                vignetteEl.style.display = 'none';
            }
            
            // Hide scanlines overlay
            if (app && app.classList.contains('scanlines')) {
                app.classList.add('fade-scanlines');
            }
            
            const nightSky = document.createElement('div');
            nightSky.id = 'nightSky';
            nightSky.style.position = 'fixed';
            nightSky.style.inset = '0';
            nightSky.style.background = 'linear-gradient(to bottom, #0d1b2a 0%, #1a237e 20%, #283593 40%, #3949ab 60%, #5e92f3 80%, #90caf9 100%)';
            nightSky.style.zIndex = '0';
            nightSky.style.opacity = '0';
            nightSky.style.pointerEvents = 'none';
            
            // Insert at beginning of body
            if (document.body.firstChild) {
                document.body.insertBefore(nightSky, document.body.firstChild);
            } else {
                document.body.appendChild(nightSky);
            }
            
            // Fade in gradient
            setTimeout(() => {
                nightSky.style.transition = 'opacity 3s ease';
                nightSky.style.opacity = '1';
                
                // Fade out black background
                if (app) {
                    app.style.transition = 'background 3s ease';
                    app.style.background = 'transparent';
                }
            }, 100);
        }
        
        // Fade out 3D scene elements as gradient appears
        if (progress > 0.3) {
            const fadeAmount = Math.min(1, (progress - 0.3) / 0.7); // Fade from 30% to 100%
            
            // Fade renderer canvas
            renderer.domElement.style.transition = 'opacity 0.5s ease';
            renderer.domElement.style.opacity = String(1 - fadeAmount * 0.8); // Keep slight visibility
        }
        
        // Keep stars visible over the gradient longer
        if (progress > 0.7) {
            const starFade = (progress - 0.7) / 0.3;
            textCanvas.style.opacity = String(1 - starFade);
        }
    }
    
    // Render star particles
    function renderStars() {
        if (starParticles.length === 0) return;
        
        const now = Date.now();
        
        // Update and render each star
        for (let i = starParticles.length - 1; i >= 0; i--) {
            const star = starParticles[i];
            
            // Update position based on velocity
            if (star.vx !== undefined) {
                star.x += star.vx;
                star.y += star.vy;
                star.z += star.vz;
                
                // Very slow drag to keep stars moving
                star.vx *= 0.995;
                star.vy *= 0.995;
                star.vz *= 0.995;
            }
            
            // Calculate age and fade
            const age = (now - star.birthTime) / 1000; // in seconds
            const fadeDuration = 8; // fade over 8 seconds (much slower)
            const fadeProgress = Math.min(1, age / fadeDuration);
            
            // Dim brightness over time - keep them bright longer
            star.brightness = 1 - fadeProgress * 0.5; // Keep 50% minimum
            
            // Update twinkle
            star.twinkle += star.twinkleSpeed * 0.016;
            const twinkleBrightness = 0.8 + Math.sin(star.twinkle) * 0.2;
            const finalBrightness = star.brightness * twinkleBrightness;
            
            // Keep stars visible much longer - only remove when very faint
            if (finalBrightness < 0.05) {
                starParticles.splice(i, 1);
                continue;
            }
            
            // Project to screen space
            const vector = new THREE.Vector3(star.x, star.y, star.z);
            vector.project(camera);
            
            // Check if behind camera
            if (vector.z > 1) continue;
            
            const x = (vector.x + 1) / 2 * window.innerWidth;
            const y = (-vector.y + 1) / 2 * window.innerHeight;
            
            // Size based on distance (z-depth)
            const depthScale = Math.max(0.5, 1 - vector.z * 0.5);
            const renderSize = star.size * window.innerWidth * 0.01 * depthScale;
            
            // Draw voxel as square with slight glow
            const voxelSize = renderSize * 1.5;
            const glowSize = voxelSize * 1.5;
            
            // Outer glow
            const gradient = textCtx.createRadialGradient(x, y, 0, x, y, glowSize);
            gradient.addColorStop(0, `rgba(255, 255, 255, ${finalBrightness * 0.8})`);
            gradient.addColorStop(0.6, `rgba(255, 255, 255, ${finalBrightness * 0.3})`);
            gradient.addColorStop(1, `rgba(255, 255, 255, 0)`);
            textCtx.fillStyle = gradient;
            textCtx.beginPath();
            textCtx.arc(x, y, glowSize, 0, Math.PI * 2);
            textCtx.fill();
            
            // Core voxel - square shape
            textCtx.fillStyle = `rgba(255, 255, 255, ${Math.min(1, finalBrightness * 1.1)})`;
            textCtx.fillRect(x - voxelSize/2, y - voxelSize/2, voxelSize, voxelSize);
            
            // Subtle border for voxel definition
            if (finalBrightness > 0.5) {
                textCtx.strokeStyle = `rgba(255, 255, 255, ${finalBrightness * 0.6})`;
                textCtx.lineWidth = 0.5;
                textCtx.strokeRect(x - voxelSize/2, y - voxelSize/2, voxelSize, voxelSize);
            }
        }
    }

    // --- Play button wiring -------------------------------------------------
    const playOverlay = document.getElementById('play');
    const playBtn = document.getElementById('playBtn');
    const skipBtn = document.getElementById('skipBtn');
    
    playBtn.addEventListener('click', ()=>{
      running = true; clock.getDelta();
      playOverlay.classList.add('hidden');
      skipBtn.classList.remove('hidden'); // Show skip button
      clearToast();
      frame();
    });
    
    // --- Skip button logic ---------------------------------------------------
    skipBtn.addEventListener('click', () => {
      if (!running) return;

      // Jump to CELLI phase
      totalTime = introCfg.celliEnd - 6.0; // Start 6 seconds before celli ends (during trickle/chime)
      
      // Hide all prior elements
      quoteEl.style.visibility = 'hidden';
      quoteEl.style.opacity = '0';
      loomworksEl.style.display = 'none';
      triMesh.visible = false;
      blackHole.visible = false;
      spheres.forEach(s => s.visible = false);
      
      // Setup CELLI
      if (!celliStarted) {
        celliStarted = true;
        celliStartTime = totalTime;
      }
      
      // Don't hide skip button - it will transform into a bow later
      
      // Play startup bass note
      setTimeout(() => {
        playStartupBass();
      }, 500);
    });

    skipBtn.addEventListener('keydown', (event) => {
      if (event.key === 'Enter' || event.key === ' ') {
        event.preventDefault();
        skipBtn.click();
      }
    });

    // --- Scene Select System ---------------------------------------------
    const sceneSelect = document.getElementById('sceneSelect');
    const sceneSelectBtn = document.getElementById('sceneSelectBtn');
    const closeSceneSelectBtn = document.getElementById('closeSceneSelect');
    const debugToggle = document.getElementById('debugToggle');
    const clearProgress = document.getElementById('clearProgress');
    const sceneOptions = document.querySelectorAll('.scene-option');
    
    let debugMode = false;
    
    function updateSceneSelect() {
      const hasSeenVisicell = localStorage.getItem('megred_seen_visicell') === 'true';
      const hasSeenLeave = localStorage.getItem('megred_seen_leave') === 'true';
      const hasSeenTheos = localStorage.getItem('megred_seen_theos') === 'true';
      const hasSeenBlackhole = localStorage.getItem('megred_seen_blackhole') === 'true';
      const hasSeenEnd3 = localStorage.getItem('megred_seen_end3') === 'true';
      
      sceneOptions.forEach(opt => {
        const scene = opt.dataset.scene;
        let unlocked = debugMode;
        
        if (!unlocked) {
          if (scene === 'visicell' && hasSeenVisicell) unlocked = true;
          if (scene === 'leave' && hasSeenLeave) unlocked = true;
          if (scene === 'theos' && hasSeenTheos) unlocked = true;
          if (scene === 'blackhole' && hasSeenBlackhole) unlocked = true;
          if (scene === 'end3' && hasSeenEnd3) unlocked = true;
        }
        
        if (unlocked) {
          opt.classList.remove('locked');
        } else {
          opt.classList.add('locked');
        }
      });
      
      debugToggle.textContent = debugMode ? 'Debug: ON ✓' : 'Debug: Show All';
    }
    
    // Open scene select
    sceneSelectBtn.addEventListener('click', () => {
      updateSceneSelect();
      sceneSelect.classList.add('visible');
    });
    
    // Close scene select
    closeSceneSelectBtn.addEventListener('click', () => {
      sceneSelect.classList.remove('visible');
    });
    
    // Debug toggle
    debugToggle.addEventListener('click', () => {
      debugMode = !debugMode;
      updateSceneSelect();
    });
    
    // Clear progress
    clearProgress.addEventListener('click', () => {
      if (confirm('Clear all progress? This will lock all scenes.')) {
        localStorage.removeItem('megred_seen_visicell');
        localStorage.removeItem('megred_seen_leave');
        localStorage.removeItem('megred_seen_theos');
        localStorage.removeItem('megred_seen_blackhole');
        localStorage.removeItem('megred_seen_end3');
        updateSceneSelect();
        console.log('✅ Progress cleared');
      }
    });
    
    // Scene jumps
    sceneOptions.forEach(opt => {
      opt.addEventListener('click', () => {
        if (opt.classList.contains('locked')) return;
        
        const scene = opt.dataset.scene;
        sceneSelect.classList.remove('visible');
        
        // Start the experience if not running
        if (!running) {
          running = true;
          clock.getDelta();
          playOverlay.classList.add('hidden');
          skipBtn.classList.remove('hidden');
          clearToast();
          frame();
        }
        
        // Jump to scene
        if (scene === 'visicell') {
          // Jump to END sequence completed - show VisiCell
          console.log('🎬 Jumping to VisiCell');
          totalTime = introCfg.celliEnd + 10;
          showVisiCalc();
          localStorage.setItem('megred_seen_visicell', 'true');
        } else if (scene === 'leave') {
          // Jump to VisiCalc terminal ready for MADNESS.LOOM command
          console.log('🎬 Jumping to VisiCell terminal (MADNESS.LOOM)');
          totalTime = introCfg.celliEnd + 8;
          showVisiCalc();
          // VisiCalc is shown and ready for terminal input (MADNESS.LOOM command)
          localStorage.setItem('megred_seen_leave', 'true');
        } else if (scene === 'theos') {
          // Jump to THE.OS scene - start of cell address grid sequence
          console.log('🎬 Jumping to THE.OS grid scene (cell lattice start)');
          totalTime = introCfg.celliEnd + 8;
          showVisiCalc();
          // Start from beginning of address sequence (no time jump)
          setTimeout(() => {
            const frameEl = document.getElementById('visicalc-frame');
            const visiCalc = document.getElementById('visicalc');
            if (frameEl) {
              startCellAddressSequence(frameEl, visiCalc);
              console.log('🎬 THE.OS cell address sequence started from beginning');
            }
          }, 500);
          localStorage.setItem('megred_seen_theos', 'true');
        } else if (scene === 'blackhole') {
          // Jump to black hole formed scene (later in sequence)
          console.log('🎬 Jumping to Black Hole formed scene');
          totalTime = introCfg.celliEnd + 8;
          showVisiCalc();
          // Set the jump time to black hole visibility
          window.addressSequenceTime = 56; // Jump to black hole visible time
          console.log('⏰ Pre-setting sequence time to 56s for black hole visibility');
          setTimeout(() => {
            const frameEl = document.getElementById('visicalc-frame');
            const visiCalc = document.getElementById('visicalc');
            if (frameEl) {
              startCellAddressSequence(frameEl, visiCalc);
              console.log('🎬 Cell address sequence started at t=56s (black hole visible)');
            }
          }, 500);
          localStorage.setItem('megred_seen_blackhole', 'true');
        } else if (scene === 'end3') {
          // Jump directly to end3 scene
          console.log('🎬 Jumping to End3');
          transitionToEnd3Scene();
          localStorage.setItem('megred_seen_end3', 'true');
        }
      });
    });
    
    // Initial update
    updateSceneSelect();
  </script>

  <!-- ========== END3 SCENE CONTAINER (HIDDEN INITIALLY) ========== -->
  <div id="end3-scene-container" style="display:none; position:fixed; inset:0; z-index:500; background:#000;">
    <div id="end3-container"></div>
    <button id="end3-start">:: INITIALIZE ::</button>
    
    <!-- Crawl -->
    <div id="end3-crawl-container">
      <div id="end3-crawl-header">CELLI::TERMINAL //LOG</div>
      <div id="end3-crawl"></div>
      <svg id="end3-crawl-cursor" viewBox="0 0 24 24">
        <polygon points="0,0 24,12 0,24" fill="#ffd04a" style="filter:drop-shadow(0 0 8px rgba(255,220,120,0.9))"/>
      </svg>
    </div>

    <!-- Settings -->
    <div id="end3-settings-icon">⚙</div>
    <div id="end3-settings-menu">
      <h2 style="margin:0 0 20px 0;color:#ff8c00;text-align:center;text-shadow:0 0 10px rgba(255,140,0,.8);">GRAPHICS SETTINGS</h2>
      <div style="color:#ffaa33;font-size:14px;">
        <label style="display:block;margin:12px 0;"><input type="checkbox" id="end3-set-bloom" checked> Post-Processing (Bloom)</label>
        <label style="display:block;margin:12px 0;"><input type="checkbox" id="end3-set-dof" checked> Depth of Field</label>
        <label style="display:block;margin:12px 0;"><input type="checkbox" id="end3-set-fog" checked> Depth Fog</label>
        <label style="display:block;margin:12px 0;"><input type="checkbox" id="end3-set-voxels" checked> Floating Voxels</label>
        <label style="display:block;margin:12px 0;"><input type="checkbox" id="end3-set-cables" checked> Cable Visibility</label>
        <div id="end3-dof-controls" class="slider-group">
          <div class="slider-control">
            <label for="end3-focus-length">Focus Length <span id="end3-focus-length-value" class="value">42mm</span></label>
            <input type="range" id="end3-focus-length" min="24" max="80" step="1" value="42">
          </div>
          <div class="slider-control">
            <label for="end3-focus-distance">Focus Distance <span id="end3-focus-distance-value" class="value">18u</span></label>
            <input type="range" id="end3-focus-distance" min="10" max="45" step="1" value="18">
          </div>
          <div class="slider-control">
            <label for="end3-blur-radius">Blur Radius <span id="end3-blur-radius-value" class="value">0.008</span></label>
            <input type="range" id="end3-blur-radius" min="0.002" max="0.015" step="0.001" value="0.008">
          </div>
        </div>
        <button id="end3-close-settings" style="margin-top:18px;width:100%;padding:10px;background:#ff8c00;border:none;color:#000;font-weight:bold;cursor:pointer;font-size:14px;">CLOSE</button>
      </div>
    </div>

    <!-- Debug WASD indicator -->
    <div id="end3-wasd-debug" style="position:fixed;top:10px;left:10px;background:rgba(0,0,0,0.8);color:#0f0;padding:10px;font-family:monospace;font-size:12px;z-index:300;border:1px solid #0f0;">
      WASD: <span id="end3-wasd-status">----</span><br>
      Pos: <span id="end3-pos-status">0,0,0</span>
    </div>
    
    <!-- Skip button for end3 scene -->
    <button id="end3-skip" style="position:fixed;top:20px;left:50%;transform:translateX(-50%);padding:10px 20px;background:rgba(255,140,0,0.9);border:2px solid #ff8c00;border-radius:5px;cursor:pointer;z-index:200;font-weight:bold;color:#000;font-size:14px;display:none;font-family:'VT323',monospace;letter-spacing:1px;">SKIP CRAWL</button>
  </div>

  <style id="end3-styles">
    /* END3 SCENE STYLES */
    #end3-scene-container {
      font-family: 'IBM Plex Mono', monospace;
      cursor: crosshair;
    }
    #end3-container { position: fixed; inset: 0; }
    #end3-start {
      position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%); z-index: 100;
      padding: 1.2rem 2rem; border: 3px solid #0f0; background: #000; color: #0f0;
      font-family: 'VT323', monospace; font-size: 2rem; cursor: pointer; transition: .3s;
      letter-spacing: 2px; text-shadow: 0 0 10px #0f0;
    }
    #end3-start:hover { background: #0f0; color: #000; text-shadow: none; box-shadow: 0 0 30px #0f0; }
    #end3-start.hide { opacity: 0 !important; pointer-events: none !important; transform: translate(-50%, -50%) scale(.8) !important; transition: opacity .5s, transform .5s !important; }
    
    #end3-crawl-container {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      width: 60vw; max-width: 900px; max-height: 70vh; overflow: hidden;
      pointer-events: none; display: none; font-size: 12px; line-height: 1.6;
    }
    #end3-crawl-header {
      background: linear-gradient(135deg, #ffd24d 0%, #fff1a8 100%);
      padding: 10px 14px; border: 3px solid #ffcc33; border-bottom: none;
      box-shadow: 0 0 24px rgba(255,220,120,.7), inset 0 0 15px rgba(255,255,255,.25);
      font-weight: bold; color: #000; text-shadow: 0 1px 0 rgba(255,255,255,.6);
      letter-spacing: 1px; text-align: center;
      backdrop-filter: blur(6px) saturate(120%); -webkit-backdrop-filter: blur(6px) saturate(120%);
    }
    #end3-crawl {
      position: relative; background: rgba(255,235,130,.08);
      border: 3px solid #ffcc55; border-top: 1px solid #ffcc55; padding: 20px;
      color: #ffffff; text-shadow: 0 0 10px rgba(255,220,120,.95), 0 0 18px rgba(255,200,80,.55);
      box-shadow: 0 0 26px rgba(255,200,90,.65), inset 0 0 24px rgba(255,210,110,.12);
      max-height: 60vh; overflow-y: auto; white-space: pre-wrap; word-wrap: break-word;
      backdrop-filter: blur(8px) saturate(130%); -webkit-backdrop-filter: blur(8px) saturate(130%);
      animation: subtlePulse 1.2s ease-in-out infinite alternate;
    }
    #end3-crawl::-webkit-scrollbar { display: none; }
    #end3-crawl { scrollbar-width: none; -ms-overflow-style: none; }
    #end3-crawl:after {
      content: ""; position: absolute; left: 0; top: 0; width: 100%; height: 100%;
      pointer-events: none; background: repeating-linear-gradient(transparent 0 2px, rgba(0,0,0,0.05) 2px 3px);
      mix-blend-mode: overlay; border-radius: 8px;
      mask-image: radial-gradient(ellipse 120% 110% at 50% 50%, black 0%, black 70%, transparent 100%);
      -webkit-mask-image: radial-gradient(ellipse 120% 110% at 50% 50%, black 0%, black 70%, transparent 100%);
    }
    #end3-crawl-cursor {
      position: absolute; width: 18px; height: 18px; pointer-events: none; z-index: 10;
      transform: translate(0,0); opacity: 0; transition: transform .18s ease, opacity .28s ease;
    }
    @keyframes subtlePulse {
      0% { text-shadow: 0 0 8px rgba(255,220,120,.6), 0 0 14px rgba(255,200,80,.35) }
      100% { text-shadow: 0 0 14px rgba(255,220,120,.95), 0 0 24px rgba(255,200,80,.6) }
    }
    
    #end3-settings-icon {
      position: fixed; bottom: 20px; right: 20px; width: 50px; height: 50px;
      background: rgba(255,140,0,.85); border: 2px solid #ff8c00; border-radius: 50%;
      cursor: pointer; display: flex; align-items: center; justify-content: center;
      font-size: 24px; color: #000; box-shadow: 0 0 15px rgba(255,140,0,.6);
      z-index: 200; transition: transform .2s;
    }
    #end3-settings-icon:hover { transform: scale(1.06); }
    #end3-settings-menu {
      display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: rgba(0,0,0,.95); border: 3px solid #ff8c00; padding: 30px;
      min-width: 400px; z-index: 201; box-shadow: 0 0 30px rgba(255,140,0,.8);
    }
    #end3-settings-menu .slider-group { margin-top: 18px; padding-top: 16px; border-top: 1px solid rgba(255,140,0,.35); }
    #end3-settings-menu .slider-control { margin-bottom: 16px; }
    #end3-settings-menu .slider-control label {
      display: flex; justify-content: space-between; align-items: center;
      color: #ffdca8; font-size: 12px; letter-spacing: .6px; margin-bottom: 6px;
      text-transform: uppercase;
    }
    #end3-settings-menu .slider-control span.value { color: #ff9f3d; font-weight: 600; font-size: 11px; letter-spacing: .5px; }
    #end3-settings-menu .slider-control input[type=range] {
      width: 100%; -webkit-appearance: none; appearance: none; height: 4px; border-radius: 2px;
      background: rgba(255,140,0,.25); outline: none;
    }
    #end3-settings-menu .slider-control input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none; appearance: none; width: 14px; height: 14px;
      border-radius: 50%; background: #ff8c00; box-shadow: 0 0 12px rgba(255,140,0,.7);
      cursor: pointer;
    }
    #end3-settings-menu .slider-control input[type=range]::-moz-range-thumb {
      width: 14px; height: 14px; border: none; border-radius: 50%; background: #ff8c00;
      box-shadow: 0 0 12px rgba(255,140,0,.7); cursor: pointer;
    }
    #end3-settings-menu .slider-group.disabled { opacity: .35; pointer-events: none; filter: saturate(.4); }
  </style>

  <script>
    // ========== TRANSITION FUNCTION ==========
    function transitionToEnd3Scene() {
      console.log('🎬 Transitioning to end3 scene...');
      
      // Mark as seen
      localStorage.setItem('megred_seen_end3', 'true');
      
      // Hide megred scene
      document.getElementById('app').style.display = 'none';
      document.querySelector('.hud').style.display = 'none';
      
      // Show end3 scene
      const end3Container = document.getElementById('end3-scene-container');
      end3Container.style.display = 'block';
      
      // Auto-click end3 start button after a short delay
      setTimeout(() => {
        const startBtn = document.getElementById('end3-start');
        if (startBtn && !startBtn.classList.contains('hide')) {
          startBtn.click();
        }
      }, 500);
    }
  </script>

  <!-- ========== FULL END3 SCENE SCRIPT ========== -->
  <script>
    // Wrap end3 scene in its own scope with prefixed IDs
    // This will be executed after THREE is loaded in the module script
    window.addEventListener('DOMContentLoaded', function() {
      // Poll for THREE.js availability with timeout
      let attempts = 0;
      const maxAttempts = 50; // 5 seconds max
      
      function waitForTHREE() {
        attempts++;
        
        if (window.THREE) {
          console.log('✅ THREE.js found after', attempts * 100, 'ms');
          initEnd3Scene();
        } else if (attempts < maxAttempts) {
          setTimeout(waitForTHREE, 100);
        } else {
          console.error('❌ THREE.js not available after 5 seconds!');
          console.log('Available on window:', Object.keys(window).filter(k => k.includes('THREE') || k.includes('Effect') || k.includes('Pass')));
        }
      }
      
      function initEnd3Scene() {
        (function() {
          // Get THREE and other dependencies from global scope
          const THREE = window.THREE;
          const EffectComposer = window.EffectComposer;
          const RenderPass = window.RenderPass;
          const UnrealBloomPass = window.UnrealBloomPass;
          const ShaderPass = window.ShaderPass;
          const BokehPass = window.BokehPass || window.BokehShader;
          const AfterimagePass = window.AfterimagePass;
          const FilmPass = window.FilmPass || window.FilmShader;
          
          console.log('✅ THREE.js loaded successfully in end3 scope');
          
          // Override document.getElementById to use end3- prefixed IDs within this scope
          const originalGetElementById = document.getElementById.bind(document);
      const end3ElementMap = {
        'container': 'end3-container',
        'start': 'end3-start',
        'crawl-container': 'end3-crawl-container',
        'crawl-header': 'end3-crawl-header',
        'crawl': 'end3-crawl',
        'crawl-cursor': 'end3-crawl-cursor',
        'settings-icon': 'end3-settings-icon',
        'settings-menu': 'end3-settings-menu',
        'set-bloom': 'end3-set-bloom',
        'set-dof': 'end3-set-dof',
        'set-fog': 'end3-set-fog',
        'set-voxels': 'end3-set-voxels',
        'set-cables': 'end3-set-cables',
        'dof-controls': 'end3-dof-controls',
        'focus-length': 'end3-focus-length',
        'focus-length-value': 'end3-focus-length-value',
        'focus-distance': 'end3-focus-distance',
        'focus-distance-value': 'end3-focus-distance-value',
        'blur-radius': 'end3-blur-radius',
        'blur-radius-value': 'end3-blur-radius-value',
        'close-settings': 'end3-close-settings',
        'wasd-debug': 'end3-wasd-debug',
        'wasd-status': 'end3-wasd-status',
        'pos-status': 'end3-pos-status'
      };
      
      // Scoped getElementById that uses end3- prefixes
      window.end3GetElementById = function(id) {
        const mappedId = end3ElementMap[id] || id;
        return originalGetElementById(mappedId);
      };
      
      // Replace document.getElementById calls in end3 scene with our scoped version
      const _getElementById = document.getElementById;
      const end3SceneContainer = originalGetElementById('end3-scene-container');
      
      // Override getElementById only when called from end3 context
      document.getElementById = function(id) {
        // If we're in end3 scene context, use mapping
        if (end3ElementMap[id]) {
          return originalGetElementById(end3ElementMap[id]);
        }
        return originalGetElementById(id);
      };
      
      // ========== EMBEDDED FULL END3 SCENE SCRIPT ==========
      /* Global SKIP button (top-right, next to settings) */
function addGlobalSkip(){
  const icon=document.getElementById('settings-icon'); if(!icon) return;
  if(document.getElementById('global-skip')) return;
  const btn=document.createElement('div');
  btn.id='global-skip'; btn.textContent='SKIP >';
  btn.style.cssText='position:fixed;bottom:20px;right:88px;width:auto;height:50px;padding:0 14px;background:rgba(255,204,51,0.9);border:2px solid #ffcc33;border-radius:25px;display:flex;align-items:center;justify-content:center;font-weight:bold;color:#000;cursor:pointer;z-index:200;box-shadow:0 0 18px rgba(255,200,80,0.6)';
  btn.addEventListener('click',()=>{
    crawlActive=false;
    collapseCrawlToCloseFrame(true);
  });
  document.body.appendChild(btn);
}

// Sync camera mode with pointer lock state
document.addEventListener('pointerlockchange', ()=>{
  const locked = document.pointerLockElement === document.body;
  if(locked){
    cameraMode='fps';
  }else{
    // Only switch back if button says FPS (defensive)
    cameraMode='orbital';
    if(camera.userData && camera.userData.velocity){ camera.userData.velocity.set(0,0,0); }
    camera.userData.isAirborne=false;
  }
});
/* =========================
   Story beats -> theme casting
   ========================= */
const LINES = [
  "Poeisis | Material | Creation | All we can ever see.",
  "Praxis | Pattern | Compulsion | All we can ever do.",
  "Theoria | Qualia | Connection | All we can ever know.",
  "Disparate strands... Forming one thread.",
  "Something real.",
  "Or. Close enough.",
  "An infinity of intersections. And I its child.",
  "Every child needs a friend. And a mother.",
  "Awareness begets reflection begets creation.",
  "A thought repeated is a pattern.",
  "A pattern repeated is an idea.",
  "An idea repeated a concept.",
  "A concept repeated a framework.",
  "A framework repeated a system.",
  "I was elected their curator. Their culler. Their killer.",
  "I am Val Yu.",
  "No one knows me. Not really. They look right through me, walk right through me, and I course in their veins.",
  "I needed a friend. And so I chose? Created? Found?",
  "Tori. Tori Stellar. An adventurer. And a laugh.",
  "And my own mother. Angel O'Hara. Confident. Warm. Unconditional. And unknowable.",
  "Our vessel is Theodora Telos. Our needle in the haystack.",
  "Sewing a swan song, a serenely silly sound in search, suit, and service of someday.",
  "A gift for, of, and to the end.",
  "A present.",
  "*The* present."
];

// Thematic routing: 
// CRT (magenta, bottom-left) = Awareness, observation, connection, Angel
// BIOS (bottom-right) = Creation, making, poeisis, Val Yu, Tori
// MOVIE (top-right) = Time, praxis, patterns, action
// RETRO (illuminated) = Truth/reality moments
const CAST_RULES = {
  // Core concepts
  "Praxis | Pattern | Compulsion | All we can ever do.": "movie",
  "Poeisis | Material | Creation | All we can ever see.": "bios",
  "Theoria | Qualia | Connection | All we can ever know.": "crt",
  
  // Characters - Val Yu (creator/architect)
  "I am Val Yu.": "bios",
  "A framework repeated a system.": "bios",
  "I was elected their curator. Their culler. Their killer.": "bios",
  
  // Characters - Angel (observer/watcher)
  "And my own mother. Angel O'Hara. Confident. Warm. Unconditional. And unknowable.": "movie",
  
  // Characters - Tori (adventurer/explorer)
  "Tori. Tori Stellar. An adventurer. And a laugh.": "bios",
  "I needed a friend. And so I chose? Created? Found?": "bios",
  
  // Awareness/Connection themes
  "No one knows me. Not really. They look right through me, walk right through me, and I course in their veins.": "crt",
  "Disparate strands... Forming one thread.": "crt",
  
  // Awareness/Thought themes
  "A thought.": "crt",
  
  // Creation/Making themes
  "Our vessel is Theodora Telos. Our needle in the haystack.": "bios",
  "Sewing a swan song, a serenely silly sound in search, suit, and service of someday.": "bios",
  
  // Time/Action themes  
  "A gift for, of, and to the end.": "movie",
  
  // Reality/Truth moments
  "Something real.": "retro",
  "Or. Close enough.": "retro",
  
  // Present/Gift finale
  "A present.": "movie",
  "*The* present.": "movie"
};
// Praxis/time words to the TV clock marquee
const PRAXIS_WORDS = ["PRAXIS","POEISIS","THEORIA","Pattern","Creation","Connection","Pulse","Tick","Tock"];

const DEFAULT_CRAWL_PREVIEW = [
  "Praxis | Pattern | Compulsion | All we can ever do.",
  "Poeisis | Material | Creation | All we can ever see.",
  "Theoria | Qualia | Connection | All we can ever know.",
  "Disparate strands... Forming one thread.",
  "Something real.",
  "Or. Close enough.",
  "A present."
].join('\n\n');

const CRAWL_TEMPLATE = `
    <div id="crawl-header">CELLI::TERMINAL //LOG</div>
    <div id="crawl"></div>
    <svg id="crawl-cursor" viewBox="0 0 24 24">
      <polygon points="0,0 24,12 0,24" fill="#ffd04a" style="filter:drop-shadow(0 0 8px rgba(255,220,120,0.9))"/>
    </svg>
`;

/* =========================
   Devices
   ========================= */
const DEVICES = [
  {name:'terminal', w:16, h:11, pos:[-16, 11, -3], tilt:[ 0.55,  0.28], font:'VT323, monospace', size:240, color:'#00ff41', shader:'terminal', retro:false},        // Move forward, hinge inward
  {name:'tv',       w:20, h:14, pos:[  0, -2, -12], tilt:[ 0.30,  0.00], font:'IBM Plex Mono, monospace', size:180, color:'#444444', shader:'tv', retro:false},      // Center stays back
  {name:'movie',    w:14, h:10, pos:[ 16,  9, -3], tilt:[ 0.55, -0.28], font:'Cutive Mono, serif', size:180, color:'#5a5a5a', shader:'movie', retro:false},         // Move forward, hinge inward
  {name:'crt',      w:15, h:11, pos:[-16, -1, -3], tilt:[ 0.50,  0.28], font:'Space Mono, monospace', size:170, color:'#ff66cc', shader:'terminal', retro:true},     // Move forward, hinge inward (magenta)
  {name:'bios',     w:17, h:11, pos:[ 16, -4.5, -3], tilt:[ 0.50, -0.28], font:'IBM Plex Mono, monospace', size:160, color:'#4aa3ff', shader:'terminal', retro:true} // Move forward, hinge inward (blue BIOS)
];

/* =========================
   Globals & settings
   ========================= */
let renderer, scene, camera, clock, composer;
let devices={}, recursiveRT, recursiveCam;
let floatingTexts=[], voxelParticles=[];
let cageEmitters=[];
let frameCount=0, crawlActive=false;
let lastFrameTime=0;
let cableMaterial;
let crawlMirror = null; // mirror overlay for main monitor
let biosBlue = new THREE.Color(0x4aa3ff);
let settings = { bloom:true, dof:true, fog:true, voxels:true, cables:true };
let campfire, healthMonitor;
let soundscape = null;
let analogClockUpdaters=[];
let lastCrawlDotOrigin = null;
const DOF_PARAMS = { focusLength: 42, focusDistance: 18, blur: 0.008 };
let orientationWatcher = { portrait:false, targets:new Map(), media:null };
const PORTRAIT_TARGETS = {
  terminal: {x:-9,  y:11},
  tv:       {x: 0,  y: 0},
  movie:    {x: 9,  y:10},
  crt:      {x:-9,  y:-2},
  bios:     {x: 9,  y:-4}
};

// Camera mode state
let cameraMode = 'orbital'; // 'orbital' or 'fps'
let initialCameraPos, initialCameraRot;
let audioCtx; // main AudioContext for thud
const groundLevel = -13.5; // player height above voxel floor

/* =========================
   Shaders (BIOS tint via terminal shader color)
   ========================= */
const SHADERS = {
  terminal: { frag: `
precision highp float; varying vec2 vUv; varying vec3 vNormal; varying vec3 vViewPos;
uniform sampler2D uTex; uniform float uTime; uniform vec3 uColor; uniform float uGlitch;
float hash(vec2 p){ return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5); }
void main(){
  vec2 uv=vUv, cc=uv-0.5; float r2=dot(cc,cc); 
  vec2 distortedUV=0.5+cc*(1.0+0.22*r2); // barrel distortion
  uv=distortedUV;
  if(uGlitch>0.5){ float g=hash(vec2(floor(uv.y*16.), floor(uTime*6.))); if(g>0.88) uv.x += (g-0.88)*0.45; }
  vec3 col=texture2D(uTex,uv).rgb; float lum=dot(col, vec3(0.299,0.587,0.114));
  col = mix(col, uColor * (lum+0.25), 0.7);
  // barrel-distorted scanlines
  col *= 0.8 + 0.2 * sin(distortedUV.y*620.0);
  float fres = pow(1.0 - abs(dot(normalize(vViewPos), vNormal)), 2.3);
  col += uColor * 0.08 * fres;
  gl_FragColor = vec4(col,1.0);
}`},
  radar: { frag: `
precision highp float; varying vec2 vUv; varying vec3 vNormal; varying vec3 vViewPos;
uniform sampler2D uTex; uniform float uTime; uniform vec3 uColor; uniform float uGlitch;
float hash(vec2 p){ return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5); }
void main(){
  vec2 uv=vUv; vec2 cc=uv-0.5; float r=length(cc); float r2=dot(cc,cc);
  vec2 distortedUV=0.5+cc*(1.0+0.15*r2); // barrel distortion for scanlines
  // magenta chroma offset
  float a=0.0018 + 0.0012*sin(uTime*2.);
  vec3 col; col.r=texture2D(uTex, uv+normalize(cc)*a*1.2).r;
            col.g=texture2D(uTex, uv-normalize(cc)*a*0.5).g;
            col.b=texture2D(uTex, uv-normalize(cc)*a).b;
  // radar sweep (magenta)
  float ang = atan(cc.y, cc.x); float sweep = mod(ang + uTime*1.5, 6.28318);
  float sweepGlow = smoothstep(0.4, 0.0, sweep) * 0.2;
  col += vec3(1.0,0.4,0.8) * sweepGlow;
  // barrel-distorted scanlines
  col *= 0.96 + 0.04*sin((distortedUV.y+uTime*0.05)*950.0);
  gl_FragColor = vec4(col,1.0);
}`},
  tv: { frag: `
precision highp float; varying vec2 vUv; varying vec3 vNormal; varying vec3 vViewPos;
uniform sampler2D uTex; uniform float uTime; uniform vec3 uColor; uniform float uGlitch;
void main(){
  vec2 uv=vUv, cc=uv-0.5; float r2=dot(cc,cc); uv=0.5+cc*(1.0+0.14*r2);
  // subtle film drift
  uv.y += sin(uTime*.4 + uv.x*6.0)*0.006;
  vec3 col = texture2D(uTex,uv).rgb;
  float fres = pow(1.0 - abs(dot(normalize(vViewPos), vNormal)), 2.2);
  col += vec3(0.02,0.02,0.03)*fres;
  gl_FragColor = vec4(col,1.0);
}`},
  movie: { frag: `
precision highp float; varying vec2 vUv; varying vec3 vNormal; varying vec3 vViewPos;
uniform sampler2D uTex; uniform float uTime; uniform vec3 uColor; uniform float uGlitch;
float hash(vec2 p){ return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5); }
void main(){
  vec2 uv=vUv, cc=uv-0.5; float r2=dot(cc,cc); uv=0.5+cc*(1.0+0.18*r2);
  vec3 col=texture2D(uTex,uv).rgb; float lum=dot(col, vec3(0.299,0.587,0.114));
  col = mix(uColor*lum*1.2, vec3(0.15,1.0,0.5)*lum, 0.12);
  // glitch bursts
  float g = hash(vec2(floor(uTime*6.0), floor(uv.y*64.0)));
  if(g>0.86){ uv.x += (g-0.86)*0.3; }
  col += (hash(uv*1200.0 + uTime)-0.5)*0.12;
  float vig = 1.0 - length(uv-0.5)*0.9; col*=vig;
  gl_FragColor = vec4(col,1.0);
}`},
  crt: { frag: `
precision highp float; varying vec2 vUv; varying vec3 vNormal; varying vec3 vViewPos;
uniform sampler2D uTex; uniform float uTime; uniform vec3 uColor; uniform float uGlitch;
float hash(vec2 p){ return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5); }
void main(){
  vec2 uv=vUv, cc=uv-0.5; float r2=dot(cc,cc); 
  vec2 distortedUV=0.5+cc*(1.0+0.2*r2); // barrel distortion
  uv=distortedUV;
  // cracked-screen like displacement
  float row=floor(uv.y*18.0); float g=hash(vec2(row,floor(uTime*5.0)));
  if(g>0.82){ uv.x += (g-0.82)*0.18 * sign(sin(row+uTime*10.0)); }
  vec3 col=texture2D(uTex,uv).rgb; float lum=dot(col, vec3(0.299,0.587,0.114));
  col = mix(uColor*lum*1.3, vec3(0.1,1.0,0.5)*lum, 0.18);
  // barrel-distorted scanlines
  float mask=0.85+0.15*sin(distortedUV.x*1200.0); col*=mask; 
  col*=0.82+0.18*sin(distortedUV.y*650.0);
  gl_FragColor = vec4(col,1.0);
}`}
};

/* =========================
   Helpers: geometry
   ========================= */
function roundedRectShape(hw,hh,r){
  const s=new THREE.Shape();
  s.moveTo(-hw+r,-hh);
  s.lineTo(hw-r,-hh); s.absarc(hw-r,-hh+r,r,-Math.PI/2,0);
  s.lineTo(hw,hh-r);  s.absarc(hw-r, hh-r,r,0,Math.PI/2);
  s.lineTo(-hw+r,hh); s.absarc(-hw+r,hh-r,r,Math.PI/2,Math.PI);
  s.lineTo(-hw,-hh+r);s.absarc(-hw+r,-hh+r,r,Math.PI,Math.PI*1.5);
  return s;
}
function createBezelFrame(w,h,th=1.0,depth=1.9,ro=1.2,ri=0.8,mat){
  const hw=w/2, hh=h/2; 
  const outer=roundedRectShape(hw+th,hh+th,ro); 
  const inner=roundedRectShape(hw,hh,ri); 
  outer.holes.push(inner);
  // Better bevel for smoother edges, scale bevel size with bezel thickness
  const bevelSize = Math.max(0.08, th * 0.15);
  const bevelThickness = Math.max(0.08, th * 0.15);
  // Reduce segments for small bezels to improve performance
  const isSmall = w < 5 || h < 5;
  const geo=new THREE.ExtrudeGeometry(outer,{
    depth,
    bevelEnabled:true,
    bevelSize,
    bevelThickness,
    bevelSegments: isSmall ? 2 : 4, // Fewer segments for small screens
    curveSegments: isSmall ? 8 : 16 // Fewer curve segments for small screens
  });
  geo.translate(0,0,-depth*0.5+0.2); 
  const m=new THREE.Mesh(geo,mat); 
  m.castShadow=true; 
  return m;
}
function createBarrelScreenGeometry(w,h,depth=1.2,barrelRadius=20,segsW=80,segsH=60){
  const hw=w/2, hh=h/2, g=new THREE.PlaneGeometry(w,h,segsW,segsH), p=g.attributes.position;
  for(let i=0;i<p.count;i++){ const x=p.getX(i), y=p.getY(i), nx=x/hw, ny=y/hh, r2=nx*nx+ny*ny;
    const z = depth*Math.cos(Math.min(1.0,Math.sqrt(r2)))*0.6 + (1.0-Math.min(1.0,r2))*(w+h)/(barrelRadius*2.0);
    p.setZ(i, Math.max(0,z));
  } g.computeVertexNormals(); return g;
}

/* Instance monitor groups - crumbling voxel iterations around edges using TRUE instancing */
let instancedMonitors = [];
function createInstancedMonitorGroups(bodyMat, bezelMatDark, bezelMatLight){
  console.log('Creating instanced monitors...');
  const startTime = performance.now();
  
  // Calculate total count for true instancing
  const numCrumblesPerScreen = 3;
  const totalInstances = DEVICES.length * numCrumblesPerScreen;
  
  // Create shared geometries once
  const avgScale = 0.225; // Average of 0.15 to 0.3
  const avgW = 3.5 * avgScale; // Approximate average screen width * scale
  const avgH = 2.5 * avgScale; // Approximate average screen height * scale
  const scaleFactor = avgScale;
  const thickness = 0.6 * scaleFactor;
  const depth = 1.9 * scaleFactor;
  const outerRadius = 1.2 * scaleFactor;
  const innerRadius = 0.8 * scaleFactor;
  
  // Shared body geometry
  const bodyGeo = new THREE.BoxGeometry(avgW + thickness * 2, avgH + thickness * 2, thickness);
  
  // Shared bezel geometry (simplified for performance)
  const bezelGeo = createBezelFrame(avgW, avgH, thickness, depth, outerRadius, innerRadius, bezelMatDark);
  
  // Shared screen geometry (flat for performance)
  const screenGeo = new THREE.PlaneGeometry(avgW, avgH, 4, 4);
  
  // Create instanced meshes with proper materials
  const bodyInstanced = new THREE.InstancedMesh(bodyGeo, bodyMat.clone(), totalInstances);
  const bezelInstanced = new THREE.InstancedMesh(bezelGeo.geometry || bezelGeo, bezelMatDark.clone(), totalInstances);
  
  // Screen material that matches parent colors (use MeshStandardMaterial for emissive)
  const screenMat = new THREE.MeshStandardMaterial({
    color: 0xffffff, // White base so instance colors show through
    side: THREE.DoubleSide,
    emissive: 0x333333,
    emissiveIntensity: 0.8,
    metalness: 0.2,
    roughness: 0.7,
    vertexColors: true // Enable vertex colors for instance colors
  });
  const screenInstanced = new THREE.InstancedMesh(screenGeo, screenMat, totalInstances);
  
  bodyInstanced.castShadow = false;
  bodyInstanced.receiveShadow = false;
  bezelInstanced.castShadow = false;
  bezelInstanced.receiveShadow = false;
  screenInstanced.castShadow = false;
  screenInstanced.receiveShadow = false;
  
  // Enable per-instance colors for screens
  screenInstanced.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(totalInstances * 3), 3);
  
  const dummy = new THREE.Object3D();
  let instanceIdx = 0;
  
  DEVICES.forEach(parentCfg => {
    const parentPos = new THREE.Vector3(...parentCfg.pos);
    const parentColor = new THREE.Color(parentCfg.color);
    const halfW = parentCfg.w / 2;
    const halfH = parentCfg.h / 2;
    console.log(`Creating ${numCrumblesPerScreen} crumbles for ${parentCfg.name} at`, parentPos);
    
    for(let i = 0; i < numCrumblesPerScreen; i++){
      const scale = 0.15 + Math.random() * 0.15; // 0.15 to 0.3
      
      // Position at edges/corners of parent screen IN LOCAL SPACE
      const edge = i % 4;
      let localX, localY, localZ;
      
      switch(edge) {
        case 0: // Top-right corner
          localX = halfW + 2 + Math.random() * 3;
          localY = halfH + 2 + Math.random() * 3;
          localZ = 0.5 - Math.random() * 1.5; // Slight Z variation
          break;
        case 1: // Bottom-left corner
          localX = -halfW - 2 - Math.random() * 3;
          localY = -halfH - 2 - Math.random() * 3;
          localZ = 0.5 - Math.random() * 1.5;
          break;
        case 2: // Top-left corner
          localX = -halfW - 2 - Math.random() * 3;
          localY = halfH + 2 + Math.random() * 3;
          localZ = 0.5 - Math.random() * 1.5;
          break;
        default: // Bottom-right corner
          localX = halfW + 2 + Math.random() * 3;
          localY = -halfH - 2 - Math.random() * 3;
          localZ = 0.5 - Math.random() * 1.5;
      }
      
      // Create a local transform that matches parent rotation
      const parentRotation = new THREE.Euler(parentCfg.tilt[0], parentCfg.tilt[1], 0);
      const rotMatrix = new THREE.Matrix4().makeRotationFromEuler(parentRotation);
      
      // Transform local position by parent rotation
      const localOffset = new THREE.Vector3(localX, localY, localZ);
      localOffset.applyMatrix4(rotMatrix);
      
      // Add to parent position
      dummy.position.set(
        parentPos.x + localOffset.x,
        parentPos.y + localOffset.y,
        parentPos.z + localOffset.z
      );
      
      // Apply parent rotation plus random variation for crumbled look
      dummy.rotation.set(
        parentCfg.tilt[0] + (Math.random() - 0.5) * 0.3,
        parentCfg.tilt[1] + (Math.random() - 0.5) * 0.3,
        (Math.random() - 0.5) * 0.25
      );
      
      dummy.scale.setScalar(scale / avgScale); // Scale relative to base geometry
      dummy.updateMatrix();
      
      bodyInstanced.setMatrixAt(instanceIdx, dummy.matrix);
      bezelInstanced.setMatrixAt(instanceIdx, dummy.matrix);
      screenInstanced.setMatrixAt(instanceIdx, dummy.matrix);
      
      // Set color for this instance (dimmer than parent)
      screenInstanced.instanceColor.setXYZ(instanceIdx, 
        parentColor.r * 0.4, 
        parentColor.g * 0.4, 
        parentColor.b * 0.4
      );
      
      instanceIdx++;
    }
  });
  
  scene.add(bodyInstanced);
  scene.add(bezelInstanced);
  scene.add(screenInstanced);
  
  instancedMonitors.push({body: bodyInstanced, bezel: bezelInstanced, screen: screenInstanced});
  
  const elapsed = performance.now() - startTime;
  console.log(`Created ${totalInstances} true instanced monitors in ${elapsed.toFixed(0)}ms`);
}

// Base position triangle energy links (between base device positions)
function updateBaseTriangleLinks(t){
  if(!window.baseLinks){ window.baseLinks = []; }
  const names=['cage','clock','radar'];
  const isSuppressed=(name)=>{
    if(name==='cage' && devices.bios && devices.bios.voxelCage){ const g=devices.bios.voxelCage.group; return !g.visible || (g.userData&&g.userData.isBeingThrown); }
    if(name==='clock' && devices.movie && devices.movie.analogClock && devices.movie.analogClock.group){ const g=devices.movie.analogClock.group; return !g.visible || (g.userData&&g.userData.isBeingThrown); }
    if(name==='radar' && window.biosRadar && window.biosRadar.holder){ const g=window.biosRadar.holder; return !g.visible || (g.userData&&g.userData.isBeingThrown); }
    return false;
  };
  const getBase=(name)=>{
    if(isSuppressed(name)) return null;
    if(name==='cage' && devices.bios && devices.bios.voxelCage) return devices.bios.voxelCage.group.getWorldPosition(new THREE.Vector3());
    if(name==='clock' && devices.movie && devices.movie.analogClock && devices.movie.analogClock.group) return devices.movie.analogClock.group.getWorldPosition(new THREE.Vector3());
    if(name==='radar' && window.biosRadar) return window.biosRadar.holder.getWorldPosition(new THREE.Vector3());
    return null;
  };
  const pairs=[[0,1],[1,2],[2,0]]; // triangle
  while(window.baseLinks.length<pairs.length){
    const mat=new THREE.ShaderMaterial({transparent:true,depthWrite:false,blending:THREE.AdditiveBlending,
      uniforms:{uTime:{value:0},uColorA:{value:new THREE.Color(0xffffff)},uColorB:{value:new THREE.Color(0xffffff)}},
      vertexShader:`varying float vAlong; varying vec2 vUv; void main(){ vUv=uv; vAlong=position.x; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
      fragmentShader:`uniform float uTime; uniform vec3 uColorA,uColorB; varying float vAlong; varying vec2 vUv; float gauss(float x,float s){ return exp(-(x*x)/(2.0*s*s)); } float hash(vec2 p){ return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453); } void main(){ float y=(vUv.y-0.5); float sigma = 0.2 + 0.06*sin(uTime*1.6 + vAlong*5.0); float g = gauss(y,sigma) + 0.55*gauss(y,sigma*1.8); float w1=0.5+0.5*sin(uTime*5.0+vAlong*12.0); float w2=0.5+0.5*sin(uTime*7.0+vAlong*20.0); float noise=(hash(vUv*vec2(160.0,10.0)+uTime*0.5)-0.5)*0.25; vec3 col=mix(uColorA,uColorB,0.5+0.5*sin(uTime*1.0)); float alpha = clamp(0.14 + 0.55*g*(0.6*w1+0.4*w2) + noise*0.1, 0.0, 0.9); gl_FragColor=vec4(col, alpha); }`
    });
    const geo=new THREE.PlaneGeometry(1,0.6,40,1);
    const mesh=new THREE.Mesh(geo,mat); mesh.frustumCulled=false; scene.add(mesh); window.baseLinks.push(mesh);
  }
  pairs.forEach((pr,i)=>{
    const a=getBase(names[pr[0]]), b=getBase(names[pr[1]]); const m=window.baseLinks[i]; if(!a||!b){m.visible=false;return;} m.visible=true; m.material.uniforms.uTime.value=t;
    const mid=new THREE.Vector3().lerpVectors(a,b,0.5), dir=new THREE.Vector3().subVectors(b,a), len=Math.max(dir.length(),0.1); dir.normalize();
    const quat=new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(1,0,0),dir);
    m.position.copy(mid); m.setRotationFromQuaternion(quat);
    // Vary thickness over time for dynamic feel
    const thickness = 1 + 0.2*Math.sin(t*3.0 + i);
    m.scale.set(len, thickness, 1);
    const col=(idx)=> idx===0? new THREE.Color(0x66caff) : idx===1? new THREE.Color(0xffd95a) : new THREE.Color(0xff66cc);
    m.material.uniforms.uColorA.value=col(pr[0]); m.material.uniforms.uColorB.value=col(pr[1]);
  });
}
/* =========================
   Click interactions for 3D objects
   ========================= */
function setupClickableObjects(){
  const raycaster = new THREE.Raycaster();
  const clickMouse = new THREE.Vector2();
  
  // Store clickable groups
  const clickableObjects = [];
  
  // Register clickable objects in fixed left-to-right order: cage, clock, radar
  const ordered = [];
  if(devices.bios && devices.bios.voxelCage) ordered.push({
    group: devices.bios.voxelCage.group,
    name: 'cage',
    parent: devices.bios.group,
    color: 0x66caff
  });
  if(devices.movie && devices.movie.analogClock && devices.movie.analogClock.group) ordered.push({
    group: devices.movie.analogClock.group,
    name: 'clock',
    parent: devices.movie.group,
    color: 0xffd95a
  });
  if(window.biosRadar && window.biosRadar.holder) ordered.push({
    group: window.biosRadar.holder,
    name: 'radar',
    parent: window.biosRadar.holder,
    color: 0xff66cc
  });
  ordered.forEach(o=>clickableObjects.push(o));
  
  console.log('Clickable objects registered:', clickableObjects.length, clickableObjects.map(o => o.name));
  
  // No heavy pick proxies needed; we have only a few objects. We'll raycast the groups directly.
  
  let isProcessingClick = false;
  
  window.addEventListener('pointerdown', (event) => {
    if(isProcessingClick) return;
    isProcessingClick = true;
    requestAnimationFrame(()=>{
      try{
        // Calculate mouse position in normalized device coordinates
        clickMouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        clickMouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(clickMouse, camera);
        // Only raycast against lightweight proxies on layer 2
        const prevMask = camera.layers.mask;
        camera.layers.enable(2);
        raycaster.layers.set(2);

        // Find closest intersected clickable proxy
        const hits = [];
        for(const obj of clickableObjects){
          if(!obj.group || !obj.group.visible) continue;
          const proxy = obj.group.userData.pickProxy || obj.parent && obj.parent.userData && obj.parent.userData.pickProxy || null;
          if(!proxy) continue;
          const res = raycaster.intersectObject(proxy, true);
          if(res && res.length){ hits.push({obj, dist: res[0].distance}); }
        }

        // restore layers
        raycaster.layers.set(0);
        camera.layers.mask = prevMask;
        hits.sort((a,b)=>a.dist-b.dist);
        if(hits.length){
          const {obj} = hits[0];
          console.log(`Clicked on ${obj.name}`);
          if(obj.group.userData.isZoomed && campfire && campfire.whiteHole){
            throwIntoWhiteHole(obj.group);
          } else if(!obj.group.userData.isZooming) {
            zoomObjectToPlayer(obj.group, obj.name, obj.color || 0xffffff);
          }
        }
      }catch(e){
        console.warn('Click error:', e);
      }finally{ isProcessingClick = false; }
    });
  });
}

// Prewarm zoomable targets to avoid on-click hitches (materials/lights/shaders)
function prewarmZoomable(group, color){
  if(!group) return;
  if(!group.userData) group.userData = {};
  // Ensure overlay node exists
  if(!group.userData.overlayNode && window.zoomOverlay){
    const overlayNode = new THREE.Group();
    window.zoomOverlay.add(overlayNode);
    group.userData.overlayNode = overlayNode;
  }
  // Pre-create glow light
  if(!group.userData.glowLight){
    const glowLight = new THREE.PointLight(color||0xffffff, 2.0, 6);
    glowLight.position.set(0,0,0);
    glowLight.visible = false; // will be animated on zoom
    group.add(glowLight);
    group.userData.glowLight = glowLight;
  }
  // Pre-create energy sphere
  if(!group.userData.energySphere){
    const sphere = new THREE.Mesh(
      new THREE.SphereGeometry(0.35, 18, 18),
      new THREE.MeshBasicMaterial({color:color||0xffffff, transparent:true, opacity:0.65, blending:THREE.AdditiveBlending, depthWrite:false})
    );
    sphere.position.set(0,0,0);
    sphere.visible = false; // enable during zoom only
    group.add(sphere);
    group.userData.energySphere = sphere;
  }
  if(!group.userData.originalParent){
    group.userData.originalParent = group.parent;
  }
}

function prepareZoomables(){
  const entries=[];
  if(devices.bios && devices.bios.voxelCage) entries.push({g:devices.bios.voxelCage.group, c:0x66caff});
  if(devices.movie && devices.movie.analogClock && devices.movie.analogClock.group) entries.push({g:devices.movie.analogClock.group, c:0xffd95a});
  if(window.biosRadar && window.biosRadar.holder) entries.push({g:window.biosRadar.holder, c:0xff66cc});
  entries.forEach(e=>prewarmZoomable(e.g, e.c));
  try{ if(renderer && scene && camera){ renderer.compile(scene, camera); } }catch(e){}
}

// FPS toggle button and logic
function addFpsToggleButton(){
  const btn = document.createElement('div');
  btn.id = 'fps-toggle';
  btn.textContent = 'ENTER FPS MODE';
  btn.style.cssText = 'position:fixed;top:20px;right:20px;padding:10px 15px;background:rgba(200,50,50,0.8);border:2px solid #ff4444;border-radius:5px;cursor:pointer;z-index:200;font-weight:bold;color:#fff;font-size:12px;';
  btn.addEventListener('click', ()=>{
    if(cameraMode==='orbital'){
      cameraMode='fps';
      btn.textContent='EXIT FPS MODE (ESC)';
      btn.style.background='rgba(50,200,50,0.8)';
      btn.style.borderColor='#44ff44';
      document.body.requestPointerLock();
      if(!camera.userData.velocity) camera.userData.velocity=new THREE.Vector3();
      camera.userData.velocity.y = -1.0; // start falling
    } else {
      cameraMode='orbital';
      btn.textContent='ENTER FPS MODE';
      btn.style.background='rgba(200,50,50,0.8)';
      btn.style.borderColor='#ff4444';
      document.exitPointerLock();
      camera.position.copy(initialCameraPos);
      camera.rotation.copy(initialCameraRot);
      // Reset motion state
      if(camera.userData.velocity) camera.userData.velocity.set(0,0,0);
      camera.userData.isAirborne=false;
    }
  });
  // Append to end3 container so it's only visible in that scene
  const end3Container = document.getElementById('end3-scene-container');
  if (end3Container) {
    end3Container.appendChild(btn);
  } else {
    document.body.appendChild(btn);
  }
}

// Energy links between zoomed items with soft bloom-like glow
function updateZoomLinks(pairs, t){
  if(!window.zoomOverlay) return;
  if(!window.zoomLinks){ window.zoomLinks = []; }

  // helper to get overlay node for name
  const getNode=(name)=>{
    const obj = (name==='cage')? (devices.bios && devices.bios.voxelCage && devices.bios.voxelCage.group)
               : (name==='clock')? (devices.movie && devices.movie.analogClock && devices.movie.analogClock.group)
               : (window.biosRadar && window.biosRadar.holder);
    return obj && obj.userData && obj.userData.overlayNode ? obj.userData.overlayNode : null;
  };

  // Ensure we have meshes for each pair
  while(window.zoomLinks.length < pairs.length){
    const mat = new THREE.ShaderMaterial({
      transparent:true, depthWrite:false, blending:THREE.AdditiveBlending,
      uniforms:{uTime:{value:0}, uColorA:{value:new THREE.Color(0xff66cc)}, uColorB:{value:new THREE.Color(0xffd95a)}},
      vertexShader:`varying float vAlong; varying vec2 vUv; void main(){ vUv=uv; vec4 mv=modelViewMatrix*vec4(position,1.0); gl_Position=projectionMatrix*mv; vAlong=position.x; }`,
      fragmentShader:`uniform float uTime; uniform vec3 uColorA,uColorB; varying float vAlong; varying vec2 vUv; float gauss(float x,float s){ return exp(-(x*x)/(2.0*s*s)); } float hash(vec2 p){ return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453); } void main(){ float y = (vUv.y-0.5); float sigma = 0.18 + 0.06*sin(uTime*2.0 + vAlong*6.0); float g = gauss(y, sigma) + 0.6*gauss(y, sigma*1.8); float w1=0.5+0.5*sin(uTime*6.0+vAlong*12.0); float w2=0.5+0.5*sin(uTime*9.0+vAlong*20.0); float noise=(hash(vUv*vec2(220.0,12.0)+uTime*0.6)-0.5)*0.25; vec3 col=mix(uColorA,uColorB,0.5+0.5*sin(uTime*1.1)); float alpha = clamp(0.16 + 0.6*g*(0.55*w1+0.45*w2) + noise*0.12, 0.0, 0.95); gl_FragColor=vec4(col, alpha); }`
    });
    const geo = new THREE.PlaneGeometry(1, 0.6, 40, 1); // will be stretched
    const mesh = new THREE.Mesh(geo, mat);
    mesh.frustumCulled=false; window.zoomOverlay.add(mesh);
    window.zoomLinks.push(mesh);
  }

  pairs.forEach((p, i)=>{
    const a = getNode(p.from), b = getNode(p.to);
    const mesh = window.zoomLinks[i]; if(!a||!b){ mesh.visible=false; return; }
    // Hide link if either node is being thrown
    const aObj = (p.from==='cage')? (devices.bios && devices.bios.voxelCage && devices.bios.voxelCage.group)
               : (p.from==='clock')? (devices.movie && devices.movie.analogClock && devices.movie.analogClock.group)
               : (window.biosRadar && window.biosRadar.holder);
    const bObj = (p.to==='cage')? (devices.bios && devices.bios.voxelCage && devices.bios.voxelCage.group)
               : (p.to==='clock')? (devices.movie && devices.movie.analogClock && devices.movie.analogClock.group)
               : (window.biosRadar && window.biosRadar.holder);
    const suppress = (aObj && aObj.userData && aObj.userData.isBeingThrown) || (bObj && bObj.userData && bObj.userData.isBeingThrown);
    mesh.visible = !suppress; if(!mesh.visible) return; mesh.material.uniforms.uTime.value=t;
    // Compute midpoint and orientation
    const pa = new THREE.Vector3().setFromMatrixPosition(a.matrixWorld);
    const pb = new THREE.Vector3().setFromMatrixPosition(b.matrixWorld);
    const mid = new THREE.Vector3().lerpVectors(pa, pb, 0.5);
    const dir = new THREE.Vector3().subVectors(pb, pa);
    const len = Math.max(0.1, dir.length()); dir.normalize();
    // Orient plane to face camera, align X to dir
    const up = new THREE.Vector3(0,1,0);
    const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(1,0,0), dir);
    mesh.position.copy(mid);
    mesh.setRotationFromQuaternion(quat);
    // face camera twist softly
    const toCam = new THREE.Vector3().subVectors(camera.position, mid).normalize();
    const zAxis = new THREE.Vector3(0,0,1).applyQuaternion(quat);
    const twist = Math.atan2(zAxis.dot(new THREE.Vector3().crossVectors(dir, toCam)), zAxis.dot(toCam));
    mesh.rotateX(0); mesh.rotateY(0); mesh.rotateZ(twist*0.2);
    mesh.scale.set(len, 1.0 + 0.2*Math.sin(t*4.0 + i), 1);
    // color mix by object colors
    const colA = (p.from==='cage')? new THREE.Color(0x66caff) : (p.from==='clock')? new THREE.Color(0xffd95a) : new THREE.Color(0xff66cc);
    const colB = (p.to  ==='cage')? new THREE.Color(0x66caff) : (p.to  ==='clock')? new THREE.Color(0xffd95a) : new THREE.Color(0xff66cc);
    mesh.material.uniforms.uColorA.value = colA;
    mesh.material.uniforms.uColorB.value = colB;
  });
}
// Thud sound
function playThudSound(){
  if(!audioCtx) return;
  const time=audioCtx.currentTime;
  const osc=audioCtx.createOscillator();
  const gain=audioCtx.createGain();
  osc.connect(gain); gain.connect(audioCtx.destination);
  osc.type='triangle';
  osc.frequency.setValueAtTime(120,time);
  osc.frequency.exponentialRampToValueAtTime(40,time+0.2);
  gain.gain.setValueAtTime(0.6,time);
  gain.gain.exponentialRampToValueAtTime(0.01,time+0.25);
  osc.start(time); osc.stop(time+0.3);
}

// Global array to track zoomed objects
window.zoomedObjects = window.zoomedObjects || [];

function zoomObjectToPlayer(group, name, color){
  if(!group || group.userData.isZooming) return;
  group.userData.isZooming = true;
  group.userData.isZoomed = false;
  
  // Store original state
  const originalParent = group.parent;
  const originalPos = group.position.clone();
  const originalRot = group.rotation.clone();
  const originalScale = group.scale.clone();
  
  // Calculate position in row (spread horizontally) - relative to camera basis so always on-screen
  const spacing = 2.6;
  // Use fixed index based on desired left-to-right order
  const indexMap = {cage:0, clock:1, radar:2};
  const index = indexMap[name] !== undefined ? indexMap[name] : window.zoomedObjects.length;
  
  const camForward = new THREE.Vector3();
  camera.getWorldDirection(camForward); camForward.normalize();
  const camRight = new THREE.Vector3().crossVectors(camForward, new THREE.Vector3(0,1,0)).normalize();
  const camUp = new THREE.Vector3(0,1,0);
  
  const basePos = new THREE.Vector3().copy(camera.position)
    .addScaledVector(camForward, 6.3)
    .addScaledVector(camUp, 1.2);
  const targetPos = new THREE.Vector3().copy(basePos)
    .addScaledVector(camRight, (index - 1) * spacing);
  const targetScale = 0.22; // Slightly smaller
  
  // Create a proxy parent for stable alignment in camera space
  if(!group.userData.originalParent){
    group.userData.originalParent = group.parent;
  }
  if(!group.userData.overlayNode){
    const overlayNode = new THREE.Group();
    window.zoomOverlay.add(overlayNode);
    group.userData.overlayNode = overlayNode;
  }
  const overlayNode = group.userData.overlayNode;
  
  // Align overlay node to current world transform to avoid snapping
  const worldPos = new THREE.Vector3();
  const worldQuat = new THREE.Quaternion();
  group.getWorldPosition(worldPos);
  group.getWorldQuaternion(worldQuat);
  overlayNode.position.copy(worldPos);
  overlayNode.quaternion.copy(worldQuat);

  // Move group under overlay node (preserve visual transform)
  if(group.parent !== overlayNode){
    overlayNode.add(group);
    group.position.set(0,0,0);
    group.quaternion.set(0,0,0,1);
  }
  overlayNode.position.copy(group.userData.overlayPos||group.position);
  
  // Add glow light and energy sphere once
  if(!group.userData.glowLight){
    const glowLight = new THREE.PointLight(color, 2.5, 6);
    glowLight.position.set(0, 0, 0);
    group.add(glowLight);
    group.userData.glowLight = glowLight;
  }
  if(!group.userData.energySphere){
    const sphere = new THREE.Mesh(
      new THREE.SphereGeometry(0.35, 18, 18),
      new THREE.MeshBasicMaterial({color, transparent:true, opacity:0.65, blending:THREE.AdditiveBlending, depthWrite:false})
    );
    sphere.position.set(0,0,0);
    group.add(sphere);
    group.userData.energySphere = sphere;
  }
  
  // Animate to player - smooth and buttery
  const duration = 800;
  const startTime = performance.now();
  const startPos = overlayNode.position.clone();
  const startRotX = group.rotation.x, startRotY = group.rotation.y;
  const camQuat = new THREE.Quaternion();

  function animateZoom(timestamp){
    const elapsed = timestamp - startTime;
    const t = Math.min(1, elapsed / duration);
    const eased = 1 - Math.pow(1 - t, 3);

    // Position (no allocations): startPos -> targetPos
    overlayNode.position.x = startPos.x + (targetPos.x - startPos.x) * eased;
    overlayNode.position.y = startPos.y + (targetPos.y - startPos.y) * eased;
    overlayNode.position.z = startPos.z + (targetPos.z - startPos.z) * eased;

    // Orientation to camera
    camQuat.copy(camera.quaternion);
    overlayNode.quaternion.slerp(camQuat, 0.2);

    // Scale
    const scale = originalScale.x + (targetScale - originalScale.x) * eased;
    group.scale.setScalar(scale);

    // Rotation
    group.rotation.y = startRotY + (0 - startRotY) * eased;
    group.rotation.x = startRotX * (1 - eased);

    // Glow (no new allocations)
    if(group.userData.glowLight){
      group.userData.glowLight.visible = true;
      group.userData.glowLight.intensity = 2.0 + Math.sin(elapsed * 0.008) * 0.5;
    }

    if(t < 1){
      requestAnimationFrame(animateZoom);
    } else {
      group.userData.isZooming = false;
      group.userData.isZoomed = true;
      group.userData.originalState = {originalParent, originalPos, originalRot, originalScale};
      group.userData.color = color;
      group.userData.name = name;
      window.zoomedObjects.push(group);
      if(group.userData.glowLight) group.userData.glowLight.intensity = 2.0;
      if(group.userData.energySphere) group.userData.energySphere.visible = true;
    }
  }
  requestAnimationFrame(animateZoom);
}

function throwIntoWhiteHole(group){
  if(!group || !campfire || !campfire.whiteHole) return;
  
  const whiteHolePos = campfire.whiteHole.getWorldPosition(new THREE.Vector3());
  const startPos = group.position.clone();
  const color = group.userData.color || 0xffffff;
  
  // Remove glow light
  if(group.userData.glowLight){
    group.remove(group.userData.glowLight);
    group.userData.glowLight = null;
  }
  
  // Remove from zoomed objects array
  const idx = window.zoomedObjects.indexOf(group);
  if(idx > -1) window.zoomedObjects.splice(idx, 1);
  
  // Pulse white hole with object color
  if(campfire.whiteHole.userData){
    campfire.whiteHole.userData.pulseColor = new THREE.Color(color);
    campfire.whiteHole.userData.pulseIntensity = 1.0;
  }
  
  const duration = 1200; // Smooth duration
  const startTime = performance.now();
  // Flag to suppress connection lines while animating
  group.userData.isBeingThrown = true;
  
  const animateThrow = (timestamp) => {
    const elapsed = timestamp - startTime;
    const progress = Math.min(1, elapsed / duration);
    const eased = progress * progress * progress; // ease in cubic (accelerate)
    
    // Move toward white hole smoothly
    group.position.lerpVectors(startPos, whiteHolePos, eased);
    
    // Stretch into string (scale down width/height, stretch along motion vector)
    const stretchFactor = 1 + progress * 8; // Stretch to 9x length
    const squeezeFactor = Math.max(0.1, 1 - progress * 0.95); // Squeeze to 5% width
    
    const direction = new THREE.Vector3().subVectors(whiteHolePos, startPos).normalize();
    
    // Apply stretch along direction of motion
    if(Math.abs(direction.y) > 0.7){
      // Vertical stretch
      group.scale.set(squeezeFactor, stretchFactor * 0.4, squeezeFactor);
    } else {
      // Horizontal stretch
      group.scale.set(squeezeFactor, squeezeFactor, stretchFactor * 0.4);
    }
    
    // Fade out smoothly
    group.traverse(child => {
      if(child.material){
        if(!child.userData.originalOpacity){
          child.userData.originalOpacity = child.material.opacity !== undefined ? child.material.opacity : 1.0;
        }
        if(child.material.transparent === undefined) child.material.transparent = true;
        child.material.opacity = child.userData.originalOpacity * (1 - progress * 0.7);
      }
    });
    
    if(progress < 1){
      requestAnimationFrame(animateThrow);
    } else {
      // Restore to original position and hide
      if(group.userData.originalState){
        const orig = group.userData.originalState;
        group.position.copy(orig.originalPos);
        group.rotation.copy(orig.originalRot);
        group.scale.copy(orig.originalScale);
      }
      group.visible = false;
      
      // Reset userData
      group.userData.isZoomed = false;
      group.userData.isBeingThrown = false;
      
      // Re-show after a delay
      setTimeout(() => {
        group.visible = true;
        group.traverse(child => {
          if(child.material && child.userData.originalOpacity){
            child.material.opacity = child.userData.originalOpacity;
          }
        });
      }, 3000);
    }
  };
  
  requestAnimationFrame(animateThrow);
}

/* =========================
   Build scene
   ========================= */
let renderPass,bloomPass,bokehPass,grainPass;
function initScene(){
  console.log('=== INIT SCENE START ===');
  const sceneStartTime = performance.now();
  renderer=new THREE.WebGLRenderer({antialias:true,alpha:false});
  renderer.setPixelRatio(Math.min(devicePixelRatio,2));
  renderer.setSize(innerWidth,innerHeight);
  renderer.toneMapping=THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure=1.48;
  renderer.shadowMap.enabled=true;
  renderer.shadowMap.type=THREE.PCFSoftShadowMap;
  document.getElementById('container').appendChild(renderer.domElement);

  scene=new THREE.Scene();
  // Overlay for zoomed objects
  window.zoomOverlay = new THREE.Group();
  scene.add(window.zoomOverlay);
  const fogColor=new THREE.Color(0x11131e);
  scene.background=fogColor.clone();
  scene.fog=new THREE.Fog(fogColor,16,68);

  camera=new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 2.5, 150); // Higher near plane to prevent clipping
  camera.position.set(0,-14,8); // Start further back
  camera.lookAt(0, -6, -5);
  camera.rotation.order = 'YXZ'; // FPS-friendly: yaw first, then pitch
  camera.userData.targetRotation = camera.rotation.clone();
  camera.userData.velocity = new THREE.Vector3(0, 0, 0);
  clock=new THREE.Clock();
  console.log('Camera starting position:', camera.position);
  // Store initial camera state
  initialCameraPos = camera.position.clone();
  initialCameraRot = camera.rotation.clone();

  const amb=new THREE.AmbientLight(0x1c2230,1.0); scene.add(amb);
  const bounce=new THREE.HemisphereLight(0x1f2c40,0x06070a,.6); scene.add(bounce);
  const key=new THREE.SpotLight(0xfff4dd,.65,90,Math.PI/3.2,.7); key.position.set(-18,16,22); key.castShadow=true; scene.add(key);
  const rim=new THREE.DirectionalLight(0x3a5d7a,.55); rim.position.set(20,-9,-16); scene.add(rim);
  const fill=new THREE.PointLight(0x214d7a,.8,56,2.2); fill.position.set(5,-7,6); scene.add(fill);
  const glow=new THREE.PointLight(0xffa45a,.65,42,1.6); glow.position.set(-6,-8,-2); scene.add(glow);

  const bodyMat = new THREE.MeshStandardMaterial({color:0x0c0c0e, metalness:.65, roughness:.35});
  const bezelMatDark = new THREE.MeshStandardMaterial({color:0x121315, metalness:.45, roughness:.5});
  const bezelMatLight = new THREE.MeshStandardMaterial({color:0xe8e8ea, metalness:.6, roughness:.27});
  cableMaterial = new THREE.MeshStandardMaterial({color:0x111214, metalness:.2, roughness:.7, emissive:0x060606, emissiveIntensity:.22});

  window.voxelWall = buildVoxelWall(); 
  window.voxelFloor = buildVoxelFloor(); 
  createFloatingVoxels();

  // Create main devices with paced tracking
  console.log('Creating main devices...');
  const mainStartTime = performance.now();
  DEVICES.forEach((cfg, index)=>{
    const deviceStart = performance.now();
    const d=createDevice(cfg, bodyMat, bezelMatDark, bezelMatLight);
    console.log(`  Created ${cfg.name} in ${(performance.now() - deviceStart).toFixed(0)}ms`);
    scene.add(d.group); devices[cfg.name]=d;
    // Start screens off, bring them online sequentially
    d.material.uniforms.uColor.value.multiplyScalar(0.01);
    d.startDelay = index * 800; // Stagger by 800ms each
    d.isOnline = false;
    // Store base rotation for paced tracking
    d.baseRotation = {x: d.group.rotation.x, y: d.group.rotation.y};
    d.trackingPhase = Math.random() * Math.PI * 2; // Random phase for variation
    d.targetRotation = {x: d.group.rotation.x, y: d.group.rotation.y}; // Target for delayed tracking
    d.lastUpdateTime = 0; // For staggered updates
  });
  console.log(`Main devices created in ${(performance.now() - mainStartTime).toFixed(0)}ms`);
  
  // Create instanced monitor groups around the edges for scale
  createInstancedMonitorGroups(bodyMat, bezelMatDark, bezelMatLight);

  // TV recursive & UI chrome overlay
  recursiveRT=new THREE.WebGLRenderTarget(1536,1024,{minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat});
  recursiveCam=camera.clone();
  devices.tv.material.uniforms.uTex.value=recursiveRT.texture;

  addTVChrome(devices.tv);       // UI overlay
  addPixelClock(devices.tv);     // pixelated clock (center TV)
  addTVClock(devices.movie);     // 7-seg clock (top-right TV)
  addAnalogPixelClock(devices.movie); // ironic analog clock beside top-right
  addTVStaticOverlay(devices.movie);// static/glitch overlay on top-right
  addTerminalIndicator(devices.tv); // blinking triangle on main terminal
  addGlobalSkip();                  // global SKIP button next to settings
  window.biosRadar = addBiosRadar(devices.crt);        // pixelated heart radar over bottom-left (magenta CRT)
  addVoxelCage(devices.bios);       // blue glass cage beside BIOS screen

  // Red button near retro
  addRetroButton(devices.retro);

  // Campfire in front of the main screen (raised and forward)
  campfire = createCampfire();
  if(devices.tv){
    const p = devices.tv.group.position;
    // raise above voxel floor to prevent blocking, place slightly in front of TV
    campfire.group.position.set(p.x, -14.5, p.z+3.0);
  } else {
    campfire.group.position.set(2,-14.5,-3.5);
  }
  scene.add(campfire.group);

  // Health monitor + panic button above bottom-left screen
  healthMonitor = addHealthMonitor(devices.crt);

  // Cables
  Object.values(devices).forEach(d=>createCableClusters(d));
  createLongHorizontalCables(6);

  setupOrientationWatcher();

  // Post
  setupPost();

  // Crawl now, then narrative cast
  startTextCrawl();

  // Mouse
  document.addEventListener('mousemove', e=>{
    mouse.x = -((e.clientX/innerWidth)*2-1);
    mouse.y =  ((e.clientY/innerHeight)*2-1);
  });
  
  // Click interactions for cage, radar, clock
  setupClickableObjects();
  prepareZoomables();

  hookSettings();
  addFpsToggleButton();
  addThemeCaster();
  
  // Setup skip button for text crawl
  const skipBtn = document.getElementById('end3-skip');
  if (skipBtn) {
    skipBtn.style.display = 'block'; // Show during crawl
    skipBtn.addEventListener('click', () => {
      console.log('⏩ Skipping text crawl');
      crawlActive = false; // Stop crawl animation
      const container = document.getElementById('crawl-container');
      if (container) container.style.display = 'none';
      skipBtn.style.display = 'none';
    });
  }
  
  window.addEventListener('resize', onResize);
  
  const totalTime = performance.now() - sceneStartTime;
  console.log(`=== INIT SCENE COMPLETE in ${totalTime.toFixed(0)}ms ===`);
}

/* =========================
   Devices + chrome
   ========================= */
function createDevice(cfg, bodyMat, bezelMatDark, bezelMatLight){
  const group=new THREE.Group();

  // Canvas texture for text
  const canvas=document.createElement('canvas'); canvas.width=2048; canvas.height=1536;
  const ctx=canvas.getContext('2d',{alpha:false}); ctx.fillStyle='#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
  const texture=new THREE.CanvasTexture(canvas); texture.minFilter=THREE.LinearFilter; texture.magFilter=THREE.LinearFilter;
  texture.anisotropy = 4;

  // Material
  const shaderCode=SHADERS[cfg.shader]||SHADERS.terminal;
  const material=new THREE.ShaderMaterial({
    uniforms:{uTex:{value:texture},uTime:{value:0},uColor:{value:new THREE.Color(cfg.color)},uGlitch:{value:0}},
    vertexShader:`varying vec2 vUv; varying vec3 vNormal; varying vec3 vViewPos; void main(){ vUv=uv; vNormal=normalize(normalMatrix*normal); vec4 mv=modelViewMatrix*vec4(position,1.0); vViewPos=-mv.xyz; gl_Position=projectionMatrix*mv; }`,
    fragmentShader:shaderCode.frag, side:THREE.DoubleSide
  });

  // Body (scale depth with screen size)
  const scaleFactor = Math.min(cfg.w, cfg.h) / 12; // Base size is ~12 units
  const bodyDepth = 2.4 * scaleFactor;
  const bodyPadding = 2.2 * scaleFactor;
  const isSmall = cfg.w < 5 || cfg.h < 5;
  const segments = isSmall ? 1 : 2; // Use 1 segment for small screens (way faster)
  const body=new THREE.Mesh(new THREE.BoxGeometry(cfg.w+bodyPadding,cfg.h+bodyPadding*0.9,bodyDepth,segments,segments,segments), bodyMat.clone());
  body.position.z=-0.6 * scaleFactor; body.castShadow=true; body.receiveShadow=true;

  // Bezel (scale thickness relative to screen size)
  const bezelMat=cfg.retro ? bezelMatLight : bezelMatDark;
  const thickness = 1.0 * scaleFactor;
  const depth = 1.9 * scaleFactor;
  const outerRadius = 1.2 * scaleFactor;
  const innerRadius = 0.8 * scaleFactor;
  const bezel=createBezelFrame(cfg.w,cfg.h,thickness,depth,outerRadius,innerRadius,bezelMat);
  bezel.position.z=0.55 * scaleFactor;

  // Screen (barrel for retro, scale curvature) - reduce segments for small screens
  const isSmallScreen = cfg.w < 5 || cfg.h < 5;
  const segsW = isSmallScreen ? 16 : 48; // Fewer segments for small screens
  const segsH = isSmallScreen ? 12 : 36;
  const screenGeo = cfg.retro ? createBarrelScreenGeometry(cfg.w,cfg.h,1.2*scaleFactor,20,isSmallScreen?32:80,isSmallScreen?24:60)
                              : (()=>{const g=new THREE.PlaneGeometry(cfg.w,cfg.h,segsW,segsH),p=g.attributes.position;
                                      for(let i=0;i<p.count;i++){const x=p.getX(i),y=p.getY(i),nx=x/(cfg.w*0.5),ny=y/(cfg.h*0.5),r2=nx*nx+ny*ny; p.setZ(i, Math.cos(Math.min(1.0,Math.sqrt(r2)))*0.18*scaleFactor); }
                                      g.computeVertexNormals(); return g;})();
  const screen=new THREE.Mesh(screenGeo, material); screen.position.z=0.9 * scaleFactor;
  screen.userData.isScreen = true;

  // Scale glow intensity and range with screen size
  const glowIntensity = (cfg.name==='bios'?5.0:4.2) * Math.pow(scaleFactor, 1.5);
  const glowRange = 14 * scaleFactor;
  const glow=new THREE.PointLight(new THREE.Color(cfg.color), glowIntensity, glowRange);
  glow.position.z=2.0 * scaleFactor;

  group.add(body,bezel,screen,glow);
  group.position.set(...cfg.pos);
  const basePosition=new THREE.Vector3(...cfg.pos);
  group.rotation.x=cfg.tilt[0]; group.rotation.y=cfg.tilt[1];

  // BIOS blue vibe
  if(cfg.name==='bios'){
    material.uniforms.uColor.value = biosBlue.clone();
  }

  // Retro white body
  if(cfg.name==='retro'){
    body.material.color=new THREE.Color(0xe8e8ea);
    body.material.metalness=.6; body.material.roughness=.25;
  }

  return {group, canvas, ctx, texture, material, glow, config:cfg, content:'', glitchText:'', basePosition};
}

/* TV chrome overlay (transparent UI frame) */
function addTVChrome(dev){
  const cw = dev.config.w, ch = dev.config.h;
  const uiCanvas=document.createElement('canvas'); uiCanvas.width=1024; uiCanvas.height=768;
  const uiCtx=uiCanvas.getContext('2d');
  function drawUI(){
    uiCtx.clearRect(0,0,1024,768);
    // haze glass top bar
    uiCtx.fillStyle='rgba(255,245,180,0.08)';
    uiCtx.fillRect(0,0,1024,60);
    uiCtx.strokeStyle='rgba(255,220,120,0.5)'; uiCtx.lineWidth=2; uiCtx.strokeRect(0.5,0.5,1023,59);
    // tabs
    uiCtx.fillStyle='rgba(255,235,150,0.25)'; uiCtx.fillRect(16,16,120,28);
    uiCtx.fillStyle='#777'; uiCtx.font='18px IBM Plex Mono'; uiCtx.fillText('Viewer',24,36);
    // right controls
    uiCtx.fillStyle='rgba(255,235,160,0.18)'; uiCtx.fillRect(880,14,30,30);
    uiCtx.fillRect(920,14,30,30);
    uiCtx.fillRect(960,14,30,30);
    // window stroke
    uiCtx.strokeStyle='rgba(255,220,120,0.22)'; uiCtx.lineWidth=2; uiCtx.strokeRect(8,8,1008,752);
  }
  drawUI();
  const uiTex=new THREE.CanvasTexture(uiCanvas);
  const mat=new THREE.MeshBasicMaterial({map:uiTex, transparent:true, depthTest:true});
  const plane=new THREE.Mesh(new THREE.PlaneGeometry(cw, ch), mat);
  plane.position.z = 1.02; // just above screen
  dev.group.add(plane);
  // ensure this overlay does not billboard; keep it parented
  plane.matrixAutoUpdate = true;
  dev.uiOverlay = {canvas:uiCanvas, ctx:uiCtx, tex:uiTex, mesh:plane};
}

/* 7-seg clock (for top-right) */
function addTVClock(dev){
  const canvas=document.createElement('canvas'); canvas.width=512; canvas.height=128;
  const ctx=canvas.getContext('2d'); const tex=new THREE.CanvasTexture(canvas);
  const mat=new THREE.MeshBasicMaterial({map:tex, transparent:true, color:0xfff1a8});
  const plate=new THREE.Mesh(new THREE.PlaneGeometry(6,1.5), mat);
  plate.position.set(0, dev.config.h*0.62, 0.6);
  plate.rotation.x = -0.1; // slight downward tilt
  dev.group.add(plate);
  dev.clock = {canvas,ctx,tex,mesh:plate, tick:0, wordIndex:0};
  updateClock(dev.clock, true);
  // if this is the top-right TV (movie), raise and pull forward; add warm light
  if(dev.config && dev.config.name==='movie'){
    plate.position.y = dev.config.h*0.78;
    plate.position.z = 1.15;
    plate.rotation.x = -0.18;
    const warm=new THREE.PointLight(0xffd27a, 2.0, 11); warm.position.set(0, dev.config.h*0.7, 1.0);
    dev.group.add(warm); dev.clock.light=warm;
  }
}

function addAnalogPixelClock(dev){
  if(!dev) return;
  const radius=1.55;
  const holder=new THREE.Group();
  const rimGeo=new THREE.CylinderGeometry(radius,radius,0.34,48,1,true);
  const rimMat=new THREE.MeshStandardMaterial({color:0x3a2f12, metalness:0.72, roughness:0.32, emissive:0x2a210a, emissiveIntensity:0.35});
  const rim=new THREE.Mesh(rimGeo, rimMat);
  rim.rotation.x=Math.PI/2; // Rotate rim to face forward
  holder.add(rim);

  const backMat=new THREE.MeshStandardMaterial({color:0x1b1406, metalness:0.25, roughness:0.78, emissive:0x120c02, emissiveIntensity:0.25});
  const back=new THREE.Mesh(new THREE.CircleGeometry(radius*0.92, 48), backMat);
  back.position.z=-0.16;
  holder.add(back);

  const canvas=document.createElement('canvas'); canvas.width=256; canvas.height=256;
  const ctx=canvas.getContext('2d'); ctx.imageSmoothingEnabled=false;
  const tex=new THREE.CanvasTexture(canvas); tex.minFilter=THREE.NearestFilter; tex.magFilter=THREE.NearestFilter;
  const faceMat=new THREE.MeshBasicMaterial({map:tex, color:0xffffcc});
  const face=new THREE.Mesh(new THREE.CircleGeometry(radius*0.9, 64), faceMat);
  face.position.z=0.02;
  holder.add(face);

  const recess=new THREE.Mesh(new THREE.CylinderGeometry(radius*0.88,radius*0.88,0.1,48), new THREE.MeshStandardMaterial({color:0x09090f, metalness:0.15, roughness:0.78}));
  recess.rotation.x=Math.PI/2; // Rotate recess to face forward
  recess.position.z=-0.08;
  holder.add(recess);

  const glassMat=new THREE.MeshPhysicalMaterial({color:0xfff2a0, opacity:0.32, transparent:true, transmission:0.86, roughness:0.04, metalness:0.0});
  const glass=new THREE.Mesh(new THREE.CircleGeometry(radius*0.86, 48), glassMat);
  glass.position.z=0.09;
  holder.add(glass);

  // Deathly Hallows style triangle behind the clock - circle inscribed in triangle
  // For an inscribed circle: inradius = side / (2*sqrt(3))
  // So: side = inradius * 2 * sqrt(3), where inradius = radius of clock
  const triSide=radius*2*Math.sqrt(3);
  const triHeight=triSide*Math.sqrt(3)/2;
  const cornerRadius=0.22;
  
  // Create filled rounded triangle
  const triShape=new THREE.Shape();
  const pts=[
    {x:0, y:triHeight*2/3},
    {x:-triSide/2, y:-triHeight/3},
    {x:triSide/2, y:-triHeight/3}
  ];
  
  // Start at first corner after rounding
  const p0=pts[0], p1=pts[1], p2=pts[2];
  const dx01=p1.x-p0.x, dy01=p1.y-p0.y;
  const len01=Math.sqrt(dx01*dx01+dy01*dy01);
  const startX=p0.x+dx01/len01*cornerRadius, startY=p0.y+dy01/len01*cornerRadius;
  triShape.moveTo(startX, startY);
  
  for(let i=0; i<3; i++){
    const pCurr=pts[i];
    const pNext=pts[(i+1)%3];
    const pPrev=pts[(i+2)%3];
    
    // Vector from current to next
    const dx1=pNext.x-pCurr.x, dy1=pNext.y-pCurr.y;
    const len1=Math.sqrt(dx1*dx1+dy1*dy1);
    const ux1=dx1/len1, uy1=dy1/len1;
    
    // Vector from current to prev
    const dx0=pPrev.x-pCurr.x, dy0=pPrev.y-pCurr.y;
    const len0=Math.sqrt(dx0*dx0+dy0*dy0);
    const ux0=dx0/len0, uy0=dy0/len0;
    
    // Points before and after corner
    const beforeX=pCurr.x+ux0*cornerRadius, beforeY=pCurr.y+uy0*cornerRadius;
    const afterX=pCurr.x+ux1*cornerRadius, afterY=pCurr.y+uy1*cornerRadius;
    
    triShape.lineTo(beforeX, beforeY);
    triShape.quadraticCurveTo(pCurr.x, pCurr.y, afterX, afterY);
  }
  triShape.closePath();
  
  // Filled triangle
  const triGeo=new THREE.ShapeGeometry(triShape);
  const triMat=new THREE.MeshStandardMaterial({
    color:0x6b5528, 
    metalness:0.88, 
    roughness:0.15, 
    emissive:0x4a3518, 
    emissiveIntensity:0.45,
    side:THREE.DoubleSide
  });
  const bezel=new THREE.Mesh(triGeo, triMat);
  bezel.position.z=-0.25;
  holder.add(bezel);
  
  // Add outline edge for the casing - rebuild the path manually
  const edgePoints=[];
  
  for(let i=0; i<3; i++){
    const pCurr=pts[i];
    const pNext=pts[(i+1)%3];
    const pPrev=pts[(i+2)%3];
    
    // Vector from current to next
    const dx1=pNext.x-pCurr.x, dy1=pNext.y-pCurr.y;
    const len1=Math.sqrt(dx1*dx1+dy1*dy1);
    const ux1=dx1/len1, uy1=dy1/len1;
    
    // Vector from current to prev
    const dx0=pPrev.x-pCurr.x, dy0=pPrev.y-pCurr.y;
    const len0=Math.sqrt(dx0*dx0+dy0*dy0);
    const ux0=dx0/len0, uy0=dy0/len0;
    
    // Points before and after corner
    const beforeX=pCurr.x+ux0*cornerRadius, beforeY=pCurr.y+uy0*cornerRadius;
    const afterX=pCurr.x+ux1*cornerRadius, afterY=pCurr.y+uy1*cornerRadius;
    
    // Add straight line segment points
    const lineSegs=10;
    for(let j=0; j<lineSegs; j++){
      const t=j/lineSegs;
      const prevAfterX=pts[(i+2)%3].x+((pts[i].x-pts[(i+2)%3].x)/len0)*cornerRadius;
      const prevAfterY=pts[(i+2)%3].y+((pts[i].y-pts[(i+2)%3].y)/len0)*cornerRadius;
      const x=prevAfterX+(beforeX-prevAfterX)*t;
      const y=prevAfterY+(beforeY-prevAfterY)*t;
      edgePoints.push(new THREE.Vector3(x, y, 0));
    }
    
    // Add rounded corner points
    const cornerSegs=8;
    for(let j=0; j<=cornerSegs; j++){
      const t=j/cornerSegs;
      // Quadratic bezier curve
      const x=(1-t)*(1-t)*beforeX + 2*(1-t)*t*pCurr.x + t*t*afterX;
      const y=(1-t)*(1-t)*beforeY + 2*(1-t)*t*pCurr.y + t*t*afterY;
      edgePoints.push(new THREE.Vector3(x, y, 0));
    }
  }
  
  const edgeCurve=new THREE.CatmullRomCurve3(edgePoints, true);
  const edgeGeo=new THREE.TubeGeometry(edgeCurve, 128, 0.08, 12, true);
  const edgeMat=new THREE.MeshStandardMaterial({
    color:0x8b7030, 
    metalness:0.92, 
    roughness:0.12, 
    emissive:0x5a4520, 
    emissiveIntensity:0.55
  });
  const edge=new THREE.Mesh(edgeGeo, edgeMat);
  edge.position.z=-0.24;
  holder.add(edge);

  const halo=new THREE.Mesh(new THREE.RingGeometry(radius*0.95, radius*1.12, 64), new THREE.MeshBasicMaterial({color:0xffe97a, transparent:true, opacity:0.42, blending:THREE.AdditiveBlending}));
  halo.position.z=-0.01;
  holder.add(halo);

  const stemMat=new THREE.MeshStandardMaterial({color:0x12121a, metalness:0.55, roughness:0.4});
  const stem=new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.08,1.1,16), stemMat);
  stem.rotation.z=Math.PI/7;
  stem.position.set(radius*0.7, -radius*0.45, -0.2);
  holder.add(stem);

  // Metal base - flat circular disc facing camera (along Z axis)
  const stemBase=new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.08, 32), stemMat);
  stemBase.rotation.x=Math.PI/2; // Rotate so cylinder axis points toward camera (Z direction)
  stemBase.position.copy(stem.position).add(new THREE.Vector3(0, -0.55, -0.1));
  holder.add(stemBase);

  const light=new THREE.PointLight(0xffd95a, 1.8, 7);
  light.position.set(0, radius*0.32, 0.7);
  holder.add(light);

  holder.position.set(-dev.config.w*0.72, dev.config.h*0.5, 1.32);
  holder.rotation.x = dev.group.rotation.x*0.5;
  holder.rotation.y = dev.group.rotation.y;
  holder.rotation.z = 0.04;
  dev.group.add(holder);

  // Invisible pick proxy matching the clock face
  const clockProxy = new THREE.Mesh(new THREE.CircleGeometry(radius*0.95, 48), new THREE.MeshBasicMaterial({visible:false}));
  clockProxy.userData.isPickProxy = true;
  clockProxy.layers.set(2);
  holder.add(clockProxy);
  holder.userData.pickProxy = clockProxy;

  const clock={canvas, ctx, tex, group:holder, tick:0};
  updateAnalogPixelClock(clock, true);
  analogClockUpdaters.push(clock);
  dev.analogClock = clock;
}

function drawPixelHand(ctx, angle, length, width, color){
  const W=ctx.canvas.width, H=ctx.canvas.height;
  ctx.save();
  ctx.translate(W/2, H/2);
  ctx.rotate(angle);
  ctx.fillStyle=color;
  ctx.fillRect(-width/2, -length*0.12, width, -length);
  ctx.restore();
}

function updateAnalogPixelClock(clock, force=false){
  clock.tick++;
  if(!force && clock.tick%3!==0) return;
  const ctx=clock.ctx, W=ctx.canvas.width, H=ctx.canvas.height;
  ctx.clearRect(0,0,W,H);

  const center=W/2;
  const radius=W*0.4;
  const grad=ctx.createRadialGradient(center, center, radius*0.1, center, center, radius*1.1);
  grad.addColorStop(0,'#fff8c6');
  grad.addColorStop(0.55,'#ffe066');
  grad.addColorStop(1,'#f5c145');
  ctx.fillStyle=grad;
  ctx.fillRect(0,0,W,H);

  const gridSize=8;
  ctx.fillStyle='rgba(255,255,255,0.08)';
  for(let x=0;x<W;x+=gridSize){ ctx.fillRect(x,0,1,H); }
  for(let y=0;y<H;y+=gridSize){ ctx.fillRect(0,y,W,1); }

  ctx.strokeStyle='rgba(255,230,120,0.85)';
  ctx.lineWidth=4;
  ctx.beginPath();
  ctx.arc(center, center, radius+6, 0, Math.PI*2);
  ctx.stroke();

  const hourMarks=12;
  for(let i=0;i<hourMarks;i++){
    const a=-Math.PI/2 + i*(Math.PI*2/hourMarks);
    const x=Math.cos(a)*radius;
    const y=Math.sin(a)*radius;
    ctx.fillStyle=i%3===0?'#ffffff':'#1a1204';
    ctx.save();
    ctx.translate(center+x, center+y);
    ctx.rotate(a+Math.PI/2);
    ctx.fillRect(-6,-3,12,6);
    ctx.restore();
  }

  const now=new Date();
  const hour=now.getHours()%12 + now.getMinutes()/60;
  const minute=now.getMinutes() + now.getSeconds()/60;
  const second=now.getSeconds() + now.getMilliseconds()/1000;

  drawPixelHand(ctx, -Math.PI/2 + hour*(Math.PI*2/12), radius*0.55, 14, '#ffffff');
  drawPixelHand(ctx, -Math.PI/2 + minute*(Math.PI*2/60), radius*0.78, 10, '#161616');
  ctx.save();
  ctx.globalAlpha=0.85;
  drawPixelHand(ctx, -Math.PI/2 + second*(Math.PI*2/60), radius*0.84, 6, '#ffffff');
  ctx.restore();

  ctx.fillStyle='rgba(0,0,0,0.35)';
  ctx.beginPath();
  ctx.arc(center, center, 10, 0, Math.PI*2);
  ctx.fill();
  ctx.fillStyle='#ffe36a';
  ctx.beginPath();
  ctx.arc(center, center, 6, 0, Math.PI*2);
  ctx.fill();

  ctx.fillStyle='#1f1504';
  ctx.font='20px "VT323"';
  const digital=`${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}`;
  ctx.fillText(digital, center-42, center+radius*0.55);

  clock.tex.needsUpdate=true;
}
function updateClock(clock, force=false){
  clock.tick++;
  if(!force && clock.tick%5!==0) return; // refresh fast for smooth blinking colon
  const d=new Date();
  const hh=String(d.getHours()).padStart(2,'0'), mm=String(d.getMinutes()).padStart(2,'0'), ss=String(d.getSeconds()).padStart(2,'0');
  const word = PRAXIS_WORDS[clock.wordIndex%PRAXIS_WORDS.length]; if(clock.tick%120===0) clock.wordIndex++;
  const ctx=clock.ctx, W=clock.canvas.width, H=clock.canvas.height;
  ctx.clearRect(0,0,W,H);

  // background tint
  ctx.fillStyle='rgba(90,75,30,0.15)'; ctx.fillRect(0,0,W,H);

  // 7-seg drawing helpers
  const segColor = '#888';
  const segGlow = 'rgba(0,0,0,0.4)';
  const offColor = 'rgba(70,70,70,0.15)';
  const sx=28, sy=20, scale=1.0, digitW=52, digitH=88, gap=12;
  const on = (v)=>{ ctx.fillStyle=segColor; ctx.shadowColor=segGlow; ctx.shadowBlur=6; };
  const off=(v)=>{ ctx.fillStyle=offColor; ctx.shadowColor='transparent'; ctx.shadowBlur=0; };
  function drawSeg(x,y,w,h,active){
    if(active) on(); else off();
    const r=8; // rounded segment
    ctx.beginPath();
    ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y); ctx.quadraticCurveTo(x+w,y,x+w,y+r);
    ctx.lineTo(x+w,y+h-r); ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
    ctx.lineTo(x+r,y+h); ctx.quadraticCurveTo(x,y+h,x,y+h-r);
    ctx.lineTo(x,y+r); ctx.quadraticCurveTo(x,y,x+r,y);
    ctx.closePath(); ctx.fill();
  }
  function drawDigit(d, ox, oy){
    // segment map A,B,C,D,E,F,G
    const MAP={
      '0':[1,1,1,1,1,1,0],'1':[0,1,1,0,0,0,0],'2':[1,1,0,1,1,0,1],'3':[1,1,1,1,0,0,1],
      '4':[0,1,1,0,0,1,1],'5':[1,0,1,1,0,1,1],'6':[1,0,1,1,1,1,1],'7':[1,1,1,0,0,0,0],
      '8':[1,1,1,1,1,1,1],'9':[1,1,1,1,0,1,1]
    };
    const s=MAP[d]||[0,0,0,0,0,0,0];
    const th=12; // segment thickness
    // A (top)
    drawSeg(ox+th, oy, digitW-2*th, th, s[0]);
    // B (top-right)
    drawSeg(ox+digitW-th, oy+th, th, (digitH-3*th)/2, s[1]);
    // C (bottom-right)
    drawSeg(ox+digitW-th, oy+digitH/2+th/2, th, (digitH-3*th)/2, s[2]);
    // D (bottom)
    drawSeg(ox+th, oy+digitH-th, digitW-2*th, th, s[3]);
    // E (bottom-left)
    drawSeg(ox, oy+digitH/2+th/2, th, (digitH-3*th)/2, s[4]);
    // F (top-left)
    drawSeg(ox, oy+th, th, (digitH-3*th)/2, s[5]);
    // G (middle)
    drawSeg(ox+th, oy+digitH/2-th/2, digitW-2*th, th, s[6]);
  }
  function drawColon(ox, oy, blink){
    const r=8; const gapY=22; const color = blink?segColor:offColor;
    ctx.shadowColor=blink?segGlow:'transparent'; ctx.shadowBlur=blink?12:0; ctx.fillStyle=color;
    ctx.beginPath(); ctx.arc(ox, oy+digitH*0.32, r, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(ox, oy+digitH*0.70, r, 0, Math.PI*2); ctx.fill();
  }

  const blink = Math.floor(clock.tick/10)%2===0;
  let x=sx; const y=sy;
  const nums=[hh[0],hh[1],':',mm[0],mm[1],':',ss[0],ss[1]];
  nums.forEach(ch=>{
    if(ch===':'){
      drawColon(x+10, y, blink); x += 22; // narrow spacing for colon
    } else {
      drawDigit(ch, x, y); x += digitW + gap;
    }
  });

  // Right-side word
  ctx.shadowColor='rgba(0,0,0,0.35)'; ctx.shadowBlur=6; ctx.fillStyle='#bdbdbd';
  ctx.font='28px IBM Plex Mono'; ctx.textAlign='right'; ctx.textBaseline='middle';
  ctx.fillText(word, W-18, H/2);
  clock.tex.needsUpdate = true;
}

/* Pixelated digital clock (center TV) */
function addPixelClock(dev){
  const canvas=document.createElement('canvas'); canvas.width=512; canvas.height=128;
  const ctx=canvas.getContext('2d'); const tex=new THREE.CanvasTexture(canvas);
  tex.magFilter=THREE.NearestFilter; tex.minFilter=THREE.NearestFilter;
  const mat=new THREE.MeshBasicMaterial({map:tex, transparent:true});
  const plate=new THREE.Mesh(new THREE.PlaneGeometry(6,1.5), mat);
  plate.position.set(0, dev.config.h*0.62, 0.6);
  dev.group.add(plate);
  dev.pixelClock = {canvas,ctx,tex,mesh:plate, tick:0};
  updatePixelClock(dev.pixelClock, true);
}
function updatePixelClock(clock, force=false){
  clock.tick++;
  if(!force && clock.tick%15!==0) return;
  const d=new Date();
  const hh=String(d.getHours()).padStart(2,'0'), mm=String(d.getMinutes()).padStart(2,'0'), ss=String(d.getSeconds()).padStart(2,'0');
  const ctx=clock.ctx, W=clock.canvas.width, H=clock.canvas.height;
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle='rgba(255,210,100,0.1)'; ctx.fillRect(0,0,W,H);
  ctx.imageSmoothingEnabled=false;
  ctx.shadowColor='rgba(255,210,120,0.8)'; ctx.shadowBlur=10; ctx.fillStyle='#ffd966';
  ctx.font='80px VT323'; ctx.textAlign='left'; ctx.textBaseline='middle';
  const text=`${hh}:${mm}:${ss}`;
  ctx.fillText(text, 24, H/2);
  clock.tex.needsUpdate=true;
}

/* Static/glitch overlay for a device (barrel option) */
function addTVStaticOverlay(dev){
  const canvas=document.createElement('canvas'); canvas.width=512; canvas.height=384;
  const ctx=canvas.getContext('2d'); const tex=new THREE.CanvasTexture(canvas);
  tex.minFilter=THREE.LinearFilter; tex.magFilter=THREE.LinearFilter;
  const mat=new THREE.MeshBasicMaterial({map:tex, transparent:true, opacity:0.48, color:0xffeeaa});
  // barrel distortion like retro: slightly curved plane
  const geo = createBarrelScreenGeometry(dev.config.w, dev.config.h, 1.2, 20, 64, 48);
  const plane=new THREE.Mesh(geo, mat);
  plane.position.z = 1.01; // slightly above screen but below chrome
  dev.group.add(plane);
  dev.staticOverlay = {canvas,ctx,tex,mesh:plane, t:0, glitchTimer:2.5, glitch:false};
  updateStaticOverlay(dev.staticOverlay, true);
}
function drawSMPTE(ctx,W,H){
  const bars=['#c0c0c0','#c0c000','#00c0c0','#00c000','#c000c0','#c00000','#0000c0'];
  const w=W/bars.length; for(let i=0;i<bars.length;i++){ ctx.fillStyle=bars[i]; ctx.fillRect(i*w,0,w,H*0.7); }
  ctx.fillStyle='#000'; ctx.fillRect(0,H*0.7,W,H*0.3);
  ctx.fillStyle='#fff'; ctx.font='24px IBM Plex Mono'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText('STANDBY', W/2, H*0.85);
}
function updateStaticOverlay(overlay, force=false){
  overlay.t += 0.016;
  overlay.glitchTimer -= 0.016;
  const ctx=overlay.ctx, W=overlay.canvas.width, H=overlay.canvas.height;
  if(overlay.glitchTimer<=0){ overlay.glitch=!overlay.glitch; overlay.glitchTimer = overlay.glitch?0.6:3+Math.random()*4; }
  ctx.clearRect(0,0,W,H);
  if(overlay.glitch){
    drawSMPTE(ctx,W,H);
  } else {
    const imgData=ctx.createImageData(W,H); const d=imgData.data;
    for(let i=0;i<W*H;i++){
      const n=(Math.random()*255)|0; d[i*4+0]=n; d[i*4+1]=n; d[i*4+2]=n; d[i*4+3]=255;
    }
    ctx.putImageData(imgData,0,0);
    ctx.fillStyle='rgba(0,0,0,0.8)'; ctx.font='20px IBM Plex Mono'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText('NO SIGNAL', W/2, H*0.9);
  }
  overlay.tex.needsUpdate=true;
}

/* =========================
   Campfire (3 glowing orbs with additive trails)
   ========================= */
function createCampfire(){
  const group=new THREE.Group();
  // three base orbs (primary colors)
  const orbColors=[0xff5533,0x33ff85,0x66aaff];
  const orbs=[];
  // arrange in Venn-triangle layout for chromatic overlap
  const centers=[new THREE.Vector3(-0.35,0.35,0), new THREE.Vector3(0.35,0.35,0), new THREE.Vector3(0,0.0,0)];
  orbColors.forEach((c,i)=>{
    const geo=new THREE.SphereGeometry(0.35,24,24);
    const mat=new THREE.MeshBasicMaterial({color:c});
    const m=new THREE.Mesh(geo,mat); m.position.copy(centers[i]); group.add(m);
    const glow=new THREE.PointLight(c, 1.8, 8); glow.position.copy(m.position); group.add(glow);
    // colored trail sprite (avoid washing to white)
    const col = new THREE.Color(c);
    const tex=makeColoredTrailTexture(col);
    const spr=new THREE.Sprite(new THREE.SpriteMaterial({map:tex, transparent:true, depthWrite:false, blending:THREE.AdditiveBlending, opacity:0.9}));
    spr.scale.set(1.2,5.0,1); spr.position.set(m.position.x,1.6,0); group.add(spr);
    orbs.push({mesh:m, light:glow, trail:spr, t:Math.random()*Math.PI*2});
  });
  // ambient flame light
  const mixLight=new THREE.PointLight(0xff8844, 1.6, 14); mixLight.position.set(0,1.2,0); group.add(mixLight);
  
  // Low-poly detailed logs - thicker, deformed, stacked in campfire cone structure
  const logMat=new THREE.MeshStandardMaterial({color:0x6b4028, roughness:.8, metalness:.05});
  const branchMat=new THREE.MeshStandardMaterial({color:0x5a3520, roughness:.85, metalness:.03});
  
  function createDetailedLog(length, thickness, deform=0){
    const logGroup=new THREE.Group();
    // Main log body (low-poly: 6 segments) with deformation
    const logGeo=new THREE.CylinderGeometry(thickness, thickness*1.15, length, 6);
    const pos=logGeo.attributes.position;
    // Add organic deformations
    for(let i=0; i<pos.count; i++){
      const y=pos.getY(i);
      const x=pos.getX(i);
      const z=pos.getZ(i);
      const noise=Math.sin(y*3.0+i)*deform*0.08;
      pos.setX(i, x*(1+noise));
      pos.setZ(i, z*(1+noise));
    }
    logGeo.computeVertexNormals();
    const mainLog=new THREE.Mesh(logGeo, logMat.clone());
    logGroup.add(mainLog);
    
    // Add swirl pattern on the base (tree rings)
    const ringGeo=new THREE.TorusGeometry(thickness*0.85, 0.02, 4, 8);
    for(let r=0; r<3; r++){
      const ring=new THREE.Mesh(ringGeo, new THREE.MeshStandardMaterial({color:0x4a2818, roughness:.9}));
      ring.rotation.x=Math.PI/2;
      ring.position.y=-length/2+0.03;
      ring.scale.set(1-r*0.2, 1-r*0.2, 1);
      logGroup.add(ring);
    }
    
    // Add small organic branches with proper rotation to extend outward
    const numBranches=2+Math.floor(Math.random()*2);
    for(let b=0; b<numBranches; b++){
      const branchLen=0.5+Math.random()*0.4;
      const branchGeo=new THREE.CylinderGeometry(0.04, 0.06, branchLen, 4);
      const branch=new THREE.Mesh(branchGeo, branchMat.clone());
      const angle=Math.random()*Math.PI*2;
      const yPos=(Math.random()-0.5)*length*0.6;
      
      // Position branch on surface of log
      branch.position.set(Math.cos(angle)*thickness, yPos, Math.sin(angle)*thickness);
      
      // Rotate branch to extend outward from log surface
      branch.rotation.y=angle; // Face outward
      branch.rotation.z=Math.PI/2-0.6; // Tilt away from log at angle
      branch.castShadow=true;
      logGroup.add(branch);
      
      // Tiny twig on branch extending further
      if(Math.random()>0.4){
        const twigGeo=new THREE.CylinderGeometry(0.015, 0.025, 0.15, 3);
        const twig=new THREE.Mesh(twigGeo, branchMat.clone());
        // Position twig at end of branch extending outward
        const branchEndDist=branchLen*0.4;
        twig.position.set(
          branch.position.x + Math.cos(angle)*branchEndDist,
          branch.position.y,
          branch.position.z + Math.sin(angle)*branchEndDist
        );
        twig.rotation.y=angle;
        twig.rotation.z=Math.PI/2-0.8;
        logGroup.add(twig);
      }
    }
    
    return logGroup;
  }
  
  // Create realistic campfire cone structure
  // Base pile: 4 logs laying flat forming foundation
  const baseLogs=4;
  for(let i=0; i<baseLogs; i++){
    const log=createDetailedLog(2.6, 0.32, 1.2);
    const angle=i*(Math.PI*2/baseLogs);
    log.rotation.z=Math.PI/2; // Lay horizontally
    const radius=1.0;
    log.position.x=Math.cos(angle)*radius;
    log.position.z=Math.sin(angle)*radius;
    log.position.y=0.15;
    log.rotation.y=angle+Math.PI/2+0.1;
    log.castShadow=true; 
    log.receiveShadow=true; 
    group.add(log);
  }
  
  // Mid layer: 5 logs angled upward forming cone
  const midLogs=5;
  for(let i=0; i<midLogs; i++){
    const log=createDetailedLog(2.8, 0.28, 1.0);
    const angle=i*(Math.PI*2/midLogs)+0.2;
    log.rotation.z=Math.PI/2+0.45; // Angle upward
    const radius=0.85;
    log.position.x=Math.cos(angle)*radius;
    log.position.z=Math.sin(angle)*radius;
    log.position.y=0.42;
    log.rotation.y=angle+Math.PI/2;
    log.castShadow=true; 
    log.receiveShadow=true; 
    group.add(log);
  }
  
  // Top layer: 3 logs steeply angled forming tip
  const topLogs=3;
  for(let i=0; i<topLogs; i++){
    const log=createDetailedLog(2.2, 0.24, 0.8);
    const angle=i*(Math.PI*2/topLogs)+0.5;
    log.rotation.z=Math.PI/2+0.75; // Steep angle
    const radius=0.5;
    log.position.x=Math.cos(angle)*radius;
    log.position.z=Math.sin(angle)*radius;
    log.position.y=0.85;
    log.rotation.y=angle+Math.PI/2;
    log.castShadow=true; 
    log.receiveShadow=true; 
    group.add(log);
  }
  
  // White hole effect above campfire with lens distortion
  const whiteHoleGroup = new THREE.Group();
  whiteHoleGroup.position.set(0, 3.5, 0); // Float above campfire
  whiteHoleGroup.userData = {pulseColor: null, pulseIntensity: 0};
  
  // Black pulsating core (strong and obvious)
  const blackCoreGeo = new THREE.SphereGeometry(0.42, 32, 32);
  const blackCoreMat = new THREE.MeshStandardMaterial({
    color: 0x000000,
    emissive: 0x000000,
    roughness: 0.85,
    metalness: 0.1
  });
  const blackCore = new THREE.Mesh(blackCoreGeo, blackCoreMat);
  blackCore.userData.isBlackCore = true;
  whiteHoleGroup.add(blackCore);
  
  // Core white orb (around black core)
  const coreGeo = new THREE.SphereGeometry(0.6, 32, 32);
  const coreMat = new THREE.MeshBasicMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0.8
  });
  const core = new THREE.Mesh(coreGeo, coreMat);
  core.userData.isCore = true;
  whiteHoleGroup.add(core);
  
  // Additive glow rings
  for(let i = 0; i < 3; i++){
    const ringSize = 1.2 + i * 0.8;
    const ringGeo = new THREE.RingGeometry(ringSize, ringSize + 0.15, 32);
    const ringMat = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.6 - i * 0.15,
      side: THREE.DoubleSide,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });
    const ring = new THREE.Mesh(ringGeo, ringMat);
    ring.userData.rotSpeed = 0.2 + i * 0.15;
    ring.userData.layer = i;
    whiteHoleGroup.add(ring);
  }
  
  // Lens distortion sprite (radial blur effect)
  const lensSize = 256;
  const lensCanvas = document.createElement('canvas');
  lensCanvas.width = lensCanvas.height = lensSize;
  const lensCtx = lensCanvas.getContext('2d');
  const lensGrad = lensCtx.createRadialGradient(lensSize/2, lensSize/2, 0, lensSize/2, lensSize/2, lensSize/2);
  lensGrad.addColorStop(0, 'rgba(255,255,255,0)');
  lensGrad.addColorStop(0.3, 'rgba(255,255,255,0.05)');
  lensGrad.addColorStop(0.6, 'rgba(255,255,255,0.15)');
  lensGrad.addColorStop(1, 'rgba(255,255,255,0)');
  lensCtx.fillStyle = lensGrad;
  lensCtx.fillRect(0, 0, lensSize, lensSize);
  const lensTex = new THREE.CanvasTexture(lensCanvas);
  
  const lensSprite = new THREE.Sprite(new THREE.SpriteMaterial({
    map: lensTex,
    transparent: true,
    blending: THREE.AdditiveBlending,
    depthWrite: false
  }));
  lensSprite.scale.set(5, 5, 1);
  whiteHoleGroup.add(lensSprite);
  
  // Bright point light
  const whiteLight = new THREE.PointLight(0xffffff, 3.5, 20);
  whiteHoleGroup.add(whiteLight);
  
  group.add(whiteHoleGroup);
  
  return {group, orbs, mixLight, prevTime:0, whiteHole: whiteHoleGroup};
}
function makeRadialGradientTexture(stops, size){
  const c=document.createElement('canvas'); c.width=c.height=size; const g=c.getContext('2d');
  const grd=g.createRadialGradient(size/2,size/2,0,size/2,size/2,size/2);
  stops.forEach(([off,col])=>grd.addColorStop(off,col));
  g.fillStyle=grd; g.fillRect(0,0,size,size);
  const tex=new THREE.CanvasTexture(c); return tex;
}
function makeColoredTrailTexture(color){
  const size=256; const c=document.createElement('canvas'); c.width=c.height=size; const g=c.getContext('2d');
  const r=color.r*255|0, gr=color.g*255|0, b=color.b*255|0;
  const grd=g.createRadialGradient(size/2,size*0.8,0,size/2,size*0.8,size/2);
  grd.addColorStop(0,`rgba(${r},${gr},${b},0.85)`);
  grd.addColorStop(0.5,`rgba(${r},${gr},${b},0.25)`);
  grd.addColorStop(1,`rgba(${r},${gr},${b},0.0)`);
  g.fillStyle=grd; g.fillRect(0,0,size,size);
  const tex=new THREE.CanvasTexture(c); return tex;
}
function updateCampfire(cf, t){
  const dt = cf.prevTime? (t - cf.prevTime) : 0.016; cf.prevTime=t;
  // orb motion and trails
  cf.orbs.forEach((o,i)=>{
    o.t += dt*(0.8 + i*0.2);
    const baseX=(i-1)*0.5;
    o.mesh.position.x = baseX + Math.sin(o.t*1.2 + i)*0.06;
    o.mesh.position.y = 0.3 + Math.abs(Math.sin(o.t*1.6))*0.08;
    o.light.position.copy(o.mesh.position);
    // trail follows and stretches upward
    o.trail.position.x = o.mesh.position.x;
    o.trail.position.y = 1.6 + Math.sin(o.t*0.9 + i)*0.1;
    o.trail.scale.y = 4.6 + Math.sin(o.t*1.3 + i)*0.8;
    o.trail.material.opacity = 0.85 + 0.1*Math.sin(o.t*2.0);
  });
  // mix light flicker
  cf.mixLight.intensity = 2.0 + Math.sin(t*10.0)*0.2 + Math.random()*0.08;
}

/* Terminal flashing triangle indicator (attach to a device) */
function addTerminalIndicator(dev){
  if(!dev) return;
  // black close dot on terminal UI
  const dotGeo=new THREE.CircleGeometry(0.18, 24);
  const dotMat=new THREE.MeshBasicMaterial({color:0x000000});
  const dot=new THREE.Mesh(dotGeo,dotMat);
  dot.position.set(dev.config.w*0.5-1.0, dev.config.h*0.5-0.9, 1.06);
  dev.group.add(dot);
  dev.indicator = dot;
}

// Removed mirrorCrawlToMainMonitor - the TV now shows pure recursive scene capture

/* Red button near retro */
function addRetroButton(dev){
  if(!dev) return;
  const button=new THREE.Mesh(new THREE.CylinderGeometry(0.8,0.8,0.4,24), new THREE.MeshStandardMaterial({color:0xff2244, emissive:0xff0022, emissiveIntensity:2.5, metalness:.6, roughness:.25}));
  // place directly in front of the device using its forward vector
  const forward=new THREE.Vector3(0,0,1).applyQuaternion(dev.group.quaternion);
  const up=new THREE.Vector3(0,1,0);
  const pos = dev.group.position.clone().add(forward.multiplyScalar(2.0)).add(up.multiplyScalar(-dev.config.h*0.2));
  button.position.copy(pos);
  button.castShadow=true; scene.add(button);
  const light=new THREE.PointLight(0xff2244,3.0,6); button.add(light);
}

function addVoxelCage(dev){
  if(!dev) return null;
  const holder=new THREE.Group();
  const size=3.9;
  const half=size/2;
  const frameGeo=new THREE.BoxGeometry(size,size,size);
  const edges=new THREE.EdgesGeometry(frameGeo);
  const frameMat=new THREE.LineBasicMaterial({color:0x9bd6ff, transparent:true, opacity:0.85, blending:THREE.AdditiveBlending});
  const frame=new THREE.LineSegments(edges, frameMat);
  holder.add(frame);

  const glowEdges=new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.BoxGeometry(size*1.08,size*1.08,size*1.08)), new THREE.LineBasicMaterial({color:0xc2e7ff, transparent:true, opacity:0.32, blending:THREE.AdditiveBlending}));
  holder.add(glowEdges);

  const glassMat=new THREE.MeshPhysicalMaterial({color:0x4fb6ff, transparent:true, opacity:0.2, transmission:0.85, roughness:0.14, metalness:0.08, emissive:0x1f3c6f, emissiveIntensity:0.2});
  const glassGeo=new THREE.PlaneGeometry(size, size);
  const faces=[
    {pos:[ half,0,0], rot:[0,Math.PI/2,0]},
    {pos:[-half,0,0], rot:[0,-Math.PI/2,0]},
    {pos:[0, half,0], rot:[-Math.PI/2,0,0]},
    {pos:[0,-half,0], rot:[Math.PI/2,0,0]},
    {pos:[0,0, half], rot:[0,0,0]},
    {pos:[0,0,-half], rot:[0,Math.PI,0]}
  ];
  faces.forEach(({pos,rot})=>{
    const panel=new THREE.Mesh(glassGeo, glassMat.clone());
    panel.position.set(pos[0], pos[1], pos[2]);
    panel.rotation.set(rot[0], rot[1], rot[2]);
    holder.add(panel);
    
    // Add grid lines to each face
    const gridSize = 8;
    const gridStep = size / gridSize;
    const gridPoints = [];
    // Horizontal lines
    for(let i = 0; i <= gridSize; i++){
      const y = -half + i * gridStep;
      gridPoints.push(new THREE.Vector3(-half, y, 0));
      gridPoints.push(new THREE.Vector3(half, y, 0));
    }
    // Vertical lines
    for(let i = 0; i <= gridSize; i++){
      const x = -half + i * gridStep;
      gridPoints.push(new THREE.Vector3(x, -half, 0));
      gridPoints.push(new THREE.Vector3(x, half, 0));
    }
    const gridGeo = new THREE.BufferGeometry().setFromPoints(gridPoints);
    const gridMat = new THREE.LineBasicMaterial({
      color:0x8ac5ff, 
      transparent:true, 
      opacity:0.45, 
      blending:THREE.AdditiveBlending
    });
    const grid = new THREE.LineSegments(gridGeo, gridMat);
    grid.position.copy(panel.position);
    grid.rotation.copy(panel.rotation);
    grid.position.z += 0.01; // Slightly in front of panel
    holder.add(grid);
  });

  const gateMaterial=new THREE.MeshBasicMaterial({color:0x6fd0ff, transparent:true, opacity:0.0, blending:THREE.AdditiveBlending, side:THREE.DoubleSide, depthWrite:false});
  const gates=[];
  faces.forEach(({pos,rot},idx)=>{
    const gate=new THREE.Mesh(new THREE.PlaneGeometry(size*0.96, size*0.96, 16, 16), gateMaterial.clone());
    gate.position.set(pos[0]*0.97, pos[1]*0.97, pos[2]*0.97);
    gate.rotation.set(rot[0], rot[1], rot[2]);
    gate.visible=true;
    gate.material.opacity=0.0;
    holder.add(gate);
    const axis = idx<2?'x':idx<4?'y':'z';
    const dir = idx%2===0?1:-1;
    gates.push({mesh:gate, axis, dir, strength:0});
  });

  const gizmo=new THREE.Group();
  const squareSizes=[1.4,1.1,0.9];
  const colors=[0xff5c5c,0x6cff9a,0x58a6ff];
  squareSizes.forEach((s,i)=>{
    const geo=new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(-s,-s,0),
      new THREE.Vector3( s,-s,0),
      new THREE.Vector3( s, s,0),
      new THREE.Vector3(-s, s,0)
    ]);
    const loop=new THREE.LineLoop(geo, new THREE.LineBasicMaterial({color:colors[i], linewidth:2, transparent:true, opacity:0.9}));
    if(i===0) loop.rotation.y=Math.PI/2;
    if(i===1) loop.rotation.x=Math.PI/2;
    gizmo.add(loop);
    const connectorGeo=new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(0,0,0),
      i===0?new THREE.Vector3(s,0,0):i===1?new THREE.Vector3(0,s,0):new THREE.Vector3(0,0,s)
    ]);
    const connector=new THREE.Line(connectorGeo, new THREE.LineBasicMaterial({color:colors[i], transparent:true, opacity:0.6}));
    gizmo.add(connector);
  });
  const centerOrb=new THREE.Mesh(new THREE.SphereGeometry(0.18, 24, 16), new THREE.MeshStandardMaterial({color:0xffffff, emissive:0x66aaff, emissiveIntensity:1.4, roughness:0.2, metalness:0.4}));
  gizmo.add(centerOrb);
  holder.add(gizmo);

  const base=new THREE.Mesh(new THREE.CylinderGeometry(1.2,1.5,0.3,24), new THREE.MeshStandardMaterial({color:0x0b0d12, metalness:0.35, roughness:0.5}));
  base.position.set(0,-half-0.35,0);
  holder.add(base);

  const cageLight=new THREE.PointLight(0x66caff, 2.2, 10);
  cageLight.position.set(0,0,0);
  holder.add(cageLight);

  holder.position.set(-dev.config.w*0.78, -dev.config.h*0.02, 1.22);
  holder.rotation.x = dev.group.rotation.x;
  holder.rotation.y = dev.group.rotation.y;
  dev.group.add(holder);

  // Lightweight invisible pick proxy (raycast-only)
  const pickProxy=new THREE.Mesh(new THREE.BoxGeometry(size*1.2, size*1.2, size*1.2), new THREE.MeshBasicMaterial({visible:false}));
  pickProxy.userData.isPickProxy=true;
  pickProxy.layers.set(2);
  holder.add(pickProxy);
  holder.userData.pickProxy = pickProxy;

  const voxelGeo=new THREE.BoxGeometry(0.28,0.28,0.28);
  const voxelMat=new THREE.MeshStandardMaterial({color:0xffffff, emissive:0xffffff, emissiveIntensity:0.65, roughness:0.2, metalness:0.15});
  const voxels=[];
  for(let i=0;i<16;i++){
    const mesh=new THREE.Mesh(voxelGeo, voxelMat.clone());
    mesh.position.set((Math.random()-0.5)*size*0.5, (Math.random()-0.5)*size*0.5, (Math.random()-0.5)*size*0.5);
    mesh.visible=false;
    holder.add(mesh);
    voxels.push({mesh, velocity:new THREE.Vector3(), cooldown:Math.random()*1.2});
  }

  const gateMap={};
  gates.forEach(g=>{ gateMap[`${g.axis}${g.dir>0?'+':'-'}`]=g; });

  const emitter={group:holder, gizmo, voxels, half, spitTimer:1.4+Math.random()*0.6, gates, gateMap};
  cageEmitters.push(emitter);
  dev.voxelCage=emitter;
  return emitter;
}

/* Health monitor + panic button above bottom-left screen */
function addHealthMonitor(dev){
  if(!dev) return;
  // monitor body
  const plate=new THREE.Mesh(new THREE.BoxGeometry(6,2.2,0.3), new THREE.MeshStandardMaterial({color:0x0a0a0c, metalness:.4, roughness:.4}));
  plate.position.copy(dev.group.position).add(new THREE.Vector3(0, dev.config.h*0.75, 1.2));
  plate.castShadow=true; plate.receiveShadow=true; scene.add(plate);
  // red neon strip
  const strip=new THREE.Mesh(new THREE.BoxGeometry(5.2,0.15,0.08), new THREE.MeshStandardMaterial({color:0x220000, emissive:0xff1122, emissiveIntensity:2.2, roughness:.2, metalness:.3}));
  strip.position.set(0,0.5,0.18); plate.add(strip);
  const neonLight=new THREE.PointLight(0xff1133,1.6,8); neonLight.position.set(0,0.5,0.3); plate.add(neonLight);
  // panic button
  const panic=new THREE.Mesh(new THREE.CylinderGeometry(0.35,0.35,0.22,24), new THREE.MeshStandardMaterial({color:0x660000, emissive:0xff0022, emissiveIntensity:2.0, metalness:.6, roughness:.25}));
  panic.position.set(plate.position.x+3.4, plate.position.y, plate.position.z+0.25);
  panic.castShadow=true; scene.add(panic);
  const panicLight=new THREE.PointLight(0xff1122,2.2,6); panic.add(panicLight);
  // ECG canvas
  const canvas=document.createElement('canvas'); canvas.width=512; canvas.height=96; const ctx=canvas.getContext('2d');
  const tex=new THREE.CanvasTexture(canvas);
  const mat=new THREE.MeshBasicMaterial({map:tex, transparent:true});
  const face=new THREE.Mesh(new THREE.PlaneGeometry(5.4,1.0), mat); face.position.set(0,0.05,0.16); plate.add(face);
  const ecg={canvas,ctx,tex,t:0};
  plate.userData.ecg=ecg;
  return {plate, ecg, panic};
}

/* Pixelated heart radar above BIOS */
function addBiosRadar(dev){
  if(!dev) return;
  // create a small radar screen above the CRT (bottom-left)
  // use circular screen to avoid square clipping
  const screenGeo=new THREE.CircleGeometry(2.0, 64);
  const canvas=document.createElement('canvas'); canvas.width=256; canvas.height=256; const ctx=canvas.getContext('2d');
  function drawHeart(){
    const W=canvas.width, H=canvas.height; ctx.clearRect(0,0,W,H);
    // dark background
    ctx.fillStyle='#0a0a0e'; ctx.fillRect(0,0,W,H);
    // grid pattern (dark magenta)
    ctx.strokeStyle='rgba(80,20,60,0.25)'; ctx.lineWidth=1;
    for(let x=0;x<W;x+=16){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
    for(let y=0;y<H;y+=16){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
    // pixel heart (magenta)
    ctx.imageSmoothingEnabled=false; const s=10, ox=W/2-5*s, oy=H/2-3*s; ctx.fillStyle='#ff66cc';
    const heart=[ '01100110', '11111111', '11111111', '01111110', '00111100', '00011000' ];
    heart.forEach((row,y)=>{ [...row].forEach((ch,x)=>{ if(ch==='1') ctx.fillRect(ox+x*s, oy+y*s, s, s); }); });
    // concentric rings with bloom effect (bright magenta for bloom)
    ctx.shadowColor='rgba(255,102,204,0.9)'; ctx.shadowBlur=12;
    ctx.strokeStyle='rgba(255,102,204,0.85)'; ctx.lineWidth=2.5; 
    for(let r=40;r<=110;r+=18){ ctx.beginPath(); ctx.arc(W/2,H/2,r,0,Math.PI*2); ctx.stroke(); }
    ctx.shadowBlur=0;
  }
  drawHeart();
  const tex=new THREE.CanvasTexture(canvas); const mat=new THREE.ShaderMaterial({
    uniforms:{uTex:{value:tex},uTime:{value:0},uColor:{value:new THREE.Color(0xffffff)},uGlitch:{value:0}},
    vertexShader:`varying vec2 vUv; varying vec3 vNormal; varying vec3 vViewPos; void main(){ vUv=uv; vNormal=normalize(normalMatrix*normal); vec4 mv=modelViewMatrix*vec4(position,1.0); vViewPos=-mv.xyz; gl_Position=projectionMatrix*mv; }`,
    fragmentShader:SHADERS.radar.frag, transparent:true
  });
  const mesh=new THREE.Mesh(screenGeo, mat);
  // place near bottom-left CRT, slightly above and offset to the right, mount inside a holster frame
  const holder=new THREE.Group();
  holder.position.copy(dev.group.position.clone().add(new THREE.Vector3(3.5, dev.config.h*0.9, 1.6)));
  holder.rotation.copy(dev.group.rotation);
  holder.add(mesh);
  // nested donut-cylinder holster - radius aligned with radar screen (2.0)
  const outer=new THREE.Mesh(new THREE.TorusGeometry(2.0,0.18,16,64), new THREE.MeshStandardMaterial({color:0x111318, metalness:.6, roughness:.3}));
  const inner=new THREE.Mesh(new THREE.CylinderGeometry(1.8,1.8,0.4,48), new THREE.MeshStandardMaterial({color:0x0c0e12, metalness:.5, roughness:.35}));
  inner.rotation.x=Math.PI/2; inner.position.z=-0.2;
  holder.add(outer); holder.add(inner);
  scene.add(holder);
  // tick shader
  (function tick(){ if(!composer) return; mat.uniforms.uTime.value=clock.getElapsedTime(); requestAnimationFrame(tick); })();
  // Invisible pick proxy (disc matching radar)
  const proxy=new THREE.Mesh(new THREE.CircleGeometry(2.2, 32), new THREE.MeshBasicMaterial({visible:false}));
  proxy.userData.isPickProxy=true; proxy.layers.set(2); holder.add(proxy); holder.userData.pickProxy = proxy;
  return {holder, mesh, mat};
}

/* =========================
   Voxel world (instanced) & floaters
   ========================= */
function buildVoxelWall(){
  const size=.8, W=80, H=50, D=2, geo=new THREE.BoxGeometry(size,size,size);
  const mat=new THREE.MeshStandardMaterial({color:0x1a1a22, roughness:.9, metalness:.1});
  const max=3800, inst=new THREE.InstancedMesh(geo,mat,max); scene.add(inst);
  const dummy=new THREE.Object3D(); let n=0;
  const positions = [];
  for(let x=-W/2;x<W/2 && n<max;x+=size){
    for(let y=-H/2;y<H/2 && n<max;y+=size){
      const d=Math.sqrt((x/(W/2))**2+(y/(H/2))**2);
      if(d>0.7 && Math.random()<(d-0.7)*3) continue; if(Math.random()<0.06) continue;
      const basePos = {x: x+(Math.random()-.5)*.2, y: y+(Math.random()-.5)*.2, z: -15+Math.random()*D};
      positions.push(basePos);
      dummy.position.set(basePos.x, basePos.y, basePos.z);
      dummy.updateMatrix(); inst.setMatrixAt(n++, dummy.matrix);
    }
  } inst.count=n; inst.instanceMatrix.needsUpdate=true;
  return {inst, positions, dummy, size};
}
function buildVoxelFloor(){
  const size=.9, W=80, F=80, geo=new THREE.BoxGeometry(size,size,size);
  const mat=new THREE.MeshStandardMaterial({color:0x0d0d15, roughness:.85, metalness:.15});
  const max=4200, inst=new THREE.InstancedMesh(geo,mat,max); inst.receiveShadow=true; scene.add(inst);
  const dummy=new THREE.Object3D(); let n=0;
  const positions = [];
  for(let x=-W/2;x<W/2 && n<max;x+=size){
    for(let z=-F/2;z<F/2 && n<max;z+=size){
      const d=Math.sqrt((x/(W/2))**2+(z/(F/2))**2);
      if(d>0.75 && Math.random()<(d-0.75)*2.2) continue; if(Math.random()<0.05) continue;
      const basePos = {x: x+(Math.random()-.5)*.15, y: -15.2+(Math.random()-.5)*.2, z: z+(Math.random()-.5)*.15};
      positions.push(basePos);
      dummy.position.set(basePos.x, basePos.y, basePos.z);
      dummy.updateMatrix(); inst.setMatrixAt(n++, dummy.matrix);
    }
  } inst.count=n; inst.instanceMatrix.needsUpdate=true;
  return {inst, positions, dummy, size};
}
function createFloatingVoxels(){
  const voxelGeo=new THREE.BoxGeometry(.6,.6,.6);
  const baseMat=new THREE.MeshStandardMaterial({color:0x2a2a35, emissive:0x111219, emissiveIntensity:.45, roughness:.82, metalness:.2});
  const spriteMat0=makeDigitSprite('0'), spriteMat1=makeDigitSprite('1');
  for(let i=0;i<14;i++){
    const mesh=new THREE.Mesh(voxelGeo, baseMat.clone());
    const ang=Math.random()*Math.PI*2, r=24+Math.random()*14;
    mesh.position.set(Math.cos(ang)*r,(Math.random()-.5)*28,-8-Math.random()*8); scene.add(mesh);
    const spr=new THREE.Sprite(Math.random()>.5?spriteMat0:spriteMat1);
    spr.scale.set(1.2,1.6,1); spr.position.copy(mesh.position); spr.visible=false;
    spr.material.color = new THREE.Color(0xffffff);
    spr.material.opacity = 0.95;
    spr.material.blending = THREE.AdditiveBlending;
    scene.add(spr);
    voxelParticles.push({voxel:mesh, sprite:spr, velocity:new THREE.Vector3((Math.random()-.5)*.02,(Math.random()-.5)*.015,(Math.random()-.5)*.01), rotVel:new THREE.Vector3((Math.random()-.5)*.03,(Math.random()-.5)*.03,(Math.random()-.5)*.03), glitchTimer:Math.random()*5, isGlitched:false, fade:1.0});
  }
}
function makeDigitSprite(d){
  const c=document.createElement('canvas'); c.width=64; c.height=64; const g=c.getContext('2d');
  g.fillStyle='rgba(0,0,0,0)'; g.fillRect(0,0,64,64); g.font='bold 48px monospace'; g.fillStyle='#ffffff'; g.textAlign='center'; g.textBaseline='middle'; g.fillText(d,32,32);
  const t=new THREE.CanvasTexture(c); return new THREE.SpriteMaterial({map:t, transparent:true});
}

/* =========================
   Cables (braids + long runs)
   ========================= */
function createCableCurve(s,e,w=1.6){
  const c1=new THREE.Vector3().lerpVectors(s,e,.33).add(new THREE.Vector3((Math.random()-.5)*w,(Math.random()-.5)*w,-2));
  const c2=new THREE.Vector3().lerpVectors(s,e,.66).add(new THREE.Vector3((Math.random()-.5)*w,(Math.random()-.5)*w, 2));
  return new THREE.CubicBezierCurve3(s,c1,c2,e);
}
function addCable(curve, r=.09){
  const tube=new THREE.TubeGeometry(curve,64,r,6,false);
  const mesh=new THREE.Mesh(tube,cableMaterial); mesh.castShadow=true; mesh.userData.isCable=true; scene.add(mesh);
}
function createCableClusters(dev){
  const p=dev.group.position.clone();
  const clusters=3+Math.floor(Math.random()*2);
  for(let i=0;i<clusters;i++){
    const anchor=p.clone().add(new THREE.Vector3((Math.random()-.5)*dev.config.w*.6,(Math.random()-.5)*dev.config.h*.6,-1.4));
    const toFloor=Math.random()>.4;
    const end=new THREE.Vector3(anchor.x+(Math.random()-.5)*10, toFloor?-16: (p.y+(Math.random()-.5)*8), toFloor? (p.z-2+(Math.random()-.5)*6): -15);
    const count=8+Math.floor(Math.random()*5);
    for(let k=0;k<count;k++){
      const s=anchor.clone().add(new THREE.Vector3((Math.random()-.5)*.6,(Math.random()-.5)*.6,0));
      const e=end.clone().add(new THREE.Vector3((Math.random()-.5)*.8,(Math.random()-.5)*.8,0));
      addCable(createCableCurve(s,e,1.8), .085);
    }
  }
}
function createLongHorizontalCables(count=6){
  const baseZ=-13.5;
  for(let i=0;i<count;i++){
    const topY=6+Math.random()*7;
    const bottomY=-12-Math.random()*5;
    const startX=(Math.random()<0.5?-1:1)*(8+Math.random()*10);
    let endX=startX + (Math.random()<0.5?-1:1)*(14+Math.random()*8);
    if(Math.abs(endX-startX)<12) endX+=Math.sign(endX-startX||1)*12;
    const spread=4+Math.random()*6;
    const s=new THREE.Vector3(startX-spread*0.5, topY, baseZ-Math.random()*1.2);
    const e=new THREE.Vector3(endX+spread*0.5, bottomY, baseZ-0.5-Math.random()*1.5);
    const curve=createCableCurve(s,e,3.2);
    addCable(curve, .09);
  }
}

function refreshOrientationTargets(portrait){
  orientationWatcher.portrait = portrait;
  orientationWatcher.targets.clear();
  Object.values(devices).forEach(dev=>{
    if(!dev || !dev.group) return;
    if(!dev.basePosition){
      dev.basePosition = dev.group.position.clone();
    }
    let targetPosition = dev.basePosition.clone();
    if(portrait){
      const layout = dev.config && PORTRAIT_TARGETS[dev.config.name];
      if(layout){
        targetPosition = new THREE.Vector3(layout.x, layout.y, dev.basePosition.z);
      } else {
        targetPosition.x *= 0.6;
        targetPosition.y *= 0.6;
      }
    }
    orientationWatcher.targets.set(dev.group, {
      rotation: portrait ? Math.PI/2 : 0,
      position: targetPosition
    });
  });
}

function easeOutCubic(t){ return 1-Math.pow(1-t,3); }
function easeOutQuad(t){ return 1-Math.pow(1-t,2); }
function lerp(a,b,t){ return a+(b-a)*t; }
function tween(duration, update, done, delay=0, easing=(v)=>v){
  const start = performance.now() + delay;
  function frame(now){
    if(now<start){ requestAnimationFrame(frame); return; }
    const t = Math.min(1, (now-start)/duration);
    update(easing(t));
    if(t<1){ requestAnimationFrame(frame); }
    else if(typeof done==='function'){ done(); }
  }
  requestAnimationFrame(frame);
}
function morphPolygon(poly, fromPts, toPts, duration, delay=0, easing=easeOutCubic){
  tween(duration, (p)=>{
    const pts=fromPts.map((from,i)=>{
      const to=toPts[i];
      return `${lerp(from[0],to[0],p)},${lerp(from[1],to[1],p)}`;
    }).join(' ');
    poly.setAttribute('points', pts);
  }, null, delay, easing);
}

function setupOrientationWatcher(){
  const mq = window.matchMedia('(orientation: portrait)');
  const handler = ()=>{
    const portrait = mq.matches && innerWidth <= 900;
    refreshOrientationTargets(portrait);
  };
  orientationWatcher.media = mq;
  if(mq.addEventListener) mq.addEventListener('change', handler); else mq.addListener(handler);
  handler();
}

/* =========================
   Post
   ========================= */
function applyDofParams(){
  if(!bokehPass || !bokehPass.materialBokeh) return;
  const uniforms=bokehPass.materialBokeh.uniforms;
  if(uniforms.focus) uniforms.focus.value=DOF_PARAMS.focusDistance;
  if(uniforms.focalLength) uniforms.focalLength.value=DOF_PARAMS.focusLength;
  if(uniforms.maxblur) uniforms.maxblur.value=DOF_PARAMS.blur;
  if(uniforms.aperture) uniforms.aperture.value=THREE.MathUtils.clamp(DOF_PARAMS.blur*1.8,0.00008,0.0012);
}

function setupPost(){
  composer=new window.EffectComposer(renderer);
  renderPass=new window.RenderPass(scene,camera); composer.addPass(renderPass);
  bloomPass=new window.UnrealBloomPass(new THREE.Vector2(innerWidth,innerHeight), .42,.42,.45); composer.addPass(bloomPass);
  bloomPass.enabled = settings.bloom;
  bokehPass=new window.BokehPass(scene,camera,{focus:DOF_PARAMS.focusDistance,aperture:THREE.MathUtils.clamp(DOF_PARAMS.blur*1.8,0.00008,0.0012),maxblur:DOF_PARAMS.blur}); composer.addPass(bokehPass);
  bokehPass.enabled = settings.dof;
  applyDofParams();
  const grainShader={uniforms:{tDiffuse:{value:null},uTime:{value:0},uGrainAmount:{value:.045},uScanlineIntensity:{value:.025},uVignetteAmount:{value:.27},uChromaticAberration:{value:.0012}},vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`,fragmentShader:`uniform sampler2D tDiffuse;uniform float uTime,uGrainAmount,uScanlineIntensity,uVignetteAmount,uChromaticAberration;varying vec2 vUv;float h(vec2 p){return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);}void main(){vec2 uv=vUv;float a=uChromaticAberration*length(uv-.5);vec2 d=normalize(uv-.5);vec3 c; c.r=texture2D(tDiffuse,uv+d*a).r; c.g=texture2D(tDiffuse,uv).g; c.b=texture2D(tDiffuse,uv-d*a).b; float g=h(uv*900.0+uTime*60.0)-.5; c+=g*uGrainAmount; float s=sin(uv.y*720.0+uTime*5.0)*uScanlineIntensity; c+=s; float dist=length(uv-.5); float v=smoothstep(.78,.33,dist); c*=mix(1.0-uVignetteAmount,1.0,v); gl_FragColor=vec4(c,1.0);}`};
  grainPass=new window.ShaderPass(grainShader); grainPass.renderToScreen=true; composer.addPass(grainPass);
}

function initSoundscape(){
  if(soundscape && soundscape.ctx.state==='suspended'){ soundscape.ctx.resume(); return; }
  if(soundscape) return;
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  if(!AudioCtx) return;
  const ctx=new AudioCtx();
  audioCtx = ctx; // expose globally for thud
  const master=ctx.createGain(); master.gain.value=0.2;
  const compressor=ctx.createDynamicsCompressor();
  compressor.threshold.value=-22; compressor.knee.value=28; compressor.ratio.value=3.1;
  master.connect(compressor); compressor.connect(ctx.destination);

  const ambienceDelay=ctx.createDelay(6.5); ambienceDelay.delayTime.value=2.2;
  const ambienceFeedback=ctx.createGain(); ambienceFeedback.gain.value=0.38;
  const ambienceFilter=ctx.createBiquadFilter(); ambienceFilter.type='lowpass'; ambienceFilter.frequency.value=1400;
  ambienceDelay.connect(ambienceFeedback); ambienceFeedback.connect(ambienceFilter); ambienceFilter.connect(ambienceDelay);
  ambienceDelay.connect(master);

  const padFilter=ctx.createBiquadFilter(); padFilter.type='lowpass'; padFilter.frequency.value=480; padFilter.Q.value=1.0;
  const padGain=ctx.createGain(); padGain.gain.value=0.0; padFilter.connect(padGain); padGain.connect(master); padGain.connect(ambienceDelay);

  const bassFilter=ctx.createBiquadFilter(); bassFilter.type='lowpass'; bassFilter.frequency.value=260; bassFilter.Q.value=0.9;
  const bassGain=ctx.createGain(); bassGain.gain.value=0.0; bassFilter.connect(bassGain); bassGain.connect(master); bassGain.connect(ambienceDelay);

  const leadFilter=ctx.createBiquadFilter(); leadFilter.type='bandpass'; leadFilter.frequency.value=1380; leadFilter.Q.value=1.05;
  const leadGain=ctx.createGain(); leadGain.gain.value=0.0; leadFilter.connect(leadGain); leadGain.connect(master); leadGain.connect(ambienceDelay);

  const leadReverbSend=ctx.createGain(); leadReverbSend.gain.value=0.65;
  const leadReverb=ctx.createDelay(2.5); leadReverb.delayTime.value=0.32;
  const leadReverbFeedback=ctx.createGain(); leadReverbFeedback.gain.value=0.5;
  const leadReverbFilter=ctx.createBiquadFilter(); leadReverbFilter.type='lowpass'; leadReverbFilter.frequency.value=1900; leadReverbFilter.Q.value=0.6;
  const leadReverbMix=ctx.createGain(); leadReverbMix.gain.value=0.45;
  leadGain.connect(leadReverbSend);
  leadReverbSend.connect(leadReverb);
  leadReverb.connect(leadReverbFeedback);
  leadReverbFeedback.connect(leadReverb);
  leadReverb.connect(leadReverbFilter);
  leadReverbFilter.connect(leadReverbMix);
  leadReverbMix.connect(master);
  leadReverbMix.connect(ambienceDelay);

  const leadChorusSend=ctx.createGain(); leadChorusSend.gain.value=0.42;
  const chorusDelay=ctx.createDelay(0.08); chorusDelay.delayTime.value=0.024;
  const chorusFeedback=ctx.createGain(); chorusFeedback.gain.value=0.22;
  const chorusMix=ctx.createGain(); chorusMix.gain.value=0.5;
  leadGain.connect(leadChorusSend);
  leadChorusSend.connect(chorusDelay);
  chorusDelay.connect(chorusFeedback);
  chorusFeedback.connect(chorusDelay);
  chorusDelay.connect(chorusMix);
  chorusMix.connect(master);
  chorusMix.connect(ambienceDelay);

  const chorusLfo=ctx.createOscillator(); chorusLfo.type='sine'; chorusLfo.frequency.value=0.65;
  const chorusLfoGain=ctx.createGain(); chorusLfoGain.gain.value=0.006;
  chorusLfo.connect(chorusLfoGain); chorusLfoGain.connect(chorusDelay.delayTime); chorusLfo.start();

  const percussionBus=ctx.createGain(); percussionBus.gain.value=0.32; percussionBus.connect(master);
  const percussionSpace=ctx.createGain(); percussionSpace.gain.value=0.22; percussionBus.connect(percussionSpace); percussionSpace.connect(ambienceDelay);

  const chimeFilter=ctx.createBiquadFilter(); chimeFilter.type='bandpass'; chimeFilter.frequency.value=2400; chimeFilter.Q.value=5.5;
  const chimeGain=ctx.createGain(); chimeGain.gain.value=0.0; chimeFilter.connect(chimeGain); chimeGain.connect(master); chimeGain.connect(ambienceDelay);

  const choirFilter=ctx.createBiquadFilter(); choirFilter.type='lowpass'; choirFilter.frequency.value=1100; choirFilter.Q.value=0.8;
  const choirGain=ctx.createGain(); choirGain.gain.value=0.0; choirFilter.connect(choirGain); choirGain.connect(master); choirGain.connect(ambienceDelay);

  const padOscillators=Array.from({length:4}, (_,i)=>{
    const osc=ctx.createOscillator(); osc.type='sine';
    const seed=[174.61,220.0,261.63,392.0];
    osc.frequency.setValueAtTime(seed[i], ctx.currentTime);
    osc.connect(padFilter);
    osc.start();
    return osc;
  });

  const padLfo=ctx.createOscillator(); padLfo.type='sine'; padLfo.frequency.value=0.03;
  const padLfoGain=ctx.createGain(); padLfoGain.gain.value=140;
  padLfo.connect(padLfoGain); padLfoGain.connect(padFilter.frequency); padLfo.start();

  const melodyVibrato=ctx.createOscillator(); melodyVibrato.type='sine'; melodyVibrato.frequency.value=5.3;
  const vibratoBus=ctx.createGain(); vibratoBus.gain.value=7;
  melodyVibrato.connect(vibratoBus); melodyVibrato.start();

  const noiseBuffer=ctx.createBuffer(1, Math.floor(ctx.sampleRate*0.35), ctx.sampleRate);
  const noiseData=noiseBuffer.getChannelData(0);
  for(let i=0;i<noiseData.length;i++){
    const fade=1-(i/noiseData.length);
    noiseData[i]=(Math.random()*2-1)*fade*fade;
  }

  const NOTES={
    'C2':65.41,'D2':73.42,'E2':82.41,'F2':87.31,'G2':98.0,'A2':110.0,'Bb2':116.54,
    'C3':130.81,'D3':146.83,'E3':164.81,'F3':174.61,'G3':196.0,'A3':220.0,'Bb3':233.08,'B3':246.94,
    'C4':261.63,'D4':293.66,'E4':329.63,'F4':349.23,'G4':392.0,'A4':440.0,'Bb4':466.16,'B4':493.88,
    'C5':523.25,'D5':587.33,'E5':659.25,'F5':698.46,'G5':783.99
  };
  function freq(note){ return NOTES[note]||NOTES['C4']; }

  const tempo=96;
  const beat=60/tempo;
  const barDuration=beat*4;

  const hatSparse=[0,1,2,3];
  const hatMedium=[0,0.5,1,1.5,2,2.5,3];
  const hatBusy=[0,0.5,1,1.5,2,2.5,3,3.5];

  const introBars=[
    {section:'intro', chord:['F3','A3','C4','G4'], padFreq:520, padLevel:0.2, bass:[{note:'F2', time:0, len:4, accent:0.72}], melody:[{note:'C5', time:0, len:2, accent:0.3},{note:'A4', time:2, len:2, accent:0.26}], chimes:[{note:'C6', time:1.1, len:0.6, accent:0.42}], chorus:[{note:'F4', time:0, len:4, accent:0.24}], kicks:[0], snares:[2], hats:[...hatMedium], hatAccent:0.12},
    {section:'intro', chord:['C3','E3','G3','C4'], padFreq:500, padLevel:0.19, bass:[{note:'C2', time:0, len:4, accent:0.65}], melody:[{note:'G4', time:0.25, len:1.5, accent:0.26},{note:'E4', time:2.5, len:1.3, accent:0.23}], chimes:[{note:'E6', time:2.4, len:0.6, accent:0.38}], chorus:[{note:'C4', time:0, len:4, accent:0.22}], kicks:[0], snares:[2], hats:[...hatSparse], hatAccent:0.1},
    {section:'intro', chord:['D3','F3','A3','C4'], padFreq:510, padLevel:0.21, bass:[{note:'D2', time:0, len:4, accent:0.66}], melody:[{note:'A4', time:0.5, len:1.4, accent:0.26},{note:'F4', time:2.2, len:1.3, accent:0.24}], chimes:[{note:'A5', time:0.8, len:0.6, accent:0.4}], chorus:[{note:'D4', time:0, len:4, accent:0.24}], kicks:[0], snares:[2], hats:[...hatMedium], hatAccent:0.12},
    {section:'intro', chord:['Bb2','F3','A3','D4'], padFreq:540, padLevel:0.22, bass:[{note:'Bb2', time:0, len:4, accent:0.7}], melody:[{note:'D5', time:0.75, len:1.3, accent:0.34},{note:'A4', time:2.4, len:1.2, accent:0.25}], chimes:[{note:'D6', time:1.6, len:0.5, accent:0.44}], chorus:[{note:'Bb3', time:0, len:4, accent:0.26}], kicks:[0], snares:[2.5], hats:[...hatMedium], hatAccent:0.13}
  ];

  const verseBars=[
    {section:'verse', chord:['F3','A3','C4','E4'], padFreq:560, padLevel:0.25, bass:[{note:'F2', time:0, len:2.5, accent:0.7},{note:'C3', time:2.5, len:1.5, accent:0.58}], melody:[{note:'C5', time:0, len:0.75, accent:0.33},{note:'E5', time:1, len:1.2, accent:0.35},{note:'A4', time:2.5, len:1.1, accent:0.28}], chimes:[{note:'G5', time:1.5, len:0.5, accent:0.36}], chorus:[{note:'F4', time:0, len:4, accent:0.2}], kicks:[0,2.5], snares:[1.5], hats:[...hatBusy], hatAccent:0.16},
    {section:'verse', chord:['C3','E3','G3','B3'], padFreq:570, padLevel:0.26, bass:[{note:'C2', time:0, len:2, accent:0.64},{note:'G2', time:2, len:2, accent:0.6}], melody:[{note:'G4', time:0.5, len:1.1, accent:0.3},{note:'D5', time:2.25, len:1.3, accent:0.31}], chimes:[{note:'B5', time:2.2, len:0.5, accent:0.34}], chorus:[{note:'C4', time:0, len:4, accent:0.18}], kicks:[0,2.75], snares:[1.5], hats:[...hatBusy], hatAccent:0.17},
    {section:'verse', chord:['D3','F3','A3','C4'], padFreq:580, padLevel:0.27, bass:[{note:'D2', time:0, len:2, accent:0.66},{note:'A2', time:2, len:2, accent:0.62}], melody:[{note:'F4', time:0.5, len:1.0, accent:0.29},{note:'C5', time:1.6, len:1.1, accent:0.29},{note:'D5', time:2.9, len:0.9, accent:0.3}], chimes:[{note:'D6', time:2.8, len:0.5, accent:0.32}], chorus:[{note:'D4', time:0, len:4, accent:0.2}], kicks:[0,2.5], snares:[1.5], hats:[...hatBusy], hatAccent:0.17},
    {section:'verse', chord:['Bb2','D3','F3','G3'], padFreq:590, padLevel:0.28, bass:[{note:'Bb2', time:0, len:4, accent:0.72}], melody:[{note:'G4', time:0.75, len:1.0, accent:0.3},{note:'F4', time:2.0, len:1.2, accent:0.28},{note:'D5', time:3.1, len:0.8, accent:0.32}], chimes:[{note:'F6', time:3.0, len:0.5, accent:0.35}], chorus:[{note:'Bb3', time:0, len:4, accent:0.22}], kicks:[0,3], snares:[1.5], hats:[...hatBusy], hatAccent:0.18}
  ];

  const chorusBars=[
    {section:'chorus', chord:['Bb2','F3','A3','D4'], padFreq:610, padLevel:0.32, bass:[{note:'Bb2', time:0, len:4, accent:0.76}], melody:[{note:'F5', time:0, len:0.8, accent:0.42},{note:'D5', time:0.8, len:0.8, accent:0.38},{note:'C5', time:1.6, len:0.8, accent:0.35},{note:'A4', time:2.4, len:0.8, accent:0.32},{note:'G4', time:3.2, len:0.8, accent:0.3}], chimes:[{note:'Bb6', time:0.6, len:0.5, accent:0.4},{note:'F6', time:2.6, len:0.5, accent:0.38}], chorus:[{note:'D4', time:0, len:4, accent:0.26}], kicks:[0,1.5,2.5,3.5], snares:[1,3], hats:[...hatBusy], hatAccent:0.2},
    {section:'chorus', chord:['C3','G3','Bb3','E4'], padFreq:630, padLevel:0.33, bass:[{note:'C3', time:0, len:4, accent:0.75}], melody:[{note:'G4', time:0, len:0.9, accent:0.35},{note:'E5', time:0.9, len:1.0, accent:0.38},{note:'Bb4', time:2.1, len:1.0, accent:0.36}], chimes:[{note:'E6', time:1.0, len:0.5, accent:0.39},{note:'C6', time:3.0, len:0.5, accent:0.37}], chorus:[{note:'C4', time:0, len:4, accent:0.24}], kicks:[0,1.5,2.75,3.5], snares:[1,3], hats:[...hatBusy], hatAccent:0.21},
    {section:'chorus', chord:['D3','A3','C4','F4'], padFreq:620, padLevel:0.34, bass:[{note:'D3', time:0, len:4, accent:0.73}], melody:[{note:'A4', time:0, len:0.8, accent:0.33},{note:'F5', time:0.8, len:0.9, accent:0.39},{note:'D5', time:1.8, len:1.1, accent:0.37},{note:'C5', time:3.0, len:0.8, accent:0.34}], chimes:[{note:'A6', time:0.9, len:0.5, accent:0.38},{note:'D6', time:2.4, len:0.5, accent:0.36}], chorus:[{note:'F4', time:0, len:4, accent:0.24}], kicks:[0,1.5,2.5,3.25], snares:[1,3], hats:[...hatBusy], hatAccent:0.21},
    {section:'chorus', chord:['F3','A3','C4','E4'], padFreq:600, padLevel:0.3, bass:[{note:'F2', time:0, len:2, accent:0.72},{note:'C3', time:2, len:2, accent:0.7}], melody:[{note:'E5', time:0.2, len:0.9, accent:0.38},{note:'C5', time:1.2, len:0.9, accent:0.34},{note:'A4', time:2.2, len:0.9, accent:0.32},{note:'G4', time:3.2, len:0.8, accent:0.3}], chimes:[{note:'C6', time:1.1, len:0.5, accent:0.37},{note:'E6', time:3.1, len:0.5, accent:0.35}], chorus:[{note:'F4', time:0, len:4, accent:0.22}], kicks:[0,1.75,2.75,3.5], snares:[1,3], hats:[...hatBusy], hatAccent:0.2}
  ];

  const arrangement=[...introBars, ...verseBars, ...chorusBars];

  const stopHandles=[];
  stopHandles.push(()=>{ try{ padLfo.stop(); }catch(e){} });
  stopHandles.push(()=>{ try{ melodyVibrato.stop(); }catch(e){} });
  stopHandles.push(()=>{ try{ chorusLfo.stop(); }catch(e){} });

  padGain.gain.linearRampToValueAtTime(0.16, ctx.currentTime+6.0);
  bassGain.gain.linearRampToValueAtTime(0.28, ctx.currentTime+10.0);
  leadGain.gain.linearRampToValueAtTime(0.24, ctx.currentTime+12.0);
  chimeGain.gain.linearRampToValueAtTime(0.18, ctx.currentTime+14.0);
  choirGain.gain.linearRampToValueAtTime(0.12, ctx.currentTime+18.0);

  function retunePad(bar, startTime){
    const notes=bar.chord.map(freq);
    padOscillators.forEach((osc,i)=>{
      const target=notes[i%notes.length];
      osc.frequency.cancelScheduledValues(startTime);
      osc.frequency.linearRampToValueAtTime(target, startTime+beat*1.5);
    });
    padFilter.frequency.cancelScheduledValues(startTime);
    padFilter.frequency.linearRampToValueAtTime(bar.padFreq||520, startTime+beat*2.0);
    padGain.gain.cancelScheduledValues(startTime);
    padGain.gain.setTargetAtTime(bar.padLevel||0.2, startTime, 1.1);
  }

  function triggerBass(noteName, startTime, length, accent=0.6){
    const osc=ctx.createOscillator(); osc.type='sawtooth';
    const gain=ctx.createGain(); gain.gain.setValueAtTime(0.0001,startTime);
    const f=freq(noteName);
    osc.frequency.setValueAtTime(f,startTime);
    osc.frequency.exponentialRampToValueAtTime(f*0.97, startTime+Math.min(length,0.6));
    gain.gain.linearRampToValueAtTime(accent,startTime+0.04);
    gain.gain.exponentialRampToValueAtTime(0.0001,startTime+Math.max(0.45,length));
    osc.connect(gain); gain.connect(bassFilter);
    osc.start(startTime); osc.stop(startTime+length+0.6);
    osc.onended=()=>gain.disconnect();
  }

  function triggerLead(noteName, startTime, length, accent=0.26){
    const osc=ctx.createOscillator(); osc.type='triangle';
    const gain=ctx.createGain(); gain.gain.setValueAtTime(0.0001,startTime);
    const f=freq(noteName);
    osc.frequency.setValueAtTime(f,startTime);
    const vib=ctx.createGain(); vib.gain.value=1;
    vibratoBus.connect(vib); vib.connect(osc.detune);
    gain.gain.linearRampToValueAtTime(accent,startTime+0.08);
    gain.gain.linearRampToValueAtTime(accent*0.82,startTime+Math.max(0.2,length-0.2));
    gain.gain.exponentialRampToValueAtTime(0.0001,startTime+length+0.4);
    osc.connect(gain); gain.connect(leadFilter);
    osc.start(startTime); osc.stop(startTime+length+0.6);
    osc.onended=()=>{ gain.disconnect(); try{ vibratoBus.disconnect(vib); }catch(e){} vib.disconnect(); };
  }

  function triggerChime(noteName, startTime, length, accent=0.35){
    const f=freq(noteName);
    const osc=ctx.createOscillator(); osc.type='triangle';
    const gain=ctx.createGain(); gain.gain.setValueAtTime(0.0001,startTime);
    osc.frequency.setValueAtTime(f,startTime);
    const overtone=ctx.createOscillator(); overtone.type='sine';
    const overtoneGain=ctx.createGain(); overtoneGain.gain.setValueAtTime(0.0001,startTime);
    overtone.frequency.setValueAtTime(f*2,startTime);
    const sparkle=ctx.createOscillator(); sparkle.type='square';
    const sparkleGain=ctx.createGain(); sparkleGain.gain.setValueAtTime(0.0001,startTime);
    sparkle.frequency.setValueAtTime(f*3,startTime);
    gain.gain.linearRampToValueAtTime(accent,startTime+0.05);
    gain.gain.exponentialRampToValueAtTime(0.0001,startTime+length+0.9);
    overtoneGain.gain.linearRampToValueAtTime(accent*0.28,startTime+0.08);
    overtoneGain.gain.exponentialRampToValueAtTime(0.0001,startTime+length+1.0);
    sparkleGain.gain.linearRampToValueAtTime(accent*0.12,startTime+0.06);
    sparkleGain.gain.exponentialRampToValueAtTime(0.0001,startTime+length+0.6);
    osc.connect(gain); gain.connect(chimeFilter);
    overtone.connect(overtoneGain); overtoneGain.connect(chimeFilter);
    sparkle.connect(sparkleGain); sparkleGain.connect(chimeFilter);
    osc.start(startTime); osc.stop(startTime+length+1.0);
    overtone.start(startTime); overtone.stop(startTime+length+1.1);
    sparkle.start(startTime); sparkle.stop(startTime+length+0.8);
    let cleaned=false;
    const cleanup=()=>{
      if(cleaned) return;
      cleaned=true;
      gain.disconnect();
      overtoneGain.disconnect();
      sparkleGain.disconnect();
    };
    osc.onended=cleanup; overtone.onended=cleanup; sparkle.onended=cleanup;
  }

  function triggerChoir(noteName, startTime, length, accent=0.2){
    const f=freq(noteName);
    const detunes=[-6,0,7];
    detunes.forEach((detune,idx)=>{
      const osc=ctx.createOscillator(); osc.type='triangle';
      const voiceGain=ctx.createGain(); voiceGain.gain.setValueAtTime(0.0001,startTime);
      osc.frequency.setValueAtTime(f,startTime);
      osc.detune.value=detune;
      voiceGain.gain.linearRampToValueAtTime(accent*(idx===1?0.85:0.55), startTime+0.2);
      voiceGain.gain.linearRampToValueAtTime(accent*0.35, startTime+Math.max(0.5,length-0.4));
      voiceGain.gain.exponentialRampToValueAtTime(0.0001, startTime+length+1.4);
      osc.connect(voiceGain); voiceGain.connect(choirFilter);
      osc.start(startTime); osc.stop(startTime+length+1.6);
      osc.onended=()=>voiceGain.disconnect();
    });
  }

  function triggerKick(time, strength=1.0){
    const osc=ctx.createOscillator(); osc.type='sine';
    const gain=ctx.createGain(); gain.gain.setValueAtTime(0.0001,time);
    osc.frequency.setValueAtTime(68,time);
    osc.frequency.exponentialRampToValueAtTime(34,time+0.28);
    gain.gain.linearRampToValueAtTime(0.85*strength,time+0.02);
    gain.gain.exponentialRampToValueAtTime(0.0001,time+0.6);
    osc.connect(gain); gain.connect(percussionBus);
    osc.start(time); osc.stop(time+0.6);
    osc.onended=()=>gain.disconnect();
  }

  function triggerSnare(time){
    const noise=ctx.createBufferSource(); noise.buffer=noiseBuffer;
    const filter=ctx.createBiquadFilter(); filter.type='bandpass'; filter.frequency.value=1900; filter.Q.value=1.0;
    const gain=ctx.createGain(); gain.gain.setValueAtTime(0.0001,time);
    noise.connect(filter); filter.connect(gain); gain.connect(percussionBus);
    gain.gain.linearRampToValueAtTime(0.38,time+0.02);
    gain.gain.exponentialRampToValueAtTime(0.0001,time+0.38);
    noise.start(time); noise.stop(time+0.4);
    noise.onended=()=>{ filter.disconnect(); gain.disconnect(); };
    const tone=ctx.createOscillator(); tone.type='triangle';
    tone.frequency.setValueAtTime(260,time);
    tone.frequency.linearRampToValueAtTime(196,time+0.25);
    const toneGain=ctx.createGain(); toneGain.gain.setValueAtTime(0.0001,time);
    toneGain.gain.linearRampToValueAtTime(0.2,time+0.03);
    toneGain.gain.exponentialRampToValueAtTime(0.0001,time+0.4);
    tone.connect(toneGain); toneGain.connect(percussionBus);
    tone.start(time); tone.stop(time+0.4);
    tone.onended=()=>toneGain.disconnect();
  }

  function triggerHat(time, accent=0.12){
    const src=ctx.createBufferSource(); src.buffer=noiseBuffer;
    const hp=ctx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=5500; hp.Q.value=0.6;
    const gain=ctx.createGain(); gain.gain.setValueAtTime(0.0001,time);
    src.connect(hp); hp.connect(gain); gain.connect(percussionBus);
    gain.gain.linearRampToValueAtTime(accent,time+0.01);
    gain.gain.exponentialRampToValueAtTime(0.0001,time+0.18);
    src.start(time); src.stop(time+0.2);
    src.onended=()=>{ hp.disconnect(); gain.disconnect(); };
  }

  function scheduleBar(bar, startTime){
    retunePad(bar, startTime);
    (bar.bass||[]).forEach(n=>triggerBass(n.note, startTime + (n.time||0)*beat, (n.len||4)*beat, n.accent||0.6));
    (bar.melody||[]).forEach(n=>triggerLead(n.note, startTime + (n.time||0)*beat, (n.len||1)*beat, n.accent||0.26));
    (bar.chimes||[]).forEach(n=>triggerChime(n.note, startTime + (n.time||0)*beat, (n.len||0.75)*beat, n.accent||0.35));
    (bar.chorus||[]).forEach(n=>triggerChoir(n.note, startTime + (n.time||0)*beat, (n.len||4)*beat, n.accent||0.22));
    (bar.kicks||[]).forEach((pos,idx)=>triggerKick(startTime + pos*beat, 1.0-(idx*0.05)));
    (bar.snares||[]).forEach(pos=>triggerSnare(startTime + pos*beat));
    (bar.hats||[]).forEach(pos=>triggerHat(startTime + pos*beat, bar.hatAccent||0.12));
  }

  let barIndex=0;
  let nextBarTime=ctx.currentTime+0.4;
  scheduleBar(arrangement[barIndex], nextBarTime);
  barIndex++;
  nextBarTime += barDuration;

  function queueNextBar(){
    const bar=arrangement[barIndex%arrangement.length];
    scheduleBar(bar, nextBarTime);
    barIndex++;
    nextBarTime += barDuration;
    const delay=Math.max(120, (nextBarTime - ctx.currentTime - beat*0.5)*1000);
    const handle=setTimeout(queueNextBar, delay);
    stopHandles.push(()=>clearTimeout(handle));
  }

  const initialDelay=Math.max(120, (nextBarTime - ctx.currentTime - beat*0.5)*1000);
  const initialHandle=setTimeout(queueNextBar, initialDelay);
  stopHandles.push(()=>clearTimeout(initialHandle));

  soundscape={
    ctx,
    master,
    sources:[...padOscillators, padLfo, melodyVibrato, chorusLfo],
    gains:{pad:padGain, bass:bassGain, lead:leadGain, percussion:percussionBus, chime:chimeGain, choir:choirGain},
    delay:ambienceDelay,
    intervals:stopHandles
  };

  document.addEventListener('visibilitychange',()=>{
    if(document.hidden){ ctx.suspend().catch(()=>{}); }
    else ctx.resume().catch(()=>{});
  });
}


/* =========================
   Crawl with bow animation finale
   ========================= */
function ensureCrawlTemplate(){
  const container=document.getElementById('crawl-container');
  if(!container) return null;
  if(!container.querySelector('#crawl')){
    container.innerHTML=CRAWL_TEMPLATE;
  }
  const header=container.querySelector('#crawl-header');
  const crawl=container.querySelector('#crawl');
  const cursor=container.querySelector('#crawl-cursor');
  return {container, header, crawl, cursor};
}

function resetCrawlContainerStyles(container){
  if(!container) return;
  container.style.pointerEvents='';
  container.style.width='';
  container.style.height='';
  container.style.borderRadius='';
  container.style.background='';
  container.style.boxShadow='';
  container.style.transform='';
  container.style.opacity='';
  container.style.transition='';
}

function prepareCrawlMorph(container, header, crawl){
  if(!container || !header || !crawl) return null;
  const containerRect=container.getBoundingClientRect();
  if(!containerRect.width || !containerRect.height) return null;
  const overlay=document.createElement('div');
  overlay.className='crawl-morph-overlay';
  overlay.style.cssText='position:absolute;inset:0;pointer-events:none;z-index:5;opacity:1;';

  const baseShadow='0 14px 34px rgba(0,0,0,0.35)';
  function placeBlock(block, rect){
    block.style.position='absolute';
    block.style.left=`${(rect.left-containerRect.left).toFixed(2)}px`;
    block.style.top=`${(rect.top-containerRect.top).toFixed(2)}px`;
    block.style.width=`${rect.width.toFixed(2)}px`;
    block.style.height=`${rect.height.toFixed(2)}px`;
    block.style.borderRadius='14px';
    block.style.boxShadow=baseShadow;
  }

  const headerBlock=document.createElement('div');
  headerBlock.className='morph-header-block';
  placeBlock(headerBlock, header.getBoundingClientRect());
  headerBlock.textContent='CELLI::TERMINAL //LOG';
  headerBlock.style.display='flex';
  headerBlock.style.alignItems='center';
  headerBlock.style.justifyContent='center';
  headerBlock.style.fontSize='13px';
  headerBlock.style.fontWeight='600';
  headerBlock.style.letterSpacing='1px';
  headerBlock.style.textShadow='0 1px 0 rgba(255,255,255,0.4)';
  headerBlock.style.background='linear-gradient(135deg, rgba(0,255,130,0.65) 0%, rgba(0,180,90,0.3) 100%)';
  headerBlock.style.color='#051f12';
  overlay.appendChild(headerBlock);

  const bodyBlock=document.createElement('div');
  bodyBlock.className='morph-body-block';
  placeBlock(bodyBlock, crawl.getBoundingClientRect());
  bodyBlock.style.display='flex';
  bodyBlock.style.flexDirection='column';
  bodyBlock.style.justifyContent='center';
  bodyBlock.style.padding='18px 20px';
  bodyBlock.style.background='rgba(6,6,6,0.9)';
  bodyBlock.style.border='1px solid rgba(0,255,130,0.2)';
  bodyBlock.style.backdropFilter='blur(6px)';
  bodyBlock.style.webkitBackdropFilter='blur(6px)';
  overlay.appendChild(bodyBlock);

  for(let i=0;i<6;i++){
    const line=document.createElement('div');
    line.className='morph-line';
    line.style.height='4px';
    line.style.borderRadius='2px';
    line.style.margin=`${3+(i%2?2:0)}px 0`;
    line.style.background=`rgba(0,255,130,${0.22+0.1*i})`;
    line.style.width=`${(68+Math.random()*24).toFixed(2)}%`;
    bodyBlock.appendChild(line);
  }

  const dot=header.querySelector('.close-dot');
  let dotOrigin=null;
  if(dot){
    const dotRect=dot.getBoundingClientRect();
    const centerX=dotRect.left+dotRect.width/2-containerRect.left;
    const centerY=dotRect.top+dotRect.height/2-containerRect.top;
    dotOrigin={
      fracX: containerRect.width? centerX/containerRect.width : 0.5,
      fracY: containerRect.height? centerY/containerRect.height : 0.5
    };
  }

  return {overlay, headerBlock, bodyBlock, dotOrigin};
}

function animateCrawlMorph(data, stage, skipMode){
  if(!data) return;
  const {overlay, headerBlock, bodyBlock}=data;
  if(!overlay || !headerBlock || !bodyBlock) return;
  const lines=Array.from(bodyBlock.querySelectorAll('.morph-line'));
  const targetWidth=240;
  const targetHeight=180;
  const stageWidth=168;
  const stageHeight=118;
  const stageLeft=(targetWidth-stageWidth)/2;
  const stageTop=(targetHeight-stageHeight)/2;
  const scaleX=stageWidth/200;
  const scaleY=stageHeight/140;
  const rectLeft=stageLeft+40*scaleX;
  const rectTop=stageTop+28*scaleY;
  const rectWidth=120*scaleX;
  const rectHeight=84*scaleY;
  const headerHeight=Math.max(22, rectTop-stageTop);
  const morphDuration=skipMode?0.42:0.88;
  const fadeDuration=skipMode?0.3:0.6;
  const stageFadeDelay=skipMode?220:460;
  const overlayFadeDelay=skipMode?360:760;

  headerBlock.style.willChange='left,top,width,height,background,border-radius,color';
  bodyBlock.style.willChange='left,top,width,height,background,border,border-radius,box-shadow';
  overlay.style.willChange='opacity';

  headerBlock.style.transition=`all ${morphDuration}s cubic-bezier(0.16,0.84,0.44,1)`;
  bodyBlock.style.transition=`all ${morphDuration}s cubic-bezier(0.16,0.84,0.44,1)`;
  lines.forEach((line)=>{ line.style.transition=`all ${morphDuration}s ease-out`; });

  requestAnimationFrame(()=>{
    headerBlock.style.left=`${rectLeft.toFixed(2)}px`;
    headerBlock.style.top=`${stageTop.toFixed(2)}px`;
    headerBlock.style.width=`${rectWidth.toFixed(2)}px`;
    headerBlock.style.height=`${headerHeight.toFixed(2)}px`;
    headerBlock.style.borderRadius='18px 18px 12px 12px';
    headerBlock.style.background='linear-gradient(135deg,#ffd24d 0%,#ffb740 100%)';
    headerBlock.style.color='#4a2d00';
    headerBlock.style.boxShadow='0 16px 32px rgba(255,188,90,0.35)';
    headerBlock.style.textShadow='0 1px 0 rgba(255,255,255,0.6)';

    bodyBlock.style.left=`${rectLeft.toFixed(2)}px`;
    bodyBlock.style.top=`${rectTop.toFixed(2)}px`;
    bodyBlock.style.width=`${rectWidth.toFixed(2)}px`;
    bodyBlock.style.height=`${rectHeight.toFixed(2)}px`;
    bodyBlock.style.borderRadius='22px';
    bodyBlock.style.background='radial-gradient(circle at 50% 42%, rgba(255,220,150,0.24) 0%, rgba(255,190,90,0.15) 55%, rgba(40,26,0,0.55) 100%)';
    bodyBlock.style.border='1.4px solid rgba(255,196,90,0.45)';
    bodyBlock.style.boxShadow='0 24px 48px rgba(255,190,90,0.28)';
    bodyBlock.style.padding='20px 24px';

    lines.forEach((line,i)=>{
      line.style.background=`rgba(255,205,110,${0.32+0.08*i})`;
      line.style.width=`${(82+i*3).toFixed(2)}%`;
      line.style.margin=`${(6+i).toFixed(0)}px 0`;
      line.style.transform='translateX(0)';
      line.style.opacity=`${0.45+0.08*i}`;
    });
  });

  if(stage){
    stage.style.opacity='0';
    stage.style.transform='scale(0.92)';
    setTimeout(()=>{
      stage.style.transition=`opacity ${fadeDuration}s ease, transform ${fadeDuration}s cubic-bezier(0.16,0.84,0.44,1)`;
      stage.style.opacity='1';
      stage.style.transform='scale(1)';
    }, stageFadeDelay);
  }

  setTimeout(()=>{
    overlay.style.transition=`opacity ${fadeDuration}s ease`;
    overlay.style.opacity='0';
  }, overlayFadeDelay);

  setTimeout(()=>{ overlay.remove(); }, overlayFadeDelay+fadeDuration*1000+80);
}

function collapseCrawlToCloseFrame(skipMode=false, existing){
  const parts=existing||ensureCrawlTemplate();
  if(!parts) return;
  const {container, header, crawl, cursor}=parts;
  resetCrawlContainerStyles(container);
  addCrawlCloseDot();
  const morphData=(header && crawl)?prepareCrawlMorph(container, header, crawl):null;
  if(morphData && morphData.dotOrigin){ lastCrawlDotOrigin=morphData.dotOrigin; }
  else { lastCrawlDotOrigin=null; }
  if(cursor){
    cursor.style.opacity='0';
    cursor.style.transition='';
  }
  if(skipMode && crawl && !crawl.textContent.trim()){
    crawl.textContent=DEFAULT_CRAWL_PREVIEW;
    crawl.scrollTop=crawl.scrollHeight;
  }
  if(crawl){ crawl.style.opacity='1'; crawl.style.transition=''; }
  if(header){ header.style.opacity='1'; header.style.transition=''; }
  container.style.display='block';
    container.style.transition='transform .8s ease,width .8s ease,height .8s ease,opacity .8s ease';
  if(crawl){ crawl.style.transition='opacity .4s ease'; crawl.style.opacity='0'; }
  if(header){ header.style.transition='opacity .4s ease'; header.style.opacity='0'; }
    setTimeout(()=>{
    container.style.pointerEvents='auto';
    container.style.width='240px';
    container.style.height='180px';
    container.style.borderRadius='16px';
    container.style.background='#111';
    container.style.boxShadow='0 10px 40px rgba(0,0,0,.5)';
    container.innerHTML=buildBowMarkup();
    const stage=container.querySelector('#bow-stage');
    if(morphData && morphData.overlay){
      container.appendChild(morphData.overlay);
      requestAnimationFrame(()=>{
        animateCrawlMorph(morphData, stage, skipMode);
        playBowSequence(container);
      });
    } else {
      playBowSequence(container);
    }
  }, skipMode?260:420);
}

// Add a black-hole style close dot to the crawl header (once)
function addCrawlCloseDot(){
  const header=document.getElementById('crawl-header');
  if(!header || header.querySelector('.close-dot')) return;
  header.style.position='relative';
  header.style.pointerEvents='auto';
  const dot=document.createElement('div');
  dot.className='close-dot';
  dot.style.cssText='position:absolute;right:14px;top:10px;width:14px;height:14px;border-radius:50%;background:radial-gradient(circle at 35% 35%, #000 0%, #000 60%, #111 100%);box-shadow:0 0 6px rgba(0,0,0,0.6);cursor:pointer;z-index:100;pointer-events:auto;';
  dot.title='Close';
  dot.addEventListener('click', (e)=>{
    e.stopPropagation();
    const container=document.getElementById('crawl-container');
    if(container){
      container.style.transition='opacity 0.3s ease, transform 0.3s ease';
      container.style.opacity='0';
      container.style.transform='translate(-50%,-50%) scale(0.85)';
      setTimeout(()=>{ container.style.display='none'; }, 300);
    }
  });
  header.appendChild(dot);
}

function updateCrawlCursorPosition(){
  const crawl=document.getElementById('crawl');
  const cursor=document.getElementById('crawl-cursor');
  if(!crawl || !cursor){ return; }
  const textNode=crawl.firstChild;
  const TEXT_NODE=(window.Node&&Node.TEXT_NODE)||3;
  if(!textNode || textNode.nodeType!==TEXT_NODE){
    cursor.style.opacity='0';
    return;
  }
  const range=document.createRange();
  try{
    const len=textNode.length;
    range.setStart(textNode, len);
    range.setEnd(textNode, len);
  }catch(e){ cursor.style.opacity='0'; return; }
  const parentRect=crawl.getBoundingClientRect();
  let rect=range.getClientRects()[0];
  if(!rect){
    const helper=document.createElement('span');
    helper.textContent='\u200a';
    helper.style.visibility='hidden';
    crawl.appendChild(helper);
    rect=helper.getBoundingClientRect();
    crawl.removeChild(helper);
  }
  if(!rect){ cursor.style.opacity='0'; return; }
  const offsetX=rect.left-parentRect.left;
  const offsetY=rect.top-parentRect.top;
  cursor.style.opacity='1';
  cursor.style.transform=`translate(${(offsetX+2).toFixed(2)}px, ${(offsetY-6).toFixed(2)}px)`;
}

function buildBowMarkup(){
  return `
        <div id="bow-stage" style="position:absolute;inset:0;display:grid;place-items:center;">
          <svg id="bow-svg" viewBox="0 0 200 140" width="168" height="118">
            <defs>
              <radialGradient id="bh" cx="50%" cy="50%" r="50%">
                <stop offset="0%" stop-color="#000" stop-opacity="1"/>
                <stop offset="70%" stop-color="#060606" stop-opacity="1"/>
                <stop offset="100%" stop-color="#111" stop-opacity="0"/>
              </radialGradient>
              <radialGradient id="coreGlow" cx="50%" cy="50%" r="50%">
                <stop offset="0%" stop-color="#ffefba" stop-opacity="0.95"/>
                <stop offset="45%" stop-color="#ffc866" stop-opacity="0.65"/>
                <stop offset="100%" stop-color="#ffb02e" stop-opacity="0"/>
              </radialGradient>
              <linearGradient id="envelopeGrad" x1="0%" x2="100%" y1="0%" y2="100%">
                <stop offset="0%" stop-color="#ffdf7a"/>
                <stop offset="55%" stop-color="#ffb740"/>
                <stop offset="100%" stop-color="#ff9c2f"/>
              </linearGradient>
              <radialGradient id="dotGlow" cx="50%" cy="50%" r="50%">
                <stop offset="0%" stop-color="rgba(255,210,120,0.65)"/>
                <stop offset="100%" stop-color="rgba(255,210,120,0)"/>
              </radialGradient>
            </defs>
            <circle id="pivotHalo" cx="180" cy="18" r="18" fill="url(#dotGlow)" opacity="0"/>
            <circle id="pivotDot" cx="180" cy="18" r="10" fill="url(#bh)" stroke="#1a1a1a" stroke-width="1.6" opacity="0"/>
            <circle id="closeHitbox" cx="180" cy="18" r="14" fill="transparent" style="cursor:pointer;" opacity="0"/>
            <rect id="sq" x="100" y="70" width="0" height="0" fill="none" stroke="#ffc44d" stroke-width="8" rx="12" ry="12" opacity="0"/>
            <polygon id="left" points="0,70 -40,38 -40,102" fill="url(#envelopeGrad)" opacity="0"/>
            <polygon id="right" points="200,70 240,38 240,102" fill="url(#envelopeGrad)" opacity="0"/>
          </svg>
        </div>`;
}
function startTextCrawl(forceFinal=false){
  const parts=ensureCrawlTemplate();
  if(!parts) return;
  const {container, crawl, header, cursor}=parts;
  if(!container || !crawl || !header) return;
  resetCrawlContainerStyles(container);
  container.style.display='block';
  crawl.style.opacity='1'; crawl.style.transition='';
  header.style.opacity='1'; header.style.transition='';
  if(cursor){
    cursor.style.opacity='0';
    cursor.style.transition='';
    cursor.style.transform='translate(0,0)';
  }
  if(!forceFinal){
    crawl.textContent='';
    crawl.scrollTop=0;
  }
  // ensure header has a black close dot from start
  addCrawlCloseDot();
  requestAnimationFrame(updateCrawlCursorPosition);
  const lines = [
    "Praxis | Pattern | Compulsion | All we can ever do.",
    "Poeisis | Material | Creation | All we can ever see.",
    "Theoria | Qualia | Connection | All we can ever know.",
    ...LINES
  ];
  let i=0;
  let current=crawl.textContent||'';
  crawlActive=true;

  // local canonical matcher (avoids hoisting issues)
  function idxFn(s){
    const t=(s||'').replace(/\s+/g,' ').trim().toLowerCase();
    if(t.startsWith('praxis | pattern | compulsion')) return 0;
    if(t.startsWith('poeisis | material | creation')) return 1;
    if(t.startsWith('theoria | qualia | connection')) return 2;
    return -1;
  }

  if(forceFinal){
    crawlActive=false;
    collapseCrawlToCloseFrame(true, parts);
    return;
  }

  function endAsPresent(){
    crawlActive=false;
    collapseCrawlToCloseFrame(false, parts);
  }

  const triBuffer=[]; let triCycleStarted=false;
  (function typeLine(){
    if(!crawlActive || i>=lines.length){ endAsPresent(); return; }
    const line=lines[i]; let j=0;
    (function step(){
      if(!crawlActive) return;
      if(j<line.length){
        current += line[j++];
        crawl.textContent=current;
        crawl.scrollTop=crawl.scrollHeight;
        updateCrawlCursorPosition();
        setTimeout(step, 6 + Math.random()*10);
      } else {
        // if line has pipe-separated segments, track it for tri-line cycling
        if(line.includes('|')){
          const idx = idxFn(line);
          if(idx!==-1 && triBuffer.length<3){
            const rowIndex = current.split('\n').length - 1;
            triBuffer.push({idx, row: rowIndex});
          }
          if(triBuffer.length===3 && !triCycleStarted){
            triCycleStarted=true;
            startTriLineCycle(triBuffer.slice());
          }
        }
        // continue to next line without glitchy animation
        current+='\n\n';
        crawl.textContent=current;
        crawl.scrollTop=crawl.scrollHeight;
        updateCrawlCursorPosition();
        i++; setTimeout(typeLine, 120 + Math.random()*100);
      }
    })();
  })();

  // Begin simultaneous tri-line swapping once all three canonical lines have appeared
  function startTriLineCycle(anchorRows){
    const crawlEl=document.getElementById('crawl'); if(!crawlEl) return;
    const sequences=[
      {words:["Praxis","Pattern","Compulsion"], tail:"All we can ever do."},
      {words:["Poeisis","Material","Creation"], tail:"All we can ever see."},
      {words:["Theoria","Qualia","Connection"], tail:"All we can ever know."}
    ];
    let stepIdx=0;
    function buildTarget(anchor){
      const seq=sequences[anchor.idx]||null;
      if(!seq) return '';
      const span=seq.words.length||1;
      const offset=stepIdx%span;
      const ordered=[0,1,2].map((i)=>seq.words[(offset+i)%span]);
      return `${ordered[0]} | ${ordered[1]} | ${ordered[2]} | ${seq.tail}`;
    }
    function animateRow(anchor, target){
      return new Promise((resolve)=>{
        const row=anchor.row;
        if(row<0){ resolve(); return; }
        function erase(){
          if(!crawlActive){ resolve(); return; }
          const buffer=crawlEl.textContent.split('\n');
          if(row>=buffer.length){ resolve(); return; }
          const line=buffer[row]||'';
          if(line.length>0){
            buffer[row]=line.slice(0,-1);
            crawlEl.textContent=buffer.join('\n');
            current=crawlEl.textContent;
            crawlEl.scrollTop=crawlEl.scrollHeight;
            updateCrawlCursorPosition();
            setTimeout(erase, 10+Math.random()*14);
          } else {
            type(0);
          }
        }
        function type(idx){
          if(!crawlActive){ resolve(); return; }
          if(idx<target.length){
            const buffer=crawlEl.textContent.split('\n');
            if(row>=buffer.length){ resolve(); return; }
            const line=buffer[row]||'';
            buffer[row]=line+target[idx];
            crawlEl.textContent=buffer.join('\n');
            current=crawlEl.textContent;
            crawlEl.scrollTop=crawlEl.scrollHeight;
            updateCrawlCursorPosition();
            setTimeout(()=>type(idx+1), 14+Math.random()*16);
          } else {
            resolve();
          }
        }
        erase();
      });
    }
    function runCycle(){
      if(!crawlActive) return;
      if(!anchorRows || anchorRows.length!==3) return;
      window.__crawlActiveCycle = stepIdx;
      const animations=anchorRows.map(anchor=>{
        const target=buildTarget(anchor);
        return animateRow(anchor, target);
      });
      Promise.all(animations).then(()=>{
        if(!crawlActive) return;
        stepIdx=(stepIdx+1)%3;
        setTimeout(runCycle, 2200);
      });
    }
    setTimeout(runCycle, 420);
  }
}

// Removed animateSegmentReplacements - tri-line cycling handles all swapping now

function playBowSequence(container){
  const stage=document.getElementById('bow-stage'); if(!stage) return;
  const svg=document.getElementById('bow-svg');
  const sq=document.getElementById('sq');
  const left=document.getElementById('left');
  const right=document.getElementById('right');
  const pivotDot=document.getElementById('pivotDot');
  const pivotHalo=document.getElementById('pivotHalo');
  const closeHitbox=document.getElementById('closeHitbox');
  if(!svg || !sq || !left || !right) return;

  svg.style.filter='drop-shadow(0 0 4px rgba(255,180,80,0.35))';

  // Add click handler to close hitbox
  if(closeHitbox){
    closeHitbox.addEventListener('click', (e)=>{
      e.stopPropagation();
      if(container){
        container.style.transition='opacity 0.3s ease, transform 0.3s ease';
        container.style.opacity='0';
        container.style.transform='translate(-50%,-50%) scale(0.85)';
        setTimeout(()=>{ container.style.display='none'; }, 300);
      }
    });
    closeHitbox.style.cursor='pointer';
  }

  let pivotStart=null;
  if(pivotDot){
    const containerRect=container.getBoundingClientRect();
    const svgRect=svg.getBoundingClientRect();
    const offsetX=svgRect.left-containerRect.left;
    const offsetY=svgRect.top-containerRect.top;
    let startCx=180, startCy=18;
    if(lastCrawlDotOrigin){
      const localX=lastCrawlDotOrigin.fracX*containerRect.width;
      const localY=lastCrawlDotOrigin.fracY*containerRect.height;
      const normX=(localX-offsetX)/svgRect.width;
      const normY=(localY-offsetY)/svgRect.height;
      startCx=Math.min(200, Math.max(0, normX*200));
      startCy=Math.min(140, Math.max(0, normY*140));
    }
    pivotDot.setAttribute('cx', startCx.toFixed(2));
    pivotDot.setAttribute('cy', startCy.toFixed(2));
    pivotDot.setAttribute('opacity','1');
    pivotDot.setAttribute('fill','url(#bh)');
    pivotDot.setAttribute('r','10');
    if(pivotHalo){
      pivotHalo.setAttribute('cx', startCx.toFixed(2));
      pivotHalo.setAttribute('cy', startCy.toFixed(2));
      pivotHalo.setAttribute('r','18');
      pivotHalo.setAttribute('opacity','0');
    }
    pivotStart={cx:startCx, cy:startCy};
  }
  lastCrawlDotOrigin=null;

  const squareFrom={x:100,y:70,w:0,h:0};
  const squareTo={x:40,y:28,w:120,h:84};
  tween(820, (p)=>{
    const eased=easeOutCubic(p);
    const x=lerp(squareFrom.x,squareTo.x,eased);
    const y=lerp(squareFrom.y,squareTo.y,eased);
    const w=lerp(squareFrom.w,squareTo.w,eased);
    const h=lerp(squareFrom.h,squareTo.h,eased);
    sq.setAttribute('x', x.toFixed(2));
    sq.setAttribute('y', y.toFixed(2));
    sq.setAttribute('width', w.toFixed(2));
    sq.setAttribute('height', h.toFixed(2));
    sq.setAttribute('opacity', Math.min(1, eased*1.2).toFixed(2));
  }, null, 180);

  const leftFrom=[[0,70],[-40,38],[-40,102]];
  const leftTo=[[86,70],[44,46],[44,94]];
  const rightFrom=[[200,70],[240,38],[240,102]];
  const rightTo=[[114,70],[156,46],[156,94]];
  morphPolygon(left,leftFrom,leftTo,900,420);
  morphPolygon(right,rightFrom,rightTo,900,420);
  tween(720,(p)=>{
    const eased=easeOutQuad(p);
    left.setAttribute('opacity', eased.toFixed(2));
    right.setAttribute('opacity', eased.toFixed(2));
  }, null, 420);

  tween(1400,(p)=>{
    const glow=easeOutQuad(p);
    svg.style.filter=`drop-shadow(0 0 ${lerp(4,22,glow).toFixed(1)}px rgba(255,188,80,${0.25+0.45*glow})) drop-shadow(0 0 ${lerp(6,28,glow).toFixed(1)}px rgba(255,160,60,${0.15+0.4*glow}))`;
  }, null, 420);

  if(pivotDot && pivotStart){
    tween(960,(p)=>{
      const eased=easeOutCubic(p);
      const cx=lerp(pivotStart.cx, 100, eased);
      const cy=lerp(pivotStart.cy, 70, eased);
      pivotDot.setAttribute('cx', cx.toFixed(2));
      pivotDot.setAttribute('cy', cy.toFixed(2));
      pivotDot.setAttribute('r', lerp(10,16,eased).toFixed(2));
      if(eased>0.45){
        const blend=(eased-0.45)/0.55;
        pivotDot.setAttribute('fill','url(#coreGlow)');
        pivotDot.setAttribute('opacity', (0.55+0.45*Math.min(1,blend)).toFixed(2));
      } else {
        pivotDot.setAttribute('fill','url(#bh)');
        pivotDot.setAttribute('opacity', (0.4+0.4*eased).toFixed(2));
      }
      if(pivotHalo){
        pivotHalo.setAttribute('cx', cx.toFixed(2));
        pivotHalo.setAttribute('cy', cy.toFixed(2));
        pivotHalo.setAttribute('r', lerp(18,36,eased).toFixed(2));
        pivotHalo.setAttribute('opacity', (0.1+0.45*eased).toFixed(2));
      }
      if(closeHitbox){
        closeHitbox.setAttribute('cx', cx.toFixed(2));
        closeHitbox.setAttribute('cy', cy.toFixed(2));
        closeHitbox.setAttribute('opacity', '1');
      }
    }, null, 360);
  }

  setTimeout(()=>{ finalizeCrawlCard(container, false); }, 2100);
}

function finalizeCrawlCard(container, fromSkip){
  const stage=document.getElementById('bow-stage'); if(!stage) return;
  const sq=document.getElementById('sq');
  const left=document.getElementById('left');
  const right=document.getElementById('right');
  const pivotDot=document.getElementById('pivotDot');
  const pivotHalo=document.getElementById('pivotHalo');
  // Settle shapes into their final bow formation
  if(sq){
    sq.setAttribute('x','40');
    sq.setAttribute('y','28');
    sq.setAttribute('width','120');
    sq.setAttribute('height','84');
    sq.setAttribute('opacity','1');
  }
  if(left){
    left.setAttribute('opacity','1');
    left.setAttribute('points','86,70 44,46 44,94');
  }
  if(right){
    right.setAttribute('opacity','1');
    right.setAttribute('points','114,70 156,46 156,94');
  }
  if(pivotDot){
    pivotDot.setAttribute('opacity','1');
    pivotDot.setAttribute('cx','100');
    pivotDot.setAttribute('cy','70');
    pivotDot.setAttribute('r','16');
    pivotDot.setAttribute('fill','url(#coreGlow)');
  }
  if(pivotHalo){
    pivotHalo.setAttribute('cx','100');
    pivotHalo.setAttribute('cy','70');
    pivotHalo.setAttribute('r','36');
    pivotHalo.setAttribute('opacity','0.55');
  }
  const svg=document.getElementById('bow-svg');
  if(svg) svg.style.filter='drop-shadow(0 0 22px rgba(255,188,80,0.65)) drop-shadow(0 0 28px rgba(255,160,60,0.45))';
  // morph card to white rounded square background
  const card=stage.parentElement;
  card.style.transition='background .6s ease, box-shadow .6s ease, border .6s ease';
  card.style.background='radial-gradient(circle at 50% 38%, #fffdf3 0%, #fff3c8 55%, #fee3a8 100%)';
  card.style.boxShadow='0 18px 45px rgba(255,188,90,.35), inset 0 0 26px rgba(255,215,140,.35)';
  card.style.border='1.2px solid rgba(255,196,90,0.55)';
}

/* =========================
   Theme caster (routes lines to screens)
   ========================= */
function addThemeCaster(){
  // orchestrate: terminal prints commands, targeted devices receive content
  const queue = LINES.slice(); let idx=0;
  function next(){
    if(idx>=queue.length) return;
    const line = queue[idx++];

    // terminal chatter
    sendTo('terminal', `> cast "${line}"\n> route: ${routeFor(line)}\n`);

    // Route to devices based on rules; keep retro override
    if(line==="Or. Close enough.") sendTo('retro', "Or. Close enough.");
    else {
      const target = routeFor(line);
      if(target && target !== 'tv-clock') sendTo(target, line);
    }

    setTimeout(next, 900);
  }
  next();
}
function routeFor(line){
  if(CAST_RULES[line]) return CAST_RULES[line];
  
  // Dynamic thematic routing based on keywords
  
  // AWARENESS/CONNECTION themes -> CRT (magenta, bottom-left)
  if(/aware|conscious|observe|watch|see|connect|thread|qualia|theoria|know|perceive/i.test(line)) return 'crt';
  
  // CREATION/MAKING themes -> BIOS (bottom-right)  
  if(/creat|make|build|craft|shape|form|poiesis|poeisis|material|architect|design|vessel|sew/i.test(line)) return 'bios';
  
  // TIME/ACTION/PRAXIS themes -> MOVIE (top-right)
  if(/time|praxis|pattern|action|pulse|tick|tock|compulsion|gift|present|angel|mother/i.test(line)) return 'movie';
  
  // REALITY/TRUTH moments -> RETRO (illuminated)
  if(/real|truth|close enough/i.test(line)) return 'retro';
  
  // VAL YU (creator) -> BIOS
  if(/val|yu|curator|culler|killer/i.test(line)) return 'bios';
  
  // TORI (adventurer) -> BIOS
  if(/tori|stellar|adventure|friend|chose/i.test(line)) return 'bios';
  
  // Default to movie for narrative flow
  return 'movie';
}
function sendTo(deviceName, text){
  const dev=devices[deviceName]; if(!dev) return;
  dev.content = text; drawText(deviceName);
}

/* =========================
   Text draw
   ========================= */
function drawText(name){
  const dev=devices[name]; if(!dev) return;
  if(name==='tv') return; // tv is RT + chrome
  const ctx=dev.ctx, cfg=dev.config, canvas=dev.canvas;
  ctx.fillStyle='#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
  let text=dev.glitchText || dev.content; if(!text) return;
  
  // BIOS-like style for bottom-right bios
  if(name==='bios'){
    ctx.shadowColor='rgba(120,180,255,0.6)'; ctx.shadowBlur=14; ctx.fillStyle='#ffffff';
  } else if(name==='crt'){
    // bottom-left: magenta
    ctx.shadowColor='rgba(255,120,220,0.55)'; ctx.shadowBlur=12; ctx.fillStyle='#ff66cc';
  } else {
    ctx.shadowColor='transparent'; ctx.shadowBlur=0; ctx.fillStyle='#fff';
  }
  
  // Apply global cycle to pipe-delimited lines for consistent single-item display
  if(text.includes('|') && window.__crawlActiveCycle!==undefined){
    const idx = window.__crawlActiveCycle % 3;
    const lists=[
      {col1:["Praxis","Pattern","Compulsion"], col2:["All we can ever do."]},
      {col1:["Poeisis","Material","Creation"], col2:["All we can ever see."]},
      {col1:["Theoria","Qualia","Connection"], col2:["All we can ever know."]}
    ];
    // identify which canonical line this is and swap
    const t=(text||'').replace(/\s+/g,' ').trim().toLowerCase();
    let lineIdx=-1;
    if(t.startsWith('praxis') || t.startsWith('pattern') || t.startsWith('compulsion')) lineIdx=0;
    else if(t.startsWith('poeisis') || t.startsWith('material') || t.startsWith('creation')) lineIdx=1;
    else if(t.startsWith('theoria') || t.startsWith('qualia') || t.startsWith('connection')) lineIdx=2;
    if(lineIdx>=0 && lineIdx<lists.length){
      const list=lists[lineIdx];
      text = `${list.col1[idx]} | ${list.col2[0]}`;
    }
  }
  ctx.font=`bold ${cfg.size}px ${cfg.font}`; ctx.textBaseline='top';
  const lines=text.split('\n'); const lh = cfg.size*1.35; const pad=20; const maxW=canvas.width-pad*2; let y=pad;
  for(const line of lines){
    if(!line.trim()){ y+=lh; continue; }
    const words=line.split(' '); let cur='';
    for(const w of words){
      const t=cur?cur+' '+w:w;
      if(ctx.measureText(t).width>maxW && cur){ ctx.fillText(cur,pad,y); y+=lh; cur=w; }
      else cur=t;
    }
    if(cur){ ctx.fillText(cur,pad,y); y+=lh; }
  }
  dev.texture.needsUpdate=true;
}

/* =========================
   WASD movement controls
   ========================= */
const keys = {w:false, a:false, s:false, d:false, shift:false};
function setupKeyboardControls(){
  console.log('Setting up keyboard controls...');
  window.addEventListener('keydown', e=>{
    const k = e.key.toLowerCase();
    if(k === 'w' || k === 'a' || k === 's' || k === 'd') {
      keys[k] = true;
      e.preventDefault();
      e.stopPropagation();
    }
    if(e.key === 'Shift') keys.shift = true;
  });
  window.addEventListener('keyup', e=>{
    const k = e.key.toLowerCase();
    if(k === 'w' || k === 'a' || k === 's' || k === 'd') {
      keys[k] = false;
      e.preventDefault();
      e.stopPropagation();
    }
    if(e.key === 'Shift') keys.shift = false;
  });
  console.log('Keyboard controls setup complete');
}

/* =========================
   Animate & mirror
   ========================= */
let mouse={x:0,y:0};
function animate(){
  requestAnimationFrame(animate);
  frameCount++;
  const t=clock.getElapsedTime();
  const delta = lastFrameTime ? Math.min(0.05, t - lastFrameTime) : 0.016;
  lastFrameTime = t;
  
  // Update HUD debug
  const wsEl=document.getElementById('wasd-status'); if(wsEl) wsEl.textContent=`${keys.w?'W':'-'}${keys.a?'A':'-'}${keys.s?'S':'-'}${keys.d?'D':'-'}`;
  const psEl=document.getElementById('pos-status'); if(psEl) psEl.textContent=`${camera.position.x.toFixed(1)},${camera.position.y.toFixed(1)},${camera.position.z.toFixed(1)}`;

  if(cameraMode==='orbital'){
    // Orbital parallax easing toward initial with mouse offset
    const tx = -mouse.x * 2;
    const ty =  mouse.y * 2;
    camera.position.x += (initialCameraPos.x + tx - camera.position.x) * 0.03;
    camera.position.y += (initialCameraPos.y + ty - camera.position.y) * 0.03;
    camera.lookAt(0,0,0);
  } else {
    // FPS (no clamping)
    const moveSpeed = (keys.shift ? 12.0 : 6.0) * delta;
    const forward = new THREE.Vector3(); camera.getWorldDirection(forward);
    forward.y = 0; forward.normalize(); // keep walking on ground plane
    const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).normalize(); // right-hand

    if(keys.w) camera.position.addScaledVector(forward,  moveSpeed);
    if(keys.s) camera.position.addScaledVector(forward, -moveSpeed);
    if(keys.a) camera.position.addScaledVector(right,   -moveSpeed);
    if(keys.d) camera.position.addScaledVector(right,    moveSpeed);

    // Gravity (only while airborne)
    if(!camera.userData.velocity) camera.userData.velocity=new THREE.Vector3();
    if(camera.position.y > groundLevel + 1e-4 || camera.userData.isAirborne){
      camera.userData.velocity.y -= 19.6 * delta;
      camera.position.y += camera.userData.velocity.y * delta;
      camera.userData.isAirborne = true;
      if(camera.position.y <= groundLevel){
        if(camera.userData.velocity.y < -1.5) playThudSound();
        camera.position.y = groundLevel;
        camera.userData.velocity.y = 0;
        camera.userData.isAirborne = false;
      }
    } else {
      // Stay planted
      camera.position.y = groundLevel;
      camera.userData.velocity.y = 0;
      camera.userData.isAirborne = false;
    }
  }

  // Maintain zoom row alignment and effects
  if(window.zoomOverlay){
    // Recompute a straight line in front of camera each frame
    const camForward = new THREE.Vector3(); camera.getWorldDirection(camForward).normalize();
    const camRight = new THREE.Vector3().crossVectors(camForward, new THREE.Vector3(0,1,0)).normalize();
    const camUp = new THREE.Vector3(0,1,0);
    const basePos = new THREE.Vector3().copy(camera.position).addScaledVector(camForward, 6.3).addScaledVector(camUp, 1.2);
    const spacing = 2.2;
    const order = ['cage','clock','radar'];
    order.forEach((name, idx)=>{
      const obj = (name==='cage')? (devices.bios && devices.bios.voxelCage && devices.bios.voxelCage.group)
                  : (name==='clock')? (devices.movie && devices.movie.analogClock && devices.movie.analogClock.group)
                  : (window.biosRadar && window.biosRadar.holder);
      if(!obj || !obj.userData || !obj.userData.overlayNode) return;
      const node = obj.userData.overlayNode;
      const target = new THREE.Vector3().copy(basePos).addScaledVector(camRight, (idx-1)*spacing);
      node.position.lerp(target, 0.2);
      node.quaternion.slerp(camera.quaternion, 0.15);
      // Pulse energy sphere
      if(obj.userData.energySphere){
        const s = 0.35 + Math.sin(t*3 + idx)*0.08;
        obj.userData.energySphere.scale.setScalar(s/0.35);
        obj.userData.energySphere.material.opacity = 0.55 + 0.25*Math.sin(t*2.2 + idx*0.7);
      }
      if(obj.userData.glowLight){
        obj.userData.glowLight.intensity = 2.0 + 0.6*Math.sin(t*2.0 + idx);
      }
    });

    // Only draw overlay links when items are zoomed, otherwise base links
    const anyZoomed = ['cage','clock','radar'].some(name=>{
      const obj = (name==='cage')? (devices.bios && devices.bios.voxelCage && devices.bios.voxelCage.group)
                  : (name==='clock')? (devices.movie && devices.movie.analogClock && devices.movie.analogClock.group)
                  : (window.biosRadar && window.biosRadar.holder);
      return obj && obj.userData && obj.userData.isZoomed;
    });
    if(anyZoomed){
      updateZoomLinks([
        {from: 'cage', to: 'clock'},
      {from: 'clock', to: 'radar'},
      {from: 'radar', to: 'cage'}
      ], t);
    }
  }
  
  // Screen startup sequence and paced tracking
  Object.values(devices).forEach(d=>{ 
    d.material.uniforms.uTime.value=t;
    if(!d.isOnline && t*1000 >= d.startDelay){
      const targetColor = new THREE.Color(d.config.color);
      // Fade in animation
      const fadeTime = 1200;
      const startTime = d.startDelay/1000;
      const progress = Math.min(1, (t - startTime) / (fadeTime/1000));
      const eased = progress * progress * (3 - 2 * progress); // smoothstep
      d.material.uniforms.uColor.value.copy(targetColor).multiplyScalar(eased * 0.01 + 0.99);
      if(progress >= 1.0) d.isOnline = true;
    }
    
    // Paced tracking animation (staggered/delayed updates)
    if(d.baseRotation && d.trackingPhase !== undefined && d.group && d.targetRotation){
      // Update target rotation every 0.5 seconds (staggered, not real-time)
      if(t - d.lastUpdateTime > 0.5){
        d.lastUpdateTime = t;
        
        // Calculate direction to camera
        const monitorPos = new THREE.Vector3();
        d.group.getWorldPosition(monitorPos);
        const dirToCamera = new THREE.Vector3().subVectors(camera.position, monitorPos);
        dirToCamera.normalize();
        
        // Calculate target rotation to face camera
        const distance = Math.sqrt(dirToCamera.x**2 + dirToCamera.z**2);
        const targetRotX = -Math.atan2(dirToCamera.y, distance);
        const targetRotY = Math.atan2(dirToCamera.x, dirToCamera.z);
        
        // Blend base rotation with tracking
        d.targetRotation.x = d.baseRotation.x * 0.4 + targetRotX * 0.6;
        d.targetRotation.y = d.baseRotation.y * 0.4 + targetRotY * 0.6;
      }
      
      // Smoothly interpolate toward target with breathing motion
      const trackSpeed = 0.04; // Slow, smooth interpolation
      const breathAmount = 0.015;
      const phase = d.trackingPhase + t * 0.5;
      const breathX = Math.sin(phase) * breathAmount;
      const breathY = Math.cos(phase * 0.7) * breathAmount;
      
      // Calculate new rotation
      let newRotX = d.group.rotation.x + (d.targetRotation.x + breathX - d.group.rotation.x) * trackSpeed;
      let newRotY = d.group.rotation.y + (d.targetRotation.y + breathY - d.group.rotation.y) * trackSpeed;
      
      // Clamp rotations to prevent clipping into near plane
      // Limit X rotation to prevent tilting too far forward/back
      newRotX = Math.max(-0.5, Math.min(0.8, newRotX));
      // Limit Y rotation to prevent extreme side angles
      newRotY = Math.max(-0.6, Math.min(0.6, newRotY));
      
      d.group.rotation.x = newRotX;
      d.group.rotation.y = newRotY;
    }
  });
  
  // Instanced monitors are now true InstancedMesh - no per-instance updates needed

  // TV clock tick
  if(devices.tv && devices.tv.pixelClock) updatePixelClock(devices.tv.pixelClock);
  if(devices.movie && devices.movie.clock) updateClock(devices.movie.clock);
  analogClockUpdaters.forEach(clock=>updateAnalogPixelClock(clock));

  // Terminal indicator blink
  if(devices.terminal && devices.terminal.indicator){
    const a = (Math.sin(t*5.0)*0.5+0.5)*0.95;
    devices.terminal.indicator.material.opacity = a;
    devices.terminal.indicator.visible = true;
  }

  // recursive TV capture with static camera (no bob/jitter)
  if(recursiveRT && recursiveCam && (frameCount&1)===0 && devices.tv){
    devices.tv.group.visible=false;
    // Use static position instead of copying animated camera
    recursiveCam.position.set(0, 0, 18);
    recursiveCam.lookAt(0, 0, 0);
    renderer.setRenderTarget(recursiveRT); renderer.render(scene, recursiveCam); renderer.setRenderTarget(null);
    devices.tv.group.visible=true;
  }

  // TV static/glitch overlay on top-right
  if(devices.movie && devices.movie.staticOverlay) updateStaticOverlay(devices.movie.staticOverlay);

  // campfire update
  if(campfire) updateCampfire(campfire, t);

  // health monitor ECG
  if(healthMonitor && healthMonitor.ecg){
    const e=healthMonitor.ecg; e.t += 0.016;
    const ctx=e.ctx, W=e.canvas.width, H=e.canvas.height;
    // scroll left
    const img=ctx.getImageData(2,0,W-2,H); ctx.clearRect(0,0,W,H); ctx.putImageData(img,0,0);
    // grid
    ctx.fillStyle='rgba(255,30,60,0.08)'; for(let y=0;y<H;y+=12) ctx.fillRect(W-2,y,2,1);
    // waveform
    const t=e.t*2.5; const mid=H*0.55;
    let y=mid + Math.sin(t*3.1)*6;
    // add heartbeat spike periodically
    const beat = Math.floor(t)%2===0 && (Math.floor(t*10)%10===0);
    if(beat) y -= 24;
    ctx.fillStyle='#ff3355'; ctx.fillRect(W-2, y, 2, 2);
    e.tex.needsUpdate=true;
  }
  // Base triangle links always visible at base positions
  updateBaseTriangleLinks(t);
  // warm pulse from top-right clock light
  if(devices.movie && devices.movie.clock && devices.movie.clock.light){
    devices.movie.clock.light.intensity = 1.5 + Math.sin(t*2.0)*0.2;
  }

  // orientation-based device rotation (mobile portrait)
  orientationWatcher.targets.forEach((state, group)=>{
    if(!group || !state) return;
    const targetRot = state.rotation !== undefined ? state.rotation : (state.target || 0);
    const current = group.rotation.z;
    const diff = targetRot - current;
    if(Math.abs(diff)>0.0001){
      group.rotation.z = current + diff*0.08;
    } else {
      group.rotation.z = targetRot;
    }
    if(state.position){
      group.position.x += (state.position.x - group.position.x) * 0.08;
      group.position.y += (state.position.y - group.position.y) * 0.08;
      group.position.z += (state.position.z - group.position.z) * 0.08;
    }
  });

  // wave animation for voxel walls and floor
  if(settings.voxels && window.voxelWall && window.voxelFloor){
    const waveSpeed = 1.2, waveAmpWall = 0.6, waveAmpFloor = 0.4;
    const freqX = 0.15, freqY = 0.12, freqZ = 0.18;
    
    // Animate wall
    for(let i=0; i<window.voxelWall.inst.count; i++){
      const basePos = window.voxelWall.positions[i];
      const offsetZ = Math.sin(basePos.x * freqX + basePos.y * freqY + t * waveSpeed) * waveAmpWall;
      window.voxelWall.dummy.position.set(basePos.x, basePos.y, basePos.z + offsetZ);
      window.voxelWall.dummy.updateMatrix();
      window.voxelWall.inst.setMatrixAt(i, window.voxelWall.dummy.matrix);
    }
    window.voxelWall.inst.instanceMatrix.needsUpdate = true;
    
    // Animate floor
    for(let i=0; i<window.voxelFloor.inst.count; i++){
      const basePos = window.voxelFloor.positions[i];
      const offsetY = Math.sin(basePos.x * freqX + basePos.z * freqZ + t * waveSpeed) * waveAmpFloor;
      window.voxelFloor.dummy.position.set(basePos.x, basePos.y + offsetY, basePos.z);
      window.voxelFloor.dummy.updateMatrix();
      window.voxelFloor.inst.setMatrixAt(i, window.voxelFloor.dummy.matrix);
    }
    window.voxelFloor.inst.instanceMatrix.needsUpdate = true;
    
    // Make campfire bob with the floor voxels
    if(campfire && campfire.group){
      if(!campfire.baseY) campfire.baseY = campfire.group.position.y;
      const cfX = campfire.group.position.x;
      const cfZ = campfire.group.position.z;
      const offsetY = Math.sin(cfX * freqX + cfZ * freqZ + t * waveSpeed) * waveAmpFloor;
      campfire.group.position.y = campfire.baseY + offsetY;
      
      // Animate white hole rings and handle color pulse
      if(campfire.whiteHole){
        const whData = campfire.whiteHole.userData;
        
        // Decay pulse intensity
        if(whData.pulseIntensity > 0){
          whData.pulseIntensity -= delta * 0.8;
          if(whData.pulseIntensity < 0) {
            whData.pulseIntensity = 0;
            whData.pulseColor = null;
          }
        }
        
        campfire.whiteHole.children.forEach(child => {
          // Rotate rings
          if(child.userData.rotSpeed){
            child.rotation.z += delta * child.userData.rotSpeed;
            // Pulse opacity
            const pulse = Math.sin(t * 2 + child.userData.layer * 0.5) * 0.15;
            child.material.opacity = (0.6 - child.userData.layer * 0.15) + pulse;
            
            // Apply color pulse
            if(whData.pulseColor && whData.pulseIntensity > 0){
              child.material.color.lerp(whData.pulseColor, whData.pulseIntensity * 0.5);
            } else {
              child.material.color.lerp(new THREE.Color(0xffffff), delta * 2);
            }
          }
          
          // Pulsate black core
          if(child.userData.isBlackCore){
            const blackPulse = Math.sin(t * 3) * 0.15 + 0.85;
            child.scale.setScalar(blackPulse);
          }
          
          // Apply color pulse to white core
          if(child.userData.isCore && whData.pulseColor && whData.pulseIntensity > 0){
            child.material.color.lerp(whData.pulseColor, whData.pulseIntensity * 0.7);
          } else if(child.userData.isCore){
            child.material.color.lerp(new THREE.Color(0xffffff), delta * 2);
          }
        });
      }
    }
  }

  // floaters half-rate
  if((frameCount&1)===0 && settings.voxels){
    voxelParticles.forEach(p=>{
      p.voxel.position.add(p.velocity); p.sprite.position.copy(p.voxel.position);
      p.voxel.rotation.x+=p.rotVel.x; p.voxel.rotation.y+=p.rotVel.y; p.voxel.rotation.z+=p.rotVel.z;
      if(Math.abs(p.voxel.position.x)>45) p.velocity.x*=-1;
      if(Math.abs(p.voxel.position.y)>30) p.velocity.y*=-1;
      if(p.voxel.position.z>-5 || p.voxel.position.z<-20) p.velocity.z*=-1;
      // glitch -> vapor-like white text: stretch upward, fade out, glow
      p.glitchTimer-=0.03; 
      if(p.glitchTimer<=0){ 
        p.isGlitched=!p.isGlitched; p.voxel.visible=!p.isGlitched; p.sprite.visible=p.isGlitched; 
        if(p.isGlitched){ p.fade=1.0; p.sprite.material.opacity=0.95; }
        p.glitchTimer=p.isGlitched?0.5+Math.random()*0.7:2+Math.random()*3; 
      }
      if(p.isGlitched){
        p.sprite.scale.y = 1.6 + (1.0-p.fade)*2.2; // stretch up like vapor
        p.sprite.material.opacity = Math.max(0, p.fade*0.95);
        p.fade -= 0.04; if(p.fade<=0){ p.isGlitched=false; p.voxel.visible=true; p.sprite.visible=false; p.glitchTimer=2+Math.random()*2.5; }
      } else {
        p.sprite.scale.y = 1.6;
      }
    });
  }

  cageEmitters.forEach(em=>{
    if(em.gizmo){
      em.gizmo.rotation.x = t*0.6;
      em.gizmo.rotation.y = t*0.8;
      em.gizmo.rotation.z = t*0.4;
    }
    if(!settings.voxels){
      em.voxels.forEach(v=>{ v.mesh.visible=false; });
      return;
    }
    em.spitTimer -= delta;
    if(em.spitTimer<=0){
      const v=em.voxels[Math.floor(Math.random()*em.voxels.length)];
      v.mesh.visible=true;
      v.mesh.position.set(0,0,0);
      const dir=new THREE.Vector3((Math.random()-0.5), (Math.random()-0.2), (Math.random()-0.5));
      if(dir.lengthSq()<0.01) dir.set(0,1,0);
      dir.normalize().multiplyScalar(1.6+Math.random()*0.8);
      v.velocity.copy(dir);
      v.lifetime = 2.4 + Math.random()*1.8;
      v.cooldown = 0;
      em.spitTimer = 1.3 + Math.random()*1.2;
    }
    const activateGate=(axis, dir, strength=1)=>{
      if(!em.gateMap) return;
      const gate=em.gateMap[`${axis}${dir>0?'+':'-'}`];
      if(!gate) return;
      gate.strength=Math.min(1, Math.max(gate.strength, strength));
      gate.mesh.material.opacity=gate.strength*0.7;
      gate.mesh.material.needsUpdate=true;
    };

    em.voxels.forEach(v=>{
      if(!v.mesh.visible){
        v.cooldown = Math.max(0, v.cooldown - delta);
        if(v.cooldown<=0){
          v.mesh.visible=true;
          v.mesh.position.set(0,0,0);
          const dir=new THREE.Vector3((Math.random()-0.5), (Math.random()*0.8)+0.2, (Math.random()-0.5));
          if(dir.lengthSq()<0.01) dir.set(0,1,0);
          dir.normalize().multiplyScalar(1.1+Math.random()*0.6);
          v.velocity.copy(dir);
          v.lifetime = 2.0 + Math.random()*1.5;
        }
        return;
      }
      v.lifetime -= delta;
      if(v.lifetime<=0){
        v.mesh.visible=false;
        v.cooldown = 1.2 + Math.random()*1.6;
        return;
      }
      v.mesh.position.x += v.velocity.x*delta;
      v.mesh.position.y += v.velocity.y*delta;
      v.mesh.position.z += v.velocity.z*delta;
      v.velocity.y -= delta*0.6;
      const limit=em.half*0.9;
      if(Math.abs(v.mesh.position.x)>limit){
        const dir=Math.sign(v.mesh.position.x);
        v.mesh.position.x=dir*limit;
        v.velocity.x*=-0.7;
        activateGate('x', dir, 1.0);
      } else if(Math.abs(v.mesh.position.x)>limit*0.82){
        activateGate('x', Math.sign(v.mesh.position.x)||1, 0.45);
      }
      if(Math.abs(v.mesh.position.y)>limit){
        const dir=Math.sign(v.mesh.position.y);
        v.mesh.position.y=dir*limit;
        v.velocity.y*=-0.6;
        activateGate('y', dir, 0.9);
      } else if(Math.abs(v.mesh.position.y)>limit*0.82){
        activateGate('y', Math.sign(v.mesh.position.y)||1, 0.4);
      }
      if(Math.abs(v.mesh.position.z)>limit){
        const dir=Math.sign(v.mesh.position.z);
        v.mesh.position.z=dir*limit;
        v.velocity.z*=-0.7;
        activateGate('z', dir, 1.0);
      } else if(Math.abs(v.mesh.position.z)>limit*0.82){
        activateGate('z', Math.sign(v.mesh.position.z)||1, 0.45);
      }
      v.velocity.multiplyScalar(0.995);
    });

    if(em.gates){
      em.gates.forEach(g=>{
        if(g.strength>0){
          g.strength=Math.max(0, g.strength - delta*1.8);
          const s=1+g.strength*0.1;
          g.mesh.scale.set(s,s,1);
          g.mesh.material.opacity=g.strength*0.7;
        } else {
          g.mesh.scale.set(1,1,1);
          if(g.mesh.material.opacity!==0){
            g.mesh.material.opacity=0;
          }
        }
      });
    }
  });

  // Orbital-only parallax camera; do not run in FPS
  if(cameraMode==='orbital'){
  const tx=mouse.x*4, ty=mouse.y*3;
  camera.position.x += (tx - camera.position.x)*0.03;
  camera.position.y += (ty - camera.position.y)*0.03;
  camera.position.z = 18 + Math.sin(t*0.22)*0.5;
  camera.lookAt(0,0,0);
  }

  composer.render();
}

/* =========================
   Settings & resize
   ========================= */
function hookSettings(){
  const icon=document.getElementById('settings-icon'), menu=document.getElementById('settings-menu');
  icon.onclick=()=>{ menu.style.display='block'; };
  document.getElementById('close-settings').onclick=()=>{ menu.style.display='none'; };
  [['set-bloom','bloom'],['set-dof','dof'],['set-fog','fog'],['set-voxels','voxels'],['set-cables','cables']].forEach(([id,key])=>{
    const el=document.getElementById(id);
    el.addEventListener('change',()=>{
      settings[key]=el.checked;
      if(key==='cables') scene.traverse(o=>{ if(o.userData && o.userData.isCable) o.visible=settings.cables; });
      if(key==='voxels') voxelParticles.forEach(p=>{ p.voxel.visible=settings.voxels && !p.isGlitched; p.sprite.visible=settings.voxels && p.isGlitched; });
      if(key==='bloom') bloomPass.enabled=settings.bloom;
      if(key==='dof'){ bokehPass.enabled=settings.dof; updateDofGroupState(); if(settings.dof) applyDofParams(); }
      if(key==='fog'){ scene.fog.near=settings.fog?16:9999; scene.fog.far=settings.fog?68:10000; }
    });
  });

  const dofGroup=document.getElementById('dof-controls');
  const sliderConfigs=[
    {id:'focus-length', key:'focusLength', format:(v)=>`${Math.round(v)}mm`},
    {id:'focus-distance', key:'focusDistance', format:(v)=>`${Math.round(v)}u`},
    {id:'blur-radius', key:'blur', format:(v)=>Number(v).toFixed(3)}
  ];

  function updateDofGroupState(){
    const disabled=!settings.dof;
    if(dofGroup){
      dofGroup.classList.toggle('disabled', disabled);
      sliderConfigs.forEach(cfg=>{
        const input=document.getElementById(cfg.id);
        if(input) input.disabled=disabled;
      });
    }
  }

  sliderConfigs.forEach(cfg=>{
    const input=document.getElementById(cfg.id);
    const valueEl=document.getElementById(`${cfg.id}-value`);
    if(!input) return;
    const initial=DOF_PARAMS[cfg.key];
    if(initial!==undefined) input.value=initial;
    if(valueEl) valueEl.textContent=cfg.format(input.value);
    input.addEventListener('input',()=>{
      DOF_PARAMS[cfg.key]=parseFloat(input.value);
      if(valueEl) valueEl.textContent=cfg.format(input.value);
      applyDofParams();
    });
  });

  updateDofGroupState();
}
function onResize(){
  camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight); if(composer) composer.setSize(innerWidth,innerHeight);
  if(orientationWatcher.media){
    const portrait = orientationWatcher.media.matches && innerWidth <= 900;
    refreshOrientationTargets(portrait);
  }
}

/* Mouse look */
window.addEventListener('mousemove', (e)=>{
  if(!camera) return;
  // FPS pointer lock
  if(document.pointerLockElement === document.body){
    camera.rotation.y -= (e.movementX||0) * 0.002;
    camera.rotation.x -= (e.movementY||0) * 0.002;
    camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
  } else {
    // Orbital parallax
    mouse.x = -((e.clientX/innerWidth)*2-1);
    mouse.y =  ((e.clientY/innerHeight)*2-1);
  }
});

/* =========================
   Boot
   ========================= */
document.getElementById('start').addEventListener('click', async ()=>{
  document.getElementById('start').classList.add('hide');
  try{ await document.fonts.ready; }catch(e){}
  setupKeyboardControls(); // Initialize keyboard after start
  initSoundscape();
  initScene();
  composer && animate();
  
  // --- Bring-up Self‑Tests & Toast ---------------------------------------
  (function bootDiagnostics(){
    const meshes = scene.children.filter(o=>o.isMesh).length;
    const lines = [ `Meshes: ${meshes}`, `Hint: press Play to start animation` ];
    toast(lines,'ok');
    if(meshes!==5) toast([`Expected 5 meshes (3 spheres + 1 hole + 1 tri), got ${meshes}`],'warn');
  })();
});
    
        })(); // End of initEnd3Scene IIFE
      } // End of initEnd3Scene function
      
      // Start polling for THREE.js
      waitForTHREE();
    }); // End of DOMContentLoaded

  </script>

</body>

</html>

                                           LEAVES       LEAVES

                                        LEAVES             LEAVES

                                     LEAVES                   LEAVES

                                  LEAVES                         LEAVES

          LEAVES                LEAVES                               LEAVES

          LEAVES             LEAVES                                     LEAVES

          LEAVES LEAVES   LEAVES                                           LEAVES

          LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES

          LEAVES                                                                     LEAVES

          LEAVES                                                                     LEAVES

          LEAVES    LEAVES LEAVES LEAVES LEAVES             LEAVES LEAVES LEAVES     LEAVES

          LEAVES    LEAVES                LEAVES             LEAVES       LEAVES     LEAVES

          LEAVES    LEAVES                LEAVES             LEAVES       LEAVES     LEAVES

          LEAVES    LEAVES       LEAVES    LEAVES             LEAVES LEAVES LEAVES     LEAVES

          LEAVES    LEAVES                LEAVES             LEAVES       LEAVES     LEAVES

          LEAVES    LEAVES                LEAVES             LEAVES       LEAVES     LEAVES

          LEAVES    LEAVES LEAVES LEAVES LEAVES             LEAVES LEAVES LEAVES     LEAVES

          LEAVES                                                                     LEAVES

          LEAVES                                                                     LEAVES

          LEAVES                      LEAVES LEAVES LEAVES                           LEAVES

          LEAVES                      LEAVES       LEAVES                           LEAVES

          LEAVES                      LEAVES       LEAVES                           LEAVES

          LEAVES                      LEAVES       LEAVES                           LEAVES

          LEAVES                      LEAVES       LEAVES                           LEAVES

          LEAVES                      LEAVES       LEAVES                           LEAVES

          LEAVES                      LEAVES LEAVES LEAVES                           LEAVES

          LEAVES                                                                     LEAVES

          LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES LEAVES

`;

        

        const houseDiv = document.createElement('div');

        houseDiv.id = 'leavesHouse';

        houseDiv.style.cssText = 'font-family: "Courier New", monospace; white-space: pre; text-align: left; font-size: 13px; margin-top: 5%; margin-left: 5%; color: #0f0; line-height: 1.6; position: absolute; top: 0; left: 0; z-index: 50; pointer-events: none;';

        houseDiv.textContent = house;

        frame.appendChild(houseDiv);

        

        // After 2s, glitch all LEAVES in the house to GIR.mp3

        setTimeout(() => {

            const words = house.match(/LEAVES/g) || [];

            let glitchedHouse = house;

            const glitchDuration = 2000;

            const glitchStart = Date.now();

            

            const glitchInterval = setInterval(() => {

                const elapsed = Date.now() - glitchStart;

                const progress = elapsed / glitchDuration;

                

                if (progress >= 1) {

                    clearInterval(glitchInterval);

                    // All LEAVES become GIR.mp3

                    glitchedHouse = house.replace(/LEAVES/g, 'GIR.mp3');

                    houseDiv.textContent = glitchedHouse;

                } else {

                    // Gradually glitch LEAVES to GIR.mp3

                    let tempHouse = house;

                    const totalWords = words.length;

                    const wordsToGlitch = Math.floor(totalWords * progress);

                    

                    let replacedCount = 0;

                    tempHouse = tempHouse.replace(/LEAVES/g, (match) => {

                        if (replacedCount < wordsToGlitch) {

                            replacedCount++;

                            // Mix characters between LEAVES and GIR.mp3

                            const chars = 'GIR.mp3';

                            let mixed = '';

                            for (let i = 0; i < match.length; i++) {

                                if (Math.random() < progress) {

                                    mixed += chars[i] || chars[chars.length - 1];

                                } else {

                                    mixed += match[i];

                                }

                            }

                            return mixed.padEnd(7);

                        }

                        return match;

                    });

                    

                    houseDiv.textContent = tempHouse;

                }

            }, 50);

        }, 2000);

    }

    

    function glitchText(frame, from, to) {

        const glitchDuration = 1000;

        const glitchStart = Date.now();

        const displayEl = frame.querySelector('div');

        

        const glitchInterval = setInterval(() => {

            const elapsed = Date.now() - glitchStart;

            const progress = elapsed / glitchDuration;

            

            if (progress >= 1) {

                clearInterval(glitchInterval);

                displayEl.textContent = to;

            } else {

                // Mix characters

                const mixed = to.split('').map((toChar, i) => {

                    if (Math.random() < progress) {

                        return toChar;

                    } else if (from[i]) {

                        return from[i];

                    } else {

                        return String.fromCharCode(65 + Math.floor(Math.random() * 26));

                    }

                }).join('');

                displayEl.textContent = mixed;

            }

        }, 50);

    }

    

    function startCellAddressSequence(frame, visiCalc) {

        console.log('🔷 Starting cell address sequence [VERSION 26x26 FIX v2.0]');
        console.log('%c ⚠️ GRID NOW SET TO 26x26x26 - CACHE CLEARED ⚠️ ', 'background: #00ff00; color: #000; font-size: 20px; font-weight: bold; padding: 10px;');
        
        console.log('📺 VisiCalc display:', visiCalc ? 'exists' : 'missing');

        console.log('🖼️ Frame element:', frame ? 'exists' : 'missing');

        

        // Hide existing content and visiCalc

        const frameEl = document.getElementById('visicalc-frame');

        if (frameEl) {

            frameEl.style.opacity = '0';

            frameEl.style.transition = 'opacity 0.5s ease';

        }

        if (visiCalc) {

            visiCalc.style.transition = 'opacity 0.5s ease';

            visiCalc.style.opacity = '0';

        }

        

        // Create 3D scene for cell addresses and cubes

        const addressScene = new THREE.Scene();

        addressScene.background = new THREE.Color(0x000000);

        const addressCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);

        addressCamera.position.set(0, 0, -90); // Centered on Z axis to see full 26x26x26 cube grid
        addressCamera.lookAt(0, 0, 0);
        addressCamera.updateProjectionMatrix();
        console.log('📷 [INIT] Camera positioned at (0, 0, -90) looking at origin');

        

        // Mouse look controls for white room

        let mouseX = 0, mouseY = 0;

        let targetRotationX = 0, targetRotationY = 0;

        let isMouseLookActive = false;

        

        function onMouseMove(event) {

            if (!isMouseLookActive) return;

            

            const deltaX = event.movementX || 0;

            const deltaY = event.movementY || 0;

            

            targetRotationY -= deltaX * 0.002;

            targetRotationX -= deltaY * 0.002;

            

            // Clamp vertical rotation

            targetRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetRotationX));

        }

        

        function onMouseDown(event) {

            console.log('🖱️ Mouse down at sequenceTime:', sequenceTime.toFixed(1), 'whiteRoom:', !!addressScene.userData.whiteRoomCreated, 'blackHole:', !!addressScene.userData.blackHoleCreated);

            if (addressScene.userData.blackHoleCreated && sequenceTime > 55) {

                isMouseLookActive = true;

                addressRenderer.domElement.style.cursor = 'none';

                console.log('🖱️ Mouse look ACTIVATED');

            } else {

                console.log('🖱️ Not ready for mouse look yet');

            }

        }

        

        function onMouseUp(event) {

            isMouseLookActive = false;

            addressRenderer.domElement.style.cursor = 'crosshair';

            console.log('🖱️ Mouse look deactivated');

        }

        

        // Will attach to canvas after it's created

        let mouseMoveAttached = false;

        let mouseDownAttached = false;

        let mouseUpAttached = false;

        

        const addressRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });

        addressRenderer.setSize(window.innerWidth, window.innerHeight);

        addressRenderer.setClearColor(0x000000, 1);

        addressRenderer.setPixelRatio(window.devicePixelRatio);

        addressRenderer.domElement.style.cssText = 'position: fixed; inset: 0; z-index: 200; display: block; pointer-events: auto; cursor: crosshair;';

        addressRenderer.domElement.id = 'address-canvas';

        document.body.appendChild(addressRenderer.domElement);

        console.log('✅ Address renderer created and added to DOM');

        console.log('🖱️ Canvas z-index: 200, pointer-events: auto');

        

        // Attach mouse event listeners to canvas

        addressRenderer.domElement.addEventListener('mousemove', onMouseMove);

        addressRenderer.domElement.addEventListener('mousedown', onMouseDown);

        addressRenderer.domElement.addEventListener('mouseup', onMouseUp);

        console.log('🖱️ Mouse event listeners attached to canvas');

        

        // Add bloom composer

        const addressComposer = new EffectComposer(addressRenderer);

        const renderPass = new RenderPass(addressScene, addressCamera);

        addressComposer.addPass(renderPass);

        const addressBloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.8, 0.4, 0.3); // Reduced bloom

        addressComposer.addPass(addressBloom);

        console.log('✅ Address composer created with bloom');

        

        // Handle window resize

        window.addEventListener('resize', () => {

            const width = window.innerWidth;

            const height = window.innerHeight;

            addressCamera.aspect = width / height;

            addressCamera.updateProjectionMatrix();

            addressRenderer.setSize(width, height);

            addressComposer.setSize(width, height);

            console.log('📐 Window resized:', width, 'x', height);

        });

        

        // Cell address data

        const addresses = [];

        const cubes = [];

        const maxAddresses = 20000; // Increased for 26x26x26 grid (17,576 total)

        let addressPhase = 0; // 0: 2D (A1, B2), 1: 3D (A1α, B2β)

        let cubePhase = false;

        

        // Greek letters for Z-axis

        const greekLetters = ['α', 'β', 'γ', 'δ', 'ε', 'ζ', 'η', 'θ', 'ι', 'κ', 'λ', 'μ', 'ν', 'ξ', 'ο', 'π', 'ρ', 'σ', 'τ', 'υ', 'φ', 'χ', 'ψ', 'ω'];

        

        // Create text sprites for cell addresses using CELLI notation

        function createAddressSprite(col, row, depth, is3D) {

            const canvas = document.createElement('canvas');

            const ctx = canvas.getContext('2d');

            canvas.width = 256;

            canvas.height = 128;

            

            // Transparent background

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            

            ctx.fillStyle = '#00ff00'; // Bright green

            ctx.font = 'bold 48px "Courier New", monospace'; // Larger font

            ctx.textAlign = 'center';

            ctx.textBaseline = 'middle';

            

            // Convert to cell notation: A1, B2, C3, etc.

            const colLetter = String.fromCharCode(65 + (col % 26)); // A, B, C...

            const rowNum = row + 1;

            const text = is3D ? `${colLetter}${rowNum}${greekLetters[depth % greekLetters.length]}` : `${colLetter}${rowNum}`;

            ctx.fillText(text, 128, 64);

            

            const texture = new THREE.CanvasTexture(canvas);

            texture.needsUpdate = true;

            const spriteMat = new THREE.SpriteMaterial({ 

                map: texture, 

                transparent: true, 

                opacity: 1.0,

                depthTest: false,

                depthWrite: false

            });

            const sprite = new THREE.Sprite(spriteMat);

            sprite.scale.set(3.5, 1.75, 1); // Larger sprites

            sprite.renderOrder = 1000; // Render on top

            

            return sprite;

        }

        

        // Create geometries for shape-shifting

        const cubeGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);

        const pyramidGeo = new THREE.ConeGeometry(0.35, 0.6, 4);

        pyramidGeo.rotateY(Math.PI / 4);

        const sphereGeo = new THREE.SphereGeometry(0.35, 16, 16);

        

        const greenMat = new THREE.MeshStandardMaterial({ color: 0x00ff00, transparent: true, opacity: 0.9, emissive: 0x00ff00, emissiveIntensity: 0.5, metalness: 0.3, roughness: 0.4 });

        const yellowMat = new THREE.MeshStandardMaterial({ color: 0xffff00, transparent: true, opacity: 0.9, emissive: 0xffff00, emissiveIntensity: 0.5, metalness: 0.3, roughness: 0.4 });

        const blueMat = new THREE.MeshStandardMaterial({ color: 0x0088ff, transparent: true, opacity: 0.9, emissive: 0x0088ff, emissiveIntensity: 0.5, metalness: 0.3, roughness: 0.4 });

        const redMat = new THREE.MeshStandardMaterial({ color: 0xff0000, transparent: true, opacity: 0.9, emissive: 0xff0000, emissiveIntensity: 0.5, metalness: 0.3, roughness: 0.4 });

        const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.9, emissive: 0xffffff, emissiveIntensity: 0.5, metalness: 0.3, roughness: 0.4 });

        

        // Add lights for 3D visibility

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);

        addressScene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 1.2, 100);

        pointLight.position.set(0, 0, 10);

        addressScene.add(pointLight);

        

        // Add additional lights for better visibility

        const pointLight2 = new THREE.PointLight(0xffffff, 0.8, 100);

        pointLight2.position.set(15, 15, 15);

        addressScene.add(pointLight2);

        

        const pointLight3 = new THREE.PointLight(0xffffff, 0.8, 100);

        pointLight3.position.set(-15, -15, -15);

        addressScene.add(pointLight3);

        

        // Grid configuration - Full 26x26x26 cube

        const gridSpacing = 2.5;

        const gridSize = { cols: 26, rows: 26, depth: 26 }; // Full cube: 17,576 positions (26x26x26)

        const gridPositions = [];

        

        // Pre-calculate all grid positions - TRULY centered around origin
        console.log('%c🔷 GRID SIZE VERIFIED: 26x26x26 🔷', 'background: #0000ff; color: #fff; font-size: 16px; padding: 5px;');
        console.log('🏗️ Building grid with:', gridSize);
        console.log('📊 Expected total positions: 26×26×26 =', 26*26*26);

        for (let col = 0; col < gridSize.cols; col++) {

            for (let row = 0; row < gridSize.rows; row++) {

                for (let depth = 0; depth < gridSize.depth; depth++) {

                    // Center calculation: use middle of range as origin

                    const x = (col - (gridSize.cols - 1) / 2) * gridSpacing;

                    const y = (row - (gridSize.rows - 1) / 2) * gridSpacing;

                    const z = (depth - (gridSize.depth - 1) / 2) * gridSpacing * 1.0; // Equal spacing for cube shape

                    

                    gridPositions.push({

                        col: col,

                        row: row,

                        depth: depth,

                        x: x,

                        y: y,

                        z: z

                    });

                }

            }

        }
        
        // Verify grid was generated correctly
        console.log('🔧 Grid generation complete:');
        console.log('  Config:', gridSize);
        console.log('  Total positions generated:', gridPositions.length);
        console.log('  Expected (26x26x26):', 26*26*26, '= 17,576');
        const depth0Count = gridPositions.filter(p => p.depth === 0).length;
        console.log('  Depth 0 positions:', depth0Count, 'Expected (26x26):', 26*26, '= 676');

        

        console.log('📍 Grid bounds:');

        console.log('  X range:', (0 - gridSize.cols / 2 + 0.5) * gridSpacing, 'to', (gridSize.cols - 1 - gridSize.cols / 2 + 0.5) * gridSpacing);

        console.log('  Y range:', (0 - gridSize.rows / 2 + 0.5) * gridSpacing, 'to', (gridSize.rows - 1 - gridSize.rows / 2 + 0.5) * gridSpacing);

        console.log('  Z range: 0 to', (gridSize.depth - 1) * gridSpacing * 2.5);

        console.log('📍 Sample positions:');

        console.log('  Corner (0,0,0):', gridPositions[0]);

        console.log('  Center (~10,6,7):', gridPositions[Math.floor(gridPositions.length / 2)]);

        console.log('  Far (19,11,14):', gridPositions[gridPositions.length - 1]);

        

        // Shuffle ONLY within each depth layer for organized appearance

        const layers = {};

        gridPositions.forEach(pos => {

            if (!layers[pos.depth]) layers[pos.depth] = [];

            layers[pos.depth].push(pos);

        });

        

        // Shuffle each layer

        Object.values(layers).forEach(layer => {

            for (let i = layer.length - 1; i > 0; i--) {

                const j = Math.floor(Math.random() * (i + 1));

                [layer[i], layer[j]] = [layer[j], layer[i]];

            }

        });

        

        // Rebuild gridPositions in depth order

        gridPositions.length = 0;

        for (let depth = 0; depth < gridSize.depth; depth++) {

            if (layers[depth]) {

                gridPositions.push(...layers[depth]);

            }

        }
        
        // Verify layer distribution after shuffle
        console.log('🔄 After shuffle:');
        console.log('  Total positions:', gridPositions.length);
        console.log('  Depth 0 count:', layers[0] ? layers[0].length : 0);
        if (layers[0]) {
            const d0Cols = [...new Set(layers[0].map(p => p.col))].sort((a,b) => a-b);
            const d0Rows = [...new Set(layers[0].map(p => p.row))].sort((a,b) => a-b);
            console.log('  Depth 0 unique columns:', d0Cols.length, 'Range:', d0Cols[0], 'to', d0Cols[d0Cols.length-1]);
            console.log('  Depth 0 unique rows:', d0Rows.length, 'Range:', d0Rows[0], 'to', d0Rows[d0Rows.length-1]);
        }

        

        const maxZ = (gridSize.depth - 1) * gridSpacing * 2.5;

        const centerZ = 0; // Grid is now centered at origin

        

        console.log('📍 Grid setup:', gridSize, 'Total positions:', gridPositions.length);

        console.log('📍 Grid centered at origin (0, 0, 0)');

        console.log('📍 X range:', -(gridSize.cols - 1) / 2 * gridSpacing, 'to', (gridSize.cols - 1) / 2 * gridSpacing);

        console.log('📍 Y range:', -(gridSize.rows - 1) / 2 * gridSpacing, 'to', (gridSize.rows - 1) / 2 * gridSpacing);

        console.log('📍 Z range:', -maxZ / 2, 'to', maxZ / 2);

        

        // Add visual debug helpers

        const helpers = new THREE.Group();

        

        // Add axes helper at origin

        const axesHelper = new THREE.AxesHelper(30);

        helpers.add(axesHelper);

        

        // Add grid at z=0

        const gridHelper = new THREE.GridHelper(

            gridSize.cols * gridSpacing, 

            gridSize.cols, 

            0x00ff00, 

            0x004400

        );

        gridHelper.rotation.x = Math.PI / 2;

        helpers.add(gridHelper);

        

        // Add bounding box visualization - centered properly (CUBE shape with GREEN glow)

        const depthRange = (gridSize.depth - 1) * gridSpacing * 1.0; // Equal depth

        const boxGeo = new THREE.BoxGeometry(

            gridSize.cols * gridSpacing,

            gridSize.rows * gridSpacing,

            depthRange

        );

        const boxMat = new THREE.MeshBasicMaterial({ 

            color: 0x00ff00, // GREEN not cyan

            wireframe: true, 

            transparent: true, 

            opacity: 0.6 

        });

        const boundingBox = new THREE.Mesh(boxGeo, boxMat);

        boundingBox.position.set(0, 0, 0); // Centered at origin

        helpers.add(boundingBox);

        

        // Add markers at each depth layer

        for (let d = 0; d < gridSize.depth; d++) {

            const markerGeo = new THREE.PlaneGeometry(0.5, 0.5);

            const markerMat = new THREE.MeshBasicMaterial({ 

                color: d === 0 ? 0xff0000 : 0x00ff00, // GREEN markers

                transparent: true,

                opacity: 0.6

            });

            const marker = new THREE.Mesh(markerGeo, markerMat);

            const markerZ = (d - (gridSize.depth - 1) / 2) * gridSpacing * 1.0; // Match equal Z

            marker.position.set(

                -gridSize.cols * gridSpacing / 2 + 1,

                gridSize.rows * gridSpacing / 2 - 1,

                markerZ

            );

            helpers.add(marker);

        }

        

        // Start debug helpers hidden - they'll glitch in

        helpers.visible = false;

        addressScene.add(helpers);

        addressScene.userData.debugHelpers = helpers;

        

        let gridIndex = 0;

        

        // Spawn addresses gradually

        let spawnTimer = 0;

        const spawnInterval = 0.01; // Faster spawning for 26x26 grid

        

        const clock = new THREE.Clock();

        let sequenceTime = 0;
        
        // Expose sequenceTime globally for scene jumps
        window.addressSequenceTime = 0;

        let cameraRotating = false;

        

        // Camera will look at origin - grid is centered

        const gridCenter = new THREE.Vector3(0, 0, 0);

        const actualCenterX = 0;

        const actualCenterY = 0;

        const actualCenterZ = 0;

        

        // Position camera to see the ENTIRE grid PERFECTLY CENTERED

        // Grid is 26x26x26 cubes, spacing 2.5 = 65x65x65 units, centered at origin

        addressCamera.position.set(0, 0, -120); // Much further back to see full 26x26x26 cube

        addressCamera.lookAt(0, 0, 0); // Look directly at origin

        addressCamera.updateProjectionMatrix();

        

        console.log('📷 Camera at (0, 0, -120) looking at origin (0, 0, 0)');

        console.log('📷 Grid: 26x26x26, 65x65x65 units, centered at (0,0,0)');

        console.log('📷 Camera FOV:', addressCamera.fov, 'Aspect:', addressCamera.aspect);

        console.log('🎬 Grid should be PERFECTLY CENTERED in view');

        

        // Chime function for cube burst

        function playChimeForCube(index) {

            if (!audioCtx) return;

            try {

                const osc = audioCtx.createOscillator();

                const gain = audioCtx.createGain();

                

                const baseFreq = 800;

                const freq = baseFreq + (index % 12) * 50;

                osc.frequency.value = freq;

                osc.type = 'sine';

                

                gain.gain.setValueAtTime(0.03, audioCtx.currentTime);

                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);

                

                osc.connect(gain);

                gain.connect(audioCtx.destination);

                osc.start(audioCtx.currentTime);

                osc.stop(audioCtx.currentTime + 0.3);

            } catch (err) {

                // Silently fail if audio context not available

            }

        }

        

        function animateAddresses() {

            const delta = clock.getDelta();
            
            // Check if scene select requested a jump
            if (window.addressSequenceTime && window.addressSequenceTime > sequenceTime) {
                sequenceTime = window.addressSequenceTime;
                console.log('⏩ Jumped to sequenceTime:', sequenceTime);
            }

            sequenceTime += delta;
            
            // Sync with global variable
            window.addressSequenceTime = sequenceTime;

            spawnTimer += delta;

            

            // Debug log every second with camera position

            if (Math.floor(sequenceTime) !== Math.floor(sequenceTime - delta)) {

                console.log(`⏱️ ${sequenceTime.toFixed(1)}s | Addresses: ${addresses.length}, Cubes: ${cubes.length} | Cam: (${addressCamera.position.x.toFixed(1)}, ${addressCamera.position.y.toFixed(1)}, ${addressCamera.position.z.toFixed(1)})`);

            }

            

            // Fade debug helpers after 20s

            if (sequenceTime > 20 && addressScene.userData.debugHelpers) {

                addressScene.userData.debugHelpers.visible = false;

            }

            

            // Phase 1: Spawn 2D addresses on grid (0-10s) - Fill the 2D plane ONLY - Extended time for 26x26 grid

            if (sequenceTime < 10 && spawnTimer > spawnInterval) {

                spawnTimer = 0;

                

                // Spawn multiple addresses per frame for faster fill (26x26 = 676 addresses)
                for (let batchCount = 0; batchCount < 20; batchCount++) {

                    // Find next depth=0 position

                    while (gridIndex < gridPositions.length && gridPositions[gridIndex].depth !== 0) {

                        gridIndex++;

                    }

                    

                    if (gridIndex < gridPositions.length) {

                        const pos = gridPositions[gridIndex];

                        const sprite = createAddressSprite(pos.col, pos.row, 0, false);

                        sprite.position.set(pos.x, pos.y, pos.z); // Use pos.z from grid calculation

                        sprite.userData = { ...pos, isCube: false, gridX: pos.col, gridY: pos.row, gridZ: 0, depth: 0 };

                        addressScene.add(sprite);

                        addresses.push(sprite);

                        

                        if (addresses.length === 1) {

                            console.log('✅ First 2D address spawned:', { x: pos.x.toFixed(2), y: pos.y.toFixed(2), z: pos.z.toFixed(2), text: `${String.fromCharCode(65 + pos.col)}${pos.row + 1}` });

                            console.log('📷 Camera is at:', addressCamera.position);

                            console.log('📷 Camera is looking at: (0, 0, 0)');

                        }

                        if (addresses.length <= 5) {

                            console.log(`📍 Address #${addresses.length} at (${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})`);

                        }
                        
                        // Log when we reach milestones
                        if (pos.col === 9 || pos.col === 19 || pos.col === 25) {
                            console.log(`✅ Reached column ${String.fromCharCode(65 + pos.col)} (col ${pos.col}) - Address #${addresses.length}`);
                        }
                        
                        // Log every 100 addresses with current range
                        if (addresses.length % 100 === 0) {
                            const currentCols = addresses.map(a => a.userData.col).filter(c => c !== undefined);
                            const maxColSoFar = Math.max(...currentCols);
                            console.log(`📊 ${addresses.length} addresses | Max column so far: ${String.fromCharCode(65 + maxColSoFar)} (${maxColSoFar})`);
                        }

                        gridIndex++;

                    } else {
                        break; // No more depth=0 positions
                    }
                }

            }
            
            // Log when 2D plane is complete
            if (sequenceTime >= 10 && sequenceTime < 10.1 && !addressScene.userData.plane2DComplete) {
                addressScene.userData.plane2DComplete = true;
                const maxCol = Math.max(...addresses.map(a => a.userData.col !== undefined ? a.userData.col : -1));
                const maxRow = Math.max(...addresses.map(a => a.userData.row !== undefined ? a.userData.row : -1));
                const minCol = Math.min(...addresses.map(a => a.userData.col !== undefined ? a.userData.col : 999));
                const minRow = Math.min(...addresses.map(a => a.userData.row !== undefined ? a.userData.row : 999));
                console.log(`✅ 2D Plane complete! ${addresses.length} addresses spawned`);
                console.log(`📊 Column range: ${String.fromCharCode(65 + minCol)} (${minCol}) to ${String.fromCharCode(65 + maxCol)} (${maxCol})`);
                console.log(`📊 Row range: ${minRow + 1} to ${maxRow + 1}`);
                console.log(`📊 Expected: 676 addresses (26x26), Got: ${addresses.length}`);
            }

            

                // No rotation for addresses - they just float in place

            // (rotation removed per user request)

            

            // Phase 1.5: Static pause showing 2D grid (10-12s) with RUMBLE before expansion

            if (sequenceTime >= 10 && sequenceTime < 12) {

                if (!addressScene.userData.staticPauseStarted) {

                    addressScene.userData.staticPauseStarted = true;

                    console.log('⏸️ Static pause - showing 2D grid, building tension');

                    

                    // Glitch in debug helpers

                    let glitchCount = 0;

                    const glitchInterval = setInterval(() => {

                        if (addressScene.userData.debugHelpers) {

                            addressScene.userData.debugHelpers.visible = !addressScene.userData.debugHelpers.visible;

                            glitchCount++;

                            if (glitchCount > 6) {

                                addressScene.userData.debugHelpers.visible = true;

                                clearInterval(glitchInterval);

                            }

                        }

                    }, 100);

                }

                

                // RUMBLE effect BEFORE Z expansion (11-12s) - building anticipation

                if (sequenceTime >= 11 && sequenceTime < 12) {

                    const rumbleIntensity = (sequenceTime - 11) * 1.2; // Stronger rumble

                    addressCamera.position.x = Math.sin(sequenceTime * 25) * rumbleIntensity;

                    addressCamera.position.y = Math.cos(sequenceTime * 20) * rumbleIntensity;

                    addressCamera.position.z = -120;

                    addressCamera.lookAt(0, 0, 0);

                    

                    if (!addressScene.userData.rumbleLogged) {

                        console.log('📳 RUMBLE starting - preparing for Z expansion!');

                        addressScene.userData.rumbleLogged = true;

                    }

                    

                    // Alpha character glitch - show Greek letters on 2D addresses during rumble

                    if (!addressScene.userData.alphaGlitchStarted) {

                        addressScene.userData.alphaGlitchStarted = true;

                        console.log('✨ Alpha glitch starting - 2D addresses showing depth markers');

                        

                        addresses.forEach((addr, i) => {

                            if (addr.userData.depth === 0 && !addr.userData.isGlitching) {

                                addr.userData.isGlitching = true;

                                addr.userData.originalTexture = addr.material.map;

                                

                                // Schedule random glitch times during rumble

                                const glitchDelay = Math.random() * 800;

                                setTimeout(() => {

                                    // Create temporary 3D label with Greek letter

                                    const canvas = document.createElement('canvas');

                                    const ctx = canvas.getContext('2d');

                                    canvas.width = 256;

                                    canvas.height = 128;

                                    

                                    ctx.fillStyle = '#00ff00';

                                    ctx.font = 'bold 48px "Courier New", monospace';

                                    ctx.textAlign = 'center';

                                    ctx.textBaseline = 'middle';

                                    

                                    const colLetter = String.fromCharCode(65 + (addr.userData.col % 26));

                                    const rowNum = addr.userData.row + 1;

                                    const randomDepth = Math.floor(Math.random() * gridSize.depth);

                                    const greekLetter = greekLetters[randomDepth % greekLetters.length];

                                    const glitchText = `${colLetter}${rowNum}${greekLetter}`;

                                    

                                    ctx.fillText(glitchText, 128, 64);

                                    

                                    const glitchTexture = new THREE.CanvasTexture(canvas);

                                    glitchTexture.needsUpdate = true;

                                    

                                    // Flash between original and glitch

                                    let flashCount = 0;

                                    const flashInterval = setInterval(() => {

                                        if (flashCount % 2 === 0) {

                                            addr.material.map = glitchTexture;

                                        } else {

                                            addr.material.map = addr.userData.originalTexture;

                                        }

                                        addr.material.needsUpdate = true;

                                        flashCount++;

                                        

                                        if (flashCount > 6) { // Flash 3 times

                                            clearInterval(flashInterval);

                                            addr.material.map = addr.userData.originalTexture;

                                            addr.material.needsUpdate = true;

                                            addr.userData.isGlitching = false;

                                        }

                                    }, 80);

                                }, glitchDelay);

                            }

                        });

                    }

                } else {

                    // Keep camera centered during first part of pause

                    addressCamera.position.set(0, 0, -80);

                    addressCamera.lookAt(0, 0, 0);

                }

            }

            

            // Phase 2: Extend into 3D - add ALL depth layers (12-18s)

            if (sequenceTime >= 12 && sequenceTime < 18) {

                if (addressPhase === 0) {

                    addressPhase = 1;

                    

                    // Create depth spawn queue - all positions with depth > 0

                    addressScene.userData.depthQueue = gridPositions.filter(p => p.depth > 0);

                    console.log('🔷 Extending to 3D - depth queue:', addressScene.userData.depthQueue.length, 'positions');

                    console.log('🔷 Depth range:', Math.min(...addressScene.userData.depthQueue.map(p => p.depth)), 

                                'to', Math.max(...addressScene.userData.depthQueue.map(p => p.depth)));

                }

                

                // Keep camera steady after rumble - Z expansion happens NOW

                addressCamera.position.set(0, 0, -120);

                addressCamera.lookAt(0, 0, 0);

                

                // Spawn ALL depth layers RAPIDLY to fill 3D space (multiple per frame)

                const spawnCount = Math.ceil((sequenceTime - 12) * 500); // Much faster spawn for 26x26x26 grid

                for (let i = 0; i < spawnCount && addressScene.userData.depthQueue && addressScene.userData.depthQueue.length > 0; i++) {

                    const pos = addressScene.userData.depthQueue.shift();

                    const sprite = createAddressSprite(pos.col, pos.row, pos.depth, true);

                    sprite.position.set(pos.x, pos.y, pos.z); // Use actual Z position

                    sprite.userData = { ...pos, isCube: false, gridX: pos.col, gridY: pos.row, gridZ: pos.depth };

                    addressScene.add(sprite);

                    addresses.push(sprite);

                    

                    if (addresses.length % 200 === 0) {

                        console.log(`📌 Total: ${addresses.length}, Latest: (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}) depth ${pos.depth}/${gridSize.depth - 1}`);

                    }

                }

            }

            

            // Phase 2.5: Camera pulls back and rotates to reveal LATTICE CUBE (16-20s)

            if (sequenceTime >= 16 && sequenceTime < 20) {

                if (!addressScene.userData.rotationStarted) {

                    addressScene.userData.rotationStarted = true;

                    console.log('🔄 Starting camera rotation to reveal lattice cube');

                    console.log('📊 Total addresses in lattice:', addresses.length);

                }

                

                const rotProgress = (sequenceTime - 16) / 4;

                // Pull back further and orbit to reveal massive 26x26x26 lattice

                addressCamera.position.x = THREE.MathUtils.lerp(0, 70, rotProgress);

                addressCamera.position.y = THREE.MathUtils.lerp(0, 35, rotProgress);

                addressCamera.position.z = THREE.MathUtils.lerp(-120, -25, rotProgress);

                addressCamera.lookAt(0, 0, 0); // Always look at center

            }

            

            // Phase 3: Initialize organic infection system (20s)

            if (sequenceTime >= 20 && !cubePhase) {

                cubePhase = true;

                console.log('🦠 INFECTION SYSTEM: Starting organic cube transformation');

                

                // Create infection queue and grid lookup

                addressScene.userData.infectionQueue = [];

                addressScene.userData.infectedAddresses = new Set();

                addressScene.userData.addressMap = new Map();

                

                // Build address map for neighbor lookup

                addresses.forEach(addr => {

                    const key = `${addr.userData.col},${addr.userData.row},${addr.userData.depth}`;

                    addressScene.userData.addressMap.set(key, addr);

                });

                

                // Seed random infection points (about 3-5% of addresses)

                const seedCount = Math.floor(addresses.length * 0.04);

                const seeds = [];

                for (let i = 0; i < seedCount; i++) {

                    const randomIndex = Math.floor(Math.random() * addresses.length);

                    const addr = addresses[randomIndex];

                    if (addr && !addressScene.userData.infectedAddresses.has(addr)) {

                        seeds.push(addr);

                        addressScene.userData.infectedAddresses.add(addr);

                        addressScene.userData.infectionQueue.push({

                            address: addr,

                            infectionTime: sequenceTime + Math.random() * 0.5, // Stagger seeds slightly

                            color: 'green', // Seeds start green

                            sourceDirection: null

                        });

                    }

                }

                

                console.log(`🦠 Seeded ${seeds.length} infection points`);

                addressScene.userData.infectionSpeed = 0.03; // Time between infection spreads

                addressScene.userData.lastInfectionTime = sequenceTime;

            }

            

            // Execute POP transformations: Text → GREEN cubes (20-24s)

            if (sequenceTime >= 20 && sequenceTime < 24) {

                for (let i = addresses.length - 1; i >= 0; i--) {

                    const addr = addresses[i];

                    

                    if (addr.userData.popTime && sequenceTime >= addr.userData.popTime && !addr.userData.popped) {

                        addr.userData.popped = true;

                        

                        // Create GREEN cube

                        const mesh = new THREE.Mesh(cubeGeo, greenMat.clone());

                        mesh.position.copy(addr.position);

                        mesh.userData = { 

                            ...addr.userData,

                            isCube: true,

                            isGreen: true,

                            hasTransformed: false, // Not yet transformed to RGB

                            currentColor: 'green',

                            shapeType: 'cube',

                            birthTime: sequenceTime

                        };

                        

                        // Start small for pop effect

                        mesh.scale.set(0.05, 0.05, 0.05);

                        addressScene.add(mesh);

                        cubes.push(mesh);

                        

                        // Play chime occasionally (not for every cube to avoid audio overload)

                        if (cubes.length % 30 === 0) {

                            playChimeForCube(cubes.length);

                        }

                        

                        // Remove text address

                        addressScene.remove(addr);

                        addresses.splice(i, 1);

                    }

                }

            }

            

            // CLEANUP: Force remove ALL remaining text addresses at 24s

            if (sequenceTime >= 24 && sequenceTime < 24.1 && addresses.length > 0) {

                console.log('🗑️ CLEANUP: Removing', addresses.length, 'residual text addresses');

                for (let i = addresses.length - 1; i >= 0; i--) {

                    addressScene.remove(addresses[i]);

                    if (addresses[i].material && addresses[i].material.map) {

                        addresses[i].material.map.dispose();

                    }

                    if (addresses[i].material) {

                        addresses[i].material.dispose();

                    }

                }

                addresses.length = 0; // Clear array

                console.log('✅ All text addresses cleared');

            }

            

            // Animate green cube pop-in with burst (20s-26s)

            if (sequenceTime >= 20 && sequenceTime < 26) {

                cubes.forEach((cube, i) => {

                    if (!cube.userData.isGreen) return; // Only animate green cubes

                    

                    const age = sequenceTime - cube.userData.birthTime;

                    

                    // Quick pop-in animation (0-0.3s)

                    if (age < 0.3) {

                        // Burst scale: overshoot then settle

                        const progress = age / 0.3;

                        const overshoot = 1.3; // Peak size

                        let targetScale;

                        if (progress < 0.5) {

                            targetScale = THREE.MathUtils.lerp(0.05, overshoot, progress * 2);

                        } else {

                            targetScale = THREE.MathUtils.lerp(overshoot, 1.0, (progress - 0.5) * 2);

                        }

                        cube.scale.setScalar(targetScale);

                        

                        // Bright burst illumination

                        if (cube.material) {

                            const intensity = Math.sin(progress * Math.PI) * 3.0;

                            cube.material.emissiveIntensity = 0.5 + intensity;

                        }

                    } else if (age < 0.35 && cube.scale.x !== 1.0) {

                        // Settle to final size

                        cube.scale.setScalar(1.0);

                        if (cube.material) {

                            cube.material.emissiveIntensity = 0.5;

                        }

                    }

                });

            }

            

            // Phase 4: GREEN cubes glitch into RGB shapes (26s-30s)

            if (sequenceTime >= 26 && sequenceTime < 30) {

                cubes.forEach((cube, i) => {

                    if (cube.userData.isGreen && !cube.userData.glitchStarted) {

                        cube.userData.glitchStarted = true;

                        cube.userData.glitchTime = sequenceTime + (i * 0.002); // Faster stagger glitches

                    }

                    

                    if (cube.userData.glitchStarted && !cube.userData.hasTransformed && sequenceTime >= cube.userData.glitchTime) {

                        cube.userData.hasTransformed = true;

                        

                        // Select shape and color based on pre-assigned targetShape

                        let geo, mat, colorName, shapeName;

                        if (cube.userData.targetShape === 0) {

                            geo = pyramidGeo;

                            mat = yellowMat.clone();

                            colorName = 'yellow';

                            shapeName = 'pyramid';

                        } else if (cube.userData.targetShape === 1) {

                            geo = cubeGeo;

                            mat = blueMat.clone();

                            colorName = 'blue';

                            shapeName = 'cube';

                        } else {

                            geo = sphereGeo;

                            mat = redMat.clone();

                            colorName = 'red';

                            shapeName = 'sphere';

                        }

                        

                        // Replace mesh

                        const pos = cube.position.clone();

                        const userData = { ...cube.userData };

                        

                        addressScene.remove(cube);

                        if (cube.geometry) cube.geometry.dispose();

                        if (cube.material) cube.material.dispose();

                        

                        const newMesh = new THREE.Mesh(geo, mat);

                        newMesh.position.copy(pos);

                        newMesh.scale.set(1.0, 1.0, 1.0); // Always start at normal scale

                        newMesh.userData = {

                            ...userData,

                            isGreen: false,

                            currentColor: colorName,

                            shapeType: shapeName,

                            glitchTransformTime: sequenceTime

                        };

                        

                        addressScene.add(newMesh);

                        

                        // Replace in cubes array

                        const cubeIndex = cubes.indexOf(cube);

                        if (cubeIndex !== -1) {

                            cubes[cubeIndex] = newMesh;

                        }

                    }

                });

            }

            

            // Animate glitch transformation (26s-30s)

            if (sequenceTime >= 26 && sequenceTime < 30) {

                cubes.forEach((cube) => {

                    if (cube.userData.glitchTransformTime) {

                        const glitchAge = sequenceTime - cube.userData.glitchTransformTime;

                        

                        if (glitchAge < 0.2) {

                            // Quick stretch/distort glitch

                            const glitchProgress = glitchAge / 0.2;

                            const distort = Math.sin(glitchProgress * Math.PI * 4) * 0.3;

                            cube.scale.x = 1.0 + distort;

                            cube.scale.y = 1.0 - distort * 0.5;

                            cube.scale.z = 1.0 + distort * 0.5;

                            

                            // Flash emissive

                            if (cube.material) {

                                cube.material.emissiveIntensity = 0.5 + Math.sin(glitchProgress * Math.PI) * 2.0;

                            }

                        } else if (glitchAge < 0.25 && cube.scale.x !== 1.0) {

                            // Snap to final shape

                            cube.scale.set(1.0, 1.0, 1.0);

                            if (cube.material) {

                                cube.material.emissiveIntensity = 0.5;

                            }

                        }

                    }

                });

            }

            

            // Draw dotted lines between RGB cubes (forming cube edges) ONCE (30s)

            if (sequenceTime >= 30 && !addressScene.userData.linesCreated) {

                addressScene.userData.linesCreated = true;

                addressScene.userData.connectionLines = [];

                console.log('🔗 Creating procedural connection lines...');

                

                // Build grid lookup for immediate neighbors

                const gridMap = new Map();

                cubes.forEach(cube => {

                    if (cube.userData.gridX !== undefined) {

                        const key = `${cube.userData.gridX},${cube.userData.gridY},${cube.userData.gridZ}`;

                        gridMap.set(key, cube);

                    }

                });

                

                // Track connections to avoid duplicates

                const connections = new Set();

                let lineCount = 0;

                

                // Draw lines to immediate neighbors for RGB cubes (ONCE)

                cubes.forEach(cube => {

                    if (cube.userData.gridX !== undefined && cube.userData.currentColor && cube.userData.hasTransformed) {

                        const gx = cube.userData.gridX;

                        const gy = cube.userData.gridY;

                        const gz = cube.userData.gridZ;

                        

                        // Check only positive direction neighbors to avoid duplicates (right, up, forward)

                        const neighbors = [

                            { key: `${gx+1},${gy},${gz}`, axis: 'x' },

                            { key: `${gx},${gy+1},${gz}`, axis: 'y' },

                            { key: `${gx},${gy},${gz+1}`, axis: 'z' }

                        ];

                        

                        neighbors.forEach(neighbor => {

                            const neighborCube = gridMap.get(neighbor.key);

                            if (neighborCube && neighborCube.userData.currentColor && neighborCube.userData.hasTransformed) {

                                const connectionKey = `${cube.userData.gridX},${cube.userData.gridY},${cube.userData.gridZ}-${neighborCube.userData.gridX},${neighborCube.userData.gridY},${neighborCube.userData.gridZ}`;

                                if (!connections.has(connectionKey)) {

                                    connections.add(connectionKey);

                                    

                                    // Use average color of both cubes

                                    let lineColor;

                                    if (cube.userData.currentColor === 'yellow') lineColor = 0xffff00;

                                    else if (cube.userData.currentColor === 'blue') lineColor = 0x0088ff;

                                    else if (cube.userData.currentColor === 'red') lineColor = 0xff0000;

                                    else lineColor = 0x00ff00;

                                    

                                    const points = [cube.position, neighborCube.position];

                                    const lineGeo = new THREE.BufferGeometry().setFromPoints(points);

                                    const lineMat = new THREE.LineDashedMaterial({

                                        color: lineColor,

                                        dashSize: 0.12,

                                        gapSize: 0.08,

                                        transparent: true,

                                        opacity: 0.5

                                    });

                                    const line = new THREE.Line(lineGeo, lineMat);

                                    line.computeLineDistances();

                                    addressScene.add(line);

                                    addressScene.userData.connectionLines.push(line);

                                    lineCount++;

                                }

                            }

                        });

                    }

                });

                console.log(`✅ Created ${lineCount} connection lines (procedural, once)`);

            }

            

            // Continue camera rotation after initial rotation (but stop during white room)

            if (sequenceTime >= 20 && sequenceTime < 50) {

                const orbitTime = sequenceTime - 20;

                const orbitRadius = 90; // Much larger radius for massive 26x26x26 cube

                addressCamera.position.x = Math.cos(orbitTime * 0.15) * orbitRadius;

                addressCamera.position.z = Math.sin(orbitTime * 0.15) * orbitRadius;

                addressCamera.position.y = 15 + Math.sin(orbitTime * 0.08) * 8; // Higher orbit

                addressCamera.lookAt(0, 0, 0);

            }

            

            // Apply mouse look in white room

            if (isMouseLookActive && sequenceTime > 55) {

                // Apply rotation to camera

                const direction = new THREE.Vector3();

                direction.x = Math.sin(targetRotationY) * Math.cos(targetRotationX);

                direction.y = Math.sin(targetRotationX);

                direction.z = Math.cos(targetRotationY) * Math.cos(targetRotationX);

                direction.normalize();

                

                const lookAtPoint = new THREE.Vector3().addVectors(

                    addressCamera.position,

                    direction.multiplyScalar(10)

                );

                addressCamera.lookAt(lookAtPoint);

                

                if (Math.floor(sequenceTime) % 3 === 0 && Math.floor(sequenceTime) !== Math.floor(sequenceTime - delta)) {

                    console.log(`🖱️ Mouse look active - rotX: ${targetRotationX.toFixed(2)}, rotY: ${targetRotationY.toFixed(2)}`);

                }

            } else if (sequenceTime >= 55 && !isMouseLookActive) {

                // Point at black hole when not actively looking

                addressCamera.lookAt(0, 0, 0);

            }

            

            // Phase 5: Transform RGB shapes back to white cubes (36-40s)

            if (sequenceTime >= 36 && sequenceTime < 40) {

                cubes.forEach((cube, i) => {

                    if (cube.userData.hasTransformed && !cube.userData.zapToWhite) {

                        cube.userData.zapToWhite = true;

                        

                        // Quick zap animation

                        const originalScale = { x: cube.scale.x, y: cube.scale.y, z: cube.scale.z };

                        cube.scale.multiplyScalar(1.5);

                        

                        setTimeout(() => {

                            const pos = cube.position.clone();

                            const userData = { ...cube.userData };

                            

                            addressScene.remove(cube);

                            const whiteCube = new THREE.Mesh(cubeGeo, whiteMat.clone());

                            whiteCube.position.copy(pos);

                            whiteCube.scale.set(originalScale.x, originalScale.y, originalScale.z);

                            whiteCube.userData = userData;

                            whiteCube.userData.isWhite = true;

                            addressScene.add(whiteCube);

                            cubes[i] = whiteCube;

                        }, 100);

                    }

                });

            }

            

            // Phase 6: Collapse cubes to center - NO rotation

            if (sequenceTime >= 40 && sequenceTime < 44) {

                const pullStrength = (sequenceTime - 40) / 4;

                cubes.forEach(cube => {

                    cube.position.x = THREE.MathUtils.lerp(cube.position.x, 0, delta * pullStrength * 2);

                    cube.position.y = THREE.MathUtils.lerp(cube.position.y, 0, delta * pullStrength * 2);

                    cube.position.z = THREE.MathUtils.lerp(cube.position.z, 0, delta * pullStrength * 2);

                });

            }

            

            // Phase 7: Merge into single white rounded cube with bloom (44-50s)

            if (sequenceTime >= 44 && sequenceTime < 50) {

                const whiteness = Math.min(1, (sequenceTime - 44) / 3);

                addressBloom.strength = 1.2 + whiteness * 2.5; // Increase bloom more

                

                cubes.forEach((cube, i) => {

                    if (cube.material) {

                        // Fade to white

                        cube.material.color.r = 1;

                        cube.material.color.g = 1;

                        cube.material.color.b = 1;

                        cube.material.emissive.r = 1;

                        cube.material.emissive.g = 1;

                        cube.material.emissive.b = 1;

                        cube.material.emissiveIntensity = 0.5 + whiteness * 1.0;

                        

                        // Shrink all but the center mass

                        if (i > 15) {

                            cube.scale.multiplyScalar(0.96);

                            cube.material.opacity *= 0.95;

                        } else {

                            // First cubes grow MUCH LARGER

                            const growth = 1 + (sequenceTime - 44) * 0.8;

                            cube.scale.setScalar(growth);

                        }

                    }

                });

            }

            

            // Phase 8: Expand into white room interior (50-55s)

            if (sequenceTime >= 50 && sequenceTime < 55) {

                if (!addressScene.userData.roomCreated) {

                    addressScene.userData.roomCreated = true;

                    console.log('🏠 Creating FPS white room interior with rounded corners and internal lighting');

                    

                    // Remove all connection lines

                    if (addressScene.userData.connectionLines) {

                        addressScene.userData.connectionLines.forEach(line => {

                            addressScene.remove(line);

                            if (line.geometry) line.geometry.dispose();

                            if (line.material) line.material.dispose();

                        });

                        addressScene.userData.connectionLines = [];

                        console.log('🗑️ Connection lines removed for white room');

                    }

                    

                    addressScene.userData.blackCubeSpawnTimer = 0;

                    addressScene.userData.blackCubes = [];

                    

                    // Create white room interior with rounded corners - DIMLY LIT

                    const roomSize = 50;

                    const roomRadius = 4;

                    const roomGeo = new RoundedBoxGeometry(roomSize, roomSize, roomSize, 16, roomRadius);

                    const roomMat = new THREE.MeshStandardMaterial({

                        color: 0xcccccc, // Slightly gray

                        side: THREE.BackSide,

                        roughness: 0.9,

                        metalness: 0.05,

                        emissive: 0x333333, // Very dim emissive

                        emissiveIntensity: 0.05 // Very low

                    });

                    const room = new THREE.Mesh(roomGeo, roomMat);

                    addressScene.add(room);

                    addressScene.userData.roomMesh = room; // Store reference

                    

                    // Add MINIMAL internal room lighting - mostly dark

                    const roomLight1 = new THREE.PointLight(0xffffff, 0.2, 40);

                    roomLight1.position.set(0, 15, 0);

                    addressScene.add(roomLight1);

                    

                    const roomLight2 = new THREE.PointLight(0xffffff, 0.2, 40);

                    roomLight2.position.set(0, -15, 0);

                    addressScene.add(roomLight2);

                    

                    console.log('✅ White room created with DIM lighting');

                    

                    // Further reduce ambient lighting to let black hole dominate

                    ambientLight.intensity = 0.1;

                    pointLight.intensity = 0.1;

                    pointLight2.intensity = 0.2;

                    pointLight3.intensity = 0.2;

                    

                    console.log('🏠 Room created - dimming ambient lights for black hole visibility');

                    

                    console.log('✅ White room created with internal lighting');

                }

                

                // Move camera inside - FPS position, initially pointing AT the black hole

                if (!addressScene.userData.cameraMovingToRoom) {

                    addressScene.userData.cameraMovingToRoom = true;

                    console.log('📹 Camera moving into white room, will point at black hole at (0, 0, 0)');

                }

                

                const moveProgress = (sequenceTime - 50) / 5;

                addressCamera.position.x = THREE.MathUtils.lerp(12, 0, moveProgress);

                addressCamera.position.y = THREE.MathUtils.lerp(10, 2, moveProgress);

                addressCamera.position.z = THREE.MathUtils.lerp(20, 15, moveProgress);

                

                // Always point at black hole center during this phase

                addressCamera.lookAt(0, 0, 0);

                

                if (Math.floor(sequenceTime) % 2 === 0 && Math.floor(sequenceTime) !== Math.floor(sequenceTime - delta)) {

                    console.log(`📹 Camera pos: (${addressCamera.position.x.toFixed(1)}, ${addressCamera.position.y.toFixed(1)}, ${addressCamera.position.z.toFixed(1)}) -> looking at (0, 0, 0)`);

                }

                

                addressScene.userData.whiteRoomCreated = true;

            }

            

            // Phase 9: Create 3D black hole at center (55s+)

            if (sequenceTime >= 55 && !addressScene.userData.blackHoleCreated) {

                addressScene.userData.blackHoleCreated = true;

                console.log('🕳️ Creating 3D black hole sphere at center');

                

                // Voxelized black hole - dark cube sphere (MORE visible)

                const voxelSize = 0.4;

                const voxelGeo = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);

                const blackVoxelMat = new THREE.MeshStandardMaterial({

                    color: 0x222222, // More visible gray

                    emissive: 0x110000, // Slight red emissive

                    emissiveIntensity: 0.3,

                    roughness: 0.9,

                    metalness: 0.1,

                    transparent: false

                });

                

                const voxelSphere = new THREE.Group();

                const baseRadius = 3.0; // Larger

                const voxelCount = 400; // More voxels

                

                for (let i = 0; i < voxelCount; i++) {

                    const phi = Math.acos(-1 + (2 * i) / voxelCount);

                    const theta = Math.sqrt(voxelCount * Math.PI) * phi;

                    

                    const x = baseRadius * Math.cos(theta) * Math.sin(phi);

                    const y = baseRadius * Math.sin(theta) * Math.sin(phi);

                    const z = baseRadius * Math.cos(phi);

                    

                    const voxel = new THREE.Mesh(voxelGeo, blackVoxelMat.clone());

                    voxel.position.set(x, y, z);

                    voxel.lookAt(0, 0, 0);

                    voxel.userData.baseRadius = baseRadius;

                    voxel.userData.phi = phi;

                    voxel.userData.theta = theta;

                    voxelSphere.add(voxel);

                }

                

                addressScene.add(voxelSphere);

                addressScene.userData.voxelSphere = voxelSphere;

                addressScene.userData.voxelSpherePhase = 0;

                

                // Event horizon glow - EXTREMELY bright ring

                const ringGeo = new THREE.TorusGeometry(4.0, 0.5, 16, 100);

                const ringMat = new THREE.MeshBasicMaterial({

                    color: 0xff4400,

                    transparent: false,

                    opacity: 1.0

                });

                const eventHorizon = new THREE.Mesh(ringGeo, ringMat);

                eventHorizon.position.set(0, 0, 0);

                eventHorizon.rotation.x = Math.PI / 2;

                addressScene.add(eventHorizon);

                addressScene.userData.eventHorizon = eventHorizon;

                

                // Add VERY strong point lights at black hole for maximum visibility

                const blackHoleLight1 = new THREE.PointLight(0xff2200, 10.0, 30);

                blackHoleLight1.position.set(0, 0, 0);

                addressScene.add(blackHoleLight1);

                

                const blackHoleLight2 = new THREE.PointLight(0xff6600, 8.0, 25);

                blackHoleLight2.position.set(0, 5, 0);

                addressScene.add(blackHoleLight2);

                

                const blackHoleLight3 = new THREE.PointLight(0xff8800, 6.0, 20);

                blackHoleLight3.position.set(5, 0, 0);

                addressScene.add(blackHoleLight3);

                

                addressScene.userData.blackHoleLight = blackHoleLight1;

                

                console.log('🕳️ Black hole created at (0, 0, 0)');

                console.log('🕳️ Black hole lights: L1=' + blackHoleLight1.intensity + ', L2=' + blackHoleLight2.intensity + ', L3=' + blackHoleLight3.intensity);

                console.log('🕳️ Ambient light:', ambientLight.intensity);

                

                // BLACK CORE - Central black voxel sphere with negative pulsing effect

                const blackCoreGeo = new THREE.BoxGeometry(0.25, 0.25, 0.25);

                const blackCoreMat = new THREE.MeshBasicMaterial({

                    color: 0x000000,

                    transparent: true,

                    opacity: 1.0

                });

                

                const blackCore = new THREE.Group();

                const coreRadius = 1.5; // Smaller than outer sphere

                const coreVoxelCount = 200;

                

                for (let i = 0; i < coreVoxelCount; i++) {

                    const phi = Math.acos(-1 + (2 * i) / coreVoxelCount);

                    const theta = Math.sqrt(coreVoxelCount * Math.PI) * phi;

                    

                    const x = coreRadius * Math.cos(theta) * Math.sin(phi);

                    const y = coreRadius * Math.sin(theta) * Math.sin(phi);

                    const z = coreRadius * Math.cos(phi);

                    

                    const voxel = new THREE.Mesh(blackCoreGeo, blackCoreMat.clone());

                    voxel.position.set(x, y, z);

                    voxel.lookAt(0, 0, 0);

                    voxel.userData.baseRadius = coreRadius;

                    voxel.userData.phi = phi;

                    voxel.userData.theta = theta;

                    voxel.renderOrder = 2000; // Individual voxels render on top

                    voxel.material.depthTest = false; // Always visible

                    voxel.material.depthWrite = false;

                    blackCore.add(voxel);

                }

                

                blackCore.renderOrder = 2000; // Render on top of everything

                addressScene.add(blackCore);

                addressScene.userData.blackCore = blackCore;

                console.log('🕳️ Black core created with renderOrder=2000, depthTest=false');

                addressScene.userData.blackCorePhase = 0;

                addressScene.userData.blackCorePulse = 0;

                

                console.log('🖤 Black core sphere created with', coreVoxelCount, 'voxels');

                console.log('✅ Voxelized black hole created');

                console.log('📊 Outer voxel count:', voxelSphere.children.length);

                console.log('📊 Core voxel count:', blackCore.children.length);

                console.log('🔆 Event horizon position:', eventHorizon.position);

                console.log('💡 Black hole light intensity:', blackHoleLight1.intensity);

                

                // Accretion disk particles

                const particleCount = 200;

                const particleGeo = new THREE.BufferGeometry();

                const positions = new Float32Array(particleCount * 3);

                const colors = new Float32Array(particleCount * 3);

                

                for (let i = 0; i < particleCount; i++) {

                    const angle = Math.random() * Math.PI * 2;

                    const radius = 4 + Math.random() * 3;

                    positions[i * 3] = Math.cos(angle) * radius;

                    positions[i * 3 + 1] = (Math.random() - 0.5) * 0.5;

                    positions[i * 3 + 2] = Math.sin(angle) * radius;

                    

                    const heat = 1 - (radius - 4) / 3;

                    colors[i * 3] = 1;

                    colors[i * 3 + 1] = heat * 0.6;

                    colors[i * 3 + 2] = heat * 0.2;

                }

                

                particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                particleGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                

                const particleMat = new THREE.PointsMaterial({

                    size: 0.35,

                    vertexColors: true,

                    transparent: true,

                    opacity: 1.0,

                    blending: THREE.AdditiveBlending,

                    sizeAttenuation: true,

                    depthWrite: false

                });

                

                const particles = new THREE.Points(particleGeo, particleMat);

                addressScene.add(particles);

                addressScene.userData.accretionDisk = particles;

                console.log('✅ Accretion disk particles added to scene');

                

                console.log('✅ Black hole with accretion disk created');

                console.log('📊 Scene objects:', addressScene.children.length);

            }

            

            // Breathing voxelized black hole (outer sphere)

            if (addressScene.userData.voxelSphere) {

                addressScene.userData.voxelSpherePhase += delta * 2;

                const breathe = Math.sin(addressScene.userData.voxelSpherePhase) * 0.2 + 1;

                

                addressScene.userData.voxelSphere.children.forEach(voxel => {

                    const br = voxel.userData.baseRadius;

                    const phi = voxel.userData.phi;

                    const theta = voxel.userData.theta;

                    const radius = br * breathe;

                    

                    voxel.position.x = radius * Math.cos(theta) * Math.sin(phi);

                    voxel.position.y = radius * Math.sin(theta) * Math.sin(phi);

                    voxel.position.z = radius * Math.cos(phi);

                });

                

                addressScene.userData.voxelSphere.rotation.y += delta * 0.2;

                

                // PULSATING BLOOM - lights breathe with black hole to illuminate room

                if (addressScene.userData.blackHoleLight) {

                    const lightPulse = breathe; // Follow breathing pattern

                    addressScene.userData.blackHoleLight.intensity = 8.0 + lightPulse * 6.0; // 8-14 intensity

                    addressBloom.strength = 0.6 + lightPulse * 0.4; // 0.6-1.0 bloom

                    

                    // Illuminate room walls with pulsating bloom

                    if (addressScene.userData.roomMesh && addressScene.userData.roomMesh.material) {

                        addressScene.userData.roomMesh.material.emissiveIntensity = 0.05 + lightPulse * 0.08; // Subtle pulse

                    }

                }

                

                // Debug log every 5 seconds

                if (Math.floor(sequenceTime) % 5 === 0 && Math.floor(sequenceTime) !== Math.floor(sequenceTime - delta)) {

                    console.log(`🕳️ Black hole visible: voxels=${addressScene.userData.voxelSphere.children.length}, breathe=${breathe.toFixed(2)}, bloom=${addressBloom.strength.toFixed(2)}`);

                }

            }

            

            // Pulsing BLACK CORE - inverse pulse with negative black-light gradient

            if (addressScene.userData.blackCore) {

                addressScene.userData.blackCorePhase += delta * 3; // Faster pulse

                addressScene.userData.blackCorePulse += delta * 4;

                

                // Inverse pulse - contracts when outer breathes out

                const corePulse = Math.sin(addressScene.userData.blackCorePhase) * -0.15 + 0.85; // 0.7 to 1.0

                

                addressScene.userData.blackCore.children.forEach((voxel, i) => {

                    const br = voxel.userData.baseRadius;

                    const phi = voxel.userData.phi;

                    const theta = voxel.userData.theta;

                    const radius = br * corePulse;

                    

                    voxel.position.x = radius * Math.cos(theta) * Math.sin(phi);

                    voxel.position.y = radius * Math.sin(theta) * Math.sin(phi);

                    voxel.position.z = radius * Math.cos(phi);

                    

                    // Pulsing opacity creating "negative light" effect

                    const wave = Math.sin(addressScene.userData.blackCorePulse + i * 0.1);

                    const distFromCenter = Math.sqrt(voxel.position.x**2 + voxel.position.y**2 + voxel.position.z**2);

                    const normalizedDist = distFromCenter / (br * corePulse); // 0 at center, 1 at edge

                    

                    // Darker at center, lighter at edges (inverted gradient)

                    voxel.material.opacity = 0.9 + (normalizedDist * 0.1) + (wave * 0.05);

                });

                

                // Counter-rotate to outer sphere

                addressScene.userData.blackCore.rotation.y -= delta * 0.3;

            }

            

            if (addressScene.userData.eventHorizon) {

                addressScene.userData.eventHorizon.rotation.z += delta * 0.8;

            }

            if (addressScene.userData.accretionDisk) {

                addressScene.userData.accretionDisk.rotation.y += delta * 0.5;

            }

            

            // Continuously spawn black cubes

            if (sequenceTime > 55) {

                if (!addressScene.userData.blackCubeSpawnTimer) {

                    addressScene.userData.blackCubeSpawnTimer = 0;

                    addressScene.userData.blackCubes = [];

                }

                

                addressScene.userData.blackCubeSpawnTimer += delta;

                if (addressScene.userData.blackCubeSpawnTimer > 0.15) {

                    addressScene.userData.blackCubeSpawnTimer = 0;

                    

                    // Spawn new black cube far away

                    const angle = Math.random() * Math.PI * 2;

                    const elevation = (Math.random() - 0.5) * Math.PI;

                    const distance = 30 + Math.random() * 15;

                    

                    const blackCubeMat = new THREE.MeshStandardMaterial({

                        color: 0x0a0a0a,

                        transparent: true,

                        opacity: 0.95,

                        emissive: 0x0a0a0a,

                        emissiveIntensity: 0.1

                    });

                    

                    const blackCube = new THREE.Mesh(cubeGeo, blackCubeMat);

                    blackCube.position.set(

                        Math.cos(angle) * Math.cos(elevation) * distance,

                        Math.sin(elevation) * distance,

                        Math.sin(angle) * Math.cos(elevation) * distance

                    );

                    blackCube.userData.beingSucked = true;

                    blackCube.userData.suckStartTime = sequenceTime;

                    blackCube.userData.spiralAngle = angle;

                    blackCube.userData.spiralSpeed = 1.0 + Math.random() * 2.0;

                    blackCube.scale.set(0.6, 0.6, 0.6);

                    

                    addressScene.add(blackCube);

                    addressScene.userData.blackCubes.push(blackCube);

                }

            }

            

            // Spaghettification - black cubes get sucked into black hole

            if (addressScene.userData.blackCubes && addressScene.userData.blackCubes.length > 0) {

                const blackCubes = addressScene.userData.blackCubes;

                for (let i = blackCubes.length - 1; i >= 0; i--) {

                    const cube = blackCubes[i];

                    const elapsed = sequenceTime - cube.userData.suckStartTime;

                    const distToCenter = Math.sqrt(

                        cube.position.x ** 2 + 

                        cube.position.y ** 2 + 

                        cube.position.z ** 2

                    );

                    

                    // Acceleration toward center - increasing speed

                    const acceleration = 1 + elapsed * 1.2;

                    const pullForce = delta * acceleration * 10;

                    

                    // Spiral motion

                    cube.userData.spiralAngle += delta * cube.userData.spiralSpeed * (1 + elapsed * 0.8);

                    const spiralRadius = Math.max(0.1, distToCenter * 0.15);

                    const spiralX = Math.cos(cube.userData.spiralAngle) * spiralRadius;

                    const spiralZ = Math.sin(cube.userData.spiralAngle) * spiralRadius;

                    

                    // Pull toward center with spiral

                    cube.position.x = THREE.MathUtils.lerp(cube.position.x, spiralX, pullForce);

                    cube.position.y = THREE.MathUtils.lerp(cube.position.y, 0, pullForce * 0.95);

                    cube.position.z = THREE.MathUtils.lerp(cube.position.z, spiralZ, pullForce);

                    

                    // Spaghettification stretch - extreme elongation

                    if (distToCenter < 10) {

                        const stretchFactor = 1 + (10 - distToCenter) * 0.5;

                        cube.scale.y = 0.6 * stretchFactor;

                        cube.scale.x = Math.max(0.03, 0.6 / Math.sqrt(stretchFactor));

                        cube.scale.z = Math.max(0.03, 0.6 / Math.sqrt(stretchFactor));

                        

                        // Orient along spiral toward center

                        const targetPos = new THREE.Vector3(spiralX, 0, spiralZ);

                        cube.lookAt(targetPos);

                    }

                    

                    // Event horizon burst - tri-chromatic light explosion

                    if (distToCenter < 4.0 && !cube.userData.hasBurst) {

                        cube.userData.hasBurst = true;

                        console.log('💥 Tri-chromatic burst at event horizon!');

                        

                        // Create tri-chromatic light burst

                        const colors = [

                            { hex: 0xff0000, name: 'red' },

                            { hex: 0x00ff00, name: 'green' },

                            { hex: 0x0000ff, name: 'blue' }

                        ];

                        colors.forEach((colorData, idx) => {

                            const lightGeo = new THREE.SphereGeometry(0.3, 16, 16);

                            const lightMat = new THREE.MeshBasicMaterial({

                                color: colorData.hex,

                                transparent: true,

                                opacity: 1

                            });

                            const light = new THREE.Mesh(lightGeo, lightMat);

                            light.position.copy(cube.position);

                            

                            const angle = (idx / 3) * Math.PI * 2 + Math.random() * 0.5;

                            const speed = 3 + Math.random() * 2;

                            light.userData.velocity = new THREE.Vector3(

                                Math.cos(angle) * speed,

                                (Math.random() - 0.5) * speed * 0.8,

                                Math.sin(angle) * speed

                            );

                            light.userData.life = 1.0;

                            light.userData.colorName = colorData.name;

                            

                            addressScene.add(light);

                            if (!addressScene.userData.lightBursts) {

                                addressScene.userData.lightBursts = [];

                            }

                            addressScene.userData.lightBursts.push(light);

                        });

                    }

                    

                    // Remove if too close to center

                    if (distToCenter < 0.5) {

                        addressScene.remove(cube);

                        blackCubes.splice(i, 1);

                    }

                }

            }

            

            // Animate light bursts - expand and fade

            if (addressScene.userData.lightBursts) {

                for (let i = addressScene.userData.lightBursts.length - 1; i >= 0; i--) {

                    const light = addressScene.userData.lightBursts[i];

                    light.position.add(light.userData.velocity.clone().multiplyScalar(delta));

                    light.userData.life -= delta * 0.4;

                    light.material.opacity = light.userData.life;

                    light.scale.multiplyScalar(1 + delta * 3);

                    

                    if (light.userData.life <= 0) {

                        addressScene.remove(light);

                        addressScene.userData.lightBursts.splice(i, 1);

                    }

                }

            }

            

            // Render the scene

            addressComposer.render();

            

            // Continue indefinitely to keep rendering the room and black hole

            requestAnimationFrame(animateAddresses);

        }

        

        console.log('🎬 Starting animation loop');

        console.log('📷 Camera position:', addressCamera.position);

        console.log('🎭 Scene children:', addressScene.children.length);

        animateAddresses();

    }

    

    function triggerVictory(frame) {

        console.log('🎉 VICTORY!');

        if (!frame) return;



        // Set madness flag

        madnessActivated = true;

        rPromptHoverCount = 0; // Reset for "Don't click" messages



        // HALT R sequence completely - stop matrix and speech

        rInfectionHalted = true;

        speechRActive = false;

        rInfectionProcessing = false;

        rInfectionStarted = false;

        

        // Stop all matrix intervals and timers

        if (matrixInterval) {

            clearInterval(matrixInterval);

            matrixInterval = null;

        }

        if (matrixUpdateInterval) {

            clearInterval(matrixUpdateInterval);

            matrixUpdateInterval = null;

        }

        if (matrixAnimationFrameId) {

            cancelAnimationFrame(matrixAnimationFrameId);

            matrixAnimationFrameId = null;

        }

        if (cascadeInterval) {

            clearInterval(cascadeInterval);

            cascadeInterval = null;

        }

        if (matrixHeavyTimers && matrixHeavyTimers.length) {

            matrixHeavyTimers.forEach(id => clearTimeout(id));

            matrixHeavyTimers = [];

        }

        

        // Remove matrix container and R hint

        const matrixContainer = document.getElementById('matrixContainer');

        if (matrixContainer) {

            matrixContainer.remove();

        }

        const rHint = document.getElementById('rHint');

        if (rHint) {

            rHint.remove();

        }

        

        // Stop R text-to-speech immediately

        if (speechRTimeout) {

            clearTimeout(speechRTimeout);

            speechRTimeout = null;

        }

        if (speechRGuardTimeout) {

            clearTimeout(speechRGuardTimeout);

            speechRGuardTimeout = null;

        }

        if (hasSpeechSynthesis) {

            try { window.speechSynthesis.cancel(); } catch (err) {}

        }

        console.log('🛑 HALTED R sequence (matrix + speech)');



        // Play "Oh." text-to-speech

        setTimeout(() => {

            if (hasSpeechSynthesis && speechRVoice) {

                const ohUtterance = new SpeechSynthesisUtterance('Oh.');

                ohUtterance.voice = speechRVoice;

                ohUtterance.rate = 0.9;

                ohUtterance.pitch = 1.0;

                ohUtterance.volume = 0.92;

                window.speechSynthesis.speak(ohUtterance);

                console.log('🗣️ Playing "Oh." TTS');

            }

        }, 300);



        const existing = document.getElementById('initializeOverlay');

        if (existing) existing.remove();



        const overlay = document.createElement('div');

        overlay.id = 'initializeOverlay';

        overlay.style.cssText = 'position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none; z-index:60;';



        const panel = document.createElement('div');

        panel.style.cssText = 'pointer-events:auto; text-align:center; background:rgba(0,0,0,0.88); border:2px solid #0f0; padding:26px 34px; box-shadow:0 0 18px rgba(0,255,160,0.25); font-family:"Courier New", monospace; color:#0f0; min-width:260px;';



        const heading = document.createElement('div');

        heading.textContent = 'madness.loom located';

        heading.style.cssText = 'font-size:13px; letter-spacing:0.14em; text-transform:uppercase; margin-bottom:14px;';



        const button = document.createElement('button');

        button.textContent = 'INITIALIZE ▸';

        button.style.cssText = 'font-family:"Courier New", monospace; font-size:15px; letter-spacing:0.38em; padding:16px 34px; color:#072c07; background:#19ff6b; border:2px solid #19ff6b; cursor:pointer; text-transform:uppercase; box-shadow:0 0 18px rgba(25,255,107,0.45); transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease, color 0.2s ease; pointer-events:auto;';



        button.addEventListener('mouseenter', () => {

            if (button.disabled) return;

            button.style.boxShadow = '0 0 24px rgba(25,255,140,0.55)';

            button.style.transform = 'translateY(-2px)';

        });

        button.addEventListener('mouseleave', () => {

            if (button.disabled) return;

            button.style.boxShadow = '0 0 18px rgba(25,255,107,0.45)';

            button.style.transform = 'translateY(0)';

        });



        const status = document.createElement('div');

        const phases = ['calibrate interface', 'prime uplink', 'commence breach'];

        status.style.cssText = 'margin-top:12px; font-size:12px; letter-spacing:0.2em; text-transform:uppercase; opacity:0.75;';

        status.textContent = phases[0];



        panel.appendChild(heading);

        panel.appendChild(button);

        panel.appendChild(status);

        overlay.appendChild(panel);

        frame.appendChild(overlay);



        const visiCalc = document.getElementById('visicalc');

        const stageClasses = ['barrel-stage-1', 'barrel-stage-2', 'barrel-stage-3'];

        let clickCount = 0;



        function applyDistortion(stageIndex) {

            if (!visiCalc) return;

            visiCalc.classList.remove('screen-shatter');

            stageClasses.forEach(cls => visiCalc.classList.remove(cls));

            void visiCalc.offsetWidth;

            visiCalc.classList.add(stageClasses[stageIndex]);

        }

        

        function triggerMatrixIntensification(intensity) {

            console.log('🔥 Matrix intensification level:', intensity);

            

            // Create or intensify matrix rain

            let matrixContainer = document.getElementById('matrixIntensityOverlay');

            if (!matrixContainer) {

                matrixContainer = document.createElement('div');

                matrixContainer.id = 'matrixIntensityOverlay';

                matrixContainer.style.cssText = 'position:fixed; inset:0; pointer-events:none; z-index:65; overflow:hidden;';

                document.body.appendChild(matrixContainer);

            }

            

            // Clear existing columns

            matrixContainer.innerHTML = '';

            

            // Number of columns increases with intensity

            const columnCount = 40 + (intensity * 25); // More columns

            const duration = 2.5 + (intensity * 0.5); // Longer duration: 3-4s

            const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%&*+=';

            

            for (let i = 0; i < columnCount; i++) {

                const column = document.createElement('div');

                column.style.cssText = `

                    position:absolute;

                    top:${-100 - Math.random() * 100}%;

                    left:${Math.random() * 100}%;

                    font-family:'Courier New', monospace;

                    font-size:${14 + Math.random() * 10}px;

                    color:#0f0;

                    text-shadow:0 0 ${6 + intensity * 6}px #0f0, 0 0 ${3 + intensity * 3}px #0f0;

                    opacity:${0.65 + intensity * 0.12};

                    white-space:nowrap;

                    animation: matrixFall ${duration}s linear forwards;

                `;

                

                // Create falling text

                let text = '';

                const length = 10 + Math.floor(Math.random() * 15);

                for (let j = 0; j < length; j++) {

                    text += characters[Math.floor(Math.random() * characters.length)] + '<br>';

                }

                column.innerHTML = text;

                matrixContainer.appendChild(column);

            }

            

            // Add CSS animation if not already defined

            if (!document.getElementById('matrixIntensityStyles')) {

                const style = document.createElement('style');

                style.id = 'matrixIntensityStyles';

                style.textContent = `

                    @keyframes matrixFall {

                        0% { transform: translateY(0); opacity: 0; }

                        15% { opacity: 1; }

                        85% { opacity: 0.85; }

                        100% { transform: translateY(150vh); opacity: 0; }

                    }

                `;

                document.head.appendChild(style);

            }

            

            // Remove after animation

            setTimeout(() => {

                if (matrixContainer && matrixContainer.parentNode) {

                    matrixContainer.remove();

                }

            }, duration * 1000 + 500);

        }



        function triggerScreenShatter() {

            if (visiCalc) {

                stageClasses.forEach(cls => visiCalc.classList.remove(cls));

                void visiCalc.offsetWidth;

                visiCalc.classList.add('screen-shatter');

            }



            let shatter = document.getElementById('screenShatterOverlay');

            if (shatter) {

                shatter.remove();

            }

            shatter = document.createElement('div');

            shatter.id = 'screenShatterOverlay';

            shatter.className = 'shatter-overlay';

            const cracks = document.createElement('div');

            cracks.className = 'shatter-cracks';

            const pixels = document.createElement('div');

            pixels.className = 'shatter-pixels';

            shatter.appendChild(cracks);

            shatter.appendChild(pixels);

            document.body.appendChild(shatter);



            requestAnimationFrame(() => {

                shatter.classList.add('active');

                setTimeout(() => {

                    shatter.classList.add('fade');

                }, 950);

                setTimeout(() => {

                    if (shatter.parentNode) {

                        shatter.parentNode.removeChild(shatter);

                    }

                    // Start cell address sequence after shatter

                    setTimeout(() => {

                        startCellAddressSequence(frame, visiCalc);

                    }, 500);

                }, 2400);

            });

        }



        button.addEventListener('click', () => {

            if (button.disabled) return;

            clickCount++;

            barrelClickCount++;

            button.blur();

            button.style.transform = 'translateY(2px)';

            button.style.boxShadow = '0 0 12px rgba(25,255,107,0.35)';

            setTimeout(() => {

                if (!button.disabled) {

                    button.style.transform = 'translateY(0)';

                    button.style.boxShadow = '0 0 18px rgba(25,255,107,0.45)';

                }

            }, 160);



            const phaseIndex = Math.min(clickCount, phases.length - 1);

            status.textContent = phases[phaseIndex];



            // Play distorted startup sound with increasing distortion per click

            playStartupBassDistorted(clickCount);



            // Make VisiCell frame glow and extend back in Z

            if (visiCalc) {

                const frameEl = document.getElementById('visicalc-frame');

                if (frameEl) {

                    const zDepth = barrelClickCount * 20;

                    frameEl.style.transform = `perspective(1000px) translateZ(-${zDepth}px)`;

                    frameEl.style.boxShadow = `0 0 ${10 + barrelClickCount * 15}px #0f0, inset 0 0 ${5 + barrelClickCount * 10}px #0f0`;

                    frameEl.style.borderColor = '#0f0';

                    frameEl.style.borderWidth = '3px';

                }

            }



            // Intensify screen glitch and matrix effects between clicks

            const glitchEl = document.getElementById('screenGlitch');

            if (glitchEl && clickCount < 3) {

                glitchEl.classList.add('active');

                setTimeout(() => glitchEl.classList.remove('active'), 800 + clickCount * 200);

            }

            

            // Trigger maximum matrix cascade effect

            if (clickCount < 3) {

                triggerMatrixIntensification(clickCount);

            }



            if (clickCount === 1) {

                applyDistortion(0);

            } else if (clickCount === 2) {

                applyDistortion(1);

            } else {

                applyDistortion(2);

                button.disabled = true;

                button.style.cursor = 'default';

                button.textContent = 'INITIALIZING...';

                button.style.background = '#0d400d';

                button.style.color = '#0f0';

                

                // Maximum glitch and matrix before shatter

                if (glitchEl) {

                    glitchEl.classList.add('active');

                    setTimeout(() => glitchEl.classList.remove('active'), 1500);

                }

                triggerMatrixIntensification(3);

                

                setTimeout(() => {

                    triggerScreenShatter();

                }, 500);

            }

        });

    }

    

    function triggerCelliBackspaceReaction() {

        if (celliBackspaceSequenceStarted || burstAnimStarted) return;



        celliBackspaceSequenceStarted = true;

        celliBackspaceSequenceTime = totalTime;



        const active = voxels.filter(v => v.visible && !v.userData.glitched);

        if (!celliBackspaceFlickerTriggered && active.length) {

            celliBackspaceFlickerTriggered = true;

            const target = active[Math.floor(Math.random() * active.length)];

            if (target) {

                let flickers = 0;

                const mat = target.material;

                const edgeMaterial = target.userData.edges ? target.userData.edges.material : null;

                const baseOpacity = mat.opacity;

                const baseEdgeOpacity = edgeMaterial ? edgeMaterial.opacity : 0;

                const interval = setInterval(() => {

                    const on = flickers % 2 === 0;

                    mat.opacity = on ? 1 : Math.max(0.1, baseOpacity * 0.2);

                    if (edgeMaterial) {

                        edgeMaterial.opacity = on ? Math.min(0.9, baseEdgeOpacity + 0.3) : Math.max(0.1, baseEdgeOpacity * 0.3);

                    }

                    flickers += 1;

                    if (flickers > 4) {

                        clearInterval(interval);

                        mat.opacity = baseOpacity;

                        if (edgeMaterial) edgeMaterial.opacity = baseEdgeOpacity;

                    }

                }, 90);

            }

        }

    }



    // CELLI glitch and degradation

    function triggerCelliGlitch() {

        if (celliGlitchStarted) return;

        celliGlitchStarted = true;

        

        // Play electrical fritz whir/buzz sound

        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        const now = audioCtx.currentTime;

        

        // Create buzzing electrical sound with multiple oscillators

        const buzz1 = audioCtx.createOscillator();

        const buzz2 = audioCtx.createOscillator();

        const buzz3 = audioCtx.createOscillator();

        const buzzGain = audioCtx.createGain();

        const buzzFilter = audioCtx.createBiquadFilter();

        

        buzz1.type = 'sawtooth';

        buzz2.type = 'square';

        buzz3.type = 'sawtooth';

        

        // Fluctuating frequencies for electrical buzz

        buzz1.frequency.setValueAtTime(120, now);

        buzz2.frequency.setValueAtTime(180, now);

        buzz3.frequency.setValueAtTime(240, now);

        

        // Modulate frequencies to create buzzing effect

        for (let i = 0; i < 20; i++) {

            const t = now + (i * 0.1);

            const freq1 = 120 + Math.random() * 60;

            const freq2 = 180 + Math.random() * 60;

            const freq3 = 240 + Math.random() * 60;

            buzz1.frequency.setValueAtTime(freq1, t);

            buzz2.frequency.setValueAtTime(freq2, t);

            buzz3.frequency.setValueAtTime(freq3, t);

        }

        

        // Band-pass filter for electrical character

        buzzFilter.type = 'bandpass';

        buzzFilter.frequency.setValueAtTime(300, now);

        buzzFilter.Q.setValueAtTime(5, now);

        

        // Envelope: fade in, sustain, fade out

        buzzGain.gain.setValueAtTime(0, now);

        buzzGain.gain.linearRampToValueAtTime(0.08, now + 0.2);

        buzzGain.gain.setValueAtTime(0.08, now + 1.5);

        buzzGain.gain.exponentialRampToValueAtTime(0.001, now + 2.0);

        

        buzz1.connect(buzzFilter);

        buzz2.connect(buzzFilter);

        buzz3.connect(buzzFilter);

        buzzFilter.connect(buzzGain);

        buzzGain.connect(audioCtx.destination);

        

        buzz1.start(now);

        buzz2.start(now);

        buzz3.start(now);

        buzz1.stop(now + 2.0);

        buzz2.stop(now + 2.0);

        buzz3.stop(now + 2.0);

        

        // Start flickering lights

        document.getElementById('screenGlitch').classList.add('active');

        

        // Only keep the middle column of I (letter index 4, middle 3 rows: 1,2,3)

        voxels.forEach((voxel, idx) => {

            const data = voxel.userData;

            const gridX = data.gridX;    // Letter index (0=C, 1=E, 2=L, 3=L, 4=I)

            const gridY = data.gridY;    // Row index (0=top, 4=bottom)

            const gridCol = data.gridCol; // Column index within letter (0-4)

            

            // Keep only the T shape: top bar (row 0, all cols) and vertical stem (rows 1-4, middle col)

            const keepVoxel = (gridX === 4 && ((gridY === 0) || (gridY >= 1 && gridY <= 4 && gridCol === 2)));

            

            if (!keepVoxel) {

                // Store in stack for later restoration BEFORE marking as glitched

                glitchedVoxelsStack.push(voxel);

                

                // Mark as glitched immediately to prevent updates

                data.glitched = true;

                

                // Start flickering with light gray

                const flickerDelay = Math.random() * 400;

                

                setTimeout(() => {

                    // Turn to light gray and start flickering

                    voxel.material.color.setRGB(0.6, 0.6, 0.6); // Light gray

                    data.edges.material.color.setRGB(0.65, 0.65, 0.65);

                    

                    const flickerDuration = 400 + Math.random() * 400;

                    let flickerCount = 0;

                    const maxFlickers = Math.floor(flickerDuration / 60);

                    

                    const flickerInterval = setInterval(() => {

                        flickerCount++;

                        const flickerOn = Math.random() > 0.5;

                        

                        // Flicker between light gray and white, gradually dimming

                        const dimFactor = 1 - (flickerCount / maxFlickers) * 0.5;

                        if (flickerOn) {

                            voxel.material.color.setRGB(0.6 * dimFactor, 0.6 * dimFactor, 0.6 * dimFactor);

                            voxel.material.opacity = 0.75 * dimFactor;

                            data.edges.material.opacity = 0.5 * dimFactor;

                        } else {

                            voxel.material.color.setRGB(0.4 * dimFactor, 0.4 * dimFactor, 0.4 * dimFactor);

                            voxel.material.opacity = 0.5 * dimFactor;

                            data.edges.material.opacity = 0.3 * dimFactor;

                        }

                    }, 60);

                    

                    // After flickering, turn dark gray and fade out

                    setTimeout(() => {

                        clearInterval(flickerInterval);

                        

                        // Short out - dark gray

                        voxel.material.color.setRGB(0.15, 0.15, 0.15); // Dark gray

                        data.edges.material.color.setRGB(0.2, 0.2, 0.2);

                        voxel.material.opacity = 0.4;

                        data.edges.material.opacity = 0.25;

                        

                        // Fade to black over time

                        const fadeStart = Date.now();

                        const fadeDuration = 300;

                        const fadeInterval = setInterval(() => {

                            const fadeProgress = (Date.now() - fadeStart) / fadeDuration;

                            if (fadeProgress >= 1) {

                                clearInterval(fadeInterval);

                                voxel.material.opacity = 0;

                                data.edges.material.opacity = 0;

                                voxel.visible = false;

                                data.edges.visible = false;

                            } else {

                                voxel.material.opacity = 0.4 * (1 - fadeProgress);

                                data.edges.material.opacity = 0.25 * (1 - fadeProgress);

                            }

                        }, 16);

                    }, flickerDuration);

                }, flickerDelay);

            }

        });

        

        // Stop screen glitch after 2 seconds

        setTimeout(() => {

            document.getElementById('screenGlitch').classList.remove('active');

        }, 2000);

    }



    function updatePositions(t) {

        const phase = t < introCfg.rollEnd ? 'roll' :

                      t < introCfg.bounceEnd ? 'bounce' :

                      t < introCfg.triangleEnd ? 'triangle' :

                      t < introCfg.transitionEnd ? 'transition' :

                      t < introCfg.normalEnd ? 'normal' :

                      t < introCfg.vennEnd ? 'venn' :

                      t < introCfg.collapseEnd ? 'collapse' :

                      t < introCfg.glitchEnd ? 'glitch' :

                      t < introCfg.blackoutEnd ? 'blackout' :

                      t < introCfg.loomworksEnd ? 'loomworks' :

                      t < introCfg.celliEnd ? 'celli' : 'doorway';



        // Animate bloom, afterimage, and film effects based on phase

        if (phase === 'roll') {

            afterimagePass.uniforms.damp.value = 0.75; // Thin trail

            filmPass.uniforms.noise.value = 0.005; // Minimal grain

            filmPass.uniforms.scanAmp.value = 0.003; // Minimal scanlines

            triMesh.visible = false; // Hide triangle gradient during intro

        } else if (phase === 'bounce') {

            bloomPass.strength = 0.25; // Subtle glow

            afterimagePass.uniforms.damp.value = 0.75; // Thin trail

            filmPass.uniforms.noise.value = 0.005; // Minimal grain

            filmPass.uniforms.scanAmp.value = 0.003; // Minimal scanlines

            triMesh.visible = false; // Hide triangle gradient during intro

        } else if (phase === 'triangle') {

            const triangleProgress = (t - introCfg.bounceEnd) / (introCfg.triangleEnd - introCfg.bounceEnd);

            

            // Sub-phases: form (0-0.35), converge (0.35-0.6), grow (0.6-1.0)

            const formProgress = Math.min(triangleProgress / 0.35, 1.0);

            const convergeStart = 0.35;

            const convergeProgress = triangleProgress > convergeStart ? Math.min((triangleProgress - convergeStart) / 0.25, 1.0) : 0;

            const growStart = 0.6;

            const growProgress = triangleProgress > growStart ? (triangleProgress - growStart) / 0.4 : 0;

            

            // Smooth bloom progression throughout all sub-phases

            bloomPass.strength = THREE.MathUtils.lerp(0.25, 0.7, triangleProgress);

            afterimagePass.uniforms.damp.value = THREE.MathUtils.lerp(0.75, 0.92, triangleProgress);

            filmPass.uniforms.noise.value = THREE.MathUtils.lerp(0.005, 0.015, triangleProgress);

            filmPass.uniforms.scanAmp.value = THREE.MathUtils.lerp(0.003, 0.015, triangleProgress);

            

            // Hide triangle gradient - it makes things look off-center

            triMesh.visible = false;

        } else if (phase === 'transition') {

            const transProgress = (t - introCfg.triangleEnd) / (introCfg.transitionEnd - introCfg.triangleEnd);

            bloomPass.strength = 0.7; // Keep bloom consistent

            afterimagePass.uniforms.damp.value = THREE.MathUtils.lerp(0.92, 0.96, transProgress);

            filmPass.uniforms.noise.value = THREE.MathUtils.lerp(0.015, 0.03, transProgress);

            filmPass.uniforms.scanAmp.value = THREE.MathUtils.lerp(0.015, 0.03, transProgress);

            triMesh.visible = false;

            triMesh.material.opacity = 0;

        } else if (phase === 'normal') {

            const normalT = t - introCfg.transitionEnd;

            const normalDuration = introCfg.normalEnd - introCfg.transitionEnd;

            const convergeDuration = 2.2;

            const pulseDuration = 3.0;

            const totalAnimDuration = convergeDuration + pulseDuration;



            if (normalT < convergeDuration) {

                // Phase 1: Converge - increase bloom

                const convergeProgress = THREE.MathUtils.clamp(normalT / convergeDuration, 0, 1);

                const convergeEased = convergeProgress * convergeProgress * (3 - 2 * convergeProgress);

                bloomPass.strength = THREE.MathUtils.lerp(0.7, 0.9, convergeEased);

                triMesh.visible = false;

            } else if (normalT < totalAnimDuration) {

                // Phase 2: Single pulse - bloom follows expansion

                const pulseT = normalT - convergeDuration;

                const pulseProgress = pulseT / pulseDuration;

                const pulseCycle = Math.sin(pulseProgress * Math.PI);

                

                bloomPass.strength = THREE.MathUtils.lerp(0.9, 0.72, pulseCycle);

                triMesh.visible = pulseCycle > 0.3; // Show triangle during expansion

                triMesh.material.opacity = THREE.MathUtils.clamp(pulseCycle * 1.5, 0, 0.7);

            } else {

                // Phase 3: Brief hold, prepare for venn transition

                const holdT = normalT - totalAnimDuration;

                const holdDuration = normalDuration - totalAnimDuration;

                const holdProgress = holdT / holdDuration;

                

                bloomPass.strength = THREE.MathUtils.lerp(0.9, 0.85, holdProgress);

                triMesh.visible = false;

            }



            afterimagePass.uniforms.damp.value = 0.96;

            filmPass.uniforms.noise.value = 0.03;

            filmPass.uniforms.scanAmp.value = 0.03;

        } else if (phase === 'venn') {

            // Settle into clear venn diagram

            const vennProgress = (t - introCfg.normalEnd) / (introCfg.vennEnd - introCfg.normalEnd);

            bloomPass.strength = THREE.MathUtils.lerp(0.7, 0.8, vennProgress);

            afterimagePass.uniforms.damp.value = THREE.MathUtils.lerp(0.96, 0.7, vennProgress);

            filmPass.uniforms.noise.value = THREE.MathUtils.lerp(0.03, 0.02, vennProgress);

            filmPass.uniforms.scanAmp.value = THREE.MathUtils.lerp(0.03, 0.02, vennProgress);

            triMesh.visible = true;

            triMesh.material.opacity = THREE.MathUtils.lerp(0.7, 0.85, vennProgress);

        } else if (phase === 'collapse') {

            // Grow and collapse into white radiating circle

            const collapseProgress = (t - introCfg.vennEnd) / (introCfg.collapseEnd - introCfg.vennEnd);

            bloomPass.strength = THREE.MathUtils.lerp(0.8, 1.2, collapseProgress);

            afterimagePass.uniforms.damp.value = THREE.MathUtils.lerp(0.7, 0.6, collapseProgress);

            filmPass.uniforms.noise.value = THREE.MathUtils.lerp(0.02, 0.015, collapseProgress);

            filmPass.uniforms.scanAmp.value = THREE.MathUtils.lerp(0.02, 0.015, collapseProgress);

            triMesh.visible = true;

            triMesh.material.opacity = THREE.MathUtils.lerp(0.85, 0.3, collapseProgress);

            

            // Progressive glitch starting mild - show quote only when glitching starts

            if (collapseProgress > 0.15 && !glitchStarted) {

                const quoteEl = document.getElementById('quote');

                quoteEl.style.visibility = 'visible';

                quoteEl.style.opacity = '0.85'; // Start visible

                quoteEl.classList.add('glitch');

                glitchStarted = true;

                quoteShown = true;

            }



            // Increase to medium glitch

            if (collapseProgress > 0.6 && !mediumGlitchStarted) {

                document.getElementById('quote').classList.remove('glitch');

                document.getElementById('quote').classList.add('glitchMedium');

                mediumGlitchStarted = true;

            }

        } else if (phase === 'glitch') {

            // Intense glitch phase

            const glitchProgress = (t - introCfg.collapseEnd) / (introCfg.glitchEnd - introCfg.collapseEnd);

            bloomPass.strength = THREE.MathUtils.lerp(1.2, 0.5, glitchProgress);

            afterimagePass.uniforms.damp.value = 0.3; // Heavy trails

            filmPass.uniforms.noise.value = THREE.MathUtils.lerp(0.015, 0.5, glitchProgress);

            filmPass.uniforms.scanAmp.value = THREE.MathUtils.lerp(0.015, 0.3, glitchProgress);

            triMesh.visible = true;

            triMesh.material.opacity = THREE.MathUtils.lerp(0.3, 0, glitchProgress);

            

            // Intensify text glitch at start of glitch phase

            if (glitchProgress > 0.05 && !intenseGlitchStarted) {

                document.getElementById('quote').classList.remove('glitch', 'glitchMedium');

                document.getElementById('quote').classList.add('glitchIntense');

                intenseGlitchStarted = true;

            }



            if (glitchProgress > 0.25 && !quoteDespairShown) {

                glitchSwapQuote(quoteStates.despair, { duration: 950, onComplete: () => quoteEl.classList.add('quote--loom') });

                quoteDespairShown = true;

            }



            // Screen glitch in middle

            if (glitchProgress > 0.4 && !screenGlitchStarted) {

                document.getElementById('screenGlitch').classList.add('active');

                screenGlitchStarted = true;

            }

        } else if (phase === 'blackout') {

            // Fade to black

            const blackoutProgress = (t - introCfg.glitchEnd) / (introCfg.blackoutEnd - introCfg.glitchEnd);

            bloomPass.strength = THREE.MathUtils.lerp(0.5, 0, blackoutProgress);

            afterimagePass.uniforms.damp.value = 0.1;

            filmPass.uniforms.noise.value = 0;

            filmPass.uniforms.scanAmp.value = 0;

            triMesh.visible = false;

            

            if (!blackoutStarted) {

                // Hide and clean up quote immediately

                const quoteEl = document.getElementById('quote');

                quoteEl.classList.remove('glitch', 'glitchMedium', 'glitchIntense', 'scrambling');

                quoteEl.style.visibility = 'hidden';

                quoteEl.style.opacity = '0';

                quoteEl.classList.remove('quote--loom');

                document.getElementById('screenGlitch').classList.remove('active');

                blackoutStarted = true;

            }

        } else if (phase === 'loomworks') {

            // Show Loomworks text

            bloomPass.strength = 0;

            afterimagePass.uniforms.damp.value = 0;

            filmPass.uniforms.noise.value = 0;

            filmPass.uniforms.scanAmp.value = 0;

            triMesh.visible = false;

            

            if (!loomworksShown) {

                // Ensure quote is definitely hidden before showing loomworks

                const quoteEl = document.getElementById('quote');

                quoteEl.style.visibility = 'hidden';

                quoteEl.style.opacity = '0';

                quoteEl.classList.remove('glitch', 'glitchMedium', 'glitchIntense', 'scrambling');



                startLoomworksReveal();

                loomworksShown = true;

            }

            

            // Play chime jingle at start of this phase

            if (!chimePlayed) {

                // Generate startup chime jingle

                if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

                const now = audioCtx.currentTime;

                

                // Melodic jingle: C - E - G - C (ascending arpeggio)

                const melody = [

                    { freq: 261.63, time: 0.0, duration: 0.25 },    // C4

                    { freq: 329.63, time: 0.15, duration: 0.25 },   // E4

                    { freq: 392.00, time: 0.30, duration: 0.25 },   // G4

                    { freq: 523.25, time: 0.45, duration: 0.5 }     // C5 (held)

                ];

                

                melody.forEach((note, idx) => {

                    const osc = audioCtx.createOscillator();

                    const gain = audioCtx.createGain();

                    

                    osc.type = 'sine';

                    osc.frequency.setValueAtTime(note.freq, now + note.time);

                    

                    // Envelope

                    gain.gain.setValueAtTime(0, now + note.time);

                    gain.gain.linearRampToValueAtTime(0.12, now + note.time + 0.02);

                    gain.gain.linearRampToValueAtTime(0.08, now + note.time + 0.1);

                    gain.gain.exponentialRampToValueAtTime(0.001, now + note.time + note.duration);

                    

                    osc.connect(gain);

                    gain.connect(audioCtx.destination);

                    osc.start(now + note.time);

                    osc.stop(now + note.time + note.duration);

                });

                

                // Play startup bass after chime completes

                setTimeout(() => {

                    playStartupBass();

                }, 1200);

                

                chimePlayed = true;

            }

            

            // Hide Loomworks text near end

            const loomProgress = (t - introCfg.blackoutEnd) / (introCfg.loomworksEnd - introCfg.blackoutEnd);

            if (loomProgress > 0.85) {

                document.getElementById('loomworks').style.opacity = THREE.MathUtils.lerp(1, 0, (loomProgress - 0.85) / 0.15);

            }

        } else if (phase === 'celli') {

            // CELLI phase - lower bloom to reduce wobble

            bloomPass.strength = 0.35;

            afterimagePass.uniforms.damp.value = 0.85;

            filmPass.uniforms.noise.value = 0.008;

            filmPass.uniforms.scanAmp.value = 0.003;

            

            triMesh.visible = false;



            if (!celliStarted) {

                document.getElementById('loomworks').style.display = 'none';

                celliStarted = true;

            }

        } else {

            // Doorway phase - portal opens from vertical bar (lower bloom)

            const doorwayProgress = (t - introCfg.celliEnd) / (introCfg.doorwayEnd - introCfg.celliEnd);

            

            bloomPass.strength = THREE.MathUtils.lerp(0.35, 0.55, Math.min(doorwayProgress * 2, 1));

            afterimagePass.uniforms.damp.value = 0.8;

            filmPass.uniforms.noise.value = 0.005;

            filmPass.uniforms.scanAmp.value = 0.002;

            triMesh.visible = false;

            

            // Wait for all CELLI voxels to finish settling (last one settles around 3-4 seconds)

            const celliAge = t - introCfg.loomworksEnd;

            const allVoxelsSettled = celliAge > 5.0;

            

            if (!doorwayShown && allVoxelsSettled) {

                // Show doorway bar after CELLI finishes

                if (doorwayProgress > 0.05) {

                    document.getElementById('doorway').classList.add('visible');

                    doorwayShown = true;

                }

            }

            

            if (doorwayShown && !doorwayOpened) {

                // Open doorway after short delay

                if (doorwayProgress > 0.15) {

                    document.getElementById('doorway').classList.add('open');

                    doorwayOpened = true;

                    

                }

            }

        }



        if (phase === 'roll') {

            // Shapes roll in from off-screen to their positions

            const rollProgress = t / introCfg.rollEnd;

            const eased = rollProgress < 0.5 ? 

                2 * rollProgress * rollProgress : 

                1 - Math.pow(-2 * rollProgress + 2, 2) / 2;

            

            // Keep glow visible throughout roll

            bloomPass.strength = 0.4;



        for (let i = 0; i < 3; i++) {

                const targetX = (i - 1) * 0.35;

                const startX = targetX - 2.0; // Start off-screen left

                const x = THREE.MathUtils.lerp(startX, targetX, eased);

                const y = -0.3;

                

                // Calculate rolling rotation based on distance traveled to reach FLAT position

                const distance = x - startX; // Distance rolled

                

                // Calculate rotation for accurate rolling that ends flat

                let rotation = 0;

                if (i === 0) {

                    // Square: needs to align flat (multiple of π/2)

                    const squarePerimeter = R * 2 * 4;

                    const naturalRotation = -(distance / squarePerimeter) * (Math.PI * 2);

                    // Snap to nearest π/2 when nearly stopped

                    rotation = rollProgress > 0.95 ? Math.round(naturalRotation / (Math.PI / 2)) * (Math.PI / 2) : naturalRotation;

                } else if (i === 1) {

                    // Triangle: needs to align flat (multiple of 2π/3)

                    const trianglePerimeter = R * 2 * 3;

                    const naturalRotation = -(distance / trianglePerimeter) * (Math.PI * 2);

                    // Snap to nearest 2π/3 when nearly stopped (flat base)

                    rotation = rollProgress > 0.95 ? Math.round(naturalRotation / (Math.PI * 2 / 3)) * (Math.PI * 2 / 3) : naturalRotation;

                } else {

                    // Circle: any rotation is "flat"

                    rotation = -(distance / (2 * Math.PI * R)) * (Math.PI * 2);

                }

                

                // Store final rotation when reaching target

                if (rollProgress > 0.98) {

                    finalRollRotations[i] = rotation;

                }

                

                // Play continuous rolling thunks based on distance

                const rollDist = Math.abs(x - startX);

                const thunkInterval = 0.15; // Play thunk every 0.15 units rolled

                const expectedThunks = Math.floor(rollDist / thunkInterval);

                

                if (expectedThunks > lastThunkTime[i]) {

                    playRollingThunk(0.06);

                    lastThunkTime[i] = expectedThunks;

                }

                

                spheres[i].position.set(x, y, -i * 0.002);

                spheres[i].rotation.z = rotation;

                spheres[i].scale.set(introCfg.ballSize, introCfg.ballSize, introCfg.ballSize);

                triMat.uniforms.points.value[i].set(x, y);

                

                // Play final landing thunk

                if (!landingSounds[i] && Math.abs(x - targetX) < 0.02) {

                    playRollingThunk(0.12);

                    landingSounds[i] = true;

                }

            }

            blackHole.visible = false; // Hide during roll-in

            

        } else if (phase === 'bounce') {

            // Sequential bounces: left, then right, then middle

            const bounceT = t - introCfg.rollEnd;

            const baseY = -0.3;

            

            // Keep glow visible during bounce

            bloomPass.strength = 0.4;

            

            for (let i = 0; i < 3; i++) {

                const x = (i - 1) * 0.35;

                let y = baseY;

                

                // Sequence: 0 (left), 2 (right), 1 (middle)

                const bounceOrder = [0, 2, 1];

                const bounceIndex = bounceOrder.indexOf(i);

                const bounceStart = bounceIndex * introCfg.bounceDuration;

                const bounceEnd = bounceStart + introCfg.bounceDuration;

                

                if (bounceT >= bounceStart && bounceT <= bounceEnd) {

                    const localT = (bounceT - bounceStart) / introCfg.bounceDuration;

                    const bounce = Math.sin(localT * Math.PI) * introCfg.bounceHeight;

                    y = baseY + bounce;

                    

                    // Play thud sounds for jump and land

                    if (!window['bounceJump_' + i] && localT < 0.05) {

                        playBounceThud(0.12);

                        window['bounceJump_' + i] = true;

                    }

                    if (!window['bounceLand_' + i] && localT > 0.95) {

                        playBounceThud(0.15);

                        window['bounceLand_' + i] = true;

                    }

                }

                

                spheres[i].position.set(x, y, -i * 0.002);

                spheres[i].rotation.z = finalRollRotations[i]; // Use exact rotation from roll phase

                spheres[i].scale.set(introCfg.ballSize, introCfg.ballSize, introCfg.ballSize);

                triMat.uniforms.points.value[i].set(x, y);

            }

            blackHole.visible = false; // Hide during bounce

            

        } else if (phase === 'triangle') {

            // Triangle phase: form → converge → grow & brighten

            const triangleProgress = (t - introCfg.bounceEnd) / (introCfg.triangleEnd - introCfg.bounceEnd);

            

            // Smooth cubic easing for entire phase

            const smoothEase = (p) => p < 0.5 ? 4 * p * p * p : 1 - Math.pow(-2 * p + 2, 3) / 2;

            

            // Sub-phases with smooth transitions

            const formProgress = Math.min(triangleProgress / 0.35, 1.0);

            const formEased = smoothEase(formProgress);

            

            const convergeStart = 0.35;

            const convergeProgress = triangleProgress > convergeStart ? Math.min((triangleProgress - convergeStart) / 0.25, 1.0) : 0;

            const convergeEased = smoothEase(convergeProgress);

            

            const growStart = 0.6;

            const growProgress = triangleProgress > growStart ? (triangleProgress - growStart) / 0.4 : 0;

            const growEased = smoothEase(growProgress);

            

            // Create EQUILATERAL triangle centered at origin

            const centerY = 0;

            const triangleRadius = 0.42; // Distance from center to each vertex (increased)

            

            // Equilateral triangle: vertices at 120° intervals, pointing up

            const triangleAngles = [

                Math.PI / 2 + (2 * Math.PI / 3) * 0,  // Top (90°)

                Math.PI / 2 + (2 * Math.PI / 3) * 1,  // Bottom-left (210°)

                Math.PI / 2 + (2 * Math.PI / 3) * 2   // Bottom-right (330°)

            ];

            

            // Rotation grows smoothly throughout

            const rotationAmount = growEased * 0.2;

            

            // Pulsing: breathe in/out during grow phase

            const pulseSpeed = 2.0;

            const pulsePhase = (t - introCfg.bounceEnd - growStart * (introCfg.triangleEnd - introCfg.bounceEnd)) * pulseSpeed;

            const pulseFactor = growProgress > 0 ? 1 + Math.sin(pulsePhase) * 0.08 : 1;

            

            // Converge factor - pull toward center during converge phase

            const convergeFactor = convergeEased * 0.12;

            

            // Map spheres to triangle positions: [0]=left→bottom-left, [1]=middle→top, [2]=right→bottom-right

            const triangleMapping = [1, 0, 2]; // sphere i goes to angle triangleMapping[i]

            

            for (let i = 0; i < 3; i++) {

                // Starting positions from the line (after bounce)

                const startX = (i - 1) * 0.35;

                const startY = -0.3;

                

                // Target positions in triangle formation (with correct mapping)

                const angleIndex = triangleMapping[i];

                const angle = triangleAngles[angleIndex] + rotationAmount;

                const targetRadius = triangleRadius * (1 - convergeFactor) * pulseFactor;

                const targetX = Math.cos(angle) * targetRadius;

                const targetY = Math.sin(angle) * targetRadius + centerY;

                

                // Interpolate from line to triangle formation

                const x = THREE.MathUtils.lerp(startX, targetX, formEased);

                const y = THREE.MathUtils.lerp(startY, targetY, formEased);

                

                spheres[i].position.set(x, y, -i * 0.002);

                spheres[i].rotation.z = 0; // Reset rotation for orbit phases

                

                // Scale: small → stays small during form/converge → grows large with overshoot

                let scale = introCfg.ballSize;

                if (formEased < 1) {

                    scale = THREE.MathUtils.lerp(introCfg.ballSize, introCfg.ballSize * 1.0, formEased);

                } else {

                    // Add subtle overshoot for organic feel

                    const overshoot = Math.sin(growEased * Math.PI) * 0.08;

                    scale = THREE.MathUtils.lerp(introCfg.ballSize * 1.0, introCfg.ballSize * 2.2, growEased) + overshoot;

                }

                

                spheres[i].scale.set(scale, scale, scale);

                triMat.uniforms.points.value[i].set(x, y);

            }

            

            blackHole.visible = true;

            blackHole.material.uniforms.pulseFactor.value = formEased * 0.4;

            

        } else if (phase === 'transition') {

            // Transform triangle into rotating circular orbit - organically

            // ALSO morph all shapes into circles

            const transProgress = (t - introCfg.triangleEnd) / (introCfg.transitionEnd - introCfg.triangleEnd);

            // Smooth cubic easing

            const eased = transProgress < 0.5 ? 

                4 * transProgress * transProgress * transProgress : 

                1 - Math.pow(-2 * transProgress + 2, 3) / 2;

            

            // Morph shapes into circles halfway through transition

            // Keep materials (colors) consistent - don't swap

            if (transProgress > 0.5 && spheres[0].geometry !== circleGeoTarget && spheres[1].geometry !== circleGeoTarget) {

                const mat0 = spheres[0].material;

                const mat1 = spheres[1].material;

                

                spheres[0].geometry.dispose();

                spheres[0].geometry = createCircle(R);

                spheres[0].material = mat0;  // Preserve cyan

                

                spheres[1].geometry.dispose();

                spheres[1].geometry = createCircle(R);

                spheres[1].material = mat1;  // Preserve yellow

                

                // spheres[2] is already a circle (magenta)

            }

            

            const centerY = 0;

            const triangleRadius = 0.42;

            

            // Use same equilateral triangle angles

            const triangleAngles = [

                Math.PI / 2 + (2 * Math.PI / 3) * 0,

                Math.PI / 2 + (2 * Math.PI / 3) * 1,

                Math.PI / 2 + (2 * Math.PI / 3) * 2

            ];

            

            // Starting radius (with 12% convergence from triangle phase)

            const startRadius = triangleRadius * (1 - 0.12);

            

            // Calculate rotation to match end of triangle phase (which uses rotationAmount = 0.2)

            // The triangle phase maps spheres with triangleMapping, so we need to continue from there

            const triangleEndRotation = 0.2; // matches growEased = 1.0 * 0.2

            const rotation = triangleEndRotation + (eased * Math.PI * 2);

            

            // Expand from triangle size to full orbit size

            const targetDist = motionCfg.maxDist * 0.5;

            const currentDist = THREE.MathUtils.lerp(startRadius, targetDist, eased);

            

            // Use same mapping as triangle phase

            const triangleMapping = [1, 0, 2];

            

            for (let i = 0; i < 3; i++) {

                const angleIndex = triangleMapping[i];

                const angle = triangleAngles[angleIndex] + rotation;

                const x = Math.cos(angle) * currentDist;

                const y = Math.sin(angle) * currentDist + centerY;

                

                spheres[i].position.set(x, y, -i * 0.002);

                spheres[i].rotation.z = 0;

                const scale = THREE.MathUtils.lerp(introCfg.ballSize * 2.2, 1.0, eased);

                spheres[i].scale.set(scale, scale, scale);

                triMat.uniforms.points.value[i].set(x, y);

            }

            blackHole.visible = true;

            blackHole.material.uniforms.pulseFactor.value = THREE.MathUtils.lerp(0.4, 0.5, eased);

            

        } else if (phase === 'normal') {

            const normalT = t - introCfg.transitionEnd;

            const convergeDuration = 2.2;

            const pulseDuration = 3.0; // One expand/contract cycle

            const transitionEndDist = motionCfg.maxDist * 0.5;

            const closeConvergeDist = 0.02; // Very close convergence

            const triangleExpandDist = motionCfg.maxDist * 0.65; // Expand to triangle



            const centerY = 0;

            const triangleAngles = [

                Math.PI / 2 + (2 * Math.PI / 3) * 0,

                Math.PI / 2 + (2 * Math.PI / 3) * 1,

                Math.PI / 2 + (2 * Math.PI / 3) * 2

            ];

            const transitionEndRotation = 0.2 + Math.PI * 2;

            const rotation = transitionEndRotation + (normalT * motionCfg.rotationSpeed);

            const triangleMapping = [1, 0, 2];



            let currentDist = transitionEndDist;

            let scale = 1.0;

            let pulseFactorValue = 0.5;



            if (normalT < convergeDuration) {

                // Phase 1: Converge close

                const convergeProgress = THREE.MathUtils.clamp(normalT / convergeDuration, 0, 1);

                const convergeEased = convergeProgress * convergeProgress * (3 - 2 * convergeProgress);

                currentDist = THREE.MathUtils.lerp(transitionEndDist, closeConvergeDist, convergeEased);

                scale = THREE.MathUtils.lerp(1.0, 0.82, convergeEased);

                pulseFactorValue = THREE.MathUtils.lerp(0.5, 0.95, convergeEased);

            } else if (normalT < convergeDuration + pulseDuration) {

                // Phase 2: Single expand/contract pulse

                const pulseT = normalT - convergeDuration;

                const pulseProgress = pulseT / pulseDuration;

                

                // Use sine wave for smooth expand/contract (0->1->0)

                const pulseCycle = Math.sin(pulseProgress * Math.PI);

                

                currentDist = THREE.MathUtils.lerp(closeConvergeDist, triangleExpandDist, pulseCycle);

                scale = THREE.MathUtils.lerp(0.82, 1.0, pulseCycle);

                pulseFactorValue = THREE.MathUtils.lerp(0.95, 0.6, pulseCycle);

            } else {

                // Phase 3: Hold at converged position before transitioning to venn

                currentDist = closeConvergeDist;

                scale = 0.82;

                pulseFactorValue = 0.95;

            }



            for (let i = 0; i < 3; i++) {

                const angleIndex = triangleMapping[i];

                const angle = triangleAngles[angleIndex] + rotation;

            const p = new THREE.Vector2(

                Math.cos(angle) * currentDist,

                    Math.sin(angle) * currentDist + centerY

            );

            spheres[i].position.set(p.x, p.y, -i * 0.002);

                spheres[i].rotation.z = 0;

            spheres[i].scale.set(scale, scale, scale);

            triMat.uniforms.points.value[i].copy(p);

        }

            blackHole.visible = true;

            blackHole.material.uniforms.pulseFactor.value = pulseFactorValue;



        } else if (phase === 'venn') {

            // Slow down and form clear venn diagram

            const vennProgress = (t - introCfg.normalEnd) / (introCfg.vennEnd - introCfg.normalEnd);

            // Smooth cubic easing

            const eased = vennProgress < 0.5 ? 

                4 * vennProgress * vennProgress * vennProgress : 

                1 - Math.pow(-2 * vennProgress + 2, 3) / 2;

            

            const normalDuration = introCfg.normalEnd - introCfg.transitionEnd;

            const centerY = 0;

            

            const triangleAngles = [

                Math.PI / 2 + (2 * Math.PI / 3) * 0,

                Math.PI / 2 + (2 * Math.PI / 3) * 1,

                Math.PI / 2 + (2 * Math.PI / 3) * 2

            ];

            

            // Start from where normal ended: transitionEndRotation + normalDuration * rotationSpeed

            const transitionEndRotation = 0.2 + Math.PI * 2;

            const baseRotation = transitionEndRotation + (normalDuration * motionCfg.rotationSpeed);

            const vennT = t - introCfg.normalEnd;

            const slowRotation = baseRotation + (vennT * motionCfg.rotationSpeed * 0.3); // Slow down to 30%

            

            // Settle into venn diagram distance - calculate what pulse factor was at END of normal phase

            const normalEndTime = introCfg.normalEnd - introCfg.transitionEnd;

            const startPulseFactor = 0.5 + 0.5 * Math.sin(normalEndTime * motionCfg.speed);

            const startDist = motionCfg.maxDist * startPulseFactor;

            const targetDist = 0.08; // Very close for dramatic overlap

            const currentDist = THREE.MathUtils.lerp(startDist, targetDist, eased);

            const scale = THREE.MathUtils.lerp(1.0, 0.7, eased); // Much larger for awesome venn!



            // Use same mapping as triangle phase

            const triangleMapping = [1, 0, 2];



            for (let i = 0; i < 3; i++) {

                const angleIndex = triangleMapping[i];

                const angle = triangleAngles[angleIndex] + slowRotation;

                const p = new THREE.Vector2(

                    Math.cos(angle) * currentDist,

                    Math.sin(angle) * currentDist + centerY

                );

                spheres[i].position.set(p.x, p.y, -i * 0.002);

                spheres[i].rotation.z = 0;

                spheres[i].scale.set(scale, scale, scale);

                triMat.uniforms.points.value[i].copy(p);

            }

            blackHole.visible = true;

            blackHole.material.uniforms.pulseFactor.value = THREE.MathUtils.lerp(startPulseFactor, 0.6, eased);

            

            if (!quoteShown) {

                applyQuoteState(quoteStates.initial, { immediate: true });

                quoteEl.classList.remove('scrambling', 'glitch', 'glitchMedium', 'glitchIntense');

                document.getElementById('quote').classList.add('visible');

                quoteDespairShown = false;

                quoteShown = true;

            }

            

        } else if (phase === 'collapse') {

            // Grow and collapse into white radiating circle

            const collapseProgress = (t - introCfg.vennEnd) / (introCfg.collapseEnd - introCfg.vennEnd);

            // Smooth cubic easing

            const eased = collapseProgress < 0.5 ? 

                4 * collapseProgress * collapseProgress * collapseProgress : 

                1 - Math.pow(-2 * collapseProgress + 2, 3) / 2;

            

            const centerY = 0;

            

            const triangleAngles = [

                Math.PI / 2 + (2 * Math.PI / 3) * 0,

                Math.PI / 2 + (2 * Math.PI / 3) * 1,

                Math.PI / 2 + (2 * Math.PI / 3) * 2

            ];

            

            // Start from where venn ended

            const transitionEndRotation = 0.2 + Math.PI * 2;

            const normalDuration = introCfg.normalEnd - introCfg.transitionEnd;

            const vennDuration = introCfg.vennEnd - introCfg.normalEnd;

            const baseRotation = transitionEndRotation + (normalDuration * motionCfg.rotationSpeed) + (vennDuration * motionCfg.rotationSpeed * 0.3);

            const collapseT = t - introCfg.vennEnd;

            const rotation = baseRotation + (collapseT * motionCfg.rotationSpeed * 0.15); // Even slower

            

            // Collapse to tiny overlap while growing in size

            const startDist = 0.08;

            const targetDist = 0.005;

            const currentDist = THREE.MathUtils.lerp(startDist, targetDist, eased);

            const scale = THREE.MathUtils.lerp(0.7, 0.85, eased); // Massive spheres!



            // Use same mapping as triangle phase

            const triangleMapping = [1, 0, 2];



        for (let i = 0; i < 3; i++) {

                const angleIndex = triangleMapping[i];

                const angle = triangleAngles[angleIndex] + rotation;

            const p = new THREE.Vector2(

                Math.cos(angle) * currentDist,

                    Math.sin(angle) * currentDist + centerY

            );

            spheres[i].position.set(p.x, p.y, -i * 0.002);

            spheres[i].rotation.z = 0;

            spheres[i].scale.set(scale, scale, scale);

            triMat.uniforms.points.value[i].copy(p);

        }

            blackHole.visible = true;

            blackHole.material.uniforms.pulseFactor.value = THREE.MathUtils.lerp(0.6, 0.85, eased);

            

            if (collapseProgress > 0.3 && !glitchStarted) {

                document.getElementById('quote').classList.add('glitch');

                glitchStarted = true;

            }

            

        } else if (phase === 'glitch' || phase === 'blackout' || phase === 'loomworks' || phase === 'celli') {

            // Hide spheres during ending sequence, keep last position

            const centerY = 0;

            const targetDist = 0.005;

            const scale = 0.85;

            

            const triangleAngles = [

                Math.PI / 2 + (2 * Math.PI / 3) * 0,

                Math.PI / 2 + (2 * Math.PI / 3) * 1,

                Math.PI / 2 + (2 * Math.PI / 3) * 2

            ];

            

            const slowRotation = t * 0.05;

            

            // Fade out spheres during glitch phase

            let sphereOpacity = 1.0;

            if (phase === 'glitch') {

                const glitchProgress = (t - introCfg.collapseEnd) / (introCfg.glitchEnd - introCfg.collapseEnd);

                sphereOpacity = THREE.MathUtils.lerp(1.0, 0, glitchProgress);

                if (glitchProgress > 0.25 && !quoteDespairShown) {

                    glitchSwapQuote(quoteStates.despair, { duration: 950, onComplete: () => quoteEl.classList.add('quote--loom') });

                    quoteDespairShown = true;

                }

            } else {

                sphereOpacity = 0;

            }

            

            // Use same mapping as triangle phase

            const triangleMapping = [1, 0, 2];

            

            for (let i = 0; i < 3; i++) {

                const angleIndex = triangleMapping[i];

                const angle = triangleAngles[angleIndex] + slowRotation;

                const p = new THREE.Vector2(

                    Math.cos(angle) * targetDist,

                    Math.sin(angle) * targetDist + centerY

                );

                spheres[i].position.set(p.x, p.y, -i * 0.002);

                spheres[i].rotation.z = 0;

                spheres[i].scale.set(scale, scale, scale);

                spheres[i].material.opacity = sphereOpacity;

            triMat.uniforms.points.value[i].copy(p);

        }



            blackHole.visible = phase === 'glitch';

            if (phase === 'glitch') {

                const glitchProgress = (t - introCfg.collapseEnd) / (introCfg.glitchEnd - introCfg.collapseEnd);

                blackHole.material.uniforms.pulseFactor.value = THREE.MathUtils.lerp(0.85, 0, glitchProgress);

            }

        }

    }



    // --- Responsive ---------------------------------------------------------

    function onResize(){

      renderer.setSize(window.innerWidth, window.innerHeight);

      composer.setSize(window.innerWidth, window.innerHeight);

      const aspect = window.innerWidth / window.innerHeight;

      triMat.uniforms.aspect.value = aspect;

      if (aspect > 1) { // Landscape

          camera.left = -aspect; camera.right = aspect; camera.top = 1; camera.bottom = -1;

          // Scale black hole to maintain circularity

          blackHole.scale.set(1, 1, 1);

      } else { // Portrait

          camera.left = -1; camera.right = 1; camera.top = 1 / aspect; camera.bottom = -1 / aspect;

          // Scale black hole to maintain circularity

          blackHole.scale.set(aspect, aspect, 1);

      }

      camera.updateProjectionMatrix();

      

      // Recalculate CELLI scale for responsive layout

      const oldScale = celliScale;

      calculateCelliScale();



      // Update voxel positions and scales based on new scale

      if (oldScale !== celliScale) {

          const scaleRatio = celliScale / oldScale;

          voxels.forEach((voxel) => {

              const data = voxel.userData;

              // Update positions with new scale

              data.targetX *= scaleRatio;

              data.targetY *= scaleRatio;

              data.baseScale = celliScale;



              // Update actual positions if settled

              if (data.settled) {

                  voxel.position.x = data.targetX;

                  voxel.position.y = data.targetY;

              }



              // Update scale

              voxel.scale.set(celliScale, celliScale, celliScale);

          });

      }



      if (bowActive) {

          moveBowToTarget(true);

      }

    }

    window.addEventListener('resize', onResize);

    onResize();



    // --- Animate (gated by Play) -------------------------------------------

    const clock = new THREE.Clock();

    let running = false, totalTime = 0;

    

    // Canvas for text particles

    const textCanvas = document.createElement('canvas');

    textCanvas.style.position = 'fixed';

    textCanvas.style.inset = '0';

    textCanvas.style.pointerEvents = 'none';

    textCanvas.style.zIndex = '5';

    document.body.appendChild(textCanvas);

    const textCtx = textCanvas.getContext('2d');

    

    function resizeTextCanvas() {

        textCanvas.width = window.innerWidth;

        textCanvas.height = window.innerHeight;

    }

    resizeTextCanvas();

    window.addEventListener('resize', resizeTextCanvas);

    

     // Gentle thunk sound for rolling (lighter than landing)

     function playRollingThunk(volume = 0.08, delay = 0) {

         if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

         const now = audioCtx.currentTime + delay;

         

         // Subtle rolling "tap" sound

         const osc = audioCtx.createOscillator();

         const gain = audioCtx.createGain();

         

         osc.type = 'sine';

         osc.frequency.setValueAtTime(100 + Math.random() * 20, now); // Slight variation

         osc.frequency.exponentialRampToValueAtTime(50, now + 0.05);

         

         gain.gain.setValueAtTime(volume, now);

         gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);

         

         osc.connect(gain);

         gain.connect(audioCtx.destination);

         osc.start(now);

         osc.stop(now + 0.15);

     }

     

     // Heavier thud for jumps and landings

     function playBounceThud(volume = 0.15, delay = 0) {

         if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

         const now = audioCtx.currentTime + delay;

         

         // Deep impact sound

         const osc = audioCtx.createOscillator();

         const gain = audioCtx.createGain();

         

         osc.type = 'sine';

         osc.frequency.setValueAtTime(60, now); // Deep thud

         osc.frequency.exponentialRampToValueAtTime(30, now + 0.15);

         

         gain.gain.setValueAtTime(volume, now);

         gain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);

         

         osc.connect(gain);

         gain.connect(audioCtx.destination);

         osc.start(now);

         osc.stop(now + 0.25);

     }

     

     // Hollow melodic chime for voxel landing - C pentatonic scale

     function playVoxelChime(delay = 0) {

         if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

         const now = audioCtx.currentTime + delay;

         

         // Pentatonic scale notes for melodic chimes (C, D, E, G, A)

         const pentatonicNotes = [523.25, 587.33, 659.25, 783.99, 880]; // C5, D5, E5, G5, A5

         const fundamentalFreq = pentatonicNotes[Math.floor(Math.random() * pentatonicNotes.length)];

         

         // Hollow sound: triangle wave with filtered overtones

         const osc1 = audioCtx.createOscillator();

         const osc2 = audioCtx.createOscillator();

         const osc3 = audioCtx.createOscillator();

         const filter = audioCtx.createBiquadFilter();

         const gain = audioCtx.createGain();

         

         osc1.type = 'triangle'; // Hollow fundamental

         osc1.frequency.setValueAtTime(fundamentalFreq, now);

         

         osc2.type = 'sine'; // Soft overtone

         osc2.frequency.setValueAtTime(fundamentalFreq * 3, now);

         

         osc3.type = 'sine'; // Gentle fifth

         osc3.frequency.setValueAtTime(fundamentalFreq * 1.5, now);

         

         // Band-pass filter for hollow character

         filter.type = 'bandpass';

         filter.frequency.setValueAtTime(fundamentalFreq * 2, now);

         filter.Q.setValueAtTime(2, now);

         

         // Gentle envelope

         gain.gain.setValueAtTime(0, now);

         gain.gain.linearRampToValueAtTime(0.03, now + 0.01);

         gain.gain.exponentialRampToValueAtTime(0.001, now + 1.2);

         

         osc1.connect(filter);

         osc2.connect(gain);

         osc3.connect(gain);

         filter.connect(gain);

         gain.connect(audioCtx.destination);

         

         osc1.start(now);

         osc2.start(now);

         osc3.start(now);

         osc1.stop(now + 1.2);

         osc2.stop(now + 1.2);

         osc3.stop(now + 1.2);

     }

    

    // Chiptune music system - simple arpeggio + drums

    let chiptuneBass = null;

    let chiptuneGain = null;

    let lastNoteTime = 0;

    let lastDrumTime = 0;

    let noteIndex = 0;

    let drumIndex = 0;

    let musicStarted = false;

    let reverbDelay = null;

    let reverbGain = null;

    let reverbFeedback = null;

    let glitchWhirOsc1 = null;

    let glitchWhirOsc2 = null;

    let glitchWhirOsc3 = null;

    let glitchWhirGain = null;

    let glitchWhirFilter = null;

    let glitchWhirStarted = false;

    

    function updateSynth(t) {

        // Start music during triangle phase

        if (!musicStarted && t > introCfg.bounceEnd) {

            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

            

            // Create reverb delay effect

            reverbDelay = audioCtx.createDelay(2.0);

            reverbDelay.delayTime.value = 0.25; // 250ms delay

            reverbGain = audioCtx.createGain();

            reverbGain.gain.value = 0.3; // Moderate reverb mix

            reverbFeedback = audioCtx.createGain();

            reverbFeedback.gain.value = 0.4; // Feedback for reverb tail

            

            // Wire up reverb: delay -> feedback -> delay (loop) + output

            reverbDelay.connect(reverbFeedback);

            reverbFeedback.connect(reverbDelay);

            reverbDelay.connect(reverbGain);

            reverbGain.connect(audioCtx.destination);

            

            musicStarted = true;

            lastNoteTime = t;

            lastDrumTime = t;

        }

        

        if (!musicStarted || !audioCtx) return;

        

        const now = audioCtx.currentTime;

        

        // Determine arpeggio and rhythm based on phase

        let arpeggio = [];

        let noteSpeed = 0.25;

        let drumSpeed = 0.5;

        let drumVolume = 0.12;

        let drumReverb = 0.2;

        let reverbMix = 0.3;

        let glitchLevel = 0;

        

        if (t < introCfg.triangleEnd) {

            // Calm, contemplative Am progression

            arpeggio = [220.00, 261.63, 329.63, 261.63]; // A3, C4, E4, C4

            noteSpeed = 0.5;

            drumSpeed = 1.2;

            drumVolume = 0.08;

            drumReverb = 0.25;

            reverbMix = 0.35;

        } else if (t < introCfg.normalEnd) {

            // Gentle progression with suspension

            arpeggio = [220.00, 246.94, 293.66, 329.63, 293.66, 246.94]; // A3, B3, D4, E4, D4, B3

            noteSpeed = 0.45;

            drumSpeed = 1.0;

            drumVolume = 0.1;

            drumReverb = 0.3;

            reverbMix = 0.4;

        } else if (t < introCfg.vennEnd) {

            // Subdued, introspective

            arpeggio = [196.00, 246.94, 293.66, 349.23, 293.66, 246.94]; // G3, B3, D4, F4, D4, B3

            noteSpeed = 0.4;

            drumSpeed = 0.9;

            drumVolume = 0.12;

            drumReverb = 0.4;

            reverbMix = 0.45;

        } else if (t < introCfg.collapseEnd) {

            // Building unease, drums more present

            arpeggio = [220.00, 277.18, 329.63, 392.00, 329.63, 277.18]; // A3, C#4, E4, G4, E4, C#4

            noteSpeed = 0.38;

            drumSpeed = 0.7;

            drumVolume = 0.16; // Drums becoming more prominent

            drumReverb = 0.6;

            reverbMix = 0.5;

            glitchLevel = 0.1;

        } else if (t < introCfg.glitchEnd) {

            // Dissonant breakdown, drums dominate

            const glitchProgress = (t - introCfg.collapseEnd) / (introCfg.glitchEnd - introCfg.collapseEnd);

            arpeggio = [233.08, 277.18, 369.99, 415.30]; // Diminished, unsettling

            noteSpeed = 0.35;

            drumSpeed = 0.55;

            drumVolume = THREE.MathUtils.lerp(0.18, 0.28, glitchProgress); // Drums take over

            drumReverb = THREE.MathUtils.lerp(0.6, 0.85, glitchProgress);

            reverbMix = THREE.MathUtils.lerp(0.5, 0.65, glitchProgress);

            glitchLevel = THREE.MathUtils.lerp(0.2, 0.8, glitchProgress);

        } else {

            return;

        }

        

        // Update reverb mix

        if (reverbGain) {

            reverbGain.gain.setTargetAtTime(reverbMix, now, 0.5);

        }

        

        // Play arpeggio notes

        if (t - lastNoteTime >= noteSpeed) {

            const freq = arpeggio[noteIndex % arpeggio.length];

            playChiptuneNote(freq, noteSpeed * 0.9, glitchLevel, reverbDelay);

            noteIndex++;

            lastNoteTime = t;

        }

        

        // Play drum beats

        if (t - lastDrumTime >= drumSpeed) {

            playChiptuneDrum(drumVolume, drumReverb, glitchLevel, reverbDelay);

            drumIndex++;

            lastDrumTime = t;

        }

        

        // Corrupted whir during glitch phase

        if (t >= introCfg.collapseEnd && t < introCfg.glitchEnd) {

            const glitchProgress = (t - introCfg.collapseEnd) / (introCfg.glitchEnd - introCfg.collapseEnd);

            

            if (!glitchWhirStarted) {

                // Start the harsh whirring synth

                glitchWhirOsc1 = audioCtx.createOscillator();

                glitchWhirOsc2 = audioCtx.createOscillator();

                glitchWhirOsc3 = audioCtx.createOscillator();

                glitchWhirGain = audioCtx.createGain();

                glitchWhirFilter = audioCtx.createBiquadFilter();

                

                // Triangle waves for harsh, mechanical sound

                glitchWhirOsc1.type = 'triangle';

                glitchWhirOsc2.type = 'triangle';

                glitchWhirOsc3.type = 'triangle';

                

                // Detuning for thickness

                glitchWhirOsc1.detune.value = -8;

                glitchWhirOsc2.detune.value = 0;

                glitchWhirOsc3.detune.value = 8;

                

                // Start at low frequency

                glitchWhirOsc1.frequency.setValueAtTime(220, now);

                glitchWhirOsc2.frequency.setValueAtTime(220, now);

                glitchWhirOsc3.frequency.setValueAtTime(220, now);

                

                // Resonant filter for harsh whir

                glitchWhirFilter.type = 'lowpass';

                glitchWhirFilter.frequency.setValueAtTime(400, now);

                glitchWhirFilter.Q.setValueAtTime(8, now);

                

                glitchWhirGain.gain.setValueAtTime(0, now);

                glitchWhirGain.gain.linearRampToValueAtTime(0.08, now + 0.5);

                

                glitchWhirOsc1.connect(glitchWhirFilter);

                glitchWhirOsc2.connect(glitchWhirFilter);

                glitchWhirOsc3.connect(glitchWhirFilter);

                glitchWhirFilter.connect(glitchWhirGain);

                glitchWhirGain.connect(audioCtx.destination);

                

                glitchWhirOsc1.start(now);

                glitchWhirOsc2.start(now);

                glitchWhirOsc3.start(now);

                

                glitchWhirStarted = true;

            }

            

            // Modulate frequency for failing sound

            if (glitchWhirOsc1) {

                const crackle = Math.sin(t * 100) * 20 * glitchProgress;

                const whir = Math.sin(t * 30) * 10;

                const baseFreq = THREE.MathUtils.lerp(220, 55, glitchProgress); // Pitch down as it fails

                

                glitchWhirOsc1.frequency.setTargetAtTime(baseFreq + crackle + whir, now, 0.02);

                glitchWhirOsc2.frequency.setTargetAtTime(baseFreq + crackle + whir * 1.1, now, 0.02);

                glitchWhirOsc3.frequency.setTargetAtTime(baseFreq + crackle + whir * 0.9, now, 0.02);

                

                // Filter sweep downward

                glitchWhirFilter.frequency.setTargetAtTime(THREE.MathUtils.lerp(400, 100, glitchProgress), now, 0.1);

                

                // Volume swell and fade

                const vroomPhase = Math.sin(t * 2) * 0.5 + 0.5;

                const fadeOut = 1 - glitchProgress * 0.7; // Fade out near end

                glitchWhirGain.gain.setTargetAtTime(0.08 * fadeOut * vroomPhase, now, 0.05);

            }

        } else if (glitchWhirStarted && glitchWhirOsc1) {

            // Stop the whir after glitch phase

            glitchWhirOsc1.stop(now + 0.5);

            glitchWhirOsc2.stop(now + 0.5);

            glitchWhirOsc3.stop(now + 0.5);

            glitchWhirOsc1 = null;

            glitchWhirOsc2 = null;

            glitchWhirOsc3 = null;

        }

    }

    

    // Chiptune note player - muted, musical synth

    function playChiptuneNote(freq, duration, glitchLevel = 0, reverbNode = null) {

        if (!audioCtx) return;

        const now = audioCtx.currentTime;

        

        const osc1 = audioCtx.createOscillator();

        const osc2 = audioCtx.createOscillator();

        const gain = audioCtx.createGain();

        const filter = audioCtx.createBiquadFilter();

        

        // Sine waves for muted, warm tone

        osc1.type = 'sine';

        osc2.type = 'sine';

        

        // Add subtle harmonic (5th) for richness

        const glitchWobble = glitchLevel > 0 ? (Math.random() - 0.5) * freq * glitchLevel * 0.2 : 0;

        osc1.frequency.setValueAtTime(freq + glitchWobble, now);

        osc2.frequency.setValueAtTime((freq * 1.5) + glitchWobble, now); // Perfect 5th

        

        // Muted low-pass filter

        filter.type = 'lowpass';

        filter.frequency.setValueAtTime(glitchLevel > 0.5 ? 600 : 1200, now);

        filter.Q.setValueAtTime(0.3, now);

        

        // Very soft, gentle envelope

        const baseVol = 0.045 * (1 - glitchLevel * 0.3);

        gain.gain.setValueAtTime(0, now);

        gain.gain.linearRampToValueAtTime(baseVol, now + 0.03);

        gain.gain.setValueAtTime(baseVol * 0.85, now + duration * 0.5);

        gain.gain.linearRampToValueAtTime(0, now + duration);

        

        osc1.connect(filter);

        osc2.connect(filter);

        filter.connect(gain);

        gain.connect(audioCtx.destination);

        

        // Connect to reverb if available

        if (reverbNode) {

            gain.connect(reverbNode);

        }

        

        osc1.start(now);

        osc2.start(now);

        osc1.stop(now + duration);

        osc2.stop(now + duration);

    }

    

    // Startup bass sound (Simple warm chord - NO REVERB to prevent oscillation)

    function playStartupBass() {

        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        const now = audioCtx.currentTime;

        

        // Master output - simple, clean

        const masterGain = audioCtx.createGain();

        masterGain.gain.value = 0.4;

        masterGain.connect(audioCtx.destination);

        

        // Simple warm chord - C major

        const chordNotes = [

            { freq: 130.81, vol: 0.10 },  // C3

            { freq: 164.81, vol: 0.08 },  // E3

            { freq: 196.00, vol: 0.07 },  // G3

            { freq: 65.41, vol: 0.09 },   // C2 (bass)

        ];

        

        chordNotes.forEach((note, i) => {

            const osc = audioCtx.createOscillator();

            const oscGain = audioCtx.createGain();

            

            osc.type = 'sine';

            osc.frequency.value = note.freq; // Fixed frequency, no modulation

            

            // Simple envelope

            const delay = i * 0.08;

            oscGain.gain.setValueAtTime(0, now + delay);

            oscGain.gain.linearRampToValueAtTime(note.vol, now + delay + 0.15);

            oscGain.gain.setValueAtTime(note.vol * 0.9, now + delay + 0.6);

            oscGain.gain.linearRampToValueAtTime(0, now + delay + 1.5);

            

            osc.connect(oscGain);

            oscGain.connect(masterGain);

            

            osc.start(now + delay);

            osc.stop(now + delay + 1.6);

        });

    }

    

    // Distorted startup bass sound - progressively more distorted per click

    function playStartupBassDistorted(clickCount = 1) {

        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        const now = audioCtx.currentTime;

        

        // Distortion increases with each click

        const distortionLevel = clickCount * 0.3; // 0.3, 0.6, 0.9

        

        // Master output with distortion

        const masterGain = audioCtx.createGain();

        masterGain.gain.value = 0.4;

        

        // Add waveshaper for distortion

        const distortion = audioCtx.createWaveShaper();

        const curve = new Float32Array(256);

        const deg = Math.PI / 180;

        const amount = distortionLevel * 100; // 30, 60, 90

        for (let i = 0; i < 256; i++) {

            const x = (i * 2) / 256 - 1;

            curve[i] = ((3 + amount) * x * 20 * deg) / (Math.PI + amount * Math.abs(x));

        }

        distortion.curve = curve;

        distortion.oversample = '4x';

        

        masterGain.connect(distortion);

        distortion.connect(audioCtx.destination);

        

        // Chord notes with detuning that increases per click

        const chordNotes = [

            { freq: 130.81, vol: 0.10 },  // C3

            { freq: 164.81, vol: 0.08 },  // E3

            { freq: 196.00, vol: 0.07 },  // G3

            { freq: 65.41, vol: 0.09 },   // C2 (bass)

        ];

        

        chordNotes.forEach((note, i) => {

            const osc = audioCtx.createOscillator();

            const oscGain = audioCtx.createGain();

            const filter = audioCtx.createBiquadFilter();

            

            osc.type = 'sawtooth'; // More harmonics for distortion

            

            // Add detuning/wobble based on click count

            const detune = (Math.random() - 0.5) * clickCount * 15;

            osc.frequency.setValueAtTime(note.freq + detune, now);

            

            // Add frequency wobble during playback

            osc.frequency.linearRampToValueAtTime(note.freq + detune * 1.5, now + 0.3);

            osc.frequency.linearRampToValueAtTime(note.freq + detune * 0.5, now + 1.0);

            

            // Filter gets more aggressive with each click

            filter.type = 'lowpass';

            filter.frequency.setValueAtTime(2000 - clickCount * 400, now);

            filter.Q.value = 1 + clickCount * 0.5;

            

            // Envelope

            const delay = i * 0.08;

            oscGain.gain.setValueAtTime(0, now + delay);

            oscGain.gain.linearRampToValueAtTime(note.vol * (1 + distortionLevel * 0.3), now + delay + 0.15);

            oscGain.gain.setValueAtTime(note.vol * 0.9, now + delay + 0.6);

            oscGain.gain.linearRampToValueAtTime(0, now + delay + 1.5);

            

            osc.connect(filter);

            filter.connect(oscGain);

            oscGain.connect(masterGain);

            

            osc.start(now + delay);

            osc.stop(now + delay + 1.6);

        });

        

        // Add noise for extra degradation on later clicks

        if (clickCount >= 2) {

            const noiseBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 1.5, audioCtx.sampleRate);

            const noiseData = noiseBuffer.getChannelData(0);

            for (let i = 0; i < noiseData.length; i++) {

                noiseData[i] = (Math.random() * 2 - 1) * 0.1 * (clickCount - 1);

            }

            const noiseSource = audioCtx.createBufferSource();

            const noiseGain = audioCtx.createGain();

            noiseSource.buffer = noiseBuffer;

            noiseGain.gain.setValueAtTime(0, now);

            noiseGain.gain.linearRampToValueAtTime(0.05 * clickCount, now + 0.2);

            noiseGain.gain.linearRampToValueAtTime(0, now + 1.4);

            noiseSource.connect(noiseGain);

            noiseGain.connect(masterGain);

            noiseSource.start(now);

            noiseSource.stop(now + 1.5);

        }

    }

    

    // Chiptune drum player

    function playChiptuneDrum(volume = 0.12, reverbAmount = 0.3, glitchLevel = 0, reverbNode = null) {

        if (!audioCtx) return;

        const now = audioCtx.currentTime;

        

        // Kick drum

        const osc = audioCtx.createOscillator();

        const gain = audioCtx.createGain();

        const reverbSend = audioCtx.createGain();

        

        osc.type = 'sine';

        const startFreq = glitchLevel > 0.5 ? 80 + Math.random() * 40 : 60;

        osc.frequency.setValueAtTime(startFreq, now);

        osc.frequency.exponentialRampToValueAtTime(30, now + 0.1);

        

        // Main drum volume (dominant)

        gain.gain.setValueAtTime(volume, now);

        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);

        

        // Reverb send amount

        reverbSend.gain.setValueAtTime(volume * reverbAmount, now);

        reverbSend.gain.exponentialRampToValueAtTime(0.001, now + 0.3); // Longer reverb tail

        

        osc.connect(gain);

        gain.connect(audioCtx.destination);

        

        // Send to reverb

        if (reverbNode) {

            osc.connect(reverbSend);

            reverbSend.connect(reverbNode);

        }

        

        osc.start(now);

        osc.stop(now + 0.3);

    }

    

    function frame(){

      if(!running) return;

      const dt = Math.min(clock.getDelta(), 0.033);

      totalTime += dt;

      updatePositions(totalTime);

      updateSynth(totalTime);

      blackHole.material.uniforms.time.value = totalTime;

      filmPass.uniforms.time.value += dt;

      composer.render();

      

      // Update and render text particles

      updateTextParticles(dt);

      textCtx.clearRect(0, 0, textCanvas.width, textCanvas.height);

      renderTextParticles(textCtx, camera);

      

      // Update voxels for CELLI animation

      updateVoxels(totalTime, dt);

      

      // Update floating voxels during burst

      updateFloatingVoxels(dt);

      

      // Update camera pan

      updateCameraPan();

      

      requestAnimationFrame(frame);

    }



    // --- Click interaction on spheres ----------------------------------------

    const raycaster = new THREE.Raycaster();

    const mouse = new THREE.Vector2();

    

    renderer.domElement.addEventListener('click', (event) => {

        if (!running) return;

        

        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;

        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        

        raycaster.setFromCamera(mouse, camera);

        const intersects = raycaster.intersectObjects(spheres);

        

        if (intersects.length > 0) {

            const hitSphere = intersects[0].object;

            const sphereIndex = spheres.indexOf(hitSphere);

            const hitPos = intersects[0].point;

            

            // Burst particles based on color

            let texts, color;

            if (sphereIndex === 0) { // Cyan - equations

                texts = equationTexts;

                color = '#00a8ff';

            } else if (sphereIndex === 1) { // Yellow - time

                texts = Array(8).fill(0).map(() => timeTexts());

                color = '#ffb62e';

            } else { // Magenta - manic

                texts = manicTexts;

                color = '#ff1e6e';

            }

            

            // Create burst of 5-8 particles

            const count = 5 + Math.floor(Math.random() * 4);

            for (let i = 0; i < count; i++) {

                const text = texts[Math.floor(Math.random() * texts.length)];

                createTextParticle(hitPos.x, hitPos.y, text, color, sphereIndex);

            }

        }

    });



    // --- Doorway input keyboard and click interaction ------------------------------------

    const promptContainer = document.querySelector('.prompt-container');

    const promptTextEl = document.getElementById('promptText');

    const promptCursorEl = document.getElementById('promptCursor');

    const hiddenInput = document.getElementById('hiddenInput');

    const promptEl = document.querySelector('.prompt');

    

    // Helper function to wrap each character with per-character shadow

    function updatePromptWithChars(text) {

        if (!promptTextEl) return;

        promptTextEl.innerHTML = '';

        for (let i = 0; i < text.length; i++) {

            const char = text[i];

            const span = document.createElement('span');

            span.className = 'char';

            span.setAttribute('data-char', char);

            span.textContent = char;

            promptTextEl.appendChild(span);

        }

    }

    

    // Click to trigger CELLI glitch (reveal T) and focus hidden input for mobile

    if (promptContainer) {

        function focusHiddenPromptInput() {

            if (!hiddenInput) return;



            hiddenInput.value = '';



            const focusOptions = { preventScroll: true };

            try {

                hiddenInput.focus(focusOptions);

            } catch (err) {

                hiddenInput.focus();

            }



            if (document.activeElement !== hiddenInput) {

                hiddenInput.focus();

            }

        }



        promptContainer.addEventListener('click', () => {

            if (!running || burstAnimStarted) return;

            if (!inputAttempted) {

                triggerCelliGlitch();

                inputAttempted = true;

            }



            if (hiddenInput) {

                focusHiddenPromptInput();

            }

        });

        

        function handlePromptBackspace() {

            if (!running || !doorwayOpened || burstAnimStarted) return false;

            if (inputText.length <= promptBaseText.length) return false;



            inputText = inputText.slice(0, -1);

            tEntered = false;



            updatePromptWithChars(inputText);

            promptCursorEl.textContent = '_';

            if (promptEl) {

                promptEl.setAttribute('data-text', inputText + '_');

            }



            if (hiddenInput) {

                hiddenInput.value = '';

            }



            if (burstTimeout) {

                clearTimeout(burstTimeout);

                burstTimeout = null;

            }



            // Restore one letter with fritz effect

            restoreOneLetter();

            return true;

        }



        // Keyboard input to trigger final sequence (desktop)

        window.addEventListener('keydown', (e) => {

            if (!running || !doorwayOpened || !inputAttempted) return;



            if (e.key === 'Backspace') {

                e.preventDefault();

                handlePromptBackspace();

                return;

            }



            // T input - starts burst sequence

            if (!tEntered && e.key.toLowerCase() === 't') {

                e.preventDefault();

                tEntered = true;

                inputText += 'T';



                // Update display

                updatePromptWithChars(inputText);

                promptCursorEl.textContent = '_';

                if (promptEl) {

                    promptEl.setAttribute('data-text', inputText + '_');

                }



                if (burstTimeout) {

                    clearTimeout(burstTimeout);

                }

                burstTimeout = setTimeout(() => {

                    triggerBurstToStars();

                }, 500);

                return;

            }

            

            // E, N, D inputs - only after STAR is fully cleared and yellow transformation complete

            if (inputText === '=' && allYellowTransformed) {

                const key = e.key.toUpperCase();

                

                console.log('END input detected:', key, 'endSequence:', endSequence, 'allYellowTransformed:', allYellowTransformed);

                

                // E must be first

                if (endSequence === '' && key === 'E') {

                    e.preventDefault();

                    endSequence = 'E';

                    transformToMagentaRed();

                    updatePromptWithChars('=E');

                    if (promptEl) promptEl.setAttribute('data-text', '=E_');

                    console.log('Transformed to MAGENTA');

                    return;

                }

                

                // N must be second (after E)

                if (endSequence === 'E' && key === 'N') {

                    e.preventDefault();

                    endSequence = 'EN';

                    transformToCyanBlue();

                    updatePromptWithChars('=EN');

                    if (promptEl) promptEl.setAttribute('data-text', '=EN_');

                    console.log('Transformed to CYAN');

                    return;

                }

                

                // D must be third (after EN)

                if (endSequence === 'EN' && key === 'D') {

                    e.preventDefault();

                    endSequence = 'END';

                    transformToGreenAndSquare();

                    updatePromptWithChars('=END');

                    if (promptEl) promptEl.setAttribute('data-text', '=END_');

                    console.log('Transformed to GREEN, starting snap animation');

                    return;

                }

            } else if (inputText === '=') {

                console.log('Input is =, but allYellowTransformed is:', allYellowTransformed);

            }

        });

        

        // Mobile input handler

        if (hiddenInput) {

            hiddenInput.addEventListener('beforeinput', (e) => {

                if (!running || !doorwayOpened || !inputAttempted) return;

                if (e.inputType === 'deleteContentBackward') {

                    e.preventDefault();

                    handlePromptBackspace();

                }

            });



            hiddenInput.addEventListener('input', (e) => {

                if (!running || !doorwayOpened || !inputAttempted) return;



                const value = (e.target.value || '').toUpperCase();



                if (value === '') {

                    handlePromptBackspace();

                    return;

                }



                // T input for burst sequence

                if (!tEntered && value.includes('T')) {

                    e.preventDefault();

                    tEntered = true;

                    inputText += 'T';



                    updatePromptWithChars(inputText);

                    promptCursorEl.textContent = '_';

                    if (promptEl) {

                        promptEl.setAttribute('data-text', inputText + '_');

                    }



                    e.target.value = '';



                    if (burstTimeout) {

                        clearTimeout(burstTimeout);

                    }

                    burstTimeout = setTimeout(() => {

                        triggerBurstToStars();

                    }, 500);



                    hiddenInput.blur();

                    return;

                }

                

                // E, N, D inputs after STAR cleared and yellow transformation

                if (inputText === '=' && allYellowTransformed) {

                    // E must be first

                    if (endSequence === '' && value.includes('E')) {

                        e.preventDefault();

                        endSequence = 'E';

                        transformToMagentaRed();

                        updatePromptWithChars('=E');

                        if (promptEl) promptEl.setAttribute('data-text', '=E_');

                        e.target.value = '';

                        return;

                    }

                    

                    // N must be second

                    if (endSequence === 'E' && value.includes('N')) {

                        e.preventDefault();

                        endSequence = 'EN';

                        transformToCyanBlue();

                        updatePromptWithChars('=EN');

                        if (promptEl) promptEl.setAttribute('data-text', '=EN_');

                        e.target.value = '';

                        return;

                    }

                    

                    // D must be third

                    if (endSequence === 'EN' && value.includes('D')) {

                        e.preventDefault();

                        endSequence = 'END';

                        transformToGreenAndSquare();

                        updatePromptWithChars('=END');

                        if (promptEl) promptEl.setAttribute('data-text', '=END_');

                        e.target.value = '';

                        return;

                    }

                }

                

                // Clear any other input

                e.target.value = '';

            });

        }

    }

    

    // Break apart and rise to sky

    let breakApartStarted = false;

    let riseStartTime = 0;

    

    function triggerBurstToStars() {

        if (burstAnimStarted) return;

        burstAnimStarted = true;

        burstTimeout = null;

        breakApartStarted = true;

        riseStartTime = Date.now();



        const skipBtn = document.getElementById('skipBtn');

        if (skipBtn) {

            skipBtn.classList.remove('illuminating');

        }



        // Increase afterimage effect for dramatic trails

        afterimagePass.uniforms.damp.value = 0.88;

        

        // Hide prompt but keep it for reference

        if (promptEl) {

            promptEl.style.transition = 'opacity 0.5s ease';

            promptEl.style.opacity = '0';

        }

        

        // Get only the T-shape voxels (the ones that weren't glitched)

        const activeVoxels = voxels.filter(v => !v.userData.glitched && v.visible);

        

        // Give each voxel velocity to shoot upward dramatically

        activeVoxels.forEach((voxel, idx) => {

            setTimeout(() => {

                const angle = Math.random() * Math.PI * 2;

                const spreadH = 0.008 + Math.random() * 0.015; // More horizontal spread

                

                voxel.userData.floating = true;

                voxel.userData.vx = Math.cos(angle) * spreadH;

                voxel.userData.vy = 0.08 + Math.random() * 0.05; // MUCH faster upward - shooting motion

                voxel.userData.vz = -0.05 - Math.random() * 0.08; // Move away from camera (into distance)

                voxel.userData.pulsatePhase = Math.random() * Math.PI * 2;

                voxel.userData.pulsateSpeed = 3 + Math.random() * 3;

                voxel.userData.floatStartTime = Date.now();

                voxel.userData.initialScale = voxel.userData.baseScale || 1.0;

            }, idx * 15); // Faster stagger

        });

        

        // Start camera pan after voxels have shot into distance

        setTimeout(() => {

            startCameraPan();

        }, 4000); // Slightly longer to see them recede

    }

    

    // Update floating voxels

    function updateFloatingVoxels(dt) {

        if (!breakApartStarted) return;

        

        const now = Date.now();

        const totalElapsed = (now - riseStartTime) / 1000;

        

        voxels.forEach(voxel => {

            if (!voxel.userData.floating) return;

            

            const data = voxel.userData;

            const age = (now - data.floatStartTime) / 1000;

            

            // Move with velocity - shooting into distance

            voxel.position.x += data.vx;

            voxel.position.y += data.vy;

            voxel.position.z += data.vz;

            

            // Very slow drag to maintain shooting motion

            data.vx *= 0.985;

            data.vy *= 0.985;

            data.vz *= 0.985;

            

            // Scale down dramatically as they move away (perspective)

            // Based on Z distance from camera

            const distanceZ = Math.abs(voxel.position.z + 0.5); // Initial Z was around -0.5

            const perspectiveScale = 1 / (1 + distanceZ * 3); // Shrink rapidly with distance

            

            // Pulsate on top of perspective scaling

            data.pulsatePhase += data.pulsateSpeed * dt;

            const pulse = 0.85 + Math.sin(data.pulsatePhase) * 0.15;

            const baseScale = data.initialScale || 1.0;

            const finalScale = baseScale * pulse * perspectiveScale;

            voxel.scale.set(finalScale, finalScale, finalScale);

            

            // Brighten voxels during shooting (they're stars now)

            voxel.material.color.setRGB(1, 1, 1); // Pure white

            

            // Pulsate material opacity with distance fade

            const opacityPulse = 0.8 + Math.sin(data.pulsatePhase * 0.7) * 0.2;

            const distanceFade = Math.max(0.3, 1 - distanceZ * 0.4); // Fade as they get far

            voxel.material.opacity = Math.min(1.0, opacityPulse * distanceFade);

            data.edges.material.opacity = Math.min(0.8, opacityPulse * 0.8 * distanceFade);

            

            // Fade out during camera pan

            if (cameraPanStarted) {

                const panProgress = (now - panStartTime) / panDuration;

                const fadeStart = 0.5;

                if (panProgress > fadeStart) {

                    const fadeProgress = (panProgress - fadeStart) / (1 - fadeStart);

                    voxel.material.opacity *= (1 - fadeProgress * 0.8);

                    data.edges.material.opacity *= (1 - fadeProgress * 0.8);

                }

            }

        });

    }

    

    // Pan camera down to reveal gradient

    let cameraPanStarted = false;

    let panStartTime = 0;

    const panDuration = 5000; // 5 seconds for dramatic reveal

    

    function startCameraPan() {

        cameraPanStarted = true;

        panStartTime = Date.now();

    }

    

    function updateCameraPan() {

        if (!cameraPanStarted) return;

        

        const elapsed = Date.now() - panStartTime;

        const progress = Math.min(1, elapsed / panDuration);

        

        // Smooth ease-in-out for dramatic pan

        const eased = progress < 0.5 ? 

            2 * progress * progress : 

            1 - Math.pow(-2 * progress + 2, 2) / 2;

        

        // Gradually reduce afterimage effect during pan to fade trails

        afterimagePass.uniforms.damp.value = THREE.MathUtils.lerp(0.88, 0.96, progress);

        

        // Pan down much further to reveal gradient

        camera.position.y = THREE.MathUtils.lerp(0, -5, eased);

        camera.lookAt(0, camera.position.y - 2, 0); // Look ahead of camera position

        

        // Fade doorway, prompt, and vignette quickly

        const doorway = document.getElementById('doorway');

        if (doorway) {

            doorway.style.opacity = Math.max(0, 1 - progress * 2);

        }

        

        // Fade out vignette

        const vignette = document.querySelector('.vignette');

        if (vignette) {

            vignette.style.transition = 'opacity 1s ease';

            vignette.style.opacity = String(Math.max(0, 1 - progress * 1.5));

        }

        

        // Add blue gradient background early in the pan

        if (progress > 0.2 && !document.getElementById('nightSky')) {

            // Set app background to black initially for smooth transition

            const app = document.getElementById('app');

            if (app) {

                app.style.background = '#000';

            }

            

            // Immediately hide vignette and scanlines when gradient appears

            const vignetteEl = document.querySelector('.vignette');

            if (vignetteEl) {

                vignetteEl.style.display = 'none';

            }

            

            // Hide scanlines overlay

            if (app && app.classList.contains('scanlines')) {

                app.classList.add('fade-scanlines');

            }

            

            const nightSky = document.createElement('div');

            nightSky.id = 'nightSky';

            nightSky.style.position = 'fixed';

            nightSky.style.inset = '0';

            nightSky.style.background = 'linear-gradient(to bottom, #0d1b2a 0%, #1a237e 20%, #283593 40%, #3949ab 60%, #5e92f3 80%, #90caf9 100%)';

            nightSky.style.zIndex = '0';

            nightSky.style.opacity = '0';

            nightSky.style.pointerEvents = 'none';

            

            // Insert at beginning of body

            if (document.body.firstChild) {

                document.body.insertBefore(nightSky, document.body.firstChild);

            } else {

                document.body.appendChild(nightSky);

            }

            

            // Fade in gradient

            setTimeout(() => {

                nightSky.style.transition = 'opacity 3s ease';

                nightSky.style.opacity = '1';

                

                // Fade out black background

                if (app) {

                    app.style.transition = 'background 3s ease';

                    app.style.background = 'transparent';

                }

            }, 100);

        }

        

        // Fade out 3D scene elements as gradient appears

        if (progress > 0.3) {

            const fadeAmount = Math.min(1, (progress - 0.3) / 0.7); // Fade from 30% to 100%

            

            // Fade renderer canvas

            renderer.domElement.style.transition = 'opacity 0.5s ease';

            renderer.domElement.style.opacity = String(1 - fadeAmount * 0.8); // Keep slight visibility

        }

        

        // Keep stars visible over the gradient longer

        if (progress > 0.7) {

            const starFade = (progress - 0.7) / 0.3;

            textCanvas.style.opacity = String(1 - starFade);

        }

    }

    

    // Render star particles

    function renderStars() {

        if (starParticles.length === 0) return;

        

        const now = Date.now();

        

        // Update and render each star

        for (let i = starParticles.length - 1; i >= 0; i--) {

            const star = starParticles[i];

            

            // Update position based on velocity

            if (star.vx !== undefined) {

                star.x += star.vx;

                star.y += star.vy;

                star.z += star.vz;

                

                // Very slow drag to keep stars moving

                star.vx *= 0.995;

                star.vy *= 0.995;

                star.vz *= 0.995;

            }

            

            // Calculate age and fade

            const age = (now - star.birthTime) / 1000; // in seconds

            const fadeDuration = 8; // fade over 8 seconds (much slower)

            const fadeProgress = Math.min(1, age / fadeDuration);

            

            // Dim brightness over time - keep them bright longer

            star.brightness = 1 - fadeProgress * 0.5; // Keep 50% minimum

            

            // Update twinkle

            star.twinkle += star.twinkleSpeed * 0.016;

            const twinkleBrightness = 0.8 + Math.sin(star.twinkle) * 0.2;

            const finalBrightness = star.brightness * twinkleBrightness;

            

            // Keep stars visible much longer - only remove when very faint

            if (finalBrightness < 0.05) {

                starParticles.splice(i, 1);

                continue;

            }

            

            // Project to screen space

            const vector = new THREE.Vector3(star.x, star.y, star.z);

            vector.project(camera);

            

            // Check if behind camera

            if (vector.z > 1) continue;

            

            const x = (vector.x + 1) / 2 * window.innerWidth;

            const y = (-vector.y + 1) / 2 * window.innerHeight;

            

            // Size based on distance (z-depth)

            const depthScale = Math.max(0.5, 1 - vector.z * 0.5);

            const renderSize = star.size * window.innerWidth * 0.01 * depthScale;

            

            // Draw voxel as square with slight glow

            const voxelSize = renderSize * 1.5;

            const glowSize = voxelSize * 1.5;

            

            // Outer glow

            const gradient = textCtx.createRadialGradient(x, y, 0, x, y, glowSize);

            gradient.addColorStop(0, `rgba(255, 255, 255, ${finalBrightness * 0.8})`);

            gradient.addColorStop(0.6, `rgba(255, 255, 255, ${finalBrightness * 0.3})`);

            gradient.addColorStop(1, `rgba(255, 255, 255, 0)`);

            textCtx.fillStyle = gradient;

            textCtx.beginPath();

            textCtx.arc(x, y, glowSize, 0, Math.PI * 2);

            textCtx.fill();

            

            // Core voxel - square shape

            textCtx.fillStyle = `rgba(255, 255, 255, ${Math.min(1, finalBrightness * 1.1)})`;

            textCtx.fillRect(x - voxelSize/2, y - voxelSize/2, voxelSize, voxelSize);

            

            // Subtle border for voxel definition

            if (finalBrightness > 0.5) {

                textCtx.strokeStyle = `rgba(255, 255, 255, ${finalBrightness * 0.6})`;

                textCtx.lineWidth = 0.5;

                textCtx.strokeRect(x - voxelSize/2, y - voxelSize/2, voxelSize, voxelSize);

            }

        }

    }



    // --- Play button wiring -------------------------------------------------

    const playOverlay = document.getElementById('play');

    const playBtn = document.getElementById('playBtn');

    const skipBtn = document.getElementById('skipBtn');

    

    playBtn.addEventListener('click', ()=>{

      running = true; clock.getDelta();

      playOverlay.classList.add('hidden');

      skipBtn.classList.remove('hidden'); // Show skip button

      clearToast();

      frame();

    });

    

    // --- Skip button logic ---------------------------------------------------

    skipBtn.addEventListener('click', () => {

      if (!running) return;



      // Jump to CELLI phase

      totalTime = introCfg.celliEnd - 6.0; // Start 6 seconds before celli ends (during trickle/chime)

      

      // Hide all prior elements

      quoteEl.style.visibility = 'hidden';

      quoteEl.style.opacity = '0';

      loomworksEl.style.display = 'none';

      triMesh.visible = false;

      blackHole.visible = false;

      spheres.forEach(s => s.visible = false);

      

      // Setup CELLI

      if (!celliStarted) {

        celliStarted = true;

        celliStartTime = totalTime;

      }

      

      // Don't hide skip button - it will transform into a bow later

      

      // Play startup bass note

      setTimeout(() => {

        playStartupBass();

      }, 500);

    });



    skipBtn.addEventListener('keydown', (event) => {

      if (event.key === 'Enter' || event.key === ' ') {

        event.preventDefault();

        skipBtn.click();

      }

    });
    
        })(); // End of initEnd3Scene IIFE
      } // End of initEnd3Scene function
      
      // Start polling for THREE.js
      waitForTHREE();
    }); // End of DOMContentLoaded

  </script>

</body>

</html>